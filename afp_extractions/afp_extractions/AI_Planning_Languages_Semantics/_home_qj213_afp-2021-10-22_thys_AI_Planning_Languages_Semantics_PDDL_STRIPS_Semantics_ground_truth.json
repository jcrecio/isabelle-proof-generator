{"file_name": "/home/qj213/afp-2021-10-22/thys/AI_Planning_Languages_Semantics/PDDL_STRIPS_Semantics.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/AI_Planning_Languages_Semantics", "problem_names": ["lemma index_by_eq_Some_eq[simp]:\n  assumes \"distinct (map f l)\"\n  shows \"index_by f l n = Some x \\<longleftrightarrow> (x\\<in>set l \\<and> f x = n)\"", "lemma index_by_eq_SomeD:\n  shows \"index_by f l n = Some x \\<Longrightarrow> (x\\<in>set l \\<and> f x = n)\"", "lemma lookup_zip_idx_eq:\n  assumes \"length params = length args\"\n  assumes \"i<length args\"\n  assumes \"distinct params\"\n  assumes \"k = params ! i\"\n  shows \"map_of (zip params args) k = Some (args ! i)\"", "lemma rtrancl_image_idem[simp]: \"R\\<^sup>* `` R\\<^sup>* `` s = R\\<^sup>* `` s\"", "lemma \"wm_basic M \\<Longrightarrow> close_world M = close_neg (M \\<union> {Atom (Eq a a) | a. True})\"", "lemma\n    close_world_extensive: \"M \\<subseteq> close_world M\" and\n    close_world_idem[simp]: \"close_world (close_world M) = close_world M\"", "lemma in_close_world_conv:\n    \"\\<phi> \\<in> close_world M \\<longleftrightarrow> (\n        \\<phi>\\<in>M\n      \\<or> (\\<exists>p as. \\<phi>=\\<^bold>\\<not>(Atom (predAtm p as)) \\<and> Atom (predAtm p as)\\<notin>M)\n      \\<or> (\\<exists>a. \\<phi>=Atom (Eq a a))\n      \\<or> (\\<exists>a b. \\<phi>=\\<^bold>\\<not>(Atom (Eq a b)) \\<and> a\\<noteq>b)\n    )\"", "lemma valuation_aux_1:\n    fixes M :: world_model and \\<phi> :: \"object atom formula\"\n    defines \"C \\<equiv> close_world M\"\n    assumes A: \"\\<forall>\\<phi>\\<in>C. \\<A> \\<Turnstile> \\<phi>\"\n    shows \"\\<A> = valuation M\"", "lemma valuation_aux_2:\n    assumes \"wm_basic M\"\n    shows \"(\\<forall>G\\<in>close_world M. valuation M \\<Turnstile> G)\"", "lemma val_imp_close_world: \"valuation M \\<Turnstile> \\<phi> \\<Longrightarrow> M \\<^sup>c\\<TTurnstile>\\<^sub>= \\<phi>\"", "lemma close_world_imp_val:\n    \"wm_basic M \\<Longrightarrow> M \\<^sup>c\\<TTurnstile>\\<^sub>= \\<phi> \\<Longrightarrow> valuation M \\<Turnstile> \\<phi>\"", "theorem valuation_iff_close_world:\n    assumes \"wm_basic M\"\n    shows \"valuation M \\<Turnstile> \\<phi> \\<longleftrightarrow> M \\<^sup>c\\<TTurnstile>\\<^sub>= \\<phi>\"", "lemma aux1: \"\\<lbrakk>wm_basic M; is_STRIPS_fmla \\<phi>; valuation M \\<Turnstile> \\<phi>; \\<forall>G\\<in>M. \\<A> \\<Turnstile> G\\<rbrakk> \\<Longrightarrow> \\<A> \\<Turnstile> \\<phi>\"", "lemma aux2: \"\\<lbrakk>wm_basic M; is_STRIPS_fmla \\<phi>; \\<forall>\\<A>. (\\<forall>G\\<in>M. \\<A> \\<Turnstile> G) \\<longrightarrow> \\<A> \\<Turnstile> \\<phi>\\<rbrakk> \\<Longrightarrow> valuation M \\<Turnstile> \\<phi>\"", "lemma valuation_iff_STRIPS:\n  assumes \"wm_basic M\"\n  assumes \"is_STRIPS_fmla \\<phi>\"\n  shows \"valuation M \\<Turnstile> \\<phi> \\<longleftrightarrow> M \\<TTurnstile> \\<phi>\"", "theorem proper_STRIPS_generalization:\n  \"\\<lbrakk>wm_basic M; is_STRIPS_fmla \\<phi>\\<rbrakk> \\<Longrightarrow> M \\<^sup>c\\<TTurnstile>\\<^sub>= \\<phi> \\<longleftrightarrow> M \\<TTurnstile> \\<phi>\"", "lemma ground_action_path_in_paper:\n    \"ground_action_path M [] M' \\<longleftrightarrow> (M = M')\"\n    \"ground_action_path M (\\<alpha>#\\<alpha>s) M' \\<longleftrightarrow> M \\<^sup>c\\<TTurnstile>\\<^sub>= precondition \\<alpha>\n    \\<and> (ground_action_path (apply_effect (effect \\<alpha>) M) \\<alpha>s M')\"", "lemma ty_term_mono: \"varT \\<subseteq>\\<^sub>m varT' \\<Longrightarrow> objT \\<subseteq>\\<^sub>m objT' \\<Longrightarrow>\n  ty_term varT objT \\<subseteq>\\<^sub>m ty_term varT' objT'\"", "lemma \"wf_fmla \\<phi> = (\\<forall>a\\<in>atoms \\<phi>. wf_atom a)\"", "lemma wf_fmla_atom_alt: \"wf_fmla_atom \\<phi> \\<longleftrightarrow> is_predAtom \\<phi> \\<and> wf_fmla \\<phi>\"", "lemma objT_alt: \"objT = map_of (consts D @ objects P)\"", "lemma wf_effect_inst_alt: \"wf_effect_inst eff = wf_effect objT eff\"", "lemma is_obj_of_type_alt: \"is_obj_of_type = is_of_type objT\"", "lemma \"valid_plan \\<pi>s \\<equiv> \\<exists>M'. plan_action_path I \\<pi>s M' \\<and> M' \\<^sup>c\\<TTurnstile>\\<^sub>= (goal P)\"", "lemma (in ast_domain) of_type_refl[simp, intro!]: \"of_type T T\"", "lemma (in ast_domain) of_type_trans[trans]:\n    \"of_type T1 T2 \\<Longrightarrow> of_type T2 T3 \\<Longrightarrow> of_type T1 T3\"", "lemma is_of_type_map_ofE:\n    assumes \"is_of_type (map_of params) x T\"\n    obtains i xT where \"i<length params\" \"params!i = (x,xT)\" \"of_type xT T\"", "lemma wf_atom_mono:\n    assumes SS: \"tys \\<subseteq>\\<^sub>m tys'\"\n    assumes WF: \"wf_atom tys a\"\n    shows \"wf_atom tys' a\"", "lemma wf_fmla_atom_mono:\n    assumes SS: \"tys \\<subseteq>\\<^sub>m tys'\"\n    assumes WF: \"wf_fmla_atom tys a\"\n    shows \"wf_fmla_atom tys' a\"", "lemma constT_ss_objT: \"constT \\<subseteq>\\<^sub>m objT\"", "lemma wf_atom_constT_imp_objT: \"wf_atom (ty_term Q constT) a \\<Longrightarrow> wf_atom (ty_term Q objT) a\"", "lemma wf_fmla_atom_constT_imp_objT: \"wf_fmla_atom (ty_term Q constT) a \\<Longrightarrow> wf_fmla_atom (ty_term Q objT) a\"", "lemma is_of_type_var_conv: \"is_of_type (ty_term Q objT) (term.VAR x) T  \\<longleftrightarrow> is_of_type Q x T\"", "lemma is_of_type_const_conv: \"is_of_type (ty_term Q objT) (term.CONST x) T  \\<longleftrightarrow> is_of_type objT x T\"", "lemma INST': \"is_of_type (ty_term Q objT) x T \\<Longrightarrow> is_of_type objT (subst_term f x) T\"", "lemma wf_inst_eq_aux: \"Q x = Some T \\<Longrightarrow> objT (f x) \\<noteq> None\"", "lemma wf_inst_eq_aux': \"ty_term Q objT x = Some T \\<Longrightarrow> objT (subst_term f x) \\<noteq> None\"", "lemma wf_inst_atom:\n      assumes \"wf_atom (ty_term Q constT) a\"\n      shows \"wf_atom objT (map_atom (subst_term f) a)\"", "lemma wf_inst_formula_atom:\n      assumes \"wf_fmla_atom (ty_term Q constT) a\"\n      shows \"wf_fmla_atom objT ((map_formula o map_atom o subst_term) f a)\"", "lemma wf_inst_effect:\n      assumes \"wf_effect (ty_term Q constT) \\<phi>\"\n      shows \"wf_effect objT ((map_ast_effect o subst_term) f \\<phi>)\"", "lemma wf_inst_formula:\n      assumes \"wf_fmla (ty_term Q constT) \\<phi>\"\n      shows \"wf_fmla objT ((map_formula o map_atom o subst_term) f \\<phi>)\"", "theorem wf_instantiate_action_schema:\n    assumes \"action_params_match a args\"\n    assumes \"wf_action_schema a\"\n    shows \"wf_ground_action (instantiate_action_schema a args)\"", "lemma plan_action_path_Nil[simp]: \"plan_action_path M [] M' \\<longleftrightarrow> M'=M\"", "lemma plan_action_path_Cons[simp]:\n    \"plan_action_path M (\\<pi>#\\<pi>s) M' \\<longleftrightarrow>\n      plan_action_enabled \\<pi> M\n    \\<and> plan_action_path (execute_plan_action \\<pi> M) \\<pi>s M'\"", "lemma wf_I: \"wf_world_model I\"", "lemma wf_apply_effect:\n    assumes \"wf_effect objT e\"\n    assumes \"wf_world_model s\"\n    shows \"wf_world_model (apply_effect e s)\"", "theorem wf_execute:\n    assumes \"plan_action_enabled \\<pi> s\"\n    assumes \"wf_world_model s\"\n    shows \"wf_world_model (execute_plan_action \\<pi> s)\"", "theorem wf_execute_compact_notation:\n    \"plan_action_enabled \\<pi> s \\<Longrightarrow> wf_world_model s\n    \\<Longrightarrow> wf_world_model (execute_plan_action \\<pi> s)\""], "translations": [["", "lemma index_by_eq_Some_eq[simp]:\n  assumes \"distinct (map f l)\"\n  shows \"index_by f l n = Some x \\<longleftrightarrow> (x\\<in>set l \\<and> f x = n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (index_by f l n = Some x) = (x \\<in> set l \\<and> f x = n)", "unfolding index_by_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (map_of (map (\\<lambda>x. (f x, x)) l) n = Some x) =\n    (x \\<in> set l \\<and> f x = n)", "using assms"], ["proof (prove)\nusing this:\n  distinct (map f l)\n\ngoal (1 subgoal):\n 1. (map_of (map (\\<lambda>x. (f x, x)) l) n = Some x) =\n    (x \\<in> set l \\<and> f x = n)", "by (auto simp: o_def)"], ["", "lemma index_by_eq_SomeD:\n  shows \"index_by f l n = Some x \\<Longrightarrow> (x\\<in>set l \\<and> f x = n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. index_by f l n = Some x \\<Longrightarrow> x \\<in> set l \\<and> f x = n", "unfolding index_by_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (map (\\<lambda>x. (f x, x)) l) n = Some x \\<Longrightarrow>\n    x \\<in> set l \\<and> f x = n", "by (auto dest: map_of_SomeD)"], ["", "lemma lookup_zip_idx_eq:\n  assumes \"length params = length args\"\n  assumes \"i<length args\"\n  assumes \"distinct params\"\n  assumes \"k = params ! i\"\n  shows \"map_of (zip params args) k = Some (args ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (zip params args) k = Some (args ! i)", "using assms"], ["proof (prove)\nusing this:\n  length params = length args\n  i < length args\n  distinct params\n  k = params ! i\n\ngoal (1 subgoal):\n 1. map_of (zip params args) k = Some (args ! i)", "by (auto simp: in_set_conv_nth)"], ["", "lemma rtrancl_image_idem[simp]: \"R\\<^sup>* `` R\\<^sup>* `` s = R\\<^sup>* `` s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R\\<^sup>* `` R\\<^sup>* `` s = R\\<^sup>* `` s", "by (metis relcomp_Image rtrancl_idemp_self_comp)"], ["", "subsection \\<open>Abstract Syntax\\<close>"], ["", "subsubsection \\<open>Generic Entities\\<close>"], ["", "type_synonym name = string"], ["", "datatype predicate = Pred (name: name)"], ["", "text \\<open>Some of the AST entities are defined over a polymorphic \\<open>'val\\<close> type,\n  which gets either instantiated by variables (for domains)\n  or objects (for problems).\n\\<close>"], ["", "text \\<open>An atom is either a predicate with arguments, or an equality statement.\\<close>"], ["", "datatype 'ent atom = predAtm (predicate: predicate) (arguments: \"'ent list\")\n                     | Eq (lhs: 'ent) (rhs: 'ent)"], ["", "text \\<open>A type is a list of primitive type names.\n  To model a primitive type, we use a singleton list.\\<close>"], ["", "datatype type = Either (primitives: \"name list\")"], ["", "text \\<open>An effect contains a list of values to be added, and a list of values\n  to be removed.\\<close>"], ["", "datatype 'ent ast_effect = Effect (adds: \"('ent atom formula) list\") (dels: \"('ent atom formula) list\")"], ["", "text \\<open>Variables are identified by their names.\\<close>"], ["", "datatype variable = varname: Var name"], ["", "text \\<open>Objects and constants are identified by their names\\<close>"], ["", "datatype object = name: Obj name"], ["", "datatype \"term\" = VAR variable | CONST object"], ["", "hide_const (open) VAR CONST \\<comment> \\<open>Refer to constructors by qualified names only\\<close>"], ["", "subsubsection \\<open>Domains\\<close>"], ["", "text \\<open>An action schema has a name, a typed parameter list, a precondition,\n  and an effect.\\<close>"], ["", "datatype ast_action_schema = Action_Schema\n  (name: name)\n  (parameters: \"(variable \\<times> type) list\")\n  (precondition: \"term atom formula\")\n  (effect: \"term ast_effect\")"], ["", "text \\<open>A predicate declaration contains the predicate's name and its\n  argument types.\\<close>"], ["", "datatype predicate_decl = PredDecl\n  (pred: predicate)\n  (argTs: \"type list\")"], ["", "text \\<open>A domain contains the declarations of primitive types, predicates,\n  and action schemas.\\<close>"], ["", "datatype ast_domain = Domain\n  (types: \"(name \\<times> name) list\") \\<comment> \\<open> \\<open>(type, supertype)\\<close> declarations. \\<close>\n  (predicates: \"predicate_decl list\")\n  (\"consts\": \"(object \\<times> type) list\")\n  (actions: \"ast_action_schema list\")"], ["", "subsubsection \\<open>Problems\\<close>"], ["", "text \\<open>A fact is a predicate applied to objects.\\<close>"], ["", "type_synonym fact = \"predicate \\<times> object list\""], ["", "text \\<open>A problem consists of a domain, a list of objects,\n  a description of the initial state, and a description of the goal state. \\<close>"], ["", "datatype ast_problem = Problem\n  (domain: ast_domain)\n  (objects: \"(object \\<times> type) list\")\n  (init: \"object atom formula list\")\n  (goal: \"object atom formula\")"], ["", "subsubsection \\<open>Plans\\<close>"], ["", "datatype plan_action = PAction\n  (name: name)\n  (arguments: \"object list\")"], ["", "type_synonym plan = \"plan_action list\""], ["", "subsubsection \\<open>Ground Actions\\<close>"], ["", "text \\<open>The following datatype represents an action scheme that has been\n  instantiated by replacing the arguments with concrete objects,\n  also called ground action.\n\\<close>"], ["", "datatype ground_action = Ground_Action\n  (precondition: \"(object atom) formula\")\n  (effect: \"object ast_effect\")"], ["", "subsection \\<open>Closed-World Assumption, Equality, and Negation\\<close>"], ["", "text \\<open>Discriminator for atomic predicate formulas.\\<close>"], ["", "fun is_predAtom where\n    \"is_predAtom (Atom (predAtm _ _)) = True\" | \"is_predAtom _ = False\""], ["", "text \\<open>The world model is a set of (atomic) formulas\\<close>"], ["", "type_synonym world_model = \"object atom formula set\""], ["", "text \\<open>It is basic, if it only contains atoms\\<close>"], ["", "definition \"wm_basic M \\<equiv> \\<forall>a\\<in>M. is_predAtom a\""], ["", "text \\<open>A valuation extracted from the atoms of the world model\\<close>"], ["", "definition valuation :: \"world_model \\<Rightarrow> object atom valuation\"\n    where \"valuation M \\<equiv> \\<lambda>predAtm p xs \\<Rightarrow> Atom (predAtm p xs) \\<in> M | Eq a b \\<Rightarrow> a=b\""], ["", "text \\<open>Augment a world model by adding negated versions of all atoms\n    not contained in it, as well as interpretations of equality.\\<close>"], ["", "definition close_world :: \"world_model \\<Rightarrow> world_model\" where \"close_world M =\n    M \\<union> {\\<^bold>\\<not>(Atom (predAtm p as)) | p as. Atom (predAtm p as) \\<notin> M}\n    \\<union> {Atom (Eq a a) | a. True} \\<union> {\\<^bold>\\<not>(Atom (Eq a b)) | a b. a\\<noteq>b}\""], ["", "definition \"close_neg M \\<equiv> M \\<union> {\\<^bold>\\<not>(Atom a) | a. Atom a \\<notin> M}\""], ["", "lemma \"wm_basic M \\<Longrightarrow> close_world M = close_neg (M \\<union> {Atom (Eq a a) | a. True})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wm_basic M \\<Longrightarrow>\n    close_world M = close_neg (M \\<union> {Atom (Eq a a) |a. True})", "unfolding close_world_def close_neg_def wm_basic_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>M. is_predAtom a \\<Longrightarrow>\n    M \\<union>\n    {\\<^bold>\\<not> (Atom (predAtm p as)) |p as.\n     Atom (predAtm p as) \\<notin> M} \\<union>\n    {Atom (Eq a a) |a. True} \\<union>\n    {\\<^bold>\\<not> (Atom (Eq a b)) |a b. a \\<noteq> b} =\n    M \\<union> {Atom (Eq a a) |a. True} \\<union>\n    {\\<^bold>\\<not> (Atom a) |a.\n     Atom a \\<notin> M \\<union> {Atom (Eq a a) |a. True}}", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a\\<in>M. is_predAtom a \\<Longrightarrow>\n    M \\<union>\n    {\\<^bold>\\<not> (Atom (predAtm p as)) |p as.\n     Atom (predAtm p as) \\<notin> M} \\<union>\n    {uu_. \\<exists>a. uu_ = Atom (Eq a a)} \\<union>\n    {\\<^bold>\\<not> (Atom (Eq a b)) |a b. a \\<noteq> b} =\n    M \\<union> {uu_. \\<exists>a. uu_ = Atom (Eq a a)} \\<union>\n    {\\<^bold>\\<not> (Atom a) |a.\n     Atom a \\<notin> M \\<and> (\\<forall>aa. a \\<noteq> Eq aa aa)}", "apply (auto 0 3)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>\\<forall>x\\<in>M. is_predAtom x;\n        \\<^bold>\\<not> (Atom a) \\<notin> M;\n        \\<forall>aa b. a = Eq aa b \\<longrightarrow> aa = b;\n        Atom a \\<notin> M; \\<forall>aa. a \\<noteq> Eq aa aa\\<rbrakk>\n       \\<Longrightarrow> \\<exists>p as.\n                            a = predAtm p as \\<and>\n                            Atom (predAtm p as) \\<notin> M", "by (metis atom.exhaust)"], ["", "abbreviation cw_entailment (infix \"\\<^sup>c\\<TTurnstile>\\<^sub>=\" 53) where\n    \"M \\<^sup>c\\<TTurnstile>\\<^sub>= \\<phi> \\<equiv> close_world M \\<TTurnstile> \\<phi>\""], ["", "lemma\n    close_world_extensive: \"M \\<subseteq> close_world M\" and\n    close_world_idem[simp]: \"close_world (close_world M) = close_world M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M \\<subseteq> close_world M &&&\n    close_world (close_world M) = close_world M", "by (auto simp: close_world_def)"], ["", "lemma in_close_world_conv:\n    \"\\<phi> \\<in> close_world M \\<longleftrightarrow> (\n        \\<phi>\\<in>M\n      \\<or> (\\<exists>p as. \\<phi>=\\<^bold>\\<not>(Atom (predAtm p as)) \\<and> Atom (predAtm p as)\\<notin>M)\n      \\<or> (\\<exists>a. \\<phi>=Atom (Eq a a))\n      \\<or> (\\<exists>a b. \\<phi>=\\<^bold>\\<not>(Atom (Eq a b)) \\<and> a\\<noteq>b)\n    )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<phi> \\<in> close_world M) =\n    (\\<phi> \\<in> M \\<or>\n     (\\<exists>p as.\n         \\<phi> = \\<^bold>\\<not> (Atom (predAtm p as)) \\<and>\n         Atom (predAtm p as) \\<notin> M) \\<or>\n     (\\<exists>a. \\<phi> = Atom (Eq a a)) \\<or>\n     (\\<exists>a b.\n         \\<phi> = \\<^bold>\\<not> (Atom (Eq a b)) \\<and> a \\<noteq> b))", "by (auto simp: close_world_def)"], ["", "lemma valuation_aux_1:\n    fixes M :: world_model and \\<phi> :: \"object atom formula\"\n    defines \"C \\<equiv> close_world M\"\n    assumes A: \"\\<forall>\\<phi>\\<in>C. \\<A> \\<Turnstile> \\<phi>\"\n    shows \"\\<A> = valuation M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<A> = valuation M", "using A"], ["proof (prove)\nusing this:\n  \\<forall>\\<phi>\\<in>C. \\<A> \\<Turnstile> \\<phi>\n\ngoal (1 subgoal):\n 1. \\<A> = valuation M", "unfolding C_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<phi>\\<in>close_world M. \\<A> \\<Turnstile> \\<phi>\n\ngoal (1 subgoal):\n 1. \\<A> = valuation M", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<phi>\\<in>close_world M.\n       \\<A> \\<Turnstile> \\<phi> \\<Longrightarrow>\n    \\<A> = valuation M", "apply (auto simp: in_close_world_conv valuation_def Ball_def intro!: ext split: atom.split)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x11 x12.\n       \\<lbrakk>\\<forall>x.\n                   (x \\<in> M \\<longrightarrow> \\<A> \\<Turnstile> x) \\<and>\n                   ((\\<exists>p as.\n                        x = \\<^bold>\\<not> (Atom (predAtm p as)) \\<and>\n                        Atom (predAtm p as) \\<notin> M) \\<longrightarrow>\n                    \\<A> \\<Turnstile> x) \\<and>\n                   ((\\<exists>a. x = Atom (Eq a a)) \\<longrightarrow>\n                    \\<A> \\<Turnstile> x) \\<and>\n                   ((\\<exists>a b.\n                        x = \\<^bold>\\<not> (Atom (Eq a b)) \\<and>\n                        a \\<noteq> b) \\<longrightarrow>\n                    \\<A> \\<Turnstile> x);\n        \\<A> (predAtm x11 x12)\\<rbrakk>\n       \\<Longrightarrow> Atom (predAtm x11 x12) \\<in> M\n 2. \\<And>x21 x22.\n       \\<lbrakk>\\<forall>x.\n                   (x \\<in> M \\<longrightarrow> \\<A> \\<Turnstile> x) \\<and>\n                   ((\\<exists>p as.\n                        x = \\<^bold>\\<not> (Atom (predAtm p as)) \\<and>\n                        Atom (predAtm p as) \\<notin> M) \\<longrightarrow>\n                    \\<A> \\<Turnstile> x) \\<and>\n                   ((\\<exists>a. x = Atom (Eq a a)) \\<longrightarrow>\n                    \\<A> \\<Turnstile> x) \\<and>\n                   ((\\<exists>a b.\n                        x = \\<^bold>\\<not> (Atom (Eq a b)) \\<and>\n                        a \\<noteq> b) \\<longrightarrow>\n                    \\<A> \\<Turnstile> x);\n        \\<A> (Eq x21 x22)\\<rbrakk>\n       \\<Longrightarrow> x21 = x22\n 3. \\<And>x.\n       \\<lbrakk>\\<forall>x.\n                   (x \\<in> M \\<longrightarrow> \\<A> \\<Turnstile> x) \\<and>\n                   ((\\<exists>p as.\n                        x = \\<^bold>\\<not> (Atom (predAtm p as)) \\<and>\n                        Atom (predAtm p as) \\<notin> M) \\<longrightarrow>\n                    \\<A> \\<Turnstile> x) \\<and>\n                   ((\\<exists>a. x = Atom (Eq a a)) \\<longrightarrow>\n                    \\<A> \\<Turnstile> x) \\<and>\n                   ((\\<exists>a b.\n                        x = \\<^bold>\\<not> (Atom (Eq a b)) \\<and>\n                        a \\<noteq> b) \\<longrightarrow>\n                    \\<A> \\<Turnstile> x);\n        \\<forall>x11 x12.\n           x = predAtm x11 x12 \\<longrightarrow>\n           Atom (predAtm x11 x12) \\<in> M;\n        \\<forall>x21 x22.\n           x = Eq x21 x22 \\<longrightarrow> x21 = x22\\<rbrakk>\n       \\<Longrightarrow> \\<A> x", "apply (metis formula_semantics.simps(1) formula_semantics.simps(3))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x21 x22.\n       \\<lbrakk>\\<forall>x.\n                   (x \\<in> M \\<longrightarrow> \\<A> \\<Turnstile> x) \\<and>\n                   ((\\<exists>p as.\n                        x = \\<^bold>\\<not> (Atom (predAtm p as)) \\<and>\n                        Atom (predAtm p as) \\<notin> M) \\<longrightarrow>\n                    \\<A> \\<Turnstile> x) \\<and>\n                   ((\\<exists>a. x = Atom (Eq a a)) \\<longrightarrow>\n                    \\<A> \\<Turnstile> x) \\<and>\n                   ((\\<exists>a b.\n                        x = \\<^bold>\\<not> (Atom (Eq a b)) \\<and>\n                        a \\<noteq> b) \\<longrightarrow>\n                    \\<A> \\<Turnstile> x);\n        \\<A> (Eq x21 x22)\\<rbrakk>\n       \\<Longrightarrow> x21 = x22\n 2. \\<And>x.\n       \\<lbrakk>\\<forall>x.\n                   (x \\<in> M \\<longrightarrow> \\<A> \\<Turnstile> x) \\<and>\n                   ((\\<exists>p as.\n                        x = \\<^bold>\\<not> (Atom (predAtm p as)) \\<and>\n                        Atom (predAtm p as) \\<notin> M) \\<longrightarrow>\n                    \\<A> \\<Turnstile> x) \\<and>\n                   ((\\<exists>a. x = Atom (Eq a a)) \\<longrightarrow>\n                    \\<A> \\<Turnstile> x) \\<and>\n                   ((\\<exists>a b.\n                        x = \\<^bold>\\<not> (Atom (Eq a b)) \\<and>\n                        a \\<noteq> b) \\<longrightarrow>\n                    \\<A> \\<Turnstile> x);\n        \\<forall>x11 x12.\n           x = predAtm x11 x12 \\<longrightarrow>\n           Atom (predAtm x11 x12) \\<in> M;\n        \\<forall>x21 x22.\n           x = Eq x21 x22 \\<longrightarrow> x21 = x22\\<rbrakk>\n       \\<Longrightarrow> \\<A> x", "apply (metis formula_semantics.simps(1) formula_semantics.simps(3))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<forall>x.\n                   (x \\<in> M \\<longrightarrow> \\<A> \\<Turnstile> x) \\<and>\n                   ((\\<exists>p as.\n                        x = \\<^bold>\\<not> (Atom (predAtm p as)) \\<and>\n                        Atom (predAtm p as) \\<notin> M) \\<longrightarrow>\n                    \\<A> \\<Turnstile> x) \\<and>\n                   ((\\<exists>a. x = Atom (Eq a a)) \\<longrightarrow>\n                    \\<A> \\<Turnstile> x) \\<and>\n                   ((\\<exists>a b.\n                        x = \\<^bold>\\<not> (Atom (Eq a b)) \\<and>\n                        a \\<noteq> b) \\<longrightarrow>\n                    \\<A> \\<Turnstile> x);\n        \\<forall>x11 x12.\n           x = predAtm x11 x12 \\<longrightarrow>\n           Atom (predAtm x11 x12) \\<in> M;\n        \\<forall>x21 x22.\n           x = Eq x21 x22 \\<longrightarrow> x21 = x22\\<rbrakk>\n       \\<Longrightarrow> \\<A> x", "by (metis atom.collapse(2) formula_semantics.simps(1) is_predAtm_def)"], ["", "lemma valuation_aux_2:\n    assumes \"wm_basic M\"\n    shows \"(\\<forall>G\\<in>close_world M. valuation M \\<Turnstile> G)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>G\\<in>close_world M. valuation M \\<Turnstile> G", "using assms"], ["proof (prove)\nusing this:\n  wm_basic M\n\ngoal (1 subgoal):\n 1. \\<forall>G\\<in>close_world M. valuation M \\<Turnstile> G", "unfolding wm_basic_def"], ["proof (prove)\nusing this:\n  \\<forall>a\\<in>M. is_predAtom a\n\ngoal (1 subgoal):\n 1. \\<forall>G\\<in>close_world M. valuation M \\<Turnstile> G", "by (force simp: in_close_world_conv valuation_def elim: is_predAtom.elims)"], ["", "lemma val_imp_close_world: \"valuation M \\<Turnstile> \\<phi> \\<Longrightarrow> M \\<^sup>c\\<TTurnstile>\\<^sub>= \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valuation M \\<Turnstile> \\<phi> \\<Longrightarrow>\n    M \\<^sup>c\\<TTurnstile>\\<^sub>= \\<phi>", "unfolding entailment_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. valuation M \\<Turnstile> \\<phi> \\<Longrightarrow>\n    \\<forall>\\<A>.\n       (\\<forall>G\\<in>close_world M. \\<A> \\<Turnstile> G) \\<longrightarrow>\n       \\<A> \\<Turnstile> \\<phi>", "using valuation_aux_1"], ["proof (prove)\nusing this:\n  \\<forall>\\<phi>\\<in>close_world ?M.\n     ?\\<A> \\<Turnstile> \\<phi> \\<Longrightarrow>\n  ?\\<A> = valuation ?M\n\ngoal (1 subgoal):\n 1. valuation M \\<Turnstile> \\<phi> \\<Longrightarrow>\n    \\<forall>\\<A>.\n       (\\<forall>G\\<in>close_world M. \\<A> \\<Turnstile> G) \\<longrightarrow>\n       \\<A> \\<Turnstile> \\<phi>", "by blast"], ["", "lemma close_world_imp_val:\n    \"wm_basic M \\<Longrightarrow> M \\<^sup>c\\<TTurnstile>\\<^sub>= \\<phi> \\<Longrightarrow> valuation M \\<Turnstile> \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wm_basic M; M \\<^sup>c\\<TTurnstile>\\<^sub>= \\<phi>\\<rbrakk>\n    \\<Longrightarrow> valuation M \\<Turnstile> \\<phi>", "unfolding entailment_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wm_basic M;\n     \\<forall>\\<A>.\n        (\\<forall>G\\<in>close_world M.\n            \\<A> \\<Turnstile> G) \\<longrightarrow>\n        \\<A> \\<Turnstile> \\<phi>\\<rbrakk>\n    \\<Longrightarrow> valuation M \\<Turnstile> \\<phi>", "using valuation_aux_2"], ["proof (prove)\nusing this:\n  wm_basic ?M \\<Longrightarrow>\n  \\<forall>G\\<in>close_world ?M. valuation ?M \\<Turnstile> G\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wm_basic M;\n     \\<forall>\\<A>.\n        (\\<forall>G\\<in>close_world M.\n            \\<A> \\<Turnstile> G) \\<longrightarrow>\n        \\<A> \\<Turnstile> \\<phi>\\<rbrakk>\n    \\<Longrightarrow> valuation M \\<Turnstile> \\<phi>", "by blast"], ["", "text \\<open>Main theorem of this section:\n    If a world model \\<open>M\\<close> contains only atoms, its induced valuation\n    satisfies a formula \\<open>\\<phi>\\<close> if and only if the closure of \\<open>M\\<close> entails \\<open>\\<phi>\\<close>.\n\n    Note that there are no syntactic restrictions on \\<open>\\<phi>\\<close>,\n    in particular, \\<open>\\<phi>\\<close> may contain negation.\n  \\<close>"], ["", "theorem valuation_iff_close_world:\n    assumes \"wm_basic M\"\n    shows \"valuation M \\<Turnstile> \\<phi> \\<longleftrightarrow> M \\<^sup>c\\<TTurnstile>\\<^sub>= \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valuation M \\<Turnstile> \\<phi> = M \\<^sup>c\\<TTurnstile>\\<^sub>= \\<phi>", "using assms val_imp_close_world close_world_imp_val"], ["proof (prove)\nusing this:\n  wm_basic M\n  valuation ?M \\<Turnstile> ?\\<phi> \\<Longrightarrow>\n  ?M \\<^sup>c\\<TTurnstile>\\<^sub>= ?\\<phi>\n  \\<lbrakk>wm_basic ?M; ?M \\<^sup>c\\<TTurnstile>\\<^sub>= ?\\<phi>\\<rbrakk>\n  \\<Longrightarrow> valuation ?M \\<Turnstile> ?\\<phi>\n\ngoal (1 subgoal):\n 1. valuation M \\<Turnstile> \\<phi> = M \\<^sup>c\\<TTurnstile>\\<^sub>= \\<phi>", "by blast"], ["", "subsubsection \\<open>Proper Generalization\\<close>"], ["", "text \\<open>Adding negation and equality is a proper generalization of the\n  case without negation and equality\\<close>"], ["", "fun is_STRIPS_fmla :: \"'ent atom formula \\<Rightarrow> bool\" where\n  \"is_STRIPS_fmla (Atom (predAtm _ _)) \\<longleftrightarrow> True\"\n| \"is_STRIPS_fmla (\\<bottom>) \\<longleftrightarrow> True\"\n| \"is_STRIPS_fmla (\\<phi>\\<^sub>1 \\<^bold>\\<and> \\<phi>\\<^sub>2) \\<longleftrightarrow> is_STRIPS_fmla \\<phi>\\<^sub>1 \\<and> is_STRIPS_fmla \\<phi>\\<^sub>2\"\n| \"is_STRIPS_fmla (\\<phi>\\<^sub>1 \\<^bold>\\<or> \\<phi>\\<^sub>2) \\<longleftrightarrow> is_STRIPS_fmla \\<phi>\\<^sub>1 \\<and> is_STRIPS_fmla \\<phi>\\<^sub>2\"\n| \"is_STRIPS_fmla (\\<^bold>\\<not>\\<bottom>) \\<longleftrightarrow> True\"\n| \"is_STRIPS_fmla _ \\<longleftrightarrow> False\""], ["", "lemma aux1: \"\\<lbrakk>wm_basic M; is_STRIPS_fmla \\<phi>; valuation M \\<Turnstile> \\<phi>; \\<forall>G\\<in>M. \\<A> \\<Turnstile> G\\<rbrakk> \\<Longrightarrow> \\<A> \\<Turnstile> \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wm_basic M; is_STRIPS_fmla \\<phi>;\n     valuation M \\<Turnstile> \\<phi>;\n     \\<forall>G\\<in>M. \\<A> \\<Turnstile> G\\<rbrakk>\n    \\<Longrightarrow> \\<A> \\<Turnstile> \\<phi>", "apply(induction \\<phi> rule: is_STRIPS_fmla.induct)"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>uu_ uv_.\n       \\<lbrakk>wm_basic M; is_STRIPS_fmla (Atom (predAtm uu_ uv_));\n        valuation M \\<Turnstile> Atom (predAtm uu_ uv_);\n        Ball M ((\\<Turnstile>) \\<A>)\\<rbrakk>\n       \\<Longrightarrow> \\<A> \\<Turnstile> Atom (predAtm uu_ uv_)\n 2. \\<lbrakk>wm_basic M; is_STRIPS_fmla \\<bottom>;\n     valuation M \\<Turnstile> \\<bottom>;\n     Ball M ((\\<Turnstile>) \\<A>)\\<rbrakk>\n    \\<Longrightarrow> \\<A> \\<Turnstile> \\<bottom>\n 3. \\<And>\\<phi>\\<^sub>1 \\<phi>\\<^sub>2.\n       \\<lbrakk>\\<lbrakk>wm_basic M; is_STRIPS_fmla \\<phi>\\<^sub>1;\n                 valuation M \\<Turnstile> \\<phi>\\<^sub>1;\n                 Ball M ((\\<Turnstile>) \\<A>)\\<rbrakk>\n                \\<Longrightarrow> \\<A> \\<Turnstile> \\<phi>\\<^sub>1;\n        \\<lbrakk>wm_basic M; is_STRIPS_fmla \\<phi>\\<^sub>2;\n         valuation M \\<Turnstile> \\<phi>\\<^sub>2;\n         Ball M ((\\<Turnstile>) \\<A>)\\<rbrakk>\n        \\<Longrightarrow> \\<A> \\<Turnstile> \\<phi>\\<^sub>2;\n        wm_basic M;\n        is_STRIPS_fmla (\\<phi>\\<^sub>1 \\<^bold>\\<and> \\<phi>\\<^sub>2);\n        valuation M \\<Turnstile>\n        \\<phi>\\<^sub>1 \\<^bold>\\<and> \\<phi>\\<^sub>2;\n        Ball M ((\\<Turnstile>) \\<A>)\\<rbrakk>\n       \\<Longrightarrow> \\<A> \\<Turnstile>\n                         \\<phi>\\<^sub>1 \\<^bold>\\<and> \\<phi>\\<^sub>2\n 4. \\<And>\\<phi>\\<^sub>1 \\<phi>\\<^sub>2.\n       \\<lbrakk>\\<lbrakk>wm_basic M; is_STRIPS_fmla \\<phi>\\<^sub>1;\n                 valuation M \\<Turnstile> \\<phi>\\<^sub>1;\n                 Ball M ((\\<Turnstile>) \\<A>)\\<rbrakk>\n                \\<Longrightarrow> \\<A> \\<Turnstile> \\<phi>\\<^sub>1;\n        \\<lbrakk>wm_basic M; is_STRIPS_fmla \\<phi>\\<^sub>2;\n         valuation M \\<Turnstile> \\<phi>\\<^sub>2;\n         Ball M ((\\<Turnstile>) \\<A>)\\<rbrakk>\n        \\<Longrightarrow> \\<A> \\<Turnstile> \\<phi>\\<^sub>2;\n        wm_basic M;\n        is_STRIPS_fmla (\\<phi>\\<^sub>1 \\<^bold>\\<or> \\<phi>\\<^sub>2);\n        valuation M \\<Turnstile>\n        \\<phi>\\<^sub>1 \\<^bold>\\<or> \\<phi>\\<^sub>2;\n        Ball M ((\\<Turnstile>) \\<A>)\\<rbrakk>\n       \\<Longrightarrow> \\<A> \\<Turnstile>\n                         \\<phi>\\<^sub>1 \\<^bold>\\<or> \\<phi>\\<^sub>2\n 5. \\<lbrakk>wm_basic M; is_STRIPS_fmla (\\<^bold>\\<not> \\<bottom>);\n     valuation M \\<Turnstile> \\<^bold>\\<not> \\<bottom>;\n     Ball M ((\\<Turnstile>) \\<A>)\\<rbrakk>\n    \\<Longrightarrow> \\<A> \\<Turnstile> \\<^bold>\\<not> \\<bottom>\n 6. \\<And>va vb.\n       \\<lbrakk>wm_basic M; is_STRIPS_fmla (Atom (Eq va vb));\n        valuation M \\<Turnstile> Atom (Eq va vb);\n        Ball M ((\\<Turnstile>) \\<A>)\\<rbrakk>\n       \\<Longrightarrow> \\<A> \\<Turnstile> Atom (Eq va vb)\n 7. \\<And>va.\n       \\<lbrakk>wm_basic M; is_STRIPS_fmla (\\<^bold>\\<not> (Atom va));\n        valuation M \\<Turnstile> \\<^bold>\\<not> (Atom va);\n        Ball M ((\\<Turnstile>) \\<A>)\\<rbrakk>\n       \\<Longrightarrow> \\<A> \\<Turnstile> \\<^bold>\\<not> (Atom va)\n 8. \\<And>va.\n       \\<lbrakk>wm_basic M;\n        is_STRIPS_fmla (\\<^bold>\\<not> (\\<^bold>\\<not> va));\n        valuation M \\<Turnstile> \\<^bold>\\<not> (\\<^bold>\\<not> va);\n        Ball M ((\\<Turnstile>) \\<A>)\\<rbrakk>\n       \\<Longrightarrow> \\<A> \\<Turnstile>\n                         \\<^bold>\\<not> (\\<^bold>\\<not> va)\n 9. \\<And>va vb.\n       \\<lbrakk>wm_basic M;\n        is_STRIPS_fmla (\\<^bold>\\<not> (va \\<^bold>\\<and> vb));\n        valuation M \\<Turnstile> \\<^bold>\\<not> (va \\<^bold>\\<and> vb);\n        Ball M ((\\<Turnstile>) \\<A>)\\<rbrakk>\n       \\<Longrightarrow> \\<A> \\<Turnstile>\n                         \\<^bold>\\<not> (va \\<^bold>\\<and> vb)\n 10. \\<And>va vb.\n        \\<lbrakk>wm_basic M;\n         is_STRIPS_fmla (\\<^bold>\\<not> (va \\<^bold>\\<or> vb));\n         valuation M \\<Turnstile> \\<^bold>\\<not> (va \\<^bold>\\<or> vb);\n         Ball M ((\\<Turnstile>) \\<A>)\\<rbrakk>\n        \\<Longrightarrow> \\<A> \\<Turnstile>\n                          \\<^bold>\\<not> (va \\<^bold>\\<or> vb)\nA total of 12 subgoals...", "by (auto simp: valuation_def)"], ["", "lemma aux2: \"\\<lbrakk>wm_basic M; is_STRIPS_fmla \\<phi>; \\<forall>\\<A>. (\\<forall>G\\<in>M. \\<A> \\<Turnstile> G) \\<longrightarrow> \\<A> \\<Turnstile> \\<phi>\\<rbrakk> \\<Longrightarrow> valuation M \\<Turnstile> \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wm_basic M; is_STRIPS_fmla \\<phi>;\n     \\<forall>\\<A>.\n        (\\<forall>G\\<in>M. \\<A> \\<Turnstile> G) \\<longrightarrow>\n        \\<A> \\<Turnstile> \\<phi>\\<rbrakk>\n    \\<Longrightarrow> valuation M \\<Turnstile> \\<phi>", "apply(induction \\<phi> rule: is_STRIPS_fmla.induct)"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>uu_ uv_.\n       \\<lbrakk>wm_basic M; is_STRIPS_fmla (Atom (predAtm uu_ uv_));\n        \\<forall>\\<A>.\n           Ball M ((\\<Turnstile>) \\<A>) \\<longrightarrow>\n           \\<A> \\<Turnstile> Atom (predAtm uu_ uv_)\\<rbrakk>\n       \\<Longrightarrow> valuation M \\<Turnstile> Atom (predAtm uu_ uv_)\n 2. \\<lbrakk>wm_basic M; is_STRIPS_fmla \\<bottom>;\n     \\<forall>\\<A>.\n        Ball M ((\\<Turnstile>) \\<A>) \\<longrightarrow>\n        \\<A> \\<Turnstile> \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> valuation M \\<Turnstile> \\<bottom>\n 3. \\<And>\\<phi>\\<^sub>1 \\<phi>\\<^sub>2.\n       \\<lbrakk>\\<lbrakk>wm_basic M; is_STRIPS_fmla \\<phi>\\<^sub>1;\n                 \\<forall>\\<A>.\n                    Ball M ((\\<Turnstile>) \\<A>) \\<longrightarrow>\n                    \\<A> \\<Turnstile> \\<phi>\\<^sub>1\\<rbrakk>\n                \\<Longrightarrow> valuation M \\<Turnstile> \\<phi>\\<^sub>1;\n        \\<lbrakk>wm_basic M; is_STRIPS_fmla \\<phi>\\<^sub>2;\n         \\<forall>\\<A>.\n            Ball M ((\\<Turnstile>) \\<A>) \\<longrightarrow>\n            \\<A> \\<Turnstile> \\<phi>\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> valuation M \\<Turnstile> \\<phi>\\<^sub>2;\n        wm_basic M;\n        is_STRIPS_fmla (\\<phi>\\<^sub>1 \\<^bold>\\<and> \\<phi>\\<^sub>2);\n        \\<forall>\\<A>.\n           Ball M ((\\<Turnstile>) \\<A>) \\<longrightarrow>\n           \\<A> \\<Turnstile>\n           \\<phi>\\<^sub>1 \\<^bold>\\<and> \\<phi>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> valuation M \\<Turnstile>\n                         \\<phi>\\<^sub>1 \\<^bold>\\<and> \\<phi>\\<^sub>2\n 4. \\<And>\\<phi>\\<^sub>1 \\<phi>\\<^sub>2.\n       \\<lbrakk>\\<lbrakk>wm_basic M; is_STRIPS_fmla \\<phi>\\<^sub>1;\n                 \\<forall>\\<A>.\n                    Ball M ((\\<Turnstile>) \\<A>) \\<longrightarrow>\n                    \\<A> \\<Turnstile> \\<phi>\\<^sub>1\\<rbrakk>\n                \\<Longrightarrow> valuation M \\<Turnstile> \\<phi>\\<^sub>1;\n        \\<lbrakk>wm_basic M; is_STRIPS_fmla \\<phi>\\<^sub>2;\n         \\<forall>\\<A>.\n            Ball M ((\\<Turnstile>) \\<A>) \\<longrightarrow>\n            \\<A> \\<Turnstile> \\<phi>\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> valuation M \\<Turnstile> \\<phi>\\<^sub>2;\n        wm_basic M;\n        is_STRIPS_fmla (\\<phi>\\<^sub>1 \\<^bold>\\<or> \\<phi>\\<^sub>2);\n        \\<forall>\\<A>.\n           Ball M ((\\<Turnstile>) \\<A>) \\<longrightarrow>\n           \\<A> \\<Turnstile>\n           \\<phi>\\<^sub>1 \\<^bold>\\<or> \\<phi>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> valuation M \\<Turnstile>\n                         \\<phi>\\<^sub>1 \\<^bold>\\<or> \\<phi>\\<^sub>2\n 5. \\<lbrakk>wm_basic M; is_STRIPS_fmla (\\<^bold>\\<not> \\<bottom>);\n     \\<forall>\\<A>.\n        Ball M ((\\<Turnstile>) \\<A>) \\<longrightarrow>\n        \\<A> \\<Turnstile> \\<^bold>\\<not> \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> valuation M \\<Turnstile> \\<^bold>\\<not> \\<bottom>\n 6. \\<And>va vb.\n       \\<lbrakk>wm_basic M; is_STRIPS_fmla (Atom (Eq va vb));\n        \\<forall>\\<A>.\n           Ball M ((\\<Turnstile>) \\<A>) \\<longrightarrow>\n           \\<A> \\<Turnstile> Atom (Eq va vb)\\<rbrakk>\n       \\<Longrightarrow> valuation M \\<Turnstile> Atom (Eq va vb)\n 7. \\<And>va.\n       \\<lbrakk>wm_basic M; is_STRIPS_fmla (\\<^bold>\\<not> (Atom va));\n        \\<forall>\\<A>.\n           Ball M ((\\<Turnstile>) \\<A>) \\<longrightarrow>\n           \\<A> \\<Turnstile> \\<^bold>\\<not> (Atom va)\\<rbrakk>\n       \\<Longrightarrow> valuation M \\<Turnstile> \\<^bold>\\<not> (Atom va)\n 8. \\<And>va.\n       \\<lbrakk>wm_basic M;\n        is_STRIPS_fmla (\\<^bold>\\<not> (\\<^bold>\\<not> va));\n        \\<forall>\\<A>.\n           Ball M ((\\<Turnstile>) \\<A>) \\<longrightarrow>\n           \\<A> \\<Turnstile> \\<^bold>\\<not> (\\<^bold>\\<not> va)\\<rbrakk>\n       \\<Longrightarrow> valuation M \\<Turnstile>\n                         \\<^bold>\\<not> (\\<^bold>\\<not> va)\n 9. \\<And>va vb.\n       \\<lbrakk>wm_basic M;\n        is_STRIPS_fmla (\\<^bold>\\<not> (va \\<^bold>\\<and> vb));\n        \\<forall>\\<A>.\n           Ball M ((\\<Turnstile>) \\<A>) \\<longrightarrow>\n           \\<A> \\<Turnstile> \\<^bold>\\<not> (va \\<^bold>\\<and> vb)\\<rbrakk>\n       \\<Longrightarrow> valuation M \\<Turnstile>\n                         \\<^bold>\\<not> (va \\<^bold>\\<and> vb)\n 10. \\<And>va vb.\n        \\<lbrakk>wm_basic M;\n         is_STRIPS_fmla (\\<^bold>\\<not> (va \\<^bold>\\<or> vb));\n         \\<forall>\\<A>.\n            Ball M ((\\<Turnstile>) \\<A>) \\<longrightarrow>\n            \\<A> \\<Turnstile> \\<^bold>\\<not> (va \\<^bold>\\<or> vb)\\<rbrakk>\n        \\<Longrightarrow> valuation M \\<Turnstile>\n                          \\<^bold>\\<not> (va \\<^bold>\\<or> vb)\nA total of 12 subgoals...", "apply simp_all"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>uu_ uv_.\n       \\<lbrakk>wm_basic M;\n        \\<forall>\\<A>.\n           (\\<forall>x\\<in>M. \\<A> \\<Turnstile> x) \\<longrightarrow>\n           \\<A> (predAtm uu_ uv_)\\<rbrakk>\n       \\<Longrightarrow> valuation M (predAtm uu_ uv_)\n 2. \\<lbrakk>wm_basic M;\n     \\<forall>\\<A>. \\<exists>x\\<in>M. \\<not> \\<A> \\<Turnstile> x\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<And>\\<phi>\\<^sub>1 \\<phi>\\<^sub>2.\n       \\<lbrakk>\\<forall>\\<A>.\n                   (\\<forall>x\\<in>M. \\<A> \\<Turnstile> x) \\<longrightarrow>\n                   \\<A> \\<Turnstile> \\<phi>\\<^sub>1 \\<Longrightarrow>\n                valuation M \\<Turnstile> \\<phi>\\<^sub>1;\n        \\<forall>\\<A>.\n           (\\<forall>x\\<in>M. \\<A> \\<Turnstile> x) \\<longrightarrow>\n           \\<A> \\<Turnstile> \\<phi>\\<^sub>2 \\<Longrightarrow>\n        valuation M \\<Turnstile> \\<phi>\\<^sub>2;\n        wm_basic M;\n        is_STRIPS_fmla \\<phi>\\<^sub>1 \\<and> is_STRIPS_fmla \\<phi>\\<^sub>2;\n        \\<forall>\\<A>.\n           (\\<forall>x\\<in>M. \\<A> \\<Turnstile> x) \\<longrightarrow>\n           \\<A> \\<Turnstile> \\<phi>\\<^sub>1 \\<or>\n           \\<A> \\<Turnstile> \\<phi>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> valuation M \\<Turnstile> \\<phi>\\<^sub>1 \\<or>\n                         valuation M \\<Turnstile> \\<phi>\\<^sub>2", "apply (metis in_close_world_conv valuation_aux_2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>wm_basic M;\n     \\<forall>\\<A>. \\<exists>x\\<in>M. \\<not> \\<A> \\<Turnstile> x\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>\\<phi>\\<^sub>1 \\<phi>\\<^sub>2.\n       \\<lbrakk>\\<forall>\\<A>.\n                   (\\<forall>x\\<in>M. \\<A> \\<Turnstile> x) \\<longrightarrow>\n                   \\<A> \\<Turnstile> \\<phi>\\<^sub>1 \\<Longrightarrow>\n                valuation M \\<Turnstile> \\<phi>\\<^sub>1;\n        \\<forall>\\<A>.\n           (\\<forall>x\\<in>M. \\<A> \\<Turnstile> x) \\<longrightarrow>\n           \\<A> \\<Turnstile> \\<phi>\\<^sub>2 \\<Longrightarrow>\n        valuation M \\<Turnstile> \\<phi>\\<^sub>2;\n        wm_basic M;\n        is_STRIPS_fmla \\<phi>\\<^sub>1 \\<and> is_STRIPS_fmla \\<phi>\\<^sub>2;\n        \\<forall>\\<A>.\n           (\\<forall>x\\<in>M. \\<A> \\<Turnstile> x) \\<longrightarrow>\n           \\<A> \\<Turnstile> \\<phi>\\<^sub>1 \\<or>\n           \\<A> \\<Turnstile> \\<phi>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> valuation M \\<Turnstile> \\<phi>\\<^sub>1 \\<or>\n                         valuation M \\<Turnstile> \\<phi>\\<^sub>2", "using in_close_world_conv valuation_aux_2"], ["proof (prove)\nusing this:\n  (?\\<phi> \\<in> close_world ?M) =\n  (?\\<phi> \\<in> ?M \\<or>\n   (\\<exists>p as.\n       ?\\<phi> = \\<^bold>\\<not> (Atom (predAtm p as)) \\<and>\n       Atom (predAtm p as) \\<notin> ?M) \\<or>\n   (\\<exists>a. ?\\<phi> = Atom (Eq a a)) \\<or>\n   (\\<exists>a b.\n       ?\\<phi> = \\<^bold>\\<not> (Atom (Eq a b)) \\<and> a \\<noteq> b))\n  wm_basic ?M \\<Longrightarrow>\n  \\<forall>G\\<in>close_world ?M. valuation ?M \\<Turnstile> G\n\ngoal (2 subgoals):\n 1. \\<lbrakk>wm_basic M;\n     \\<forall>\\<A>. \\<exists>x\\<in>M. \\<not> \\<A> \\<Turnstile> x\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>\\<phi>\\<^sub>1 \\<phi>\\<^sub>2.\n       \\<lbrakk>\\<forall>\\<A>.\n                   (\\<forall>x\\<in>M. \\<A> \\<Turnstile> x) \\<longrightarrow>\n                   \\<A> \\<Turnstile> \\<phi>\\<^sub>1 \\<Longrightarrow>\n                valuation M \\<Turnstile> \\<phi>\\<^sub>1;\n        \\<forall>\\<A>.\n           (\\<forall>x\\<in>M. \\<A> \\<Turnstile> x) \\<longrightarrow>\n           \\<A> \\<Turnstile> \\<phi>\\<^sub>2 \\<Longrightarrow>\n        valuation M \\<Turnstile> \\<phi>\\<^sub>2;\n        wm_basic M;\n        is_STRIPS_fmla \\<phi>\\<^sub>1 \\<and> is_STRIPS_fmla \\<phi>\\<^sub>2;\n        \\<forall>\\<A>.\n           (\\<forall>x\\<in>M. \\<A> \\<Turnstile> x) \\<longrightarrow>\n           \\<A> \\<Turnstile> \\<phi>\\<^sub>1 \\<or>\n           \\<A> \\<Turnstile> \\<phi>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> valuation M \\<Turnstile> \\<phi>\\<^sub>1 \\<or>\n                         valuation M \\<Turnstile> \\<phi>\\<^sub>2", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<phi>\\<^sub>1 \\<phi>\\<^sub>2.\n       \\<lbrakk>\\<forall>\\<A>.\n                   (\\<forall>x\\<in>M. \\<A> \\<Turnstile> x) \\<longrightarrow>\n                   \\<A> \\<Turnstile> \\<phi>\\<^sub>1 \\<Longrightarrow>\n                valuation M \\<Turnstile> \\<phi>\\<^sub>1;\n        \\<forall>\\<A>.\n           (\\<forall>x\\<in>M. \\<A> \\<Turnstile> x) \\<longrightarrow>\n           \\<A> \\<Turnstile> \\<phi>\\<^sub>2 \\<Longrightarrow>\n        valuation M \\<Turnstile> \\<phi>\\<^sub>2;\n        wm_basic M;\n        is_STRIPS_fmla \\<phi>\\<^sub>1 \\<and> is_STRIPS_fmla \\<phi>\\<^sub>2;\n        \\<forall>\\<A>.\n           (\\<forall>x\\<in>M. \\<A> \\<Turnstile> x) \\<longrightarrow>\n           \\<A> \\<Turnstile> \\<phi>\\<^sub>1 \\<or>\n           \\<A> \\<Turnstile> \\<phi>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> valuation M \\<Turnstile> \\<phi>\\<^sub>1 \\<or>\n                         valuation M \\<Turnstile> \\<phi>\\<^sub>2", "using in_close_world_conv valuation_aux_2"], ["proof (prove)\nusing this:\n  (?\\<phi> \\<in> close_world ?M) =\n  (?\\<phi> \\<in> ?M \\<or>\n   (\\<exists>p as.\n       ?\\<phi> = \\<^bold>\\<not> (Atom (predAtm p as)) \\<and>\n       Atom (predAtm p as) \\<notin> ?M) \\<or>\n   (\\<exists>a. ?\\<phi> = Atom (Eq a a)) \\<or>\n   (\\<exists>a b.\n       ?\\<phi> = \\<^bold>\\<not> (Atom (Eq a b)) \\<and> a \\<noteq> b))\n  wm_basic ?M \\<Longrightarrow>\n  \\<forall>G\\<in>close_world ?M. valuation ?M \\<Turnstile> G\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>\\<^sub>1 \\<phi>\\<^sub>2.\n       \\<lbrakk>\\<forall>\\<A>.\n                   (\\<forall>x\\<in>M. \\<A> \\<Turnstile> x) \\<longrightarrow>\n                   \\<A> \\<Turnstile> \\<phi>\\<^sub>1 \\<Longrightarrow>\n                valuation M \\<Turnstile> \\<phi>\\<^sub>1;\n        \\<forall>\\<A>.\n           (\\<forall>x\\<in>M. \\<A> \\<Turnstile> x) \\<longrightarrow>\n           \\<A> \\<Turnstile> \\<phi>\\<^sub>2 \\<Longrightarrow>\n        valuation M \\<Turnstile> \\<phi>\\<^sub>2;\n        wm_basic M;\n        is_STRIPS_fmla \\<phi>\\<^sub>1 \\<and> is_STRIPS_fmla \\<phi>\\<^sub>2;\n        \\<forall>\\<A>.\n           (\\<forall>x\\<in>M. \\<A> \\<Turnstile> x) \\<longrightarrow>\n           \\<A> \\<Turnstile> \\<phi>\\<^sub>1 \\<or>\n           \\<A> \\<Turnstile> \\<phi>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> valuation M \\<Turnstile> \\<phi>\\<^sub>1 \\<or>\n                         valuation M \\<Turnstile> \\<phi>\\<^sub>2", "by auto"], ["", "lemma valuation_iff_STRIPS:\n  assumes \"wm_basic M\"\n  assumes \"is_STRIPS_fmla \\<phi>\"\n  shows \"valuation M \\<Turnstile> \\<phi> \\<longleftrightarrow> M \\<TTurnstile> \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valuation M \\<Turnstile> \\<phi> = M \\<TTurnstile> \\<phi>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. valuation M \\<Turnstile> \\<phi> = M \\<TTurnstile> \\<phi>", "have aux1: \"\\<And>\\<A>. \\<lbrakk>valuation M \\<Turnstile> \\<phi>; \\<forall>G\\<in>M. \\<A> \\<Turnstile> G\\<rbrakk> \\<Longrightarrow> \\<A> \\<Turnstile> \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<A>.\n       \\<lbrakk>valuation M \\<Turnstile> \\<phi>;\n        \\<forall>G\\<in>M. \\<A> \\<Turnstile> G\\<rbrakk>\n       \\<Longrightarrow> \\<A> \\<Turnstile> \\<phi>", "using assms"], ["proof (prove)\nusing this:\n  wm_basic M\n  is_STRIPS_fmla \\<phi>\n\ngoal (1 subgoal):\n 1. \\<And>\\<A>.\n       \\<lbrakk>valuation M \\<Turnstile> \\<phi>;\n        \\<forall>G\\<in>M. \\<A> \\<Turnstile> G\\<rbrakk>\n       \\<Longrightarrow> \\<A> \\<Turnstile> \\<phi>", "apply(induction \\<phi> rule: is_STRIPS_fmla.induct)"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>uu_ uv_ \\<A>.\n       \\<lbrakk>valuation M \\<Turnstile> Atom (predAtm uu_ uv_);\n        Ball M ((\\<Turnstile>) \\<A>); wm_basic M;\n        is_STRIPS_fmla (Atom (predAtm uu_ uv_))\\<rbrakk>\n       \\<Longrightarrow> \\<A> \\<Turnstile> Atom (predAtm uu_ uv_)\n 2. \\<And>\\<A>.\n       \\<lbrakk>valuation M \\<Turnstile> \\<bottom>;\n        Ball M ((\\<Turnstile>) \\<A>); wm_basic M;\n        is_STRIPS_fmla \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> \\<A> \\<Turnstile> \\<bottom>\n 3. \\<And>\\<phi>\\<^sub>1 \\<phi>\\<^sub>2 \\<A>.\n       \\<lbrakk>\\<And>\\<A>.\n                   \\<lbrakk>valuation M \\<Turnstile> \\<phi>\\<^sub>1;\n                    Ball M ((\\<Turnstile>) \\<A>); wm_basic M;\n                    is_STRIPS_fmla \\<phi>\\<^sub>1\\<rbrakk>\n                   \\<Longrightarrow> \\<A> \\<Turnstile> \\<phi>\\<^sub>1;\n        \\<And>\\<A>.\n           \\<lbrakk>valuation M \\<Turnstile> \\<phi>\\<^sub>2;\n            Ball M ((\\<Turnstile>) \\<A>); wm_basic M;\n            is_STRIPS_fmla \\<phi>\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> \\<A> \\<Turnstile> \\<phi>\\<^sub>2;\n        valuation M \\<Turnstile>\n        \\<phi>\\<^sub>1 \\<^bold>\\<and> \\<phi>\\<^sub>2;\n        Ball M ((\\<Turnstile>) \\<A>); wm_basic M;\n        is_STRIPS_fmla\n         (\\<phi>\\<^sub>1 \\<^bold>\\<and> \\<phi>\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<A> \\<Turnstile>\n                         \\<phi>\\<^sub>1 \\<^bold>\\<and> \\<phi>\\<^sub>2\n 4. \\<And>\\<phi>\\<^sub>1 \\<phi>\\<^sub>2 \\<A>.\n       \\<lbrakk>\\<And>\\<A>.\n                   \\<lbrakk>valuation M \\<Turnstile> \\<phi>\\<^sub>1;\n                    Ball M ((\\<Turnstile>) \\<A>); wm_basic M;\n                    is_STRIPS_fmla \\<phi>\\<^sub>1\\<rbrakk>\n                   \\<Longrightarrow> \\<A> \\<Turnstile> \\<phi>\\<^sub>1;\n        \\<And>\\<A>.\n           \\<lbrakk>valuation M \\<Turnstile> \\<phi>\\<^sub>2;\n            Ball M ((\\<Turnstile>) \\<A>); wm_basic M;\n            is_STRIPS_fmla \\<phi>\\<^sub>2\\<rbrakk>\n           \\<Longrightarrow> \\<A> \\<Turnstile> \\<phi>\\<^sub>2;\n        valuation M \\<Turnstile>\n        \\<phi>\\<^sub>1 \\<^bold>\\<or> \\<phi>\\<^sub>2;\n        Ball M ((\\<Turnstile>) \\<A>); wm_basic M;\n        is_STRIPS_fmla\n         (\\<phi>\\<^sub>1 \\<^bold>\\<or> \\<phi>\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> \\<A> \\<Turnstile>\n                         \\<phi>\\<^sub>1 \\<^bold>\\<or> \\<phi>\\<^sub>2\n 5. \\<And>\\<A>.\n       \\<lbrakk>valuation M \\<Turnstile> \\<^bold>\\<not> \\<bottom>;\n        Ball M ((\\<Turnstile>) \\<A>); wm_basic M;\n        is_STRIPS_fmla (\\<^bold>\\<not> \\<bottom>)\\<rbrakk>\n       \\<Longrightarrow> \\<A> \\<Turnstile> \\<^bold>\\<not> \\<bottom>\n 6. \\<And>va vb \\<A>.\n       \\<lbrakk>valuation M \\<Turnstile> Atom (Eq va vb);\n        Ball M ((\\<Turnstile>) \\<A>); wm_basic M;\n        is_STRIPS_fmla (Atom (Eq va vb))\\<rbrakk>\n       \\<Longrightarrow> \\<A> \\<Turnstile> Atom (Eq va vb)\n 7. \\<And>va \\<A>.\n       \\<lbrakk>valuation M \\<Turnstile> \\<^bold>\\<not> (Atom va);\n        Ball M ((\\<Turnstile>) \\<A>); wm_basic M;\n        is_STRIPS_fmla (\\<^bold>\\<not> (Atom va))\\<rbrakk>\n       \\<Longrightarrow> \\<A> \\<Turnstile> \\<^bold>\\<not> (Atom va)\n 8. \\<And>va \\<A>.\n       \\<lbrakk>valuation M \\<Turnstile> \\<^bold>\\<not> (\\<^bold>\\<not> va);\n        Ball M ((\\<Turnstile>) \\<A>); wm_basic M;\n        is_STRIPS_fmla (\\<^bold>\\<not> (\\<^bold>\\<not> va))\\<rbrakk>\n       \\<Longrightarrow> \\<A> \\<Turnstile>\n                         \\<^bold>\\<not> (\\<^bold>\\<not> va)\n 9. \\<And>va vb \\<A>.\n       \\<lbrakk>valuation M \\<Turnstile>\n                \\<^bold>\\<not> (va \\<^bold>\\<and> vb);\n        Ball M ((\\<Turnstile>) \\<A>); wm_basic M;\n        is_STRIPS_fmla (\\<^bold>\\<not> (va \\<^bold>\\<and> vb))\\<rbrakk>\n       \\<Longrightarrow> \\<A> \\<Turnstile>\n                         \\<^bold>\\<not> (va \\<^bold>\\<and> vb)\n 10. \\<And>va vb \\<A>.\n        \\<lbrakk>valuation M \\<Turnstile>\n                 \\<^bold>\\<not> (va \\<^bold>\\<or> vb);\n         Ball M ((\\<Turnstile>) \\<A>); wm_basic M;\n         is_STRIPS_fmla (\\<^bold>\\<not> (va \\<^bold>\\<or> vb))\\<rbrakk>\n        \\<Longrightarrow> \\<A> \\<Turnstile>\n                          \\<^bold>\\<not> (va \\<^bold>\\<or> vb)\nA total of 12 subgoals...", "by (auto simp: valuation_def)"], ["proof (state)\nthis:\n  \\<lbrakk>valuation M \\<Turnstile> \\<phi>;\n   \\<forall>G\\<in>M. ?\\<A> \\<Turnstile> G\\<rbrakk>\n  \\<Longrightarrow> ?\\<A> \\<Turnstile> \\<phi>\n\ngoal (1 subgoal):\n 1. valuation M \\<Turnstile> \\<phi> = M \\<TTurnstile> \\<phi>", "have aux2: \"\\<lbrakk>\\<forall>\\<A>. (\\<forall>G\\<in>M. \\<A> \\<Turnstile> G) \\<longrightarrow> \\<A> \\<Turnstile> \\<phi>\\<rbrakk> \\<Longrightarrow> valuation M \\<Turnstile> \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<A>.\n       (\\<forall>G\\<in>M. \\<A> \\<Turnstile> G) \\<longrightarrow>\n       \\<A> \\<Turnstile> \\<phi> \\<Longrightarrow>\n    valuation M \\<Turnstile> \\<phi>", "using assms"], ["proof (prove)\nusing this:\n  wm_basic M\n  is_STRIPS_fmla \\<phi>\n\ngoal (1 subgoal):\n 1. \\<forall>\\<A>.\n       (\\<forall>G\\<in>M. \\<A> \\<Turnstile> G) \\<longrightarrow>\n       \\<A> \\<Turnstile> \\<phi> \\<Longrightarrow>\n    valuation M \\<Turnstile> \\<phi>", "apply(induction \\<phi> rule: is_STRIPS_fmla.induct)"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<And>uu_ uv_.\n       \\<lbrakk>\\<forall>\\<A>.\n                   Ball M ((\\<Turnstile>) \\<A>) \\<longrightarrow>\n                   \\<A> \\<Turnstile> Atom (predAtm uu_ uv_);\n        wm_basic M; is_STRIPS_fmla (Atom (predAtm uu_ uv_))\\<rbrakk>\n       \\<Longrightarrow> valuation M \\<Turnstile> Atom (predAtm uu_ uv_)\n 2. \\<lbrakk>\\<forall>\\<A>.\n                Ball M ((\\<Turnstile>) \\<A>) \\<longrightarrow>\n                \\<A> \\<Turnstile> \\<bottom>;\n     wm_basic M; is_STRIPS_fmla \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> valuation M \\<Turnstile> \\<bottom>\n 3. \\<And>\\<phi>\\<^sub>1 \\<phi>\\<^sub>2.\n       \\<lbrakk>\\<lbrakk>\\<forall>\\<A>.\n                            Ball M ((\\<Turnstile>) \\<A>) \\<longrightarrow>\n                            \\<A> \\<Turnstile> \\<phi>\\<^sub>1;\n                 wm_basic M; is_STRIPS_fmla \\<phi>\\<^sub>1\\<rbrakk>\n                \\<Longrightarrow> valuation M \\<Turnstile> \\<phi>\\<^sub>1;\n        \\<lbrakk>\\<forall>\\<A>.\n                    Ball M ((\\<Turnstile>) \\<A>) \\<longrightarrow>\n                    \\<A> \\<Turnstile> \\<phi>\\<^sub>2;\n         wm_basic M; is_STRIPS_fmla \\<phi>\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> valuation M \\<Turnstile> \\<phi>\\<^sub>2;\n        \\<forall>\\<A>.\n           Ball M ((\\<Turnstile>) \\<A>) \\<longrightarrow>\n           \\<A> \\<Turnstile> \\<phi>\\<^sub>1 \\<^bold>\\<and> \\<phi>\\<^sub>2;\n        wm_basic M;\n        is_STRIPS_fmla\n         (\\<phi>\\<^sub>1 \\<^bold>\\<and> \\<phi>\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valuation M \\<Turnstile>\n                         \\<phi>\\<^sub>1 \\<^bold>\\<and> \\<phi>\\<^sub>2\n 4. \\<And>\\<phi>\\<^sub>1 \\<phi>\\<^sub>2.\n       \\<lbrakk>\\<lbrakk>\\<forall>\\<A>.\n                            Ball M ((\\<Turnstile>) \\<A>) \\<longrightarrow>\n                            \\<A> \\<Turnstile> \\<phi>\\<^sub>1;\n                 wm_basic M; is_STRIPS_fmla \\<phi>\\<^sub>1\\<rbrakk>\n                \\<Longrightarrow> valuation M \\<Turnstile> \\<phi>\\<^sub>1;\n        \\<lbrakk>\\<forall>\\<A>.\n                    Ball M ((\\<Turnstile>) \\<A>) \\<longrightarrow>\n                    \\<A> \\<Turnstile> \\<phi>\\<^sub>2;\n         wm_basic M; is_STRIPS_fmla \\<phi>\\<^sub>2\\<rbrakk>\n        \\<Longrightarrow> valuation M \\<Turnstile> \\<phi>\\<^sub>2;\n        \\<forall>\\<A>.\n           Ball M ((\\<Turnstile>) \\<A>) \\<longrightarrow>\n           \\<A> \\<Turnstile> \\<phi>\\<^sub>1 \\<^bold>\\<or> \\<phi>\\<^sub>2;\n        wm_basic M;\n        is_STRIPS_fmla\n         (\\<phi>\\<^sub>1 \\<^bold>\\<or> \\<phi>\\<^sub>2)\\<rbrakk>\n       \\<Longrightarrow> valuation M \\<Turnstile>\n                         \\<phi>\\<^sub>1 \\<^bold>\\<or> \\<phi>\\<^sub>2\n 5. \\<lbrakk>\\<forall>\\<A>.\n                Ball M ((\\<Turnstile>) \\<A>) \\<longrightarrow>\n                \\<A> \\<Turnstile> \\<^bold>\\<not> \\<bottom>;\n     wm_basic M; is_STRIPS_fmla (\\<^bold>\\<not> \\<bottom>)\\<rbrakk>\n    \\<Longrightarrow> valuation M \\<Turnstile> \\<^bold>\\<not> \\<bottom>\n 6. \\<And>va vb.\n       \\<lbrakk>\\<forall>\\<A>.\n                   Ball M ((\\<Turnstile>) \\<A>) \\<longrightarrow>\n                   \\<A> \\<Turnstile> Atom (Eq va vb);\n        wm_basic M; is_STRIPS_fmla (Atom (Eq va vb))\\<rbrakk>\n       \\<Longrightarrow> valuation M \\<Turnstile> Atom (Eq va vb)\n 7. \\<And>va.\n       \\<lbrakk>\\<forall>\\<A>.\n                   Ball M ((\\<Turnstile>) \\<A>) \\<longrightarrow>\n                   \\<A> \\<Turnstile> \\<^bold>\\<not> (Atom va);\n        wm_basic M; is_STRIPS_fmla (\\<^bold>\\<not> (Atom va))\\<rbrakk>\n       \\<Longrightarrow> valuation M \\<Turnstile> \\<^bold>\\<not> (Atom va)\n 8. \\<And>va.\n       \\<lbrakk>\\<forall>\\<A>.\n                   Ball M ((\\<Turnstile>) \\<A>) \\<longrightarrow>\n                   \\<A> \\<Turnstile> \\<^bold>\\<not> (\\<^bold>\\<not> va);\n        wm_basic M;\n        is_STRIPS_fmla (\\<^bold>\\<not> (\\<^bold>\\<not> va))\\<rbrakk>\n       \\<Longrightarrow> valuation M \\<Turnstile>\n                         \\<^bold>\\<not> (\\<^bold>\\<not> va)\n 9. \\<And>va vb.\n       \\<lbrakk>\\<forall>\\<A>.\n                   Ball M ((\\<Turnstile>) \\<A>) \\<longrightarrow>\n                   \\<A> \\<Turnstile> \\<^bold>\\<not> (va \\<^bold>\\<and> vb);\n        wm_basic M;\n        is_STRIPS_fmla (\\<^bold>\\<not> (va \\<^bold>\\<and> vb))\\<rbrakk>\n       \\<Longrightarrow> valuation M \\<Turnstile>\n                         \\<^bold>\\<not> (va \\<^bold>\\<and> vb)\n 10. \\<And>va vb.\n        \\<lbrakk>\\<forall>\\<A>.\n                    Ball M ((\\<Turnstile>) \\<A>) \\<longrightarrow>\n                    \\<A> \\<Turnstile> \\<^bold>\\<not> (va \\<^bold>\\<or> vb);\n         wm_basic M;\n         is_STRIPS_fmla (\\<^bold>\\<not> (va \\<^bold>\\<or> vb))\\<rbrakk>\n        \\<Longrightarrow> valuation M \\<Turnstile>\n                          \\<^bold>\\<not> (va \\<^bold>\\<or> vb)\nA total of 12 subgoals...", "apply simp_all"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>uu_ uv_.\n       \\<lbrakk>\\<forall>\\<A>.\n                   (\\<forall>x\\<in>M. \\<A> \\<Turnstile> x) \\<longrightarrow>\n                   \\<A> (predAtm uu_ uv_);\n        wm_basic M\\<rbrakk>\n       \\<Longrightarrow> valuation M (predAtm uu_ uv_)\n 2. \\<lbrakk>\\<forall>\\<A>. \\<exists>x\\<in>M. \\<not> \\<A> \\<Turnstile> x;\n     wm_basic M\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<And>\\<phi>\\<^sub>1 \\<phi>\\<^sub>2.\n       \\<lbrakk>\\<forall>\\<A>.\n                   (\\<forall>x\\<in>M. \\<A> \\<Turnstile> x) \\<longrightarrow>\n                   \\<A> \\<Turnstile> \\<phi>\\<^sub>1 \\<Longrightarrow>\n                valuation M \\<Turnstile> \\<phi>\\<^sub>1;\n        \\<forall>\\<A>.\n           (\\<forall>x\\<in>M. \\<A> \\<Turnstile> x) \\<longrightarrow>\n           \\<A> \\<Turnstile> \\<phi>\\<^sub>2 \\<Longrightarrow>\n        valuation M \\<Turnstile> \\<phi>\\<^sub>2;\n        \\<forall>\\<A>.\n           (\\<forall>x\\<in>M. \\<A> \\<Turnstile> x) \\<longrightarrow>\n           \\<A> \\<Turnstile> \\<phi>\\<^sub>1 \\<or>\n           \\<A> \\<Turnstile> \\<phi>\\<^sub>2;\n        wm_basic M;\n        is_STRIPS_fmla \\<phi>\\<^sub>1 \\<and>\n        is_STRIPS_fmla \\<phi>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> valuation M \\<Turnstile> \\<phi>\\<^sub>1 \\<or>\n                         valuation M \\<Turnstile> \\<phi>\\<^sub>2", "apply (metis in_close_world_conv valuation_aux_2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>\\<A>. \\<exists>x\\<in>M. \\<not> \\<A> \\<Turnstile> x;\n     wm_basic M\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>\\<phi>\\<^sub>1 \\<phi>\\<^sub>2.\n       \\<lbrakk>\\<forall>\\<A>.\n                   (\\<forall>x\\<in>M. \\<A> \\<Turnstile> x) \\<longrightarrow>\n                   \\<A> \\<Turnstile> \\<phi>\\<^sub>1 \\<Longrightarrow>\n                valuation M \\<Turnstile> \\<phi>\\<^sub>1;\n        \\<forall>\\<A>.\n           (\\<forall>x\\<in>M. \\<A> \\<Turnstile> x) \\<longrightarrow>\n           \\<A> \\<Turnstile> \\<phi>\\<^sub>2 \\<Longrightarrow>\n        valuation M \\<Turnstile> \\<phi>\\<^sub>2;\n        \\<forall>\\<A>.\n           (\\<forall>x\\<in>M. \\<A> \\<Turnstile> x) \\<longrightarrow>\n           \\<A> \\<Turnstile> \\<phi>\\<^sub>1 \\<or>\n           \\<A> \\<Turnstile> \\<phi>\\<^sub>2;\n        wm_basic M;\n        is_STRIPS_fmla \\<phi>\\<^sub>1 \\<and>\n        is_STRIPS_fmla \\<phi>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> valuation M \\<Turnstile> \\<phi>\\<^sub>1 \\<or>\n                         valuation M \\<Turnstile> \\<phi>\\<^sub>2", "using in_close_world_conv valuation_aux_2"], ["proof (prove)\nusing this:\n  (?\\<phi> \\<in> close_world ?M) =\n  (?\\<phi> \\<in> ?M \\<or>\n   (\\<exists>p as.\n       ?\\<phi> = \\<^bold>\\<not> (Atom (predAtm p as)) \\<and>\n       Atom (predAtm p as) \\<notin> ?M) \\<or>\n   (\\<exists>a. ?\\<phi> = Atom (Eq a a)) \\<or>\n   (\\<exists>a b.\n       ?\\<phi> = \\<^bold>\\<not> (Atom (Eq a b)) \\<and> a \\<noteq> b))\n  wm_basic ?M \\<Longrightarrow>\n  \\<forall>G\\<in>close_world ?M. valuation ?M \\<Turnstile> G\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<forall>\\<A>. \\<exists>x\\<in>M. \\<not> \\<A> \\<Turnstile> x;\n     wm_basic M\\<rbrakk>\n    \\<Longrightarrow> False\n 2. \\<And>\\<phi>\\<^sub>1 \\<phi>\\<^sub>2.\n       \\<lbrakk>\\<forall>\\<A>.\n                   (\\<forall>x\\<in>M. \\<A> \\<Turnstile> x) \\<longrightarrow>\n                   \\<A> \\<Turnstile> \\<phi>\\<^sub>1 \\<Longrightarrow>\n                valuation M \\<Turnstile> \\<phi>\\<^sub>1;\n        \\<forall>\\<A>.\n           (\\<forall>x\\<in>M. \\<A> \\<Turnstile> x) \\<longrightarrow>\n           \\<A> \\<Turnstile> \\<phi>\\<^sub>2 \\<Longrightarrow>\n        valuation M \\<Turnstile> \\<phi>\\<^sub>2;\n        \\<forall>\\<A>.\n           (\\<forall>x\\<in>M. \\<A> \\<Turnstile> x) \\<longrightarrow>\n           \\<A> \\<Turnstile> \\<phi>\\<^sub>1 \\<or>\n           \\<A> \\<Turnstile> \\<phi>\\<^sub>2;\n        wm_basic M;\n        is_STRIPS_fmla \\<phi>\\<^sub>1 \\<and>\n        is_STRIPS_fmla \\<phi>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> valuation M \\<Turnstile> \\<phi>\\<^sub>1 \\<or>\n                         valuation M \\<Turnstile> \\<phi>\\<^sub>2", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<phi>\\<^sub>1 \\<phi>\\<^sub>2.\n       \\<lbrakk>\\<forall>\\<A>.\n                   (\\<forall>x\\<in>M. \\<A> \\<Turnstile> x) \\<longrightarrow>\n                   \\<A> \\<Turnstile> \\<phi>\\<^sub>1 \\<Longrightarrow>\n                valuation M \\<Turnstile> \\<phi>\\<^sub>1;\n        \\<forall>\\<A>.\n           (\\<forall>x\\<in>M. \\<A> \\<Turnstile> x) \\<longrightarrow>\n           \\<A> \\<Turnstile> \\<phi>\\<^sub>2 \\<Longrightarrow>\n        valuation M \\<Turnstile> \\<phi>\\<^sub>2;\n        \\<forall>\\<A>.\n           (\\<forall>x\\<in>M. \\<A> \\<Turnstile> x) \\<longrightarrow>\n           \\<A> \\<Turnstile> \\<phi>\\<^sub>1 \\<or>\n           \\<A> \\<Turnstile> \\<phi>\\<^sub>2;\n        wm_basic M;\n        is_STRIPS_fmla \\<phi>\\<^sub>1 \\<and>\n        is_STRIPS_fmla \\<phi>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> valuation M \\<Turnstile> \\<phi>\\<^sub>1 \\<or>\n                         valuation M \\<Turnstile> \\<phi>\\<^sub>2", "using in_close_world_conv valuation_aux_2"], ["proof (prove)\nusing this:\n  (?\\<phi> \\<in> close_world ?M) =\n  (?\\<phi> \\<in> ?M \\<or>\n   (\\<exists>p as.\n       ?\\<phi> = \\<^bold>\\<not> (Atom (predAtm p as)) \\<and>\n       Atom (predAtm p as) \\<notin> ?M) \\<or>\n   (\\<exists>a. ?\\<phi> = Atom (Eq a a)) \\<or>\n   (\\<exists>a b.\n       ?\\<phi> = \\<^bold>\\<not> (Atom (Eq a b)) \\<and> a \\<noteq> b))\n  wm_basic ?M \\<Longrightarrow>\n  \\<forall>G\\<in>close_world ?M. valuation ?M \\<Turnstile> G\n\ngoal (1 subgoal):\n 1. \\<And>\\<phi>\\<^sub>1 \\<phi>\\<^sub>2.\n       \\<lbrakk>\\<forall>\\<A>.\n                   (\\<forall>x\\<in>M. \\<A> \\<Turnstile> x) \\<longrightarrow>\n                   \\<A> \\<Turnstile> \\<phi>\\<^sub>1 \\<Longrightarrow>\n                valuation M \\<Turnstile> \\<phi>\\<^sub>1;\n        \\<forall>\\<A>.\n           (\\<forall>x\\<in>M. \\<A> \\<Turnstile> x) \\<longrightarrow>\n           \\<A> \\<Turnstile> \\<phi>\\<^sub>2 \\<Longrightarrow>\n        valuation M \\<Turnstile> \\<phi>\\<^sub>2;\n        \\<forall>\\<A>.\n           (\\<forall>x\\<in>M. \\<A> \\<Turnstile> x) \\<longrightarrow>\n           \\<A> \\<Turnstile> \\<phi>\\<^sub>1 \\<or>\n           \\<A> \\<Turnstile> \\<phi>\\<^sub>2;\n        wm_basic M;\n        is_STRIPS_fmla \\<phi>\\<^sub>1 \\<and>\n        is_STRIPS_fmla \\<phi>\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> valuation M \\<Turnstile> \\<phi>\\<^sub>1 \\<or>\n                         valuation M \\<Turnstile> \\<phi>\\<^sub>2", "by auto"], ["proof (state)\nthis:\n  \\<forall>\\<A>.\n     (\\<forall>G\\<in>M. \\<A> \\<Turnstile> G) \\<longrightarrow>\n     \\<A> \\<Turnstile> \\<phi> \\<Longrightarrow>\n  valuation M \\<Turnstile> \\<phi>\n\ngoal (1 subgoal):\n 1. valuation M \\<Turnstile> \\<phi> = M \\<TTurnstile> \\<phi>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. valuation M \\<Turnstile> \\<phi> = M \\<TTurnstile> \\<phi>", "by (auto simp: entailment_def intro: aux1 aux2)"], ["proof (state)\nthis:\n  valuation M \\<Turnstile> \\<phi> = M \\<TTurnstile> \\<phi>\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Our extension to negation and equality is a proper generalization of the\n  standard STRIPS semantics for formula without negation and equality\\<close>"], ["", "theorem proper_STRIPS_generalization:\n  \"\\<lbrakk>wm_basic M; is_STRIPS_fmla \\<phi>\\<rbrakk> \\<Longrightarrow> M \\<^sup>c\\<TTurnstile>\\<^sub>= \\<phi> \\<longleftrightarrow> M \\<TTurnstile> \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wm_basic M; is_STRIPS_fmla \\<phi>\\<rbrakk>\n    \\<Longrightarrow> M \\<^sup>c\\<TTurnstile>\\<^sub>= \\<phi> =\n                      M \\<TTurnstile> \\<phi>", "by (simp add: valuation_iff_close_world[symmetric] valuation_iff_STRIPS)"], ["", "subsection \\<open>STRIPS Semantics\\<close>"], ["", "text \\<open>For this section, we fix a domain \\<open>D\\<close>, using Isabelle's\n  locale mechanism.\\<close>"], ["", "locale ast_domain =\n  fixes D :: ast_domain\nbegin"], ["", "text \\<open>It seems to be agreed upon that, in case of a contradictory effect,\n    addition overrides deletion. We model this behaviour by first executing\n    the deletions, and then the additions.\\<close>"], ["", "fun apply_effect :: \"object ast_effect \\<Rightarrow> world_model \\<Rightarrow> world_model\"\n  where\n     \"apply_effect (Effect a d) s = (s - set d) \\<union> (set a)\""], ["", "text \\<open>Execute a ground action\\<close>"], ["", "definition execute_ground_action :: \"ground_action \\<Rightarrow> world_model \\<Rightarrow> world_model\"\n  where\n    \"execute_ground_action a M = apply_effect (effect a) M\""], ["", "text \\<open>Predicate to model that the given list of action instances is\n    executable, and transforms an initial world model \\<open>M\\<close> into a final\n    model \\<open>M'\\<close>.\n\n    Note that this definition over the list structure is more convenient in HOL\n    than to explicitly define an indexed sequence \\<open>M\\<^sub>0\\<dots>M\\<^sub>N\\<close> of intermediate world\n     models, as done in [Lif87].\n  \\<close>"], ["", "fun ground_action_path\n    :: \"world_model \\<Rightarrow> ground_action list \\<Rightarrow> world_model \\<Rightarrow> bool\"\n  where\n    \"ground_action_path M [] M' \\<longleftrightarrow> (M = M')\"\n  | \"ground_action_path M (\\<alpha>#\\<alpha>s) M' \\<longleftrightarrow> M \\<^sup>c\\<TTurnstile>\\<^sub>= precondition \\<alpha>\n    \\<and> ground_action_path (execute_ground_action \\<alpha> M) \\<alpha>s M'\""], ["", "text \\<open>Function equations as presented in paper,\n    with inlined @{const execute_ground_action}.\\<close>"], ["", "lemma ground_action_path_in_paper:\n    \"ground_action_path M [] M' \\<longleftrightarrow> (M = M')\"\n    \"ground_action_path M (\\<alpha>#\\<alpha>s) M' \\<longleftrightarrow> M \\<^sup>c\\<TTurnstile>\\<^sub>= precondition \\<alpha>\n    \\<and> (ground_action_path (apply_effect (effect \\<alpha>) M) \\<alpha>s M')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ground_action_path M [] M' = (M = M') &&&\n    ground_action_path M (\\<alpha> # \\<alpha>s) M' =\n    (M \\<^sup>c\\<TTurnstile>\\<^sub>=\n     ground_action.precondition \\<alpha> \\<and>\n     ground_action_path (apply_effect (ground_action.effect \\<alpha>) M)\n      \\<alpha>s M')", "by (auto simp: execute_ground_action_def)"], ["", "end \\<comment> \\<open>Context of \\<open>ast_domain\\<close>\\<close>"], ["", "subsection \\<open>Well-Formedness of PDDL\\<close>"], ["", "(* Well-formedness *)\n\n(*\n  Compute signature: predicate/arity\n  Check that all atoms (schemas and facts) satisfy signature\n\n  for action:\n    Check that used parameters \\<subseteq> declared parameters\n\n  for init/goal: Check that facts only use declared objects\n*)"], ["", "fun ty_term where\n  \"ty_term varT objT (term.VAR v) = varT v\"\n| \"ty_term varT objT (term.CONST c) = objT c\""], ["", "lemma ty_term_mono: \"varT \\<subseteq>\\<^sub>m varT' \\<Longrightarrow> objT \\<subseteq>\\<^sub>m objT' \\<Longrightarrow>\n  ty_term varT objT \\<subseteq>\\<^sub>m ty_term varT' objT'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>varT \\<subseteq>\\<^sub>m varT';\n     objT \\<subseteq>\\<^sub>m objT'\\<rbrakk>\n    \\<Longrightarrow> ty_term varT objT \\<subseteq>\\<^sub>m\n                      ty_term varT' objT'", "apply (rule map_leI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x v.\n       \\<lbrakk>varT \\<subseteq>\\<^sub>m varT';\n        objT \\<subseteq>\\<^sub>m objT';\n        ty_term varT objT x = Some v\\<rbrakk>\n       \\<Longrightarrow> ty_term varT' objT' x = Some v", "subgoal for x v"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>varT \\<subseteq>\\<^sub>m varT'; objT \\<subseteq>\\<^sub>m objT';\n     ty_term varT objT x = Some v\\<rbrakk>\n    \\<Longrightarrow> ty_term varT' objT' x = Some v", "apply (cases x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>varT \\<subseteq>\\<^sub>m varT';\n        objT \\<subseteq>\\<^sub>m objT'; ty_term varT objT x = Some v;\n        x = term.VAR x1\\<rbrakk>\n       \\<Longrightarrow> ty_term varT' objT' x = Some v\n 2. \\<And>x2.\n       \\<lbrakk>varT \\<subseteq>\\<^sub>m varT';\n        objT \\<subseteq>\\<^sub>m objT'; ty_term varT objT x = Some v;\n        x = term.CONST x2\\<rbrakk>\n       \\<Longrightarrow> ty_term varT' objT' x = Some v", "apply (auto dest: map_leD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "context ast_domain begin"], ["", "text \\<open>The signature is a partial function that maps the predicates\n    of the domain to lists of argument types.\\<close>"], ["", "definition sig :: \"predicate \\<rightharpoonup> type list\" where\n    \"sig \\<equiv> map_of (map (\\<lambda>PredDecl p n \\<Rightarrow> (p,n)) (predicates D))\""], ["", "text \\<open>We use a flat subtype hierarchy, where every type is a subtype\n    of object, and there are no other subtype relations.\n\n    Note that we do not need to restrict this relation to declared types,\n    as we will explicitly ensure that all types used in the problem are\n    declared.\n    \\<close>"], ["", "fun subtype_edge where\n    \"subtype_edge (ty,superty) = (superty,ty)\""], ["", "definition \"subtype_rel \\<equiv> set (map subtype_edge (types D))\""], ["", "(*\n  definition \"subtype_rel \\<equiv> {''object''}\\<times>UNIV\"\n  *)"], ["", "definition of_type :: \"type \\<Rightarrow> type \\<Rightarrow> bool\" where\n    \"of_type oT T \\<equiv> set (primitives oT) \\<subseteq> subtype_rel\\<^sup>* `` set (primitives T)\""], ["", "text \\<open>This checks that every primitive on the LHS is contained in or a\n    subtype of a primitive on the RHS\\<close>"], ["", "text \\<open>For the next few definitions, we fix a partial function that maps\n    a polymorphic entity type @{typ \"'e\"} to types. An entity can be\n    instantiated by variables or objects later.\\<close>"], ["", "context\n    fixes ty_ent :: \"'ent \\<rightharpoonup> type\"  \\<comment> \\<open>Entity's type, None if invalid\\<close>\n  begin"], ["", "text \\<open>Checks whether an entity has a given type\\<close>"], ["", "definition is_of_type :: \"'ent \\<Rightarrow> type \\<Rightarrow> bool\" where\n      \"is_of_type v T \\<longleftrightarrow> (\n        case ty_ent v of\n          Some vT \\<Rightarrow> of_type vT T\n        | None \\<Rightarrow> False)\""], ["", "fun wf_pred_atom :: \"predicate \\<times> 'ent list \\<Rightarrow> bool\" where\n      \"wf_pred_atom (p,vs) \\<longleftrightarrow> (\n        case sig p of\n          None \\<Rightarrow> False\n        | Some Ts \\<Rightarrow> list_all2 is_of_type vs Ts)\""], ["", "text \\<open>Predicate-atoms are well-formed if their arguments match the\n      signature, equalities are well-formed if the arguments are valid\n      objects (have a type).\n\n      TODO: We could check that types may actually overlap\n    \\<close>"], ["", "fun wf_atom :: \"'ent atom \\<Rightarrow> bool\" where\n      \"wf_atom (predAtm p vs) \\<longleftrightarrow> wf_pred_atom (p,vs)\"\n    | \"wf_atom (Eq a b) \\<longleftrightarrow> ty_ent a \\<noteq> None \\<and> ty_ent b \\<noteq> None\""], ["", "text \\<open>A formula is well-formed if it consists of valid atoms,\n      and does not contain negations, except for the encoding \\<open>\\<^bold>\\<not>\\<bottom>\\<close> of true.\n    \\<close>"], ["", "fun wf_fmla :: \"('ent atom) formula \\<Rightarrow> bool\" where\n      \"wf_fmla (Atom a) \\<longleftrightarrow> wf_atom a\"\n    | \"wf_fmla (\\<bottom>) \\<longleftrightarrow> True\"\n    | \"wf_fmla (\\<phi>1 \\<^bold>\\<and> \\<phi>2) \\<longleftrightarrow> (wf_fmla \\<phi>1 \\<and> wf_fmla \\<phi>2)\"\n    | \"wf_fmla (\\<phi>1 \\<^bold>\\<or> \\<phi>2) \\<longleftrightarrow> (wf_fmla \\<phi>1 \\<and> wf_fmla \\<phi>2)\"\n    | \"wf_fmla (\\<^bold>\\<not>\\<phi>) \\<longleftrightarrow> wf_fmla \\<phi>\"\n    | \"wf_fmla (\\<phi>1 \\<^bold>\\<rightarrow> \\<phi>2) \\<longleftrightarrow> (wf_fmla \\<phi>1 \\<and> wf_fmla \\<phi>2)\""], ["", "lemma \"wf_fmla \\<phi> = (\\<forall>a\\<in>atoms \\<phi>. wf_atom a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_fmla \\<phi> = Ball (atoms \\<phi>) wf_atom", "by (induction \\<phi>) auto"], ["", "(*lemma wf_fmla_add_simps[simp]: \"wf_fmla (\\<^bold>\\<not>\\<phi>) \\<longleftrightarrow> \\<phi>=\\<bottom>\"\n      by (cases \\<phi>) auto*)"], ["", "text \\<open>Special case for a well-formed atomic predicate formula\\<close>"], ["", "fun wf_fmla_atom where\n      \"wf_fmla_atom (Atom (predAtm a vs)) \\<longleftrightarrow> wf_pred_atom (a,vs)\"\n    | \"wf_fmla_atom _ \\<longleftrightarrow> False\""], ["", "lemma wf_fmla_atom_alt: \"wf_fmla_atom \\<phi> \\<longleftrightarrow> is_predAtom \\<phi> \\<and> wf_fmla \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_fmla_atom \\<phi> = (is_predAtom \\<phi> \\<and> wf_fmla \\<phi>)", "by (cases \\<phi> rule: wf_fmla_atom.cases) auto"], ["", "text \\<open>An effect is well-formed if the added and removed formulas\n      are atomic\\<close>"], ["", "fun wf_effect where\n      \"wf_effect (Effect a d) \\<longleftrightarrow>\n          (\\<forall>ae\\<in>set a. wf_fmla_atom ae)\n        \\<and> (\\<forall>de\\<in>set d.  wf_fmla_atom de)\""], ["", "end \\<comment> \\<open>Context fixing \\<open>ty_ent\\<close>\\<close>"], ["", "definition constT :: \"object \\<rightharpoonup> type\" where\n    \"constT \\<equiv> map_of (consts D)\""], ["", "text \\<open>An action schema is well-formed if the parameter names are distinct,\n    and the precondition and effect is well-formed wrt.\\ the parameters.\n  \\<close>"], ["", "fun wf_action_schema :: \"ast_action_schema \\<Rightarrow> bool\" where\n    \"wf_action_schema (Action_Schema n params pre eff) \\<longleftrightarrow> (\n      let\n        tyt = ty_term (map_of params) constT\n      in\n        distinct (map fst params)\n      \\<and> wf_fmla tyt pre\n      \\<and> wf_effect tyt eff)\""], ["", "text \\<open>A type is well-formed if it consists only of declared primitive types,\n     and the type object.\\<close>"], ["", "fun wf_type where\n    \"wf_type (Either Ts) \\<longleftrightarrow> set Ts \\<subseteq> insert ''object'' (fst`set (types D))\""], ["", "text \\<open>A predicate is well-formed if its argument types are well-formed.\\<close>"], ["", "fun wf_predicate_decl where\n    \"wf_predicate_decl (PredDecl p Ts) \\<longleftrightarrow> (\\<forall>T\\<in>set Ts. wf_type T)\""], ["", "text \\<open>The types declaration is well-formed, if all supertypes are declared types (or object)\\<close>"], ["", "definition \"wf_types \\<equiv> snd`set (types D) \\<subseteq> insert ''object'' (fst`set (types D))\""], ["", "text \\<open>A domain is well-formed if\n    \\<^item> there are no duplicate declared predicate names,\n    \\<^item> all declared predicates are well-formed,\n    \\<^item> there are no duplicate action names,\n    \\<^item> and all declared actions are well-formed\n    \\<close>"], ["", "definition wf_domain :: \"bool\" where\n    \"wf_domain \\<equiv>\n      wf_types\n    \\<and> distinct (map (predicate_decl.pred) (predicates D))\n    \\<and> (\\<forall>p\\<in>set (predicates D). wf_predicate_decl p)\n    \\<and> distinct (map fst (consts D))\n    \\<and> (\\<forall>(n,T)\\<in>set (consts D). wf_type T)\n    \\<and> distinct (map ast_action_schema.name (actions D))\n    \\<and> (\\<forall>a\\<in>set (actions D). wf_action_schema a)\n    \""], ["", "end \\<comment> \\<open>locale \\<open>ast_domain\\<close>\\<close>"], ["", "text \\<open>We fix a problem, and also include the definitions for the domain\n  of this problem.\\<close>"], ["", "locale ast_problem = ast_domain \"domain P\"\n  for P :: ast_problem\nbegin"], ["", "text \\<open>We refer to the problem domain as \\<open>D\\<close>\\<close>"], ["", "abbreviation \"D \\<equiv> ast_problem.domain P\""], ["", "definition objT :: \"object \\<rightharpoonup> type\" where\n    \"objT \\<equiv> map_of (objects P) ++ constT\""], ["", "lemma objT_alt: \"objT = map_of (consts D @ objects P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. objT = map_of (consts D @ objects P)", "unfolding objT_def constT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (objects P) ++ map_of (consts D) = map_of (consts D @ objects P)", "apply (clarsimp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition wf_fact :: \"fact \\<Rightarrow> bool\" where\n    \"wf_fact = wf_pred_atom objT\""], ["", "text \\<open>This definition is needed for well-formedness of the initial model,\n    and forward-references to the concept of world model.\n  \\<close>"], ["", "definition wf_world_model where\n    \"wf_world_model M = (\\<forall>f\\<in>M. wf_fmla_atom objT f)\""], ["", "(*Note: current semantics assigns each object a unique type *)"], ["", "definition wf_problem where\n    \"wf_problem \\<equiv>\n      wf_domain\n    \\<and> distinct (map fst (objects P) @ map fst (consts D))\n    \\<and> (\\<forall>(n,T)\\<in>set (objects P). wf_type T)\n    \\<and> distinct (init P)\n    \\<and> wf_world_model (set (init P))\n    \\<and> wf_fmla objT (goal P)\n    \""], ["", "fun wf_effect_inst :: \"object ast_effect \\<Rightarrow> bool\" where\n    \"wf_effect_inst (Effect (a) (d))\n      \\<longleftrightarrow> (\\<forall>a\\<in>set a \\<union> set d. wf_fmla_atom objT a)\""], ["", "lemma wf_effect_inst_alt: \"wf_effect_inst eff = wf_effect objT eff\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_effect_inst eff = wf_effect objT eff", "by (cases eff) auto"], ["", "end \\<comment> \\<open>locale \\<open>ast_problem\\<close>\\<close>"], ["", "text \\<open>Locale to express a well-formed domain\\<close>"], ["", "locale wf_ast_domain = ast_domain +\n  assumes wf_domain: wf_domain"], ["", "text \\<open>Locale to express a well-formed problem\\<close>"], ["", "locale wf_ast_problem = ast_problem P for P +\n  assumes wf_problem: wf_problem\nbegin"], ["", "sublocale wf_ast_domain \"domain P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_ast_domain D", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_domain", "using wf_problem"], ["proof (prove)\nusing this:\n  wf_problem\n\ngoal (1 subgoal):\n 1. wf_domain", "unfolding wf_problem_def"], ["proof (prove)\nusing this:\n  wf_domain \\<and>\n  distinct (map fst (objects P) @ map fst (consts D)) \\<and>\n  (\\<forall>(n, y)\\<in>set (objects P). wf_type y) \\<and>\n  distinct (init P) \\<and>\n  wf_world_model (set (init P)) \\<and> wf_fmla objT (goal P)\n\ngoal (1 subgoal):\n 1. wf_domain", "by simp"], ["", "end \\<comment> \\<open>locale \\<open>wf_ast_problem\\<close>\\<close>"], ["", "subsection \\<open>PDDL Semantics\\<close>"], ["", "(* Semantics *)\n\n(*  To apply plan_action:\n    find action schema, instantiate, check precond, apply effect\n*)"], ["", "context ast_domain begin"], ["", "definition resolve_action_schema :: \"name \\<rightharpoonup> ast_action_schema\" where\n    \"resolve_action_schema n = index_by ast_action_schema.name (actions D) n\""], ["", "fun subst_term where\n    \"subst_term psubst (term.VAR x) = psubst x\"\n  | \"subst_term psubst (term.CONST c) = c\""], ["", "text \\<open>To instantiate an action schema, we first compute a substitution from\n    parameters to objects, and then apply this substitution to the\n    precondition and effect. The substitution is applied via the \\<open>map_xxx\\<close>\n    functions generated by the datatype package.\n    \\<close>"], ["", "fun instantiate_action_schema\n    :: \"ast_action_schema \\<Rightarrow> object list \\<Rightarrow> ground_action\"\n  where\n    \"instantiate_action_schema (Action_Schema n params pre eff) args = (let\n        tsubst = subst_term (the o (map_of (zip (map fst params) args)));\n        pre_inst = (map_formula o map_atom) tsubst pre;\n        eff_inst = (map_ast_effect) tsubst eff\n      in\n        Ground_Action pre_inst eff_inst\n      )\""], ["", "end \\<comment> \\<open>Context of \\<open>ast_domain\\<close>\\<close>"], ["", "context ast_problem begin"], ["", "text \\<open>Initial model\\<close>"], ["", "definition I :: \"world_model\" where\n    \"I \\<equiv> set (init P)\""], ["", "text \\<open>Resolve a plan action and instantiate the referenced action schema.\\<close>"], ["", "fun resolve_instantiate :: \"plan_action \\<Rightarrow> ground_action\" where\n    \"resolve_instantiate (PAction n args) =\n      instantiate_action_schema\n        (the (resolve_action_schema n))\n        args\""], ["", "text \\<open>Check whether object has specified type\\<close>"], ["", "definition \"is_obj_of_type n T \\<equiv> case objT n of\n    None \\<Rightarrow> False\n  | Some oT \\<Rightarrow> of_type oT T\""], ["", "text \\<open>We can also use the generic \\<open>is_of_type\\<close> function.\\<close>"], ["", "lemma is_obj_of_type_alt: \"is_obj_of_type = is_of_type objT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_obj_of_type = is_of_type objT", "apply (intro ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa. is_obj_of_type x xa = is_of_type objT x xa", "unfolding is_obj_of_type_def is_of_type_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x xa.\n       (case objT x of None \\<Rightarrow> False\n        | Some oT \\<Rightarrow> of_type oT xa) =\n       (case objT x of None \\<Rightarrow> False\n        | Some vT \\<Rightarrow> of_type vT xa)", "by auto"], ["", "text \\<open>HOL encoding of matching an action's formal parameters against an\n    argument list.\n    The parameters of the action are encoded as a list of \\<open>name\\<times>type\\<close> pairs,\n    such that we map it to a list of types first. Then, the list\n    relator @{const list_all2} checks that arguments and types have the same\n    length, and each matching pair of argument and type\n    satisfies the predicate @{const is_obj_of_type}.\n  \\<close>"], ["", "definition \"action_params_match a args\n    \\<equiv> list_all2 is_obj_of_type args (map snd (parameters a))\""], ["", "text \\<open>At this point, we can define well-formedness of a plan action:\n    The action must refer to a declared action schema, the arguments must\n    be compatible with the formal parameters' types.\n  \\<close>"], ["", "(* Objects are valid and match parameter types *)"], ["", "fun wf_plan_action :: \"plan_action \\<Rightarrow> bool\" where\n    \"wf_plan_action (PAction n args) = (\n      case resolve_action_schema n of\n        None \\<Rightarrow> False\n      | Some a \\<Rightarrow>\n          action_params_match a args\n        \\<and> wf_effect_inst (effect (instantiate_action_schema a args))\n        )\""], ["", "text \\<open>\n    TODO: The second conjunct is redundant, as instantiating a well formed\n      action with valid objects yield a valid effect.\n  \\<close>"], ["", "text \\<open>A sequence of plan actions form a path, if they are well-formed and\n    their instantiations form a path.\\<close>"], ["", "definition plan_action_path\n    :: \"world_model \\<Rightarrow> plan_action list \\<Rightarrow> world_model \\<Rightarrow> bool\"\n  where\n    \"plan_action_path M \\<pi>s M' =\n        ((\\<forall>\\<pi> \\<in> set \\<pi>s. wf_plan_action \\<pi>)\n      \\<and> ground_action_path M (map resolve_instantiate \\<pi>s) M')\""], ["", "text \\<open>A plan is valid wrt.\\ a given initial model, if it forms a path to a\n    goal model \\<close>"], ["", "definition valid_plan_from :: \"world_model \\<Rightarrow> plan \\<Rightarrow> bool\" where\n    \"valid_plan_from M \\<pi>s = (\\<exists>M'. plan_action_path M \\<pi>s M' \\<and> M' \\<^sup>c\\<TTurnstile>\\<^sub>= (goal P))\""], ["", "(* Implementation note: resolve and instantiate already done inside\n      enabledness check, redundancy! *)"], ["", "text \\<open>Finally, a plan is valid if it is valid wrt.\\ the initial world\n    model @{const I}\\<close>"], ["", "definition valid_plan :: \"plan \\<Rightarrow> bool\"\n    where \"valid_plan \\<equiv> valid_plan_from I\""], ["", "text \\<open>Concise definition used in paper:\\<close>"], ["", "lemma \"valid_plan \\<pi>s \\<equiv> \\<exists>M'. plan_action_path I \\<pi>s M' \\<and> M' \\<^sup>c\\<TTurnstile>\\<^sub>= (goal P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid_plan \\<pi>s \\<equiv>\n    \\<exists>M'.\n       plan_action_path I \\<pi>s M' \\<and>\n       M' \\<^sup>c\\<TTurnstile>\\<^sub>= goal P", "unfolding valid_plan_def valid_plan_from_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>M'.\n       plan_action_path I \\<pi>s M' \\<and>\n       M' \\<^sup>c\\<TTurnstile>\\<^sub>= goal P \\<equiv>\n    \\<exists>M'.\n       plan_action_path I \\<pi>s M' \\<and>\n       M' \\<^sup>c\\<TTurnstile>\\<^sub>= goal P", "by auto"], ["", "end \\<comment> \\<open>Context of \\<open>ast_problem\\<close>\\<close>"], ["", "subsection \\<open>Preservation of Well-Formedness\\<close>"], ["", "subsubsection \\<open>Well-Formed Action Instances\\<close>"], ["", "text \\<open>The goal of this section is to establish that well-formedness of\n  world models is preserved by execution of well-formed plan actions.\n\\<close>"], ["", "context ast_problem begin"], ["", "text \\<open>As plan actions are executed by first instantiating them, and then\n    executing the action instance, it is natural to define a well-formedness\n    concept for action instances.\\<close>"], ["", "fun wf_ground_action :: \"ground_action \\<Rightarrow> bool\" where\n    \"wf_ground_action (Ground_Action pre eff) \\<longleftrightarrow> (\n        wf_fmla objT pre\n      \\<and> wf_effect objT eff\n      )\n    \""], ["", "text \\<open>We first prove that instantiating a well-formed action schema will yield\n    a well-formed action instance.\n\n    We begin with some auxiliary lemmas before the actual theorem.\n  \\<close>"], ["", "lemma (in ast_domain) of_type_refl[simp, intro!]: \"of_type T T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_type T T", "unfolding of_type_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. set (primitives T) \\<subseteq> subtype_rel\\<^sup>* `` set (primitives T)", "by auto"], ["", "lemma (in ast_domain) of_type_trans[trans]:\n    \"of_type T1 T2 \\<Longrightarrow> of_type T2 T3 \\<Longrightarrow> of_type T1 T3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>of_type T1 T2; of_type T2 T3\\<rbrakk>\n    \\<Longrightarrow> of_type T1 T3", "unfolding of_type_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>set (primitives T1)\n             \\<subseteq> subtype_rel\\<^sup>* `` set (primitives T2);\n     set (primitives T2)\n     \\<subseteq> subtype_rel\\<^sup>* `` set (primitives T3)\\<rbrakk>\n    \\<Longrightarrow> set (primitives T1)\n                      \\<subseteq> subtype_rel\\<^sup>* `` set (primitives T3)", "by clarsimp (metis (no_types, hide_lams)\n      Image_mono contra_subsetD order_refl rtrancl_image_idem)"], ["", "lemma is_of_type_map_ofE:\n    assumes \"is_of_type (map_of params) x T\"\n    obtains i xT where \"i<length params\" \"params!i = (x,xT)\" \"of_type xT T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i xT.\n        \\<lbrakk>i < length params; params ! i = (x, xT);\n         of_type xT T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  is_of_type (map_of params) x T\n\ngoal (1 subgoal):\n 1. (\\<And>i xT.\n        \\<lbrakk>i < length params; params ! i = (x, xT);\n         of_type xT T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding is_of_type_def"], ["proof (prove)\nusing this:\n  case map_of params x of None \\<Rightarrow> False\n  | Some vT \\<Rightarrow> of_type vT T\n\ngoal (1 subgoal):\n 1. (\\<And>i xT.\n        \\<lbrakk>i < length params; params ! i = (x, xT);\n         of_type xT T\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto split: option.splits dest!: map_of_SomeD simp: in_set_conv_nth)"], ["", "lemma wf_atom_mono:\n    assumes SS: \"tys \\<subseteq>\\<^sub>m tys'\"\n    assumes WF: \"wf_atom tys a\"\n    shows \"wf_atom tys' a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_atom tys' a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_atom tys' a", "have \"list_all2 (is_of_type tys') xs Ts\" if \"list_all2 (is_of_type tys) xs Ts\" for xs Ts"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (is_of_type tys') xs Ts", "using that"], ["proof (prove)\nusing this:\n  list_all2 (is_of_type tys) xs Ts\n\ngoal (1 subgoal):\n 1. list_all2 (is_of_type tys') xs Ts", "apply induction"], ["proof (prove)\ngoal (2 subgoals):\n 1. list_all2 (is_of_type tys') [] []\n 2. \\<And>x xs y ys.\n       \\<lbrakk>is_of_type tys x y; list_all2 (is_of_type tys) xs ys;\n        list_all2 (is_of_type tys') xs ys\\<rbrakk>\n       \\<Longrightarrow> list_all2 (is_of_type tys') (x # xs) (y # ys)", "by (auto simp: is_of_type_def split: option.splits dest: map_leD[OF SS])"], ["proof (state)\nthis:\n  list_all2 (is_of_type tys) ?xs16 ?Ts16 \\<Longrightarrow>\n  list_all2 (is_of_type tys') ?xs16 ?Ts16\n\ngoal (1 subgoal):\n 1. wf_atom tys' a", "with WF"], ["proof (chain)\npicking this:\n  wf_atom tys a\n  list_all2 (is_of_type tys) ?xs16 ?Ts16 \\<Longrightarrow>\n  list_all2 (is_of_type tys') ?xs16 ?Ts16", "show ?thesis"], ["proof (prove)\nusing this:\n  wf_atom tys a\n  list_all2 (is_of_type tys) ?xs16 ?Ts16 \\<Longrightarrow>\n  list_all2 (is_of_type tys') ?xs16 ?Ts16\n\ngoal (1 subgoal):\n 1. wf_atom tys' a", "by (cases a) (auto split: option.splits dest: map_leD[OF SS])"], ["proof (state)\nthis:\n  wf_atom tys' a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wf_fmla_atom_mono:\n    assumes SS: \"tys \\<subseteq>\\<^sub>m tys'\"\n    assumes WF: \"wf_fmla_atom tys a\"\n    shows \"wf_fmla_atom tys' a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_fmla_atom tys' a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_fmla_atom tys' a", "have \"list_all2 (is_of_type tys') xs Ts\" if \"list_all2 (is_of_type tys) xs Ts\" for xs Ts"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (is_of_type tys') xs Ts", "using that"], ["proof (prove)\nusing this:\n  list_all2 (is_of_type tys) xs Ts\n\ngoal (1 subgoal):\n 1. list_all2 (is_of_type tys') xs Ts", "apply induction"], ["proof (prove)\ngoal (2 subgoals):\n 1. list_all2 (is_of_type tys') [] []\n 2. \\<And>x xs y ys.\n       \\<lbrakk>is_of_type tys x y; list_all2 (is_of_type tys) xs ys;\n        list_all2 (is_of_type tys') xs ys\\<rbrakk>\n       \\<Longrightarrow> list_all2 (is_of_type tys') (x # xs) (y # ys)", "by (auto simp: is_of_type_def split: option.splits dest: map_leD[OF SS])"], ["proof (state)\nthis:\n  list_all2 (is_of_type tys) ?xs16 ?Ts16 \\<Longrightarrow>\n  list_all2 (is_of_type tys') ?xs16 ?Ts16\n\ngoal (1 subgoal):\n 1. wf_fmla_atom tys' a", "with WF"], ["proof (chain)\npicking this:\n  wf_fmla_atom tys a\n  list_all2 (is_of_type tys) ?xs16 ?Ts16 \\<Longrightarrow>\n  list_all2 (is_of_type tys') ?xs16 ?Ts16", "show ?thesis"], ["proof (prove)\nusing this:\n  wf_fmla_atom tys a\n  list_all2 (is_of_type tys) ?xs16 ?Ts16 \\<Longrightarrow>\n  list_all2 (is_of_type tys') ?xs16 ?Ts16\n\ngoal (1 subgoal):\n 1. wf_fmla_atom tys' a", "by (cases a rule: wf_fmla_atom.cases) (auto split: option.splits dest: map_leD[OF SS])"], ["proof (state)\nthis:\n  wf_fmla_atom tys' a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma constT_ss_objT: \"constT \\<subseteq>\\<^sub>m objT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. constT \\<subseteq>\\<^sub>m objT", "unfolding constT_def objT_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of (consts D) \\<subseteq>\\<^sub>m\n    map_of (objects P) ++ map_of (consts D)", "apply rule"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x v.\n       map_of (consts D) x = Some v \\<Longrightarrow>\n       (map_of (objects P) ++ map_of (consts D)) x = Some v", "by (auto simp: map_add_def split: option.split)"], ["", "lemma wf_atom_constT_imp_objT: \"wf_atom (ty_term Q constT) a \\<Longrightarrow> wf_atom (ty_term Q objT) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_atom (ty_term Q constT) a \\<Longrightarrow>\n    wf_atom (ty_term Q objT) a", "apply (erule wf_atom_mono[rotated])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ty_term Q constT \\<subseteq>\\<^sub>m ty_term Q objT", "apply (rule ty_term_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Q \\<subseteq>\\<^sub>m Q\n 2. constT \\<subseteq>\\<^sub>m objT", "by (simp_all add: constT_ss_objT)"], ["", "lemma wf_fmla_atom_constT_imp_objT: \"wf_fmla_atom (ty_term Q constT) a \\<Longrightarrow> wf_fmla_atom (ty_term Q objT) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_fmla_atom (ty_term Q constT) a \\<Longrightarrow>\n    wf_fmla_atom (ty_term Q objT) a", "apply (erule wf_fmla_atom_mono[rotated])"], ["proof (prove)\ngoal (1 subgoal):\n 1. ty_term Q constT \\<subseteq>\\<^sub>m ty_term Q objT", "apply (rule ty_term_mono)"], ["proof (prove)\ngoal (2 subgoals):\n 1. Q \\<subseteq>\\<^sub>m Q\n 2. constT \\<subseteq>\\<^sub>m objT", "by (simp_all add: constT_ss_objT)"], ["", "context\n    fixes Q and f :: \"variable \\<Rightarrow> object\"\n    assumes INST: \"is_of_type Q x T \\<Longrightarrow> is_of_type objT (f x) T\"\n  begin"], ["", "lemma is_of_type_var_conv: \"is_of_type (ty_term Q objT) (term.VAR x) T  \\<longleftrightarrow> is_of_type Q x T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_of_type (ty_term Q objT) (term.VAR x) T = is_of_type Q x T", "unfolding is_of_type_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case ty_term Q objT (term.VAR x) of None \\<Rightarrow> False\n     | Some vT \\<Rightarrow> of_type vT T) =\n    (case Q x of None \\<Rightarrow> False\n     | Some vT \\<Rightarrow> of_type vT T)", "by (auto)"], ["", "lemma is_of_type_const_conv: \"is_of_type (ty_term Q objT) (term.CONST x) T  \\<longleftrightarrow> is_of_type objT x T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_of_type (ty_term Q objT) (term.CONST x) T = is_of_type objT x T", "unfolding is_of_type_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case ty_term Q objT (term.CONST x) of None \\<Rightarrow> False\n     | Some vT \\<Rightarrow> of_type vT T) =\n    (case objT x of None \\<Rightarrow> False\n     | Some vT \\<Rightarrow> of_type vT T)", "by (auto split: option.split)"], ["", "lemma INST': \"is_of_type (ty_term Q objT) x T \\<Longrightarrow> is_of_type objT (subst_term f x) T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_of_type (ty_term Q objT) x T \\<Longrightarrow>\n    is_of_type objT (subst_term f x) T", "apply (cases x)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>is_of_type (ty_term Q objT) x T; x = term.VAR x1\\<rbrakk>\n       \\<Longrightarrow> is_of_type objT (subst_term f x) T\n 2. \\<And>x2.\n       \\<lbrakk>is_of_type (ty_term Q objT) x T; x = term.CONST x2\\<rbrakk>\n       \\<Longrightarrow> is_of_type objT (subst_term f x) T", "using INST"], ["proof (prove)\nusing this:\n  is_of_type Q ?x16 ?T16 \\<Longrightarrow> is_of_type objT (f ?x16) ?T16\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<lbrakk>is_of_type (ty_term Q objT) x T; x = term.VAR x1\\<rbrakk>\n       \\<Longrightarrow> is_of_type objT (subst_term f x) T\n 2. \\<And>x2.\n       \\<lbrakk>is_of_type (ty_term Q objT) x T; x = term.CONST x2\\<rbrakk>\n       \\<Longrightarrow> is_of_type objT (subst_term f x) T", "apply (auto simp: is_of_type_var_conv is_of_type_const_conv)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wf_inst_eq_aux: \"Q x = Some T \\<Longrightarrow> objT (f x) \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q x = Some T \\<Longrightarrow> objT (f x) \\<noteq> None", "using INST[of x T]"], ["proof (prove)\nusing this:\n  is_of_type Q x T \\<Longrightarrow> is_of_type objT (f x) T\n\ngoal (1 subgoal):\n 1. Q x = Some T \\<Longrightarrow> objT (f x) \\<noteq> None", "unfolding is_of_type_def"], ["proof (prove)\nusing this:\n  case Q x of None \\<Rightarrow> False\n  | Some vT \\<Rightarrow> of_type vT T \\<Longrightarrow>\n  case objT (f x) of None \\<Rightarrow> False\n  | Some vT \\<Rightarrow> of_type vT T\n\ngoal (1 subgoal):\n 1. Q x = Some T \\<Longrightarrow> objT (f x) \\<noteq> None", "by (auto split: option.splits)"], ["", "lemma wf_inst_eq_aux': \"ty_term Q objT x = Some T \\<Longrightarrow> objT (subst_term f x) \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ty_term Q objT x = Some T \\<Longrightarrow>\n    objT (subst_term f x) \\<noteq> None", "by (cases x) (auto simp: wf_inst_eq_aux)"], ["", "lemma wf_inst_atom:\n      assumes \"wf_atom (ty_term Q constT) a\"\n      shows \"wf_atom objT (map_atom (subst_term f) a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_atom objT (map_atom (subst_term f) a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_atom objT (map_atom (subst_term f) a)", "have X1: \"list_all2 (is_of_type objT) (map (subst_term f) xs) Ts\" if\n        \"list_all2 (is_of_type (ty_term Q objT)) xs Ts\" for xs Ts"], ["proof (prove)\ngoal (1 subgoal):\n 1. list_all2 (is_of_type objT) (map (subst_term f) xs) Ts", "using that"], ["proof (prove)\nusing this:\n  list_all2 (is_of_type (ty_term Q objT)) xs Ts\n\ngoal (1 subgoal):\n 1. list_all2 (is_of_type objT) (map (subst_term f) xs) Ts", "apply induction"], ["proof (prove)\ngoal (2 subgoals):\n 1. list_all2 (is_of_type objT) (map (subst_term f) []) []\n 2. \\<And>x xs y ys.\n       \\<lbrakk>is_of_type (ty_term Q objT) x y;\n        list_all2 (is_of_type (ty_term Q objT)) xs ys;\n        list_all2 (is_of_type objT) (map (subst_term f) xs) ys\\<rbrakk>\n       \\<Longrightarrow> list_all2 (is_of_type objT)\n                          (map (subst_term f) (x # xs)) (y # ys)", "using INST'"], ["proof (prove)\nusing this:\n  is_of_type (ty_term Q objT) ?x ?T \\<Longrightarrow>\n  is_of_type objT (subst_term f ?x) ?T\n\ngoal (2 subgoals):\n 1. list_all2 (is_of_type objT) (map (subst_term f) []) []\n 2. \\<And>x xs y ys.\n       \\<lbrakk>is_of_type (ty_term Q objT) x y;\n        list_all2 (is_of_type (ty_term Q objT)) xs ys;\n        list_all2 (is_of_type objT) (map (subst_term f) xs) ys\\<rbrakk>\n       \\<Longrightarrow> list_all2 (is_of_type objT)\n                          (map (subst_term f) (x # xs)) (y # ys)", "by auto"], ["proof (state)\nthis:\n  list_all2 (is_of_type (ty_term Q objT)) ?xs16 ?Ts16 \\<Longrightarrow>\n  list_all2 (is_of_type objT) (map (subst_term f) ?xs16) ?Ts16\n\ngoal (1 subgoal):\n 1. wf_atom objT (map_atom (subst_term f) a)", "then"], ["proof (chain)\npicking this:\n  list_all2 (is_of_type (ty_term Q objT)) ?xs16 ?Ts16 \\<Longrightarrow>\n  list_all2 (is_of_type objT) (map (subst_term f) ?xs16) ?Ts16", "show ?thesis"], ["proof (prove)\nusing this:\n  list_all2 (is_of_type (ty_term Q objT)) ?xs16 ?Ts16 \\<Longrightarrow>\n  list_all2 (is_of_type objT) (map (subst_term f) ?xs16) ?Ts16\n\ngoal (1 subgoal):\n 1. wf_atom objT (map_atom (subst_term f) a)", "using assms[THEN wf_atom_constT_imp_objT] wf_inst_eq_aux'"], ["proof (prove)\nusing this:\n  list_all2 (is_of_type (ty_term Q objT)) ?xs16 ?Ts16 \\<Longrightarrow>\n  list_all2 (is_of_type objT) (map (subst_term f) ?xs16) ?Ts16\n  wf_atom (ty_term Q objT) a\n  ty_term Q objT ?x = Some ?T \\<Longrightarrow>\n  objT (subst_term f ?x) \\<noteq> None\n\ngoal (1 subgoal):\n 1. wf_atom objT (map_atom (subst_term f) a)", "by (cases a; auto split: option.splits)"], ["proof (state)\nthis:\n  wf_atom objT (map_atom (subst_term f) a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wf_inst_formula_atom:\n      assumes \"wf_fmla_atom (ty_term Q constT) a\"\n      shows \"wf_fmla_atom objT ((map_formula o map_atom o subst_term) f a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_fmla_atom objT\n     ((map_formula \\<circ> map_atom \\<circ> subst_term) f a)", "using assms[THEN wf_fmla_atom_constT_imp_objT] wf_inst_atom"], ["proof (prove)\nusing this:\n  wf_fmla_atom (ty_term Q objT) a\n  wf_atom (ty_term Q constT) ?a \\<Longrightarrow>\n  wf_atom objT (map_atom (subst_term f) ?a)\n\ngoal (1 subgoal):\n 1. wf_fmla_atom objT\n     ((map_formula \\<circ> map_atom \\<circ> subst_term) f a)", "apply (cases a rule: wf_fmla_atom.cases; auto split: option.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa vs x2.\n       \\<lbrakk>a = Atom (predAtm aa vs);\n        \\<And>a.\n           wf_atom (ty_term Q constT) a \\<Longrightarrow>\n           wf_atom objT (map_atom (subst_term f) a);\n        sig aa = Some x2;\n        list_all2 (is_of_type (ty_term Q objT)) vs x2\\<rbrakk>\n       \\<Longrightarrow> list_all2 (is_of_type objT) (map (subst_term f) vs)\n                          x2", "by (simp add: INST' list.rel_map(1) list_all2_mono)"], ["", "lemma wf_inst_effect:\n      assumes \"wf_effect (ty_term Q constT) \\<phi>\"\n      shows \"wf_effect objT ((map_ast_effect o subst_term) f \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_effect objT ((map_ast_effect \\<circ> subst_term) f \\<phi>)", "using assms"], ["proof (prove)\nusing this:\n  wf_effect (ty_term Q constT) \\<phi>\n\ngoal (1 subgoal):\n 1. wf_effect objT ((map_ast_effect \\<circ> subst_term) f \\<phi>)", "proof (induction \\<phi>)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1a x2a.\n       wf_effect (ty_term Q constT) (Effect x1a x2a) \\<Longrightarrow>\n       wf_effect objT\n        ((map_ast_effect \\<circ> subst_term) f (Effect x1a x2a))", "case (Effect x1a x2a)"], ["proof (state)\nthis:\n  wf_effect (ty_term Q constT) (Effect x1a x2a)\n\ngoal (1 subgoal):\n 1. \\<And>x1a x2a.\n       wf_effect (ty_term Q constT) (Effect x1a x2a) \\<Longrightarrow>\n       wf_effect objT\n        ((map_ast_effect \\<circ> subst_term) f (Effect x1a x2a))", "then"], ["proof (chain)\npicking this:\n  wf_effect (ty_term Q constT) (Effect x1a x2a)", "show ?case"], ["proof (prove)\nusing this:\n  wf_effect (ty_term Q constT) (Effect x1a x2a)\n\ngoal (1 subgoal):\n 1. wf_effect objT ((map_ast_effect \\<circ> subst_term) f (Effect x1a x2a))", "using wf_inst_formula_atom"], ["proof (prove)\nusing this:\n  wf_effect (ty_term Q constT) (Effect x1a x2a)\n  wf_fmla_atom (ty_term Q constT) ?a \\<Longrightarrow>\n  wf_fmla_atom objT ((map_formula \\<circ> map_atom \\<circ> subst_term) f ?a)\n\ngoal (1 subgoal):\n 1. wf_effect objT ((map_ast_effect \\<circ> subst_term) f (Effect x1a x2a))", "by auto"], ["proof (state)\nthis:\n  wf_effect objT ((map_ast_effect \\<circ> subst_term) f (Effect x1a x2a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wf_inst_formula:\n      assumes \"wf_fmla (ty_term Q constT) \\<phi>\"\n      shows \"wf_fmla objT ((map_formula o map_atom o subst_term) f \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_fmla objT\n     ((map_formula \\<circ> map_atom \\<circ> subst_term) f \\<phi>)", "using assms"], ["proof (prove)\nusing this:\n  wf_fmla (ty_term Q constT) \\<phi>\n\ngoal (1 subgoal):\n 1. wf_fmla objT\n     ((map_formula \\<circ> map_atom \\<circ> subst_term) f \\<phi>)", "by (induction \\<phi>) (auto simp: wf_inst_atom dest: wf_inst_eq_aux)"], ["", "end"], ["", "text \\<open>Instantiating a well-formed action schema with compatible arguments\n    will yield a well-formed action instance.\n  \\<close>"], ["", "theorem wf_instantiate_action_schema:\n    assumes \"action_params_match a args\"\n    assumes \"wf_action_schema a\"\n    shows \"wf_ground_action (instantiate_action_schema a args)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_ground_action (instantiate_action_schema a args)", "proof (cases a)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       a = Action_Schema x1 x2 x3 x4 \\<Longrightarrow>\n       wf_ground_action (instantiate_action_schema a args)", "case [simp]: (Action_Schema name params pre eff)"], ["proof (state)\nthis:\n  a = Action_Schema name params pre eff\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       a = Action_Schema x1 x2 x3 x4 \\<Longrightarrow>\n       wf_ground_action (instantiate_action_schema a args)", "have INST:\n      \"is_of_type objT ((the \\<circ> map_of (zip (map fst params) args)) x) T\"\n      if \"is_of_type (map_of params) x T\" for x T"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_of_type objT\n     ((the \\<circ>\\<circ> map_of) (zip (map fst params) args) x) T", "using that"], ["proof (prove)\nusing this:\n  is_of_type (map_of params) x T\n\ngoal (1 subgoal):\n 1. is_of_type objT\n     ((the \\<circ>\\<circ> map_of) (zip (map fst params) args) x) T", "apply (rule is_of_type_map_ofE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i xT.\n       \\<lbrakk>i < length params; params ! i = (x, xT);\n        of_type xT T\\<rbrakk>\n       \\<Longrightarrow> is_of_type objT\n                          ((the \\<circ>\\<circ> map_of)\n                            (zip (map fst params) args) x)\n                          T", "using assms"], ["proof (prove)\nusing this:\n  action_params_match a args\n  wf_action_schema a\n\ngoal (1 subgoal):\n 1. \\<And>i xT.\n       \\<lbrakk>i < length params; params ! i = (x, xT);\n        of_type xT T\\<rbrakk>\n       \\<Longrightarrow> is_of_type objT\n                          ((the \\<circ>\\<circ> map_of)\n                            (zip (map fst params) args) x)\n                          T", "apply (clarsimp simp: Let_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i xT.\n       \\<lbrakk>i < length params; params ! i = (x, xT); of_type xT T;\n        action_params_match (Action_Schema name params pre eff) args;\n        distinct (map fst params);\n        wf_fmla (ty_term (map_of params) constT) pre;\n        wf_effect (ty_term (map_of params) constT) eff\\<rbrakk>\n       \\<Longrightarrow> is_of_type objT\n                          (the (map_of (zip (map fst params) args) x)) T", "subgoal for i xT"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length params; params ! i = (x, xT); of_type xT T;\n     action_params_match (Action_Schema name params pre eff) args;\n     distinct (map fst params);\n     wf_fmla (ty_term (map_of params) constT) pre;\n     wf_effect (ty_term (map_of params) constT) eff\\<rbrakk>\n    \\<Longrightarrow> is_of_type objT\n                       (the (map_of (zip (map fst params) args) x)) T", "unfolding action_params_match_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length params; params ! i = (x, xT); of_type xT T;\n     list_all2 is_obj_of_type args\n      (map snd (parameters (Action_Schema name params pre eff)));\n     distinct (map fst params);\n     wf_fmla (ty_term (map_of params) constT) pre;\n     wf_effect (ty_term (map_of params) constT) eff\\<rbrakk>\n    \\<Longrightarrow> is_of_type objT\n                       (the (map_of (zip (map fst params) args) x)) T", "apply (subst lookup_zip_idx_eq[where i=i];\n          (clarsimp simp: list_all2_lengthD)?)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length params; params ! i = (x, xT); of_type xT T;\n     list_all2 is_obj_of_type args (map snd params);\n     distinct (map fst params);\n     wf_fmla (ty_term (map_of params) constT) pre;\n     wf_effect (ty_term (map_of params) constT) eff\\<rbrakk>\n    \\<Longrightarrow> is_of_type objT (args ! i) T", "apply (frule list_all2_nthD2[where p=i]; simp?)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length params; params ! i = (x, xT); of_type xT T;\n     list_all2 is_obj_of_type args (map snd params);\n     distinct (map fst params);\n     wf_fmla (ty_term (map_of params) constT) pre;\n     wf_effect (ty_term (map_of params) constT) eff;\n     is_obj_of_type (args ! i) xT\\<rbrakk>\n    \\<Longrightarrow> is_of_type objT (args ! i) T", "apply (auto\n                simp: is_obj_of_type_alt is_of_type_def\n                intro: of_type_trans\n                split: option.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  is_of_type (map_of params) ?x16 ?T16 \\<Longrightarrow>\n  is_of_type objT\n   ((the \\<circ>\\<circ> map_of) (zip (map fst params) args) ?x16) ?T16\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       a = Action_Schema x1 x2 x3 x4 \\<Longrightarrow>\n       wf_ground_action (instantiate_action_schema a args)", "then"], ["proof (chain)\npicking this:\n  is_of_type (map_of params) ?x16 ?T16 \\<Longrightarrow>\n  is_of_type objT\n   ((the \\<circ>\\<circ> map_of) (zip (map fst params) args) ?x16) ?T16", "show ?thesis"], ["proof (prove)\nusing this:\n  is_of_type (map_of params) ?x16 ?T16 \\<Longrightarrow>\n  is_of_type objT\n   ((the \\<circ>\\<circ> map_of) (zip (map fst params) args) ?x16) ?T16\n\ngoal (1 subgoal):\n 1. wf_ground_action (instantiate_action_schema a args)", "using assms(2) wf_inst_formula wf_inst_effect"], ["proof (prove)\nusing this:\n  is_of_type (map_of params) ?x16 ?T16 \\<Longrightarrow>\n  is_of_type objT\n   ((the \\<circ>\\<circ> map_of) (zip (map fst params) args) ?x16) ?T16\n  wf_action_schema a\n  \\<lbrakk>\\<And>x T.\n              is_of_type ?Q x T \\<Longrightarrow> is_of_type objT (?f x) T;\n   wf_fmla (ty_term ?Q constT) ?\\<phi>\\<rbrakk>\n  \\<Longrightarrow> wf_fmla objT\n                     ((map_formula \\<circ> map_atom \\<circ> subst_term) ?f\n                       ?\\<phi>)\n  \\<lbrakk>\\<And>x T.\n              is_of_type ?Q x T \\<Longrightarrow> is_of_type objT (?f x) T;\n   wf_effect (ty_term ?Q constT) ?\\<phi>\\<rbrakk>\n  \\<Longrightarrow> wf_effect objT\n                     ((map_ast_effect \\<circ> subst_term) ?f ?\\<phi>)\n\ngoal (1 subgoal):\n 1. wf_ground_action (instantiate_action_schema a args)", "by (fastforce split: term.splits simp: Let_def comp_apply[abs_def])"], ["proof (state)\nthis:\n  wf_ground_action (instantiate_action_schema a args)\n\ngoal:\nNo subgoals!", "qed"], ["", "end \\<comment> \\<open>Context of \\<open>ast_problem\\<close>\\<close>"], ["", "subsubsection \\<open>Preservation\\<close>"], ["", "context ast_problem begin"], ["", "text \\<open>We start by defining two shorthands for enabledness and execution of\n    a plan action.\\<close>"], ["", "text \\<open>Shorthand for enabled plan action: It is well-formed, and the\n    precondition holds for its instance.\\<close>"], ["", "definition plan_action_enabled :: \"plan_action \\<Rightarrow> world_model \\<Rightarrow> bool\" where\n    \"plan_action_enabled \\<pi> M\n      \\<longleftrightarrow> wf_plan_action \\<pi> \\<and> M \\<^sup>c\\<TTurnstile>\\<^sub>= precondition (resolve_instantiate \\<pi>)\""], ["", "text \\<open>Shorthand for executing a plan action: Resolve, instantiate, and\n    apply effect\\<close>"], ["", "definition execute_plan_action :: \"plan_action \\<Rightarrow> world_model \\<Rightarrow> world_model\"\n    where \"execute_plan_action \\<pi> M\n      = (apply_effect (effect (resolve_instantiate \\<pi>)) M)\""], ["", "text \\<open>The @{const plan_action_path} predicate can be decomposed naturally\n    using these shorthands: \\<close>"], ["", "lemma plan_action_path_Nil[simp]: \"plan_action_path M [] M' \\<longleftrightarrow> M'=M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plan_action_path M [] M' = (M' = M)", "by (auto simp: plan_action_path_def)"], ["", "lemma plan_action_path_Cons[simp]:\n    \"plan_action_path M (\\<pi>#\\<pi>s) M' \\<longleftrightarrow>\n      plan_action_enabled \\<pi> M\n    \\<and> plan_action_path (execute_plan_action \\<pi> M) \\<pi>s M'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. plan_action_path M (\\<pi> # \\<pi>s) M' =\n    (plan_action_enabled \\<pi> M \\<and>\n     plan_action_path (execute_plan_action \\<pi> M) \\<pi>s M')", "by (auto\n      simp: plan_action_path_def execute_plan_action_def\n            execute_ground_action_def plan_action_enabled_def)"], ["", "end \\<comment> \\<open>Context of \\<open>ast_problem\\<close>\\<close>"], ["", "context wf_ast_problem begin"], ["", "text \\<open>The initial world model is well-formed\\<close>"], ["", "lemma wf_I: \"wf_world_model I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_world_model I", "using wf_problem"], ["proof (prove)\nusing this:\n  wf_problem\n\ngoal (1 subgoal):\n 1. wf_world_model I", "unfolding I_def wf_world_model_def wf_problem_def"], ["proof (prove)\nusing this:\n  wf_domain \\<and>\n  distinct (map fst (objects P) @ map fst (consts D)) \\<and>\n  (\\<forall>(n, y)\\<in>set (objects P). wf_type y) \\<and>\n  distinct (init P) \\<and>\n  Ball (set (init P)) (wf_fmla_atom objT) \\<and> wf_fmla objT (goal P)\n\ngoal (1 subgoal):\n 1. Ball (set (init P)) (wf_fmla_atom objT)", "apply(safe)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> set (init P); wf_domain;\n        distinct (map fst (objects P) @ map fst (consts D));\n        \\<forall>(n, y)\\<in>set (objects P). wf_type y; distinct (init P);\n        Ball (set (init P)) (wf_fmla_atom objT);\n        wf_fmla objT (goal P)\\<rbrakk>\n       \\<Longrightarrow> wf_fmla_atom objT x", "subgoal for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> set (init P); wf_domain;\n     distinct (map fst (objects P) @ map fst (consts D));\n     \\<forall>(n, y)\\<in>set (objects P). wf_type y; distinct (init P);\n     Ball (set (init P)) (wf_fmla_atom objT); wf_fmla objT (goal P)\\<rbrakk>\n    \\<Longrightarrow> wf_fmla_atom objT f", "by (induction f) auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text \\<open>Application of a well-formed effect preserves well-formedness\n    of the model\\<close>"], ["", "lemma wf_apply_effect:\n    assumes \"wf_effect objT e\"\n    assumes \"wf_world_model s\"\n    shows \"wf_world_model (apply_effect e s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_world_model (apply_effect e s)", "using assms wf_problem"], ["proof (prove)\nusing this:\n  wf_effect objT e\n  wf_world_model s\n  wf_problem\n\ngoal (1 subgoal):\n 1. wf_world_model (apply_effect e s)", "unfolding wf_world_model_def wf_problem_def wf_domain_def"], ["proof (prove)\nusing this:\n  wf_effect objT e\n  Ball s (wf_fmla_atom objT)\n  (wf_types \\<and>\n   distinct (map pred (predicates D)) \\<and>\n   Ball (set (predicates D)) wf_predicate_decl \\<and>\n   distinct (map fst (consts D)) \\<and>\n   (\\<forall>(n, y)\\<in>set (consts D). wf_type y) \\<and>\n   distinct (map ast_action_schema.name (actions D)) \\<and>\n   Ball (set (actions D)) wf_action_schema) \\<and>\n  distinct (map fst (objects P) @ map fst (consts D)) \\<and>\n  (\\<forall>(n, y)\\<in>set (objects P). wf_type y) \\<and>\n  distinct (init P) \\<and>\n  Ball (set (init P)) (wf_fmla_atom objT) \\<and> wf_fmla objT (goal P)\n\ngoal (1 subgoal):\n 1. Ball (apply_effect e s) (wf_fmla_atom objT)", "by (cases e) (auto split: formula.splits prod.splits)"], ["", "text \\<open>Execution of plan actions preserves well-formedness\\<close>"], ["", "theorem wf_execute:\n    assumes \"plan_action_enabled \\<pi> s\"\n    assumes \"wf_world_model s\"\n    shows \"wf_world_model (execute_plan_action \\<pi> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_world_model (execute_plan_action \\<pi> s)", "using assms"], ["proof (prove)\nusing this:\n  plan_action_enabled \\<pi> s\n  wf_world_model s\n\ngoal (1 subgoal):\n 1. wf_world_model (execute_plan_action \\<pi> s)", "proof (cases \\<pi>)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>plan_action_enabled \\<pi> s; wf_world_model s;\n        \\<pi> = PAction x1 x2\\<rbrakk>\n       \\<Longrightarrow> wf_world_model (execute_plan_action \\<pi> s)", "case [simp]: (PAction name args)"], ["proof (state)\nthis:\n  \\<pi> = PAction name args\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>plan_action_enabled \\<pi> s; wf_world_model s;\n        \\<pi> = PAction x1 x2\\<rbrakk>\n       \\<Longrightarrow> wf_world_model (execute_plan_action \\<pi> s)", "from \\<open>plan_action_enabled \\<pi> s\\<close>"], ["proof (chain)\npicking this:\n  plan_action_enabled \\<pi> s", "have \"wf_plan_action \\<pi>\""], ["proof (prove)\nusing this:\n  plan_action_enabled \\<pi> s\n\ngoal (1 subgoal):\n 1. wf_plan_action \\<pi>", "unfolding plan_action_enabled_def"], ["proof (prove)\nusing this:\n  wf_plan_action \\<pi> \\<and>\n  s \\<^sup>c\\<TTurnstile>\\<^sub>=\n  ground_action.precondition (resolve_instantiate \\<pi>)\n\ngoal (1 subgoal):\n 1. wf_plan_action \\<pi>", "by auto"], ["proof (state)\nthis:\n  wf_plan_action \\<pi>\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>plan_action_enabled \\<pi> s; wf_world_model s;\n        \\<pi> = PAction x1 x2\\<rbrakk>\n       \\<Longrightarrow> wf_world_model (execute_plan_action \\<pi> s)", "then"], ["proof (chain)\npicking this:\n  wf_plan_action \\<pi>", "obtain a where\n      \"resolve_action_schema name = Some a\" and\n      T: \"action_params_match a args\""], ["proof (prove)\nusing this:\n  wf_plan_action \\<pi>\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        \\<lbrakk>resolve_action_schema name = Some a;\n         action_params_match a args\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto split: option.splits)"], ["proof (state)\nthis:\n  resolve_action_schema name = Some a\n  action_params_match a args\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>plan_action_enabled \\<pi> s; wf_world_model s;\n        \\<pi> = PAction x1 x2\\<rbrakk>\n       \\<Longrightarrow> wf_world_model (execute_plan_action \\<pi> s)", "from wf_domain"], ["proof (chain)\npicking this:\n  wf_domain", "have\n      [simp]: \"distinct (map ast_action_schema.name (actions D))\""], ["proof (prove)\nusing this:\n  wf_domain\n\ngoal (1 subgoal):\n 1. distinct (map ast_action_schema.name (actions D))", "unfolding wf_domain_def"], ["proof (prove)\nusing this:\n  wf_types \\<and>\n  distinct (map pred (predicates D)) \\<and>\n  Ball (set (predicates D)) wf_predicate_decl \\<and>\n  distinct (map fst (consts D)) \\<and>\n  (\\<forall>(n, y)\\<in>set (consts D). wf_type y) \\<and>\n  distinct (map ast_action_schema.name (actions D)) \\<and>\n  Ball (set (actions D)) wf_action_schema\n\ngoal (1 subgoal):\n 1. distinct (map ast_action_schema.name (actions D))", "by auto"], ["proof (state)\nthis:\n  distinct (map ast_action_schema.name (actions D))\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>plan_action_enabled \\<pi> s; wf_world_model s;\n        \\<pi> = PAction x1 x2\\<rbrakk>\n       \\<Longrightarrow> wf_world_model (execute_plan_action \\<pi> s)", "from \\<open>resolve_action_schema name = Some a\\<close>"], ["proof (chain)\npicking this:\n  resolve_action_schema name = Some a", "have\n      \"a \\<in> set (actions D)\""], ["proof (prove)\nusing this:\n  resolve_action_schema name = Some a\n\ngoal (1 subgoal):\n 1. a \\<in> set (actions D)", "unfolding resolve_action_schema_def"], ["proof (prove)\nusing this:\n  index_by ast_action_schema.name (actions D) name = Some a\n\ngoal (1 subgoal):\n 1. a \\<in> set (actions D)", "by auto"], ["proof (state)\nthis:\n  a \\<in> set (actions D)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>plan_action_enabled \\<pi> s; wf_world_model s;\n        \\<pi> = PAction x1 x2\\<rbrakk>\n       \\<Longrightarrow> wf_world_model (execute_plan_action \\<pi> s)", "with wf_domain"], ["proof (chain)\npicking this:\n  wf_domain\n  a \\<in> set (actions D)", "have \"wf_action_schema a\""], ["proof (prove)\nusing this:\n  wf_domain\n  a \\<in> set (actions D)\n\ngoal (1 subgoal):\n 1. wf_action_schema a", "unfolding wf_domain_def"], ["proof (prove)\nusing this:\n  wf_types \\<and>\n  distinct (map pred (predicates D)) \\<and>\n  Ball (set (predicates D)) wf_predicate_decl \\<and>\n  distinct (map fst (consts D)) \\<and>\n  (\\<forall>(n, y)\\<in>set (consts D). wf_type y) \\<and>\n  distinct (map ast_action_schema.name (actions D)) \\<and>\n  Ball (set (actions D)) wf_action_schema\n  a \\<in> set (actions D)\n\ngoal (1 subgoal):\n 1. wf_action_schema a", "by auto"], ["proof (state)\nthis:\n  wf_action_schema a\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>plan_action_enabled \\<pi> s; wf_world_model s;\n        \\<pi> = PAction x1 x2\\<rbrakk>\n       \\<Longrightarrow> wf_world_model (execute_plan_action \\<pi> s)", "hence \"wf_ground_action (resolve_instantiate \\<pi>)\""], ["proof (prove)\nusing this:\n  wf_action_schema a\n\ngoal (1 subgoal):\n 1. wf_ground_action (resolve_instantiate \\<pi>)", "using \\<open>resolve_action_schema name = Some a\\<close> T\n        wf_instantiate_action_schema"], ["proof (prove)\nusing this:\n  wf_action_schema a\n  resolve_action_schema name = Some a\n  action_params_match a args\n  \\<lbrakk>action_params_match ?a ?args; wf_action_schema ?a\\<rbrakk>\n  \\<Longrightarrow> wf_ground_action (instantiate_action_schema ?a ?args)\n\ngoal (1 subgoal):\n 1. wf_ground_action (resolve_instantiate \\<pi>)", "by auto"], ["proof (state)\nthis:\n  wf_ground_action (resolve_instantiate \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>plan_action_enabled \\<pi> s; wf_world_model s;\n        \\<pi> = PAction x1 x2\\<rbrakk>\n       \\<Longrightarrow> wf_world_model (execute_plan_action \\<pi> s)", "thus ?thesis"], ["proof (prove)\nusing this:\n  wf_ground_action (resolve_instantiate \\<pi>)\n\ngoal (1 subgoal):\n 1. wf_world_model (execute_plan_action \\<pi> s)", "apply (simp add: execute_plan_action_def execute_ground_action_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_ground_action\n     (instantiate_action_schema (the (resolve_action_schema name))\n       args) \\<Longrightarrow>\n    wf_world_model\n     (apply_effect\n       (ground_action.effect\n         (instantiate_action_schema (the (resolve_action_schema name))\n           args))\n       s)", "apply (rule wf_apply_effect)"], ["proof (prove)\ngoal (2 subgoals):\n 1. wf_ground_action\n     (instantiate_action_schema (the (resolve_action_schema name))\n       args) \\<Longrightarrow>\n    wf_effect objT\n     (ground_action.effect\n       (instantiate_action_schema (the (resolve_action_schema name)) args))\n 2. wf_ground_action\n     (instantiate_action_schema (the (resolve_action_schema name))\n       args) \\<Longrightarrow>\n    wf_world_model s", "apply (cases \"resolve_instantiate \\<pi>\"; simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_ground_action\n     (instantiate_action_schema (the (resolve_action_schema name))\n       args) \\<Longrightarrow>\n    wf_world_model s", "by (rule \\<open>wf_world_model s\\<close>)"], ["proof (state)\nthis:\n  wf_world_model (execute_plan_action \\<pi> s)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem wf_execute_compact_notation:\n    \"plan_action_enabled \\<pi> s \\<Longrightarrow> wf_world_model s\n    \\<Longrightarrow> wf_world_model (execute_plan_action \\<pi> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>plan_action_enabled \\<pi> s; wf_world_model s\\<rbrakk>\n    \\<Longrightarrow> wf_world_model (execute_plan_action \\<pi> s)", "by (rule wf_execute)"], ["", "text \\<open>Execution of a plan preserves well-formedness\\<close>"], ["", "corollary wf_plan_action_path:\n    assumes \"wf_world_model M\" and \" plan_action_path M \\<pi>s M'\"\n    shows \"wf_world_model M'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_world_model M'", "using assms"], ["proof (prove)\nusing this:\n  wf_world_model M\n  plan_action_path M \\<pi>s M'\n\ngoal (1 subgoal):\n 1. wf_world_model M'", "by (induction \\<pi>s arbitrary: M) (auto intro: wf_execute)"], ["", "end \\<comment> \\<open>Context of \\<open>wf_ast_problem\\<close>\\<close>"], ["", "end \\<comment> \\<open>Theory\\<close>"]]}