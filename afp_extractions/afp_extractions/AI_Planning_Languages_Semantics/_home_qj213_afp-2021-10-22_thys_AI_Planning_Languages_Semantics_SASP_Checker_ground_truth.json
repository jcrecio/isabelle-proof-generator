{"file_name": "/home/qj213/afp-2021-10-22/thys/AI_Planning_Languages_Semantics/SASP_Checker.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/AI_Planning_Languages_Semantics", "problem_names": ["lemma map_of_leI:\n    assumes \"distinct (map fst l)\"\n    assumes \"\\<And>k v. (k,v)\\<in>set l \\<Longrightarrow> m k = Some v\"\n    shows \"map_of l \\<subseteq>\\<^sub>m m\"", "lemma [simp]: \"fst \\<circ> (\\<lambda>(a, b, c, d). (f a b c d, g a b c d)) = (\\<lambda>(a,b,c,d). f a b c d)\"", "lemma map_mp: \"m\\<subseteq>\\<^sub>mm' \\<Longrightarrow> m k = Some v \\<Longrightarrow> m' k = Some v\"", "lemma map_add_map_of_fold: \n    fixes ps and m :: \"'a \\<rightharpoonup> 'b\"\n    assumes \"distinct (map fst ps)\"\n    shows \"m ++ map_of ps = fold (\\<lambda>(k, v) m. m(k \\<mapsto> v)) ps m\"", "lemmas wf_code_thms = \n      ast_problem.astDom_def ast_problem.astI_def ast_problem.astG_def ast_problem.ast\\<delta>_def\n      ast_problem.numVars_def ast_problem.numVals_def \n      ast_problem.wf_partial_state_def ast_problem.wf_operator_def ast_problem.well_formed_def", "lemma match_pres_correct:\n      assumes D: \"distinct (map fst pres)\"\n      assumes \"s\\<in>valid_states\"  \n      shows \"match_pres pres s \\<longleftrightarrow> s\\<in>subsuming_states (map_of pres)\"", "lemma match_implicit_pres_correct:\n      assumes D: \"distinct (map (\\<lambda>(_, v, _, _). v) effs)\"\n      assumes \"s\\<in>valid_states\"  \n      shows \"match_implicit_pres effs s \\<longleftrightarrow> s\\<in>subsuming_states (map_of (implicit_pres effs))\"", "lemma enabled_opr'_correct:\n      assumes V: \"s\\<in>valid_states\"\n      assumes \"lookup_operator name = Some \\<pi>\"  \n      shows \"enabled_opr' \\<pi> s \\<longleftrightarrow> enabled name s\"", "lemma eff_enabled'_correct:\n      assumes V: \"s\\<in>valid_states\"\n      assumes \"case eff of (pres,_,_,_) \\<Rightarrow> wf_partial_state pres\"  \n      shows \"eff_enabled' s eff \\<longleftrightarrow> eff_enabled s eff\"", "lemma execute_opr'_correct:\n      assumes V: \"s\\<in>valid_states\"\n      assumes LO: \"lookup_operator name = Some \\<pi>\"  \n      shows \"execute_opr' \\<pi> s = execute name s\"", "lemma lookup_operator'_correct: \n      \"lookup_operator' problem name = lookup_operator name\"", "lemma enabled'_correct:\n      assumes V: \"s\\<in>valid_states\"\n      shows \"enabled' problem name s = enabled name s\"", "lemma execute'_correct:\n      assumes V: \"s\\<in>valid_states\"\n      assumes \"enabled name s\"      (* Intentionally put this here, also we could resolve non-enabled case by reflexivity (undefined=undefined) *)\n      shows \"execute' problem name s = execute name s\"", "lemma simulate_plan_correct: \"simulate_plan \\<pi>s s = Some s' \\<longleftrightarrow> path_to s \\<pi>s s'\"", "lemma check_plan_correct: \"check_plan \\<pi>s \\<longleftrightarrow> valid_plan \\<pi>s\"", "lemma simulate_plan'_code[code]:\n    \"simulate_plan' problem [] s = Some s\"\n    \"simulate_plan' problem (\\<pi>#\\<pi>s) s = (\n      case lookup_operator' problem \\<pi> of\n        None \\<Rightarrow> None\n      | Some \\<pi> \\<Rightarrow> \n          if enabled_opr' \\<pi> s then \n            simulate_plan' problem \\<pi>s (execute_opr' \\<pi> s)\n          else None\n    )\"", "lemma simulate_plan'_correct:\n      assumes \"s\\<in>valid_states\"\n      shows \"simulate_plan' problem \\<pi>s s = simulate_plan \\<pi>s s\"", "lemma simulate_plan'_correct_paper: (* For presentation in paper. \n        Summarizing intermediate refinement step. *)\n      assumes \"s\\<in>valid_states\"\n      shows \"simulate_plan' problem \\<pi>s s = Some s'\n            \\<longleftrightarrow> path_to s \\<pi>s s'\"", "lemma initial_state'_correct: \n      \"initial_state' problem = I\"", "lemma check_plan'_correct:\n      \"check_plan' problem \\<pi>s = check_plan \\<pi>s\"", "lemma verify_plan_correct:\n    \"verify_plan problem \\<pi>s = Inr () \n    \\<longleftrightarrow> ast_problem.well_formed problem \\<and> ast_problem.valid_plan problem \\<pi>s\""], "translations": [["", "lemma map_of_leI:\n    assumes \"distinct (map fst l)\"\n    assumes \"\\<And>k v. (k,v)\\<in>set l \\<Longrightarrow> m k = Some v\"\n    shows \"map_of l \\<subseteq>\\<^sub>m m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_of l \\<subseteq>\\<^sub>m m", "using assms"], ["proof (prove)\nusing this:\n  distinct (map fst l)\n  (?k, ?v) \\<in> set l \\<Longrightarrow> m ?k = Some ?v\n\ngoal (1 subgoal):\n 1. map_of l \\<subseteq>\\<^sub>m m", "by (metis (no_types, hide_lams) domIff map_le_def map_of_SomeD not_Some_eq)"], ["", "lemma [simp]: \"fst \\<circ> (\\<lambda>(a, b, c, d). (f a b c d, g a b c d)) = (\\<lambda>(a,b,c,d). f a b c d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst \\<circ> (\\<lambda>(a, b, c, d). (f a b c d, g a b c d)) =\n    (\\<lambda>(a, b, c, d). f a b c d)", "by auto"], ["", "lemma map_mp: \"m\\<subseteq>\\<^sub>mm' \\<Longrightarrow> m k = Some v \\<Longrightarrow> m' k = Some v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>m \\<subseteq>\\<^sub>m m'; m k = Some v\\<rbrakk>\n    \\<Longrightarrow> m' k = Some v", "by (auto simp: map_le_def dom_def)"], ["", "lemma map_add_map_of_fold: \n    fixes ps and m :: \"'a \\<rightharpoonup> 'b\"\n    assumes \"distinct (map fst ps)\"\n    shows \"m ++ map_of ps = fold (\\<lambda>(k, v) m. m(k \\<mapsto> v)) ps m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m ++ map_of ps = fold (\\<lambda>(k, v) m. m(k \\<mapsto> v)) ps m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. m ++ map_of ps = fold (\\<lambda>(k, v) m. m(k \\<mapsto> v)) ps m", "have X1: \"fold (\\<lambda>(k, v) m. m(k \\<mapsto> v)) ps m(a \\<mapsto> b) \n            = fold (\\<lambda>(k, v) m. m(k \\<mapsto> v)) ps (m(a \\<mapsto> b))\" \n      if \"a \\<notin> fst ` set ps\"\n      for a b ps and m :: \"'a \\<rightharpoonup> 'b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>(k, v) m. m(k \\<mapsto> v)) ps m(a \\<mapsto> b) =\n    fold (\\<lambda>(k, v) m. m(k \\<mapsto> v)) ps (m(a \\<mapsto> b))", "using that"], ["proof (prove)\nusing this:\n  a \\<notin> fst ` set ps\n\ngoal (1 subgoal):\n 1. fold (\\<lambda>(k, v) m. m(k \\<mapsto> v)) ps m(a \\<mapsto> b) =\n    fold (\\<lambda>(k, v) m. m(k \\<mapsto> v)) ps (m(a \\<mapsto> b))", "by (induction ps arbitrary: m) (auto simp: fun_upd_twist)"], ["proof (state)\nthis:\n  ?a \\<notin> fst ` set ?ps \\<Longrightarrow>\n  fold (\\<lambda>(k, v) m. m(k \\<mapsto> v)) ?ps ?m(?a \\<mapsto> ?b) =\n  fold (\\<lambda>(k, v) m. m(k \\<mapsto> v)) ?ps (?m(?a \\<mapsto> ?b))\n\ngoal (1 subgoal):\n 1. m ++ map_of ps = fold (\\<lambda>(k, v) m. m(k \\<mapsto> v)) ps m", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. m ++ map_of ps = fold (\\<lambda>(k, v) m. m(k \\<mapsto> v)) ps m", "using assms"], ["proof (prove)\nusing this:\n  distinct (map fst ps)\n\ngoal (1 subgoal):\n 1. m ++ map_of ps = fold (\\<lambda>(k, v) m. m(k \\<mapsto> v)) ps m", "by (induction ps arbitrary: m) (auto simp: X1)"], ["proof (state)\nthis:\n  m ++ map_of ps = fold (\\<lambda>(k, v) m. m(k \\<mapsto> v)) ps m\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Well-formedness Check\\<close>"], ["", "lemmas wf_code_thms = \n      ast_problem.astDom_def ast_problem.astI_def ast_problem.astG_def ast_problem.ast\\<delta>_def\n      ast_problem.numVars_def ast_problem.numVals_def \n      ast_problem.wf_partial_state_def ast_problem.wf_operator_def ast_problem.well_formed_def"], ["", "declare wf_code_thms[code]"], ["", "export_code ast_problem.well_formed in SML"], ["", "subsection \\<open>Execution\\<close>"], ["", "definition match_pre :: \"ast_precond \\<Rightarrow> state \\<Rightarrow> bool\" where\n    \"match_pre \\<equiv> \\<lambda>(x,v) s. s x = Some v\""], ["", "definition match_pres :: \"ast_precond list \\<Rightarrow> state \\<Rightarrow> bool\" where \n    \"match_pres pres s \\<equiv> \\<forall>pre\\<in>set pres. match_pre pre s\""], ["", "definition match_implicit_pres :: \"ast_effect list \\<Rightarrow> state \\<Rightarrow> bool\" where\n    \"match_implicit_pres effs s \\<equiv> \\<forall>(_,x,vp,_)\\<in>set effs. \n      (case vp of None \\<Rightarrow> True | Some v \\<Rightarrow> s x = Some v)\""], ["", "definition enabled_opr' :: \"ast_operator \\<Rightarrow> state \\<Rightarrow> bool\" where \n    \"enabled_opr' \\<equiv> \\<lambda>(name,pres,effs,cost) s. match_pres pres s \\<and> match_implicit_pres effs s\""], ["", "definition eff_enabled' :: \"state \\<Rightarrow> ast_effect \\<Rightarrow> bool\" where\n    \"eff_enabled' s \\<equiv> \\<lambda>(pres,_,_,_). match_pres pres s\""], ["", "definition \"execute_opr' \\<equiv> \\<lambda>(name,_,effs,_) s. \n    let effs = filter (eff_enabled' s) effs\n    in fold (\\<lambda>(_,x,_,v) s. s(x\\<mapsto>v)) effs s\n  \""], ["", "definition lookup_operator' :: \"ast_problem \\<Rightarrow> name \\<rightharpoonup> ast_operator\" \n    where \"lookup_operator' \\<equiv> \\<lambda>(D,I,G,\\<delta>) name. find (\\<lambda>(n,_,_,_). n=name) \\<delta>\""], ["", "definition enabled' :: \"ast_problem \\<Rightarrow> name \\<Rightarrow> state \\<Rightarrow> bool\" where\n    \"enabled' problem name s \\<equiv> \n      case lookup_operator' problem name of \n        Some \\<pi> \\<Rightarrow> enabled_opr' \\<pi> s\n      | None \\<Rightarrow> False\""], ["", "definition execute' :: \"ast_problem \\<Rightarrow> name \\<Rightarrow> state \\<Rightarrow> state\" where\n    \"execute' problem name s \\<equiv> \n      case lookup_operator' problem name of \n        Some \\<pi> \\<Rightarrow> execute_opr' \\<pi> s\n      | None \\<Rightarrow> undefined\""], ["", "context wf_ast_problem begin"], ["", "lemma match_pres_correct:\n      assumes D: \"distinct (map fst pres)\"\n      assumes \"s\\<in>valid_states\"  \n      shows \"match_pres pres s \\<longleftrightarrow> s\\<in>subsuming_states (map_of pres)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match_pres pres s = (s \\<in> subsuming_states (map_of pres))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. match_pres pres s = (s \\<in> subsuming_states (map_of pres))", "have \"match_pres pres s \\<longleftrightarrow> map_of pres \\<subseteq>\\<^sub>m s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match_pres pres s = (map_of pres \\<subseteq>\\<^sub>m s)", "unfolding match_pres_def match_pre_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>pre\\<in>set pres.\n        (case pre of (x, v) \\<Rightarrow> \\<lambda>s. s x = Some v) s) =\n    (map_of pres \\<subseteq>\\<^sub>m s)", "apply (auto split: prod.splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>pre\\<in>set pres.\n       \\<forall>x1 x2.\n          pre = (x1, x2) \\<longrightarrow> s x1 = Some x2 \\<Longrightarrow>\n    map_of pres \\<subseteq>\\<^sub>m s\n 2. \\<And>x1 x2.\n       \\<lbrakk>map_of pres \\<subseteq>\\<^sub>m s;\n        (x1, x2) \\<in> set pres\\<rbrakk>\n       \\<Longrightarrow> s x1 = Some x2", "using map_le_def map_of_SomeD"], ["proof (prove)\nusing this:\n  (?m\\<^sub>1 \\<subseteq>\\<^sub>m ?m\\<^sub>2) =\n  (\\<forall>a\\<in>dom ?m\\<^sub>1. ?m\\<^sub>1 a = ?m\\<^sub>2 a)\n  map_of ?xs ?k = Some ?y \\<Longrightarrow> (?k, ?y) \\<in> set ?xs\n\ngoal (2 subgoals):\n 1. \\<forall>pre\\<in>set pres.\n       \\<forall>x1 x2.\n          pre = (x1, x2) \\<longrightarrow> s x1 = Some x2 \\<Longrightarrow>\n    map_of pres \\<subseteq>\\<^sub>m s\n 2. \\<And>x1 x2.\n       \\<lbrakk>map_of pres \\<subseteq>\\<^sub>m s;\n        (x1, x2) \\<in> set pres\\<rbrakk>\n       \\<Longrightarrow> s x1 = Some x2", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       \\<lbrakk>map_of pres \\<subseteq>\\<^sub>m s;\n        (x1, x2) \\<in> set pres\\<rbrakk>\n       \\<Longrightarrow> s x1 = Some x2", "by (metis (full_types) D domIff map_le_def map_of_eq_Some_iff option.simps(3))"], ["proof (state)\nthis:\n  match_pres pres s = (map_of pres \\<subseteq>\\<^sub>m s)\n\ngoal (1 subgoal):\n 1. match_pres pres s = (s \\<in> subsuming_states (map_of pres))", "with assms"], ["proof (chain)\npicking this:\n  distinct (map fst pres)\n  s \\<in> valid_states\n  match_pres pres s = (map_of pres \\<subseteq>\\<^sub>m s)", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct (map fst pres)\n  s \\<in> valid_states\n  match_pres pres s = (map_of pres \\<subseteq>\\<^sub>m s)\n\ngoal (1 subgoal):\n 1. match_pres pres s = (s \\<in> subsuming_states (map_of pres))", "unfolding subsuming_states_def"], ["proof (prove)\nusing this:\n  distinct (map fst pres)\n  s \\<in> valid_states\n  match_pres pres s = (map_of pres \\<subseteq>\\<^sub>m s)\n\ngoal (1 subgoal):\n 1. match_pres pres s =\n    (s \\<in> {s \\<in> valid_states. map_of pres \\<subseteq>\\<^sub>m s})", "by auto"], ["proof (state)\nthis:\n  match_pres pres s = (s \\<in> subsuming_states (map_of pres))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma match_implicit_pres_correct:\n      assumes D: \"distinct (map (\\<lambda>(_, v, _, _). v) effs)\"\n      assumes \"s\\<in>valid_states\"  \n      shows \"match_implicit_pres effs s \\<longleftrightarrow> s\\<in>subsuming_states (map_of (implicit_pres effs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match_implicit_pres effs s =\n    (s \\<in> subsuming_states (map_of (implicit_pres effs)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. match_implicit_pres effs s =\n    (s \\<in> subsuming_states (map_of (implicit_pres effs)))", "from assms"], ["proof (chain)\npicking this:\n  distinct (map (\\<lambda>(uu_, v, uu_, uu_). v) effs)\n  s \\<in> valid_states", "show ?thesis"], ["proof (prove)\nusing this:\n  distinct (map (\\<lambda>(uu_, v, uu_, uu_). v) effs)\n  s \\<in> valid_states\n\ngoal (1 subgoal):\n 1. match_implicit_pres effs s =\n    (s \\<in> subsuming_states (map_of (implicit_pres effs)))", "unfolding subsuming_states_def"], ["proof (prove)\nusing this:\n  distinct (map (\\<lambda>(uu_, v, uu_, uu_). v) effs)\n  s \\<in> valid_states\n\ngoal (1 subgoal):\n 1. match_implicit_pres effs s =\n    (s \\<in> {s \\<in> valid_states.\n              map_of (implicit_pres effs) \\<subseteq>\\<^sub>m s})", "unfolding match_implicit_pres_def implicit_pres_def"], ["proof (prove)\nusing this:\n  distinct (map (\\<lambda>(uu_, v, uu_, uu_). v) effs)\n  s \\<in> valid_states\n\ngoal (1 subgoal):\n 1. (\\<forall>(uu_, x, vp, uu_)\\<in>set effs.\n        case vp of None \\<Rightarrow> True\n        | Some v \\<Rightarrow> s x = Some v) =\n    (s \\<in> {s \\<in> valid_states.\n              map_of\n               (map (\\<lambda>(uu_, v, vpre, uu_). (v, the vpre))\n                 (filter\n                   (\\<lambda>(uu_, uu_, vpre, uu_). vpre \\<noteq> None)\n                   effs)) \\<subseteq>\\<^sub>m\n              s})", "apply (auto \n            split: prod.splits option.splits \n            simp: distinct_map_filter\n            intro!: map_of_leI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 ac x2 ba.\n       \\<lbrakk>distinct (map (\\<lambda>(uu_, v, uu_, uu_). v) effs);\n        s \\<in> valid_states;\n        map_of\n         (map (\\<lambda>(uu_, v, vpre, uu_). (v, the vpre))\n           (filter\n             (\\<lambda>(uu_, uu_, vpre, uu_). \\<exists>y. vpre = Some y)\n             effs)) \\<subseteq>\\<^sub>m\n        s;\n        (x1, ac, Some x2, ba) \\<in> set effs\\<rbrakk>\n       \\<Longrightarrow> s ac = Some x2", "apply (force simp: distinct_map_filter split: prod.split elim: map_mp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  match_implicit_pres effs s =\n  (s \\<in> subsuming_states (map_of (implicit_pres effs)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma enabled_opr'_correct:\n      assumes V: \"s\\<in>valid_states\"\n      assumes \"lookup_operator name = Some \\<pi>\"  \n      shows \"enabled_opr' \\<pi> s \\<longleftrightarrow> enabled name s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enabled_opr' \\<pi> s = enabled name s", "using lookup_operator_wf[OF assms(2)] assms"], ["proof (prove)\nusing this:\n  wf_operator \\<pi>\n  fst \\<pi> = name\n  s \\<in> valid_states\n  lookup_operator name = Some \\<pi>\n\ngoal (1 subgoal):\n 1. enabled_opr' \\<pi> s = enabled name s", "unfolding enabled_opr'_def enabled_def wf_operator_def"], ["proof (prove)\nusing this:\n  case \\<pi> of\n  (name, pres, effs, cost) \\<Rightarrow>\n    wf_partial_state pres \\<and>\n    distinct (map (\\<lambda>(uu_, v, uu_, uu_). v) effs) \\<and>\n    (\\<forall>(epres, x, vp, v)\\<in>set effs.\n        wf_partial_state epres \\<and>\n        x < numVars \\<and>\n        v < numVals x \\<and>\n        (case vp of None \\<Rightarrow> True\n         | Some v \\<Rightarrow> v < numVals x))\n  fst \\<pi> = name\n  s \\<in> valid_states\n  lookup_operator name = Some \\<pi>\n\ngoal (1 subgoal):\n 1. (case \\<pi> of\n     (name, pres, effs, cost) \\<Rightarrow>\n       \\<lambda>s. match_pres pres s \\<and> match_implicit_pres effs s)\n     s =\n    (case lookup_operator name of None \\<Rightarrow> False\n     | Some (x, pres, effs, xa) \\<Rightarrow>\n         s \\<in> subsuming_states (map_of pres) \\<and>\n         s \\<in> subsuming_states (map_of (implicit_pres effs)))", "by (auto \n          simp: match_pres_correct[OF _ V] match_implicit_pres_correct[OF _ V]\n          simp: wf_partial_state_def\n          split: option.split\n          )"], ["", "lemma eff_enabled'_correct:\n      assumes V: \"s\\<in>valid_states\"\n      assumes \"case eff of (pres,_,_,_) \\<Rightarrow> wf_partial_state pres\"  \n      shows \"eff_enabled' s eff \\<longleftrightarrow> eff_enabled s eff\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eff_enabled' s eff = eff_enabled s eff", "using assms"], ["proof (prove)\nusing this:\n  s \\<in> valid_states\n  case eff of (pres, x, xa, xb) \\<Rightarrow> wf_partial_state pres\n\ngoal (1 subgoal):\n 1. eff_enabled' s eff = eff_enabled s eff", "unfolding eff_enabled'_def eff_enabled_def wf_partial_state_def"], ["proof (prove)\nusing this:\n  s \\<in> valid_states\n  case eff of\n  (pres, x, xa, xb) \\<Rightarrow>\n    distinct (map fst pres) \\<and>\n    (\\<forall>(x, v)\\<in>set pres. x < numVars \\<and> v < numVals x)\n\ngoal (1 subgoal):\n 1. (case eff of (pres, uu_, uua_, uub_) \\<Rightarrow> match_pres pres s) =\n    (case eff of\n     (pres, uu_, uua_, uub_) \\<Rightarrow>\n       s \\<in> subsuming_states (map_of pres))", "by (auto simp: match_pres_correct)"], ["", "lemma execute_opr'_correct:\n      assumes V: \"s\\<in>valid_states\"\n      assumes LO: \"lookup_operator name = Some \\<pi>\"  \n      shows \"execute_opr' \\<pi> s = execute name s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_opr' \\<pi> s = execute name s", "proof (cases \\<pi>)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<pi> = (a, b, c, d) \\<Longrightarrow>\n       execute_opr' \\<pi> s = execute name s", "case [simp]: (fields name pres effs)"], ["proof (state)\nthis:\n  \\<pi> = (name, pres, effs, d_)\n\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<pi> = (a, b, c, d) \\<Longrightarrow>\n       execute_opr' \\<pi> s = execute name s", "have [simp]: \"filter (eff_enabled' s) effs = filter (eff_enabled s) effs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. filter (eff_enabled' s) effs = filter (eff_enabled s) effs", "apply (rule filter_cong[OF refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set effs \\<Longrightarrow> eff_enabled' s x = eff_enabled s x", "apply (rule eff_enabled'_correct[OF V])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set effs \\<Longrightarrow>\n       case x of (pres, x, xa, xb) \\<Rightarrow> wf_partial_state pres", "using lookup_operator_wf[OF LO]"], ["proof (prove)\nusing this:\n  wf_operator \\<pi>\n  fst \\<pi> = name\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set effs \\<Longrightarrow>\n       case x of (pres, x, xa, xb) \\<Rightarrow> wf_partial_state pres", "unfolding wf_operator_def"], ["proof (prove)\nusing this:\n  case \\<pi> of\n  (name, pres, effs, cost) \\<Rightarrow>\n    wf_partial_state pres \\<and>\n    distinct (map (\\<lambda>(uu_, v, uu_, uu_). v) effs) \\<and>\n    (\\<forall>(epres, x, vp, v)\\<in>set effs.\n        wf_partial_state epres \\<and>\n        x < numVars \\<and>\n        v < numVals x \\<and>\n        (case vp of None \\<Rightarrow> True\n         | Some v \\<Rightarrow> v < numVals x))\n  fst \\<pi> = name\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> set effs \\<Longrightarrow>\n       case x of (pres, x, xa, xb) \\<Rightarrow> wf_partial_state pres", "by auto"], ["proof (state)\nthis:\n  filter (eff_enabled' s) effs = filter (eff_enabled s) effs\n\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<pi> = (a, b, c, d) \\<Longrightarrow>\n       execute_opr' \\<pi> s = execute name s", "have X1: \"distinct (map fst (map (\\<lambda>(_, x, _, y). (x, y)) (filter (eff_enabled s) effs)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct\n     (map fst\n       (map (\\<lambda>(uu_, x, uu_, y). (x, y))\n         (filter (eff_enabled s) effs)))", "using lookup_operator_wf[OF LO]"], ["proof (prove)\nusing this:\n  wf_operator \\<pi>\n  fst \\<pi> = name\n\ngoal (1 subgoal):\n 1. distinct\n     (map fst\n       (map (\\<lambda>(uu_, x, uu_, y). (x, y))\n         (filter (eff_enabled s) effs)))", "unfolding wf_operator_def"], ["proof (prove)\nusing this:\n  case \\<pi> of\n  (name, pres, effs, cost) \\<Rightarrow>\n    wf_partial_state pres \\<and>\n    distinct (map (\\<lambda>(uu_, v, uu_, uu_). v) effs) \\<and>\n    (\\<forall>(epres, x, vp, v)\\<in>set effs.\n        wf_partial_state epres \\<and>\n        x < numVars \\<and>\n        v < numVals x \\<and>\n        (case vp of None \\<Rightarrow> True\n         | Some v \\<Rightarrow> v < numVals x))\n  fst \\<pi> = name\n\ngoal (1 subgoal):\n 1. distinct\n     (map fst\n       (map (\\<lambda>(uu_, x, uu_, y). (x, y))\n         (filter (eff_enabled s) effs)))", "by (auto simp: distinct_map_filter)"], ["proof (state)\nthis:\n  distinct\n   (map fst\n     (map (\\<lambda>(uu_, x, uu_, y). (x, y))\n       (filter (eff_enabled s) effs)))\n\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<pi> = (a, b, c, d) \\<Longrightarrow>\n       execute_opr' \\<pi> s = execute name s", "term \"filter (eff_enabled s) effs\""], ["proof (state)\nthis:\n  distinct\n   (map fst\n     (map (\\<lambda>(uu_, x, uu_, y). (x, y))\n       (filter (eff_enabled s) effs)))\n\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<pi> = (a, b, c, d) \\<Longrightarrow>\n       execute_opr' \\<pi> s = execute name s", "have [simp]: \n        \"fold (\\<lambda>(_, x, _, v) s. s(x \\<mapsto> v)) l s =\n         fold (\\<lambda>(k, v) m. m(k \\<mapsto> v)) (map (\\<lambda>(_, x, _, y). (x, y)) l) s\" \n        for l :: \"ast_effect list\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fold (\\<lambda>(uu_, x, uu_, v) s. s(x \\<mapsto> v)) l s =\n    fold (\\<lambda>(k, v) m. m(k \\<mapsto> v))\n     (map (\\<lambda>(uu_, x, uu_, y). (x, y)) l) s", "by (induction l arbitrary: s) auto"], ["proof (state)\nthis:\n  fold (\\<lambda>(uu_, x, uu_, v) s. s(x \\<mapsto> v)) ?l s =\n  fold (\\<lambda>(k, v) m. m(k \\<mapsto> v))\n   (map (\\<lambda>(uu_, x, uu_, y). (x, y)) ?l) s\n\ngoal (1 subgoal):\n 1. \\<And>a b c d.\n       \\<pi> = (a, b, c, d) \\<Longrightarrow>\n       execute_opr' \\<pi> s = execute name s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. execute_opr' \\<pi> s = execute name s", "unfolding execute_opr'_def execute_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case \\<pi> of\n     (name, uu_, effs, uua_) \\<Rightarrow>\n       \\<lambda>s.\n          let effs = filter (eff_enabled' s) effs\n          in fold (\\<lambda>(uu_, x, uu_, v) s. s(x \\<mapsto> v)) effs s)\n     s =\n    (case lookup_operator name of\n     Some (x, xa, effs, xb) \\<Rightarrow>\n       s ++\n       map_of\n        (map (\\<lambda>(uu_, x, uu_, v). (x, v))\n          (filter (eff_enabled s) effs)))", "using LO"], ["proof (prove)\nusing this:\n  lookup_operator name = Some \\<pi>\n\ngoal (1 subgoal):\n 1. (case \\<pi> of\n     (name, uu_, effs, uua_) \\<Rightarrow>\n       \\<lambda>s.\n          let effs = filter (eff_enabled' s) effs\n          in fold (\\<lambda>(uu_, x, uu_, v) s. s(x \\<mapsto> v)) effs s)\n     s =\n    (case lookup_operator name of\n     Some (x, xa, effs, xb) \\<Rightarrow>\n       s ++\n       map_of\n        (map (\\<lambda>(uu_, x, uu_, v). (x, v))\n          (filter (eff_enabled s) effs)))", "by (auto simp: map_add_map_of_fold[OF X1])"], ["proof (state)\nthis:\n  execute_opr' \\<pi> s = execute name s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lookup_operator'_correct: \n      \"lookup_operator' problem name = lookup_operator name\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup_operator' problem name = lookup_operator name", "unfolding lookup_operator'_def lookup_operator_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case problem of\n     (D, I, G, \\<delta>) \\<Rightarrow>\n       \\<lambda>name. find (\\<lambda>(n, uu_, uu_, uu_). n = name) \\<delta>)\n     name =\n    find (\\<lambda>(n, uu_, uu_, uu_). n = name) ast\\<delta>", "unfolding ast\\<delta>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case problem of\n     (D, I, G, \\<delta>) \\<Rightarrow>\n       \\<lambda>name. find (\\<lambda>(n, uu_, uu_, uu_). n = name) \\<delta>)\n     name =\n    find (\\<lambda>(n, uu_, uu_, uu_). n = name)\n     (case problem of (D, I, G, \\<delta>) \\<Rightarrow> \\<delta>)", "by (auto split: prod.split)"], ["", "lemma enabled'_correct:\n      assumes V: \"s\\<in>valid_states\"\n      shows \"enabled' problem name s = enabled name s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enabled' problem name s = enabled name s", "unfolding enabled'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case lookup_operator' problem name of None \\<Rightarrow> False\n     | Some \\<pi> \\<Rightarrow> enabled_opr' \\<pi> s) =\n    enabled name s", "using enabled_opr'_correct[OF V]"], ["proof (prove)\nusing this:\n  lookup_operator ?name = Some ?\\<pi> \\<Longrightarrow>\n  enabled_opr' ?\\<pi> s = enabled ?name s\n\ngoal (1 subgoal):\n 1. (case lookup_operator' problem name of None \\<Rightarrow> False\n     | Some \\<pi> \\<Rightarrow> enabled_opr' \\<pi> s) =\n    enabled name s", "by (auto split: option.splits simp: enabled_def lookup_operator'_correct)"], ["", "lemma execute'_correct:\n      assumes V: \"s\\<in>valid_states\"\n      assumes \"enabled name s\"      (* Intentionally put this here, also we could resolve non-enabled case by reflexivity (undefined=undefined) *)\n      shows \"execute' problem name s = execute name s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. execute' problem name s = execute name s", "unfolding execute'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case lookup_operator' problem name of\n     Some \\<pi> \\<Rightarrow> execute_opr' \\<pi> s) =\n    execute name s", "using execute_opr'_correct[OF V] \\<open>enabled name s\\<close>"], ["proof (prove)\nusing this:\n  lookup_operator ?name = Some ?\\<pi> \\<Longrightarrow>\n  execute_opr' ?\\<pi> s = execute ?name s\n  enabled name s\n\ngoal (1 subgoal):\n 1. (case lookup_operator' problem name of\n     Some \\<pi> \\<Rightarrow> execute_opr' \\<pi> s) =\n    execute name s", "by (auto split: option.splits simp: enabled_def lookup_operator'_correct)"], ["", "end"], ["", "context ast_problem \n  begin"], ["", "fun simulate_plan :: \"plan \\<Rightarrow> state \\<rightharpoonup> state\" where\n      \"simulate_plan [] s = Some s\"\n    | \"simulate_plan (\\<pi>#\\<pi>s) s = (\n        if enabled \\<pi> s then \n          let s' = execute \\<pi> s in\n          simulate_plan \\<pi>s s'\n        else\n          None\n      )\""], ["", "lemma simulate_plan_correct: \"simulate_plan \\<pi>s s = Some s' \\<longleftrightarrow> path_to s \\<pi>s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (simulate_plan \\<pi>s s = Some s') = path_to s \\<pi>s s'", "by (induction s \\<pi>s s' rule: path_to.induct) auto"], ["", "definition check_plan :: \"plan \\<Rightarrow> bool\" where\n      \"check_plan \\<pi>s = (\n        case simulate_plan \\<pi>s I of \n          None \\<Rightarrow> False \n        | Some s' \\<Rightarrow> s' \\<in> G)\""], ["", "lemma check_plan_correct: \"check_plan \\<pi>s \\<longleftrightarrow> valid_plan \\<pi>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check_plan \\<pi>s = valid_plan \\<pi>s", "unfolding check_plan_def valid_plan_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case simulate_plan \\<pi>s I of None \\<Rightarrow> False\n     | Some s' \\<Rightarrow> s' \\<in> G) =\n    (\\<exists>s'\\<in>G. path_to I \\<pi>s s')", "by (auto split: option.split simp: simulate_plan_correct[symmetric])"], ["", "end"], ["", "fun simulate_plan' :: \"ast_problem \\<Rightarrow> plan \\<Rightarrow> state \\<rightharpoonup> state\" where\n    \"simulate_plan' problem [] s = Some s\"\n  | \"simulate_plan' problem (\\<pi>#\\<pi>s) s = (\n      if enabled' problem \\<pi> s then\n        let s = execute' problem \\<pi> s in\n        simulate_plan' problem \\<pi>s s\n      else\n        None\n    )\""], ["", "text \\<open>Avoiding duplicate lookup.\\<close>"], ["", "(*[code]  *)"], ["", "lemma simulate_plan'_code[code]:\n    \"simulate_plan' problem [] s = Some s\"\n    \"simulate_plan' problem (\\<pi>#\\<pi>s) s = (\n      case lookup_operator' problem \\<pi> of\n        None \\<Rightarrow> None\n      | Some \\<pi> \\<Rightarrow> \n          if enabled_opr' \\<pi> s then \n            simulate_plan' problem \\<pi>s (execute_opr' \\<pi> s)\n          else None\n    )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simulate_plan' problem [] s = Some s &&&\n    simulate_plan' problem (\\<pi> # \\<pi>s) s =\n    (case lookup_operator' problem \\<pi> of None \\<Rightarrow> None\n     | Some \\<pi> \\<Rightarrow>\n         if enabled_opr' \\<pi> s\n         then simulate_plan' problem \\<pi>s (execute_opr' \\<pi> s)\n         else None)", "by (auto simp: enabled'_def execute'_def split: option.split)"], ["", "definition initial_state' :: \"ast_problem \\<Rightarrow> state\" where\n    \"initial_state' problem \\<equiv> let astI = ast_problem.astI problem in (\n       \\<lambda>v. if v<length astI then Some (astI!v) else None\n     )\""], ["", "definition check_plan' :: \"ast_problem \\<Rightarrow> plan \\<Rightarrow> bool\" where\n    \"check_plan' problem \\<pi>s = (\n      case simulate_plan' problem \\<pi>s (initial_state' problem) of \n        None \\<Rightarrow> False \n      | Some s' \\<Rightarrow> match_pres (ast_problem.astG problem) s')\""], ["", "context wf_ast_problem \n  begin"], ["", "lemma simulate_plan'_correct:\n      assumes \"s\\<in>valid_states\"\n      shows \"simulate_plan' problem \\<pi>s s = simulate_plan \\<pi>s s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. simulate_plan' problem \\<pi>s s = simulate_plan \\<pi>s s", "using assms"], ["proof (prove)\nusing this:\n  s \\<in> valid_states\n\ngoal (1 subgoal):\n 1. simulate_plan' problem \\<pi>s s = simulate_plan \\<pi>s s", "apply (induction \\<pi>s s rule: simulate_plan.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>s.\n       s \\<in> valid_states \\<Longrightarrow>\n       simulate_plan' problem [] s = simulate_plan [] s\n 2. \\<And>\\<pi> \\<pi>s s.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>enabled \\<pi> s; x = execute \\<pi> s;\n                    x \\<in> valid_states\\<rbrakk>\n                   \\<Longrightarrow> simulate_plan' problem \\<pi>s x =\n                                     simulate_plan \\<pi>s x;\n        s \\<in> valid_states\\<rbrakk>\n       \\<Longrightarrow> simulate_plan' problem (\\<pi> # \\<pi>s) s =\n                         simulate_plan (\\<pi> # \\<pi>s) s", "apply (auto simp: enabled'_correct execute'_correct execute_preserves_valid)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma simulate_plan'_correct_paper: (* For presentation in paper. \n        Summarizing intermediate refinement step. *)\n      assumes \"s\\<in>valid_states\"\n      shows \"simulate_plan' problem \\<pi>s s = Some s'\n            \\<longleftrightarrow> path_to s \\<pi>s s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (simulate_plan' problem \\<pi>s s = Some s') = path_to s \\<pi>s s'", "using simulate_plan'_correct[OF assms] simulate_plan_correct"], ["proof (prove)\nusing this:\n  simulate_plan' problem ?\\<pi>s s = simulate_plan ?\\<pi>s s\n  (simulate_plan ?\\<pi>s ?s = Some ?s') = path_to ?s ?\\<pi>s ?s'\n\ngoal (1 subgoal):\n 1. (simulate_plan' problem \\<pi>s s = Some s') = path_to s \\<pi>s s'", "by simp"], ["", "lemma initial_state'_correct: \n      \"initial_state' problem = I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. initial_state' problem = I", "unfolding initial_state'_def I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (let astI = astI\n     in (\\<lambda>v. if v < length astI then Some (astI ! v) else None)) =\n    (\\<lambda>v. if v < length astI then Some (astI ! v) else None)", "by (auto simp: Let_def)"], ["", "lemma check_plan'_correct:\n      \"check_plan' problem \\<pi>s = check_plan \\<pi>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check_plan' problem \\<pi>s = check_plan \\<pi>s", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. check_plan' problem \\<pi>s = check_plan \\<pi>s", "have D: \"distinct (map fst astG)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. distinct (map fst astG)", "using wf_goal"], ["proof (prove)\nusing this:\n  wf_partial_state astG\n\ngoal (1 subgoal):\n 1. distinct (map fst astG)", "unfolding wf_partial_state_def"], ["proof (prove)\nusing this:\n  distinct (map fst astG) \\<and>\n  (\\<forall>(x, v)\\<in>set astG. x < numVars \\<and> v < numVals x)\n\ngoal (1 subgoal):\n 1. distinct (map fst astG)", "by auto"], ["proof (state)\nthis:\n  distinct (map fst astG)\n\ngoal (1 subgoal):\n 1. check_plan' problem \\<pi>s = check_plan \\<pi>s", "have S'V: \"s'\\<in>valid_states\" if \"simulate_plan \\<pi>s I = Some s'\" for s'"], ["proof (prove)\ngoal (1 subgoal):\n 1. s' \\<in> valid_states", "using that"], ["proof (prove)\nusing this:\n  simulate_plan \\<pi>s I = Some s'\n\ngoal (1 subgoal):\n 1. s' \\<in> valid_states", "by (auto simp: simulate_plan_correct path_to_pres_valid[OF I_valid])"], ["proof (state)\nthis:\n  simulate_plan \\<pi>s I = Some ?s' \\<Longrightarrow> ?s' \\<in> valid_states\n\ngoal (1 subgoal):\n 1. check_plan' problem \\<pi>s = check_plan \\<pi>s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. check_plan' problem \\<pi>s = check_plan \\<pi>s", "unfolding check_plan'_def check_plan_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case simulate_plan' problem \\<pi>s (initial_state' problem) of\n     None \\<Rightarrow> False | Some x \\<Rightarrow> match_pres astG x) =\n    (case simulate_plan \\<pi>s I of None \\<Rightarrow> False\n     | Some s' \\<Rightarrow> s' \\<in> G)", "by (auto \n            split: option.splits \n            simp: initial_state'_correct simulate_plan'_correct[OF I_valid]\n            simp: match_pres_correct[OF D S'V] G_def\n            )"], ["proof (state)\nthis:\n  check_plan' problem \\<pi>s = check_plan \\<pi>s\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* Overall checker *)"], ["", "definition verify_plan :: \"ast_problem \\<Rightarrow> plan \\<Rightarrow> String.literal + unit\" where\n    \"verify_plan problem \\<pi>s = (\n      if ast_problem.well_formed problem then\n        if check_plan' problem \\<pi>s then Inr () else Inl (STR ''Invalid plan'')\n      else Inl (STR ''Problem not well formed'')\n    )\""], ["", "lemma verify_plan_correct:\n    \"verify_plan problem \\<pi>s = Inr () \n    \\<longleftrightarrow> ast_problem.well_formed problem \\<and> ast_problem.valid_plan problem \\<pi>s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (verify_plan problem \\<pi>s = Inr ()) =\n    (ast_problem.well_formed problem \\<and>\n     ast_problem.valid_plan problem \\<pi>s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (verify_plan problem \\<pi>s = Inr ()) =\n    (ast_problem.well_formed problem \\<and>\n     ast_problem.valid_plan problem \\<pi>s)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (verify_plan problem \\<pi>s = Inr ()) =\n    (ast_problem.well_formed problem \\<and>\n     ast_problem.valid_plan problem \\<pi>s)", "assume \"ast_problem.well_formed problem\""], ["proof (state)\nthis:\n  ast_problem.well_formed problem\n\ngoal (1 subgoal):\n 1. (verify_plan problem \\<pi>s = Inr ()) =\n    (ast_problem.well_formed problem \\<and>\n     ast_problem.valid_plan problem \\<pi>s)", "then"], ["proof (chain)\npicking this:\n  ast_problem.well_formed problem", "interpret wf_ast_problem"], ["proof (prove)\nusing this:\n  ast_problem.well_formed problem\n\ngoal (1 subgoal):\n 1. wf_ast_problem problem", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. (verify_plan problem \\<pi>s = Inr ()) =\n    (well_formed \\<and> valid_plan \\<pi>s)", "from check_plan'_correct check_plan_correct"], ["proof (chain)\npicking this:\n  check_plan' problem ?\\<pi>s = check_plan ?\\<pi>s\n  check_plan ?\\<pi>s = valid_plan ?\\<pi>s", "have \"check_plan' problem \\<pi>s = valid_plan \\<pi>s\""], ["proof (prove)\nusing this:\n  check_plan' problem ?\\<pi>s = check_plan ?\\<pi>s\n  check_plan ?\\<pi>s = valid_plan ?\\<pi>s\n\ngoal (1 subgoal):\n 1. check_plan' problem \\<pi>s = valid_plan \\<pi>s", "by simp"], ["proof (state)\nthis:\n  check_plan' problem \\<pi>s = valid_plan \\<pi>s\n\ngoal (1 subgoal):\n 1. (verify_plan problem \\<pi>s = Inr ()) =\n    (well_formed \\<and> valid_plan \\<pi>s)", "}"], ["proof (state)\nthis:\n  ast_problem.well_formed problem \\<Longrightarrow>\n  check_plan' problem \\<pi>s = ast_problem.valid_plan problem \\<pi>s\n\ngoal (1 subgoal):\n 1. (verify_plan problem \\<pi>s = Inr ()) =\n    (ast_problem.well_formed problem \\<and>\n     ast_problem.valid_plan problem \\<pi>s)", "then"], ["proof (chain)\npicking this:\n  ast_problem.well_formed problem \\<Longrightarrow>\n  check_plan' problem \\<pi>s = ast_problem.valid_plan problem \\<pi>s", "show ?thesis"], ["proof (prove)\nusing this:\n  ast_problem.well_formed problem \\<Longrightarrow>\n  check_plan' problem \\<pi>s = ast_problem.valid_plan problem \\<pi>s\n\ngoal (1 subgoal):\n 1. (verify_plan problem \\<pi>s = Inr ()) =\n    (ast_problem.well_formed problem \\<and>\n     ast_problem.valid_plan problem \\<pi>s)", "unfolding verify_plan_def"], ["proof (prove)\nusing this:\n  ast_problem.well_formed problem \\<Longrightarrow>\n  check_plan' problem \\<pi>s = ast_problem.valid_plan problem \\<pi>s\n\ngoal (1 subgoal):\n 1. ((if ast_problem.well_formed problem\n      then if check_plan' problem \\<pi>s then Inr ()\n           else Inl STR ''Invalid plan''\n      else Inl STR ''Problem not well formed'') =\n     Inr ()) =\n    (ast_problem.well_formed problem \\<and>\n     ast_problem.valid_plan problem \\<pi>s)", "by auto"], ["proof (state)\nthis:\n  (verify_plan problem \\<pi>s = Inr ()) =\n  (ast_problem.well_formed problem \\<and>\n   ast_problem.valid_plan problem \\<pi>s)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition nat_opt_of_integer :: \"integer \\<Rightarrow> nat option\" where\n       \"nat_opt_of_integer i = (if (i \\<ge> 0) then Some (nat_of_integer i) else None)\""], ["", "(*Export functions, which includes constructors*)"], ["", "export_code verify_plan nat_of_integer integer_of_nat nat_opt_of_integer Inl Inr String.explode String.implode\n    in SML\n    module_name SASP_Checker_Exported\n    file \"code/SASP_Checker_Exported.sml\""], ["", "end"]]}