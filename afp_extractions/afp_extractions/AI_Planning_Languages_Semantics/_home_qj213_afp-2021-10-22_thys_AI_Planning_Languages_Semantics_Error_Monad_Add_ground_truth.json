{"file_name": "/home/qj213/afp-2021-10-22/thys/AI_Planning_Languages_Semantics/Error_Monad_Add.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/AI_Planning_Languages_Semantics", "problem_names": ["lemma lift_opt_simps[simp]: \n    \"lift_opt None e = error e\"\n    \"lift_opt (Some v) e = return v\"", "lemma reflcl_image_iff[simp]: \"R\\<^sup>=``S = S\\<union>R``S\"", "lemma bind_return_iff[return_iff]: \"Error_Monad.bind m f = Inr y \\<longleftrightarrow> (\\<exists>x. m = Inr x \\<and> f x = Inr y)\"", "lemma lift_opt_return_iff[return_iff]: \"lift_opt m e = Inr x \\<longleftrightarrow> m=Some x\"", "lemma check_return_iff[return_iff]: \"check \\<Phi> e = Inr uu \\<longleftrightarrow> \\<Phi>\"", "lemma check_simps[simp]:  \n    \"check True e = succeed\"\n    \"check False e = error e\"", "lemma Let_return_iff[return_iff]: \"(let x=v in f x) = Inr w \\<longleftrightarrow> f v = Inr w\"", "lemma error_monad_bind_split: \"P (bind m f) \\<longleftrightarrow> (\\<forall>v. m = Inl v \\<longrightarrow> P (Inl v)) \\<and> (\\<forall>v. m = Inr v \\<longrightarrow> P (f v))\"", "lemma error_monad_bind_split_asm: \"P (bind m f) \\<longleftrightarrow> \\<not> (\\<exists>x. m = Inl x \\<and> \\<not> P (Inl x) \\<or> (\\<exists>x. m = Inr x \\<and> \\<not> P (f x)))\"", "lemmas error_monad_bind_splits =error_monad_bind_split error_monad_bind_split_asm"], "translations": [["", "lemma lift_opt_simps[simp]: \n    \"lift_opt None e = error e\"\n    \"lift_opt (Some v) e = return v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lift_opt None e = Inl e &&& lift_opt (Some v) e = Inr v", "by (auto simp: lift_opt_def)"], ["", "(* TODO: Move *)"], ["", "lemma reflcl_image_iff[simp]: \"R\\<^sup>=``S = S\\<union>R``S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R\\<^sup>= `` S = S \\<union> R `` S", "by blast"], ["", "named_theorems return_iff"], ["", "lemma bind_return_iff[return_iff]: \"Error_Monad.bind m f = Inr y \\<longleftrightarrow> (\\<exists>x. m = Inr x \\<and> f x = Inr y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m \\<bind> f = Inr y) = (\\<exists>x. m = Inr x \\<and> f x = Inr y)", "by auto"], ["", "lemma lift_opt_return_iff[return_iff]: \"lift_opt m e = Inr x \\<longleftrightarrow> m=Some x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lift_opt m e = Inr x) = (m = Some x)", "unfolding lift_opt_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((case m of None \\<Rightarrow> Inl e | Some x \\<Rightarrow> Inr x) =\n     Inr x) =\n    (m = Some x)", "by (auto split: option.split)"], ["", "lemma check_return_iff[return_iff]: \"check \\<Phi> e = Inr uu \\<longleftrightarrow> \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (check \\<Phi> e = Inr uu) = \\<Phi>", "by (auto simp: check_def)"], ["", "lemma check_simps[simp]:  \n    \"check True e = succeed\"\n    \"check False e = error e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. check True e = Inr () &&& check False e = Inl e", "by (auto simp: check_def)"], ["", "lemma Let_return_iff[return_iff]: \"(let x=v in f x) = Inr w \\<longleftrightarrow> f v = Inr w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Let v f = Inr w) = (f v = Inr w)", "by simp"], ["", "abbreviation ERR :: \"shows \\<Rightarrow> (unit \\<Rightarrow> shows)\" where \"ERR s \\<equiv> \\<lambda>_. s\""], ["", "abbreviation ERRS :: \"String.literal \\<Rightarrow> (unit \\<Rightarrow> shows)\" where \"ERRS s \\<equiv> ERR (shows s)\""], ["", "lemma error_monad_bind_split: \"P (bind m f) \\<longleftrightarrow> (\\<forall>v. m = Inl v \\<longrightarrow> P (Inl v)) \\<and> (\\<forall>v. m = Inr v \\<longrightarrow> P (f v))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (m \\<bind> f) =\n    ((\\<forall>v. m = Inl v \\<longrightarrow> P (Inl v)) \\<and>\n     (\\<forall>v. m = Inr v \\<longrightarrow> P (f v)))", "by (cases m) auto"], ["", "lemma error_monad_bind_split_asm: \"P (bind m f) \\<longleftrightarrow> \\<not> (\\<exists>x. m = Inl x \\<and> \\<not> P (Inl x) \\<or> (\\<exists>x. m = Inr x \\<and> \\<not> P (f x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (m \\<bind> f) =\n    (\\<nexists>x.\n        m = Inl x \\<and> \\<not> P (Inl x) \\<or>\n        (\\<exists>x. m = Inr x \\<and> \\<not> P (f x)))", "by (cases m) auto"], ["", "lemmas error_monad_bind_splits =error_monad_bind_split error_monad_bind_split_asm"], ["", "end"]]}