{"file_name": "/home/qj213/afp-2021-10-22/thys/AI_Planning_Languages_Semantics/Lifschitz_Consistency.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/AI_Planning_Languages_Semantics", "problem_names": ["lemma close_eq_predAtm[simp]: \"close_eq s (predAtm p xs) \\<longleftrightarrow> s (p,xs)\"", "lemma close_eq_Eq[simp]: \"close_eq s (Eq a b) \\<longleftrightarrow> a=b\"", "lemma sound_opr_alt:\n    \"sound_opr opr f =\n      ((\\<forall>s. s \\<Turnstile>\\<^sub>= (precondition opr) \\<longrightarrow>\n          (\\<exists>s'. f s = (Some s')\n                \\<and> (\\<forall>atm. is_predAtom atm \\<and> atm \\<notin> set(dels (effect opr)) \\<and> s \\<Turnstile>\\<^sub>= atm \\<longrightarrow> s' \\<Turnstile>\\<^sub>= atm)\n                \\<and> (\\<forall>atm. is_predAtom atm \\<and> atm \\<notin> set (adds (effect opr)) \\<and> s \\<Turnstile>\\<^sub>= Not atm \\<longrightarrow> s' \\<Turnstile>\\<^sub>= Not atm)\n                \\<and> (\\<forall>atm. atm \\<in> set(adds (effect opr)) \\<longrightarrow> s' \\<Turnstile>\\<^sub>= atm)\n                \\<and> (\\<forall>fmla. fmla \\<in> set (dels (effect opr)) \\<and> fmla \\<notin> set(adds (effect opr)) \\<longrightarrow> s' \\<Turnstile>\\<^sub>= (Not fmla))\n                \\<and> (\\<forall>a b. s \\<Turnstile>\\<^sub>= Atom (Eq a b) \\<longrightarrow> s' \\<Turnstile>\\<^sub>= Atom (Eq a b))\n                \\<and> (\\<forall>a b. s \\<Turnstile>\\<^sub>= Not (Atom (Eq a b)) \\<longrightarrow> s' \\<Turnstile>\\<^sub>= Not (Atom (Eq a b)))\n                ))\n        \\<and> (\\<forall>fmla\\<in>set(adds (effect opr)). is_predAtom fmla))\"", "lemma compose_actions_Nil[simp]:\n    \"compose_actions [] = Some\"", "lemma compose_actions_Cons[simp]:\n    \"f s = Some s' \\<Longrightarrow> compose_actions (f#fs) s = compose_actions fs s'\"", "theorem STRIPS_sema_sound:\n  assumes \"sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f\"\n    \\<comment> \\<open>For a sound system \\<open>\\<Sigma>\\<close>\\<close>\n  assumes \"set \\<alpha>s \\<subseteq> \\<Sigma>\"\n    \\<comment> \\<open>And a plan \\<open>\\<alpha>s\\<close>\\<close>\n  assumes \"ground_action_path M\\<^sub>0 \\<alpha>s M'\"\n    \\<comment> \\<open>Which is accepted by the system, yielding result \\<open>M'\\<close>\n          (called \\<open>R(\\<alpha>s)\\<close> in Lifschitz's paper~\\cite{lifschitz1987semantics}.)\\<close>\n  obtains s'\n    \\<comment> \\<open>We have that \\<open>f(\\<alpha>s)\\<close> is applicable\n          in initial state, yielding state \\<open>s'\\<close> (called \\<open>f\\<^sub>\\<alpha>\\<^sub>s(s\\<^sub>0)\\<close> in Lifschitz's paper~\\cite{lifschitz1987semantics}.)\\<close>\n  where \"compose_actions (map f \\<alpha>s) s\\<^sub>0 = Some s'\"\n    \\<comment> \\<open>The result world model \\<open>M'\\<close> is satisfied in state \\<open>s'\\<close>\\<close>\n    and \"\\<forall>fmla\\<in>close_world M'. s' \\<Turnstile>\\<^sub>= fmla\"", "theorem STRIPS_sema_sound_compact_version:\n    \"sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f \\<Longrightarrow> set \\<alpha>s \\<subseteq> \\<Sigma>\n    \\<Longrightarrow> ground_action_path M\\<^sub>0 \\<alpha>s M'\n    \\<Longrightarrow> \\<exists>s'. compose_actions (map f \\<alpha>s) s\\<^sub>0 = Some s'\n          \\<and> (\\<forall>fmla\\<in>close_world M'. s' \\<Turnstile>\\<^sub>= fmla)\"", "lemma wm_to_state_eq[simp]: \"wm_to_state M (p, as) \\<longleftrightarrow> Atom (predAtm p as) \\<in> M\"", "lemma wm_to_state_inv[simp]: \"wm_to_state (state_to_wm s) = s\"", "lemma atom_in_wm_eq:\n    \"s \\<Turnstile>\\<^sub>= (formula.Atom atm)\n      \\<longleftrightarrow> ((formula.Atom atm) \\<in> close_eq_M (state_to_wm s))\"", "lemma atom_in_wm_2_eq:\n    \"close_eq (wm_to_state M) \\<Turnstile> (formula.Atom atm)\n      \\<longleftrightarrow> ((formula.Atom atm) \\<in> close_eq_M M)\"", "lemma not_dels_preserved:\n    assumes \"f \\<notin> (set d)\" \" f \\<in> M\"\n    shows \"f \\<in> apply_effect (Effect a d) M\"", "lemma adds_satisfied:\n    assumes \"f \\<in> (set a)\"\n    shows \"f \\<in> apply_effect (Effect a d) M\"", "lemma dels_unsatisfied:\n    assumes \"f \\<in> (set d)\" \"f \\<notin> set a\"\n    shows \"f \\<notin> apply_effect (Effect a d) M\"", "lemma dels_unsatisfied_2:\n    assumes \"f \\<in> set (dels eff)\" \"f \\<notin> set (adds eff)\"\n    shows \"f \\<notin> apply_effect eff M\"", "lemma wf_fmla_atm_is_atom: \"wf_fmla_atom objT f \\<Longrightarrow> is_predAtom f\"", "lemma wf_act_adds_are_atoms:\n    assumes \"wf_effect_inst effs\" \"ae \\<in> set (adds effs)\"\n    shows \"is_predAtom ae\"", "lemma wf_act_adds_dels_atoms:\n    assumes \"wf_effect_inst effs\" \"ae \\<in> set (dels effs)\"\n    shows \"is_predAtom ae\"", "lemma to_state_close_from_state_eq[simp]: \"wm_to_state (close_world (state_to_wm s)) = s\"", "lemma wf_eff_pddl_ground_act_is_sound_opr:\n  assumes \"wf_effect_inst (effect g_opr)\"\n  shows \"sound_opr g_opr ((pddl_opr_to_act g_opr))\"", "lemma wf_eff_impt_wf_eff_inst: \"wf_effect objT eff \\<Longrightarrow> wf_effect_inst eff\"", "lemma wf_pddl_ground_act_is_sound_opr:\n    assumes \"wf_ground_action g_opr\"\n    shows \"sound_opr g_opr (pddl_opr_to_act g_opr)\"", "lemma wf_action_schema_sound_inst:\n    assumes \"action_params_match act args\" \"wf_action_schema act\"\n    shows \"sound_opr\n      (instantiate_action_schema act args)\n      ((pddl_opr_to_act (instantiate_action_schema act args)))\"", "lemma wf_plan_act_is_sound:\n    assumes \"wf_plan_action (PAction n args)\"\n    shows \"sound_opr\n      (instantiate_action_schema (the (resolve_action_schema n)) args)\n      ((pddl_opr_to_act\n        (instantiate_action_schema (the (resolve_action_schema n)) args)))\"", "lemma wf_plan_act_is_sound':\n    assumes \"wf_plan_action \\<pi>\"\n    shows \"sound_opr\n      (resolve_instantiate \\<pi>)\n      ((pddl_opr_to_act (resolve_instantiate \\<pi>)))\"", "lemma wf_world_model_has_atoms: \"f\\<in>M \\<Longrightarrow> wf_world_model M \\<Longrightarrow> is_predAtom f\"", "lemma wm_to_state_works_for_wf_wm_closed:\n    \"wf_world_model M \\<Longrightarrow> fmla\\<in>close_world M \\<Longrightarrow> close_eq (wm_to_state M) \\<Turnstile> fmla\"", "lemma wm_to_state_works_for_wf_wm: \"wf_world_model M \\<Longrightarrow> fmla\\<in>M \\<Longrightarrow> close_eq (wm_to_state M) \\<Turnstile> fmla\"", "lemma wm_to_state_works_for_I_closed:\n    assumes \"x \\<in> close_world I\"\n    shows \"close_eq (wm_to_state I) \\<Turnstile> x\"", "lemma wf_wm_imp_basic: \"wf_world_model M \\<Longrightarrow> wm_basic M\"", "theorem wf_plan_sound_system:\n  assumes \"\\<forall>\\<pi>\\<in> set \\<pi>s. wf_plan_action \\<pi>\"\n  shows \"sound_system\n      (set (map resolve_instantiate \\<pi>s))\n      I\n      (wm_to_state I)\n      ((\\<lambda>\\<alpha>. pddl_opr_to_act \\<alpha>))\"", "theorem wf_plan_soundness_theorem:\n    assumes \"plan_action_path I \\<pi>s M\"\n    defines \"\\<alpha>s \\<equiv> map (pddl_opr_to_act \\<circ> resolve_instantiate) \\<pi>s\"\n    defines \"s\\<^sub>0 \\<equiv> wm_to_state I\"\n    shows \"\\<exists>s'. compose_actions \\<alpha>s s\\<^sub>0 = Some s' \\<and> (\\<forall>\\<phi>\\<in>close_world M. s' \\<Turnstile>\\<^sub>= \\<phi>)\""], "translations": [["", "lemma close_eq_predAtm[simp]: \"close_eq s (predAtm p xs) \\<longleftrightarrow> s (p,xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. close_eq s (predAtm p xs) = s (p, xs)", "by (auto simp: close_eq_def)"], ["", "lemma close_eq_Eq[simp]: \"close_eq s (Eq a b) \\<longleftrightarrow> a=b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. close_eq s (Eq a b) = (a = b)", "by (auto simp: close_eq_def)"], ["", "abbreviation entail_eq :: \"state \\<Rightarrow> object atom formula \\<Rightarrow> bool\" (infix \"\\<Turnstile>\\<^sub>=\" 55)\n    where \"entail_eq s f \\<equiv> close_eq s \\<Turnstile> f\""], ["", "fun sound_opr :: \"ground_action \\<Rightarrow> action \\<Rightarrow> bool\" where\n    \"sound_opr (Ground_Action pre (Effect add del)) f \\<longleftrightarrow>\n      (\\<forall>s. s \\<Turnstile>\\<^sub>= pre \\<longrightarrow>\n        (\\<exists>s'. f s = Some s' \\<and> (\\<forall>atm. is_predAtom atm \\<and> atm \\<notin> set del \\<and> s \\<Turnstile>\\<^sub>= atm \\<longrightarrow> s' \\<Turnstile>\\<^sub>= atm)\n              \\<and>  (\\<forall>atm. is_predAtom atm \\<and> atm \\<notin> set add \\<and> s \\<Turnstile>\\<^sub>= Not atm \\<longrightarrow> s' \\<Turnstile>\\<^sub>= Not atm)\n              \\<and> (\\<forall>fmla. fmla \\<in> set add \\<longrightarrow> s' \\<Turnstile>\\<^sub>= fmla)\n              \\<and> (\\<forall>fmla. fmla \\<in> set del \\<and> fmla \\<notin> set add \\<longrightarrow> s' \\<Turnstile>\\<^sub>= (Not fmla))\n              ))\n        \\<and> (\\<forall>fmla\\<in>set add. is_predAtom fmla)\""], ["", "lemma sound_opr_alt:\n    \"sound_opr opr f =\n      ((\\<forall>s. s \\<Turnstile>\\<^sub>= (precondition opr) \\<longrightarrow>\n          (\\<exists>s'. f s = (Some s')\n                \\<and> (\\<forall>atm. is_predAtom atm \\<and> atm \\<notin> set(dels (effect opr)) \\<and> s \\<Turnstile>\\<^sub>= atm \\<longrightarrow> s' \\<Turnstile>\\<^sub>= atm)\n                \\<and> (\\<forall>atm. is_predAtom atm \\<and> atm \\<notin> set (adds (effect opr)) \\<and> s \\<Turnstile>\\<^sub>= Not atm \\<longrightarrow> s' \\<Turnstile>\\<^sub>= Not atm)\n                \\<and> (\\<forall>atm. atm \\<in> set(adds (effect opr)) \\<longrightarrow> s' \\<Turnstile>\\<^sub>= atm)\n                \\<and> (\\<forall>fmla. fmla \\<in> set (dels (effect opr)) \\<and> fmla \\<notin> set(adds (effect opr)) \\<longrightarrow> s' \\<Turnstile>\\<^sub>= (Not fmla))\n                \\<and> (\\<forall>a b. s \\<Turnstile>\\<^sub>= Atom (Eq a b) \\<longrightarrow> s' \\<Turnstile>\\<^sub>= Atom (Eq a b))\n                \\<and> (\\<forall>a b. s \\<Turnstile>\\<^sub>= Not (Atom (Eq a b)) \\<longrightarrow> s' \\<Turnstile>\\<^sub>= Not (Atom (Eq a b)))\n                ))\n        \\<and> (\\<forall>fmla\\<in>set(adds (effect opr)). is_predAtom fmla))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound_opr opr f =\n    ((\\<forall>s.\n         close_eq s \\<Turnstile>\n         ground_action.precondition opr \\<longrightarrow>\n         (\\<exists>s'.\n             f s = Some s' \\<and>\n             (\\<forall>atm.\n                 is_predAtom atm \\<and>\n                 atm \\<notin> set (dels (ground_action.effect opr)) \\<and>\n                 close_eq s \\<Turnstile> atm \\<longrightarrow>\n                 close_eq s' \\<Turnstile> atm) \\<and>\n             (\\<forall>atm.\n                 is_predAtom atm \\<and>\n                 atm \\<notin> set (adds (ground_action.effect opr)) \\<and>\n                 close_eq s \\<Turnstile>\n                 \\<^bold>\\<not> atm \\<longrightarrow>\n                 close_eq s' \\<Turnstile> \\<^bold>\\<not> atm) \\<and>\n             (\\<forall>atm.\n                 atm\n                 \\<in> set (adds\n                             (ground_action.effect opr)) \\<longrightarrow>\n                 close_eq s' \\<Turnstile> atm) \\<and>\n             (\\<forall>fmla.\n                 fmla \\<in> set (dels (ground_action.effect opr)) \\<and>\n                 fmla\n                 \\<notin> set (adds\n                                (ground_action.effect\n                                  opr)) \\<longrightarrow>\n                 close_eq s' \\<Turnstile> \\<^bold>\\<not> fmla) \\<and>\n             (\\<forall>a b.\n                 close_eq s \\<Turnstile> Atom (Eq a b) \\<longrightarrow>\n                 close_eq s' \\<Turnstile> Atom (Eq a b)) \\<and>\n             (\\<forall>a b.\n                 close_eq s \\<Turnstile>\n                 \\<^bold>\\<not> (Atom (Eq a b)) \\<longrightarrow>\n                 close_eq s' \\<Turnstile>\n                 \\<^bold>\\<not> (Atom (Eq a b))))) \\<and>\n     (\\<forall>fmla\\<in>set (adds (ground_action.effect opr)).\n         is_predAtom fmla))", "by (cases \"(opr,f)\" rule: sound_opr.cases) auto"], ["", "text \\<open>Definition B (v)--(vii) in  Lifschitz's paper~\\cite{lifschitz1987semantics}\\<close>"], ["", "definition sound_system\n    :: \"ground_action set\n      \\<Rightarrow> world_model\n      \\<Rightarrow> state\n      \\<Rightarrow> (ground_action \\<Rightarrow> action)\n      \\<Rightarrow> bool\"\n    where\n    \"sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f \\<longleftrightarrow>\n      ((\\<forall>fmla\\<in>close_world M\\<^sub>0. s\\<^sub>0  \\<Turnstile>\\<^sub>= fmla)\n      \\<and> wm_basic M\\<^sub>0\n      \\<and> (\\<forall>\\<alpha>\\<in>\\<Sigma>. sound_opr \\<alpha> (f \\<alpha>)))\""], ["", "text \\<open>Composing two actions\\<close>"], ["", "definition compose_action :: \"action \\<Rightarrow> action \\<Rightarrow> action\" where\n    \"compose_action f1 f2 x = (case f2 x of Some y \\<Rightarrow> f1 y | None \\<Rightarrow> None)\""], ["", "text \\<open>Composing a list of actions\\<close>"], ["", "definition compose_actions :: \"action list \\<Rightarrow> action\" where\n    \"compose_actions fs \\<equiv> fold compose_action fs Some\""], ["", "text \\<open>Composing a list of actions satisfies some natural lemmas: \\<close>"], ["", "lemma compose_actions_Nil[simp]:\n    \"compose_actions [] = Some\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compose_actions [] = Some", "unfolding compose_actions_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. fold compose_action [] Some = Some", "by auto"], ["", "lemma compose_actions_Cons[simp]:\n    \"f s = Some s' \\<Longrightarrow> compose_actions (f#fs) s = compose_actions fs s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f s = Some s' \\<Longrightarrow>\n    compose_actions (f # fs) s = compose_actions fs s'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f s = Some s' \\<Longrightarrow>\n    compose_actions (f # fs) s = compose_actions fs s'", "interpret monoid_add compose_action Some"], ["proof (prove)\ngoal (1 subgoal):\n 1. class.monoid_add compose_action Some", "apply unfold_locales"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b c.\n       compose_action (compose_action a b) c =\n       compose_action a (compose_action b c)\n 2. \\<And>a. compose_action Some a = a\n 3. \\<And>a. compose_action a Some = a", "unfolding compose_action_def"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b c.\n       (\\<lambda>x.\n           case c x of None \\<Rightarrow> None\n           | Some x \\<Rightarrow>\n               case b x of None \\<Rightarrow> None\n               | Some x \\<Rightarrow> a x) =\n       (\\<lambda>x.\n           case case c x of None \\<Rightarrow> None\n                | Some x \\<Rightarrow> b x of\n           None \\<Rightarrow> None | Some x \\<Rightarrow> a x)\n 2. \\<And>a.\n       (\\<lambda>x.\n           case a x of None \\<Rightarrow> None\n           | Some x \\<Rightarrow> Some x) =\n       a\n 3. \\<And>a.\n       (\\<lambda>x.\n           case Some x of None \\<Rightarrow> None\n           | Some x \\<Rightarrow> a x) =\n       a", "by (auto split: option.split)"], ["proof (state)\ngoal (1 subgoal):\n 1. f s = Some s' \\<Longrightarrow>\n    compose_actions (f # fs) s = compose_actions fs s'", "assume \"f s = Some s'\""], ["proof (state)\nthis:\n  f s = Some s'\n\ngoal (1 subgoal):\n 1. f s = Some s' \\<Longrightarrow>\n    compose_actions (f # fs) s = compose_actions fs s'", "then"], ["proof (chain)\npicking this:\n  f s = Some s'", "show ?thesis"], ["proof (prove)\nusing this:\n  f s = Some s'\n\ngoal (1 subgoal):\n 1. compose_actions (f # fs) s = compose_actions fs s'", "unfolding compose_actions_def"], ["proof (prove)\nusing this:\n  f s = Some s'\n\ngoal (1 subgoal):\n 1. fold compose_action (f # fs) Some s = fold compose_action fs Some s'", "by (simp add: compose_action_def fold_plus_sum_list_rev)"], ["proof (state)\nthis:\n  compose_actions (f # fs) s = compose_actions fs s'\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>Soundness Theorem in Lifschitz's paper~\\cite{lifschitz1987semantics}.\\<close>"], ["", "theorem STRIPS_sema_sound:\n  assumes \"sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f\"\n    \\<comment> \\<open>For a sound system \\<open>\\<Sigma>\\<close>\\<close>\n  assumes \"set \\<alpha>s \\<subseteq> \\<Sigma>\"\n    \\<comment> \\<open>And a plan \\<open>\\<alpha>s\\<close>\\<close>\n  assumes \"ground_action_path M\\<^sub>0 \\<alpha>s M'\"\n    \\<comment> \\<open>Which is accepted by the system, yielding result \\<open>M'\\<close>\n          (called \\<open>R(\\<alpha>s)\\<close> in Lifschitz's paper~\\cite{lifschitz1987semantics}.)\\<close>\n  obtains s'\n    \\<comment> \\<open>We have that \\<open>f(\\<alpha>s)\\<close> is applicable\n          in initial state, yielding state \\<open>s'\\<close> (called \\<open>f\\<^sub>\\<alpha>\\<^sub>s(s\\<^sub>0)\\<close> in Lifschitz's paper~\\cite{lifschitz1987semantics}.)\\<close>\n  where \"compose_actions (map f \\<alpha>s) s\\<^sub>0 = Some s'\"\n    \\<comment> \\<open>The result world model \\<open>M'\\<close> is satisfied in state \\<open>s'\\<close>\\<close>\n    and \"\\<forall>fmla\\<in>close_world M'. s' \\<Turnstile>\\<^sub>= fmla\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        \\<lbrakk>compose_actions (map f \\<alpha>s) s\\<^sub>0 = Some s';\n         \\<forall>fmla\\<in>close_world M'.\n            close_eq s' \\<Turnstile> fmla\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        \\<lbrakk>compose_actions (map f \\<alpha>s) s\\<^sub>0 = Some s';\n         \\<forall>fmla\\<in>close_world M'.\n            close_eq s' \\<Turnstile> fmla\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"(valuation M' \\<Turnstile> fmla)\" if \"wm_basic M'\" \"fmla\\<in>M'\" for fmla"], ["proof (prove)\ngoal (1 subgoal):\n 1. valuation M' \\<Turnstile> fmla", "using that"], ["proof (prove)\nusing this:\n  wm_basic M'\n  fmla \\<in> M'\n\ngoal (1 subgoal):\n 1. valuation M' \\<Turnstile> fmla", "apply (induction fmla)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>wm_basic M'; Atom x \\<in> M'\\<rbrakk>\n       \\<Longrightarrow> valuation M' \\<Turnstile> Atom x\n 2. \\<lbrakk>wm_basic M'; \\<bottom> \\<in> M'\\<rbrakk>\n    \\<Longrightarrow> valuation M' \\<Turnstile> \\<bottom>\n 3. \\<And>fmla.\n       \\<lbrakk>\\<lbrakk>wm_basic M'; fmla \\<in> M'\\<rbrakk>\n                \\<Longrightarrow> valuation M' \\<Turnstile> fmla;\n        wm_basic M'; \\<^bold>\\<not> fmla \\<in> M'\\<rbrakk>\n       \\<Longrightarrow> valuation M' \\<Turnstile> \\<^bold>\\<not> fmla\n 4. \\<And>fmla1 fmla2.\n       \\<lbrakk>\\<lbrakk>wm_basic M'; fmla1 \\<in> M'\\<rbrakk>\n                \\<Longrightarrow> valuation M' \\<Turnstile> fmla1;\n        \\<lbrakk>wm_basic M'; fmla2 \\<in> M'\\<rbrakk>\n        \\<Longrightarrow> valuation M' \\<Turnstile> fmla2;\n        wm_basic M'; fmla1 \\<^bold>\\<and> fmla2 \\<in> M'\\<rbrakk>\n       \\<Longrightarrow> valuation M' \\<Turnstile>\n                         fmla1 \\<^bold>\\<and> fmla2\n 5. \\<And>fmla1 fmla2.\n       \\<lbrakk>\\<lbrakk>wm_basic M'; fmla1 \\<in> M'\\<rbrakk>\n                \\<Longrightarrow> valuation M' \\<Turnstile> fmla1;\n        \\<lbrakk>wm_basic M'; fmla2 \\<in> M'\\<rbrakk>\n        \\<Longrightarrow> valuation M' \\<Turnstile> fmla2;\n        wm_basic M'; fmla1 \\<^bold>\\<or> fmla2 \\<in> M'\\<rbrakk>\n       \\<Longrightarrow> valuation M' \\<Turnstile> fmla1 \\<^bold>\\<or> fmla2\n 6. \\<And>fmla1 fmla2.\n       \\<lbrakk>\\<lbrakk>wm_basic M'; fmla1 \\<in> M'\\<rbrakk>\n                \\<Longrightarrow> valuation M' \\<Turnstile> fmla1;\n        \\<lbrakk>wm_basic M'; fmla2 \\<in> M'\\<rbrakk>\n        \\<Longrightarrow> valuation M' \\<Turnstile> fmla2;\n        wm_basic M'; fmla1 \\<^bold>\\<rightarrow> fmla2 \\<in> M'\\<rbrakk>\n       \\<Longrightarrow> valuation M' \\<Turnstile>\n                         fmla1 \\<^bold>\\<rightarrow> fmla2", "by (auto simp: valuation_def wm_basic_def split: atom.split)"], ["proof (state)\nthis:\n  \\<lbrakk>wm_basic M'; ?fmla16 \\<in> M'\\<rbrakk>\n  \\<Longrightarrow> valuation M' \\<Turnstile> ?fmla16\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        \\<lbrakk>compose_actions (map f \\<alpha>s) s\\<^sub>0 = Some s';\n         \\<forall>fmla\\<in>close_world M'.\n            close_eq s' \\<Turnstile> fmla\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<exists>s'. compose_actions (map f \\<alpha>s) s\\<^sub>0 = Some s' \\<and> (\\<forall>fmla\\<in>close_world M'. s' \\<Turnstile>\\<^sub>= fmla)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       compose_actions (map f \\<alpha>s) s\\<^sub>0 = Some s' \\<and>\n       (\\<forall>fmla\\<in>close_world M'. close_eq s' \\<Turnstile> fmla)", "using assms"], ["proof (prove)\nusing this:\n  sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f\n  set \\<alpha>s \\<subseteq> \\<Sigma>\n  ground_action_path M\\<^sub>0 \\<alpha>s M'\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       compose_actions (map f \\<alpha>s) s\\<^sub>0 = Some s' \\<and>\n       (\\<forall>fmla\\<in>close_world M'. close_eq s' \\<Turnstile> fmla)", "proof(induction \\<alpha>s arbitrary: s\\<^sub>0 M\\<^sub>0 )"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s\\<^sub>0 M\\<^sub>0.\n       \\<lbrakk>sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n        set [] \\<subseteq> \\<Sigma>;\n        ground_action_path M\\<^sub>0 [] M'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            compose_actions (map f []) s\\<^sub>0 =\n                            Some s' \\<and>\n                            Ball (close_world M')\n                             ((\\<Turnstile>) (close_eq s'))\n 2. \\<And>a \\<alpha>s s\\<^sub>0 M\\<^sub>0.\n       \\<lbrakk>\\<And>s\\<^sub>0 M\\<^sub>0.\n                   \\<lbrakk>sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n                    set \\<alpha>s \\<subseteq> \\<Sigma>;\n                    ground_action_path M\\<^sub>0 \\<alpha>s M'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>s'.\n  compose_actions (map f \\<alpha>s) s\\<^sub>0 = Some s' \\<and>\n  Ball (close_world M') ((\\<Turnstile>) (close_eq s'));\n        sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n        set (a # \\<alpha>s) \\<subseteq> \\<Sigma>;\n        ground_action_path M\\<^sub>0 (a # \\<alpha>s) M'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            compose_actions (map f (a # \\<alpha>s))\n                             s\\<^sub>0 =\n                            Some s' \\<and>\n                            Ball (close_world M')\n                             ((\\<Turnstile>) (close_eq s'))", "case Nil"], ["proof (state)\nthis:\n  sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f\n  set [] \\<subseteq> \\<Sigma>\n  ground_action_path M\\<^sub>0 [] M'\n\ngoal (2 subgoals):\n 1. \\<And>s\\<^sub>0 M\\<^sub>0.\n       \\<lbrakk>sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n        set [] \\<subseteq> \\<Sigma>;\n        ground_action_path M\\<^sub>0 [] M'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            compose_actions (map f []) s\\<^sub>0 =\n                            Some s' \\<and>\n                            Ball (close_world M')\n                             ((\\<Turnstile>) (close_eq s'))\n 2. \\<And>a \\<alpha>s s\\<^sub>0 M\\<^sub>0.\n       \\<lbrakk>\\<And>s\\<^sub>0 M\\<^sub>0.\n                   \\<lbrakk>sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n                    set \\<alpha>s \\<subseteq> \\<Sigma>;\n                    ground_action_path M\\<^sub>0 \\<alpha>s M'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>s'.\n  compose_actions (map f \\<alpha>s) s\\<^sub>0 = Some s' \\<and>\n  Ball (close_world M') ((\\<Turnstile>) (close_eq s'));\n        sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n        set (a # \\<alpha>s) \\<subseteq> \\<Sigma>;\n        ground_action_path M\\<^sub>0 (a # \\<alpha>s) M'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            compose_actions (map f (a # \\<alpha>s))\n                             s\\<^sub>0 =\n                            Some s' \\<and>\n                            Ball (close_world M')\n                             ((\\<Turnstile>) (close_eq s'))", "then"], ["proof (chain)\npicking this:\n  sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f\n  set [] \\<subseteq> \\<Sigma>\n  ground_action_path M\\<^sub>0 [] M'", "show ?case"], ["proof (prove)\nusing this:\n  sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f\n  set [] \\<subseteq> \\<Sigma>\n  ground_action_path M\\<^sub>0 [] M'\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       compose_actions (map f []) s\\<^sub>0 = Some s' \\<and>\n       (\\<forall>a\\<in>close_world M'. close_eq s' \\<Turnstile> a)", "by (auto simp add: close_world_def compose_action_def sound_system_def)"], ["proof (state)\nthis:\n  \\<exists>s'.\n     compose_actions (map f []) s\\<^sub>0 = Some s' \\<and>\n     (\\<forall>a\\<in>close_world M'. close_eq s' \\<Turnstile> a)\n\ngoal (1 subgoal):\n 1. \\<And>a \\<alpha>s s\\<^sub>0 M\\<^sub>0.\n       \\<lbrakk>\\<And>s\\<^sub>0 M\\<^sub>0.\n                   \\<lbrakk>sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n                    set \\<alpha>s \\<subseteq> \\<Sigma>;\n                    ground_action_path M\\<^sub>0 \\<alpha>s M'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>s'.\n  compose_actions (map f \\<alpha>s) s\\<^sub>0 = Some s' \\<and>\n  Ball (close_world M') ((\\<Turnstile>) (close_eq s'));\n        sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n        set (a # \\<alpha>s) \\<subseteq> \\<Sigma>;\n        ground_action_path M\\<^sub>0 (a # \\<alpha>s) M'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            compose_actions (map f (a # \\<alpha>s))\n                             s\\<^sub>0 =\n                            Some s' \\<and>\n                            Ball (close_world M')\n                             ((\\<Turnstile>) (close_eq s'))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a \\<alpha>s s\\<^sub>0 M\\<^sub>0.\n       \\<lbrakk>\\<And>s\\<^sub>0 M\\<^sub>0.\n                   \\<lbrakk>sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n                    set \\<alpha>s \\<subseteq> \\<Sigma>;\n                    ground_action_path M\\<^sub>0 \\<alpha>s M'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>s'.\n  compose_actions (map f \\<alpha>s) s\\<^sub>0 = Some s' \\<and>\n  Ball (close_world M') ((\\<Turnstile>) (close_eq s'));\n        sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n        set (a # \\<alpha>s) \\<subseteq> \\<Sigma>;\n        ground_action_path M\\<^sub>0 (a # \\<alpha>s) M'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            compose_actions (map f (a # \\<alpha>s))\n                             s\\<^sub>0 =\n                            Some s' \\<and>\n                            Ball (close_world M')\n                             ((\\<Turnstile>) (close_eq s'))", "case ass: (Cons \\<alpha> \\<alpha>s)"], ["proof (state)\nthis:\n  \\<lbrakk>sound_system \\<Sigma> ?M\\<^sub>016 ?s\\<^sub>016 f;\n   set \\<alpha>s \\<subseteq> \\<Sigma>;\n   ground_action_path ?M\\<^sub>016 \\<alpha>s M'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       compose_actions (map f \\<alpha>s) ?s\\<^sub>016 =\n                       Some s' \\<and>\n                       (\\<forall>a\\<in>close_world M'.\n                           close_eq s' \\<Turnstile> a)\n  sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f\n  set (\\<alpha> # \\<alpha>s) \\<subseteq> \\<Sigma>\n  ground_action_path M\\<^sub>0 (\\<alpha> # \\<alpha>s) M'\n\ngoal (1 subgoal):\n 1. \\<And>a \\<alpha>s s\\<^sub>0 M\\<^sub>0.\n       \\<lbrakk>\\<And>s\\<^sub>0 M\\<^sub>0.\n                   \\<lbrakk>sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n                    set \\<alpha>s \\<subseteq> \\<Sigma>;\n                    ground_action_path M\\<^sub>0 \\<alpha>s M'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>s'.\n  compose_actions (map f \\<alpha>s) s\\<^sub>0 = Some s' \\<and>\n  Ball (close_world M') ((\\<Turnstile>) (close_eq s'));\n        sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n        set (a # \\<alpha>s) \\<subseteq> \\<Sigma>;\n        ground_action_path M\\<^sub>0 (a # \\<alpha>s) M'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            compose_actions (map f (a # \\<alpha>s))\n                             s\\<^sub>0 =\n                            Some s' \\<and>\n                            Ball (close_world M')\n                             ((\\<Turnstile>) (close_eq s'))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>sound_system \\<Sigma> ?M\\<^sub>016 ?s\\<^sub>016 f;\n   set \\<alpha>s \\<subseteq> \\<Sigma>;\n   ground_action_path ?M\\<^sub>016 \\<alpha>s M'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       compose_actions (map f \\<alpha>s) ?s\\<^sub>016 =\n                       Some s' \\<and>\n                       (\\<forall>a\\<in>close_world M'.\n                           close_eq s' \\<Turnstile> a)\n  sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f\n  set (\\<alpha> # \\<alpha>s) \\<subseteq> \\<Sigma>\n  ground_action_path M\\<^sub>0 (\\<alpha> # \\<alpha>s) M'", "obtain pre add del where a: \"\\<alpha> = Ground_Action pre (Effect add del)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>sound_system \\<Sigma> ?M\\<^sub>016 ?s\\<^sub>016 f;\n   set \\<alpha>s \\<subseteq> \\<Sigma>;\n   ground_action_path ?M\\<^sub>016 \\<alpha>s M'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       compose_actions (map f \\<alpha>s) ?s\\<^sub>016 =\n                       Some s' \\<and>\n                       (\\<forall>a\\<in>close_world M'.\n                           close_eq s' \\<Turnstile> a)\n  sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f\n  set (\\<alpha> # \\<alpha>s) \\<subseteq> \\<Sigma>\n  ground_action_path M\\<^sub>0 (\\<alpha> # \\<alpha>s) M'\n\ngoal (1 subgoal):\n 1. (\\<And>pre add del.\n        \\<alpha> = Ground_Action pre (Effect add del) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ground_action.exhaust ast_effect.exhaust"], ["proof (prove)\nusing this:\n  \\<lbrakk>sound_system \\<Sigma> ?M\\<^sub>016 ?s\\<^sub>016 f;\n   set \\<alpha>s \\<subseteq> \\<Sigma>;\n   ground_action_path ?M\\<^sub>016 \\<alpha>s M'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       compose_actions (map f \\<alpha>s) ?s\\<^sub>016 =\n                       Some s' \\<and>\n                       (\\<forall>a\\<in>close_world M'.\n                           close_eq s' \\<Turnstile> a)\n  sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f\n  set (\\<alpha> # \\<alpha>s) \\<subseteq> \\<Sigma>\n  ground_action_path M\\<^sub>0 (\\<alpha> # \\<alpha>s) M'\n  (\\<And>x1 x2.\n      ?y = Ground_Action x1 x2 \\<Longrightarrow> ?P) \\<Longrightarrow>\n  ?P\n  (\\<And>x1 x2. ?y = Effect x1 x2 \\<Longrightarrow> ?P) \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<And>pre add del.\n        \\<alpha> = Ground_Action pre (Effect add del) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  \\<alpha> = Ground_Action pre (Effect add del)\n\ngoal (1 subgoal):\n 1. \\<And>a \\<alpha>s s\\<^sub>0 M\\<^sub>0.\n       \\<lbrakk>\\<And>s\\<^sub>0 M\\<^sub>0.\n                   \\<lbrakk>sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n                    set \\<alpha>s \\<subseteq> \\<Sigma>;\n                    ground_action_path M\\<^sub>0 \\<alpha>s M'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>s'.\n  compose_actions (map f \\<alpha>s) s\\<^sub>0 = Some s' \\<and>\n  Ball (close_world M') ((\\<Turnstile>) (close_eq s'));\n        sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n        set (a # \\<alpha>s) \\<subseteq> \\<Sigma>;\n        ground_action_path M\\<^sub>0 (a # \\<alpha>s) M'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            compose_actions (map f (a # \\<alpha>s))\n                             s\\<^sub>0 =\n                            Some s' \\<and>\n                            Ball (close_world M')\n                             ((\\<Turnstile>) (close_eq s'))", "let ?M\\<^sub>1 = \"execute_ground_action \\<alpha> M\\<^sub>0\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a \\<alpha>s s\\<^sub>0 M\\<^sub>0.\n       \\<lbrakk>\\<And>s\\<^sub>0 M\\<^sub>0.\n                   \\<lbrakk>sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n                    set \\<alpha>s \\<subseteq> \\<Sigma>;\n                    ground_action_path M\\<^sub>0 \\<alpha>s M'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>s'.\n  compose_actions (map f \\<alpha>s) s\\<^sub>0 = Some s' \\<and>\n  Ball (close_world M') ((\\<Turnstile>) (close_eq s'));\n        sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n        set (a # \\<alpha>s) \\<subseteq> \\<Sigma>;\n        ground_action_path M\\<^sub>0 (a # \\<alpha>s) M'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            compose_actions (map f (a # \\<alpha>s))\n                             s\\<^sub>0 =\n                            Some s' \\<and>\n                            Ball (close_world M')\n                             ((\\<Turnstile>) (close_eq s'))", "have \"close_world M\\<^sub>0 \\<TTurnstile> precondition \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. M\\<^sub>0 \\<^sup>c\\<TTurnstile>\\<^sub>=\n    ground_action.precondition \\<alpha>", "using ass(4)"], ["proof (prove)\nusing this:\n  ground_action_path M\\<^sub>0 (\\<alpha> # \\<alpha>s) M'\n\ngoal (1 subgoal):\n 1. M\\<^sub>0 \\<^sup>c\\<TTurnstile>\\<^sub>=\n    ground_action.precondition \\<alpha>", "by auto"], ["proof (state)\nthis:\n  M\\<^sub>0 \\<^sup>c\\<TTurnstile>\\<^sub>=\n  ground_action.precondition \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>a \\<alpha>s s\\<^sub>0 M\\<^sub>0.\n       \\<lbrakk>\\<And>s\\<^sub>0 M\\<^sub>0.\n                   \\<lbrakk>sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n                    set \\<alpha>s \\<subseteq> \\<Sigma>;\n                    ground_action_path M\\<^sub>0 \\<alpha>s M'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>s'.\n  compose_actions (map f \\<alpha>s) s\\<^sub>0 = Some s' \\<and>\n  Ball (close_world M') ((\\<Turnstile>) (close_eq s'));\n        sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n        set (a # \\<alpha>s) \\<subseteq> \\<Sigma>;\n        ground_action_path M\\<^sub>0 (a # \\<alpha>s) M'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            compose_actions (map f (a # \\<alpha>s))\n                             s\\<^sub>0 =\n                            Some s' \\<and>\n                            Ball (close_world M')\n                             ((\\<Turnstile>) (close_eq s'))", "moreover"], ["proof (state)\nthis:\n  M\\<^sub>0 \\<^sup>c\\<TTurnstile>\\<^sub>=\n  ground_action.precondition \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>a \\<alpha>s s\\<^sub>0 M\\<^sub>0.\n       \\<lbrakk>\\<And>s\\<^sub>0 M\\<^sub>0.\n                   \\<lbrakk>sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n                    set \\<alpha>s \\<subseteq> \\<Sigma>;\n                    ground_action_path M\\<^sub>0 \\<alpha>s M'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>s'.\n  compose_actions (map f \\<alpha>s) s\\<^sub>0 = Some s' \\<and>\n  Ball (close_world M') ((\\<Turnstile>) (close_eq s'));\n        sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n        set (a # \\<alpha>s) \\<subseteq> \\<Sigma>;\n        ground_action_path M\\<^sub>0 (a # \\<alpha>s) M'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            compose_actions (map f (a # \\<alpha>s))\n                             s\\<^sub>0 =\n                            Some s' \\<and>\n                            Ball (close_world M')\n                             ((\\<Turnstile>) (close_eq s'))", "have s0_ent_cwM0: \"\\<forall>fmla\\<in>(close_world M\\<^sub>0). close_eq s\\<^sub>0 \\<Turnstile> fmla\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>fmla\\<in>close_world M\\<^sub>0.\n       close_eq s\\<^sub>0 \\<Turnstile> fmla", "using ass(2)"], ["proof (prove)\nusing this:\n  sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f\n\ngoal (1 subgoal):\n 1. \\<forall>fmla\\<in>close_world M\\<^sub>0.\n       close_eq s\\<^sub>0 \\<Turnstile> fmla", "unfolding sound_system_def"], ["proof (prove)\nusing this:\n  Ball (close_world M\\<^sub>0) ((\\<Turnstile>) (close_eq s\\<^sub>0)) \\<and>\n  wm_basic M\\<^sub>0 \\<and>\n  (\\<forall>\\<alpha>\\<in>\\<Sigma>. sound_opr \\<alpha> (f \\<alpha>))\n\ngoal (1 subgoal):\n 1. \\<forall>fmla\\<in>close_world M\\<^sub>0.\n       close_eq s\\<^sub>0 \\<Turnstile> fmla", "by auto"], ["proof (state)\nthis:\n  \\<forall>fmla\\<in>close_world M\\<^sub>0.\n     close_eq s\\<^sub>0 \\<Turnstile> fmla\n\ngoal (1 subgoal):\n 1. \\<And>a \\<alpha>s s\\<^sub>0 M\\<^sub>0.\n       \\<lbrakk>\\<And>s\\<^sub>0 M\\<^sub>0.\n                   \\<lbrakk>sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n                    set \\<alpha>s \\<subseteq> \\<Sigma>;\n                    ground_action_path M\\<^sub>0 \\<alpha>s M'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>s'.\n  compose_actions (map f \\<alpha>s) s\\<^sub>0 = Some s' \\<and>\n  Ball (close_world M') ((\\<Turnstile>) (close_eq s'));\n        sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n        set (a # \\<alpha>s) \\<subseteq> \\<Sigma>;\n        ground_action_path M\\<^sub>0 (a # \\<alpha>s) M'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            compose_actions (map f (a # \\<alpha>s))\n                             s\\<^sub>0 =\n                            Some s' \\<and>\n                            Ball (close_world M')\n                             ((\\<Turnstile>) (close_eq s'))", "ultimately"], ["proof (chain)\npicking this:\n  M\\<^sub>0 \\<^sup>c\\<TTurnstile>\\<^sub>=\n  ground_action.precondition \\<alpha>\n  \\<forall>fmla\\<in>close_world M\\<^sub>0.\n     close_eq s\\<^sub>0 \\<Turnstile> fmla", "have s0_ent_alpha_precond: \"close_eq s\\<^sub>0 \\<Turnstile> precondition \\<alpha>\""], ["proof (prove)\nusing this:\n  M\\<^sub>0 \\<^sup>c\\<TTurnstile>\\<^sub>=\n  ground_action.precondition \\<alpha>\n  \\<forall>fmla\\<in>close_world M\\<^sub>0.\n     close_eq s\\<^sub>0 \\<Turnstile> fmla\n\ngoal (1 subgoal):\n 1. close_eq s\\<^sub>0 \\<Turnstile> ground_action.precondition \\<alpha>", "unfolding entailment_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<A>.\n     (\\<forall>G\\<in>close_world M\\<^sub>0.\n         \\<A> \\<Turnstile> G) \\<longrightarrow>\n     \\<A> \\<Turnstile> ground_action.precondition \\<alpha>\n  \\<forall>fmla\\<in>close_world M\\<^sub>0.\n     close_eq s\\<^sub>0 \\<Turnstile> fmla\n\ngoal (1 subgoal):\n 1. close_eq s\\<^sub>0 \\<Turnstile> ground_action.precondition \\<alpha>", "by auto"], ["proof (state)\nthis:\n  close_eq s\\<^sub>0 \\<Turnstile> ground_action.precondition \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>a \\<alpha>s s\\<^sub>0 M\\<^sub>0.\n       \\<lbrakk>\\<And>s\\<^sub>0 M\\<^sub>0.\n                   \\<lbrakk>sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n                    set \\<alpha>s \\<subseteq> \\<Sigma>;\n                    ground_action_path M\\<^sub>0 \\<alpha>s M'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>s'.\n  compose_actions (map f \\<alpha>s) s\\<^sub>0 = Some s' \\<and>\n  Ball (close_world M') ((\\<Turnstile>) (close_eq s'));\n        sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n        set (a # \\<alpha>s) \\<subseteq> \\<Sigma>;\n        ground_action_path M\\<^sub>0 (a # \\<alpha>s) M'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            compose_actions (map f (a # \\<alpha>s))\n                             s\\<^sub>0 =\n                            Some s' \\<and>\n                            Ball (close_world M')\n                             ((\\<Turnstile>) (close_eq s'))", "then"], ["proof (chain)\npicking this:\n  close_eq s\\<^sub>0 \\<Turnstile> ground_action.precondition \\<alpha>", "obtain s\\<^sub>1 where s1: \"(f \\<alpha>) s\\<^sub>0 = Some s\\<^sub>1\"\n      \"(\\<forall>atm. is_predAtom atm \\<longrightarrow> atm \\<notin> set(dels (effect \\<alpha>))\n                                            \\<longrightarrow> close_eq s\\<^sub>0 \\<Turnstile> atm\n                                            \\<longrightarrow> close_eq s\\<^sub>1 \\<Turnstile> atm)\"\n      \"(\\<forall>fmla. fmla \\<in> set(adds (effect \\<alpha>))\n                                            \\<longrightarrow> close_eq s\\<^sub>1 \\<Turnstile> fmla)\"\n      \"(\\<forall>atm. is_predAtom atm \\<and> atm \\<notin> set (adds (effect \\<alpha>)) \\<and> close_eq s\\<^sub>0 \\<Turnstile> Not atm \\<longrightarrow> close_eq s\\<^sub>1 \\<Turnstile> Not atm)\"\n      \"(\\<forall>fmla. fmla \\<in> set (dels (effect \\<alpha>)) \\<and> fmla \\<notin> set(adds (effect \\<alpha>)) \\<longrightarrow> close_eq s\\<^sub>1 \\<Turnstile> (Not fmla))\"\n      \"(\\<forall>a b. close_eq s\\<^sub>0 \\<Turnstile> Atom (Eq a b) \\<longrightarrow> close_eq s\\<^sub>1 \\<Turnstile> Atom (Eq a b))\"\n      \"(\\<forall>a b. close_eq s\\<^sub>0 \\<Turnstile> Not (Atom (Eq a b)) \\<longrightarrow> close_eq s\\<^sub>1 \\<Turnstile> Not (Atom (Eq a b)))\""], ["proof (prove)\nusing this:\n  close_eq s\\<^sub>0 \\<Turnstile> ground_action.precondition \\<alpha>\n\ngoal (1 subgoal):\n 1. (\\<And>s\\<^sub>1.\n        \\<lbrakk>f \\<alpha> s\\<^sub>0 = Some s\\<^sub>1;\n         \\<forall>atm.\n            is_predAtom atm \\<longrightarrow>\n            atm\n            \\<notin> set (dels\n                           (ground_action.effect\n                             \\<alpha>)) \\<longrightarrow>\n            close_eq s\\<^sub>0 \\<Turnstile> atm \\<longrightarrow>\n            close_eq s\\<^sub>1 \\<Turnstile> atm;\n         \\<forall>fmla.\n            fmla\n            \\<in> set (adds\n                        (ground_action.effect \\<alpha>)) \\<longrightarrow>\n            close_eq s\\<^sub>1 \\<Turnstile> fmla;\n         \\<forall>atm.\n            is_predAtom atm \\<and>\n            atm \\<notin> set (adds (ground_action.effect \\<alpha>)) \\<and>\n            close_eq s\\<^sub>0 \\<Turnstile>\n            \\<^bold>\\<not> atm \\<longrightarrow>\n            close_eq s\\<^sub>1 \\<Turnstile> \\<^bold>\\<not> atm;\n         \\<forall>fmla.\n            fmla \\<in> set (dels (ground_action.effect \\<alpha>)) \\<and>\n            fmla\n            \\<notin> set (adds\n                           (ground_action.effect\n                             \\<alpha>)) \\<longrightarrow>\n            close_eq s\\<^sub>1 \\<Turnstile> \\<^bold>\\<not> fmla;\n         \\<forall>a b.\n            close_eq s\\<^sub>0 \\<Turnstile> Atom (Eq a b) \\<longrightarrow>\n            close_eq s\\<^sub>1 \\<Turnstile> Atom (Eq a b);\n         \\<forall>a b.\n            close_eq s\\<^sub>0 \\<Turnstile>\n            \\<^bold>\\<not> (Atom (Eq a b)) \\<longrightarrow>\n            close_eq s\\<^sub>1 \\<Turnstile>\n            \\<^bold>\\<not> (Atom (Eq a b))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ass(2-4)"], ["proof (prove)\nusing this:\n  close_eq s\\<^sub>0 \\<Turnstile> ground_action.precondition \\<alpha>\n  sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f\n  set (\\<alpha> # \\<alpha>s) \\<subseteq> \\<Sigma>\n  ground_action_path M\\<^sub>0 (\\<alpha> # \\<alpha>s) M'\n\ngoal (1 subgoal):\n 1. (\\<And>s\\<^sub>1.\n        \\<lbrakk>f \\<alpha> s\\<^sub>0 = Some s\\<^sub>1;\n         \\<forall>atm.\n            is_predAtom atm \\<longrightarrow>\n            atm\n            \\<notin> set (dels\n                           (ground_action.effect\n                             \\<alpha>)) \\<longrightarrow>\n            close_eq s\\<^sub>0 \\<Turnstile> atm \\<longrightarrow>\n            close_eq s\\<^sub>1 \\<Turnstile> atm;\n         \\<forall>fmla.\n            fmla\n            \\<in> set (adds\n                        (ground_action.effect \\<alpha>)) \\<longrightarrow>\n            close_eq s\\<^sub>1 \\<Turnstile> fmla;\n         \\<forall>atm.\n            is_predAtom atm \\<and>\n            atm \\<notin> set (adds (ground_action.effect \\<alpha>)) \\<and>\n            close_eq s\\<^sub>0 \\<Turnstile>\n            \\<^bold>\\<not> atm \\<longrightarrow>\n            close_eq s\\<^sub>1 \\<Turnstile> \\<^bold>\\<not> atm;\n         \\<forall>fmla.\n            fmla \\<in> set (dels (ground_action.effect \\<alpha>)) \\<and>\n            fmla\n            \\<notin> set (adds\n                           (ground_action.effect\n                             \\<alpha>)) \\<longrightarrow>\n            close_eq s\\<^sub>1 \\<Turnstile> \\<^bold>\\<not> fmla;\n         \\<forall>a b.\n            close_eq s\\<^sub>0 \\<Turnstile> Atom (Eq a b) \\<longrightarrow>\n            close_eq s\\<^sub>1 \\<Turnstile> Atom (Eq a b);\n         \\<forall>a b.\n            close_eq s\\<^sub>0 \\<Turnstile>\n            \\<^bold>\\<not> (Atom (Eq a b)) \\<longrightarrow>\n            close_eq s\\<^sub>1 \\<Turnstile>\n            \\<^bold>\\<not> (Atom (Eq a b))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding sound_system_def sound_opr_alt"], ["proof (prove)\nusing this:\n  close_eq s\\<^sub>0 \\<Turnstile> ground_action.precondition \\<alpha>\n  Ball (close_world M\\<^sub>0) ((\\<Turnstile>) (close_eq s\\<^sub>0)) \\<and>\n  wm_basic M\\<^sub>0 \\<and>\n  (\\<forall>\\<alpha>\\<in>\\<Sigma>.\n      (\\<forall>s.\n          close_eq s \\<Turnstile>\n          ground_action.precondition \\<alpha> \\<longrightarrow>\n          (\\<exists>s'.\n              f \\<alpha> s = Some s' \\<and>\n              (\\<forall>atm.\n                  is_predAtom atm \\<and>\n                  atm\n                  \\<notin> set (dels (ground_action.effect \\<alpha>)) \\<and>\n                  close_eq s \\<Turnstile> atm \\<longrightarrow>\n                  close_eq s' \\<Turnstile> atm) \\<and>\n              (\\<forall>atm.\n                  is_predAtom atm \\<and>\n                  atm\n                  \\<notin> set (adds (ground_action.effect \\<alpha>)) \\<and>\n                  close_eq s \\<Turnstile>\n                  \\<^bold>\\<not> atm \\<longrightarrow>\n                  close_eq s' \\<Turnstile> \\<^bold>\\<not> atm) \\<and>\n              (\\<forall>atm.\n                  atm\n                  \\<in> set (adds\n                              (ground_action.effect\n                                \\<alpha>)) \\<longrightarrow>\n                  close_eq s' \\<Turnstile> atm) \\<and>\n              (\\<forall>fmla.\n                  fmla\n                  \\<in> set (dels (ground_action.effect \\<alpha>)) \\<and>\n                  fmla\n                  \\<notin> set (adds\n                                 (ground_action.effect\n                                   \\<alpha>)) \\<longrightarrow>\n                  close_eq s' \\<Turnstile> \\<^bold>\\<not> fmla) \\<and>\n              (\\<forall>a b.\n                  close_eq s \\<Turnstile> Atom (Eq a b) \\<longrightarrow>\n                  close_eq s' \\<Turnstile> Atom (Eq a b)) \\<and>\n              (\\<forall>a b.\n                  close_eq s \\<Turnstile>\n                  \\<^bold>\\<not> (Atom (Eq a b)) \\<longrightarrow>\n                  close_eq s' \\<Turnstile>\n                  \\<^bold>\\<not> (Atom (Eq a b))))) \\<and>\n      Ball (set (adds (ground_action.effect \\<alpha>))) is_predAtom)\n  set (\\<alpha> # \\<alpha>s) \\<subseteq> \\<Sigma>\n  ground_action_path M\\<^sub>0 (\\<alpha> # \\<alpha>s) M'\n\ngoal (1 subgoal):\n 1. (\\<And>s\\<^sub>1.\n        \\<lbrakk>f \\<alpha> s\\<^sub>0 = Some s\\<^sub>1;\n         \\<forall>atm.\n            is_predAtom atm \\<longrightarrow>\n            atm\n            \\<notin> set (dels\n                           (ground_action.effect\n                             \\<alpha>)) \\<longrightarrow>\n            close_eq s\\<^sub>0 \\<Turnstile> atm \\<longrightarrow>\n            close_eq s\\<^sub>1 \\<Turnstile> atm;\n         \\<forall>fmla.\n            fmla\n            \\<in> set (adds\n                        (ground_action.effect \\<alpha>)) \\<longrightarrow>\n            close_eq s\\<^sub>1 \\<Turnstile> fmla;\n         \\<forall>atm.\n            is_predAtom atm \\<and>\n            atm \\<notin> set (adds (ground_action.effect \\<alpha>)) \\<and>\n            close_eq s\\<^sub>0 \\<Turnstile>\n            \\<^bold>\\<not> atm \\<longrightarrow>\n            close_eq s\\<^sub>1 \\<Turnstile> \\<^bold>\\<not> atm;\n         \\<forall>fmla.\n            fmla \\<in> set (dels (ground_action.effect \\<alpha>)) \\<and>\n            fmla\n            \\<notin> set (adds\n                           (ground_action.effect\n                             \\<alpha>)) \\<longrightarrow>\n            close_eq s\\<^sub>1 \\<Turnstile> \\<^bold>\\<not> fmla;\n         \\<forall>a b.\n            close_eq s\\<^sub>0 \\<Turnstile> Atom (Eq a b) \\<longrightarrow>\n            close_eq s\\<^sub>1 \\<Turnstile> Atom (Eq a b);\n         \\<forall>a b.\n            close_eq s\\<^sub>0 \\<Turnstile>\n            \\<^bold>\\<not> (Atom (Eq a b)) \\<longrightarrow>\n            close_eq s\\<^sub>1 \\<Turnstile>\n            \\<^bold>\\<not> (Atom (Eq a b))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  f \\<alpha> s\\<^sub>0 = Some s\\<^sub>1\n  \\<forall>atm.\n     is_predAtom atm \\<longrightarrow>\n     atm\n     \\<notin> set (dels (ground_action.effect \\<alpha>)) \\<longrightarrow>\n     close_eq s\\<^sub>0 \\<Turnstile> atm \\<longrightarrow>\n     close_eq s\\<^sub>1 \\<Turnstile> atm\n  \\<forall>fmla.\n     fmla \\<in> set (adds (ground_action.effect \\<alpha>)) \\<longrightarrow>\n     close_eq s\\<^sub>1 \\<Turnstile> fmla\n  \\<forall>atm.\n     is_predAtom atm \\<and>\n     atm \\<notin> set (adds (ground_action.effect \\<alpha>)) \\<and>\n     close_eq s\\<^sub>0 \\<Turnstile> \\<^bold>\\<not> atm \\<longrightarrow>\n     close_eq s\\<^sub>1 \\<Turnstile> \\<^bold>\\<not> atm\n  \\<forall>fmla.\n     fmla \\<in> set (dels (ground_action.effect \\<alpha>)) \\<and>\n     fmla\n     \\<notin> set (adds (ground_action.effect \\<alpha>)) \\<longrightarrow>\n     close_eq s\\<^sub>1 \\<Turnstile> \\<^bold>\\<not> fmla\n  \\<forall>a b.\n     close_eq s\\<^sub>0 \\<Turnstile> Atom (Eq a b) \\<longrightarrow>\n     close_eq s\\<^sub>1 \\<Turnstile> Atom (Eq a b)\n  \\<forall>a b.\n     close_eq s\\<^sub>0 \\<Turnstile>\n     \\<^bold>\\<not> (Atom (Eq a b)) \\<longrightarrow>\n     close_eq s\\<^sub>1 \\<Turnstile> \\<^bold>\\<not> (Atom (Eq a b))\n\ngoal (1 subgoal):\n 1. \\<And>a \\<alpha>s s\\<^sub>0 M\\<^sub>0.\n       \\<lbrakk>\\<And>s\\<^sub>0 M\\<^sub>0.\n                   \\<lbrakk>sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n                    set \\<alpha>s \\<subseteq> \\<Sigma>;\n                    ground_action_path M\\<^sub>0 \\<alpha>s M'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>s'.\n  compose_actions (map f \\<alpha>s) s\\<^sub>0 = Some s' \\<and>\n  Ball (close_world M') ((\\<Turnstile>) (close_eq s'));\n        sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n        set (a # \\<alpha>s) \\<subseteq> \\<Sigma>;\n        ground_action_path M\\<^sub>0 (a # \\<alpha>s) M'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            compose_actions (map f (a # \\<alpha>s))\n                             s\\<^sub>0 =\n                            Some s' \\<and>\n                            Ball (close_world M')\n                             ((\\<Turnstile>) (close_eq s'))", "have \"close_eq s\\<^sub>1 \\<Turnstile> fmla\" if \"fmla\\<in>close_world ?M\\<^sub>1\" for fmla"], ["proof (prove)\ngoal (1 subgoal):\n 1. close_eq s\\<^sub>1 \\<Turnstile> fmla", "using ass(2)"], ["proof (prove)\nusing this:\n  sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f\n\ngoal (1 subgoal):\n 1. close_eq s\\<^sub>1 \\<Turnstile> fmla", "using that s1 s0_ent_cwM0"], ["proof (prove)\nusing this:\n  sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f\n  fmla \\<in> close_world (execute_ground_action \\<alpha> M\\<^sub>0)\n  f \\<alpha> s\\<^sub>0 = Some s\\<^sub>1\n  \\<forall>atm.\n     is_predAtom atm \\<longrightarrow>\n     atm\n     \\<notin> set (dels (ground_action.effect \\<alpha>)) \\<longrightarrow>\n     close_eq s\\<^sub>0 \\<Turnstile> atm \\<longrightarrow>\n     close_eq s\\<^sub>1 \\<Turnstile> atm\n  \\<forall>fmla.\n     fmla \\<in> set (adds (ground_action.effect \\<alpha>)) \\<longrightarrow>\n     close_eq s\\<^sub>1 \\<Turnstile> fmla\n  \\<forall>atm.\n     is_predAtom atm \\<and>\n     atm \\<notin> set (adds (ground_action.effect \\<alpha>)) \\<and>\n     close_eq s\\<^sub>0 \\<Turnstile> \\<^bold>\\<not> atm \\<longrightarrow>\n     close_eq s\\<^sub>1 \\<Turnstile> \\<^bold>\\<not> atm\n  \\<forall>fmla.\n     fmla \\<in> set (dels (ground_action.effect \\<alpha>)) \\<and>\n     fmla\n     \\<notin> set (adds (ground_action.effect \\<alpha>)) \\<longrightarrow>\n     close_eq s\\<^sub>1 \\<Turnstile> \\<^bold>\\<not> fmla\n  \\<forall>a b.\n     close_eq s\\<^sub>0 \\<Turnstile> Atom (Eq a b) \\<longrightarrow>\n     close_eq s\\<^sub>1 \\<Turnstile> Atom (Eq a b)\n  \\<forall>a b.\n     close_eq s\\<^sub>0 \\<Turnstile>\n     \\<^bold>\\<not> (Atom (Eq a b)) \\<longrightarrow>\n     close_eq s\\<^sub>1 \\<Turnstile> \\<^bold>\\<not> (Atom (Eq a b))\n  \\<forall>fmla\\<in>close_world M\\<^sub>0.\n     close_eq s\\<^sub>0 \\<Turnstile> fmla\n\ngoal (1 subgoal):\n 1. close_eq s\\<^sub>1 \\<Turnstile> fmla", "unfolding sound_system_def execute_ground_action_def wm_basic_def"], ["proof (prove)\nusing this:\n  Ball (close_world M\\<^sub>0) ((\\<Turnstile>) (close_eq s\\<^sub>0)) \\<and>\n  (\\<forall>a\\<in>M\\<^sub>0. is_predAtom a) \\<and>\n  (\\<forall>\\<alpha>\\<in>\\<Sigma>. sound_opr \\<alpha> (f \\<alpha>))\n  fmla\n  \\<in> close_world (apply_effect (ground_action.effect \\<alpha>) M\\<^sub>0)\n  f \\<alpha> s\\<^sub>0 = Some s\\<^sub>1\n  \\<forall>atm.\n     is_predAtom atm \\<longrightarrow>\n     atm\n     \\<notin> set (dels (ground_action.effect \\<alpha>)) \\<longrightarrow>\n     close_eq s\\<^sub>0 \\<Turnstile> atm \\<longrightarrow>\n     close_eq s\\<^sub>1 \\<Turnstile> atm\n  \\<forall>fmla.\n     fmla \\<in> set (adds (ground_action.effect \\<alpha>)) \\<longrightarrow>\n     close_eq s\\<^sub>1 \\<Turnstile> fmla\n  \\<forall>atm.\n     is_predAtom atm \\<and>\n     atm \\<notin> set (adds (ground_action.effect \\<alpha>)) \\<and>\n     close_eq s\\<^sub>0 \\<Turnstile> \\<^bold>\\<not> atm \\<longrightarrow>\n     close_eq s\\<^sub>1 \\<Turnstile> \\<^bold>\\<not> atm\n  \\<forall>fmla.\n     fmla \\<in> set (dels (ground_action.effect \\<alpha>)) \\<and>\n     fmla\n     \\<notin> set (adds (ground_action.effect \\<alpha>)) \\<longrightarrow>\n     close_eq s\\<^sub>1 \\<Turnstile> \\<^bold>\\<not> fmla\n  \\<forall>a b.\n     close_eq s\\<^sub>0 \\<Turnstile> Atom (Eq a b) \\<longrightarrow>\n     close_eq s\\<^sub>1 \\<Turnstile> Atom (Eq a b)\n  \\<forall>a b.\n     close_eq s\\<^sub>0 \\<Turnstile>\n     \\<^bold>\\<not> (Atom (Eq a b)) \\<longrightarrow>\n     close_eq s\\<^sub>1 \\<Turnstile> \\<^bold>\\<not> (Atom (Eq a b))\n  \\<forall>fmla\\<in>close_world M\\<^sub>0.\n     close_eq s\\<^sub>0 \\<Turnstile> fmla\n\ngoal (1 subgoal):\n 1. close_eq s\\<^sub>1 \\<Turnstile> fmla", "apply (auto simp: in_close_world_conv)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>f \\<alpha> s\\<^sub>0 = Some s\\<^sub>1;\n     \\<forall>atm.\n        is_predAtom atm \\<longrightarrow>\n        atm\n        \\<notin> set (dels\n                       (ground_action.effect \\<alpha>)) \\<longrightarrow>\n        close_eq s\\<^sub>0 \\<Turnstile> atm \\<longrightarrow>\n        close_eq s\\<^sub>1 \\<Turnstile> atm;\n     \\<forall>fmla.\n        fmla\n        \\<in> set (adds (ground_action.effect \\<alpha>)) \\<longrightarrow>\n        close_eq s\\<^sub>1 \\<Turnstile> fmla;\n     \\<forall>atm.\n        is_predAtom atm \\<and>\n        atm \\<notin> set (adds (ground_action.effect \\<alpha>)) \\<and>\n        \\<not> close_eq s\\<^sub>0 \\<Turnstile> atm \\<longrightarrow>\n        \\<not> close_eq s\\<^sub>1 \\<Turnstile> atm;\n     \\<forall>fmla.\n        fmla \\<in> set (dels (ground_action.effect \\<alpha>)) \\<and>\n        fmla\n        \\<notin> set (adds\n                       (ground_action.effect \\<alpha>)) \\<longrightarrow>\n        \\<not> close_eq s\\<^sub>1 \\<Turnstile> fmla;\n     \\<forall>x\\<in>close_world M\\<^sub>0.\n        close_eq s\\<^sub>0 \\<Turnstile> x;\n     \\<forall>x\\<in>M\\<^sub>0. is_predAtom x;\n     \\<forall>\\<alpha>\\<in>\\<Sigma>. sound_opr \\<alpha> (f \\<alpha>);\n     fmla\n     \\<in> apply_effect (ground_action.effect \\<alpha>) M\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> close_eq s\\<^sub>1 \\<Turnstile> fmla\n 2. \\<And>p as.\n       \\<lbrakk>f \\<alpha> s\\<^sub>0 = Some s\\<^sub>1;\n        \\<forall>atm.\n           is_predAtom atm \\<longrightarrow>\n           atm\n           \\<notin> set (dels\n                          (ground_action.effect \\<alpha>)) \\<longrightarrow>\n           close_eq s\\<^sub>0 \\<Turnstile> atm \\<longrightarrow>\n           close_eq s\\<^sub>1 \\<Turnstile> atm;\n        \\<forall>fmla.\n           fmla\n           \\<in> set (adds\n                       (ground_action.effect \\<alpha>)) \\<longrightarrow>\n           close_eq s\\<^sub>1 \\<Turnstile> fmla;\n        \\<forall>atm.\n           is_predAtom atm \\<and>\n           atm \\<notin> set (adds (ground_action.effect \\<alpha>)) \\<and>\n           \\<not> close_eq s\\<^sub>0 \\<Turnstile> atm \\<longrightarrow>\n           \\<not> close_eq s\\<^sub>1 \\<Turnstile> atm;\n        \\<forall>fmla.\n           fmla \\<in> set (dels (ground_action.effect \\<alpha>)) \\<and>\n           fmla\n           \\<notin> set (adds\n                          (ground_action.effect \\<alpha>)) \\<longrightarrow>\n           \\<not> close_eq s\\<^sub>1 \\<Turnstile> fmla;\n        \\<forall>x\\<in>close_world M\\<^sub>0.\n           close_eq s\\<^sub>0 \\<Turnstile> x;\n        \\<forall>x\\<in>M\\<^sub>0. is_predAtom x;\n        \\<forall>\\<alpha>\\<in>\\<Sigma>. sound_opr \\<alpha> (f \\<alpha>);\n        Atom (predAtm p as)\n        \\<notin> apply_effect (ground_action.effect \\<alpha>) M\\<^sub>0;\n        fmla = \\<^bold>\\<not> (Atom (predAtm p as));\n        s\\<^sub>1 (p, as)\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<alpha> s\\<^sub>0 = Some s\\<^sub>1;\n     \\<forall>atm.\n        is_predAtom atm \\<longrightarrow>\n        atm\n        \\<notin> set (dels\n                       (ground_action.effect \\<alpha>)) \\<longrightarrow>\n        close_eq s\\<^sub>0 \\<Turnstile> atm \\<longrightarrow>\n        close_eq s\\<^sub>1 \\<Turnstile> atm;\n     \\<forall>fmla.\n        fmla\n        \\<in> set (adds (ground_action.effect \\<alpha>)) \\<longrightarrow>\n        close_eq s\\<^sub>1 \\<Turnstile> fmla;\n     \\<forall>atm.\n        is_predAtom atm \\<and>\n        atm \\<notin> set (adds (ground_action.effect \\<alpha>)) \\<and>\n        \\<not> close_eq s\\<^sub>0 \\<Turnstile> atm \\<longrightarrow>\n        \\<not> close_eq s\\<^sub>1 \\<Turnstile> atm;\n     \\<forall>fmla.\n        fmla \\<in> set (dels (ground_action.effect \\<alpha>)) \\<and>\n        fmla\n        \\<notin> set (adds\n                       (ground_action.effect \\<alpha>)) \\<longrightarrow>\n        \\<not> close_eq s\\<^sub>1 \\<Turnstile> fmla;\n     \\<forall>x\\<in>close_world M\\<^sub>0.\n        close_eq s\\<^sub>0 \\<Turnstile> x;\n     \\<forall>x\\<in>M\\<^sub>0. is_predAtom x;\n     \\<forall>\\<alpha>\\<in>\\<Sigma>. sound_opr \\<alpha> (f \\<alpha>);\n     fmla\n     \\<in> apply_effect (ground_action.effect \\<alpha>) M\\<^sub>0\\<rbrakk>\n    \\<Longrightarrow> close_eq s\\<^sub>1 \\<Turnstile> fmla", "by (metis (no_types, lifting) DiffE UnE a apply_effect.simps ground_action.sel(2) ast_effect.sel(1) ast_effect.sel(2) close_world_extensive subsetCE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>p as.\n       \\<lbrakk>f \\<alpha> s\\<^sub>0 = Some s\\<^sub>1;\n        \\<forall>atm.\n           is_predAtom atm \\<longrightarrow>\n           atm\n           \\<notin> set (dels\n                          (ground_action.effect \\<alpha>)) \\<longrightarrow>\n           close_eq s\\<^sub>0 \\<Turnstile> atm \\<longrightarrow>\n           close_eq s\\<^sub>1 \\<Turnstile> atm;\n        \\<forall>fmla.\n           fmla\n           \\<in> set (adds\n                       (ground_action.effect \\<alpha>)) \\<longrightarrow>\n           close_eq s\\<^sub>1 \\<Turnstile> fmla;\n        \\<forall>atm.\n           is_predAtom atm \\<and>\n           atm \\<notin> set (adds (ground_action.effect \\<alpha>)) \\<and>\n           \\<not> close_eq s\\<^sub>0 \\<Turnstile> atm \\<longrightarrow>\n           \\<not> close_eq s\\<^sub>1 \\<Turnstile> atm;\n        \\<forall>fmla.\n           fmla \\<in> set (dels (ground_action.effect \\<alpha>)) \\<and>\n           fmla\n           \\<notin> set (adds\n                          (ground_action.effect \\<alpha>)) \\<longrightarrow>\n           \\<not> close_eq s\\<^sub>1 \\<Turnstile> fmla;\n        \\<forall>x\\<in>close_world M\\<^sub>0.\n           close_eq s\\<^sub>0 \\<Turnstile> x;\n        \\<forall>x\\<in>M\\<^sub>0. is_predAtom x;\n        \\<forall>\\<alpha>\\<in>\\<Sigma>. sound_opr \\<alpha> (f \\<alpha>);\n        Atom (predAtm p as)\n        \\<notin> apply_effect (ground_action.effect \\<alpha>) M\\<^sub>0;\n        fmla = \\<^bold>\\<not> (Atom (predAtm p as));\n        s\\<^sub>1 (p, as)\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<alpha> s\\<^sub>0 = Some s\\<^sub>1;\n     \\<forall>atm.\n        is_predAtom atm \\<longrightarrow>\n        atm\n        \\<notin> set (dels\n                       (ground_action.effect \\<alpha>)) \\<longrightarrow>\n        close_eq s\\<^sub>0 \\<Turnstile> atm \\<longrightarrow>\n        close_eq s\\<^sub>1 \\<Turnstile> atm;\n     \\<forall>fmla.\n        fmla\n        \\<in> set (adds (ground_action.effect \\<alpha>)) \\<longrightarrow>\n        close_eq s\\<^sub>1 \\<Turnstile> fmla;\n     \\<forall>atm.\n        is_predAtom atm \\<and>\n        atm \\<notin> set (adds (ground_action.effect \\<alpha>)) \\<and>\n        \\<not> close_eq s\\<^sub>0 \\<Turnstile> atm \\<longrightarrow>\n        \\<not> close_eq s\\<^sub>1 \\<Turnstile> atm;\n     \\<forall>fmla.\n        fmla \\<in> set (dels (ground_action.effect \\<alpha>)) \\<and>\n        fmla\n        \\<notin> set (adds\n                       (ground_action.effect \\<alpha>)) \\<longrightarrow>\n        \\<not> close_eq s\\<^sub>1 \\<Turnstile> fmla;\n     \\<forall>x\\<in>close_world M\\<^sub>0.\n        close_eq s\\<^sub>0 \\<Turnstile> x;\n     \\<forall>x\\<in>M\\<^sub>0. is_predAtom x;\n     \\<forall>\\<alpha>\\<in>\\<Sigma>. sound_opr \\<alpha> (f \\<alpha>);\n     Atom (predAtm p_ as_)\n     \\<notin> apply_effect (ground_action.effect \\<alpha>) M\\<^sub>0;\n     fmla = \\<^bold>\\<not> (Atom (predAtm p_ as_));\n     s\\<^sub>1 (p_, as_)\\<rbrakk>\n    \\<Longrightarrow> False", "by (metis Diff_iff Un_iff a ground_action.sel(2) ast_domain.apply_effect.simps ast_domain.close_eq_predAtm ast_effect.sel(1) ast_effect.sel(2) formula_semantics.simps(1) formula_semantics.simps(3) in_close_world_conv is_predAtom.simps(1))"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  ?fmla16\n  \\<in> close_world\n         (execute_ground_action \\<alpha> M\\<^sub>0) \\<Longrightarrow>\n  close_eq s\\<^sub>1 \\<Turnstile> ?fmla16\n\ngoal (1 subgoal):\n 1. \\<And>a \\<alpha>s s\\<^sub>0 M\\<^sub>0.\n       \\<lbrakk>\\<And>s\\<^sub>0 M\\<^sub>0.\n                   \\<lbrakk>sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n                    set \\<alpha>s \\<subseteq> \\<Sigma>;\n                    ground_action_path M\\<^sub>0 \\<alpha>s M'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>s'.\n  compose_actions (map f \\<alpha>s) s\\<^sub>0 = Some s' \\<and>\n  Ball (close_world M') ((\\<Turnstile>) (close_eq s'));\n        sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n        set (a # \\<alpha>s) \\<subseteq> \\<Sigma>;\n        ground_action_path M\\<^sub>0 (a # \\<alpha>s) M'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            compose_actions (map f (a # \\<alpha>s))\n                             s\\<^sub>0 =\n                            Some s' \\<and>\n                            Ball (close_world M')\n                             ((\\<Turnstile>) (close_eq s'))", "moreover"], ["proof (state)\nthis:\n  ?fmla16\n  \\<in> close_world\n         (execute_ground_action \\<alpha> M\\<^sub>0) \\<Longrightarrow>\n  close_eq s\\<^sub>1 \\<Turnstile> ?fmla16\n\ngoal (1 subgoal):\n 1. \\<And>a \\<alpha>s s\\<^sub>0 M\\<^sub>0.\n       \\<lbrakk>\\<And>s\\<^sub>0 M\\<^sub>0.\n                   \\<lbrakk>sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n                    set \\<alpha>s \\<subseteq> \\<Sigma>;\n                    ground_action_path M\\<^sub>0 \\<alpha>s M'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>s'.\n  compose_actions (map f \\<alpha>s) s\\<^sub>0 = Some s' \\<and>\n  Ball (close_world M') ((\\<Turnstile>) (close_eq s'));\n        sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n        set (a # \\<alpha>s) \\<subseteq> \\<Sigma>;\n        ground_action_path M\\<^sub>0 (a # \\<alpha>s) M'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            compose_actions (map f (a # \\<alpha>s))\n                             s\\<^sub>0 =\n                            Some s' \\<and>\n                            Ball (close_world M')\n                             ((\\<Turnstile>) (close_eq s'))", "have \"(\\<forall>atm. fmla \\<noteq> formula.Atom atm) \\<longrightarrow> s \\<Turnstile> fmla\" if \"fmla\\<in>?M\\<^sub>1\" for fmla s"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>atm. fmla \\<noteq> Atom atm) \\<longrightarrow>\n    s \\<Turnstile> fmla", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>atm. fmla \\<noteq> Atom atm) \\<longrightarrow>\n    s \\<Turnstile> fmla", "have alpha: \"(\\<forall>s.\\<forall>fmla\\<in>set(adds (effect \\<alpha>)). \\<not> is_predAtom fmla \\<longrightarrow> s \\<Turnstile> fmla)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s.\n       \\<forall>fmla\\<in>set (adds (ground_action.effect \\<alpha>)).\n          \\<not> is_predAtom fmla \\<longrightarrow> s \\<Turnstile> fmla", "using ass(2,3)"], ["proof (prove)\nusing this:\n  sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f\n  set (\\<alpha> # \\<alpha>s) \\<subseteq> \\<Sigma>\n\ngoal (1 subgoal):\n 1. \\<forall>s.\n       \\<forall>fmla\\<in>set (adds (ground_action.effect \\<alpha>)).\n          \\<not> is_predAtom fmla \\<longrightarrow> s \\<Turnstile> fmla", "unfolding sound_system_def ast_domain.sound_opr_alt"], ["proof (prove)\nusing this:\n  Ball (close_world M\\<^sub>0) ((\\<Turnstile>) (close_eq s\\<^sub>0)) \\<and>\n  wm_basic M\\<^sub>0 \\<and>\n  (\\<forall>\\<alpha>\\<in>\\<Sigma>.\n      (\\<forall>s.\n          close_eq s \\<Turnstile>\n          ground_action.precondition \\<alpha> \\<longrightarrow>\n          (\\<exists>s'.\n              f \\<alpha> s = Some s' \\<and>\n              (\\<forall>atm.\n                  is_predAtom atm \\<and>\n                  atm\n                  \\<notin> set (dels (ground_action.effect \\<alpha>)) \\<and>\n                  close_eq s \\<Turnstile> atm \\<longrightarrow>\n                  close_eq s' \\<Turnstile> atm) \\<and>\n              (\\<forall>atm.\n                  is_predAtom atm \\<and>\n                  atm\n                  \\<notin> set (adds (ground_action.effect \\<alpha>)) \\<and>\n                  close_eq s \\<Turnstile>\n                  \\<^bold>\\<not> atm \\<longrightarrow>\n                  close_eq s' \\<Turnstile> \\<^bold>\\<not> atm) \\<and>\n              (\\<forall>atm.\n                  atm\n                  \\<in> set (adds\n                              (ground_action.effect\n                                \\<alpha>)) \\<longrightarrow>\n                  close_eq s' \\<Turnstile> atm) \\<and>\n              (\\<forall>fmla.\n                  fmla\n                  \\<in> set (dels (ground_action.effect \\<alpha>)) \\<and>\n                  fmla\n                  \\<notin> set (adds\n                                 (ground_action.effect\n                                   \\<alpha>)) \\<longrightarrow>\n                  close_eq s' \\<Turnstile> \\<^bold>\\<not> fmla) \\<and>\n              (\\<forall>a b.\n                  close_eq s \\<Turnstile> Atom (Eq a b) \\<longrightarrow>\n                  close_eq s' \\<Turnstile> Atom (Eq a b)) \\<and>\n              (\\<forall>a b.\n                  close_eq s \\<Turnstile>\n                  \\<^bold>\\<not> (Atom (Eq a b)) \\<longrightarrow>\n                  close_eq s' \\<Turnstile>\n                  \\<^bold>\\<not> (Atom (Eq a b))))) \\<and>\n      Ball (set (adds (ground_action.effect \\<alpha>))) is_predAtom)\n  set (\\<alpha> # \\<alpha>s) \\<subseteq> \\<Sigma>\n\ngoal (1 subgoal):\n 1. \\<forall>s.\n       \\<forall>fmla\\<in>set (adds (ground_action.effect \\<alpha>)).\n          \\<not> is_predAtom fmla \\<longrightarrow> s \\<Turnstile> fmla", "by auto"], ["proof (state)\nthis:\n  \\<forall>s.\n     \\<forall>fmla\\<in>set (adds (ground_action.effect \\<alpha>)).\n        \\<not> is_predAtom fmla \\<longrightarrow> s \\<Turnstile> fmla\n\ngoal (1 subgoal):\n 1. (\\<forall>atm. fmla \\<noteq> Atom atm) \\<longrightarrow>\n    s \\<Turnstile> fmla", "then"], ["proof (chain)\npicking this:\n  \\<forall>s.\n     \\<forall>fmla\\<in>set (adds (ground_action.effect \\<alpha>)).\n        \\<not> is_predAtom fmla \\<longrightarrow> s \\<Turnstile> fmla", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>s.\n     \\<forall>fmla\\<in>set (adds (ground_action.effect \\<alpha>)).\n        \\<not> is_predAtom fmla \\<longrightarrow> s \\<Turnstile> fmla\n\ngoal (1 subgoal):\n 1. (\\<forall>atm. fmla \\<noteq> Atom atm) \\<longrightarrow>\n    s \\<Turnstile> fmla", "using that"], ["proof (prove)\nusing this:\n  \\<forall>s.\n     \\<forall>fmla\\<in>set (adds (ground_action.effect \\<alpha>)).\n        \\<not> is_predAtom fmla \\<longrightarrow> s \\<Turnstile> fmla\n  fmla \\<in> execute_ground_action \\<alpha> M\\<^sub>0\n\ngoal (1 subgoal):\n 1. (\\<forall>atm. fmla \\<noteq> Atom atm) \\<longrightarrow>\n    s \\<Turnstile> fmla", "unfolding a execute_ground_action_def"], ["proof (prove)\nusing this:\n  \\<forall>s.\n     \\<forall>fmla\n              \\<in>set (adds\n                         (ground_action.effect\n                           (Ground_Action pre (Effect add del)))).\n        \\<not> is_predAtom fmla \\<longrightarrow> s \\<Turnstile> fmla\n  fmla\n  \\<in> apply_effect\n         (ground_action.effect (Ground_Action pre (Effect add del)))\n         M\\<^sub>0\n\ngoal (1 subgoal):\n 1. (\\<forall>atm. fmla \\<noteq> Atom atm) \\<longrightarrow>\n    s \\<Turnstile> fmla", "using ass.prems(1)[unfolded sound_system_def]"], ["proof (prove)\nusing this:\n  \\<forall>s.\n     \\<forall>fmla\n              \\<in>set (adds\n                         (ground_action.effect\n                           (Ground_Action pre (Effect add del)))).\n        \\<not> is_predAtom fmla \\<longrightarrow> s \\<Turnstile> fmla\n  fmla\n  \\<in> apply_effect\n         (ground_action.effect (Ground_Action pre (Effect add del)))\n         M\\<^sub>0\n  Ball (close_world M\\<^sub>0) ((\\<Turnstile>) (close_eq s\\<^sub>0)) \\<and>\n  wm_basic M\\<^sub>0 \\<and>\n  (\\<forall>\\<alpha>\\<in>\\<Sigma>. sound_opr \\<alpha> (f \\<alpha>))\n\ngoal (1 subgoal):\n 1. (\\<forall>atm. fmla \\<noteq> Atom atm) \\<longrightarrow>\n    s \\<Turnstile> fmla", "by(cases fmla; fastforce simp: wm_basic_def)"], ["proof (state)\nthis:\n  (\\<forall>atm. fmla \\<noteq> Atom atm) \\<longrightarrow>\n  s \\<Turnstile> fmla\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?fmla16 \\<in> execute_ground_action \\<alpha> M\\<^sub>0 \\<Longrightarrow>\n  (\\<forall>atm. ?fmla16 \\<noteq> Atom atm) \\<longrightarrow>\n  ?s16 \\<Turnstile> ?fmla16\n\ngoal (1 subgoal):\n 1. \\<And>a \\<alpha>s s\\<^sub>0 M\\<^sub>0.\n       \\<lbrakk>\\<And>s\\<^sub>0 M\\<^sub>0.\n                   \\<lbrakk>sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n                    set \\<alpha>s \\<subseteq> \\<Sigma>;\n                    ground_action_path M\\<^sub>0 \\<alpha>s M'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>s'.\n  compose_actions (map f \\<alpha>s) s\\<^sub>0 = Some s' \\<and>\n  Ball (close_world M') ((\\<Turnstile>) (close_eq s'));\n        sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n        set (a # \\<alpha>s) \\<subseteq> \\<Sigma>;\n        ground_action_path M\\<^sub>0 (a # \\<alpha>s) M'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            compose_actions (map f (a # \\<alpha>s))\n                             s\\<^sub>0 =\n                            Some s' \\<and>\n                            Ball (close_world M')\n                             ((\\<Turnstile>) (close_eq s'))", "moreover"], ["proof (state)\nthis:\n  ?fmla16 \\<in> execute_ground_action \\<alpha> M\\<^sub>0 \\<Longrightarrow>\n  (\\<forall>atm. ?fmla16 \\<noteq> Atom atm) \\<longrightarrow>\n  ?s16 \\<Turnstile> ?fmla16\n\ngoal (1 subgoal):\n 1. \\<And>a \\<alpha>s s\\<^sub>0 M\\<^sub>0.\n       \\<lbrakk>\\<And>s\\<^sub>0 M\\<^sub>0.\n                   \\<lbrakk>sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n                    set \\<alpha>s \\<subseteq> \\<Sigma>;\n                    ground_action_path M\\<^sub>0 \\<alpha>s M'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>s'.\n  compose_actions (map f \\<alpha>s) s\\<^sub>0 = Some s' \\<and>\n  Ball (close_world M') ((\\<Turnstile>) (close_eq s'));\n        sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n        set (a # \\<alpha>s) \\<subseteq> \\<Sigma>;\n        ground_action_path M\\<^sub>0 (a # \\<alpha>s) M'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            compose_actions (map f (a # \\<alpha>s))\n                             s\\<^sub>0 =\n                            Some s' \\<and>\n                            Ball (close_world M')\n                             ((\\<Turnstile>) (close_eq s'))", "have \"(\\<forall>opr\\<in>\\<Sigma>. sound_opr opr (f opr))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>opr\\<in>\\<Sigma>. sound_opr opr (f opr)", "using ass(2)"], ["proof (prove)\nusing this:\n  sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f\n\ngoal (1 subgoal):\n 1. \\<forall>opr\\<in>\\<Sigma>. sound_opr opr (f opr)", "unfolding sound_system_def"], ["proof (prove)\nusing this:\n  Ball (close_world M\\<^sub>0) ((\\<Turnstile>) (close_eq s\\<^sub>0)) \\<and>\n  wm_basic M\\<^sub>0 \\<and>\n  (\\<forall>\\<alpha>\\<in>\\<Sigma>. sound_opr \\<alpha> (f \\<alpha>))\n\ngoal (1 subgoal):\n 1. \\<forall>opr\\<in>\\<Sigma>. sound_opr opr (f opr)", "by (auto simp add:)"], ["proof (state)\nthis:\n  \\<forall>opr\\<in>\\<Sigma>. sound_opr opr (f opr)\n\ngoal (1 subgoal):\n 1. \\<And>a \\<alpha>s s\\<^sub>0 M\\<^sub>0.\n       \\<lbrakk>\\<And>s\\<^sub>0 M\\<^sub>0.\n                   \\<lbrakk>sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n                    set \\<alpha>s \\<subseteq> \\<Sigma>;\n                    ground_action_path M\\<^sub>0 \\<alpha>s M'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>s'.\n  compose_actions (map f \\<alpha>s) s\\<^sub>0 = Some s' \\<and>\n  Ball (close_world M') ((\\<Turnstile>) (close_eq s'));\n        sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n        set (a # \\<alpha>s) \\<subseteq> \\<Sigma>;\n        ground_action_path M\\<^sub>0 (a # \\<alpha>s) M'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            compose_actions (map f (a # \\<alpha>s))\n                             s\\<^sub>0 =\n                            Some s' \\<and>\n                            Ball (close_world M')\n                             ((\\<Turnstile>) (close_eq s'))", "moreover"], ["proof (state)\nthis:\n  \\<forall>opr\\<in>\\<Sigma>. sound_opr opr (f opr)\n\ngoal (1 subgoal):\n 1. \\<And>a \\<alpha>s s\\<^sub>0 M\\<^sub>0.\n       \\<lbrakk>\\<And>s\\<^sub>0 M\\<^sub>0.\n                   \\<lbrakk>sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n                    set \\<alpha>s \\<subseteq> \\<Sigma>;\n                    ground_action_path M\\<^sub>0 \\<alpha>s M'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>s'.\n  compose_actions (map f \\<alpha>s) s\\<^sub>0 = Some s' \\<and>\n  Ball (close_world M') ((\\<Turnstile>) (close_eq s'));\n        sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n        set (a # \\<alpha>s) \\<subseteq> \\<Sigma>;\n        ground_action_path M\\<^sub>0 (a # \\<alpha>s) M'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            compose_actions (map f (a # \\<alpha>s))\n                             s\\<^sub>0 =\n                            Some s' \\<and>\n                            Ball (close_world M')\n                             ((\\<Turnstile>) (close_eq s'))", "have \"wm_basic ?M\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wm_basic (execute_ground_action \\<alpha> M\\<^sub>0)", "using ass(2,3)"], ["proof (prove)\nusing this:\n  sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f\n  set (\\<alpha> # \\<alpha>s) \\<subseteq> \\<Sigma>\n\ngoal (1 subgoal):\n 1. wm_basic (execute_ground_action \\<alpha> M\\<^sub>0)", "unfolding sound_system_def execute_ground_action_def"], ["proof (prove)\nusing this:\n  Ball (close_world M\\<^sub>0) ((\\<Turnstile>) (close_eq s\\<^sub>0)) \\<and>\n  wm_basic M\\<^sub>0 \\<and>\n  (\\<forall>\\<alpha>\\<in>\\<Sigma>. sound_opr \\<alpha> (f \\<alpha>))\n  set (\\<alpha> # \\<alpha>s) \\<subseteq> \\<Sigma>\n\ngoal (1 subgoal):\n 1. wm_basic (apply_effect (ground_action.effect \\<alpha>) M\\<^sub>0)", "thm sound_opr.cases"], ["proof (prove)\nusing this:\n  Ball (close_world M\\<^sub>0) ((\\<Turnstile>) (close_eq s\\<^sub>0)) \\<and>\n  wm_basic M\\<^sub>0 \\<and>\n  (\\<forall>\\<alpha>\\<in>\\<Sigma>. sound_opr \\<alpha> (f \\<alpha>))\n  set (\\<alpha> # \\<alpha>s) \\<subseteq> \\<Sigma>\n\ngoal (1 subgoal):\n 1. wm_basic (apply_effect (ground_action.effect \\<alpha>) M\\<^sub>0)", "apply (cases \"(\\<alpha>,f \\<alpha>)\" rule: sound_opr.cases)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>pre add del fa.\n       \\<lbrakk>Ball (close_world M\\<^sub>0)\n                 ((\\<Turnstile>) (close_eq s\\<^sub>0)) \\<and>\n                wm_basic M\\<^sub>0 \\<and>\n                (\\<forall>\\<alpha>\\<in>\\<Sigma>.\n                    sound_opr \\<alpha> (f \\<alpha>));\n        set (\\<alpha> # \\<alpha>s) \\<subseteq> \\<Sigma>;\n        (\\<alpha>, f \\<alpha>) =\n        (Ground_Action pre (Effect add del), fa)\\<rbrakk>\n       \\<Longrightarrow> wm_basic\n                          (apply_effect (ground_action.effect \\<alpha>)\n                            M\\<^sub>0)", "apply (auto simp: wm_basic_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  wm_basic (execute_ground_action \\<alpha> M\\<^sub>0)\n\ngoal (1 subgoal):\n 1. \\<And>a \\<alpha>s s\\<^sub>0 M\\<^sub>0.\n       \\<lbrakk>\\<And>s\\<^sub>0 M\\<^sub>0.\n                   \\<lbrakk>sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n                    set \\<alpha>s \\<subseteq> \\<Sigma>;\n                    ground_action_path M\\<^sub>0 \\<alpha>s M'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>s'.\n  compose_actions (map f \\<alpha>s) s\\<^sub>0 = Some s' \\<and>\n  Ball (close_world M') ((\\<Turnstile>) (close_eq s'));\n        sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n        set (a # \\<alpha>s) \\<subseteq> \\<Sigma>;\n        ground_action_path M\\<^sub>0 (a # \\<alpha>s) M'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            compose_actions (map f (a # \\<alpha>s))\n                             s\\<^sub>0 =\n                            Some s' \\<and>\n                            Ball (close_world M')\n                             ((\\<Turnstile>) (close_eq s'))", "ultimately"], ["proof (chain)\npicking this:\n  ?fmla16\n  \\<in> close_world\n         (execute_ground_action \\<alpha> M\\<^sub>0) \\<Longrightarrow>\n  close_eq s\\<^sub>1 \\<Turnstile> ?fmla16\n  ?fmla16 \\<in> execute_ground_action \\<alpha> M\\<^sub>0 \\<Longrightarrow>\n  (\\<forall>atm. ?fmla16 \\<noteq> Atom atm) \\<longrightarrow>\n  ?s16 \\<Turnstile> ?fmla16\n  \\<forall>opr\\<in>\\<Sigma>. sound_opr opr (f opr)\n  wm_basic (execute_ground_action \\<alpha> M\\<^sub>0)", "have \"sound_system \\<Sigma> ?M\\<^sub>1 s\\<^sub>1 f\""], ["proof (prove)\nusing this:\n  ?fmla16\n  \\<in> close_world\n         (execute_ground_action \\<alpha> M\\<^sub>0) \\<Longrightarrow>\n  close_eq s\\<^sub>1 \\<Turnstile> ?fmla16\n  ?fmla16 \\<in> execute_ground_action \\<alpha> M\\<^sub>0 \\<Longrightarrow>\n  (\\<forall>atm. ?fmla16 \\<noteq> Atom atm) \\<longrightarrow>\n  ?s16 \\<Turnstile> ?fmla16\n  \\<forall>opr\\<in>\\<Sigma>. sound_opr opr (f opr)\n  wm_basic (execute_ground_action \\<alpha> M\\<^sub>0)\n\ngoal (1 subgoal):\n 1. sound_system \\<Sigma> (execute_ground_action \\<alpha> M\\<^sub>0)\n     s\\<^sub>1 f", "unfolding sound_system_def"], ["proof (prove)\nusing this:\n  ?fmla16\n  \\<in> close_world\n         (execute_ground_action \\<alpha> M\\<^sub>0) \\<Longrightarrow>\n  close_eq s\\<^sub>1 \\<Turnstile> ?fmla16\n  ?fmla16 \\<in> execute_ground_action \\<alpha> M\\<^sub>0 \\<Longrightarrow>\n  (\\<forall>atm. ?fmla16 \\<noteq> Atom atm) \\<longrightarrow>\n  ?s16 \\<Turnstile> ?fmla16\n  \\<forall>opr\\<in>\\<Sigma>. sound_opr opr (f opr)\n  wm_basic (execute_ground_action \\<alpha> M\\<^sub>0)\n\ngoal (1 subgoal):\n 1. Ball (close_world (execute_ground_action \\<alpha> M\\<^sub>0))\n     ((\\<Turnstile>) (close_eq s\\<^sub>1)) \\<and>\n    wm_basic (execute_ground_action \\<alpha> M\\<^sub>0) \\<and>\n    (\\<forall>\\<alpha>\\<in>\\<Sigma>. sound_opr \\<alpha> (f \\<alpha>))", "by (auto simp: wm_basic_def)"], ["proof (state)\nthis:\n  sound_system \\<Sigma> (execute_ground_action \\<alpha> M\\<^sub>0) s\\<^sub>1\n   f\n\ngoal (1 subgoal):\n 1. \\<And>a \\<alpha>s s\\<^sub>0 M\\<^sub>0.\n       \\<lbrakk>\\<And>s\\<^sub>0 M\\<^sub>0.\n                   \\<lbrakk>sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n                    set \\<alpha>s \\<subseteq> \\<Sigma>;\n                    ground_action_path M\\<^sub>0 \\<alpha>s M'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>s'.\n  compose_actions (map f \\<alpha>s) s\\<^sub>0 = Some s' \\<and>\n  Ball (close_world M') ((\\<Turnstile>) (close_eq s'));\n        sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n        set (a # \\<alpha>s) \\<subseteq> \\<Sigma>;\n        ground_action_path M\\<^sub>0 (a # \\<alpha>s) M'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            compose_actions (map f (a # \\<alpha>s))\n                             s\\<^sub>0 =\n                            Some s' \\<and>\n                            Ball (close_world M')\n                             ((\\<Turnstile>) (close_eq s'))", "from ass.IH[OF this] ass.prems"], ["proof (chain)\npicking this:\n  \\<lbrakk>set \\<alpha>s \\<subseteq> \\<Sigma>;\n   ground_action_path (execute_ground_action \\<alpha> M\\<^sub>0) \\<alpha>s\n    M'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       compose_actions (map f \\<alpha>s) s\\<^sub>1 =\n                       Some s' \\<and>\n                       (\\<forall>a\\<in>close_world M'.\n                           close_eq s' \\<Turnstile> a)\n  sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f\n  set (\\<alpha> # \\<alpha>s) \\<subseteq> \\<Sigma>\n  ground_action_path M\\<^sub>0 (\\<alpha> # \\<alpha>s) M'", "obtain s' where\n      \"compose_actions (map f \\<alpha>s) s\\<^sub>1 = Some s' \\<and> (\\<forall>a\\<in>close_world M'. s' \\<Turnstile>\\<^sub>= a)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>set \\<alpha>s \\<subseteq> \\<Sigma>;\n   ground_action_path (execute_ground_action \\<alpha> M\\<^sub>0) \\<alpha>s\n    M'\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s'.\n                       compose_actions (map f \\<alpha>s) s\\<^sub>1 =\n                       Some s' \\<and>\n                       (\\<forall>a\\<in>close_world M'.\n                           close_eq s' \\<Turnstile> a)\n  sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f\n  set (\\<alpha> # \\<alpha>s) \\<subseteq> \\<Sigma>\n  ground_action_path M\\<^sub>0 (\\<alpha> # \\<alpha>s) M'\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        compose_actions (map f \\<alpha>s) s\\<^sub>1 = Some s' \\<and>\n        (\\<forall>a\\<in>close_world M'.\n            close_eq s' \\<Turnstile> a) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  compose_actions (map f \\<alpha>s) s\\<^sub>1 = Some s' \\<and>\n  (\\<forall>a\\<in>close_world M'. close_eq s' \\<Turnstile> a)\n\ngoal (1 subgoal):\n 1. \\<And>a \\<alpha>s s\\<^sub>0 M\\<^sub>0.\n       \\<lbrakk>\\<And>s\\<^sub>0 M\\<^sub>0.\n                   \\<lbrakk>sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n                    set \\<alpha>s \\<subseteq> \\<Sigma>;\n                    ground_action_path M\\<^sub>0 \\<alpha>s M'\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>s'.\n  compose_actions (map f \\<alpha>s) s\\<^sub>0 = Some s' \\<and>\n  Ball (close_world M') ((\\<Turnstile>) (close_eq s'));\n        sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n        set (a # \\<alpha>s) \\<subseteq> \\<Sigma>;\n        ground_action_path M\\<^sub>0 (a # \\<alpha>s) M'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            compose_actions (map f (a # \\<alpha>s))\n                             s\\<^sub>0 =\n                            Some s' \\<and>\n                            Ball (close_world M')\n                             ((\\<Turnstile>) (close_eq s'))", "thus ?case"], ["proof (prove)\nusing this:\n  compose_actions (map f \\<alpha>s) s\\<^sub>1 = Some s' \\<and>\n  (\\<forall>a\\<in>close_world M'. close_eq s' \\<Turnstile> a)\n\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       compose_actions (map f (\\<alpha> # \\<alpha>s)) s\\<^sub>0 =\n       Some s' \\<and>\n       (\\<forall>a\\<in>close_world M'. close_eq s' \\<Turnstile> a)", "by (auto simp: s1(1))"], ["proof (state)\nthis:\n  \\<exists>s'.\n     compose_actions (map f (\\<alpha> # \\<alpha>s)) s\\<^sub>0 =\n     Some s' \\<and>\n     (\\<forall>a\\<in>close_world M'. close_eq s' \\<Turnstile> a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>s'.\n     compose_actions (map f \\<alpha>s) s\\<^sub>0 = Some s' \\<and>\n     (\\<forall>fmla\\<in>close_world M'. close_eq s' \\<Turnstile> fmla)\n\ngoal (1 subgoal):\n 1. (\\<And>s'.\n        \\<lbrakk>compose_actions (map f \\<alpha>s) s\\<^sub>0 = Some s';\n         \\<forall>fmla\\<in>close_world M'.\n            close_eq s' \\<Turnstile> fmla\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with that"], ["proof (chain)\npicking this:\n  \\<lbrakk>compose_actions (map f \\<alpha>s) s\\<^sub>0 = Some ?s'16;\n   \\<forall>fmla\\<in>close_world M'.\n      close_eq ?s'16 \\<Turnstile> fmla\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<exists>s'.\n     compose_actions (map f \\<alpha>s) s\\<^sub>0 = Some s' \\<and>\n     (\\<forall>fmla\\<in>close_world M'. close_eq s' \\<Turnstile> fmla)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>compose_actions (map f \\<alpha>s) s\\<^sub>0 = Some ?s'16;\n   \\<forall>fmla\\<in>close_world M'.\n      close_eq ?s'16 \\<Turnstile> fmla\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<exists>s'.\n     compose_actions (map f \\<alpha>s) s\\<^sub>0 = Some s' \\<and>\n     (\\<forall>fmla\\<in>close_world M'. close_eq s' \\<Turnstile> fmla)\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>More compact notation of the soundness theorem.\\<close>"], ["", "theorem STRIPS_sema_sound_compact_version:\n    \"sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f \\<Longrightarrow> set \\<alpha>s \\<subseteq> \\<Sigma>\n    \\<Longrightarrow> ground_action_path M\\<^sub>0 \\<alpha>s M'\n    \\<Longrightarrow> \\<exists>s'. compose_actions (map f \\<alpha>s) s\\<^sub>0 = Some s'\n          \\<and> (\\<forall>fmla\\<in>close_world M'. s' \\<Turnstile>\\<^sub>= fmla)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n     set \\<alpha>s \\<subseteq> \\<Sigma>;\n     ground_action_path M\\<^sub>0 \\<alpha>s M'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s'.\n                         compose_actions (map f \\<alpha>s) s\\<^sub>0 =\n                         Some s' \\<and>\n                         (\\<forall>fmla\\<in>close_world M'.\n                             close_eq s' \\<Turnstile> fmla)", "using STRIPS_sema_sound"], ["proof (prove)\nusing this:\n  \\<lbrakk>sound_system ?\\<Sigma> ?M\\<^sub>0 ?s\\<^sub>0 ?f;\n   set ?\\<alpha>s \\<subseteq> ?\\<Sigma>;\n   ground_action_path ?M\\<^sub>0 ?\\<alpha>s ?M';\n   \\<And>s'.\n      \\<lbrakk>compose_actions (map ?f ?\\<alpha>s) ?s\\<^sub>0 = Some s';\n       \\<forall>fmla\\<in>close_world ?M'.\n          close_eq s' \\<Turnstile> fmla\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sound_system \\<Sigma> M\\<^sub>0 s\\<^sub>0 f;\n     set \\<alpha>s \\<subseteq> \\<Sigma>;\n     ground_action_path M\\<^sub>0 \\<alpha>s M'\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s'.\n                         compose_actions (map f \\<alpha>s) s\\<^sub>0 =\n                         Some s' \\<and>\n                         (\\<forall>fmla\\<in>close_world M'.\n                             close_eq s' \\<Turnstile> fmla)", "by metis"], ["", "end \\<comment> \\<open>Context of \\<open>ast_domain\\<close>\\<close>"], ["", "subsection \\<open>Soundness Theorem for PDDL\\<close>"], ["", "context wf_ast_problem begin"], ["", "text \\<open>Mapping world models to states\\<close>"], ["", "definition state_to_wm :: \"state \\<Rightarrow> world_model\"\n    where \"state_to_wm s = ({formula.Atom (predAtm p xs) | p xs. s (p,xs)})\""], ["", "definition wm_to_state :: \"world_model \\<Rightarrow> state\"\n    where \"wm_to_state M = (\\<lambda>(p,xs). (formula.Atom (predAtm p xs)) \\<in> M)\""], ["", "lemma wm_to_state_eq[simp]: \"wm_to_state M (p, as) \\<longleftrightarrow> Atom (predAtm p as) \\<in> M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wm_to_state M (p, as) = (Atom (predAtm p as) \\<in> M)", "by (auto simp: wm_to_state_def)"], ["", "lemma wm_to_state_inv[simp]: \"wm_to_state (state_to_wm s) = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wm_to_state (state_to_wm s) = s", "by (auto simp: wm_to_state_def\n      state_to_wm_def image_def)"], ["", "text \\<open>Mapping AST action instances to actions\\<close>"], ["", "definition \"pddl_opr_to_act g_opr s = (\n    let M = state_to_wm s in\n    if (wm_to_state (close_world M)) \\<Turnstile>\\<^sub>= (precondition g_opr) then\n      Some (wm_to_state (apply_effect (effect g_opr) M))\n    else\n      None)\""], ["", "definition \"close_eq_M M = (M \\<inter> {Atom (predAtm p xs) | p xs. True }) \\<union> {Atom (Eq a a) | a. True} \\<union> {\\<^bold>\\<not>(Atom (Eq a b)) | a b. a\\<noteq>b}\""], ["", "lemma atom_in_wm_eq:\n    \"s \\<Turnstile>\\<^sub>= (formula.Atom atm)\n      \\<longleftrightarrow> ((formula.Atom atm) \\<in> close_eq_M (state_to_wm s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. close_eq s \\<Turnstile> Atom atm =\n    (Atom atm \\<in> close_eq_M (state_to_wm s))", "by (auto simp: wm_to_state_def\n      state_to_wm_def image_def close_eq_M_def close_eq_def split: atom.splits)"], ["", "lemma atom_in_wm_2_eq:\n    \"close_eq (wm_to_state M) \\<Turnstile> (formula.Atom atm)\n      \\<longleftrightarrow> ((formula.Atom atm) \\<in> close_eq_M M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. close_eq (wm_to_state M) \\<Turnstile> Atom atm =\n    (Atom atm \\<in> close_eq_M M)", "by (auto simp: wm_to_state_def\n      state_to_wm_def image_def close_eq_def close_eq_M_def split:atom.splits)"], ["", "lemma not_dels_preserved:\n    assumes \"f \\<notin> (set d)\" \" f \\<in> M\"\n    shows \"f \\<in> apply_effect (Effect a d) M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> apply_effect (Effect a d) M", "using assms"], ["proof (prove)\nusing this:\n  f \\<notin> set d\n  f \\<in> M\n\ngoal (1 subgoal):\n 1. f \\<in> apply_effect (Effect a d) M", "by auto"], ["", "lemma adds_satisfied:\n    assumes \"f \\<in> (set a)\"\n    shows \"f \\<in> apply_effect (Effect a d) M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> apply_effect (Effect a d) M", "using assms"], ["proof (prove)\nusing this:\n  f \\<in> set a\n\ngoal (1 subgoal):\n 1. f \\<in> apply_effect (Effect a d) M", "by auto"], ["", "lemma dels_unsatisfied:\n    assumes \"f \\<in> (set d)\" \"f \\<notin> set a\"\n    shows \"f \\<notin> apply_effect (Effect a d) M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<notin> apply_effect (Effect a d) M", "using assms"], ["proof (prove)\nusing this:\n  f \\<in> set d\n  f \\<notin> set a\n\ngoal (1 subgoal):\n 1. f \\<notin> apply_effect (Effect a d) M", "by auto"], ["", "lemma dels_unsatisfied_2:\n    assumes \"f \\<in> set (dels eff)\" \"f \\<notin> set (adds eff)\"\n    shows \"f \\<notin> apply_effect eff M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<notin> apply_effect eff M", "using assms"], ["proof (prove)\nusing this:\n  f \\<in> set (dels eff)\n  f \\<notin> set (adds eff)\n\ngoal (1 subgoal):\n 1. f \\<notin> apply_effect eff M", "by (cases eff; auto)"], ["", "lemma wf_fmla_atm_is_atom: \"wf_fmla_atom objT f \\<Longrightarrow> is_predAtom f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_fmla_atom objT f \\<Longrightarrow> is_predAtom f", "by (cases f rule: wf_fmla_atom.cases) auto"], ["", "lemma wf_act_adds_are_atoms:\n    assumes \"wf_effect_inst effs\" \"ae \\<in> set (adds effs)\"\n    shows \"is_predAtom ae\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_predAtom ae", "using assms"], ["proof (prove)\nusing this:\n  wf_effect_inst effs\n  ae \\<in> set (adds effs)\n\ngoal (1 subgoal):\n 1. is_predAtom ae", "by (cases effs) (auto simp: wf_fmla_atom_alt)"], ["", "lemma wf_act_adds_dels_atoms:\n    assumes \"wf_effect_inst effs\" \"ae \\<in> set (dels effs)\"\n    shows \"is_predAtom ae\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_predAtom ae", "using assms"], ["proof (prove)\nusing this:\n  wf_effect_inst effs\n  ae \\<in> set (dels effs)\n\ngoal (1 subgoal):\n 1. is_predAtom ae", "by (cases effs) (auto simp: wf_fmla_atom_alt)"], ["", "lemma to_state_close_from_state_eq[simp]: \"wm_to_state (close_world (state_to_wm s)) = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wm_to_state (close_world (state_to_wm s)) = s", "by (auto simp: wm_to_state_def close_world_def\n      state_to_wm_def image_def)"], ["", "lemma wf_eff_pddl_ground_act_is_sound_opr:\n  assumes \"wf_effect_inst (effect g_opr)\"\n  shows \"sound_opr g_opr ((pddl_opr_to_act g_opr))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound_opr g_opr (pddl_opr_to_act g_opr)", "unfolding sound_opr_alt"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>s.\n        close_eq s \\<Turnstile>\n        ground_action.precondition g_opr \\<longrightarrow>\n        (\\<exists>s'.\n            pddl_opr_to_act g_opr s = Some s' \\<and>\n            (\\<forall>atm.\n                is_predAtom atm \\<and>\n                atm \\<notin> set (dels (ground_action.effect g_opr)) \\<and>\n                close_eq s \\<Turnstile> atm \\<longrightarrow>\n                close_eq s' \\<Turnstile> atm) \\<and>\n            (\\<forall>atm.\n                is_predAtom atm \\<and>\n                atm \\<notin> set (adds (ground_action.effect g_opr)) \\<and>\n                close_eq s \\<Turnstile> \\<^bold>\\<not> atm \\<longrightarrow>\n                close_eq s' \\<Turnstile> \\<^bold>\\<not> atm) \\<and>\n            (\\<forall>atm.\n                atm\n                \\<in> set (adds\n                            (ground_action.effect g_opr)) \\<longrightarrow>\n                close_eq s' \\<Turnstile> atm) \\<and>\n            (\\<forall>fmla.\n                fmla \\<in> set (dels (ground_action.effect g_opr)) \\<and>\n                fmla\n                \\<notin> set (adds\n                               (ground_action.effect\n                                 g_opr)) \\<longrightarrow>\n                close_eq s' \\<Turnstile> \\<^bold>\\<not> fmla) \\<and>\n            (\\<forall>a b.\n                close_eq s \\<Turnstile> Atom (Eq a b) \\<longrightarrow>\n                close_eq s' \\<Turnstile> Atom (Eq a b)) \\<and>\n            (\\<forall>a b.\n                close_eq s \\<Turnstile>\n                \\<^bold>\\<not> (Atom (Eq a b)) \\<longrightarrow>\n                close_eq s' \\<Turnstile>\n                \\<^bold>\\<not> (Atom (Eq a b))))) \\<and>\n    Ball (set (adds (ground_action.effect g_opr))) is_predAtom", "apply(cases g_opr; safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x1 x2 s.\n       \\<lbrakk>g_opr = Ground_Action x1 x2;\n        close_eq s \\<Turnstile>\n        ground_action.precondition (Ground_Action x1 x2)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            pddl_opr_to_act (Ground_Action x1 x2) s =\n                            Some s' \\<and>\n                            (\\<forall>atm.\n                                is_predAtom atm \\<and>\n                                atm\n                                \\<notin> set\n    (dels (ground_action.effect (Ground_Action x1 x2))) \\<and>\n                                close_eq s \\<Turnstile>\n                                atm \\<longrightarrow>\n                                close_eq s' \\<Turnstile> atm) \\<and>\n                            (\\<forall>atm.\n                                is_predAtom atm \\<and>\n                                atm\n                                \\<notin> set\n    (adds (ground_action.effect (Ground_Action x1 x2))) \\<and>\n                                close_eq s \\<Turnstile>\n                                \\<^bold>\\<not> atm \\<longrightarrow>\n                                close_eq s' \\<Turnstile>\n                                \\<^bold>\\<not> atm) \\<and>\n                            (\\<forall>atm.\n                                atm\n                                \\<in> set\n (adds (ground_action.effect (Ground_Action x1 x2))) \\<longrightarrow>\n                                close_eq s' \\<Turnstile> atm) \\<and>\n                            (\\<forall>fmla.\n                                fmla\n                                \\<in> set\n (dels (ground_action.effect (Ground_Action x1 x2))) \\<and>\n                                fmla\n                                \\<notin> set\n    (adds (ground_action.effect (Ground_Action x1 x2))) \\<longrightarrow>\n                                close_eq s' \\<Turnstile>\n                                \\<^bold>\\<not> fmla) \\<and>\n                            (\\<forall>a b.\n                                close_eq s \\<Turnstile>\n                                Atom (Eq a b) \\<longrightarrow>\n                                close_eq s' \\<Turnstile>\n                                Atom (Eq a b)) \\<and>\n                            (\\<forall>a b.\n                                close_eq s \\<Turnstile>\n                                \\<^bold>\\<not>\n                                 (Atom (Eq a b)) \\<longrightarrow>\n                                close_eq s' \\<Turnstile>\n                                \\<^bold>\\<not> (Atom (Eq a b)))\n 2. \\<And>x1 x2 x.\n       \\<lbrakk>g_opr = Ground_Action x1 x2;\n        x \\<in> set (adds\n                      (ground_action.effect (Ground_Action x1 x2)))\\<rbrakk>\n       \\<Longrightarrow> is_predAtom x", "subgoal for pre eff s"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g_opr = Ground_Action pre eff;\n     close_eq s \\<Turnstile>\n     ground_action.precondition (Ground_Action pre eff)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>s'.\n                         pddl_opr_to_act (Ground_Action pre eff) s =\n                         Some s' \\<and>\n                         (\\<forall>atm.\n                             is_predAtom atm \\<and>\n                             atm\n                             \\<notin> set\n (dels (ground_action.effect (Ground_Action pre eff))) \\<and>\n                             close_eq s \\<Turnstile> atm \\<longrightarrow>\n                             close_eq s' \\<Turnstile> atm) \\<and>\n                         (\\<forall>atm.\n                             is_predAtom atm \\<and>\n                             atm\n                             \\<notin> set\n (adds (ground_action.effect (Ground_Action pre eff))) \\<and>\n                             close_eq s \\<Turnstile>\n                             \\<^bold>\\<not> atm \\<longrightarrow>\n                             close_eq s' \\<Turnstile>\n                             \\<^bold>\\<not> atm) \\<and>\n                         (\\<forall>atm.\n                             atm\n                             \\<in> set (adds\n   (ground_action.effect (Ground_Action pre eff))) \\<longrightarrow>\n                             close_eq s' \\<Turnstile> atm) \\<and>\n                         (\\<forall>fmla.\n                             fmla\n                             \\<in> set (dels\n   (ground_action.effect (Ground_Action pre eff))) \\<and>\n                             fmla\n                             \\<notin> set\n (adds (ground_action.effect (Ground_Action pre eff))) \\<longrightarrow>\n                             close_eq s' \\<Turnstile>\n                             \\<^bold>\\<not> fmla) \\<and>\n                         (\\<forall>a b.\n                             close_eq s \\<Turnstile>\n                             Atom (Eq a b) \\<longrightarrow>\n                             close_eq s' \\<Turnstile> Atom (Eq a b)) \\<and>\n                         (\\<forall>a b.\n                             close_eq s \\<Turnstile>\n                             \\<^bold>\\<not>\n                              (Atom (Eq a b)) \\<longrightarrow>\n                             close_eq s' \\<Turnstile>\n                             \\<^bold>\\<not> (Atom (Eq a b)))", "apply (rule exI[where x=\"wm_to_state(apply_effect eff (state_to_wm s))\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g_opr = Ground_Action pre eff;\n     close_eq s \\<Turnstile>\n     ground_action.precondition (Ground_Action pre eff)\\<rbrakk>\n    \\<Longrightarrow> pddl_opr_to_act (Ground_Action pre eff) s =\n                      Some\n                       (wm_to_state\n                         (apply_effect eff (state_to_wm s))) \\<and>\n                      (\\<forall>atm.\n                          is_predAtom atm \\<and>\n                          atm\n                          \\<notin> set (dels\n   (ground_action.effect (Ground_Action pre eff))) \\<and>\n                          close_eq s \\<Turnstile> atm \\<longrightarrow>\n                          close_eq\n                           (wm_to_state\n                             (apply_effect eff\n                               (state_to_wm s))) \\<Turnstile>\n                          atm) \\<and>\n                      (\\<forall>atm.\n                          is_predAtom atm \\<and>\n                          atm\n                          \\<notin> set (adds\n   (ground_action.effect (Ground_Action pre eff))) \\<and>\n                          close_eq s \\<Turnstile>\n                          \\<^bold>\\<not> atm \\<longrightarrow>\n                          close_eq\n                           (wm_to_state\n                             (apply_effect eff\n                               (state_to_wm s))) \\<Turnstile>\n                          \\<^bold>\\<not> atm) \\<and>\n                      (\\<forall>atm.\n                          atm\n                          \\<in> set (adds\n(ground_action.effect (Ground_Action pre eff))) \\<longrightarrow>\n                          close_eq\n                           (wm_to_state\n                             (apply_effect eff\n                               (state_to_wm s))) \\<Turnstile>\n                          atm) \\<and>\n                      (\\<forall>fmla.\n                          fmla\n                          \\<in> set (dels\n(ground_action.effect (Ground_Action pre eff))) \\<and>\n                          fmla\n                          \\<notin> set (adds\n   (ground_action.effect (Ground_Action pre eff))) \\<longrightarrow>\n                          close_eq\n                           (wm_to_state\n                             (apply_effect eff\n                               (state_to_wm s))) \\<Turnstile>\n                          \\<^bold>\\<not> fmla) \\<and>\n                      (\\<forall>a b.\n                          close_eq s \\<Turnstile>\n                          Atom (Eq a b) \\<longrightarrow>\n                          close_eq\n                           (wm_to_state\n                             (apply_effect eff\n                               (state_to_wm s))) \\<Turnstile>\n                          Atom (Eq a b)) \\<and>\n                      (\\<forall>a b.\n                          close_eq s \\<Turnstile>\n                          \\<^bold>\\<not> (Atom (Eq a b)) \\<longrightarrow>\n                          close_eq\n                           (wm_to_state\n                             (apply_effect eff\n                               (state_to_wm s))) \\<Turnstile>\n                          \\<^bold>\\<not> (Atom (Eq a b)))", "apply (auto simp: pddl_opr_to_act_def Let_def split:if_splits)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>atm.\n       \\<lbrakk>g_opr = Ground_Action pre eff; close_eq s \\<Turnstile> pre;\n        is_predAtom atm; atm \\<notin> set (dels eff);\n        close_eq s \\<Turnstile> atm\\<rbrakk>\n       \\<Longrightarrow> close_eq\n                          (wm_to_state\n                            (apply_effect eff (state_to_wm s))) \\<Turnstile>\n                         atm\n 2. \\<And>atm.\n       \\<lbrakk>g_opr = Ground_Action pre eff; close_eq s \\<Turnstile> pre;\n        is_predAtom atm; atm \\<notin> set (adds eff);\n        \\<not> close_eq s \\<Turnstile> atm;\n        close_eq\n         (wm_to_state (apply_effect eff (state_to_wm s))) \\<Turnstile>\n        atm\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>atm.\n       \\<lbrakk>g_opr = Ground_Action pre eff; close_eq s \\<Turnstile> pre;\n        atm \\<in> set (adds eff)\\<rbrakk>\n       \\<Longrightarrow> close_eq\n                          (wm_to_state\n                            (apply_effect eff (state_to_wm s))) \\<Turnstile>\n                         atm\n 4. \\<And>fmla.\n       \\<lbrakk>g_opr = Ground_Action pre eff; close_eq s \\<Turnstile> pre;\n        fmla \\<in> set (dels eff); fmla \\<notin> set (adds eff);\n        close_eq\n         (wm_to_state (apply_effect eff (state_to_wm s))) \\<Turnstile>\n        fmla\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal for atm"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g_opr = Ground_Action pre eff; close_eq s \\<Turnstile> pre;\n     is_predAtom atm; atm \\<notin> set (dels eff);\n     close_eq s \\<Turnstile> atm\\<rbrakk>\n    \\<Longrightarrow> close_eq\n                       (wm_to_state\n                         (apply_effect eff (state_to_wm s))) \\<Turnstile>\n                      atm", "by (cases eff; cases atm; auto simp: close_eq_def wm_to_state_def state_to_wm_def split: atom.splits)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>atm.\n       \\<lbrakk>g_opr = Ground_Action pre eff; close_eq s \\<Turnstile> pre;\n        is_predAtom atm; atm \\<notin> set (adds eff);\n        \\<not> close_eq s \\<Turnstile> atm;\n        close_eq\n         (wm_to_state (apply_effect eff (state_to_wm s))) \\<Turnstile>\n        atm\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>atm.\n       \\<lbrakk>g_opr = Ground_Action pre eff; close_eq s \\<Turnstile> pre;\n        atm \\<in> set (adds eff)\\<rbrakk>\n       \\<Longrightarrow> close_eq\n                          (wm_to_state\n                            (apply_effect eff (state_to_wm s))) \\<Turnstile>\n                         atm\n 3. \\<And>fmla.\n       \\<lbrakk>g_opr = Ground_Action pre eff; close_eq s \\<Turnstile> pre;\n        fmla \\<in> set (dels eff); fmla \\<notin> set (adds eff);\n        close_eq\n         (wm_to_state (apply_effect eff (state_to_wm s))) \\<Turnstile>\n        fmla\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal for atm"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g_opr = Ground_Action pre eff; close_eq s \\<Turnstile> pre;\n     is_predAtom atm; atm \\<notin> set (adds eff);\n     \\<not> close_eq s \\<Turnstile> atm;\n     close_eq (wm_to_state (apply_effect eff (state_to_wm s))) \\<Turnstile>\n     atm\\<rbrakk>\n    \\<Longrightarrow> False", "by (cases eff; cases atm; auto simp: close_eq_def wm_to_state_def state_to_wm_def split: atom.splits)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>atm.\n       \\<lbrakk>g_opr = Ground_Action pre eff; close_eq s \\<Turnstile> pre;\n        atm \\<in> set (adds eff)\\<rbrakk>\n       \\<Longrightarrow> close_eq\n                          (wm_to_state\n                            (apply_effect eff (state_to_wm s))) \\<Turnstile>\n                         atm\n 2. \\<And>fmla.\n       \\<lbrakk>g_opr = Ground_Action pre eff; close_eq s \\<Turnstile> pre;\n        fmla \\<in> set (dels eff); fmla \\<notin> set (adds eff);\n        close_eq\n         (wm_to_state (apply_effect eff (state_to_wm s))) \\<Turnstile>\n        fmla\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal for atm"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g_opr = Ground_Action pre eff; close_eq s \\<Turnstile> pre;\n     atm \\<in> set (adds eff)\\<rbrakk>\n    \\<Longrightarrow> close_eq\n                       (wm_to_state\n                         (apply_effect eff (state_to_wm s))) \\<Turnstile>\n                      atm", "using assms"], ["proof (prove)\nusing this:\n  wf_effect_inst (ground_action.effect g_opr)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>g_opr = Ground_Action pre eff; close_eq s \\<Turnstile> pre;\n     atm \\<in> set (adds eff)\\<rbrakk>\n    \\<Longrightarrow> close_eq\n                       (wm_to_state\n                         (apply_effect eff (state_to_wm s))) \\<Turnstile>\n                      atm", "by (cases eff; cases atm; force simp: close_eq_def wm_to_state_def state_to_wm_def split: atom.splits)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>fmla.\n       \\<lbrakk>g_opr = Ground_Action pre eff; close_eq s \\<Turnstile> pre;\n        fmla \\<in> set (dels eff); fmla \\<notin> set (adds eff);\n        close_eq\n         (wm_to_state (apply_effect eff (state_to_wm s))) \\<Turnstile>\n        fmla\\<rbrakk>\n       \\<Longrightarrow> False", "subgoal for fmla"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g_opr = Ground_Action pre eff; close_eq s \\<Turnstile> pre;\n     fmla \\<in> set (dels eff); fmla \\<notin> set (adds eff);\n     close_eq (wm_to_state (apply_effect eff (state_to_wm s))) \\<Turnstile>\n     fmla\\<rbrakk>\n    \\<Longrightarrow> False", "using assms"], ["proof (prove)\nusing this:\n  wf_effect_inst (ground_action.effect g_opr)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>g_opr = Ground_Action pre eff; close_eq s \\<Turnstile> pre;\n     fmla \\<in> set (dels eff); fmla \\<notin> set (adds eff);\n     close_eq (wm_to_state (apply_effect eff (state_to_wm s))) \\<Turnstile>\n     fmla\\<rbrakk>\n    \\<Longrightarrow> False", "by (cases eff; cases fmla rule: wf_fmla_atom.cases; force simp: close_eq_def wm_to_state_def state_to_wm_def split: atom.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x.\n       \\<lbrakk>g_opr = Ground_Action x1 x2;\n        x \\<in> set (adds\n                      (ground_action.effect (Ground_Action x1 x2)))\\<rbrakk>\n       \\<Longrightarrow> is_predAtom x", "subgoal for pre eff fmla"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>g_opr = Ground_Action pre eff;\n     fmla\n     \\<in> set (adds\n                 (ground_action.effect (Ground_Action pre eff)))\\<rbrakk>\n    \\<Longrightarrow> is_predAtom fmla", "using assms"], ["proof (prove)\nusing this:\n  wf_effect_inst (ground_action.effect g_opr)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>g_opr = Ground_Action pre eff;\n     fmla\n     \\<in> set (adds\n                 (ground_action.effect (Ground_Action pre eff)))\\<rbrakk>\n    \\<Longrightarrow> is_predAtom fmla", "by (cases eff; cases fmla rule: wf_fmla_atom.cases; force)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma wf_eff_impt_wf_eff_inst: \"wf_effect objT eff \\<Longrightarrow> wf_effect_inst eff\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_effect objT eff \\<Longrightarrow> wf_effect_inst eff", "by (cases eff; auto simp add: wf_fmla_atom_alt)"], ["", "lemma wf_pddl_ground_act_is_sound_opr:\n    assumes \"wf_ground_action g_opr\"\n    shows \"sound_opr g_opr (pddl_opr_to_act g_opr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound_opr g_opr (pddl_opr_to_act g_opr)", "using wf_eff_impt_wf_eff_inst wf_eff_pddl_ground_act_is_sound_opr assms"], ["proof (prove)\nusing this:\n  wf_effect objT ?eff \\<Longrightarrow> wf_effect_inst ?eff\n  wf_effect_inst (ground_action.effect ?g_opr) \\<Longrightarrow>\n  sound_opr ?g_opr (pddl_opr_to_act ?g_opr)\n  wf_ground_action g_opr\n\ngoal (1 subgoal):\n 1. sound_opr g_opr (pddl_opr_to_act g_opr)", "by (cases g_opr; auto)"], ["", "lemma wf_action_schema_sound_inst:\n    assumes \"action_params_match act args\" \"wf_action_schema act\"\n    shows \"sound_opr\n      (instantiate_action_schema act args)\n      ((pddl_opr_to_act (instantiate_action_schema act args)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound_opr (instantiate_action_schema act args)\n     (pddl_opr_to_act (instantiate_action_schema act args))", "using\n      wf_pddl_ground_act_is_sound_opr[\n        OF wf_instantiate_action_schema[OF assms]]"], ["proof (prove)\nusing this:\n  sound_opr (instantiate_action_schema act args)\n   (pddl_opr_to_act (instantiate_action_schema act args))\n\ngoal (1 subgoal):\n 1. sound_opr (instantiate_action_schema act args)\n     (pddl_opr_to_act (instantiate_action_schema act args))", "by blast"], ["", "lemma wf_plan_act_is_sound:\n    assumes \"wf_plan_action (PAction n args)\"\n    shows \"sound_opr\n      (instantiate_action_schema (the (resolve_action_schema n)) args)\n      ((pddl_opr_to_act\n        (instantiate_action_schema (the (resolve_action_schema n)) args)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound_opr\n     (instantiate_action_schema (the (resolve_action_schema n)) args)\n     (pddl_opr_to_act\n       (instantiate_action_schema (the (resolve_action_schema n)) args))", "using assms"], ["proof (prove)\nusing this:\n  wf_plan_action (PAction n args)\n\ngoal (1 subgoal):\n 1. sound_opr\n     (instantiate_action_schema (the (resolve_action_schema n)) args)\n     (pddl_opr_to_act\n       (instantiate_action_schema (the (resolve_action_schema n)) args))", "using wf_action_schema_sound_inst wf_eff_pddl_ground_act_is_sound_opr"], ["proof (prove)\nusing this:\n  wf_plan_action (PAction n args)\n  \\<lbrakk>action_params_match ?act ?args; wf_action_schema ?act\\<rbrakk>\n  \\<Longrightarrow> sound_opr (instantiate_action_schema ?act ?args)\n                     (pddl_opr_to_act\n                       (instantiate_action_schema ?act ?args))\n  wf_effect_inst (ground_action.effect ?g_opr) \\<Longrightarrow>\n  sound_opr ?g_opr (pddl_opr_to_act ?g_opr)\n\ngoal (1 subgoal):\n 1. sound_opr\n     (instantiate_action_schema (the (resolve_action_schema n)) args)\n     (pddl_opr_to_act\n       (instantiate_action_schema (the (resolve_action_schema n)) args))", "by (auto split: option.splits)"], ["", "lemma wf_plan_act_is_sound':\n    assumes \"wf_plan_action \\<pi>\"\n    shows \"sound_opr\n      (resolve_instantiate \\<pi>)\n      ((pddl_opr_to_act (resolve_instantiate \\<pi>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound_opr (resolve_instantiate \\<pi>)\n     (pddl_opr_to_act (resolve_instantiate \\<pi>))", "using assms wf_plan_act_is_sound"], ["proof (prove)\nusing this:\n  wf_plan_action \\<pi>\n  wf_plan_action (PAction ?n ?args) \\<Longrightarrow>\n  sound_opr\n   (instantiate_action_schema (the (resolve_action_schema ?n)) ?args)\n   (pddl_opr_to_act\n     (instantiate_action_schema (the (resolve_action_schema ?n)) ?args))\n\ngoal (1 subgoal):\n 1. sound_opr (resolve_instantiate \\<pi>)\n     (pddl_opr_to_act (resolve_instantiate \\<pi>))", "by (cases \\<pi>; auto )"], ["", "lemma wf_world_model_has_atoms: \"f\\<in>M \\<Longrightarrow> wf_world_model M \\<Longrightarrow> is_predAtom f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> M; wf_world_model M\\<rbrakk>\n    \\<Longrightarrow> is_predAtom f", "using wf_fmla_atm_is_atom"], ["proof (prove)\nusing this:\n  wf_fmla_atom objT ?f \\<Longrightarrow> is_predAtom ?f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> M; wf_world_model M\\<rbrakk>\n    \\<Longrightarrow> is_predAtom f", "unfolding wf_world_model_def"], ["proof (prove)\nusing this:\n  wf_fmla_atom objT ?f \\<Longrightarrow> is_predAtom ?f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>f \\<in> M; Ball M (wf_fmla_atom objT)\\<rbrakk>\n    \\<Longrightarrow> is_predAtom f", "by auto"], ["", "lemma wm_to_state_works_for_wf_wm_closed:\n    \"wf_world_model M \\<Longrightarrow> fmla\\<in>close_world M \\<Longrightarrow> close_eq (wm_to_state M) \\<Turnstile> fmla\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_world_model M; fmla \\<in> close_world M\\<rbrakk>\n    \\<Longrightarrow> close_eq (wm_to_state M) \\<Turnstile> fmla", "apply (cases fmla rule: wf_fmla_atom.cases)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>a vs.\n       \\<lbrakk>wf_world_model M; fmla \\<in> close_world M;\n        fmla = Atom (predAtm a vs)\\<rbrakk>\n       \\<Longrightarrow> close_eq (wm_to_state M) \\<Turnstile> fmla\n 2. \\<And>va vb.\n       \\<lbrakk>wf_world_model M; fmla \\<in> close_world M;\n        fmla = Atom (Eq va vb)\\<rbrakk>\n       \\<Longrightarrow> close_eq (wm_to_state M) \\<Turnstile> fmla\n 3. \\<lbrakk>wf_world_model M; fmla \\<in> close_world M;\n     fmla = \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> close_eq (wm_to_state M) \\<Turnstile> fmla\n 4. \\<And>v.\n       \\<lbrakk>wf_world_model M; fmla \\<in> close_world M;\n        fmla = \\<^bold>\\<not> v\\<rbrakk>\n       \\<Longrightarrow> close_eq (wm_to_state M) \\<Turnstile> fmla\n 5. \\<And>v va.\n       \\<lbrakk>wf_world_model M; fmla \\<in> close_world M;\n        fmla = v \\<^bold>\\<and> va\\<rbrakk>\n       \\<Longrightarrow> close_eq (wm_to_state M) \\<Turnstile> fmla\n 6. \\<And>v va.\n       \\<lbrakk>wf_world_model M; fmla \\<in> close_world M;\n        fmla = v \\<^bold>\\<or> va\\<rbrakk>\n       \\<Longrightarrow> close_eq (wm_to_state M) \\<Turnstile> fmla\n 7. \\<And>v va.\n       \\<lbrakk>wf_world_model M; fmla \\<in> close_world M;\n        fmla = v \\<^bold>\\<rightarrow> va\\<rbrakk>\n       \\<Longrightarrow> close_eq (wm_to_state M) \\<Turnstile> fmla", "by (auto simp: wf_world_model_def close_eq_def wm_to_state_def close_world_def)"], ["", "lemma wm_to_state_works_for_wf_wm: \"wf_world_model M \\<Longrightarrow> fmla\\<in>M \\<Longrightarrow> close_eq (wm_to_state M) \\<Turnstile> fmla\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_world_model M; fmla \\<in> M\\<rbrakk>\n    \\<Longrightarrow> close_eq (wm_to_state M) \\<Turnstile> fmla", "apply (cases fmla rule: wf_fmla_atom.cases)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>a vs.\n       \\<lbrakk>wf_world_model M; fmla \\<in> M;\n        fmla = Atom (predAtm a vs)\\<rbrakk>\n       \\<Longrightarrow> close_eq (wm_to_state M) \\<Turnstile> fmla\n 2. \\<And>va vb.\n       \\<lbrakk>wf_world_model M; fmla \\<in> M;\n        fmla = Atom (Eq va vb)\\<rbrakk>\n       \\<Longrightarrow> close_eq (wm_to_state M) \\<Turnstile> fmla\n 3. \\<lbrakk>wf_world_model M; fmla \\<in> M; fmla = \\<bottom>\\<rbrakk>\n    \\<Longrightarrow> close_eq (wm_to_state M) \\<Turnstile> fmla\n 4. \\<And>v.\n       \\<lbrakk>wf_world_model M; fmla \\<in> M;\n        fmla = \\<^bold>\\<not> v\\<rbrakk>\n       \\<Longrightarrow> close_eq (wm_to_state M) \\<Turnstile> fmla\n 5. \\<And>v va.\n       \\<lbrakk>wf_world_model M; fmla \\<in> M;\n        fmla = v \\<^bold>\\<and> va\\<rbrakk>\n       \\<Longrightarrow> close_eq (wm_to_state M) \\<Turnstile> fmla\n 6. \\<And>v va.\n       \\<lbrakk>wf_world_model M; fmla \\<in> M;\n        fmla = v \\<^bold>\\<or> va\\<rbrakk>\n       \\<Longrightarrow> close_eq (wm_to_state M) \\<Turnstile> fmla\n 7. \\<And>v va.\n       \\<lbrakk>wf_world_model M; fmla \\<in> M;\n        fmla = v \\<^bold>\\<rightarrow> va\\<rbrakk>\n       \\<Longrightarrow> close_eq (wm_to_state M) \\<Turnstile> fmla", "by (auto simp: wf_world_model_def close_eq_def wm_to_state_def)"], ["", "lemma wm_to_state_works_for_I_closed:\n    assumes \"x \\<in> close_world I\"\n    shows \"close_eq (wm_to_state I) \\<Turnstile> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. close_eq (wm_to_state I) \\<Turnstile> x", "apply (rule wm_to_state_works_for_wf_wm_closed)"], ["proof (prove)\ngoal (2 subgoals):\n 1. wf_world_model I\n 2. x \\<in> close_world I", "using assms wf_I"], ["proof (prove)\nusing this:\n  x \\<in> close_world I\n  wf_world_model I\n\ngoal (2 subgoals):\n 1. wf_world_model I\n 2. x \\<in> close_world I", "by auto"], ["", "lemma wf_wm_imp_basic: \"wf_world_model M \\<Longrightarrow> wm_basic M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_world_model M \\<Longrightarrow> wm_basic M", "by (auto simp: wf_world_model_def wm_basic_def wf_fmla_atm_is_atom)"], ["", "theorem wf_plan_sound_system:\n  assumes \"\\<forall>\\<pi>\\<in> set \\<pi>s. wf_plan_action \\<pi>\"\n  shows \"sound_system\n      (set (map resolve_instantiate \\<pi>s))\n      I\n      (wm_to_state I)\n      ((\\<lambda>\\<alpha>. pddl_opr_to_act \\<alpha>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound_system (set (map resolve_instantiate \\<pi>s)) I (wm_to_state I)\n     pddl_opr_to_act", "unfolding sound_system_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ball (close_world I) ((\\<Turnstile>) (close_eq (wm_to_state I))) \\<and>\n    wm_basic I \\<and>\n    (\\<forall>\\<alpha>\\<in>set (map resolve_instantiate \\<pi>s).\n        sound_opr \\<alpha> (pddl_opr_to_act \\<alpha>))", "proof(intro conjI ballI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> close_world I \\<Longrightarrow>\n       close_eq (wm_to_state I) \\<Turnstile> x\n 2. wm_basic I\n 3. \\<And>\\<alpha>.\n       \\<alpha> \\<in> set (map resolve_instantiate \\<pi>s) \\<Longrightarrow>\n       sound_opr \\<alpha> (pddl_opr_to_act \\<alpha>)", "show \"close_eq(wm_to_state I) \\<Turnstile> x\" if \"x \\<in> close_world I\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. close_eq (wm_to_state I) \\<Turnstile> x", "using that[unfolded in_close_world_conv]\n      wm_to_state_works_for_I_closed wm_to_state_works_for_wf_wm"], ["proof (prove)\nusing this:\n  x \\<in> I \\<or>\n  (\\<exists>p as.\n      x = \\<^bold>\\<not> (Atom (predAtm p as)) \\<and>\n      Atom (predAtm p as) \\<notin> I) \\<or>\n  (\\<exists>a. x = Atom (Eq a a)) \\<or>\n  (\\<exists>a b. x = \\<^bold>\\<not> (Atom (Eq a b)) \\<and> a \\<noteq> b)\n  ?x \\<in> close_world I \\<Longrightarrow>\n  close_eq (wm_to_state I) \\<Turnstile> ?x\n  \\<lbrakk>wf_world_model ?M; ?fmla \\<in> ?M\\<rbrakk>\n  \\<Longrightarrow> close_eq (wm_to_state ?M) \\<Turnstile> ?fmla\n\ngoal (1 subgoal):\n 1. close_eq (wm_to_state I) \\<Turnstile> x", "by (auto simp: wf_I)"], ["proof (state)\nthis:\n  ?x16 \\<in> close_world I \\<Longrightarrow>\n  close_eq (wm_to_state I) \\<Turnstile> ?x16\n\ngoal (2 subgoals):\n 1. wm_basic I\n 2. \\<And>\\<alpha>.\n       \\<alpha> \\<in> set (map resolve_instantiate \\<pi>s) \\<Longrightarrow>\n       sound_opr \\<alpha> (pddl_opr_to_act \\<alpha>)", "show \"wm_basic I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wm_basic I", "using wf_wm_imp_basic[OF wf_I]"], ["proof (prove)\nusing this:\n  wm_basic I\n\ngoal (1 subgoal):\n 1. wm_basic I", "."], ["proof (state)\nthis:\n  wm_basic I\n\ngoal (1 subgoal):\n 1. \\<And>\\<alpha>.\n       \\<alpha> \\<in> set (map resolve_instantiate \\<pi>s) \\<Longrightarrow>\n       sound_opr \\<alpha> (pddl_opr_to_act \\<alpha>)", "show \"sound_opr \\<alpha> (pddl_opr_to_act \\<alpha>)\" if \"\\<alpha> \\<in> set (map resolve_instantiate \\<pi>s)\" for \\<alpha>"], ["proof (prove)\ngoal (1 subgoal):\n 1. sound_opr \\<alpha> (pddl_opr_to_act \\<alpha>)", "using that"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> set (map resolve_instantiate \\<pi>s)\n\ngoal (1 subgoal):\n 1. sound_opr \\<alpha> (pddl_opr_to_act \\<alpha>)", "using wf_plan_act_is_sound' assms"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> set (map resolve_instantiate \\<pi>s)\n  wf_plan_action ?\\<pi> \\<Longrightarrow>\n  sound_opr (resolve_instantiate ?\\<pi>)\n   (pddl_opr_to_act (resolve_instantiate ?\\<pi>))\n  Ball (set \\<pi>s) wf_plan_action\n\ngoal (1 subgoal):\n 1. sound_opr \\<alpha> (pddl_opr_to_act \\<alpha>)", "by auto"], ["proof (state)\nthis:\n  ?\\<alpha>16 \\<in> set (map resolve_instantiate \\<pi>s) \\<Longrightarrow>\n  sound_opr ?\\<alpha>16 (pddl_opr_to_act ?\\<alpha>16)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem wf_plan_soundness_theorem:\n    assumes \"plan_action_path I \\<pi>s M\"\n    defines \"\\<alpha>s \\<equiv> map (pddl_opr_to_act \\<circ> resolve_instantiate) \\<pi>s\"\n    defines \"s\\<^sub>0 \\<equiv> wm_to_state I\"\n    shows \"\\<exists>s'. compose_actions \\<alpha>s s\\<^sub>0 = Some s' \\<and> (\\<forall>\\<phi>\\<in>close_world M. s' \\<Turnstile>\\<^sub>= \\<phi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s'.\n       compose_actions \\<alpha>s s\\<^sub>0 = Some s' \\<and>\n       (\\<forall>\\<phi>\\<in>close_world M. close_eq s' \\<Turnstile> \\<phi>)", "apply (rule STRIPS_sema_sound)"], ["proof (prove)\ngoal (4 subgoals):\n 1. sound_system ?\\<Sigma> ?M\\<^sub>0 ?s\\<^sub>0 ?f\n 2. set ?\\<alpha>s \\<subseteq> ?\\<Sigma>\n 3. ground_action_path ?M\\<^sub>0 ?\\<alpha>s ?M'\n 4. \\<And>s'.\n       \\<lbrakk>compose_actions (map ?f ?\\<alpha>s) ?s\\<^sub>0 = Some s';\n        \\<forall>fmla\\<in>close_world ?M'.\n           close_eq s' \\<Turnstile> fmla\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            compose_actions \\<alpha>s s\\<^sub>0 =\n                            Some s' \\<and>\n                            (\\<forall>\\<phi>\\<in>close_world M.\n                                close_eq s' \\<Turnstile> \\<phi>)", "apply (rule wf_plan_sound_system)"], ["proof (prove)\ngoal (4 subgoals):\n 1. Ball (set ?\\<pi>s5) wf_plan_action\n 2. set ?\\<alpha>s \\<subseteq> set (map resolve_instantiate ?\\<pi>s5)\n 3. ground_action_path I ?\\<alpha>s ?M'\n 4. \\<And>s'.\n       \\<lbrakk>compose_actions (map pddl_opr_to_act ?\\<alpha>s)\n                 (wm_to_state I) =\n                Some s';\n        \\<forall>fmla\\<in>close_world ?M'.\n           close_eq s' \\<Turnstile> fmla\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            compose_actions \\<alpha>s s\\<^sub>0 =\n                            Some s' \\<and>\n                            (\\<forall>\\<phi>\\<in>close_world M.\n                                close_eq s' \\<Turnstile> \\<phi>)", "using assms"], ["proof (prove)\nusing this:\n  plan_action_path I \\<pi>s M\n  \\<alpha>s \\<equiv>\n  map ((pddl_opr_to_act \\<circ>\\<circ> ast_problem.resolve_instantiate) P)\n   \\<pi>s\n  s\\<^sub>0 \\<equiv> wm_to_state I\n\ngoal (4 subgoals):\n 1. Ball (set ?\\<pi>s5) wf_plan_action\n 2. set ?\\<alpha>s \\<subseteq> set (map resolve_instantiate ?\\<pi>s5)\n 3. ground_action_path I ?\\<alpha>s ?M'\n 4. \\<And>s'.\n       \\<lbrakk>compose_actions (map pddl_opr_to_act ?\\<alpha>s)\n                 (wm_to_state I) =\n                Some s';\n        \\<forall>fmla\\<in>close_world ?M'.\n           close_eq s' \\<Turnstile> fmla\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            compose_actions \\<alpha>s s\\<^sub>0 =\n                            Some s' \\<and>\n                            (\\<forall>\\<phi>\\<in>close_world M.\n                                close_eq s' \\<Turnstile> \\<phi>)", "unfolding plan_action_path_def"], ["proof (prove)\nusing this:\n  Ball (set \\<pi>s) wf_plan_action \\<and>\n  ground_action_path I (map resolve_instantiate \\<pi>s) M\n  \\<alpha>s \\<equiv>\n  map ((pddl_opr_to_act \\<circ>\\<circ> ast_problem.resolve_instantiate) P)\n   \\<pi>s\n  s\\<^sub>0 \\<equiv> wm_to_state I\n\ngoal (4 subgoals):\n 1. Ball (set ?\\<pi>s5) wf_plan_action\n 2. set ?\\<alpha>s \\<subseteq> set (map resolve_instantiate ?\\<pi>s5)\n 3. ground_action_path I ?\\<alpha>s ?M'\n 4. \\<And>s'.\n       \\<lbrakk>compose_actions (map pddl_opr_to_act ?\\<alpha>s)\n                 (wm_to_state I) =\n                Some s';\n        \\<forall>fmla\\<in>close_world ?M'.\n           close_eq s' \\<Turnstile> fmla\\<rbrakk>\n       \\<Longrightarrow> \\<exists>s'.\n                            compose_actions \\<alpha>s s\\<^sub>0 =\n                            Some s' \\<and>\n                            (\\<forall>\\<phi>\\<in>close_world M.\n                                close_eq s' \\<Turnstile> \\<phi>)", "by (auto simp add: image_def)"], ["", "end \\<comment> \\<open>Context of \\<open>wf_ast_problem\\<close>\\<close>"], ["", "end"]]}