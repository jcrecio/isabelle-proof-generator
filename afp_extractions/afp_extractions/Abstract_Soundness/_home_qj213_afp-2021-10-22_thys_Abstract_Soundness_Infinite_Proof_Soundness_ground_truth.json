{"file_name": "/home/qj213/afp-2021-10-22/thys/Abstract_Soundness/Infinite_Proof_Soundness.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Abstract_Soundness", "problem_names": ["lemma num:\n  assumes ev: \"ev (\\<lambda>xs. P (shd xs)) xs\"\n  defines \"n \\<equiv> num P xs\"\n  shows\n    \"(list_all (Not o P) (stake n xs) \\<and> P (xs!!n)) \\<and>\n (\\<forall>m. list_all (Not o P) (stake m xs) \\<and> P (xs!!m) \\<longrightarrow> n \\<le> m)\"", "lemma num_stl[simp]:\n  assumes \"ev (\\<lambda>xs. P (shd xs)) xs\" and \"\\<not> P (shd xs)\"\n  shows \"num P xs = Suc (num P (stl xs))\"", "lemmas well_order_on_defs =\n  well_order_on_def linear_order_on_def partial_order_on_def\n  preorder_on_def trans_def antisym_def refl_on_def", "lemma sdrop_length_shift[simp]:\n  \"sdrop (length xs) (xs @- s) = s\"", "lemma ev_iff_shift:\n  \"ev \\<phi> xs \\<longleftrightarrow> (\\<exists>xl xs2. xs = xl @- xs2 \\<and> \\<phi> xs2)\"", "lemma tfinite_good: \"tfinite t \\<Longrightarrow> good t\"", "lemma stl_konigDtree:\n  fixes t defines \"s \\<equiv> fst (root t)\" and \"r \\<equiv> snd (root t)\"\n  assumes s': \"s' |\\<in>| fimage (fst o root) (cont t)\"  and \"pred (s,a) r (s',a'')\" and \"inv (s',a'')\"\n  shows \"\\<exists>t' a'. t' |\\<in>| cont t \\<and> pred (s,a) r (fst (root t'),a') \\<and> inv (fst (root t'),a')\n  \\<and> stl (konigDtree t a) = konigDtree t' a'\"", "lemma konigDtree:\n  assumes 1: \"\\<And>r s sl a.\n  \\<lbrakk>r \\<in> R; eff r s sl; inv (s,a)\\<rbrakk> \\<Longrightarrow>\n  \\<exists>s' a'. s' |\\<in>| sl \\<and> inv (s',a') \\<and> pred (s,a) r (s',a')\"\n    and 2: \"wf t\" \"inv (fst (root t), a)\"\n  shows\n    \"alw (\\<lambda>stepas.\n        let ((s,r),a) = shd stepas; ((s',_),a') = shd (stl stepas) in\n          inv (s,a) \\<and> pred (s,a) r (s',a'))\n     (konigDtree t a)\"", "lemma konigDtree_ipath:\n  assumes \"\\<And>r s sl a.\n  \\<lbrakk>r \\<in> R; eff r s sl; inv (s,a)\\<rbrakk> \\<Longrightarrow>\n  \\<exists>s' a'. s' |\\<in>| sl \\<and> inv (s',a') \\<and> pred (s,a) r (s',a')\"\n    and \"wf t\" and \"inv (fst (root t), a)\"\n  shows \"ipath t (smap fst (konigDtree t a))\"", "lemma follow_stl_smap_fst[simp]:\n  \"follow bs Ms (smap fst stepSs) \\<Longrightarrow>\n   follow (stl bs) (stl Ms) (smap fst (stl stepSs))\"", "lemma epath_stl_smap_fst[simp]:\n  \"epath (smap fst stepSs) \\<Longrightarrow>\n   epath (smap fst (stl stepSs))\"", "lemma infDecr_tl[simp]: \"infDecr bs \\<Longrightarrow> infDecr (stl bs)\"", "lemma descentE[elim]:\n  assumes \"descent (s,S) r (s',S')\" and \"(v,b,v') \\<in> \\<delta> s r s'\"\n  shows \"(\\<sigma>(v',S'), \\<sigma>(v,S)) \\<in> Ord \\<and> (b \\<longrightarrow> \\<sigma>(v',S') \\<noteq> \\<sigma>(v,S))\"", "lemma konigDown:\n  assumes \"wf t\" and \"S \\<in> structure\" and \"\\<not> sat S (fst (root t))\"\n  shows\n    \"alw (\\<lambda>stepSs. let ((s,r),S) = shd stepSs; ((s',_),S') = shd (stl stepSs) in\n                    S \\<in> structure \\<and> \\<not> sat S s \\<and> descent (s,S) r (s',S'))\n     (konigDown t S)\"", "lemma konigDown_ipath:\n  assumes \"wf t\" and \"S \\<in> structure\" and \"\\<not> sat S (fst (root t))\"\n  shows\n    \"ipath t (smap fst (konigDown t S))\"", "lemma alw_ev_Ord:\n  obtains ks where \"alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord) ks\"\n    and \"alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)) ks\"", "lemma alw_ks: \"alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord) ks\"\n  and alw_ev_ks: \"alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)) ks\"", "lemmas decr_simps = decr0.code[of Ord]", "lemma decr_ev:\n  assumes m: \"(shd js, m) \\<in> Ord\"\n  shows \"ev (\\<lambda>js. (shd js, m) \\<in> Ord \\<and> shd js \\<noteq> m) js\"\n    (is \"ev (\\<lambda>js. ?\\<phi> m js) js\")", "lemma decr_simps_diff[simp]:\n  assumes m: \"(shd js, m) \\<in> Ord\"\n    and \"shd js \\<noteq> m\"\n  shows \"decr m js = shd js ## decr (shd js) js\"", "lemma decr_simps_eq[simp]:\n  \"decr (shd js) js = decr (shd js) (stl js)\"", "lemma stl_decr:\n  assumes a: \"alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) js\"\n    and ae: \"alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) js\"\n    and m: \"(shd js, m) \\<in> Ord\"\n  shows\n    \"\\<exists>js1 js2. js = js1 @- js2 \\<and> set js1 \\<subseteq> {m} \\<and>\n (shd js2, m) \\<in> Ord \\<and> shd js2 \\<noteq> m \\<and>\n  shd (decr m js) = shd js2 \\<and> stl (decr m js) = decr (shd js2) js2\"\n    (is \"\\<exists>js1 js2. ?\\<phi> js js1 js2\")", "lemma decr:\n  assumes a: \"alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) js\" (is \"?a js\")\n    and ae: \"alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) js\" (is \"?ae js\")\n  shows\n    \"alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord \\<and> shd (stl js) \\<noteq> shd js) (decr (shd js) js)\"\n    (is \"alw ?\\<phi> _\")", "lemma alw_snth:\n  assumes \"alw (\\<lambda>xs. P (shd (stl xs)) (shd xs)) xs\"\n  shows \"P (xs!!(Suc n)) (xs!! n)\"", "lemma F: False", "theorem infinite_soundness:\n  assumes \"wf t\" and \"good t\" and \"S \\<in> structure\"\n  shows \"sat S (fst (root t))\"", "lemma cwf_Link: \"cwf (Link l) \\<longleftrightarrow> cwf (pointsTo l)\"", "lemma cwf_cNode_seqOf:\n  \"cwf (cNode (s, r) cts) \\<Longrightarrow> eff r s (fimage seqOf cts)\"", "lemma treeOf_seqOf[simp]:\n  \"fst \\<circ> root \\<circ> treeOf pointsTo = seqOf\"", "lemma wf_treeOf:\n  assumes \"cwf ct\"\n  shows \"wf (treeOf pointsTo ct)\"", "theorem cyclic_soundness:\n  assumes \"cwf ct\" and \"cgood ct\" and \"S \\<in> structure\"\n  shows \"sat S (seqOf ct)\"", "lemma wf_rels[simp]:\n  assumes \"wf {(l,l'). (pointsTo :: 'link \\<Rightarrow> ('sequent, 'rule, 'link)ctree) l' = Link l}\"\n    (is \"wf ?w\")\n  shows \"wf (rels pointsTo)\"", "lemma rel: \"wf rel\""], "translations": [["", "lemma num:\n  assumes ev: \"ev (\\<lambda>xs. P (shd xs)) xs\"\n  defines \"n \\<equiv> num P xs\"\n  shows\n    \"(list_all (Not o P) (stake n xs) \\<and> P (xs!!n)) \\<and>\n (\\<forall>m. list_all (Not o P) (stake m xs) \\<and> P (xs!!m) \\<longrightarrow> n \\<le> m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_all (Not \\<circ> P) (stake n xs) \\<and> P (xs !! n)) \\<and>\n    (\\<forall>m.\n        list_all (Not \\<circ> P) (stake m xs) \\<and>\n        P (xs !! m) \\<longrightarrow>\n        n \\<le> m)", "unfolding n_def num_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (list_all (Not \\<circ> P)\n      (stake\n        (LEAST n. list_all (Not \\<circ> P) (stake n xs) \\<and> P (xs !! n))\n        xs) \\<and>\n     P (xs !!\n        (LEAST n.\n            list_all (Not \\<circ> P) (stake n xs) \\<and>\n            P (xs !! n)))) \\<and>\n    (\\<forall>m.\n        list_all (Not \\<circ> P) (stake m xs) \\<and>\n        P (xs !! m) \\<longrightarrow>\n        (LEAST n. list_all (Not \\<circ> P) (stake n xs) \\<and> P (xs !! n))\n        \\<le> m)", "proof (intro conjI[OF LeastI_ex] allI impI Least_le)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<exists>x. list_all (Not \\<circ> P) (stake x xs) \\<and> P (xs !! x)\n 2. \\<And>m.\n       list_all (Not \\<circ> P) (stake m xs) \\<and>\n       P (xs !! m) \\<Longrightarrow>\n       \\<exists>x. list_all (Not \\<circ> P) (stake m xs)\n 3. \\<And>m.\n       list_all (Not \\<circ> P) (stake m xs) \\<and>\n       P (xs !! m) \\<Longrightarrow>\n       P (xs !! m)", "from ev"], ["proof (chain)\npicking this:\n  ev (\\<lambda>xs. P (shd xs)) xs", "show \"\\<exists>n. list_all (Not o P) (stake n xs) \\<and> P (xs !! n)\""], ["proof (prove)\nusing this:\n  ev (\\<lambda>xs. P (shd xs)) xs\n\ngoal (1 subgoal):\n 1. \\<exists>n. list_all (Not \\<circ> P) (stake n xs) \\<and> P (xs !! n)", "by (induct rule: ev_induct_strong) (auto intro: exI[of _ 0] exI[of _ \"Suc _\"])"], ["proof (state)\nthis:\n  \\<exists>n. list_all (Not \\<circ> P) (stake n xs) \\<and> P (xs !! n)\n\ngoal (2 subgoals):\n 1. \\<And>m.\n       list_all (Not \\<circ> P) (stake m xs) \\<and>\n       P (xs !! m) \\<Longrightarrow>\n       \\<exists>x. list_all (Not \\<circ> P) (stake m xs)\n 2. \\<And>m.\n       list_all (Not \\<circ> P) (stake m xs) \\<and>\n       P (xs !! m) \\<Longrightarrow>\n       P (xs !! m)", "qed (simp_all add: o_def)"], ["", "private"], ["", "lemma num_stl[simp]:\n  assumes \"ev (\\<lambda>xs. P (shd xs)) xs\" and \"\\<not> P (shd xs)\"\n  shows \"num P xs = Suc (num P (stl xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num P xs = Suc (num P (stl xs))", "unfolding num_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST n. list_all (Not \\<circ> P) (stake n xs) \\<and> P (xs !! n)) =\n    Suc (LEAST n.\n            list_all (Not \\<circ> P) (stake n (stl xs)) \\<and>\n            P (stl xs !! n))", "by (rule trans[OF Least_Suc[of _ \"num P xs\"]])\n    (auto simp: num[OF assms(1)] assms(2))"], ["", "corecursive decr0 where\n  \"decr0 Ord minSoFar js =\n    (if \\<not> (ev (\\<lambda>js. (shd js, minSoFar) \\<in> Ord \\<and> shd js \\<noteq> minSoFar)) js\n     then undefined\n     else if ((shd js, minSoFar) \\<in> Ord \\<and> shd js \\<noteq> minSoFar)\n          then shd js ## decr0 Ord (shd js) js\n          else decr0 Ord minSoFar (stl js))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. All (Wellfounded.accp decr0_inner_fp_rel)", "by (relation \"measure (\\<lambda>(Ord,m,js). num (\\<lambda>j. (j, m) \\<in> Ord \\<and> j \\<noteq> m) js)\") auto"], ["", "end"], ["", "lemmas well_order_on_defs =\n  well_order_on_def linear_order_on_def partial_order_on_def\n  preorder_on_def trans_def antisym_def refl_on_def"], ["", "lemma sdrop_length_shift[simp]:\n  \"sdrop (length xs) (xs @- s) = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sdrop (length xs) (xs @- s) = s", "by (simp add: sdrop_shift)"], ["", "lemma ev_iff_shift:\n  \"ev \\<phi> xs \\<longleftrightarrow> (\\<exists>xl xs2. xs = xl @- xs2 \\<and> \\<phi> xs2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ev \\<phi> xs = (\\<exists>xl xs2. xs = xl @- xs2 \\<and> \\<phi> xs2)", "by (meson ev.base ev_imp_shift ev_shift)"], ["", "locale Infinite_Soundness = RuleSystem_Defs eff rules for\n  eff :: \"'rule \\<Rightarrow> 'sequent \\<Rightarrow> 'sequent fset \\<Rightarrow> bool\"\n  and rules :: \"'rule stream\"\n  +\n  fixes \"structure\" :: \"'structure set\"\n    and sat :: \"'structure \\<Rightarrow> 'sequent \\<Rightarrow> bool\"\n    and \\<delta> :: \"'sequent \\<Rightarrow> 'rule \\<Rightarrow> 'sequent \\<Rightarrow> ('marker \\<times> bool \\<times> 'marker) set\"\n    and Ord :: \"'ord rel\"\n    and \\<sigma> :: \"'marker \\<times> 'structure \\<Rightarrow> 'ord\"\n  assumes\n    Ord: \"well_order Ord\"\n    and\n    descent: (* The original paper has an error in stating this: quantifies existentially\n  instead of universally over r *)\n    \"\\<And>r s sl S.\n      \\<lbrakk>r \\<in> R; eff r s sl; S \\<in> structure; \\<not> sat S s\\<rbrakk>\n      \\<Longrightarrow>\n      \\<exists>s' S'.\n        s' |\\<in>| sl \\<and> S' \\<in> structure \\<and> \\<not> sat S' s' \\<and>\n        (\\<forall>v v' b.\n          (v,b,v') \\<in> \\<delta> s r s' \\<longrightarrow>\n             (\\<sigma>(v',S'), \\<sigma>(v,S)) \\<in> Ord \\<and> (b \\<longrightarrow> \\<sigma>(v',S') \\<noteq> \\<sigma>(v,S)))\""], ["", "(* The descent property subsumes local_soundness: *)"], ["", "sublocale Infinite_Soundness < Soundness where eff = eff and rules = rules\n  and \"structure\" = \"structure\" and sat = sat"], ["proof (prove)\ngoal (1 subgoal):\n 1. Soundness eff rules structure sat", "by standard (blast dest: descent)"], ["", "context Infinite_Soundness\nbegin"], ["", "(* The notion of a trace of markers following a path: to make the original paper definition\ninto a rigorous one, we include the trace of \"progressing bits\" as well:  *)"], ["", "coinductive follow :: \"bool stream \\<Rightarrow> 'marker stream \\<Rightarrow> ('sequent,'rule)step stream \\<Rightarrow> bool\" where\n  \"\\<lbrakk>M' = shd Ms; s' = fst (shd steps); (M,b,M') \\<in> \\<delta> s r s'; follow bs Ms steps\\<rbrakk>\n \\<Longrightarrow>\n follow (SCons b bs) (SCons M Ms) (SCons (s,r) steps)\""], ["", "(* Now infinite progress simply means \"always eventually the bit is True\": *)"], ["", "definition infDecr :: \"bool stream \\<Rightarrow> bool\" where\n  \"infDecr \\<equiv> alw (ev (\\<lambda>bs. shd bs))\""], ["", "(* Good trees: *)"], ["", "definition good :: \"('sequent,'rule)dtree \\<Rightarrow> bool\" where\n  \"good t \\<equiv> \\<forall>steps.\n  ipath t steps\n  \\<longrightarrow>\n  ev (\\<lambda>steps'. \\<exists>bs Ms. follow bs Ms steps' \\<and> infDecr bs) steps\""], ["", "(* Note the mixture of temporal connectives and standard HOL quantifiers:\nan advantage of the shallow embedding of LTL *)\n\n(* Trivially, finite trees are particular cases of good trees, since they\nhave no infinite paths: *)"], ["", "lemma tfinite_good: \"tfinite t \\<Longrightarrow> good t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tfinite t \\<Longrightarrow> good t", "using ftree_no_ipath"], ["proof (prove)\nusing this:\n  tfinite ?t \\<Longrightarrow> \\<not> ipath ?t ?steps\n\ngoal (1 subgoal):\n 1. tfinite t \\<Longrightarrow> good t", "unfolding good_def"], ["proof (prove)\nusing this:\n  tfinite ?t \\<Longrightarrow> \\<not> ipath ?t ?steps\n\ngoal (1 subgoal):\n 1. tfinite t \\<Longrightarrow>\n    \\<forall>steps.\n       ipath t steps \\<longrightarrow>\n       ev (\\<lambda>steps'.\n              \\<exists>bs Ms. follow bs Ms steps' \\<and> infDecr bs)\n        steps", "by auto"], ["", "context\n  fixes inv :: \"'sequent \\<times> 'a \\<Rightarrow> bool\"\n    and pred :: \"'sequent \\<times> 'a \\<Rightarrow> 'rule \\<Rightarrow> 'sequent \\<times> 'a \\<Rightarrow> bool\"\nbegin"], ["", "primcorec konigDtree ::\n  \"('sequent,'rule) dtree \\<Rightarrow> 'a \\<Rightarrow> (('sequent,'rule) step \\<times> 'a) stream\" where\n  \"shd (konigDtree t a) = (root t, a)\"\n|\"stl (konigDtree t a) =\n  (let s = fst (root t); r = snd (root t);\n   (s',a') = (SOME (s',a'). s' |\\<in>| fimage (fst o root) (cont t) \\<and> pred (s,a) r (s',a') \\<and> inv (s',a'));\n   t' = (SOME t'. t' |\\<in>| cont t \\<and> s' = fst (root t'))\n   in konigDtree t' a'\n  )\""], ["", "lemma stl_konigDtree:\n  fixes t defines \"s \\<equiv> fst (root t)\" and \"r \\<equiv> snd (root t)\"\n  assumes s': \"s' |\\<in>| fimage (fst o root) (cont t)\"  and \"pred (s,a) r (s',a'')\" and \"inv (s',a'')\"\n  shows \"\\<exists>t' a'. t' |\\<in>| cont t \\<and> pred (s,a) r (fst (root t'),a') \\<and> inv (fst (root t'),a')\n  \\<and> stl (konigDtree t a) = konigDtree t' a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t' a'.\n       t' |\\<in>| cont t \\<and>\n       pred (s, a) r (fst (tree.root t'), a') \\<and>\n       inv (fst (tree.root t'), a') \\<and>\n       stl (konigDtree t a) = konigDtree t' a'", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>t' a'.\n       t' |\\<in>| cont t \\<and>\n       pred (s, a) r (fst (tree.root t'), a') \\<and>\n       inv (fst (tree.root t'), a') \\<and>\n       stl (konigDtree t a) = konigDtree t' a'", "define P where \"P \\<equiv> \\<lambda>(s',a'). s' |\\<in>| fimage (fst o root) (cont t) \\<and> pred (s,a) r (s',a') \\<and> inv (s',a')\""], ["proof (state)\nthis:\n  P \\<equiv>\n  \\<lambda>(s', a').\n     s' |\\<in>| (fst \\<circ> tree.root) |`| cont t \\<and>\n     pred (s, a) r (s', a') \\<and> inv (s', a')\n\ngoal (1 subgoal):\n 1. \\<exists>t' a'.\n       t' |\\<in>| cont t \\<and>\n       pred (s, a) r (fst (tree.root t'), a') \\<and>\n       inv (fst (tree.root t'), a') \\<and>\n       stl (konigDtree t a) = konigDtree t' a'", "define s'a' where \"s'a' \\<equiv> SOME (s',a'). P (s',a')\""], ["proof (state)\nthis:\n  s'a' \\<equiv> SOME (s', a'). P (s', a')\n\ngoal (1 subgoal):\n 1. \\<exists>t' a'.\n       t' |\\<in>| cont t \\<and>\n       pred (s, a) r (fst (tree.root t'), a') \\<and>\n       inv (fst (tree.root t'), a') \\<and>\n       stl (konigDtree t a) = konigDtree t' a'", "let ?s' = \"fst s'a'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>t' a'.\n       t' |\\<in>| cont t \\<and>\n       pred (s, a) r (fst (tree.root t'), a') \\<and>\n       inv (fst (tree.root t'), a') \\<and>\n       stl (konigDtree t a) = konigDtree t' a'", "let ?a' = \"snd s'a'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>t' a'.\n       t' |\\<in>| cont t \\<and>\n       pred (s, a) r (fst (tree.root t'), a') \\<and>\n       inv (fst (tree.root t'), a') \\<and>\n       stl (konigDtree t a) = konigDtree t' a'", "define t' where \"t' \\<equiv> SOME (t'::('sequent,'rule)dtree). t' |\\<in>| cont t \\<and> ?s' = fst (root t')\""], ["proof (state)\nthis:\n  t' \\<equiv>\n  SOME t'. t' |\\<in>| cont t \\<and> fst s'a' = fst (tree.root t')\n\ngoal (1 subgoal):\n 1. \\<exists>t' a'.\n       t' |\\<in>| cont t \\<and>\n       pred (s, a) r (fst (tree.root t'), a') \\<and>\n       inv (fst (tree.root t'), a') \\<and>\n       stl (konigDtree t a) = konigDtree t' a'", "have \"P (s',a'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (s', a'')", "using assms"], ["proof (prove)\nusing this:\n  s \\<equiv> fst (tree.root t)\n  r \\<equiv> snd (tree.root t)\n  s' |\\<in>| (fst \\<circ> tree.root) |`| cont t\n  pred (s, a) r (s', a'')\n  inv (s', a'')\n\ngoal (1 subgoal):\n 1. P (s', a'')", "unfolding P_def"], ["proof (prove)\nusing this:\n  s \\<equiv> fst (tree.root t)\n  r \\<equiv> snd (tree.root t)\n  s' |\\<in>| (fst \\<circ> tree.root) |`| cont t\n  pred (s, a) r (s', a'')\n  inv (s', a'')\n\ngoal (1 subgoal):\n 1. case (s', a'') of\n    (s', a') \\<Rightarrow>\n      s' |\\<in>| (fst \\<circ> tree.root) |`| cont t \\<and>\n      pred (s, a) r (s', a') \\<and> inv (s', a')", "by auto"], ["proof (state)\nthis:\n  P (s', a'')\n\ngoal (1 subgoal):\n 1. \\<exists>t' a'.\n       t' |\\<in>| cont t \\<and>\n       pred (s, a) r (fst (tree.root t'), a') \\<and>\n       inv (fst (tree.root t'), a') \\<and>\n       stl (konigDtree t a) = konigDtree t' a'", "hence P: \"P (?s',?a')\""], ["proof (prove)\nusing this:\n  P (s', a'')\n\ngoal (1 subgoal):\n 1. P (fst s'a', snd s'a')", "using someI[of P]"], ["proof (prove)\nusing this:\n  P (s', a'')\n  P ?x \\<Longrightarrow> P (Eps P)\n\ngoal (1 subgoal):\n 1. P (fst s'a', snd s'a')", "unfolding s'a'_def"], ["proof (prove)\nusing this:\n  P (s', a'')\n  P ?x \\<Longrightarrow> P (Eps P)\n\ngoal (1 subgoal):\n 1. P (fst (SOME (s', a'). P (s', a')), snd (SOME (s', a'). P (s', a')))", "by auto"], ["proof (state)\nthis:\n  P (fst s'a', snd s'a')\n\ngoal (1 subgoal):\n 1. \\<exists>t' a'.\n       t' |\\<in>| cont t \\<and>\n       pred (s, a) r (fst (tree.root t'), a') \\<and>\n       inv (fst (tree.root t'), a') \\<and>\n       stl (konigDtree t a) = konigDtree t' a'", "hence \"\\<exists>t'. t' |\\<in>| cont t \\<and> ?s' = fst (root t')\""], ["proof (prove)\nusing this:\n  P (fst s'a', snd s'a')\n\ngoal (1 subgoal):\n 1. \\<exists>t'. t' |\\<in>| cont t \\<and> fst s'a' = fst (tree.root t')", "unfolding P_def"], ["proof (prove)\nusing this:\n  case (fst s'a', snd s'a') of\n  (s', a') \\<Rightarrow>\n    s' |\\<in>| (fst \\<circ> tree.root) |`| cont t \\<and>\n    pred (s, a) r (s', a') \\<and> inv (s', a')\n\ngoal (1 subgoal):\n 1. \\<exists>t'. t' |\\<in>| cont t \\<and> fst s'a' = fst (tree.root t')", "by auto"], ["proof (state)\nthis:\n  \\<exists>t'. t' |\\<in>| cont t \\<and> fst s'a' = fst (tree.root t')\n\ngoal (1 subgoal):\n 1. \\<exists>t' a'.\n       t' |\\<in>| cont t \\<and>\n       pred (s, a) r (fst (tree.root t'), a') \\<and>\n       inv (fst (tree.root t'), a') \\<and>\n       stl (konigDtree t a) = konigDtree t' a'", "hence t': \"t' |\\<in>| cont t\" and s': \"?s' = fst (root t')\""], ["proof (prove)\nusing this:\n  \\<exists>t'. t' |\\<in>| cont t \\<and> fst s'a' = fst (tree.root t')\n\ngoal (1 subgoal):\n 1. t' |\\<in>| cont t &&& fst s'a' = fst (tree.root t')", "using someI_ex[of \"\\<lambda>t'. t' |\\<in>| cont t \\<and> ?s' = fst (root t')\"]"], ["proof (prove)\nusing this:\n  \\<exists>t'. t' |\\<in>| cont t \\<and> fst s'a' = fst (tree.root t')\n  \\<exists>x.\n     x |\\<in>| cont t \\<and> fst s'a' = fst (tree.root x) \\<Longrightarrow>\n  (SOME x. x |\\<in>| cont t \\<and> fst s'a' = fst (tree.root x)) |\\<in>|\n  cont t \\<and>\n  fst s'a' =\n  fst (tree.root\n        (SOME x. x |\\<in>| cont t \\<and> fst s'a' = fst (tree.root x)))\n\ngoal (1 subgoal):\n 1. t' |\\<in>| cont t &&& fst s'a' = fst (tree.root t')", "unfolding t'_def"], ["proof (prove)\nusing this:\n  \\<exists>t'. t' |\\<in>| cont t \\<and> fst s'a' = fst (tree.root t')\n  \\<exists>x.\n     x |\\<in>| cont t \\<and> fst s'a' = fst (tree.root x) \\<Longrightarrow>\n  (SOME x. x |\\<in>| cont t \\<and> fst s'a' = fst (tree.root x)) |\\<in>|\n  cont t \\<and>\n  fst s'a' =\n  fst (tree.root\n        (SOME x. x |\\<in>| cont t \\<and> fst s'a' = fst (tree.root x)))\n\ngoal (1 subgoal):\n 1. (SOME t'.\n        t' |\\<in>| cont t \\<and> fst s'a' = fst (tree.root t')) |\\<in>|\n    cont t &&&\n    fst s'a' =\n    fst (tree.root\n          (SOME t'. t' |\\<in>| cont t \\<and> fst s'a' = fst (tree.root t')))", "by auto"], ["proof (state)\nthis:\n  t' |\\<in>| cont t\n  fst s'a' = fst (tree.root t')\n\ngoal (1 subgoal):\n 1. \\<exists>t' a'.\n       t' |\\<in>| cont t \\<and>\n       pred (s, a) r (fst (tree.root t'), a') \\<and>\n       inv (fst (tree.root t'), a') \\<and>\n       stl (konigDtree t a) = konigDtree t' a'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t' a'.\n       t' |\\<in>| cont t \\<and>\n       pred (s, a) r (fst (tree.root t'), a') \\<and>\n       inv (fst (tree.root t'), a') \\<and>\n       stl (konigDtree t a) = konigDtree t' a'", "using t' P s' assms P_def s'a'_def t'_def"], ["proof (prove)\nusing this:\n  t' |\\<in>| cont t\n  P (fst s'a', snd s'a')\n  fst s'a' = fst (tree.root t')\n  s \\<equiv> fst (tree.root t)\n  r \\<equiv> snd (tree.root t)\n  s' |\\<in>| (fst \\<circ> tree.root) |`| cont t\n  pred (s, a) r (s', a'')\n  inv (s', a'')\n  P \\<equiv>\n  \\<lambda>(s', a').\n     s' |\\<in>| (fst \\<circ> tree.root) |`| cont t \\<and>\n     pred (s, a) r (s', a') \\<and> inv (s', a')\n  s'a' \\<equiv> SOME (s', a'). P (s', a')\n  t' \\<equiv>\n  SOME t'. t' |\\<in>| cont t \\<and> fst s'a' = fst (tree.root t')\n\ngoal (1 subgoal):\n 1. \\<exists>t' a'.\n       t' |\\<in>| cont t \\<and>\n       pred (s, a) r (fst (tree.root t'), a') \\<and>\n       inv (fst (tree.root t'), a') \\<and>\n       stl (konigDtree t a) = konigDtree t' a'", "by (intro exI[of _ t'] exI[of _ ?a']) auto"], ["proof (state)\nthis:\n  \\<exists>t' a'.\n     t' |\\<in>| cont t \\<and>\n     pred (s, a) r (fst (tree.root t'), a') \\<and>\n     inv (fst (tree.root t'), a') \\<and>\n     stl (konigDtree t a) = konigDtree t' a'\n\ngoal:\nNo subgoals!", "qed"], ["", "declare konigDtree.simps(2)[simp del]"], ["", "lemma konigDtree:\n  assumes 1: \"\\<And>r s sl a.\n  \\<lbrakk>r \\<in> R; eff r s sl; inv (s,a)\\<rbrakk> \\<Longrightarrow>\n  \\<exists>s' a'. s' |\\<in>| sl \\<and> inv (s',a') \\<and> pred (s,a) r (s',a')\"\n    and 2: \"wf t\" \"inv (fst (root t), a)\"\n  shows\n    \"alw (\\<lambda>stepas.\n        let ((s,r),a) = shd stepas; ((s',_),a') = shd (stl stepas) in\n          inv (s,a) \\<and> pred (s,a) r (s',a'))\n     (konigDtree t a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (\\<lambda>stepas.\n            let ((s, r), a) = shd stepas; ((s', uu_), a') = shd (stl stepas)\n            in inv (s, a) \\<and> pred (s, a) r (s', a'))\n     (konigDtree t a)", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?r1 \\<in> R; eff ?r1 ?s1 ?sl1; inv (?s1, ?a1)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s' a'.\n                       s' |\\<in>| ?sl1 \\<and>\n                       inv (s', a') \\<and> pred (?s1, ?a1) ?r1 (s', a')\n  local.wf t\n  inv (fst (tree.root t), a)\n\ngoal (1 subgoal):\n 1. alw (\\<lambda>stepas.\n            let ((s, r), a) = shd stepas; ((s', uu_), a') = shd (stl stepas)\n            in inv (s, a) \\<and> pred (s, a) r (s', a'))\n     (konigDtree t a)", "proof (coinduction arbitrary: t a)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t a.\n       \\<lbrakk>\\<forall>r s sl a.\n                   r \\<in> R \\<longrightarrow>\n                   eff r s sl \\<longrightarrow>\n                   inv (s, a) \\<longrightarrow>\n                   (\\<exists>s' a'.\n                       s' |\\<in>| sl \\<and>\n                       inv (s', a') \\<and> pred (s, a) r (s', a'));\n        local.wf t; inv (fst (tree.root t), a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            konigDtree t a = xs \\<and>\n                            (let ((s, r), a) = shd xs;\n                                 ((s', uu_), a') = shd (stl xs)\n                             in inv (s, a) \\<and>\n                                pred (s, a) r (s', a')) \\<and>\n                            ((\\<exists>t a.\n                                 stl xs = konigDtree t a \\<and>\n                                 (\\<forall>r s sl a.\n                                     r \\<in> R \\<longrightarrow>\n                                     eff r s sl \\<longrightarrow>\n                                     inv (s, a) \\<longrightarrow>\n                                     (\\<exists>s' a'.\n   s' |\\<in>| sl \\<and> inv (s', a') \\<and> pred (s, a) r (s', a'))) \\<and>\n                                 local.wf t \\<and>\n                                 inv (fst (tree.root t), a)) \\<or>\n                             alw (\\<lambda>stepas.\n                                     let ((s, r), a) = shd stepas;\n   ((s', uu_), a') = shd (stl stepas)\n                                     in inv (s, a) \\<and>\n  pred (s, a) r (s', a'))\n                              (stl xs))", "case (alw t a)"], ["proof (state)\nthis:\n  \\<forall>r s sl a.\n     r \\<in> R \\<longrightarrow>\n     eff r s sl \\<longrightarrow>\n     inv (s, a) \\<longrightarrow>\n     (\\<exists>s' a'.\n         s' |\\<in>| sl \\<and> inv (s', a') \\<and> pred (s, a) r (s', a'))\n  local.wf t\n  inv (fst (tree.root t), a)\n\ngoal (1 subgoal):\n 1. \\<And>t a.\n       \\<lbrakk>\\<forall>r s sl a.\n                   r \\<in> R \\<longrightarrow>\n                   eff r s sl \\<longrightarrow>\n                   inv (s, a) \\<longrightarrow>\n                   (\\<exists>s' a'.\n                       s' |\\<in>| sl \\<and>\n                       inv (s', a') \\<and> pred (s, a) r (s', a'));\n        local.wf t; inv (fst (tree.root t), a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            konigDtree t a = xs \\<and>\n                            (let ((s, r), a) = shd xs;\n                                 ((s', uu_), a') = shd (stl xs)\n                             in inv (s, a) \\<and>\n                                pred (s, a) r (s', a')) \\<and>\n                            ((\\<exists>t a.\n                                 stl xs = konigDtree t a \\<and>\n                                 (\\<forall>r s sl a.\n                                     r \\<in> R \\<longrightarrow>\n                                     eff r s sl \\<longrightarrow>\n                                     inv (s, a) \\<longrightarrow>\n                                     (\\<exists>s' a'.\n   s' |\\<in>| sl \\<and> inv (s', a') \\<and> pred (s, a) r (s', a'))) \\<and>\n                                 local.wf t \\<and>\n                                 inv (fst (tree.root t), a)) \\<or>\n                             alw (\\<lambda>stepas.\n                                     let ((s, r), a) = shd stepas;\n   ((s', uu_), a') = shd (stl stepas)\n                                     in inv (s, a) \\<and>\n  pred (s, a) r (s', a'))\n                              (stl xs))", "then"], ["proof (chain)\npicking this:\n  \\<forall>r s sl a.\n     r \\<in> R \\<longrightarrow>\n     eff r s sl \\<longrightarrow>\n     inv (s, a) \\<longrightarrow>\n     (\\<exists>s' a'.\n         s' |\\<in>| sl \\<and> inv (s', a') \\<and> pred (s, a) r (s', a'))\n  local.wf t\n  inv (fst (tree.root t), a)", "obtain s' a' where \"s' |\\<in>| (fst \\<circ> root) |`| cont t\" \"inv (s', a')\"\n    \"pred (fst (root t), a) (snd (root t)) (s', a')\""], ["proof (prove)\nusing this:\n  \\<forall>r s sl a.\n     r \\<in> R \\<longrightarrow>\n     eff r s sl \\<longrightarrow>\n     inv (s, a) \\<longrightarrow>\n     (\\<exists>s' a'.\n         s' |\\<in>| sl \\<and> inv (s', a') \\<and> pred (s, a) r (s', a'))\n  local.wf t\n  inv (fst (tree.root t), a)\n\ngoal (1 subgoal):\n 1. (\\<And>s' a'.\n        \\<lbrakk>s' |\\<in>| (fst \\<circ> tree.root) |`| cont t;\n         inv (s', a');\n         pred (fst (tree.root t), a) (snd (tree.root t)) (s', a')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim!: wf.cases dest!: spec[of _ \"snd (root t)\"] spec[of _ \"fst (root t)\"]\n        spec[of _ \"(fst \\<circ> root) |`| cont t\"] spec[of _ a], fastforce)"], ["proof (state)\nthis:\n  s' |\\<in>| (fst \\<circ> tree.root) |`| cont t\n  inv (s', a')\n  pred (fst (tree.root t), a) (snd (tree.root t)) (s', a')\n\ngoal (1 subgoal):\n 1. \\<And>t a.\n       \\<lbrakk>\\<forall>r s sl a.\n                   r \\<in> R \\<longrightarrow>\n                   eff r s sl \\<longrightarrow>\n                   inv (s, a) \\<longrightarrow>\n                   (\\<exists>s' a'.\n                       s' |\\<in>| sl \\<and>\n                       inv (s', a') \\<and> pred (s, a) r (s', a'));\n        local.wf t; inv (fst (tree.root t), a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>xs.\n                            konigDtree t a = xs \\<and>\n                            (let ((s, r), a) = shd xs;\n                                 ((s', uu_), a') = shd (stl xs)\n                             in inv (s, a) \\<and>\n                                pred (s, a) r (s', a')) \\<and>\n                            ((\\<exists>t a.\n                                 stl xs = konigDtree t a \\<and>\n                                 (\\<forall>r s sl a.\n                                     r \\<in> R \\<longrightarrow>\n                                     eff r s sl \\<longrightarrow>\n                                     inv (s, a) \\<longrightarrow>\n                                     (\\<exists>s' a'.\n   s' |\\<in>| sl \\<and> inv (s', a') \\<and> pred (s, a) r (s', a'))) \\<and>\n                                 local.wf t \\<and>\n                                 inv (fst (tree.root t), a)) \\<or>\n                             alw (\\<lambda>stepas.\n                                     let ((s, r), a) = shd stepas;\n   ((s', uu_), a') = shd (stl stepas)\n                                     in inv (s, a) \\<and>\n  pred (s, a) r (s', a'))\n                              (stl xs))", "with alw stl_konigDtree[of s' t a a']"], ["proof (chain)\npicking this:\n  \\<forall>r s sl a.\n     r \\<in> R \\<longrightarrow>\n     eff r s sl \\<longrightarrow>\n     inv (s, a) \\<longrightarrow>\n     (\\<exists>s' a'.\n         s' |\\<in>| sl \\<and> inv (s', a') \\<and> pred (s, a) r (s', a'))\n  local.wf t\n  inv (fst (tree.root t), a)\n  \\<lbrakk>s' |\\<in>| (fst \\<circ> tree.root) |`| cont t;\n   pred (fst (tree.root t), a) (snd (tree.root t)) (s', a');\n   inv (s', a')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t' a'.\n                       t' |\\<in>| cont t \\<and>\n                       pred (fst (tree.root t), a) (snd (tree.root t))\n                        (fst (tree.root t'), a') \\<and>\n                       inv (fst (tree.root t'), a') \\<and>\n                       stl (konigDtree t a) = konigDtree t' a'\n  s' |\\<in>| (fst \\<circ> tree.root) |`| cont t\n  inv (s', a')\n  pred (fst (tree.root t), a) (snd (tree.root t)) (s', a')", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>r s sl a.\n     r \\<in> R \\<longrightarrow>\n     eff r s sl \\<longrightarrow>\n     inv (s, a) \\<longrightarrow>\n     (\\<exists>s' a'.\n         s' |\\<in>| sl \\<and> inv (s', a') \\<and> pred (s, a) r (s', a'))\n  local.wf t\n  inv (fst (tree.root t), a)\n  \\<lbrakk>s' |\\<in>| (fst \\<circ> tree.root) |`| cont t;\n   pred (fst (tree.root t), a) (snd (tree.root t)) (s', a');\n   inv (s', a')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t' a'.\n                       t' |\\<in>| cont t \\<and>\n                       pred (fst (tree.root t), a) (snd (tree.root t))\n                        (fst (tree.root t'), a') \\<and>\n                       inv (fst (tree.root t'), a') \\<and>\n                       stl (konigDtree t a) = konigDtree t' a'\n  s' |\\<in>| (fst \\<circ> tree.root) |`| cont t\n  inv (s', a')\n  pred (fst (tree.root t), a) (snd (tree.root t)) (s', a')\n\ngoal (1 subgoal):\n 1. \\<exists>xs.\n       konigDtree t a = xs \\<and>\n       (let ((s, r), a) = shd xs; ((s', uu_), a') = shd (stl xs)\n        in inv (s, a) \\<and> pred (s, a) r (s', a')) \\<and>\n       ((\\<exists>t a.\n            stl xs = konigDtree t a \\<and>\n            (\\<forall>r s sl a.\n                r \\<in> R \\<longrightarrow>\n                eff r s sl \\<longrightarrow>\n                inv (s, a) \\<longrightarrow>\n                (\\<exists>s' a'.\n                    s' |\\<in>| sl \\<and>\n                    inv (s', a') \\<and> pred (s, a) r (s', a'))) \\<and>\n            local.wf t \\<and> inv (fst (tree.root t), a)) \\<or>\n        alw (\\<lambda>stepas.\n                let ((s, r), a) = shd stepas;\n                    ((s', uu_), a') = shd (stl stepas)\n                in inv (s, a) \\<and> pred (s, a) r (s', a'))\n         (stl xs))", "by (auto split: prod.splits elim!: wf.cases) fastforce"], ["proof (state)\nthis:\n  \\<exists>xs.\n     konigDtree t a = xs \\<and>\n     (let ((s, r), a) = shd xs; ((s', uu_), a') = shd (stl xs)\n      in inv (s, a) \\<and> pred (s, a) r (s', a')) \\<and>\n     ((\\<exists>t a.\n          stl xs = konigDtree t a \\<and>\n          (\\<forall>r s sl a.\n              r \\<in> R \\<longrightarrow>\n              eff r s sl \\<longrightarrow>\n              inv (s, a) \\<longrightarrow>\n              (\\<exists>s' a'.\n                  s' |\\<in>| sl \\<and>\n                  inv (s', a') \\<and> pred (s, a) r (s', a'))) \\<and>\n          local.wf t \\<and> inv (fst (tree.root t), a)) \\<or>\n      alw (\\<lambda>stepas.\n              let ((s, r), a) = shd stepas;\n                  ((s', uu_), a') = shd (stl stepas)\n              in inv (s, a) \\<and> pred (s, a) r (s', a'))\n       (stl xs))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma konigDtree_ipath:\n  assumes \"\\<And>r s sl a.\n  \\<lbrakk>r \\<in> R; eff r s sl; inv (s,a)\\<rbrakk> \\<Longrightarrow>\n  \\<exists>s' a'. s' |\\<in>| sl \\<and> inv (s',a') \\<and> pred (s,a) r (s',a')\"\n    and \"wf t\" and \"inv (fst (root t), a)\"\n  shows \"ipath t (smap fst (konigDtree t a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipath t (smap fst (konigDtree t a))", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>?r1 \\<in> R; eff ?r1 ?s1 ?sl1; inv (?s1, ?a1)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s' a'.\n                       s' |\\<in>| ?sl1 \\<and>\n                       inv (s', a') \\<and> pred (?s1, ?a1) ?r1 (s', a')\n  local.wf t\n  inv (fst (tree.root t), a)\n\ngoal (1 subgoal):\n 1. ipath t (smap fst (konigDtree t a))", "proof (coinduction arbitrary: t a)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t a.\n       \\<lbrakk>\\<forall>r s sl a.\n                   r \\<in> R \\<longrightarrow>\n                   eff r s sl \\<longrightarrow>\n                   inv (s, a) \\<longrightarrow>\n                   (\\<exists>s' a'.\n                       s' |\\<in>| sl \\<and>\n                       inv (s', a') \\<and> pred (s, a) r (s', a'));\n        local.wf t; inv (fst (tree.root t), a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta steps t'.\n                            t = ta \\<and>\n                            smap fst (konigDtree t a) = steps \\<and>\n                            tree.root ta = shd steps \\<and>\n                            t' |\\<in>| cont ta \\<and>\n                            ((\\<exists>t a.\n                                 t' = t \\<and>\n                                 stl steps =\n                                 smap fst (konigDtree t a) \\<and>\n                                 (\\<forall>r s sl a.\n                                     r \\<in> R \\<longrightarrow>\n                                     eff r s sl \\<longrightarrow>\n                                     inv (s, a) \\<longrightarrow>\n                                     (\\<exists>s' a'.\n   s' |\\<in>| sl \\<and> inv (s', a') \\<and> pred (s, a) r (s', a'))) \\<and>\n                                 local.wf t \\<and>\n                                 inv (fst (tree.root t), a)) \\<or>\n                             ipath t' (stl steps))", "case (ipath t a)"], ["proof (state)\nthis:\n  \\<forall>r s sl a.\n     r \\<in> R \\<longrightarrow>\n     eff r s sl \\<longrightarrow>\n     inv (s, a) \\<longrightarrow>\n     (\\<exists>s' a'.\n         s' |\\<in>| sl \\<and> inv (s', a') \\<and> pred (s, a) r (s', a'))\n  local.wf t\n  inv (fst (tree.root t), a)\n\ngoal (1 subgoal):\n 1. \\<And>t a.\n       \\<lbrakk>\\<forall>r s sl a.\n                   r \\<in> R \\<longrightarrow>\n                   eff r s sl \\<longrightarrow>\n                   inv (s, a) \\<longrightarrow>\n                   (\\<exists>s' a'.\n                       s' |\\<in>| sl \\<and>\n                       inv (s', a') \\<and> pred (s, a) r (s', a'));\n        local.wf t; inv (fst (tree.root t), a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta steps t'.\n                            t = ta \\<and>\n                            smap fst (konigDtree t a) = steps \\<and>\n                            tree.root ta = shd steps \\<and>\n                            t' |\\<in>| cont ta \\<and>\n                            ((\\<exists>t a.\n                                 t' = t \\<and>\n                                 stl steps =\n                                 smap fst (konigDtree t a) \\<and>\n                                 (\\<forall>r s sl a.\n                                     r \\<in> R \\<longrightarrow>\n                                     eff r s sl \\<longrightarrow>\n                                     inv (s, a) \\<longrightarrow>\n                                     (\\<exists>s' a'.\n   s' |\\<in>| sl \\<and> inv (s', a') \\<and> pred (s, a) r (s', a'))) \\<and>\n                                 local.wf t \\<and>\n                                 inv (fst (tree.root t), a)) \\<or>\n                             ipath t' (stl steps))", "then"], ["proof (chain)\npicking this:\n  \\<forall>r s sl a.\n     r \\<in> R \\<longrightarrow>\n     eff r s sl \\<longrightarrow>\n     inv (s, a) \\<longrightarrow>\n     (\\<exists>s' a'.\n         s' |\\<in>| sl \\<and> inv (s', a') \\<and> pred (s, a) r (s', a'))\n  local.wf t\n  inv (fst (tree.root t), a)", "obtain s' a' where \"s' |\\<in>| (fst \\<circ> root) |`| cont t\" \"inv (s', a')\"\n    \"pred (fst (root t), a) (snd (root t)) (s', a')\""], ["proof (prove)\nusing this:\n  \\<forall>r s sl a.\n     r \\<in> R \\<longrightarrow>\n     eff r s sl \\<longrightarrow>\n     inv (s, a) \\<longrightarrow>\n     (\\<exists>s' a'.\n         s' |\\<in>| sl \\<and> inv (s', a') \\<and> pred (s, a) r (s', a'))\n  local.wf t\n  inv (fst (tree.root t), a)\n\ngoal (1 subgoal):\n 1. (\\<And>s' a'.\n        \\<lbrakk>s' |\\<in>| (fst \\<circ> tree.root) |`| cont t;\n         inv (s', a');\n         pred (fst (tree.root t), a) (snd (tree.root t)) (s', a')\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto elim!: wf.cases dest!: spec[of _ \"snd (root t)\"] spec[of _ \"fst (root t)\"]\n        spec[of _ \"(fst \\<circ> root) |`| cont t\"] spec[of _ a], fastforce)"], ["proof (state)\nthis:\n  s' |\\<in>| (fst \\<circ> tree.root) |`| cont t\n  inv (s', a')\n  pred (fst (tree.root t), a) (snd (tree.root t)) (s', a')\n\ngoal (1 subgoal):\n 1. \\<And>t a.\n       \\<lbrakk>\\<forall>r s sl a.\n                   r \\<in> R \\<longrightarrow>\n                   eff r s sl \\<longrightarrow>\n                   inv (s, a) \\<longrightarrow>\n                   (\\<exists>s' a'.\n                       s' |\\<in>| sl \\<and>\n                       inv (s', a') \\<and> pred (s, a) r (s', a'));\n        local.wf t; inv (fst (tree.root t), a)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ta steps t'.\n                            t = ta \\<and>\n                            smap fst (konigDtree t a) = steps \\<and>\n                            tree.root ta = shd steps \\<and>\n                            t' |\\<in>| cont ta \\<and>\n                            ((\\<exists>t a.\n                                 t' = t \\<and>\n                                 stl steps =\n                                 smap fst (konigDtree t a) \\<and>\n                                 (\\<forall>r s sl a.\n                                     r \\<in> R \\<longrightarrow>\n                                     eff r s sl \\<longrightarrow>\n                                     inv (s, a) \\<longrightarrow>\n                                     (\\<exists>s' a'.\n   s' |\\<in>| sl \\<and> inv (s', a') \\<and> pred (s, a) r (s', a'))) \\<and>\n                                 local.wf t \\<and>\n                                 inv (fst (tree.root t), a)) \\<or>\n                             ipath t' (stl steps))", "with ipath stl_konigDtree[of s' t a a']"], ["proof (chain)\npicking this:\n  \\<forall>r s sl a.\n     r \\<in> R \\<longrightarrow>\n     eff r s sl \\<longrightarrow>\n     inv (s, a) \\<longrightarrow>\n     (\\<exists>s' a'.\n         s' |\\<in>| sl \\<and> inv (s', a') \\<and> pred (s, a) r (s', a'))\n  local.wf t\n  inv (fst (tree.root t), a)\n  \\<lbrakk>s' |\\<in>| (fst \\<circ> tree.root) |`| cont t;\n   pred (fst (tree.root t), a) (snd (tree.root t)) (s', a');\n   inv (s', a')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t' a'.\n                       t' |\\<in>| cont t \\<and>\n                       pred (fst (tree.root t), a) (snd (tree.root t))\n                        (fst (tree.root t'), a') \\<and>\n                       inv (fst (tree.root t'), a') \\<and>\n                       stl (konigDtree t a) = konigDtree t' a'\n  s' |\\<in>| (fst \\<circ> tree.root) |`| cont t\n  inv (s', a')\n  pred (fst (tree.root t), a) (snd (tree.root t)) (s', a')", "show ?case"], ["proof (prove)\nusing this:\n  \\<forall>r s sl a.\n     r \\<in> R \\<longrightarrow>\n     eff r s sl \\<longrightarrow>\n     inv (s, a) \\<longrightarrow>\n     (\\<exists>s' a'.\n         s' |\\<in>| sl \\<and> inv (s', a') \\<and> pred (s, a) r (s', a'))\n  local.wf t\n  inv (fst (tree.root t), a)\n  \\<lbrakk>s' |\\<in>| (fst \\<circ> tree.root) |`| cont t;\n   pred (fst (tree.root t), a) (snd (tree.root t)) (s', a');\n   inv (s', a')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>t' a'.\n                       t' |\\<in>| cont t \\<and>\n                       pred (fst (tree.root t), a) (snd (tree.root t))\n                        (fst (tree.root t'), a') \\<and>\n                       inv (fst (tree.root t'), a') \\<and>\n                       stl (konigDtree t a) = konigDtree t' a'\n  s' |\\<in>| (fst \\<circ> tree.root) |`| cont t\n  inv (s', a')\n  pred (fst (tree.root t), a) (snd (tree.root t)) (s', a')\n\ngoal (1 subgoal):\n 1. \\<exists>t steps t'.\n       t = t \\<and>\n       smap fst (konigDtree t a) = steps \\<and>\n       tree.root t = shd steps \\<and>\n       t' |\\<in>| cont t \\<and>\n       ((\\<exists>t a.\n            t' = t \\<and>\n            stl steps = smap fst (konigDtree t a) \\<and>\n            (\\<forall>r s sl a.\n                r \\<in> R \\<longrightarrow>\n                eff r s sl \\<longrightarrow>\n                inv (s, a) \\<longrightarrow>\n                (\\<exists>s' a'.\n                    s' |\\<in>| sl \\<and>\n                    inv (s', a') \\<and> pred (s, a) r (s', a'))) \\<and>\n            local.wf t \\<and> inv (fst (tree.root t), a)) \\<or>\n        ipath t' (stl steps))", "by (auto split: prod.splits elim!: wf.cases) force"], ["proof (state)\nthis:\n  \\<exists>t steps t'.\n     t = t \\<and>\n     smap fst (konigDtree t a) = steps \\<and>\n     tree.root t = shd steps \\<and>\n     t' |\\<in>| cont t \\<and>\n     ((\\<exists>t a.\n          t' = t \\<and>\n          stl steps = smap fst (konigDtree t a) \\<and>\n          (\\<forall>r s sl a.\n              r \\<in> R \\<longrightarrow>\n              eff r s sl \\<longrightarrow>\n              inv (s, a) \\<longrightarrow>\n              (\\<exists>s' a'.\n                  s' |\\<in>| sl \\<and>\n                  inv (s', a') \\<and> pred (s, a) r (s', a'))) \\<and>\n          local.wf t \\<and> inv (fst (tree.root t), a)) \\<or>\n      ipath t' (stl steps))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context *)"], ["", "lemma follow_stl_smap_fst[simp]:\n  \"follow bs Ms (smap fst stepSs) \\<Longrightarrow>\n   follow (stl bs) (stl Ms) (smap fst (stl stepSs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. follow bs Ms (smap fst stepSs) \\<Longrightarrow>\n    follow (stl bs) (stl Ms) (smap fst (stl stepSs))", "by (erule follow.cases) (auto simp del: stream.map_sel simp add: stream.map_sel[symmetric])"], ["", "lemma epath_stl_smap_fst[simp]:\n  \"epath (smap fst stepSs) \\<Longrightarrow>\n   epath (smap fst (stl stepSs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. epath (smap fst stepSs) \\<Longrightarrow> epath (smap fst (stl stepSs))", "by (erule epath.cases) (auto simp del: stream.map_sel simp add: stream.map_sel[symmetric])"], ["", "lemma infDecr_tl[simp]: \"infDecr bs \\<Longrightarrow> infDecr (stl bs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infDecr bs \\<Longrightarrow> infDecr (stl bs)", "unfolding infDecr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (ev shd) bs \\<Longrightarrow> alw (ev shd) (stl bs)", "by auto"], ["", "(* Proof of the main theorem: *)"], ["", "fun descent where \"descent (s,S) r (s',S') =\n (\\<forall>v v' b.\n    (v,b,v') \\<in> \\<delta> s r s' \\<longrightarrow>\n    (\\<sigma>(v',S'), \\<sigma>(v,S)) \\<in> Ord \\<and> (b \\<longrightarrow> \\<sigma>(v',S') \\<noteq> \\<sigma>(v,S)))\""], ["", "lemma descentE[elim]:\n  assumes \"descent (s,S) r (s',S')\" and \"(v,b,v') \\<in> \\<delta> s r s'\"\n  shows \"(\\<sigma>(v',S'), \\<sigma>(v,S)) \\<in> Ord \\<and> (b \\<longrightarrow> \\<sigma>(v',S') \\<noteq> \\<sigma>(v,S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> (v', S'), \\<sigma> (v, S)) \\<in> Ord \\<and>\n    (b \\<longrightarrow> \\<sigma> (v', S') \\<noteq> \\<sigma> (v, S))", "using assms"], ["proof (prove)\nusing this:\n  descent (s, S) r (s', S')\n  (v, b, v') \\<in> \\<delta> s r s'\n\ngoal (1 subgoal):\n 1. (\\<sigma> (v', S'), \\<sigma> (v, S)) \\<in> Ord \\<and>\n    (b \\<longrightarrow> \\<sigma> (v', S') \\<noteq> \\<sigma> (v, S))", "by auto"], ["", "definition \"konigDown \\<equiv> konigDtree (\\<lambda>(s,S). S \\<in> structure \\<and> \\<not> sat S s) descent\""], ["", "lemma konigDown:\n  assumes \"wf t\" and \"S \\<in> structure\" and \"\\<not> sat S (fst (root t))\"\n  shows\n    \"alw (\\<lambda>stepSs. let ((s,r),S) = shd stepSs; ((s',_),S') = shd (stl stepSs) in\n                    S \\<in> structure \\<and> \\<not> sat S s \\<and> descent (s,S) r (s',S'))\n     (konigDown t S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (\\<lambda>stepSs.\n            let ((s, r), S) = shd stepSs; ((s', uu_), S') = shd (stl stepSs)\n            in S \\<in> structure \\<and>\n               \\<not> sat S s \\<and> descent (s, S) r (s', S'))\n     (konigDown t S)", "using konigDtree[of \"\\<lambda>(s,S). S \\<in> structure \\<and> \\<not> sat S s\" descent, unfolded konigDown_def[symmetric]]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>r s sl a.\n              \\<lbrakk>r \\<in> R; eff r s sl;\n               case (s, a) of\n               (s, S) \\<Rightarrow>\n                 S \\<in> structure \\<and> \\<not> sat S s\\<rbrakk>\n              \\<Longrightarrow> \\<exists>s' a'.\n                                   s' |\\<in>| sl \\<and>\n                                   (case (s', a') of\n                                    (s, S) \\<Rightarrow>\nS \\<in> structure \\<and> \\<not> sat S s) \\<and>\n                                   descent (s, a) r (s', a');\n   local.wf ?t;\n   case (fst (tree.root ?t), ?a) of\n   (s, S) \\<Rightarrow> S \\<in> structure \\<and> \\<not> sat S s\\<rbrakk>\n  \\<Longrightarrow> alw (\\<lambda>stepas.\n                            let ((s, r), a) = shd stepas;\n                                ((s', uu_), a') = shd (stl stepas)\n                            in (case (s, a) of\n                                (s, S) \\<Rightarrow>\n                                  S \\<in> structure \\<and>\n                                  \\<not> sat S s) \\<and>\n                               descent (s, a) r (s', a'))\n                     (konigDown ?t ?a)\n\ngoal (1 subgoal):\n 1. alw (\\<lambda>stepSs.\n            let ((s, r), S) = shd stepSs; ((s', uu_), S') = shd (stl stepSs)\n            in S \\<in> structure \\<and>\n               \\<not> sat S s \\<and> descent (s, S) r (s', S'))\n     (konigDown t S)", "using assms descent"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>r s sl a.\n              \\<lbrakk>r \\<in> R; eff r s sl;\n               case (s, a) of\n               (s, S) \\<Rightarrow>\n                 S \\<in> structure \\<and> \\<not> sat S s\\<rbrakk>\n              \\<Longrightarrow> \\<exists>s' a'.\n                                   s' |\\<in>| sl \\<and>\n                                   (case (s', a') of\n                                    (s, S) \\<Rightarrow>\nS \\<in> structure \\<and> \\<not> sat S s) \\<and>\n                                   descent (s, a) r (s', a');\n   local.wf ?t;\n   case (fst (tree.root ?t), ?a) of\n   (s, S) \\<Rightarrow> S \\<in> structure \\<and> \\<not> sat S s\\<rbrakk>\n  \\<Longrightarrow> alw (\\<lambda>stepas.\n                            let ((s, r), a) = shd stepas;\n                                ((s', uu_), a') = shd (stl stepas)\n                            in (case (s, a) of\n                                (s, S) \\<Rightarrow>\n                                  S \\<in> structure \\<and>\n                                  \\<not> sat S s) \\<and>\n                               descent (s, a) r (s', a'))\n                     (konigDown ?t ?a)\n  local.wf t\n  S \\<in> structure\n  \\<not> sat S (fst (tree.root t))\n  \\<lbrakk>?r \\<in> R; eff ?r ?s ?sl; ?S \\<in> structure;\n   \\<not> sat ?S ?s\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s' S'.\n                       s' |\\<in>| ?sl \\<and>\n                       S' \\<in> structure \\<and>\n                       \\<not> sat S' s' \\<and>\n                       (\\<forall>v v' b.\n                           (v, b, v')\n                           \\<in> \\<delta> ?s ?r s' \\<longrightarrow>\n                           (\\<sigma> (v', S'), \\<sigma> (v, ?S))\n                           \\<in> Ord \\<and>\n                           (b \\<longrightarrow>\n                            \\<sigma> (v', S') \\<noteq> \\<sigma> (v, ?S)))\n\ngoal (1 subgoal):\n 1. alw (\\<lambda>stepSs.\n            let ((s, r), S) = shd stepSs; ((s', uu_), S') = shd (stl stepSs)\n            in S \\<in> structure \\<and>\n               \\<not> sat S s \\<and> descent (s, S) r (s', S'))\n     (konigDown t S)", "by auto"], ["", "lemma konigDown_ipath:\n  assumes \"wf t\" and \"S \\<in> structure\" and \"\\<not> sat S (fst (root t))\"\n  shows\n    \"ipath t (smap fst (konigDown t S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ipath t (smap fst (konigDown t S))", "using konigDtree_ipath[of \"\\<lambda>(s,S). S \\<in> structure \\<and> \\<not> sat S s\" descent, unfolded konigDown_def[symmetric]]"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>r s sl a.\n              \\<lbrakk>r \\<in> R; eff r s sl;\n               case (s, a) of\n               (s, S) \\<Rightarrow>\n                 S \\<in> structure \\<and> \\<not> sat S s\\<rbrakk>\n              \\<Longrightarrow> \\<exists>s' a'.\n                                   s' |\\<in>| sl \\<and>\n                                   (case (s', a') of\n                                    (s, S) \\<Rightarrow>\nS \\<in> structure \\<and> \\<not> sat S s) \\<and>\n                                   descent (s, a) r (s', a');\n   local.wf ?t;\n   case (fst (tree.root ?t), ?a) of\n   (s, S) \\<Rightarrow> S \\<in> structure \\<and> \\<not> sat S s\\<rbrakk>\n  \\<Longrightarrow> ipath ?t (smap fst (konigDown ?t ?a))\n\ngoal (1 subgoal):\n 1. ipath t (smap fst (konigDown t S))", "using assms descent"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<And>r s sl a.\n              \\<lbrakk>r \\<in> R; eff r s sl;\n               case (s, a) of\n               (s, S) \\<Rightarrow>\n                 S \\<in> structure \\<and> \\<not> sat S s\\<rbrakk>\n              \\<Longrightarrow> \\<exists>s' a'.\n                                   s' |\\<in>| sl \\<and>\n                                   (case (s', a') of\n                                    (s, S) \\<Rightarrow>\nS \\<in> structure \\<and> \\<not> sat S s) \\<and>\n                                   descent (s, a) r (s', a');\n   local.wf ?t;\n   case (fst (tree.root ?t), ?a) of\n   (s, S) \\<Rightarrow> S \\<in> structure \\<and> \\<not> sat S s\\<rbrakk>\n  \\<Longrightarrow> ipath ?t (smap fst (konigDown ?t ?a))\n  local.wf t\n  S \\<in> structure\n  \\<not> sat S (fst (tree.root t))\n  \\<lbrakk>?r \\<in> R; eff ?r ?s ?sl; ?S \\<in> structure;\n   \\<not> sat ?S ?s\\<rbrakk>\n  \\<Longrightarrow> \\<exists>s' S'.\n                       s' |\\<in>| ?sl \\<and>\n                       S' \\<in> structure \\<and>\n                       \\<not> sat S' s' \\<and>\n                       (\\<forall>v v' b.\n                           (v, b, v')\n                           \\<in> \\<delta> ?s ?r s' \\<longrightarrow>\n                           (\\<sigma> (v', S'), \\<sigma> (v, ?S))\n                           \\<in> Ord \\<and>\n                           (b \\<longrightarrow>\n                            \\<sigma> (v', S') \\<noteq> \\<sigma> (v, ?S)))\n\ngoal (1 subgoal):\n 1. ipath t (smap fst (konigDown t S))", "by auto"], ["", "context\n  fixes t S\n  assumes w: \"wf t\" and t: \"good t\" and S: \"S \\<in> structure\" \"\\<not> sat S (fst (root t))\"\nbegin"], ["", "lemma alw_ev_Ord:\n  obtains ks where \"alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord) ks\"\n    and \"alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)) ks\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ks.\n        \\<lbrakk>alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord) ks;\n         alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)) ks\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>ks.\n        \\<lbrakk>alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord) ks;\n         alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)) ks\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define P where \"P \\<equiv> \\<lambda>stepSs. let ((s,r),S) = shd stepSs; ((s',_),S') = shd (stl stepSs) in\n                      S \\<in> structure \\<and> \\<not> sat S s \\<and> descent (s,S) r (s',S')\""], ["proof (state)\nthis:\n  P \\<equiv>\n  \\<lambda>stepSs.\n     let ((s, r), S) = shd stepSs; ((s', uu_), S') = shd (stl stepSs)\n     in S \\<in> structure \\<and>\n        \\<not> sat S s \\<and> descent (s, S) r (s', S')\n\ngoal (1 subgoal):\n 1. (\\<And>ks.\n        \\<lbrakk>alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord) ks;\n         alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)) ks\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"alw P (konigDown t S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alw P (konigDown t S)", "using konigDown[OF w S]"], ["proof (prove)\nusing this:\n  alw (\\<lambda>stepSs.\n          let ((s, r), S) = shd stepSs; ((s', uu_), S') = shd (stl stepSs)\n          in S \\<in> structure \\<and>\n             \\<not> sat S s \\<and> descent (s, S) r (s', S'))\n   (konigDown t S)\n\ngoal (1 subgoal):\n 1. alw P (konigDown t S)", "unfolding P_def"], ["proof (prove)\nusing this:\n  alw (\\<lambda>stepSs.\n          let ((s, r), S) = shd stepSs; ((s', uu_), S') = shd (stl stepSs)\n          in S \\<in> structure \\<and>\n             \\<not> sat S s \\<and> descent (s, S) r (s', S'))\n   (konigDown t S)\n\ngoal (1 subgoal):\n 1. alw (\\<lambda>stepSs.\n            let ((s, r), S) = shd stepSs; ((s', uu_), S') = shd (stl stepSs)\n            in S \\<in> structure \\<and>\n               \\<not> sat S s \\<and> descent (s, S) r (s', S'))\n     (konigDown t S)", "by auto"], ["proof (state)\nthis:\n  alw P (konigDown t S)\n\ngoal (1 subgoal):\n 1. (\\<And>ks.\n        \\<lbrakk>alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord) ks;\n         alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)) ks\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain srs steps bs Ms where 0: \"smap fst (konigDown t S) = srs @- steps\" and\n    f: \"follow bs Ms steps\" and i: \"infDecr bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>srs steps bs Ms.\n        \\<lbrakk>smap fst (konigDown t S) = srs @- steps;\n         follow bs Ms steps; infDecr bs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using konigDown_ipath[OF w S] t"], ["proof (prove)\nusing this:\n  ipath t (smap fst (konigDown t S))\n  good t\n\ngoal (1 subgoal):\n 1. (\\<And>srs steps bs Ms.\n        \\<lbrakk>smap fst (konigDown t S) = srs @- steps;\n         follow bs Ms steps; infDecr bs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding good_def ev_iff_shift"], ["proof (prove)\nusing this:\n  ipath t (smap fst (konigDown t S))\n  \\<forall>steps.\n     ipath t steps \\<longrightarrow>\n     (\\<exists>xl xs2.\n         steps = xl @- xs2 \\<and>\n         (\\<exists>bs Ms. follow bs Ms xs2 \\<and> infDecr bs))\n\ngoal (1 subgoal):\n 1. (\\<And>srs steps bs Ms.\n        \\<lbrakk>smap fst (konigDown t S) = srs @- steps;\n         follow bs Ms steps; infDecr bs\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  smap fst (konigDown t S) = srs @- steps\n  follow bs Ms steps\n  infDecr bs\n\ngoal (1 subgoal):\n 1. (\\<And>ks.\n        \\<lbrakk>alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord) ks;\n         alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)) ks\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define stepSs where \"stepSs = sdrop (length srs) (konigDown t S)\""], ["proof (state)\nthis:\n  stepSs = sdrop (length srs) (konigDown t S)\n\ngoal (1 subgoal):\n 1. (\\<And>ks.\n        \\<lbrakk>alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord) ks;\n         alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)) ks\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have steps: \"steps = smap fst stepSs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. steps = smap fst stepSs", "unfolding stepSs_def sdrop_smap[symmetric] 0"], ["proof (prove)\ngoal (1 subgoal):\n 1. steps = sdrop (length srs) (srs @- steps)", "by simp"], ["proof (state)\nthis:\n  steps = smap fst stepSs\n\ngoal (1 subgoal):\n 1. (\\<And>ks.\n        \\<lbrakk>alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord) ks;\n         alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)) ks\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have e: \"epath steps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. epath steps", "using wf_ipath_epath[OF w konigDown_ipath[OF w S]] 0 epath_shift"], ["proof (prove)\nusing this:\n  epath (smap fst (konigDown t S))\n  smap fst (konigDown t S) = srs @- steps\n  epath (?srs @- ?steps) \\<Longrightarrow> epath ?steps\n\ngoal (1 subgoal):\n 1. epath steps", "by simp"], ["proof (state)\nthis:\n  epath steps\n\ngoal (1 subgoal):\n 1. (\\<And>ks.\n        \\<lbrakk>alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord) ks;\n         alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)) ks\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"alw P (konigDown t S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alw P (konigDown t S)", "using konigDown[OF w S]"], ["proof (prove)\nusing this:\n  alw (\\<lambda>stepSs.\n          let ((s, r), S) = shd stepSs; ((s', uu_), S') = shd (stl stepSs)\n          in S \\<in> structure \\<and>\n             \\<not> sat S s \\<and> descent (s, S) r (s', S'))\n   (konigDown t S)\n\ngoal (1 subgoal):\n 1. alw P (konigDown t S)", "unfolding P_def"], ["proof (prove)\nusing this:\n  alw (\\<lambda>stepSs.\n          let ((s, r), S) = shd stepSs; ((s', uu_), S') = shd (stl stepSs)\n          in S \\<in> structure \\<and>\n             \\<not> sat S s \\<and> descent (s, S) r (s', S'))\n   (konigDown t S)\n\ngoal (1 subgoal):\n 1. alw (\\<lambda>stepSs.\n            let ((s, r), S) = shd stepSs; ((s', uu_), S') = shd (stl stepSs)\n            in S \\<in> structure \\<and>\n               \\<not> sat S s \\<and> descent (s, S) r (s', S'))\n     (konigDown t S)", "by auto"], ["proof (state)\nthis:\n  alw P (konigDown t S)\n\ngoal (1 subgoal):\n 1. (\\<And>ks.\n        \\<lbrakk>alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord) ks;\n         alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)) ks\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence P: \"alw P stepSs\""], ["proof (prove)\nusing this:\n  alw P (konigDown t S)\n\ngoal (1 subgoal):\n 1. alw P stepSs", "using alw_sdrop"], ["proof (prove)\nusing this:\n  alw P (konigDown t S)\n  alw ?\\<phi> ?xs \\<Longrightarrow> alw ?\\<phi> (sdrop ?n ?xs)\n\ngoal (1 subgoal):\n 1. alw P stepSs", "unfolding stepSs_def"], ["proof (prove)\nusing this:\n  alw P (konigDown t S)\n  alw ?\\<phi> ?xs \\<Longrightarrow> alw ?\\<phi> (sdrop ?n ?xs)\n\ngoal (1 subgoal):\n 1. alw P (sdrop (length srs) (konigDown t S))", "by auto"], ["proof (state)\nthis:\n  alw P stepSs\n\ngoal (1 subgoal):\n 1. (\\<And>ks.\n        \\<lbrakk>alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord) ks;\n         alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)) ks\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "let ?ks = \"smap \\<sigma> (szip Ms (smap snd stepSs))\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>ks.\n        \\<lbrakk>alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord) ks;\n         alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)) ks\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "proof(rule that[of ?ks])"], ["proof (state)\ngoal (2 subgoals):\n 1. alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord)\n     (smap \\<sigma> (szip Ms (smap snd stepSs)))\n 2. alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks))\n     (smap \\<sigma> (szip Ms (smap snd stepSs)))", "show \"alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord) ?ks\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord)\n     (smap \\<sigma> (szip Ms (smap snd stepSs)))", "using e f P"], ["proof (prove)\nusing this:\n  epath steps\n  follow bs Ms steps\n  alw P stepSs\n\ngoal (1 subgoal):\n 1. alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord)\n     (smap \\<sigma> (szip Ms (smap snd stepSs)))", "unfolding steps"], ["proof (prove)\nusing this:\n  epath (smap fst stepSs)\n  follow bs Ms (smap fst stepSs)\n  alw P stepSs\n\ngoal (1 subgoal):\n 1. alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord)\n     (smap \\<sigma> (szip Ms (smap snd stepSs)))", "proof(coinduction arbitrary: bs Ms stepSs rule: alw_coinduct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> (shd (stl (smap \\<sigma>\n                                     (szip Ms (smap snd stepSs)))),\n                          shd (smap \\<sigma> (szip Ms (smap snd stepSs))))\n                         \\<in> Ord\n 2. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs;\n        \\<not> alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord)\n                (stl (smap \\<sigma> (szip Ms (smap snd stepSs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bs Msa stepSsa.\n                            stl (smap \\<sigma>\n                                  (szip Ms (smap snd stepSs))) =\n                            smap \\<sigma>\n                             (szip Msa (smap snd stepSsa)) \\<and>\n                            epath (smap fst stepSsa) \\<and>\n                            follow bs Msa (smap fst stepSsa) \\<and>\n                            alw P stepSsa", "case (alw bs Ms stepSs)"], ["proof (state)\nthis:\n  epath (smap fst stepSs)\n  follow bs Ms (smap fst stepSs)\n  alw P stepSs\n\ngoal (2 subgoals):\n 1. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> (shd (stl (smap \\<sigma>\n                                     (szip Ms (smap snd stepSs)))),\n                          shd (smap \\<sigma> (szip Ms (smap snd stepSs))))\n                         \\<in> Ord\n 2. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs;\n        \\<not> alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord)\n                (stl (smap \\<sigma> (szip Ms (smap snd stepSs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bs Msa stepSsa.\n                            stl (smap \\<sigma>\n                                  (szip Ms (smap snd stepSs))) =\n                            smap \\<sigma>\n                             (szip Msa (smap snd stepSsa)) \\<and>\n                            epath (smap fst stepSsa) \\<and>\n                            follow bs Msa (smap fst stepSsa) \\<and>\n                            alw P stepSsa", "let ?steps = \"smap fst stepSs\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> (shd (stl (smap \\<sigma>\n                                     (szip Ms (smap snd stepSs)))),\n                          shd (smap \\<sigma> (szip Ms (smap snd stepSs))))\n                         \\<in> Ord\n 2. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs;\n        \\<not> alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord)\n                (stl (smap \\<sigma> (szip Ms (smap snd stepSs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bs Msa stepSsa.\n                            stl (smap \\<sigma>\n                                  (szip Ms (smap snd stepSs))) =\n                            smap \\<sigma>\n                             (szip Msa (smap snd stepSsa)) \\<and>\n                            epath (smap fst stepSsa) \\<and>\n                            follow bs Msa (smap fst stepSsa) \\<and>\n                            alw P stepSsa", "let ?Ss = \"smap snd stepSs\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> (shd (stl (smap \\<sigma>\n                                     (szip Ms (smap snd stepSs)))),\n                          shd (smap \\<sigma> (szip Ms (smap snd stepSs))))\n                         \\<in> Ord\n 2. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs;\n        \\<not> alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord)\n                (stl (smap \\<sigma> (szip Ms (smap snd stepSs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bs Msa stepSsa.\n                            stl (smap \\<sigma>\n                                  (szip Ms (smap snd stepSs))) =\n                            smap \\<sigma>\n                             (szip Msa (smap snd stepSsa)) \\<and>\n                            epath (smap fst stepSsa) \\<and>\n                            follow bs Msa (smap fst stepSsa) \\<and>\n                            alw P stepSsa", "let ?MSs = \"szip Ms (smap snd stepSs)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> (shd (stl (smap \\<sigma>\n                                     (szip Ms (smap snd stepSs)))),\n                          shd (smap \\<sigma> (szip Ms (smap snd stepSs))))\n                         \\<in> Ord\n 2. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs;\n        \\<not> alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord)\n                (stl (smap \\<sigma> (szip Ms (smap snd stepSs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bs Msa stepSsa.\n                            stl (smap \\<sigma>\n                                  (szip Ms (smap snd stepSs))) =\n                            smap \\<sigma>\n                             (szip Msa (smap snd stepSsa)) \\<and>\n                            epath (smap fst stepSsa) \\<and>\n                            follow bs Msa (smap fst stepSsa) \\<and>\n                            alw P stepSsa", "let ?s = \"fst (shd ?steps)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> (shd (stl (smap \\<sigma>\n                                     (szip Ms (smap snd stepSs)))),\n                          shd (smap \\<sigma> (szip Ms (smap snd stepSs))))\n                         \\<in> Ord\n 2. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs;\n        \\<not> alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord)\n                (stl (smap \\<sigma> (szip Ms (smap snd stepSs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bs Msa stepSsa.\n                            stl (smap \\<sigma>\n                                  (szip Ms (smap snd stepSs))) =\n                            smap \\<sigma>\n                             (szip Msa (smap snd stepSsa)) \\<and>\n                            epath (smap fst stepSsa) \\<and>\n                            follow bs Msa (smap fst stepSsa) \\<and>\n                            alw P stepSsa", "let ?s' = \"fst (shd (stl ?steps))\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> (shd (stl (smap \\<sigma>\n                                     (szip Ms (smap snd stepSs)))),\n                          shd (smap \\<sigma> (szip Ms (smap snd stepSs))))\n                         \\<in> Ord\n 2. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs;\n        \\<not> alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord)\n                (stl (smap \\<sigma> (szip Ms (smap snd stepSs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bs Msa stepSsa.\n                            stl (smap \\<sigma>\n                                  (szip Ms (smap snd stepSs))) =\n                            smap \\<sigma>\n                             (szip Msa (smap snd stepSsa)) \\<and>\n                            epath (smap fst stepSsa) \\<and>\n                            follow bs Msa (smap fst stepSsa) \\<and>\n                            alw P stepSsa", "let ?r = \"snd (shd ?steps)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> (shd (stl (smap \\<sigma>\n                                     (szip Ms (smap snd stepSs)))),\n                          shd (smap \\<sigma> (szip Ms (smap snd stepSs))))\n                         \\<in> Ord\n 2. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs;\n        \\<not> alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord)\n                (stl (smap \\<sigma> (szip Ms (smap snd stepSs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bs Msa stepSsa.\n                            stl (smap \\<sigma>\n                                  (szip Ms (smap snd stepSs))) =\n                            smap \\<sigma>\n                             (szip Msa (smap snd stepSsa)) \\<and>\n                            epath (smap fst stepSsa) \\<and>\n                            follow bs Msa (smap fst stepSsa) \\<and>\n                            alw P stepSsa", "let ?S = \"snd (shd stepSs)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> (shd (stl (smap \\<sigma>\n                                     (szip Ms (smap snd stepSs)))),\n                          shd (smap \\<sigma> (szip Ms (smap snd stepSs))))\n                         \\<in> Ord\n 2. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs;\n        \\<not> alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord)\n                (stl (smap \\<sigma> (szip Ms (smap snd stepSs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bs Msa stepSsa.\n                            stl (smap \\<sigma>\n                                  (szip Ms (smap snd stepSs))) =\n                            smap \\<sigma>\n                             (szip Msa (smap snd stepSsa)) \\<and>\n                            epath (smap fst stepSsa) \\<and>\n                            follow bs Msa (smap fst stepSsa) \\<and>\n                            alw P stepSsa", "let ?S' = \"snd (shd (stl stepSs))\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> (shd (stl (smap \\<sigma>\n                                     (szip Ms (smap snd stepSs)))),\n                          shd (smap \\<sigma> (szip Ms (smap snd stepSs))))\n                         \\<in> Ord\n 2. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs;\n        \\<not> alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord)\n                (stl (smap \\<sigma> (szip Ms (smap snd stepSs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bs Msa stepSsa.\n                            stl (smap \\<sigma>\n                                  (szip Ms (smap snd stepSs))) =\n                            smap \\<sigma>\n                             (szip Msa (smap snd stepSsa)) \\<and>\n                            epath (smap fst stepSsa) \\<and>\n                            follow bs Msa (smap fst stepSsa) \\<and>\n                            alw P stepSsa", "let ?M = \"shd Ms\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> (shd (stl (smap \\<sigma>\n                                     (szip Ms (smap snd stepSs)))),\n                          shd (smap \\<sigma> (szip Ms (smap snd stepSs))))\n                         \\<in> Ord\n 2. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs;\n        \\<not> alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord)\n                (stl (smap \\<sigma> (szip Ms (smap snd stepSs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bs Msa stepSsa.\n                            stl (smap \\<sigma>\n                                  (szip Ms (smap snd stepSs))) =\n                            smap \\<sigma>\n                             (szip Msa (smap snd stepSsa)) \\<and>\n                            epath (smap fst stepSsa) \\<and>\n                            follow bs Msa (smap fst stepSsa) \\<and>\n                            alw P stepSsa", "let ?M' = \"shd (stl Ms)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> (shd (stl (smap \\<sigma>\n                                     (szip Ms (smap snd stepSs)))),\n                          shd (smap \\<sigma> (szip Ms (smap snd stepSs))))\n                         \\<in> Ord\n 2. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs;\n        \\<not> alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord)\n                (stl (smap \\<sigma> (szip Ms (smap snd stepSs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bs Msa stepSsa.\n                            stl (smap \\<sigma>\n                                  (szip Ms (smap snd stepSs))) =\n                            smap \\<sigma>\n                             (szip Msa (smap snd stepSsa)) \\<and>\n                            epath (smap fst stepSsa) \\<and>\n                            follow bs Msa (smap fst stepSsa) \\<and>\n                            alw P stepSsa", "let ?b = \"shd bs\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> (shd (stl (smap \\<sigma>\n                                     (szip Ms (smap snd stepSs)))),\n                          shd (smap \\<sigma> (szip Ms (smap snd stepSs))))\n                         \\<in> Ord\n 2. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs;\n        \\<not> alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord)\n                (stl (smap \\<sigma> (szip Ms (smap snd stepSs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bs Msa stepSsa.\n                            stl (smap \\<sigma>\n                                  (szip Ms (smap snd stepSs))) =\n                            smap \\<sigma>\n                             (szip Msa (smap snd stepSsa)) \\<and>\n                            epath (smap fst stepSsa) \\<and>\n                            follow bs Msa (smap fst stepSsa) \\<and>\n                            alw P stepSsa", "have 1: \"(?M, ?b, ?M') \\<in> \\<delta> ?s ?r ?s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (shd Ms, shd bs, shd (stl Ms))\n    \\<in> \\<delta> (fst (shd (smap fst stepSs)))\n           (snd (shd (smap fst stepSs))) (fst (shd (stl (smap fst stepSs))))", "using \\<open>follow bs Ms (smap fst stepSs)\\<close>"], ["proof (prove)\nusing this:\n  follow bs Ms (smap fst stepSs)\n\ngoal (1 subgoal):\n 1. (shd Ms, shd bs, shd (stl Ms))\n    \\<in> \\<delta> (fst (shd (smap fst stepSs)))\n           (snd (shd (smap fst stepSs))) (fst (shd (stl (smap fst stepSs))))", "by (cases rule: follow.cases) auto"], ["proof (state)\nthis:\n  (shd Ms, shd bs, shd (stl Ms))\n  \\<in> \\<delta> (fst (shd (smap fst stepSs))) (snd (shd (smap fst stepSs)))\n         (fst (shd (stl (smap fst stepSs))))\n\ngoal (2 subgoals):\n 1. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> (shd (stl (smap \\<sigma>\n                                     (szip Ms (smap snd stepSs)))),\n                          shd (smap \\<sigma> (szip Ms (smap snd stepSs))))\n                         \\<in> Ord\n 2. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs;\n        \\<not> alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord)\n                (stl (smap \\<sigma> (szip Ms (smap snd stepSs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bs Msa stepSsa.\n                            stl (smap \\<sigma>\n                                  (szip Ms (smap snd stepSs))) =\n                            smap \\<sigma>\n                             (szip Msa (smap snd stepSsa)) \\<and>\n                            epath (smap fst stepSsa) \\<and>\n                            follow bs Msa (smap fst stepSsa) \\<and>\n                            alw P stepSsa", "have 2: \"descent (?s,?S) ?r (?s',?S')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. descent (fst (shd (smap fst stepSs)), snd (shd stepSs))\n     (snd (shd (smap fst stepSs)))\n     (fst (shd (stl (smap fst stepSs))), snd (shd (stl stepSs)))", "using \\<open>alw P stepSs\\<close>"], ["proof (prove)\nusing this:\n  alw P stepSs\n\ngoal (1 subgoal):\n 1. descent (fst (shd (smap fst stepSs)), snd (shd stepSs))\n     (snd (shd (smap fst stepSs)))\n     (fst (shd (stl (smap fst stepSs))), snd (shd (stl stepSs)))", "unfolding P_def"], ["proof (prove)\nusing this:\n  alw (\\<lambda>stepSs.\n          let ((s, r), S) = shd stepSs; ((s', uu_), S') = shd (stl stepSs)\n          in S \\<in> structure \\<and>\n             \\<not> sat S s \\<and> descent (s, S) r (s', S'))\n   stepSs\n\ngoal (1 subgoal):\n 1. descent (fst (shd (smap fst stepSs)), snd (shd stepSs))\n     (snd (shd (smap fst stepSs)))\n     (fst (shd (stl (smap fst stepSs))), snd (shd (stl stepSs)))", "by (cases rule: alw.cases) auto"], ["proof (state)\nthis:\n  descent (fst (shd (smap fst stepSs)), snd (shd stepSs))\n   (snd (shd (smap fst stepSs)))\n   (fst (shd (stl (smap fst stepSs))), snd (shd (stl stepSs)))\n\ngoal (2 subgoals):\n 1. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> (shd (stl (smap \\<sigma>\n                                     (szip Ms (smap snd stepSs)))),\n                          shd (smap \\<sigma> (szip Ms (smap snd stepSs))))\n                         \\<in> Ord\n 2. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs;\n        \\<not> alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord)\n                (stl (smap \\<sigma> (szip Ms (smap snd stepSs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bs Msa stepSsa.\n                            stl (smap \\<sigma>\n                                  (szip Ms (smap snd stepSs))) =\n                            smap \\<sigma>\n                             (szip Msa (smap snd stepSsa)) \\<and>\n                            epath (smap fst stepSsa) \\<and>\n                            follow bs Msa (smap fst stepSsa) \\<and>\n                            alw P stepSsa", "have \"(\\<sigma>(?M',?S'), \\<sigma>(?M,?S)) \\<in> Ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> (shd (stl Ms), snd (shd (stl stepSs))),\n     \\<sigma> (shd Ms, snd (shd stepSs)))\n    \\<in> Ord", "using descentE[OF 2 1]"], ["proof (prove)\nusing this:\n  (\\<sigma> (shd (stl Ms), snd (shd (stl stepSs))),\n   \\<sigma> (shd Ms, snd (shd stepSs)))\n  \\<in> Ord \\<and>\n  (shd bs \\<longrightarrow>\n   \\<sigma> (shd (stl Ms), snd (shd (stl stepSs))) \\<noteq>\n   \\<sigma> (shd Ms, snd (shd stepSs)))\n\ngoal (1 subgoal):\n 1. (\\<sigma> (shd (stl Ms), snd (shd (stl stepSs))),\n     \\<sigma> (shd Ms, snd (shd stepSs)))\n    \\<in> Ord", "by simp"], ["proof (state)\nthis:\n  (\\<sigma> (shd (stl Ms), snd (shd (stl stepSs))),\n   \\<sigma> (shd Ms, snd (shd stepSs)))\n  \\<in> Ord\n\ngoal (2 subgoals):\n 1. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> (shd (stl (smap \\<sigma>\n                                     (szip Ms (smap snd stepSs)))),\n                          shd (smap \\<sigma> (szip Ms (smap snd stepSs))))\n                         \\<in> Ord\n 2. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs;\n        \\<not> alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord)\n                (stl (smap \\<sigma> (szip Ms (smap snd stepSs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bs Msa stepSsa.\n                            stl (smap \\<sigma>\n                                  (szip Ms (smap snd stepSs))) =\n                            smap \\<sigma>\n                             (szip Msa (smap snd stepSsa)) \\<and>\n                            epath (smap fst stepSsa) \\<and>\n                            follow bs Msa (smap fst stepSsa) \\<and>\n                            alw P stepSsa", "thus ?case"], ["proof (prove)\nusing this:\n  (\\<sigma> (shd (stl Ms), snd (shd (stl stepSs))),\n   \\<sigma> (shd Ms, snd (shd stepSs)))\n  \\<in> Ord\n\ngoal (1 subgoal):\n 1. (shd (stl (smap \\<sigma> (szip Ms (smap snd stepSs)))),\n     shd (smap \\<sigma> (szip Ms (smap snd stepSs))))\n    \\<in> Ord", "by simp"], ["proof (state)\nthis:\n  (shd (stl (smap \\<sigma> (szip Ms (smap snd stepSs)))),\n   shd (smap \\<sigma> (szip Ms (smap snd stepSs))))\n  \\<in> Ord\n\ngoal (1 subgoal):\n 1. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs;\n        \\<not> alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord)\n                (stl (smap \\<sigma> (szip Ms (smap snd stepSs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bs Msa stepSsa.\n                            stl (smap \\<sigma>\n                                  (szip Ms (smap snd stepSs))) =\n                            smap \\<sigma>\n                             (szip Msa (smap snd stepSsa)) \\<and>\n                            epath (smap fst stepSsa) \\<and>\n                            follow bs Msa (smap fst stepSsa) \\<and>\n                            alw P stepSsa", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs;\n        \\<not> alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord)\n                (stl (smap \\<sigma> (szip Ms (smap snd stepSs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bs Msa stepSsa.\n                            stl (smap \\<sigma>\n                                  (szip Ms (smap snd stepSs))) =\n                            smap \\<sigma>\n                             (szip Msa (smap snd stepSsa)) \\<and>\n                            epath (smap fst stepSsa) \\<and>\n                            follow bs Msa (smap fst stepSsa) \\<and>\n                            alw P stepSsa", "case (stl bs Ms stepSs)"], ["proof (state)\nthis:\n  epath (smap fst stepSs)\n  follow bs Ms (smap fst stepSs)\n  alw P stepSs\n  \\<not> alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord)\n          (stl (smap \\<sigma> (szip Ms (smap snd stepSs))))\n\ngoal (1 subgoal):\n 1. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs;\n        \\<not> alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord)\n                (stl (smap \\<sigma> (szip Ms (smap snd stepSs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bs Msa stepSsa.\n                            stl (smap \\<sigma>\n                                  (szip Ms (smap snd stepSs))) =\n                            smap \\<sigma>\n                             (szip Msa (smap snd stepSsa)) \\<and>\n                            epath (smap fst stepSsa) \\<and>\n                            follow bs Msa (smap fst stepSsa) \\<and>\n                            alw P stepSsa", "thus ?case"], ["proof (prove)\nusing this:\n  epath (smap fst stepSs)\n  follow bs Ms (smap fst stepSs)\n  alw P stepSs\n  \\<not> alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord)\n          (stl (smap \\<sigma> (szip Ms (smap snd stepSs))))\n\ngoal (1 subgoal):\n 1. \\<exists>bs Ms stepSs.\n       stl (smap \\<sigma> (szip Ms (smap snd stepSs))) =\n       smap \\<sigma> (szip Ms (smap snd stepSs)) \\<and>\n       epath (smap fst stepSs) \\<and>\n       follow bs Ms (smap fst stepSs) \\<and> alw P stepSs", "by (intro exI[of _ \"stl bs\"] exI[of _ \"stl Ms\"] exI[of _ \"stl stepSs\"])\n          (auto elim: epath.cases)"], ["proof (state)\nthis:\n  \\<exists>bs Ms stepSs.\n     stl (smap \\<sigma> (szip Ms (smap snd stepSs))) =\n     smap \\<sigma> (szip Ms (smap snd stepSs)) \\<and>\n     epath (smap fst stepSs) \\<and>\n     follow bs Ms (smap fst stepSs) \\<and> alw P stepSs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord)\n   (smap \\<sigma> (szip Ms (smap snd stepSs)))\n\ngoal (1 subgoal):\n 1. alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks))\n     (smap \\<sigma> (szip Ms (smap snd stepSs)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks))\n     (smap \\<sigma> (szip Ms (smap snd stepSs)))", "show \"alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)) ?ks\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks))\n     (smap \\<sigma> (szip Ms (smap snd stepSs)))", "using e f P i"], ["proof (prove)\nusing this:\n  epath steps\n  follow bs Ms steps\n  alw P stepSs\n  infDecr bs\n\ngoal (1 subgoal):\n 1. alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks))\n     (smap \\<sigma> (szip Ms (smap snd stepSs)))", "unfolding steps"], ["proof (prove)\nusing this:\n  epath (smap fst stepSs)\n  follow bs Ms (smap fst stepSs)\n  alw P stepSs\n  infDecr bs\n\ngoal (1 subgoal):\n 1. alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks))\n     (smap \\<sigma> (szip Ms (smap snd stepSs)))", "proof(coinduction arbitrary: bs Ms stepSs rule: alw_coinduct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs; infDecr bs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))\n 2. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs; infDecr bs;\n        \\<not> alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks))\n                (stl (smap \\<sigma> (szip Ms (smap snd stepSs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bs Msa stepSsa.\n                            stl (smap \\<sigma>\n                                  (szip Ms (smap snd stepSs))) =\n                            smap \\<sigma>\n                             (szip Msa (smap snd stepSsa)) \\<and>\n                            epath (smap fst stepSsa) \\<and>\n                            follow bs Msa (smap fst stepSsa) \\<and>\n                            alw P stepSsa \\<and> infDecr bs", "case (alw bs Ms stepSs)"], ["proof (state)\nthis:\n  epath (smap fst stepSs)\n  follow bs Ms (smap fst stepSs)\n  alw P stepSs\n  infDecr bs\n\ngoal (2 subgoals):\n 1. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs; infDecr bs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))\n 2. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs; infDecr bs;\n        \\<not> alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks))\n                (stl (smap \\<sigma> (szip Ms (smap snd stepSs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bs Msa stepSsa.\n                            stl (smap \\<sigma>\n                                  (szip Ms (smap snd stepSs))) =\n                            smap \\<sigma>\n                             (szip Msa (smap snd stepSsa)) \\<and>\n                            epath (smap fst stepSsa) \\<and>\n                            follow bs Msa (smap fst stepSsa) \\<and>\n                            alw P stepSsa \\<and> infDecr bs", "let ?steps = \"smap fst stepSs\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs; infDecr bs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))\n 2. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs; infDecr bs;\n        \\<not> alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks))\n                (stl (smap \\<sigma> (szip Ms (smap snd stepSs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bs Msa stepSsa.\n                            stl (smap \\<sigma>\n                                  (szip Ms (smap snd stepSs))) =\n                            smap \\<sigma>\n                             (szip Msa (smap snd stepSsa)) \\<and>\n                            epath (smap fst stepSsa) \\<and>\n                            follow bs Msa (smap fst stepSsa) \\<and>\n                            alw P stepSsa \\<and> infDecr bs", "let ?Ss = \"smap snd stepSs\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs; infDecr bs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))\n 2. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs; infDecr bs;\n        \\<not> alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks))\n                (stl (smap \\<sigma> (szip Ms (smap snd stepSs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bs Msa stepSsa.\n                            stl (smap \\<sigma>\n                                  (szip Ms (smap snd stepSs))) =\n                            smap \\<sigma>\n                             (szip Msa (smap snd stepSsa)) \\<and>\n                            epath (smap fst stepSsa) \\<and>\n                            follow bs Msa (smap fst stepSsa) \\<and>\n                            alw P stepSsa \\<and> infDecr bs", "let ?MSs = \"szip Ms (smap snd stepSs)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs; infDecr bs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))\n 2. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs; infDecr bs;\n        \\<not> alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks))\n                (stl (smap \\<sigma> (szip Ms (smap snd stepSs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bs Msa stepSsa.\n                            stl (smap \\<sigma>\n                                  (szip Ms (smap snd stepSs))) =\n                            smap \\<sigma>\n                             (szip Msa (smap snd stepSsa)) \\<and>\n                            epath (smap fst stepSsa) \\<and>\n                            follow bs Msa (smap fst stepSsa) \\<and>\n                            alw P stepSsa \\<and> infDecr bs", "let ?s = \"fst (shd ?steps)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs; infDecr bs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))\n 2. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs; infDecr bs;\n        \\<not> alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks))\n                (stl (smap \\<sigma> (szip Ms (smap snd stepSs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bs Msa stepSsa.\n                            stl (smap \\<sigma>\n                                  (szip Ms (smap snd stepSs))) =\n                            smap \\<sigma>\n                             (szip Msa (smap snd stepSsa)) \\<and>\n                            epath (smap fst stepSsa) \\<and>\n                            follow bs Msa (smap fst stepSsa) \\<and>\n                            alw P stepSsa \\<and> infDecr bs", "let ?s' = \"fst (shd (stl ?steps))\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs; infDecr bs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))\n 2. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs; infDecr bs;\n        \\<not> alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks))\n                (stl (smap \\<sigma> (szip Ms (smap snd stepSs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bs Msa stepSsa.\n                            stl (smap \\<sigma>\n                                  (szip Ms (smap snd stepSs))) =\n                            smap \\<sigma>\n                             (szip Msa (smap snd stepSsa)) \\<and>\n                            epath (smap fst stepSsa) \\<and>\n                            follow bs Msa (smap fst stepSsa) \\<and>\n                            alw P stepSsa \\<and> infDecr bs", "let ?r = \"snd (shd ?steps)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs; infDecr bs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))\n 2. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs; infDecr bs;\n        \\<not> alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks))\n                (stl (smap \\<sigma> (szip Ms (smap snd stepSs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bs Msa stepSsa.\n                            stl (smap \\<sigma>\n                                  (szip Ms (smap snd stepSs))) =\n                            smap \\<sigma>\n                             (szip Msa (smap snd stepSsa)) \\<and>\n                            epath (smap fst stepSsa) \\<and>\n                            follow bs Msa (smap fst stepSsa) \\<and>\n                            alw P stepSsa \\<and> infDecr bs", "let ?S = \"snd (shd stepSs)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs; infDecr bs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))\n 2. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs; infDecr bs;\n        \\<not> alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks))\n                (stl (smap \\<sigma> (szip Ms (smap snd stepSs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bs Msa stepSsa.\n                            stl (smap \\<sigma>\n                                  (szip Ms (smap snd stepSs))) =\n                            smap \\<sigma>\n                             (szip Msa (smap snd stepSsa)) \\<and>\n                            epath (smap fst stepSsa) \\<and>\n                            follow bs Msa (smap fst stepSsa) \\<and>\n                            alw P stepSsa \\<and> infDecr bs", "let ?S' = \"snd (shd (stl stepSs))\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs; infDecr bs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))\n 2. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs; infDecr bs;\n        \\<not> alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks))\n                (stl (smap \\<sigma> (szip Ms (smap snd stepSs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bs Msa stepSsa.\n                            stl (smap \\<sigma>\n                                  (szip Ms (smap snd stepSs))) =\n                            smap \\<sigma>\n                             (szip Msa (smap snd stepSsa)) \\<and>\n                            epath (smap fst stepSsa) \\<and>\n                            follow bs Msa (smap fst stepSsa) \\<and>\n                            alw P stepSsa \\<and> infDecr bs", "let ?M = \"shd Ms\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs; infDecr bs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))\n 2. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs; infDecr bs;\n        \\<not> alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks))\n                (stl (smap \\<sigma> (szip Ms (smap snd stepSs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bs Msa stepSsa.\n                            stl (smap \\<sigma>\n                                  (szip Ms (smap snd stepSs))) =\n                            smap \\<sigma>\n                             (szip Msa (smap snd stepSsa)) \\<and>\n                            epath (smap fst stepSsa) \\<and>\n                            follow bs Msa (smap fst stepSsa) \\<and>\n                            alw P stepSsa \\<and> infDecr bs", "let ?M' = \"shd (stl Ms)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs; infDecr bs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))\n 2. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs; infDecr bs;\n        \\<not> alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks))\n                (stl (smap \\<sigma> (szip Ms (smap snd stepSs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bs Msa stepSsa.\n                            stl (smap \\<sigma>\n                                  (szip Ms (smap snd stepSs))) =\n                            smap \\<sigma>\n                             (szip Msa (smap snd stepSsa)) \\<and>\n                            epath (smap fst stepSsa) \\<and>\n                            follow bs Msa (smap fst stepSsa) \\<and>\n                            alw P stepSsa \\<and> infDecr bs", "let ?b = \"shd bs\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs; infDecr bs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))\n 2. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs; infDecr bs;\n        \\<not> alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks))\n                (stl (smap \\<sigma> (szip Ms (smap snd stepSs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bs Msa stepSsa.\n                            stl (smap \\<sigma>\n                                  (szip Ms (smap snd stepSs))) =\n                            smap \\<sigma>\n                             (szip Msa (smap snd stepSsa)) \\<and>\n                            epath (smap fst stepSsa) \\<and>\n                            follow bs Msa (smap fst stepSsa) \\<and>\n                            alw P stepSsa \\<and> infDecr bs", "have 1: \"(?M, ?b, ?M') \\<in> \\<delta> ?s ?r ?s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (shd Ms, shd bs, shd (stl Ms))\n    \\<in> \\<delta> (fst (shd (smap fst stepSs)))\n           (snd (shd (smap fst stepSs))) (fst (shd (stl (smap fst stepSs))))", "using \\<open>follow bs Ms (smap fst stepSs)\\<close>"], ["proof (prove)\nusing this:\n  follow bs Ms (smap fst stepSs)\n\ngoal (1 subgoal):\n 1. (shd Ms, shd bs, shd (stl Ms))\n    \\<in> \\<delta> (fst (shd (smap fst stepSs)))\n           (snd (shd (smap fst stepSs))) (fst (shd (stl (smap fst stepSs))))", "by (cases rule: follow.cases) auto"], ["proof (state)\nthis:\n  (shd Ms, shd bs, shd (stl Ms))\n  \\<in> \\<delta> (fst (shd (smap fst stepSs))) (snd (shd (smap fst stepSs)))\n         (fst (shd (stl (smap fst stepSs))))\n\ngoal (2 subgoals):\n 1. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs; infDecr bs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))\n 2. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs; infDecr bs;\n        \\<not> alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks))\n                (stl (smap \\<sigma> (szip Ms (smap snd stepSs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bs Msa stepSsa.\n                            stl (smap \\<sigma>\n                                  (szip Ms (smap snd stepSs))) =\n                            smap \\<sigma>\n                             (szip Msa (smap snd stepSsa)) \\<and>\n                            epath (smap fst stepSsa) \\<and>\n                            follow bs Msa (smap fst stepSsa) \\<and>\n                            alw P stepSsa \\<and> infDecr bs", "have 2: \"descent (?s,?S) ?r (?s',?S')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. descent (fst (shd (smap fst stepSs)), snd (shd stepSs))\n     (snd (shd (smap fst stepSs)))\n     (fst (shd (stl (smap fst stepSs))), snd (shd (stl stepSs)))", "using \\<open>alw P stepSs\\<close>"], ["proof (prove)\nusing this:\n  alw P stepSs\n\ngoal (1 subgoal):\n 1. descent (fst (shd (smap fst stepSs)), snd (shd stepSs))\n     (snd (shd (smap fst stepSs)))\n     (fst (shd (stl (smap fst stepSs))), snd (shd (stl stepSs)))", "unfolding P_def"], ["proof (prove)\nusing this:\n  alw (\\<lambda>stepSs.\n          let ((s, r), S) = shd stepSs; ((s', uu_), S') = shd (stl stepSs)\n          in S \\<in> structure \\<and>\n             \\<not> sat S s \\<and> descent (s, S) r (s', S'))\n   stepSs\n\ngoal (1 subgoal):\n 1. descent (fst (shd (smap fst stepSs)), snd (shd stepSs))\n     (snd (shd (smap fst stepSs)))\n     (fst (shd (stl (smap fst stepSs))), snd (shd (stl stepSs)))", "by (cases rule: alw.cases) auto"], ["proof (state)\nthis:\n  descent (fst (shd (smap fst stepSs)), snd (shd stepSs))\n   (snd (shd (smap fst stepSs)))\n   (fst (shd (stl (smap fst stepSs))), snd (shd (stl stepSs)))\n\ngoal (2 subgoals):\n 1. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs; infDecr bs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))\n 2. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs; infDecr bs;\n        \\<not> alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks))\n                (stl (smap \\<sigma> (szip Ms (smap snd stepSs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bs Msa stepSsa.\n                            stl (smap \\<sigma>\n                                  (szip Ms (smap snd stepSs))) =\n                            smap \\<sigma>\n                             (szip Msa (smap snd stepSsa)) \\<and>\n                            epath (smap fst stepSsa) \\<and>\n                            follow bs Msa (smap fst stepSsa) \\<and>\n                            alw P stepSsa \\<and> infDecr bs", "have \"(\\<sigma>(?M',?S'), \\<sigma>(?M,?S)) \\<in> Ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> (shd (stl Ms), snd (shd (stl stepSs))),\n     \\<sigma> (shd Ms, snd (shd stepSs)))\n    \\<in> Ord", "using descentE[OF 2 1]"], ["proof (prove)\nusing this:\n  (\\<sigma> (shd (stl Ms), snd (shd (stl stepSs))),\n   \\<sigma> (shd Ms, snd (shd stepSs)))\n  \\<in> Ord \\<and>\n  (shd bs \\<longrightarrow>\n   \\<sigma> (shd (stl Ms), snd (shd (stl stepSs))) \\<noteq>\n   \\<sigma> (shd Ms, snd (shd stepSs)))\n\ngoal (1 subgoal):\n 1. (\\<sigma> (shd (stl Ms), snd (shd (stl stepSs))),\n     \\<sigma> (shd Ms, snd (shd stepSs)))\n    \\<in> Ord", "by simp"], ["proof (state)\nthis:\n  (\\<sigma> (shd (stl Ms), snd (shd (stl stepSs))),\n   \\<sigma> (shd Ms, snd (shd stepSs)))\n  \\<in> Ord\n\ngoal (2 subgoals):\n 1. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs; infDecr bs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))\n 2. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs; infDecr bs;\n        \\<not> alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks))\n                (stl (smap \\<sigma> (szip Ms (smap snd stepSs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bs Msa stepSsa.\n                            stl (smap \\<sigma>\n                                  (szip Ms (smap snd stepSs))) =\n                            smap \\<sigma>\n                             (szip Msa (smap snd stepSsa)) \\<and>\n                            epath (smap fst stepSsa) \\<and>\n                            follow bs Msa (smap fst stepSsa) \\<and>\n                            alw P stepSsa \\<and> infDecr bs", "have \"ev shd bs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ev shd bs", "using \\<open>infDecr bs\\<close>"], ["proof (prove)\nusing this:\n  infDecr bs\n\ngoal (1 subgoal):\n 1. ev shd bs", "unfolding infDecr_def"], ["proof (prove)\nusing this:\n  alw (ev shd) bs\n\ngoal (1 subgoal):\n 1. ev shd bs", "by auto"], ["proof (state)\nthis:\n  ev shd bs\n\ngoal (2 subgoals):\n 1. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs; infDecr bs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))\n 2. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs; infDecr bs;\n        \\<not> alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks))\n                (stl (smap \\<sigma> (szip Ms (smap snd stepSs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bs Msa stepSsa.\n                            stl (smap \\<sigma>\n                                  (szip Ms (smap snd stepSs))) =\n                            smap \\<sigma>\n                             (szip Msa (smap snd stepSsa)) \\<and>\n                            epath (smap fst stepSsa) \\<and>\n                            follow bs Msa (smap fst stepSsa) \\<and>\n                            alw P stepSsa \\<and> infDecr bs", "thus ?case"], ["proof (prove)\nusing this:\n  ev shd bs\n\ngoal (1 subgoal):\n 1. ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n     (smap \\<sigma> (szip Ms (smap snd stepSs)))", "using \\<open>epath ?steps\\<close> \\<open>follow bs Ms ?steps\\<close> \\<open>alw P stepSs\\<close>"], ["proof (prove)\nusing this:\n  ev shd bs\n  epath (smap fst stepSs)\n  follow bs Ms (smap fst stepSs)\n  alw P stepSs\n\ngoal (1 subgoal):\n 1. ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n     (smap \\<sigma> (szip Ms (smap snd stepSs)))", "proof (induction arbitrary: Ms stepSs)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs Ms stepSs.\n       \\<lbrakk>shd xs; epath (smap fst stepSs);\n        follow xs Ms (smap fst stepSs); alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))\n 2. \\<And>xs Ms stepSs.\n       \\<lbrakk>ev shd (stl xs);\n        \\<And>Ms stepSs.\n           \\<lbrakk>epath (smap fst stepSs);\n            follow (stl xs) Ms (smap fst stepSs); alw P stepSs\\<rbrakk>\n           \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                              (smap \\<sigma> (szip Ms (smap snd stepSs)));\n        epath (smap fst stepSs); follow xs Ms (smap fst stepSs);\n        alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))", "case (base bs Ms stepSs)"], ["proof (state)\nthis:\n  shd bs\n  epath (smap fst stepSs)\n  follow bs Ms (smap fst stepSs)\n  alw P stepSs\n\ngoal (2 subgoals):\n 1. \\<And>xs Ms stepSs.\n       \\<lbrakk>shd xs; epath (smap fst stepSs);\n        follow xs Ms (smap fst stepSs); alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))\n 2. \\<And>xs Ms stepSs.\n       \\<lbrakk>ev shd (stl xs);\n        \\<And>Ms stepSs.\n           \\<lbrakk>epath (smap fst stepSs);\n            follow (stl xs) Ms (smap fst stepSs); alw P stepSs\\<rbrakk>\n           \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                              (smap \\<sigma> (szip Ms (smap snd stepSs)));\n        epath (smap fst stepSs); follow xs Ms (smap fst stepSs);\n        alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))", "let ?steps = \"smap fst stepSs\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs Ms stepSs.\n       \\<lbrakk>shd xs; epath (smap fst stepSs);\n        follow xs Ms (smap fst stepSs); alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))\n 2. \\<And>xs Ms stepSs.\n       \\<lbrakk>ev shd (stl xs);\n        \\<And>Ms stepSs.\n           \\<lbrakk>epath (smap fst stepSs);\n            follow (stl xs) Ms (smap fst stepSs); alw P stepSs\\<rbrakk>\n           \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                              (smap \\<sigma> (szip Ms (smap snd stepSs)));\n        epath (smap fst stepSs); follow xs Ms (smap fst stepSs);\n        alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))", "let ?Ss = \"smap snd stepSs\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs Ms stepSs.\n       \\<lbrakk>shd xs; epath (smap fst stepSs);\n        follow xs Ms (smap fst stepSs); alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))\n 2. \\<And>xs Ms stepSs.\n       \\<lbrakk>ev shd (stl xs);\n        \\<And>Ms stepSs.\n           \\<lbrakk>epath (smap fst stepSs);\n            follow (stl xs) Ms (smap fst stepSs); alw P stepSs\\<rbrakk>\n           \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                              (smap \\<sigma> (szip Ms (smap snd stepSs)));\n        epath (smap fst stepSs); follow xs Ms (smap fst stepSs);\n        alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))", "let ?MSs = \"szip Ms (smap snd stepSs)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs Ms stepSs.\n       \\<lbrakk>shd xs; epath (smap fst stepSs);\n        follow xs Ms (smap fst stepSs); alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))\n 2. \\<And>xs Ms stepSs.\n       \\<lbrakk>ev shd (stl xs);\n        \\<And>Ms stepSs.\n           \\<lbrakk>epath (smap fst stepSs);\n            follow (stl xs) Ms (smap fst stepSs); alw P stepSs\\<rbrakk>\n           \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                              (smap \\<sigma> (szip Ms (smap snd stepSs)));\n        epath (smap fst stepSs); follow xs Ms (smap fst stepSs);\n        alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))", "let ?s = \"fst (shd ?steps)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs Ms stepSs.\n       \\<lbrakk>shd xs; epath (smap fst stepSs);\n        follow xs Ms (smap fst stepSs); alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))\n 2. \\<And>xs Ms stepSs.\n       \\<lbrakk>ev shd (stl xs);\n        \\<And>Ms stepSs.\n           \\<lbrakk>epath (smap fst stepSs);\n            follow (stl xs) Ms (smap fst stepSs); alw P stepSs\\<rbrakk>\n           \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                              (smap \\<sigma> (szip Ms (smap snd stepSs)));\n        epath (smap fst stepSs); follow xs Ms (smap fst stepSs);\n        alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))", "let ?s' = \"fst (shd (stl ?steps))\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs Ms stepSs.\n       \\<lbrakk>shd xs; epath (smap fst stepSs);\n        follow xs Ms (smap fst stepSs); alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))\n 2. \\<And>xs Ms stepSs.\n       \\<lbrakk>ev shd (stl xs);\n        \\<And>Ms stepSs.\n           \\<lbrakk>epath (smap fst stepSs);\n            follow (stl xs) Ms (smap fst stepSs); alw P stepSs\\<rbrakk>\n           \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                              (smap \\<sigma> (szip Ms (smap snd stepSs)));\n        epath (smap fst stepSs); follow xs Ms (smap fst stepSs);\n        alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))", "let ?r = \"snd (shd ?steps)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs Ms stepSs.\n       \\<lbrakk>shd xs; epath (smap fst stepSs);\n        follow xs Ms (smap fst stepSs); alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))\n 2. \\<And>xs Ms stepSs.\n       \\<lbrakk>ev shd (stl xs);\n        \\<And>Ms stepSs.\n           \\<lbrakk>epath (smap fst stepSs);\n            follow (stl xs) Ms (smap fst stepSs); alw P stepSs\\<rbrakk>\n           \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                              (smap \\<sigma> (szip Ms (smap snd stepSs)));\n        epath (smap fst stepSs); follow xs Ms (smap fst stepSs);\n        alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))", "let ?S = \"snd (shd stepSs)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs Ms stepSs.\n       \\<lbrakk>shd xs; epath (smap fst stepSs);\n        follow xs Ms (smap fst stepSs); alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))\n 2. \\<And>xs Ms stepSs.\n       \\<lbrakk>ev shd (stl xs);\n        \\<And>Ms stepSs.\n           \\<lbrakk>epath (smap fst stepSs);\n            follow (stl xs) Ms (smap fst stepSs); alw P stepSs\\<rbrakk>\n           \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                              (smap \\<sigma> (szip Ms (smap snd stepSs)));\n        epath (smap fst stepSs); follow xs Ms (smap fst stepSs);\n        alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))", "let ?S' = \"snd (shd (stl stepSs))\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs Ms stepSs.\n       \\<lbrakk>shd xs; epath (smap fst stepSs);\n        follow xs Ms (smap fst stepSs); alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))\n 2. \\<And>xs Ms stepSs.\n       \\<lbrakk>ev shd (stl xs);\n        \\<And>Ms stepSs.\n           \\<lbrakk>epath (smap fst stepSs);\n            follow (stl xs) Ms (smap fst stepSs); alw P stepSs\\<rbrakk>\n           \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                              (smap \\<sigma> (szip Ms (smap snd stepSs)));\n        epath (smap fst stepSs); follow xs Ms (smap fst stepSs);\n        alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))", "let ?M = \"shd Ms\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs Ms stepSs.\n       \\<lbrakk>shd xs; epath (smap fst stepSs);\n        follow xs Ms (smap fst stepSs); alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))\n 2. \\<And>xs Ms stepSs.\n       \\<lbrakk>ev shd (stl xs);\n        \\<And>Ms stepSs.\n           \\<lbrakk>epath (smap fst stepSs);\n            follow (stl xs) Ms (smap fst stepSs); alw P stepSs\\<rbrakk>\n           \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                              (smap \\<sigma> (szip Ms (smap snd stepSs)));\n        epath (smap fst stepSs); follow xs Ms (smap fst stepSs);\n        alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))", "let ?M' = \"shd (stl Ms)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs Ms stepSs.\n       \\<lbrakk>shd xs; epath (smap fst stepSs);\n        follow xs Ms (smap fst stepSs); alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))\n 2. \\<And>xs Ms stepSs.\n       \\<lbrakk>ev shd (stl xs);\n        \\<And>Ms stepSs.\n           \\<lbrakk>epath (smap fst stepSs);\n            follow (stl xs) Ms (smap fst stepSs); alw P stepSs\\<rbrakk>\n           \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                              (smap \\<sigma> (szip Ms (smap snd stepSs)));\n        epath (smap fst stepSs); follow xs Ms (smap fst stepSs);\n        alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))", "let ?b = \"shd bs\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs Ms stepSs.\n       \\<lbrakk>shd xs; epath (smap fst stepSs);\n        follow xs Ms (smap fst stepSs); alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))\n 2. \\<And>xs Ms stepSs.\n       \\<lbrakk>ev shd (stl xs);\n        \\<And>Ms stepSs.\n           \\<lbrakk>epath (smap fst stepSs);\n            follow (stl xs) Ms (smap fst stepSs); alw P stepSs\\<rbrakk>\n           \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                              (smap \\<sigma> (szip Ms (smap snd stepSs)));\n        epath (smap fst stepSs); follow xs Ms (smap fst stepSs);\n        alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))", "have 1: \"(?M, ?b, ?M') \\<in> \\<delta> ?s ?r ?s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (shd Ms, shd bs, shd (stl Ms))\n    \\<in> \\<delta> (fst (shd (smap fst stepSs)))\n           (snd (shd (smap fst stepSs))) (fst (shd (stl (smap fst stepSs))))", "using \\<open>follow bs Ms (smap fst stepSs)\\<close>"], ["proof (prove)\nusing this:\n  follow bs Ms (smap fst stepSs)\n\ngoal (1 subgoal):\n 1. (shd Ms, shd bs, shd (stl Ms))\n    \\<in> \\<delta> (fst (shd (smap fst stepSs)))\n           (snd (shd (smap fst stepSs))) (fst (shd (stl (smap fst stepSs))))", "by (cases rule: follow.cases) auto"], ["proof (state)\nthis:\n  (shd Ms, shd bs, shd (stl Ms))\n  \\<in> \\<delta> (fst (shd (smap fst stepSs))) (snd (shd (smap fst stepSs)))\n         (fst (shd (stl (smap fst stepSs))))\n\ngoal (2 subgoals):\n 1. \\<And>xs Ms stepSs.\n       \\<lbrakk>shd xs; epath (smap fst stepSs);\n        follow xs Ms (smap fst stepSs); alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))\n 2. \\<And>xs Ms stepSs.\n       \\<lbrakk>ev shd (stl xs);\n        \\<And>Ms stepSs.\n           \\<lbrakk>epath (smap fst stepSs);\n            follow (stl xs) Ms (smap fst stepSs); alw P stepSs\\<rbrakk>\n           \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                              (smap \\<sigma> (szip Ms (smap snd stepSs)));\n        epath (smap fst stepSs); follow xs Ms (smap fst stepSs);\n        alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))", "have 2: \"descent (?s,?S) ?r (?s',?S')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. descent (fst (shd (smap fst stepSs)), snd (shd stepSs))\n     (snd (shd (smap fst stepSs)))\n     (fst (shd (stl (smap fst stepSs))), snd (shd (stl stepSs)))", "using \\<open>alw P stepSs\\<close>"], ["proof (prove)\nusing this:\n  alw P stepSs\n\ngoal (1 subgoal):\n 1. descent (fst (shd (smap fst stepSs)), snd (shd stepSs))\n     (snd (shd (smap fst stepSs)))\n     (fst (shd (stl (smap fst stepSs))), snd (shd (stl stepSs)))", "unfolding P_def"], ["proof (prove)\nusing this:\n  alw (\\<lambda>stepSs.\n          let ((s, r), S) = shd stepSs; ((s', uu_), S') = shd (stl stepSs)\n          in S \\<in> structure \\<and>\n             \\<not> sat S s \\<and> descent (s, S) r (s', S'))\n   stepSs\n\ngoal (1 subgoal):\n 1. descent (fst (shd (smap fst stepSs)), snd (shd stepSs))\n     (snd (shd (smap fst stepSs)))\n     (fst (shd (stl (smap fst stepSs))), snd (shd (stl stepSs)))", "by (cases rule: alw.cases) auto"], ["proof (state)\nthis:\n  descent (fst (shd (smap fst stepSs)), snd (shd stepSs))\n   (snd (shd (smap fst stepSs)))\n   (fst (shd (stl (smap fst stepSs))), snd (shd (stl stepSs)))\n\ngoal (2 subgoals):\n 1. \\<And>xs Ms stepSs.\n       \\<lbrakk>shd xs; epath (smap fst stepSs);\n        follow xs Ms (smap fst stepSs); alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))\n 2. \\<And>xs Ms stepSs.\n       \\<lbrakk>ev shd (stl xs);\n        \\<And>Ms stepSs.\n           \\<lbrakk>epath (smap fst stepSs);\n            follow (stl xs) Ms (smap fst stepSs); alw P stepSs\\<rbrakk>\n           \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                              (smap \\<sigma> (szip Ms (smap snd stepSs)));\n        epath (smap fst stepSs); follow xs Ms (smap fst stepSs);\n        alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))", "have \"\\<sigma>(?M',?S') \\<noteq> \\<sigma>(?M,?S)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> (shd (stl Ms), snd (shd (stl stepSs))) \\<noteq>\n    \\<sigma> (shd Ms, snd (shd stepSs))", "using descentE[OF 2 1] \\<open>shd bs\\<close>"], ["proof (prove)\nusing this:\n  (\\<sigma> (shd (stl Ms), snd (shd (stl stepSs))),\n   \\<sigma> (shd Ms, snd (shd stepSs)))\n  \\<in> Ord \\<and>\n  (shd bs \\<longrightarrow>\n   \\<sigma> (shd (stl Ms), snd (shd (stl stepSs))) \\<noteq>\n   \\<sigma> (shd Ms, snd (shd stepSs)))\n  shd bs\n\ngoal (1 subgoal):\n 1. \\<sigma> (shd (stl Ms), snd (shd (stl stepSs))) \\<noteq>\n    \\<sigma> (shd Ms, snd (shd stepSs))", "by simp"], ["proof (state)\nthis:\n  \\<sigma> (shd (stl Ms), snd (shd (stl stepSs))) \\<noteq>\n  \\<sigma> (shd Ms, snd (shd stepSs))\n\ngoal (2 subgoals):\n 1. \\<And>xs Ms stepSs.\n       \\<lbrakk>shd xs; epath (smap fst stepSs);\n        follow xs Ms (smap fst stepSs); alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))\n 2. \\<And>xs Ms stepSs.\n       \\<lbrakk>ev shd (stl xs);\n        \\<And>Ms stepSs.\n           \\<lbrakk>epath (smap fst stepSs);\n            follow (stl xs) Ms (smap fst stepSs); alw P stepSs\\<rbrakk>\n           \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                              (smap \\<sigma> (szip Ms (smap snd stepSs)));\n        epath (smap fst stepSs); follow xs Ms (smap fst stepSs);\n        alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))", "thus ?case"], ["proof (prove)\nusing this:\n  \\<sigma> (shd (stl Ms), snd (shd (stl stepSs))) \\<noteq>\n  \\<sigma> (shd Ms, snd (shd stepSs))\n\ngoal (1 subgoal):\n 1. ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n     (smap \\<sigma> (szip Ms (smap snd stepSs)))", "by auto"], ["proof (state)\nthis:\n  ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n   (smap \\<sigma> (szip Ms (smap snd stepSs)))\n\ngoal (1 subgoal):\n 1. \\<And>xs Ms stepSs.\n       \\<lbrakk>ev shd (stl xs);\n        \\<And>Ms stepSs.\n           \\<lbrakk>epath (smap fst stepSs);\n            follow (stl xs) Ms (smap fst stepSs); alw P stepSs\\<rbrakk>\n           \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                              (smap \\<sigma> (szip Ms (smap snd stepSs)));\n        epath (smap fst stepSs); follow xs Ms (smap fst stepSs);\n        alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs Ms stepSs.\n       \\<lbrakk>ev shd (stl xs);\n        \\<And>Ms stepSs.\n           \\<lbrakk>epath (smap fst stepSs);\n            follow (stl xs) Ms (smap fst stepSs); alw P stepSs\\<rbrakk>\n           \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                              (smap \\<sigma> (szip Ms (smap snd stepSs)));\n        epath (smap fst stepSs); follow xs Ms (smap fst stepSs);\n        alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))", "case (step bs Ms stepSs)"], ["proof (state)\nthis:\n  ev shd (stl bs)\n  \\<lbrakk>epath (smap fst ?stepSs2);\n   follow (stl bs) ?Ms2 (smap fst ?stepSs2); alw P ?stepSs2\\<rbrakk>\n  \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                     (smap \\<sigma> (szip ?Ms2 (smap snd ?stepSs2)))\n  epath (smap fst stepSs)\n  follow bs Ms (smap fst stepSs)\n  alw P stepSs\n\ngoal (1 subgoal):\n 1. \\<And>xs Ms stepSs.\n       \\<lbrakk>ev shd (stl xs);\n        \\<And>Ms stepSs.\n           \\<lbrakk>epath (smap fst stepSs);\n            follow (stl xs) Ms (smap fst stepSs); alw P stepSs\\<rbrakk>\n           \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                              (smap \\<sigma> (szip Ms (smap snd stepSs)));\n        epath (smap fst stepSs); follow xs Ms (smap fst stepSs);\n        alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))", "have \"ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                  (smap \\<sigma>\n                  (szip (stl Ms) (smap snd (stl stepSs))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n     (smap \\<sigma> (szip (stl Ms) (smap snd (stl stepSs))))", "using step(3-5) step(2)[of \"stl stepSs\" \"stl Ms\"]"], ["proof (prove)\nusing this:\n  epath (smap fst stepSs)\n  follow bs Ms (smap fst stepSs)\n  alw P stepSs\n  \\<lbrakk>epath (smap fst (stl stepSs));\n   follow (stl bs) (stl Ms) (smap fst (stl stepSs));\n   alw P (stl stepSs)\\<rbrakk>\n  \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                     (smap \\<sigma> (szip (stl Ms) (smap snd (stl stepSs))))\n\ngoal (1 subgoal):\n 1. ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n     (smap \\<sigma> (szip (stl Ms) (smap snd (stl stepSs))))", "by auto"], ["proof (state)\nthis:\n  ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n   (smap \\<sigma> (szip (stl Ms) (smap snd (stl stepSs))))\n\ngoal (1 subgoal):\n 1. \\<And>xs Ms stepSs.\n       \\<lbrakk>ev shd (stl xs);\n        \\<And>Ms stepSs.\n           \\<lbrakk>epath (smap fst stepSs);\n            follow (stl xs) Ms (smap fst stepSs); alw P stepSs\\<rbrakk>\n           \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                              (smap \\<sigma> (szip Ms (smap snd stepSs)));\n        epath (smap fst stepSs); follow xs Ms (smap fst stepSs);\n        alw P stepSs\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n                          (smap \\<sigma> (szip Ms (smap snd stepSs)))", "thus ?case"], ["proof (prove)\nusing this:\n  ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n   (smap \\<sigma> (szip (stl Ms) (smap snd (stl stepSs))))\n\ngoal (1 subgoal):\n 1. ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n     (smap \\<sigma> (szip Ms (smap snd stepSs)))", "by auto"], ["proof (state)\nthis:\n  ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n   (smap \\<sigma> (szip Ms (smap snd stepSs)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)\n   (smap \\<sigma> (szip Ms (smap snd stepSs)))\n\ngoal (1 subgoal):\n 1. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs; infDecr bs;\n        \\<not> alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks))\n                (stl (smap \\<sigma> (szip Ms (smap snd stepSs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bs Msa stepSsa.\n                            stl (smap \\<sigma>\n                                  (szip Ms (smap snd stepSs))) =\n                            smap \\<sigma>\n                             (szip Msa (smap snd stepSsa)) \\<and>\n                            epath (smap fst stepSsa) \\<and>\n                            follow bs Msa (smap fst stepSsa) \\<and>\n                            alw P stepSsa \\<and> infDecr bs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs; infDecr bs;\n        \\<not> alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks))\n                (stl (smap \\<sigma> (szip Ms (smap snd stepSs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bs Msa stepSsa.\n                            stl (smap \\<sigma>\n                                  (szip Ms (smap snd stepSs))) =\n                            smap \\<sigma>\n                             (szip Msa (smap snd stepSsa)) \\<and>\n                            epath (smap fst stepSsa) \\<and>\n                            follow bs Msa (smap fst stepSsa) \\<and>\n                            alw P stepSsa \\<and> infDecr bs", "case (stl bs Ms stepSs)"], ["proof (state)\nthis:\n  epath (smap fst stepSs)\n  follow bs Ms (smap fst stepSs)\n  alw P stepSs\n  infDecr bs\n  \\<not> alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks))\n          (stl (smap \\<sigma> (szip Ms (smap snd stepSs))))\n\ngoal (1 subgoal):\n 1. \\<And>bs Ms stepSs.\n       \\<lbrakk>epath (smap fst stepSs); follow bs Ms (smap fst stepSs);\n        alw P stepSs; infDecr bs;\n        \\<not> alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks))\n                (stl (smap \\<sigma> (szip Ms (smap snd stepSs))))\\<rbrakk>\n       \\<Longrightarrow> \\<exists>bs Msa stepSsa.\n                            stl (smap \\<sigma>\n                                  (szip Ms (smap snd stepSs))) =\n                            smap \\<sigma>\n                             (szip Msa (smap snd stepSsa)) \\<and>\n                            epath (smap fst stepSsa) \\<and>\n                            follow bs Msa (smap fst stepSsa) \\<and>\n                            alw P stepSsa \\<and> infDecr bs", "thus ?case"], ["proof (prove)\nusing this:\n  epath (smap fst stepSs)\n  follow bs Ms (smap fst stepSs)\n  alw P stepSs\n  infDecr bs\n  \\<not> alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks))\n          (stl (smap \\<sigma> (szip Ms (smap snd stepSs))))\n\ngoal (1 subgoal):\n 1. \\<exists>bs Ms stepSs.\n       stl (smap \\<sigma> (szip Ms (smap snd stepSs))) =\n       smap \\<sigma> (szip Ms (smap snd stepSs)) \\<and>\n       epath (smap fst stepSs) \\<and>\n       follow bs Ms (smap fst stepSs) \\<and> alw P stepSs \\<and> infDecr bs", "by (intro exI[of _ \"stl bs\"] exI[of _ \"stl Ms\"] exI[of _ \"stl stepSs\"])\n          (auto elim: epath.cases)"], ["proof (state)\nthis:\n  \\<exists>bs Ms stepSs.\n     stl (smap \\<sigma> (szip Ms (smap snd stepSs))) =\n     smap \\<sigma> (szip Ms (smap snd stepSs)) \\<and>\n     epath (smap fst stepSs) \\<and>\n     follow bs Ms (smap fst stepSs) \\<and> alw P stepSs \\<and> infDecr bs\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks))\n   (smap \\<sigma> (szip Ms (smap snd stepSs)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "definition\n  \"ks \\<equiv> SOME ks.\n        alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord) ks \\<and>\n        alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)) ks\""], ["", "lemma alw_ks: \"alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord) ks\"\n  and alw_ev_ks: \"alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)) ks\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord) ks &&&\n    alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)) ks", "unfolding ks_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord)\n     (SOME ks.\n         alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord) ks \\<and>\n         alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)) ks) &&&\n    alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks))\n     (SOME ks.\n         alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord) ks \\<and>\n         alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)) ks)", "using alw_ev_Ord someI_ex[of \"\\<lambda>ks.\n        alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord) ks \\<and>\n        alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)) ks\"]"], ["proof (prove)\nusing this:\n  (\\<And>ks.\n      \\<lbrakk>alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord) ks;\n       alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)) ks\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n  \\<exists>x.\n     alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord) x \\<and>\n     alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks))\n      x \\<Longrightarrow>\n  alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord)\n   (SOME x.\n       alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord) x \\<and>\n       alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)) x) \\<and>\n  alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks))\n   (SOME x.\n       alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord) x \\<and>\n       alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)) x)\n\ngoal (1 subgoal):\n 1. alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord)\n     (SOME ks.\n         alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord) ks \\<and>\n         alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)) ks) &&&\n    alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks))\n     (SOME ks.\n         alw (\\<lambda>ks. (shd (stl ks), shd ks) \\<in> Ord) ks \\<and>\n         alw (ev (\\<lambda>ks. shd (stl ks) \\<noteq> shd ks)) ks)", "by auto"], ["", "abbreviation decr where \"decr \\<equiv> decr0 Ord\""], ["", "lemmas decr_simps = decr0.code[of Ord]"], ["", "context\n  fixes js\n  assumes a: \"alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) js\"\n    and ae: \"alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) js\"\nbegin"], ["", "lemma decr_ev:\n  assumes m: \"(shd js, m) \\<in> Ord\"\n  shows \"ev (\\<lambda>js. (shd js, m) \\<in> Ord \\<and> shd js \\<noteq> m) js\"\n    (is \"ev (\\<lambda>js. ?\\<phi> m js) js\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. ev (\\<lambda>js. (shd js, m) \\<in> Ord \\<and> shd js \\<noteq> m) js", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. ev (\\<lambda>js. (shd js, m) \\<in> Ord \\<and> shd js \\<noteq> m) js", "have \"ev (\\<lambda>js. shd (stl js) \\<noteq> shd js) js\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ev (\\<lambda>js. shd (stl js) \\<noteq> shd js) js", "using ae"], ["proof (prove)\nusing this:\n  alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) js\n\ngoal (1 subgoal):\n 1. ev (\\<lambda>js. shd (stl js) \\<noteq> shd js) js", "by auto"], ["proof (state)\nthis:\n  ev (\\<lambda>js. shd (stl js) \\<noteq> shd js) js\n\ngoal (1 subgoal):\n 1. ev (\\<lambda>js. (shd js, m) \\<in> Ord \\<and> shd js \\<noteq> m) js", "thus ?thesis"], ["proof (prove)\nusing this:\n  ev (\\<lambda>js. shd (stl js) \\<noteq> shd js) js\n\ngoal (1 subgoal):\n 1. ev (\\<lambda>js. (shd js, m) \\<in> Ord \\<and> shd js \\<noteq> m) js", "using a m"], ["proof (prove)\nusing this:\n  ev (\\<lambda>js. shd (stl js) \\<noteq> shd js) js\n  alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) js\n  (shd js, m) \\<in> Ord\n\ngoal (1 subgoal):\n 1. ev (\\<lambda>js. (shd js, m) \\<in> Ord \\<and> shd js \\<noteq> m) js", "proof induction"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>shd (stl xs) \\<noteq> shd xs;\n        alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) xs;\n        (shd xs, m) \\<in> Ord\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>js.\n                                (shd js, m) \\<in> Ord \\<and>\n                                shd js \\<noteq> m)\n                          xs\n 2. \\<And>xs.\n       \\<lbrakk>ev (\\<lambda>js. shd (stl js) \\<noteq> shd js) (stl xs);\n        \\<lbrakk>alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord)\n                  (stl xs);\n         (shd (stl xs), m) \\<in> Ord\\<rbrakk>\n        \\<Longrightarrow> ev (\\<lambda>js.\n                                 (shd js, m) \\<in> Ord \\<and>\n                                 shd js \\<noteq> m)\n                           (stl xs);\n        alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) xs;\n        (shd xs, m) \\<in> Ord\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>js.\n                                (shd js, m) \\<in> Ord \\<and>\n                                shd js \\<noteq> m)\n                          xs", "case (base ls)"], ["proof (state)\nthis:\n  shd (stl ls) \\<noteq> shd ls\n  alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) ls\n  (shd ls, m) \\<in> Ord\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>shd (stl xs) \\<noteq> shd xs;\n        alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) xs;\n        (shd xs, m) \\<in> Ord\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>js.\n                                (shd js, m) \\<in> Ord \\<and>\n                                shd js \\<noteq> m)\n                          xs\n 2. \\<And>xs.\n       \\<lbrakk>ev (\\<lambda>js. shd (stl js) \\<noteq> shd js) (stl xs);\n        \\<lbrakk>alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord)\n                  (stl xs);\n         (shd (stl xs), m) \\<in> Ord\\<rbrakk>\n        \\<Longrightarrow> ev (\\<lambda>js.\n                                 (shd js, m) \\<in> Ord \\<and>\n                                 shd js \\<noteq> m)\n                           (stl xs);\n        alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) xs;\n        (shd xs, m) \\<in> Ord\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>js.\n                                (shd js, m) \\<in> Ord \\<and>\n                                shd js \\<noteq> m)\n                          xs", "hence \"ev (?\\<phi> (shd ls)) ls\""], ["proof (prove)\nusing this:\n  shd (stl ls) \\<noteq> shd ls\n  alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) ls\n  (shd ls, m) \\<in> Ord\n\ngoal (1 subgoal):\n 1. ev (\\<lambda>a. (shd a, shd ls) \\<in> Ord \\<and> shd a \\<noteq> shd ls)\n     ls", "by auto"], ["proof (state)\nthis:\n  ev (\\<lambda>a. (shd a, shd ls) \\<in> Ord \\<and> shd a \\<noteq> shd ls) ls\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>shd (stl xs) \\<noteq> shd xs;\n        alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) xs;\n        (shd xs, m) \\<in> Ord\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>js.\n                                (shd js, m) \\<in> Ord \\<and>\n                                shd js \\<noteq> m)\n                          xs\n 2. \\<And>xs.\n       \\<lbrakk>ev (\\<lambda>js. shd (stl js) \\<noteq> shd js) (stl xs);\n        \\<lbrakk>alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord)\n                  (stl xs);\n         (shd (stl xs), m) \\<in> Ord\\<rbrakk>\n        \\<Longrightarrow> ev (\\<lambda>js.\n                                 (shd js, m) \\<in> Ord \\<and>\n                                 shd js \\<noteq> m)\n                           (stl xs);\n        alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) xs;\n        (shd xs, m) \\<in> Ord\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>js.\n                                (shd js, m) \\<in> Ord \\<and>\n                                shd js \\<noteq> m)\n                          xs", "moreover"], ["proof (state)\nthis:\n  ev (\\<lambda>a. (shd a, shd ls) \\<in> Ord \\<and> shd a \\<noteq> shd ls) ls\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>shd (stl xs) \\<noteq> shd xs;\n        alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) xs;\n        (shd xs, m) \\<in> Ord\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>js.\n                                (shd js, m) \\<in> Ord \\<and>\n                                shd js \\<noteq> m)\n                          xs\n 2. \\<And>xs.\n       \\<lbrakk>ev (\\<lambda>js. shd (stl js) \\<noteq> shd js) (stl xs);\n        \\<lbrakk>alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord)\n                  (stl xs);\n         (shd (stl xs), m) \\<in> Ord\\<rbrakk>\n        \\<Longrightarrow> ev (\\<lambda>js.\n                                 (shd js, m) \\<in> Ord \\<and>\n                                 shd js \\<noteq> m)\n                           (stl xs);\n        alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) xs;\n        (shd xs, m) \\<in> Ord\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>js.\n                                (shd js, m) \\<in> Ord \\<and>\n                                shd js \\<noteq> m)\n                          xs", "have \"\\<And>js. ?\\<phi> (shd ls) js \\<Longrightarrow> ?\\<phi> m js\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>js.\n       (shd js, shd ls) \\<in> Ord \\<and>\n       shd js \\<noteq> shd ls \\<Longrightarrow>\n       (shd js, m) \\<in> Ord \\<and> shd js \\<noteq> m", "using \\<open>(shd ls, m) \\<in> Ord\\<close> Ord"], ["proof (prove)\nusing this:\n  (shd ls, m) \\<in> Ord\n  well_order Ord\n\ngoal (1 subgoal):\n 1. \\<And>js.\n       (shd js, shd ls) \\<in> Ord \\<and>\n       shd js \\<noteq> shd ls \\<Longrightarrow>\n       (shd js, m) \\<in> Ord \\<and> shd js \\<noteq> m", "unfolding well_order_on_defs"], ["proof (prove)\nusing this:\n  (shd ls, m) \\<in> Ord\n  ((((Ord \\<subseteq> UNIV \\<times> UNIV \\<and>\n      (\\<forall>x\\<in>UNIV. (x, x) \\<in> Ord)) \\<and>\n     (\\<forall>x y z.\n         (x, y) \\<in> Ord \\<longrightarrow>\n         (y, z) \\<in> Ord \\<longrightarrow> (x, z) \\<in> Ord)) \\<and>\n    (\\<forall>x y.\n        (x, y) \\<in> Ord \\<longrightarrow>\n        (y, x) \\<in> Ord \\<longrightarrow> x = y)) \\<and>\n   total Ord) \\<and>\n  Wellfounded.wf (Ord - Id)\n\ngoal (1 subgoal):\n 1. \\<And>js.\n       (shd js, shd ls) \\<in> Ord \\<and>\n       shd js \\<noteq> shd ls \\<Longrightarrow>\n       (shd js, m) \\<in> Ord \\<and> shd js \\<noteq> m", "by blast"], ["proof (state)\nthis:\n  (shd ?js2, shd ls) \\<in> Ord \\<and>\n  shd ?js2 \\<noteq> shd ls \\<Longrightarrow>\n  (shd ?js2, m) \\<in> Ord \\<and> shd ?js2 \\<noteq> m\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>shd (stl xs) \\<noteq> shd xs;\n        alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) xs;\n        (shd xs, m) \\<in> Ord\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>js.\n                                (shd js, m) \\<in> Ord \\<and>\n                                shd js \\<noteq> m)\n                          xs\n 2. \\<And>xs.\n       \\<lbrakk>ev (\\<lambda>js. shd (stl js) \\<noteq> shd js) (stl xs);\n        \\<lbrakk>alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord)\n                  (stl xs);\n         (shd (stl xs), m) \\<in> Ord\\<rbrakk>\n        \\<Longrightarrow> ev (\\<lambda>js.\n                                 (shd js, m) \\<in> Ord \\<and>\n                                 shd js \\<noteq> m)\n                           (stl xs);\n        alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) xs;\n        (shd xs, m) \\<in> Ord\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>js.\n                                (shd js, m) \\<in> Ord \\<and>\n                                shd js \\<noteq> m)\n                          xs", "ultimately"], ["proof (chain)\npicking this:\n  ev (\\<lambda>a. (shd a, shd ls) \\<in> Ord \\<and> shd a \\<noteq> shd ls) ls\n  (shd ?js2, shd ls) \\<in> Ord \\<and>\n  shd ?js2 \\<noteq> shd ls \\<Longrightarrow>\n  (shd ?js2, m) \\<in> Ord \\<and> shd ?js2 \\<noteq> m", "show ?case"], ["proof (prove)\nusing this:\n  ev (\\<lambda>a. (shd a, shd ls) \\<in> Ord \\<and> shd a \\<noteq> shd ls) ls\n  (shd ?js2, shd ls) \\<in> Ord \\<and>\n  shd ?js2 \\<noteq> shd ls \\<Longrightarrow>\n  (shd ?js2, m) \\<in> Ord \\<and> shd ?js2 \\<noteq> m\n\ngoal (1 subgoal):\n 1. ev (\\<lambda>js. (shd js, m) \\<in> Ord \\<and> shd js \\<noteq> m) ls", "using ev_mono[of \"?\\<phi> (shd ls)\" _ \"?\\<phi> m\"]"], ["proof (prove)\nusing this:\n  ev (\\<lambda>a. (shd a, shd ls) \\<in> Ord \\<and> shd a \\<noteq> shd ls) ls\n  (shd ?js2, shd ls) \\<in> Ord \\<and>\n  shd ?js2 \\<noteq> shd ls \\<Longrightarrow>\n  (shd ?js2, m) \\<in> Ord \\<and> shd ?js2 \\<noteq> m\n  \\<lbrakk>ev (\\<lambda>a.\n                  (shd a, shd ls) \\<in> Ord \\<and> shd a \\<noteq> shd ls)\n            ?xs;\n   \\<And>xs.\n      (shd xs, shd ls) \\<in> Ord \\<and>\n      shd xs \\<noteq> shd ls \\<Longrightarrow>\n      (shd xs, m) \\<in> Ord \\<and> shd xs \\<noteq> m\\<rbrakk>\n  \\<Longrightarrow> ev (\\<lambda>a.\n                           (shd a, m) \\<in> Ord \\<and> shd a \\<noteq> m)\n                     ?xs\n\ngoal (1 subgoal):\n 1. ev (\\<lambda>js. (shd js, m) \\<in> Ord \\<and> shd js \\<noteq> m) ls", "by auto"], ["proof (state)\nthis:\n  ev (\\<lambda>js. (shd js, m) \\<in> Ord \\<and> shd js \\<noteq> m) ls\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>ev (\\<lambda>js. shd (stl js) \\<noteq> shd js) (stl xs);\n        \\<lbrakk>alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord)\n                  (stl xs);\n         (shd (stl xs), m) \\<in> Ord\\<rbrakk>\n        \\<Longrightarrow> ev (\\<lambda>js.\n                                 (shd js, m) \\<in> Ord \\<and>\n                                 shd js \\<noteq> m)\n                           (stl xs);\n        alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) xs;\n        (shd xs, m) \\<in> Ord\\<rbrakk>\n       \\<Longrightarrow> ev (\\<lambda>js.\n                                (shd js, m) \\<in> Ord \\<and>\n                                shd js \\<noteq> m)\n                          xs", "qed auto"], ["proof (state)\nthis:\n  ev (\\<lambda>js. (shd js, m) \\<in> Ord \\<and> shd js \\<noteq> m) js\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma decr_simps_diff[simp]:\n  assumes m: \"(shd js, m) \\<in> Ord\"\n    and \"shd js \\<noteq> m\"\n  shows \"decr m js = shd js ## decr (shd js) js\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decr m js = shd js ## decr (shd js) js", "using decr_ev[OF m] assms"], ["proof (prove)\nusing this:\n  ev (\\<lambda>js. (shd js, m) \\<in> Ord \\<and> shd js \\<noteq> m) js\n  (shd js, m) \\<in> Ord\n  shd js \\<noteq> m\n\ngoal (1 subgoal):\n 1. decr m js = shd js ## decr (shd js) js", "by (subst decr_simps) simp"], ["", "lemma decr_simps_eq[simp]:\n  \"decr (shd js) js = decr (shd js) (stl js)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. decr (shd js) js = decr (shd js) (stl js)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. decr (shd js) js = decr (shd js) (stl js)", "have m: \"(shd js, shd js) \\<in> Ord\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (shd js, shd js) \\<in> Ord", "using Ord"], ["proof (prove)\nusing this:\n  well_order Ord\n\ngoal (1 subgoal):\n 1. (shd js, shd js) \\<in> Ord", "unfolding well_order_on_def linear_order_on_def partial_order_on_def\n      preorder_on_def refl_on_def"], ["proof (prove)\nusing this:\n  ((((Ord \\<subseteq> UNIV \\<times> UNIV \\<and>\n      (\\<forall>x\\<in>UNIV. (x, x) \\<in> Ord)) \\<and>\n     trans Ord) \\<and>\n    antisym Ord) \\<and>\n   total Ord) \\<and>\n  Wellfounded.wf (Ord - Id)\n\ngoal (1 subgoal):\n 1. (shd js, shd js) \\<in> Ord", "by auto"], ["proof (state)\nthis:\n  (shd js, shd js) \\<in> Ord\n\ngoal (1 subgoal):\n 1. decr (shd js) js = decr (shd js) (stl js)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. decr (shd js) js = decr (shd js) (stl js)", "using decr_ev[OF m]"], ["proof (prove)\nusing this:\n  ev (\\<lambda>jsa.\n         (shd jsa, shd js) \\<in> Ord \\<and> shd jsa \\<noteq> shd js)\n   js\n\ngoal (1 subgoal):\n 1. decr (shd js) js = decr (shd js) (stl js)", "by (subst decr_simps) simp"], ["proof (state)\nthis:\n  decr (shd js) js = decr (shd js) (stl js)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context *)"], ["", "lemma stl_decr:\n  assumes a: \"alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) js\"\n    and ae: \"alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) js\"\n    and m: \"(shd js, m) \\<in> Ord\"\n  shows\n    \"\\<exists>js1 js2. js = js1 @- js2 \\<and> set js1 \\<subseteq> {m} \\<and>\n (shd js2, m) \\<in> Ord \\<and> shd js2 \\<noteq> m \\<and>\n  shd (decr m js) = shd js2 \\<and> stl (decr m js) = decr (shd js2) js2\"\n    (is \"\\<exists>js1 js2. ?\\<phi> js js1 js2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>js1 js2.\n       js = js1 @- js2 \\<and>\n       set js1 \\<subseteq> {m} \\<and>\n       (shd js2, m) \\<in> Ord \\<and>\n       shd js2 \\<noteq> m \\<and>\n       shd (decr m js) = shd js2 \\<and> stl (decr m js) = decr (shd js2) js2", "using decr_ev[OF assms] m a ae"], ["proof (prove)\nusing this:\n  ev (\\<lambda>js. (shd js, m) \\<in> Ord \\<and> shd js \\<noteq> m) js\n  (shd js, m) \\<in> Ord\n  alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) js\n  alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) js\n\ngoal (1 subgoal):\n 1. \\<exists>js1 js2.\n       js = js1 @- js2 \\<and>\n       set js1 \\<subseteq> {m} \\<and>\n       (shd js2, m) \\<in> Ord \\<and>\n       shd js2 \\<noteq> m \\<and>\n       shd (decr m js) = shd js2 \\<and> stl (decr m js) = decr (shd js2) js2", "proof (induction rule: ev_induct_strong)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>(shd xs, m) \\<in> Ord \\<and> shd xs \\<noteq> m;\n        (shd xs, m) \\<in> Ord;\n        alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) xs;\n        alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>js1 js2.\n                            xs = js1 @- js2 \\<and>\n                            set js1 \\<subseteq> {m} \\<and>\n                            (shd js2, m) \\<in> Ord \\<and>\n                            shd js2 \\<noteq> m \\<and>\n                            shd (decr m xs) = shd js2 \\<and>\n                            stl (decr m xs) = decr (shd js2) js2\n 2. \\<And>xs.\n       \\<lbrakk>ev (\\<lambda>js.\n                       (shd js, m) \\<in> Ord \\<and> shd js \\<noteq> m)\n                 (stl xs);\n        \\<not> ((shd xs, m) \\<in> Ord \\<and> shd xs \\<noteq> m);\n        \\<lbrakk>(shd (stl xs), m) \\<in> Ord;\n         alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) (stl xs);\n         alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js))\n          (stl xs)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>js1 js2.\n                             stl xs = js1 @- js2 \\<and>\n                             set js1 \\<subseteq> {m} \\<and>\n                             (shd js2, m) \\<in> Ord \\<and>\n                             shd js2 \\<noteq> m \\<and>\n                             shd (decr m (stl xs)) = shd js2 \\<and>\n                             stl (decr m (stl xs)) = decr (shd js2) js2;\n        (shd xs, m) \\<in> Ord;\n        alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) xs;\n        alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>js1 js2.\n                            xs = js1 @- js2 \\<and>\n                            set js1 \\<subseteq> {m} \\<and>\n                            (shd js2, m) \\<in> Ord \\<and>\n                            shd js2 \\<noteq> m \\<and>\n                            shd (decr m xs) = shd js2 \\<and>\n                            stl (decr m xs) = decr (shd js2) js2", "case (base js)"], ["proof (state)\nthis:\n  (shd js, m) \\<in> Ord \\<and> shd js \\<noteq> m\n  (shd js, m) \\<in> Ord\n  alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) js\n  alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) js\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>(shd xs, m) \\<in> Ord \\<and> shd xs \\<noteq> m;\n        (shd xs, m) \\<in> Ord;\n        alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) xs;\n        alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>js1 js2.\n                            xs = js1 @- js2 \\<and>\n                            set js1 \\<subseteq> {m} \\<and>\n                            (shd js2, m) \\<in> Ord \\<and>\n                            shd js2 \\<noteq> m \\<and>\n                            shd (decr m xs) = shd js2 \\<and>\n                            stl (decr m xs) = decr (shd js2) js2\n 2. \\<And>xs.\n       \\<lbrakk>ev (\\<lambda>js.\n                       (shd js, m) \\<in> Ord \\<and> shd js \\<noteq> m)\n                 (stl xs);\n        \\<not> ((shd xs, m) \\<in> Ord \\<and> shd xs \\<noteq> m);\n        \\<lbrakk>(shd (stl xs), m) \\<in> Ord;\n         alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) (stl xs);\n         alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js))\n          (stl xs)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>js1 js2.\n                             stl xs = js1 @- js2 \\<and>\n                             set js1 \\<subseteq> {m} \\<and>\n                             (shd js2, m) \\<in> Ord \\<and>\n                             shd js2 \\<noteq> m \\<and>\n                             shd (decr m (stl xs)) = shd js2 \\<and>\n                             stl (decr m (stl xs)) = decr (shd js2) js2;\n        (shd xs, m) \\<in> Ord;\n        alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) xs;\n        alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>js1 js2.\n                            xs = js1 @- js2 \\<and>\n                            set js1 \\<subseteq> {m} \\<and>\n                            (shd js2, m) \\<in> Ord \\<and>\n                            shd js2 \\<noteq> m \\<and>\n                            shd (decr m xs) = shd js2 \\<and>\n                            stl (decr m xs) = decr (shd js2) js2", "thus ?case"], ["proof (prove)\nusing this:\n  (shd js, m) \\<in> Ord \\<and> shd js \\<noteq> m\n  (shd js, m) \\<in> Ord\n  alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) js\n  alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) js\n\ngoal (1 subgoal):\n 1. \\<exists>js1 js2.\n       js = js1 @- js2 \\<and>\n       set js1 \\<subseteq> {m} \\<and>\n       (shd js2, m) \\<in> Ord \\<and>\n       shd js2 \\<noteq> m \\<and>\n       shd (decr m js) = shd js2 \\<and> stl (decr m js) = decr (shd js2) js2", "by  (intro exI[of _ \"[]\"] exI[of _ js]) auto"], ["proof (state)\nthis:\n  \\<exists>js1 js2.\n     js = js1 @- js2 \\<and>\n     set js1 \\<subseteq> {m} \\<and>\n     (shd js2, m) \\<in> Ord \\<and>\n     shd js2 \\<noteq> m \\<and>\n     shd (decr m js) = shd js2 \\<and> stl (decr m js) = decr (shd js2) js2\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>ev (\\<lambda>js.\n                       (shd js, m) \\<in> Ord \\<and> shd js \\<noteq> m)\n                 (stl xs);\n        \\<not> ((shd xs, m) \\<in> Ord \\<and> shd xs \\<noteq> m);\n        \\<lbrakk>(shd (stl xs), m) \\<in> Ord;\n         alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) (stl xs);\n         alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js))\n          (stl xs)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>js1 js2.\n                             stl xs = js1 @- js2 \\<and>\n                             set js1 \\<subseteq> {m} \\<and>\n                             (shd js2, m) \\<in> Ord \\<and>\n                             shd js2 \\<noteq> m \\<and>\n                             shd (decr m (stl xs)) = shd js2 \\<and>\n                             stl (decr m (stl xs)) = decr (shd js2) js2;\n        (shd xs, m) \\<in> Ord;\n        alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) xs;\n        alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>js1 js2.\n                            xs = js1 @- js2 \\<and>\n                            set js1 \\<subseteq> {m} \\<and>\n                            (shd js2, m) \\<in> Ord \\<and>\n                            shd js2 \\<noteq> m \\<and>\n                            shd (decr m xs) = shd js2 \\<and>\n                            stl (decr m xs) = decr (shd js2) js2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>ev (\\<lambda>js.\n                       (shd js, m) \\<in> Ord \\<and> shd js \\<noteq> m)\n                 (stl xs);\n        \\<not> ((shd xs, m) \\<in> Ord \\<and> shd xs \\<noteq> m);\n        \\<lbrakk>(shd (stl xs), m) \\<in> Ord;\n         alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) (stl xs);\n         alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js))\n          (stl xs)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>js1 js2.\n                             stl xs = js1 @- js2 \\<and>\n                             set js1 \\<subseteq> {m} \\<and>\n                             (shd js2, m) \\<in> Ord \\<and>\n                             shd js2 \\<noteq> m \\<and>\n                             shd (decr m (stl xs)) = shd js2 \\<and>\n                             stl (decr m (stl xs)) = decr (shd js2) js2;\n        (shd xs, m) \\<in> Ord;\n        alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) xs;\n        alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>js1 js2.\n                            xs = js1 @- js2 \\<and>\n                            set js1 \\<subseteq> {m} \\<and>\n                            (shd js2, m) \\<in> Ord \\<and>\n                            shd js2 \\<noteq> m \\<and>\n                            shd (decr m xs) = shd js2 \\<and>\n                            stl (decr m xs) = decr (shd js2) js2", "case (step js)"], ["proof (state)\nthis:\n  ev (\\<lambda>js. (shd js, m) \\<in> Ord \\<and> shd js \\<noteq> m) (stl js)\n  \\<not> ((shd js, m) \\<in> Ord \\<and> shd js \\<noteq> m)\n  \\<lbrakk>(shd (stl js), m) \\<in> Ord;\n   alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) (stl js);\n   alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) (stl js)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>js1 js2.\n                       stl js = js1 @- js2 \\<and>\n                       set js1 \\<subseteq> {m} \\<and>\n                       (shd js2, m) \\<in> Ord \\<and>\n                       shd js2 \\<noteq> m \\<and>\n                       shd (decr m (stl js)) = shd js2 \\<and>\n                       stl (decr m (stl js)) = decr (shd js2) js2\n  (shd js, m) \\<in> Ord\n  alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) js\n  alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) js\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>ev (\\<lambda>js.\n                       (shd js, m) \\<in> Ord \\<and> shd js \\<noteq> m)\n                 (stl xs);\n        \\<not> ((shd xs, m) \\<in> Ord \\<and> shd xs \\<noteq> m);\n        \\<lbrakk>(shd (stl xs), m) \\<in> Ord;\n         alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) (stl xs);\n         alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js))\n          (stl xs)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>js1 js2.\n                             stl xs = js1 @- js2 \\<and>\n                             set js1 \\<subseteq> {m} \\<and>\n                             (shd js2, m) \\<in> Ord \\<and>\n                             shd js2 \\<noteq> m \\<and>\n                             shd (decr m (stl xs)) = shd js2 \\<and>\n                             stl (decr m (stl xs)) = decr (shd js2) js2;\n        (shd xs, m) \\<in> Ord;\n        alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) xs;\n        alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>js1 js2.\n                            xs = js1 @- js2 \\<and>\n                            set js1 \\<subseteq> {m} \\<and>\n                            (shd js2, m) \\<in> Ord \\<and>\n                            shd js2 \\<noteq> m \\<and>\n                            shd (decr m xs) = shd js2 \\<and>\n                            stl (decr m xs) = decr (shd js2) js2", "then"], ["proof (chain)\npicking this:\n  ev (\\<lambda>js. (shd js, m) \\<in> Ord \\<and> shd js \\<noteq> m) (stl js)\n  \\<not> ((shd js, m) \\<in> Ord \\<and> shd js \\<noteq> m)\n  \\<lbrakk>(shd (stl js), m) \\<in> Ord;\n   alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) (stl js);\n   alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) (stl js)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>js1 js2.\n                       stl js = js1 @- js2 \\<and>\n                       set js1 \\<subseteq> {m} \\<and>\n                       (shd js2, m) \\<in> Ord \\<and>\n                       shd js2 \\<noteq> m \\<and>\n                       shd (decr m (stl js)) = shd js2 \\<and>\n                       stl (decr m (stl js)) = decr (shd js2) js2\n  (shd js, m) \\<in> Ord\n  alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) js\n  alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) js", "obtain js1 js2 where 1: \"?\\<phi> (stl js) js1 js2\" and [simp]: \"shd js = m\""], ["proof (prove)\nusing this:\n  ev (\\<lambda>js. (shd js, m) \\<in> Ord \\<and> shd js \\<noteq> m) (stl js)\n  \\<not> ((shd js, m) \\<in> Ord \\<and> shd js \\<noteq> m)\n  \\<lbrakk>(shd (stl js), m) \\<in> Ord;\n   alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) (stl js);\n   alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) (stl js)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>js1 js2.\n                       stl js = js1 @- js2 \\<and>\n                       set js1 \\<subseteq> {m} \\<and>\n                       (shd js2, m) \\<in> Ord \\<and>\n                       shd js2 \\<noteq> m \\<and>\n                       shd (decr m (stl js)) = shd js2 \\<and>\n                       stl (decr m (stl js)) = decr (shd js2) js2\n  (shd js, m) \\<in> Ord\n  alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) js\n  alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) js\n\ngoal (1 subgoal):\n 1. (\\<And>js1 js2.\n        \\<lbrakk>stl js = js1 @- js2 \\<and>\n                 set js1 \\<subseteq> {m} \\<and>\n                 (shd js2, m) \\<in> Ord \\<and>\n                 shd js2 \\<noteq> m \\<and>\n                 shd (decr m (stl js)) = shd js2 \\<and>\n                 stl (decr m (stl js)) = decr (shd js2) js2;\n         shd js = m\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  stl js = js1 @- js2 \\<and>\n  set js1 \\<subseteq> {m} \\<and>\n  (shd js2, m) \\<in> Ord \\<and>\n  shd js2 \\<noteq> m \\<and>\n  shd (decr m (stl js)) = shd js2 \\<and>\n  stl (decr m (stl js)) = decr (shd js2) js2\n  shd js = m\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       \\<lbrakk>ev (\\<lambda>js.\n                       (shd js, m) \\<in> Ord \\<and> shd js \\<noteq> m)\n                 (stl xs);\n        \\<not> ((shd xs, m) \\<in> Ord \\<and> shd xs \\<noteq> m);\n        \\<lbrakk>(shd (stl xs), m) \\<in> Ord;\n         alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) (stl xs);\n         alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js))\n          (stl xs)\\<rbrakk>\n        \\<Longrightarrow> \\<exists>js1 js2.\n                             stl xs = js1 @- js2 \\<and>\n                             set js1 \\<subseteq> {m} \\<and>\n                             (shd js2, m) \\<in> Ord \\<and>\n                             shd js2 \\<noteq> m \\<and>\n                             shd (decr m (stl xs)) = shd js2 \\<and>\n                             stl (decr m (stl xs)) = decr (shd js2) js2;\n        (shd xs, m) \\<in> Ord;\n        alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) xs;\n        alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) xs\\<rbrakk>\n       \\<Longrightarrow> \\<exists>js1 js2.\n                            xs = js1 @- js2 \\<and>\n                            set js1 \\<subseteq> {m} \\<and>\n                            (shd js2, m) \\<in> Ord \\<and>\n                            shd js2 \\<noteq> m \\<and>\n                            shd (decr m xs) = shd js2 \\<and>\n                            stl (decr m xs) = decr (shd js2) js2", "thus ?case"], ["proof (prove)\nusing this:\n  stl js = js1 @- js2 \\<and>\n  set js1 \\<subseteq> {m} \\<and>\n  (shd js2, m) \\<in> Ord \\<and>\n  shd js2 \\<noteq> m \\<and>\n  shd (decr m (stl js)) = shd js2 \\<and>\n  stl (decr m (stl js)) = decr (shd js2) js2\n  shd js = m\n\ngoal (1 subgoal):\n 1. \\<exists>js1 js2.\n       js = js1 @- js2 \\<and>\n       set js1 \\<subseteq> {m} \\<and>\n       (shd js2, m) \\<in> Ord \\<and>\n       shd js2 \\<noteq> m \\<and>\n       shd (decr m js) = shd js2 \\<and> stl (decr m js) = decr (shd js2) js2", "by (intro exI[of _ \"shd js # js1\"] exI[of _ js2],\n      simp, metis (lifting) decr_simps_eq step(2,4,5,6) stream.collapse)"], ["proof (state)\nthis:\n  \\<exists>js1 js2.\n     js = js1 @- js2 \\<and>\n     set js1 \\<subseteq> {m} \\<and>\n     (shd js2, m) \\<in> Ord \\<and>\n     shd js2 \\<noteq> m \\<and>\n     shd (decr m js) = shd js2 \\<and> stl (decr m js) = decr (shd js2) js2\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary stl_decr_shd:\n  assumes a: \"alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) js\" and\n    ae: \"alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) js\"\n  shows\n    \"\\<exists>js1 js2. js = js1 @- js2 \\<and> set js1 \\<subseteq> {shd js} \\<and>\n (shd js2, shd js) \\<in> Ord \\<and> shd js2 \\<noteq> shd js \\<and>\n  shd (decr (shd js) js) = shd js2 \\<and> stl (decr (shd js) js) = decr (shd js2) js2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>js1 js2.\n       js = js1 @- js2 \\<and>\n       set js1 \\<subseteq> {shd js} \\<and>\n       (shd js2, shd js) \\<in> Ord \\<and>\n       shd js2 \\<noteq> shd js \\<and>\n       shd (decr (shd js) js) = shd js2 \\<and>\n       stl (decr (shd js) js) = decr (shd js2) js2", "using Ord"], ["proof (prove)\nusing this:\n  well_order Ord\n\ngoal (1 subgoal):\n 1. \\<exists>js1 js2.\n       js = js1 @- js2 \\<and>\n       set js1 \\<subseteq> {shd js} \\<and>\n       (shd js2, shd js) \\<in> Ord \\<and>\n       shd js2 \\<noteq> shd js \\<and>\n       shd (decr (shd js) js) = shd js2 \\<and>\n       stl (decr (shd js) js) = decr (shd js2) js2", "unfolding well_order_on_defs"], ["proof (prove)\nusing this:\n  ((((Ord \\<subseteq> UNIV \\<times> UNIV \\<and>\n      (\\<forall>x\\<in>UNIV. (x, x) \\<in> Ord)) \\<and>\n     (\\<forall>x y z.\n         (x, y) \\<in> Ord \\<longrightarrow>\n         (y, z) \\<in> Ord \\<longrightarrow> (x, z) \\<in> Ord)) \\<and>\n    (\\<forall>x y.\n        (x, y) \\<in> Ord \\<longrightarrow>\n        (y, x) \\<in> Ord \\<longrightarrow> x = y)) \\<and>\n   total Ord) \\<and>\n  Wellfounded.wf (Ord - Id)\n\ngoal (1 subgoal):\n 1. \\<exists>js1 js2.\n       js = js1 @- js2 \\<and>\n       set js1 \\<subseteq> {shd js} \\<and>\n       (shd js2, shd js) \\<in> Ord \\<and>\n       shd js2 \\<noteq> shd js \\<and>\n       shd (decr (shd js) js) = shd js2 \\<and>\n       stl (decr (shd js) js) = decr (shd js2) js2", "by (intro stl_decr[OF assms]) blast"], ["", "lemma decr:\n  assumes a: \"alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) js\" (is \"?a js\")\n    and ae: \"alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) js\" (is \"?ae js\")\n  shows\n    \"alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord \\<and> shd (stl js) \\<noteq> shd js) (decr (shd js) js)\"\n    (is \"alw ?\\<phi> _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (\\<lambda>js.\n            (shd (stl js), shd js) \\<in> Ord \\<and>\n            shd (stl js) \\<noteq> shd js)\n     (decr (shd js) js)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. alw (\\<lambda>js.\n            (shd (stl js), shd js) \\<in> Ord \\<and>\n            shd (stl js) \\<noteq> shd js)\n     (decr (shd js) js)", "let ?\\<xi> = \"\\<lambda>ls js. ls = decr (shd js) js \\<and> ?a js \\<and> ?ae js\""], ["proof (state)\ngoal (1 subgoal):\n 1. alw (\\<lambda>js.\n            (shd (stl js), shd js) \\<in> Ord \\<and>\n            shd (stl js) \\<noteq> shd js)\n     (decr (shd js) js)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. alw (\\<lambda>js.\n            (shd (stl js), shd js) \\<in> Ord \\<and>\n            shd (stl js) \\<noteq> shd js)\n     (decr (shd js) js)", "fix ls"], ["proof (state)\ngoal (1 subgoal):\n 1. alw (\\<lambda>js.\n            (shd (stl js), shd js) \\<in> Ord \\<and>\n            shd (stl js) \\<noteq> shd js)\n     (decr (shd js) js)", "assume \"\\<exists>js. ?\\<xi> ls js\""], ["proof (state)\nthis:\n  \\<exists>js.\n     ls = decr (shd js) js \\<and>\n     alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) js \\<and>\n     alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) js\n\ngoal (1 subgoal):\n 1. alw (\\<lambda>js.\n            (shd (stl js), shd js) \\<in> Ord \\<and>\n            shd (stl js) \\<noteq> shd js)\n     (decr (shd js) js)", "hence \"alw ?\\<phi> ls\""], ["proof (prove)\nusing this:\n  \\<exists>js.\n     ls = decr (shd js) js \\<and>\n     alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) js \\<and>\n     alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) js\n\ngoal (1 subgoal):\n 1. alw (\\<lambda>js.\n            (shd (stl js), shd js) \\<in> Ord \\<and>\n            shd (stl js) \\<noteq> shd js)\n     ls", "proof(elim alw_coinduct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<exists>js.\n          x = decr (shd js) js \\<and>\n          alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) js \\<and>\n          alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js))\n           js \\<Longrightarrow>\n       (shd (stl x), shd x) \\<in> Ord \\<and> shd (stl x) \\<noteq> shd x\n 2. \\<And>x.\n       \\<lbrakk>\\<exists>js.\n                   x = decr (shd js) js \\<and>\n                   alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord)\n                    js \\<and>\n                   alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) js;\n        \\<not> alw (\\<lambda>js.\n                       (shd (stl js), shd js) \\<in> Ord \\<and>\n                       shd (stl js) \\<noteq> shd js)\n                (stl x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>js.\n                            stl x = decr (shd js) js \\<and>\n                            alw (\\<lambda>js.\n                                    (shd (stl js), shd js) \\<in> Ord)\n                             js \\<and>\n                            alw (ev (\\<lambda>js.\n  shd (stl js) \\<noteq> shd js))\n                             js", "fix ls"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<exists>js.\n          x = decr (shd js) js \\<and>\n          alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) js \\<and>\n          alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js))\n           js \\<Longrightarrow>\n       (shd (stl x), shd x) \\<in> Ord \\<and> shd (stl x) \\<noteq> shd x\n 2. \\<And>x.\n       \\<lbrakk>\\<exists>js.\n                   x = decr (shd js) js \\<and>\n                   alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord)\n                    js \\<and>\n                   alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) js;\n        \\<not> alw (\\<lambda>js.\n                       (shd (stl js), shd js) \\<in> Ord \\<and>\n                       shd (stl js) \\<noteq> shd js)\n                (stl x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>js.\n                            stl x = decr (shd js) js \\<and>\n                            alw (\\<lambda>js.\n                                    (shd (stl js), shd js) \\<in> Ord)\n                             js \\<and>\n                            alw (ev (\\<lambda>js.\n  shd (stl js) \\<noteq> shd js))\n                             js", "assume \"\\<exists>js. ?\\<xi> ls js\""], ["proof (state)\nthis:\n  \\<exists>js.\n     ls = decr (shd js) js \\<and>\n     alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) js \\<and>\n     alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) js\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<exists>js.\n          x = decr (shd js) js \\<and>\n          alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) js \\<and>\n          alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js))\n           js \\<Longrightarrow>\n       (shd (stl x), shd x) \\<in> Ord \\<and> shd (stl x) \\<noteq> shd x\n 2. \\<And>x.\n       \\<lbrakk>\\<exists>js.\n                   x = decr (shd js) js \\<and>\n                   alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord)\n                    js \\<and>\n                   alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) js;\n        \\<not> alw (\\<lambda>js.\n                       (shd (stl js), shd js) \\<in> Ord \\<and>\n                       shd (stl js) \\<noteq> shd js)\n                (stl x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>js.\n                            stl x = decr (shd js) js \\<and>\n                            alw (\\<lambda>js.\n                                    (shd (stl js), shd js) \\<in> Ord)\n                             js \\<and>\n                            alw (ev (\\<lambda>js.\n  shd (stl js) \\<noteq> shd js))\n                             js", "then"], ["proof (chain)\npicking this:\n  \\<exists>js.\n     ls = decr (shd js) js \\<and>\n     alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) js \\<and>\n     alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) js", "obtain js where 1: \"?\\<xi> ls js\""], ["proof (prove)\nusing this:\n  \\<exists>js.\n     ls = decr (shd js) js \\<and>\n     alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) js \\<and>\n     alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) js\n\ngoal (1 subgoal):\n 1. (\\<And>js.\n        ls = decr (shd js) js \\<and>\n        alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) js \\<and>\n        alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js))\n         js \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ls = decr (shd js) js \\<and>\n  alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) js \\<and>\n  alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) js\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<exists>js.\n          x = decr (shd js) js \\<and>\n          alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) js \\<and>\n          alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js))\n           js \\<Longrightarrow>\n       (shd (stl x), shd x) \\<in> Ord \\<and> shd (stl x) \\<noteq> shd x\n 2. \\<And>x.\n       \\<lbrakk>\\<exists>js.\n                   x = decr (shd js) js \\<and>\n                   alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord)\n                    js \\<and>\n                   alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) js;\n        \\<not> alw (\\<lambda>js.\n                       (shd (stl js), shd js) \\<in> Ord \\<and>\n                       shd (stl js) \\<noteq> shd js)\n                (stl x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>js.\n                            stl x = decr (shd js) js \\<and>\n                            alw (\\<lambda>js.\n                                    (shd (stl js), shd js) \\<in> Ord)\n                             js \\<and>\n                            alw (ev (\\<lambda>js.\n  shd (stl js) \\<noteq> shd js))\n                             js", "then"], ["proof (chain)\npicking this:\n  ls = decr (shd js) js \\<and>\n  alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) js \\<and>\n  alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) js", "obtain js1 js2 where js: \"js = js1 @- js2 \\<and> set js1 \\<subseteq> {shd js} \\<and>\n       (shd js2, shd js) \\<in> Ord \\<and> shd js2 \\<noteq> shd js \\<and>\n       shd ls = shd js2 \\<and> stl ls = decr (shd js2) js2\""], ["proof (prove)\nusing this:\n  ls = decr (shd js) js \\<and>\n  alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) js \\<and>\n  alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) js\n\ngoal (1 subgoal):\n 1. (\\<And>js1 js2.\n        js = js1 @- js2 \\<and>\n        set js1 \\<subseteq> {shd js} \\<and>\n        (shd js2, shd js) \\<in> Ord \\<and>\n        shd js2 \\<noteq> shd js \\<and>\n        shd ls = shd js2 \\<and>\n        stl ls = decr (shd js2) js2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using stl_decr_shd"], ["proof (prove)\nusing this:\n  ls = decr (shd js) js \\<and>\n  alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) js \\<and>\n  alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) js\n  \\<lbrakk>alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) ?js;\n   alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) ?js\\<rbrakk>\n  \\<Longrightarrow> \\<exists>js1 js2.\n                       ?js = js1 @- js2 \\<and>\n                       set js1 \\<subseteq> {shd ?js} \\<and>\n                       (shd js2, shd ?js) \\<in> Ord \\<and>\n                       shd js2 \\<noteq> shd ?js \\<and>\n                       shd (decr (shd ?js) ?js) = shd js2 \\<and>\n                       stl (decr (shd ?js) ?js) = decr (shd js2) js2\n\ngoal (1 subgoal):\n 1. (\\<And>js1 js2.\n        js = js1 @- js2 \\<and>\n        set js1 \\<subseteq> {shd js} \\<and>\n        (shd js2, shd js) \\<in> Ord \\<and>\n        shd js2 \\<noteq> shd js \\<and>\n        shd ls = shd js2 \\<and>\n        stl ls = decr (shd js2) js2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  js = js1 @- js2 \\<and>\n  set js1 \\<subseteq> {shd js} \\<and>\n  (shd js2, shd js) \\<in> Ord \\<and>\n  shd js2 \\<noteq> shd js \\<and>\n  shd ls = shd js2 \\<and> stl ls = decr (shd js2) js2\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<exists>js.\n          x = decr (shd js) js \\<and>\n          alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) js \\<and>\n          alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js))\n           js \\<Longrightarrow>\n       (shd (stl x), shd x) \\<in> Ord \\<and> shd (stl x) \\<noteq> shd x\n 2. \\<And>x.\n       \\<lbrakk>\\<exists>js.\n                   x = decr (shd js) js \\<and>\n                   alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord)\n                    js \\<and>\n                   alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) js;\n        \\<not> alw (\\<lambda>js.\n                       (shd (stl js), shd js) \\<in> Ord \\<and>\n                       shd (stl js) \\<noteq> shd js)\n                (stl x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>js.\n                            stl x = decr (shd js) js \\<and>\n                            alw (\\<lambda>js.\n                                    (shd (stl js), shd js) \\<in> Ord)\n                             js \\<and>\n                            alw (ev (\\<lambda>js.\n  shd (stl js) \\<noteq> shd js))\n                             js", "then"], ["proof (chain)\npicking this:\n  js = js1 @- js2 \\<and>\n  set js1 \\<subseteq> {shd js} \\<and>\n  (shd js2, shd js) \\<in> Ord \\<and>\n  shd js2 \\<noteq> shd js \\<and>\n  shd ls = shd js2 \\<and> stl ls = decr (shd js2) js2", "obtain js3 js4 where js2: \"js2 = js3 @- js4 \\<and> set js3 \\<subseteq> {shd js2} \\<and>\n       (shd js4, shd js2) \\<in> Ord \\<and> shd js4 \\<noteq> shd js2 \\<and>\n       shd (decr (shd js2) js2) = shd js4 \\<and> stl ((decr (shd js2) js2)) = decr (shd js4) js4\""], ["proof (prove)\nusing this:\n  js = js1 @- js2 \\<and>\n  set js1 \\<subseteq> {shd js} \\<and>\n  (shd js2, shd js) \\<in> Ord \\<and>\n  shd js2 \\<noteq> shd js \\<and>\n  shd ls = shd js2 \\<and> stl ls = decr (shd js2) js2\n\ngoal (1 subgoal):\n 1. (\\<And>js3 js4.\n        js2 = js3 @- js4 \\<and>\n        set js3 \\<subseteq> {shd js2} \\<and>\n        (shd js4, shd js2) \\<in> Ord \\<and>\n        shd js4 \\<noteq> shd js2 \\<and>\n        shd (decr (shd js2) js2) = shd js4 \\<and>\n        stl (decr (shd js2) js2) = decr (shd js4) js4 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using stl_decr_shd[of js2] a ae"], ["proof (prove)\nusing this:\n  js = js1 @- js2 \\<and>\n  set js1 \\<subseteq> {shd js} \\<and>\n  (shd js2, shd js) \\<in> Ord \\<and>\n  shd js2 \\<noteq> shd js \\<and>\n  shd ls = shd js2 \\<and> stl ls = decr (shd js2) js2\n  \\<lbrakk>alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) js2;\n   alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) js2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>js1 js2a.\n                       js2 = js1 @- js2a \\<and>\n                       set js1 \\<subseteq> {shd js2} \\<and>\n                       (shd js2a, shd js2) \\<in> Ord \\<and>\n                       shd js2a \\<noteq> shd js2 \\<and>\n                       shd (decr (shd js2) js2) = shd js2a \\<and>\n                       stl (decr (shd js2) js2) = decr (shd js2a) js2a\n  alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) js\n  alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) js\n\ngoal (1 subgoal):\n 1. (\\<And>js3 js4.\n        js2 = js3 @- js4 \\<and>\n        set js3 \\<subseteq> {shd js2} \\<and>\n        (shd js4, shd js2) \\<in> Ord \\<and>\n        shd js4 \\<noteq> shd js2 \\<and>\n        shd (decr (shd js2) js2) = shd js4 \\<and>\n        stl (decr (shd js2) js2) = decr (shd js4) js4 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using 1 alw_shift"], ["proof (prove)\nusing this:\n  js = js1 @- js2 \\<and>\n  set js1 \\<subseteq> {shd js} \\<and>\n  (shd js2, shd js) \\<in> Ord \\<and>\n  shd js2 \\<noteq> shd js \\<and>\n  shd ls = shd js2 \\<and> stl ls = decr (shd js2) js2\n  \\<lbrakk>alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) js2;\n   alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) js2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>js1 js2a.\n                       js2 = js1 @- js2a \\<and>\n                       set js1 \\<subseteq> {shd js2} \\<and>\n                       (shd js2a, shd js2) \\<in> Ord \\<and>\n                       shd js2a \\<noteq> shd js2 \\<and>\n                       shd (decr (shd js2) js2) = shd js2a \\<and>\n                       stl (decr (shd js2) js2) = decr (shd js2a) js2a\n  alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) js\n  alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) js\n  ls = decr (shd js) js \\<and>\n  alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) js \\<and>\n  alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) js\n  alw ?\\<phi> (?xl @- ?xs) \\<Longrightarrow> alw ?\\<phi> ?xs\n\ngoal (1 subgoal):\n 1. (\\<And>js3 js4.\n        js2 = js3 @- js4 \\<and>\n        set js3 \\<subseteq> {shd js2} \\<and>\n        (shd js4, shd js2) \\<in> Ord \\<and>\n        shd js4 \\<noteq> shd js2 \\<and>\n        shd (decr (shd js2) js2) = shd js4 \\<and>\n        stl (decr (shd js2) js2) = decr (shd js4) js4 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  js2 = js3 @- js4 \\<and>\n  set js3 \\<subseteq> {shd js2} \\<and>\n  (shd js4, shd js2) \\<in> Ord \\<and>\n  shd js4 \\<noteq> shd js2 \\<and>\n  shd (decr (shd js2) js2) = shd js4 \\<and>\n  stl (decr (shd js2) js2) = decr (shd js4) js4\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<exists>js.\n          x = decr (shd js) js \\<and>\n          alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) js \\<and>\n          alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js))\n           js \\<Longrightarrow>\n       (shd (stl x), shd x) \\<in> Ord \\<and> shd (stl x) \\<noteq> shd x\n 2. \\<And>x.\n       \\<lbrakk>\\<exists>js.\n                   x = decr (shd js) js \\<and>\n                   alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord)\n                    js \\<and>\n                   alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) js;\n        \\<not> alw (\\<lambda>js.\n                       (shd (stl js), shd js) \\<in> Ord \\<and>\n                       shd (stl js) \\<noteq> shd js)\n                (stl x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>js.\n                            stl x = decr (shd js) js \\<and>\n                            alw (\\<lambda>js.\n                                    (shd (stl js), shd js) \\<in> Ord)\n                             js \\<and>\n                            alw (ev (\\<lambda>js.\n  shd (stl js) \\<noteq> shd js))\n                             js", "show \"?\\<phi> ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (shd (stl ls), shd ls) \\<in> Ord \\<and> shd (stl ls) \\<noteq> shd ls", "using 1 js js2"], ["proof (prove)\nusing this:\n  ls = decr (shd js) js \\<and>\n  alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) js \\<and>\n  alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) js\n  js = js1 @- js2 \\<and>\n  set js1 \\<subseteq> {shd js} \\<and>\n  (shd js2, shd js) \\<in> Ord \\<and>\n  shd js2 \\<noteq> shd js \\<and>\n  shd ls = shd js2 \\<and> stl ls = decr (shd js2) js2\n  js2 = js3 @- js4 \\<and>\n  set js3 \\<subseteq> {shd js2} \\<and>\n  (shd js4, shd js2) \\<in> Ord \\<and>\n  shd js4 \\<noteq> shd js2 \\<and>\n  shd (decr (shd js2) js2) = shd js4 \\<and>\n  stl (decr (shd js2) js2) = decr (shd js4) js4\n\ngoal (1 subgoal):\n 1. (shd (stl ls), shd ls) \\<in> Ord \\<and> shd (stl ls) \\<noteq> shd ls", "by metis"], ["proof (state)\nthis:\n  (shd (stl ls), shd ls) \\<in> Ord \\<and> shd (stl ls) \\<noteq> shd ls\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<exists>js.\n                   x = decr (shd js) js \\<and>\n                   alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord)\n                    js \\<and>\n                   alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) js;\n        \\<not> alw (\\<lambda>js.\n                       (shd (stl js), shd js) \\<in> Ord \\<and>\n                       shd (stl js) \\<noteq> shd js)\n                (stl x)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>js.\n                            stl x = decr (shd js) js \\<and>\n                            alw (\\<lambda>js.\n                                    (shd (stl js), shd js) \\<in> Ord)\n                             js \\<and>\n                            alw (ev (\\<lambda>js.\n  shd (stl js) \\<noteq> shd js))\n                             js", "qed (metis (no_types, lifting) alw_shift stl_decr_shd)"], ["proof (state)\nthis:\n  alw (\\<lambda>js.\n          (shd (stl js), shd js) \\<in> Ord \\<and>\n          shd (stl js) \\<noteq> shd js)\n   ls\n\ngoal (1 subgoal):\n 1. alw (\\<lambda>js.\n            (shd (stl js), shd js) \\<in> Ord \\<and>\n            shd (stl js) \\<noteq> shd js)\n     (decr (shd js) js)", "}"], ["proof (state)\nthis:\n  \\<exists>js.\n     ?ls4 = decr (shd js) js \\<and>\n     alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) js \\<and>\n     alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js))\n      js \\<Longrightarrow>\n  alw (\\<lambda>js.\n          (shd (stl js), shd js) \\<in> Ord \\<and>\n          shd (stl js) \\<noteq> shd js)\n   ?ls4\n\ngoal (1 subgoal):\n 1. alw (\\<lambda>js.\n            (shd (stl js), shd js) \\<in> Ord \\<and>\n            shd (stl js) \\<noteq> shd js)\n     (decr (shd js) js)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>js.\n     ?ls4 = decr (shd js) js \\<and>\n     alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) js \\<and>\n     alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js))\n      js \\<Longrightarrow>\n  alw (\\<lambda>js.\n          (shd (stl js), shd js) \\<in> Ord \\<and>\n          shd (stl js) \\<noteq> shd js)\n   ?ls4\n\ngoal (1 subgoal):\n 1. alw (\\<lambda>js.\n            (shd (stl js), shd js) \\<in> Ord \\<and>\n            shd (stl js) \\<noteq> shd js)\n     (decr (shd js) js)", "using assms"], ["proof (prove)\nusing this:\n  \\<exists>js.\n     ?ls4 = decr (shd js) js \\<and>\n     alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) js \\<and>\n     alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js))\n      js \\<Longrightarrow>\n  alw (\\<lambda>js.\n          (shd (stl js), shd js) \\<in> Ord \\<and>\n          shd (stl js) \\<noteq> shd js)\n   ?ls4\n  alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord) js\n  alw (ev (\\<lambda>js. shd (stl js) \\<noteq> shd js)) js\n\ngoal (1 subgoal):\n 1. alw (\\<lambda>js.\n            (shd (stl js), shd js) \\<in> Ord \\<and>\n            shd (stl js) \\<noteq> shd js)\n     (decr (shd js) js)", "by blast"], ["proof (state)\nthis:\n  alw (\\<lambda>js.\n          (shd (stl js), shd js) \\<in> Ord \\<and>\n          shd (stl js) \\<noteq> shd js)\n   (decr (shd js) js)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma alw_snth:\n  assumes \"alw (\\<lambda>xs. P (shd (stl xs)) (shd xs)) xs\"\n  shows \"P (xs!!(Suc n)) (xs!! n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (xs !! Suc n) (xs !! n)", "using assms"], ["proof (prove)\nusing this:\n  alw (\\<lambda>xs. P (shd (stl xs)) (shd xs)) xs\n\ngoal (1 subgoal):\n 1. P (xs !! Suc n) (xs !! n)", "by (induction n, auto, metis (mono_tags) alw.cases alw_iff_sdrop sdrop_simps(1) sdrop_stl)"], ["", "lemma F: False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "define ls where \"ls = decr (shd ks) ks\""], ["proof (state)\nthis:\n  ls = decr (shd ks) ks\n\ngoal (1 subgoal):\n 1. False", "have 0: \"alw (\\<lambda>js. (shd (stl js), shd js) \\<in> Ord \\<and> shd (stl js) \\<noteq> shd js) ls\""], ["proof (prove)\ngoal (1 subgoal):\n 1. alw (\\<lambda>js.\n            (shd (stl js), shd js) \\<in> Ord \\<and>\n            shd (stl js) \\<noteq> shd js)\n     ls", "using decr[OF alw_ks alw_ev_ks]"], ["proof (prove)\nusing this:\n  alw (\\<lambda>js.\n          (shd (stl js), shd js) \\<in> Ord \\<and>\n          shd (stl js) \\<noteq> shd js)\n   (decr (shd ks) ks)\n\ngoal (1 subgoal):\n 1. alw (\\<lambda>js.\n            (shd (stl js), shd js) \\<in> Ord \\<and>\n            shd (stl js) \\<noteq> shd js)\n     ls", "unfolding ls_def"], ["proof (prove)\nusing this:\n  alw (\\<lambda>js.\n          (shd (stl js), shd js) \\<in> Ord \\<and>\n          shd (stl js) \\<noteq> shd js)\n   (decr (shd ks) ks)\n\ngoal (1 subgoal):\n 1. alw (\\<lambda>js.\n            (shd (stl js), shd js) \\<in> Ord \\<and>\n            shd (stl js) \\<noteq> shd js)\n     (decr (shd ks) ks)", "."], ["proof (state)\nthis:\n  alw (\\<lambda>js.\n          (shd (stl js), shd js) \\<in> Ord \\<and>\n          shd (stl js) \\<noteq> shd js)\n   ls\n\ngoal (1 subgoal):\n 1. False", "define Q where \"Q = range (snth ls)\""], ["proof (state)\nthis:\n  Q = range ((!!) ls)\n\ngoal (1 subgoal):\n 1. False", "let ?wf = \"Wellfounded.wf\""], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have Q: \"Q \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q \\<noteq> {}", "unfolding Q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. range ((!!) ls) \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  Q \\<noteq> {}\n\ngoal (1 subgoal):\n 1. False", "have 1: \"?wf (Ord - Id)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Wellfounded.wf (Ord - Id)", "using Ord"], ["proof (prove)\nusing this:\n  well_order Ord\n\ngoal (1 subgoal):\n 1. Wellfounded.wf (Ord - Id)", "unfolding well_order_on_def"], ["proof (prove)\nusing this:\n  linear_order Ord \\<and> Wellfounded.wf (Ord - Id)\n\ngoal (1 subgoal):\n 1. Wellfounded.wf (Ord - Id)", "by auto"], ["proof (state)\nthis:\n  Wellfounded.wf (Ord - Id)\n\ngoal (1 subgoal):\n 1. False", "obtain q where q: \"q \\<in> Q\" and 2: \"\\<forall>q'. (q',q) \\<in> Ord - Id \\<longrightarrow> q' \\<notin> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> Q;\n         \\<forall>q'.\n            (q', q) \\<in> Ord - Id \\<longrightarrow> q' \\<notin> Q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using wfE_min[OF 1] Q"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<in> ?Q;\n   \\<And>z.\n      \\<lbrakk>z \\<in> ?Q;\n       \\<And>y.\n          (y, z) \\<in> Ord - Id \\<Longrightarrow> y \\<notin> ?Q\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  Q \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> Q;\n         \\<forall>q'.\n            (q', q) \\<in> Ord - Id \\<longrightarrow> q' \\<notin> Q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  q \\<in> Q\n  \\<forall>q'. (q', q) \\<in> Ord - Id \\<longrightarrow> q' \\<notin> Q\n\ngoal (1 subgoal):\n 1. False", "obtain n where \"ls!!n = q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n. ls !! n = q \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using q"], ["proof (prove)\nusing this:\n  q \\<in> Q\n\ngoal (1 subgoal):\n 1. (\\<And>n. ls !! n = q \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "unfolding Q_def"], ["proof (prove)\nusing this:\n  q \\<in> range ((!!) ls)\n\ngoal (1 subgoal):\n 1. (\\<And>n. ls !! n = q \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  ls !! n = q\n\ngoal (1 subgoal):\n 1. False", "hence \"(ls!!(Suc n),q) \\<in> Ord - Id\""], ["proof (prove)\nusing this:\n  ls !! n = q\n\ngoal (1 subgoal):\n 1. (ls !! Suc n, q) \\<in> Ord - Id", "using alw_snth[OF 0]"], ["proof (prove)\nusing this:\n  ls !! n = q\n  (ls !! Suc ?n, ls !! ?n) \\<in> Ord \\<and> ls !! Suc ?n \\<noteq> ls !! ?n\n\ngoal (1 subgoal):\n 1. (ls !! Suc n, q) \\<in> Ord - Id", "by auto"], ["proof (state)\nthis:\n  (ls !! Suc n, q) \\<in> Ord - Id\n\ngoal (1 subgoal):\n 1. False", "thus False"], ["proof (prove)\nusing this:\n  (ls !! Suc n, q) \\<in> Ord - Id\n\ngoal (1 subgoal):\n 1. False", "using 2 Q_def"], ["proof (prove)\nusing this:\n  (ls !! Suc n, q) \\<in> Ord - Id\n  \\<forall>q'. (q', q) \\<in> Ord - Id \\<longrightarrow> q' \\<notin> Q\n  Q = range ((!!) ls)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "(* context *)\n\n(* Main theorem: *)"], ["", "theorem infinite_soundness:\n  assumes \"wf t\" and \"good t\" and \"S \\<in> structure\"\n  shows \"sat S (fst (root t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sat S (fst (tree.root t))", "using F[OF assms]"], ["proof (prove)\nusing this:\n  \\<not> sat S (fst (tree.root t)) \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. sat S (fst (tree.root t))", "by auto"], ["", "end"], ["", "(* context Infinite_Soundness *)"], ["", "section \\<open>Soundness of Cyclic Proof Trees\\<close>"], ["", "(* Cyclic trees *)"], ["", "datatype (discs_sels) ('sequent, 'rule, 'link) ctree =\n  Link 'link |\n  cNode  \"('sequent,'rule) step\" \"('sequent, 'rule, 'link) ctree fset\""], ["", "corecursive treeOf where\n  \"treeOf pointsTo ct =\n   (if \\<exists>l l'. pointsTo l = Link l'\n    \\<comment> \\<open>makes sense only if backward links point to normal nodes, not to backwards links:\\<close>\n     then undefined\n     else (case ct of\n             Link l \\<Rightarrow> treeOf pointsTo (pointsTo l)\n            |cNode step cts \\<Rightarrow> Node step (fimage (treeOf pointsTo) cts)\n          )\n   )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. All (Wellfounded.accp treeOf_inner_fp_rel)", "by (relation \"measure (\\<lambda>(p,t). case t of Link l' => Suc 0 | _ => 0)\") (auto split: ctree.splits)"], ["", "declare treeOf.code[simp]"], ["", "context Infinite_Soundness\nbegin"], ["", "context\n  fixes pointsTo :: \"'link \\<Rightarrow> ('sequent, 'rule, 'link)ctree\"\n  assumes pointsTo: \"\\<forall>l l'. pointsTo l \\<noteq> Link l'\"\nbegin"], ["", "function seqOf where\n  \"seqOf (Link l) = seqOf (pointsTo l)\"\n|\n  \"seqOf (cNode (s,r) _) = s\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<And>l. x = Link l \\<Longrightarrow> P;\n        \\<And>s r uu_. x = cNode (s, r) uu_ \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>l la.\n       Link l = Link la \\<Longrightarrow>\n       seqOf_sumC (pointsTo l) = seqOf_sumC (pointsTo la)\n 3. \\<And>l s r uu_.\n       Link l = cNode (s, r) uu_ \\<Longrightarrow>\n       seqOf_sumC (pointsTo l) = s\n 4. \\<And>s r uu_ sa ra uua_.\n       cNode (s, r) uu_ = cNode (sa, ra) uua_ \\<Longrightarrow> s = sa", "by pat_completeness auto"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All seqOf_dom", "by (relation \"measure (\\<lambda>t. case t of Link l' => Suc 0 | _ => 0)\")\n    (auto split: ctree.splits simp: pointsTo)"], ["", "(* Note: Here, \"inductive\" instead of \"coinductive\" would not do! *)"], ["", "coinductive cwf where\n  Node[intro!]: \"cwf (pointsTo l) \\<Longrightarrow> cwf (Link l)\"\n|\n  cNode[intro]:\n  \"\\<lbrakk>r \\<in> R; eff r s (fimage seqOf cts); \\<And>ct'. ct' |\\<in>| cts \\<Longrightarrow> cwf ct'\\<rbrakk>\n\\<Longrightarrow>\ncwf (cNode (s,r) cts)\""], ["", "definition \"cgood ct \\<equiv> good (treeOf pointsTo ct)\""], ["", "lemma cwf_Link: \"cwf (Link l) \\<longleftrightarrow> cwf (pointsTo l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cwf (Link l) = cwf (pointsTo l)", "by (auto elim: cwf.cases)"], ["", "lemma cwf_cNode_seqOf:\n  \"cwf (cNode (s, r) cts) \\<Longrightarrow> eff r s (fimage seqOf cts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cwf (cNode (s, r) cts) \\<Longrightarrow> eff r s (seqOf |`| cts)", "by (auto elim: cwf.cases)"], ["", "lemma treeOf_seqOf[simp]:\n  \"fst \\<circ> root \\<circ> treeOf pointsTo = seqOf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst \\<circ> tree.root \\<circ> treeOf pointsTo = seqOf", "proof(rule ext, unfold o_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. fst (tree.root (treeOf pointsTo x)) = seqOf x", "fix ct"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. fst (tree.root (treeOf pointsTo x)) = seqOf x", "show \"fst (root (treeOf pointsTo ct)) = seqOf ct\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (tree.root (treeOf pointsTo ct)) = seqOf ct", "by induct (auto split: ctree.splits simp: pointsTo)"], ["proof (state)\nthis:\n  fst (tree.root (treeOf pointsTo ct)) = seqOf ct\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wf_treeOf:\n  assumes \"cwf ct\"\n  shows \"wf (treeOf pointsTo ct)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.wf (treeOf pointsTo ct)", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. local.wf (treeOf pointsTo ct)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. local.wf (treeOf pointsTo ct)", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. local.wf (treeOf pointsTo ct)", "let ?\\<phi> = \"\\<lambda>ct t. cwf ct \\<and> t = treeOf pointsTo ct\""], ["proof (state)\ngoal (1 subgoal):\n 1. local.wf (treeOf pointsTo ct)", "assume \"\\<exists>ct. ?\\<phi> ct t\""], ["proof (state)\nthis:\n  \\<exists>ct. cwf ct \\<and> t = treeOf pointsTo ct\n\ngoal (1 subgoal):\n 1. local.wf (treeOf pointsTo ct)", "hence \"wf t\""], ["proof (prove)\nusing this:\n  \\<exists>ct. cwf ct \\<and> t = treeOf pointsTo ct\n\ngoal (1 subgoal):\n 1. local.wf t", "proof(elim wf.coinduct, safe)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x ct cta.\n       \\<lbrakk>cwf ct; cwf cta; t = treeOf pointsTo cta\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            treeOf pointsTo ct = t \\<and>\n                            snd (tree.root t) \\<in> R \\<and>\n                            effStep (tree.root t)\n                             ((fst \\<circ> tree.root) |`| cont t) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont t \\<longrightarrow>\n                                (\\<exists>ct.\n                                    cwf ct \\<and>\n                                    x = treeOf pointsTo ct) \\<or>\n                                local.wf x)", "fix ct"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x ct cta.\n       \\<lbrakk>cwf ct; cwf cta; t = treeOf pointsTo cta\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            treeOf pointsTo ct = t \\<and>\n                            snd (tree.root t) \\<in> R \\<and>\n                            effStep (tree.root t)\n                             ((fst \\<circ> tree.root) |`| cont t) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont t \\<longrightarrow>\n                                (\\<exists>ct.\n                                    cwf ct \\<and>\n                                    x = treeOf pointsTo ct) \\<or>\n                                local.wf x)", "let ?t = \"treeOf pointsTo ct\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x ct cta.\n       \\<lbrakk>cwf ct; cwf cta; t = treeOf pointsTo cta\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            treeOf pointsTo ct = t \\<and>\n                            snd (tree.root t) \\<in> R \\<and>\n                            effStep (tree.root t)\n                             ((fst \\<circ> tree.root) |`| cont t) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont t \\<longrightarrow>\n                                (\\<exists>ct.\n                                    cwf ct \\<and>\n                                    x = treeOf pointsTo ct) \\<or>\n                                local.wf x)", "assume ct: \"cwf ct\""], ["proof (state)\nthis:\n  cwf ct\n\ngoal (1 subgoal):\n 1. \\<And>x ct cta.\n       \\<lbrakk>cwf ct; cwf cta; t = treeOf pointsTo cta\\<rbrakk>\n       \\<Longrightarrow> \\<exists>t.\n                            treeOf pointsTo ct = t \\<and>\n                            snd (tree.root t) \\<in> R \\<and>\n                            effStep (tree.root t)\n                             ((fst \\<circ> tree.root) |`| cont t) \\<and>\n                            (\\<forall>x.\n                                x |\\<in>| cont t \\<longrightarrow>\n                                (\\<exists>ct.\n                                    cwf ct \\<and>\n                                    x = treeOf pointsTo ct) \\<or>\n                                local.wf x)", "show \"\n       \\<exists>t. treeOf pointsTo ct = t \\<and>\n           snd (root t) \\<in> R \\<and>\n           effStep (root t) (fimage (fst \\<circ> root) (cont t)) \\<and>\n           (\\<forall>t'. t' |\\<in>| cont t \\<longrightarrow> (\\<exists>ct'. ?\\<phi> ct' t') \\<or> wf t')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>t.\n       treeOf pointsTo ct = t \\<and>\n       snd (tree.root t) \\<in> R \\<and>\n       effStep (tree.root t) ((fst \\<circ> tree.root) |`| cont t) \\<and>\n       (\\<forall>t'.\n           t' |\\<in>| cont t \\<longrightarrow>\n           (\\<exists>ct'. cwf ct' \\<and> t' = treeOf pointsTo ct') \\<or>\n           local.wf t')", "proof(rule exI[of _ ?t], safe)"], ["proof (state)\ngoal (3 subgoals):\n 1. snd (tree.root (treeOf pointsTo ct)) \\<in> R\n 2. effStep (tree.root (treeOf pointsTo ct))\n     ((fst \\<circ> tree.root) |`| cont (treeOf pointsTo ct))\n 3. \\<And>t'.\n       \\<lbrakk>t' |\\<in>| cont (treeOf pointsTo ct);\n        \\<not> local.wf t'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ct'.\n                            cwf ct' \\<and> t' = treeOf pointsTo ct'", "show \"snd (root ?t) \\<in> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (tree.root (treeOf pointsTo ct)) \\<in> R", "using pointsTo ct"], ["proof (prove)\nusing this:\n  \\<forall>l l'. pointsTo l \\<noteq> Link l'\n  cwf ct\n\ngoal (1 subgoal):\n 1. snd (tree.root (treeOf pointsTo ct)) \\<in> R", "by (auto elim: cwf.cases split: ctree.splits simp: cwf_Link)"], ["proof (state)\nthis:\n  snd (tree.root (treeOf pointsTo ct)) \\<in> R\n\ngoal (2 subgoals):\n 1. effStep (tree.root (treeOf pointsTo ct))\n     ((fst \\<circ> tree.root) |`| cont (treeOf pointsTo ct))\n 2. \\<And>t'.\n       \\<lbrakk>t' |\\<in>| cont (treeOf pointsTo ct);\n        \\<not> local.wf t'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ct'.\n                            cwf ct' \\<and> t' = treeOf pointsTo ct'", "show \"effStep (root ?t) (fimage (fst \\<circ> root) (cont ?t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. effStep (tree.root (treeOf pointsTo ct))\n     ((fst \\<circ> tree.root) |`| cont (treeOf pointsTo ct))", "using pointsTo ct"], ["proof (prove)\nusing this:\n  \\<forall>l l'. pointsTo l \\<noteq> Link l'\n  cwf ct\n\ngoal (1 subgoal):\n 1. effStep (tree.root (treeOf pointsTo ct))\n     ((fst \\<circ> tree.root) |`| cont (treeOf pointsTo ct))", "by (auto  elim: cwf.cases split: ctree.splits simp: cwf_Link)"], ["proof (state)\nthis:\n  effStep (tree.root (treeOf pointsTo ct))\n   ((fst \\<circ> tree.root) |`| cont (treeOf pointsTo ct))\n\ngoal (1 subgoal):\n 1. \\<And>t'.\n       \\<lbrakk>t' |\\<in>| cont (treeOf pointsTo ct);\n        \\<not> local.wf t'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ct'.\n                            cwf ct' \\<and> t' = treeOf pointsTo ct'", "{"], ["proof (state)\nthis:\n  effStep (tree.root (treeOf pointsTo ct))\n   ((fst \\<circ> tree.root) |`| cont (treeOf pointsTo ct))\n\ngoal (1 subgoal):\n 1. \\<And>t'.\n       \\<lbrakk>t' |\\<in>| cont (treeOf pointsTo ct);\n        \\<not> local.wf t'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ct'.\n                            cwf ct' \\<and> t' = treeOf pointsTo ct'", "fix t'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t'.\n       \\<lbrakk>t' |\\<in>| cont (treeOf pointsTo ct);\n        \\<not> local.wf t'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ct'.\n                            cwf ct' \\<and> t' = treeOf pointsTo ct'", "assume t': \"t' |\\<in>| cont ?t\""], ["proof (state)\nthis:\n  t' |\\<in>| cont (treeOf pointsTo ct)\n\ngoal (1 subgoal):\n 1. \\<And>t'.\n       \\<lbrakk>t' |\\<in>| cont (treeOf pointsTo ct);\n        \\<not> local.wf t'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>ct'.\n                            cwf ct' \\<and> t' = treeOf pointsTo ct'", "show \"\\<exists>ct'. ?\\<phi> ct' t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ct'. cwf ct' \\<and> t' = treeOf pointsTo ct'", "proof(cases ct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       ct = Link x1 \\<Longrightarrow>\n       \\<exists>ct'. cwf ct' \\<and> t' = treeOf pointsTo ct'\n 2. \\<And>x21 x22.\n       ct = cNode x21 x22 \\<Longrightarrow>\n       \\<exists>ct'. cwf ct' \\<and> t' = treeOf pointsTo ct'", "case (Link l)"], ["proof (state)\nthis:\n  ct = Link l\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       ct = Link x1 \\<Longrightarrow>\n       \\<exists>ct'. cwf ct' \\<and> t' = treeOf pointsTo ct'\n 2. \\<And>x21 x22.\n       ct = cNode x21 x22 \\<Longrightarrow>\n       \\<exists>ct'. cwf ct' \\<and> t' = treeOf pointsTo ct'", "then"], ["proof (chain)\npicking this:\n  ct = Link l", "obtain s r cts where pl: \"pointsTo l = cNode (s,r) cts\""], ["proof (prove)\nusing this:\n  ct = Link l\n\ngoal (1 subgoal):\n 1. (\\<And>s r cts.\n        pointsTo l = cNode (s, r) cts \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using pointsTo"], ["proof (prove)\nusing this:\n  ct = Link l\n  \\<forall>l l'. pointsTo l \\<noteq> Link l'\n\ngoal (1 subgoal):\n 1. (\\<And>s r cts.\n        pointsTo l = cNode (s, r) cts \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"pointsTo l\") auto"], ["proof (state)\nthis:\n  pointsTo l = cNode (s, r) cts\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       ct = Link x1 \\<Longrightarrow>\n       \\<exists>ct'. cwf ct' \\<and> t' = treeOf pointsTo ct'\n 2. \\<And>x21 x22.\n       ct = cNode x21 x22 \\<Longrightarrow>\n       \\<exists>ct'. cwf ct' \\<and> t' = treeOf pointsTo ct'", "obtain ct' where ct': \"ct' |\\<in>| cts\" and \"t' = treeOf pointsTo ct'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ct'.\n        \\<lbrakk>ct' |\\<in>| cts; t' = treeOf pointsTo ct'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using t'"], ["proof (prove)\nusing this:\n  t' |\\<in>| cont (treeOf pointsTo ct)\n\ngoal (1 subgoal):\n 1. (\\<And>ct'.\n        \\<lbrakk>ct' |\\<in>| cts; t' = treeOf pointsTo ct'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Link pl pointsTo split: ctree.splits)"], ["proof (state)\nthis:\n  ct' |\\<in>| cts\n  t' = treeOf pointsTo ct'\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       ct = Link x1 \\<Longrightarrow>\n       \\<exists>ct'. cwf ct' \\<and> t' = treeOf pointsTo ct'\n 2. \\<And>x21 x22.\n       ct = cNode x21 x22 \\<Longrightarrow>\n       \\<exists>ct'. cwf ct' \\<and> t' = treeOf pointsTo ct'", "moreover"], ["proof (state)\nthis:\n  ct' |\\<in>| cts\n  t' = treeOf pointsTo ct'\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       ct = Link x1 \\<Longrightarrow>\n       \\<exists>ct'. cwf ct' \\<and> t' = treeOf pointsTo ct'\n 2. \\<And>x21 x22.\n       ct = cNode x21 x22 \\<Longrightarrow>\n       \\<exists>ct'. cwf ct' \\<and> t' = treeOf pointsTo ct'", "have \"cwf ct'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cwf ct'", "using ct' ct pl"], ["proof (prove)\nusing this:\n  ct' |\\<in>| cts\n  cwf ct\n  pointsTo l = cNode (s, r) cts\n\ngoal (1 subgoal):\n 1. cwf ct'", "unfolding Link"], ["proof (prove)\nusing this:\n  ct' |\\<in>| cts\n  cwf (Link l)\n  pointsTo l = cNode (s, r) cts\n\ngoal (1 subgoal):\n 1. cwf ct'", "by (auto simp: cwf_Link elim: cwf.cases)"], ["proof (state)\nthis:\n  cwf ct'\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       ct = Link x1 \\<Longrightarrow>\n       \\<exists>ct'. cwf ct' \\<and> t' = treeOf pointsTo ct'\n 2. \\<And>x21 x22.\n       ct = cNode x21 x22 \\<Longrightarrow>\n       \\<exists>ct'. cwf ct' \\<and> t' = treeOf pointsTo ct'", "ultimately"], ["proof (chain)\npicking this:\n  ct' |\\<in>| cts\n  t' = treeOf pointsTo ct'\n  cwf ct'", "show ?thesis"], ["proof (prove)\nusing this:\n  ct' |\\<in>| cts\n  t' = treeOf pointsTo ct'\n  cwf ct'\n\ngoal (1 subgoal):\n 1. \\<exists>ct'. cwf ct' \\<and> t' = treeOf pointsTo ct'", "by blast"], ["proof (state)\nthis:\n  \\<exists>ct'. cwf ct' \\<and> t' = treeOf pointsTo ct'\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       ct = cNode x21 x22 \\<Longrightarrow>\n       \\<exists>ct'. cwf ct' \\<and> t' = treeOf pointsTo ct'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       ct = cNode x21 x22 \\<Longrightarrow>\n       \\<exists>ct'. cwf ct' \\<and> t' = treeOf pointsTo ct'", "case (cNode step cts)"], ["proof (state)\nthis:\n  ct = cNode step cts\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       ct = cNode x21 x22 \\<Longrightarrow>\n       \\<exists>ct'. cwf ct' \\<and> t' = treeOf pointsTo ct'", "then"], ["proof (chain)\npicking this:\n  ct = cNode step cts", "obtain s r where cNode: \"ct = cNode (s,r) cts\""], ["proof (prove)\nusing this:\n  ct = cNode step cts\n\ngoal (1 subgoal):\n 1. (\\<And>s r.\n        ct = cNode (s, r) cts \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases step) auto"], ["proof (state)\nthis:\n  ct = cNode (s, r) cts\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       ct = cNode x21 x22 \\<Longrightarrow>\n       \\<exists>ct'. cwf ct' \\<and> t' = treeOf pointsTo ct'", "obtain ct' where ct': \"ct' |\\<in>| cts\" and \"t' = treeOf pointsTo ct'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>ct'.\n        \\<lbrakk>ct' |\\<in>| cts; t' = treeOf pointsTo ct'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using t'"], ["proof (prove)\nusing this:\n  t' |\\<in>| cont (treeOf pointsTo ct)\n\ngoal (1 subgoal):\n 1. (\\<And>ct'.\n        \\<lbrakk>ct' |\\<in>| cts; t' = treeOf pointsTo ct'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: cNode pointsTo split: ctree.splits)"], ["proof (state)\nthis:\n  ct' |\\<in>| cts\n  t' = treeOf pointsTo ct'\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       ct = cNode x21 x22 \\<Longrightarrow>\n       \\<exists>ct'. cwf ct' \\<and> t' = treeOf pointsTo ct'", "moreover"], ["proof (state)\nthis:\n  ct' |\\<in>| cts\n  t' = treeOf pointsTo ct'\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       ct = cNode x21 x22 \\<Longrightarrow>\n       \\<exists>ct'. cwf ct' \\<and> t' = treeOf pointsTo ct'", "have \"cwf ct'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cwf ct'", "using ct' ct"], ["proof (prove)\nusing this:\n  ct' |\\<in>| cts\n  cwf ct\n\ngoal (1 subgoal):\n 1. cwf ct'", "unfolding cNode"], ["proof (prove)\nusing this:\n  ct' |\\<in>| cts\n  cwf (cNode (s, r) cts)\n\ngoal (1 subgoal):\n 1. cwf ct'", "by (auto simp: cwf_Link elim: cwf.cases)"], ["proof (state)\nthis:\n  cwf ct'\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       ct = cNode x21 x22 \\<Longrightarrow>\n       \\<exists>ct'. cwf ct' \\<and> t' = treeOf pointsTo ct'", "ultimately"], ["proof (chain)\npicking this:\n  ct' |\\<in>| cts\n  t' = treeOf pointsTo ct'\n  cwf ct'", "show ?thesis"], ["proof (prove)\nusing this:\n  ct' |\\<in>| cts\n  t' = treeOf pointsTo ct'\n  cwf ct'\n\ngoal (1 subgoal):\n 1. \\<exists>ct'. cwf ct' \\<and> t' = treeOf pointsTo ct'", "by blast"], ["proof (state)\nthis:\n  \\<exists>ct'. cwf ct' \\<and> t' = treeOf pointsTo ct'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>ct'. cwf ct' \\<and> t' = treeOf pointsTo ct'\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  ?t'4 |\\<in>| cont (treeOf pointsTo ct) \\<Longrightarrow>\n  \\<exists>ct'. cwf ct' \\<and> ?t'4 = treeOf pointsTo ct'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>t.\n     treeOf pointsTo ct = t \\<and>\n     snd (tree.root t) \\<in> R \\<and>\n     effStep (tree.root t) ((fst \\<circ> tree.root) |`| cont t) \\<and>\n     (\\<forall>t'.\n         t' |\\<in>| cont t \\<longrightarrow>\n         (\\<exists>ct'. cwf ct' \\<and> t' = treeOf pointsTo ct') \\<or>\n         local.wf t')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.wf t\n\ngoal (1 subgoal):\n 1. local.wf (treeOf pointsTo ct)", "}"], ["proof (state)\nthis:\n  \\<exists>ct. cwf ct \\<and> ?t4 = treeOf pointsTo ct \\<Longrightarrow>\n  local.wf ?t4\n\ngoal (1 subgoal):\n 1. local.wf (treeOf pointsTo ct)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>ct. cwf ct \\<and> ?t4 = treeOf pointsTo ct \\<Longrightarrow>\n  local.wf ?t4\n\ngoal (1 subgoal):\n 1. local.wf (treeOf pointsTo ct)", "using assms"], ["proof (prove)\nusing this:\n  \\<exists>ct. cwf ct \\<and> ?t4 = treeOf pointsTo ct \\<Longrightarrow>\n  local.wf ?t4\n  cwf ct\n\ngoal (1 subgoal):\n 1. local.wf (treeOf pointsTo ct)", "by blast"], ["proof (state)\nthis:\n  local.wf (treeOf pointsTo ct)\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem cyclic_soundness:\n  assumes \"cwf ct\" and \"cgood ct\" and \"S \\<in> structure\"\n  shows \"sat S (seqOf ct)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sat S (seqOf ct)", "using infinite_soundness wf_treeOf assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>local.wf ?t; good ?t; ?S \\<in> structure\\<rbrakk>\n  \\<Longrightarrow> sat ?S (fst (tree.root ?t))\n  cwf ?ct \\<Longrightarrow> local.wf (treeOf pointsTo ?ct)\n  cwf ct\n  cgood ct\n  S \\<in> structure\n\ngoal (1 subgoal):\n 1. sat S (seqOf ct)", "unfolding cgood_def treeOf_seqOf[symmetric] comp_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>local.wf ?t; good ?t; ?S \\<in> structure\\<rbrakk>\n  \\<Longrightarrow> sat ?S (fst (tree.root ?t))\n  cwf ?ct \\<Longrightarrow> local.wf (treeOf pointsTo ?ct)\n  cwf ct\n  good (treeOf pointsTo ct)\n  S \\<in> structure\n\ngoal (1 subgoal):\n 1. sat S (fst (tree.root (treeOf pointsTo ct)))", "by blast"], ["", "end"], ["", "(* context *)"], ["", "end"], ["", "(* context Infinite_Soundness *)"], ["", "section \\<open>Appendix: The definition of treeOf under more flexible assumptions about pointsTo\\<close>"], ["", "definition rels where\n  \"rels pointsTo \\<equiv> {((pointsTo, pointsTo l'), (pointsTo, Link l')) | l'. True}\""], ["", "definition rel :: \"(('link \\<Rightarrow> ('sequent, 'rule, 'link) ctree) \\<times> ('sequent, 'rule, 'link) ctree) rel\" where\n  \"rel \\<equiv> \\<Union> (rels ` {pointsTo. wf {(l, l'). pointsTo l' = Link l}})\""], ["", "lemma wf_rels[simp]:\n  assumes \"wf {(l,l'). (pointsTo :: 'link \\<Rightarrow> ('sequent, 'rule, 'link)ctree) l' = Link l}\"\n    (is \"wf ?w\")\n  shows \"wf (rels pointsTo)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (rels pointsTo)", "using wf_map_prod_image"], ["proof (prove)\nusing this:\n  \\<lbrakk>wf ?r; inj ?f\\<rbrakk> \\<Longrightarrow> wf (map_prod ?f ?f ` ?r)\n\ngoal (1 subgoal):\n 1. wf (rels pointsTo)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>r f.\n        \\<lbrakk>wf r; inj f\\<rbrakk>\n        \\<Longrightarrow> wf (map_prod f f ` r)) \\<Longrightarrow>\n    wf (rels pointsTo)", "define r1 :: \"(('link \\<Rightarrow> ('sequent, 'rule, 'link) ctree) \\<times> ('sequent, 'rule, 'link) ctree) rel\" where\n    \"r1 = {((pointsTo,pointsTo l'), (pointsTo, Link l'::('sequent, 'rule, 'link) ctree)) | l'.\n                 (\\<forall>l''. pointsTo l' \\<noteq> Link l'')}\""], ["proof (state)\nthis:\n  r1 =\n  {((pointsTo, pointsTo l'), pointsTo, Link l') |l'.\n   \\<forall>l''. pointsTo l' \\<noteq> Link l''}\n\ngoal (1 subgoal):\n 1. (\\<And>r f.\n        \\<lbrakk>wf r; inj f\\<rbrakk>\n        \\<Longrightarrow> wf (map_prod f f ` r)) \\<Longrightarrow>\n    wf (rels pointsTo)", "define r2 :: \"(('link \\<Rightarrow> ('sequent, 'rule, 'link) ctree) \\<times> ('sequent, 'rule, 'link) ctree) rel\" where\n    \"r2 = image (map_prod (map_prod id Link) (map_prod id Link)) (inv_image ?w snd)\""], ["proof (state)\nthis:\n  r2 =\n  map_prod (map_prod id Link) (map_prod id Link) `\n  inv_image {(l, l'). pointsTo l' = Link l} snd\n\ngoal (1 subgoal):\n 1. (\\<And>r f.\n        \\<lbrakk>wf r; inj f\\<rbrakk>\n        \\<Longrightarrow> wf (map_prod f f ` r)) \\<Longrightarrow>\n    wf (rels pointsTo)", "have 0: \"rels pointsTo \\<subseteq> r1 \\<union> r2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rels pointsTo \\<subseteq> r1 \\<union> r2", "unfolding rels_def r1_def r2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {((pointsTo, pointsTo l'), pointsTo, Link l') |l'. True}\n    \\<subseteq> {((pointsTo, pointsTo l'), pointsTo, Link l') |l'.\n                 \\<forall>l''. pointsTo l' \\<noteq> Link l''} \\<union>\n                map_prod (map_prod id Link) (map_prod id Link) `\n                inv_image {(l, l'). pointsTo l' = Link l} snd", "unfolding inv_image_def image_Collect"], ["proof (prove)\ngoal (1 subgoal):\n 1. {((pointsTo, pointsTo l'), pointsTo, Link l') |l'. True}\n    \\<subseteq> {((pointsTo, pointsTo l'), pointsTo, Link l') |l'.\n                 \\<forall>l''. pointsTo l' \\<noteq> Link l''} \\<union>\n                {map_prod (map_prod id Link) (map_prod id Link) x |x.\n                 case x of\n                 (x, y) \\<Rightarrow>\n                   (snd x, snd y) \\<in> {(l, l'). pointsTo l' = Link l}}", "by auto"], ["proof (state)\nthis:\n  rels pointsTo \\<subseteq> r1 \\<union> r2\n\ngoal (1 subgoal):\n 1. (\\<And>r f.\n        \\<lbrakk>wf r; inj f\\<rbrakk>\n        \\<Longrightarrow> wf (map_prod f f ` r)) \\<Longrightarrow>\n    wf (rels pointsTo)", "let ?m = \"measure (\\<lambda>(tOfL,t). case t of Link l' => Suc 0 | _ => 0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>r f.\n        \\<lbrakk>wf r; inj f\\<rbrakk>\n        \\<Longrightarrow> wf (map_prod f f ` r)) \\<Longrightarrow>\n    wf (rels pointsTo)", "have 1: \"wf r1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf r1", "unfolding r1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf {((pointsTo, pointsTo l'), pointsTo, Link l') |l'.\n        \\<forall>l''. pointsTo l' \\<noteq> Link l''}", "by (rule wf_subset[of ?m]) (auto split: ctree.splits)"], ["proof (state)\nthis:\n  wf r1\n\ngoal (1 subgoal):\n 1. (\\<And>r f.\n        \\<lbrakk>wf r; inj f\\<rbrakk>\n        \\<Longrightarrow> wf (map_prod f f ` r)) \\<Longrightarrow>\n    wf (rels pointsTo)", "have 2: \"wf r2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf r2", "using assms"], ["proof (prove)\nusing this:\n  wf {(l, l'). pointsTo l' = Link l}\n\ngoal (1 subgoal):\n 1. wf r2", "unfolding r2_def"], ["proof (prove)\nusing this:\n  wf {(l, l'). pointsTo l' = Link l}\n\ngoal (1 subgoal):\n 1. wf (map_prod (map_prod id Link) (map_prod id Link) `\n        inv_image {(l, l'). pointsTo l' = Link l} snd)", "by (intro wf_map_prod_image wf_inv_image) (auto simp: inj_on_def)"], ["proof (state)\nthis:\n  wf r2\n\ngoal (1 subgoal):\n 1. (\\<And>r f.\n        \\<lbrakk>wf r; inj f\\<rbrakk>\n        \\<Longrightarrow> wf (map_prod f f ` r)) \\<Longrightarrow>\n    wf (rels pointsTo)", "have 3: \"Domain r1 \\<inter> Range r2 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Domain r1 \\<inter> Range r2 = {}", "unfolding r1_def r2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Domain\n     {((pointsTo, pointsTo l'), pointsTo, Link l') |l'.\n      \\<forall>l''. pointsTo l' \\<noteq> Link l''} \\<inter>\n    Range\n     (map_prod (map_prod id Link) (map_prod id Link) `\n      inv_image {(l, l'). pointsTo l' = Link l} snd) =\n    {}", "by auto"], ["proof (state)\nthis:\n  Domain r1 \\<inter> Range r2 = {}\n\ngoal (1 subgoal):\n 1. (\\<And>r f.\n        \\<lbrakk>wf r; inj f\\<rbrakk>\n        \\<Longrightarrow> wf (map_prod f f ` r)) \\<Longrightarrow>\n    wf (rels pointsTo)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (rels pointsTo)", "using 1 2 3"], ["proof (prove)\nusing this:\n  wf r1\n  wf r2\n  Domain r1 \\<inter> Range r2 = {}\n\ngoal (1 subgoal):\n 1. wf (rels pointsTo)", "by (intro wf_subset[OF _ 0] wf_Un) auto"], ["proof (state)\nthis:\n  wf (rels pointsTo)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma rel: \"wf rel\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf rel", "unfolding rel_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (\\<Union> (rels ` {pointsTo. wf {(l, l'). pointsTo l' = Link l}}))", "apply(rule wf_UN)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>i.\n       i \\<in> {pointsTo.\n                wf {(l, l'). pointsTo l' = Link l}} \\<Longrightarrow>\n       wf (rels i)\n 2. \\<And>i j.\n       \\<lbrakk>i \\<in> {pointsTo. wf {(l, l'). pointsTo l' = Link l}};\n        j \\<in> {pointsTo. wf {(l, l'). pointsTo l' = Link l}};\n        rels i \\<noteq> rels j\\<rbrakk>\n       \\<Longrightarrow> Domain (rels i) \\<inter> Range (rels j) = {}", "subgoal"], ["proof (prove)\ngoal (1 subgoal):\n 1. i_ \\<in> {pointsTo.\n              wf {(l, l'). pointsTo l' = Link l}} \\<Longrightarrow>\n    wf (rels i_)", "by (auto intro: wf_UN)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i \\<in> {pointsTo. wf {(l, l'). pointsTo l' = Link l}};\n        j \\<in> {pointsTo. wf {(l, l'). pointsTo l' = Link l}};\n        rels i \\<noteq> rels j\\<rbrakk>\n       \\<Longrightarrow> Domain (rels i) \\<inter> Range (rels j) = {}", "unfolding rels_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>i \\<in> {pointsTo. wf {(l, l'). pointsTo l' = Link l}};\n        j \\<in> {pointsTo. wf {(l, l'). pointsTo l' = Link l}};\n        {((i, i l'), i, Link l') |l'. True} \\<noteq>\n        {((j, j l'), j, Link l') |l'. True}\\<rbrakk>\n       \\<Longrightarrow> Domain {((i, i l'), i, Link l') |l'. True} \\<inter>\n                         Range {((j, j l'), j, Link l') |l'. True} =\n                         {}", "by auto"], ["", "corecursive treeOf' where\n  \"treeOf' pointsTo ct =\n   (if \\<not> wf {(l',l).  pointsTo l = Link l'}\n    \\<comment> \\<open>makes sense only if backward links point to normal nodes, not to backwards links:\\<close>\n     then undefined\n     else (case ct of\n             Link l \\<Rightarrow> treeOf' pointsTo (pointsTo l)\n            |cNode step cts \\<Rightarrow> Node step (fimage (treeOf' pointsTo) cts)\n          )\n   )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. All (Wellfounded.accp treeOf'_inner_fp_rel)", "apply(relation rel)"], ["proof (prove)\ngoal (2 subgoals):\n 1. wf rel\n 2. \\<And>pointsTo ct x y x1.\n       \\<lbrakk>(x, y) = (pointsTo, ct);\n        \\<not> \\<not> wf {(l', l). x l = Link l'}; y = Link x1\\<rbrakk>\n       \\<Longrightarrow> ((x, x x1), pointsTo, ct) \\<in> rel", "using rel"], ["proof (prove)\nusing this:\n  wf rel\n\ngoal (2 subgoals):\n 1. wf rel\n 2. \\<And>pointsTo ct x y x1.\n       \\<lbrakk>(x, y) = (pointsTo, ct);\n        \\<not> \\<not> wf {(l', l). x l = Link l'}; y = Link x1\\<rbrakk>\n       \\<Longrightarrow> ((x, x x1), pointsTo, ct) \\<in> rel", "unfolding rel_def rels_def[abs_def]"], ["proof (prove)\nusing this:\n  wf (\\<Union>pointsTo\\<in>{pointsTo. wf {(l, l'). pointsTo l' = Link l}}.\n         {((pointsTo, pointsTo l'), pointsTo, Link l') |l'. True})\n\ngoal (2 subgoals):\n 1. wf (\\<Union>pointsTo\\<in>{pointsTo. wf {(l, l'). pointsTo l' = Link l}}.\n           {((pointsTo, pointsTo l'), pointsTo, Link l') |l'. True})\n 2. \\<And>pointsTo ct x y x1.\n       \\<lbrakk>(x, y) = (pointsTo, ct);\n        \\<not> \\<not> wf {(l', l). x l = Link l'}; y = Link x1\\<rbrakk>\n       \\<Longrightarrow> ((x, x x1), pointsTo, ct)\n                         \\<in> (\\<Union>pointsTo\\<in>{pointsTo.\n                wf {(l, l'). pointsTo l' = Link l}}.\n                                   {((pointsTo, pointsTo l'), pointsTo,\n                                     Link l') |\n                                    l'. True})", "by auto"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}