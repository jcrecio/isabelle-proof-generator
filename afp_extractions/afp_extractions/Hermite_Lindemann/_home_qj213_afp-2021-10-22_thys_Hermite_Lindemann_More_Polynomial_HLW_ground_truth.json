{"file_name": "/home/qj213/afp-2021-10-22/thys/Hermite_Lindemann/More_Polynomial_HLW.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Hermite_Lindemann", "problem_names": ["lemma lead_coeff_prod_mset:\n  fixes A :: \"'a::{comm_semiring_1, semiring_no_zero_divisors} poly multiset\"\n  shows \"Polynomial.lead_coeff (prod_mset A) = prod_mset (image_mset Polynomial.lead_coeff A)\"", "lemma content_normalize [simp]:\n  fixes p :: \"'a :: {factorial_semiring, idom_divide, semiring_gcd, normalization_semidom_multiplicative} poly\"\n  shows \"content (normalize p) = content p\"", "lemma rat_to_normalized_int_poly_exists:\n  fixes p :: \"rat poly\"\n  assumes \"p \\<noteq> 0\"\n  obtains q lc where \"p = Polynomial.smult lc (of_int_poly q)\" \"lc > 0\" \"content q = 1\"", "lemma irreducible_imp_squarefree:\n  assumes \"irreducible p\"\n  shows   \"squarefree p\"", "lemma squarefree_imp_rsquarefree:\n  fixes p :: \"'a :: idom poly\"\n  assumes \"squarefree p\"\n  shows   \"rsquarefree p\"", "lemma squarefree_imp_coprime_pderiv:\n  fixes p :: \"'a :: {factorial_ring_gcd,semiring_gcd_mult_normalize,semiring_char_0} poly\"\n  assumes \"squarefree p\" and \"content p = 1\"\n  shows   \"Rings.coprime p (pderiv p)\"", "lemma irreducible_imp_coprime_pderiv:\n  fixes p :: \"'a :: {idom_divide,semiring_char_0} poly\"\n  assumes \"irreducible p\" \"Polynomial.degree p \\<noteq> 0\"\n  shows   \"Rings.coprime p (pderiv p)\"", "lemma poly_gcd_eq_0I:\n  assumes \"poly p x = 0\" \"poly q x = 0\"\n  shows   \"poly (gcd p q) x = 0\"", "lemma poly_eq_0_coprime:\n  assumes \"Rings.coprime p q\" \"p \\<noteq> 0\" \"q \\<noteq> 0\"\n  shows   \"poly p x \\<noteq> 0 \\<or> poly q x \\<noteq> 0\"", "lemma coprime_of_int_polyI:\n  assumes \"Rings.coprime p q\"\n  shows   \"Rings.coprime (of_int_poly p) (of_int_poly q :: 'a :: {field_char_0,field_gcd} poly)\"", "lemma irreducible_imp_rsquarefree_of_int_poly:\n  fixes p :: \"int poly\"\n  assumes \"irreducible p\" and \"Polynomial.degree p > 0\"\n  shows   \"rsquarefree (of_int_poly p :: 'a :: {field_gcd, field_char_0} poly)\"", "lemma squarefree_of_int_polyI:\n  assumes \"squarefree p\" \"content p = 1\"\n  shows   \"squarefree (of_int_poly p :: 'a :: {field_char_0,field_gcd} poly)\"", "lemma higher_pderiv_pcompose_linear:\n   \"(pderiv ^^ n) (pcompose p [:0, c:]) =\n    Polynomial.smult (c ^ n) (pcompose ((pderiv ^^ n) p) [:0, c:])\"", "lemma poly_poly_eq:\n  \"poly (poly p [:x:]) y = poly (eval_poly (\\<lambda>p. [:poly p y:]) p [:0, 1:]) x\"", "lemma poly_poly_poly_y_x [simp]:\n  fixes p :: \"'a :: idom poly poly\"\n  shows \"poly (poly (poly_y_x p) [:y:]) x = poly (poly p [:x:]) y\"", "lemma (in idom_hom) map_poly_higher_pderiv [hom_distribs]:\n  \"map_poly hom ((pderiv ^^ n) p) = (pderiv ^^ n) (map_poly hom p)\"", "lemma coeff_prod_linear_factors:\n  fixes f :: \"'a \\<Rightarrow> 'b :: comm_ring_1\"\n  assumes [intro]: \"finite A\"\n  shows \"Polynomial.coeff (\\<Prod>x\\<in>A. [:-f x, 1:] ^ e x) i =\n           (\\<Sum>X | X \\<in> Pow (SIGMA x:A. {..<e x}) \\<and> i = sum e A - card X.\n             (-1) ^ card X * (\\<Prod>x\\<in>X. f (fst x)))\"", "lemma (in comm_ring_hom) synthetic_div_hom:\n  \"synthetic_div (map_poly hom p) (hom x) = map_poly hom (synthetic_div p x)\"", "lemma synthetic_div_altdef:\n  fixes p :: \"'a :: field poly\"\n  shows \"synthetic_div p c = p div [:-c, 1:]\"", "lemma (in ring_closed) poly_closed [intro]:\n  assumes \"\\<And>i. poly.coeff p i \\<in> A\" \"x \\<in> A\"\n  shows   \"poly p x \\<in> A\"", "lemma (in ring_closed) coeff_pCons_closed [intro]:\n  assumes \"\\<And>i. poly.coeff p i \\<in> A\" \"x \\<in> A\"\n  shows   \"poly.coeff (pCons x p) i \\<in> A\"", "lemma (in ring_closed) coeff_poly_mult_closed [intro]:\n  assumes \"\\<And>i. poly.coeff p i \\<in> A\" \"\\<And>i. poly.coeff q i \\<in> A\"\n  shows   \"poly.coeff (p * q) i \\<in> A\"", "lemma (in ring_closed) coeff_poly_prod_closed [intro]:\n  assumes \"\\<And>x i. x \\<in> X \\<Longrightarrow> poly.coeff (f x) i \\<in> A\"\n  shows   \"poly.coeff (prod f X) i \\<in> A\"", "lemma (in ring_closed) coeff_poly_power_closed [intro]:\n  assumes \"\\<And>i. poly.coeff p i \\<in> A\"\n  shows   \"poly.coeff (p ^ n) i \\<in> A\"", "lemma (in ring_closed) synthetic_div_closed:\n  assumes \"\\<And>i. poly.coeff p i \\<in> A\" \"x \\<in> A\"\n  shows   \"poly.coeff (synthetic_div p x) i \\<in> A\"", "lemma pcompose_monom: \"pcompose (Polynomial.monom c n) p = Polynomial.smult c (p ^ n)\"", "lemma poly_roots_uminus [simp]: \"poly_roots (-p) = poly_roots p\"", "lemma poly_roots_normalize [simp]:\n  fixes p :: \"'a :: {normalization_semidom, idom_divide} poly\"\n  shows \"poly_roots (normalize p) = poly_roots p\"", "lemma poly_roots_of_int_normalize [simp]:\n  \"poly_roots (of_int_poly (normalize p) :: 'a :: {idom, ring_char_0} poly) =\n   poly_roots (of_int_poly p)\"", "lemma poly_roots_power [simp]: \"poly_roots (p ^ n) = repeat_mset n (poly_roots p)\"", "lemma poly_roots_conv_sum_prime_factors:\n  \"poly_roots q = (\\<Sum>p\\<in>#prime_factorization q. poly_roots p)\"", "lemma poly_roots_of_int_conv_sum_prime_factors:\n  \"poly_roots (of_int_poly q :: 'a :: {idom, ring_char_0} poly) =\n   (\\<Sum>p\\<in>#prime_factorization q. poly_roots (of_int_poly p))\"", "lemma dvd_imp_poly_roots_subset:\n  assumes \"q \\<noteq> 0\" \"p dvd q\"\n  shows   \"poly_roots p \\<subseteq># poly_roots q\"", "lemma abs_prod_mset: \"\\<bar>prod_mset (A :: 'a :: idom_abs_sgn multiset)\\<bar> = prod_mset (image_mset abs A)\"", "lemma content_1_imp_nonconstant_prime_factors:\n  assumes \"content (p :: int poly) = 1\" and \"q \\<in> prime_factors p\"\n  shows   \"Polynomial.degree q > 0\""], "translations": [["", "lemma lead_coeff_prod_mset:\n  fixes A :: \"'a::{comm_semiring_1, semiring_no_zero_divisors} poly multiset\"\n  shows \"Polynomial.lead_coeff (prod_mset A) = prod_mset (image_mset Polynomial.lead_coeff A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.lead_coeff (\\<Prod>\\<^sub># A) =\n    \\<Prod>\\<^sub># (image_mset Polynomial.lead_coeff A)", "by (induction A) (auto simp: Polynomial.lead_coeff_mult)"], ["", "lemma content_normalize [simp]:\n  fixes p :: \"'a :: {factorial_semiring, idom_divide, semiring_gcd, normalization_semidom_multiplicative} poly\"\n  shows \"content (normalize p) = content p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. content (normalize p) = content p", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> content (normalize p) = content p\n 2. p \\<noteq> 0 \\<Longrightarrow> content (normalize p) = content p", "case [simp]: False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> content (normalize p) = content p\n 2. p \\<noteq> 0 \\<Longrightarrow> content (normalize p) = content p", "have \"content p = content (unit_factor p * normalize p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. content p = content (unit_factor p * normalize p)", "by simp"], ["proof (state)\nthis:\n  content p = content (unit_factor p * normalize p)\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> content (normalize p) = content p\n 2. p \\<noteq> 0 \\<Longrightarrow> content (normalize p) = content p", "also"], ["proof (state)\nthis:\n  content p = content (unit_factor p * normalize p)\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> content (normalize p) = content p\n 2. p \\<noteq> 0 \\<Longrightarrow> content (normalize p) = content p", "have \"\\<dots> = content (unit_factor p) * content (normalize p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. content (unit_factor p * normalize p) =\n    content (unit_factor p) * content (normalize p)", "by (rule content_mult)"], ["proof (state)\nthis:\n  content (unit_factor p * normalize p) =\n  content (unit_factor p) * content (normalize p)\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> content (normalize p) = content p\n 2. p \\<noteq> 0 \\<Longrightarrow> content (normalize p) = content p", "also"], ["proof (state)\nthis:\n  content (unit_factor p * normalize p) =\n  content (unit_factor p) * content (normalize p)\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> content (normalize p) = content p\n 2. p \\<noteq> 0 \\<Longrightarrow> content (normalize p) = content p", "have \"content (unit_factor p) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. content (unit_factor p) = (1::'a)", "by (auto simp: unit_factor_poly_def)"], ["proof (state)\nthis:\n  content (unit_factor p) = (1::'a)\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> content (normalize p) = content p\n 2. p \\<noteq> 0 \\<Longrightarrow> content (normalize p) = content p", "finally"], ["proof (chain)\npicking this:\n  content p = (1::'a) * content (normalize p)", "show ?thesis"], ["proof (prove)\nusing this:\n  content p = (1::'a) * content (normalize p)\n\ngoal (1 subgoal):\n 1. content (normalize p) = content p", "by simp"], ["proof (state)\nthis:\n  content (normalize p) = content p\n\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow> content (normalize p) = content p", "qed auto"], ["", "lemma rat_to_normalized_int_poly_exists:\n  fixes p :: \"rat poly\"\n  assumes \"p \\<noteq> 0\"\n  obtains q lc where \"p = Polynomial.smult lc (of_int_poly q)\" \"lc > 0\" \"content q = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>lc q.\n        \\<lbrakk>p = Polynomial.smult lc (of_int_poly q); 0 < lc;\n         content q = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>lc q.\n        \\<lbrakk>p = Polynomial.smult lc (of_int_poly q); 0 < lc;\n         content q = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define lc where \"lc = fst (rat_to_normalized_int_poly p)\""], ["proof (state)\nthis:\n  lc = fst (rat_to_normalized_int_poly p)\n\ngoal (1 subgoal):\n 1. (\\<And>lc q.\n        \\<lbrakk>p = Polynomial.smult lc (of_int_poly q); 0 < lc;\n         content q = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define q where \"q = snd (rat_to_normalized_int_poly p)\""], ["proof (state)\nthis:\n  q = snd (rat_to_normalized_int_poly p)\n\ngoal (1 subgoal):\n 1. (\\<And>lc q.\n        \\<lbrakk>p = Polynomial.smult lc (of_int_poly q); 0 < lc;\n         content q = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have eq: \"rat_to_normalized_int_poly p = (lc, q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_to_normalized_int_poly p = (lc, q)", "by (simp add: lc_def q_def)"], ["proof (state)\nthis:\n  rat_to_normalized_int_poly p = (lc, q)\n\ngoal (1 subgoal):\n 1. (\\<And>lc q.\n        \\<lbrakk>p = Polynomial.smult lc (of_int_poly q); 0 < lc;\n         content q = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. thesis", "using rat_to_normalized_int_poly[OF eq] assms"], ["proof (prove)\nusing this:\n  p = Polynomial.smult lc (of_int_poly q)\n  0 < lc\n  p \\<noteq> 0 \\<Longrightarrow> content q = 1\n  Polynomial.degree q = Polynomial.degree p\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. thesis", "by (intro that[of lc q]) auto"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma irreducible_imp_squarefree:\n  assumes \"irreducible p\"\n  shows   \"squarefree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. squarefree p", "proof (rule squarefreeI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x\\<^sup>2 dvd p \\<Longrightarrow> x dvd (1::'a)", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x\\<^sup>2 dvd p \\<Longrightarrow> x dvd (1::'a)", "assume \"q ^ 2 dvd p\""], ["proof (state)\nthis:\n  q\\<^sup>2 dvd p\n\ngoal (1 subgoal):\n 1. \\<And>x. x\\<^sup>2 dvd p \\<Longrightarrow> x dvd (1::'a)", "then"], ["proof (chain)\npicking this:\n  q\\<^sup>2 dvd p", "obtain r where qr: \"p = q ^ 2 * r\""], ["proof (prove)\nusing this:\n  q\\<^sup>2 dvd p\n\ngoal (1 subgoal):\n 1. (\\<And>r. p = q\\<^sup>2 * r \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (elim dvdE)"], ["proof (state)\nthis:\n  p = q\\<^sup>2 * r\n\ngoal (1 subgoal):\n 1. \\<And>x. x\\<^sup>2 dvd p \\<Longrightarrow> x dvd (1::'a)", "have \"q dvd 1 \\<or> q * r dvd 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q dvd (1::'a) \\<or> q * r dvd (1::'a)", "by (intro irreducibleD[OF assms]) (use qr in \\<open>simp_all add: power2_eq_square mult_ac\\<close>)"], ["proof (state)\nthis:\n  q dvd (1::'a) \\<or> q * r dvd (1::'a)\n\ngoal (1 subgoal):\n 1. \\<And>x. x\\<^sup>2 dvd p \\<Longrightarrow> x dvd (1::'a)", "thus \"q dvd 1\""], ["proof (prove)\nusing this:\n  q dvd (1::'a) \\<or> q * r dvd (1::'a)\n\ngoal (1 subgoal):\n 1. q dvd (1::'a)", "by (meson dvd_mult_left)"], ["proof (state)\nthis:\n  q dvd (1::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma squarefree_imp_rsquarefree:\n  fixes p :: \"'a :: idom poly\"\n  assumes \"squarefree p\"\n  shows   \"rsquarefree p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rsquarefree p", "unfolding rsquarefree_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<and>\n    (\\<forall>a. Polynomial.order a p = 0 \\<or> Polynomial.order a p = 1)", "proof (intro conjI allI)"], ["proof (state)\ngoal (2 subgoals):\n 1. p \\<noteq> 0\n 2. \\<And>a. Polynomial.order a p = 0 \\<or> Polynomial.order a p = 1", "fix x :: 'a"], ["proof (state)\ngoal (2 subgoals):\n 1. p \\<noteq> 0\n 2. \\<And>a. Polynomial.order a p = 0 \\<or> Polynomial.order a p = 1", "have \"Polynomial.order x p < 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.order x p < 2", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> Polynomial.order x p < 2 \\<Longrightarrow> False", "assume \"\\<not>(Polynomial.order x p < 2)\""], ["proof (state)\nthis:\n  \\<not> Polynomial.order x p < 2\n\ngoal (1 subgoal):\n 1. \\<not> Polynomial.order x p < 2 \\<Longrightarrow> False", "hence \"[:-x, 1:] ^ 2 dvd p\""], ["proof (prove)\nusing this:\n  \\<not> Polynomial.order x p < 2\n\ngoal (1 subgoal):\n 1. [:- x, 1::'a:]\\<^sup>2 dvd p", "by (subst order_divides) auto"], ["proof (state)\nthis:\n  [:- x, 1::'a:]\\<^sup>2 dvd p\n\ngoal (1 subgoal):\n 1. \\<not> Polynomial.order x p < 2 \\<Longrightarrow> False", "from assms and this"], ["proof (chain)\npicking this:\n  squarefree p\n  [:- x, 1::'a:]\\<^sup>2 dvd p", "have \"[:-x, 1:] dvd 1\""], ["proof (prove)\nusing this:\n  squarefree p\n  [:- x, 1::'a:]\\<^sup>2 dvd p\n\ngoal (1 subgoal):\n 1. [:- x, 1::'a:] dvd 1", "by (rule squarefreeD)"], ["proof (state)\nthis:\n  [:- x, 1::'a:] dvd 1\n\ngoal (1 subgoal):\n 1. \\<not> Polynomial.order x p < 2 \\<Longrightarrow> False", "hence \"Polynomial.degree [:-x, 1:] \\<le> Polynomial.degree (1 :: 'a poly)\""], ["proof (prove)\nusing this:\n  [:- x, 1::'a:] dvd 1\n\ngoal (1 subgoal):\n 1. Polynomial.degree [:- x, 1::'a:] \\<le> Polynomial.degree 1", "by (rule dvd_imp_degree_le) auto"], ["proof (state)\nthis:\n  Polynomial.degree [:- x, 1::'a:] \\<le> Polynomial.degree 1\n\ngoal (1 subgoal):\n 1. \\<not> Polynomial.order x p < 2 \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  Polynomial.degree [:- x, 1::'a:] \\<le> Polynomial.degree 1\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Polynomial.order x p < 2\n\ngoal (2 subgoals):\n 1. p \\<noteq> 0\n 2. \\<And>a. Polynomial.order a p = 0 \\<or> Polynomial.order a p = 1", "thus \"Polynomial.order x p = 0 \\<or> Polynomial.order x p = 1\""], ["proof (prove)\nusing this:\n  Polynomial.order x p < 2\n\ngoal (1 subgoal):\n 1. Polynomial.order x p = 0 \\<or> Polynomial.order x p = 1", "by linarith"], ["proof (state)\nthis:\n  Polynomial.order x p = 0 \\<or> Polynomial.order x p = 1\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "qed (use assms in auto)"], ["", "lemma squarefree_imp_coprime_pderiv:\n  fixes p :: \"'a :: {factorial_ring_gcd,semiring_gcd_mult_normalize,semiring_char_0} poly\"\n  assumes \"squarefree p\" and \"content p = 1\"\n  shows   \"Rings.coprime p (pderiv p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime p (pderiv p)", "proof (rule coprimeI_primes)"], ["proof (state)\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<or> pderiv p \\<noteq> 0\n 2. \\<And>pa.\n       \\<lbrakk>prime pa; pa dvd p; pa dvd pderiv p\\<rbrakk>\n       \\<Longrightarrow> False", "fix d"], ["proof (state)\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<or> pderiv p \\<noteq> 0\n 2. \\<And>pa.\n       \\<lbrakk>prime pa; pa dvd p; pa dvd pderiv p\\<rbrakk>\n       \\<Longrightarrow> False", "assume d: \"prime d\" \"d dvd p\" \"d dvd pderiv p\""], ["proof (state)\nthis:\n  prime d\n  d dvd p\n  d dvd pderiv p\n\ngoal (2 subgoals):\n 1. p \\<noteq> 0 \\<or> pderiv p \\<noteq> 0\n 2. \\<And>pa.\n       \\<lbrakk>prime pa; pa dvd p; pa dvd pderiv p\\<rbrakk>\n       \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases \"Polynomial.degree d = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Polynomial.degree d = 0 \\<Longrightarrow> False\n 2. Polynomial.degree d \\<noteq> 0 \\<Longrightarrow> False", "case deg: False"], ["proof (state)\nthis:\n  Polynomial.degree d \\<noteq> 0\n\ngoal (2 subgoals):\n 1. Polynomial.degree d = 0 \\<Longrightarrow> False\n 2. Polynomial.degree d \\<noteq> 0 \\<Longrightarrow> False", "obtain q where dq: \"p = d * q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q. p = d * q \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using d"], ["proof (prove)\nusing this:\n  prime d\n  d dvd p\n  d dvd pderiv p\n\ngoal (1 subgoal):\n 1. (\\<And>q. p = d * q \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (elim dvdE)"], ["proof (state)\nthis:\n  p = d * q\n\ngoal (2 subgoals):\n 1. Polynomial.degree d = 0 \\<Longrightarrow> False\n 2. Polynomial.degree d \\<noteq> 0 \\<Longrightarrow> False", "have \\<open>d dvd q * pderiv d\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. d dvd q * pderiv d", "using d"], ["proof (prove)\nusing this:\n  prime d\n  d dvd p\n  d dvd pderiv p\n\ngoal (1 subgoal):\n 1. d dvd q * pderiv d", "by (simp add: dq pderiv_mult dvd_add_right_iff)"], ["proof (state)\nthis:\n  d dvd q * pderiv d\n\ngoal (2 subgoals):\n 1. Polynomial.degree d = 0 \\<Longrightarrow> False\n 2. Polynomial.degree d \\<noteq> 0 \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  d dvd q * pderiv d\n\ngoal (2 subgoals):\n 1. Polynomial.degree d = 0 \\<Longrightarrow> False\n 2. Polynomial.degree d \\<noteq> 0 \\<Longrightarrow> False", "have \"\\<not>d dvd pderiv d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> d dvd pderiv d", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. d dvd pderiv d \\<Longrightarrow> False", "assume \"d dvd pderiv d\""], ["proof (state)\nthis:\n  d dvd pderiv d\n\ngoal (1 subgoal):\n 1. d dvd pderiv d \\<Longrightarrow> False", "hence \"Polynomial.degree d \\<le> Polynomial.degree (pderiv d)\""], ["proof (prove)\nusing this:\n  d dvd pderiv d\n\ngoal (1 subgoal):\n 1. Polynomial.degree d \\<le> Polynomial.degree (pderiv d)", "using d deg"], ["proof (prove)\nusing this:\n  d dvd pderiv d\n  prime d\n  d dvd p\n  d dvd pderiv p\n  Polynomial.degree d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Polynomial.degree d \\<le> Polynomial.degree (pderiv d)", "by (intro dvd_imp_degree_le) (auto simp: pderiv_eq_0_iff)"], ["proof (state)\nthis:\n  Polynomial.degree d \\<le> Polynomial.degree (pderiv d)\n\ngoal (1 subgoal):\n 1. d dvd pderiv d \\<Longrightarrow> False", "hence \"Polynomial.degree d = 0\""], ["proof (prove)\nusing this:\n  Polynomial.degree d \\<le> Polynomial.degree (pderiv d)\n\ngoal (1 subgoal):\n 1. Polynomial.degree d = 0", "by (subst (asm) degree_pderiv) auto"], ["proof (state)\nthis:\n  Polynomial.degree d = 0\n\ngoal (1 subgoal):\n 1. d dvd pderiv d \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  Polynomial.degree d = 0\n\ngoal (1 subgoal):\n 1. False", "using deg"], ["proof (prove)\nusing this:\n  Polynomial.degree d = 0\n  Polynomial.degree d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> d dvd pderiv d\n\ngoal (2 subgoals):\n 1. Polynomial.degree d = 0 \\<Longrightarrow> False\n 2. Polynomial.degree d \\<noteq> 0 \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  d dvd q * pderiv d\n  \\<not> d dvd pderiv d", "have \"d dvd q\""], ["proof (prove)\nusing this:\n  d dvd q * pderiv d\n  \\<not> d dvd pderiv d\n\ngoal (1 subgoal):\n 1. d dvd q", "using d(1)"], ["proof (prove)\nusing this:\n  d dvd q * pderiv d\n  \\<not> d dvd pderiv d\n  prime d\n\ngoal (1 subgoal):\n 1. d dvd q", "by (simp add: prime_dvd_mult_iff)"], ["proof (state)\nthis:\n  d dvd q\n\ngoal (2 subgoals):\n 1. Polynomial.degree d = 0 \\<Longrightarrow> False\n 2. Polynomial.degree d \\<noteq> 0 \\<Longrightarrow> False", "hence \"d ^ 2 dvd p\""], ["proof (prove)\nusing this:\n  d dvd q\n\ngoal (1 subgoal):\n 1. d\\<^sup>2 dvd p", "by (auto simp: dq power2_eq_square)"], ["proof (state)\nthis:\n  d\\<^sup>2 dvd p\n\ngoal (2 subgoals):\n 1. Polynomial.degree d = 0 \\<Longrightarrow> False\n 2. Polynomial.degree d \\<noteq> 0 \\<Longrightarrow> False", "from assms(1) and this"], ["proof (chain)\npicking this:\n  squarefree p\n  d\\<^sup>2 dvd p", "have \"is_unit d\""], ["proof (prove)\nusing this:\n  squarefree p\n  d\\<^sup>2 dvd p\n\ngoal (1 subgoal):\n 1. is_unit d", "by (rule squarefreeD)"], ["proof (state)\nthis:\n  is_unit d\n\ngoal (2 subgoals):\n 1. Polynomial.degree d = 0 \\<Longrightarrow> False\n 2. Polynomial.degree d \\<noteq> 0 \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  is_unit d\n\ngoal (1 subgoal):\n 1. False", "using \\<open>prime d\\<close>"], ["proof (prove)\nusing this:\n  is_unit d\n  prime d\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. Polynomial.degree d = 0 \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Polynomial.degree d = 0 \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  Polynomial.degree d = 0\n\ngoal (1 subgoal):\n 1. Polynomial.degree d = 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  Polynomial.degree d = 0", "obtain d' where [simp]: \"d = [:d':]\""], ["proof (prove)\nusing this:\n  Polynomial.degree d = 0\n\ngoal (1 subgoal):\n 1. (\\<And>d'. d = [:d':] \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (elim degree_eq_zeroE)"], ["proof (state)\nthis:\n  d = [:d':]\n\ngoal (1 subgoal):\n 1. Polynomial.degree d = 0 \\<Longrightarrow> False", "from d"], ["proof (chain)\npicking this:\n  prime d\n  d dvd p\n  d dvd pderiv p", "have \"d' dvd content p\""], ["proof (prove)\nusing this:\n  prime d\n  d dvd p\n  d dvd pderiv p\n\ngoal (1 subgoal):\n 1. d' dvd content p", "by (simp add: const_poly_dvd_iff_dvd_content)"], ["proof (state)\nthis:\n  d' dvd content p\n\ngoal (1 subgoal):\n 1. Polynomial.degree d = 0 \\<Longrightarrow> False", "with assms and prime_imp_prime_elem[OF \\<open>prime d\\<close>]"], ["proof (chain)\npicking this:\n  squarefree p\n  content p = (1::'a)\n  prime_elem d\n  d' dvd content p", "show False"], ["proof (prove)\nusing this:\n  squarefree p\n  content p = (1::'a)\n  prime_elem d\n  d' dvd content p\n\ngoal (1 subgoal):\n 1. False", "by (auto simp: prime_elem_const_poly_iff)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<or> pderiv p \\<noteq> 0", "qed (use assms in auto)"], ["", "lemma irreducible_imp_coprime_pderiv:\n  fixes p :: \"'a :: {idom_divide,semiring_char_0} poly\"\n  assumes \"irreducible p\" \"Polynomial.degree p \\<noteq> 0\"\n  shows   \"Rings.coprime p (pderiv p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime p (pderiv p)", "proof (rule Rings.coprimeI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>c dvd p; c dvd pderiv p\\<rbrakk> \\<Longrightarrow> is_unit c", "fix d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>c dvd p; c dvd pderiv p\\<rbrakk> \\<Longrightarrow> is_unit c", "assume d: \"d dvd p\" \"d dvd pderiv p\""], ["proof (state)\nthis:\n  d dvd p\n  d dvd pderiv p\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>c dvd p; c dvd pderiv p\\<rbrakk> \\<Longrightarrow> is_unit c", "obtain q where dq: \"p = d * q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>q. p = d * q \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using d"], ["proof (prove)\nusing this:\n  d dvd p\n  d dvd pderiv p\n\ngoal (1 subgoal):\n 1. (\\<And>q. p = d * q \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (elim dvdE)"], ["proof (state)\nthis:\n  p = d * q\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>c dvd p; c dvd pderiv p\\<rbrakk> \\<Longrightarrow> is_unit c", "have \"is_unit d \\<or> is_unit q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit d \\<or> is_unit q", "using assms dq"], ["proof (prove)\nusing this:\n  irreducible p\n  Polynomial.degree p \\<noteq> 0\n  p = d * q\n\ngoal (1 subgoal):\n 1. is_unit d \\<or> is_unit q", "by (auto simp: irreducible_def)"], ["proof (state)\nthis:\n  is_unit d \\<or> is_unit q\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       \\<lbrakk>c dvd p; c dvd pderiv p\\<rbrakk> \\<Longrightarrow> is_unit c", "thus \"is_unit d\""], ["proof (prove)\nusing this:\n  is_unit d \\<or> is_unit q\n\ngoal (1 subgoal):\n 1. is_unit d", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. is_unit d \\<Longrightarrow> is_unit d\n 2. is_unit q \\<Longrightarrow> is_unit d", "assume unit: \"is_unit q\""], ["proof (state)\nthis:\n  is_unit q\n\ngoal (2 subgoals):\n 1. is_unit d \\<Longrightarrow> is_unit d\n 2. is_unit q \\<Longrightarrow> is_unit d", "with d"], ["proof (chain)\npicking this:\n  d dvd p\n  d dvd pderiv p\n  is_unit q", "have \"p dvd pderiv p\""], ["proof (prove)\nusing this:\n  d dvd p\n  d dvd pderiv p\n  is_unit q\n\ngoal (1 subgoal):\n 1. p dvd pderiv p", "using algebraic_semidom_class.mult_unit_dvd_iff dq"], ["proof (prove)\nusing this:\n  d dvd p\n  d dvd pderiv p\n  is_unit q\n  is_unit ?b \\<Longrightarrow> (?a * ?b dvd ?c) = (?a dvd ?c)\n  p = d * q\n\ngoal (1 subgoal):\n 1. p dvd pderiv p", "by blast"], ["proof (state)\nthis:\n  p dvd pderiv p\n\ngoal (2 subgoals):\n 1. is_unit d \\<Longrightarrow> is_unit d\n 2. is_unit q \\<Longrightarrow> is_unit d", "hence \"Polynomial.degree p = 0\""], ["proof (prove)\nusing this:\n  p dvd pderiv p\n\ngoal (1 subgoal):\n 1. Polynomial.degree p = 0", "by (meson not_dvd_pderiv)"], ["proof (state)\nthis:\n  Polynomial.degree p = 0\n\ngoal (2 subgoals):\n 1. is_unit d \\<Longrightarrow> is_unit d\n 2. is_unit q \\<Longrightarrow> is_unit d", "with assms(2)"], ["proof (chain)\npicking this:\n  Polynomial.degree p \\<noteq> 0\n  Polynomial.degree p = 0", "show ?thesis"], ["proof (prove)\nusing this:\n  Polynomial.degree p \\<noteq> 0\n  Polynomial.degree p = 0\n\ngoal (1 subgoal):\n 1. is_unit d", "by contradiction"], ["proof (state)\nthis:\n  is_unit d\n\ngoal (1 subgoal):\n 1. is_unit d \\<Longrightarrow> is_unit d", "qed"], ["proof (state)\nthis:\n  is_unit d\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_gcd_eq_0I:\n  assumes \"poly p x = 0\" \"poly q x = 0\"\n  shows   \"poly (gcd p q) x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (gcd p q) x = (0::'a)", "using assms"], ["proof (prove)\nusing this:\n  poly p x = (0::'a)\n  poly q x = (0::'a)\n\ngoal (1 subgoal):\n 1. poly (gcd p q) x = (0::'a)", "by (simp add: poly_eq_0_iff_dvd)"], ["", "lemma poly_eq_0_coprime:\n  assumes \"Rings.coprime p q\" \"p \\<noteq> 0\" \"q \\<noteq> 0\"\n  shows   \"poly p x \\<noteq> 0 \\<or> poly q x \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p x \\<noteq> (0::'a) \\<or> poly q x \\<noteq> (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly p x \\<noteq> (0::'a) \\<or> poly q x \\<noteq> (0::'a)", "have False if \"poly p x = 0\" \"poly q x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. False", "have \"[:-x, 1:] dvd p\" \"[:-x, 1:] dvd q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- x, 1::'a:] dvd p &&& [:- x, 1::'a:] dvd q", "using that"], ["proof (prove)\nusing this:\n  poly p x = (0::'a)\n  poly q x = (0::'a)\n\ngoal (1 subgoal):\n 1. [:- x, 1::'a:] dvd p &&& [:- x, 1::'a:] dvd q", "by (simp_all add: poly_eq_0_iff_dvd)"], ["proof (state)\nthis:\n  [:- x, 1::'a:] dvd p\n  [:- x, 1::'a:] dvd q\n\ngoal (1 subgoal):\n 1. False", "hence \"[:-x, 1:] dvd 1\""], ["proof (prove)\nusing this:\n  [:- x, 1::'a:] dvd p\n  [:- x, 1::'a:] dvd q\n\ngoal (1 subgoal):\n 1. is_unit [:- x, 1::'a:]", "using \\<open>Rings.coprime p q\\<close>"], ["proof (prove)\nusing this:\n  [:- x, 1::'a:] dvd p\n  [:- x, 1::'a:] dvd q\n  algebraic_semidom_class.coprime p q\n\ngoal (1 subgoal):\n 1. is_unit [:- x, 1::'a:]", "by (meson not_coprimeI)"], ["proof (state)\nthis:\n  is_unit [:- x, 1::'a:]\n\ngoal (1 subgoal):\n 1. False", "thus False"], ["proof (prove)\nusing this:\n  is_unit [:- x, 1::'a:]\n\ngoal (1 subgoal):\n 1. False", "by (simp add: is_unit_poly_iff)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>poly p x = (0::'a); poly q x = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. poly p x \\<noteq> (0::'a) \\<or> poly q x \\<noteq> (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>poly p x = (0::'a); poly q x = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. poly p x \\<noteq> (0::'a) \\<or> poly q x \\<noteq> (0::'a)", "by blast"], ["proof (state)\nthis:\n  poly p x \\<noteq> (0::'a) \\<or> poly q x \\<noteq> (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coprime_of_int_polyI:\n  assumes \"Rings.coprime p q\"\n  shows   \"Rings.coprime (of_int_poly p) (of_int_poly q :: 'a :: {field_char_0,field_gcd} poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime (of_int_poly p) (of_int_poly q)", "using assms gcd_of_int_poly[of p q, where ?'a = 'a]"], ["proof (prove)\nusing this:\n  algebraic_semidom_class.coprime p q\n  gcd (of_int_poly p) (of_int_poly q) =\n  Polynomial.smult (inverse (of_int (Polynomial.lead_coeff (gcd p q))))\n   (of_int_poly (gcd p q))\n\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime (of_int_poly p) (of_int_poly q)", "unfolding coprime_iff_gcd_eq_1"], ["proof (prove)\nusing this:\n  gcd p q = 1\n  gcd (of_int_poly p) (of_int_poly q) =\n  Polynomial.smult (inverse (of_int (Polynomial.lead_coeff (gcd p q))))\n   (of_int_poly (gcd p q))\n\ngoal (1 subgoal):\n 1. gcd (of_int_poly p) (of_int_poly q) = 1", "by simp"], ["", "lemma irreducible_imp_rsquarefree_of_int_poly:\n  fixes p :: \"int poly\"\n  assumes \"irreducible p\" and \"Polynomial.degree p > 0\"\n  shows   \"rsquarefree (of_int_poly p :: 'a :: {field_gcd, field_char_0} poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rsquarefree (of_int_poly p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rsquarefree (of_int_poly p)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. rsquarefree (of_int_poly p)", "fix x :: 'a"], ["proof (state)\ngoal (1 subgoal):\n 1. rsquarefree (of_int_poly p)", "assume x: \"poly (of_int_poly p) x = 0\" \"poly (pderiv (of_int_poly p)) x = 0\""], ["proof (state)\nthis:\n  ipoly p x = (0::'a)\n  poly (pderiv (of_int_poly p)) x = (0::'a)\n\ngoal (1 subgoal):\n 1. rsquarefree (of_int_poly p)", "define d where \"d = gcd (of_int_poly p) (pderiv (of_int_poly p) :: 'a poly)\""], ["proof (state)\nthis:\n  d = gcd (of_int_poly p) (pderiv (of_int_poly p))\n\ngoal (1 subgoal):\n 1. rsquarefree (of_int_poly p)", "have \"poly d x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly d x = (0::'a)", "using x"], ["proof (prove)\nusing this:\n  ipoly p x = (0::'a)\n  poly (pderiv (of_int_poly p)) x = (0::'a)\n\ngoal (1 subgoal):\n 1. poly d x = (0::'a)", "unfolding d_def"], ["proof (prove)\nusing this:\n  ipoly p x = (0::'a)\n  poly (pderiv (of_int_poly p)) x = (0::'a)\n\ngoal (1 subgoal):\n 1. poly (gcd (of_int_poly p) (pderiv (of_int_poly p))) x = (0::'a)", "by (intro poly_gcd_eq_0I) auto"], ["proof (state)\nthis:\n  poly d x = (0::'a)\n\ngoal (1 subgoal):\n 1. rsquarefree (of_int_poly p)", "moreover"], ["proof (state)\nthis:\n  poly d x = (0::'a)\n\ngoal (1 subgoal):\n 1. rsquarefree (of_int_poly p)", "have \"d \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. d \\<noteq> 0", "using assms"], ["proof (prove)\nusing this:\n  irreducible p\n  0 < Polynomial.degree p\n\ngoal (1 subgoal):\n 1. d \\<noteq> 0", "by (auto simp: d_def)"], ["proof (state)\nthis:\n  d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. rsquarefree (of_int_poly p)", "ultimately"], ["proof (chain)\npicking this:\n  poly d x = (0::'a)\n  d \\<noteq> 0", "have \"0 < Polynomial.degree d\""], ["proof (prove)\nusing this:\n  poly d x = (0::'a)\n  d \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < Polynomial.degree d", "by (intro Nat.gr0I) (auto elim!: degree_eq_zeroE)"], ["proof (state)\nthis:\n  0 < Polynomial.degree d\n\ngoal (1 subgoal):\n 1. rsquarefree (of_int_poly p)", "also"], ["proof (state)\nthis:\n  0 < Polynomial.degree d\n\ngoal (1 subgoal):\n 1. rsquarefree (of_int_poly p)", "have \"Polynomial.degree d = Polynomial.degree (gcd p (pderiv p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.degree d = Polynomial.degree (gcd p (pderiv p))", "unfolding d_def of_int_hom.map_poly_pderiv[symmetric] gcd_of_int_poly"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.degree\n     (Polynomial.smult\n       (inverse (of_int (Polynomial.lead_coeff (gcd p (pderiv p)))))\n       (of_int_poly (gcd p (pderiv p)))) =\n    Polynomial.degree (gcd p (pderiv p))", "by simp"], ["proof (state)\nthis:\n  Polynomial.degree d = Polynomial.degree (gcd p (pderiv p))\n\ngoal (1 subgoal):\n 1. rsquarefree (of_int_poly p)", "finally"], ["proof (chain)\npicking this:\n  0 < Polynomial.degree (gcd p (pderiv p))", "have deg: \"\\<dots> > 0\""], ["proof (prove)\nusing this:\n  0 < Polynomial.degree (gcd p (pderiv p))\n\ngoal (1 subgoal):\n 1. 0 < Polynomial.degree (gcd p (pderiv p))", "."], ["proof (state)\nthis:\n  0 < Polynomial.degree (gcd p (pderiv p))\n\ngoal (1 subgoal):\n 1. rsquarefree (of_int_poly p)", "have \"gcd p (pderiv p) dvd p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd p (pderiv p) dvd p", "by auto"], ["proof (state)\nthis:\n  gcd p (pderiv p) dvd p\n\ngoal (1 subgoal):\n 1. rsquarefree (of_int_poly p)", "from irreducibleD'[OF assms(1) this] and deg"], ["proof (chain)\npicking this:\n  p dvd gcd p (pderiv p) \\<or> is_unit (gcd p (pderiv p))\n  0 < Polynomial.degree (gcd p (pderiv p))", "have \"p dvd gcd p (pderiv p)\""], ["proof (prove)\nusing this:\n  p dvd gcd p (pderiv p) \\<or> is_unit (gcd p (pderiv p))\n  0 < Polynomial.degree (gcd p (pderiv p))\n\ngoal (1 subgoal):\n 1. p dvd gcd p (pderiv p)", "by auto"], ["proof (state)\nthis:\n  p dvd gcd p (pderiv p)\n\ngoal (1 subgoal):\n 1. rsquarefree (of_int_poly p)", "also"], ["proof (state)\nthis:\n  p dvd gcd p (pderiv p)\n\ngoal (1 subgoal):\n 1. rsquarefree (of_int_poly p)", "have \"\\<dots> dvd pderiv p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd p (pderiv p) dvd pderiv p", "by auto"], ["proof (state)\nthis:\n  gcd p (pderiv p) dvd pderiv p\n\ngoal (1 subgoal):\n 1. rsquarefree (of_int_poly p)", "finally"], ["proof (chain)\npicking this:\n  p dvd pderiv p", "have \"Polynomial.degree p = 0\""], ["proof (prove)\nusing this:\n  p dvd pderiv p\n\ngoal (1 subgoal):\n 1. Polynomial.degree p = 0", "by auto"], ["proof (state)\nthis:\n  Polynomial.degree p = 0\n\ngoal (1 subgoal):\n 1. rsquarefree (of_int_poly p)", "with assms"], ["proof (chain)\npicking this:\n  irreducible p\n  0 < Polynomial.degree p\n  Polynomial.degree p = 0", "have False"], ["proof (prove)\nusing this:\n  irreducible p\n  0 < Polynomial.degree p\n  Polynomial.degree p = 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. rsquarefree (of_int_poly p)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>ipoly p ?x2 = (0::'a);\n   poly (pderiv (of_int_poly p)) ?x2 = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. rsquarefree (of_int_poly p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>ipoly p ?x2 = (0::'a);\n   poly (pderiv (of_int_poly p)) ?x2 = (0::'a)\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. rsquarefree (of_int_poly p)", "by (auto simp: rsquarefree_roots)"], ["proof (state)\nthis:\n  rsquarefree (of_int_poly p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma squarefree_of_int_polyI:\n  assumes \"squarefree p\" \"content p = 1\"\n  shows   \"squarefree (of_int_poly p :: 'a :: {field_char_0,field_gcd} poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. squarefree (of_int_poly p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. squarefree (of_int_poly p)", "have \"Rings.coprime p (pderiv p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime p (pderiv p)", "by (rule squarefree_imp_coprime_pderiv) fact+"], ["proof (state)\nthis:\n  algebraic_semidom_class.coprime p (pderiv p)\n\ngoal (1 subgoal):\n 1. squarefree (of_int_poly p)", "hence \"Rings.coprime (of_int_poly p :: 'a poly) (of_int_poly (pderiv p))\""], ["proof (prove)\nusing this:\n  algebraic_semidom_class.coprime p (pderiv p)\n\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime (of_int_poly p) (of_int_poly (pderiv p))", "by (rule coprime_of_int_polyI)"], ["proof (state)\nthis:\n  algebraic_semidom_class.coprime (of_int_poly p) (of_int_poly (pderiv p))\n\ngoal (1 subgoal):\n 1. squarefree (of_int_poly p)", "also"], ["proof (state)\nthis:\n  algebraic_semidom_class.coprime (of_int_poly p) (of_int_poly (pderiv p))\n\ngoal (1 subgoal):\n 1. squarefree (of_int_poly p)", "have \"of_int_poly (pderiv p) = pderiv (of_int_poly p :: 'a poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int_poly (pderiv p) = pderiv (of_int_poly p)", "by (simp add: of_int_hom.map_poly_pderiv)"], ["proof (state)\nthis:\n  of_int_poly (pderiv p) = pderiv (of_int_poly p)\n\ngoal (1 subgoal):\n 1. squarefree (of_int_poly p)", "finally"], ["proof (chain)\npicking this:\n  algebraic_semidom_class.coprime (of_int_poly p) (pderiv (of_int_poly p))", "show ?thesis"], ["proof (prove)\nusing this:\n  algebraic_semidom_class.coprime (of_int_poly p) (pderiv (of_int_poly p))\n\ngoal (1 subgoal):\n 1. squarefree (of_int_poly p)", "using coprime_pderiv_imp_squarefree"], ["proof (prove)\nusing this:\n  algebraic_semidom_class.coprime (of_int_poly p) (pderiv (of_int_poly p))\n  algebraic_semidom_class.coprime ?p (pderiv ?p) \\<Longrightarrow>\n  squarefree ?p\n\ngoal (1 subgoal):\n 1. squarefree (of_int_poly p)", "by blast"], ["proof (state)\nthis:\n  squarefree (of_int_poly p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma higher_pderiv_pcompose_linear:\n   \"(pderiv ^^ n) (pcompose p [:0, c:]) =\n    Polynomial.smult (c ^ n) (pcompose ((pderiv ^^ n) p) [:0, c:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (pderiv ^^ n) (p \\<circ>\\<^sub>p [:0::'a, c:]) =\n    Polynomial.smult (c ^ n) ((pderiv ^^ n) p \\<circ>\\<^sub>p [:0::'a, c:])", "by (induction n)  (simp_all add: pderiv_pcompose pderiv_smult pderiv_pCons pcompose_smult mult_ac)"], ["", "lemma poly_poly_eq:\n  \"poly (poly p [:x:]) y = poly (eval_poly (\\<lambda>p. [:poly p y:]) p [:0, 1:]) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (poly p [:x:]) y =\n    poly (eval_poly (\\<lambda>p. [:poly p y:]) p [:0::'a, 1::'a:]) x", "by (induction p) (auto simp: eval_poly_def)"], ["", "lemma poly_poly_poly_y_x [simp]:\n  fixes p :: \"'a :: idom poly poly\"\n  shows \"poly (poly (poly_y_x p) [:y:]) x = poly (poly p [:x:]) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (poly (poly_y_x p) [:y:]) x = poly (poly p [:x:]) y", "proof (induction p)"], ["proof (state)\ngoal (2 subgoals):\n 1. poly (poly (poly_y_x 0) [:y:]) x = poly (poly 0 [:x:]) y\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        poly (poly (poly_y_x p) [:y:]) x = poly (poly p [:x:]) y\\<rbrakk>\n       \\<Longrightarrow> poly (poly (poly_y_x (pCons a p)) [:y:]) x =\n                         poly (poly (pCons a p) [:x:]) y", "case (pCons a p)"], ["proof (state)\nthis:\n  a \\<noteq> 0 \\<or> p \\<noteq> 0\n  poly (poly (poly_y_x p) [:y:]) x = poly (poly p [:x:]) y\n\ngoal (2 subgoals):\n 1. poly (poly (poly_y_x 0) [:y:]) x = poly (poly 0 [:x:]) y\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        poly (poly (poly_y_x p) [:y:]) x = poly (poly p [:x:]) y\\<rbrakk>\n       \\<Longrightarrow> poly (poly (poly_y_x (pCons a p)) [:y:]) x =\n                         poly (poly (pCons a p) [:x:]) y", "have \"poly (poly (poly_y_x (pCons a p)) [:y:]) x = \n          poly a y + poly (poly (map_poly (pCons 0) (poly_y_x p)) [:y:]) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (poly (poly_y_x (pCons a p)) [:y:]) x =\n    poly a y + poly (poly (map_poly (pCons (0::'a)) (poly_y_x p)) [:y:]) x", "by (simp add: poly_y_x_pCons eval_poly_def)"], ["proof (state)\nthis:\n  poly (poly (poly_y_x (pCons a p)) [:y:]) x =\n  poly a y + poly (poly (map_poly (pCons (0::'a)) (poly_y_x p)) [:y:]) x\n\ngoal (2 subgoals):\n 1. poly (poly (poly_y_x 0) [:y:]) x = poly (poly 0 [:x:]) y\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        poly (poly (poly_y_x p) [:y:]) x = poly (poly p [:x:]) y\\<rbrakk>\n       \\<Longrightarrow> poly (poly (poly_y_x (pCons a p)) [:y:]) x =\n                         poly (poly (pCons a p) [:x:]) y", "also"], ["proof (state)\nthis:\n  poly (poly (poly_y_x (pCons a p)) [:y:]) x =\n  poly a y + poly (poly (map_poly (pCons (0::'a)) (poly_y_x p)) [:y:]) x\n\ngoal (2 subgoals):\n 1. poly (poly (poly_y_x 0) [:y:]) x = poly (poly 0 [:x:]) y\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        poly (poly (poly_y_x p) [:y:]) x = poly (poly p [:x:]) y\\<rbrakk>\n       \\<Longrightarrow> poly (poly (poly_y_x (pCons a p)) [:y:]) x =\n                         poly (poly (pCons a p) [:x:]) y", "have \"pCons 0 = (\\<lambda>p::'a poly. Polynomial.monom 1 1 * p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pCons (0::'a) = (*) (Polynomial.monom (1::'a) 1)", "by (simp add: Polynomial.monom_altdef)"], ["proof (state)\nthis:\n  pCons (0::'a) = (*) (Polynomial.monom (1::'a) 1)\n\ngoal (2 subgoals):\n 1. poly (poly (poly_y_x 0) [:y:]) x = poly (poly 0 [:x:]) y\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        poly (poly (poly_y_x p) [:y:]) x = poly (poly p [:x:]) y\\<rbrakk>\n       \\<Longrightarrow> poly (poly (poly_y_x (pCons a p)) [:y:]) x =\n                         poly (poly (pCons a p) [:x:]) y", "also"], ["proof (state)\nthis:\n  pCons (0::'a) = (*) (Polynomial.monom (1::'a) 1)\n\ngoal (2 subgoals):\n 1. poly (poly (poly_y_x 0) [:y:]) x = poly (poly 0 [:x:]) y\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        poly (poly (poly_y_x p) [:y:]) x = poly (poly p [:x:]) y\\<rbrakk>\n       \\<Longrightarrow> poly (poly (poly_y_x (pCons a p)) [:y:]) x =\n                         poly (poly (pCons a p) [:x:]) y", "have \"map_poly \\<dots> (poly_y_x p) = Polynomial.smult (Polynomial.monom 1 1) (poly_y_x p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly ((*) (Polynomial.monom (1::'a) 1)) (poly_y_x p) =\n    Polynomial.smult (Polynomial.monom (1::'a) 1) (poly_y_x p)", "by (simp add: smult_conv_map_poly)"], ["proof (state)\nthis:\n  map_poly ((*) (Polynomial.monom (1::'a) 1)) (poly_y_x p) =\n  Polynomial.smult (Polynomial.monom (1::'a) 1) (poly_y_x p)\n\ngoal (2 subgoals):\n 1. poly (poly (poly_y_x 0) [:y:]) x = poly (poly 0 [:x:]) y\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        poly (poly (poly_y_x p) [:y:]) x = poly (poly p [:x:]) y\\<rbrakk>\n       \\<Longrightarrow> poly (poly (poly_y_x (pCons a p)) [:y:]) x =\n                         poly (poly (pCons a p) [:x:]) y", "also"], ["proof (state)\nthis:\n  map_poly ((*) (Polynomial.monom (1::'a) 1)) (poly_y_x p) =\n  Polynomial.smult (Polynomial.monom (1::'a) 1) (poly_y_x p)\n\ngoal (2 subgoals):\n 1. poly (poly (poly_y_x 0) [:y:]) x = poly (poly 0 [:x:]) y\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        poly (poly (poly_y_x p) [:y:]) x = poly (poly p [:x:]) y\\<rbrakk>\n       \\<Longrightarrow> poly (poly (poly_y_x (pCons a p)) [:y:]) x =\n                         poly (poly (pCons a p) [:x:]) y", "have \"poly \\<dots> [:y:] = Polynomial.monom 1 1 * poly (poly_y_x p) [:y:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (Polynomial.smult (Polynomial.monom (1::'a) 1) (poly_y_x p))\n     [:y:] =\n    Polynomial.monom (1::'a) 1 * poly (poly_y_x p) [:y:]", "by simp"], ["proof (state)\nthis:\n  poly (Polynomial.smult (Polynomial.monom (1::'a) 1) (poly_y_x p)) [:y:] =\n  Polynomial.monom (1::'a) 1 * poly (poly_y_x p) [:y:]\n\ngoal (2 subgoals):\n 1. poly (poly (poly_y_x 0) [:y:]) x = poly (poly 0 [:x:]) y\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        poly (poly (poly_y_x p) [:y:]) x = poly (poly p [:x:]) y\\<rbrakk>\n       \\<Longrightarrow> poly (poly (poly_y_x (pCons a p)) [:y:]) x =\n                         poly (poly (pCons a p) [:x:]) y", "also"], ["proof (state)\nthis:\n  poly (Polynomial.smult (Polynomial.monom (1::'a) 1) (poly_y_x p)) [:y:] =\n  Polynomial.monom (1::'a) 1 * poly (poly_y_x p) [:y:]\n\ngoal (2 subgoals):\n 1. poly (poly (poly_y_x 0) [:y:]) x = poly (poly 0 [:x:]) y\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        poly (poly (poly_y_x p) [:y:]) x = poly (poly p [:x:]) y\\<rbrakk>\n       \\<Longrightarrow> poly (poly (poly_y_x (pCons a p)) [:y:]) x =\n                         poly (poly (pCons a p) [:x:]) y", "have \"poly a y + poly \\<dots> x = poly (poly (pCons a p) [:x:]) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly a y +\n    poly (Polynomial.monom (1::'a) 1 * poly (poly_y_x p) [:y:]) x =\n    poly (poly (pCons a p) [:x:]) y", "by (simp add: pCons poly_monom)"], ["proof (state)\nthis:\n  poly a y + poly (Polynomial.monom (1::'a) 1 * poly (poly_y_x p) [:y:]) x =\n  poly (poly (pCons a p) [:x:]) y\n\ngoal (2 subgoals):\n 1. poly (poly (poly_y_x 0) [:y:]) x = poly (poly 0 [:x:]) y\n 2. \\<And>a p.\n       \\<lbrakk>a \\<noteq> 0 \\<or> p \\<noteq> 0;\n        poly (poly (poly_y_x p) [:y:]) x = poly (poly p [:x:]) y\\<rbrakk>\n       \\<Longrightarrow> poly (poly (poly_y_x (pCons a p)) [:y:]) x =\n                         poly (poly (pCons a p) [:x:]) y", "finally"], ["proof (chain)\npicking this:\n  poly (poly (poly_y_x (pCons a p)) [:y:]) x =\n  poly (poly (pCons a p) [:x:]) y", "show ?case"], ["proof (prove)\nusing this:\n  poly (poly (poly_y_x (pCons a p)) [:y:]) x =\n  poly (poly (pCons a p) [:x:]) y\n\ngoal (1 subgoal):\n 1. poly (poly (poly_y_x (pCons a p)) [:y:]) x =\n    poly (poly (pCons a p) [:x:]) y", "."], ["proof (state)\nthis:\n  poly (poly (poly_y_x (pCons a p)) [:y:]) x =\n  poly (poly (pCons a p) [:x:]) y\n\ngoal (1 subgoal):\n 1. poly (poly (poly_y_x 0) [:y:]) x = poly (poly 0 [:x:]) y", "qed auto"], ["", "lemma (in idom_hom) map_poly_higher_pderiv [hom_distribs]:\n  \"map_poly hom ((pderiv ^^ n) p) = (pderiv ^^ n) (map_poly hom p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly hom ((pderiv ^^ n) p) = (pderiv ^^ n) (map_poly hom p)", "by (induction n) (simp_all add: map_poly_pderiv)"], ["", "lemma coeff_prod_linear_factors:\n  fixes f :: \"'a \\<Rightarrow> 'b :: comm_ring_1\"\n  assumes [intro]: \"finite A\"\n  shows \"Polynomial.coeff (\\<Prod>x\\<in>A. [:-f x, 1:] ^ e x) i =\n           (\\<Sum>X | X \\<in> Pow (SIGMA x:A. {..<e x}) \\<and> i = sum e A - card X.\n             (-1) ^ card X * (\\<Prod>x\\<in>X. f (fst x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly.coeff (\\<Prod>x\\<in>A. [:- f x, 1::'b:] ^ e x) i =\n    (\\<Sum>X | X \\<in> Pow (SIGMA x:A. {..<e x}) \\<and>\n               i = sum e A - card X.\n       (- (1::'b)) ^ card X * (\\<Prod>x\\<in>X. f (fst x)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly.coeff (\\<Prod>x\\<in>A. [:- f x, 1::'b:] ^ e x) i =\n    (\\<Sum>X | X \\<in> Pow (SIGMA x:A. {..<e x}) \\<and>\n               i = sum e A - card X.\n       (- (1::'b)) ^ card X * (\\<Prod>x\\<in>X. f (fst x)))", "define poly_X where \"poly_X = (Polynomial.monom 1 1 :: 'b poly)\""], ["proof (state)\nthis:\n  poly_X = Polynomial.monom (1::'b) 1\n\ngoal (1 subgoal):\n 1. poly.coeff (\\<Prod>x\\<in>A. [:- f x, 1::'b:] ^ e x) i =\n    (\\<Sum>X | X \\<in> Pow (SIGMA x:A. {..<e x}) \\<and>\n               i = sum e A - card X.\n       (- (1::'b)) ^ card X * (\\<Prod>x\\<in>X. f (fst x)))", "have [simp]: \"(- 1) ^ n = [:(- 1) ^ n :: 'b:]\" for n :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. (- 1) ^ n = [:(- (1::'b)) ^ n:]", "by (simp flip: pCons_one add: poly_const_pow)"], ["proof (state)\nthis:\n  (- 1) ^ ?n = [:(- (1::'b)) ^ ?n:]\n\ngoal (1 subgoal):\n 1. poly.coeff (\\<Prod>x\\<in>A. [:- f x, 1::'b:] ^ e x) i =\n    (\\<Sum>X | X \\<in> Pow (SIGMA x:A. {..<e x}) \\<and>\n               i = sum e A - card X.\n       (- (1::'b)) ^ card X * (\\<Prod>x\\<in>X. f (fst x)))", "have \"(\\<Prod>x\\<in>A. [:-f x, 1:] ^ e x) = (\\<Prod>(x,_)\\<in>Sigma A (\\<lambda>x. {..<e x}). [:-f x, 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<in>A. [:- f x, 1::'b:] ^ e x) =\n    (\\<Prod>(x, uu_)\\<in>(SIGMA x:A. {..<e x}). [:- f x, 1::'b:])", "by (subst prod.Sigma [symmetric]) auto"], ["proof (state)\nthis:\n  (\\<Prod>x\\<in>A. [:- f x, 1::'b:] ^ e x) =\n  (\\<Prod>(x, uu_)\\<in>(SIGMA x:A. {..<e x}). [:- f x, 1::'b:])\n\ngoal (1 subgoal):\n 1. poly.coeff (\\<Prod>x\\<in>A. [:- f x, 1::'b:] ^ e x) i =\n    (\\<Sum>X | X \\<in> Pow (SIGMA x:A. {..<e x}) \\<and>\n               i = sum e A - card X.\n       (- (1::'b)) ^ card X * (\\<Prod>x\\<in>X. f (fst x)))", "also"], ["proof (state)\nthis:\n  (\\<Prod>x\\<in>A. [:- f x, 1::'b:] ^ e x) =\n  (\\<Prod>(x, uu_)\\<in>(SIGMA x:A. {..<e x}). [:- f x, 1::'b:])\n\ngoal (1 subgoal):\n 1. poly.coeff (\\<Prod>x\\<in>A. [:- f x, 1::'b:] ^ e x) i =\n    (\\<Sum>X | X \\<in> Pow (SIGMA x:A. {..<e x}) \\<and>\n               i = sum e A - card X.\n       (- (1::'b)) ^ card X * (\\<Prod>x\\<in>X. f (fst x)))", "have \"\\<dots> = (\\<Prod>(x,_)\\<in>Sigma A (\\<lambda>x. {..<e x}). poly_X - [:f x:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(x, uu_)\\<in>(SIGMA x:A. {..<e x}). [:- f x, 1::'b:]) =\n    (\\<Prod>(x, uu_)\\<in>(SIGMA x:A. {..<e x}). poly_X - [:f x:])", "by (intro prod.cong) (auto simp: poly_X_def monom_altdef)"], ["proof (state)\nthis:\n  (\\<Prod>(x, uu_)\\<in>(SIGMA x:A. {..<e x}). [:- f x, 1::'b:]) =\n  (\\<Prod>(x, uu_)\\<in>(SIGMA x:A. {..<e x}). poly_X - [:f x:])\n\ngoal (1 subgoal):\n 1. poly.coeff (\\<Prod>x\\<in>A. [:- f x, 1::'b:] ^ e x) i =\n    (\\<Sum>X | X \\<in> Pow (SIGMA x:A. {..<e x}) \\<and>\n               i = sum e A - card X.\n       (- (1::'b)) ^ card X * (\\<Prod>x\\<in>X. f (fst x)))", "also"], ["proof (state)\nthis:\n  (\\<Prod>(x, uu_)\\<in>(SIGMA x:A. {..<e x}). [:- f x, 1::'b:]) =\n  (\\<Prod>(x, uu_)\\<in>(SIGMA x:A. {..<e x}). poly_X - [:f x:])\n\ngoal (1 subgoal):\n 1. poly.coeff (\\<Prod>x\\<in>A. [:- f x, 1::'b:] ^ e x) i =\n    (\\<Sum>X | X \\<in> Pow (SIGMA x:A. {..<e x}) \\<and>\n               i = sum e A - card X.\n       (- (1::'b)) ^ card X * (\\<Prod>x\\<in>X. f (fst x)))", "have \"\\<dots> = (\\<Sum>X\\<in>Pow (SIGMA x:A. {..<e x}).\n                    Polynomial.smult ((-1) ^ card X * (\\<Prod>x\\<in>X. f (fst x)))\n                    (poly_X ^ card ((SIGMA x:A. {..<e x}) - X)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>(x, uu_)\\<in>(SIGMA x:A. {..<e x}). poly_X - [:f x:]) =\n    (\\<Sum>X\\<in>Pow (SIGMA x:A. {..<e x}).\n       Polynomial.smult ((- (1::'b)) ^ card X * (\\<Prod>x\\<in>X. f (fst x)))\n        (poly_X ^ card ((SIGMA x:A. {..<e x}) - X)))", "unfolding case_prod_unfold"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>p\\<in>(SIGMA x:A. {..<e x}). poly_X - [:f (fst p):]) =\n    (\\<Sum>X\\<in>Pow (SIGMA x:A. {..<e x}).\n       Polynomial.smult ((- (1::'b)) ^ card X * (\\<Prod>x\\<in>X. f (fst x)))\n        (poly_X ^ card ((SIGMA x:A. {..<e x}) - X)))", "by (subst prod_diff1) (auto simp: mult_ac simp flip: coeff_lift_hom.hom_prod)"], ["proof (state)\nthis:\n  (\\<Prod>(x, uu_)\\<in>(SIGMA x:A. {..<e x}). poly_X - [:f x:]) =\n  (\\<Sum>X\\<in>Pow (SIGMA x:A. {..<e x}).\n     Polynomial.smult ((- (1::'b)) ^ card X * (\\<Prod>x\\<in>X. f (fst x)))\n      (poly_X ^ card ((SIGMA x:A. {..<e x}) - X)))\n\ngoal (1 subgoal):\n 1. poly.coeff (\\<Prod>x\\<in>A. [:- f x, 1::'b:] ^ e x) i =\n    (\\<Sum>X | X \\<in> Pow (SIGMA x:A. {..<e x}) \\<and>\n               i = sum e A - card X.\n       (- (1::'b)) ^ card X * (\\<Prod>x\\<in>X. f (fst x)))", "also"], ["proof (state)\nthis:\n  (\\<Prod>(x, uu_)\\<in>(SIGMA x:A. {..<e x}). poly_X - [:f x:]) =\n  (\\<Sum>X\\<in>Pow (SIGMA x:A. {..<e x}).\n     Polynomial.smult ((- (1::'b)) ^ card X * (\\<Prod>x\\<in>X. f (fst x)))\n      (poly_X ^ card ((SIGMA x:A. {..<e x}) - X)))\n\ngoal (1 subgoal):\n 1. poly.coeff (\\<Prod>x\\<in>A. [:- f x, 1::'b:] ^ e x) i =\n    (\\<Sum>X | X \\<in> Pow (SIGMA x:A. {..<e x}) \\<and>\n               i = sum e A - card X.\n       (- (1::'b)) ^ card X * (\\<Prod>x\\<in>X. f (fst x)))", "have \"\\<dots> = (\\<Sum>X\\<in>Pow (SIGMA x:A. {..<e x}).\n       Polynomial.monom ((- 1) ^ card X * (\\<Prod>x\\<in>X. f (fst x))) (card ((SIGMA x:A. {..<e x}) - X)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>X\\<in>Pow (SIGMA x:A. {..<e x}).\n       Polynomial.smult ((- (1::'b)) ^ card X * (\\<Prod>x\\<in>X. f (fst x)))\n        (poly_X ^ card ((SIGMA x:A. {..<e x}) - X))) =\n    (\\<Sum>X\\<in>Pow (SIGMA x:A. {..<e x}).\n       Polynomial.monom ((- (1::'b)) ^ card X * (\\<Prod>x\\<in>X. f (fst x)))\n        (card ((SIGMA x:A. {..<e x}) - X)))", "unfolding poly_X_def monom_power Polynomial.smult_monom"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>X\\<in>Pow (SIGMA x:A. {..<e x}).\n       Polynomial.monom\n        ((- (1::'b)) ^ card X * (\\<Prod>x\\<in>X. f (fst x)) *\n         (1::'b) ^ card ((SIGMA x:A. {..<e x}) - X))\n        (1 * card ((SIGMA x:A. {..<e x}) - X))) =\n    (\\<Sum>X\\<in>Pow (SIGMA x:A. {..<e x}).\n       Polynomial.monom ((- (1::'b)) ^ card X * (\\<Prod>x\\<in>X. f (fst x)))\n        (card ((SIGMA x:A. {..<e x}) - X)))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>X\\<in>Pow (SIGMA x:A. {..<e x}).\n     Polynomial.smult ((- (1::'b)) ^ card X * (\\<Prod>x\\<in>X. f (fst x)))\n      (poly_X ^ card ((SIGMA x:A. {..<e x}) - X))) =\n  (\\<Sum>X\\<in>Pow (SIGMA x:A. {..<e x}).\n     Polynomial.monom ((- (1::'b)) ^ card X * (\\<Prod>x\\<in>X. f (fst x)))\n      (card ((SIGMA x:A. {..<e x}) - X)))\n\ngoal (1 subgoal):\n 1. poly.coeff (\\<Prod>x\\<in>A. [:- f x, 1::'b:] ^ e x) i =\n    (\\<Sum>X | X \\<in> Pow (SIGMA x:A. {..<e x}) \\<and>\n               i = sum e A - card X.\n       (- (1::'b)) ^ card X * (\\<Prod>x\\<in>X. f (fst x)))", "also"], ["proof (state)\nthis:\n  (\\<Sum>X\\<in>Pow (SIGMA x:A. {..<e x}).\n     Polynomial.smult ((- (1::'b)) ^ card X * (\\<Prod>x\\<in>X. f (fst x)))\n      (poly_X ^ card ((SIGMA x:A. {..<e x}) - X))) =\n  (\\<Sum>X\\<in>Pow (SIGMA x:A. {..<e x}).\n     Polynomial.monom ((- (1::'b)) ^ card X * (\\<Prod>x\\<in>X. f (fst x)))\n      (card ((SIGMA x:A. {..<e x}) - X)))\n\ngoal (1 subgoal):\n 1. poly.coeff (\\<Prod>x\\<in>A. [:- f x, 1::'b:] ^ e x) i =\n    (\\<Sum>X | X \\<in> Pow (SIGMA x:A. {..<e x}) \\<and>\n               i = sum e A - card X.\n       (- (1::'b)) ^ card X * (\\<Prod>x\\<in>X. f (fst x)))", "have \"Polynomial.coeff \\<dots> i = (\\<Sum>X\\<in>{X\\<in>Pow (SIGMA x:A. {..<e x}). i =\n               sum e A - card X}. (- 1) ^ card X * (\\<Prod>x\\<in>X. f (fst x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly.coeff\n     (\\<Sum>X\\<in>Pow (SIGMA x:A. {..<e x}).\n        Polynomial.monom\n         ((- (1::'b)) ^ card X * (\\<Prod>x\\<in>X. f (fst x)))\n         (card ((SIGMA x:A. {..<e x}) - X)))\n     i =\n    (\\<Sum>X | X \\<in> Pow (SIGMA x:A. {..<e x}) \\<and>\n               i = sum e A - card X.\n       (- (1::'b)) ^ card X * (\\<Prod>x\\<in>X. f (fst x)))", "unfolding Polynomial.coeff_sum"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>Pow (SIGMA x:A. {..<e x}).\n       poly.coeff\n        (Polynomial.monom\n          ((- (1::'b)) ^ card x * (\\<Prod>x\\<in>x. f (fst x)))\n          (card ((SIGMA x:A. {..<e x}) - x)))\n        i) =\n    (\\<Sum>X | X \\<in> Pow (SIGMA x:A. {..<e x}) \\<and>\n               i = sum e A - card X.\n       (- (1::'b)) ^ card X * (\\<Prod>x\\<in>X. f (fst x)))", "proof (intro sum.mono_neutral_cong_right ballI, goal_cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. finite (Pow (SIGMA x:A. {..<e x}))\n 2. {X \\<in> Pow (SIGMA x:A. {..<e x}). i = sum e A - card X}\n    \\<subseteq> Pow (SIGMA x:A. {..<e x})\n 3. \\<And>ia.\n       ia \\<in> Pow (SIGMA x:A. {..<e x}) -\n                {X \\<in> Pow (SIGMA x:A. {..<e x}).\n                 i = sum e A - card X} \\<Longrightarrow>\n       poly.coeff\n        (Polynomial.monom\n          ((- (1::'b)) ^ card ia * (\\<Prod>x\\<in>ia. f (fst x)))\n          (card ((SIGMA x:A. {..<e x}) - ia)))\n        i =\n       (0::'b)\n 4. \\<And>x.\n       x \\<in> {X \\<in> Pow (SIGMA x:A. {..<e x}).\n                i = sum e A - card X} \\<Longrightarrow>\n       poly.coeff\n        (Polynomial.monom\n          ((- (1::'b)) ^ card x * (\\<Prod>x\\<in>x. f (fst x)))\n          (card ((SIGMA x:A. {..<e x}) - x)))\n        i =\n       (- (1::'b)) ^ card x * (\\<Prod>x\\<in>x. f (fst x))", "case (3 X)"], ["proof (state)\nthis:\n  X \\<in> Pow (SIGMA x:A. {..<e x}) -\n          {X \\<in> Pow (SIGMA x:A. {..<e x}). i = sum e A - card X}\n\ngoal (4 subgoals):\n 1. finite (Pow (SIGMA x:A. {..<e x}))\n 2. {X \\<in> Pow (SIGMA x:A. {..<e x}). i = sum e A - card X}\n    \\<subseteq> Pow (SIGMA x:A. {..<e x})\n 3. \\<And>ia.\n       ia \\<in> Pow (SIGMA x:A. {..<e x}) -\n                {X \\<in> Pow (SIGMA x:A. {..<e x}).\n                 i = sum e A - card X} \\<Longrightarrow>\n       poly.coeff\n        (Polynomial.monom\n          ((- (1::'b)) ^ card ia * (\\<Prod>x\\<in>ia. f (fst x)))\n          (card ((SIGMA x:A. {..<e x}) - ia)))\n        i =\n       (0::'b)\n 4. \\<And>x.\n       x \\<in> {X \\<in> Pow (SIGMA x:A. {..<e x}).\n                i = sum e A - card X} \\<Longrightarrow>\n       poly.coeff\n        (Polynomial.monom\n          ((- (1::'b)) ^ card x * (\\<Prod>x\\<in>x. f (fst x)))\n          (card ((SIGMA x:A. {..<e x}) - x)))\n        i =\n       (- (1::'b)) ^ card x * (\\<Prod>x\\<in>x. f (fst x))", "hence X: \"X \\<subseteq> (SIGMA x:A. {..<e x})\""], ["proof (prove)\nusing this:\n  X \\<in> Pow (SIGMA x:A. {..<e x}) -\n          {X \\<in> Pow (SIGMA x:A. {..<e x}). i = sum e A - card X}\n\ngoal (1 subgoal):\n 1. X \\<subseteq> (SIGMA x:A. {..<e x})", "by auto"], ["proof (state)\nthis:\n  X \\<subseteq> (SIGMA x:A. {..<e x})\n\ngoal (4 subgoals):\n 1. finite (Pow (SIGMA x:A. {..<e x}))\n 2. {X \\<in> Pow (SIGMA x:A. {..<e x}). i = sum e A - card X}\n    \\<subseteq> Pow (SIGMA x:A. {..<e x})\n 3. \\<And>ia.\n       ia \\<in> Pow (SIGMA x:A. {..<e x}) -\n                {X \\<in> Pow (SIGMA x:A. {..<e x}).\n                 i = sum e A - card X} \\<Longrightarrow>\n       poly.coeff\n        (Polynomial.monom\n          ((- (1::'b)) ^ card ia * (\\<Prod>x\\<in>ia. f (fst x)))\n          (card ((SIGMA x:A. {..<e x}) - ia)))\n        i =\n       (0::'b)\n 4. \\<And>x.\n       x \\<in> {X \\<in> Pow (SIGMA x:A. {..<e x}).\n                i = sum e A - card X} \\<Longrightarrow>\n       poly.coeff\n        (Polynomial.monom\n          ((- (1::'b)) ^ card x * (\\<Prod>x\\<in>x. f (fst x)))\n          (card ((SIGMA x:A. {..<e x}) - x)))\n        i =\n       (- (1::'b)) ^ card x * (\\<Prod>x\\<in>x. f (fst x))", "have card_le: \"card X \\<le> card (SIGMA x:A. {..<e x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card X \\<le> card (SIGMA x:A. {..<e x})", "using X"], ["proof (prove)\nusing this:\n  X \\<subseteq> (SIGMA x:A. {..<e x})\n\ngoal (1 subgoal):\n 1. card X \\<le> card (SIGMA x:A. {..<e x})", "by (intro card_mono) auto"], ["proof (state)\nthis:\n  card X \\<le> card (SIGMA x:A. {..<e x})\n\ngoal (4 subgoals):\n 1. finite (Pow (SIGMA x:A. {..<e x}))\n 2. {X \\<in> Pow (SIGMA x:A. {..<e x}). i = sum e A - card X}\n    \\<subseteq> Pow (SIGMA x:A. {..<e x})\n 3. \\<And>ia.\n       ia \\<in> Pow (SIGMA x:A. {..<e x}) -\n                {X \\<in> Pow (SIGMA x:A. {..<e x}).\n                 i = sum e A - card X} \\<Longrightarrow>\n       poly.coeff\n        (Polynomial.monom\n          ((- (1::'b)) ^ card ia * (\\<Prod>x\\<in>ia. f (fst x)))\n          (card ((SIGMA x:A. {..<e x}) - ia)))\n        i =\n       (0::'b)\n 4. \\<And>x.\n       x \\<in> {X \\<in> Pow (SIGMA x:A. {..<e x}).\n                i = sum e A - card X} \\<Longrightarrow>\n       poly.coeff\n        (Polynomial.monom\n          ((- (1::'b)) ^ card x * (\\<Prod>x\\<in>x. f (fst x)))\n          (card ((SIGMA x:A. {..<e x}) - x)))\n        i =\n       (- (1::'b)) ^ card x * (\\<Prod>x\\<in>x. f (fst x))", "have \"finite X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite X", "by (rule finite_subset[OF X]) auto"], ["proof (state)\nthis:\n  finite X\n\ngoal (4 subgoals):\n 1. finite (Pow (SIGMA x:A. {..<e x}))\n 2. {X \\<in> Pow (SIGMA x:A. {..<e x}). i = sum e A - card X}\n    \\<subseteq> Pow (SIGMA x:A. {..<e x})\n 3. \\<And>ia.\n       ia \\<in> Pow (SIGMA x:A. {..<e x}) -\n                {X \\<in> Pow (SIGMA x:A. {..<e x}).\n                 i = sum e A - card X} \\<Longrightarrow>\n       poly.coeff\n        (Polynomial.monom\n          ((- (1::'b)) ^ card ia * (\\<Prod>x\\<in>ia. f (fst x)))\n          (card ((SIGMA x:A. {..<e x}) - ia)))\n        i =\n       (0::'b)\n 4. \\<And>x.\n       x \\<in> {X \\<in> Pow (SIGMA x:A. {..<e x}).\n                i = sum e A - card X} \\<Longrightarrow>\n       poly.coeff\n        (Polynomial.monom\n          ((- (1::'b)) ^ card x * (\\<Prod>x\\<in>x. f (fst x)))\n          (card ((SIGMA x:A. {..<e x}) - x)))\n        i =\n       (- (1::'b)) ^ card x * (\\<Prod>x\\<in>x. f (fst x))", "hence \"card ((SIGMA x:A. {..<e x}) - X) = card (SIGMA x:A. {..<e x}) - card X\""], ["proof (prove)\nusing this:\n  finite X\n\ngoal (1 subgoal):\n 1. card ((SIGMA x:A. {..<e x}) - X) = card (SIGMA x:A. {..<e x}) - card X", "using 3"], ["proof (prove)\nusing this:\n  finite X\n  X \\<in> Pow (SIGMA x:A. {..<e x}) -\n          {X \\<in> Pow (SIGMA x:A. {..<e x}). i = sum e A - card X}\n\ngoal (1 subgoal):\n 1. card ((SIGMA x:A. {..<e x}) - X) = card (SIGMA x:A. {..<e x}) - card X", "by (intro card_Diff_subset) auto"], ["proof (state)\nthis:\n  card ((SIGMA x:A. {..<e x}) - X) = card (SIGMA x:A. {..<e x}) - card X\n\ngoal (4 subgoals):\n 1. finite (Pow (SIGMA x:A. {..<e x}))\n 2. {X \\<in> Pow (SIGMA x:A. {..<e x}). i = sum e A - card X}\n    \\<subseteq> Pow (SIGMA x:A. {..<e x})\n 3. \\<And>ia.\n       ia \\<in> Pow (SIGMA x:A. {..<e x}) -\n                {X \\<in> Pow (SIGMA x:A. {..<e x}).\n                 i = sum e A - card X} \\<Longrightarrow>\n       poly.coeff\n        (Polynomial.monom\n          ((- (1::'b)) ^ card ia * (\\<Prod>x\\<in>ia. f (fst x)))\n          (card ((SIGMA x:A. {..<e x}) - ia)))\n        i =\n       (0::'b)\n 4. \\<And>x.\n       x \\<in> {X \\<in> Pow (SIGMA x:A. {..<e x}).\n                i = sum e A - card X} \\<Longrightarrow>\n       poly.coeff\n        (Polynomial.monom\n          ((- (1::'b)) ^ card x * (\\<Prod>x\\<in>x. f (fst x)))\n          (card ((SIGMA x:A. {..<e x}) - x)))\n        i =\n       (- (1::'b)) ^ card x * (\\<Prod>x\\<in>x. f (fst x))", "also"], ["proof (state)\nthis:\n  card ((SIGMA x:A. {..<e x}) - X) = card (SIGMA x:A. {..<e x}) - card X\n\ngoal (4 subgoals):\n 1. finite (Pow (SIGMA x:A. {..<e x}))\n 2. {X \\<in> Pow (SIGMA x:A. {..<e x}). i = sum e A - card X}\n    \\<subseteq> Pow (SIGMA x:A. {..<e x})\n 3. \\<And>ia.\n       ia \\<in> Pow (SIGMA x:A. {..<e x}) -\n                {X \\<in> Pow (SIGMA x:A. {..<e x}).\n                 i = sum e A - card X} \\<Longrightarrow>\n       poly.coeff\n        (Polynomial.monom\n          ((- (1::'b)) ^ card ia * (\\<Prod>x\\<in>ia. f (fst x)))\n          (card ((SIGMA x:A. {..<e x}) - ia)))\n        i =\n       (0::'b)\n 4. \\<And>x.\n       x \\<in> {X \\<in> Pow (SIGMA x:A. {..<e x}).\n                i = sum e A - card X} \\<Longrightarrow>\n       poly.coeff\n        (Polynomial.monom\n          ((- (1::'b)) ^ card x * (\\<Prod>x\\<in>x. f (fst x)))\n          (card ((SIGMA x:A. {..<e x}) - x)))\n        i =\n       (- (1::'b)) ^ card x * (\\<Prod>x\\<in>x. f (fst x))", "have card_eq: \"card (SIGMA x:A. {..<e x}) = sum e A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (SIGMA x:A. {..<e x}) = sum e A", "by (subst card_SigmaI) auto"], ["proof (state)\nthis:\n  card (SIGMA x:A. {..<e x}) = sum e A\n\ngoal (4 subgoals):\n 1. finite (Pow (SIGMA x:A. {..<e x}))\n 2. {X \\<in> Pow (SIGMA x:A. {..<e x}). i = sum e A - card X}\n    \\<subseteq> Pow (SIGMA x:A. {..<e x})\n 3. \\<And>ia.\n       ia \\<in> Pow (SIGMA x:A. {..<e x}) -\n                {X \\<in> Pow (SIGMA x:A. {..<e x}).\n                 i = sum e A - card X} \\<Longrightarrow>\n       poly.coeff\n        (Polynomial.monom\n          ((- (1::'b)) ^ card ia * (\\<Prod>x\\<in>ia. f (fst x)))\n          (card ((SIGMA x:A. {..<e x}) - ia)))\n        i =\n       (0::'b)\n 4. \\<And>x.\n       x \\<in> {X \\<in> Pow (SIGMA x:A. {..<e x}).\n                i = sum e A - card X} \\<Longrightarrow>\n       poly.coeff\n        (Polynomial.monom\n          ((- (1::'b)) ^ card x * (\\<Prod>x\\<in>x. f (fst x)))\n          (card ((SIGMA x:A. {..<e x}) - x)))\n        i =\n       (- (1::'b)) ^ card x * (\\<Prod>x\\<in>x. f (fst x))", "finally"], ["proof (chain)\npicking this:\n  card ((SIGMA x:A. {..<e x}) - X) = sum e A - card X", "show ?case"], ["proof (prove)\nusing this:\n  card ((SIGMA x:A. {..<e x}) - X) = sum e A - card X\n\ngoal (1 subgoal):\n 1. poly.coeff\n     (Polynomial.monom ((- (1::'b)) ^ card X * (\\<Prod>x\\<in>X. f (fst x)))\n       (card ((SIGMA x:A. {..<e x}) - X)))\n     i =\n    (0::'b)", "using 3 card_le card_eq"], ["proof (prove)\nusing this:\n  card ((SIGMA x:A. {..<e x}) - X) = sum e A - card X\n  X \\<in> Pow (SIGMA x:A. {..<e x}) -\n          {X \\<in> Pow (SIGMA x:A. {..<e x}). i = sum e A - card X}\n  card X \\<le> card (SIGMA x:A. {..<e x})\n  card (SIGMA x:A. {..<e x}) = sum e A\n\ngoal (1 subgoal):\n 1. poly.coeff\n     (Polynomial.monom ((- (1::'b)) ^ card X * (\\<Prod>x\\<in>X. f (fst x)))\n       (card ((SIGMA x:A. {..<e x}) - X)))\n     i =\n    (0::'b)", "by (auto simp: algebra_simps)"], ["proof (state)\nthis:\n  poly.coeff\n   (Polynomial.monom ((- (1::'b)) ^ card X * (\\<Prod>x\\<in>X. f (fst x)))\n     (card ((SIGMA x:A. {..<e x}) - X)))\n   i =\n  (0::'b)\n\ngoal (3 subgoals):\n 1. finite (Pow (SIGMA x:A. {..<e x}))\n 2. {X \\<in> Pow (SIGMA x:A. {..<e x}). i = sum e A - card X}\n    \\<subseteq> Pow (SIGMA x:A. {..<e x})\n 3. \\<And>x.\n       x \\<in> {X \\<in> Pow (SIGMA x:A. {..<e x}).\n                i = sum e A - card X} \\<Longrightarrow>\n       poly.coeff\n        (Polynomial.monom\n          ((- (1::'b)) ^ card x * (\\<Prod>x\\<in>x. f (fst x)))\n          (card ((SIGMA x:A. {..<e x}) - x)))\n        i =\n       (- (1::'b)) ^ card x * (\\<Prod>x\\<in>x. f (fst x))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. finite (Pow (SIGMA x:A. {..<e x}))\n 2. {X \\<in> Pow (SIGMA x:A. {..<e x}). i = sum e A - card X}\n    \\<subseteq> Pow (SIGMA x:A. {..<e x})\n 3. \\<And>x.\n       x \\<in> {X \\<in> Pow (SIGMA x:A. {..<e x}).\n                i = sum e A - card X} \\<Longrightarrow>\n       poly.coeff\n        (Polynomial.monom\n          ((- (1::'b)) ^ card x * (\\<Prod>x\\<in>x. f (fst x)))\n          (card ((SIGMA x:A. {..<e x}) - x)))\n        i =\n       (- (1::'b)) ^ card x * (\\<Prod>x\\<in>x. f (fst x))", "case (4 X)"], ["proof (state)\nthis:\n  X \\<in> {X \\<in> Pow (SIGMA x:A. {..<e x}). i = sum e A - card X}\n\ngoal (3 subgoals):\n 1. finite (Pow (SIGMA x:A. {..<e x}))\n 2. {X \\<in> Pow (SIGMA x:A. {..<e x}). i = sum e A - card X}\n    \\<subseteq> Pow (SIGMA x:A. {..<e x})\n 3. \\<And>x.\n       x \\<in> {X \\<in> Pow (SIGMA x:A. {..<e x}).\n                i = sum e A - card X} \\<Longrightarrow>\n       poly.coeff\n        (Polynomial.monom\n          ((- (1::'b)) ^ card x * (\\<Prod>x\\<in>x. f (fst x)))\n          (card ((SIGMA x:A. {..<e x}) - x)))\n        i =\n       (- (1::'b)) ^ card x * (\\<Prod>x\\<in>x. f (fst x))", "hence X: \"X \\<subseteq> (SIGMA x:A. {..<e x})\""], ["proof (prove)\nusing this:\n  X \\<in> {X \\<in> Pow (SIGMA x:A. {..<e x}). i = sum e A - card X}\n\ngoal (1 subgoal):\n 1. X \\<subseteq> (SIGMA x:A. {..<e x})", "by auto"], ["proof (state)\nthis:\n  X \\<subseteq> (SIGMA x:A. {..<e x})\n\ngoal (3 subgoals):\n 1. finite (Pow (SIGMA x:A. {..<e x}))\n 2. {X \\<in> Pow (SIGMA x:A. {..<e x}). i = sum e A - card X}\n    \\<subseteq> Pow (SIGMA x:A. {..<e x})\n 3. \\<And>x.\n       x \\<in> {X \\<in> Pow (SIGMA x:A. {..<e x}).\n                i = sum e A - card X} \\<Longrightarrow>\n       poly.coeff\n        (Polynomial.monom\n          ((- (1::'b)) ^ card x * (\\<Prod>x\\<in>x. f (fst x)))\n          (card ((SIGMA x:A. {..<e x}) - x)))\n        i =\n       (- (1::'b)) ^ card x * (\\<Prod>x\\<in>x. f (fst x))", "have \"finite X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite X", "by (rule finite_subset[OF X]) auto"], ["proof (state)\nthis:\n  finite X\n\ngoal (3 subgoals):\n 1. finite (Pow (SIGMA x:A. {..<e x}))\n 2. {X \\<in> Pow (SIGMA x:A. {..<e x}). i = sum e A - card X}\n    \\<subseteq> Pow (SIGMA x:A. {..<e x})\n 3. \\<And>x.\n       x \\<in> {X \\<in> Pow (SIGMA x:A. {..<e x}).\n                i = sum e A - card X} \\<Longrightarrow>\n       poly.coeff\n        (Polynomial.monom\n          ((- (1::'b)) ^ card x * (\\<Prod>x\\<in>x. f (fst x)))\n          (card ((SIGMA x:A. {..<e x}) - x)))\n        i =\n       (- (1::'b)) ^ card x * (\\<Prod>x\\<in>x. f (fst x))", "hence \"card ((SIGMA x:A. {..<e x}) - X) = card (SIGMA x:A. {..<e x}) - card X\""], ["proof (prove)\nusing this:\n  finite X\n\ngoal (1 subgoal):\n 1. card ((SIGMA x:A. {..<e x}) - X) = card (SIGMA x:A. {..<e x}) - card X", "using 4"], ["proof (prove)\nusing this:\n  finite X\n  X \\<in> {X \\<in> Pow (SIGMA x:A. {..<e x}). i = sum e A - card X}\n\ngoal (1 subgoal):\n 1. card ((SIGMA x:A. {..<e x}) - X) = card (SIGMA x:A. {..<e x}) - card X", "by (intro card_Diff_subset) auto"], ["proof (state)\nthis:\n  card ((SIGMA x:A. {..<e x}) - X) = card (SIGMA x:A. {..<e x}) - card X\n\ngoal (3 subgoals):\n 1. finite (Pow (SIGMA x:A. {..<e x}))\n 2. {X \\<in> Pow (SIGMA x:A. {..<e x}). i = sum e A - card X}\n    \\<subseteq> Pow (SIGMA x:A. {..<e x})\n 3. \\<And>x.\n       x \\<in> {X \\<in> Pow (SIGMA x:A. {..<e x}).\n                i = sum e A - card X} \\<Longrightarrow>\n       poly.coeff\n        (Polynomial.monom\n          ((- (1::'b)) ^ card x * (\\<Prod>x\\<in>x. f (fst x)))\n          (card ((SIGMA x:A. {..<e x}) - x)))\n        i =\n       (- (1::'b)) ^ card x * (\\<Prod>x\\<in>x. f (fst x))", "also"], ["proof (state)\nthis:\n  card ((SIGMA x:A. {..<e x}) - X) = card (SIGMA x:A. {..<e x}) - card X\n\ngoal (3 subgoals):\n 1. finite (Pow (SIGMA x:A. {..<e x}))\n 2. {X \\<in> Pow (SIGMA x:A. {..<e x}). i = sum e A - card X}\n    \\<subseteq> Pow (SIGMA x:A. {..<e x})\n 3. \\<And>x.\n       x \\<in> {X \\<in> Pow (SIGMA x:A. {..<e x}).\n                i = sum e A - card X} \\<Longrightarrow>\n       poly.coeff\n        (Polynomial.monom\n          ((- (1::'b)) ^ card x * (\\<Prod>x\\<in>x. f (fst x)))\n          (card ((SIGMA x:A. {..<e x}) - x)))\n        i =\n       (- (1::'b)) ^ card x * (\\<Prod>x\\<in>x. f (fst x))", "have card_eq: \"card (SIGMA x:A. {..<e x}) = sum e A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (SIGMA x:A. {..<e x}) = sum e A", "by (subst card_SigmaI) auto"], ["proof (state)\nthis:\n  card (SIGMA x:A. {..<e x}) = sum e A\n\ngoal (3 subgoals):\n 1. finite (Pow (SIGMA x:A. {..<e x}))\n 2. {X \\<in> Pow (SIGMA x:A. {..<e x}). i = sum e A - card X}\n    \\<subseteq> Pow (SIGMA x:A. {..<e x})\n 3. \\<And>x.\n       x \\<in> {X \\<in> Pow (SIGMA x:A. {..<e x}).\n                i = sum e A - card X} \\<Longrightarrow>\n       poly.coeff\n        (Polynomial.monom\n          ((- (1::'b)) ^ card x * (\\<Prod>x\\<in>x. f (fst x)))\n          (card ((SIGMA x:A. {..<e x}) - x)))\n        i =\n       (- (1::'b)) ^ card x * (\\<Prod>x\\<in>x. f (fst x))", "finally"], ["proof (chain)\npicking this:\n  card ((SIGMA x:A. {..<e x}) - X) = sum e A - card X", "show ?case"], ["proof (prove)\nusing this:\n  card ((SIGMA x:A. {..<e x}) - X) = sum e A - card X\n\ngoal (1 subgoal):\n 1. poly.coeff\n     (Polynomial.monom ((- (1::'b)) ^ card X * (\\<Prod>x\\<in>X. f (fst x)))\n       (card ((SIGMA x:A. {..<e x}) - X)))\n     i =\n    (- (1::'b)) ^ card X * (\\<Prod>x\\<in>X. f (fst x))", "using 4 card_eq"], ["proof (prove)\nusing this:\n  card ((SIGMA x:A. {..<e x}) - X) = sum e A - card X\n  X \\<in> {X \\<in> Pow (SIGMA x:A. {..<e x}). i = sum e A - card X}\n  card (SIGMA x:A. {..<e x}) = sum e A\n\ngoal (1 subgoal):\n 1. poly.coeff\n     (Polynomial.monom ((- (1::'b)) ^ card X * (\\<Prod>x\\<in>X. f (fst x)))\n       (card ((SIGMA x:A. {..<e x}) - X)))\n     i =\n    (- (1::'b)) ^ card X * (\\<Prod>x\\<in>X. f (fst x))", "by (auto simp: algebra_simps)"], ["proof (state)\nthis:\n  poly.coeff\n   (Polynomial.monom ((- (1::'b)) ^ card X * (\\<Prod>x\\<in>X. f (fst x)))\n     (card ((SIGMA x:A. {..<e x}) - X)))\n   i =\n  (- (1::'b)) ^ card X * (\\<Prod>x\\<in>X. f (fst x))\n\ngoal (2 subgoals):\n 1. finite (Pow (SIGMA x:A. {..<e x}))\n 2. {X \\<in> Pow (SIGMA x:A. {..<e x}). i = sum e A - card X}\n    \\<subseteq> Pow (SIGMA x:A. {..<e x})", "qed auto"], ["proof (state)\nthis:\n  poly.coeff\n   (\\<Sum>X\\<in>Pow (SIGMA x:A. {..<e x}).\n      Polynomial.monom ((- (1::'b)) ^ card X * (\\<Prod>x\\<in>X. f (fst x)))\n       (card ((SIGMA x:A. {..<e x}) - X)))\n   i =\n  (\\<Sum>X | X \\<in> Pow (SIGMA x:A. {..<e x}) \\<and> i = sum e A - card X.\n     (- (1::'b)) ^ card X * (\\<Prod>x\\<in>X. f (fst x)))\n\ngoal (1 subgoal):\n 1. poly.coeff (\\<Prod>x\\<in>A. [:- f x, 1::'b:] ^ e x) i =\n    (\\<Sum>X | X \\<in> Pow (SIGMA x:A. {..<e x}) \\<and>\n               i = sum e A - card X.\n       (- (1::'b)) ^ card X * (\\<Prod>x\\<in>X. f (fst x)))", "finally"], ["proof (chain)\npicking this:\n  poly.coeff (\\<Prod>x\\<in>A. [:- f x, 1::'b:] ^ e x) i =\n  (\\<Sum>X | X \\<in> Pow (SIGMA x:A. {..<e x}) \\<and> i = sum e A - card X.\n     (- (1::'b)) ^ card X * (\\<Prod>x\\<in>X. f (fst x)))", "show ?thesis"], ["proof (prove)\nusing this:\n  poly.coeff (\\<Prod>x\\<in>A. [:- f x, 1::'b:] ^ e x) i =\n  (\\<Sum>X | X \\<in> Pow (SIGMA x:A. {..<e x}) \\<and> i = sum e A - card X.\n     (- (1::'b)) ^ card X * (\\<Prod>x\\<in>X. f (fst x)))\n\ngoal (1 subgoal):\n 1. poly.coeff (\\<Prod>x\\<in>A. [:- f x, 1::'b:] ^ e x) i =\n    (\\<Sum>X | X \\<in> Pow (SIGMA x:A. {..<e x}) \\<and>\n               i = sum e A - card X.\n       (- (1::'b)) ^ card X * (\\<Prod>x\\<in>X. f (fst x)))", "."], ["proof (state)\nthis:\n  poly.coeff (\\<Prod>x\\<in>A. [:- f x, 1::'b:] ^ e x) i =\n  (\\<Sum>X | X \\<in> Pow (SIGMA x:A. {..<e x}) \\<and> i = sum e A - card X.\n     (- (1::'b)) ^ card X * (\\<Prod>x\\<in>X. f (fst x)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in comm_ring_hom) synthetic_div_hom:\n  \"synthetic_div (map_poly hom p) (hom x) = map_poly hom (synthetic_div p x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. synthetic_div (map_poly hom p) (hom x) =\n    map_poly hom (synthetic_div p x)", "by (induction p) (auto simp: map_poly_pCons_hom)"], ["", "lemma synthetic_div_altdef:\n  fixes p :: \"'a :: field poly\"\n  shows \"synthetic_div p c = p div [:-c, 1:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. synthetic_div p c = p div [:- c, 1::'a:]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. synthetic_div p c = p div [:- c, 1::'a:]", "define q where \"q = p div [:- c, 1:]\""], ["proof (state)\nthis:\n  q = p div [:- c, 1::'a:]\n\ngoal (1 subgoal):\n 1. synthetic_div p c = p div [:- c, 1::'a:]", "have \"Polynomial.degree (p mod [:-c, 1:]) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.degree (p mod [:- c, 1::'a:]) = 0", "proof (cases \"p mod [:-c, 1:] = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p mod [:- c, 1::'a:] = 0 \\<Longrightarrow>\n    Polynomial.degree (p mod [:- c, 1::'a:]) = 0\n 2. p mod [:- c, 1::'a:] \\<noteq> 0 \\<Longrightarrow>\n    Polynomial.degree (p mod [:- c, 1::'a:]) = 0", "case False"], ["proof (state)\nthis:\n  p mod [:- c, 1::'a:] \\<noteq> 0\n\ngoal (2 subgoals):\n 1. p mod [:- c, 1::'a:] = 0 \\<Longrightarrow>\n    Polynomial.degree (p mod [:- c, 1::'a:]) = 0\n 2. p mod [:- c, 1::'a:] \\<noteq> 0 \\<Longrightarrow>\n    Polynomial.degree (p mod [:- c, 1::'a:]) = 0", "hence \"Polynomial.degree (p mod [:-c, 1:]) < Polynomial.degree [:-c, 1:]\""], ["proof (prove)\nusing this:\n  p mod [:- c, 1::'a:] \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Polynomial.degree (p mod [:- c, 1::'a:])\n    < Polynomial.degree [:- c, 1::'a:]", "by (intro degree_mod_less') auto"], ["proof (state)\nthis:\n  Polynomial.degree (p mod [:- c, 1::'a:])\n  < Polynomial.degree [:- c, 1::'a:]\n\ngoal (2 subgoals):\n 1. p mod [:- c, 1::'a:] = 0 \\<Longrightarrow>\n    Polynomial.degree (p mod [:- c, 1::'a:]) = 0\n 2. p mod [:- c, 1::'a:] \\<noteq> 0 \\<Longrightarrow>\n    Polynomial.degree (p mod [:- c, 1::'a:]) = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  Polynomial.degree (p mod [:- c, 1::'a:])\n  < Polynomial.degree [:- c, 1::'a:]\n\ngoal (1 subgoal):\n 1. Polynomial.degree (p mod [:- c, 1::'a:]) = 0", "by simp"], ["proof (state)\nthis:\n  Polynomial.degree (p mod [:- c, 1::'a:]) = 0\n\ngoal (1 subgoal):\n 1. p mod [:- c, 1::'a:] = 0 \\<Longrightarrow>\n    Polynomial.degree (p mod [:- c, 1::'a:]) = 0", "qed auto"], ["proof (state)\nthis:\n  Polynomial.degree (p mod [:- c, 1::'a:]) = 0\n\ngoal (1 subgoal):\n 1. synthetic_div p c = p div [:- c, 1::'a:]", "then"], ["proof (chain)\npicking this:\n  Polynomial.degree (p mod [:- c, 1::'a:]) = 0", "obtain d where d: \"p mod [:-c, 1:] = [:d:]\""], ["proof (prove)\nusing this:\n  Polynomial.degree (p mod [:- c, 1::'a:]) = 0\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        p mod [:- c, 1::'a:] = [:d:] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (elim degree_eq_zeroE)"], ["proof (state)\nthis:\n  p mod [:- c, 1::'a:] = [:d:]\n\ngoal (1 subgoal):\n 1. synthetic_div p c = p div [:- c, 1::'a:]", "have p_eq: \"p = q * [:-c, 1:] + [:d:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = q * [:- c, 1::'a:] + [:d:]", "unfolding q_def d [symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. p = p div [:- c, 1::'a:] * [:- c, 1::'a:] + p mod [:- c, 1::'a:]", "by presburger"], ["proof (state)\nthis:\n  p = q * [:- c, 1::'a:] + [:d:]\n\ngoal (1 subgoal):\n 1. synthetic_div p c = p div [:- c, 1::'a:]", "have [simp]: \"poly p c = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p c = d", "by (simp add: p_eq)"], ["proof (state)\nthis:\n  poly p c = d\n\ngoal (1 subgoal):\n 1. synthetic_div p c = p div [:- c, 1::'a:]", "have \"p + Polynomial.smult c q = pCons (poly p c) q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p + Polynomial.smult c q = pCons (poly p c) q", "by (subst p_eq) auto"], ["proof (state)\nthis:\n  p + Polynomial.smult c q = pCons (poly p c) q\n\ngoal (1 subgoal):\n 1. synthetic_div p c = p div [:- c, 1::'a:]", "from synthetic_div_unique[OF this]"], ["proof (chain)\npicking this:\n  poly p c = poly p c \\<and> q = synthetic_div p c", "show ?thesis"], ["proof (prove)\nusing this:\n  poly p c = poly p c \\<and> q = synthetic_div p c\n\ngoal (1 subgoal):\n 1. synthetic_div p c = p div [:- c, 1::'a:]", "by (auto simp: q_def)"], ["proof (state)\nthis:\n  synthetic_div p c = p div [:- c, 1::'a:]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma (in ring_closed) poly_closed [intro]:\n  assumes \"\\<And>i. poly.coeff p i \\<in> A\" \"x \\<in> A\"\n  shows   \"poly p x \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly p x \\<in> A", "unfolding poly_altdef"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i\\<le>Polynomial.degree p. poly.coeff p i * x ^ i) \\<in> A", "by (intro sum_closed mult_closed power_closed assms)"], ["", "lemma (in ring_closed) coeff_pCons_closed [intro]:\n  assumes \"\\<And>i. poly.coeff p i \\<in> A\" \"x \\<in> A\"\n  shows   \"poly.coeff (pCons x p) i \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly.coeff (pCons x p) i \\<in> A", "unfolding poly_altdef"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly.coeff (pCons x p) i \\<in> A", "using assms"], ["proof (prove)\nusing this:\n  poly.coeff p ?i \\<in> A\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. poly.coeff (pCons x p) i \\<in> A", "by (auto simp: coeff_pCons split: nat.splits)"], ["", "lemma (in ring_closed) coeff_poly_mult_closed [intro]:\n  assumes \"\\<And>i. poly.coeff p i \\<in> A\" \"\\<And>i. poly.coeff q i \\<in> A\"\n  shows   \"poly.coeff (p * q) i \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly.coeff (p * q) i \\<in> A", "unfolding coeff_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>ia\\<le>i. poly.coeff p ia * poly.coeff q (i - ia)) \\<in> A", "using assms"], ["proof (prove)\nusing this:\n  poly.coeff p ?i \\<in> A\n  poly.coeff q ?i \\<in> A\n\ngoal (1 subgoal):\n 1. (\\<Sum>ia\\<le>i. poly.coeff p ia * poly.coeff q (i - ia)) \\<in> A", "by auto"], ["", "lemma (in ring_closed) coeff_poly_prod_closed [intro]:\n  assumes \"\\<And>x i. x \\<in> X \\<Longrightarrow> poly.coeff (f x) i \\<in> A\"\n  shows   \"poly.coeff (prod f X) i \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly.coeff (prod f X) i \\<in> A", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> X \\<Longrightarrow> poly.coeff (f ?x) ?i \\<in> A\n\ngoal (1 subgoal):\n 1. poly.coeff (prod f X) i \\<in> A", "by (induction X arbitrary: i rule: infinite_finite_induct) auto"], ["", "lemma (in ring_closed) coeff_poly_power_closed [intro]:\n  assumes \"\\<And>i. poly.coeff p i \\<in> A\"\n  shows   \"poly.coeff (p ^ n) i \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly.coeff (p ^ n) i \\<in> A", "using coeff_poly_prod_closed[of \"{..<n}\" \"\\<lambda>_. p\" i] assms"], ["proof (prove)\nusing this:\n  (\\<And>x i.\n      x \\<in> {..<n} \\<Longrightarrow>\n      poly.coeff p i \\<in> A) \\<Longrightarrow>\n  poly.coeff (\\<Prod>_<n. p) i \\<in> A\n  poly.coeff p ?i \\<in> A\n\ngoal (1 subgoal):\n 1. poly.coeff (p ^ n) i \\<in> A", "by simp"], ["", "lemma (in ring_closed) synthetic_div_closed:\n  assumes \"\\<And>i. poly.coeff p i \\<in> A\" \"x \\<in> A\"\n  shows   \"poly.coeff (synthetic_div p x) i \\<in> A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly.coeff (synthetic_div p x) i \\<in> A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly.coeff (synthetic_div p x) i \\<in> A", "from assms(1)"], ["proof (chain)\npicking this:\n  poly.coeff p ?i \\<in> A", "have \"\\<forall>i. poly.coeff p i \\<in> A\""], ["proof (prove)\nusing this:\n  poly.coeff p ?i \\<in> A\n\ngoal (1 subgoal):\n 1. \\<forall>i. poly.coeff p i \\<in> A", "by blast"], ["proof (state)\nthis:\n  \\<forall>i. poly.coeff p i \\<in> A\n\ngoal (1 subgoal):\n 1. poly.coeff (synthetic_div p x) i \\<in> A", "from this and assms(2)"], ["proof (chain)\npicking this:\n  \\<forall>i. poly.coeff p i \\<in> A\n  x \\<in> A", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>i. poly.coeff p i \\<in> A\n  x \\<in> A\n\ngoal (1 subgoal):\n 1. poly.coeff (synthetic_div p x) i \\<in> A", "by (induction p arbitrary: i) (auto simp: coeff_pCons split: nat.splits)"], ["proof (state)\nthis:\n  poly.coeff (synthetic_div p x) i \\<in> A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pcompose_monom: \"pcompose (Polynomial.monom c n) p = Polynomial.smult c (p ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.monom c n \\<circ>\\<^sub>p p = Polynomial.smult c (p ^ n)", "by (simp add: monom_altdef pcompose_hom.hom_power pcompose_smult)"], ["", "lemma poly_roots_uminus [simp]: \"poly_roots (-p) = poly_roots p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_roots (- p) = poly_roots p", "using poly_roots_smult[of \"-1\" p]"], ["proof (prove)\nusing this:\n  - (1::'a) \\<noteq> (0::'a) \\<Longrightarrow>\n  poly_roots (Polynomial.smult (- (1::'a)) p) = poly_roots p\n\ngoal (1 subgoal):\n 1. poly_roots (- p) = poly_roots p", "by (simp del: poly_roots_smult)"], ["", "lemma poly_roots_normalize [simp]:\n  fixes p :: \"'a :: {normalization_semidom, idom_divide} poly\"\n  shows \"poly_roots (normalize p) = poly_roots p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_roots (normalize p) = poly_roots p", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> poly_roots (normalize p) = poly_roots p\n 2. p \\<noteq> 0 \\<Longrightarrow> poly_roots (normalize p) = poly_roots p", "case [simp]: False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> poly_roots (normalize p) = poly_roots p\n 2. p \\<noteq> 0 \\<Longrightarrow> poly_roots (normalize p) = poly_roots p", "have \"poly_roots p = poly_roots (unit_factor p * normalize p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_roots p = poly_roots (unit_factor p * normalize p)", "by simp"], ["proof (state)\nthis:\n  poly_roots p = poly_roots (unit_factor p * normalize p)\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> poly_roots (normalize p) = poly_roots p\n 2. p \\<noteq> 0 \\<Longrightarrow> poly_roots (normalize p) = poly_roots p", "also"], ["proof (state)\nthis:\n  poly_roots p = poly_roots (unit_factor p * normalize p)\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> poly_roots (normalize p) = poly_roots p\n 2. p \\<noteq> 0 \\<Longrightarrow> poly_roots (normalize p) = poly_roots p", "have \"\\<dots> = poly_roots (normalize p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_roots (unit_factor p * normalize p) = poly_roots (normalize p)", "unfolding unit_factor_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_roots ([:unit_factor (Polynomial.lead_coeff p):] * normalize p) =\n    poly_roots (normalize p)", "by simp"], ["proof (state)\nthis:\n  poly_roots (unit_factor p * normalize p) = poly_roots (normalize p)\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow> poly_roots (normalize p) = poly_roots p\n 2. p \\<noteq> 0 \\<Longrightarrow> poly_roots (normalize p) = poly_roots p", "finally"], ["proof (chain)\npicking this:\n  poly_roots p = poly_roots (normalize p)", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_roots p = poly_roots (normalize p)\n\ngoal (1 subgoal):\n 1. poly_roots (normalize p) = poly_roots p", ".."], ["proof (state)\nthis:\n  poly_roots (normalize p) = poly_roots p\n\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow> poly_roots (normalize p) = poly_roots p", "qed auto"], ["", "lemma poly_roots_of_int_normalize [simp]:\n  \"poly_roots (of_int_poly (normalize p) :: 'a :: {idom, ring_char_0} poly) =\n   poly_roots (of_int_poly p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_roots (of_int_poly (normalize p)) = poly_roots (of_int_poly p)", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    poly_roots (of_int_poly (normalize p)) = poly_roots (of_int_poly p)\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    poly_roots (of_int_poly (normalize p)) = poly_roots (of_int_poly p)", "case [simp]: False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    poly_roots (of_int_poly (normalize p)) = poly_roots (of_int_poly p)\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    poly_roots (of_int_poly (normalize p)) = poly_roots (of_int_poly p)", "have \"poly_roots (of_int_poly p :: 'a poly) = poly_roots (of_int_poly (unit_factor p * normalize p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_roots (of_int_poly p) =\n    poly_roots (of_int_poly (unit_factor p * normalize p))", "by simp"], ["proof (state)\nthis:\n  poly_roots (of_int_poly p) =\n  poly_roots (of_int_poly (unit_factor p * normalize p))\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    poly_roots (of_int_poly (normalize p)) = poly_roots (of_int_poly p)\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    poly_roots (of_int_poly (normalize p)) = poly_roots (of_int_poly p)", "also"], ["proof (state)\nthis:\n  poly_roots (of_int_poly p) =\n  poly_roots (of_int_poly (unit_factor p * normalize p))\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    poly_roots (of_int_poly (normalize p)) = poly_roots (of_int_poly p)\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    poly_roots (of_int_poly (normalize p)) = poly_roots (of_int_poly p)", "have \"\\<dots> = poly_roots (Polynomial.smult (of_int (sgn (Polynomial.lead_coeff p)))\n                    (of_int_poly (normalize p)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_roots (of_int_poly (unit_factor p * normalize p)) =\n    poly_roots\n     (Polynomial.smult (of_int (sgn (Polynomial.lead_coeff p)))\n       (of_int_poly (normalize p)))", "by (simp add: unit_factor_poly_def of_int_hom.map_poly_hom_smult)"], ["proof (state)\nthis:\n  poly_roots (of_int_poly (unit_factor p * normalize p)) =\n  poly_roots\n   (Polynomial.smult (of_int (sgn (Polynomial.lead_coeff p)))\n     (of_int_poly (normalize p)))\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    poly_roots (of_int_poly (normalize p)) = poly_roots (of_int_poly p)\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    poly_roots (of_int_poly (normalize p)) = poly_roots (of_int_poly p)", "also"], ["proof (state)\nthis:\n  poly_roots (of_int_poly (unit_factor p * normalize p)) =\n  poly_roots\n   (Polynomial.smult (of_int (sgn (Polynomial.lead_coeff p)))\n     (of_int_poly (normalize p)))\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    poly_roots (of_int_poly (normalize p)) = poly_roots (of_int_poly p)\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    poly_roots (of_int_poly (normalize p)) = poly_roots (of_int_poly p)", "have \"\\<dots> = poly_roots (Ring_Hom_Poly.of_int_poly (normalize p) :: 'a poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_roots\n     (Polynomial.smult (of_int (sgn (Polynomial.lead_coeff p)))\n       (of_int_poly (normalize p))) =\n    poly_roots (of_int_poly (normalize p))", "by (intro poly_roots_smult) (auto simp: sgn_if)"], ["proof (state)\nthis:\n  poly_roots\n   (Polynomial.smult (of_int (sgn (Polynomial.lead_coeff p)))\n     (of_int_poly (normalize p))) =\n  poly_roots (of_int_poly (normalize p))\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    poly_roots (of_int_poly (normalize p)) = poly_roots (of_int_poly p)\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    poly_roots (of_int_poly (normalize p)) = poly_roots (of_int_poly p)", "finally"], ["proof (chain)\npicking this:\n  poly_roots (of_int_poly p) = poly_roots (of_int_poly (normalize p))", "show ?thesis"], ["proof (prove)\nusing this:\n  poly_roots (of_int_poly p) = poly_roots (of_int_poly (normalize p))\n\ngoal (1 subgoal):\n 1. poly_roots (of_int_poly (normalize p)) = poly_roots (of_int_poly p)", ".."], ["proof (state)\nthis:\n  poly_roots (of_int_poly (normalize p)) = poly_roots (of_int_poly p)\n\ngoal (1 subgoal):\n 1. p = 0 \\<Longrightarrow>\n    poly_roots (of_int_poly (normalize p)) = poly_roots (of_int_poly p)", "qed auto"], ["", "lemma poly_roots_power [simp]: \"poly_roots (p ^ n) = repeat_mset n (poly_roots p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_roots (p ^ n) = repeat_mset n (poly_roots p)", "proof (cases \"p = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    poly_roots (p ^ n) = repeat_mset n (poly_roots p)\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    poly_roots (p ^ n) = repeat_mset n (poly_roots p)", "case True"], ["proof (state)\nthis:\n  p = 0\n\ngoal (2 subgoals):\n 1. p = 0 \\<Longrightarrow>\n    poly_roots (p ^ n) = repeat_mset n (poly_roots p)\n 2. p \\<noteq> 0 \\<Longrightarrow>\n    poly_roots (p ^ n) = repeat_mset n (poly_roots p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  p = 0\n\ngoal (1 subgoal):\n 1. poly_roots (p ^ n) = repeat_mset n (poly_roots p)", "by (cases n) auto"], ["proof (state)\nthis:\n  poly_roots (p ^ n) = repeat_mset n (poly_roots p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    poly_roots (p ^ n) = repeat_mset n (poly_roots p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    poly_roots (p ^ n) = repeat_mset n (poly_roots p)", "case False"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0 \\<Longrightarrow>\n    poly_roots (p ^ n) = repeat_mset n (poly_roots p)", "thus ?thesis"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly_roots (p ^ n) = repeat_mset n (poly_roots p)", "by (induction n) (auto simp: poly_roots_mult)"], ["proof (state)\nthis:\n  poly_roots (p ^ n) = repeat_mset n (poly_roots p)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma poly_roots_conv_sum_prime_factors:\n  \"poly_roots q = (\\<Sum>p\\<in>#prime_factorization q. poly_roots p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_roots q =\n    \\<Sum>\\<^sub># (image_mset poly_roots (prime_factorization q))", "proof (cases \"q = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. q = 0 \\<Longrightarrow>\n    poly_roots q =\n    \\<Sum>\\<^sub># (image_mset poly_roots (prime_factorization q))\n 2. q \\<noteq> 0 \\<Longrightarrow>\n    poly_roots q =\n    \\<Sum>\\<^sub># (image_mset poly_roots (prime_factorization q))", "case [simp]: False"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (2 subgoals):\n 1. q = 0 \\<Longrightarrow>\n    poly_roots q =\n    \\<Sum>\\<^sub># (image_mset poly_roots (prime_factorization q))\n 2. q \\<noteq> 0 \\<Longrightarrow>\n    poly_roots q =\n    \\<Sum>\\<^sub># (image_mset poly_roots (prime_factorization q))", "have \"(\\<Sum>p\\<in>#prime_factorization q. poly_roots p) =\n        poly_roots (prod_mset (prime_factorization q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># (image_mset poly_roots (prime_factorization q)) =\n    poly_roots (\\<Prod>\\<^sub># (prime_factorization q))", "by (rule poly_roots_prod_mset [symmetric]) auto"], ["proof (state)\nthis:\n  \\<Sum>\\<^sub># (image_mset poly_roots (prime_factorization q)) =\n  poly_roots (\\<Prod>\\<^sub># (prime_factorization q))\n\ngoal (2 subgoals):\n 1. q = 0 \\<Longrightarrow>\n    poly_roots q =\n    \\<Sum>\\<^sub># (image_mset poly_roots (prime_factorization q))\n 2. q \\<noteq> 0 \\<Longrightarrow>\n    poly_roots q =\n    \\<Sum>\\<^sub># (image_mset poly_roots (prime_factorization q))", "also"], ["proof (state)\nthis:\n  \\<Sum>\\<^sub># (image_mset poly_roots (prime_factorization q)) =\n  poly_roots (\\<Prod>\\<^sub># (prime_factorization q))\n\ngoal (2 subgoals):\n 1. q = 0 \\<Longrightarrow>\n    poly_roots q =\n    \\<Sum>\\<^sub># (image_mset poly_roots (prime_factorization q))\n 2. q \\<noteq> 0 \\<Longrightarrow>\n    poly_roots q =\n    \\<Sum>\\<^sub># (image_mset poly_roots (prime_factorization q))", "have \"\\<dots> = poly_roots (normalize (prod_mset (prime_factorization q)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_roots (\\<Prod>\\<^sub># (prime_factorization q)) =\n    poly_roots (normalize (\\<Prod>\\<^sub># (prime_factorization q)))", "by simp"], ["proof (state)\nthis:\n  poly_roots (\\<Prod>\\<^sub># (prime_factorization q)) =\n  poly_roots (normalize (\\<Prod>\\<^sub># (prime_factorization q)))\n\ngoal (2 subgoals):\n 1. q = 0 \\<Longrightarrow>\n    poly_roots q =\n    \\<Sum>\\<^sub># (image_mset poly_roots (prime_factorization q))\n 2. q \\<noteq> 0 \\<Longrightarrow>\n    poly_roots q =\n    \\<Sum>\\<^sub># (image_mset poly_roots (prime_factorization q))", "also"], ["proof (state)\nthis:\n  poly_roots (\\<Prod>\\<^sub># (prime_factorization q)) =\n  poly_roots (normalize (\\<Prod>\\<^sub># (prime_factorization q)))\n\ngoal (2 subgoals):\n 1. q = 0 \\<Longrightarrow>\n    poly_roots q =\n    \\<Sum>\\<^sub># (image_mset poly_roots (prime_factorization q))\n 2. q \\<noteq> 0 \\<Longrightarrow>\n    poly_roots q =\n    \\<Sum>\\<^sub># (image_mset poly_roots (prime_factorization q))", "have \"normalize (prod_mset (prime_factorization q)) = normalize q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize (\\<Prod>\\<^sub># (prime_factorization q)) = normalize q", "by (rule prod_mset_prime_factorization_weak) auto"], ["proof (state)\nthis:\n  normalize (\\<Prod>\\<^sub># (prime_factorization q)) = normalize q\n\ngoal (2 subgoals):\n 1. q = 0 \\<Longrightarrow>\n    poly_roots q =\n    \\<Sum>\\<^sub># (image_mset poly_roots (prime_factorization q))\n 2. q \\<noteq> 0 \\<Longrightarrow>\n    poly_roots q =\n    \\<Sum>\\<^sub># (image_mset poly_roots (prime_factorization q))", "also"], ["proof (state)\nthis:\n  normalize (\\<Prod>\\<^sub># (prime_factorization q)) = normalize q\n\ngoal (2 subgoals):\n 1. q = 0 \\<Longrightarrow>\n    poly_roots q =\n    \\<Sum>\\<^sub># (image_mset poly_roots (prime_factorization q))\n 2. q \\<noteq> 0 \\<Longrightarrow>\n    poly_roots q =\n    \\<Sum>\\<^sub># (image_mset poly_roots (prime_factorization q))", "have \"poly_roots \\<dots> = poly_roots q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_roots (normalize q) = poly_roots q", "by simp"], ["proof (state)\nthis:\n  poly_roots (normalize q) = poly_roots q\n\ngoal (2 subgoals):\n 1. q = 0 \\<Longrightarrow>\n    poly_roots q =\n    \\<Sum>\\<^sub># (image_mset poly_roots (prime_factorization q))\n 2. q \\<noteq> 0 \\<Longrightarrow>\n    poly_roots q =\n    \\<Sum>\\<^sub># (image_mset poly_roots (prime_factorization q))", "finally"], ["proof (chain)\npicking this:\n  \\<Sum>\\<^sub># (image_mset poly_roots (prime_factorization q)) =\n  poly_roots q", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Sum>\\<^sub># (image_mset poly_roots (prime_factorization q)) =\n  poly_roots q\n\ngoal (1 subgoal):\n 1. poly_roots q =\n    \\<Sum>\\<^sub># (image_mset poly_roots (prime_factorization q))", ".."], ["proof (state)\nthis:\n  poly_roots q =\n  \\<Sum>\\<^sub># (image_mset poly_roots (prime_factorization q))\n\ngoal (1 subgoal):\n 1. q = 0 \\<Longrightarrow>\n    poly_roots q =\n    \\<Sum>\\<^sub># (image_mset poly_roots (prime_factorization q))", "qed auto"], ["", "lemma poly_roots_of_int_conv_sum_prime_factors:\n  \"poly_roots (of_int_poly q :: 'a :: {idom, ring_char_0} poly) =\n   (\\<Sum>p\\<in>#prime_factorization q. poly_roots (of_int_poly p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_roots (of_int_poly q) =\n    (\\<Sum>p\\<in>#prime_factorization q. poly_roots (of_int_poly p))", "proof (cases \"q = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. q = 0 \\<Longrightarrow>\n    poly_roots (of_int_poly q) =\n    (\\<Sum>p\\<in>#prime_factorization q. poly_roots (of_int_poly p))\n 2. q \\<noteq> 0 \\<Longrightarrow>\n    poly_roots (of_int_poly q) =\n    (\\<Sum>p\\<in>#prime_factorization q. poly_roots (of_int_poly p))", "case [simp]: False"], ["proof (state)\nthis:\n  q \\<noteq> 0\n\ngoal (2 subgoals):\n 1. q = 0 \\<Longrightarrow>\n    poly_roots (of_int_poly q) =\n    (\\<Sum>p\\<in>#prime_factorization q. poly_roots (of_int_poly p))\n 2. q \\<noteq> 0 \\<Longrightarrow>\n    poly_roots (of_int_poly q) =\n    (\\<Sum>p\\<in>#prime_factorization q. poly_roots (of_int_poly p))", "have \"(\\<Sum>p\\<in>#prime_factorization q. poly_roots (of_int_poly p :: 'a poly)) =\n        poly_roots (\\<Prod>p\\<in>#prime_factorization q. of_int_poly p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>#prime_factorization q. poly_roots (of_int_poly p)) =\n    poly_roots\n     (\\<Prod>\\<^sub># (image_mset of_int_poly (prime_factorization q)))", "by (subst poly_roots_prod_mset) (auto simp: multiset.map_comp o_def)"], ["proof (state)\nthis:\n  (\\<Sum>p\\<in>#prime_factorization q. poly_roots (of_int_poly p)) =\n  poly_roots\n   (\\<Prod>\\<^sub># (image_mset of_int_poly (prime_factorization q)))\n\ngoal (2 subgoals):\n 1. q = 0 \\<Longrightarrow>\n    poly_roots (of_int_poly q) =\n    (\\<Sum>p\\<in>#prime_factorization q. poly_roots (of_int_poly p))\n 2. q \\<noteq> 0 \\<Longrightarrow>\n    poly_roots (of_int_poly q) =\n    (\\<Sum>p\\<in>#prime_factorization q. poly_roots (of_int_poly p))", "also"], ["proof (state)\nthis:\n  (\\<Sum>p\\<in>#prime_factorization q. poly_roots (of_int_poly p)) =\n  poly_roots\n   (\\<Prod>\\<^sub># (image_mset of_int_poly (prime_factorization q)))\n\ngoal (2 subgoals):\n 1. q = 0 \\<Longrightarrow>\n    poly_roots (of_int_poly q) =\n    (\\<Sum>p\\<in>#prime_factorization q. poly_roots (of_int_poly p))\n 2. q \\<noteq> 0 \\<Longrightarrow>\n    poly_roots (of_int_poly q) =\n    (\\<Sum>p\\<in>#prime_factorization q. poly_roots (of_int_poly p))", "have \"(\\<Prod>p\\<in>#prime_factorization q. of_int_poly p :: 'a poly) =\n               of_int_poly (prod_mset (prime_factorization q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Prod>\\<^sub># (image_mset of_int_poly (prime_factorization q)) =\n    of_int_poly (\\<Prod>\\<^sub># (prime_factorization q))", "by simp"], ["proof (state)\nthis:\n  \\<Prod>\\<^sub># (image_mset of_int_poly (prime_factorization q)) =\n  of_int_poly (\\<Prod>\\<^sub># (prime_factorization q))\n\ngoal (2 subgoals):\n 1. q = 0 \\<Longrightarrow>\n    poly_roots (of_int_poly q) =\n    (\\<Sum>p\\<in>#prime_factorization q. poly_roots (of_int_poly p))\n 2. q \\<noteq> 0 \\<Longrightarrow>\n    poly_roots (of_int_poly q) =\n    (\\<Sum>p\\<in>#prime_factorization q. poly_roots (of_int_poly p))", "also"], ["proof (state)\nthis:\n  \\<Prod>\\<^sub># (image_mset of_int_poly (prime_factorization q)) =\n  of_int_poly (\\<Prod>\\<^sub># (prime_factorization q))\n\ngoal (2 subgoals):\n 1. q = 0 \\<Longrightarrow>\n    poly_roots (of_int_poly q) =\n    (\\<Sum>p\\<in>#prime_factorization q. poly_roots (of_int_poly p))\n 2. q \\<noteq> 0 \\<Longrightarrow>\n    poly_roots (of_int_poly q) =\n    (\\<Sum>p\\<in>#prime_factorization q. poly_roots (of_int_poly p))", "have \"poly_roots \\<dots> = poly_roots (of_int_poly (normalize (prod_mset (prime_factorization q))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_roots (of_int_poly (\\<Prod>\\<^sub># (prime_factorization q))) =\n    poly_roots\n     (of_int_poly (normalize (\\<Prod>\\<^sub># (prime_factorization q))))", "by (rule poly_roots_of_int_normalize [symmetric])"], ["proof (state)\nthis:\n  poly_roots (of_int_poly (\\<Prod>\\<^sub># (prime_factorization q))) =\n  poly_roots\n   (of_int_poly (normalize (\\<Prod>\\<^sub># (prime_factorization q))))\n\ngoal (2 subgoals):\n 1. q = 0 \\<Longrightarrow>\n    poly_roots (of_int_poly q) =\n    (\\<Sum>p\\<in>#prime_factorization q. poly_roots (of_int_poly p))\n 2. q \\<noteq> 0 \\<Longrightarrow>\n    poly_roots (of_int_poly q) =\n    (\\<Sum>p\\<in>#prime_factorization q. poly_roots (of_int_poly p))", "also"], ["proof (state)\nthis:\n  poly_roots (of_int_poly (\\<Prod>\\<^sub># (prime_factorization q))) =\n  poly_roots\n   (of_int_poly (normalize (\\<Prod>\\<^sub># (prime_factorization q))))\n\ngoal (2 subgoals):\n 1. q = 0 \\<Longrightarrow>\n    poly_roots (of_int_poly q) =\n    (\\<Sum>p\\<in>#prime_factorization q. poly_roots (of_int_poly p))\n 2. q \\<noteq> 0 \\<Longrightarrow>\n    poly_roots (of_int_poly q) =\n    (\\<Sum>p\\<in>#prime_factorization q. poly_roots (of_int_poly p))", "have \"normalize (prod_mset (prime_factorization q)) = normalize q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize (\\<Prod>\\<^sub># (prime_factorization q)) = normalize q", "by (rule prod_mset_prime_factorization_weak) auto"], ["proof (state)\nthis:\n  normalize (\\<Prod>\\<^sub># (prime_factorization q)) = normalize q\n\ngoal (2 subgoals):\n 1. q = 0 \\<Longrightarrow>\n    poly_roots (of_int_poly q) =\n    (\\<Sum>p\\<in>#prime_factorization q. poly_roots (of_int_poly p))\n 2. q \\<noteq> 0 \\<Longrightarrow>\n    poly_roots (of_int_poly q) =\n    (\\<Sum>p\\<in>#prime_factorization q. poly_roots (of_int_poly p))", "also"], ["proof (state)\nthis:\n  normalize (\\<Prod>\\<^sub># (prime_factorization q)) = normalize q\n\ngoal (2 subgoals):\n 1. q = 0 \\<Longrightarrow>\n    poly_roots (of_int_poly q) =\n    (\\<Sum>p\\<in>#prime_factorization q. poly_roots (of_int_poly p))\n 2. q \\<noteq> 0 \\<Longrightarrow>\n    poly_roots (of_int_poly q) =\n    (\\<Sum>p\\<in>#prime_factorization q. poly_roots (of_int_poly p))", "have \"poly_roots (of_int_poly \\<dots> :: 'a poly) = poly_roots (of_int_poly q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_roots (of_int_poly (normalize q)) = poly_roots (of_int_poly q)", "by simp"], ["proof (state)\nthis:\n  poly_roots (of_int_poly (normalize q)) = poly_roots (of_int_poly q)\n\ngoal (2 subgoals):\n 1. q = 0 \\<Longrightarrow>\n    poly_roots (of_int_poly q) =\n    (\\<Sum>p\\<in>#prime_factorization q. poly_roots (of_int_poly p))\n 2. q \\<noteq> 0 \\<Longrightarrow>\n    poly_roots (of_int_poly q) =\n    (\\<Sum>p\\<in>#prime_factorization q. poly_roots (of_int_poly p))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>p\\<in>#prime_factorization q. poly_roots (of_int_poly p)) =\n  poly_roots (of_int_poly q)", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<Sum>p\\<in>#prime_factorization q. poly_roots (of_int_poly p)) =\n  poly_roots (of_int_poly q)\n\ngoal (1 subgoal):\n 1. poly_roots (of_int_poly q) =\n    (\\<Sum>p\\<in>#prime_factorization q. poly_roots (of_int_poly p))", ".."], ["proof (state)\nthis:\n  poly_roots (of_int_poly q) =\n  (\\<Sum>p\\<in>#prime_factorization q. poly_roots (of_int_poly p))\n\ngoal (1 subgoal):\n 1. q = 0 \\<Longrightarrow>\n    poly_roots (of_int_poly q) =\n    (\\<Sum>p\\<in>#prime_factorization q. poly_roots (of_int_poly p))", "qed auto"], ["", "lemma dvd_imp_poly_roots_subset:\n  assumes \"q \\<noteq> 0\" \"p dvd q\"\n  shows   \"poly_roots p \\<subseteq># poly_roots q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_roots p \\<subseteq># poly_roots q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. poly_roots p \\<subseteq># poly_roots q", "from assms"], ["proof (chain)\npicking this:\n  q \\<noteq> 0\n  p dvd q", "have \"p \\<noteq> 0\""], ["proof (prove)\nusing this:\n  q \\<noteq> 0\n  p dvd q\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly_roots p \\<subseteq># poly_roots q", "thus ?thesis"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. poly_roots p \\<subseteq># poly_roots q", "using assms"], ["proof (prove)\nusing this:\n  p \\<noteq> 0\n  q \\<noteq> 0\n  p dvd q\n\ngoal (1 subgoal):\n 1. poly_roots p \\<subseteq># poly_roots q", "by (intro mset_subset_eqI) (auto intro: dvd_imp_order_le)"], ["proof (state)\nthis:\n  poly_roots p \\<subseteq># poly_roots q\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma abs_prod_mset: \"\\<bar>prod_mset (A :: 'a :: idom_abs_sgn multiset)\\<bar> = prod_mset (image_mset abs A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>\\<Prod>\\<^sub># A\\<bar> = \\<Prod>\\<^sub># (image_mset abs A)", "by (induction A) (auto simp: abs_mult)"], ["", "lemma content_1_imp_nonconstant_prime_factors:\n  assumes \"content (p :: int poly) = 1\" and \"q \\<in> prime_factors p\"\n  shows   \"Polynomial.degree q > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < Polynomial.degree q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < Polynomial.degree q", "let ?d = \"Polynomial.degree :: int poly \\<Rightarrow> nat\""], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < Polynomial.degree q", "let ?lc = \"Polynomial.lead_coeff :: int poly \\<Rightarrow> int\""], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < Polynomial.degree q", "define P where \"P = prime_factorization p\""], ["proof (state)\nthis:\n  P = prime_factorization p\n\ngoal (1 subgoal):\n 1. 0 < Polynomial.degree q", "define P1 where \"P1 = filter_mset (\\<lambda>p. ?d p = 0) P\""], ["proof (state)\nthis:\n  P1 = {#p \\<in># P. Polynomial.degree p = 0#}\n\ngoal (1 subgoal):\n 1. 0 < Polynomial.degree q", "define P2 where \"P2 = filter_mset (\\<lambda>p. ?d p > 0) P\""], ["proof (state)\nthis:\n  P2 = {#p \\<in># P. 0 < Polynomial.degree p#}\n\ngoal (1 subgoal):\n 1. 0 < Polynomial.degree q", "have [simp]: \"p \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "using assms"], ["proof (prove)\nusing this:\n  content p = 1\n  q \\<in># prime_factorization p\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < Polynomial.degree q", "have \"1 = content (normalize p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 = content (normalize p)", "using assms"], ["proof (prove)\nusing this:\n  content p = 1\n  q \\<in># prime_factorization p\n\ngoal (1 subgoal):\n 1. 1 = content (normalize p)", "by simp"], ["proof (state)\nthis:\n  1 = content (normalize p)\n\ngoal (1 subgoal):\n 1. 0 < Polynomial.degree q", "also"], ["proof (state)\nthis:\n  1 = content (normalize p)\n\ngoal (1 subgoal):\n 1. 0 < Polynomial.degree q", "have \"normalize p = prod_mset P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize p = \\<Prod>\\<^sub># P", "unfolding P_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize p = \\<Prod>\\<^sub># (prime_factorization p)", "by (rule prod_mset_prime_factorization [symmetric]) auto"], ["proof (state)\nthis:\n  normalize p = \\<Prod>\\<^sub># P\n\ngoal (1 subgoal):\n 1. 0 < Polynomial.degree q", "also"], ["proof (state)\nthis:\n  normalize p = \\<Prod>\\<^sub># P\n\ngoal (1 subgoal):\n 1. 0 < Polynomial.degree q", "have \"P = filter_mset (\\<lambda>p. ?d p = 0) P + filter_mset (\\<lambda>p. ?d p > 0) P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P =\n    {#p \\<in># P. Polynomial.degree p = 0#} +\n    {#p \\<in># P. 0 < Polynomial.degree p#}", "by (induction P) auto"], ["proof (state)\nthis:\n  P =\n  {#p \\<in># P. Polynomial.degree p = 0#} +\n  {#p \\<in># P. 0 < Polynomial.degree p#}\n\ngoal (1 subgoal):\n 1. 0 < Polynomial.degree q", "also"], ["proof (state)\nthis:\n  P =\n  {#p \\<in># P. Polynomial.degree p = 0#} +\n  {#p \\<in># P. 0 < Polynomial.degree p#}\n\ngoal (1 subgoal):\n 1. 0 < Polynomial.degree q", "have \"prod_mset \\<dots> = prod_mset P1 * prod_mset P2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Prod>\\<^sub>#\n     ({#p \\<in># P. Polynomial.degree p = 0#} +\n      {#p \\<in># P. 0 < Polynomial.degree p#}) =\n    \\<Prod>\\<^sub># P1 * \\<Prod>\\<^sub># P2", "unfolding P1_def P2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Prod>\\<^sub>#\n     ({#p \\<in># P. Polynomial.degree p = 0#} +\n      {#p \\<in># P. 0 < Polynomial.degree p#}) =\n    \\<Prod>\\<^sub># {#p \\<in># P. Polynomial.degree p = 0#} *\n    \\<Prod>\\<^sub># {#p \\<in># P. 0 < Polynomial.degree p#}", "by (subst prod_mset.union) auto"], ["proof (state)\nthis:\n  \\<Prod>\\<^sub>#\n   ({#p \\<in># P. Polynomial.degree p = 0#} +\n    {#p \\<in># P. 0 < Polynomial.degree p#}) =\n  \\<Prod>\\<^sub># P1 * \\<Prod>\\<^sub># P2\n\ngoal (1 subgoal):\n 1. 0 < Polynomial.degree q", "also"], ["proof (state)\nthis:\n  \\<Prod>\\<^sub>#\n   ({#p \\<in># P. Polynomial.degree p = 0#} +\n    {#p \\<in># P. 0 < Polynomial.degree p#}) =\n  \\<Prod>\\<^sub># P1 * \\<Prod>\\<^sub># P2\n\ngoal (1 subgoal):\n 1. 0 < Polynomial.degree q", "have \"content \\<dots> = content (prod_mset P1) * content (prod_mset P2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. content (\\<Prod>\\<^sub># P1 * \\<Prod>\\<^sub># P2) =\n    content (\\<Prod>\\<^sub># P1) * content (\\<Prod>\\<^sub># P2)", "unfolding content_mult"], ["proof (prove)\ngoal (1 subgoal):\n 1. content (\\<Prod>\\<^sub># P1) * content (\\<Prod>\\<^sub># P2) =\n    content (\\<Prod>\\<^sub># P1) * content (\\<Prod>\\<^sub># P2)", ".."], ["proof (state)\nthis:\n  content (\\<Prod>\\<^sub># P1 * \\<Prod>\\<^sub># P2) =\n  content (\\<Prod>\\<^sub># P1) * content (\\<Prod>\\<^sub># P2)\n\ngoal (1 subgoal):\n 1. 0 < Polynomial.degree q", "also"], ["proof (state)\nthis:\n  content (\\<Prod>\\<^sub># P1 * \\<Prod>\\<^sub># P2) =\n  content (\\<Prod>\\<^sub># P1) * content (\\<Prod>\\<^sub># P2)\n\ngoal (1 subgoal):\n 1. 0 < Polynomial.degree q", "have \"image_mset id P1 = image_mset (\\<lambda>q. [:?lc q:]) P1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. image_mset id P1 = {#[:Polynomial.lead_coeff q:]. q \\<in># P1#}", "by (intro image_mset_cong) (auto simp: P1_def elim!: degree_eq_zeroE)"], ["proof (state)\nthis:\n  image_mset id P1 = {#[:Polynomial.lead_coeff q:]. q \\<in># P1#}\n\ngoal (1 subgoal):\n 1. 0 < Polynomial.degree q", "hence \"P1 = image_mset (\\<lambda>q. [:?lc q:]) P1\""], ["proof (prove)\nusing this:\n  image_mset id P1 = {#[:Polynomial.lead_coeff q:]. q \\<in># P1#}\n\ngoal (1 subgoal):\n 1. P1 = {#[:Polynomial.lead_coeff q:]. q \\<in># P1#}", "by simp"], ["proof (state)\nthis:\n  P1 = {#[:Polynomial.lead_coeff q:]. q \\<in># P1#}\n\ngoal (1 subgoal):\n 1. 0 < Polynomial.degree q", "also"], ["proof (state)\nthis:\n  P1 = {#[:Polynomial.lead_coeff q:]. q \\<in># P1#}\n\ngoal (1 subgoal):\n 1. 0 < Polynomial.degree q", "have \"content (prod_mset \\<dots>) = \\<bar>(\\<Prod>q\\<in>#P1. ?lc q)\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. content (\\<Prod>q\\<in>#P1. [:Polynomial.lead_coeff q:]) =\n    \\<bar>\\<Prod>\\<^sub># (image_mset Polynomial.lead_coeff P1)\\<bar>", "by (simp add: content_prod_mset multiset.map_comp o_def abs_prod_mset)"], ["proof (state)\nthis:\n  content (\\<Prod>q\\<in>#P1. [:Polynomial.lead_coeff q:]) =\n  \\<bar>\\<Prod>\\<^sub># (image_mset Polynomial.lead_coeff P1)\\<bar>\n\ngoal (1 subgoal):\n 1. 0 < Polynomial.degree q", "finally"], ["proof (chain)\npicking this:\n  1 =\n  \\<bar>\\<Prod>\\<^sub># (image_mset Polynomial.lead_coeff P1)\\<bar> *\n  content (\\<Prod>\\<^sub># P2)", "have \"\\<bar>(\\<Prod>q\\<in>#P1. ?lc q)\\<bar> * content (prod_mset P2) = 1\""], ["proof (prove)\nusing this:\n  1 =\n  \\<bar>\\<Prod>\\<^sub># (image_mset Polynomial.lead_coeff P1)\\<bar> *\n  content (\\<Prod>\\<^sub># P2)\n\ngoal (1 subgoal):\n 1. \\<bar>\\<Prod>\\<^sub># (image_mset Polynomial.lead_coeff P1)\\<bar> *\n    content (\\<Prod>\\<^sub># P2) =\n    1", ".."], ["proof (state)\nthis:\n  \\<bar>\\<Prod>\\<^sub># (image_mset Polynomial.lead_coeff P1)\\<bar> *\n  content (\\<Prod>\\<^sub># P2) =\n  1\n\ngoal (1 subgoal):\n 1. 0 < Polynomial.degree q", "hence \"\\<bar>(\\<Prod>q\\<in>#P1. ?lc q)\\<bar> dvd 1\""], ["proof (prove)\nusing this:\n  \\<bar>\\<Prod>\\<^sub># (image_mset Polynomial.lead_coeff P1)\\<bar> *\n  content (\\<Prod>\\<^sub># P2) =\n  1\n\ngoal (1 subgoal):\n 1. is_unit\n     \\<bar>\\<Prod>\\<^sub># (image_mset Polynomial.lead_coeff P1)\\<bar>", "unfolding dvd_def"], ["proof (prove)\nusing this:\n  \\<bar>\\<Prod>\\<^sub># (image_mset Polynomial.lead_coeff P1)\\<bar> *\n  content (\\<Prod>\\<^sub># P2) =\n  1\n\ngoal (1 subgoal):\n 1. \\<exists>k.\n       1 =\n       \\<bar>\\<Prod>\\<^sub># (image_mset Polynomial.lead_coeff P1)\\<bar> * k", "by metis"], ["proof (state)\nthis:\n  is_unit \\<bar>\\<Prod>\\<^sub># (image_mset Polynomial.lead_coeff P1)\\<bar>\n\ngoal (1 subgoal):\n 1. 0 < Polynomial.degree q", "have \"set_mset P1 = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_mset P1 = {}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. set_mset P1 \\<noteq> {} \\<Longrightarrow> False", "assume \"set_mset P1 \\<noteq> {}\""], ["proof (state)\nthis:\n  set_mset P1 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. set_mset P1 \\<noteq> {} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  set_mset P1 \\<noteq> {}", "obtain q where q: \"q \\<in># P1\""], ["proof (prove)\nusing this:\n  set_mset P1 \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>q. q \\<in># P1 \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  q \\<in># P1\n\ngoal (1 subgoal):\n 1. set_mset P1 \\<noteq> {} \\<Longrightarrow> False", "have \"\\<bar>?lc q\\<bar> dvd (\\<Prod>q\\<in>#P1. \\<bar>?lc q\\<bar>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>Polynomial.lead_coeff q\\<bar> dvd\n    (\\<Prod>q\\<in>#P1. \\<bar>Polynomial.lead_coeff q\\<bar>)", "by (rule dvd_prod_mset) (use q in auto)"], ["proof (state)\nthis:\n  \\<bar>Polynomial.lead_coeff q\\<bar> dvd\n  (\\<Prod>q\\<in>#P1. \\<bar>Polynomial.lead_coeff q\\<bar>)\n\ngoal (1 subgoal):\n 1. set_mset P1 \\<noteq> {} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  \\<bar>Polynomial.lead_coeff q\\<bar> dvd\n  (\\<Prod>q\\<in>#P1. \\<bar>Polynomial.lead_coeff q\\<bar>)\n\ngoal (1 subgoal):\n 1. set_mset P1 \\<noteq> {} \\<Longrightarrow> False", "have \"\\<dots> = \\<bar>(\\<Prod>q\\<in>#P1. ?lc q)\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>q\\<in>#P1. \\<bar>Polynomial.lead_coeff q\\<bar>) =\n    \\<bar>\\<Prod>\\<^sub># (image_mset Polynomial.lead_coeff P1)\\<bar>", "by (simp add: abs_prod_mset multiset.map_comp o_def)"], ["proof (state)\nthis:\n  (\\<Prod>q\\<in>#P1. \\<bar>Polynomial.lead_coeff q\\<bar>) =\n  \\<bar>\\<Prod>\\<^sub># (image_mset Polynomial.lead_coeff P1)\\<bar>\n\ngoal (1 subgoal):\n 1. set_mset P1 \\<noteq> {} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Prod>q\\<in>#P1. \\<bar>Polynomial.lead_coeff q\\<bar>) =\n  \\<bar>\\<Prod>\\<^sub># (image_mset Polynomial.lead_coeff P1)\\<bar>\n\ngoal (1 subgoal):\n 1. set_mset P1 \\<noteq> {} \\<Longrightarrow> False", "have \"\\<dots> dvd 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit\n     \\<bar>\\<Prod>\\<^sub># (image_mset Polynomial.lead_coeff P1)\\<bar>", "by fact"], ["proof (state)\nthis:\n  is_unit \\<bar>\\<Prod>\\<^sub># (image_mset Polynomial.lead_coeff P1)\\<bar>\n\ngoal (1 subgoal):\n 1. set_mset P1 \\<noteq> {} \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  is_unit \\<bar>Polynomial.lead_coeff q\\<bar>", "have \"is_unit (?lc q)\""], ["proof (prove)\nusing this:\n  is_unit \\<bar>Polynomial.lead_coeff q\\<bar>\n\ngoal (1 subgoal):\n 1. is_unit (Polynomial.lead_coeff q)", "by simp"], ["proof (state)\nthis:\n  is_unit (Polynomial.lead_coeff q)\n\ngoal (1 subgoal):\n 1. set_mset P1 \\<noteq> {} \\<Longrightarrow> False", "hence \"is_unit q\""], ["proof (prove)\nusing this:\n  is_unit (Polynomial.lead_coeff q)\n\ngoal (1 subgoal):\n 1. is_unit q", "using q"], ["proof (prove)\nusing this:\n  is_unit (Polynomial.lead_coeff q)\n  q \\<in># P1\n\ngoal (1 subgoal):\n 1. is_unit q", "unfolding P1_def"], ["proof (prove)\nusing this:\n  is_unit (Polynomial.lead_coeff q)\n  q \\<in># {#p \\<in># P. Polynomial.degree p = 0#}\n\ngoal (1 subgoal):\n 1. is_unit q", "by (auto elim!: degree_eq_zeroE)"], ["proof (state)\nthis:\n  is_unit q\n\ngoal (1 subgoal):\n 1. set_mset P1 \\<noteq> {} \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  is_unit q\n\ngoal (1 subgoal):\n 1. set_mset P1 \\<noteq> {} \\<Longrightarrow> False", "have \"prime q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime q", "using q"], ["proof (prove)\nusing this:\n  q \\<in># P1\n\ngoal (1 subgoal):\n 1. prime q", "unfolding P1_def P_def"], ["proof (prove)\nusing this:\n  q \\<in># {#p \\<in># prime_factorization p. Polynomial.degree p = 0#}\n\ngoal (1 subgoal):\n 1. prime q", "by auto"], ["proof (state)\nthis:\n  prime q\n\ngoal (1 subgoal):\n 1. set_mset P1 \\<noteq> {} \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  is_unit q\n  prime q", "show False"], ["proof (prove)\nusing this:\n  is_unit q\n  prime q\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set_mset P1 = {}\n\ngoal (1 subgoal):\n 1. 0 < Polynomial.degree q", "with assms"], ["proof (chain)\npicking this:\n  content p = 1\n  q \\<in># prime_factorization p\n  set_mset P1 = {}", "show ?thesis"], ["proof (prove)\nusing this:\n  content p = 1\n  q \\<in># prime_factorization p\n  set_mset P1 = {}\n\ngoal (1 subgoal):\n 1. 0 < Polynomial.degree q", "by (auto simp: P1_def P_def)"], ["proof (state)\nthis:\n  0 < Polynomial.degree q\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}