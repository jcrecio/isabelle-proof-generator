{"file_name": "/home/qj213/afp-2021-10-22/thys/Hermite_Lindemann/Hermite_Lindemann.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Hermite_Lindemann", "problem_names": ["lemma Hermite_Lindemann_aux1:\n  fixes P :: \"int poly set\" and \\<beta> :: \"int poly \\<Rightarrow> int\"\n  assumes \"finite P\" and \"P \\<noteq> {}\"\n  assumes distinct: \"pairwise Rings.coprime P\"\n  assumes irred: \"\\<And>p. p \\<in> P \\<Longrightarrow> irreducible p\"\n  assumes nonconstant: \"\\<And>p. p \\<in> P \\<Longrightarrow> Polynomial.degree p > 0\"\n  assumes \\<beta>_nz: \"\\<And>p. p \\<in> P \\<Longrightarrow> \\<beta> p \\<noteq> 0\"\n  defines \"Roots \\<equiv> (\\<lambda>p. {\\<alpha>::complex. poly (of_int_poly p) \\<alpha> = 0})\"\n  shows   \"(\\<Sum>p\\<in>P. of_int (\\<beta> p) * (\\<Sum>\\<alpha>\\<in>Roots p. exp \\<alpha>)) \\<noteq> 0\"", "lemma Hermite_Lindemann_aux2:\n  fixes X :: \"complex set\" and \\<beta> :: \"complex \\<Rightarrow> int\"\n  assumes \"finite X\"\n  assumes nz:   \"\\<And>x. x \\<in> X \\<Longrightarrow> \\<beta> x \\<noteq> 0\"\n  assumes alg:  \"\\<And>x. x \\<in> X \\<Longrightarrow> algebraic x\"\n  assumes sum0: \"(\\<Sum>x\\<in>X. of_int (\\<beta> x) * exp x) = 0\"\n  shows   \"X = {}\"", "lemma Hermite_Lindemann_aux3:\n  fixes X :: \"complex set\" and \\<beta> :: \"complex \\<Rightarrow> rat\"\n  assumes \"finite X\"\n  assumes nz:   \"\\<And>x. x \\<in> X \\<Longrightarrow> \\<beta> x \\<noteq> 0\"\n  assumes alg:  \"\\<And>x. x \\<in> X \\<Longrightarrow> algebraic x\"\n  assumes sum0: \"(\\<Sum>x\\<in>X. of_rat (\\<beta> x) * exp x) = 0\"\n  shows   \"X = {}\"", "lemma Hermite_Lindemann_aux4:\n  fixes \\<beta> :: \"complex \\<Rightarrow> complex\"\n  assumes [intro]: \"finite X\"\n  assumes alg1: \"\\<And>x. x \\<in> X \\<Longrightarrow> algebraic x\"\n  assumes alg2: \"\\<And>x. x \\<in> X \\<Longrightarrow> algebraic (\\<beta> x)\"\n  assumes nz:   \"\\<And>x. x \\<in> X \\<Longrightarrow> \\<beta> x \\<noteq> 0\"\n  assumes sum0: \"(\\<Sum>x\\<in>X. \\<beta> x * exp x) = 0\"\n  shows   \"X = {}\"", "lemma Hermite_Lindemann':\n  fixes \\<beta> :: \"complex \\<Rightarrow> complex\"\n  assumes \"finite X\"\n  assumes \"\\<And>x. x \\<in> X \\<Longrightarrow> algebraic x\"\n  assumes \"\\<And>x. x \\<in> X \\<Longrightarrow> algebraic (\\<beta> x)\"\n  assumes \"(\\<Sum>x\\<in>X. \\<beta> x * exp x) = 0\"\n  shows   \"\\<forall>x\\<in>X. \\<beta> x = 0\"", "theorem Hermite_Lindemann:\n  fixes \\<alpha> \\<beta> :: \"'a \\<Rightarrow> complex\"\n  assumes \"finite I\"\n  assumes \"\\<And>x. x \\<in> I \\<Longrightarrow> algebraic (\\<alpha> x)\"\n  assumes \"\\<And>x. x \\<in> I \\<Longrightarrow> algebraic (\\<beta> x)\"\n  assumes \"inj_on \\<alpha> I\"\n  assumes \"(\\<Sum>x\\<in>I. \\<beta> x * exp (\\<alpha> x)) = 0\"\n  shows   \"\\<forall>x\\<in>I. \\<beta> x = 0\"", "lemma transcendental_sinh:\n  assumes \"algebraic z\" \"z \\<noteq> 0\"\n  shows   \"\\<not>algebraic (sinh z :: complex)\"", "lemma transcendental_cosh:\n  assumes \"algebraic z\" \"z \\<noteq> 0\"\n  shows   \"\\<not>algebraic (cosh z :: complex)\"", "lemma transcendental_sin:\n  assumes \"algebraic z\" \"z \\<noteq> 0\"\n  shows   \"\\<not>algebraic (sin z :: complex)\"", "lemma transcendental_cos:\n  assumes \"algebraic z\" \"z \\<noteq> 0\"\n  shows   \"\\<not>algebraic (cos z :: complex)\"", "lemma tan_square_neq_neg1: \"tan (z :: complex) ^ 2 \\<noteq> -1\"", "lemma transcendental_tan:\n  assumes \"algebraic z\" \"z \\<noteq> 0\"\n  shows   \"\\<not>algebraic (tan z :: complex)\"", "lemma transcendental_cot:\n  assumes \"algebraic z\" \"z \\<noteq> 0\"\n  shows   \"\\<not>algebraic (cot z :: complex)\"", "lemma transcendental_tanh:\n  assumes \"algebraic z\" \"z \\<noteq> 0\" \"cosh z \\<noteq> 0\"\n  shows   \"\\<not>algebraic (tanh z :: complex)\"", "lemma transcendental_Arcsin:\n  assumes \"algebraic z\" \"z \\<noteq> 0\"\n  shows   \"\\<not>algebraic (Arcsin z)\"", "lemma transcendental_Arccos:\n  assumes \"algebraic z\" \"z \\<noteq> 1\"\n  shows   \"\\<not>algebraic (Arccos z)\"", "lemma transcendental_Arctan:\n  assumes \"algebraic z\" \"z \\<notin> {0, \\<i>, -\\<i>}\"\n  shows   \"\\<not>algebraic (Arctan z)\""], "translations": [["", "lemma Hermite_Lindemann_aux1:\n  fixes P :: \"int poly set\" and \\<beta> :: \"int poly \\<Rightarrow> int\"\n  assumes \"finite P\" and \"P \\<noteq> {}\"\n  assumes distinct: \"pairwise Rings.coprime P\"\n  assumes irred: \"\\<And>p. p \\<in> P \\<Longrightarrow> irreducible p\"\n  assumes nonconstant: \"\\<And>p. p \\<in> P \\<Longrightarrow> Polynomial.degree p > 0\"\n  assumes \\<beta>_nz: \"\\<And>p. p \\<in> P \\<Longrightarrow> \\<beta> p \\<noteq> 0\"\n  defines \"Roots \\<equiv> (\\<lambda>p. {\\<alpha>::complex. poly (of_int_poly p) \\<alpha> = 0})\"\n  shows   \"(\\<Sum>p\\<in>P. of_int (\\<beta> p) * (\\<Sum>\\<alpha>\\<in>Roots p. exp \\<alpha>)) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) \\<noteq> 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "note [intro] = \\<open>finite P\\<close>"], ["proof (state)\nthis:\n  finite P\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "assume sum_eq_0: \"(\\<Sum>p\\<in>P. of_int (\\<beta> p) * (\\<Sum>\\<alpha>\\<in>Roots p. exp \\<alpha>)) = 0\""], ["proof (state)\nthis:\n  (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "define Roots' where \"Roots' = (\\<Union>p\\<in>P. Roots p)\""], ["proof (state)\nthis:\n  Roots' = \\<Union> (Roots ` P)\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "have finite_Roots [intro]: \"finite (Roots p)\" if \"p \\<in> P\" for p"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Roots p)", "using nonconstant[of p] that"], ["proof (prove)\nusing this:\n  p \\<in> P \\<Longrightarrow> 0 < Polynomial.degree p\n  p \\<in> P\n\ngoal (1 subgoal):\n 1. finite (Roots p)", "by (auto intro: poly_roots_finite simp: Roots_def)"], ["proof (state)\nthis:\n  ?p \\<in> P \\<Longrightarrow> finite (Roots ?p)\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "have [intro]: \"finite Roots'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite Roots'", "by (auto simp: Roots'_def)"], ["proof (state)\nthis:\n  finite Roots'\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "have [simp]: \"0 \\<notin> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> P", "using nonconstant[of 0]"], ["proof (prove)\nusing this:\n  0 \\<in> P \\<Longrightarrow> 0 < Polynomial.degree 0\n\ngoal (1 subgoal):\n 1. 0 \\<notin> P", "by auto"], ["proof (state)\nthis:\n  0 \\<notin> P\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "have [simp]: \"p \\<noteq> 0\" if \"p \\<in> P\" for p"], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "using that"], ["proof (prove)\nusing this:\n  p \\<in> P\n\ngoal (1 subgoal):\n 1. p \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  ?p \\<in> P \\<Longrightarrow> ?p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "text \\<open>\n    The polynomials in \\<^term>\\<open>P\\<close> do not have multiple roots:\n  \\<close>"], ["proof (state)\nthis:\n  ?p \\<in> P \\<Longrightarrow> ?p \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "have rsquarefree: \"rsquarefree (of_int_poly q :: complex poly)\" if \"q \\<in> P\" for q"], ["proof (prove)\ngoal (1 subgoal):\n 1. rsquarefree (Ring_Hom_Poly.of_int_poly q)", "by (rule irreducible_imp_rsquarefree_of_int_poly) (use that in \\<open>auto intro: irred nonconstant\\<close>)"], ["proof (state)\nthis:\n  ?q \\<in> P \\<Longrightarrow> rsquarefree (Ring_Hom_Poly.of_int_poly ?q)\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "text \\<open>\n    No two different polynomials in \\<^term>\\<open>P\\<close> have roots in common:\n  \\<close>"], ["proof (state)\nthis:\n  ?q \\<in> P \\<Longrightarrow> rsquarefree (Ring_Hom_Poly.of_int_poly ?q)\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "have disjoint: \"disjoint_family_on Roots P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. disjoint_family_on Roots P", "using distinct"], ["proof (prove)\nusing this:\n  pairwise algebraic_semidom_class.coprime P\n\ngoal (1 subgoal):\n 1. disjoint_family_on Roots P", "proof (rule pairwise_imp_disjoint_family_on)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>m \\<in> P; n \\<in> P;\n        algebraic_semidom_class.coprime m n\\<rbrakk>\n       \\<Longrightarrow> Roots m \\<inter> Roots n = {}", "fix p q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>m \\<in> P; n \\<in> P;\n        algebraic_semidom_class.coprime m n\\<rbrakk>\n       \\<Longrightarrow> Roots m \\<inter> Roots n = {}", "assume P: \"p \\<in> P\" \"q \\<in> P\" and \"Rings.coprime p q\""], ["proof (state)\nthis:\n  p \\<in> P\n  q \\<in> P\n  algebraic_semidom_class.coprime p q\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>m \\<in> P; n \\<in> P;\n        algebraic_semidom_class.coprime m n\\<rbrakk>\n       \\<Longrightarrow> Roots m \\<inter> Roots n = {}", "hence \"Rings.coprime (of_int_poly p :: complex poly) (of_int_poly q)\""], ["proof (prove)\nusing this:\n  p \\<in> P\n  q \\<in> P\n  algebraic_semidom_class.coprime p q\n\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime (Ring_Hom_Poly.of_int_poly p)\n     (Ring_Hom_Poly.of_int_poly q)", "by (intro coprime_of_int_polyI)"], ["proof (state)\nthis:\n  algebraic_semidom_class.coprime (Ring_Hom_Poly.of_int_poly p)\n   (Ring_Hom_Poly.of_int_poly q)\n\ngoal (1 subgoal):\n 1. \\<And>m n.\n       \\<lbrakk>m \\<in> P; n \\<in> P;\n        algebraic_semidom_class.coprime m n\\<rbrakk>\n       \\<Longrightarrow> Roots m \\<inter> Roots n = {}", "thus \"Roots p \\<inter> Roots q = {}\""], ["proof (prove)\nusing this:\n  algebraic_semidom_class.coprime (Ring_Hom_Poly.of_int_poly p)\n   (Ring_Hom_Poly.of_int_poly q)\n\ngoal (1 subgoal):\n 1. Roots p \\<inter> Roots q = {}", "using poly_eq_0_coprime[of \"of_int_poly p\" \"of_int_poly q :: complex poly\"] P"], ["proof (prove)\nusing this:\n  algebraic_semidom_class.coprime (Ring_Hom_Poly.of_int_poly p)\n   (Ring_Hom_Poly.of_int_poly q)\n  \\<lbrakk>algebraic_semidom_class.coprime (Ring_Hom_Poly.of_int_poly p)\n            (Ring_Hom_Poly.of_int_poly q);\n   Ring_Hom_Poly.of_int_poly p \\<noteq> 0;\n   Ring_Hom_Poly.of_int_poly q \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> ipoly p ?x \\<noteq> 0 \\<or> ipoly q ?x \\<noteq> 0\n  p \\<in> P\n  q \\<in> P\n\ngoal (1 subgoal):\n 1. Roots p \\<inter> Roots q = {}", "by (auto simp: Roots_def)"], ["proof (state)\nthis:\n  Roots p \\<inter> Roots q = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  disjoint_family_on Roots P\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "define n_roots :: \"int poly \\<Rightarrow> nat\" (\"\\<sharp>_\")\n    where \"n_roots = (\\<lambda>p. card (Roots p))\""], ["proof (state)\nthis:\n  n_roots = (\\<lambda>p. card (Roots p))\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "define n where \"n = (\\<Sum>p\\<in>P. \\<sharp>p)\""], ["proof (state)\nthis:\n  n = sum n_roots P\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "have n_altdef: \"n = card Roots'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = card Roots'", "unfolding n_def Roots'_def n_roots_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. card (Roots p)) = card (\\<Union> (Roots ` P))", "using disjoint"], ["proof (prove)\nusing this:\n  disjoint_family_on Roots P\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. card (Roots p)) = card (\\<Union> (Roots ` P))", "by (subst card_UN_disjoint) (auto simp: disjoint_family_on_def)"], ["proof (state)\nthis:\n  n = card Roots'\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "have Roots_nonempty: \"Roots p \\<noteq> {}\" if \"p \\<in> P\" for p"], ["proof (prove)\ngoal (1 subgoal):\n 1. Roots p \\<noteq> {}", "using nonconstant[OF that]"], ["proof (prove)\nusing this:\n  0 < Polynomial.degree p\n\ngoal (1 subgoal):\n 1. Roots p \\<noteq> {}", "by (auto simp: Roots_def fundamental_theorem_of_algebra constant_degree)"], ["proof (state)\nthis:\n  ?p \\<in> P \\<Longrightarrow> Roots ?p \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "have \"Roots' \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Roots' \\<noteq> {}", "using Roots_nonempty \\<open>P \\<noteq> {}\\<close>"], ["proof (prove)\nusing this:\n  ?p \\<in> P \\<Longrightarrow> Roots ?p \\<noteq> {}\n  P \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Roots' \\<noteq> {}", "by (auto simp: Roots'_def)"], ["proof (state)\nthis:\n  Roots' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "have \"n > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n", "using \\<open>Roots' \\<noteq> {}\\<close> \\<open>finite Roots'\\<close>"], ["proof (prove)\nusing this:\n  Roots' \\<noteq> {}\n  finite Roots'\n\ngoal (1 subgoal):\n 1. 0 < n", "by (auto simp: n_altdef)"], ["proof (state)\nthis:\n  0 < n\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "text \\<open>\n    We can split each polynomial in \\<open>P\\<close> into a product of linear factors:\n  \\<close>"], ["proof (state)\nthis:\n  0 < n\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "have of_int_poly_P:\n     \"of_int_poly q = Polynomial.smult (Polynomial.lead_coeff q) (\\<Prod>x\\<in>Roots q. [:-x, 1:])\"\n     if \"q \\<in> P\" for q"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ring_Hom_Poly.of_int_poly q =\n    Polynomial.smult (of_int (Polynomial.lead_coeff q))\n     (\\<Prod>x\\<in>Roots q. [:- x, 1:])", "using complex_poly_decompose_rsquarefree[OF rsquarefree[OF that]]"], ["proof (prove)\nusing this:\n  Polynomial.smult (Polynomial.lead_coeff (Ring_Hom_Poly.of_int_poly q))\n   (\\<Prod>z\\<in>{z. ipoly q z = 0}. [:- z, 1:]) =\n  Ring_Hom_Poly.of_int_poly q\n\ngoal (1 subgoal):\n 1. Ring_Hom_Poly.of_int_poly q =\n    Polynomial.smult (of_int (Polynomial.lead_coeff q))\n     (\\<Prod>x\\<in>Roots q. [:- x, 1:])", "by (simp add: Roots_def)"], ["proof (state)\nthis:\n  ?q \\<in> P \\<Longrightarrow>\n  Ring_Hom_Poly.of_int_poly ?q =\n  Polynomial.smult (of_int (Polynomial.lead_coeff ?q))\n   (\\<Prod>x\\<in>Roots ?q. [:- x, 1:])\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "text \\<open>\n    We let \\<open>l\\<close> be an integer such that $l\\alpha$ is an algebraic integer for all our roots \\<open>\\<alpha>\\<close>:\n  \\<close>"], ["proof (state)\nthis:\n  ?q \\<in> P \\<Longrightarrow>\n  Ring_Hom_Poly.of_int_poly ?q =\n  Polynomial.smult (of_int (Polynomial.lead_coeff ?q))\n   (\\<Prod>x\\<in>Roots ?q. [:- x, 1:])\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "define l where \"l = (LCM q\\<in>P. Polynomial.lead_coeff q)\""], ["proof (state)\nthis:\n  l = Lcm (Polynomial.lead_coeff ` P)\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "have alg_int: \"algebraic_int (of_int l * x)\" if \"x \\<in> Roots'\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic_int (of_int l * x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. algebraic_int (of_int l * x)", "from that"], ["proof (chain)\npicking this:\n  x \\<in> Roots'", "obtain q where q: \"q \\<in> P\" \"ipoly q x = 0\""], ["proof (prove)\nusing this:\n  x \\<in> Roots'\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> P; ipoly q x = 0\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Roots'_def Roots_def)"], ["proof (state)\nthis:\n  q \\<in> P\n  ipoly q x = 0\n\ngoal (1 subgoal):\n 1. algebraic_int (of_int l * x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic_int (of_int l * x)", "by (rule algebraic_imp_algebraic_int'[of q]) (use q in \\<open>auto simp: l_def\\<close>)"], ["proof (state)\nthis:\n  algebraic_int (of_int l * x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> Roots' \\<Longrightarrow> algebraic_int (of_int l * ?x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "have \"l \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<noteq> 0", "using \\<open>finite P\\<close>"], ["proof (prove)\nusing this:\n  finite P\n\ngoal (1 subgoal):\n 1. l \\<noteq> 0", "by (auto simp: l_def Lcm_0_iff)"], ["proof (state)\nthis:\n  l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "have \"l \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> l", "unfolding l_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> Lcm (Polynomial.lead_coeff ` P)", "by (rule Lcm_int_greater_eq_0)"], ["proof (state)\nthis:\n  0 \\<le> l\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  l \\<noteq> 0\n  0 \\<le> l", "have \"l > 0\""], ["proof (prove)\nusing this:\n  l \\<noteq> 0\n  0 \\<le> l\n\ngoal (1 subgoal):\n 1. 0 < l", "by linarith"], ["proof (state)\nthis:\n  0 < l\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "text \\<open>\n    We can split the product of all the polynomials in \\<open>P\\<close> into linear factors:\n  \\<close>"], ["proof (state)\nthis:\n  0 < l\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "define lc_factor where \"lc_factor = (\\<Prod>q\\<in>P. l ^ Polynomial.degree q div Polynomial.lead_coeff q)\""], ["proof (state)\nthis:\n  lc_factor =\n  (\\<Prod>q\\<in>P. l ^ Polynomial.degree q div Polynomial.lead_coeff q)\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "have lc_factor: \"Polynomial.smult (of_int l ^ n) (\\<Prod>\\<alpha>'\\<in>Roots'. [:-\\<alpha>',1:]) =\n                      of_int_poly (Polynomial.smult lc_factor (\\<Prod>P))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (of_int l ^ n)\n     (\\<Prod>\\<alpha>'\\<in>Roots'. [:- \\<alpha>', 1:]) =\n    Ring_Hom_Poly.of_int_poly (Polynomial.smult lc_factor (\\<Prod>P))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Polynomial.smult (of_int l ^ n)\n     (\\<Prod>\\<alpha>'\\<in>Roots'. [:- \\<alpha>', 1:]) =\n    Ring_Hom_Poly.of_int_poly (Polynomial.smult lc_factor (\\<Prod>P))", "define lc where \"lc = (\\<lambda>q. Polynomial.lead_coeff q :: int)\""], ["proof (state)\nthis:\n  lc = Polynomial.lead_coeff\n\ngoal (1 subgoal):\n 1. Polynomial.smult (of_int l ^ n)\n     (\\<Prod>\\<alpha>'\\<in>Roots'. [:- \\<alpha>', 1:]) =\n    Ring_Hom_Poly.of_int_poly (Polynomial.smult lc_factor (\\<Prod>P))", "define d where \"d = (Polynomial.degree :: int poly \\<Rightarrow> nat)\""], ["proof (state)\nthis:\n  d = Polynomial.degree\n\ngoal (1 subgoal):\n 1. Polynomial.smult (of_int l ^ n)\n     (\\<Prod>\\<alpha>'\\<in>Roots'. [:- \\<alpha>', 1:]) =\n    Ring_Hom_Poly.of_int_poly (Polynomial.smult lc_factor (\\<Prod>P))", "have \"(\\<Prod>q\\<in>P. of_int_poly q) =\n          (\\<Prod>q\\<in>P. Polynomial.smult (lc q) (\\<Prod>x\\<in>Roots q. [:-x, 1:]) :: complex poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod Ring_Hom_Poly.of_int_poly P =\n    (\\<Prod>q\\<in>P.\n       Polynomial.smult (of_int (lc q)) (\\<Prod>x\\<in>Roots q. [:- x, 1:]))", "unfolding lc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod Ring_Hom_Poly.of_int_poly P =\n    (\\<Prod>q\\<in>P.\n       Polynomial.smult (of_int (Polynomial.lead_coeff q))\n        (\\<Prod>x\\<in>Roots q. [:- x, 1:]))", "by (intro prod.cong of_int_poly_P refl)"], ["proof (state)\nthis:\n  prod Ring_Hom_Poly.of_int_poly P =\n  (\\<Prod>q\\<in>P.\n     Polynomial.smult (of_int (lc q)) (\\<Prod>x\\<in>Roots q. [:- x, 1:]))\n\ngoal (1 subgoal):\n 1. Polynomial.smult (of_int l ^ n)\n     (\\<Prod>\\<alpha>'\\<in>Roots'. [:- \\<alpha>', 1:]) =\n    Ring_Hom_Poly.of_int_poly (Polynomial.smult lc_factor (\\<Prod>P))", "also"], ["proof (state)\nthis:\n  prod Ring_Hom_Poly.of_int_poly P =\n  (\\<Prod>q\\<in>P.\n     Polynomial.smult (of_int (lc q)) (\\<Prod>x\\<in>Roots q. [:- x, 1:]))\n\ngoal (1 subgoal):\n 1. Polynomial.smult (of_int l ^ n)\n     (\\<Prod>\\<alpha>'\\<in>Roots'. [:- \\<alpha>', 1:]) =\n    Ring_Hom_Poly.of_int_poly (Polynomial.smult lc_factor (\\<Prod>P))", "have \"\\<dots> = Polynomial.smult (\\<Prod>q\\<in>P. lc q) (\\<Prod>q\\<in>P. (\\<Prod>x\\<in>Roots q. [:-x, 1:]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>q\\<in>P.\n       Polynomial.smult (of_int (lc q))\n        (\\<Prod>x\\<in>Roots q. [:- x, 1:])) =\n    Polynomial.smult (of_int (prod lc P))\n     (\\<Prod>q\\<in>P. \\<Prod>x\\<in>Roots q. [:- x, 1:])", "by (simp add: prod_smult)"], ["proof (state)\nthis:\n  (\\<Prod>q\\<in>P.\n     Polynomial.smult (of_int (lc q)) (\\<Prod>x\\<in>Roots q. [:- x, 1:])) =\n  Polynomial.smult (of_int (prod lc P))\n   (\\<Prod>q\\<in>P. \\<Prod>x\\<in>Roots q. [:- x, 1:])\n\ngoal (1 subgoal):\n 1. Polynomial.smult (of_int l ^ n)\n     (\\<Prod>\\<alpha>'\\<in>Roots'. [:- \\<alpha>', 1:]) =\n    Ring_Hom_Poly.of_int_poly (Polynomial.smult lc_factor (\\<Prod>P))", "also"], ["proof (state)\nthis:\n  (\\<Prod>q\\<in>P.\n     Polynomial.smult (of_int (lc q)) (\\<Prod>x\\<in>Roots q. [:- x, 1:])) =\n  Polynomial.smult (of_int (prod lc P))\n   (\\<Prod>q\\<in>P. \\<Prod>x\\<in>Roots q. [:- x, 1:])\n\ngoal (1 subgoal):\n 1. Polynomial.smult (of_int l ^ n)\n     (\\<Prod>\\<alpha>'\\<in>Roots'. [:- \\<alpha>', 1:]) =\n    Ring_Hom_Poly.of_int_poly (Polynomial.smult lc_factor (\\<Prod>P))", "have \"(\\<Prod>q\\<in>P. (\\<Prod>x\\<in>Roots q. [:-x, 1:])) = (\\<Prod>x\\<in>Roots'. [:-x, 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>q\\<in>P. \\<Prod>x\\<in>Roots q. [:- x, 1:]) =\n    (\\<Prod>x\\<in>Roots'. [:- x, 1:])", "unfolding Roots'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>q\\<in>P. \\<Prod>x\\<in>Roots q. [:- x, 1:]) =\n    (\\<Prod>x\\<in>\\<Union> (Roots ` P). [:- x, 1:])", "using disjoint"], ["proof (prove)\nusing this:\n  disjoint_family_on Roots P\n\ngoal (1 subgoal):\n 1. (\\<Prod>q\\<in>P. \\<Prod>x\\<in>Roots q. [:- x, 1:]) =\n    (\\<Prod>x\\<in>\\<Union> (Roots ` P). [:- x, 1:])", "by (intro prod.UNION_disjoint [symmetric]) (auto simp: disjoint_family_on_def)"], ["proof (state)\nthis:\n  (\\<Prod>q\\<in>P. \\<Prod>x\\<in>Roots q. [:- x, 1:]) =\n  (\\<Prod>x\\<in>Roots'. [:- x, 1:])\n\ngoal (1 subgoal):\n 1. Polynomial.smult (of_int l ^ n)\n     (\\<Prod>\\<alpha>'\\<in>Roots'. [:- \\<alpha>', 1:]) =\n    Ring_Hom_Poly.of_int_poly (Polynomial.smult lc_factor (\\<Prod>P))", "also"], ["proof (state)\nthis:\n  (\\<Prod>q\\<in>P. \\<Prod>x\\<in>Roots q. [:- x, 1:]) =\n  (\\<Prod>x\\<in>Roots'. [:- x, 1:])\n\ngoal (1 subgoal):\n 1. Polynomial.smult (of_int l ^ n)\n     (\\<Prod>\\<alpha>'\\<in>Roots'. [:- \\<alpha>', 1:]) =\n    Ring_Hom_Poly.of_int_poly (Polynomial.smult lc_factor (\\<Prod>P))", "have \"Polynomial.smult (of_int lc_factor) (Polynomial.smult (\\<Prod>q\\<in>P. lc q) \\<dots>) =\n               Polynomial.smult (\\<Prod>q\\<in>P. of_int (l ^ d q div lc q * lc q)) (\\<Prod>x\\<in>Roots'. pCons (- x) 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (of_int lc_factor)\n     (Polynomial.smult (of_int (prod lc P))\n       (\\<Prod>x\\<in>Roots'. [:- x, 1:])) =\n    Polynomial.smult (\\<Prod>q\\<in>P. of_int (l ^ d q div lc q * lc q))\n     (\\<Prod>x\\<in>Roots'. pCons (- x) 1)", "by (simp add: lc_factor_def prod.distrib lc_def d_def)"], ["proof (state)\nthis:\n  Polynomial.smult (of_int lc_factor)\n   (Polynomial.smult (of_int (prod lc P))\n     (\\<Prod>x\\<in>Roots'. [:- x, 1:])) =\n  Polynomial.smult (\\<Prod>q\\<in>P. of_int (l ^ d q div lc q * lc q))\n   (\\<Prod>x\\<in>Roots'. pCons (- x) 1)\n\ngoal (1 subgoal):\n 1. Polynomial.smult (of_int l ^ n)\n     (\\<Prod>\\<alpha>'\\<in>Roots'. [:- \\<alpha>', 1:]) =\n    Ring_Hom_Poly.of_int_poly (Polynomial.smult lc_factor (\\<Prod>P))", "also"], ["proof (state)\nthis:\n  Polynomial.smult (of_int lc_factor)\n   (Polynomial.smult (of_int (prod lc P))\n     (\\<Prod>x\\<in>Roots'. [:- x, 1:])) =\n  Polynomial.smult (\\<Prod>q\\<in>P. of_int (l ^ d q div lc q * lc q))\n   (\\<Prod>x\\<in>Roots'. pCons (- x) 1)\n\ngoal (1 subgoal):\n 1. Polynomial.smult (of_int l ^ n)\n     (\\<Prod>\\<alpha>'\\<in>Roots'. [:- \\<alpha>', 1:]) =\n    Ring_Hom_Poly.of_int_poly (Polynomial.smult lc_factor (\\<Prod>P))", "have \"(\\<Prod>q\\<in>P. of_int (l ^ d q div lc q * lc q)) = (\\<Prod>q\\<in>P. of_int l ^ d q :: complex)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>q\\<in>P. of_int (l ^ d q div lc q * lc q)) =\n    (\\<Prod>q\\<in>P. of_int l ^ d q)", "proof (intro prod.cong, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. P = P\n 2. \\<And>x.\n       x \\<in> P \\<Longrightarrow>\n       of_int (l ^ d x div lc x * lc x) = of_int l ^ d x", "case (2 q)"], ["proof (state)\nthis:\n  q \\<in> P\n\ngoal (2 subgoals):\n 1. P = P\n 2. \\<And>x.\n       x \\<in> P \\<Longrightarrow>\n       of_int (l ^ d x div lc x * lc x) = of_int l ^ d x", "have \"lc q dvd l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lc q dvd l", "unfolding l_def lc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.lead_coeff q dvd Lcm (Polynomial.lead_coeff ` P)", "using 2"], ["proof (prove)\nusing this:\n  q \\<in> P\n\ngoal (1 subgoal):\n 1. Polynomial.lead_coeff q dvd Lcm (Polynomial.lead_coeff ` P)", "by auto"], ["proof (state)\nthis:\n  lc q dvd l\n\ngoal (2 subgoals):\n 1. P = P\n 2. \\<And>x.\n       x \\<in> P \\<Longrightarrow>\n       of_int (l ^ d x div lc x * lc x) = of_int l ^ d x", "also"], ["proof (state)\nthis:\n  lc q dvd l\n\ngoal (2 subgoals):\n 1. P = P\n 2. \\<And>x.\n       x \\<in> P \\<Longrightarrow>\n       of_int (l ^ d x div lc x * lc x) = of_int l ^ d x", "have \"\\<dots> dvd l ^ d q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l dvd l ^ d q", "using 2 nonconstant[of q]"], ["proof (prove)\nusing this:\n  q \\<in> P\n  q \\<in> P \\<Longrightarrow> 0 < Polynomial.degree q\n\ngoal (1 subgoal):\n 1. l dvd l ^ d q", "by (intro dvd_power) (auto simp: d_def)"], ["proof (state)\nthis:\n  l dvd l ^ d q\n\ngoal (2 subgoals):\n 1. P = P\n 2. \\<And>x.\n       x \\<in> P \\<Longrightarrow>\n       of_int (l ^ d x div lc x * lc x) = of_int l ^ d x", "finally"], ["proof (chain)\npicking this:\n  lc q dvd l ^ d q", "show ?case"], ["proof (prove)\nusing this:\n  lc q dvd l ^ d q\n\ngoal (1 subgoal):\n 1. of_int (l ^ d q div lc q * lc q) = of_int l ^ d q", "by simp"], ["proof (state)\nthis:\n  of_int (l ^ d q div lc q * lc q) = of_int l ^ d q\n\ngoal (1 subgoal):\n 1. P = P", "qed auto"], ["proof (state)\nthis:\n  (\\<Prod>q\\<in>P. of_int (l ^ d q div lc q * lc q)) =\n  (\\<Prod>q\\<in>P. of_int l ^ d q)\n\ngoal (1 subgoal):\n 1. Polynomial.smult (of_int l ^ n)\n     (\\<Prod>\\<alpha>'\\<in>Roots'. [:- \\<alpha>', 1:]) =\n    Ring_Hom_Poly.of_int_poly (Polynomial.smult lc_factor (\\<Prod>P))", "also"], ["proof (state)\nthis:\n  (\\<Prod>q\\<in>P. of_int (l ^ d q div lc q * lc q)) =\n  (\\<Prod>q\\<in>P. of_int l ^ d q)\n\ngoal (1 subgoal):\n 1. Polynomial.smult (of_int l ^ n)\n     (\\<Prod>\\<alpha>'\\<in>Roots'. [:- \\<alpha>', 1:]) =\n    Ring_Hom_Poly.of_int_poly (Polynomial.smult lc_factor (\\<Prod>P))", "have \"\\<dots> = l ^ (\\<Sum>q\\<in>P. d q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>q\\<in>P. of_int l ^ d q) = of_int (l ^ sum d P)", "by (simp add: power_sum)"], ["proof (state)\nthis:\n  (\\<Prod>q\\<in>P. of_int l ^ d q) = of_int (l ^ sum d P)\n\ngoal (1 subgoal):\n 1. Polynomial.smult (of_int l ^ n)\n     (\\<Prod>\\<alpha>'\\<in>Roots'. [:- \\<alpha>', 1:]) =\n    Ring_Hom_Poly.of_int_poly (Polynomial.smult lc_factor (\\<Prod>P))", "also"], ["proof (state)\nthis:\n  (\\<Prod>q\\<in>P. of_int l ^ d q) = of_int (l ^ sum d P)\n\ngoal (1 subgoal):\n 1. Polynomial.smult (of_int l ^ n)\n     (\\<Prod>\\<alpha>'\\<in>Roots'. [:- \\<alpha>', 1:]) =\n    Ring_Hom_Poly.of_int_poly (Polynomial.smult lc_factor (\\<Prod>P))", "have \"(\\<Sum>q\\<in>P. d q) = (\\<Sum>q\\<in>P. n_roots q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum d P = sum n_roots P", "proof (intro sum.cong, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. P = P\n 2. \\<And>x. x \\<in> P \\<Longrightarrow> d x = \\<sharp>x", "case (2 q)"], ["proof (state)\nthis:\n  q \\<in> P\n\ngoal (2 subgoals):\n 1. P = P\n 2. \\<And>x. x \\<in> P \\<Longrightarrow> d x = \\<sharp>x", "thus ?case"], ["proof (prove)\nusing this:\n  q \\<in> P\n\ngoal (1 subgoal):\n 1. d q = \\<sharp>q", "using rsquarefree[OF 2]"], ["proof (prove)\nusing this:\n  q \\<in> P\n  rsquarefree (Ring_Hom_Poly.of_int_poly q)\n\ngoal (1 subgoal):\n 1. d q = \\<sharp>q", "by (subst (asm) rsquarefree_card_degree) (auto simp: d_def n_roots_def Roots_def)"], ["proof (state)\nthis:\n  d q = \\<sharp>q\n\ngoal (1 subgoal):\n 1. P = P", "qed auto"], ["proof (state)\nthis:\n  sum d P = sum n_roots P\n\ngoal (1 subgoal):\n 1. Polynomial.smult (of_int l ^ n)\n     (\\<Prod>\\<alpha>'\\<in>Roots'. [:- \\<alpha>', 1:]) =\n    Ring_Hom_Poly.of_int_poly (Polynomial.smult lc_factor (\\<Prod>P))", "also"], ["proof (state)\nthis:\n  sum d P = sum n_roots P\n\ngoal (1 subgoal):\n 1. Polynomial.smult (of_int l ^ n)\n     (\\<Prod>\\<alpha>'\\<in>Roots'. [:- \\<alpha>', 1:]) =\n    Ring_Hom_Poly.of_int_poly (Polynomial.smult lc_factor (\\<Prod>P))", "have \"\\<dots> = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum n_roots P = n", "by (simp add: n_def)"], ["proof (state)\nthis:\n  sum n_roots P = n\n\ngoal (1 subgoal):\n 1. Polynomial.smult (of_int l ^ n)\n     (\\<Prod>\\<alpha>'\\<in>Roots'. [:- \\<alpha>', 1:]) =\n    Ring_Hom_Poly.of_int_poly (Polynomial.smult lc_factor (\\<Prod>P))", "finally"], ["proof (chain)\npicking this:\n  Polynomial.smult (of_int lc_factor) (prod Ring_Hom_Poly.of_int_poly P) =\n  Polynomial.smult (of_int (l ^ n)) (\\<Prod>x\\<in>Roots'. pCons (- x) 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  Polynomial.smult (of_int lc_factor) (prod Ring_Hom_Poly.of_int_poly P) =\n  Polynomial.smult (of_int (l ^ n)) (\\<Prod>x\\<in>Roots'. pCons (- x) 1)\n\ngoal (1 subgoal):\n 1. Polynomial.smult (of_int l ^ n)\n     (\\<Prod>\\<alpha>'\\<in>Roots'. [:- \\<alpha>', 1:]) =\n    Ring_Hom_Poly.of_int_poly (Polynomial.smult lc_factor (\\<Prod>P))", "by (simp add: of_int_hom.map_poly_hom_smult of_int_poly_hom.hom_prod)"], ["proof (state)\nthis:\n  Polynomial.smult (of_int l ^ n)\n   (\\<Prod>\\<alpha>'\\<in>Roots'. [:- \\<alpha>', 1:]) =\n  Ring_Hom_Poly.of_int_poly (Polynomial.smult lc_factor (\\<Prod>P))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Polynomial.smult (of_int l ^ n)\n   (\\<Prod>\\<alpha>'\\<in>Roots'. [:- \\<alpha>', 1:]) =\n  Ring_Hom_Poly.of_int_poly (Polynomial.smult lc_factor (\\<Prod>P))\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "text \\<open>\n    We define \\<open>R\\<close> to be the radius of the smallest circle around the origin in which all our\n    roots lie:\n  \\<close>"], ["proof (state)\nthis:\n  Polynomial.smult (of_int l ^ n)\n   (\\<Prod>\\<alpha>'\\<in>Roots'. [:- \\<alpha>', 1:]) =\n  Ring_Hom_Poly.of_int_poly (Polynomial.smult lc_factor (\\<Prod>P))\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "define R :: real where \"R = Max (norm ` Roots')\""], ["proof (state)\nthis:\n  R = Max (cmod ` Roots')\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "have R_ge: \"R \\<ge> norm \\<alpha>\" if \"\\<alpha> \\<in> Roots'\" for \\<alpha>"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod \\<alpha> \\<le> R", "unfolding R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod \\<alpha> \\<le> Max (cmod ` Roots')", "using that"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> Roots'\n\ngoal (1 subgoal):\n 1. cmod \\<alpha> \\<le> Max (cmod ` Roots')", "by (intro Max_ge) auto"], ["proof (state)\nthis:\n  ?\\<alpha> \\<in> Roots' \\<Longrightarrow> cmod ?\\<alpha> \\<le> R\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "have \"R \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> R", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 \\<le> R", "from \\<open>Roots' \\<noteq> {}\\<close>"], ["proof (chain)\npicking this:\n  Roots' \\<noteq> {}", "obtain \\<alpha> where \"\\<alpha> \\<in> Roots'\""], ["proof (prove)\nusing this:\n  Roots' \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>\\<alpha>.\n        \\<alpha> \\<in> Roots' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<alpha> \\<in> Roots'\n\ngoal (1 subgoal):\n 1. 0 \\<le> R", "have \"0 \\<le> norm \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> cmod \\<alpha>", "by simp"], ["proof (state)\nthis:\n  0 \\<le> cmod \\<alpha>\n\ngoal (1 subgoal):\n 1. 0 \\<le> R", "also"], ["proof (state)\nthis:\n  0 \\<le> cmod \\<alpha>\n\ngoal (1 subgoal):\n 1. 0 \\<le> R", "have \"\\<dots> \\<le> R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod \\<alpha> \\<le> R", "by (intro R_ge) fact"], ["proof (state)\nthis:\n  cmod \\<alpha> \\<le> R\n\ngoal (1 subgoal):\n 1. 0 \\<le> R", "finally"], ["proof (chain)\npicking this:\n  0 \\<le> R", "show \"R \\<ge> 0\""], ["proof (prove)\nusing this:\n  0 \\<le> R\n\ngoal (1 subgoal):\n 1. 0 \\<le> R", "by simp"], ["proof (state)\nthis:\n  0 \\<le> R\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 \\<le> R\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "text \\<open>\n    Now the main part of the proof: for any sufficiently large prime \\<open>p\\<close>, our assumptions\n    imply $(p-1)! ^ n \\leq C' l^{np} (2R)^{np-1}$ for some constant $C'$:    \n  \\<close>"], ["proof (state)\nthis:\n  0 \\<le> R\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "define C :: \"nat \\<Rightarrow> real\" where \"C = (\\<lambda>p. l ^ (n * p) * (2*R) ^ (n * p - 1))\""], ["proof (state)\nthis:\n  C = (\\<lambda>p. real_of_int (l ^ (n * p)) * (2 * R) ^ (n * p - 1))\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "define C' where\n    \"C' = (\\<Prod>x\\<in>Roots'. \\<Sum>q\\<in>P. real_of_int \\<bar>\\<beta> q\\<bar> * (\\<Sum>\\<alpha>\\<in>Roots q. cmod \\<alpha> * exp (cmod \\<alpha>)))\""], ["proof (state)\nthis:\n  C' =\n  (\\<Prod>x\\<in>Roots'.\n     \\<Sum>q\\<in>P.\n       real_of_int \\<bar>\\<beta> q\\<bar> *\n       (\\<Sum>\\<alpha>\\<in>Roots q. cmod \\<alpha> * exp (cmod \\<alpha>)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "text \\<open>\n    We commence with the proof of the main inequality.\n  \\<close>"], ["proof (state)\nthis:\n  C' =\n  (\\<Prod>x\\<in>Roots'.\n     \\<Sum>q\\<in>P.\n       real_of_int \\<bar>\\<beta> q\\<bar> *\n       (\\<Sum>\\<alpha>\\<in>Roots q. cmod \\<alpha> * exp (cmod \\<alpha>)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "have ineq: \"fact (p - 1) ^ n \\<le> C' * C p ^ n\"\n    if p: \"prime p\" \n    and p_ineqs: \"\\<forall>q\\<in>P. p > \\<bar>\\<beta> q\\<bar>\"\n                 \"real p > norm (\\<Prod>\\<alpha>\\<in>Roots'. of_int (l^n) * (\\<Prod>x\\<in>Roots'-{\\<alpha>}. \\<alpha> - x))\"\n    for p :: nat"], ["proof (prove)\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> C' * C p ^ n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> C' * C p ^ n", "have \"p > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < p", "using prime_gt_1_nat[OF p]"], ["proof (prove)\nusing this:\n  1 < p\n\ngoal (1 subgoal):\n 1. 1 < p", "."], ["proof (state)\nthis:\n  1 < p\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> C' * C p ^ n", "text \\<open>\n      We define the polynomial function\n        \\[f_i(X) = l^{np} \\frac{\\prod_\\alpha (X-\\alpha)^p}{X - \\alpha_i}\\]\n      where the product runs over all roots $\\alpha$.\n    \\<close>"], ["proof (state)\nthis:\n  1 < p\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> C' * C p ^ n", "define f_poly :: \"complex \\<Rightarrow> complex poly\" where\n      \"f_poly = (\\<lambda>\\<alpha>. Polynomial.smult (l^(n*p)) ((\\<Prod>\\<alpha>'\\<in>Roots'. [:-\\<alpha>', 1:]^p) div [:-\\<alpha>, 1:]))\""], ["proof (state)\nthis:\n  f_poly =\n  (\\<lambda>\\<alpha>.\n      Polynomial.smult (of_int (l ^ (n * p)))\n       ((\\<Prod>\\<alpha>'\\<in>Roots'. [:- \\<alpha>', 1:] ^ p) div\n        [:- \\<alpha>, 1:]))\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> C' * C p ^ n", "have f_poly_altdef: \"f_poly \\<alpha> = Polynomial.smult (l^(n*p))\n                           ((\\<Prod>\\<alpha>'\\<in>Roots'. [:-\\<alpha>', 1:]^(if \\<alpha>' = \\<alpha> then p - 1 else p)))\"\n      if \"\\<alpha> \\<in> Roots'\" for \\<alpha>"], ["proof (prove)\ngoal (1 subgoal):\n 1. f_poly \\<alpha> =\n    Polynomial.smult (of_int (l ^ (n * p)))\n     (\\<Prod>\\<alpha>'\\<in>Roots'.\n        [:- \\<alpha>', 1:] ^ (if \\<alpha>' = \\<alpha> then p - 1 else p))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f_poly \\<alpha> =\n    Polynomial.smult (of_int (l ^ (n * p)))\n     (\\<Prod>\\<alpha>'\\<in>Roots'.\n        [:- \\<alpha>', 1:] ^ (if \\<alpha>' = \\<alpha> then p - 1 else p))", "have \"(\\<Prod>\\<alpha>'\\<in>Roots'. [:-\\<alpha>', 1:] ^ (if \\<alpha>'=\\<alpha> then p-1 else p)) * [:-\\<alpha>, 1:] =\n            [:- \\<alpha>, 1:] ^ (p - 1) * (\\<Prod>x\\<in>Roots' - {\\<alpha>}. [:- x, 1:] ^ p) * [:- \\<alpha>, 1:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>\\<alpha>'\\<in>Roots'.\n       [:- \\<alpha>', 1:] ^ (if \\<alpha>' = \\<alpha> then p - 1 else p)) *\n    [:- \\<alpha>, 1:] =\n    [:- \\<alpha>, 1:] ^ (p - 1) *\n    (\\<Prod>x\\<in>Roots' - {\\<alpha>}. [:- x, 1:] ^ p) *\n    [:- \\<alpha>, 1:]", "using that"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> Roots'\n\ngoal (1 subgoal):\n 1. (\\<Prod>\\<alpha>'\\<in>Roots'.\n       [:- \\<alpha>', 1:] ^ (if \\<alpha>' = \\<alpha> then p - 1 else p)) *\n    [:- \\<alpha>, 1:] =\n    [:- \\<alpha>, 1:] ^ (p - 1) *\n    (\\<Prod>x\\<in>Roots' - {\\<alpha>}. [:- x, 1:] ^ p) *\n    [:- \\<alpha>, 1:]", "by (subst prod.If_eq) (auto simp: algebra_simps)"], ["proof (state)\nthis:\n  (\\<Prod>\\<alpha>'\\<in>Roots'.\n     [:- \\<alpha>', 1:] ^ (if \\<alpha>' = \\<alpha> then p - 1 else p)) *\n  [:- \\<alpha>, 1:] =\n  [:- \\<alpha>, 1:] ^ (p - 1) *\n  (\\<Prod>x\\<in>Roots' - {\\<alpha>}. [:- x, 1:] ^ p) *\n  [:- \\<alpha>, 1:]\n\ngoal (1 subgoal):\n 1. f_poly \\<alpha> =\n    Polynomial.smult (of_int (l ^ (n * p)))\n     (\\<Prod>\\<alpha>'\\<in>Roots'.\n        [:- \\<alpha>', 1:] ^ (if \\<alpha>' = \\<alpha> then p - 1 else p))", "also"], ["proof (state)\nthis:\n  (\\<Prod>\\<alpha>'\\<in>Roots'.\n     [:- \\<alpha>', 1:] ^ (if \\<alpha>' = \\<alpha> then p - 1 else p)) *\n  [:- \\<alpha>, 1:] =\n  [:- \\<alpha>, 1:] ^ (p - 1) *\n  (\\<Prod>x\\<in>Roots' - {\\<alpha>}. [:- x, 1:] ^ p) *\n  [:- \\<alpha>, 1:]\n\ngoal (1 subgoal):\n 1. f_poly \\<alpha> =\n    Polynomial.smult (of_int (l ^ (n * p)))\n     (\\<Prod>\\<alpha>'\\<in>Roots'.\n        [:- \\<alpha>', 1:] ^ (if \\<alpha>' = \\<alpha> then p - 1 else p))", "have \"\\<dots> = (\\<Prod>x\\<in>Roots' - {\\<alpha>}. [:- x, 1:] ^ p) * [:- \\<alpha>, 1:] ^ Suc (p - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:- \\<alpha>, 1:] ^ (p - 1) *\n    (\\<Prod>x\\<in>Roots' - {\\<alpha>}. [:- x, 1:] ^ p) *\n    [:- \\<alpha>, 1:] =\n    (\\<Prod>x\\<in>Roots' - {\\<alpha>}. [:- x, 1:] ^ p) *\n    [:- \\<alpha>, 1:] ^ Suc (p - 1)", "by (simp only: power_Suc mult_ac)"], ["proof (state)\nthis:\n  [:- \\<alpha>, 1:] ^ (p - 1) *\n  (\\<Prod>x\\<in>Roots' - {\\<alpha>}. [:- x, 1:] ^ p) *\n  [:- \\<alpha>, 1:] =\n  (\\<Prod>x\\<in>Roots' - {\\<alpha>}. [:- x, 1:] ^ p) *\n  [:- \\<alpha>, 1:] ^ Suc (p - 1)\n\ngoal (1 subgoal):\n 1. f_poly \\<alpha> =\n    Polynomial.smult (of_int (l ^ (n * p)))\n     (\\<Prod>\\<alpha>'\\<in>Roots'.\n        [:- \\<alpha>', 1:] ^ (if \\<alpha>' = \\<alpha> then p - 1 else p))", "also"], ["proof (state)\nthis:\n  [:- \\<alpha>, 1:] ^ (p - 1) *\n  (\\<Prod>x\\<in>Roots' - {\\<alpha>}. [:- x, 1:] ^ p) *\n  [:- \\<alpha>, 1:] =\n  (\\<Prod>x\\<in>Roots' - {\\<alpha>}. [:- x, 1:] ^ p) *\n  [:- \\<alpha>, 1:] ^ Suc (p - 1)\n\ngoal (1 subgoal):\n 1. f_poly \\<alpha> =\n    Polynomial.smult (of_int (l ^ (n * p)))\n     (\\<Prod>\\<alpha>'\\<in>Roots'.\n        [:- \\<alpha>', 1:] ^ (if \\<alpha>' = \\<alpha> then p - 1 else p))", "have \"Suc (p - 1) = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (p - 1) = p", "using \\<open>p > 1\\<close>"], ["proof (prove)\nusing this:\n  1 < p\n\ngoal (1 subgoal):\n 1. Suc (p - 1) = p", "by auto"], ["proof (state)\nthis:\n  Suc (p - 1) = p\n\ngoal (1 subgoal):\n 1. f_poly \\<alpha> =\n    Polynomial.smult (of_int (l ^ (n * p)))\n     (\\<Prod>\\<alpha>'\\<in>Roots'.\n        [:- \\<alpha>', 1:] ^ (if \\<alpha>' = \\<alpha> then p - 1 else p))", "also"], ["proof (state)\nthis:\n  Suc (p - 1) = p\n\ngoal (1 subgoal):\n 1. f_poly \\<alpha> =\n    Polynomial.smult (of_int (l ^ (n * p)))\n     (\\<Prod>\\<alpha>'\\<in>Roots'.\n        [:- \\<alpha>', 1:] ^ (if \\<alpha>' = \\<alpha> then p - 1 else p))", "have \"(\\<Prod>x\\<in>Roots' - {\\<alpha>}. [:- x, 1:] ^ p) * [:- \\<alpha>, 1:] ^ p = (\\<Prod>x\\<in>Roots'. [:- x, 1:] ^ p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<in>Roots' - {\\<alpha>}. [:- x, 1:] ^ p) *\n    [:- \\<alpha>, 1:] ^ p =\n    (\\<Prod>x\\<in>Roots'. [:- x, 1:] ^ p)", "using that"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> Roots'\n\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<in>Roots' - {\\<alpha>}. [:- x, 1:] ^ p) *\n    [:- \\<alpha>, 1:] ^ p =\n    (\\<Prod>x\\<in>Roots'. [:- x, 1:] ^ p)", "by (subst prod.remove[of _ \\<alpha>]) auto"], ["proof (state)\nthis:\n  (\\<Prod>x\\<in>Roots' - {\\<alpha>}. [:- x, 1:] ^ p) *\n  [:- \\<alpha>, 1:] ^ p =\n  (\\<Prod>x\\<in>Roots'. [:- x, 1:] ^ p)\n\ngoal (1 subgoal):\n 1. f_poly \\<alpha> =\n    Polynomial.smult (of_int (l ^ (n * p)))\n     (\\<Prod>\\<alpha>'\\<in>Roots'.\n        [:- \\<alpha>', 1:] ^ (if \\<alpha>' = \\<alpha> then p - 1 else p))", "finally"], ["proof (chain)\npicking this:\n  (\\<Prod>\\<alpha>'\\<in>Roots'.\n     [:- \\<alpha>', 1:] ^ (if \\<alpha>' = \\<alpha> then p - 1 else p)) *\n  [:- \\<alpha>, 1:] =\n  (\\<Prod>x\\<in>Roots'. [:- x, 1:] ^ p)", "have eq: \"(\\<Prod>\\<alpha>'\\<in>Roots'. [:-\\<alpha>', 1:] ^ (if \\<alpha>'=\\<alpha> then p-1 else p)) * [:-\\<alpha>, 1:] =\n                        (\\<Prod>x\\<in>Roots'. [:- x, 1:] ^ p)\""], ["proof (prove)\nusing this:\n  (\\<Prod>\\<alpha>'\\<in>Roots'.\n     [:- \\<alpha>', 1:] ^ (if \\<alpha>' = \\<alpha> then p - 1 else p)) *\n  [:- \\<alpha>, 1:] =\n  (\\<Prod>x\\<in>Roots'. [:- x, 1:] ^ p)\n\ngoal (1 subgoal):\n 1. (\\<Prod>\\<alpha>'\\<in>Roots'.\n       [:- \\<alpha>', 1:] ^ (if \\<alpha>' = \\<alpha> then p - 1 else p)) *\n    [:- \\<alpha>, 1:] =\n    (\\<Prod>x\\<in>Roots'. [:- x, 1:] ^ p)", "."], ["proof (state)\nthis:\n  (\\<Prod>\\<alpha>'\\<in>Roots'.\n     [:- \\<alpha>', 1:] ^ (if \\<alpha>' = \\<alpha> then p - 1 else p)) *\n  [:- \\<alpha>, 1:] =\n  (\\<Prod>x\\<in>Roots'. [:- x, 1:] ^ p)\n\ngoal (1 subgoal):\n 1. f_poly \\<alpha> =\n    Polynomial.smult (of_int (l ^ (n * p)))\n     (\\<Prod>\\<alpha>'\\<in>Roots'.\n        [:- \\<alpha>', 1:] ^ (if \\<alpha>' = \\<alpha> then p - 1 else p))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. f_poly \\<alpha> =\n    Polynomial.smult (of_int (l ^ (n * p)))\n     (\\<Prod>\\<alpha>'\\<in>Roots'.\n        [:- \\<alpha>', 1:] ^ (if \\<alpha>' = \\<alpha> then p - 1 else p))", "unfolding f_poly_def eq[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (of_int (l ^ (n * p)))\n     ((\\<Prod>\\<alpha>'\\<in>Roots'.\n         [:- \\<alpha>', 1:] ^ (if \\<alpha>' = \\<alpha> then p - 1 else p)) *\n      [:- \\<alpha>, 1:] div\n      [:- \\<alpha>, 1:]) =\n    Polynomial.smult (of_int (l ^ (n * p)))\n     (\\<Prod>\\<alpha>'\\<in>Roots'.\n        [:- \\<alpha>', 1:] ^ (if \\<alpha>' = \\<alpha> then p - 1 else p))", "by (subst nonzero_mult_div_cancel_right) auto"], ["proof (state)\nthis:\n  f_poly \\<alpha> =\n  Polynomial.smult (of_int (l ^ (n * p)))\n   (\\<Prod>\\<alpha>'\\<in>Roots'.\n      [:- \\<alpha>', 1:] ^ (if \\<alpha>' = \\<alpha> then p - 1 else p))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?\\<alpha> \\<in> Roots' \\<Longrightarrow>\n  f_poly ?\\<alpha> =\n  Polynomial.smult (of_int (l ^ (n * p)))\n   (\\<Prod>\\<alpha>'\\<in>Roots'.\n      [:- \\<alpha>', 1:] ^ (if \\<alpha>' = ?\\<alpha> then p - 1 else p))\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> C' * C p ^ n", "define f :: \"complex \\<Rightarrow> complex \\<Rightarrow> complex\"\n      where \"f = (\\<lambda>\\<alpha> x. l^(n*p) * (\\<Prod>\\<alpha>'\\<in>Roots'. (x - \\<alpha>')^(if \\<alpha>' = \\<alpha> then p - 1 else p)))\""], ["proof (state)\nthis:\n  f =\n  (\\<lambda>\\<alpha> x.\n      of_int (l ^ (n * p)) *\n      (\\<Prod>\\<alpha>'\\<in>Roots'.\n         (x - \\<alpha>') ^ (if \\<alpha>' = \\<alpha> then p - 1 else p)))\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> C' * C p ^ n", "have eval_f: \"poly (f_poly \\<alpha>) x = f \\<alpha> x\" if \"\\<alpha> \\<in> Roots'\" for \\<alpha> x"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (f_poly \\<alpha>) x = f \\<alpha> x", "using that"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> Roots'\n\ngoal (1 subgoal):\n 1. poly (f_poly \\<alpha>) x = f \\<alpha> x", "by (simp add: f_poly_altdef poly_prod f_def)"], ["proof (state)\nthis:\n  ?\\<alpha> \\<in> Roots' \\<Longrightarrow>\n  poly (f_poly ?\\<alpha>) ?x = f ?\\<alpha> ?x\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> C' * C p ^ n", "have deg_f: \"Polynomial.degree (f_poly \\<alpha>) = n * p - 1\" if \"\\<alpha> \\<in> Roots'\" for \\<alpha>"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.degree (f_poly \\<alpha>) = n * p - 1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Polynomial.degree (f_poly \\<alpha>) = n * p - 1", "have \"Polynomial.degree (f_poly \\<alpha>) = p - 1 + (n - 1) * p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.degree (f_poly \\<alpha>) = p - 1 + (n - 1) * p", "unfolding f_poly_altdef[OF that]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.degree\n     (Polynomial.smult (of_int (l ^ (n * p)))\n       (\\<Prod>\\<alpha>'\\<in>Roots'.\n          [:- \\<alpha>', 1:] ^\n          (if \\<alpha>' = \\<alpha> then p - 1 else p))) =\n    p - 1 + (n - 1) * p", "using that \\<open>l > 0\\<close> \\<open>finite Roots'\\<close>"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> Roots'\n  0 < l\n  finite Roots'\n\ngoal (1 subgoal):\n 1. Polynomial.degree\n     (Polynomial.smult (of_int (l ^ (n * p)))\n       (\\<Prod>\\<alpha>'\\<in>Roots'.\n          [:- \\<alpha>', 1:] ^\n          (if \\<alpha>' = \\<alpha> then p - 1 else p))) =\n    p - 1 + (n - 1) * p", "by (subst prod.If_eq) (auto simp: degree_prod_eq degree_power_eq degree_mult_eq n_altdef)"], ["proof (state)\nthis:\n  Polynomial.degree (f_poly \\<alpha>) = p - 1 + (n - 1) * p\n\ngoal (1 subgoal):\n 1. Polynomial.degree (f_poly \\<alpha>) = n * p - 1", "also"], ["proof (state)\nthis:\n  Polynomial.degree (f_poly \\<alpha>) = p - 1 + (n - 1) * p\n\ngoal (1 subgoal):\n 1. Polynomial.degree (f_poly \\<alpha>) = n * p - 1", "have \"p - 1 + (n - 1) * p = n * p - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p - 1 + (n - 1) * p = n * p - 1", "using \\<open>n > 0\\<close> \\<open>p > 1\\<close>"], ["proof (prove)\nusing this:\n  0 < n\n  1 < p\n\ngoal (1 subgoal):\n 1. p - 1 + (n - 1) * p = n * p - 1", "by (cases n) auto"], ["proof (state)\nthis:\n  p - 1 + (n - 1) * p = n * p - 1\n\ngoal (1 subgoal):\n 1. Polynomial.degree (f_poly \\<alpha>) = n * p - 1", "finally"], ["proof (chain)\npicking this:\n  Polynomial.degree (f_poly \\<alpha>) = n * p - 1", "show ?thesis"], ["proof (prove)\nusing this:\n  Polynomial.degree (f_poly \\<alpha>) = n * p - 1\n\ngoal (1 subgoal):\n 1. Polynomial.degree (f_poly \\<alpha>) = n * p - 1", "."], ["proof (state)\nthis:\n  Polynomial.degree (f_poly \\<alpha>) = n * p - 1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?\\<alpha> \\<in> Roots' \\<Longrightarrow>\n  Polynomial.degree (f_poly ?\\<alpha>) = n * p - 1\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> C' * C p ^ n", "text \\<open>\n      Next, we define the function $I_i(z) = \\int_0^z e^{z-t} f_i(t) \\text{d}t$, and,\n      based on that, the numbers $J_i = \\sum_{i=1}^m \\beta_i \\sum_{q_i(x) = 0} I_i(x)$,\n      and the number $J$, which is the product of all the $J_i$:\n    \\<close>"], ["proof (state)\nthis:\n  ?\\<alpha> \\<in> Roots' \\<Longrightarrow>\n  Polynomial.degree (f_poly ?\\<alpha>) = n * p - 1\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> C' * C p ^ n", "define I :: \"complex \\<Rightarrow> complex \\<Rightarrow> complex\"\n      where \"I = (\\<lambda>\\<alpha> x. lindemann_weierstrass_aux.I (f_poly \\<alpha>) x)\""], ["proof (state)\nthis:\n  I = (\\<lambda>\\<alpha>. lindemann_weierstrass_aux.I (f_poly \\<alpha>))\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> C' * C p ^ n", "define J :: \"complex \\<Rightarrow> complex\"\n      where \"J = (\\<lambda>\\<alpha>. \\<Sum>q\\<in>P. \\<beta> q * (\\<Sum>x\\<in>Roots q. I \\<alpha> x))\""], ["proof (state)\nthis:\n  J =\n  (\\<lambda>\\<alpha>.\n      \\<Sum>q\\<in>P. of_int (\\<beta> q) * sum (I \\<alpha>) (Roots q))\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> C' * C p ^ n", "define J' :: complex\n      where \"J' = (\\<Prod>\\<alpha>\\<in>Roots'. J \\<alpha>)\""], ["proof (state)\nthis:\n  J' = prod J Roots'\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> C' * C p ^ n", "text \\<open>\n      Reusing some of the machinery from the proof that \\<open>e\\<close> is transcendental,\n      we find the following equality for $J_i$:\n    \\<close>"], ["proof (state)\nthis:\n  J' = prod J Roots'\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> C' * C p ^ n", "have J_eq: \"J \\<alpha> = -(\\<Sum>q\\<in>P. of_int (\\<beta> q) * (\\<Sum>x\\<in>Roots q. \\<Sum>j<n*p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x))\"\n      if \"\\<alpha> \\<in> Roots'\" for \\<alpha>"], ["proof (prove)\ngoal (1 subgoal):\n 1. J \\<alpha> =\n    - (\\<Sum>q\\<in>P.\n         of_int (\\<beta> q) *\n         (\\<Sum>x\\<in>Roots q.\n            \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. J \\<alpha> =\n    - (\\<Sum>q\\<in>P.\n         of_int (\\<beta> q) *\n         (\\<Sum>x\\<in>Roots q.\n            \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x))", "have \"n * p \\<ge> 1 * 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * 2 \\<le> n * p", "using \\<open>n > 0\\<close> \\<open>p > 1\\<close>"], ["proof (prove)\nusing this:\n  0 < n\n  1 < p\n\ngoal (1 subgoal):\n 1. 1 * 2 \\<le> n * p", "by (intro mult_mono) auto"], ["proof (state)\nthis:\n  1 * 2 \\<le> n * p\n\ngoal (1 subgoal):\n 1. J \\<alpha> =\n    - (\\<Sum>q\\<in>P.\n         of_int (\\<beta> q) *\n         (\\<Sum>x\\<in>Roots q.\n            \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x))", "hence [simp]: \"{..n*p-Suc 0} = {..<n*p}\""], ["proof (prove)\nusing this:\n  1 * 2 \\<le> n * p\n\ngoal (1 subgoal):\n 1. {..n * p - Suc 0} = {..<n * p}", "by auto"], ["proof (state)\nthis:\n  {..n * p - Suc 0} = {..<n * p}\n\ngoal (1 subgoal):\n 1. J \\<alpha> =\n    - (\\<Sum>q\\<in>P.\n         of_int (\\<beta> q) *\n         (\\<Sum>x\\<in>Roots q.\n            \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x))", "have \"J \\<alpha> = (\\<Sum>q\\<in>P. \\<beta> q * (\\<Sum>x\\<in>Roots q. I \\<alpha> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. J \\<alpha> =\n    (\\<Sum>q\\<in>P. of_int (\\<beta> q) * sum (I \\<alpha>) (Roots q))", "unfolding J_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>P. of_int (\\<beta> q) * sum (I \\<alpha>) (Roots q)) =\n    (\\<Sum>q\\<in>P. of_int (\\<beta> q) * sum (I \\<alpha>) (Roots q))", ".."], ["proof (state)\nthis:\n  J \\<alpha> =\n  (\\<Sum>q\\<in>P. of_int (\\<beta> q) * sum (I \\<alpha>) (Roots q))\n\ngoal (1 subgoal):\n 1. J \\<alpha> =\n    - (\\<Sum>q\\<in>P.\n         of_int (\\<beta> q) *\n         (\\<Sum>x\\<in>Roots q.\n            \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x))", "also"], ["proof (state)\nthis:\n  J \\<alpha> =\n  (\\<Sum>q\\<in>P. of_int (\\<beta> q) * sum (I \\<alpha>) (Roots q))\n\ngoal (1 subgoal):\n 1. J \\<alpha> =\n    - (\\<Sum>q\\<in>P.\n         of_int (\\<beta> q) *\n         (\\<Sum>x\\<in>Roots q.\n            \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x))", "have \"\\<dots> = (\\<Sum>q\\<in>P. of_int (\\<beta> q) * (\\<Sum>x\\<in>Roots q. exp x * (\\<Sum>j<n*p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) 0))) -\n                      (\\<Sum>q\\<in>P. of_int (\\<beta> q) * (\\<Sum>x\\<in>Roots q. \\<Sum>j<n*p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>P. of_int (\\<beta> q) * sum (I \\<alpha>) (Roots q)) =\n    (\\<Sum>q\\<in>P.\n       of_int (\\<beta> q) *\n       (\\<Sum>x\\<in>Roots q.\n          exp x *\n          (\\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) 0))) -\n    (\\<Sum>q\\<in>P.\n       of_int (\\<beta> q) *\n       (\\<Sum>x\\<in>Roots q.\n          \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x))", "unfolding I_def lindemann_weierstrass_aux.I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>P.\n       of_int (\\<beta> q) *\n       (\\<Sum>x\\<in>Roots q.\n          exp x *\n          (\\<Sum>j\\<le>Polynomial.degree (f_poly \\<alpha>).\n              poly ((pderiv ^^ j) (f_poly \\<alpha>)) 0) -\n          (\\<Sum>j\\<le>Polynomial.degree (f_poly \\<alpha>).\n              poly ((pderiv ^^ j) (f_poly \\<alpha>)) x))) =\n    (\\<Sum>q\\<in>P.\n       of_int (\\<beta> q) *\n       (\\<Sum>x\\<in>Roots q.\n          exp x *\n          (\\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) 0))) -\n    (\\<Sum>q\\<in>P.\n       of_int (\\<beta> q) *\n       (\\<Sum>x\\<in>Roots q.\n          \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x))", "by (simp add: deg_f that ring_distribs sum_subtractf sum_distrib_left sum_distrib_right mult_ac)"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>P. of_int (\\<beta> q) * sum (I \\<alpha>) (Roots q)) =\n  (\\<Sum>q\\<in>P.\n     of_int (\\<beta> q) *\n     (\\<Sum>x\\<in>Roots q.\n        exp x *\n        (\\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) 0))) -\n  (\\<Sum>q\\<in>P.\n     of_int (\\<beta> q) *\n     (\\<Sum>x\\<in>Roots q.\n        \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x))\n\ngoal (1 subgoal):\n 1. J \\<alpha> =\n    - (\\<Sum>q\\<in>P.\n         of_int (\\<beta> q) *\n         (\\<Sum>x\\<in>Roots q.\n            \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x))", "also"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>P. of_int (\\<beta> q) * sum (I \\<alpha>) (Roots q)) =\n  (\\<Sum>q\\<in>P.\n     of_int (\\<beta> q) *\n     (\\<Sum>x\\<in>Roots q.\n        exp x *\n        (\\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) 0))) -\n  (\\<Sum>q\\<in>P.\n     of_int (\\<beta> q) *\n     (\\<Sum>x\\<in>Roots q.\n        \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x))\n\ngoal (1 subgoal):\n 1. J \\<alpha> =\n    - (\\<Sum>q\\<in>P.\n         of_int (\\<beta> q) *\n         (\\<Sum>x\\<in>Roots q.\n            \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x))", "have \"\\<dots> = -(\\<Sum>q\\<in>P. of_int (\\<beta> q) * (\\<Sum>x\\<in>Roots q. \\<Sum>j<n*p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>P.\n       of_int (\\<beta> q) *\n       (\\<Sum>x\\<in>Roots q.\n          exp x *\n          (\\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) 0))) -\n    (\\<Sum>q\\<in>P.\n       of_int (\\<beta> q) *\n       (\\<Sum>x\\<in>Roots q.\n          \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x)) =\n    - (\\<Sum>q\\<in>P.\n         of_int (\\<beta> q) *\n         (\\<Sum>x\\<in>Roots q.\n            \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x))", "unfolding sum_distrib_right [symmetric] mult.assoc [symmetric] sum_eq_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 * (\\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) 0) -\n    (\\<Sum>q\\<in>P.\n       of_int (\\<beta> q) *\n       (\\<Sum>x\\<in>Roots q.\n          \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x)) =\n    - (\\<Sum>q\\<in>P.\n         of_int (\\<beta> q) *\n         (\\<Sum>x\\<in>Roots q.\n            \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x))", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>P.\n     of_int (\\<beta> q) *\n     (\\<Sum>x\\<in>Roots q.\n        exp x *\n        (\\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) 0))) -\n  (\\<Sum>q\\<in>P.\n     of_int (\\<beta> q) *\n     (\\<Sum>x\\<in>Roots q.\n        \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x)) =\n  - (\\<Sum>q\\<in>P.\n       of_int (\\<beta> q) *\n       (\\<Sum>x\\<in>Roots q.\n          \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x))\n\ngoal (1 subgoal):\n 1. J \\<alpha> =\n    - (\\<Sum>q\\<in>P.\n         of_int (\\<beta> q) *\n         (\\<Sum>x\\<in>Roots q.\n            \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x))", "finally"], ["proof (chain)\npicking this:\n  J \\<alpha> =\n  - (\\<Sum>q\\<in>P.\n       of_int (\\<beta> q) *\n       (\\<Sum>x\\<in>Roots q.\n          \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x))", "show ?thesis"], ["proof (prove)\nusing this:\n  J \\<alpha> =\n  - (\\<Sum>q\\<in>P.\n       of_int (\\<beta> q) *\n       (\\<Sum>x\\<in>Roots q.\n          \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x))\n\ngoal (1 subgoal):\n 1. J \\<alpha> =\n    - (\\<Sum>q\\<in>P.\n         of_int (\\<beta> q) *\n         (\\<Sum>x\\<in>Roots q.\n            \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x))", "."], ["proof (state)\nthis:\n  J \\<alpha> =\n  - (\\<Sum>q\\<in>P.\n       of_int (\\<beta> q) *\n       (\\<Sum>x\\<in>Roots q.\n          \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?\\<alpha> \\<in> Roots' \\<Longrightarrow>\n  J ?\\<alpha> =\n  - (\\<Sum>q\\<in>P.\n       of_int (\\<beta> q) *\n       (\\<Sum>x\\<in>Roots q.\n          \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly ?\\<alpha>)) x))\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> C' * C p ^ n", "text \\<open>\n      The next big step is to show that $(p-1)! \\mid J_i$ as an algebraic integer (i.e.\n      $J_i / (p-1)!$ is an algebraic integer), but $p \\not\\mid J_i$. This is done by brute force:\n      We show that every summand in the above sum has $p!$ as a factor, except for\n      the one corresponding to $x = \\alpha_i$, $j = p - 1$, which has $(p-1)!$ as a factor but\n      not \\<open>p\\<close>.\n    \\<close>"], ["proof (state)\nthis:\n  ?\\<alpha> \\<in> Roots' \\<Longrightarrow>\n  J ?\\<alpha> =\n  - (\\<Sum>q\\<in>P.\n       of_int (\\<beta> q) *\n       (\\<Sum>x\\<in>Roots q.\n          \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly ?\\<alpha>)) x))\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> C' * C p ^ n", "have J: \"fact (p - 1) alg_dvd J \\<alpha>\" \"\\<not>of_nat p alg_dvd J \\<alpha>\" if \\<alpha>: \"\\<alpha> \\<in> Roots'\" for \\<alpha>"], ["proof (prove)\ngoal (1 subgoal):\n 1. fact (p - 1) alg_dvd J \\<alpha> &&& \\<not> of_nat p alg_dvd J \\<alpha>", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. fact (p - 1) alg_dvd J \\<alpha>\n 2. \\<not> of_nat p alg_dvd J \\<alpha>", "define h where \"h = (\\<lambda>\\<alpha>' j. poly ((pderiv ^^ j) (f_poly \\<alpha>)) \\<alpha>')\""], ["proof (state)\nthis:\n  h =\n  (\\<lambda>\\<alpha>' j. poly ((pderiv ^^ j) (f_poly \\<alpha>)) \\<alpha>')\n\ngoal (2 subgoals):\n 1. fact (p - 1) alg_dvd J \\<alpha>\n 2. \\<not> of_nat p alg_dvd J \\<alpha>", "from \\<alpha>"], ["proof (chain)\npicking this:\n  \\<alpha> \\<in> Roots'", "obtain q where q: \"q \\<in> P\" \"\\<alpha> \\<in> Roots q\""], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> Roots'\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in> P; \\<alpha> \\<in> Roots q\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: Roots'_def)"], ["proof (state)\nthis:\n  q \\<in> P\n  \\<alpha> \\<in> Roots q\n\ngoal (2 subgoals):\n 1. fact (p - 1) alg_dvd J \\<alpha>\n 2. \\<not> of_nat p alg_dvd J \\<alpha>", "have \"J \\<alpha> = -(\\<Sum>(q, \\<alpha>')\\<in>Sigma P Roots. \\<Sum>j<n*p. of_int (\\<beta> q) * h \\<alpha>' j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. J \\<alpha> =\n    - (\\<Sum>(q, \\<alpha>')\\<in>Sigma P Roots.\n         \\<Sum>j<n * p. of_int (\\<beta> q) * h \\<alpha>' j)", "unfolding J_eq[OF \\<alpha>] h_def sum_distrib_left"], ["proof (prove)\ngoal (1 subgoal):\n 1. - (\\<Sum>q\\<in>P.\n         \\<Sum>na\\<in>Roots q.\n           \\<Sum>n<n * p.\n              of_int (\\<beta> q) *\n              poly ((pderiv ^^ n) (f_poly \\<alpha>)) na) =\n    - (\\<Sum>(q, \\<alpha>')\\<in>Sigma P Roots.\n         \\<Sum>j<n * p.\n            of_int (\\<beta> q) *\n            poly ((pderiv ^^ j) (f_poly \\<alpha>)) \\<alpha>')", "by (subst (2) sum.Sigma) auto"], ["proof (state)\nthis:\n  J \\<alpha> =\n  - (\\<Sum>(q, \\<alpha>')\\<in>Sigma P Roots.\n       \\<Sum>j<n * p. of_int (\\<beta> q) * h \\<alpha>' j)\n\ngoal (2 subgoals):\n 1. fact (p - 1) alg_dvd J \\<alpha>\n 2. \\<not> of_nat p alg_dvd J \\<alpha>", "also"], ["proof (state)\nthis:\n  J \\<alpha> =\n  - (\\<Sum>(q, \\<alpha>')\\<in>Sigma P Roots.\n       \\<Sum>j<n * p. of_int (\\<beta> q) * h \\<alpha>' j)\n\ngoal (2 subgoals):\n 1. fact (p - 1) alg_dvd J \\<alpha>\n 2. \\<not> of_nat p alg_dvd J \\<alpha>", "have \"\\<dots> = -(\\<Sum>((q,\\<alpha>'),i)\\<in>Sigma P Roots\\<times>{..<n*p}. of_int (\\<beta> q) * h \\<alpha>' i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. - (\\<Sum>(q, \\<alpha>')\\<in>Sigma P Roots.\n         \\<Sum>j<n * p. of_int (\\<beta> q) * h \\<alpha>' j) =\n    - (\\<Sum>((q, \\<alpha>'), i)\\<in>Sigma P Roots \\<times> {..<n * p}.\n         of_int (\\<beta> q) * h \\<alpha>' i)", "by (subst (2) sum.Sigma [symmetric]) (auto simp: case_prod_unfold)"], ["proof (state)\nthis:\n  - (\\<Sum>(q, \\<alpha>')\\<in>Sigma P Roots.\n       \\<Sum>j<n * p. of_int (\\<beta> q) * h \\<alpha>' j) =\n  - (\\<Sum>((q, \\<alpha>'), i)\\<in>Sigma P Roots \\<times> {..<n * p}.\n       of_int (\\<beta> q) * h \\<alpha>' i)\n\ngoal (2 subgoals):\n 1. fact (p - 1) alg_dvd J \\<alpha>\n 2. \\<not> of_nat p alg_dvd J \\<alpha>", "finally"], ["proof (chain)\npicking this:\n  J \\<alpha> =\n  - (\\<Sum>((q, \\<alpha>'), i)\\<in>Sigma P Roots \\<times> {..<n * p}.\n       of_int (\\<beta> q) * h \\<alpha>' i)", "have J_eq': \"J \\<alpha> = - (\\<Sum>((q, \\<alpha>'), i)\\<in>Sigma P Roots \\<times> {..<n * p}. of_int (\\<beta> q) * h \\<alpha>' i)\""], ["proof (prove)\nusing this:\n  J \\<alpha> =\n  - (\\<Sum>((q, \\<alpha>'), i)\\<in>Sigma P Roots \\<times> {..<n * p}.\n       of_int (\\<beta> q) * h \\<alpha>' i)\n\ngoal (1 subgoal):\n 1. J \\<alpha> =\n    - (\\<Sum>((q, \\<alpha>'), i)\\<in>Sigma P Roots \\<times> {..<n * p}.\n         of_int (\\<beta> q) * h \\<alpha>' i)", "."], ["proof (state)\nthis:\n  J \\<alpha> =\n  - (\\<Sum>((q, \\<alpha>'), i)\\<in>Sigma P Roots \\<times> {..<n * p}.\n       of_int (\\<beta> q) * h \\<alpha>' i)\n\ngoal (2 subgoals):\n 1. fact (p - 1) alg_dvd J \\<alpha>\n 2. \\<not> of_nat p alg_dvd J \\<alpha>", "have h_\\<alpha>_pm1_eq: \"h \\<alpha> (p-1) = of_int (l^(n*p)) * fact (p-1) * (\\<Prod>\\<alpha>'\\<in>Roots'-{\\<alpha>}. (\\<alpha>-\\<alpha>')^p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<alpha> (p - 1) =\n    of_int (l ^ (n * p)) * fact (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}. (\\<alpha> - \\<alpha>') ^ p)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. h \\<alpha> (p - 1) =\n    of_int (l ^ (n * p)) * fact (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}. (\\<alpha> - \\<alpha>') ^ p)", "have \"h \\<alpha> (p - 1) = of_int (l ^ (n * p)) *\n                poly ((pderiv ^^ (p-1)) (\\<Prod>\\<alpha>'\\<in>Roots'. [:-\\<alpha>',1:] ^ (if \\<alpha>' = \\<alpha> then p - 1 else p))) \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<alpha> (p - 1) =\n    of_int (l ^ (n * p)) *\n    poly\n     ((pderiv ^^ (p - 1))\n       (\\<Prod>\\<alpha>'\\<in>Roots'.\n          [:- \\<alpha>', 1:] ^ (if \\<alpha>' = \\<alpha> then p - 1 else p)))\n     \\<alpha>", "unfolding h_def f_poly_altdef[OF \\<alpha>] higher_pderiv_smult poly_smult"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (l ^ (n * p)) *\n    poly\n     ((pderiv ^^ (p - 1))\n       (\\<Prod>\\<alpha>'\\<in>Roots'.\n          [:- \\<alpha>', 1:] ^ (if \\<alpha>' = \\<alpha> then p - 1 else p)))\n     \\<alpha> =\n    of_int (l ^ (n * p)) *\n    poly\n     ((pderiv ^^ (p - 1))\n       (\\<Prod>\\<alpha>'\\<in>Roots'.\n          [:- \\<alpha>', 1:] ^ (if \\<alpha>' = \\<alpha> then p - 1 else p)))\n     \\<alpha>", ".."], ["proof (state)\nthis:\n  h \\<alpha> (p - 1) =\n  of_int (l ^ (n * p)) *\n  poly\n   ((pderiv ^^ (p - 1))\n     (\\<Prod>\\<alpha>'\\<in>Roots'.\n        [:- \\<alpha>', 1:] ^ (if \\<alpha>' = \\<alpha> then p - 1 else p)))\n   \\<alpha>\n\ngoal (1 subgoal):\n 1. h \\<alpha> (p - 1) =\n    of_int (l ^ (n * p)) * fact (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}. (\\<alpha> - \\<alpha>') ^ p)", "also"], ["proof (state)\nthis:\n  h \\<alpha> (p - 1) =\n  of_int (l ^ (n * p)) *\n  poly\n   ((pderiv ^^ (p - 1))\n     (\\<Prod>\\<alpha>'\\<in>Roots'.\n        [:- \\<alpha>', 1:] ^ (if \\<alpha>' = \\<alpha> then p - 1 else p)))\n   \\<alpha>\n\ngoal (1 subgoal):\n 1. h \\<alpha> (p - 1) =\n    of_int (l ^ (n * p)) * fact (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}. (\\<alpha> - \\<alpha>') ^ p)", "have \"(\\<Prod>\\<alpha>'\\<in>Roots'. [:-\\<alpha>',1:] ^ (if \\<alpha>' = \\<alpha> then p - 1 else p)) =\n                    [:-\\<alpha>,1:]^(p-1) * (\\<Prod>\\<alpha>'\\<in>Roots'-{\\<alpha>}. [:-\\<alpha>',1:]^p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>\\<alpha>'\\<in>Roots'.\n       [:- \\<alpha>', 1:] ^ (if \\<alpha>' = \\<alpha> then p - 1 else p)) =\n    [:- \\<alpha>, 1:] ^ (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}. [:- \\<alpha>', 1:] ^ p)", "using \\<alpha>"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> Roots'\n\ngoal (1 subgoal):\n 1. (\\<Prod>\\<alpha>'\\<in>Roots'.\n       [:- \\<alpha>', 1:] ^ (if \\<alpha>' = \\<alpha> then p - 1 else p)) =\n    [:- \\<alpha>, 1:] ^ (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}. [:- \\<alpha>', 1:] ^ p)", "by (subst prod.If_eq) auto"], ["proof (state)\nthis:\n  (\\<Prod>\\<alpha>'\\<in>Roots'.\n     [:- \\<alpha>', 1:] ^ (if \\<alpha>' = \\<alpha> then p - 1 else p)) =\n  [:- \\<alpha>, 1:] ^ (p - 1) *\n  (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}. [:- \\<alpha>', 1:] ^ p)\n\ngoal (1 subgoal):\n 1. h \\<alpha> (p - 1) =\n    of_int (l ^ (n * p)) * fact (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}. (\\<alpha> - \\<alpha>') ^ p)", "also"], ["proof (state)\nthis:\n  (\\<Prod>\\<alpha>'\\<in>Roots'.\n     [:- \\<alpha>', 1:] ^ (if \\<alpha>' = \\<alpha> then p - 1 else p)) =\n  [:- \\<alpha>, 1:] ^ (p - 1) *\n  (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}. [:- \\<alpha>', 1:] ^ p)\n\ngoal (1 subgoal):\n 1. h \\<alpha> (p - 1) =\n    of_int (l ^ (n * p)) * fact (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}. (\\<alpha> - \\<alpha>') ^ p)", "have \"poly ((pderiv ^^ (p-1)) \\<dots>) \\<alpha> = fact (p - 1) * (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}. (\\<alpha> - \\<alpha>') ^ p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly\n     ((pderiv ^^ (p - 1))\n       ([:- \\<alpha>, 1:] ^ (p - 1) *\n        (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}. [:- \\<alpha>', 1:] ^ p)))\n     \\<alpha> =\n    fact (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}. (\\<alpha> - \\<alpha>') ^ p)", "by (subst poly_higher_pderiv_aux2) (simp_all add: poly_prod)"], ["proof (state)\nthis:\n  poly\n   ((pderiv ^^ (p - 1))\n     ([:- \\<alpha>, 1:] ^ (p - 1) *\n      (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}. [:- \\<alpha>', 1:] ^ p)))\n   \\<alpha> =\n  fact (p - 1) *\n  (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}. (\\<alpha> - \\<alpha>') ^ p)\n\ngoal (1 subgoal):\n 1. h \\<alpha> (p - 1) =\n    of_int (l ^ (n * p)) * fact (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}. (\\<alpha> - \\<alpha>') ^ p)", "finally"], ["proof (chain)\npicking this:\n  h \\<alpha> (p - 1) =\n  of_int (l ^ (n * p)) *\n  (fact (p - 1) *\n   (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}. (\\<alpha> - \\<alpha>') ^ p))", "show ?thesis"], ["proof (prove)\nusing this:\n  h \\<alpha> (p - 1) =\n  of_int (l ^ (n * p)) *\n  (fact (p - 1) *\n   (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}. (\\<alpha> - \\<alpha>') ^ p))\n\ngoal (1 subgoal):\n 1. h \\<alpha> (p - 1) =\n    of_int (l ^ (n * p)) * fact (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}. (\\<alpha> - \\<alpha>') ^ p)", "by (simp only: mult.assoc)"], ["proof (state)\nthis:\n  h \\<alpha> (p - 1) =\n  of_int (l ^ (n * p)) * fact (p - 1) *\n  (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}. (\\<alpha> - \\<alpha>') ^ p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  h \\<alpha> (p - 1) =\n  of_int (l ^ (n * p)) * fact (p - 1) *\n  (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}. (\\<alpha> - \\<alpha>') ^ p)\n\ngoal (2 subgoals):\n 1. fact (p - 1) alg_dvd J \\<alpha>\n 2. \\<not> of_nat p alg_dvd J \\<alpha>", "have \"fact (p-1) alg_dvd h \\<alpha> (p-1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fact (p - 1) alg_dvd h \\<alpha> (p - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fact (p - 1) alg_dvd h \\<alpha> (p - 1)", "have \"fact (p-1) alg_dvd fact (p-1) * (of_int (l^p) * (\\<Prod>\\<alpha>'\\<in>Roots'-{\\<alpha>}. (l*\\<alpha>-l*\\<alpha>')^p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fact (p - 1) alg_dvd\n    fact (p - 1) *\n    (of_int (l ^ p) *\n     (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n        (of_int l * \\<alpha> - of_int l * \\<alpha>') ^ p))", "by (intro alg_dvd_triv_left algebraic_int_times[of \"of_int (l^p)\"]\n                    algebraic_int_prod algebraic_int_power algebraic_int_diff\n                    alg_int \\<alpha> algebraic_int_of_int) auto"], ["proof (state)\nthis:\n  fact (p - 1) alg_dvd\n  fact (p - 1) *\n  (of_int (l ^ p) *\n   (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n      (of_int l * \\<alpha> - of_int l * \\<alpha>') ^ p))\n\ngoal (1 subgoal):\n 1. fact (p - 1) alg_dvd h \\<alpha> (p - 1)", "also"], ["proof (state)\nthis:\n  fact (p - 1) alg_dvd\n  fact (p - 1) *\n  (of_int (l ^ p) *\n   (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n      (of_int l * \\<alpha> - of_int l * \\<alpha>') ^ p))\n\ngoal (1 subgoal):\n 1. fact (p - 1) alg_dvd h \\<alpha> (p - 1)", "have \"(\\<Prod>\\<alpha>'\\<in>Roots'-{\\<alpha>}. (l*\\<alpha>-l*\\<alpha>')^p) = (\\<Prod>\\<alpha>'\\<in>Roots'-{\\<alpha>}. of_int l^p * (\\<alpha>-\\<alpha>')^p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n       (of_int l * \\<alpha> - of_int l * \\<alpha>') ^ p) =\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n       of_int l ^ p * (\\<alpha> - \\<alpha>') ^ p)", "by (subst power_mult_distrib [symmetric]) (simp_all add: algebra_simps)"], ["proof (state)\nthis:\n  (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n     (of_int l * \\<alpha> - of_int l * \\<alpha>') ^ p) =\n  (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n     of_int l ^ p * (\\<alpha> - \\<alpha>') ^ p)\n\ngoal (1 subgoal):\n 1. fact (p - 1) alg_dvd h \\<alpha> (p - 1)", "also"], ["proof (state)\nthis:\n  (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n     (of_int l * \\<alpha> - of_int l * \\<alpha>') ^ p) =\n  (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n     of_int l ^ p * (\\<alpha> - \\<alpha>') ^ p)\n\ngoal (1 subgoal):\n 1. fact (p - 1) alg_dvd h \\<alpha> (p - 1)", "have \"\\<dots> = of_int (l ^ (p * (n-1))) * (\\<Prod>\\<alpha>'\\<in>Roots'-{\\<alpha>}. (\\<alpha>-\\<alpha>')^p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n       of_int l ^ p * (\\<alpha> - \\<alpha>') ^ p) =\n    of_int (l ^ (p * (n - 1))) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}. (\\<alpha> - \\<alpha>') ^ p)", "using \\<alpha>"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> Roots'\n\ngoal (1 subgoal):\n 1. (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n       of_int l ^ p * (\\<alpha> - \\<alpha>') ^ p) =\n    of_int (l ^ (p * (n - 1))) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}. (\\<alpha> - \\<alpha>') ^ p)", "by (subst prod.distrib) (auto simp: card_Diff_subset n_altdef simp flip: power_mult)"], ["proof (state)\nthis:\n  (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n     of_int l ^ p * (\\<alpha> - \\<alpha>') ^ p) =\n  of_int (l ^ (p * (n - 1))) *\n  (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}. (\\<alpha> - \\<alpha>') ^ p)\n\ngoal (1 subgoal):\n 1. fact (p - 1) alg_dvd h \\<alpha> (p - 1)", "also"], ["proof (state)\nthis:\n  (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n     of_int l ^ p * (\\<alpha> - \\<alpha>') ^ p) =\n  of_int (l ^ (p * (n - 1))) *\n  (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}. (\\<alpha> - \\<alpha>') ^ p)\n\ngoal (1 subgoal):\n 1. fact (p - 1) alg_dvd h \\<alpha> (p - 1)", "have \"of_int (l^p) * \\<dots> = of_int (l^(p+p*(n-1))) * (\\<Prod>\\<alpha>'\\<in>Roots'-{\\<alpha>}. (\\<alpha>-\\<alpha>')^p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (l ^ p) *\n    (of_int (l ^ (p * (n - 1))) *\n     (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n        (\\<alpha> - \\<alpha>') ^ p)) =\n    of_int (l ^ (p + p * (n - 1))) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}. (\\<alpha> - \\<alpha>') ^ p)", "unfolding mult.assoc [symmetric] power_add [symmetric] of_int_power"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int l ^ (p + p * (n - 1)) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}. (\\<alpha> - \\<alpha>') ^ p) =\n    of_int l ^ (p + p * (n - 1)) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}. (\\<alpha> - \\<alpha>') ^ p)", ".."], ["proof (state)\nthis:\n  of_int (l ^ p) *\n  (of_int (l ^ (p * (n - 1))) *\n   (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}. (\\<alpha> - \\<alpha>') ^ p)) =\n  of_int (l ^ (p + p * (n - 1))) *\n  (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}. (\\<alpha> - \\<alpha>') ^ p)\n\ngoal (1 subgoal):\n 1. fact (p - 1) alg_dvd h \\<alpha> (p - 1)", "also"], ["proof (state)\nthis:\n  of_int (l ^ p) *\n  (of_int (l ^ (p * (n - 1))) *\n   (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}. (\\<alpha> - \\<alpha>') ^ p)) =\n  of_int (l ^ (p + p * (n - 1))) *\n  (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}. (\\<alpha> - \\<alpha>') ^ p)\n\ngoal (1 subgoal):\n 1. fact (p - 1) alg_dvd h \\<alpha> (p - 1)", "have \"p + p * (n - 1) = n * p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p + p * (n - 1) = n * p", "using \\<open>n > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. p + p * (n - 1) = n * p", "by (cases n) (auto simp: mult_ac)"], ["proof (state)\nthis:\n  p + p * (n - 1) = n * p\n\ngoal (1 subgoal):\n 1. fact (p - 1) alg_dvd h \\<alpha> (p - 1)", "also"], ["proof (state)\nthis:\n  p + p * (n - 1) = n * p\n\ngoal (1 subgoal):\n 1. fact (p - 1) alg_dvd h \\<alpha> (p - 1)", "have \"fact (p - 1) * (of_int (l^(n*p)) * (\\<Prod>\\<alpha>'\\<in>Roots'-{\\<alpha>}. (\\<alpha>-\\<alpha>')^p)) = h \\<alpha> (p-1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fact (p - 1) *\n    (of_int (l ^ (n * p)) *\n     (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n        (\\<alpha> - \\<alpha>') ^ p)) =\n    h \\<alpha> (p - 1)", "unfolding h_\\<alpha>_pm1_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. fact (p - 1) *\n    (of_int (l ^ (n * p)) *\n     (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n        (\\<alpha> - \\<alpha>') ^ p)) =\n    of_int (l ^ (n * p)) * fact (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}. (\\<alpha> - \\<alpha>') ^ p)", "by (simp add: mult_ac)"], ["proof (state)\nthis:\n  fact (p - 1) *\n  (of_int (l ^ (n * p)) *\n   (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}. (\\<alpha> - \\<alpha>') ^ p)) =\n  h \\<alpha> (p - 1)\n\ngoal (1 subgoal):\n 1. fact (p - 1) alg_dvd h \\<alpha> (p - 1)", "finally"], ["proof (chain)\npicking this:\n  fact (p - 1) alg_dvd h \\<alpha> (p - 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  fact (p - 1) alg_dvd h \\<alpha> (p - 1)\n\ngoal (1 subgoal):\n 1. fact (p - 1) alg_dvd h \\<alpha> (p - 1)", "."], ["proof (state)\nthis:\n  fact (p - 1) alg_dvd h \\<alpha> (p - 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fact (p - 1) alg_dvd h \\<alpha> (p - 1)\n\ngoal (2 subgoals):\n 1. fact (p - 1) alg_dvd J \\<alpha>\n 2. \\<not> of_nat p alg_dvd J \\<alpha>", "have \"\\<not>of_nat p alg_dvd of_int (\\<beta> q) * h \\<alpha> (p-1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> of_nat p alg_dvd of_int (\\<beta> q) * h \\<alpha> (p - 1)", "unfolding h_\\<alpha>_pm1_eq mult.assoc [symmetric] of_int_mult [symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> of_nat p alg_dvd\n           of_int (\\<beta> q * l ^ (n * p)) * fact (p - 1) *\n           (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n              (\\<alpha> - \\<alpha>') ^ p)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. of_nat p alg_dvd\n    of_int (\\<beta> q * l ^ (n * p)) * fact (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n       (\\<alpha> - \\<alpha>') ^ p) \\<Longrightarrow>\n    False", "define r where \"r = (\\<lambda>\\<alpha>. of_int (l^n) * (\\<Prod>\\<alpha>'\\<in>Roots'-{\\<alpha>}. \\<alpha>-\\<alpha>'))\""], ["proof (state)\nthis:\n  r =\n  (\\<lambda>\\<alpha>.\n      of_int (l ^ n) * prod ((-) \\<alpha>) (Roots' - {\\<alpha>}))\n\ngoal (1 subgoal):\n 1. of_nat p alg_dvd\n    of_int (\\<beta> q * l ^ (n * p)) * fact (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n       (\\<alpha> - \\<alpha>') ^ p) \\<Longrightarrow>\n    False", "have alg_int_r: \"algebraic_int (r \\<alpha>)\" if \"\\<alpha> \\<in> Roots'\" for \\<alpha>"], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic_int (r \\<alpha>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. algebraic_int (r \\<alpha>)", "have \"algebraic_int (of_int l * (\\<Prod>\\<alpha>'\\<in>Roots'-{\\<alpha>}. of_int l * \\<alpha> - of_int l * \\<alpha>'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic_int\n     (of_int l *\n      (\\<Prod>\\<alpha>''\\<in>Roots' - {\\<alpha>}.\n         of_int l * \\<alpha> - of_int l * \\<alpha>''))", "by (intro algebraic_int_times[OF algebraic_int_of_int] algebraic_int_prod \n                      algebraic_int_power algebraic_int_diff alg_int that) auto"], ["proof (state)\nthis:\n  algebraic_int\n   (of_int l *\n    (\\<Prod>\\<alpha>''\\<in>Roots' - {\\<alpha>}.\n       of_int l * \\<alpha> - of_int l * \\<alpha>''))\n\ngoal (1 subgoal):\n 1. algebraic_int (r \\<alpha>)", "also"], ["proof (state)\nthis:\n  algebraic_int\n   (of_int l *\n    (\\<Prod>\\<alpha>''\\<in>Roots' - {\\<alpha>}.\n       of_int l * \\<alpha> - of_int l * \\<alpha>''))\n\ngoal (1 subgoal):\n 1. algebraic_int (r \\<alpha>)", "have \"\\<dots> = of_int l * (\\<Prod>\\<alpha>'\\<in>Roots'-{\\<alpha>}. of_int l * (\\<alpha> - \\<alpha>'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int l *\n    (\\<Prod>\\<alpha>''\\<in>Roots' - {\\<alpha>}.\n       of_int l * \\<alpha> - of_int l * \\<alpha>'') =\n    of_int l *\n    (\\<Prod>\\<alpha>''\\<in>Roots' - {\\<alpha>}.\n       of_int l * (\\<alpha> - \\<alpha>''))", "by (simp add: algebra_simps flip: power_mult_distrib)"], ["proof (state)\nthis:\n  of_int l *\n  (\\<Prod>\\<alpha>''\\<in>Roots' - {\\<alpha>}.\n     of_int l * \\<alpha> - of_int l * \\<alpha>'') =\n  of_int l *\n  (\\<Prod>\\<alpha>''\\<in>Roots' - {\\<alpha>}.\n     of_int l * (\\<alpha> - \\<alpha>''))\n\ngoal (1 subgoal):\n 1. algebraic_int (r \\<alpha>)", "also"], ["proof (state)\nthis:\n  of_int l *\n  (\\<Prod>\\<alpha>''\\<in>Roots' - {\\<alpha>}.\n     of_int l * \\<alpha> - of_int l * \\<alpha>'') =\n  of_int l *\n  (\\<Prod>\\<alpha>''\\<in>Roots' - {\\<alpha>}.\n     of_int l * (\\<alpha> - \\<alpha>''))\n\ngoal (1 subgoal):\n 1. algebraic_int (r \\<alpha>)", "have \"\\<dots> = of_int (l^(1 + (n-1))) * (\\<Prod>\\<alpha>'\\<in>Roots'-{\\<alpha>}. \\<alpha> - \\<alpha>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int l *\n    (\\<Prod>\\<alpha>''\\<in>Roots' - {\\<alpha>}.\n       of_int l * (\\<alpha> - \\<alpha>'')) =\n    of_int (l ^ (1 + (n - 1))) * prod ((-) \\<alpha>) (Roots' - {\\<alpha>})", "using that"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> Roots'\n\ngoal (1 subgoal):\n 1. of_int l *\n    (\\<Prod>\\<alpha>''\\<in>Roots' - {\\<alpha>}.\n       of_int l * (\\<alpha> - \\<alpha>'')) =\n    of_int (l ^ (1 + (n - 1))) * prod ((-) \\<alpha>) (Roots' - {\\<alpha>})", "by (simp add: r_def prod.distrib card_Diff_subset\n                                     n_altdef power_add mult_ac flip: power_mult)"], ["proof (state)\nthis:\n  of_int l *\n  (\\<Prod>\\<alpha>''\\<in>Roots' - {\\<alpha>}.\n     of_int l * (\\<alpha> - \\<alpha>'')) =\n  of_int (l ^ (1 + (n - 1))) * prod ((-) \\<alpha>) (Roots' - {\\<alpha>})\n\ngoal (1 subgoal):\n 1. algebraic_int (r \\<alpha>)", "also"], ["proof (state)\nthis:\n  of_int l *\n  (\\<Prod>\\<alpha>''\\<in>Roots' - {\\<alpha>}.\n     of_int l * (\\<alpha> - \\<alpha>'')) =\n  of_int (l ^ (1 + (n - 1))) * prod ((-) \\<alpha>) (Roots' - {\\<alpha>})\n\ngoal (1 subgoal):\n 1. algebraic_int (r \\<alpha>)", "have \"1 + (n - 1) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + (n - 1) = n", "using \\<open>n > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. 1 + (n - 1) = n", "by auto"], ["proof (state)\nthis:\n  1 + (n - 1) = n\n\ngoal (1 subgoal):\n 1. algebraic_int (r \\<alpha>)", "finally"], ["proof (chain)\npicking this:\n  algebraic_int (of_int (l ^ n) * prod ((-) \\<alpha>) (Roots' - {\\<alpha>}))", "show \"algebraic_int (r \\<alpha>)\""], ["proof (prove)\nusing this:\n  algebraic_int (of_int (l ^ n) * prod ((-) \\<alpha>) (Roots' - {\\<alpha>}))\n\ngoal (1 subgoal):\n 1. algebraic_int (r \\<alpha>)", "unfolding r_def"], ["proof (prove)\nusing this:\n  algebraic_int (of_int (l ^ n) * prod ((-) \\<alpha>) (Roots' - {\\<alpha>}))\n\ngoal (1 subgoal):\n 1. algebraic_int\n     (of_int (l ^ n) * prod ((-) \\<alpha>) (Roots' - {\\<alpha>}))", "."], ["proof (state)\nthis:\n  algebraic_int (r \\<alpha>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?\\<alpha> \\<in> Roots' \\<Longrightarrow> algebraic_int (r ?\\<alpha>)\n\ngoal (1 subgoal):\n 1. of_nat p alg_dvd\n    of_int (\\<beta> q * l ^ (n * p)) * fact (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n       (\\<alpha> - \\<alpha>') ^ p) \\<Longrightarrow>\n    False", "have \"(\\<Prod>\\<alpha>'\\<in>Roots'. r \\<alpha>') \\<in> \\<rat>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod r Roots' \\<in> \\<rat>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prod r Roots' \\<in> \\<rat>", "obtain Root where Root_bij: \"bij_betw Root {..<n} Roots'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Root.\n        bij_betw Root {..<n} Roots' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ex_bij_betw_nat_finite[OF \\<open>finite Roots'\\<close>]"], ["proof (prove)\nusing this:\n  \\<exists>h. bij_betw h {0..<card Roots'} Roots'\n\ngoal (1 subgoal):\n 1. (\\<And>Root.\n        bij_betw Root {..<n} Roots' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding n_altdef atLeast0LessThan"], ["proof (prove)\nusing this:\n  \\<exists>h. bij_betw h {..<card Roots'} Roots'\n\ngoal (1 subgoal):\n 1. (\\<And>Root.\n        bij_betw Root {..<card Roots'} Roots' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  bij_betw Root {..<n} Roots'\n\ngoal (1 subgoal):\n 1. prod r Roots' \\<in> \\<rat>", "have Root_in_Roots': \"Root i \\<in> Roots'\" if \"i < n\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. Root i \\<in> Roots'", "using Root_bij that"], ["proof (prove)\nusing this:\n  bij_betw Root {..<n} Roots'\n  i < n\n\ngoal (1 subgoal):\n 1. Root i \\<in> Roots'", "by (auto simp: bij_betw_def)"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow> Root ?i \\<in> Roots'\n\ngoal (1 subgoal):\n 1. prod r Roots' \\<in> \\<rat>", "define R :: \"complex mpoly\" where\n            \"R = (\\<Prod>i<n. Const (of_int (l^n)) * (\\<Prod>j\\<in>{..<n}-{i}. Var i - Var j))\""], ["proof (state)\nthis:\n  R =\n  (\\<Prod>i<n.\n      Const (of_int (l ^ n)) * (\\<Prod>j\\<in>{..<n} - {i}. Var i - Var j))\n\ngoal (1 subgoal):\n 1. prod r Roots' \\<in> \\<rat>", "have \"insertion Root R \\<in> \\<rat>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion Root R \\<in> \\<rat>", "proof (rule symmetric_poly_of_roots_in_subring)"], ["proof (state)\ngoal (10 subgoals):\n 1. ring_closed \\<rat>\n 2. \\<forall>m. MPoly_Type.coeff R m \\<in> \\<rat>\n 3. ring_homomorphism (\\<lambda>a. a)\n 4. finite ?A\n 5. symmetric_mpoly ?A R\n 6. vars R \\<subseteq> ?A\n 7. ?cinv * ?c = 1\n 8. ?cinv \\<in> \\<rat>\n 9. ?p = Polynomial.smult ?c (\\<Prod>i\\<in>?A. [:- Root i, 1:])\n 10. \\<forall>i. poly.coeff ?p i \\<in> \\<rat>", "show \"symmetric_mpoly {..<n} R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric_mpoly {..<n} R", "unfolding R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric_mpoly {..<n}\n     (\\<Prod>i<n.\n         Const (of_int (l ^ n)) *\n         (\\<Prod>j\\<in>{..<n} - {i}. Var i - Var j))", "proof (rule symmetric_mpoly_symmetric_prod'[of _ \"\\<lambda>\\<pi>. \\<pi>\"], goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes {..<n} \\<Longrightarrow> \\<pi> permutes {..<n}\n 2. \\<And>i \\<pi>.\n       \\<lbrakk>i \\<in> {..<n}; \\<pi> permutes {..<n}\\<rbrakk>\n       \\<Longrightarrow> mpoly_map_vars \\<pi>\n                          (Const (of_int (l ^ n)) *\n                           (\\<Prod>j\\<in>{..<n} - {i}. Var i - Var j)) =\n                         Const (of_int (l ^ n)) *\n                         (\\<Prod>j\\<in>{..<n} - {\\<pi> i}.\n                            Var (\\<pi> i) - Var j)", "case (2 i \\<pi>)"], ["proof (state)\nthis:\n  i \\<in> {..<n}\n  \\<pi> permutes {..<n}\n\ngoal (2 subgoals):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes {..<n} \\<Longrightarrow> \\<pi> permutes {..<n}\n 2. \\<And>i \\<pi>.\n       \\<lbrakk>i \\<in> {..<n}; \\<pi> permutes {..<n}\\<rbrakk>\n       \\<Longrightarrow> mpoly_map_vars \\<pi>\n                          (Const (of_int (l ^ n)) *\n                           (\\<Prod>j\\<in>{..<n} - {i}. Var i - Var j)) =\n                         Const (of_int (l ^ n)) *\n                         (\\<Prod>j\\<in>{..<n} - {\\<pi> i}.\n                            Var (\\<pi> i) - Var j)", "from \\<open>\\<pi> permutes {..<n}\\<close>"], ["proof (chain)\npicking this:\n  \\<pi> permutes {..<n}", "have [simp]: \"bij \\<pi>\""], ["proof (prove)\nusing this:\n  \\<pi> permutes {..<n}\n\ngoal (1 subgoal):\n 1. bij \\<pi>", "by (rule permutes_bij)"], ["proof (state)\nthis:\n  bij \\<pi>\n\ngoal (2 subgoals):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes {..<n} \\<Longrightarrow> \\<pi> permutes {..<n}\n 2. \\<And>i \\<pi>.\n       \\<lbrakk>i \\<in> {..<n}; \\<pi> permutes {..<n}\\<rbrakk>\n       \\<Longrightarrow> mpoly_map_vars \\<pi>\n                          (Const (of_int (l ^ n)) *\n                           (\\<Prod>j\\<in>{..<n} - {i}. Var i - Var j)) =\n                         Const (of_int (l ^ n)) *\n                         (\\<Prod>j\\<in>{..<n} - {\\<pi> i}.\n                            Var (\\<pi> i) - Var j)", "have \"mpoly_map_vars \\<pi> (Const (of_int (l ^ n)) *\n                      (\\<Prod>j\\<in>{..<n} - {i}. Var i - Var j):: complex mpoly) =\n                    Const (of_int l ^ n) * (\\<Prod>j\\<in>{..<n} - {i}. Var (\\<pi> i) - Var (\\<pi> j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_map_vars \\<pi>\n     (Const (of_int (l ^ n)) * (\\<Prod>j\\<in>{..<n} - {i}. Var i - Var j)) =\n    Const (of_int l ^ n) *\n    (\\<Prod>j\\<in>{..<n} - {i}. Var (\\<pi> i) - Var (\\<pi> j))", "by simp"], ["proof (state)\nthis:\n  mpoly_map_vars \\<pi>\n   (Const (of_int (l ^ n)) * (\\<Prod>j\\<in>{..<n} - {i}. Var i - Var j)) =\n  Const (of_int l ^ n) *\n  (\\<Prod>j\\<in>{..<n} - {i}. Var (\\<pi> i) - Var (\\<pi> j))\n\ngoal (2 subgoals):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes {..<n} \\<Longrightarrow> \\<pi> permutes {..<n}\n 2. \\<And>i \\<pi>.\n       \\<lbrakk>i \\<in> {..<n}; \\<pi> permutes {..<n}\\<rbrakk>\n       \\<Longrightarrow> mpoly_map_vars \\<pi>\n                          (Const (of_int (l ^ n)) *\n                           (\\<Prod>j\\<in>{..<n} - {i}. Var i - Var j)) =\n                         Const (of_int (l ^ n)) *\n                         (\\<Prod>j\\<in>{..<n} - {\\<pi> i}.\n                            Var (\\<pi> i) - Var j)", "also"], ["proof (state)\nthis:\n  mpoly_map_vars \\<pi>\n   (Const (of_int (l ^ n)) * (\\<Prod>j\\<in>{..<n} - {i}. Var i - Var j)) =\n  Const (of_int l ^ n) *\n  (\\<Prod>j\\<in>{..<n} - {i}. Var (\\<pi> i) - Var (\\<pi> j))\n\ngoal (2 subgoals):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes {..<n} \\<Longrightarrow> \\<pi> permutes {..<n}\n 2. \\<And>i \\<pi>.\n       \\<lbrakk>i \\<in> {..<n}; \\<pi> permutes {..<n}\\<rbrakk>\n       \\<Longrightarrow> mpoly_map_vars \\<pi>\n                          (Const (of_int (l ^ n)) *\n                           (\\<Prod>j\\<in>{..<n} - {i}. Var i - Var j)) =\n                         Const (of_int (l ^ n)) *\n                         (\\<Prod>j\\<in>{..<n} - {\\<pi> i}.\n                            Var (\\<pi> i) - Var j)", "have \"(\\<Prod>j\\<in>{..<n} - {i}. Var (\\<pi> i) - Var (\\<pi> j)) =\n                         (\\<Prod>j\\<in>{..<n} - {\\<pi> i}. Var (\\<pi> i) - Var j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>j\\<in>{..<n} - {i}. Var (\\<pi> i) - Var (\\<pi> j)) =\n    (\\<Prod>j\\<in>{..<n} - {\\<pi> i}. Var (\\<pi> i) - Var j)", "using 2 permutes_in_image[OF 2(2), of i]"], ["proof (prove)\nusing this:\n  i \\<in> {..<n}\n  \\<pi> permutes {..<n}\n  (\\<pi> i \\<in> {..<n}) = (i \\<in> {..<n})\n\ngoal (1 subgoal):\n 1. (\\<Prod>j\\<in>{..<n} - {i}. Var (\\<pi> i) - Var (\\<pi> j)) =\n    (\\<Prod>j\\<in>{..<n} - {\\<pi> i}. Var (\\<pi> i) - Var j)", "by (intro prod.reindex_bij_betw bij_betw_Diff permutes_imp_bij[OF 2(2)])\n                   (auto simp: bij_betw_singleton)"], ["proof (state)\nthis:\n  (\\<Prod>j\\<in>{..<n} - {i}. Var (\\<pi> i) - Var (\\<pi> j)) =\n  (\\<Prod>j\\<in>{..<n} - {\\<pi> i}. Var (\\<pi> i) - Var j)\n\ngoal (2 subgoals):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes {..<n} \\<Longrightarrow> \\<pi> permutes {..<n}\n 2. \\<And>i \\<pi>.\n       \\<lbrakk>i \\<in> {..<n}; \\<pi> permutes {..<n}\\<rbrakk>\n       \\<Longrightarrow> mpoly_map_vars \\<pi>\n                          (Const (of_int (l ^ n)) *\n                           (\\<Prod>j\\<in>{..<n} - {i}. Var i - Var j)) =\n                         Const (of_int (l ^ n)) *\n                         (\\<Prod>j\\<in>{..<n} - {\\<pi> i}.\n                            Var (\\<pi> i) - Var j)", "finally"], ["proof (chain)\npicking this:\n  mpoly_map_vars \\<pi>\n   (Const (of_int (l ^ n)) * (\\<Prod>j\\<in>{..<n} - {i}. Var i - Var j)) =\n  Const (of_int l ^ n) *\n  (\\<Prod>j\\<in>{..<n} - {\\<pi> i}. Var (\\<pi> i) - Var j)", "show ?case"], ["proof (prove)\nusing this:\n  mpoly_map_vars \\<pi>\n   (Const (of_int (l ^ n)) * (\\<Prod>j\\<in>{..<n} - {i}. Var i - Var j)) =\n  Const (of_int l ^ n) *\n  (\\<Prod>j\\<in>{..<n} - {\\<pi> i}. Var (\\<pi> i) - Var j)\n\ngoal (1 subgoal):\n 1. mpoly_map_vars \\<pi>\n     (Const (of_int (l ^ n)) * (\\<Prod>j\\<in>{..<n} - {i}. Var i - Var j)) =\n    Const (of_int (l ^ n)) *\n    (\\<Prod>j\\<in>{..<n} - {\\<pi> i}. Var (\\<pi> i) - Var j)", "by simp"], ["proof (state)\nthis:\n  mpoly_map_vars \\<pi>\n   (Const (of_int (l ^ n)) * (\\<Prod>j\\<in>{..<n} - {i}. Var i - Var j)) =\n  Const (of_int (l ^ n)) *\n  (\\<Prod>j\\<in>{..<n} - {\\<pi> i}. Var (\\<pi> i) - Var j)\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes {..<n} \\<Longrightarrow> \\<pi> permutes {..<n}", "qed"], ["proof (state)\nthis:\n  symmetric_mpoly {..<n} R\n\ngoal (9 subgoals):\n 1. ring_closed \\<rat>\n 2. \\<forall>m. MPoly_Type.coeff R m \\<in> \\<rat>\n 3. ring_homomorphism (\\<lambda>a. a)\n 4. finite {..<n}\n 5. vars R \\<subseteq> {..<n}\n 6. ?cinv * ?c = 1\n 7. ?cinv \\<in> \\<rat>\n 8. ?p = Polynomial.smult ?c (\\<Prod>i<n. [:- Root i, 1:])\n 9. \\<forall>i. poly.coeff ?p i \\<in> \\<rat>", "next"], ["proof (state)\ngoal (9 subgoals):\n 1. ring_closed \\<rat>\n 2. \\<forall>m. MPoly_Type.coeff R m \\<in> \\<rat>\n 3. ring_homomorphism (\\<lambda>a. a)\n 4. finite {..<n}\n 5. vars R \\<subseteq> {..<n}\n 6. ?cinv * ?c = 1\n 7. ?cinv \\<in> \\<rat>\n 8. ?p = Polynomial.smult ?c (\\<Prod>i<n. [:- Root i, 1:])\n 9. \\<forall>i. poly.coeff ?p i \\<in> \\<rat>", "show \"vars R \\<subseteq> {..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars R \\<subseteq> {..<n}", "unfolding R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars\n     (\\<Prod>i<n.\n         Const (of_int (l ^ n)) *\n         (\\<Prod>j\\<in>{..<n} - {i}. Var i - Var j))\n    \\<subseteq> {..<n}", "by (intro order.trans[OF vars_prod] UN_least order.trans[OF vars_mult]\n                        Un_least order.trans[OF vars_power] order.trans[OF vars_diff])\n                 (auto simp: vars_Var)"], ["proof (state)\nthis:\n  vars R \\<subseteq> {..<n}\n\ngoal (8 subgoals):\n 1. ring_closed \\<rat>\n 2. \\<forall>m. MPoly_Type.coeff R m \\<in> \\<rat>\n 3. ring_homomorphism (\\<lambda>a. a)\n 4. finite {..<n}\n 5. ?cinv * ?c = 1\n 6. ?cinv \\<in> \\<rat>\n 7. ?p = Polynomial.smult ?c (\\<Prod>i<n. [:- Root i, 1:])\n 8. \\<forall>i. poly.coeff ?p i \\<in> \\<rat>", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. ring_closed \\<rat>\n 2. \\<forall>m. MPoly_Type.coeff R m \\<in> \\<rat>\n 3. ring_homomorphism (\\<lambda>a. a)\n 4. finite {..<n}\n 5. ?cinv * ?c = 1\n 6. ?cinv \\<in> \\<rat>\n 7. ?p = Polynomial.smult ?c (\\<Prod>i<n. [:- Root i, 1:])\n 8. \\<forall>i. poly.coeff ?p i \\<in> \\<rat>", "show \"ring_closed (\\<rat> :: complex set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ring_closed \\<rat>", "by unfold_locales auto"], ["proof (state)\nthis:\n  ring_closed \\<rat>\n\ngoal (7 subgoals):\n 1. \\<forall>m. MPoly_Type.coeff R m \\<in> \\<rat>\n 2. ring_homomorphism (\\<lambda>a. a)\n 3. finite {..<n}\n 4. ?cinv * ?c = 1\n 5. ?cinv \\<in> \\<rat>\n 6. ?p = Polynomial.smult ?c (\\<Prod>i<n. [:- Root i, 1:])\n 7. \\<forall>i. poly.coeff ?p i \\<in> \\<rat>", "then"], ["proof (chain)\npicking this:\n  ring_closed \\<rat>", "interpret ring_closed \"\\<rat> :: complex set\""], ["proof (prove)\nusing this:\n  ring_closed \\<rat>\n\ngoal (1 subgoal):\n 1. ring_closed \\<rat>", "."], ["proof (state)\ngoal (7 subgoals):\n 1. \\<forall>m. MPoly_Type.coeff R m \\<in> \\<rat>\n 2. ring_homomorphism (\\<lambda>a. a)\n 3. finite {..<n}\n 4. ?cinv * ?c = 1\n 5. ?cinv \\<in> \\<rat>\n 6. ?p = Polynomial.smult ?c (\\<Prod>i<n. [:- Root i, 1:])\n 7. \\<forall>i. poly.coeff ?p i \\<in> \\<rat>", "show \"\\<forall>m. MPoly_Type.coeff R m \\<in> \\<rat>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m. MPoly_Type.coeff R m \\<in> \\<rat>", "unfolding R_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m.\n       MPoly_Type.coeff\n        (\\<Prod>i<n.\n            Const (of_int (l ^ n)) *\n            (\\<Prod>j\\<in>{..<n} - {i}. Var i - Var j))\n        m\n       \\<in> \\<rat>", "by (intro allI coeff_prod_closed coeff_mult_closed coeff_power_closed)\n                 (auto simp: mpoly_coeff_Const coeff_Var when_def)"], ["proof (state)\nthis:\n  \\<forall>m. MPoly_Type.coeff R m \\<in> \\<rat>\n\ngoal (6 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<n}\n 3. ?cinv * ?c = 1\n 4. ?cinv \\<in> \\<rat>\n 5. ?p = Polynomial.smult ?c (\\<Prod>i<n. [:- Root i, 1:])\n 6. \\<forall>i. poly.coeff ?p i \\<in> \\<rat>", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<n}\n 3. ?cinv * ?c = 1\n 4. ?cinv \\<in> \\<rat>\n 5. ?p = Polynomial.smult ?c (\\<Prod>i<n. [:- Root i, 1:])\n 6. \\<forall>i. poly.coeff ?p i \\<in> \\<rat>", "let ?lc = \"of_int (\\<Prod>p\\<in>P. Polynomial.lead_coeff p) :: complex\""], ["proof (state)\ngoal (6 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<n}\n 3. ?cinv * ?c = 1\n 4. ?cinv \\<in> \\<rat>\n 5. ?p = Polynomial.smult ?c (\\<Prod>i<n. [:- Root i, 1:])\n 6. \\<forall>i. poly.coeff ?p i \\<in> \\<rat>", "have \"(\\<Prod>q\\<in>P. of_int_poly q) = (\\<Prod>q\\<in>P. Polynomial.smult\n                    (of_int (Polynomial.lead_coeff q)) (\\<Prod>x\\<in>Roots q. [:-x, 1:]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod Ring_Hom_Poly.of_int_poly P =\n    (\\<Prod>q\\<in>P.\n       Polynomial.smult (of_int (Polynomial.lead_coeff q))\n        (\\<Prod>x\\<in>Roots q. [:- x, 1:]))", "by (intro prod.cong of_int_poly_P refl)"], ["proof (state)\nthis:\n  prod Ring_Hom_Poly.of_int_poly P =\n  (\\<Prod>q\\<in>P.\n     Polynomial.smult (of_int (Polynomial.lead_coeff q))\n      (\\<Prod>x\\<in>Roots q. [:- x, 1:]))\n\ngoal (6 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<n}\n 3. ?cinv * ?c = 1\n 4. ?cinv \\<in> \\<rat>\n 5. ?p = Polynomial.smult ?c (\\<Prod>i<n. [:- Root i, 1:])\n 6. \\<forall>i. poly.coeff ?p i \\<in> \\<rat>", "also"], ["proof (state)\nthis:\n  prod Ring_Hom_Poly.of_int_poly P =\n  (\\<Prod>q\\<in>P.\n     Polynomial.smult (of_int (Polynomial.lead_coeff q))\n      (\\<Prod>x\\<in>Roots q. [:- x, 1:]))\n\ngoal (6 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<n}\n 3. ?cinv * ?c = 1\n 4. ?cinv \\<in> \\<rat>\n 5. ?p = Polynomial.smult ?c (\\<Prod>i<n. [:- Root i, 1:])\n 6. \\<forall>i. poly.coeff ?p i \\<in> \\<rat>", "have \"\\<dots> = Polynomial.smult ?lc (\\<Prod>q\\<in>P. \\<Prod>x\\<in>Roots q. [:-x, 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>q\\<in>P.\n       Polynomial.smult (of_int (Polynomial.lead_coeff q))\n        (\\<Prod>x\\<in>Roots q. [:- x, 1:])) =\n    Polynomial.smult (of_int (prod Polynomial.lead_coeff P))\n     (\\<Prod>q\\<in>P. \\<Prod>x\\<in>Roots q. [:- x, 1:])", "by (simp add: prod_smult)"], ["proof (state)\nthis:\n  (\\<Prod>q\\<in>P.\n     Polynomial.smult (of_int (Polynomial.lead_coeff q))\n      (\\<Prod>x\\<in>Roots q. [:- x, 1:])) =\n  Polynomial.smult (of_int (prod Polynomial.lead_coeff P))\n   (\\<Prod>q\\<in>P. \\<Prod>x\\<in>Roots q. [:- x, 1:])\n\ngoal (6 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<n}\n 3. ?cinv * ?c = 1\n 4. ?cinv \\<in> \\<rat>\n 5. ?p = Polynomial.smult ?c (\\<Prod>i<n. [:- Root i, 1:])\n 6. \\<forall>i. poly.coeff ?p i \\<in> \\<rat>", "also"], ["proof (state)\nthis:\n  (\\<Prod>q\\<in>P.\n     Polynomial.smult (of_int (Polynomial.lead_coeff q))\n      (\\<Prod>x\\<in>Roots q. [:- x, 1:])) =\n  Polynomial.smult (of_int (prod Polynomial.lead_coeff P))\n   (\\<Prod>q\\<in>P. \\<Prod>x\\<in>Roots q. [:- x, 1:])\n\ngoal (6 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<n}\n 3. ?cinv * ?c = 1\n 4. ?cinv \\<in> \\<rat>\n 5. ?p = Polynomial.smult ?c (\\<Prod>i<n. [:- Root i, 1:])\n 6. \\<forall>i. poly.coeff ?p i \\<in> \\<rat>", "have \"(\\<Prod>q\\<in>P. \\<Prod>x\\<in>Roots q. [:-x, 1:]) = (\\<Prod>x\\<in>Roots'. [:-x, 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>q\\<in>P. \\<Prod>x\\<in>Roots q. [:- x, 1:]) =\n    (\\<Prod>x\\<in>Roots'. [:- x, 1:])", "unfolding Roots'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>q\\<in>P. \\<Prod>x\\<in>Roots q. [:- x, 1:]) =\n    (\\<Prod>x\\<in>\\<Union> (Roots ` P). [:- x, 1:])", "using disjoint"], ["proof (prove)\nusing this:\n  disjoint_family_on Roots P\n\ngoal (1 subgoal):\n 1. (\\<Prod>q\\<in>P. \\<Prod>x\\<in>Roots q. [:- x, 1:]) =\n    (\\<Prod>x\\<in>\\<Union> (Roots ` P). [:- x, 1:])", "by (intro prod.UNION_disjoint [symmetric]) (auto simp: disjoint_family_on_def)"], ["proof (state)\nthis:\n  (\\<Prod>q\\<in>P. \\<Prod>x\\<in>Roots q. [:- x, 1:]) =\n  (\\<Prod>x\\<in>Roots'. [:- x, 1:])\n\ngoal (6 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<n}\n 3. ?cinv * ?c = 1\n 4. ?cinv \\<in> \\<rat>\n 5. ?p = Polynomial.smult ?c (\\<Prod>i<n. [:- Root i, 1:])\n 6. \\<forall>i. poly.coeff ?p i \\<in> \\<rat>", "also"], ["proof (state)\nthis:\n  (\\<Prod>q\\<in>P. \\<Prod>x\\<in>Roots q. [:- x, 1:]) =\n  (\\<Prod>x\\<in>Roots'. [:- x, 1:])\n\ngoal (6 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<n}\n 3. ?cinv * ?c = 1\n 4. ?cinv \\<in> \\<rat>\n 5. ?p = Polynomial.smult ?c (\\<Prod>i<n. [:- Root i, 1:])\n 6. \\<forall>i. poly.coeff ?p i \\<in> \\<rat>", "have \"\\<dots> = (\\<Prod>i<n. [:- Root i, 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<in>Roots'. [:- x, 1:]) = (\\<Prod>i<n. [:- Root i, 1:])", "by (intro prod.reindex_bij_betw [symmetric] Root_bij)"], ["proof (state)\nthis:\n  (\\<Prod>x\\<in>Roots'. [:- x, 1:]) = (\\<Prod>i<n. [:- Root i, 1:])\n\ngoal (6 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<n}\n 3. ?cinv * ?c = 1\n 4. ?cinv \\<in> \\<rat>\n 5. ?p = Polynomial.smult ?c (\\<Prod>i<n. [:- Root i, 1:])\n 6. \\<forall>i. poly.coeff ?p i \\<in> \\<rat>", "finally"], ["proof (chain)\npicking this:\n  prod Ring_Hom_Poly.of_int_poly P =\n  Polynomial.smult (of_int (prod Polynomial.lead_coeff P))\n   (\\<Prod>i<n. [:- Root i, 1:])", "show \"of_int_poly (\\<Prod>P) = Polynomial.smult ?lc (\\<Prod>i<n. [:- Root i, 1:])\""], ["proof (prove)\nusing this:\n  prod Ring_Hom_Poly.of_int_poly P =\n  Polynomial.smult (of_int (prod Polynomial.lead_coeff P))\n   (\\<Prod>i<n. [:- Root i, 1:])\n\ngoal (1 subgoal):\n 1. Ring_Hom_Poly.of_int_poly (\\<Prod>P) =\n    Polynomial.smult (of_int (prod Polynomial.lead_coeff P))\n     (\\<Prod>i<n. [:- Root i, 1:])", "by (simp add: of_int_poly_hom.hom_prod)"], ["proof (state)\nthis:\n  Ring_Hom_Poly.of_int_poly (\\<Prod>P) =\n  Polynomial.smult (of_int (prod Polynomial.lead_coeff P))\n   (\\<Prod>i<n. [:- Root i, 1:])\n\ngoal (5 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<n}\n 3. ?cinv * of_int (prod Polynomial.lead_coeff P) = 1\n 4. ?cinv \\<in> \\<rat>\n 5. \\<forall>i.\n       poly.coeff (Ring_Hom_Poly.of_int_poly (\\<Prod>P)) i \\<in> \\<rat>", "have \"prod Polynomial.lead_coeff P \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod Polynomial.lead_coeff P \\<noteq> 0", "by (intro prod_nonzeroI) auto"], ["proof (state)\nthis:\n  prod Polynomial.lead_coeff P \\<noteq> 0\n\ngoal (5 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<n}\n 3. ?cinv * of_int (prod Polynomial.lead_coeff P) = 1\n 4. ?cinv \\<in> \\<rat>\n 5. \\<forall>i.\n       poly.coeff (Ring_Hom_Poly.of_int_poly (\\<Prod>P)) i \\<in> \\<rat>", "thus \"inverse ?lc * ?lc = 1\" \"inverse ?lc \\<in> \\<rat>\""], ["proof (prove)\nusing this:\n  prod Polynomial.lead_coeff P \\<noteq> 0\n\ngoal (1 subgoal):\n 1. inverse (of_int (prod Polynomial.lead_coeff P)) *\n    of_int (prod Polynomial.lead_coeff P) =\n    1 &&&\n    inverse (of_int (prod Polynomial.lead_coeff P)) \\<in> \\<rat>", "by (auto simp: field_simps simp flip: of_int_prod)"], ["proof (state)\nthis:\n  inverse (of_int (prod Polynomial.lead_coeff P)) *\n  of_int (prod Polynomial.lead_coeff P) =\n  1\n  inverse (of_int (prod Polynomial.lead_coeff P)) \\<in> \\<rat>\n\ngoal (3 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<n}\n 3. \\<forall>i.\n       poly.coeff (Ring_Hom_Poly.of_int_poly (\\<Prod>P)) i \\<in> \\<rat>", "qed auto"], ["proof (state)\nthis:\n  insertion Root R \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. prod r Roots' \\<in> \\<rat>", "also"], ["proof (state)\nthis:\n  insertion Root R \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. prod r Roots' \\<in> \\<rat>", "have \"insertion Root R = (\\<Prod>i<n. of_int (l^n) * (\\<Prod>j\\<in>{..<n}-{i}. Root i - Root j))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion Root R =\n    (\\<Prod>i<n.\n        of_int (l ^ n) * (\\<Prod>j\\<in>{..<n} - {i}. Root i - Root j))", "by (simp add: R_def insertion_prod insertion_mult insertion_power insertion_diff)"], ["proof (state)\nthis:\n  insertion Root R =\n  (\\<Prod>i<n.\n      of_int (l ^ n) * (\\<Prod>j\\<in>{..<n} - {i}. Root i - Root j))\n\ngoal (1 subgoal):\n 1. prod r Roots' \\<in> \\<rat>", "also"], ["proof (state)\nthis:\n  insertion Root R =\n  (\\<Prod>i<n.\n      of_int (l ^ n) * (\\<Prod>j\\<in>{..<n} - {i}. Root i - Root j))\n\ngoal (1 subgoal):\n 1. prod r Roots' \\<in> \\<rat>", "have \"\\<dots> = (\\<Prod>i<n. of_int (l^n) * (\\<Prod>\\<alpha>'\\<in>Roots'-{Root i}. Root i - \\<alpha>'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i<n.\n        of_int (l ^ n) * (\\<Prod>j\\<in>{..<n} - {i}. Root i - Root j)) =\n    (\\<Prod>i<n. of_int (l ^ n) * prod ((-) (Root i)) (Roots' - {Root i}))", "proof (intro prod.cong, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. {..<n} = {..<n}\n 2. \\<And>x.\n       x \\<in> {..<n} \\<Longrightarrow>\n       of_int (l ^ n) * (\\<Prod>j\\<in>{..<n} - {x}. Root x - Root j) =\n       of_int (l ^ n) * prod ((-) (Root x)) (Roots' - {Root x})", "case (2 i)"], ["proof (state)\nthis:\n  i \\<in> {..<n}\n\ngoal (2 subgoals):\n 1. {..<n} = {..<n}\n 2. \\<And>x.\n       x \\<in> {..<n} \\<Longrightarrow>\n       of_int (l ^ n) * (\\<Prod>j\\<in>{..<n} - {x}. Root x - Root j) =\n       of_int (l ^ n) * prod ((-) (Root x)) (Roots' - {Root x})", "hence \"(\\<Prod>j\\<in>{..<n}-{i}. Root i - Root j) = (\\<Prod>\\<alpha>'\\<in>Roots'-{Root i}. Root i - \\<alpha>')\""], ["proof (prove)\nusing this:\n  i \\<in> {..<n}\n\ngoal (1 subgoal):\n 1. (\\<Prod>j\\<in>{..<n} - {i}. Root i - Root j) =\n    prod ((-) (Root i)) (Roots' - {Root i})", "by (intro prod.reindex_bij_betw bij_betw_Diff Root_bij)\n                 (auto intro: Root_in_Roots' simp: bij_betw_singleton)"], ["proof (state)\nthis:\n  (\\<Prod>j\\<in>{..<n} - {i}. Root i - Root j) =\n  prod ((-) (Root i)) (Roots' - {Root i})\n\ngoal (2 subgoals):\n 1. {..<n} = {..<n}\n 2. \\<And>x.\n       x \\<in> {..<n} \\<Longrightarrow>\n       of_int (l ^ n) * (\\<Prod>j\\<in>{..<n} - {x}. Root x - Root j) =\n       of_int (l ^ n) * prod ((-) (Root x)) (Roots' - {Root x})", "thus ?case"], ["proof (prove)\nusing this:\n  (\\<Prod>j\\<in>{..<n} - {i}. Root i - Root j) =\n  prod ((-) (Root i)) (Roots' - {Root i})\n\ngoal (1 subgoal):\n 1. of_int (l ^ n) * (\\<Prod>j\\<in>{..<n} - {i}. Root i - Root j) =\n    of_int (l ^ n) * prod ((-) (Root i)) (Roots' - {Root i})", "by simp"], ["proof (state)\nthis:\n  of_int (l ^ n) * (\\<Prod>j\\<in>{..<n} - {i}. Root i - Root j) =\n  of_int (l ^ n) * prod ((-) (Root i)) (Roots' - {Root i})\n\ngoal (1 subgoal):\n 1. {..<n} = {..<n}", "qed auto"], ["proof (state)\nthis:\n  (\\<Prod>i<n.\n      of_int (l ^ n) * (\\<Prod>j\\<in>{..<n} - {i}. Root i - Root j)) =\n  (\\<Prod>i<n. of_int (l ^ n) * prod ((-) (Root i)) (Roots' - {Root i}))\n\ngoal (1 subgoal):\n 1. prod r Roots' \\<in> \\<rat>", "also"], ["proof (state)\nthis:\n  (\\<Prod>i<n.\n      of_int (l ^ n) * (\\<Prod>j\\<in>{..<n} - {i}. Root i - Root j)) =\n  (\\<Prod>i<n. of_int (l ^ n) * prod ((-) (Root i)) (Roots' - {Root i}))\n\ngoal (1 subgoal):\n 1. prod r Roots' \\<in> \\<rat>", "have \"\\<dots> = (\\<Prod>\\<alpha>'\\<in>Roots'. r \\<alpha>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i<n. of_int (l ^ n) * prod ((-) (Root i)) (Roots' - {Root i})) =\n    prod r Roots'", "unfolding r_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i<n. of_int (l ^ n) * prod ((-) (Root i)) (Roots' - {Root i})) =\n    (\\<Prod>\\<alpha>'\\<in>Roots'.\n       of_int (l ^ n) * prod ((-) \\<alpha>') (Roots' - {\\<alpha>'}))", "by (intro prod.reindex_bij_betw Root_bij)"], ["proof (state)\nthis:\n  (\\<Prod>i<n. of_int (l ^ n) * prod ((-) (Root i)) (Roots' - {Root i})) =\n  prod r Roots'\n\ngoal (1 subgoal):\n 1. prod r Roots' \\<in> \\<rat>", "finally"], ["proof (chain)\npicking this:\n  prod r Roots' \\<in> \\<rat>", "show \"(\\<Prod>\\<alpha>'\\<in>Roots'. r \\<alpha>') \\<in> \\<rat>\""], ["proof (prove)\nusing this:\n  prod r Roots' \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. prod r Roots' \\<in> \\<rat>", "."], ["proof (state)\nthis:\n  prod r Roots' \\<in> \\<rat>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prod r Roots' \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. of_nat p alg_dvd\n    of_int (\\<beta> q * l ^ (n * p)) * fact (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n       (\\<alpha> - \\<alpha>') ^ p) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  prod r Roots' \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. of_nat p alg_dvd\n    of_int (\\<beta> q * l ^ (n * p)) * fact (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n       (\\<alpha> - \\<alpha>') ^ p) \\<Longrightarrow>\n    False", "have \"algebraic_int (\\<Prod>\\<alpha>'\\<in>Roots'. r \\<alpha>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic_int (prod r Roots')", "by (intro algebraic_int_prod alg_int_r)"], ["proof (state)\nthis:\n  algebraic_int (prod r Roots')\n\ngoal (1 subgoal):\n 1. of_nat p alg_dvd\n    of_int (\\<beta> q * l ^ (n * p)) * fact (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n       (\\<alpha> - \\<alpha>') ^ p) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  prod r Roots' \\<in> \\<rat>\n  algebraic_int (prod r Roots')", "have is_int: \"(\\<Prod>\\<alpha>'\\<in>Roots'. r \\<alpha>') \\<in> \\<int>\""], ["proof (prove)\nusing this:\n  prod r Roots' \\<in> \\<rat>\n  algebraic_int (prod r Roots')\n\ngoal (1 subgoal):\n 1. prod r Roots' \\<in> \\<int>", "using rational_algebraic_int_is_int"], ["proof (prove)\nusing this:\n  prod r Roots' \\<in> \\<rat>\n  algebraic_int (prod r Roots')\n  \\<lbrakk>algebraic_int ?x; ?x \\<in> \\<rat>\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. prod r Roots' \\<in> \\<int>", "by blast"], ["proof (state)\nthis:\n  prod r Roots' \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. of_nat p alg_dvd\n    of_int (\\<beta> q * l ^ (n * p)) * fact (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n       (\\<alpha> - \\<alpha>') ^ p) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  prod r Roots' \\<in> \\<int>", "obtain R' where R': \"(\\<Prod>\\<alpha>'\\<in>Roots'. r \\<alpha>') = of_int R'\""], ["proof (prove)\nusing this:\n  prod r Roots' \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. (\\<And>R'.\n        prod r Roots' = of_int R' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (elim Ints_cases)"], ["proof (state)\nthis:\n  prod r Roots' = of_int R'\n\ngoal (1 subgoal):\n 1. of_nat p alg_dvd\n    of_int (\\<beta> q * l ^ (n * p)) * fact (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n       (\\<alpha> - \\<alpha>') ^ p) \\<Longrightarrow>\n    False", "have \"(\\<Prod>\\<alpha>'\\<in>Roots'. r \\<alpha>') \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod r Roots' \\<noteq> 0", "using \\<open>l > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < l\n\ngoal (1 subgoal):\n 1. prod r Roots' \\<noteq> 0", "by (intro prod_nonzeroI) (auto simp: r_def \\<open>finite Roots'\\<close>)"], ["proof (state)\nthis:\n  prod r Roots' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. of_nat p alg_dvd\n    of_int (\\<beta> q * l ^ (n * p)) * fact (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n       (\\<alpha> - \\<alpha>') ^ p) \\<Longrightarrow>\n    False", "with R'"], ["proof (chain)\npicking this:\n  prod r Roots' = of_int R'\n  prod r Roots' \\<noteq> 0", "have [simp]: \"R' \\<noteq> 0\""], ["proof (prove)\nusing this:\n  prod r Roots' = of_int R'\n  prod r Roots' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. R' \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  R' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. of_nat p alg_dvd\n    of_int (\\<beta> q * l ^ (n * p)) * fact (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n       (\\<alpha> - \\<alpha>') ^ p) \\<Longrightarrow>\n    False", "assume \"of_nat p alg_dvd of_int (\\<beta> q * l^(n*p)) * fact (p-1) * (\\<Prod>\\<alpha>'\\<in>Roots'-{\\<alpha>}. (\\<alpha>-\\<alpha>') ^ p)\""], ["proof (state)\nthis:\n  of_nat p alg_dvd\n  of_int (\\<beta> q * l ^ (n * p)) * fact (p - 1) *\n  (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}. (\\<alpha> - \\<alpha>') ^ p)\n\ngoal (1 subgoal):\n 1. of_nat p alg_dvd\n    of_int (\\<beta> q * l ^ (n * p)) * fact (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n       (\\<alpha> - \\<alpha>') ^ p) \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  of_nat p alg_dvd\n  of_int (\\<beta> q * l ^ (n * p)) * fact (p - 1) *\n  (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}. (\\<alpha> - \\<alpha>') ^ p)\n\ngoal (1 subgoal):\n 1. of_nat p alg_dvd\n    of_int (\\<beta> q * l ^ (n * p)) * fact (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n       (\\<alpha> - \\<alpha>') ^ p) \\<Longrightarrow>\n    False", "have \"\\<dots> = of_int (\\<beta> q) * fact (p-1) * r \\<alpha> ^ p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (\\<beta> q * l ^ (n * p)) * fact (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}. (\\<alpha> - \\<alpha>') ^ p) =\n    of_int (\\<beta> q) * fact (p - 1) * r \\<alpha> ^ p", "by (simp add: r_def mult_ac power_mult_distrib power_mult prod_power_distrib)"], ["proof (state)\nthis:\n  of_int (\\<beta> q * l ^ (n * p)) * fact (p - 1) *\n  (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}. (\\<alpha> - \\<alpha>') ^ p) =\n  of_int (\\<beta> q) * fact (p - 1) * r \\<alpha> ^ p\n\ngoal (1 subgoal):\n 1. of_nat p alg_dvd\n    of_int (\\<beta> q * l ^ (n * p)) * fact (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n       (\\<alpha> - \\<alpha>') ^ p) \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  of_int (\\<beta> q * l ^ (n * p)) * fact (p - 1) *\n  (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}. (\\<alpha> - \\<alpha>') ^ p) =\n  of_int (\\<beta> q) * fact (p - 1) * r \\<alpha> ^ p\n\ngoal (1 subgoal):\n 1. of_nat p alg_dvd\n    of_int (\\<beta> q * l ^ (n * p)) * fact (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n       (\\<alpha> - \\<alpha>') ^ p) \\<Longrightarrow>\n    False", "have \"\\<dots> alg_dvd of_int (\\<beta> q) * fact (p-1) * r \\<alpha> ^ p * (\\<Prod>\\<alpha>'\\<in>Roots'-{\\<alpha>}. r \\<alpha>') ^ p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (\\<beta> q) * fact (p - 1) * r \\<alpha> ^ p alg_dvd\n    of_int (\\<beta> q) * fact (p - 1) * r \\<alpha> ^ p *\n    prod r (Roots' - {\\<alpha>}) ^ p", "by (intro alg_dvd_triv_left algebraic_int_prod alg_int_r algebraic_int_power) auto"], ["proof (state)\nthis:\n  of_int (\\<beta> q) * fact (p - 1) * r \\<alpha> ^ p alg_dvd\n  of_int (\\<beta> q) * fact (p - 1) * r \\<alpha> ^ p *\n  prod r (Roots' - {\\<alpha>}) ^ p\n\ngoal (1 subgoal):\n 1. of_nat p alg_dvd\n    of_int (\\<beta> q * l ^ (n * p)) * fact (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n       (\\<alpha> - \\<alpha>') ^ p) \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  of_int (\\<beta> q) * fact (p - 1) * r \\<alpha> ^ p alg_dvd\n  of_int (\\<beta> q) * fact (p - 1) * r \\<alpha> ^ p *\n  prod r (Roots' - {\\<alpha>}) ^ p\n\ngoal (1 subgoal):\n 1. of_nat p alg_dvd\n    of_int (\\<beta> q * l ^ (n * p)) * fact (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n       (\\<alpha> - \\<alpha>') ^ p) \\<Longrightarrow>\n    False", "have \"\\<dots> = of_int (\\<beta> q) * fact (p-1) * (\\<Prod>\\<alpha>'\\<in>Roots'. r \\<alpha>') ^ p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (\\<beta> q) * fact (p - 1) * r \\<alpha> ^ p *\n    prod r (Roots' - {\\<alpha>}) ^ p =\n    of_int (\\<beta> q) * fact (p - 1) * prod r Roots' ^ p", "using \\<alpha>"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> Roots'\n\ngoal (1 subgoal):\n 1. of_int (\\<beta> q) * fact (p - 1) * r \\<alpha> ^ p *\n    prod r (Roots' - {\\<alpha>}) ^ p =\n    of_int (\\<beta> q) * fact (p - 1) * prod r Roots' ^ p", "by (subst (2) prod.remove[of _ \"\\<alpha>\"]) (auto simp: mult_ac power_mult_distrib)"], ["proof (state)\nthis:\n  of_int (\\<beta> q) * fact (p - 1) * r \\<alpha> ^ p *\n  prod r (Roots' - {\\<alpha>}) ^ p =\n  of_int (\\<beta> q) * fact (p - 1) * prod r Roots' ^ p\n\ngoal (1 subgoal):\n 1. of_nat p alg_dvd\n    of_int (\\<beta> q * l ^ (n * p)) * fact (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n       (\\<alpha> - \\<alpha>') ^ p) \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  of_int (\\<beta> q) * fact (p - 1) * r \\<alpha> ^ p *\n  prod r (Roots' - {\\<alpha>}) ^ p =\n  of_int (\\<beta> q) * fact (p - 1) * prod r Roots' ^ p\n\ngoal (1 subgoal):\n 1. of_nat p alg_dvd\n    of_int (\\<beta> q * l ^ (n * p)) * fact (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n       (\\<alpha> - \\<alpha>') ^ p) \\<Longrightarrow>\n    False", "have \"\\<dots> = of_int (\\<beta> q * fact (p - 1) * R' ^ p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (\\<beta> q) * fact (p - 1) * prod r Roots' ^ p =\n    of_int (\\<beta> q * fact (p - 1) * R' ^ p)", "by (simp add: R')"], ["proof (state)\nthis:\n  of_int (\\<beta> q) * fact (p - 1) * prod r Roots' ^ p =\n  of_int (\\<beta> q * fact (p - 1) * R' ^ p)\n\ngoal (1 subgoal):\n 1. of_nat p alg_dvd\n    of_int (\\<beta> q * l ^ (n * p)) * fact (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n       (\\<alpha> - \\<alpha>') ^ p) \\<Longrightarrow>\n    False", "also"], ["proof (state)\nthis:\n  of_int (\\<beta> q) * fact (p - 1) * prod r Roots' ^ p =\n  of_int (\\<beta> q * fact (p - 1) * R' ^ p)\n\ngoal (1 subgoal):\n 1. of_nat p alg_dvd\n    of_int (\\<beta> q * l ^ (n * p)) * fact (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n       (\\<alpha> - \\<alpha>') ^ p) \\<Longrightarrow>\n    False", "have \"of_nat p = of_int (int p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat p = of_int (int p)", "by simp"], ["proof (state)\nthis:\n  of_nat p = of_int (int p)\n\ngoal (1 subgoal):\n 1. of_nat p alg_dvd\n    of_int (\\<beta> q * l ^ (n * p)) * fact (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n       (\\<alpha> - \\<alpha>') ^ p) \\<Longrightarrow>\n    False", "finally"], ["proof (chain)\npicking this:\n  of_int (int p) alg_dvd of_int (\\<beta> q * fact (p - 1) * R' ^ p)", "have \"int p dvd \\<beta> q * fact (p - 1) * R' ^ p\""], ["proof (prove)\nusing this:\n  of_int (int p) alg_dvd of_int (\\<beta> q * fact (p - 1) * R' ^ p)\n\ngoal (1 subgoal):\n 1. int p dvd \\<beta> q * fact (p - 1) * R' ^ p", "by (subst (asm) alg_dvd_of_int_iff)"], ["proof (state)\nthis:\n  int p dvd \\<beta> q * fact (p - 1) * R' ^ p\n\ngoal (1 subgoal):\n 1. of_nat p alg_dvd\n    of_int (\\<beta> q * l ^ (n * p)) * fact (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n       (\\<alpha> - \\<alpha>') ^ p) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  int p dvd \\<beta> q * fact (p - 1) * R' ^ p\n\ngoal (1 subgoal):\n 1. of_nat p alg_dvd\n    of_int (\\<beta> q * l ^ (n * p)) * fact (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n       (\\<alpha> - \\<alpha>') ^ p) \\<Longrightarrow>\n    False", "have \"prime (int p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime (int p)", "using \\<open>prime p\\<close>"], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. prime (int p)", "by auto"], ["proof (state)\nthis:\n  prime (int p)\n\ngoal (1 subgoal):\n 1. of_nat p alg_dvd\n    of_int (\\<beta> q * l ^ (n * p)) * fact (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n       (\\<alpha> - \\<alpha>') ^ p) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  int p dvd \\<beta> q * fact (p - 1) * R' ^ p\n  prime (int p)", "have \"int p dvd \\<beta> q \\<or> int p dvd fact (p - 1) \\<or> int p dvd R' ^ p\""], ["proof (prove)\nusing this:\n  int p dvd \\<beta> q * fact (p - 1) * R' ^ p\n  prime (int p)\n\ngoal (1 subgoal):\n 1. int p dvd \\<beta> q \\<or> int p dvd fact (p - 1) \\<or> int p dvd R' ^ p", "by (simp add: prime_dvd_mult_iff)"], ["proof (state)\nthis:\n  int p dvd \\<beta> q \\<or> int p dvd fact (p - 1) \\<or> int p dvd R' ^ p\n\ngoal (1 subgoal):\n 1. of_nat p alg_dvd\n    of_int (\\<beta> q * l ^ (n * p)) * fact (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n       (\\<alpha> - \\<alpha>') ^ p) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  int p dvd \\<beta> q \\<or> int p dvd fact (p - 1) \\<or> int p dvd R' ^ p\n\ngoal (1 subgoal):\n 1. of_nat p alg_dvd\n    of_int (\\<beta> q * l ^ (n * p)) * fact (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n       (\\<alpha> - \\<alpha>') ^ p) \\<Longrightarrow>\n    False", "have \"\\<not>int p dvd \\<beta> q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> int p dvd \\<beta> q", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. int p dvd \\<beta> q \\<Longrightarrow> False", "assume \"int p dvd \\<beta> q\""], ["proof (state)\nthis:\n  int p dvd \\<beta> q\n\ngoal (1 subgoal):\n 1. int p dvd \\<beta> q \\<Longrightarrow> False", "hence \"int p \\<le> \\<bar>\\<beta> q\\<bar>\""], ["proof (prove)\nusing this:\n  int p dvd \\<beta> q\n\ngoal (1 subgoal):\n 1. int p \\<le> \\<bar>\\<beta> q\\<bar>", "using \\<beta>_nz[of q] dvd_imp_le_int[of \"\\<beta> q\" \"int p\"] q"], ["proof (prove)\nusing this:\n  int p dvd \\<beta> q\n  q \\<in> P \\<Longrightarrow> \\<beta> q \\<noteq> 0\n  \\<lbrakk>\\<beta> q \\<noteq> 0; int p dvd \\<beta> q\\<rbrakk>\n  \\<Longrightarrow> \\<bar>int p\\<bar> \\<le> \\<bar>\\<beta> q\\<bar>\n  q \\<in> P\n  \\<alpha> \\<in> Roots q\n\ngoal (1 subgoal):\n 1. int p \\<le> \\<bar>\\<beta> q\\<bar>", "by auto"], ["proof (state)\nthis:\n  int p \\<le> \\<bar>\\<beta> q\\<bar>\n\ngoal (1 subgoal):\n 1. int p dvd \\<beta> q \\<Longrightarrow> False", "with p_ineqs(1) q"], ["proof (chain)\npicking this:\n  \\<forall>q\\<in>P. \\<bar>\\<beta> q\\<bar> < int p\n  q \\<in> P\n  \\<alpha> \\<in> Roots q\n  int p \\<le> \\<bar>\\<beta> q\\<bar>", "show False"], ["proof (prove)\nusing this:\n  \\<forall>q\\<in>P. \\<bar>\\<beta> q\\<bar> < int p\n  q \\<in> P\n  \\<alpha> \\<in> Roots q\n  int p \\<le> \\<bar>\\<beta> q\\<bar>\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> int p dvd \\<beta> q\n\ngoal (1 subgoal):\n 1. of_nat p alg_dvd\n    of_int (\\<beta> q * l ^ (n * p)) * fact (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n       (\\<alpha> - \\<alpha>') ^ p) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  \\<not> int p dvd \\<beta> q\n\ngoal (1 subgoal):\n 1. of_nat p alg_dvd\n    of_int (\\<beta> q * l ^ (n * p)) * fact (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n       (\\<alpha> - \\<alpha>') ^ p) \\<Longrightarrow>\n    False", "have \"\\<not>int p dvd fact (p - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> int p dvd fact (p - 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> int p dvd fact (p - 1)", "have \"\\<not>p dvd fact (p - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> p dvd fact (p - 1)", "using \\<open>p > 1\\<close> p"], ["proof (prove)\nusing this:\n  1 < p\n  prime p\n\ngoal (1 subgoal):\n 1. \\<not> p dvd fact (p - 1)", "by (subst prime_dvd_fact_iff) auto"], ["proof (state)\nthis:\n  \\<not> p dvd fact (p - 1)\n\ngoal (1 subgoal):\n 1. \\<not> int p dvd fact (p - 1)", "hence \"\\<not>int p dvd int (fact (p - 1))\""], ["proof (prove)\nusing this:\n  \\<not> p dvd fact (p - 1)\n\ngoal (1 subgoal):\n 1. \\<not> int p dvd int (fact (p - 1))", "by (subst int_dvd_int_iff)"], ["proof (state)\nthis:\n  \\<not> int p dvd int (fact (p - 1))\n\ngoal (1 subgoal):\n 1. \\<not> int p dvd fact (p - 1)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> int p dvd int (fact (p - 1))\n\ngoal (1 subgoal):\n 1. \\<not> int p dvd fact (p - 1)", "unfolding of_nat_fact"], ["proof (prove)\nusing this:\n  \\<not> int p dvd fact (p - 1)\n\ngoal (1 subgoal):\n 1. \\<not> int p dvd fact (p - 1)", "."], ["proof (state)\nthis:\n  \\<not> int p dvd fact (p - 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> int p dvd fact (p - 1)\n\ngoal (1 subgoal):\n 1. of_nat p alg_dvd\n    of_int (\\<beta> q * l ^ (n * p)) * fact (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n       (\\<alpha> - \\<alpha>') ^ p) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  \\<not> int p dvd fact (p - 1)\n\ngoal (1 subgoal):\n 1. of_nat p alg_dvd\n    of_int (\\<beta> q * l ^ (n * p)) * fact (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n       (\\<alpha> - \\<alpha>') ^ p) \\<Longrightarrow>\n    False", "have \"\\<not>int p dvd R' ^ p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> int p dvd R' ^ p", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. int p dvd R' ^ p \\<Longrightarrow> False", "assume \"int p dvd R' ^ p\""], ["proof (state)\nthis:\n  int p dvd R' ^ p\n\ngoal (1 subgoal):\n 1. int p dvd R' ^ p \\<Longrightarrow> False", "hence \"int p dvd R'\""], ["proof (prove)\nusing this:\n  int p dvd R' ^ p\n\ngoal (1 subgoal):\n 1. int p dvd R'", "using \\<open>prime (int p)\\<close> prime_dvd_power"], ["proof (prove)\nusing this:\n  int p dvd R' ^ p\n  prime (int p)\n  \\<lbrakk>prime ?p; ?p dvd ?x ^ ?n\\<rbrakk> \\<Longrightarrow> ?p dvd ?x\n\ngoal (1 subgoal):\n 1. int p dvd R'", "by metis"], ["proof (state)\nthis:\n  int p dvd R'\n\ngoal (1 subgoal):\n 1. int p dvd R' ^ p \\<Longrightarrow> False", "hence \"int p \\<le> \\<bar>R'\\<bar>\""], ["proof (prove)\nusing this:\n  int p dvd R'\n\ngoal (1 subgoal):\n 1. int p \\<le> \\<bar>R'\\<bar>", "using \\<beta>_nz[of q] dvd_imp_le_int[of R' \"int p\"] q"], ["proof (prove)\nusing this:\n  int p dvd R'\n  q \\<in> P \\<Longrightarrow> \\<beta> q \\<noteq> 0\n  \\<lbrakk>R' \\<noteq> 0; int p dvd R'\\<rbrakk>\n  \\<Longrightarrow> \\<bar>int p\\<bar> \\<le> \\<bar>R'\\<bar>\n  q \\<in> P\n  \\<alpha> \\<in> Roots q\n\ngoal (1 subgoal):\n 1. int p \\<le> \\<bar>R'\\<bar>", "by auto"], ["proof (state)\nthis:\n  int p \\<le> \\<bar>R'\\<bar>\n\ngoal (1 subgoal):\n 1. int p dvd R' ^ p \\<Longrightarrow> False", "hence \"real p \\<le> real_of_int \\<bar>R'\\<bar>\""], ["proof (prove)\nusing this:\n  int p \\<le> \\<bar>R'\\<bar>\n\ngoal (1 subgoal):\n 1. real p \\<le> real_of_int \\<bar>R'\\<bar>", "by linarith"], ["proof (state)\nthis:\n  real p \\<le> real_of_int \\<bar>R'\\<bar>\n\ngoal (1 subgoal):\n 1. int p dvd R' ^ p \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  real p \\<le> real_of_int \\<bar>R'\\<bar>\n\ngoal (1 subgoal):\n 1. int p dvd R' ^ p \\<Longrightarrow> False", "have \"\\<dots> = norm (\\<Prod>\\<alpha>\\<in>Roots'. r \\<alpha>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int \\<bar>R'\\<bar> = cmod (prod r Roots')", "unfolding R'"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int \\<bar>R'\\<bar> = cmod (of_int R')", "by simp"], ["proof (state)\nthis:\n  real_of_int \\<bar>R'\\<bar> = cmod (prod r Roots')\n\ngoal (1 subgoal):\n 1. int p dvd R' ^ p \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  real p \\<le> cmod (prod r Roots')", "show False"], ["proof (prove)\nusing this:\n  real p \\<le> cmod (prod r Roots')\n\ngoal (1 subgoal):\n 1. False", "unfolding r_def"], ["proof (prove)\nusing this:\n  real p\n  \\<le> cmod\n         (\\<Prod>\\<alpha>\\<in>Roots'.\n            of_int (l ^ n) * prod ((-) \\<alpha>) (Roots' - {\\<alpha>}))\n\ngoal (1 subgoal):\n 1. False", "using p_ineqs(2)"], ["proof (prove)\nusing this:\n  real p\n  \\<le> cmod\n         (\\<Prod>\\<alpha>\\<in>Roots'.\n            of_int (l ^ n) * prod ((-) \\<alpha>) (Roots' - {\\<alpha>}))\n  cmod\n   (\\<Prod>\\<alpha>\\<in>Roots'.\n      of_int (l ^ n) * prod ((-) \\<alpha>) (Roots' - {\\<alpha>}))\n  < real p\n\ngoal (1 subgoal):\n 1. False", "by linarith"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> int p dvd R' ^ p\n\ngoal (1 subgoal):\n 1. of_nat p alg_dvd\n    of_int (\\<beta> q * l ^ (n * p)) * fact (p - 1) *\n    (\\<Prod>\\<alpha>'\\<in>Roots' - {\\<alpha>}.\n       (\\<alpha> - \\<alpha>') ^ p) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  int p dvd \\<beta> q \\<or> int p dvd fact (p - 1) \\<or> int p dvd R' ^ p\n  \\<not> int p dvd \\<beta> q\n  \\<not> int p dvd fact (p - 1)\n  \\<not> int p dvd R' ^ p", "show False"], ["proof (prove)\nusing this:\n  int p dvd \\<beta> q \\<or> int p dvd fact (p - 1) \\<or> int p dvd R' ^ p\n  \\<not> int p dvd \\<beta> q\n  \\<not> int p dvd fact (p - 1)\n  \\<not> int p dvd R' ^ p\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> of_nat p alg_dvd of_int (\\<beta> q) * h \\<alpha> (p - 1)\n\ngoal (2 subgoals):\n 1. fact (p - 1) alg_dvd J \\<alpha>\n 2. \\<not> of_nat p alg_dvd J \\<alpha>", "have fact_p_dvd: \"fact p alg_dvd h \\<alpha>' j\" if \"\\<alpha>' \\<in> Roots'\" \"\\<alpha>' \\<noteq> \\<alpha> \\<or> j \\<noteq> p - 1\" for \\<alpha>' j"], ["proof (prove)\ngoal (1 subgoal):\n 1. fact p alg_dvd h \\<alpha>' j", "proof (cases \"j \\<ge> p\")"], ["proof (state)\ngoal (2 subgoals):\n 1. p \\<le> j \\<Longrightarrow> fact p alg_dvd h \\<alpha>' j\n 2. \\<not> p \\<le> j \\<Longrightarrow> fact p alg_dvd h \\<alpha>' j", "case False"], ["proof (state)\nthis:\n  \\<not> p \\<le> j\n\ngoal (2 subgoals):\n 1. p \\<le> j \\<Longrightarrow> fact p alg_dvd h \\<alpha>' j\n 2. \\<not> p \\<le> j \\<Longrightarrow> fact p alg_dvd h \\<alpha>' j", "with that"], ["proof (chain)\npicking this:\n  \\<alpha>' \\<in> Roots'\n  \\<alpha>' \\<noteq> \\<alpha> \\<or> j \\<noteq> p - 1\n  \\<not> p \\<le> j", "have j: \"j < (if \\<alpha>' = \\<alpha> then p - 1 else p)\""], ["proof (prove)\nusing this:\n  \\<alpha>' \\<in> Roots'\n  \\<alpha>' \\<noteq> \\<alpha> \\<or> j \\<noteq> p - 1\n  \\<not> p \\<le> j\n\ngoal (1 subgoal):\n 1. j < (if \\<alpha>' = \\<alpha> then p - 1 else p)", "by auto"], ["proof (state)\nthis:\n  j < (if \\<alpha>' = \\<alpha> then p - 1 else p)\n\ngoal (2 subgoals):\n 1. p \\<le> j \\<Longrightarrow> fact p alg_dvd h \\<alpha>' j\n 2. \\<not> p \\<le> j \\<Longrightarrow> fact p alg_dvd h \\<alpha>' j", "have \"h \\<alpha>' j = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<alpha>' j = 0", "unfolding h_def f_poly_altdef[OF \\<alpha>]"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly\n     ((pderiv ^^ j)\n       (Polynomial.smult (of_int (l ^ (n * p)))\n         (\\<Prod>\\<alpha>'\\<in>Roots'.\n            [:- \\<alpha>', 1:] ^\n            (if \\<alpha>' = \\<alpha> then p - 1 else p))))\n     \\<alpha>' =\n    0", "by (intro poly_higher_pderiv_aux1'[OF j] dvd_smult dvd_prodI that) auto"], ["proof (state)\nthis:\n  h \\<alpha>' j = 0\n\ngoal (2 subgoals):\n 1. p \\<le> j \\<Longrightarrow> fact p alg_dvd h \\<alpha>' j\n 2. \\<not> p \\<le> j \\<Longrightarrow> fact p alg_dvd h \\<alpha>' j", "thus ?thesis"], ["proof (prove)\nusing this:\n  h \\<alpha>' j = 0\n\ngoal (1 subgoal):\n 1. fact p alg_dvd h \\<alpha>' j", "by simp"], ["proof (state)\nthis:\n  fact p alg_dvd h \\<alpha>' j\n\ngoal (1 subgoal):\n 1. p \\<le> j \\<Longrightarrow> fact p alg_dvd h \\<alpha>' j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<le> j \\<Longrightarrow> fact p alg_dvd h \\<alpha>' j", "case True"], ["proof (state)\nthis:\n  p \\<le> j\n\ngoal (1 subgoal):\n 1. p \\<le> j \\<Longrightarrow> fact p alg_dvd h \\<alpha>' j", "define e where \"e = (\\<lambda>x. if x = \\<alpha> then p - 1 else p)\""], ["proof (state)\nthis:\n  e = (\\<lambda>x. if x = \\<alpha> then p - 1 else p)\n\ngoal (1 subgoal):\n 1. p \\<le> j \\<Longrightarrow> fact p alg_dvd h \\<alpha>' j", "define Q where \"Q = (\\<Prod>x\\<in>Roots'. [:-x, 1:] ^ e x)\""], ["proof (state)\nthis:\n  Q = (\\<Prod>x\\<in>Roots'. [:- x, 1:] ^ e x)\n\ngoal (1 subgoal):\n 1. p \\<le> j \\<Longrightarrow> fact p alg_dvd h \\<alpha>' j", "define Q' where \"Q' = Polynomial.smult (of_int (l^(n*p+j))) (pcompose Q [:0, 1 / of_int l:])\""], ["proof (state)\nthis:\n  Q' =\n  Polynomial.smult (of_int (l ^ (n * p + j)))\n   (Q \\<circ>\\<^sub>p [:0, 1 / of_int l:])\n\ngoal (1 subgoal):\n 1. p \\<le> j \\<Longrightarrow> fact p alg_dvd h \\<alpha>' j", "have \"poly ((pderiv ^^ j) Q) \\<alpha>' / l ^ j =\n                poly ((pderiv ^^ j) (pcompose Q [:0, 1 / of_int l:])) (l * \\<alpha>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly ((pderiv ^^ j) Q) \\<alpha>' / of_int (l ^ j) =\n    poly ((pderiv ^^ j) (Q \\<circ>\\<^sub>p [:0, 1 / of_int l:]))\n     (of_int l * \\<alpha>')", "using \\<open>l > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < l\n\ngoal (1 subgoal):\n 1. poly ((pderiv ^^ j) Q) \\<alpha>' / of_int (l ^ j) =\n    poly ((pderiv ^^ j) (Q \\<circ>\\<^sub>p [:0, 1 / of_int l:]))\n     (of_int l * \\<alpha>')", "by (simp add: higher_pderiv_pcompose_linear poly_pcompose field_simps)"], ["proof (state)\nthis:\n  poly ((pderiv ^^ j) Q) \\<alpha>' / of_int (l ^ j) =\n  poly ((pderiv ^^ j) (Q \\<circ>\\<^sub>p [:0, 1 / of_int l:]))\n   (of_int l * \\<alpha>')\n\ngoal (1 subgoal):\n 1. p \\<le> j \\<Longrightarrow> fact p alg_dvd h \\<alpha>' j", "have \"sum e Roots' = (n - 1) * p + (p - 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum e Roots' = (n - 1) * p + (p - 1)", "unfolding e_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>Roots'. if x = \\<alpha> then p - 1 else p) =\n    (n - 1) * p + (p - 1)", "using \\<alpha>"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> Roots'\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>Roots'. if x = \\<alpha> then p - 1 else p) =\n    (n - 1) * p + (p - 1)", "by (subst sum.If_eq) (auto simp: card_Diff_subset n_altdef algebra_simps)"], ["proof (state)\nthis:\n  sum e Roots' = (n - 1) * p + (p - 1)\n\ngoal (1 subgoal):\n 1. p \\<le> j \\<Longrightarrow> fact p alg_dvd h \\<alpha>' j", "also"], ["proof (state)\nthis:\n  sum e Roots' = (n - 1) * p + (p - 1)\n\ngoal (1 subgoal):\n 1. p \\<le> j \\<Longrightarrow> fact p alg_dvd h \\<alpha>' j", "have \"\\<dots> = n * p - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (n - 1) * p + (p - 1) = n * p - 1", "using \\<open>n > 0\\<close> \\<open>p > 1\\<close>"], ["proof (prove)\nusing this:\n  0 < n\n  1 < p\n\ngoal (1 subgoal):\n 1. (n - 1) * p + (p - 1) = n * p - 1", "by (cases n) auto"], ["proof (state)\nthis:\n  (n - 1) * p + (p - 1) = n * p - 1\n\ngoal (1 subgoal):\n 1. p \\<le> j \\<Longrightarrow> fact p alg_dvd h \\<alpha>' j", "finally"], ["proof (chain)\npicking this:\n  sum e Roots' = n * p - 1", "have [simp]: \"sum e Roots' = n * p - 1\""], ["proof (prove)\nusing this:\n  sum e Roots' = n * p - 1\n\ngoal (1 subgoal):\n 1. sum e Roots' = n * p - 1", "."], ["proof (state)\nthis:\n  sum e Roots' = n * p - 1\n\ngoal (1 subgoal):\n 1. p \\<le> j \\<Longrightarrow> fact p alg_dvd h \\<alpha>' j", "have \"h \\<alpha>' j = of_int (l^(n*p)) * poly ((pderiv ^^ j) Q) \\<alpha>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h \\<alpha>' j = of_int (l ^ (n * p)) * poly ((pderiv ^^ j) Q) \\<alpha>'", "unfolding h_def f_poly_altdef[OF \\<alpha>] higher_pderiv_smult poly_smult e_def Q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (l ^ (n * p)) *\n    poly\n     ((pderiv ^^ j)\n       (\\<Prod>\\<alpha>'\\<in>Roots'.\n          [:- \\<alpha>', 1:] ^ (if \\<alpha>' = \\<alpha> then p - 1 else p)))\n     \\<alpha>' =\n    of_int (l ^ (n * p)) *\n    poly\n     ((pderiv ^^ j)\n       (\\<Prod>x\\<in>Roots'.\n          [:- x, 1:] ^ (if x = \\<alpha> then p - 1 else p)))\n     \\<alpha>'", ".."], ["proof (state)\nthis:\n  h \\<alpha>' j = of_int (l ^ (n * p)) * poly ((pderiv ^^ j) Q) \\<alpha>'\n\ngoal (1 subgoal):\n 1. p \\<le> j \\<Longrightarrow> fact p alg_dvd h \\<alpha>' j", "also"], ["proof (state)\nthis:\n  h \\<alpha>' j = of_int (l ^ (n * p)) * poly ((pderiv ^^ j) Q) \\<alpha>'\n\ngoal (1 subgoal):\n 1. p \\<le> j \\<Longrightarrow> fact p alg_dvd h \\<alpha>' j", "have \"poly ((pderiv ^^ j) Q) \\<alpha>' =\n                     of_int l ^ j * poly ((pderiv ^^ j) (pcompose Q [:0, 1 / of_int l:])) (l * \\<alpha>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly ((pderiv ^^ j) Q) \\<alpha>' =\n    of_int l ^ j *\n    poly ((pderiv ^^ j) (Q \\<circ>\\<^sub>p [:0, 1 / of_int l:]))\n     (of_int l * \\<alpha>')", "using \\<open>l > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < l\n\ngoal (1 subgoal):\n 1. poly ((pderiv ^^ j) Q) \\<alpha>' =\n    of_int l ^ j *\n    poly ((pderiv ^^ j) (Q \\<circ>\\<^sub>p [:0, 1 / of_int l:]))\n     (of_int l * \\<alpha>')", "by (simp add: higher_pderiv_pcompose_linear poly_pcompose field_simps)"], ["proof (state)\nthis:\n  poly ((pderiv ^^ j) Q) \\<alpha>' =\n  of_int l ^ j *\n  poly ((pderiv ^^ j) (Q \\<circ>\\<^sub>p [:0, 1 / of_int l:]))\n   (of_int l * \\<alpha>')\n\ngoal (1 subgoal):\n 1. p \\<le> j \\<Longrightarrow> fact p alg_dvd h \\<alpha>' j", "also"], ["proof (state)\nthis:\n  poly ((pderiv ^^ j) Q) \\<alpha>' =\n  of_int l ^ j *\n  poly ((pderiv ^^ j) (Q \\<circ>\\<^sub>p [:0, 1 / of_int l:]))\n   (of_int l * \\<alpha>')\n\ngoal (1 subgoal):\n 1. p \\<le> j \\<Longrightarrow> fact p alg_dvd h \\<alpha>' j", "have \"of_int (l ^ (n * p)) * \\<dots> = poly ((pderiv ^^ j) Q') (l * \\<alpha>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (l ^ (n * p)) *\n    (of_int l ^ j *\n     poly ((pderiv ^^ j) (Q \\<circ>\\<^sub>p [:0, 1 / of_int l:]))\n      (of_int l * \\<alpha>')) =\n    poly ((pderiv ^^ j) Q') (of_int l * \\<alpha>')", "by (simp add: Q'_def higher_pderiv_smult power_add)"], ["proof (state)\nthis:\n  of_int (l ^ (n * p)) *\n  (of_int l ^ j *\n   poly ((pderiv ^^ j) (Q \\<circ>\\<^sub>p [:0, 1 / of_int l:]))\n    (of_int l * \\<alpha>')) =\n  poly ((pderiv ^^ j) Q') (of_int l * \\<alpha>')\n\ngoal (1 subgoal):\n 1. p \\<le> j \\<Longrightarrow> fact p alg_dvd h \\<alpha>' j", "also"], ["proof (state)\nthis:\n  of_int (l ^ (n * p)) *\n  (of_int l ^ j *\n   poly ((pderiv ^^ j) (Q \\<circ>\\<^sub>p [:0, 1 / of_int l:]))\n    (of_int l * \\<alpha>')) =\n  poly ((pderiv ^^ j) Q') (of_int l * \\<alpha>')\n\ngoal (1 subgoal):\n 1. p \\<le> j \\<Longrightarrow> fact p alg_dvd h \\<alpha>' j", "have \"fact p alg_dvd \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fact p alg_dvd poly ((pderiv ^^ j) Q') (of_int l * \\<alpha>')", "proof (rule fact_alg_dvd_poly_higher_pderiv)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i. algebraic_int (poly.coeff Q' i)\n 2. algebraic_int (of_int l * \\<alpha>')\n 3. p \\<le> j", "show \"j \\<ge> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<le> j", "by fact"], ["proof (state)\nthis:\n  p \\<le> j\n\ngoal (2 subgoals):\n 1. \\<And>i. algebraic_int (poly.coeff Q' i)\n 2. algebraic_int (of_int l * \\<alpha>')", "show \"algebraic_int (of_int l * \\<alpha>')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic_int (of_int l * \\<alpha>')", "by (rule alg_int) fact"], ["proof (state)\nthis:\n  algebraic_int (of_int l * \\<alpha>')\n\ngoal (1 subgoal):\n 1. \\<And>i. algebraic_int (poly.coeff Q' i)", "interpret alg_int: ring_closed \"{x::complex. algebraic_int x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ring_closed {x. algebraic_int x}", "by standard auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. algebraic_int (poly.coeff Q' i)", "show \"algebraic_int (poly.coeff Q' i)\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic_int (poly.coeff Q' i)", "proof (cases \"i \\<le> Polynomial.degree Q'\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i \\<le> Polynomial.degree Q' \\<Longrightarrow>\n    algebraic_int (poly.coeff Q' i)\n 2. \\<not> i \\<le> Polynomial.degree Q' \\<Longrightarrow>\n    algebraic_int (poly.coeff Q' i)", "case False"], ["proof (state)\nthis:\n  \\<not> i \\<le> Polynomial.degree Q'\n\ngoal (2 subgoals):\n 1. i \\<le> Polynomial.degree Q' \\<Longrightarrow>\n    algebraic_int (poly.coeff Q' i)\n 2. \\<not> i \\<le> Polynomial.degree Q' \\<Longrightarrow>\n    algebraic_int (poly.coeff Q' i)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> i \\<le> Polynomial.degree Q'\n\ngoal (1 subgoal):\n 1. algebraic_int (poly.coeff Q' i)", "by (simp add: coeff_eq_0)"], ["proof (state)\nthis:\n  algebraic_int (poly.coeff Q' i)\n\ngoal (1 subgoal):\n 1. i \\<le> Polynomial.degree Q' \\<Longrightarrow>\n    algebraic_int (poly.coeff Q' i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<le> Polynomial.degree Q' \\<Longrightarrow>\n    algebraic_int (poly.coeff Q' i)", "case True"], ["proof (state)\nthis:\n  i \\<le> Polynomial.degree Q'\n\ngoal (1 subgoal):\n 1. i \\<le> Polynomial.degree Q' \\<Longrightarrow>\n    algebraic_int (poly.coeff Q' i)", "hence \"i \\<le> n * p - 1\""], ["proof (prove)\nusing this:\n  i \\<le> Polynomial.degree Q'\n\ngoal (1 subgoal):\n 1. i \\<le> n * p - 1", "using \\<open>l > 0\\<close>"], ["proof (prove)\nusing this:\n  i \\<le> Polynomial.degree Q'\n  0 < l\n\ngoal (1 subgoal):\n 1. i \\<le> n * p - 1", "by (simp add: Q'_def degree_prod_eq Q_def degree_power_eq)"], ["proof (state)\nthis:\n  i \\<le> n * p - 1\n\ngoal (1 subgoal):\n 1. i \\<le> Polynomial.degree Q' \\<Longrightarrow>\n    algebraic_int (poly.coeff Q' i)", "also"], ["proof (state)\nthis:\n  i \\<le> n * p - 1\n\ngoal (1 subgoal):\n 1. i \\<le> Polynomial.degree Q' \\<Longrightarrow>\n    algebraic_int (poly.coeff Q' i)", "have \"n * p > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n * p", "using \\<open>n > 0\\<close> \\<open>p > 1\\<close>"], ["proof (prove)\nusing this:\n  0 < n\n  1 < p\n\ngoal (1 subgoal):\n 1. 0 < n * p", "by auto"], ["proof (state)\nthis:\n  0 < n * p\n\ngoal (1 subgoal):\n 1. i \\<le> Polynomial.degree Q' \\<Longrightarrow>\n    algebraic_int (poly.coeff Q' i)", "hence \"n * p - 1 < n * p\""], ["proof (prove)\nusing this:\n  0 < n * p\n\ngoal (1 subgoal):\n 1. n * p - 1 < n * p", "by simp"], ["proof (state)\nthis:\n  n * p - 1 < n * p\n\ngoal (1 subgoal):\n 1. i \\<le> Polynomial.degree Q' \\<Longrightarrow>\n    algebraic_int (poly.coeff Q' i)", "finally"], ["proof (chain)\npicking this:\n  i < n * p", "have i: \"i < n * p\""], ["proof (prove)\nusing this:\n  i < n * p\n\ngoal (1 subgoal):\n 1. i < n * p", "."], ["proof (state)\nthis:\n  i < n * p\n\ngoal (1 subgoal):\n 1. i \\<le> Polynomial.degree Q' \\<Longrightarrow>\n    algebraic_int (poly.coeff Q' i)", "have \"poly.coeff Q' i = of_int l ^ (n * p + j) / of_int l ^ i * poly.coeff Q i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly.coeff Q' i = of_int l ^ (n * p + j) / of_int l ^ i * poly.coeff Q i", "by (simp add: Q'_def coeff_pcompose_linear field_simps)"], ["proof (state)\nthis:\n  poly.coeff Q' i = of_int l ^ (n * p + j) / of_int l ^ i * poly.coeff Q i\n\ngoal (1 subgoal):\n 1. i \\<le> Polynomial.degree Q' \\<Longrightarrow>\n    algebraic_int (poly.coeff Q' i)", "also"], ["proof (state)\nthis:\n  poly.coeff Q' i = of_int l ^ (n * p + j) / of_int l ^ i * poly.coeff Q i\n\ngoal (1 subgoal):\n 1. i \\<le> Polynomial.degree Q' \\<Longrightarrow>\n    algebraic_int (poly.coeff Q' i)", "have \"of_int l ^ (n * p + j) = (of_int l ^ (n * p + j - i) :: complex) * of_int l ^ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int l ^ (n * p + j) = of_int l ^ (n * p + j - i) * of_int l ^ i", "unfolding power_add [symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int l ^ (n * p + j) = of_int l ^ (n * p + j - i + i)", "using i"], ["proof (prove)\nusing this:\n  i < n * p\n\ngoal (1 subgoal):\n 1. of_int l ^ (n * p + j) = of_int l ^ (n * p + j - i + i)", "by simp"], ["proof (state)\nthis:\n  of_int l ^ (n * p + j) = of_int l ^ (n * p + j - i) * of_int l ^ i\n\ngoal (1 subgoal):\n 1. i \\<le> Polynomial.degree Q' \\<Longrightarrow>\n    algebraic_int (poly.coeff Q' i)", "hence \"of_int l ^ (n * p + j) / of_int l ^ i = (of_int l ^ (n * p + j - i) :: complex)\""], ["proof (prove)\nusing this:\n  of_int l ^ (n * p + j) = of_int l ^ (n * p + j - i) * of_int l ^ i\n\ngoal (1 subgoal):\n 1. of_int l ^ (n * p + j) / of_int l ^ i = of_int l ^ (n * p + j - i)", "using \\<open>l > 0\\<close>"], ["proof (prove)\nusing this:\n  of_int l ^ (n * p + j) = of_int l ^ (n * p + j - i) * of_int l ^ i\n  0 < l\n\ngoal (1 subgoal):\n 1. of_int l ^ (n * p + j) / of_int l ^ i = of_int l ^ (n * p + j - i)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  of_int l ^ (n * p + j) / of_int l ^ i = of_int l ^ (n * p + j - i)\n\ngoal (1 subgoal):\n 1. i \\<le> Polynomial.degree Q' \\<Longrightarrow>\n    algebraic_int (poly.coeff Q' i)", "also"], ["proof (state)\nthis:\n  of_int l ^ (n * p + j) / of_int l ^ i = of_int l ^ (n * p + j - i)\n\ngoal (1 subgoal):\n 1. i \\<le> Polynomial.degree Q' \\<Longrightarrow>\n    algebraic_int (poly.coeff Q' i)", "have \"\\<dots> * poly.coeff Q i =\n                (\\<Sum>X\\<in>{X. X \\<subseteq> (SIGMA x:Roots'. {..<e x}) \\<and> i = n * p - Suc (card X)}.\n                of_int l ^ (n * p + j - (n * p - Suc (card X))) * ((- 1) ^ card X * prod fst X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int l ^ (n * p + j - i) * poly.coeff Q i =\n    (\\<Sum>X | X \\<subseteq> (SIGMA x:Roots'. {..<e x}) \\<and>\n               i = n * p - Suc (card X).\n       of_int l ^ (n * p + j - (n * p - Suc (card X))) *\n       ((- 1) ^ card X * prod fst X))", "unfolding Q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int l ^ (n * p + j - i) *\n    poly.coeff (\\<Prod>x\\<in>Roots'. [:- x, 1:] ^ e x) i =\n    (\\<Sum>X | X \\<subseteq> (SIGMA x:Roots'. {..<e x}) \\<and>\n               i = n * p - Suc (card X).\n       of_int l ^ (n * p + j - (n * p - Suc (card X))) *\n       ((- 1) ^ card X * prod fst X))", "by (subst coeff_prod_linear_factors) (auto simp: sum_distrib_left)"], ["proof (state)\nthis:\n  of_int l ^ (n * p + j - i) * poly.coeff Q i =\n  (\\<Sum>X | X \\<subseteq> (SIGMA x:Roots'. {..<e x}) \\<and>\n             i = n * p - Suc (card X).\n     of_int l ^ (n * p + j - (n * p - Suc (card X))) *\n     ((- 1) ^ card X * prod fst X))\n\ngoal (1 subgoal):\n 1. i \\<le> Polynomial.degree Q' \\<Longrightarrow>\n    algebraic_int (poly.coeff Q' i)", "also"], ["proof (state)\nthis:\n  of_int l ^ (n * p + j - i) * poly.coeff Q i =\n  (\\<Sum>X | X \\<subseteq> (SIGMA x:Roots'. {..<e x}) \\<and>\n             i = n * p - Suc (card X).\n     of_int l ^ (n * p + j - (n * p - Suc (card X))) *\n     ((- 1) ^ card X * prod fst X))\n\ngoal (1 subgoal):\n 1. i \\<le> Polynomial.degree Q' \\<Longrightarrow>\n    algebraic_int (poly.coeff Q' i)", "have \"algebraic_int \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic_int\n     (\\<Sum>X | X \\<subseteq> (SIGMA x:Roots'. {..<e x}) \\<and>\n                i = n * p - Suc (card X).\n        of_int l ^ (n * p + j - (n * p - Suc (card X))) *\n        ((- 1) ^ card X * prod fst X))", "proof (intro algebraic_int_sum, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {X. X \\<subseteq> (SIGMA x:Roots'. {..<e x}) \\<and>\n                   i = n * p - Suc (card X)} \\<Longrightarrow>\n       algebraic_int\n        (of_int l ^ (n * p + j - (n * p - Suc (card x))) *\n         ((- 1) ^ card x * prod fst x))", "case (1 X)"], ["proof (state)\nthis:\n  X \\<in> {X. X \\<subseteq> (SIGMA x:Roots'. {..<e x}) \\<and>\n              i = n * p - Suc (card X)}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {X. X \\<subseteq> (SIGMA x:Roots'. {..<e x}) \\<and>\n                   i = n * p - Suc (card X)} \\<Longrightarrow>\n       algebraic_int\n        (of_int l ^ (n * p + j - (n * p - Suc (card x))) *\n         ((- 1) ^ card x * prod fst x))", "hence X: \"X \\<subseteq> (SIGMA x:Roots'. {..<e x})\""], ["proof (prove)\nusing this:\n  X \\<in> {X. X \\<subseteq> (SIGMA x:Roots'. {..<e x}) \\<and>\n              i = n * p - Suc (card X)}\n\ngoal (1 subgoal):\n 1. X \\<subseteq> (SIGMA x:Roots'. {..<e x})", "by auto"], ["proof (state)\nthis:\n  X \\<subseteq> (SIGMA x:Roots'. {..<e x})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {X. X \\<subseteq> (SIGMA x:Roots'. {..<e x}) \\<and>\n                   i = n * p - Suc (card X)} \\<Longrightarrow>\n       algebraic_int\n        (of_int l ^ (n * p + j - (n * p - Suc (card x))) *\n         ((- 1) ^ card x * prod fst x))", "have card_eq: \"card (SIGMA x:Roots'. {..<e x}) = n * p - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (SIGMA x:Roots'. {..<e x}) = n * p - 1", "by (subst card_SigmaI) auto"], ["proof (state)\nthis:\n  card (SIGMA x:Roots'. {..<e x}) = n * p - 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {X. X \\<subseteq> (SIGMA x:Roots'. {..<e x}) \\<and>\n                   i = n * p - Suc (card X)} \\<Longrightarrow>\n       algebraic_int\n        (of_int l ^ (n * p + j - (n * p - Suc (card x))) *\n         ((- 1) ^ card x * prod fst x))", "from X"], ["proof (chain)\npicking this:\n  X \\<subseteq> (SIGMA x:Roots'. {..<e x})", "have \"card X \\<le> card (SIGMA x:Roots'. {..<e x})\""], ["proof (prove)\nusing this:\n  X \\<subseteq> (SIGMA x:Roots'. {..<e x})\n\ngoal (1 subgoal):\n 1. card X \\<le> card (SIGMA x:Roots'. {..<e x})", "by (intro card_mono) auto"], ["proof (state)\nthis:\n  card X \\<le> card (SIGMA x:Roots'. {..<e x})\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {X. X \\<subseteq> (SIGMA x:Roots'. {..<e x}) \\<and>\n                   i = n * p - Suc (card X)} \\<Longrightarrow>\n       algebraic_int\n        (of_int l ^ (n * p + j - (n * p - Suc (card x))) *\n         ((- 1) ^ card x * prod fst x))", "hence \"card X \\<le> n * p - 1\""], ["proof (prove)\nusing this:\n  card X \\<le> card (SIGMA x:Roots'. {..<e x})\n\ngoal (1 subgoal):\n 1. card X \\<le> n * p - 1", "using card_eq"], ["proof (prove)\nusing this:\n  card X \\<le> card (SIGMA x:Roots'. {..<e x})\n  card (SIGMA x:Roots'. {..<e x}) = n * p - 1\n\ngoal (1 subgoal):\n 1. card X \\<le> n * p - 1", "by auto"], ["proof (state)\nthis:\n  card X \\<le> n * p - 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {X. X \\<subseteq> (SIGMA x:Roots'. {..<e x}) \\<and>\n                   i = n * p - Suc (card X)} \\<Longrightarrow>\n       algebraic_int\n        (of_int l ^ (n * p + j - (n * p - Suc (card x))) *\n         ((- 1) ^ card x * prod fst x))", "also"], ["proof (state)\nthis:\n  card X \\<le> n * p - 1\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {X. X \\<subseteq> (SIGMA x:Roots'. {..<e x}) \\<and>\n                   i = n * p - Suc (card X)} \\<Longrightarrow>\n       algebraic_int\n        (of_int l ^ (n * p + j - (n * p - Suc (card x))) *\n         ((- 1) ^ card x * prod fst x))", "have \"\\<dots> < n * p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n * p - 1 < n * p", "using  \\<open>n * p > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < n * p\n\ngoal (1 subgoal):\n 1. n * p - 1 < n * p", "by simp"], ["proof (state)\nthis:\n  n * p - 1 < n * p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {X. X \\<subseteq> (SIGMA x:Roots'. {..<e x}) \\<and>\n                   i = n * p - Suc (card X)} \\<Longrightarrow>\n       algebraic_int\n        (of_int l ^ (n * p + j - (n * p - Suc (card x))) *\n         ((- 1) ^ card x * prod fst x))", "finally"], ["proof (chain)\npicking this:\n  card X < n * p", "have card_less: \"card X < n * p\""], ["proof (prove)\nusing this:\n  card X < n * p\n\ngoal (1 subgoal):\n 1. card X < n * p", "."], ["proof (state)\nthis:\n  card X < n * p\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {X. X \\<subseteq> (SIGMA x:Roots'. {..<e x}) \\<and>\n                   i = n * p - Suc (card X)} \\<Longrightarrow>\n       algebraic_int\n        (of_int l ^ (n * p + j - (n * p - Suc (card x))) *\n         ((- 1) ^ card x * prod fst x))", "have \"algebraic_int ((-1) ^ card X * of_int l ^ (j + 1) * (\\<Prod>x\\<in>X. of_int l * fst x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic_int\n     ((- 1) ^ card X * of_int l ^ (j + 1) *\n      (\\<Prod>x\\<in>X. of_int l * fst x))", "using X"], ["proof (prove)\nusing this:\n  X \\<subseteq> (SIGMA x:Roots'. {..<e x})\n\ngoal (1 subgoal):\n 1. algebraic_int\n     ((- 1) ^ card X * of_int l ^ (j + 1) *\n      (\\<Prod>x\\<in>X. of_int l * fst x))", "by (intro algebraic_int_times algebraic_int_prod alg_int) auto"], ["proof (state)\nthis:\n  algebraic_int\n   ((- 1) ^ card X * of_int l ^ (j + 1) *\n    (\\<Prod>x\\<in>X. of_int l * fst x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {X. X \\<subseteq> (SIGMA x:Roots'. {..<e x}) \\<and>\n                   i = n * p - Suc (card X)} \\<Longrightarrow>\n       algebraic_int\n        (of_int l ^ (n * p + j - (n * p - Suc (card x))) *\n         ((- 1) ^ card x * prod fst x))", "thus ?case"], ["proof (prove)\nusing this:\n  algebraic_int\n   ((- 1) ^ card X * of_int l ^ (j + 1) *\n    (\\<Prod>x\\<in>X. of_int l * fst x))\n\ngoal (1 subgoal):\n 1. algebraic_int\n     (of_int l ^ (n * p + j - (n * p - Suc (card X))) *\n      ((- 1) ^ card X * prod fst X))", "using card_less"], ["proof (prove)\nusing this:\n  algebraic_int\n   ((- 1) ^ card X * of_int l ^ (j + 1) *\n    (\\<Prod>x\\<in>X. of_int l * fst x))\n  card X < n * p\n\ngoal (1 subgoal):\n 1. algebraic_int\n     (of_int l ^ (n * p + j - (n * p - Suc (card X))) *\n      ((- 1) ^ card X * prod fst X))", "by (simp add: power_add prod.distrib mult_ac)"], ["proof (state)\nthis:\n  algebraic_int\n   (of_int l ^ (n * p + j - (n * p - Suc (card X))) *\n    ((- 1) ^ card X * prod fst X))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  algebraic_int\n   (\\<Sum>X | X \\<subseteq> (SIGMA x:Roots'. {..<e x}) \\<and>\n              i = n * p - Suc (card X).\n      of_int l ^ (n * p + j - (n * p - Suc (card X))) *\n      ((- 1) ^ card X * prod fst X))\n\ngoal (1 subgoal):\n 1. i \\<le> Polynomial.degree Q' \\<Longrightarrow>\n    algebraic_int (poly.coeff Q' i)", "finally"], ["proof (chain)\npicking this:\n  algebraic_int (poly.coeff Q' i)", "show ?thesis"], ["proof (prove)\nusing this:\n  algebraic_int (poly.coeff Q' i)\n\ngoal (1 subgoal):\n 1. algebraic_int (poly.coeff Q' i)", "."], ["proof (state)\nthis:\n  algebraic_int (poly.coeff Q' i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  algebraic_int (poly.coeff Q' ?i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fact p alg_dvd poly ((pderiv ^^ j) Q') (of_int l * \\<alpha>')\n\ngoal (1 subgoal):\n 1. p \\<le> j \\<Longrightarrow> fact p alg_dvd h \\<alpha>' j", "finally"], ["proof (chain)\npicking this:\n  fact p alg_dvd h \\<alpha>' j", "show ?thesis"], ["proof (prove)\nusing this:\n  fact p alg_dvd h \\<alpha>' j\n\ngoal (1 subgoal):\n 1. fact p alg_dvd h \\<alpha>' j", "."], ["proof (state)\nthis:\n  fact p alg_dvd h \\<alpha>' j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?\\<alpha>' \\<in> Roots';\n   ?\\<alpha>' \\<noteq> \\<alpha> \\<or> ?j \\<noteq> p - 1\\<rbrakk>\n  \\<Longrightarrow> fact p alg_dvd h ?\\<alpha>' ?j\n\ngoal (2 subgoals):\n 1. fact (p - 1) alg_dvd J \\<alpha>\n 2. \\<not> of_nat p alg_dvd J \\<alpha>", "have p_dvd: \"of_nat p alg_dvd h \\<alpha>' j\" if \"\\<alpha>' \\<in> Roots'\" \"\\<alpha>' \\<noteq> \\<alpha> \\<or> j \\<noteq> p - 1\" for \\<alpha>' j"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat p alg_dvd h \\<alpha>' j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. of_nat p alg_dvd h \\<alpha>' j", "have \"of_nat p alg_dvd (of_nat (fact p) :: complex)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat p alg_dvd of_nat (fact p)", "by (intro alg_dvd_of_nat dvd_fact) (use \\<open>p > 1\\<close> in auto)"], ["proof (state)\nthis:\n  of_nat p alg_dvd of_nat (fact p)\n\ngoal (1 subgoal):\n 1. of_nat p alg_dvd h \\<alpha>' j", "hence \"of_nat p alg_dvd (fact p :: complex)\""], ["proof (prove)\nusing this:\n  of_nat p alg_dvd of_nat (fact p)\n\ngoal (1 subgoal):\n 1. of_nat p alg_dvd fact p", "by simp"], ["proof (state)\nthis:\n  of_nat p alg_dvd fact p\n\ngoal (1 subgoal):\n 1. of_nat p alg_dvd h \\<alpha>' j", "also"], ["proof (state)\nthis:\n  of_nat p alg_dvd fact p\n\ngoal (1 subgoal):\n 1. of_nat p alg_dvd h \\<alpha>' j", "have \"\\<dots> alg_dvd h \\<alpha>' j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fact p alg_dvd h \\<alpha>' j", "using that"], ["proof (prove)\nusing this:\n  \\<alpha>' \\<in> Roots'\n  \\<alpha>' \\<noteq> \\<alpha> \\<or> j \\<noteq> p - 1\n\ngoal (1 subgoal):\n 1. fact p alg_dvd h \\<alpha>' j", "by (intro fact_p_dvd)"], ["proof (state)\nthis:\n  fact p alg_dvd h \\<alpha>' j\n\ngoal (1 subgoal):\n 1. of_nat p alg_dvd h \\<alpha>' j", "finally"], ["proof (chain)\npicking this:\n  of_nat p alg_dvd h \\<alpha>' j", "show ?thesis"], ["proof (prove)\nusing this:\n  of_nat p alg_dvd h \\<alpha>' j\n\ngoal (1 subgoal):\n 1. of_nat p alg_dvd h \\<alpha>' j", "."], ["proof (state)\nthis:\n  of_nat p alg_dvd h \\<alpha>' j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?\\<alpha>' \\<in> Roots';\n   ?\\<alpha>' \\<noteq> \\<alpha> \\<or> ?j \\<noteq> p - 1\\<rbrakk>\n  \\<Longrightarrow> of_nat p alg_dvd h ?\\<alpha>' ?j\n\ngoal (2 subgoals):\n 1. fact (p - 1) alg_dvd J \\<alpha>\n 2. \\<not> of_nat p alg_dvd J \\<alpha>", "show \"fact (p - 1) alg_dvd J \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fact (p - 1) alg_dvd J \\<alpha>", "unfolding J_eq'"], ["proof (prove)\ngoal (1 subgoal):\n 1. fact (p - 1) alg_dvd\n    - (\\<Sum>((q, \\<alpha>'), i)\\<in>Sigma P Roots \\<times> {..<n * p}.\n         of_int (\\<beta> q) * h \\<alpha>' i)", "proof (intro alg_dvd_uminus_right alg_dvd_sum, safe intro!: alg_dvd_mult algebraic_int_of_int)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<lbrakk>ba < n * p; a \\<in> P; b \\<in> Roots a\\<rbrakk>\n       \\<Longrightarrow> fact (p - 1) alg_dvd h b ba", "fix q \\<alpha>' j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<lbrakk>ba < n * p; a \\<in> P; b \\<in> Roots a\\<rbrakk>\n       \\<Longrightarrow> fact (p - 1) alg_dvd h b ba", "assume \"q \\<in> P\" \"\\<alpha>' \\<in> Roots q\" \"j < n * p\""], ["proof (state)\nthis:\n  q \\<in> P\n  \\<alpha>' \\<in> Roots q\n  j < n * p\n\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<lbrakk>ba < n * p; a \\<in> P; b \\<in> Roots a\\<rbrakk>\n       \\<Longrightarrow> fact (p - 1) alg_dvd h b ba", "hence \"\\<alpha>' \\<in> Roots'\""], ["proof (prove)\nusing this:\n  q \\<in> P\n  \\<alpha>' \\<in> Roots q\n  j < n * p\n\ngoal (1 subgoal):\n 1. \\<alpha>' \\<in> Roots'", "by (auto simp: Roots'_def)"], ["proof (state)\nthis:\n  \\<alpha>' \\<in> Roots'\n\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<lbrakk>ba < n * p; a \\<in> P; b \\<in> Roots a\\<rbrakk>\n       \\<Longrightarrow> fact (p - 1) alg_dvd h b ba", "show \"fact (p - 1) alg_dvd h \\<alpha>' j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fact (p - 1) alg_dvd h \\<alpha>' j", "proof (cases \"\\<alpha>' = \\<alpha> \\<and> j = p - 1\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<alpha>' = \\<alpha> \\<and> j = p - 1 \\<Longrightarrow>\n    fact (p - 1) alg_dvd h \\<alpha>' j\n 2. \\<not> (\\<alpha>' = \\<alpha> \\<and> j = p - 1) \\<Longrightarrow>\n    fact (p - 1) alg_dvd h \\<alpha>' j", "case True"], ["proof (state)\nthis:\n  \\<alpha>' = \\<alpha> \\<and> j = p - 1\n\ngoal (2 subgoals):\n 1. \\<alpha>' = \\<alpha> \\<and> j = p - 1 \\<Longrightarrow>\n    fact (p - 1) alg_dvd h \\<alpha>' j\n 2. \\<not> (\\<alpha>' = \\<alpha> \\<and> j = p - 1) \\<Longrightarrow>\n    fact (p - 1) alg_dvd h \\<alpha>' j", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<alpha>' = \\<alpha> \\<and> j = p - 1\n\ngoal (1 subgoal):\n 1. fact (p - 1) alg_dvd h \\<alpha>' j", "using \\<open>fact (p - 1) alg_dvd h \\<alpha> (p - 1)\\<close>"], ["proof (prove)\nusing this:\n  \\<alpha>' = \\<alpha> \\<and> j = p - 1\n  fact (p - 1) alg_dvd h \\<alpha> (p - 1)\n\ngoal (1 subgoal):\n 1. fact (p - 1) alg_dvd h \\<alpha>' j", "by simp"], ["proof (state)\nthis:\n  fact (p - 1) alg_dvd h \\<alpha>' j\n\ngoal (1 subgoal):\n 1. \\<not> (\\<alpha>' = \\<alpha> \\<and> j = p - 1) \\<Longrightarrow>\n    fact (p - 1) alg_dvd h \\<alpha>' j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<alpha>' = \\<alpha> \\<and> j = p - 1) \\<Longrightarrow>\n    fact (p - 1) alg_dvd h \\<alpha>' j", "case False"], ["proof (state)\nthis:\n  \\<not> (\\<alpha>' = \\<alpha> \\<and> j = p - 1)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<alpha>' = \\<alpha> \\<and> j = p - 1) \\<Longrightarrow>\n    fact (p - 1) alg_dvd h \\<alpha>' j", "have \"of_int (fact (p - 1)) alg_dvd (of_int (fact p) :: complex)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (fact (p - 1)) alg_dvd of_int (fact p)", "by (intro alg_dvd_of_int fact_dvd) auto"], ["proof (state)\nthis:\n  of_int (fact (p - 1)) alg_dvd of_int (fact p)\n\ngoal (1 subgoal):\n 1. \\<not> (\\<alpha>' = \\<alpha> \\<and> j = p - 1) \\<Longrightarrow>\n    fact (p - 1) alg_dvd h \\<alpha>' j", "hence \"fact (p - 1) alg_dvd (fact p :: complex)\""], ["proof (prove)\nusing this:\n  of_int (fact (p - 1)) alg_dvd of_int (fact p)\n\ngoal (1 subgoal):\n 1. fact (p - 1) alg_dvd fact p", "by simp"], ["proof (state)\nthis:\n  fact (p - 1) alg_dvd fact p\n\ngoal (1 subgoal):\n 1. \\<not> (\\<alpha>' = \\<alpha> \\<and> j = p - 1) \\<Longrightarrow>\n    fact (p - 1) alg_dvd h \\<alpha>' j", "also"], ["proof (state)\nthis:\n  fact (p - 1) alg_dvd fact p\n\ngoal (1 subgoal):\n 1. \\<not> (\\<alpha>' = \\<alpha> \\<and> j = p - 1) \\<Longrightarrow>\n    fact (p - 1) alg_dvd h \\<alpha>' j", "have \"\\<dots> alg_dvd h \\<alpha>' j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fact p alg_dvd h \\<alpha>' j", "using False \\<open>\\<alpha>' \\<in> Roots'\\<close>"], ["proof (prove)\nusing this:\n  \\<not> (\\<alpha>' = \\<alpha> \\<and> j = p - 1)\n  \\<alpha>' \\<in> Roots'\n\ngoal (1 subgoal):\n 1. fact p alg_dvd h \\<alpha>' j", "by (intro fact_p_dvd) auto"], ["proof (state)\nthis:\n  fact p alg_dvd h \\<alpha>' j\n\ngoal (1 subgoal):\n 1. \\<not> (\\<alpha>' = \\<alpha> \\<and> j = p - 1) \\<Longrightarrow>\n    fact (p - 1) alg_dvd h \\<alpha>' j", "finally"], ["proof (chain)\npicking this:\n  fact (p - 1) alg_dvd h \\<alpha>' j", "show ?thesis"], ["proof (prove)\nusing this:\n  fact (p - 1) alg_dvd h \\<alpha>' j\n\ngoal (1 subgoal):\n 1. fact (p - 1) alg_dvd h \\<alpha>' j", "."], ["proof (state)\nthis:\n  fact (p - 1) alg_dvd h \\<alpha>' j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fact (p - 1) alg_dvd h \\<alpha>' j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fact (p - 1) alg_dvd J \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<not> of_nat p alg_dvd J \\<alpha>", "show \"\\<not>of_nat p alg_dvd J \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> of_nat p alg_dvd J \\<alpha>", "unfolding J_eq' alg_dvd_uminus_right_iff"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> of_nat p alg_dvd\n           (\\<Sum>((q, \\<alpha>'), i)\\<in>Sigma P Roots \\<times> {..<n * p}.\n              of_int (\\<beta> q) * h \\<alpha>' i)", "proof (rule not_alg_dvd_sum)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x.\n       x \\<in> Sigma P Roots \\<times> {..<n * p} - {?x'} \\<Longrightarrow>\n       of_nat p alg_dvd\n       (case x of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (q, \\<alpha>') \\<Rightarrow>\n             \\<lambda>i. of_int (\\<beta> q) * h \\<alpha>' i)\n           xa)\n 2. \\<not> of_nat p alg_dvd\n           (case ?x' of\n            (x, xa) \\<Rightarrow>\n              (case x of\n               (q, \\<alpha>') \\<Rightarrow>\n                 \\<lambda>i. of_int (\\<beta> q) * h \\<alpha>' i)\n               xa)\n 3. ?x' \\<in> Sigma P Roots \\<times> {..<n * p}\n 4. finite (Sigma P Roots \\<times> {..<n * p})", "have \"p - 1 < 1 * p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p - 1 < 1 * p", "using \\<open>p > 1\\<close>"], ["proof (prove)\nusing this:\n  1 < p\n\ngoal (1 subgoal):\n 1. p - 1 < 1 * p", "by simp"], ["proof (state)\nthis:\n  p - 1 < 1 * p\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       x \\<in> Sigma P Roots \\<times> {..<n * p} - {?x'} \\<Longrightarrow>\n       of_nat p alg_dvd\n       (case x of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (q, \\<alpha>') \\<Rightarrow>\n             \\<lambda>i. of_int (\\<beta> q) * h \\<alpha>' i)\n           xa)\n 2. \\<not> of_nat p alg_dvd\n           (case ?x' of\n            (x, xa) \\<Rightarrow>\n              (case x of\n               (q, \\<alpha>') \\<Rightarrow>\n                 \\<lambda>i. of_int (\\<beta> q) * h \\<alpha>' i)\n               xa)\n 3. ?x' \\<in> Sigma P Roots \\<times> {..<n * p}\n 4. finite (Sigma P Roots \\<times> {..<n * p})", "also"], ["proof (state)\nthis:\n  p - 1 < 1 * p\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       x \\<in> Sigma P Roots \\<times> {..<n * p} - {?x'} \\<Longrightarrow>\n       of_nat p alg_dvd\n       (case x of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (q, \\<alpha>') \\<Rightarrow>\n             \\<lambda>i. of_int (\\<beta> q) * h \\<alpha>' i)\n           xa)\n 2. \\<not> of_nat p alg_dvd\n           (case ?x' of\n            (x, xa) \\<Rightarrow>\n              (case x of\n               (q, \\<alpha>') \\<Rightarrow>\n                 \\<lambda>i. of_int (\\<beta> q) * h \\<alpha>' i)\n               xa)\n 3. ?x' \\<in> Sigma P Roots \\<times> {..<n * p}\n 4. finite (Sigma P Roots \\<times> {..<n * p})", "have \"1 * p \\<le> n * p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 * p \\<le> n * p", "using \\<open>n > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. 1 * p \\<le> n * p", "by (intro mult_right_mono) auto"], ["proof (state)\nthis:\n  1 * p \\<le> n * p\n\ngoal (4 subgoals):\n 1. \\<And>x.\n       x \\<in> Sigma P Roots \\<times> {..<n * p} - {?x'} \\<Longrightarrow>\n       of_nat p alg_dvd\n       (case x of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (q, \\<alpha>') \\<Rightarrow>\n             \\<lambda>i. of_int (\\<beta> q) * h \\<alpha>' i)\n           xa)\n 2. \\<not> of_nat p alg_dvd\n           (case ?x' of\n            (x, xa) \\<Rightarrow>\n              (case x of\n               (q, \\<alpha>') \\<Rightarrow>\n                 \\<lambda>i. of_int (\\<beta> q) * h \\<alpha>' i)\n               xa)\n 3. ?x' \\<in> Sigma P Roots \\<times> {..<n * p}\n 4. finite (Sigma P Roots \\<times> {..<n * p})", "finally"], ["proof (chain)\npicking this:\n  p - 1 < n * p", "show \"((q, \\<alpha>), p - 1) \\<in> Sigma P Roots \\<times> {..<n*p}\""], ["proof (prove)\nusing this:\n  p - 1 < n * p\n\ngoal (1 subgoal):\n 1. ((q, \\<alpha>), p - 1) \\<in> Sigma P Roots \\<times> {..<n * p}", "using q \\<open>n > 0\\<close>"], ["proof (prove)\nusing this:\n  p - 1 < n * p\n  q \\<in> P\n  \\<alpha> \\<in> Roots q\n  0 < n\n\ngoal (1 subgoal):\n 1. ((q, \\<alpha>), p - 1) \\<in> Sigma P Roots \\<times> {..<n * p}", "by auto"], ["proof (state)\nthis:\n  ((q, \\<alpha>), p - 1) \\<in> Sigma P Roots \\<times> {..<n * p}\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> Sigma P Roots \\<times> {..<n * p} -\n               {((q, \\<alpha>), p - 1)} \\<Longrightarrow>\n       of_nat p alg_dvd\n       (case x of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (q, \\<alpha>') \\<Rightarrow>\n             \\<lambda>i. of_int (\\<beta> q) * h \\<alpha>' i)\n           xa)\n 2. \\<not> of_nat p alg_dvd\n           (case ((q, \\<alpha>), p - 1) of\n            (x, xa) \\<Rightarrow>\n              (case x of\n               (q, \\<alpha>') \\<Rightarrow>\n                 \\<lambda>i. of_int (\\<beta> q) * h \\<alpha>' i)\n               xa)\n 3. finite (Sigma P Roots \\<times> {..<n * p})", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> Sigma P Roots \\<times> {..<n * p} -\n               {((q, \\<alpha>), p - 1)} \\<Longrightarrow>\n       of_nat p alg_dvd\n       (case x of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (q, \\<alpha>') \\<Rightarrow>\n             \\<lambda>i. of_int (\\<beta> q) * h \\<alpha>' i)\n           xa)\n 2. \\<not> of_nat p alg_dvd\n           (case ((q, \\<alpha>), p - 1) of\n            (x, xa) \\<Rightarrow>\n              (case x of\n               (q, \\<alpha>') \\<Rightarrow>\n                 \\<lambda>i. of_int (\\<beta> q) * h \\<alpha>' i)\n               xa)\n 3. finite (Sigma P Roots \\<times> {..<n * p})", "fix z"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> Sigma P Roots \\<times> {..<n * p} -\n               {((q, \\<alpha>), p - 1)} \\<Longrightarrow>\n       of_nat p alg_dvd\n       (case x of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (q, \\<alpha>') \\<Rightarrow>\n             \\<lambda>i. of_int (\\<beta> q) * h \\<alpha>' i)\n           xa)\n 2. \\<not> of_nat p alg_dvd\n           (case ((q, \\<alpha>), p - 1) of\n            (x, xa) \\<Rightarrow>\n              (case x of\n               (q, \\<alpha>') \\<Rightarrow>\n                 \\<lambda>i. of_int (\\<beta> q) * h \\<alpha>' i)\n               xa)\n 3. finite (Sigma P Roots \\<times> {..<n * p})", "assume z: \"z \\<in> Sigma P Roots \\<times> {..<n*p}-{((q,\\<alpha>),p-1)}\""], ["proof (state)\nthis:\n  z \\<in> Sigma P Roots \\<times> {..<n * p} - {((q, \\<alpha>), p - 1)}\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> Sigma P Roots \\<times> {..<n * p} -\n               {((q, \\<alpha>), p - 1)} \\<Longrightarrow>\n       of_nat p alg_dvd\n       (case x of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (q, \\<alpha>') \\<Rightarrow>\n             \\<lambda>i. of_int (\\<beta> q) * h \\<alpha>' i)\n           xa)\n 2. \\<not> of_nat p alg_dvd\n           (case ((q, \\<alpha>), p - 1) of\n            (x, xa) \\<Rightarrow>\n              (case x of\n               (q, \\<alpha>') \\<Rightarrow>\n                 \\<lambda>i. of_int (\\<beta> q) * h \\<alpha>' i)\n               xa)\n 3. finite (Sigma P Roots \\<times> {..<n * p})", "from z"], ["proof (chain)\npicking this:\n  z \\<in> Sigma P Roots \\<times> {..<n * p} - {((q, \\<alpha>), p - 1)}", "have \"snd (fst z) \\<in> Roots'\""], ["proof (prove)\nusing this:\n  z \\<in> Sigma P Roots \\<times> {..<n * p} - {((q, \\<alpha>), p - 1)}\n\ngoal (1 subgoal):\n 1. snd (fst z) \\<in> Roots'", "by (auto simp: Roots'_def)"], ["proof (state)\nthis:\n  snd (fst z) \\<in> Roots'\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> Sigma P Roots \\<times> {..<n * p} -\n               {((q, \\<alpha>), p - 1)} \\<Longrightarrow>\n       of_nat p alg_dvd\n       (case x of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (q, \\<alpha>') \\<Rightarrow>\n             \\<lambda>i. of_int (\\<beta> q) * h \\<alpha>' i)\n           xa)\n 2. \\<not> of_nat p alg_dvd\n           (case ((q, \\<alpha>), p - 1) of\n            (x, xa) \\<Rightarrow>\n              (case x of\n               (q, \\<alpha>') \\<Rightarrow>\n                 \\<lambda>i. of_int (\\<beta> q) * h \\<alpha>' i)\n               xa)\n 3. finite (Sigma P Roots \\<times> {..<n * p})", "moreover"], ["proof (state)\nthis:\n  snd (fst z) \\<in> Roots'\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> Sigma P Roots \\<times> {..<n * p} -\n               {((q, \\<alpha>), p - 1)} \\<Longrightarrow>\n       of_nat p alg_dvd\n       (case x of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (q, \\<alpha>') \\<Rightarrow>\n             \\<lambda>i. of_int (\\<beta> q) * h \\<alpha>' i)\n           xa)\n 2. \\<not> of_nat p alg_dvd\n           (case ((q, \\<alpha>), p - 1) of\n            (x, xa) \\<Rightarrow>\n              (case x of\n               (q, \\<alpha>') \\<Rightarrow>\n                 \\<lambda>i. of_int (\\<beta> q) * h \\<alpha>' i)\n               xa)\n 3. finite (Sigma P Roots \\<times> {..<n * p})", "have \"fst (fst z) = q\" if \"\\<alpha> \\<in> Roots (fst (fst z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (fst z) = q", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fst (fst z) = q", "have \"\\<alpha> \\<in> Roots (fst (fst z)) \\<inter> Roots q\" \"q \\<in> P\" \"fst (fst z) \\<in> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha> \\<in> Roots (fst (fst z)) \\<inter> Roots q &&&\n    q \\<in> P &&& fst (fst z) \\<in> P", "using that q z"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> Roots (fst (fst z))\n  q \\<in> P\n  \\<alpha> \\<in> Roots q\n  z \\<in> Sigma P Roots \\<times> {..<n * p} - {((q, \\<alpha>), p - 1)}\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<in> Roots (fst (fst z)) \\<inter> Roots q &&&\n    q \\<in> P &&& fst (fst z) \\<in> P", "by auto"], ["proof (state)\nthis:\n  \\<alpha> \\<in> Roots (fst (fst z)) \\<inter> Roots q\n  q \\<in> P\n  fst (fst z) \\<in> P\n\ngoal (1 subgoal):\n 1. fst (fst z) = q", "with disjoint"], ["proof (chain)\npicking this:\n  disjoint_family_on Roots P\n  \\<alpha> \\<in> Roots (fst (fst z)) \\<inter> Roots q\n  q \\<in> P\n  fst (fst z) \\<in> P", "show ?thesis"], ["proof (prove)\nusing this:\n  disjoint_family_on Roots P\n  \\<alpha> \\<in> Roots (fst (fst z)) \\<inter> Roots q\n  q \\<in> P\n  fst (fst z) \\<in> P\n\ngoal (1 subgoal):\n 1. fst (fst z) = q", "unfolding disjoint_family_on_def"], ["proof (prove)\nusing this:\n  \\<forall>m\\<in>P.\n     \\<forall>n\\<in>P.\n        m \\<noteq> n \\<longrightarrow> Roots m \\<inter> Roots n = {}\n  \\<alpha> \\<in> Roots (fst (fst z)) \\<inter> Roots q\n  q \\<in> P\n  fst (fst z) \\<in> P\n\ngoal (1 subgoal):\n 1. fst (fst z) = q", "by blast"], ["proof (state)\nthis:\n  fst (fst z) = q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<alpha> \\<in> Roots (fst (fst z)) \\<Longrightarrow> fst (fst z) = q\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> Sigma P Roots \\<times> {..<n * p} -\n               {((q, \\<alpha>), p - 1)} \\<Longrightarrow>\n       of_nat p alg_dvd\n       (case x of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (q, \\<alpha>') \\<Rightarrow>\n             \\<lambda>i. of_int (\\<beta> q) * h \\<alpha>' i)\n           xa)\n 2. \\<not> of_nat p alg_dvd\n           (case ((q, \\<alpha>), p - 1) of\n            (x, xa) \\<Rightarrow>\n              (case x of\n               (q, \\<alpha>') \\<Rightarrow>\n                 \\<lambda>i. of_int (\\<beta> q) * h \\<alpha>' i)\n               xa)\n 3. finite (Sigma P Roots \\<times> {..<n * p})", "ultimately"], ["proof (chain)\npicking this:\n  snd (fst z) \\<in> Roots'\n  \\<alpha> \\<in> Roots (fst (fst z)) \\<Longrightarrow> fst (fst z) = q", "have \"of_nat p alg_dvd h (snd (fst z)) (snd z)\""], ["proof (prove)\nusing this:\n  snd (fst z) \\<in> Roots'\n  \\<alpha> \\<in> Roots (fst (fst z)) \\<Longrightarrow> fst (fst z) = q\n\ngoal (1 subgoal):\n 1. of_nat p alg_dvd h (snd (fst z)) (snd z)", "using z"], ["proof (prove)\nusing this:\n  snd (fst z) \\<in> Roots'\n  \\<alpha> \\<in> Roots (fst (fst z)) \\<Longrightarrow> fst (fst z) = q\n  z \\<in> Sigma P Roots \\<times> {..<n * p} - {((q, \\<alpha>), p - 1)}\n\ngoal (1 subgoal):\n 1. of_nat p alg_dvd h (snd (fst z)) (snd z)", "by (intro p_dvd) auto"], ["proof (state)\nthis:\n  of_nat p alg_dvd h (snd (fst z)) (snd z)\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> Sigma P Roots \\<times> {..<n * p} -\n               {((q, \\<alpha>), p - 1)} \\<Longrightarrow>\n       of_nat p alg_dvd\n       (case x of\n        (x, xa) \\<Rightarrow>\n          (case x of\n           (q, \\<alpha>') \\<Rightarrow>\n             \\<lambda>i. of_int (\\<beta> q) * h \\<alpha>' i)\n           xa)\n 2. \\<not> of_nat p alg_dvd\n           (case ((q, \\<alpha>), p - 1) of\n            (x, xa) \\<Rightarrow>\n              (case x of\n               (q, \\<alpha>') \\<Rightarrow>\n                 \\<lambda>i. of_int (\\<beta> q) * h \\<alpha>' i)\n               xa)\n 3. finite (Sigma P Roots \\<times> {..<n * p})", "thus  \"of_nat p alg_dvd (case z of (x, xa) \\<Rightarrow> (case x of (q, \\<alpha>') \\<Rightarrow> \\<lambda>i. of_int (\\<beta> q) * h \\<alpha>' i) xa)\""], ["proof (prove)\nusing this:\n  of_nat p alg_dvd h (snd (fst z)) (snd z)\n\ngoal (1 subgoal):\n 1. of_nat p alg_dvd\n    (case z of\n     (x, xa) \\<Rightarrow>\n       (case x of\n        (q, \\<alpha>') \\<Rightarrow>\n          \\<lambda>i. of_int (\\<beta> q) * h \\<alpha>' i)\n        xa)", "using z"], ["proof (prove)\nusing this:\n  of_nat p alg_dvd h (snd (fst z)) (snd z)\n  z \\<in> Sigma P Roots \\<times> {..<n * p} - {((q, \\<alpha>), p - 1)}\n\ngoal (1 subgoal):\n 1. of_nat p alg_dvd\n    (case z of\n     (x, xa) \\<Rightarrow>\n       (case x of\n        (q, \\<alpha>') \\<Rightarrow>\n          \\<lambda>i. of_int (\\<beta> q) * h \\<alpha>' i)\n        xa)", "by auto"], ["proof (state)\nthis:\n  of_nat p alg_dvd\n  (case z of\n   (x, xa) \\<Rightarrow>\n     (case x of\n      (q, \\<alpha>') \\<Rightarrow>\n        \\<lambda>i. of_int (\\<beta> q) * h \\<alpha>' i)\n      xa)\n\ngoal (2 subgoals):\n 1. \\<not> of_nat p alg_dvd\n           (case ((q, \\<alpha>), p - 1) of\n            (x, xa) \\<Rightarrow>\n              (case x of\n               (q, \\<alpha>') \\<Rightarrow>\n                 \\<lambda>i. of_int (\\<beta> q) * h \\<alpha>' i)\n               xa)\n 2. finite (Sigma P Roots \\<times> {..<n * p})", "qed (use \\<open>\\<not>of_nat p alg_dvd of_int (\\<beta> q) * h \\<alpha> (p-1)\\<close> in auto)"], ["proof (state)\nthis:\n  \\<not> of_nat p alg_dvd J \\<alpha>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?\\<alpha> \\<in> Roots' \\<Longrightarrow> fact (p - 1) alg_dvd J ?\\<alpha>\n  ?\\<alpha> \\<in> Roots' \\<Longrightarrow>\n  \\<not> of_nat p alg_dvd J ?\\<alpha>\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> C' * C p ^ n", "text \\<open>\n      Our next goal is to show that $J$ is rational. This is done by repeated applications\n      of the fundamental theorem of symmetric polynomials, exploiting the fact that $J$ is\n      symmetric in all the $\\alpha_i$ for each set of conjugates.\n    \\<close>"], ["proof (state)\nthis:\n  ?\\<alpha> \\<in> Roots' \\<Longrightarrow> fact (p - 1) alg_dvd J ?\\<alpha>\n  ?\\<alpha> \\<in> Roots' \\<Longrightarrow>\n  \\<not> of_nat p alg_dvd J ?\\<alpha>\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> C' * C p ^ n", "define g :: \"int poly poly\"\n      where \"g = synthetic_div (map_poly (\\<lambda>x. [:x:])\n                   ((Polynomial.smult lc_factor (\\<Prod>P)) ^ p)) [:0, 1:]\""], ["proof (state)\nthis:\n  g =\n  synthetic_div\n   (map_poly (\\<lambda>x. [:x:])\n     (Polynomial.smult lc_factor (\\<Prod>P) ^ p))\n   [:0, 1:]\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> C' * C p ^ n", "have g: \"map_poly (\\<lambda>p. ipoly p \\<alpha>) g = f_poly \\<alpha>\" if \\<alpha>: \"\\<alpha> \\<in> Roots'\" for \\<alpha>"], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly (\\<lambda>p. ipoly p \\<alpha>) g = f_poly \\<alpha>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. map_poly (\\<lambda>p. ipoly p \\<alpha>) g = f_poly \\<alpha>", "interpret \\<alpha>: comm_ring_hom \"\\<lambda>p. ipoly p \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. comm_ring_hom (\\<lambda>p. ipoly p \\<alpha>)", "by standard (auto simp: of_int_hom.poly_map_poly_eval_poly of_int_poly_hom.hom_mult)"], ["proof (state)\ngoal (1 subgoal):\n 1. map_poly (\\<lambda>p. ipoly p \\<alpha>) g = f_poly \\<alpha>", "define Q :: \"int poly\" where \"Q = (Polynomial.smult lc_factor (\\<Prod>P)) ^ p\""], ["proof (state)\nthis:\n  Q = Polynomial.smult lc_factor (\\<Prod>P) ^ p\n\ngoal (1 subgoal):\n 1. map_poly (\\<lambda>p. ipoly p \\<alpha>) g = f_poly \\<alpha>", "have \"f_poly \\<alpha> = Polynomial.smult (of_int (l^(n*p))) ((\\<Prod>\\<alpha>'\\<in>Roots'. [:-\\<alpha>',1:])^p) div [:-\\<alpha>,1:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f_poly \\<alpha> =\n    Polynomial.smult (of_int (l ^ (n * p)))\n     ((\\<Prod>\\<alpha>'\\<in>Roots'. [:- \\<alpha>', 1:]) ^ p) div\n    [:- \\<alpha>, 1:]", "unfolding f_poly_def div_smult_left [symmetric] prod_power_distrib[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (of_int (l ^ (n * p)))\n     ((\\<Prod>\\<alpha>'\\<in>Roots'. [:- \\<alpha>', 1:]) ^ p) div\n    [:- \\<alpha>, 1:] =\n    Polynomial.smult (of_int (l ^ (n * p)))\n     ((\\<Prod>\\<alpha>'\\<in>Roots'. [:- \\<alpha>', 1:]) ^ p) div\n    [:- \\<alpha>, 1:]", ".."], ["proof (state)\nthis:\n  f_poly \\<alpha> =\n  Polynomial.smult (of_int (l ^ (n * p)))\n   ((\\<Prod>\\<alpha>'\\<in>Roots'. [:- \\<alpha>', 1:]) ^ p) div\n  [:- \\<alpha>, 1:]\n\ngoal (1 subgoal):\n 1. map_poly (\\<lambda>p. ipoly p \\<alpha>) g = f_poly \\<alpha>", "also"], ["proof (state)\nthis:\n  f_poly \\<alpha> =\n  Polynomial.smult (of_int (l ^ (n * p)))\n   ((\\<Prod>\\<alpha>'\\<in>Roots'. [:- \\<alpha>', 1:]) ^ p) div\n  [:- \\<alpha>, 1:]\n\ngoal (1 subgoal):\n 1. map_poly (\\<lambda>p. ipoly p \\<alpha>) g = f_poly \\<alpha>", "have \"of_int (l^(n*p)) = (of_int l^n)^p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (l ^ (n * p)) = (of_int l ^ n) ^ p", "by (simp add: power_mult)"], ["proof (state)\nthis:\n  of_int (l ^ (n * p)) = (of_int l ^ n) ^ p\n\ngoal (1 subgoal):\n 1. map_poly (\\<lambda>p. ipoly p \\<alpha>) g = f_poly \\<alpha>", "also"], ["proof (state)\nthis:\n  of_int (l ^ (n * p)) = (of_int l ^ n) ^ p\n\ngoal (1 subgoal):\n 1. map_poly (\\<lambda>p. ipoly p \\<alpha>) g = f_poly \\<alpha>", "have \"Polynomial.smult \\<dots> ((\\<Prod>\\<alpha>'\\<in>Roots'. [:-\\<alpha>',1:])^p) =\n                   (Polynomial.smult (of_int l ^ n) (\\<Prod>\\<alpha>'\\<in>Roots'. [:-\\<alpha>',1:])) ^ p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult ((of_int l ^ n) ^ p)\n     ((\\<Prod>\\<alpha>'\\<in>Roots'. [:- \\<alpha>', 1:]) ^ p) =\n    Polynomial.smult (of_int l ^ n)\n     (\\<Prod>\\<alpha>'\\<in>Roots'. [:- \\<alpha>', 1:]) ^\n    p", "by (simp only: smult_power)"], ["proof (state)\nthis:\n  Polynomial.smult ((of_int l ^ n) ^ p)\n   ((\\<Prod>\\<alpha>'\\<in>Roots'. [:- \\<alpha>', 1:]) ^ p) =\n  Polynomial.smult (of_int l ^ n)\n   (\\<Prod>\\<alpha>'\\<in>Roots'. [:- \\<alpha>', 1:]) ^\n  p\n\ngoal (1 subgoal):\n 1. map_poly (\\<lambda>p. ipoly p \\<alpha>) g = f_poly \\<alpha>", "also"], ["proof (state)\nthis:\n  Polynomial.smult ((of_int l ^ n) ^ p)\n   ((\\<Prod>\\<alpha>'\\<in>Roots'. [:- \\<alpha>', 1:]) ^ p) =\n  Polynomial.smult (of_int l ^ n)\n   (\\<Prod>\\<alpha>'\\<in>Roots'. [:- \\<alpha>', 1:]) ^\n  p\n\ngoal (1 subgoal):\n 1. map_poly (\\<lambda>p. ipoly p \\<alpha>) g = f_poly \\<alpha>", "have \"\\<dots> = of_int_poly Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (of_int l ^ n)\n     (\\<Prod>\\<alpha>'\\<in>Roots'. [:- \\<alpha>', 1:]) ^\n    p =\n    Ring_Hom_Poly.of_int_poly Q", "by (subst lc_factor) (simp_all add: Q_def of_int_poly_hom.hom_power)"], ["proof (state)\nthis:\n  Polynomial.smult (of_int l ^ n)\n   (\\<Prod>\\<alpha>'\\<in>Roots'. [:- \\<alpha>', 1:]) ^\n  p =\n  Ring_Hom_Poly.of_int_poly Q\n\ngoal (1 subgoal):\n 1. map_poly (\\<lambda>p. ipoly p \\<alpha>) g = f_poly \\<alpha>", "also"], ["proof (state)\nthis:\n  Polynomial.smult (of_int l ^ n)\n   (\\<Prod>\\<alpha>'\\<in>Roots'. [:- \\<alpha>', 1:]) ^\n  p =\n  Ring_Hom_Poly.of_int_poly Q\n\ngoal (1 subgoal):\n 1. map_poly (\\<lambda>p. ipoly p \\<alpha>) g = f_poly \\<alpha>", "have \"\\<dots> div [:-\\<alpha>, 1:] = synthetic_div (of_int_poly Q) \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ring_Hom_Poly.of_int_poly Q div [:- \\<alpha>, 1:] =\n    synthetic_div (Ring_Hom_Poly.of_int_poly Q) \\<alpha>", "unfolding synthetic_div_altdef"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ring_Hom_Poly.of_int_poly Q div [:- \\<alpha>, 1:] =\n    Ring_Hom_Poly.of_int_poly Q div [:- \\<alpha>, 1:]", ".."], ["proof (state)\nthis:\n  Ring_Hom_Poly.of_int_poly Q div [:- \\<alpha>, 1:] =\n  synthetic_div (Ring_Hom_Poly.of_int_poly Q) \\<alpha>\n\ngoal (1 subgoal):\n 1. map_poly (\\<lambda>p. ipoly p \\<alpha>) g = f_poly \\<alpha>", "also"], ["proof (state)\nthis:\n  Ring_Hom_Poly.of_int_poly Q div [:- \\<alpha>, 1:] =\n  synthetic_div (Ring_Hom_Poly.of_int_poly Q) \\<alpha>\n\ngoal (1 subgoal):\n 1. map_poly (\\<lambda>p. ipoly p \\<alpha>) g = f_poly \\<alpha>", "have \"\\<dots> = synthetic_div (map_poly (\\<lambda>p. ipoly p \\<alpha>) (map_poly (\\<lambda>x. [:x:]) Q)) (ipoly [:0, 1:] \\<alpha>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. synthetic_div (Ring_Hom_Poly.of_int_poly Q) \\<alpha> =\n    synthetic_div\n     (map_poly (\\<lambda>p. ipoly p \\<alpha>)\n       (map_poly (\\<lambda>x. [:x:]) Q))\n     (ipoly [:0, 1:] \\<alpha>)", "by (simp add: map_poly_map_poly o_def)"], ["proof (state)\nthis:\n  synthetic_div (Ring_Hom_Poly.of_int_poly Q) \\<alpha> =\n  synthetic_div\n   (map_poly (\\<lambda>p. ipoly p \\<alpha>)\n     (map_poly (\\<lambda>x. [:x:]) Q))\n   (ipoly [:0, 1:] \\<alpha>)\n\ngoal (1 subgoal):\n 1. map_poly (\\<lambda>p. ipoly p \\<alpha>) g = f_poly \\<alpha>", "also"], ["proof (state)\nthis:\n  synthetic_div (Ring_Hom_Poly.of_int_poly Q) \\<alpha> =\n  synthetic_div\n   (map_poly (\\<lambda>p. ipoly p \\<alpha>)\n     (map_poly (\\<lambda>x. [:x:]) Q))\n   (ipoly [:0, 1:] \\<alpha>)\n\ngoal (1 subgoal):\n 1. map_poly (\\<lambda>p. ipoly p \\<alpha>) g = f_poly \\<alpha>", "have \"\\<dots> = map_poly (\\<lambda>p. ipoly p \\<alpha>) g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. synthetic_div\n     (map_poly (\\<lambda>p. ipoly p \\<alpha>)\n       (map_poly (\\<lambda>x. [:x:]) Q))\n     (ipoly [:0, 1:] \\<alpha>) =\n    map_poly (\\<lambda>p. ipoly p \\<alpha>) g", "unfolding g_def Q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. synthetic_div\n     (map_poly (\\<lambda>p. ipoly p \\<alpha>)\n       (map_poly (\\<lambda>x. [:x:])\n         (Polynomial.smult lc_factor (\\<Prod>P) ^ p)))\n     (ipoly [:0, 1:] \\<alpha>) =\n    map_poly (\\<lambda>p. ipoly p \\<alpha>)\n     (synthetic_div\n       (map_poly (\\<lambda>x. [:x:])\n         (Polynomial.smult lc_factor (\\<Prod>P) ^ p))\n       [:0, 1:])", "by (rule \\<alpha>.synthetic_div_hom)"], ["proof (state)\nthis:\n  synthetic_div\n   (map_poly (\\<lambda>p. ipoly p \\<alpha>)\n     (map_poly (\\<lambda>x. [:x:]) Q))\n   (ipoly [:0, 1:] \\<alpha>) =\n  map_poly (\\<lambda>p. ipoly p \\<alpha>) g\n\ngoal (1 subgoal):\n 1. map_poly (\\<lambda>p. ipoly p \\<alpha>) g = f_poly \\<alpha>", "finally"], ["proof (chain)\npicking this:\n  f_poly \\<alpha> = map_poly (\\<lambda>p. ipoly p \\<alpha>) g", "show ?thesis"], ["proof (prove)\nusing this:\n  f_poly \\<alpha> = map_poly (\\<lambda>p. ipoly p \\<alpha>) g\n\ngoal (1 subgoal):\n 1. map_poly (\\<lambda>p. ipoly p \\<alpha>) g = f_poly \\<alpha>", ".."], ["proof (state)\nthis:\n  map_poly (\\<lambda>p. ipoly p \\<alpha>) g = f_poly \\<alpha>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?\\<alpha> \\<in> Roots' \\<Longrightarrow>\n  map_poly (\\<lambda>p. ipoly p ?\\<alpha>) g = f_poly ?\\<alpha>\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> C' * C p ^ n", "obtain Q where Q: \"J \\<alpha> = -(\\<Sum>q\\<in>P. of_int (\\<beta> q) * eval_poly of_rat (Q q) \\<alpha>)\"\n      if \"\\<alpha> \\<in> Roots'\" for \\<alpha>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        (\\<And>\\<alpha>.\n            \\<alpha> \\<in> Roots' \\<Longrightarrow>\n            J \\<alpha> =\n            - (\\<Sum>q\\<in>P.\n                 of_int (\\<beta> q) *\n                 eval_poly of_rat (Q q) \\<alpha>)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        (\\<And>\\<alpha>.\n            \\<alpha> \\<in> Roots' \\<Longrightarrow>\n            J \\<alpha> =\n            - (\\<Sum>q\\<in>P.\n                 of_int (\\<beta> q) *\n                 eval_poly of_rat (Q q) \\<alpha>)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "define g' :: \"nat \\<Rightarrow> complex poly poly\"\n        where \"g' = (\\<lambda>j.  (map_poly of_int_poly ((pderiv ^^ j) g)))\""], ["proof (state)\nthis:\n  g' = (\\<lambda>j. map_poly Ring_Hom_Poly.of_int_poly ((pderiv ^^ j) g))\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        (\\<And>\\<alpha>.\n            \\<alpha> \\<in> Roots' \\<Longrightarrow>\n            J \\<alpha> =\n            - (\\<Sum>q\\<in>P.\n                 of_int (\\<beta> q) *\n                 eval_poly of_rat (Q q) \\<alpha>)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "obtain root :: \"int poly \\<Rightarrow> nat \\<Rightarrow> complex\"\n        where root: \"\\<And>q. q \\<in> P \\<Longrightarrow> bij_betw (root q) {..<\\<sharp>q} (Roots q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>root.\n        (\\<And>q.\n            q \\<in> P \\<Longrightarrow>\n            bij_betw (root q) {..<\\<sharp>q} (Roots q)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ex_bij_betw_nat_finite[OF finite_Roots]"], ["proof (prove)\nusing this:\n  ?p1 \\<in> P \\<Longrightarrow>\n  \\<exists>h. bij_betw h {0..<card (Roots ?p1)} (Roots ?p1)\n\ngoal (1 subgoal):\n 1. (\\<And>root.\n        (\\<And>q.\n            q \\<in> P \\<Longrightarrow>\n            bij_betw (root q) {..<\\<sharp>q} (Roots q)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding n_roots_def atLeast0LessThan"], ["proof (prove)\nusing this:\n  ?p1 \\<in> P \\<Longrightarrow>\n  \\<exists>h. bij_betw h {..<card (Roots ?p1)} (Roots ?p1)\n\ngoal (1 subgoal):\n 1. (\\<And>root.\n        (\\<And>q.\n            q \\<in> P \\<Longrightarrow>\n            bij_betw (root q) {..<card (Roots q)}\n             (Roots q)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  ?q \\<in> P \\<Longrightarrow> bij_betw (root ?q) {..<\\<sharp>?q} (Roots ?q)\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        (\\<And>\\<alpha>.\n            \\<alpha> \\<in> Roots' \\<Longrightarrow>\n            J \\<alpha> =\n            - (\\<Sum>q\\<in>P.\n                 of_int (\\<beta> q) *\n                 eval_poly of_rat (Q q) \\<alpha>)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have \"\\<exists>Q'. map_poly of_rat Q' = (\\<Sum>x\\<in>Roots q. poly (g' j) [:x:])\" if q: \"q \\<in> P\" for q j"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Q'.\n       map_poly of_rat Q' = (\\<Sum>x\\<in>Roots q. poly (g' j) [:x:])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>Q'.\n       map_poly of_rat Q' = (\\<Sum>x\\<in>Roots q. poly (g' j) [:x:])", "define Q :: \"nat \\<Rightarrow> complex poly mpoly\"\n          where \"Q = (\\<lambda>j. (\\<Sum>i<\\<sharp>q. mpoly_of_poly i (g' j)))\""], ["proof (state)\nthis:\n  Q = (\\<lambda>j. \\<Sum>i<\\<sharp>q. mpoly_of_poly i (g' j))\n\ngoal (1 subgoal):\n 1. \\<exists>Q'.\n       map_poly of_rat Q' = (\\<Sum>x\\<in>Roots q. poly (g' j) [:x:])", "define ratpolys :: \"complex poly set\" where \"ratpolys = {p. \\<forall>i. poly.coeff p i \\<in> \\<rat>}\""], ["proof (state)\nthis:\n  ratpolys = {p. \\<forall>i. poly.coeff p i \\<in> \\<rat>}\n\ngoal (1 subgoal):\n 1. \\<exists>Q'.\n       map_poly of_rat Q' = (\\<Sum>x\\<in>Roots q. poly (g' j) [:x:])", "have \"insertion ((\\<lambda>x. [:x:]) \\<circ> root q) (Q j) \\<in> ratpolys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion ((\\<lambda>x. [:x:]) \\<circ> root q) (Q j) \\<in> ratpolys", "proof (rule symmetric_poly_of_roots_in_subring)"], ["proof (state)\ngoal (10 subgoals):\n 1. ring_closed ratpolys\n 2. \\<forall>m. MPoly_Type.coeff (Q j) m \\<in> ratpolys\n 3. ring_homomorphism (\\<lambda>a. a)\n 4. finite ?A\n 5. symmetric_mpoly ?A (Q j)\n 6. vars (Q j) \\<subseteq> ?A\n 7. ?cinv * ?c = 1\n 8. ?cinv \\<in> ratpolys\n 9. ?p =\n    Polynomial.smult ?c\n     (\\<Prod>i\\<in>?A. [:- ((\\<lambda>x. [:x:]) \\<circ> root q) i, 1:])\n 10. \\<forall>i. poly.coeff ?p i \\<in> ratpolys", "show \"ring_closed ratpolys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ring_closed ratpolys", "by standard (auto simp: ratpolys_def intro!: coeff_mult_semiring_closed)"], ["proof (state)\nthis:\n  ring_closed ratpolys\n\ngoal (9 subgoals):\n 1. \\<forall>m. MPoly_Type.coeff (Q j) m \\<in> ratpolys\n 2. ring_homomorphism (\\<lambda>a. a)\n 3. finite ?A\n 4. symmetric_mpoly ?A (Q j)\n 5. vars (Q j) \\<subseteq> ?A\n 6. ?cinv * ?c = 1\n 7. ?cinv \\<in> ratpolys\n 8. ?p =\n    Polynomial.smult ?c\n     (\\<Prod>i\\<in>?A. [:- ((\\<lambda>x. [:x:]) \\<circ> root q) i, 1:])\n 9. \\<forall>i. poly.coeff ?p i \\<in> ratpolys", "show \"\\<forall>m. MPoly_Type.coeff (Q j) m \\<in> ratpolys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m. MPoly_Type.coeff (Q j) m \\<in> ratpolys", "by (auto simp: Q_def ratpolys_def Polynomial.coeff_sum coeff_mpoly_of_poly when_def g'_def\n                     intro!: sum_in_Rats)"], ["proof (state)\nthis:\n  \\<forall>m. MPoly_Type.coeff (Q j) m \\<in> ratpolys\n\ngoal (8 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite ?A\n 3. symmetric_mpoly ?A (Q j)\n 4. vars (Q j) \\<subseteq> ?A\n 5. ?cinv * ?c = 1\n 6. ?cinv \\<in> ratpolys\n 7. ?p =\n    Polynomial.smult ?c\n     (\\<Prod>i\\<in>?A. [:- ((\\<lambda>x. [:x:]) \\<circ> root q) i, 1:])\n 8. \\<forall>i. poly.coeff ?p i \\<in> ratpolys", "show \"vars (Q j) \\<subseteq> {..<\\<sharp>q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (Q j) \\<subseteq> {..<\\<sharp>q}", "unfolding Q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (\\<Sum>i<\\<sharp>q. mpoly_of_poly i (g' j))\n    \\<subseteq> {..<\\<sharp>q}", "by (intro order.trans[OF vars_sum] UN_least order.trans[OF vars_mpoly_of_poly]) auto"], ["proof (state)\nthis:\n  vars (Q j) \\<subseteq> {..<\\<sharp>q}\n\ngoal (7 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<\\<sharp>q}\n 3. symmetric_mpoly {..<\\<sharp>q} (Q j)\n 4. ?cinv * ?c = 1\n 5. ?cinv \\<in> ratpolys\n 6. ?p =\n    Polynomial.smult ?c\n     (\\<Prod>i<\\<sharp>q. [:- ((\\<lambda>x. [:x:]) \\<circ> root q) i, 1:])\n 7. \\<forall>i. poly.coeff ?p i \\<in> ratpolys", "show \"symmetric_mpoly {..<\\<sharp>q} (Q j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric_mpoly {..<\\<sharp>q} (Q j)", "unfolding Q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric_mpoly {..<\\<sharp>q}\n     (\\<Sum>i<\\<sharp>q. mpoly_of_poly i (g' j))", "by (rule symmetric_mpoly_symmetric_sum[of _ id]) (auto simp: permutes_bij)"], ["proof (state)\nthis:\n  symmetric_mpoly {..<\\<sharp>q} (Q j)\n\ngoal (6 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<\\<sharp>q}\n 3. ?cinv * ?c = 1\n 4. ?cinv \\<in> ratpolys\n 5. ?p =\n    Polynomial.smult ?c\n     (\\<Prod>i<\\<sharp>q. [:- ((\\<lambda>x. [:x:]) \\<circ> root q) i, 1:])\n 6. \\<forall>i. poly.coeff ?p i \\<in> ratpolys", "interpret coeff_lift_hom: map_poly_idom_hom \"\\<lambda>x. [:x:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly_idom_hom (\\<lambda>x. [:x:])", "by standard"], ["proof (state)\ngoal (6 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<\\<sharp>q}\n 3. ?cinv * ?c = 1\n 4. ?cinv \\<in> ratpolys\n 5. ?p =\n    Polynomial.smult ?c\n     (\\<Prod>i<\\<sharp>q. [:- ((\\<lambda>x. [:x:]) \\<circ> root q) i, 1:])\n 6. \\<forall>i. poly.coeff ?p i \\<in> ratpolys", "define lc :: complex where \"lc = of_int (Polynomial.lead_coeff q)\""], ["proof (state)\nthis:\n  lc = of_int (Polynomial.lead_coeff q)\n\ngoal (6 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<\\<sharp>q}\n 3. ?cinv * ?c = 1\n 4. ?cinv \\<in> ratpolys\n 5. ?p =\n    Polynomial.smult ?c\n     (\\<Prod>i<\\<sharp>q. [:- ((\\<lambda>x. [:x:]) \\<circ> root q) i, 1:])\n 6. \\<forall>i. poly.coeff ?p i \\<in> ratpolys", "have \"of_int_poly q = Polynomial.smult (Polynomial.lead_coeff q) (\\<Prod>x\\<in>Roots q. [:-x, 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ring_Hom_Poly.of_int_poly q =\n    Polynomial.smult (of_int (Polynomial.lead_coeff q))\n     (\\<Prod>x\\<in>Roots q. [:- x, 1:])", "by (rule of_int_poly_P) fact"], ["proof (state)\nthis:\n  Ring_Hom_Poly.of_int_poly q =\n  Polynomial.smult (of_int (Polynomial.lead_coeff q))\n   (\\<Prod>x\\<in>Roots q. [:- x, 1:])\n\ngoal (6 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<\\<sharp>q}\n 3. ?cinv * ?c = 1\n 4. ?cinv \\<in> ratpolys\n 5. ?p =\n    Polynomial.smult ?c\n     (\\<Prod>i<\\<sharp>q. [:- ((\\<lambda>x. [:x:]) \\<circ> root q) i, 1:])\n 6. \\<forall>i. poly.coeff ?p i \\<in> ratpolys", "also"], ["proof (state)\nthis:\n  Ring_Hom_Poly.of_int_poly q =\n  Polynomial.smult (of_int (Polynomial.lead_coeff q))\n   (\\<Prod>x\\<in>Roots q. [:- x, 1:])\n\ngoal (6 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<\\<sharp>q}\n 3. ?cinv * ?c = 1\n 4. ?cinv \\<in> ratpolys\n 5. ?p =\n    Polynomial.smult ?c\n     (\\<Prod>i<\\<sharp>q. [:- ((\\<lambda>x. [:x:]) \\<circ> root q) i, 1:])\n 6. \\<forall>i. poly.coeff ?p i \\<in> ratpolys", "have \"poly_lift \\<dots> = Polynomial.smult [:lc:] (\\<Prod>a\\<in>Roots q. [:-[:a:], 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_lift\n     (Polynomial.smult (of_int (Polynomial.lead_coeff q))\n       (\\<Prod>x\\<in>Roots q. [:- x, 1:])) =\n    Polynomial.smult [:lc:] (\\<Prod>a\\<in>Roots q. [:- [:a:], 1:])", "by (simp add: poly_lift_def map_poly_smult coeff_lift_hom.hom_prod lc_def)"], ["proof (state)\nthis:\n  poly_lift\n   (Polynomial.smult (of_int (Polynomial.lead_coeff q))\n     (\\<Prod>x\\<in>Roots q. [:- x, 1:])) =\n  Polynomial.smult [:lc:] (\\<Prod>a\\<in>Roots q. [:- [:a:], 1:])\n\ngoal (6 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<\\<sharp>q}\n 3. ?cinv * ?c = 1\n 4. ?cinv \\<in> ratpolys\n 5. ?p =\n    Polynomial.smult ?c\n     (\\<Prod>i<\\<sharp>q. [:- ((\\<lambda>x. [:x:]) \\<circ> root q) i, 1:])\n 6. \\<forall>i. poly.coeff ?p i \\<in> ratpolys", "also"], ["proof (state)\nthis:\n  poly_lift\n   (Polynomial.smult (of_int (Polynomial.lead_coeff q))\n     (\\<Prod>x\\<in>Roots q. [:- x, 1:])) =\n  Polynomial.smult [:lc:] (\\<Prod>a\\<in>Roots q. [:- [:a:], 1:])\n\ngoal (6 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<\\<sharp>q}\n 3. ?cinv * ?c = 1\n 4. ?cinv \\<in> ratpolys\n 5. ?p =\n    Polynomial.smult ?c\n     (\\<Prod>i<\\<sharp>q. [:- ((\\<lambda>x. [:x:]) \\<circ> root q) i, 1:])\n 6. \\<forall>i. poly.coeff ?p i \\<in> ratpolys", "have \"(\\<Prod>a\\<in>Roots q. [:-[:a:], 1:]) = (\\<Prod>i<\\<sharp>q. [:-[:root q i:], 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>a\\<in>Roots q. [:- [:a:], 1:]) =\n    (\\<Prod>i<\\<sharp>q. [:- [:root q i:], 1:])", "by (intro prod.reindex_bij_betw [symmetric] root q)"], ["proof (state)\nthis:\n  (\\<Prod>a\\<in>Roots q. [:- [:a:], 1:]) =\n  (\\<Prod>i<\\<sharp>q. [:- [:root q i:], 1:])\n\ngoal (6 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<\\<sharp>q}\n 3. ?cinv * ?c = 1\n 4. ?cinv \\<in> ratpolys\n 5. ?p =\n    Polynomial.smult ?c\n     (\\<Prod>i<\\<sharp>q. [:- ((\\<lambda>x. [:x:]) \\<circ> root q) i, 1:])\n 6. \\<forall>i. poly.coeff ?p i \\<in> ratpolys", "also"], ["proof (state)\nthis:\n  (\\<Prod>a\\<in>Roots q. [:- [:a:], 1:]) =\n  (\\<Prod>i<\\<sharp>q. [:- [:root q i:], 1:])\n\ngoal (6 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<\\<sharp>q}\n 3. ?cinv * ?c = 1\n 4. ?cinv \\<in> ratpolys\n 5. ?p =\n    Polynomial.smult ?c\n     (\\<Prod>i<\\<sharp>q. [:- ((\\<lambda>x. [:x:]) \\<circ> root q) i, 1:])\n 6. \\<forall>i. poly.coeff ?p i \\<in> ratpolys", "have \"\\<dots> = (\\<Prod>i<\\<sharp>q. [:- ((\\<lambda>x. [:x:]) \\<circ> root q) i, 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i<\\<sharp>q. [:- [:root q i:], 1:]) =\n    (\\<Prod>i<\\<sharp>q. [:- ((\\<lambda>x. [:x:]) \\<circ> root q) i, 1:])", "by simp"], ["proof (state)\nthis:\n  (\\<Prod>i<\\<sharp>q. [:- [:root q i:], 1:]) =\n  (\\<Prod>i<\\<sharp>q. [:- ((\\<lambda>x. [:x:]) \\<circ> root q) i, 1:])\n\ngoal (6 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<\\<sharp>q}\n 3. ?cinv * ?c = 1\n 4. ?cinv \\<in> ratpolys\n 5. ?p =\n    Polynomial.smult ?c\n     (\\<Prod>i<\\<sharp>q. [:- ((\\<lambda>x. [:x:]) \\<circ> root q) i, 1:])\n 6. \\<forall>i. poly.coeff ?p i \\<in> ratpolys", "finally"], ["proof (chain)\npicking this:\n  poly_lift (Ring_Hom_Poly.of_int_poly q) =\n  Polynomial.smult [:lc:]\n   (\\<Prod>i<\\<sharp>q. [:- ((\\<lambda>x. [:x:]) \\<circ> root q) i, 1:])", "show \"poly_lift (Ring_Hom_Poly.of_int_poly q) = Polynomial.smult [:lc:] \\<dots>\""], ["proof (prove)\nusing this:\n  poly_lift (Ring_Hom_Poly.of_int_poly q) =\n  Polynomial.smult [:lc:]\n   (\\<Prod>i<\\<sharp>q. [:- ((\\<lambda>x. [:x:]) \\<circ> root q) i, 1:])\n\ngoal (1 subgoal):\n 1. poly_lift (Ring_Hom_Poly.of_int_poly q) =\n    Polynomial.smult [:lc:]\n     (\\<Prod>i<\\<sharp>q. [:- ((\\<lambda>x. [:x:]) \\<circ> root q) i, 1:])", "."], ["proof (state)\nthis:\n  poly_lift (Ring_Hom_Poly.of_int_poly q) =\n  Polynomial.smult [:lc:]\n   (\\<Prod>i<\\<sharp>q. [:- ((\\<lambda>x. [:x:]) \\<circ> root q) i, 1:])\n\ngoal (5 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<\\<sharp>q}\n 3. ?cinv * [:of_int (Polynomial.lead_coeff q):] = 1\n 4. ?cinv \\<in> ratpolys\n 5. \\<forall>i.\n       poly.coeff (poly_lift (Ring_Hom_Poly.of_int_poly q)) i \\<in> ratpolys", "have \"lc \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lc \\<noteq> 0", "using q"], ["proof (prove)\nusing this:\n  q \\<in> P\n\ngoal (1 subgoal):\n 1. lc \\<noteq> 0", "by (auto simp: lc_def)"], ["proof (state)\nthis:\n  lc \\<noteq> 0\n\ngoal (5 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<\\<sharp>q}\n 3. ?cinv * [:of_int (Polynomial.lead_coeff q):] = 1\n 4. ?cinv \\<in> ratpolys\n 5. \\<forall>i.\n       poly.coeff (poly_lift (Ring_Hom_Poly.of_int_poly q)) i \\<in> ratpolys", "thus \"[:inverse lc:] * [:lc:] = 1\""], ["proof (prove)\nusing this:\n  lc \\<noteq> 0\n\ngoal (1 subgoal):\n 1. [:inverse lc:] * [:lc:] = 1", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  [:inverse lc:] * [:lc:] = 1\n\ngoal (4 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<\\<sharp>q}\n 3. [:inverse (of_int (Polynomial.lead_coeff q)):] \\<in> ratpolys\n 4. \\<forall>i.\n       poly.coeff (poly_lift (Ring_Hom_Poly.of_int_poly q)) i \\<in> ratpolys", "qed (auto simp: ratpolys_def coeff_pCons split: nat.splits)"], ["proof (state)\nthis:\n  insertion ((\\<lambda>x. [:x:]) \\<circ> root q) (Q j) \\<in> ratpolys\n\ngoal (1 subgoal):\n 1. \\<exists>Q'.\n       map_poly of_rat Q' = (\\<Sum>x\\<in>Roots q. poly (g' j) [:x:])", "also"], ["proof (state)\nthis:\n  insertion ((\\<lambda>x. [:x:]) \\<circ> root q) (Q j) \\<in> ratpolys\n\ngoal (1 subgoal):\n 1. \\<exists>Q'.\n       map_poly of_rat Q' = (\\<Sum>x\\<in>Roots q. poly (g' j) [:x:])", "have \"insertion ((\\<lambda>x. [:x:]) \\<circ> root q) (Q j) = (\\<Sum>i<\\<sharp>q. poly (g' j) [:root q i:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion ((\\<lambda>x. [:x:]) \\<circ> root q) (Q j) =\n    (\\<Sum>i<\\<sharp>q. poly (g' j) [:root q i:])", "by (simp add: Q_def insertion_sum poly_sum)"], ["proof (state)\nthis:\n  insertion ((\\<lambda>x. [:x:]) \\<circ> root q) (Q j) =\n  (\\<Sum>i<\\<sharp>q. poly (g' j) [:root q i:])\n\ngoal (1 subgoal):\n 1. \\<exists>Q'.\n       map_poly of_rat Q' = (\\<Sum>x\\<in>Roots q. poly (g' j) [:x:])", "also"], ["proof (state)\nthis:\n  insertion ((\\<lambda>x. [:x:]) \\<circ> root q) (Q j) =\n  (\\<Sum>i<\\<sharp>q. poly (g' j) [:root q i:])\n\ngoal (1 subgoal):\n 1. \\<exists>Q'.\n       map_poly of_rat Q' = (\\<Sum>x\\<in>Roots q. poly (g' j) [:x:])", "have \"\\<dots> = (\\<Sum>x\\<in>Roots q. poly (g' j) [:x:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<\\<sharp>q. poly (g' j) [:root q i:]) =\n    (\\<Sum>x\\<in>Roots q. poly (g' j) [:x:])", "by (intro sum.reindex_bij_betw root q)"], ["proof (state)\nthis:\n  (\\<Sum>i<\\<sharp>q. poly (g' j) [:root q i:]) =\n  (\\<Sum>x\\<in>Roots q. poly (g' j) [:x:])\n\ngoal (1 subgoal):\n 1. \\<exists>Q'.\n       map_poly of_rat Q' = (\\<Sum>x\\<in>Roots q. poly (g' j) [:x:])", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>x\\<in>Roots q. poly (g' j) [:x:]) \\<in> ratpolys", "have \"\\<forall>i. poly.coeff (\\<Sum>x\\<in>Roots q. poly (g' j) [:x:]) i \\<in> \\<rat>\""], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>Roots q. poly (g' j) [:x:]) \\<in> ratpolys\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       poly.coeff (\\<Sum>x\\<in>Roots q. poly (g' j) [:x:]) i \\<in> \\<rat>", "by (auto simp: ratpolys_def)"], ["proof (state)\nthis:\n  \\<forall>i.\n     poly.coeff (\\<Sum>x\\<in>Roots q. poly (g' j) [:x:]) i \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. \\<exists>Q'.\n       map_poly of_rat Q' = (\\<Sum>x\\<in>Roots q. poly (g' j) [:x:])", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     poly.coeff (\\<Sum>x\\<in>Roots q. poly (g' j) [:x:]) i \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. \\<exists>Q'.\n       map_poly of_rat Q' = (\\<Sum>x\\<in>Roots q. poly (g' j) [:x:])", "using ratpolyE"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     poly.coeff (\\<Sum>x\\<in>Roots q. poly (g' j) [:x:]) i \\<in> \\<rat>\n  \\<lbrakk>\\<forall>i. poly.coeff ?p i \\<in> \\<rat>;\n   \\<And>q. ?p = map_poly of_rat q \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<exists>Q'.\n       map_poly of_rat Q' = (\\<Sum>x\\<in>Roots q. poly (g' j) [:x:])", "by metis"], ["proof (state)\nthis:\n  \\<exists>Q'. map_poly of_rat Q' = (\\<Sum>x\\<in>Roots q. poly (g' j) [:x:])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?q \\<in> P \\<Longrightarrow>\n  \\<exists>Q'.\n     map_poly of_rat Q' = (\\<Sum>x\\<in>Roots ?q. poly (g' ?j) [:x:])\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        (\\<And>\\<alpha>.\n            \\<alpha> \\<in> Roots' \\<Longrightarrow>\n            J \\<alpha> =\n            - (\\<Sum>q\\<in>P.\n                 of_int (\\<beta> q) *\n                 eval_poly of_rat (Q q) \\<alpha>)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  ?q \\<in> P \\<Longrightarrow>\n  \\<exists>Q'.\n     map_poly of_rat Q' = (\\<Sum>x\\<in>Roots ?q. poly (g' ?j) [:x:])", "obtain Q where Q: \"\\<And>q j. q \\<in> P \\<Longrightarrow> map_poly of_rat (Q q j) = (\\<Sum>x\\<in>Roots q. poly (g' j) [:x:])\""], ["proof (prove)\nusing this:\n  ?q \\<in> P \\<Longrightarrow>\n  \\<exists>Q'.\n     map_poly of_rat Q' = (\\<Sum>x\\<in>Roots ?q. poly (g' ?j) [:x:])\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        (\\<And>q j.\n            q \\<in> P \\<Longrightarrow>\n            map_poly of_rat (Q q j) =\n            (\\<Sum>x\\<in>Roots q. poly (g' j) [:x:])) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  ?q \\<in> P \\<Longrightarrow>\n  map_poly of_rat (Q ?q ?j) = (\\<Sum>x\\<in>Roots ?q. poly (g' ?j) [:x:])\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        (\\<And>\\<alpha>.\n            \\<alpha> \\<in> Roots' \\<Longrightarrow>\n            J \\<alpha> =\n            - (\\<Sum>q\\<in>P.\n                 of_int (\\<beta> q) *\n                 eval_poly of_rat (Q q) \\<alpha>)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "define Q' where \"Q' = (\\<lambda>q. \\<Sum>j<n*p. Q q j)\""], ["proof (state)\nthis:\n  Q' = (\\<lambda>q. sum (Q q) {..<n * p})\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        (\\<And>\\<alpha>.\n            \\<alpha> \\<in> Roots' \\<Longrightarrow>\n            J \\<alpha> =\n            - (\\<Sum>q\\<in>P.\n                 of_int (\\<beta> q) *\n                 eval_poly of_rat (Q q) \\<alpha>)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have \"J \\<alpha> = - (\\<Sum>q\\<in>P. of_int (\\<beta> q) * eval_poly of_rat (Q' q) \\<alpha>)\" if \\<alpha>: \"\\<alpha> \\<in> Roots'\" for \\<alpha>"], ["proof (prove)\ngoal (1 subgoal):\n 1. J \\<alpha> =\n    - (\\<Sum>q\\<in>P. of_int (\\<beta> q) * eval_poly of_rat (Q' q) \\<alpha>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. J \\<alpha> =\n    - (\\<Sum>q\\<in>P. of_int (\\<beta> q) * eval_poly of_rat (Q' q) \\<alpha>)", "have \"J \\<alpha> = -(\\<Sum>q\\<in>P. of_int (\\<beta> q) * (\\<Sum>x\\<in>Roots q. \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x))\"\n          (is \"_ = -?S\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. J \\<alpha> =\n    - (\\<Sum>q\\<in>P.\n         of_int (\\<beta> q) *\n         (\\<Sum>x\\<in>Roots q.\n            \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x))", "unfolding J_eq[OF \\<alpha>]"], ["proof (prove)\ngoal (1 subgoal):\n 1. - (\\<Sum>q\\<in>P.\n         of_int (\\<beta> q) *\n         (\\<Sum>x\\<in>Roots q.\n            \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x)) =\n    - (\\<Sum>q\\<in>P.\n         of_int (\\<beta> q) *\n         (\\<Sum>x\\<in>Roots q.\n            \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x))", ".."], ["proof (state)\nthis:\n  J \\<alpha> =\n  - (\\<Sum>q\\<in>P.\n       of_int (\\<beta> q) *\n       (\\<Sum>x\\<in>Roots q.\n          \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x))\n\ngoal (1 subgoal):\n 1. J \\<alpha> =\n    - (\\<Sum>q\\<in>P. of_int (\\<beta> q) * eval_poly of_rat (Q' q) \\<alpha>)", "also"], ["proof (state)\nthis:\n  J \\<alpha> =\n  - (\\<Sum>q\\<in>P.\n       of_int (\\<beta> q) *\n       (\\<Sum>x\\<in>Roots q.\n          \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x))\n\ngoal (1 subgoal):\n 1. J \\<alpha> =\n    - (\\<Sum>q\\<in>P. of_int (\\<beta> q) * eval_poly of_rat (Q' q) \\<alpha>)", "have \"?S = (\\<Sum>q\\<in>P. of_int (\\<beta> q) * eval_poly of_rat (Q' q) \\<alpha>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>q\\<in>P.\n       of_int (\\<beta> q) *\n       (\\<Sum>x\\<in>Roots q.\n          \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x)) =\n    (\\<Sum>q\\<in>P. of_int (\\<beta> q) * eval_poly of_rat (Q' q) \\<alpha>)", "proof (rule sum.cong, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. P = P\n 2. \\<And>x.\n       x \\<in> P \\<Longrightarrow>\n       of_int (\\<beta> x) *\n       (\\<Sum>x\\<in>Roots x.\n          \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x) =\n       of_int (\\<beta> x) * eval_poly of_rat (Q' x) \\<alpha>", "case q: (2 q)"], ["proof (state)\nthis:\n  q \\<in> P\n\ngoal (2 subgoals):\n 1. P = P\n 2. \\<And>x.\n       x \\<in> P \\<Longrightarrow>\n       of_int (\\<beta> x) *\n       (\\<Sum>x\\<in>Roots x.\n          \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x) =\n       of_int (\\<beta> x) * eval_poly of_rat (Q' x) \\<alpha>", "interpret \\<alpha>: idom_hom \"\\<lambda>p. ipoly p \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. idom_hom (\\<lambda>p. ipoly p \\<alpha>)", "by standard (auto simp: of_int_hom.poly_map_poly_eval_poly of_int_poly_hom.hom_mult)"], ["proof (state)\ngoal (2 subgoals):\n 1. P = P\n 2. \\<And>x.\n       x \\<in> P \\<Longrightarrow>\n       of_int (\\<beta> x) *\n       (\\<Sum>x\\<in>Roots x.\n          \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x) =\n       of_int (\\<beta> x) * eval_poly of_rat (Q' x) \\<alpha>", "have \"(\\<Sum>x\\<in>Roots q. \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x) =\n                (\\<Sum>j<n * p. \\<Sum>x\\<in>Roots q. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>Roots q.\n       \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x) =\n    (\\<Sum>j<n * p. sum (poly ((pderiv ^^ j) (f_poly \\<alpha>))) (Roots q))", "by (rule sum.swap)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>Roots q.\n     \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x) =\n  (\\<Sum>j<n * p. sum (poly ((pderiv ^^ j) (f_poly \\<alpha>))) (Roots q))\n\ngoal (2 subgoals):\n 1. P = P\n 2. \\<And>x.\n       x \\<in> P \\<Longrightarrow>\n       of_int (\\<beta> x) *\n       (\\<Sum>x\\<in>Roots x.\n          \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x) =\n       of_int (\\<beta> x) * eval_poly of_rat (Q' x) \\<alpha>", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>Roots q.\n     \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x) =\n  (\\<Sum>j<n * p. sum (poly ((pderiv ^^ j) (f_poly \\<alpha>))) (Roots q))\n\ngoal (2 subgoals):\n 1. P = P\n 2. \\<And>x.\n       x \\<in> P \\<Longrightarrow>\n       of_int (\\<beta> x) *\n       (\\<Sum>x\\<in>Roots x.\n          \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x) =\n       of_int (\\<beta> x) * eval_poly of_rat (Q' x) \\<alpha>", "have \"\\<dots> = (\\<Sum>j<n * p. eval_poly of_rat (Q q j) \\<alpha>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j<n * p.\n        sum (poly ((pderiv ^^ j) (f_poly \\<alpha>))) (Roots q)) =\n    (\\<Sum>j<n * p. eval_poly of_rat (Q q j) \\<alpha>)", "proof (rule sum.cong, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. {..<n * p} = {..<n * p}\n 2. \\<And>x.\n       x \\<in> {..<n * p} \\<Longrightarrow>\n       sum (poly ((pderiv ^^ x) (f_poly \\<alpha>))) (Roots q) =\n       eval_poly of_rat (Q q x) \\<alpha>", "case j: (2 j)"], ["proof (state)\nthis:\n  j \\<in> {..<n * p}\n\ngoal (2 subgoals):\n 1. {..<n * p} = {..<n * p}\n 2. \\<And>x.\n       x \\<in> {..<n * p} \\<Longrightarrow>\n       sum (poly ((pderiv ^^ x) (f_poly \\<alpha>))) (Roots q) =\n       eval_poly of_rat (Q q x) \\<alpha>", "have \"(\\<Sum>x\\<in>Roots q. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x) =\n                  (\\<Sum>x\\<in>Roots q. poly (poly (g' j) [:x:]) \\<alpha>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum (poly ((pderiv ^^ j) (f_poly \\<alpha>))) (Roots q) =\n    (\\<Sum>x\\<in>Roots q. poly (poly (g' j) [:x:]) \\<alpha>)", "proof (rule sum.cong, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. Roots q = Roots q\n 2. \\<And>x.\n       x \\<in> Roots q \\<Longrightarrow>\n       poly ((pderiv ^^ j) (f_poly \\<alpha>)) x =\n       poly (poly (g' j) [:x:]) \\<alpha>", "case (2 x)"], ["proof (state)\nthis:\n  x \\<in> Roots q\n\ngoal (2 subgoals):\n 1. Roots q = Roots q\n 2. \\<And>x.\n       x \\<in> Roots q \\<Longrightarrow>\n       poly ((pderiv ^^ j) (f_poly \\<alpha>)) x =\n       poly (poly (g' j) [:x:]) \\<alpha>", "have \"poly ((pderiv ^^ j) (f_poly \\<alpha>)) x =\n                    poly ((pderiv ^^ j) (map_poly (\\<lambda>p. ipoly p \\<alpha>) g)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x =\n    poly ((pderiv ^^ j) (map_poly (\\<lambda>p. ipoly p \\<alpha>) g)) x", "by (subst g[OF \\<alpha>, symmetric]) (rule refl)"], ["proof (state)\nthis:\n  poly ((pderiv ^^ j) (f_poly \\<alpha>)) x =\n  poly ((pderiv ^^ j) (map_poly (\\<lambda>p. ipoly p \\<alpha>) g)) x\n\ngoal (2 subgoals):\n 1. Roots q = Roots q\n 2. \\<And>x.\n       x \\<in> Roots q \\<Longrightarrow>\n       poly ((pderiv ^^ j) (f_poly \\<alpha>)) x =\n       poly (poly (g' j) [:x:]) \\<alpha>", "also"], ["proof (state)\nthis:\n  poly ((pderiv ^^ j) (f_poly \\<alpha>)) x =\n  poly ((pderiv ^^ j) (map_poly (\\<lambda>p. ipoly p \\<alpha>) g)) x\n\ngoal (2 subgoals):\n 1. Roots q = Roots q\n 2. \\<And>x.\n       x \\<in> Roots q \\<Longrightarrow>\n       poly ((pderiv ^^ j) (f_poly \\<alpha>)) x =\n       poly (poly (g' j) [:x:]) \\<alpha>", "have \"\\<dots> = poly (eval_poly ((\\<lambda>p. [:poly p \\<alpha>:]) \\<circ> of_int_poly) ((pderiv ^^ j) g) [:0, 1:]) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly ((pderiv ^^ j) (map_poly (\\<lambda>p. ipoly p \\<alpha>) g)) x =\n    poly\n     (eval_poly\n       ((\\<lambda>p. [:poly p \\<alpha>:]) \\<circ> Ring_Hom_Poly.of_int_poly)\n       ((pderiv ^^ j) g) [:0, 1:])\n     x", "unfolding o_def \\<alpha>.map_poly_higher_pderiv [symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (map_poly (\\<lambda>p. ipoly p \\<alpha>) ((pderiv ^^ j) g)) x =\n    poly\n     (eval_poly (\\<lambda>x. [:ipoly x \\<alpha>:]) ((pderiv ^^ j) g)\n       [:0, 1:])\n     x", "by (simp only: \\<alpha>.map_poly_eval_poly)"], ["proof (state)\nthis:\n  poly ((pderiv ^^ j) (map_poly (\\<lambda>p. ipoly p \\<alpha>) g)) x =\n  poly\n   (eval_poly\n     ((\\<lambda>p. [:poly p \\<alpha>:]) \\<circ> Ring_Hom_Poly.of_int_poly)\n     ((pderiv ^^ j) g) [:0, 1:])\n   x\n\ngoal (2 subgoals):\n 1. Roots q = Roots q\n 2. \\<And>x.\n       x \\<in> Roots q \\<Longrightarrow>\n       poly ((pderiv ^^ j) (f_poly \\<alpha>)) x =\n       poly (poly (g' j) [:x:]) \\<alpha>", "also"], ["proof (state)\nthis:\n  poly ((pderiv ^^ j) (map_poly (\\<lambda>p. ipoly p \\<alpha>) g)) x =\n  poly\n   (eval_poly\n     ((\\<lambda>p. [:poly p \\<alpha>:]) \\<circ> Ring_Hom_Poly.of_int_poly)\n     ((pderiv ^^ j) g) [:0, 1:])\n   x\n\ngoal (2 subgoals):\n 1. Roots q = Roots q\n 2. \\<And>x.\n       x \\<in> Roots q \\<Longrightarrow>\n       poly ((pderiv ^^ j) (f_poly \\<alpha>)) x =\n       poly (poly (g' j) [:x:]) \\<alpha>", "have \"\\<dots> = poly (eval_poly (\\<lambda>p. [:poly p \\<alpha>:])\n                                (map_poly of_int_poly ((pderiv ^^ j) g)) [:0, 1:]) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly\n     (eval_poly\n       ((\\<lambda>p. [:poly p \\<alpha>:]) \\<circ> Ring_Hom_Poly.of_int_poly)\n       ((pderiv ^^ j) g) [:0, 1:])\n     x =\n    poly\n     (eval_poly (\\<lambda>p. [:poly p \\<alpha>:])\n       (map_poly Ring_Hom_Poly.of_int_poly ((pderiv ^^ j) g)) [:0, 1:])\n     x", "unfolding eval_poly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly\n     (poly\n       (map_poly\n         ((\\<lambda>p. [:poly p \\<alpha>:]) \\<circ>\n          Ring_Hom_Poly.of_int_poly)\n         ((pderiv ^^ j) g))\n       [:0, 1:])\n     x =\n    poly\n     (poly\n       (map_poly (\\<lambda>p. [:poly p \\<alpha>:])\n         (map_poly Ring_Hom_Poly.of_int_poly ((pderiv ^^ j) g)))\n       [:0, 1:])\n     x", "by (subst map_poly_map_poly) auto"], ["proof (state)\nthis:\n  poly\n   (eval_poly\n     ((\\<lambda>p. [:poly p \\<alpha>:]) \\<circ> Ring_Hom_Poly.of_int_poly)\n     ((pderiv ^^ j) g) [:0, 1:])\n   x =\n  poly\n   (eval_poly (\\<lambda>p. [:poly p \\<alpha>:])\n     (map_poly Ring_Hom_Poly.of_int_poly ((pderiv ^^ j) g)) [:0, 1:])\n   x\n\ngoal (2 subgoals):\n 1. Roots q = Roots q\n 2. \\<And>x.\n       x \\<in> Roots q \\<Longrightarrow>\n       poly ((pderiv ^^ j) (f_poly \\<alpha>)) x =\n       poly (poly (g' j) [:x:]) \\<alpha>", "also"], ["proof (state)\nthis:\n  poly\n   (eval_poly\n     ((\\<lambda>p. [:poly p \\<alpha>:]) \\<circ> Ring_Hom_Poly.of_int_poly)\n     ((pderiv ^^ j) g) [:0, 1:])\n   x =\n  poly\n   (eval_poly (\\<lambda>p. [:poly p \\<alpha>:])\n     (map_poly Ring_Hom_Poly.of_int_poly ((pderiv ^^ j) g)) [:0, 1:])\n   x\n\ngoal (2 subgoals):\n 1. Roots q = Roots q\n 2. \\<And>x.\n       x \\<in> Roots q \\<Longrightarrow>\n       poly ((pderiv ^^ j) (f_poly \\<alpha>)) x =\n       poly (poly (g' j) [:x:]) \\<alpha>", "have \"\\<dots> = poly (poly (map_poly of_int_poly ((pderiv ^^ j) g)) [:x:]) \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly\n     (eval_poly (\\<lambda>p. [:poly p \\<alpha>:])\n       (map_poly Ring_Hom_Poly.of_int_poly ((pderiv ^^ j) g)) [:0, 1:])\n     x =\n    poly (poly (map_poly Ring_Hom_Poly.of_int_poly ((pderiv ^^ j) g)) [:x:])\n     \\<alpha>", "by (rule poly_poly_eq [symmetric])"], ["proof (state)\nthis:\n  poly\n   (eval_poly (\\<lambda>p. [:poly p \\<alpha>:])\n     (map_poly Ring_Hom_Poly.of_int_poly ((pderiv ^^ j) g)) [:0, 1:])\n   x =\n  poly (poly (map_poly Ring_Hom_Poly.of_int_poly ((pderiv ^^ j) g)) [:x:])\n   \\<alpha>\n\ngoal (2 subgoals):\n 1. Roots q = Roots q\n 2. \\<And>x.\n       x \\<in> Roots q \\<Longrightarrow>\n       poly ((pderiv ^^ j) (f_poly \\<alpha>)) x =\n       poly (poly (g' j) [:x:]) \\<alpha>", "also"], ["proof (state)\nthis:\n  poly\n   (eval_poly (\\<lambda>p. [:poly p \\<alpha>:])\n     (map_poly Ring_Hom_Poly.of_int_poly ((pderiv ^^ j) g)) [:0, 1:])\n   x =\n  poly (poly (map_poly Ring_Hom_Poly.of_int_poly ((pderiv ^^ j) g)) [:x:])\n   \\<alpha>\n\ngoal (2 subgoals):\n 1. Roots q = Roots q\n 2. \\<And>x.\n       x \\<in> Roots q \\<Longrightarrow>\n       poly ((pderiv ^^ j) (f_poly \\<alpha>)) x =\n       poly (poly (g' j) [:x:]) \\<alpha>", "have \"\\<dots> = poly (poly (g' j) [:x:]) \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (poly (map_poly Ring_Hom_Poly.of_int_poly ((pderiv ^^ j) g)) [:x:])\n     \\<alpha> =\n    poly (poly (g' j) [:x:]) \\<alpha>", "by (simp add: g'_def)"], ["proof (state)\nthis:\n  poly (poly (map_poly Ring_Hom_Poly.of_int_poly ((pderiv ^^ j) g)) [:x:])\n   \\<alpha> =\n  poly (poly (g' j) [:x:]) \\<alpha>\n\ngoal (2 subgoals):\n 1. Roots q = Roots q\n 2. \\<And>x.\n       x \\<in> Roots q \\<Longrightarrow>\n       poly ((pderiv ^^ j) (f_poly \\<alpha>)) x =\n       poly (poly (g' j) [:x:]) \\<alpha>", "finally"], ["proof (chain)\npicking this:\n  poly ((pderiv ^^ j) (f_poly \\<alpha>)) x =\n  poly (poly (g' j) [:x:]) \\<alpha>", "show ?case"], ["proof (prove)\nusing this:\n  poly ((pderiv ^^ j) (f_poly \\<alpha>)) x =\n  poly (poly (g' j) [:x:]) \\<alpha>\n\ngoal (1 subgoal):\n 1. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x =\n    poly (poly (g' j) [:x:]) \\<alpha>", "."], ["proof (state)\nthis:\n  poly ((pderiv ^^ j) (f_poly \\<alpha>)) x =\n  poly (poly (g' j) [:x:]) \\<alpha>\n\ngoal (1 subgoal):\n 1. Roots q = Roots q", "qed auto"], ["proof (state)\nthis:\n  sum (poly ((pderiv ^^ j) (f_poly \\<alpha>))) (Roots q) =\n  (\\<Sum>x\\<in>Roots q. poly (poly (g' j) [:x:]) \\<alpha>)\n\ngoal (2 subgoals):\n 1. {..<n * p} = {..<n * p}\n 2. \\<And>x.\n       x \\<in> {..<n * p} \\<Longrightarrow>\n       sum (poly ((pderiv ^^ x) (f_poly \\<alpha>))) (Roots q) =\n       eval_poly of_rat (Q q x) \\<alpha>", "also"], ["proof (state)\nthis:\n  sum (poly ((pderiv ^^ j) (f_poly \\<alpha>))) (Roots q) =\n  (\\<Sum>x\\<in>Roots q. poly (poly (g' j) [:x:]) \\<alpha>)\n\ngoal (2 subgoals):\n 1. {..<n * p} = {..<n * p}\n 2. \\<And>x.\n       x \\<in> {..<n * p} \\<Longrightarrow>\n       sum (poly ((pderiv ^^ x) (f_poly \\<alpha>))) (Roots q) =\n       eval_poly of_rat (Q q x) \\<alpha>", "have \"\\<dots> = poly (\\<Sum>x\\<in>Roots q. poly (g' j) [:x:]) \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>Roots q. poly (poly (g' j) [:x:]) \\<alpha>) =\n    poly (\\<Sum>x\\<in>Roots q. poly (g' j) [:x:]) \\<alpha>", "by (simp add: poly_sum)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>Roots q. poly (poly (g' j) [:x:]) \\<alpha>) =\n  poly (\\<Sum>x\\<in>Roots q. poly (g' j) [:x:]) \\<alpha>\n\ngoal (2 subgoals):\n 1. {..<n * p} = {..<n * p}\n 2. \\<And>x.\n       x \\<in> {..<n * p} \\<Longrightarrow>\n       sum (poly ((pderiv ^^ x) (f_poly \\<alpha>))) (Roots q) =\n       eval_poly of_rat (Q q x) \\<alpha>", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>Roots q. poly (poly (g' j) [:x:]) \\<alpha>) =\n  poly (\\<Sum>x\\<in>Roots q. poly (g' j) [:x:]) \\<alpha>\n\ngoal (2 subgoals):\n 1. {..<n * p} = {..<n * p}\n 2. \\<And>x.\n       x \\<in> {..<n * p} \\<Longrightarrow>\n       sum (poly ((pderiv ^^ x) (f_poly \\<alpha>))) (Roots q) =\n       eval_poly of_rat (Q q x) \\<alpha>", "have \"\\<dots> = eval_poly of_rat (Q q j) \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly (\\<Sum>x\\<in>Roots q. poly (g' j) [:x:]) \\<alpha> =\n    eval_poly of_rat (Q q j) \\<alpha>", "using q"], ["proof (prove)\nusing this:\n  q \\<in> P\n\ngoal (1 subgoal):\n 1. poly (\\<Sum>x\\<in>Roots q. poly (g' j) [:x:]) \\<alpha> =\n    eval_poly of_rat (Q q j) \\<alpha>", "by (simp add: Q eval_poly_def)"], ["proof (state)\nthis:\n  poly (\\<Sum>x\\<in>Roots q. poly (g' j) [:x:]) \\<alpha> =\n  eval_poly of_rat (Q q j) \\<alpha>\n\ngoal (2 subgoals):\n 1. {..<n * p} = {..<n * p}\n 2. \\<And>x.\n       x \\<in> {..<n * p} \\<Longrightarrow>\n       sum (poly ((pderiv ^^ x) (f_poly \\<alpha>))) (Roots q) =\n       eval_poly of_rat (Q q x) \\<alpha>", "finally"], ["proof (chain)\npicking this:\n  sum (poly ((pderiv ^^ j) (f_poly \\<alpha>))) (Roots q) =\n  eval_poly of_rat (Q q j) \\<alpha>", "show ?case"], ["proof (prove)\nusing this:\n  sum (poly ((pderiv ^^ j) (f_poly \\<alpha>))) (Roots q) =\n  eval_poly of_rat (Q q j) \\<alpha>\n\ngoal (1 subgoal):\n 1. sum (poly ((pderiv ^^ j) (f_poly \\<alpha>))) (Roots q) =\n    eval_poly of_rat (Q q j) \\<alpha>", "."], ["proof (state)\nthis:\n  sum (poly ((pderiv ^^ j) (f_poly \\<alpha>))) (Roots q) =\n  eval_poly of_rat (Q q j) \\<alpha>\n\ngoal (1 subgoal):\n 1. {..<n * p} = {..<n * p}", "qed auto"], ["proof (state)\nthis:\n  (\\<Sum>j<n * p. sum (poly ((pderiv ^^ j) (f_poly \\<alpha>))) (Roots q)) =\n  (\\<Sum>j<n * p. eval_poly of_rat (Q q j) \\<alpha>)\n\ngoal (2 subgoals):\n 1. P = P\n 2. \\<And>x.\n       x \\<in> P \\<Longrightarrow>\n       of_int (\\<beta> x) *\n       (\\<Sum>x\\<in>Roots x.\n          \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x) =\n       of_int (\\<beta> x) * eval_poly of_rat (Q' x) \\<alpha>", "also"], ["proof (state)\nthis:\n  (\\<Sum>j<n * p. sum (poly ((pderiv ^^ j) (f_poly \\<alpha>))) (Roots q)) =\n  (\\<Sum>j<n * p. eval_poly of_rat (Q q j) \\<alpha>)\n\ngoal (2 subgoals):\n 1. P = P\n 2. \\<And>x.\n       x \\<in> P \\<Longrightarrow>\n       of_int (\\<beta> x) *\n       (\\<Sum>x\\<in>Roots x.\n          \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x) =\n       of_int (\\<beta> x) * eval_poly of_rat (Q' x) \\<alpha>", "have \"\\<dots> = eval_poly of_rat (Q' q) \\<alpha>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>j<n * p. eval_poly of_rat (Q q j) \\<alpha>) =\n    eval_poly of_rat (Q' q) \\<alpha>", "by (simp add: Q'_def of_rat_hom.eval_poly_sum)"], ["proof (state)\nthis:\n  (\\<Sum>j<n * p. eval_poly of_rat (Q q j) \\<alpha>) =\n  eval_poly of_rat (Q' q) \\<alpha>\n\ngoal (2 subgoals):\n 1. P = P\n 2. \\<And>x.\n       x \\<in> P \\<Longrightarrow>\n       of_int (\\<beta> x) *\n       (\\<Sum>x\\<in>Roots x.\n          \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x) =\n       of_int (\\<beta> x) * eval_poly of_rat (Q' x) \\<alpha>", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>x\\<in>Roots q.\n     \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x) =\n  eval_poly of_rat (Q' q) \\<alpha>", "show ?case"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>Roots q.\n     \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x) =\n  eval_poly of_rat (Q' q) \\<alpha>\n\ngoal (1 subgoal):\n 1. of_int (\\<beta> q) *\n    (\\<Sum>x\\<in>Roots q.\n       \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x) =\n    of_int (\\<beta> q) * eval_poly of_rat (Q' q) \\<alpha>", "by simp"], ["proof (state)\nthis:\n  of_int (\\<beta> q) *\n  (\\<Sum>x\\<in>Roots q.\n     \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x) =\n  of_int (\\<beta> q) * eval_poly of_rat (Q' q) \\<alpha>\n\ngoal (1 subgoal):\n 1. P = P", "qed auto"], ["proof (state)\nthis:\n  (\\<Sum>q\\<in>P.\n     of_int (\\<beta> q) *\n     (\\<Sum>x\\<in>Roots q.\n        \\<Sum>j<n * p. poly ((pderiv ^^ j) (f_poly \\<alpha>)) x)) =\n  (\\<Sum>q\\<in>P. of_int (\\<beta> q) * eval_poly of_rat (Q' q) \\<alpha>)\n\ngoal (1 subgoal):\n 1. J \\<alpha> =\n    - (\\<Sum>q\\<in>P. of_int (\\<beta> q) * eval_poly of_rat (Q' q) \\<alpha>)", "finally"], ["proof (chain)\npicking this:\n  J \\<alpha> =\n  - (\\<Sum>q\\<in>P. of_int (\\<beta> q) * eval_poly of_rat (Q' q) \\<alpha>)", "show \"J \\<alpha> = - (\\<Sum>q\\<in>P. of_int (\\<beta> q) * eval_poly of_rat (Q' q) \\<alpha>)\""], ["proof (prove)\nusing this:\n  J \\<alpha> =\n  - (\\<Sum>q\\<in>P. of_int (\\<beta> q) * eval_poly of_rat (Q' q) \\<alpha>)\n\ngoal (1 subgoal):\n 1. J \\<alpha> =\n    - (\\<Sum>q\\<in>P. of_int (\\<beta> q) * eval_poly of_rat (Q' q) \\<alpha>)", "."], ["proof (state)\nthis:\n  J \\<alpha> =\n  - (\\<Sum>q\\<in>P. of_int (\\<beta> q) * eval_poly of_rat (Q' q) \\<alpha>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?\\<alpha> \\<in> Roots' \\<Longrightarrow>\n  J ?\\<alpha> =\n  - (\\<Sum>q\\<in>P. of_int (\\<beta> q) * eval_poly of_rat (Q' q) ?\\<alpha>)\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        (\\<And>\\<alpha>.\n            \\<alpha> \\<in> Roots' \\<Longrightarrow>\n            J \\<alpha> =\n            - (\\<Sum>q\\<in>P.\n                 of_int (\\<beta> q) *\n                 eval_poly of_rat (Q q) \\<alpha>)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?\\<alpha> \\<in> Roots' \\<Longrightarrow>\n  J ?\\<alpha> =\n  - (\\<Sum>q\\<in>P. of_int (\\<beta> q) * eval_poly of_rat (Q' q) ?\\<alpha>)\n\ngoal (1 subgoal):\n 1. thesis", "using that[of Q']"], ["proof (prove)\nusing this:\n  ?\\<alpha> \\<in> Roots' \\<Longrightarrow>\n  J ?\\<alpha> =\n  - (\\<Sum>q\\<in>P. of_int (\\<beta> q) * eval_poly of_rat (Q' q) ?\\<alpha>)\n  (\\<And>\\<alpha>.\n      \\<alpha> \\<in> Roots' \\<Longrightarrow>\n      J \\<alpha> =\n      - (\\<Sum>q\\<in>P.\n           of_int (\\<beta> q) *\n           eval_poly of_rat (Q' q) \\<alpha>)) \\<Longrightarrow>\n  thesis\n\ngoal (1 subgoal):\n 1. thesis", "by metis"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?\\<alpha> \\<in> Roots' \\<Longrightarrow>\n  J ?\\<alpha> =\n  - (\\<Sum>q\\<in>P. of_int (\\<beta> q) * eval_poly of_rat (Q q) ?\\<alpha>)\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> C' * C p ^ n", "have \"J' \\<in> \\<rat>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. J' \\<in> \\<rat>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. J' \\<in> \\<rat>", "have \"(\\<Prod>\\<alpha>\\<in>Roots q. J \\<alpha>) \\<in> \\<rat>\" if q: \"q \\<in> P\" for q"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod J (Roots q) \\<in> \\<rat>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prod J (Roots q) \\<in> \\<rat>", "obtain root where root: \"bij_betw root {..<\\<sharp>q} (Roots q)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>root.\n        bij_betw root {..<\\<sharp>q} (Roots q) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ex_bij_betw_nat_finite[OF finite_Roots[OF q]]"], ["proof (prove)\nusing this:\n  \\<exists>h. bij_betw h {0..<card (Roots q)} (Roots q)\n\ngoal (1 subgoal):\n 1. (\\<And>root.\n        bij_betw root {..<\\<sharp>q} (Roots q) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding atLeast0LessThan n_roots_def"], ["proof (prove)\nusing this:\n  \\<exists>h. bij_betw h {..<card (Roots q)} (Roots q)\n\ngoal (1 subgoal):\n 1. (\\<And>root.\n        bij_betw root {..<card (Roots q)} (Roots q) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  bij_betw root {..<\\<sharp>q} (Roots q)\n\ngoal (1 subgoal):\n 1. prod J (Roots q) \\<in> \\<rat>", "define Q' :: \"complex poly\"\n          where \"Q' = -(\\<Sum>q\\<in>P. Polynomial.smult (of_int (\\<beta> q)) (map_poly of_rat (Q q)))\""], ["proof (state)\nthis:\n  Q' =\n  - (\\<Sum>q\\<in>P.\n       Polynomial.smult (of_int (\\<beta> q)) (map_poly of_rat (Q q)))\n\ngoal (1 subgoal):\n 1. prod J (Roots q) \\<in> \\<rat>", "have \"(\\<Prod>\\<alpha>\\<in>Roots q. J \\<alpha>) = (\\<Prod>\\<alpha>\\<in>Roots q. -(\\<Sum>q\\<in>P. of_int (\\<beta> q) * eval_poly of_rat (Q q) \\<alpha>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod J (Roots q) =\n    (\\<Prod>\\<alpha>\\<in>Roots q.\n       - (\\<Sum>q\\<in>P.\n            of_int (\\<beta> q) * eval_poly of_rat (Q q) \\<alpha>))", "by (intro prod.cong refl Q) (auto simp: Roots'_def q)"], ["proof (state)\nthis:\n  prod J (Roots q) =\n  (\\<Prod>\\<alpha>\\<in>Roots q.\n     - (\\<Sum>q\\<in>P.\n          of_int (\\<beta> q) * eval_poly of_rat (Q q) \\<alpha>))\n\ngoal (1 subgoal):\n 1. prod J (Roots q) \\<in> \\<rat>", "also"], ["proof (state)\nthis:\n  prod J (Roots q) =\n  (\\<Prod>\\<alpha>\\<in>Roots q.\n     - (\\<Sum>q\\<in>P.\n          of_int (\\<beta> q) * eval_poly of_rat (Q q) \\<alpha>))\n\ngoal (1 subgoal):\n 1. prod J (Roots q) \\<in> \\<rat>", "have \"\\<dots> = (\\<Prod>\\<alpha>\\<in>Roots q. poly Q' \\<alpha>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>\\<alpha>\\<in>Roots q.\n       - (\\<Sum>q\\<in>P.\n            of_int (\\<beta> q) * eval_poly of_rat (Q q) \\<alpha>)) =\n    prod (poly Q') (Roots q)", "by (simp add: Q'_def poly_sum eval_poly_def)"], ["proof (state)\nthis:\n  (\\<Prod>\\<alpha>\\<in>Roots q.\n     - (\\<Sum>q\\<in>P.\n          of_int (\\<beta> q) * eval_poly of_rat (Q q) \\<alpha>)) =\n  prod (poly Q') (Roots q)\n\ngoal (1 subgoal):\n 1. prod J (Roots q) \\<in> \\<rat>", "also"], ["proof (state)\nthis:\n  (\\<Prod>\\<alpha>\\<in>Roots q.\n     - (\\<Sum>q\\<in>P.\n          of_int (\\<beta> q) * eval_poly of_rat (Q q) \\<alpha>)) =\n  prod (poly Q') (Roots q)\n\ngoal (1 subgoal):\n 1. prod J (Roots q) \\<in> \\<rat>", "have \"\\<dots> = (\\<Prod>i<\\<sharp>q. poly Q' (root i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod (poly Q') (Roots q) = (\\<Prod>i<\\<sharp>q. poly Q' (root i))", "by (intro prod.reindex_bij_betw [symmetric] root)"], ["proof (state)\nthis:\n  prod (poly Q') (Roots q) = (\\<Prod>i<\\<sharp>q. poly Q' (root i))\n\ngoal (1 subgoal):\n 1. prod J (Roots q) \\<in> \\<rat>", "also"], ["proof (state)\nthis:\n  prod (poly Q') (Roots q) = (\\<Prod>i<\\<sharp>q. poly Q' (root i))\n\ngoal (1 subgoal):\n 1. prod J (Roots q) \\<in> \\<rat>", "have \"\\<dots> = insertion root (\\<Prod>i<\\<sharp>q. mpoly_of_poly i Q')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i<\\<sharp>q. poly Q' (root i)) =\n    insertion root (\\<Prod>i<\\<sharp>q. mpoly_of_poly i Q')", "by (simp add: insertion_prod)"], ["proof (state)\nthis:\n  (\\<Prod>i<\\<sharp>q. poly Q' (root i)) =\n  insertion root (\\<Prod>i<\\<sharp>q. mpoly_of_poly i Q')\n\ngoal (1 subgoal):\n 1. prod J (Roots q) \\<in> \\<rat>", "also"], ["proof (state)\nthis:\n  (\\<Prod>i<\\<sharp>q. poly Q' (root i)) =\n  insertion root (\\<Prod>i<\\<sharp>q. mpoly_of_poly i Q')\n\ngoal (1 subgoal):\n 1. prod J (Roots q) \\<in> \\<rat>", "have \"\\<dots> \\<in> \\<rat>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion root (\\<Prod>i<\\<sharp>q. mpoly_of_poly i Q') \\<in> \\<rat>", "proof (rule symmetric_poly_of_roots_in_subring)"], ["proof (state)\ngoal (10 subgoals):\n 1. ring_closed \\<rat>\n 2. \\<forall>m.\n       MPoly_Type.coeff (\\<Prod>i<\\<sharp>q. mpoly_of_poly i Q') m\n       \\<in> \\<rat>\n 3. ring_homomorphism (\\<lambda>a. a)\n 4. finite ?A\n 5. symmetric_mpoly ?A (\\<Prod>i<\\<sharp>q. mpoly_of_poly i Q')\n 6. vars (\\<Prod>i<\\<sharp>q. mpoly_of_poly i Q') \\<subseteq> ?A\n 7. ?cinv * ?c = 1\n 8. ?cinv \\<in> \\<rat>\n 9. ?p = Polynomial.smult ?c (\\<Prod>i\\<in>?A. [:- root i, 1:])\n 10. \\<forall>i. poly.coeff ?p i \\<in> \\<rat>", "show \"ring_closed (\\<rat> :: complex set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ring_closed \\<rat>", "by standard auto"], ["proof (state)\nthis:\n  ring_closed \\<rat>\n\ngoal (9 subgoals):\n 1. \\<forall>m.\n       MPoly_Type.coeff (\\<Prod>i<\\<sharp>q. mpoly_of_poly i Q') m\n       \\<in> \\<rat>\n 2. ring_homomorphism (\\<lambda>a. a)\n 3. finite ?A\n 4. symmetric_mpoly ?A (\\<Prod>i<\\<sharp>q. mpoly_of_poly i Q')\n 5. vars (\\<Prod>i<\\<sharp>q. mpoly_of_poly i Q') \\<subseteq> ?A\n 6. ?cinv * ?c = 1\n 7. ?cinv \\<in> \\<rat>\n 8. ?p = Polynomial.smult ?c (\\<Prod>i\\<in>?A. [:- root i, 1:])\n 9. \\<forall>i. poly.coeff ?p i \\<in> \\<rat>", "then"], ["proof (chain)\npicking this:\n  ring_closed \\<rat>", "interpret Q: ring_closed \"\\<rat> :: complex set\""], ["proof (prove)\nusing this:\n  ring_closed \\<rat>\n\ngoal (1 subgoal):\n 1. ring_closed \\<rat>", "."], ["proof (state)\ngoal (9 subgoals):\n 1. \\<forall>m.\n       MPoly_Type.coeff (\\<Prod>i<\\<sharp>q. mpoly_of_poly i Q') m\n       \\<in> \\<rat>\n 2. ring_homomorphism (\\<lambda>a. a)\n 3. finite ?A\n 4. symmetric_mpoly ?A (\\<Prod>i<\\<sharp>q. mpoly_of_poly i Q')\n 5. vars (\\<Prod>i<\\<sharp>q. mpoly_of_poly i Q') \\<subseteq> ?A\n 6. ?cinv * ?c = 1\n 7. ?cinv \\<in> \\<rat>\n 8. ?p = Polynomial.smult ?c (\\<Prod>i\\<in>?A. [:- root i, 1:])\n 9. \\<forall>i. poly.coeff ?p i \\<in> \\<rat>", "show \"\\<forall>m. MPoly_Type.coeff (\\<Prod>i<\\<sharp>q. mpoly_of_poly i Q') m \\<in> \\<rat>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m.\n       MPoly_Type.coeff (\\<Prod>i<\\<sharp>q. mpoly_of_poly i Q') m\n       \\<in> \\<rat>", "by (auto intro!: Q.coeff_prod_closed sum_in_Rats\n                     simp: coeff_mpoly_of_poly when_def Q'_def Polynomial.coeff_sum)"], ["proof (state)\nthis:\n  \\<forall>m.\n     MPoly_Type.coeff (\\<Prod>i<\\<sharp>q. mpoly_of_poly i Q') m\n     \\<in> \\<rat>\n\ngoal (8 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite ?A\n 3. symmetric_mpoly ?A (\\<Prod>i<\\<sharp>q. mpoly_of_poly i Q')\n 4. vars (\\<Prod>i<\\<sharp>q. mpoly_of_poly i Q') \\<subseteq> ?A\n 5. ?cinv * ?c = 1\n 6. ?cinv \\<in> \\<rat>\n 7. ?p = Polynomial.smult ?c (\\<Prod>i\\<in>?A. [:- root i, 1:])\n 8. \\<forall>i. poly.coeff ?p i \\<in> \\<rat>", "show \"symmetric_mpoly {..<\\<sharp>q} (\\<Prod>i<\\<sharp>q. mpoly_of_poly i Q')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric_mpoly {..<\\<sharp>q} (\\<Prod>i<\\<sharp>q. mpoly_of_poly i Q')", "by (intro symmetric_mpoly_symmetric_prod'[of _ id]) (auto simp: permutes_bij)"], ["proof (state)\nthis:\n  symmetric_mpoly {..<\\<sharp>q} (\\<Prod>i<\\<sharp>q. mpoly_of_poly i Q')\n\ngoal (7 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<\\<sharp>q}\n 3. vars (\\<Prod>i<\\<sharp>q. mpoly_of_poly i Q') \\<subseteq> {..<\\<sharp>q}\n 4. ?cinv * ?c = 1\n 5. ?cinv \\<in> \\<rat>\n 6. ?p = Polynomial.smult ?c (\\<Prod>i<\\<sharp>q. [:- root i, 1:])\n 7. \\<forall>i. poly.coeff ?p i \\<in> \\<rat>", "show \"vars (\\<Prod>i<\\<sharp>q. mpoly_of_poly i Q') \\<subseteq> {..<\\<sharp>q}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (\\<Prod>i<\\<sharp>q. mpoly_of_poly i Q') \\<subseteq> {..<\\<sharp>q}", "by (intro order.trans[OF vars_prod] order.trans[OF vars_mpoly_of_poly] UN_least) auto"], ["proof (state)\nthis:\n  vars (\\<Prod>i<\\<sharp>q. mpoly_of_poly i Q') \\<subseteq> {..<\\<sharp>q}\n\ngoal (6 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<\\<sharp>q}\n 3. ?cinv * ?c = 1\n 4. ?cinv \\<in> \\<rat>\n 5. ?p = Polynomial.smult ?c (\\<Prod>i<\\<sharp>q. [:- root i, 1:])\n 6. \\<forall>i. poly.coeff ?p i \\<in> \\<rat>", "define lc where \"lc = (of_int (Polynomial.lead_coeff q) :: complex)\""], ["proof (state)\nthis:\n  lc = of_int (Polynomial.lead_coeff q)\n\ngoal (6 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<\\<sharp>q}\n 3. ?cinv * ?c = 1\n 4. ?cinv \\<in> \\<rat>\n 5. ?p = Polynomial.smult ?c (\\<Prod>i<\\<sharp>q. [:- root i, 1:])\n 6. \\<forall>i. poly.coeff ?p i \\<in> \\<rat>", "have \"of_int_poly q = Polynomial.smult lc (\\<Prod>x\\<in>Roots q. [:- x, 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ring_Hom_Poly.of_int_poly q =\n    Polynomial.smult lc (\\<Prod>x\\<in>Roots q. [:- x, 1:])", "unfolding lc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ring_Hom_Poly.of_int_poly q =\n    Polynomial.smult (of_int (Polynomial.lead_coeff q))\n     (\\<Prod>x\\<in>Roots q. [:- x, 1:])", "by (rule of_int_poly_P) fact"], ["proof (state)\nthis:\n  Ring_Hom_Poly.of_int_poly q =\n  Polynomial.smult lc (\\<Prod>x\\<in>Roots q. [:- x, 1:])\n\ngoal (6 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<\\<sharp>q}\n 3. ?cinv * ?c = 1\n 4. ?cinv \\<in> \\<rat>\n 5. ?p = Polynomial.smult ?c (\\<Prod>i<\\<sharp>q. [:- root i, 1:])\n 6. \\<forall>i. poly.coeff ?p i \\<in> \\<rat>", "also"], ["proof (state)\nthis:\n  Ring_Hom_Poly.of_int_poly q =\n  Polynomial.smult lc (\\<Prod>x\\<in>Roots q. [:- x, 1:])\n\ngoal (6 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<\\<sharp>q}\n 3. ?cinv * ?c = 1\n 4. ?cinv \\<in> \\<rat>\n 5. ?p = Polynomial.smult ?c (\\<Prod>i<\\<sharp>q. [:- root i, 1:])\n 6. \\<forall>i. poly.coeff ?p i \\<in> \\<rat>", "have \"(\\<Prod>x\\<in>Roots q. [:- x, 1:]) = (\\<Prod>i<\\<sharp>q. [:- root i, 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<in>Roots q. [:- x, 1:]) =\n    (\\<Prod>i<\\<sharp>q. [:- root i, 1:])", "by (intro prod.reindex_bij_betw [symmetric] root)"], ["proof (state)\nthis:\n  (\\<Prod>x\\<in>Roots q. [:- x, 1:]) = (\\<Prod>i<\\<sharp>q. [:- root i, 1:])\n\ngoal (6 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<\\<sharp>q}\n 3. ?cinv * ?c = 1\n 4. ?cinv \\<in> \\<rat>\n 5. ?p = Polynomial.smult ?c (\\<Prod>i<\\<sharp>q. [:- root i, 1:])\n 6. \\<forall>i. poly.coeff ?p i \\<in> \\<rat>", "finally"], ["proof (chain)\npicking this:\n  Ring_Hom_Poly.of_int_poly q =\n  Polynomial.smult lc (\\<Prod>i<\\<sharp>q. [:- root i, 1:])", "show \"of_int_poly q = Polynomial.smult lc (\\<Prod>i<\\<sharp>q. [:- root i, 1:])\""], ["proof (prove)\nusing this:\n  Ring_Hom_Poly.of_int_poly q =\n  Polynomial.smult lc (\\<Prod>i<\\<sharp>q. [:- root i, 1:])\n\ngoal (1 subgoal):\n 1. Ring_Hom_Poly.of_int_poly q =\n    Polynomial.smult lc (\\<Prod>i<\\<sharp>q. [:- root i, 1:])", "."], ["proof (state)\nthis:\n  Ring_Hom_Poly.of_int_poly q =\n  Polynomial.smult lc (\\<Prod>i<\\<sharp>q. [:- root i, 1:])\n\ngoal (5 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<\\<sharp>q}\n 3. ?cinv * of_int (Polynomial.lead_coeff q) = 1\n 4. ?cinv \\<in> \\<rat>\n 5. \\<forall>i. poly.coeff (Ring_Hom_Poly.of_int_poly q) i \\<in> \\<rat>", "have \"lc \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lc \\<noteq> 0", "using q"], ["proof (prove)\nusing this:\n  q \\<in> P\n\ngoal (1 subgoal):\n 1. lc \\<noteq> 0", "by (auto simp: lc_def)"], ["proof (state)\nthis:\n  lc \\<noteq> 0\n\ngoal (5 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<\\<sharp>q}\n 3. ?cinv * of_int (Polynomial.lead_coeff q) = 1\n 4. ?cinv \\<in> \\<rat>\n 5. \\<forall>i. poly.coeff (Ring_Hom_Poly.of_int_poly q) i \\<in> \\<rat>", "thus \"inverse lc * lc = 1\" \"inverse lc \\<in> \\<rat>\""], ["proof (prove)\nusing this:\n  lc \\<noteq> 0\n\ngoal (1 subgoal):\n 1. inverse lc * lc = 1 &&& inverse lc \\<in> \\<rat>", "by (auto simp: lc_def)"], ["proof (state)\nthis:\n  inverse lc * lc = 1\n  inverse lc \\<in> \\<rat>\n\ngoal (3 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<\\<sharp>q}\n 3. \\<forall>i. poly.coeff (Ring_Hom_Poly.of_int_poly q) i \\<in> \\<rat>", "qed auto"], ["proof (state)\nthis:\n  insertion root (\\<Prod>i<\\<sharp>q. mpoly_of_poly i Q') \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. prod J (Roots q) \\<in> \\<rat>", "finally"], ["proof (chain)\npicking this:\n  prod J (Roots q) \\<in> \\<rat>", "show ?thesis"], ["proof (prove)\nusing this:\n  prod J (Roots q) \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. prod J (Roots q) \\<in> \\<rat>", "."], ["proof (state)\nthis:\n  prod J (Roots q) \\<in> \\<rat>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?q \\<in> P \\<Longrightarrow> prod J (Roots ?q) \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. J' \\<in> \\<rat>", "hence \"(\\<Prod>q\\<in>P. \\<Prod>\\<alpha>\\<in>Roots q. J \\<alpha>) \\<in> \\<rat>\""], ["proof (prove)\nusing this:\n  ?q \\<in> P \\<Longrightarrow> prod J (Roots ?q) \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. (\\<Prod>q\\<in>P. prod J (Roots q)) \\<in> \\<rat>", "by (rule prod_in_Rats)"], ["proof (state)\nthis:\n  (\\<Prod>q\\<in>P. prod J (Roots q)) \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. J' \\<in> \\<rat>", "also"], ["proof (state)\nthis:\n  (\\<Prod>q\\<in>P. prod J (Roots q)) \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. J' \\<in> \\<rat>", "have \"(\\<Prod>q\\<in>P. \\<Prod>\\<alpha>\\<in>Roots q. J \\<alpha>) = J'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>q\\<in>P. prod J (Roots q)) = J'", "unfolding Roots'_def J'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>q\\<in>P. prod J (Roots q)) = prod J (\\<Union> (Roots ` P))", "using disjoint"], ["proof (prove)\nusing this:\n  disjoint_family_on Roots P\n\ngoal (1 subgoal):\n 1. (\\<Prod>q\\<in>P. prod J (Roots q)) = prod J (\\<Union> (Roots ` P))", "by (intro prod.UNION_disjoint [symmetric]) (auto simp: disjoint_family_on_def)"], ["proof (state)\nthis:\n  (\\<Prod>q\\<in>P. prod J (Roots q)) = J'\n\ngoal (1 subgoal):\n 1. J' \\<in> \\<rat>", "finally"], ["proof (chain)\npicking this:\n  J' \\<in> \\<rat>", "show \"J' \\<in> \\<rat>\""], ["proof (prove)\nusing this:\n  J' \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. J' \\<in> \\<rat>", "."], ["proof (state)\nthis:\n  J' \\<in> \\<rat>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  J' \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> C' * C p ^ n", "text \\<open>\n      Since \\<open>J'\\<close> is clearly an algebraic integer, we now know that it is in fact an integer.\n    \\<close>"], ["proof (state)\nthis:\n  J' \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> C' * C p ^ n", "moreover"], ["proof (state)\nthis:\n  J' \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> C' * C p ^ n", "have \"algebraic_int J'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic_int J'", "unfolding J'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic_int (prod J Roots')", "proof (intro algebraic_int_prod)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Roots' \\<Longrightarrow> algebraic_int (J x)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Roots' \\<Longrightarrow> algebraic_int (J x)", "assume \"x \\<in> Roots'\""], ["proof (state)\nthis:\n  x \\<in> Roots'\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Roots' \\<Longrightarrow> algebraic_int (J x)", "hence \"fact (p - 1) alg_dvd J x\""], ["proof (prove)\nusing this:\n  x \\<in> Roots'\n\ngoal (1 subgoal):\n 1. fact (p - 1) alg_dvd J x", "by (intro J)"], ["proof (state)\nthis:\n  fact (p - 1) alg_dvd J x\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Roots' \\<Longrightarrow> algebraic_int (J x)", "thus \"algebraic_int (J x)\""], ["proof (prove)\nusing this:\n  fact (p - 1) alg_dvd J x\n\ngoal (1 subgoal):\n 1. algebraic_int (J x)", "by (rule alg_dvd_imp_algebraic_int) auto"], ["proof (state)\nthis:\n  algebraic_int (J x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  algebraic_int J'\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> C' * C p ^ n", "ultimately"], ["proof (chain)\npicking this:\n  J' \\<in> \\<rat>\n  algebraic_int J'", "have \"J' \\<in> \\<int>\""], ["proof (prove)\nusing this:\n  J' \\<in> \\<rat>\n  algebraic_int J'\n\ngoal (1 subgoal):\n 1. J' \\<in> \\<int>", "using rational_algebraic_int_is_int"], ["proof (prove)\nusing this:\n  J' \\<in> \\<rat>\n  algebraic_int J'\n  \\<lbrakk>algebraic_int ?x; ?x \\<in> \\<rat>\\<rbrakk>\n  \\<Longrightarrow> ?x \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. J' \\<in> \\<int>", "by blast"], ["proof (state)\nthis:\n  J' \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> C' * C p ^ n", "text \\<open>\n      It is also non-zero, as none of the $J_i$ have $p$ as a factor and such cannot be zero.\n    \\<close>"], ["proof (state)\nthis:\n  J' \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> C' * C p ^ n", "have \"J' \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. J' \\<noteq> 0", "unfolding J'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. prod J Roots' \\<noteq> 0", "proof (intro prod_nonzeroI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Roots' \\<Longrightarrow> J x \\<noteq> 0", "fix \\<alpha>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Roots' \\<Longrightarrow> J x \\<noteq> 0", "assume \"\\<alpha> \\<in> Roots'\""], ["proof (state)\nthis:\n  \\<alpha> \\<in> Roots'\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Roots' \\<Longrightarrow> J x \\<noteq> 0", "hence \"\\<not>of_nat p alg_dvd J \\<alpha>\""], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> Roots'\n\ngoal (1 subgoal):\n 1. \\<not> of_nat p alg_dvd J \\<alpha>", "using J(2)[of \\<alpha>]"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> Roots'\n  \\<alpha> \\<in> Roots' \\<Longrightarrow> \\<not> of_nat p alg_dvd J \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<not> of_nat p alg_dvd J \\<alpha>", "by auto"], ["proof (state)\nthis:\n  \\<not> of_nat p alg_dvd J \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Roots' \\<Longrightarrow> J x \\<noteq> 0", "thus \"J \\<alpha> \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> of_nat p alg_dvd J \\<alpha>\n\ngoal (1 subgoal):\n 1. J \\<alpha> \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  J \\<alpha> \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  J' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> C' * C p ^ n", "text \\<open>\n      It then clearly follows that $(p-1)!^n \\leq J$:\n    \\<close>"], ["proof (state)\nthis:\n  J' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> C' * C p ^ n", "have \"fact (p - 1) ^ n alg_dvd J'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n alg_dvd J'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n alg_dvd J'", "have \"fact (p - 1) ^ n = (\\<Prod>\\<alpha>\\<in>Roots'. fact (p - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n = (\\<Prod>\\<alpha>\\<in>Roots'. fact (p - 1))", "by (simp add: n_altdef)"], ["proof (state)\nthis:\n  fact (p - 1) ^ n = (\\<Prod>\\<alpha>\\<in>Roots'. fact (p - 1))\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n alg_dvd J'", "also"], ["proof (state)\nthis:\n  fact (p - 1) ^ n = (\\<Prod>\\<alpha>\\<in>Roots'. fact (p - 1))\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n alg_dvd J'", "have \"\\<dots> alg_dvd J'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>\\<alpha>\\<in>Roots'. fact (p - 1)) alg_dvd J'", "unfolding J'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>\\<alpha>\\<in>Roots'. fact (p - 1)) alg_dvd prod J Roots'", "by (intro prod_alg_dvd_prod J(1))"], ["proof (state)\nthis:\n  (\\<Prod>\\<alpha>\\<in>Roots'. fact (p - 1)) alg_dvd J'\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n alg_dvd J'", "finally"], ["proof (chain)\npicking this:\n  fact (p - 1) ^ n alg_dvd J'", "show ?thesis"], ["proof (prove)\nusing this:\n  fact (p - 1) ^ n alg_dvd J'\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n alg_dvd J'", "."], ["proof (state)\nthis:\n  fact (p - 1) ^ n alg_dvd J'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fact (p - 1) ^ n alg_dvd J'\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> C' * C p ^ n", "have \"fact (p - 1) ^ n \\<le> norm J'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> cmod J'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> cmod J'", "from \\<open>J' \\<in> \\<int>\\<close>"], ["proof (chain)\npicking this:\n  J' \\<in> \\<int>", "obtain J'' where [simp]: \"J' = of_int J''\""], ["proof (prove)\nusing this:\n  J' \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. (\\<And>J''. J' = of_int J'' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (elim Ints_cases)"], ["proof (state)\nthis:\n  J' = of_int J''\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> cmod J'", "have \"of_int (fact (p - 1) ^ n) = (fact (p - 1) ^ n :: complex)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (fact (p - 1) ^ n) = fact (p - 1) ^ n", "by simp"], ["proof (state)\nthis:\n  of_int (fact (p - 1) ^ n) = fact (p - 1) ^ n\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> cmod J'", "also"], ["proof (state)\nthis:\n  of_int (fact (p - 1) ^ n) = fact (p - 1) ^ n\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> cmod J'", "have \"\\<dots> alg_dvd J'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n alg_dvd J'", "by fact"], ["proof (state)\nthis:\n  fact (p - 1) ^ n alg_dvd J'\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> cmod J'", "also"], ["proof (state)\nthis:\n  fact (p - 1) ^ n alg_dvd J'\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> cmod J'", "have \"J' = of_int J''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. J' = of_int J''", "by fact"], ["proof (state)\nthis:\n  J' = of_int J''\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> cmod J'", "finally"], ["proof (chain)\npicking this:\n  of_int (fact (p - 1) ^ n) alg_dvd of_int J''", "have \"fact (p - 1) ^ n dvd J''\""], ["proof (prove)\nusing this:\n  of_int (fact (p - 1) ^ n) alg_dvd of_int J''\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n dvd J''", "by (subst (asm) alg_dvd_of_int_iff)"], ["proof (state)\nthis:\n  fact (p - 1) ^ n dvd J''\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> cmod J'", "moreover"], ["proof (state)\nthis:\n  fact (p - 1) ^ n dvd J''\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> cmod J'", "from \\<open>J' \\<noteq> 0\\<close>"], ["proof (chain)\npicking this:\n  J' \\<noteq> 0", "have \"J'' \\<noteq> 0\""], ["proof (prove)\nusing this:\n  J' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. J'' \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  J'' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> cmod J'", "ultimately"], ["proof (chain)\npicking this:\n  fact (p - 1) ^ n dvd J''\n  J'' \\<noteq> 0", "have \"\\<bar>J''\\<bar> \\<ge> \\<bar>fact (p - 1) ^ n\\<bar>\""], ["proof (prove)\nusing this:\n  fact (p - 1) ^ n dvd J''\n  J'' \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<bar>fact (p - 1) ^ n\\<bar> \\<le> \\<bar>J''\\<bar>", "by (intro dvd_imp_le_int)"], ["proof (state)\nthis:\n  \\<bar>fact (p - 1) ^ n\\<bar> \\<le> \\<bar>J''\\<bar>\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> cmod J'", "hence \"real_of_int \\<bar>J''\\<bar> \\<ge> real_of_int \\<bar>fact (p - 1) ^ n\\<bar>\""], ["proof (prove)\nusing this:\n  \\<bar>fact (p - 1) ^ n\\<bar> \\<le> \\<bar>J''\\<bar>\n\ngoal (1 subgoal):\n 1. real_of_int \\<bar>fact (p - 1) ^ n\\<bar>\n    \\<le> real_of_int \\<bar>J''\\<bar>", "by linarith"], ["proof (state)\nthis:\n  real_of_int \\<bar>fact (p - 1) ^ n\\<bar> \\<le> real_of_int \\<bar>J''\\<bar>\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> cmod J'", "also"], ["proof (state)\nthis:\n  real_of_int \\<bar>fact (p - 1) ^ n\\<bar> \\<le> real_of_int \\<bar>J''\\<bar>\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> cmod J'", "have \"real_of_int \\<bar>J''\\<bar> = norm J'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int \\<bar>J''\\<bar> = cmod J'", "by simp"], ["proof (state)\nthis:\n  real_of_int \\<bar>J''\\<bar> = cmod J'\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> cmod J'", "finally"], ["proof (chain)\npicking this:\n  real_of_int \\<bar>fact (p - 1) ^ n\\<bar> \\<le> cmod J'", "show ?thesis"], ["proof (prove)\nusing this:\n  real_of_int \\<bar>fact (p - 1) ^ n\\<bar> \\<le> cmod J'\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> cmod J'", "by simp"], ["proof (state)\nthis:\n  fact (p - 1) ^ n \\<le> cmod J'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  fact (p - 1) ^ n \\<le> cmod J'\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> C' * C p ^ n", "text \\<open>The standard M-L bound for $I_i(x)$ shows the following inequality:\\<close>"], ["proof (state)\nthis:\n  fact (p - 1) ^ n \\<le> cmod J'\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> C' * C p ^ n", "also"], ["proof (state)\nthis:\n  fact (p - 1) ^ n \\<le> cmod J'\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> C' * C p ^ n", "have \"norm J' \\<le> C' * C p ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod J' \\<le> C' * C p ^ n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cmod J' \\<le> C' * C p ^ n", "have \"norm J' = (\\<Prod>x\\<in>Roots'. norm (J x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod J' = (\\<Prod>x\\<in>Roots'. cmod (J x))", "unfolding J'_def prod_norm [symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<in>Roots'. cmod (J x)) = (\\<Prod>x\\<in>Roots'. cmod (J x))", ".."], ["proof (state)\nthis:\n  cmod J' = (\\<Prod>x\\<in>Roots'. cmod (J x))\n\ngoal (1 subgoal):\n 1. cmod J' \\<le> C' * C p ^ n", "also"], ["proof (state)\nthis:\n  cmod J' = (\\<Prod>x\\<in>Roots'. cmod (J x))\n\ngoal (1 subgoal):\n 1. cmod J' \\<le> C' * C p ^ n", "have \"\\<dots> \\<le> (\\<Prod>x\\<in>Roots'. \\<Sum>q\\<in>P. real_of_int \\<bar>\\<beta> q\\<bar> * (\\<Sum>\\<alpha>\\<in>Roots q. cmod \\<alpha> * exp (cmod \\<alpha>) * C p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<in>Roots'. cmod (J x))\n    \\<le> (\\<Prod>x\\<in>Roots'.\n             \\<Sum>q\\<in>P.\n               real_of_int \\<bar>\\<beta> q\\<bar> *\n               (\\<Sum>\\<alpha>\\<in>Roots q.\n                  cmod \\<alpha> * exp (cmod \\<alpha>) * C p))", "proof (intro prod_mono conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i. i \\<in> Roots' \\<Longrightarrow> 0 \\<le> cmod (J i)\n 2. \\<And>i.\n       i \\<in> Roots' \\<Longrightarrow>\n       cmod (J i)\n       \\<le> (\\<Sum>q\\<in>P.\n                real_of_int \\<bar>\\<beta> q\\<bar> *\n                (\\<Sum>\\<alpha>\\<in>Roots q.\n                   cmod \\<alpha> * exp (cmod \\<alpha>) * C p))", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i. i \\<in> Roots' \\<Longrightarrow> 0 \\<le> cmod (J i)\n 2. \\<And>i.\n       i \\<in> Roots' \\<Longrightarrow>\n       cmod (J i)\n       \\<le> (\\<Sum>q\\<in>P.\n                real_of_int \\<bar>\\<beta> q\\<bar> *\n                (\\<Sum>\\<alpha>\\<in>Roots q.\n                   cmod \\<alpha> * exp (cmod \\<alpha>) * C p))", "assume x: \"x \\<in> Roots'\""], ["proof (state)\nthis:\n  x \\<in> Roots'\n\ngoal (2 subgoals):\n 1. \\<And>i. i \\<in> Roots' \\<Longrightarrow> 0 \\<le> cmod (J i)\n 2. \\<And>i.\n       i \\<in> Roots' \\<Longrightarrow>\n       cmod (J i)\n       \\<le> (\\<Sum>q\\<in>P.\n                real_of_int \\<bar>\\<beta> q\\<bar> *\n                (\\<Sum>\\<alpha>\\<in>Roots q.\n                   cmod \\<alpha> * exp (cmod \\<alpha>) * C p))", "show \"norm (J x) \\<le> (\\<Sum>q\\<in>P. real_of_int \\<bar>\\<beta> q\\<bar> * (\\<Sum>\\<alpha>\\<in>Roots q. norm \\<alpha> * exp (norm \\<alpha>) * C p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (J x)\n    \\<le> (\\<Sum>q\\<in>P.\n             real_of_int \\<bar>\\<beta> q\\<bar> *\n             (\\<Sum>\\<alpha>\\<in>Roots q.\n                cmod \\<alpha> * exp (cmod \\<alpha>) * C p))", "unfolding J_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (\\<Sum>q\\<in>P. of_int (\\<beta> q) * sum (I x) (Roots q))\n    \\<le> (\\<Sum>q\\<in>P.\n             real_of_int \\<bar>\\<beta> q\\<bar> *\n             (\\<Sum>\\<alpha>\\<in>Roots q.\n                cmod \\<alpha> * exp (cmod \\<alpha>) * C p))", "proof (intro sum_norm_le)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> P \\<Longrightarrow>\n       cmod (of_int (\\<beta> xa) * sum (I x) (Roots xa))\n       \\<le> real_of_int \\<bar>\\<beta> xa\\<bar> *\n             (\\<Sum>\\<alpha>\\<in>Roots xa.\n                cmod \\<alpha> * exp (cmod \\<alpha>) * C p)", "fix q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> P \\<Longrightarrow>\n       cmod (of_int (\\<beta> xa) * sum (I x) (Roots xa))\n       \\<le> real_of_int \\<bar>\\<beta> xa\\<bar> *\n             (\\<Sum>\\<alpha>\\<in>Roots xa.\n                cmod \\<alpha> * exp (cmod \\<alpha>) * C p)", "assume \"q \\<in> P\""], ["proof (state)\nthis:\n  q \\<in> P\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> P \\<Longrightarrow>\n       cmod (of_int (\\<beta> xa) * sum (I x) (Roots xa))\n       \\<le> real_of_int \\<bar>\\<beta> xa\\<bar> *\n             (\\<Sum>\\<alpha>\\<in>Roots xa.\n                cmod \\<alpha> * exp (cmod \\<alpha>) * C p)", "show \"norm (of_int (\\<beta> q) * sum (I x) (Roots q)) \\<le>\n                  real_of_int \\<bar>\\<beta> q\\<bar> * (\\<Sum>\\<alpha>\\<in>Roots q. norm \\<alpha> * exp (norm \\<alpha>) * C p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (of_int (\\<beta> q) * sum (I x) (Roots q))\n    \\<le> real_of_int \\<bar>\\<beta> q\\<bar> *\n          (\\<Sum>\\<alpha>\\<in>Roots q.\n             cmod \\<alpha> * exp (cmod \\<alpha>) * C p)", "unfolding norm_mult norm_of_int of_int_abs"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>real_of_int (\\<beta> q)\\<bar> * cmod (sum (I x) (Roots q))\n    \\<le> \\<bar>real_of_int (\\<beta> q)\\<bar> *\n          (\\<Sum>\\<alpha>\\<in>Roots q.\n             cmod \\<alpha> * exp (cmod \\<alpha>) * C p)", "proof (intro mult_left_mono sum_norm_le)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> Roots q \\<Longrightarrow>\n       cmod (I x xa) \\<le> cmod xa * exp (cmod xa) * C p\n 2. 0 \\<le> \\<bar>real_of_int (\\<beta> q)\\<bar>", "fix \\<alpha>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> Roots q \\<Longrightarrow>\n       cmod (I x xa) \\<le> cmod xa * exp (cmod xa) * C p\n 2. 0 \\<le> \\<bar>real_of_int (\\<beta> q)\\<bar>", "assume \"\\<alpha> \\<in> Roots q\""], ["proof (state)\nthis:\n  \\<alpha> \\<in> Roots q\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> Roots q \\<Longrightarrow>\n       cmod (I x xa) \\<le> cmod xa * exp (cmod xa) * C p\n 2. 0 \\<le> \\<bar>real_of_int (\\<beta> q)\\<bar>", "hence \\<alpha>: \"\\<alpha> \\<in> Roots'\""], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> Roots q\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<in> Roots'", "using \\<open>q \\<in> P\\<close>"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> Roots q\n  q \\<in> P\n\ngoal (1 subgoal):\n 1. \\<alpha> \\<in> Roots'", "by (auto simp: Roots'_def)"], ["proof (state)\nthis:\n  \\<alpha> \\<in> Roots'\n\ngoal (2 subgoals):\n 1. \\<And>xa.\n       xa \\<in> Roots q \\<Longrightarrow>\n       cmod (I x xa) \\<le> cmod xa * exp (cmod xa) * C p\n 2. 0 \\<le> \\<bar>real_of_int (\\<beta> q)\\<bar>", "show \"norm (I x \\<alpha>) \\<le> norm \\<alpha> * exp (norm \\<alpha>) * C p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (I x \\<alpha>) \\<le> cmod \\<alpha> * exp (cmod \\<alpha>) * C p", "unfolding I_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (lindemann_weierstrass_aux.I (f_poly x) \\<alpha>)\n    \\<le> cmod \\<alpha> * exp (cmod \\<alpha>) * C p", "proof (intro lindemann_weierstrass_aux.lindemann_weierstrass_integral_bound)"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> C p\n 2. \\<And>t.\n       t \\<in> closed_segment 0 \\<alpha> \\<Longrightarrow>\n       cmod (poly (f_poly x) t) \\<le> C p", "fix t"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 \\<le> C p\n 2. \\<And>t.\n       t \\<in> closed_segment 0 \\<alpha> \\<Longrightarrow>\n       cmod (poly (f_poly x) t) \\<le> C p", "assume \"t \\<in> closed_segment 0 \\<alpha>\""], ["proof (state)\nthis:\n  t \\<in> closed_segment 0 \\<alpha>\n\ngoal (2 subgoals):\n 1. 0 \\<le> C p\n 2. \\<And>t.\n       t \\<in> closed_segment 0 \\<alpha> \\<Longrightarrow>\n       cmod (poly (f_poly x) t) \\<le> C p", "also"], ["proof (state)\nthis:\n  t \\<in> closed_segment 0 \\<alpha>\n\ngoal (2 subgoals):\n 1. 0 \\<le> C p\n 2. \\<And>t.\n       t \\<in> closed_segment 0 \\<alpha> \\<Longrightarrow>\n       cmod (poly (f_poly x) t) \\<le> C p", "have \"closed_segment 0 \\<alpha> \\<subseteq> cball 0 R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_segment 0 \\<alpha> \\<subseteq> cball 0 R", "using \\<open>R \\<ge> 0\\<close> R_ge[OF \\<alpha>]"], ["proof (prove)\nusing this:\n  0 \\<le> R\n  cmod \\<alpha> \\<le> R\n\ngoal (1 subgoal):\n 1. closed_segment 0 \\<alpha> \\<subseteq> cball 0 R", "by (intro closed_segment_subset) auto"], ["proof (state)\nthis:\n  closed_segment 0 \\<alpha> \\<subseteq> cball 0 R\n\ngoal (2 subgoals):\n 1. 0 \\<le> C p\n 2. \\<And>t.\n       t \\<in> closed_segment 0 \\<alpha> \\<Longrightarrow>\n       cmod (poly (f_poly x) t) \\<le> C p", "finally"], ["proof (chain)\npicking this:\n  t \\<in> cball 0 R", "have \"norm t \\<le> R\""], ["proof (prove)\nusing this:\n  t \\<in> cball 0 R\n\ngoal (1 subgoal):\n 1. cmod t \\<le> R", "by simp"], ["proof (state)\nthis:\n  cmod t \\<le> R\n\ngoal (2 subgoals):\n 1. 0 \\<le> C p\n 2. \\<And>t.\n       t \\<in> closed_segment 0 \\<alpha> \\<Longrightarrow>\n       cmod (poly (f_poly x) t) \\<le> C p", "have norm_diff_le: \"norm (t - y) \\<le> 2 * R\" if \"y \\<in> Roots'\" for y"], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (t - y) \\<le> 2 * R", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cmod (t - y) \\<le> 2 * R", "have \"norm (t - y) \\<le> norm t + norm y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (t - y) \\<le> cmod t + cmod y", "by (meson norm_triangle_ineq4)"], ["proof (state)\nthis:\n  cmod (t - y) \\<le> cmod t + cmod y\n\ngoal (1 subgoal):\n 1. cmod (t - y) \\<le> 2 * R", "also"], ["proof (state)\nthis:\n  cmod (t - y) \\<le> cmod t + cmod y\n\ngoal (1 subgoal):\n 1. cmod (t - y) \\<le> 2 * R", "have \"\\<dots> \\<le> R + R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod t + cmod y \\<le> R + R", "by (intro add_mono[OF \\<open>norm t \\<le> R\\<close> R_ge] that)"], ["proof (state)\nthis:\n  cmod t + cmod y \\<le> R + R\n\ngoal (1 subgoal):\n 1. cmod (t - y) \\<le> 2 * R", "finally"], ["proof (chain)\npicking this:\n  cmod (t - y) \\<le> R + R", "show ?thesis"], ["proof (prove)\nusing this:\n  cmod (t - y) \\<le> R + R\n\ngoal (1 subgoal):\n 1. cmod (t - y) \\<le> 2 * R", "by simp"], ["proof (state)\nthis:\n  cmod (t - y) \\<le> 2 * R\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?y \\<in> Roots' \\<Longrightarrow> cmod (t - ?y) \\<le> 2 * R\n\ngoal (2 subgoals):\n 1. 0 \\<le> C p\n 2. \\<And>t.\n       t \\<in> closed_segment 0 \\<alpha> \\<Longrightarrow>\n       cmod (poly (f_poly x) t) \\<le> C p", "have \"norm (poly (f_poly x) t) =\n                      \\<bar>real_of_int l\\<bar> ^ (n * p) * (\\<Prod>y\\<in>Roots'. cmod (t - y) ^ (if y = x then p - 1 else p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cmod (poly (f_poly x) t) =\n    \\<bar>real_of_int l\\<bar> ^ (n * p) *\n    (\\<Prod>y\\<in>Roots'. cmod (t - y) ^ (if y = x then p - 1 else p))", "by (simp add: eval_f x f_def norm_mult norm_power flip: prod_norm)"], ["proof (state)\nthis:\n  cmod (poly (f_poly x) t) =\n  \\<bar>real_of_int l\\<bar> ^ (n * p) *\n  (\\<Prod>y\\<in>Roots'. cmod (t - y) ^ (if y = x then p - 1 else p))\n\ngoal (2 subgoals):\n 1. 0 \\<le> C p\n 2. \\<And>t.\n       t \\<in> closed_segment 0 \\<alpha> \\<Longrightarrow>\n       cmod (poly (f_poly x) t) \\<le> C p", "also"], ["proof (state)\nthis:\n  cmod (poly (f_poly x) t) =\n  \\<bar>real_of_int l\\<bar> ^ (n * p) *\n  (\\<Prod>y\\<in>Roots'. cmod (t - y) ^ (if y = x then p - 1 else p))\n\ngoal (2 subgoals):\n 1. 0 \\<le> C p\n 2. \\<And>t.\n       t \\<in> closed_segment 0 \\<alpha> \\<Longrightarrow>\n       cmod (poly (f_poly x) t) \\<le> C p", "have \"\\<dots> \\<le> \\<bar>real_of_int l\\<bar> ^ (n * p) * (\\<Prod>y\\<in>Roots'. (2*R) ^ (if y = x then p - 1 else p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>real_of_int l\\<bar> ^ (n * p) *\n    (\\<Prod>y\\<in>Roots'. cmod (t - y) ^ (if y = x then p - 1 else p))\n    \\<le> \\<bar>real_of_int l\\<bar> ^ (n * p) *\n          (\\<Prod>y\\<in>Roots'. (2 * R) ^ (if y = x then p - 1 else p))", "by (intro mult_left_mono prod_mono conjI power_mono norm_diff_le) auto"], ["proof (state)\nthis:\n  \\<bar>real_of_int l\\<bar> ^ (n * p) *\n  (\\<Prod>y\\<in>Roots'. cmod (t - y) ^ (if y = x then p - 1 else p))\n  \\<le> \\<bar>real_of_int l\\<bar> ^ (n * p) *\n        (\\<Prod>y\\<in>Roots'. (2 * R) ^ (if y = x then p - 1 else p))\n\ngoal (2 subgoals):\n 1. 0 \\<le> C p\n 2. \\<And>t.\n       t \\<in> closed_segment 0 \\<alpha> \\<Longrightarrow>\n       cmod (poly (f_poly x) t) \\<le> C p", "also"], ["proof (state)\nthis:\n  \\<bar>real_of_int l\\<bar> ^ (n * p) *\n  (\\<Prod>y\\<in>Roots'. cmod (t - y) ^ (if y = x then p - 1 else p))\n  \\<le> \\<bar>real_of_int l\\<bar> ^ (n * p) *\n        (\\<Prod>y\\<in>Roots'. (2 * R) ^ (if y = x then p - 1 else p))\n\ngoal (2 subgoals):\n 1. 0 \\<le> C p\n 2. \\<And>t.\n       t \\<in> closed_segment 0 \\<alpha> \\<Longrightarrow>\n       cmod (poly (f_poly x) t) \\<le> C p", "have \"\\<dots> = \\<bar>real_of_int l\\<bar>^(n*p) * (2^(p-1) * R^(p-1) * (2^p*R^p)^(n-1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>real_of_int l\\<bar> ^ (n * p) *\n    (\\<Prod>y\\<in>Roots'. (2 * R) ^ (if y = x then p - 1 else p)) =\n    \\<bar>real_of_int l\\<bar> ^ (n * p) *\n    (2 ^ (p - 1) * R ^ (p - 1) * (2 ^ p * R ^ p) ^ (n - 1))", "using x"], ["proof (prove)\nusing this:\n  x \\<in> Roots'\n\ngoal (1 subgoal):\n 1. \\<bar>real_of_int l\\<bar> ^ (n * p) *\n    (\\<Prod>y\\<in>Roots'. (2 * R) ^ (if y = x then p - 1 else p)) =\n    \\<bar>real_of_int l\\<bar> ^ (n * p) *\n    (2 ^ (p - 1) * R ^ (p - 1) * (2 ^ p * R ^ p) ^ (n - 1))", "by (subst prod.If_eq) (auto simp: card_Diff_subset n_altdef)"], ["proof (state)\nthis:\n  \\<bar>real_of_int l\\<bar> ^ (n * p) *\n  (\\<Prod>y\\<in>Roots'. (2 * R) ^ (if y = x then p - 1 else p)) =\n  \\<bar>real_of_int l\\<bar> ^ (n * p) *\n  (2 ^ (p - 1) * R ^ (p - 1) * (2 ^ p * R ^ p) ^ (n - 1))\n\ngoal (2 subgoals):\n 1. 0 \\<le> C p\n 2. \\<And>t.\n       t \\<in> closed_segment 0 \\<alpha> \\<Longrightarrow>\n       cmod (poly (f_poly x) t) \\<le> C p", "also"], ["proof (state)\nthis:\n  \\<bar>real_of_int l\\<bar> ^ (n * p) *\n  (\\<Prod>y\\<in>Roots'. (2 * R) ^ (if y = x then p - 1 else p)) =\n  \\<bar>real_of_int l\\<bar> ^ (n * p) *\n  (2 ^ (p - 1) * R ^ (p - 1) * (2 ^ p * R ^ p) ^ (n - 1))\n\ngoal (2 subgoals):\n 1. 0 \\<le> C p\n 2. \\<And>t.\n       t \\<in> closed_segment 0 \\<alpha> \\<Longrightarrow>\n       cmod (poly (f_poly x) t) \\<le> C p", "have \"2^(p-1) * R^(p-1) * (2^p*R^p)^(n-1) = (2^((p-1)+p*(n-1))) * (R^((p-1)+p*(n-1)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (p - 1) * R ^ (p - 1) * (2 ^ p * R ^ p) ^ (n - 1) =\n    2 ^ (p - 1 + p * (n - 1)) * R ^ (p - 1 + p * (n - 1))", "unfolding power_mult power_mult_distrib power_add"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (p - 1) * R ^ (p - 1) * ((2 ^ p) ^ (n - 1) * (R ^ p) ^ (n - 1)) =\n    2 ^ (p - 1) * (2 ^ p) ^ (n - 1) * (R ^ (p - 1) * (R ^ p) ^ (n - 1))", "by (simp add: mult_ac)"], ["proof (state)\nthis:\n  2 ^ (p - 1) * R ^ (p - 1) * (2 ^ p * R ^ p) ^ (n - 1) =\n  2 ^ (p - 1 + p * (n - 1)) * R ^ (p - 1 + p * (n - 1))\n\ngoal (2 subgoals):\n 1. 0 \\<le> C p\n 2. \\<And>t.\n       t \\<in> closed_segment 0 \\<alpha> \\<Longrightarrow>\n       cmod (poly (f_poly x) t) \\<le> C p", "also"], ["proof (state)\nthis:\n  2 ^ (p - 1) * R ^ (p - 1) * (2 ^ p * R ^ p) ^ (n - 1) =\n  2 ^ (p - 1 + p * (n - 1)) * R ^ (p - 1 + p * (n - 1))\n\ngoal (2 subgoals):\n 1. 0 \\<le> C p\n 2. \\<And>t.\n       t \\<in> closed_segment 0 \\<alpha> \\<Longrightarrow>\n       cmod (poly (f_poly x) t) \\<le> C p", "have \"(p-1)+p*(n-1) = p*n - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p - 1 + p * (n - 1) = p * n - 1", "using \\<open>n > 0\\<close> \\<open>p > 1\\<close>"], ["proof (prove)\nusing this:\n  0 < n\n  1 < p\n\ngoal (1 subgoal):\n 1. p - 1 + p * (n - 1) = p * n - 1", "by (cases n) (auto simp: algebra_simps)"], ["proof (state)\nthis:\n  p - 1 + p * (n - 1) = p * n - 1\n\ngoal (2 subgoals):\n 1. 0 \\<le> C p\n 2. \\<And>t.\n       t \\<in> closed_segment 0 \\<alpha> \\<Longrightarrow>\n       cmod (poly (f_poly x) t) \\<le> C p", "also"], ["proof (state)\nthis:\n  p - 1 + p * (n - 1) = p * n - 1\n\ngoal (2 subgoals):\n 1. 0 \\<le> C p\n 2. \\<And>t.\n       t \\<in> closed_segment 0 \\<alpha> \\<Longrightarrow>\n       cmod (poly (f_poly x) t) \\<le> C p", "have \"2 ^ (p * n - 1) * R ^ (p * n - 1) = (2*R)^(n * p-1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (p * n - 1) * R ^ (p * n - 1) = (2 * R) ^ (n * p - 1)", "unfolding power_mult_distrib"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 ^ (p * n - 1) * R ^ (p * n - 1) = 2 ^ (n * p - 1) * R ^ (n * p - 1)", "by (simp add: mult_ac)"], ["proof (state)\nthis:\n  2 ^ (p * n - 1) * R ^ (p * n - 1) = (2 * R) ^ (n * p - 1)\n\ngoal (2 subgoals):\n 1. 0 \\<le> C p\n 2. \\<And>t.\n       t \\<in> closed_segment 0 \\<alpha> \\<Longrightarrow>\n       cmod (poly (f_poly x) t) \\<le> C p", "finally"], ["proof (chain)\npicking this:\n  cmod (poly (f_poly x) t)\n  \\<le> \\<bar>real_of_int l\\<bar> ^ (n * p) * (2 * R) ^ (n * p - 1)", "show \"norm (poly (f_poly x) t) \\<le> C p\""], ["proof (prove)\nusing this:\n  cmod (poly (f_poly x) t)\n  \\<le> \\<bar>real_of_int l\\<bar> ^ (n * p) * (2 * R) ^ (n * p - 1)\n\ngoal (1 subgoal):\n 1. cmod (poly (f_poly x) t) \\<le> C p", "unfolding C_def"], ["proof (prove)\nusing this:\n  cmod (poly (f_poly x) t)\n  \\<le> \\<bar>real_of_int l\\<bar> ^ (n * p) * (2 * R) ^ (n * p - 1)\n\ngoal (1 subgoal):\n 1. cmod (poly (f_poly x) t)\n    \\<le> real_of_int (l ^ (n * p)) * (2 * R) ^ (n * p - 1)", "using \\<open>l > 0\\<close>"], ["proof (prove)\nusing this:\n  cmod (poly (f_poly x) t)\n  \\<le> \\<bar>real_of_int l\\<bar> ^ (n * p) * (2 * R) ^ (n * p - 1)\n  0 < l\n\ngoal (1 subgoal):\n 1. cmod (poly (f_poly x) t)\n    \\<le> real_of_int (l ^ (n * p)) * (2 * R) ^ (n * p - 1)", "by simp"], ["proof (state)\nthis:\n  cmod (poly (f_poly x) t) \\<le> C p\n\ngoal (1 subgoal):\n 1. 0 \\<le> C p", "qed (use \\<open>R \\<ge> 0\\<close> \\<open>l > 0\\<close> in \\<open>auto simp: C_def\\<close>)"], ["proof (state)\nthis:\n  cmod (I x \\<alpha>) \\<le> cmod \\<alpha> * exp (cmod \\<alpha>) * C p\n\ngoal (1 subgoal):\n 1. 0 \\<le> \\<bar>real_of_int (\\<beta> q)\\<bar>", "qed auto"], ["proof (state)\nthis:\n  cmod (of_int (\\<beta> q) * sum (I x) (Roots q))\n  \\<le> real_of_int \\<bar>\\<beta> q\\<bar> *\n        (\\<Sum>\\<alpha>\\<in>Roots q.\n           cmod \\<alpha> * exp (cmod \\<alpha>) * C p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cmod (J x)\n  \\<le> (\\<Sum>q\\<in>P.\n           real_of_int \\<bar>\\<beta> q\\<bar> *\n           (\\<Sum>\\<alpha>\\<in>Roots q.\n              cmod \\<alpha> * exp (cmod \\<alpha>) * C p))\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> Roots' \\<Longrightarrow> 0 \\<le> cmod (J i)", "qed auto"], ["proof (state)\nthis:\n  (\\<Prod>x\\<in>Roots'. cmod (J x))\n  \\<le> (\\<Prod>x\\<in>Roots'.\n           \\<Sum>q\\<in>P.\n             real_of_int \\<bar>\\<beta> q\\<bar> *\n             (\\<Sum>\\<alpha>\\<in>Roots q.\n                cmod \\<alpha> * exp (cmod \\<alpha>) * C p))\n\ngoal (1 subgoal):\n 1. cmod J' \\<le> C' * C p ^ n", "also"], ["proof (state)\nthis:\n  (\\<Prod>x\\<in>Roots'. cmod (J x))\n  \\<le> (\\<Prod>x\\<in>Roots'.\n           \\<Sum>q\\<in>P.\n             real_of_int \\<bar>\\<beta> q\\<bar> *\n             (\\<Sum>\\<alpha>\\<in>Roots q.\n                cmod \\<alpha> * exp (cmod \\<alpha>) * C p))\n\ngoal (1 subgoal):\n 1. cmod J' \\<le> C' * C p ^ n", "have \"\\<dots> = C' * C p ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<in>Roots'.\n       \\<Sum>q\\<in>P.\n         real_of_int \\<bar>\\<beta> q\\<bar> *\n         (\\<Sum>\\<alpha>\\<in>Roots q.\n            cmod \\<alpha> * exp (cmod \\<alpha>) * C p)) =\n    C' * C p ^ n", "by (simp add: C'_def power_mult_distrib n_altdef flip: sum_distrib_right mult.assoc)"], ["proof (state)\nthis:\n  (\\<Prod>x\\<in>Roots'.\n     \\<Sum>q\\<in>P.\n       real_of_int \\<bar>\\<beta> q\\<bar> *\n       (\\<Sum>\\<alpha>\\<in>Roots q.\n          cmod \\<alpha> * exp (cmod \\<alpha>) * C p)) =\n  C' * C p ^ n\n\ngoal (1 subgoal):\n 1. cmod J' \\<le> C' * C p ^ n", "finally"], ["proof (chain)\npicking this:\n  cmod J' \\<le> C' * C p ^ n", "show ?thesis"], ["proof (prove)\nusing this:\n  cmod J' \\<le> C' * C p ^ n\n\ngoal (1 subgoal):\n 1. cmod J' \\<le> C' * C p ^ n", "."], ["proof (state)\nthis:\n  cmod J' \\<le> C' * C p ^ n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cmod J' \\<le> C' * C p ^ n\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> C' * C p ^ n", "text \\<open>And with that, we have our inequality:\\<close>"], ["proof (state)\nthis:\n  cmod J' \\<le> C' * C p ^ n\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> C' * C p ^ n", "finally"], ["proof (chain)\npicking this:\n  fact (p - 1) ^ n \\<le> C' * C p ^ n", "show \"fact (p - 1) ^ n \\<le> C' * C p ^ n\""], ["proof (prove)\nusing this:\n  fact (p - 1) ^ n \\<le> C' * C p ^ n\n\ngoal (1 subgoal):\n 1. fact (p - 1) ^ n \\<le> C' * C p ^ n", "."], ["proof (state)\nthis:\n  fact (p - 1) ^ n \\<le> C' * C p ^ n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>prime ?p; \\<forall>q\\<in>P. \\<bar>\\<beta> q\\<bar> < int ?p;\n   cmod\n    (\\<Prod>\\<alpha>\\<in>Roots'.\n       of_int (l ^ n) * prod ((-) \\<alpha>) (Roots' - {\\<alpha>}))\n   < real ?p\\<rbrakk>\n  \\<Longrightarrow> fact (?p - 1) ^ n \\<le> C' * C ?p ^ n\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "text \\<open>\n    Some simple asymptotic estimates show that this is clearly a contradiction, since\n    the left-hand side grows much faster than the right-hand side and there are infinitely many\n    sufficiently large primes:\n  \\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>prime ?p; \\<forall>q\\<in>P. \\<bar>\\<beta> q\\<bar> < int ?p;\n   cmod\n    (\\<Prod>\\<alpha>\\<in>Roots'.\n       of_int (l ^ n) * prod ((-) \\<alpha>) (Roots' - {\\<alpha>}))\n   < real ?p\\<rbrakk>\n  \\<Longrightarrow> fact (?p - 1) ^ n \\<le> C' * C ?p ^ n\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "have freq: \"frequently prime sequentially\""], ["proof (prove)\ngoal (1 subgoal):\n 1. frequently prime sequentially", "using frequently_prime_cofinite"], ["proof (prove)\nusing this:\n  Inf_many prime\n\ngoal (1 subgoal):\n 1. frequently prime sequentially", "unfolding cofinite_eq_sequentially"], ["proof (prove)\nusing this:\n  frequently prime sequentially\n\ngoal (1 subgoal):\n 1. frequently prime sequentially", "."], ["proof (state)\nthis:\n  frequently prime sequentially\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "have ev: \"eventually (\\<lambda>p. (\\<forall>q\\<in>P.  int p > \\<bar>\\<beta> q\\<bar>) \\<and>\n              real p > norm (\\<Prod>\\<alpha>\\<in>Roots'. of_int (l^n) * (\\<Prod>\\<alpha>'\\<in>Roots'-{\\<alpha>}. (\\<alpha>-\\<alpha>')))) sequentially\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F p in sequentially.\n       (\\<forall>q\\<in>P. \\<bar>\\<beta> q\\<bar> < int p) \\<and>\n       cmod\n        (\\<Prod>\\<alpha>\\<in>Roots'.\n           of_int (l ^ n) * prod ((-) \\<alpha>) (Roots' - {\\<alpha>}))\n       < real p", "by (intro eventually_ball_finite \\<open>finite P\\<close> ballI eventually_conj filterlim_real_sequentially\n          eventually_compose_filterlim[OF eventually_gt_at_top] filterlim_int_sequentially)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F p in sequentially.\n     (\\<forall>q\\<in>P. \\<bar>\\<beta> q\\<bar> < int p) \\<and>\n     cmod\n      (\\<Prod>\\<alpha>\\<in>Roots'.\n         of_int (l ^ n) * prod ((-) \\<alpha>) (Roots' - {\\<alpha>}))\n     < real p\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "have \"frequently (\\<lambda>p. fact (p - 1) ^ n \\<le> C' * C p ^ n) sequentially\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<^sub>F p in sequentially. fact (p - 1) ^ n \\<le> C' * C p ^ n", "by (rule frequently_eventually_mono[OF freq ev]) (use ineq in blast)"], ["proof (state)\nthis:\n  \\<exists>\\<^sub>F p in sequentially. fact (p - 1) ^ n \\<le> C' * C p ^ n\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  \\<exists>\\<^sub>F p in sequentially. fact (p - 1) ^ n \\<le> C' * C p ^ n\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "have \"eventually (\\<lambda>p. fact (p - 1) ^ n > C' * C p ^ n) sequentially\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F p in sequentially. C' * C p ^ n < fact (p - 1) ^ n", "proof (cases \"R = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. R = 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F p in sequentially. C' * C p ^ n < fact (p - 1) ^ n\n 2. R \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F p in sequentially. C' * C p ^ n < fact (p - 1) ^ n", "case True"], ["proof (state)\nthis:\n  R = 0\n\ngoal (2 subgoals):\n 1. R = 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F p in sequentially. C' * C p ^ n < fact (p - 1) ^ n\n 2. R \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F p in sequentially. C' * C p ^ n < fact (p - 1) ^ n", "have \"eventually (\\<lambda>p. p * n > 1) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F p in sequentially. 1 < p * n", "using \\<open>n > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F p in sequentially. 1 < p * n", "by (intro eventually_compose_filterlim[OF eventually_gt_at_top] mult_nat_right_at_top)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F p in sequentially. 1 < p * n\n\ngoal (2 subgoals):\n 1. R = 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F p in sequentially. C' * C p ^ n < fact (p - 1) ^ n\n 2. R \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F p in sequentially. C' * C p ^ n < fact (p - 1) ^ n", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F p in sequentially. 1 < p * n\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F p in sequentially. C' * C p ^ n < fact (p - 1) ^ n", "by eventually_elim (use \\<open>n > 0\\<close> True in \\<open>auto simp: C_def power_0_left mult_ac\\<close>)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F p in sequentially. C' * C p ^ n < fact (p - 1) ^ n\n\ngoal (1 subgoal):\n 1. R \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F p in sequentially. C' * C p ^ n < fact (p - 1) ^ n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. R \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F p in sequentially. C' * C p ^ n < fact (p - 1) ^ n", "case False"], ["proof (state)\nthis:\n  R \\<noteq> 0\n\ngoal (1 subgoal):\n 1. R \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F p in sequentially. C' * C p ^ n < fact (p - 1) ^ n", "hence \"R > 0\""], ["proof (prove)\nusing this:\n  R \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 < R", "using \\<open>R \\<ge> 0\\<close>"], ["proof (prove)\nusing this:\n  R \\<noteq> 0\n  0 \\<le> R\n\ngoal (1 subgoal):\n 1. 0 < R", "by auto"], ["proof (state)\nthis:\n  0 < R\n\ngoal (1 subgoal):\n 1. R \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F p in sequentially. C' * C p ^ n < fact (p - 1) ^ n", "define D :: real where \"D = (2 * R * \\<bar>real_of_int l\\<bar>) ^ n\""], ["proof (state)\nthis:\n  D = (2 * R * \\<bar>real_of_int l\\<bar>) ^ n\n\ngoal (1 subgoal):\n 1. R \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F p in sequentially. C' * C p ^ n < fact (p - 1) ^ n", "have \"D > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < D", "using \\<open>R > 0\\<close> \\<open>l > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < R\n  0 < l\n\ngoal (1 subgoal):\n 1. 0 < D", "unfolding D_def"], ["proof (prove)\nusing this:\n  0 < R\n  0 < l\n\ngoal (1 subgoal):\n 1. 0 < (2 * R * \\<bar>real_of_int l\\<bar>) ^ n", "by (intro zero_less_power) auto"], ["proof (state)\nthis:\n  0 < D\n\ngoal (1 subgoal):\n 1. R \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F p in sequentially. C' * C p ^ n < fact (p - 1) ^ n", "have \"(\\<lambda>p. C' * C p ^ n) \\<in> O(\\<lambda>p. C p ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>p. C' * C p ^ n) \\<in> O(\\<lambda>p. C p ^ n)", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>p. C' * C p ^ n) \\<in> O(\\<lambda>p. C p ^ n)\n\ngoal (1 subgoal):\n 1. R \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F p in sequentially. C' * C p ^ n < fact (p - 1) ^ n", "also"], ["proof (state)\nthis:\n  (\\<lambda>p. C' * C p ^ n) \\<in> O(\\<lambda>p. C p ^ n)\n\ngoal (1 subgoal):\n 1. R \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F p in sequentially. C' * C p ^ n < fact (p - 1) ^ n", "have \"(\\<lambda>p. C p ^ n) \\<in> O(\\<lambda>p. ((2 * R * l) ^ (n * p)) ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>p. C p ^ n)\n    \\<in> O(\\<lambda>p. ((2 * R * real_of_int l) ^ (n * p)) ^ n)", "proof (rule landau_o.big_power[OF bigthetaD1])"], ["proof (state)\ngoal (1 subgoal):\n 1. C \\<in> \\<Theta>(\\<lambda>x. (2 * R * real_of_int l) ^ (n * x))", "have np: \"eventually (\\<lambda>p. p * n > 0) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F p in sequentially. 0 < p * n", "using \\<open>n > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F p in sequentially. 0 < p * n", "by (intro eventually_compose_filterlim[OF eventually_gt_at_top] mult_nat_right_at_top)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F p in sequentially. 0 < p * n\n\ngoal (1 subgoal):\n 1. C \\<in> \\<Theta>(\\<lambda>x. (2 * R * real_of_int l) ^ (n * x))", "have \"eventually (\\<lambda>p. (2 * R) * C p = (2 * R * l) ^ (n * p)) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F p in sequentially.\n       2 * R * C p = (2 * R * real_of_int l) ^ (n * p)", "using np"], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F p in sequentially. 0 < p * n\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F p in sequentially.\n       2 * R * C p = (2 * R * real_of_int l) ^ (n * p)", "proof eventually_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       0 < p * n \\<Longrightarrow>\n       2 * R * C p = (2 * R * real_of_int l) ^ (n * p)", "case (elim p)"], ["proof (state)\nthis:\n  0 < p * n\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       0 < p * n \\<Longrightarrow>\n       2 * R * C p = (2 * R * real_of_int l) ^ (n * p)", "have \"2 * R * C p = l ^ (n * p) * (2 * R) ^ (Suc (n * p - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 2 * R * C p = real_of_int (l ^ (n * p)) * (2 * R) ^ Suc (n * p - 1)", "by (simp add: C_def algebra_simps)"], ["proof (state)\nthis:\n  2 * R * C p = real_of_int (l ^ (n * p)) * (2 * R) ^ Suc (n * p - 1)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       0 < p * n \\<Longrightarrow>\n       2 * R * C p = (2 * R * real_of_int l) ^ (n * p)", "also"], ["proof (state)\nthis:\n  2 * R * C p = real_of_int (l ^ (n * p)) * (2 * R) ^ Suc (n * p - 1)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       0 < p * n \\<Longrightarrow>\n       2 * R * C p = (2 * R * real_of_int l) ^ (n * p)", "have \"Suc (n * p - 1) = n * p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (n * p - 1) = n * p", "using elim"], ["proof (prove)\nusing this:\n  0 < p * n\n\ngoal (1 subgoal):\n 1. Suc (n * p - 1) = n * p", "by auto"], ["proof (state)\nthis:\n  Suc (n * p - 1) = n * p\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       0 < p * n \\<Longrightarrow>\n       2 * R * C p = (2 * R * real_of_int l) ^ (n * p)", "finally"], ["proof (chain)\npicking this:\n  2 * R * C p = real_of_int (l ^ (n * p)) * (2 * R) ^ (n * p)", "show ?case"], ["proof (prove)\nusing this:\n  2 * R * C p = real_of_int (l ^ (n * p)) * (2 * R) ^ (n * p)\n\ngoal (1 subgoal):\n 1. 2 * R * C p = (2 * R * real_of_int l) ^ (n * p)", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  2 * R * C p = (2 * R * real_of_int l) ^ (n * p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F p in sequentially.\n     2 * R * C p = (2 * R * real_of_int l) ^ (n * p)\n\ngoal (1 subgoal):\n 1. C \\<in> \\<Theta>(\\<lambda>x. (2 * R * real_of_int l) ^ (n * x))", "hence \"(\\<lambda>p. (2 * R) * C p) \\<in> \\<Theta>(\\<lambda>p. (2 * R * l) ^ (n * p))\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F p in sequentially.\n     2 * R * C p = (2 * R * real_of_int l) ^ (n * p)\n\ngoal (1 subgoal):\n 1. (\\<lambda>p. 2 * R * C p)\n    \\<in> \\<Theta>(\\<lambda>p. (2 * R * real_of_int l) ^ (n * p))", "by (intro bigthetaI_cong)"], ["proof (state)\nthis:\n  (\\<lambda>p. 2 * R * C p)\n  \\<in> \\<Theta>(\\<lambda>p. (2 * R * real_of_int l) ^ (n * p))\n\ngoal (1 subgoal):\n 1. C \\<in> \\<Theta>(\\<lambda>x. (2 * R * real_of_int l) ^ (n * x))", "thus \"C \\<in> \\<Theta>(\\<lambda>p. (2 * R * l) ^ (n * p))\""], ["proof (prove)\nusing this:\n  (\\<lambda>p. 2 * R * C p)\n  \\<in> \\<Theta>(\\<lambda>p. (2 * R * real_of_int l) ^ (n * p))\n\ngoal (1 subgoal):\n 1. C \\<in> \\<Theta>(\\<lambda>p. (2 * R * real_of_int l) ^ (n * p))", "using \\<open>R > 0\\<close>"], ["proof (prove)\nusing this:\n  (\\<lambda>p. 2 * R * C p)\n  \\<in> \\<Theta>(\\<lambda>p. (2 * R * real_of_int l) ^ (n * p))\n  0 < R\n\ngoal (1 subgoal):\n 1. C \\<in> \\<Theta>(\\<lambda>p. (2 * R * real_of_int l) ^ (n * p))", "by simp"], ["proof (state)\nthis:\n  C \\<in> \\<Theta>(\\<lambda>p. (2 * R * real_of_int l) ^ (n * p))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>p. C p ^ n)\n  \\<in> O(\\<lambda>p. ((2 * R * real_of_int l) ^ (n * p)) ^ n)\n\ngoal (1 subgoal):\n 1. R \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F p in sequentially. C' * C p ^ n < fact (p - 1) ^ n", "also"], ["proof (state)\nthis:\n  (\\<lambda>p. C p ^ n)\n  \\<in> O(\\<lambda>p. ((2 * R * real_of_int l) ^ (n * p)) ^ n)\n\ngoal (1 subgoal):\n 1. R \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F p in sequentially. C' * C p ^ n < fact (p - 1) ^ n", "have \"\\<dots> = O(\\<lambda>p. (D ^ p) ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. O(\\<lambda>p. ((2 * R * real_of_int l) ^ (n * p)) ^ n) =\n    O(\\<lambda>p. (D ^ p) ^ n)", "using \\<open>l > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < l\n\ngoal (1 subgoal):\n 1. O(\\<lambda>p. ((2 * R * real_of_int l) ^ (n * p)) ^ n) =\n    O(\\<lambda>p. (D ^ p) ^ n)", "by (simp flip: power_mult add: power2_eq_square mult_ac D_def)"], ["proof (state)\nthis:\n  O(\\<lambda>p. ((2 * R * real_of_int l) ^ (n * p)) ^ n) =\n  O(\\<lambda>p. (D ^ p) ^ n)\n\ngoal (1 subgoal):\n 1. R \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F p in sequentially. C' * C p ^ n < fact (p - 1) ^ n", "also"], ["proof (state)\nthis:\n  O(\\<lambda>p. ((2 * R * real_of_int l) ^ (n * p)) ^ n) =\n  O(\\<lambda>p. (D ^ p) ^ n)\n\ngoal (1 subgoal):\n 1. R \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F p in sequentially. C' * C p ^ n < fact (p - 1) ^ n", "have \"(\\<lambda>p. (D ^ p) ^ n) \\<in> o(\\<lambda>p. fact (p - 1) ^ n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>p. (D ^ p) ^ n) \\<in> o(\\<lambda>p. fact (p - 1) ^ n)", "proof (intro landau_o.small_power)"], ["proof (state)\ngoal (2 subgoals):\n 1. (^) D \\<in> o(\\<lambda>x. fact (x - 1))\n 2. 0 < n", "have \"eventually (\\<lambda>p. D ^ p = D * D ^ (p - 1)) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F p in sequentially. D ^ p = D * D ^ (p - 1)", "using eventually_gt_at_top[of 0]"], ["proof (prove)\nusing this:\n  eventually ((<) (0::?'a1)) at_top\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F p in sequentially. D ^ p = D * D ^ (p - 1)", "by eventually_elim (use \\<open>D > 0\\<close> in \\<open>auto simp flip: power_Suc\\<close>)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F p in sequentially. D ^ p = D * D ^ (p - 1)\n\ngoal (2 subgoals):\n 1. (^) D \\<in> o(\\<lambda>x. fact (x - 1))\n 2. 0 < n", "hence \"(\\<lambda>p. D ^ p) \\<in> \\<Theta>(\\<lambda>p. D * D ^ (p - 1))\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F p in sequentially. D ^ p = D * D ^ (p - 1)\n\ngoal (1 subgoal):\n 1. (^) D \\<in> \\<Theta>(\\<lambda>p. D * D ^ (p - 1))", "by (intro bigthetaI_cong)"], ["proof (state)\nthis:\n  (^) D \\<in> \\<Theta>(\\<lambda>p. D * D ^ (p - 1))\n\ngoal (2 subgoals):\n 1. (^) D \\<in> o(\\<lambda>x. fact (x - 1))\n 2. 0 < n", "hence \"(\\<lambda>p. D ^ p) \\<in> \\<Theta>(\\<lambda>p. D ^ (p - 1))\""], ["proof (prove)\nusing this:\n  (^) D \\<in> \\<Theta>(\\<lambda>p. D * D ^ (p - 1))\n\ngoal (1 subgoal):\n 1. (^) D \\<in> \\<Theta>(\\<lambda>p. D ^ (p - 1))", "using \\<open>D > 0\\<close>"], ["proof (prove)\nusing this:\n  (^) D \\<in> \\<Theta>(\\<lambda>p. D * D ^ (p - 1))\n  0 < D\n\ngoal (1 subgoal):\n 1. (^) D \\<in> \\<Theta>(\\<lambda>p. D ^ (p - 1))", "by simp"], ["proof (state)\nthis:\n  (^) D \\<in> \\<Theta>(\\<lambda>p. D ^ (p - 1))\n\ngoal (2 subgoals):\n 1. (^) D \\<in> o(\\<lambda>x. fact (x - 1))\n 2. 0 < n", "also"], ["proof (state)\nthis:\n  (^) D \\<in> \\<Theta>(\\<lambda>p. D ^ (p - 1))\n\ngoal (2 subgoals):\n 1. (^) D \\<in> o(\\<lambda>x. fact (x - 1))\n 2. 0 < n", "have \"(\\<lambda>p. D ^ (p - 1)) \\<in> o(\\<lambda>p. fact (p - 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>p. D ^ (p - 1)) \\<in> o(\\<lambda>p. fact (p - 1))", "by (intro smalloI_tendsto[OF filterlim_compose[OF power_over_fact_tendsto_0]]\n                  filterlim_minus_nat_at_top) auto"], ["proof (state)\nthis:\n  (\\<lambda>p. D ^ (p - 1)) \\<in> o(\\<lambda>p. fact (p - 1))\n\ngoal (2 subgoals):\n 1. (^) D \\<in> o(\\<lambda>x. fact (x - 1))\n 2. 0 < n", "finally"], ["proof (chain)\npicking this:\n  (^) D \\<in> o(\\<lambda>p. fact (p - 1))", "show \"(\\<lambda>p. D ^ p) \\<in> o(\\<lambda>x. fact (x - 1))\""], ["proof (prove)\nusing this:\n  (^) D \\<in> o(\\<lambda>p. fact (p - 1))\n\ngoal (1 subgoal):\n 1. (^) D \\<in> o(\\<lambda>x. fact (x - 1))", "."], ["proof (state)\nthis:\n  (^) D \\<in> o(\\<lambda>x. fact (x - 1))\n\ngoal (1 subgoal):\n 1. 0 < n", "qed fact+"], ["proof (state)\nthis:\n  (\\<lambda>p. (D ^ p) ^ n) \\<in> o(\\<lambda>p. fact (p - 1) ^ n)\n\ngoal (1 subgoal):\n 1. R \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F p in sequentially. C' * C p ^ n < fact (p - 1) ^ n", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>p. C' * C p ^ n) \\<in> o(\\<lambda>p. fact (p - 1) ^ n)", "have smallo: \"(\\<lambda>p. C' * C p ^ n) \\<in> o(\\<lambda>p. fact (p - 1) ^ n)\""], ["proof (prove)\nusing this:\n  (\\<lambda>p. C' * C p ^ n) \\<in> o(\\<lambda>p. fact (p - 1) ^ n)\n\ngoal (1 subgoal):\n 1. (\\<lambda>p. C' * C p ^ n) \\<in> o(\\<lambda>p. fact (p - 1) ^ n)", "."], ["proof (state)\nthis:\n  (\\<lambda>p. C' * C p ^ n) \\<in> o(\\<lambda>p. fact (p - 1) ^ n)\n\ngoal (1 subgoal):\n 1. R \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F p in sequentially. C' * C p ^ n < fact (p - 1) ^ n", "have \"eventually (\\<lambda>p. \\<bar>C' * C p ^ n\\<bar> \\<le> 1/2 * fact (p - 1) ^ n) at_top\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F p in sequentially.\n       \\<bar>C' * C p ^ n\\<bar> \\<le> 1 / 2 * fact (p - 1) ^ n", "using landau_o.smallD[OF smallo, of \"1/2\"]"], ["proof (prove)\nusing this:\n  0 < 1 / 2 \\<Longrightarrow>\n  \\<forall>\\<^sub>F x in sequentially.\n     norm (C' * C x ^ n) \\<le> 1 / 2 * norm (fact (x - 1) ^ n)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F p in sequentially.\n       \\<bar>C' * C p ^ n\\<bar> \\<le> 1 / 2 * fact (p - 1) ^ n", "by simp"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F p in sequentially.\n     \\<bar>C' * C p ^ n\\<bar> \\<le> 1 / 2 * fact (p - 1) ^ n\n\ngoal (1 subgoal):\n 1. R \\<noteq> 0 \\<Longrightarrow>\n    \\<forall>\\<^sub>F p in sequentially. C' * C p ^ n < fact (p - 1) ^ n", "thus \"eventually (\\<lambda>p. C' * C p ^ n < fact (p - 1) ^ n) at_top\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>F p in sequentially.\n     \\<bar>C' * C p ^ n\\<bar> \\<le> 1 / 2 * fact (p - 1) ^ n\n\ngoal (1 subgoal):\n 1. \\<forall>\\<^sub>F p in sequentially. C' * C p ^ n < fact (p - 1) ^ n", "proof eventually_elim"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<bar>C' * C p ^ n\\<bar>\n       \\<le> 1 / 2 * fact (p - 1) ^ n \\<Longrightarrow>\n       C' * C p ^ n < fact (p - 1) ^ n", "case (elim p)"], ["proof (state)\nthis:\n  \\<bar>C' * C p ^ n\\<bar> \\<le> 1 / 2 * fact (p - 1) ^ n\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<bar>C' * C p ^ n\\<bar>\n       \\<le> 1 / 2 * fact (p - 1) ^ n \\<Longrightarrow>\n       C' * C p ^ n < fact (p - 1) ^ n", "have \"C' * C p ^ n \\<le> \\<bar>C' * C p ^ n\\<bar>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C' * C p ^ n \\<le> \\<bar>C' * C p ^ n\\<bar>", "by simp"], ["proof (state)\nthis:\n  C' * C p ^ n \\<le> \\<bar>C' * C p ^ n\\<bar>\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<bar>C' * C p ^ n\\<bar>\n       \\<le> 1 / 2 * fact (p - 1) ^ n \\<Longrightarrow>\n       C' * C p ^ n < fact (p - 1) ^ n", "also"], ["proof (state)\nthis:\n  C' * C p ^ n \\<le> \\<bar>C' * C p ^ n\\<bar>\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<bar>C' * C p ^ n\\<bar>\n       \\<le> 1 / 2 * fact (p - 1) ^ n \\<Longrightarrow>\n       C' * C p ^ n < fact (p - 1) ^ n", "have \"\\<dots> \\<le> 1/2 * fact (p - 1) ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bar>C' * C p ^ n\\<bar> \\<le> 1 / 2 * fact (p - 1) ^ n", "by fact"], ["proof (state)\nthis:\n  \\<bar>C' * C p ^ n\\<bar> \\<le> 1 / 2 * fact (p - 1) ^ n\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<bar>C' * C p ^ n\\<bar>\n       \\<le> 1 / 2 * fact (p - 1) ^ n \\<Longrightarrow>\n       C' * C p ^ n < fact (p - 1) ^ n", "also"], ["proof (state)\nthis:\n  \\<bar>C' * C p ^ n\\<bar> \\<le> 1 / 2 * fact (p - 1) ^ n\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<bar>C' * C p ^ n\\<bar>\n       \\<le> 1 / 2 * fact (p - 1) ^ n \\<Longrightarrow>\n       C' * C p ^ n < fact (p - 1) ^ n", "have \"\\<dots> < fact (p - 1) ^ n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 / 2 * fact (p - 1) ^ n < fact (p - 1) ^ n", "by simp"], ["proof (state)\nthis:\n  1 / 2 * fact (p - 1) ^ n < fact (p - 1) ^ n\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<bar>C' * C p ^ n\\<bar>\n       \\<le> 1 / 2 * fact (p - 1) ^ n \\<Longrightarrow>\n       C' * C p ^ n < fact (p - 1) ^ n", "finally"], ["proof (chain)\npicking this:\n  C' * C p ^ n < fact (p - 1) ^ n", "show ?case"], ["proof (prove)\nusing this:\n  C' * C p ^ n < fact (p - 1) ^ n\n\ngoal (1 subgoal):\n 1. C' * C p ^ n < fact (p - 1) ^ n", "."], ["proof (state)\nthis:\n  C' * C p ^ n < fact (p - 1) ^ n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F p in sequentially. C' * C p ^ n < fact (p - 1) ^ n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>F p in sequentially. C' * C p ^ n < fact (p - 1) ^ n\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>\\<^sub>F p in sequentially. fact (p - 1) ^ n \\<le> C' * C p ^ n\n  \\<forall>\\<^sub>F p in sequentially. C' * C p ^ n < fact (p - 1) ^ n", "have \"frequently (\\<lambda>p::nat. False) sequentially\""], ["proof (prove)\nusing this:\n  \\<exists>\\<^sub>F p in sequentially. fact (p - 1) ^ n \\<le> C' * C p ^ n\n  \\<forall>\\<^sub>F p in sequentially. C' * C p ^ n < fact (p - 1) ^ n\n\ngoal (1 subgoal):\n 1. \\<exists>\\<^sub>F p in sequentially. False", "by (rule frequently_eventually_mono) auto"], ["proof (state)\nthis:\n  \\<exists>\\<^sub>F p in sequentially. False\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>P. of_int (\\<beta> p) * sum exp (Roots p)) =\n    0 \\<Longrightarrow>\n    False", "thus False"], ["proof (prove)\nusing this:\n  \\<exists>\\<^sub>F p in sequentially. False\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Removing the restriction of full sets of conjugates\\<close>"], ["", "text \\<open>\n  We will now remove the restriction that the $\\alpha_i$ must occur in full sets of conjugates\n  by multiplying the equality with all permutations of roots.\n\\<close>"], ["", "lemma Hermite_Lindemann_aux2:\n  fixes X :: \"complex set\" and \\<beta> :: \"complex \\<Rightarrow> int\"\n  assumes \"finite X\"\n  assumes nz:   \"\\<And>x. x \\<in> X \\<Longrightarrow> \\<beta> x \\<noteq> 0\"\n  assumes alg:  \"\\<And>x. x \\<in> X \\<Longrightarrow> algebraic x\"\n  assumes sum0: \"(\\<Sum>x\\<in>X. of_int (\\<beta> x) * exp x) = 0\"\n  shows   \"X = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X = {}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "assume \"X \\<noteq> {}\""], ["proof (state)\nthis:\n  X \\<noteq> {}\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "note [intro] = \\<open>finite X\\<close>"], ["proof (state)\nthis:\n  finite X\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "text \\<open>\n    Let \\<open>P\\<close> be the smallest integer polynomial whose roots are a superset of \\<open>X\\<close>:\n  \\<close>"], ["proof (state)\nthis:\n  finite X\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "define P :: \"int poly\" where \"P = \\<Prod>(min_int_poly ` X)\""], ["proof (state)\nthis:\n  P = \\<Prod>(min_int_poly ` X)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "define Roots :: \"complex set\" where \"Roots = {x. ipoly P x = 0}\""], ["proof (state)\nthis:\n  Roots = {x. ipoly P x = 0}\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have [simp]: \"P \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<noteq> 0", "using \\<open>finite X\\<close>"], ["proof (prove)\nusing this:\n  finite X\n\ngoal (1 subgoal):\n 1. P \\<noteq> 0", "by (auto simp: P_def)"], ["proof (state)\nthis:\n  P \\<noteq> 0\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have [intro]: \"finite Roots\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite Roots", "unfolding Roots_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. ipoly P x = 0}", "by (intro poly_roots_finite) auto"], ["proof (state)\nthis:\n  finite Roots\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have \"X \\<subseteq> Roots\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<subseteq> Roots", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> x \\<in> Roots", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> x \\<in> Roots", "assume \"x \\<in> X\""], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> x \\<in> Roots", "hence \"ipoly (min_int_poly x) x = 0\""], ["proof (prove)\nusing this:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. ipoly (min_int_poly x) x = 0", "by (intro ipoly_min_int_poly alg)"], ["proof (state)\nthis:\n  ipoly (min_int_poly x) x = 0\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> X \\<Longrightarrow> x \\<in> Roots", "thus \"x \\<in> Roots\""], ["proof (prove)\nusing this:\n  ipoly (min_int_poly x) x = 0\n\ngoal (1 subgoal):\n 1. x \\<in> Roots", "using \\<open>finite X\\<close> \\<open>x \\<in> X\\<close>"], ["proof (prove)\nusing this:\n  ipoly (min_int_poly x) x = 0\n  finite X\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. x \\<in> Roots", "by (auto simp: Roots_def P_def of_int_poly_hom.hom_prod poly_prod)"], ["proof (state)\nthis:\n  x \\<in> Roots\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  X \\<subseteq> Roots\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have \"squarefree (of_int_poly P :: complex poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. squarefree (Ring_Hom_Poly.of_int_poly P)", "unfolding P_def of_int_poly_hom.hom_prod"], ["proof (prove)\ngoal (1 subgoal):\n 1. squarefree (prod Ring_Hom_Poly.of_int_poly (min_int_poly ` X))", "proof (rule squarefree_prod_coprime; safe)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b x xa.\n       \\<lbrakk>min_int_poly x \\<noteq> min_int_poly xa; x \\<in> X;\n        xa \\<in> X\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime\n                          (Ring_Hom_Poly.of_int_poly (min_int_poly x))\n                          (Ring_Hom_Poly.of_int_poly (min_int_poly xa))\n 2. \\<And>a x.\n       x \\<in> X \\<Longrightarrow>\n       squarefree (Ring_Hom_Poly.of_int_poly (min_int_poly x))", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b x xa.\n       \\<lbrakk>min_int_poly x \\<noteq> min_int_poly xa; x \\<in> X;\n        xa \\<in> X\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime\n                          (Ring_Hom_Poly.of_int_poly (min_int_poly x))\n                          (Ring_Hom_Poly.of_int_poly (min_int_poly xa))\n 2. \\<And>a x.\n       x \\<in> X \\<Longrightarrow>\n       squarefree (Ring_Hom_Poly.of_int_poly (min_int_poly x))", "assume \"x \\<in> X\""], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (2 subgoals):\n 1. \\<And>a b x xa.\n       \\<lbrakk>min_int_poly x \\<noteq> min_int_poly xa; x \\<in> X;\n        xa \\<in> X\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime\n                          (Ring_Hom_Poly.of_int_poly (min_int_poly x))\n                          (Ring_Hom_Poly.of_int_poly (min_int_poly xa))\n 2. \\<And>a x.\n       x \\<in> X \\<Longrightarrow>\n       squarefree (Ring_Hom_Poly.of_int_poly (min_int_poly x))", "thus \"squarefree (of_int_poly (min_int_poly x) :: complex poly)\""], ["proof (prove)\nusing this:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. squarefree (Ring_Hom_Poly.of_int_poly (min_int_poly x))", "by (intro squarefree_of_int_polyI) auto"], ["proof (state)\nthis:\n  squarefree (Ring_Hom_Poly.of_int_poly (min_int_poly x))\n\ngoal (1 subgoal):\n 1. \\<And>a b x xa.\n       \\<lbrakk>min_int_poly x \\<noteq> min_int_poly xa; x \\<in> X;\n        xa \\<in> X\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime\n                          (Ring_Hom_Poly.of_int_poly (min_int_poly x))\n                          (Ring_Hom_Poly.of_int_poly (min_int_poly xa))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b x xa.\n       \\<lbrakk>min_int_poly x \\<noteq> min_int_poly xa; x \\<in> X;\n        xa \\<in> X\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime\n                          (Ring_Hom_Poly.of_int_poly (min_int_poly x))\n                          (Ring_Hom_Poly.of_int_poly (min_int_poly xa))", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b x xa.\n       \\<lbrakk>min_int_poly x \\<noteq> min_int_poly xa; x \\<in> X;\n        xa \\<in> X\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime\n                          (Ring_Hom_Poly.of_int_poly (min_int_poly x))\n                          (Ring_Hom_Poly.of_int_poly (min_int_poly xa))", "assume xy: \"x \\<in> X\" \"y \\<in> X\" \"min_int_poly x \\<noteq> min_int_poly y\""], ["proof (state)\nthis:\n  x \\<in> X\n  y \\<in> X\n  min_int_poly x \\<noteq> min_int_poly y\n\ngoal (1 subgoal):\n 1. \\<And>a b x xa.\n       \\<lbrakk>min_int_poly x \\<noteq> min_int_poly xa; x \\<in> X;\n        xa \\<in> X\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime\n                          (Ring_Hom_Poly.of_int_poly (min_int_poly x))\n                          (Ring_Hom_Poly.of_int_poly (min_int_poly xa))", "thus \"Rings.coprime (of_int_poly (min_int_poly x)) (of_int_poly (min_int_poly y) :: complex poly)\""], ["proof (prove)\nusing this:\n  x \\<in> X\n  y \\<in> X\n  min_int_poly x \\<noteq> min_int_poly y\n\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime\n     (Ring_Hom_Poly.of_int_poly (min_int_poly x))\n     (Ring_Hom_Poly.of_int_poly (min_int_poly y))", "by (intro coprime_of_int_polyI[OF primes_coprime]) auto"], ["proof (state)\nthis:\n  algebraic_semidom_class.coprime\n   (Ring_Hom_Poly.of_int_poly (min_int_poly x))\n   (Ring_Hom_Poly.of_int_poly (min_int_poly y))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  squarefree (Ring_Hom_Poly.of_int_poly P)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "text \\<open>\n    Since we will need a numbering of these roots, we obtain one:\n  \\<close>"], ["proof (state)\nthis:\n  squarefree (Ring_Hom_Poly.of_int_poly P)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "define n where \"n = card Roots\""], ["proof (state)\nthis:\n  n = card Roots\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "obtain Root where Root: \"bij_betw Root {..<n} Roots\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Root.\n        bij_betw Root {..<n} Roots \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ex_bij_betw_nat_finite[OF \\<open>finite Roots\\<close>]"], ["proof (prove)\nusing this:\n  \\<exists>h. bij_betw h {0..<card Roots} Roots\n\ngoal (1 subgoal):\n 1. (\\<And>Root.\n        bij_betw Root {..<n} Roots \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding n_def atLeast0LessThan"], ["proof (prove)\nusing this:\n  \\<exists>h. bij_betw h {..<card Roots} Roots\n\ngoal (1 subgoal):\n 1. (\\<And>Root.\n        bij_betw Root {..<card Roots} Roots \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  bij_betw Root {..<n} Roots\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "define unRoot :: \"complex \\<Rightarrow> nat\" where \"unRoot = inv_into {..<n} Root\""], ["proof (state)\nthis:\n  unRoot = inv_into {..<n} Root\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have unRoot: \"bij_betw unRoot Roots {..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw unRoot Roots {..<n}", "unfolding unRoot_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (inv_into {..<n} Root) Roots {..<n}", "by (intro bij_betw_inv_into Root)"], ["proof (state)\nthis:\n  bij_betw unRoot Roots {..<n}\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have unRoot_Root [simp]: \"unRoot (Root i) = i\" if \"i < n\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. unRoot (Root i) = i", "unfolding unRoot_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_into {..<n} Root (Root i) = i", "using Root that"], ["proof (prove)\nusing this:\n  bij_betw Root {..<n} Roots\n  i < n\n\ngoal (1 subgoal):\n 1. inv_into {..<n} Root (Root i) = i", "by (subst inv_into_f_f) (auto simp: bij_betw_def)"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow> unRoot (Root ?i) = ?i\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have Root_unRoot [simp]: \"Root (unRoot x) = x\" if \"x \\<in> Roots\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. Root (unRoot x) = x", "unfolding unRoot_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Root (inv_into {..<n} Root x) = x", "using Root that"], ["proof (prove)\nusing this:\n  bij_betw Root {..<n} Roots\n  x \\<in> Roots\n\ngoal (1 subgoal):\n 1. Root (inv_into {..<n} Root x) = x", "by (subst f_inv_into_f) (auto simp: bij_betw_def)"], ["proof (state)\nthis:\n  ?x \\<in> Roots \\<Longrightarrow> Root (unRoot ?x) = ?x\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have [simp, intro]: \"Root i \\<in> Roots\" if \"i < n\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. Root i \\<in> Roots", "using Root that"], ["proof (prove)\nusing this:\n  bij_betw Root {..<n} Roots\n  i < n\n\ngoal (1 subgoal):\n 1. Root i \\<in> Roots", "by (auto simp: bij_betw_def)"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow> Root ?i \\<in> Roots\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have [simp, intro]: \"unRoot x < n\" if \"x \\<in> Roots\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. unRoot x < n", "using unRoot that"], ["proof (prove)\nusing this:\n  bij_betw unRoot Roots {..<n}\n  x \\<in> Roots\n\ngoal (1 subgoal):\n 1. unRoot x < n", "by (auto simp: bij_betw_def)"], ["proof (state)\nthis:\n  ?x \\<in> Roots \\<Longrightarrow> unRoot ?x < n\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "text \\<open>\n    We will also need to convert between permutations of natural numbers less than \\<open>n\\<close> and\n    permutations of the roots:\n  \\<close>"], ["proof (state)\nthis:\n  ?x \\<in> Roots \\<Longrightarrow> unRoot ?x < n\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "define convert_perm :: \"(nat \\<Rightarrow> nat) \\<Rightarrow> (complex \\<Rightarrow> complex)\" where\n    \"convert_perm = (\\<lambda>\\<sigma> x. if x \\<in> Roots then Root (\\<sigma> (unRoot x)) else x)\""], ["proof (state)\nthis:\n  convert_perm =\n  (\\<lambda>\\<sigma> x.\n      if x \\<in> Roots then Root (\\<sigma> (unRoot x)) else x)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have bij_convert: \"bij_betw convert_perm {\\<sigma>. \\<sigma> permutes {..<n}} {\\<sigma>. \\<sigma> permutes Roots}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw convert_perm {\\<sigma>. \\<sigma> permutes {..<n}}\n     {\\<sigma>. \\<sigma> permutes Roots}", "using bij_betw_permutations[OF Root]"], ["proof (prove)\nusing this:\n  bij_betw\n   (\\<lambda>\\<pi> x.\n       if x \\<in> Roots then Root (\\<pi> (inv_into {..<n} Root x)) else x)\n   {\\<pi>. \\<pi> permutes {..<n}} {\\<pi>. \\<pi> permutes Roots}\n\ngoal (1 subgoal):\n 1. bij_betw convert_perm {\\<sigma>. \\<sigma> permutes {..<n}}\n     {\\<sigma>. \\<sigma> permutes Roots}", "unfolding convert_perm_def unRoot_def"], ["proof (prove)\nusing this:\n  bij_betw\n   (\\<lambda>\\<pi> x.\n       if x \\<in> Roots then Root (\\<pi> (inv_into {..<n} Root x)) else x)\n   {\\<pi>. \\<pi> permutes {..<n}} {\\<pi>. \\<pi> permutes Roots}\n\ngoal (1 subgoal):\n 1. bij_betw\n     (\\<lambda>\\<sigma> x.\n         if x \\<in> Roots then Root (\\<sigma> (inv_into {..<n} Root x))\n         else x)\n     {\\<sigma>. \\<sigma> permutes {..<n}}\n     {\\<sigma>. \\<sigma> permutes Roots}", "."], ["proof (state)\nthis:\n  bij_betw convert_perm {\\<sigma>. \\<sigma> permutes {..<n}}\n   {\\<sigma>. \\<sigma> permutes Roots}\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have permutes_convert_perm [intro]: \"convert_perm \\<sigma> permutes Roots\" if \"\\<sigma> permutes {..<n}\" for \\<sigma>"], ["proof (prove)\ngoal (1 subgoal):\n 1. convert_perm \\<sigma> permutes Roots", "using that bij_convert"], ["proof (prove)\nusing this:\n  \\<sigma> permutes {..<n}\n  bij_betw convert_perm {\\<sigma>. \\<sigma> permutes {..<n}}\n   {\\<sigma>. \\<sigma> permutes Roots}\n\ngoal (1 subgoal):\n 1. convert_perm \\<sigma> permutes Roots", "unfolding bij_betw_def"], ["proof (prove)\nusing this:\n  \\<sigma> permutes {..<n}\n  inj_on convert_perm {\\<sigma>. \\<sigma> permutes {..<n}} \\<and>\n  convert_perm ` {\\<sigma>. \\<sigma> permutes {..<n}} =\n  {\\<sigma>. \\<sigma> permutes Roots}\n\ngoal (1 subgoal):\n 1. convert_perm \\<sigma> permutes Roots", "by blast"], ["proof (state)\nthis:\n  ?\\<sigma> permutes {..<n} \\<Longrightarrow>\n  convert_perm ?\\<sigma> permutes Roots\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have convert_perm_compose: \"convert_perm (\\<pi> \\<circ> \\<sigma>) = convert_perm \\<pi> \\<circ> convert_perm \\<sigma>\"\n    if \"\\<pi> permutes {..<n}\" \"\\<sigma> permutes {..<n}\" for \\<sigma> \\<pi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. convert_perm (\\<pi> \\<circ> \\<sigma>) =\n    convert_perm \\<pi> \\<circ> convert_perm \\<sigma>", "proof (intro ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       convert_perm (\\<pi> \\<circ> \\<sigma>) x =\n       (convert_perm \\<pi> \\<circ> convert_perm \\<sigma>) x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       convert_perm (\\<pi> \\<circ> \\<sigma>) x =\n       (convert_perm \\<pi> \\<circ> convert_perm \\<sigma>) x", "show \"convert_perm (\\<pi> \\<circ> \\<sigma>) x = (convert_perm \\<pi> \\<circ> convert_perm \\<sigma>) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convert_perm (\\<pi> \\<circ> \\<sigma>) x =\n    (convert_perm \\<pi> \\<circ> convert_perm \\<sigma>) x", "proof (cases \"x \\<in> Roots\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> Roots \\<Longrightarrow>\n    convert_perm (\\<pi> \\<circ> \\<sigma>) x =\n    (convert_perm \\<pi> \\<circ> convert_perm \\<sigma>) x\n 2. x \\<notin> Roots \\<Longrightarrow>\n    convert_perm (\\<pi> \\<circ> \\<sigma>) x =\n    (convert_perm \\<pi> \\<circ> convert_perm \\<sigma>) x", "case True"], ["proof (state)\nthis:\n  x \\<in> Roots\n\ngoal (2 subgoals):\n 1. x \\<in> Roots \\<Longrightarrow>\n    convert_perm (\\<pi> \\<circ> \\<sigma>) x =\n    (convert_perm \\<pi> \\<circ> convert_perm \\<sigma>) x\n 2. x \\<notin> Roots \\<Longrightarrow>\n    convert_perm (\\<pi> \\<circ> \\<sigma>) x =\n    (convert_perm \\<pi> \\<circ> convert_perm \\<sigma>) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> Roots\n\ngoal (1 subgoal):\n 1. convert_perm (\\<pi> \\<circ> \\<sigma>) x =\n    (convert_perm \\<pi> \\<circ> convert_perm \\<sigma>) x", "using permutes_in_image[OF that(2), of \"unRoot x\"]"], ["proof (prove)\nusing this:\n  x \\<in> Roots\n  (\\<sigma> (unRoot x) \\<in> {..<n}) = (unRoot x \\<in> {..<n})\n\ngoal (1 subgoal):\n 1. convert_perm (\\<pi> \\<circ> \\<sigma>) x =\n    (convert_perm \\<pi> \\<circ> convert_perm \\<sigma>) x", "by (auto simp: convert_perm_def bij_betw_def)"], ["proof (state)\nthis:\n  convert_perm (\\<pi> \\<circ> \\<sigma>) x =\n  (convert_perm \\<pi> \\<circ> convert_perm \\<sigma>) x\n\ngoal (1 subgoal):\n 1. x \\<notin> Roots \\<Longrightarrow>\n    convert_perm (\\<pi> \\<circ> \\<sigma>) x =\n    (convert_perm \\<pi> \\<circ> convert_perm \\<sigma>) x", "qed (auto simp: convert_perm_def)"], ["proof (state)\nthis:\n  convert_perm (\\<pi> \\<circ> \\<sigma>) x =\n  (convert_perm \\<pi> \\<circ> convert_perm \\<sigma>) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?\\<pi> permutes {..<n}; ?\\<sigma> permutes {..<n}\\<rbrakk>\n  \\<Longrightarrow> convert_perm (?\\<pi> \\<circ> ?\\<sigma>) =\n                    convert_perm ?\\<pi> \\<circ> convert_perm ?\\<sigma>\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "text \\<open>\n    We extend the coefficient vector to the new roots by setting their coefficients to 0:\n  \\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>?\\<pi> permutes {..<n}; ?\\<sigma> permutes {..<n}\\<rbrakk>\n  \\<Longrightarrow> convert_perm (?\\<pi> \\<circ> ?\\<sigma>) =\n                    convert_perm ?\\<pi> \\<circ> convert_perm ?\\<sigma>\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "define \\<beta>' where \"\\<beta>' = (\\<lambda>x. if x \\<in> X then \\<beta> x else 0)\""], ["proof (state)\nthis:\n  \\<beta>' = (\\<lambda>x. if x \\<in> X then \\<beta> x else 0)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "text \\<open>\n    We now define the set of all permutations of our roots:\n  \\<close>"], ["proof (state)\nthis:\n  \\<beta>' = (\\<lambda>x. if x \\<in> X then \\<beta> x else 0)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "define perms where \"perms = {\\<pi>. \\<pi> permutes Roots}\""], ["proof (state)\nthis:\n  perms = {\\<pi>. \\<pi> permutes Roots}\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have [intro]: \"finite perms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite perms", "unfolding perms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {\\<pi>. \\<pi> permutes Roots}", "by (rule finite_permutations) auto"], ["proof (state)\nthis:\n  finite perms\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have [simp]: \"card perms = fact n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card perms = fact n", "unfolding perms_def n_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. card {\\<pi>. \\<pi> permutes Roots} = fact (card Roots)", "by (intro card_permutations) auto"], ["proof (state)\nthis:\n  card perms = fact n\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "text \\<open>\n    The following is the set of all \\<open>n!\\<close>-tuples of roots, disregarding permutation of components.\n    In other words: all multisets of roots with size \\<open>n!\\<close>.\n  \\<close>"], ["proof (state)\nthis:\n  card perms = fact n\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "define Roots_ms :: \"complex multiset set\" where\n    \"Roots_ms = {X. set_mset X \\<subseteq> Roots \\<and> size X = fact n}\""], ["proof (state)\nthis:\n  Roots_ms = {X. set_mset X \\<subseteq> Roots \\<and> size X = fact n}\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have [intro]: \"finite Roots_ms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite Roots_ms", "unfolding Roots_ms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {X. set_mset X \\<subseteq> Roots \\<and> size X = fact n}", "by (rule finite_multisets_of_size) auto"], ["proof (state)\nthis:\n  finite Roots_ms\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "text \\<open>\n    Next, the following is the set of \\<open>n!\\<close>-tuples whose entries are precisely the multiset \\<open>X\\<close>:\n  \\<close>"], ["proof (state)\nthis:\n  finite Roots_ms\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "define tuples :: \"complex multiset \\<Rightarrow> ((complex \\<Rightarrow> complex) \\<Rightarrow> complex) set\" where\n    \"tuples = (\\<lambda>X. {f\\<in>perms \\<rightarrow>\\<^sub>E Roots. image_mset f (mset_set perms) = X})\""], ["proof (state)\nthis:\n  tuples =\n  (\\<lambda>X.\n      {f \\<in> perms \\<rightarrow>\\<^sub>E Roots.\n       image_mset f (mset_set perms) = X})\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have fin_tuples [intro]: \"finite (tuples X)\" for X"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (tuples X)", "unfolding tuples_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {f \\<in> perms \\<rightarrow>\\<^sub>E Roots.\n      image_mset f (mset_set perms) = X}", "by (rule finite_subset[of _ \"perms \\<rightarrow>\\<^sub>E Roots\", OF _ finite_PiE]) auto"], ["proof (state)\nthis:\n  finite (tuples ?X)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "define tuples' :: \"(complex multiset \\<times> ((complex \\<Rightarrow> complex) \\<Rightarrow> complex)) set\" where\n    \"tuples' = (SIGMA X:Roots_ms. tuples X)\""], ["proof (state)\nthis:\n  tuples' = Sigma Roots_ms tuples\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "text \\<open>\n    The following shows that our \\<^term>\\<open>tuples\\<close> definition is stable under permutation of\n    the roots.\n  \\<close>"], ["proof (state)\nthis:\n  tuples' = Sigma Roots_ms tuples\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have bij_convert': \"bij_betw (\\<lambda>f. f \\<circ> (\\<lambda>g. \\<sigma> \\<circ> g)) (tuples X) (tuples X)\"\n    if \\<sigma>: \"\\<sigma> permutes Roots\" for \\<sigma> X"], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (\\<lambda>f. f \\<circ> (\\<circ>) \\<sigma>) (tuples X)\n     (tuples X)", "proof (rule bij_betwI)"], ["proof (state)\ngoal (4 subgoals):\n 1. (\\<lambda>f. f \\<circ> (\\<circ>) \\<sigma>)\n    \\<in> tuples X \\<rightarrow> tuples X\n 2. ?g \\<in> tuples X \\<rightarrow> tuples X\n 3. \\<And>x.\n       x \\<in> tuples X \\<Longrightarrow>\n       ?g (x \\<circ> (\\<circ>) \\<sigma>) = x\n 4. \\<And>y.\n       y \\<in> tuples X \\<Longrightarrow>\n       ?g y \\<circ> (\\<circ>) \\<sigma> = y", "have *: \"(\\<lambda>f. f \\<circ> (\\<circ>) \\<sigma>) \\<in> tuples X \\<rightarrow> tuples X\" if \\<sigma>: \"\\<sigma> permutes Roots\" for \\<sigma>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f. f \\<circ> (\\<circ>) \\<sigma>)\n    \\<in> tuples X \\<rightarrow> tuples X", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> tuples X \\<Longrightarrow>\n       x \\<circ> (\\<circ>) \\<sigma> \\<in> tuples X", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> tuples X \\<Longrightarrow>\n       x \\<circ> (\\<circ>) \\<sigma> \\<in> tuples X", "assume f: \"f \\<in> tuples X\""], ["proof (state)\nthis:\n  f \\<in> tuples X\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> tuples X \\<Longrightarrow>\n       x \\<circ> (\\<circ>) \\<sigma> \\<in> tuples X", "show \"f \\<circ> (\\<circ>) \\<sigma> \\<in> tuples X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<circ> (\\<circ>) \\<sigma> \\<in> tuples X", "unfolding tuples_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<circ> (\\<circ>) \\<sigma>\n    \\<in> {f \\<in> perms \\<rightarrow>\\<^sub>E Roots.\n           image_mset f (mset_set perms) = X}", "proof safe"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> perms \\<Longrightarrow>\n       (f \\<circ> (\\<circ>) \\<sigma>) x \\<in> Roots\n 2. \\<And>x.\n       x \\<notin> perms \\<Longrightarrow>\n       (f \\<circ> (\\<circ>) \\<sigma>) x = undefined\n 3. image_mset (f \\<circ> (\\<circ>) \\<sigma>) (mset_set perms) = X", "fix \\<sigma>'"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> perms \\<Longrightarrow>\n       (f \\<circ> (\\<circ>) \\<sigma>) x \\<in> Roots\n 2. \\<And>x.\n       x \\<notin> perms \\<Longrightarrow>\n       (f \\<circ> (\\<circ>) \\<sigma>) x = undefined\n 3. image_mset (f \\<circ> (\\<circ>) \\<sigma>) (mset_set perms) = X", "assume \\<sigma>': \"\\<sigma>' \\<in> perms\""], ["proof (state)\nthis:\n  \\<sigma>' \\<in> perms\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> perms \\<Longrightarrow>\n       (f \\<circ> (\\<circ>) \\<sigma>) x \\<in> Roots\n 2. \\<And>x.\n       x \\<notin> perms \\<Longrightarrow>\n       (f \\<circ> (\\<circ>) \\<sigma>) x = undefined\n 3. image_mset (f \\<circ> (\\<circ>) \\<sigma>) (mset_set perms) = X", "show \"(f \\<circ> (\\<circ>) \\<sigma>) \\<sigma>' \\<in> Roots\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f \\<circ> (\\<circ>) \\<sigma>) \\<sigma>' \\<in> Roots", "using permutes_compose[OF _ \\<sigma>, of \\<sigma>'] \\<sigma> \\<sigma>' f"], ["proof (prove)\nusing this:\n  \\<sigma>' permutes Roots \\<Longrightarrow>\n  \\<sigma> \\<circ> \\<sigma>' permutes Roots\n  \\<sigma> permutes Roots\n  \\<sigma>' \\<in> perms\n  f \\<in> tuples X\n\ngoal (1 subgoal):\n 1. (f \\<circ> (\\<circ>) \\<sigma>) \\<sigma>' \\<in> Roots", "by (auto simp: perms_def tuples_def)"], ["proof (state)\nthis:\n  (f \\<circ> (\\<circ>) \\<sigma>) \\<sigma>' \\<in> Roots\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<notin> perms \\<Longrightarrow>\n       (f \\<circ> (\\<circ>) \\<sigma>) x = undefined\n 2. image_mset (f \\<circ> (\\<circ>) \\<sigma>) (mset_set perms) = X", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<notin> perms \\<Longrightarrow>\n       (f \\<circ> (\\<circ>) \\<sigma>) x = undefined\n 2. image_mset (f \\<circ> (\\<circ>) \\<sigma>) (mset_set perms) = X", "fix \\<sigma>'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<notin> perms \\<Longrightarrow>\n       (f \\<circ> (\\<circ>) \\<sigma>) x = undefined\n 2. image_mset (f \\<circ> (\\<circ>) \\<sigma>) (mset_set perms) = X", "assume \\<sigma>': \"\\<sigma>' \\<notin> perms\""], ["proof (state)\nthis:\n  \\<sigma>' \\<notin> perms\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<notin> perms \\<Longrightarrow>\n       (f \\<circ> (\\<circ>) \\<sigma>) x = undefined\n 2. image_mset (f \\<circ> (\\<circ>) \\<sigma>) (mset_set perms) = X", "have \"\\<not>(\\<sigma> \\<circ> \\<sigma>') permutes Roots\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> \\<sigma> \\<circ> \\<sigma>' permutes Roots", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<sigma> \\<circ> \\<sigma>' permutes Roots \\<Longrightarrow> False", "assume \"(\\<sigma> \\<circ> \\<sigma>') permutes Roots\""], ["proof (state)\nthis:\n  \\<sigma> \\<circ> \\<sigma>' permutes Roots\n\ngoal (1 subgoal):\n 1. \\<sigma> \\<circ> \\<sigma>' permutes Roots \\<Longrightarrow> False", "hence \"inv_into UNIV \\<sigma> \\<circ> (\\<sigma> \\<circ> \\<sigma>') permutes Roots\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<circ> \\<sigma>' permutes Roots\n\ngoal (1 subgoal):\n 1. inv \\<sigma> \\<circ> (\\<sigma> \\<circ> \\<sigma>') permutes Roots", "by (rule permutes_compose) (use permutes_inv[OF \\<sigma>] in simp_all)"], ["proof (state)\nthis:\n  inv \\<sigma> \\<circ> (\\<sigma> \\<circ> \\<sigma>') permutes Roots\n\ngoal (1 subgoal):\n 1. \\<sigma> \\<circ> \\<sigma>' permutes Roots \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  inv \\<sigma> \\<circ> (\\<sigma> \\<circ> \\<sigma>') permutes Roots\n\ngoal (1 subgoal):\n 1. \\<sigma> \\<circ> \\<sigma>' permutes Roots \\<Longrightarrow> False", "have \"inv_into UNIV \\<sigma> \\<circ> (\\<sigma> \\<circ> \\<sigma>') = \\<sigma>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv \\<sigma> \\<circ> (\\<sigma> \\<circ> \\<sigma>') = \\<sigma>'", "by (auto simp: fun_eq_iff permutes_inverses[OF \\<sigma>])"], ["proof (state)\nthis:\n  inv \\<sigma> \\<circ> (\\<sigma> \\<circ> \\<sigma>') = \\<sigma>'\n\ngoal (1 subgoal):\n 1. \\<sigma> \\<circ> \\<sigma>' permutes Roots \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  \\<sigma>' permutes Roots", "show False"], ["proof (prove)\nusing this:\n  \\<sigma>' permutes Roots\n\ngoal (1 subgoal):\n 1. False", "using \\<sigma>'"], ["proof (prove)\nusing this:\n  \\<sigma>' permutes Roots\n  \\<sigma>' \\<notin> perms\n\ngoal (1 subgoal):\n 1. False", "by (simp add: perms_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> \\<sigma> \\<circ> \\<sigma>' permutes Roots\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<notin> perms \\<Longrightarrow>\n       (f \\<circ> (\\<circ>) \\<sigma>) x = undefined\n 2. image_mset (f \\<circ> (\\<circ>) \\<sigma>) (mset_set perms) = X", "thus \"(f \\<circ> (\\<circ>) \\<sigma>) \\<sigma>' = undefined\""], ["proof (prove)\nusing this:\n  \\<not> \\<sigma> \\<circ> \\<sigma>' permutes Roots\n\ngoal (1 subgoal):\n 1. (f \\<circ> (\\<circ>) \\<sigma>) \\<sigma>' = undefined", "using f"], ["proof (prove)\nusing this:\n  \\<not> \\<sigma> \\<circ> \\<sigma>' permutes Roots\n  f \\<in> tuples X\n\ngoal (1 subgoal):\n 1. (f \\<circ> (\\<circ>) \\<sigma>) \\<sigma>' = undefined", "by (auto simp: perms_def tuples_def)"], ["proof (state)\nthis:\n  (f \\<circ> (\\<circ>) \\<sigma>) \\<sigma>' = undefined\n\ngoal (1 subgoal):\n 1. image_mset (f \\<circ> (\\<circ>) \\<sigma>) (mset_set perms) = X", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. image_mset (f \\<circ> (\\<circ>) \\<sigma>) (mset_set perms) = X", "have \"image_mset (f \\<circ> (\\<circ>) \\<sigma>) (mset_set perms) =\n              image_mset f (image_mset ((\\<circ>) \\<sigma>) (mset_set perms))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. image_mset (f \\<circ> (\\<circ>) \\<sigma>) (mset_set perms) =\n    image_mset f (image_mset ((\\<circ>) \\<sigma>) (mset_set perms))", "by (rule multiset.map_comp [symmetric])"], ["proof (state)\nthis:\n  image_mset (f \\<circ> (\\<circ>) \\<sigma>) (mset_set perms) =\n  image_mset f (image_mset ((\\<circ>) \\<sigma>) (mset_set perms))\n\ngoal (1 subgoal):\n 1. image_mset (f \\<circ> (\\<circ>) \\<sigma>) (mset_set perms) = X", "also"], ["proof (state)\nthis:\n  image_mset (f \\<circ> (\\<circ>) \\<sigma>) (mset_set perms) =\n  image_mset f (image_mset ((\\<circ>) \\<sigma>) (mset_set perms))\n\ngoal (1 subgoal):\n 1. image_mset (f \\<circ> (\\<circ>) \\<sigma>) (mset_set perms) = X", "have \"image_mset ((\\<circ>) \\<sigma>) (mset_set perms) = mset_set perms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. image_mset ((\\<circ>) \\<sigma>) (mset_set perms) = mset_set perms", "using bij_betw_permutes_compose_left[OF \\<sigma>]"], ["proof (prove)\nusing this:\n  bij_betw ((\\<circ>) \\<sigma>) {\\<sigma>. \\<sigma> permutes Roots}\n   {\\<sigma>. \\<sigma> permutes Roots}\n\ngoal (1 subgoal):\n 1. image_mset ((\\<circ>) \\<sigma>) (mset_set perms) = mset_set perms", "by (subst image_mset_mset_set) (auto simp: bij_betw_def perms_def)"], ["proof (state)\nthis:\n  image_mset ((\\<circ>) \\<sigma>) (mset_set perms) = mset_set perms\n\ngoal (1 subgoal):\n 1. image_mset (f \\<circ> (\\<circ>) \\<sigma>) (mset_set perms) = X", "also"], ["proof (state)\nthis:\n  image_mset ((\\<circ>) \\<sigma>) (mset_set perms) = mset_set perms\n\ngoal (1 subgoal):\n 1. image_mset (f \\<circ> (\\<circ>) \\<sigma>) (mset_set perms) = X", "have \"image_mset f \\<dots> = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. image_mset f (mset_set perms) = X", "using f"], ["proof (prove)\nusing this:\n  f \\<in> tuples X\n\ngoal (1 subgoal):\n 1. image_mset f (mset_set perms) = X", "by (auto simp: tuples_def)"], ["proof (state)\nthis:\n  image_mset f (mset_set perms) = X\n\ngoal (1 subgoal):\n 1. image_mset (f \\<circ> (\\<circ>) \\<sigma>) (mset_set perms) = X", "finally"], ["proof (chain)\npicking this:\n  image_mset (f \\<circ> (\\<circ>) \\<sigma>) (mset_set perms) = X", "show \"image_mset (f \\<circ> (\\<circ>) \\<sigma>) (mset_set perms) = X\""], ["proof (prove)\nusing this:\n  image_mset (f \\<circ> (\\<circ>) \\<sigma>) (mset_set perms) = X\n\ngoal (1 subgoal):\n 1. image_mset (f \\<circ> (\\<circ>) \\<sigma>) (mset_set perms) = X", "."], ["proof (state)\nthis:\n  image_mset (f \\<circ> (\\<circ>) \\<sigma>) (mset_set perms) = X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f \\<circ> (\\<circ>) \\<sigma> \\<in> tuples X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?\\<sigma> permutes Roots \\<Longrightarrow>\n  (\\<lambda>f. f \\<circ> (\\<circ>) ?\\<sigma>)\n  \\<in> tuples X \\<rightarrow> tuples X\n\ngoal (4 subgoals):\n 1. (\\<lambda>f. f \\<circ> (\\<circ>) \\<sigma>)\n    \\<in> tuples X \\<rightarrow> tuples X\n 2. ?g \\<in> tuples X \\<rightarrow> tuples X\n 3. \\<And>x.\n       x \\<in> tuples X \\<Longrightarrow>\n       ?g (x \\<circ> (\\<circ>) \\<sigma>) = x\n 4. \\<And>y.\n       y \\<in> tuples X \\<Longrightarrow>\n       ?g y \\<circ> (\\<circ>) \\<sigma> = y", "show \"(\\<lambda>f. f \\<circ> (\\<circ>) \\<sigma>) \\<in> tuples X \\<rightarrow> tuples X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f. f \\<circ> (\\<circ>) \\<sigma>)\n    \\<in> tuples X \\<rightarrow> tuples X", "by (rule *) fact"], ["proof (state)\nthis:\n  (\\<lambda>f. f \\<circ> (\\<circ>) \\<sigma>)\n  \\<in> tuples X \\<rightarrow> tuples X\n\ngoal (3 subgoals):\n 1. ?g \\<in> tuples X \\<rightarrow> tuples X\n 2. \\<And>x.\n       x \\<in> tuples X \\<Longrightarrow>\n       ?g (x \\<circ> (\\<circ>) \\<sigma>) = x\n 3. \\<And>y.\n       y \\<in> tuples X \\<Longrightarrow>\n       ?g y \\<circ> (\\<circ>) \\<sigma> = y", "show \"(\\<lambda>f. f \\<circ> (\\<circ>) (inv_into UNIV \\<sigma>)) \\<in> tuples X \\<rightarrow> tuples X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f. f \\<circ> (\\<circ>) (inv \\<sigma>))\n    \\<in> tuples X \\<rightarrow> tuples X", "by (intro * permutes_inv) fact"], ["proof (state)\nthis:\n  (\\<lambda>f. f \\<circ> (\\<circ>) (inv \\<sigma>))\n  \\<in> tuples X \\<rightarrow> tuples X\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> tuples X \\<Longrightarrow>\n       x \\<circ> (\\<circ>) \\<sigma> \\<circ> (\\<circ>) (inv \\<sigma>) = x\n 2. \\<And>y.\n       y \\<in> tuples X \\<Longrightarrow>\n       y \\<circ> (\\<circ>) (inv \\<sigma>) \\<circ> (\\<circ>) \\<sigma> = y", "show \"f \\<circ> (\\<circ>) \\<sigma> \\<circ> (\\<circ>) (inv_into UNIV \\<sigma>) = f\" if \"f \\<in> tuples X\" for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<circ> (\\<circ>) \\<sigma> \\<circ> (\\<circ>) (inv \\<sigma>) = f", "by (auto simp: fun_eq_iff o_def permutes_inverses[OF \\<sigma>])"], ["proof (state)\nthis:\n  ?f \\<in> tuples X \\<Longrightarrow>\n  ?f \\<circ> (\\<circ>) \\<sigma> \\<circ> (\\<circ>) (inv \\<sigma>) = ?f\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> tuples X \\<Longrightarrow>\n       y \\<circ> (\\<circ>) (inv \\<sigma>) \\<circ> (\\<circ>) \\<sigma> = y", "show \"f \\<circ> (\\<circ>) (inv_into UNIV \\<sigma>) \\<circ> (\\<circ>) \\<sigma> = f\" if \"f \\<in> tuples X\" for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<circ> (\\<circ>) (inv \\<sigma>) \\<circ> (\\<circ>) \\<sigma> = f", "by (auto simp: fun_eq_iff o_def permutes_inverses[OF \\<sigma>])"], ["proof (state)\nthis:\n  ?f \\<in> tuples X \\<Longrightarrow>\n  ?f \\<circ> (\\<circ>) (inv \\<sigma>) \\<circ> (\\<circ>) \\<sigma> = ?f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?\\<sigma> permutes Roots \\<Longrightarrow>\n  bij_betw (\\<lambda>f. f \\<circ> (\\<circ>) ?\\<sigma>) (tuples ?X)\n   (tuples ?X)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "text \\<open>\n    Next, we define the multiset of of possible exponents that we can get for a given\n    \\<open>n!\\<close>-multiset of roots,\n  \\<close>"], ["proof (state)\nthis:\n  ?\\<sigma> permutes Roots \\<Longrightarrow>\n  bij_betw (\\<lambda>f. f \\<circ> (\\<circ>) ?\\<sigma>) (tuples ?X)\n   (tuples ?X)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "define R :: \"complex multiset \\<Rightarrow> complex multiset\" where\n    \"R = (\\<lambda>X. image_mset (\\<lambda>f. \\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)) (mset_set (tuples X)))\""], ["proof (state)\nthis:\n  R =\n  (\\<lambda>X.\n      {#\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)\n      . f \\<in># mset_set (tuples X)#})\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "text \\<open>\n    We show that, for each such multiset, there is a content-free integer polynomial that has\n    exactly these exponents as roots. This shows that they form a full set of conjugates (but\n    note this polynomial is not necessarily squarefree).\n\n    The proof is yet another application of the fundamental theorem of symmetric polynomials.\n  \\<close>"], ["proof (state)\nthis:\n  R =\n  (\\<lambda>X.\n      {#\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)\n      . f \\<in># mset_set (tuples X)#})\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "obtain Q :: \"complex multiset \\<Rightarrow> int poly\"\n    where Q: \"\\<And>X. X \\<in> Roots_ms \\<Longrightarrow> poly_roots (of_int_poly (Q X)) = R X\"\n             \"\\<And>X. X \\<in> Roots_ms \\<Longrightarrow> content (Q X) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>\\<And>X.\n                    X \\<in> Roots_ms \\<Longrightarrow>\n                    poly_roots (Ring_Hom_Poly.of_int_poly (Q X)) = R X;\n         \\<And>X.\n            X \\<in> Roots_ms \\<Longrightarrow>\n            Polynomial.content (Q X) = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>\\<And>X.\n                    X \\<in> Roots_ms \\<Longrightarrow>\n                    poly_roots (Ring_Hom_Poly.of_int_poly (Q X)) = R X;\n         \\<And>X.\n            X \\<in> Roots_ms \\<Longrightarrow>\n            Polynomial.content (Q X) = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>\\<And>X.\n                    X \\<in> Roots_ms \\<Longrightarrow>\n                    poly_roots (Ring_Hom_Poly.of_int_poly (Q X)) = R X;\n         \\<And>X.\n            X \\<in> Roots_ms \\<Longrightarrow>\n            Polynomial.content (Q X) = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "fix X :: \"complex multiset\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>\\<And>X.\n                    X \\<in> Roots_ms \\<Longrightarrow>\n                    poly_roots (Ring_Hom_Poly.of_int_poly (Q X)) = R X;\n         \\<And>X.\n            X \\<in> Roots_ms \\<Longrightarrow>\n            Polynomial.content (Q X) = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "assume X: \"X \\<in> Roots_ms\""], ["proof (state)\nthis:\n  X \\<in> Roots_ms\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>\\<And>X.\n                    X \\<in> Roots_ms \\<Longrightarrow>\n                    poly_roots (Ring_Hom_Poly.of_int_poly (Q X)) = R X;\n         \\<And>X.\n            X \\<in> Roots_ms \\<Longrightarrow>\n            Polynomial.content (Q X) = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define Q :: \"complex poly mpoly\" where\n        \"Q = (\\<Prod>f\\<in>tuples X. Const [:0, 1:] -\n                 (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}. Var (\\<sigma> (unRoot (f (convert_perm \\<sigma>))))))\""], ["proof (state)\nthis:\n  Q =\n  (\\<Prod>f\\<in>tuples X.\n     Const [:0, 1:] -\n     (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n        Var (\\<sigma> (unRoot (f (convert_perm \\<sigma>))))))\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>\\<And>X.\n                    X \\<in> Roots_ms \\<Longrightarrow>\n                    poly_roots (Ring_Hom_Poly.of_int_poly (Q X)) = R X;\n         \\<And>X.\n            X \\<in> Roots_ms \\<Longrightarrow>\n            Polynomial.content (Q X) = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define Q1 where \"Q1 = (\\<Prod>f\\<in>tuples X. [:- (\\<Sum>\\<sigma> | \\<sigma> permutes Roots. \\<sigma> (f \\<sigma>)), 1:])\""], ["proof (state)\nthis:\n  Q1 =\n  (\\<Prod>f\\<in>tuples X.\n     [:- (\\<Sum>\\<sigma> | \\<sigma> permutes Roots. \\<sigma> (f \\<sigma>)),\n       1:])\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>\\<And>X.\n                    X \\<in> Roots_ms \\<Longrightarrow>\n                    poly_roots (Ring_Hom_Poly.of_int_poly (Q X)) = R X;\n         \\<And>X.\n            X \\<in> Roots_ms \\<Longrightarrow>\n            Polynomial.content (Q X) = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "define ratpolys :: \"complex poly set\" where \"ratpolys = {p. \\<forall>i. poly.coeff p i \\<in> \\<rat>}\""], ["proof (state)\nthis:\n  ratpolys = {p. \\<forall>i. poly.coeff p i \\<in> \\<rat>}\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>\\<And>X.\n                    X \\<in> Roots_ms \\<Longrightarrow>\n                    poly_roots (Ring_Hom_Poly.of_int_poly (Q X)) = R X;\n         \\<And>X.\n            X \\<in> Roots_ms \\<Longrightarrow>\n            Polynomial.content (Q X) = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"insertion (\\<lambda>x. [:Root x:]) Q \\<in> ratpolys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (\\<lambda>x. [:Root x:]) Q \\<in> ratpolys", "proof (rule symmetric_poly_of_roots_in_subring[where l = \"\\<lambda>x. [:x:]\"])"], ["proof (state)\ngoal (10 subgoals):\n 1. ring_closed ratpolys\n 2. \\<forall>m. MPoly_Type.coeff Q m \\<in> ratpolys\n 3. ring_homomorphism (\\<lambda>x. [:x:])\n 4. finite ?A\n 5. symmetric_mpoly ?A Q\n 6. vars Q \\<subseteq> ?A\n 7. ?cinv * [:?c:] = 1\n 8. ?cinv \\<in> ratpolys\n 9. ?p = Polynomial.smult ?c (\\<Prod>i\\<in>?A. [:- Root i, 1:])\n 10. \\<forall>i. [:poly.coeff ?p i:] \\<in> ratpolys", "show \"ring_closed ratpolys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ring_closed ratpolys", "unfolding ratpolys_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ring_closed {p. \\<forall>i. poly.coeff p i \\<in> \\<rat>}", "by standard (auto intro: coeff_mult_semiring_closed)"], ["proof (state)\nthis:\n  ring_closed ratpolys\n\ngoal (9 subgoals):\n 1. \\<forall>m. MPoly_Type.coeff Q m \\<in> ratpolys\n 2. ring_homomorphism (\\<lambda>x. [:x:])\n 3. finite ?A\n 4. symmetric_mpoly ?A Q\n 5. vars Q \\<subseteq> ?A\n 6. ?cinv * [:?c:] = 1\n 7. ?cinv \\<in> ratpolys\n 8. ?p = Polynomial.smult ?c (\\<Prod>i\\<in>?A. [:- Root i, 1:])\n 9. \\<forall>i. [:poly.coeff ?p i:] \\<in> ratpolys", "then"], ["proof (chain)\npicking this:\n  ring_closed ratpolys", "interpret ratpolys: ring_closed ratpolys"], ["proof (prove)\nusing this:\n  ring_closed ratpolys\n\ngoal (1 subgoal):\n 1. ring_closed ratpolys", "."], ["proof (state)\ngoal (9 subgoals):\n 1. \\<forall>m. MPoly_Type.coeff Q m \\<in> ratpolys\n 2. ring_homomorphism (\\<lambda>x. [:x:])\n 3. finite ?A\n 4. symmetric_mpoly ?A Q\n 5. vars Q \\<subseteq> ?A\n 6. ?cinv * [:?c:] = 1\n 7. ?cinv \\<in> ratpolys\n 8. ?p = Polynomial.smult ?c (\\<Prod>i\\<in>?A. [:- Root i, 1:])\n 9. \\<forall>i. [:poly.coeff ?p i:] \\<in> ratpolys", "have \"pCons 0 1 \\<in> ratpolys \""], ["proof (prove)\ngoal (1 subgoal):\n 1. pCons 0 1 \\<in> ratpolys", "by (auto simp: ratpolys_def coeff_pCons split: nat.splits)"], ["proof (state)\nthis:\n  pCons 0 1 \\<in> ratpolys\n\ngoal (9 subgoals):\n 1. \\<forall>m. MPoly_Type.coeff Q m \\<in> ratpolys\n 2. ring_homomorphism (\\<lambda>x. [:x:])\n 3. finite ?A\n 4. symmetric_mpoly ?A Q\n 5. vars Q \\<subseteq> ?A\n 6. ?cinv * [:?c:] = 1\n 7. ?cinv \\<in> ratpolys\n 8. ?p = Polynomial.smult ?c (\\<Prod>i\\<in>?A. [:- Root i, 1:])\n 9. \\<forall>i. [:poly.coeff ?p i:] \\<in> ratpolys", "thus \"\\<forall>m. MPoly_Type.coeff Q m \\<in> ratpolys\""], ["proof (prove)\nusing this:\n  pCons 0 1 \\<in> ratpolys\n\ngoal (1 subgoal):\n 1. \\<forall>m. MPoly_Type.coeff Q m \\<in> ratpolys", "unfolding Q_def"], ["proof (prove)\nusing this:\n  pCons 0 1 \\<in> ratpolys\n\ngoal (1 subgoal):\n 1. \\<forall>m.\n       MPoly_Type.coeff\n        (\\<Prod>f\\<in>tuples X.\n           Const [:0, 1:] -\n           (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n              Var (\\<sigma> (unRoot (f (convert_perm \\<sigma>))))))\n        m\n       \\<in> ratpolys", "by (intro allI ratpolys.coeff_prod_closed)\n             (auto intro!: ratpolys.minus_closed ratpolys.sum_closed ratpolys.uminus_closed simp: coeff_Var mpoly_coeff_Const when_def)"], ["proof (state)\nthis:\n  \\<forall>m. MPoly_Type.coeff Q m \\<in> ratpolys\n\ngoal (8 subgoals):\n 1. ring_homomorphism (\\<lambda>x. [:x:])\n 2. finite ?A\n 3. symmetric_mpoly ?A Q\n 4. vars Q \\<subseteq> ?A\n 5. ?cinv * [:?c:] = 1\n 6. ?cinv \\<in> ratpolys\n 7. ?p = Polynomial.smult ?c (\\<Prod>i\\<in>?A. [:- Root i, 1:])\n 8. \\<forall>i. [:poly.coeff ?p i:] \\<in> ratpolys", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. ring_homomorphism (\\<lambda>x. [:x:])\n 2. finite ?A\n 3. symmetric_mpoly ?A Q\n 4. vars Q \\<subseteq> ?A\n 5. ?cinv * [:?c:] = 1\n 6. ?cinv \\<in> ratpolys\n 7. ?p = Polynomial.smult ?c (\\<Prod>i\\<in>?A. [:- Root i, 1:])\n 8. \\<forall>i. [:poly.coeff ?p i:] \\<in> ratpolys", "show \"ring_homomorphism (\\<lambda>x::complex. [:x:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ring_homomorphism (\\<lambda>x. [:x:])", ".."], ["proof (state)\nthis:\n  ring_homomorphism (\\<lambda>x. [:x:])\n\ngoal (7 subgoals):\n 1. finite ?A\n 2. symmetric_mpoly ?A Q\n 3. vars Q \\<subseteq> ?A\n 4. ?cinv * [:?c:] = 1\n 5. ?cinv \\<in> ratpolys\n 6. ?p = Polynomial.smult ?c (\\<Prod>i\\<in>?A. [:- Root i, 1:])\n 7. \\<forall>i. [:poly.coeff ?p i:] \\<in> ratpolys", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. finite ?A\n 2. symmetric_mpoly ?A Q\n 3. vars Q \\<subseteq> ?A\n 4. ?cinv * [:?c:] = 1\n 5. ?cinv \\<in> ratpolys\n 6. ?p = Polynomial.smult ?c (\\<Prod>i\\<in>?A. [:- Root i, 1:])\n 7. \\<forall>i. [:poly.coeff ?p i:] \\<in> ratpolys", "have \"\\<sigma> (unRoot (f (convert_perm \\<sigma>))) < n\" if \"f \\<in> tuples X\" \"\\<sigma> permutes {..<n}\" for f \\<sigma>"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> (unRoot (f (convert_perm \\<sigma>))) < n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<sigma> (unRoot (f (convert_perm \\<sigma>))) < n", "have \"convert_perm \\<sigma> \\<in> perms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convert_perm \\<sigma> \\<in> perms", "using bij_convert that(2)"], ["proof (prove)\nusing this:\n  bij_betw convert_perm {\\<sigma>. \\<sigma> permutes {..<n}}\n   {\\<sigma>. \\<sigma> permutes Roots}\n  \\<sigma> permutes {..<n}\n\ngoal (1 subgoal):\n 1. convert_perm \\<sigma> \\<in> perms", "by (auto simp: bij_betw_def perms_def)"], ["proof (state)\nthis:\n  convert_perm \\<sigma> \\<in> perms\n\ngoal (1 subgoal):\n 1. \\<sigma> (unRoot (f (convert_perm \\<sigma>))) < n", "hence \"f (convert_perm \\<sigma>) \\<in> Roots\""], ["proof (prove)\nusing this:\n  convert_perm \\<sigma> \\<in> perms\n\ngoal (1 subgoal):\n 1. f (convert_perm \\<sigma>) \\<in> Roots", "using that"], ["proof (prove)\nusing this:\n  convert_perm \\<sigma> \\<in> perms\n  f \\<in> tuples X\n  \\<sigma> permutes {..<n}\n\ngoal (1 subgoal):\n 1. f (convert_perm \\<sigma>) \\<in> Roots", "by (auto simp: tuples_def)"], ["proof (state)\nthis:\n  f (convert_perm \\<sigma>) \\<in> Roots\n\ngoal (1 subgoal):\n 1. \\<sigma> (unRoot (f (convert_perm \\<sigma>))) < n", "thus ?thesis"], ["proof (prove)\nusing this:\n  f (convert_perm \\<sigma>) \\<in> Roots\n\ngoal (1 subgoal):\n 1. \\<sigma> (unRoot (f (convert_perm \\<sigma>))) < n", "using permutes_in_image[OF that(2)]"], ["proof (prove)\nusing this:\n  f (convert_perm \\<sigma>) \\<in> Roots\n  (\\<sigma> ?x \\<in> {..<n}) = (?x \\<in> {..<n})\n\ngoal (1 subgoal):\n 1. \\<sigma> (unRoot (f (convert_perm \\<sigma>))) < n", "by simp"], ["proof (state)\nthis:\n  \\<sigma> (unRoot (f (convert_perm \\<sigma>))) < n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?f \\<in> tuples X; ?\\<sigma> permutes {..<n}\\<rbrakk>\n  \\<Longrightarrow> ?\\<sigma> (unRoot (?f (convert_perm ?\\<sigma>))) < n\n\ngoal (7 subgoals):\n 1. finite ?A\n 2. symmetric_mpoly ?A Q\n 3. vars Q \\<subseteq> ?A\n 4. ?cinv * [:?c:] = 1\n 5. ?cinv \\<in> ratpolys\n 6. ?p = Polynomial.smult ?c (\\<Prod>i\\<in>?A. [:- Root i, 1:])\n 7. \\<forall>i. [:poly.coeff ?p i:] \\<in> ratpolys", "thus \"vars Q \\<subseteq> {..<n}\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?f \\<in> tuples X; ?\\<sigma> permutes {..<n}\\<rbrakk>\n  \\<Longrightarrow> ?\\<sigma> (unRoot (?f (convert_perm ?\\<sigma>))) < n\n\ngoal (1 subgoal):\n 1. vars Q \\<subseteq> {..<n}", "unfolding Q_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>?f \\<in> tuples X; ?\\<sigma> permutes {..<n}\\<rbrakk>\n  \\<Longrightarrow> ?\\<sigma> (unRoot (?f (convert_perm ?\\<sigma>))) < n\n\ngoal (1 subgoal):\n 1. vars\n     (\\<Prod>f\\<in>tuples X.\n        Const [:0, 1:] -\n        (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n           Var (\\<sigma> (unRoot (f (convert_perm \\<sigma>))))))\n    \\<subseteq> {..<n}", "by (intro order.trans[OF vars_prod] UN_least order.trans[OF vars_sum]\n                order.trans[OF vars_diff] Un_least) (auto simp: vars_Var)"], ["proof (state)\nthis:\n  vars Q \\<subseteq> {..<n}\n\ngoal (6 subgoals):\n 1. finite {..<n}\n 2. symmetric_mpoly {..<n} Q\n 3. ?cinv * [:?c:] = 1\n 4. ?cinv \\<in> ratpolys\n 5. ?p = Polynomial.smult ?c (\\<Prod>i<n. [:- Root i, 1:])\n 6. \\<forall>i. [:poly.coeff ?p i:] \\<in> ratpolys", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. finite {..<n}\n 2. symmetric_mpoly {..<n} Q\n 3. ?cinv * [:?c:] = 1\n 4. ?cinv \\<in> ratpolys\n 5. ?p = Polynomial.smult ?c (\\<Prod>i<n. [:- Root i, 1:])\n 6. \\<forall>i. [:poly.coeff ?p i:] \\<in> ratpolys", "define lc :: complex where \"lc = of_int (Polynomial.lead_coeff P)\""], ["proof (state)\nthis:\n  lc = of_int (Polynomial.lead_coeff P)\n\ngoal (6 subgoals):\n 1. finite {..<n}\n 2. symmetric_mpoly {..<n} Q\n 3. ?cinv * [:?c:] = 1\n 4. ?cinv \\<in> ratpolys\n 5. ?p = Polynomial.smult ?c (\\<Prod>i<n. [:- Root i, 1:])\n 6. \\<forall>i. [:poly.coeff ?p i:] \\<in> ratpolys", "show \"[:inverse lc:] \\<in> ratpolys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. [:inverse lc:] \\<in> ratpolys", "by (auto simp: ratpolys_def coeff_pCons lc_def split: nat.splits)"], ["proof (state)\nthis:\n  [:inverse lc:] \\<in> ratpolys\n\ngoal (5 subgoals):\n 1. finite {..<n}\n 2. symmetric_mpoly {..<n} Q\n 3. [:inverse (of_int (Polynomial.lead_coeff P)):] * [:?c:] = 1\n 4. ?p = Polynomial.smult ?c (\\<Prod>i<n. [:- Root i, 1:])\n 5. \\<forall>i. [:poly.coeff ?p i:] \\<in> ratpolys", "show \"\\<forall>i. [:poly.coeff (of_int_poly P) i:] \\<in> ratpolys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i.\n       [:poly.coeff (Ring_Hom_Poly.of_int_poly P) i:] \\<in> ratpolys", "by (auto simp: ratpolys_def coeff_pCons split: nat.splits)"], ["proof (state)\nthis:\n  \\<forall>i. [:poly.coeff (Ring_Hom_Poly.of_int_poly P) i:] \\<in> ratpolys\n\ngoal (4 subgoals):\n 1. finite {..<n}\n 2. symmetric_mpoly {..<n} Q\n 3. [:inverse (of_int (Polynomial.lead_coeff P)):] * [:?c:] = 1\n 4. Ring_Hom_Poly.of_int_poly P =\n    Polynomial.smult ?c (\\<Prod>i<n. [:- Root i, 1:])", "have \"lc \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lc \\<noteq> 0", "by (auto simp: lc_def)"], ["proof (state)\nthis:\n  lc \\<noteq> 0\n\ngoal (4 subgoals):\n 1. finite {..<n}\n 2. symmetric_mpoly {..<n} Q\n 3. [:inverse (of_int (Polynomial.lead_coeff P)):] * [:?c:] = 1\n 4. Ring_Hom_Poly.of_int_poly P =\n    Polynomial.smult ?c (\\<Prod>i<n. [:- Root i, 1:])", "thus \"[:inverse lc:] * [:lc:] = 1\""], ["proof (prove)\nusing this:\n  lc \\<noteq> 0\n\ngoal (1 subgoal):\n 1. [:inverse lc:] * [:lc:] = 1", "by auto"], ["proof (state)\nthis:\n  [:inverse lc:] * [:lc:] = 1\n\ngoal (3 subgoals):\n 1. finite {..<n}\n 2. symmetric_mpoly {..<n} Q\n 3. Ring_Hom_Poly.of_int_poly P =\n    Polynomial.smult (of_int (Polynomial.lead_coeff P))\n     (\\<Prod>i<n. [:- Root i, 1:])", "have \"rsquarefree (of_int_poly P :: complex poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rsquarefree (Ring_Hom_Poly.of_int_poly P)", "using \\<open>squarefree (of_int_poly P :: complex poly)\\<close>"], ["proof (prove)\nusing this:\n  squarefree (Ring_Hom_Poly.of_int_poly P)\n\ngoal (1 subgoal):\n 1. rsquarefree (Ring_Hom_Poly.of_int_poly P)", "by (intro squarefree_imp_rsquarefree)"], ["proof (state)\nthis:\n  rsquarefree (Ring_Hom_Poly.of_int_poly P)\n\ngoal (3 subgoals):\n 1. finite {..<n}\n 2. symmetric_mpoly {..<n} Q\n 3. Ring_Hom_Poly.of_int_poly P =\n    Polynomial.smult (of_int (Polynomial.lead_coeff P))\n     (\\<Prod>i<n. [:- Root i, 1:])", "hence \"of_int_poly P = Polynomial.smult lc (\\<Prod>x\\<in>Roots. [:-x, 1:])\""], ["proof (prove)\nusing this:\n  rsquarefree (Ring_Hom_Poly.of_int_poly P)\n\ngoal (1 subgoal):\n 1. Ring_Hom_Poly.of_int_poly P =\n    Polynomial.smult lc (\\<Prod>x\\<in>Roots. [:- x, 1:])", "unfolding lc_def Roots_def of_int_hom.hom_lead_coeff[symmetric]"], ["proof (prove)\nusing this:\n  rsquarefree (Ring_Hom_Poly.of_int_poly P)\n\ngoal (1 subgoal):\n 1. Ring_Hom_Poly.of_int_poly P =\n    Polynomial.smult (Polynomial.lead_coeff (Ring_Hom_Poly.of_int_poly P))\n     (\\<Prod>x\\<in>{x. ipoly P x = 0}. [:- x, 1:])", "by (rule complex_poly_decompose_rsquarefree [symmetric])"], ["proof (state)\nthis:\n  Ring_Hom_Poly.of_int_poly P =\n  Polynomial.smult lc (\\<Prod>x\\<in>Roots. [:- x, 1:])\n\ngoal (3 subgoals):\n 1. finite {..<n}\n 2. symmetric_mpoly {..<n} Q\n 3. Ring_Hom_Poly.of_int_poly P =\n    Polynomial.smult (of_int (Polynomial.lead_coeff P))\n     (\\<Prod>i<n. [:- Root i, 1:])", "also"], ["proof (state)\nthis:\n  Ring_Hom_Poly.of_int_poly P =\n  Polynomial.smult lc (\\<Prod>x\\<in>Roots. [:- x, 1:])\n\ngoal (3 subgoals):\n 1. finite {..<n}\n 2. symmetric_mpoly {..<n} Q\n 3. Ring_Hom_Poly.of_int_poly P =\n    Polynomial.smult (of_int (Polynomial.lead_coeff P))\n     (\\<Prod>i<n. [:- Root i, 1:])", "have \"(\\<Prod>x\\<in>Roots. [:-x, 1:]) = (\\<Prod>i<n. [:-Root i, 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<in>Roots. [:- x, 1:]) = (\\<Prod>i<n. [:- Root i, 1:])", "by (rule prod.reindex_bij_betw[OF Root, symmetric])"], ["proof (state)\nthis:\n  (\\<Prod>x\\<in>Roots. [:- x, 1:]) = (\\<Prod>i<n. [:- Root i, 1:])\n\ngoal (3 subgoals):\n 1. finite {..<n}\n 2. symmetric_mpoly {..<n} Q\n 3. Ring_Hom_Poly.of_int_poly P =\n    Polynomial.smult (of_int (Polynomial.lead_coeff P))\n     (\\<Prod>i<n. [:- Root i, 1:])", "finally"], ["proof (chain)\npicking this:\n  Ring_Hom_Poly.of_int_poly P =\n  Polynomial.smult lc (\\<Prod>i<n. [:- Root i, 1:])", "show \"of_int_poly P = Polynomial.smult lc (\\<Prod>i<n. [:- Root i, 1:])\""], ["proof (prove)\nusing this:\n  Ring_Hom_Poly.of_int_poly P =\n  Polynomial.smult lc (\\<Prod>i<n. [:- Root i, 1:])\n\ngoal (1 subgoal):\n 1. Ring_Hom_Poly.of_int_poly P =\n    Polynomial.smult lc (\\<Prod>i<n. [:- Root i, 1:])", "."], ["proof (state)\nthis:\n  Ring_Hom_Poly.of_int_poly P =\n  Polynomial.smult lc (\\<Prod>i<n. [:- Root i, 1:])\n\ngoal (2 subgoals):\n 1. finite {..<n}\n 2. symmetric_mpoly {..<n} Q", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. finite {..<n}\n 2. symmetric_mpoly {..<n} Q", "show \"symmetric_mpoly {..<n} Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric_mpoly {..<n} Q", "unfolding symmetric_mpoly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<pi>.\n       \\<pi> permutes {..<n} \\<longrightarrow> mpoly_map_vars \\<pi> Q = Q", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes {..<n} \\<Longrightarrow> mpoly_map_vars \\<pi> Q = Q", "fix \\<pi>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes {..<n} \\<Longrightarrow> mpoly_map_vars \\<pi> Q = Q", "assume \\<pi>: \"\\<pi> permutes {..<n}\""], ["proof (state)\nthis:\n  \\<pi> permutes {..<n}\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes {..<n} \\<Longrightarrow> mpoly_map_vars \\<pi> Q = Q", "have \"mpoly_map_vars \\<pi> Q = (\\<Prod>f\\<in>tuples X. Const (pCons 0 1) - (\\<Sum> \\<sigma> | \\<sigma> permutes {..<n}.\n                  Var ((\\<pi> \\<circ> \\<sigma>) (unRoot (f (convert_perm \\<sigma>))))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_map_vars \\<pi> Q =\n    (\\<Prod>f\\<in>tuples X.\n       Const (pCons 0 1) -\n       (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n          Var ((\\<pi> \\<circ> \\<sigma>)\n                (unRoot (f (convert_perm \\<sigma>))))))", "by (simp add: Q_def permutes_bij[OF \\<pi>])"], ["proof (state)\nthis:\n  mpoly_map_vars \\<pi> Q =\n  (\\<Prod>f\\<in>tuples X.\n     Const (pCons 0 1) -\n     (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n        Var ((\\<pi> \\<circ> \\<sigma>)\n              (unRoot (f (convert_perm \\<sigma>))))))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes {..<n} \\<Longrightarrow> mpoly_map_vars \\<pi> Q = Q", "also"], ["proof (state)\nthis:\n  mpoly_map_vars \\<pi> Q =\n  (\\<Prod>f\\<in>tuples X.\n     Const (pCons 0 1) -\n     (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n        Var ((\\<pi> \\<circ> \\<sigma>)\n              (unRoot (f (convert_perm \\<sigma>))))))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes {..<n} \\<Longrightarrow> mpoly_map_vars \\<pi> Q = Q", "have \"\\<dots> = (\\<Prod>f\\<in>tuples X. Const (pCons 0 1) - (\\<Sum> \\<sigma> | \\<sigma> permutes {..<n}.\n                  Var ((\\<pi> \\<circ> \\<sigma>) (unRoot ((f \\<circ> (\\<lambda>\\<sigma>. convert_perm \\<pi> \\<circ> \\<sigma>)) (convert_perm \\<sigma>))))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>f\\<in>tuples X.\n       Const (pCons 0 1) -\n       (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n          Var ((\\<pi> \\<circ> \\<sigma>)\n                (unRoot (f (convert_perm \\<sigma>)))))) =\n    (\\<Prod>f\\<in>tuples X.\n       Const (pCons 0 1) -\n       (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n          Var ((\\<pi> \\<circ> \\<sigma>)\n                (unRoot\n                  ((f \\<circ> (\\<circ>) (convert_perm \\<pi>))\n                    (convert_perm \\<sigma>))))))", "using \\<pi>"], ["proof (prove)\nusing this:\n  \\<pi> permutes {..<n}\n\ngoal (1 subgoal):\n 1. (\\<Prod>f\\<in>tuples X.\n       Const (pCons 0 1) -\n       (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n          Var ((\\<pi> \\<circ> \\<sigma>)\n                (unRoot (f (convert_perm \\<sigma>)))))) =\n    (\\<Prod>f\\<in>tuples X.\n       Const (pCons 0 1) -\n       (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n          Var ((\\<pi> \\<circ> \\<sigma>)\n                (unRoot\n                  ((f \\<circ> (\\<circ>) (convert_perm \\<pi>))\n                    (convert_perm \\<sigma>))))))", "by (intro prod.reindex_bij_betw [OF bij_convert', symmetric]) auto"], ["proof (state)\nthis:\n  (\\<Prod>f\\<in>tuples X.\n     Const (pCons 0 1) -\n     (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n        Var ((\\<pi> \\<circ> \\<sigma>)\n              (unRoot (f (convert_perm \\<sigma>)))))) =\n  (\\<Prod>f\\<in>tuples X.\n     Const (pCons 0 1) -\n     (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n        Var ((\\<pi> \\<circ> \\<sigma>)\n              (unRoot\n                ((f \\<circ> (\\<circ>) (convert_perm \\<pi>))\n                  (convert_perm \\<sigma>))))))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes {..<n} \\<Longrightarrow> mpoly_map_vars \\<pi> Q = Q", "also"], ["proof (state)\nthis:\n  (\\<Prod>f\\<in>tuples X.\n     Const (pCons 0 1) -\n     (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n        Var ((\\<pi> \\<circ> \\<sigma>)\n              (unRoot (f (convert_perm \\<sigma>)))))) =\n  (\\<Prod>f\\<in>tuples X.\n     Const (pCons 0 1) -\n     (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n        Var ((\\<pi> \\<circ> \\<sigma>)\n              (unRoot\n                ((f \\<circ> (\\<circ>) (convert_perm \\<pi>))\n                  (convert_perm \\<sigma>))))))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes {..<n} \\<Longrightarrow> mpoly_map_vars \\<pi> Q = Q", "have \"\\<dots> = Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>f\\<in>tuples X.\n       Const (pCons 0 1) -\n       (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n          Var ((\\<pi> \\<circ> \\<sigma>)\n                (unRoot\n                  ((f \\<circ> (\\<circ>) (convert_perm \\<pi>))\n                    (convert_perm \\<sigma>)))))) =\n    Q", "unfolding Q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>f\\<in>tuples X.\n       Const (pCons 0 1) -\n       (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n          Var ((\\<pi> \\<circ> \\<sigma>)\n                (unRoot\n                  ((f \\<circ> (\\<circ>) (convert_perm \\<pi>))\n                    (convert_perm \\<sigma>)))))) =\n    (\\<Prod>f\\<in>tuples X.\n       Const [:0, 1:] -\n       (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n          Var (\\<sigma> (unRoot (f (convert_perm \\<sigma>))))))", "proof (rule prod.cong, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. tuples X = tuples X\n 2. \\<And>x.\n       x \\<in> tuples X \\<Longrightarrow>\n       Const (pCons 0 1) -\n       (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n          Var ((\\<pi> \\<circ> \\<sigma>)\n                (unRoot\n                  ((x \\<circ> (\\<circ>) (convert_perm \\<pi>))\n                    (convert_perm \\<sigma>))))) =\n       Const [:0, 1:] -\n       (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n          Var (\\<sigma> (unRoot (x (convert_perm \\<sigma>)))))", "case (2 f)"], ["proof (state)\nthis:\n  f \\<in> tuples X\n\ngoal (2 subgoals):\n 1. tuples X = tuples X\n 2. \\<And>x.\n       x \\<in> tuples X \\<Longrightarrow>\n       Const (pCons 0 1) -\n       (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n          Var ((\\<pi> \\<circ> \\<sigma>)\n                (unRoot\n                  ((x \\<circ> (\\<circ>) (convert_perm \\<pi>))\n                    (convert_perm \\<sigma>))))) =\n       Const [:0, 1:] -\n       (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n          Var (\\<sigma> (unRoot (x (convert_perm \\<sigma>)))))", "have \"(\\<Sum> \\<sigma> | \\<sigma> permutes {..<n}. Var ((\\<pi> \\<circ> \\<sigma>) (unRoot ((f \\<circ> (\\<lambda>\\<sigma>. convert_perm \\<pi> \\<circ> \\<sigma>)) (convert_perm \\<sigma>))))) =\n                  (\\<Sum> \\<sigma> | \\<sigma> permutes {..<n}. Var ((\\<pi> \\<circ> \\<sigma>) (unRoot (f (convert_perm (\\<pi> \\<circ> \\<sigma>))))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n       Var ((\\<pi> \\<circ> \\<sigma>)\n             (unRoot\n               ((f \\<circ> (\\<circ>) (convert_perm \\<pi>))\n                 (convert_perm \\<sigma>))))) =\n    (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n       Var ((\\<pi> \\<circ> \\<sigma>)\n             (unRoot (f (convert_perm (\\<pi> \\<circ> \\<sigma>))))))", "using \\<pi>"], ["proof (prove)\nusing this:\n  \\<pi> permutes {..<n}\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n       Var ((\\<pi> \\<circ> \\<sigma>)\n             (unRoot\n               ((f \\<circ> (\\<circ>) (convert_perm \\<pi>))\n                 (convert_perm \\<sigma>))))) =\n    (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n       Var ((\\<pi> \\<circ> \\<sigma>)\n             (unRoot (f (convert_perm (\\<pi> \\<circ> \\<sigma>))))))", "by (intro sum.cong refl, subst convert_perm_compose) simp_all"], ["proof (state)\nthis:\n  (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n     Var ((\\<pi> \\<circ> \\<sigma>)\n           (unRoot\n             ((f \\<circ> (\\<circ>) (convert_perm \\<pi>))\n               (convert_perm \\<sigma>))))) =\n  (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n     Var ((\\<pi> \\<circ> \\<sigma>)\n           (unRoot (f (convert_perm (\\<pi> \\<circ> \\<sigma>))))))\n\ngoal (2 subgoals):\n 1. tuples X = tuples X\n 2. \\<And>x.\n       x \\<in> tuples X \\<Longrightarrow>\n       Const (pCons 0 1) -\n       (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n          Var ((\\<pi> \\<circ> \\<sigma>)\n                (unRoot\n                  ((x \\<circ> (\\<circ>) (convert_perm \\<pi>))\n                    (convert_perm \\<sigma>))))) =\n       Const [:0, 1:] -\n       (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n          Var (\\<sigma> (unRoot (x (convert_perm \\<sigma>)))))", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n     Var ((\\<pi> \\<circ> \\<sigma>)\n           (unRoot\n             ((f \\<circ> (\\<circ>) (convert_perm \\<pi>))\n               (convert_perm \\<sigma>))))) =\n  (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n     Var ((\\<pi> \\<circ> \\<sigma>)\n           (unRoot (f (convert_perm (\\<pi> \\<circ> \\<sigma>))))))\n\ngoal (2 subgoals):\n 1. tuples X = tuples X\n 2. \\<And>x.\n       x \\<in> tuples X \\<Longrightarrow>\n       Const (pCons 0 1) -\n       (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n          Var ((\\<pi> \\<circ> \\<sigma>)\n                (unRoot\n                  ((x \\<circ> (\\<circ>) (convert_perm \\<pi>))\n                    (convert_perm \\<sigma>))))) =\n       Const [:0, 1:] -\n       (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n          Var (\\<sigma> (unRoot (x (convert_perm \\<sigma>)))))", "have \"\\<dots> = (\\<Sum> \\<sigma> | \\<sigma> permutes {..<n}. Var (\\<sigma> (unRoot (f (convert_perm \\<sigma>)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n       Var ((\\<pi> \\<circ> \\<sigma>)\n             (unRoot (f (convert_perm (\\<pi> \\<circ> \\<sigma>)))))) =\n    (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n       Var (\\<sigma> (unRoot (f (convert_perm \\<sigma>)))))", "using \\<pi>"], ["proof (prove)\nusing this:\n  \\<pi> permutes {..<n}\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n       Var ((\\<pi> \\<circ> \\<sigma>)\n             (unRoot (f (convert_perm (\\<pi> \\<circ> \\<sigma>)))))) =\n    (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n       Var (\\<sigma> (unRoot (f (convert_perm \\<sigma>)))))", "by (rule setum_permutations_compose_left [symmetric])"], ["proof (state)\nthis:\n  (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n     Var ((\\<pi> \\<circ> \\<sigma>)\n           (unRoot (f (convert_perm (\\<pi> \\<circ> \\<sigma>)))))) =\n  (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n     Var (\\<sigma> (unRoot (f (convert_perm \\<sigma>)))))\n\ngoal (2 subgoals):\n 1. tuples X = tuples X\n 2. \\<And>x.\n       x \\<in> tuples X \\<Longrightarrow>\n       Const (pCons 0 1) -\n       (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n          Var ((\\<pi> \\<circ> \\<sigma>)\n                (unRoot\n                  ((x \\<circ> (\\<circ>) (convert_perm \\<pi>))\n                    (convert_perm \\<sigma>))))) =\n       Const [:0, 1:] -\n       (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n          Var (\\<sigma> (unRoot (x (convert_perm \\<sigma>)))))", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n     Var ((\\<pi> \\<circ> \\<sigma>)\n           (unRoot\n             ((f \\<circ> (\\<circ>) (convert_perm \\<pi>))\n               (convert_perm \\<sigma>))))) =\n  (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n     Var (\\<sigma> (unRoot (f (convert_perm \\<sigma>)))))", "show ?case"], ["proof (prove)\nusing this:\n  (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n     Var ((\\<pi> \\<circ> \\<sigma>)\n           (unRoot\n             ((f \\<circ> (\\<circ>) (convert_perm \\<pi>))\n               (convert_perm \\<sigma>))))) =\n  (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n     Var (\\<sigma> (unRoot (f (convert_perm \\<sigma>)))))\n\ngoal (1 subgoal):\n 1. Const (pCons 0 1) -\n    (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n       Var ((\\<pi> \\<circ> \\<sigma>)\n             (unRoot\n               ((f \\<circ> (\\<circ>) (convert_perm \\<pi>))\n                 (convert_perm \\<sigma>))))) =\n    Const [:0, 1:] -\n    (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n       Var (\\<sigma> (unRoot (f (convert_perm \\<sigma>)))))", "by simp"], ["proof (state)\nthis:\n  Const (pCons 0 1) -\n  (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n     Var ((\\<pi> \\<circ> \\<sigma>)\n           (unRoot\n             ((f \\<circ> (\\<circ>) (convert_perm \\<pi>))\n               (convert_perm \\<sigma>))))) =\n  Const [:0, 1:] -\n  (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n     Var (\\<sigma> (unRoot (f (convert_perm \\<sigma>)))))\n\ngoal (1 subgoal):\n 1. tuples X = tuples X", "qed auto"], ["proof (state)\nthis:\n  (\\<Prod>f\\<in>tuples X.\n     Const (pCons 0 1) -\n     (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n        Var ((\\<pi> \\<circ> \\<sigma>)\n              (unRoot\n                ((f \\<circ> (\\<circ>) (convert_perm \\<pi>))\n                  (convert_perm \\<sigma>)))))) =\n  Q\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes {..<n} \\<Longrightarrow> mpoly_map_vars \\<pi> Q = Q", "finally"], ["proof (chain)\npicking this:\n  mpoly_map_vars \\<pi> Q = Q", "show \"mpoly_map_vars \\<pi> Q = Q\""], ["proof (prove)\nusing this:\n  mpoly_map_vars \\<pi> Q = Q\n\ngoal (1 subgoal):\n 1. mpoly_map_vars \\<pi> Q = Q", "."], ["proof (state)\nthis:\n  mpoly_map_vars \\<pi> Q = Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  symmetric_mpoly {..<n} Q\n\ngoal (1 subgoal):\n 1. finite {..<n}", "qed auto"], ["proof (state)\nthis:\n  insertion (\\<lambda>x. [:Root x:]) Q \\<in> ratpolys\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>\\<And>X.\n                    X \\<in> Roots_ms \\<Longrightarrow>\n                    poly_roots (Ring_Hom_Poly.of_int_poly (Q X)) = R X;\n         \\<And>X.\n            X \\<in> Roots_ms \\<Longrightarrow>\n            Polynomial.content (Q X) = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  insertion (\\<lambda>x. [:Root x:]) Q \\<in> ratpolys\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>\\<And>X.\n                    X \\<in> Roots_ms \\<Longrightarrow>\n                    poly_roots (Ring_Hom_Poly.of_int_poly (Q X)) = R X;\n         \\<And>X.\n            X \\<in> Roots_ms \\<Longrightarrow>\n            Polynomial.content (Q X) = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"insertion (\\<lambda>x. [:Root x:]) Q = Q1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (\\<lambda>x. [:Root x:]) Q = Q1", "unfolding Q_def Q1_def insertion_prod insertion_sum insertion_diff insertion_Const insertion_Var"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<in>tuples X.\n       [:0, 1:] -\n       (\\<Sum>xa\\<in>{\\<sigma>. \\<sigma> permutes {..<n}}.\n          [:Root (xa (unRoot (x (convert_perm xa)))):])) =\n    (\\<Prod>f\\<in>tuples X.\n       [:- (\\<Sum>\\<sigma> | \\<sigma> permutes Roots.\n              \\<sigma> (f \\<sigma>)),\n         1:])", "proof (intro prod.cong, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. tuples X = tuples X\n 2. \\<And>x.\n       x \\<in> tuples X \\<Longrightarrow>\n       [:0, 1:] -\n       (\\<Sum>xa\\<in>{\\<sigma>. \\<sigma> permutes {..<n}}.\n          [:Root (xa (unRoot (x (convert_perm xa)))):]) =\n       [:- (\\<Sum>\\<sigma> | \\<sigma> permutes Roots.\n              \\<sigma> (x \\<sigma>)),\n         1:]", "case f: (2 f)"], ["proof (state)\nthis:\n  f \\<in> tuples X\n\ngoal (2 subgoals):\n 1. tuples X = tuples X\n 2. \\<And>x.\n       x \\<in> tuples X \\<Longrightarrow>\n       [:0, 1:] -\n       (\\<Sum>xa\\<in>{\\<sigma>. \\<sigma> permutes {..<n}}.\n          [:Root (xa (unRoot (x (convert_perm xa)))):]) =\n       [:- (\\<Sum>\\<sigma> | \\<sigma> permutes Roots.\n              \\<sigma> (x \\<sigma>)),\n         1:]", "have \"(\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}. [:Root (\\<sigma> (unRoot (f (convert_perm \\<sigma>)))):]) =\n              (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}. [:convert_perm \\<sigma> (f (convert_perm \\<sigma>)):])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n       [:Root (\\<sigma> (unRoot (f (convert_perm \\<sigma>)))):]) =\n    (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n       [:convert_perm \\<sigma> (f (convert_perm \\<sigma>)):])", "proof (rule sum.cong, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. {\\<sigma>. \\<sigma> permutes {..<n}} =\n    {\\<sigma>. \\<sigma> permutes {..<n}}\n 2. \\<And>x.\n       x \\<in> {\\<sigma>. \\<sigma> permutes {..<n}} \\<Longrightarrow>\n       [:Root (x (unRoot (f (convert_perm x)))):] =\n       [:convert_perm x (f (convert_perm x)):]", "case (2 \\<sigma>)"], ["proof (state)\nthis:\n  \\<sigma> \\<in> {\\<sigma>. \\<sigma> permutes {..<n}}\n\ngoal (2 subgoals):\n 1. {\\<sigma>. \\<sigma> permutes {..<n}} =\n    {\\<sigma>. \\<sigma> permutes {..<n}}\n 2. \\<And>x.\n       x \\<in> {\\<sigma>. \\<sigma> permutes {..<n}} \\<Longrightarrow>\n       [:Root (x (unRoot (f (convert_perm x)))):] =\n       [:convert_perm x (f (convert_perm x)):]", "have \"convert_perm \\<sigma> permutes Roots\""], ["proof (prove)\ngoal (1 subgoal):\n 1. convert_perm \\<sigma> permutes Roots", "using bij_convert 2"], ["proof (prove)\nusing this:\n  bij_betw convert_perm {\\<sigma>. \\<sigma> permutes {..<n}}\n   {\\<sigma>. \\<sigma> permutes Roots}\n  \\<sigma> \\<in> {\\<sigma>. \\<sigma> permutes {..<n}}\n\ngoal (1 subgoal):\n 1. convert_perm \\<sigma> permutes Roots", "by (auto simp: bij_betw_def)"], ["proof (state)\nthis:\n  convert_perm \\<sigma> permutes Roots\n\ngoal (2 subgoals):\n 1. {\\<sigma>. \\<sigma> permutes {..<n}} =\n    {\\<sigma>. \\<sigma> permutes {..<n}}\n 2. \\<And>x.\n       x \\<in> {\\<sigma>. \\<sigma> permutes {..<n}} \\<Longrightarrow>\n       [:Root (x (unRoot (f (convert_perm x)))):] =\n       [:convert_perm x (f (convert_perm x)):]", "hence \"f (convert_perm \\<sigma>) \\<in> Roots\""], ["proof (prove)\nusing this:\n  convert_perm \\<sigma> permutes Roots\n\ngoal (1 subgoal):\n 1. f (convert_perm \\<sigma>) \\<in> Roots", "using f"], ["proof (prove)\nusing this:\n  convert_perm \\<sigma> permutes Roots\n  f \\<in> tuples X\n\ngoal (1 subgoal):\n 1. f (convert_perm \\<sigma>) \\<in> Roots", "by (auto simp: tuples_def perms_def)"], ["proof (state)\nthis:\n  f (convert_perm \\<sigma>) \\<in> Roots\n\ngoal (2 subgoals):\n 1. {\\<sigma>. \\<sigma> permutes {..<n}} =\n    {\\<sigma>. \\<sigma> permutes {..<n}}\n 2. \\<And>x.\n       x \\<in> {\\<sigma>. \\<sigma> permutes {..<n}} \\<Longrightarrow>\n       [:Root (x (unRoot (f (convert_perm x)))):] =\n       [:convert_perm x (f (convert_perm x)):]", "thus ?case"], ["proof (prove)\nusing this:\n  f (convert_perm \\<sigma>) \\<in> Roots\n\ngoal (1 subgoal):\n 1. [:Root (\\<sigma> (unRoot (f (convert_perm \\<sigma>)))):] =\n    [:convert_perm \\<sigma> (f (convert_perm \\<sigma>)):]", "by (simp add: convert_perm_def)"], ["proof (state)\nthis:\n  [:Root (\\<sigma> (unRoot (f (convert_perm \\<sigma>)))):] =\n  [:convert_perm \\<sigma> (f (convert_perm \\<sigma>)):]\n\ngoal (1 subgoal):\n 1. {\\<sigma>. \\<sigma> permutes {..<n}} =\n    {\\<sigma>. \\<sigma> permutes {..<n}}", "qed simp_all"], ["proof (state)\nthis:\n  (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n     [:Root (\\<sigma> (unRoot (f (convert_perm \\<sigma>)))):]) =\n  (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n     [:convert_perm \\<sigma> (f (convert_perm \\<sigma>)):])\n\ngoal (2 subgoals):\n 1. tuples X = tuples X\n 2. \\<And>x.\n       x \\<in> tuples X \\<Longrightarrow>\n       [:0, 1:] -\n       (\\<Sum>xa\\<in>{\\<sigma>. \\<sigma> permutes {..<n}}.\n          [:Root (xa (unRoot (x (convert_perm xa)))):]) =\n       [:- (\\<Sum>\\<sigma> | \\<sigma> permutes Roots.\n              \\<sigma> (x \\<sigma>)),\n         1:]", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n     [:Root (\\<sigma> (unRoot (f (convert_perm \\<sigma>)))):]) =\n  (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n     [:convert_perm \\<sigma> (f (convert_perm \\<sigma>)):])\n\ngoal (2 subgoals):\n 1. tuples X = tuples X\n 2. \\<And>x.\n       x \\<in> tuples X \\<Longrightarrow>\n       [:0, 1:] -\n       (\\<Sum>xa\\<in>{\\<sigma>. \\<sigma> permutes {..<n}}.\n          [:Root (xa (unRoot (x (convert_perm xa)))):]) =\n       [:- (\\<Sum>\\<sigma> | \\<sigma> permutes Roots.\n              \\<sigma> (x \\<sigma>)),\n         1:]", "have \"\\<dots> = (\\<Sum>\\<sigma> | \\<sigma> permutes Roots. [:\\<sigma> (f \\<sigma>):])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n       [:convert_perm \\<sigma> (f (convert_perm \\<sigma>)):]) =\n    (\\<Sum>\\<sigma> | \\<sigma> permutes Roots. [:\\<sigma> (f \\<sigma>):])", "by (rule sum.reindex_bij_betw[OF bij_convert])"], ["proof (state)\nthis:\n  (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n     [:convert_perm \\<sigma> (f (convert_perm \\<sigma>)):]) =\n  (\\<Sum>\\<sigma> | \\<sigma> permutes Roots. [:\\<sigma> (f \\<sigma>):])\n\ngoal (2 subgoals):\n 1. tuples X = tuples X\n 2. \\<And>x.\n       x \\<in> tuples X \\<Longrightarrow>\n       [:0, 1:] -\n       (\\<Sum>xa\\<in>{\\<sigma>. \\<sigma> permutes {..<n}}.\n          [:Root (xa (unRoot (x (convert_perm xa)))):]) =\n       [:- (\\<Sum>\\<sigma> | \\<sigma> permutes Roots.\n              \\<sigma> (x \\<sigma>)),\n         1:]", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n     [:Root (\\<sigma> (unRoot (f (convert_perm \\<sigma>)))):]) =\n  (\\<Sum>\\<sigma> | \\<sigma> permutes Roots. [:\\<sigma> (f \\<sigma>):])", "show ?case"], ["proof (prove)\nusing this:\n  (\\<Sum>\\<sigma> | \\<sigma> permutes {..<n}.\n     [:Root (\\<sigma> (unRoot (f (convert_perm \\<sigma>)))):]) =\n  (\\<Sum>\\<sigma> | \\<sigma> permutes Roots. [:\\<sigma> (f \\<sigma>):])\n\ngoal (1 subgoal):\n 1. [:0, 1:] -\n    (\\<Sum>x\\<in>{\\<sigma>. \\<sigma> permutes {..<n}}.\n       [:Root (x (unRoot (f (convert_perm x)))):]) =\n    [:- (\\<Sum>\\<sigma> | \\<sigma> permutes Roots. \\<sigma> (f \\<sigma>)),\n      1:]", "by (simp flip: pCons_one coeff_lift_hom.hom_sum)"], ["proof (state)\nthis:\n  [:0, 1:] -\n  (\\<Sum>x\\<in>{\\<sigma>. \\<sigma> permutes {..<n}}.\n     [:Root (x (unRoot (f (convert_perm x)))):]) =\n  [:- (\\<Sum>\\<sigma> | \\<sigma> permutes Roots. \\<sigma> (f \\<sigma>)), 1:]\n\ngoal (1 subgoal):\n 1. tuples X = tuples X", "qed simp_all"], ["proof (state)\nthis:\n  insertion (\\<lambda>x. [:Root x:]) Q = Q1\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>\\<And>X.\n                    X \\<in> Roots_ms \\<Longrightarrow>\n                    poly_roots (Ring_Hom_Poly.of_int_poly (Q X)) = R X;\n         \\<And>X.\n            X \\<in> Roots_ms \\<Longrightarrow>\n            Polynomial.content (Q X) = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  Q1 \\<in> ratpolys", "have \"Q1 \\<in> ratpolys\""], ["proof (prove)\nusing this:\n  Q1 \\<in> ratpolys\n\ngoal (1 subgoal):\n 1. Q1 \\<in> ratpolys", "by auto"], ["proof (state)\nthis:\n  Q1 \\<in> ratpolys\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>\\<And>X.\n                    X \\<in> Roots_ms \\<Longrightarrow>\n                    poly_roots (Ring_Hom_Poly.of_int_poly (Q X)) = R X;\n         \\<And>X.\n            X \\<in> Roots_ms \\<Longrightarrow>\n            Polynomial.content (Q X) = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  Q1 \\<in> ratpolys", "obtain Q2 :: \"rat poly\" where Q2: \"Q1 = map_poly of_rat Q2\""], ["proof (prove)\nusing this:\n  Q1 \\<in> ratpolys\n\ngoal (1 subgoal):\n 1. (\\<And>Q2.\n        Q1 = map_poly of_rat Q2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding ratpolys_def"], ["proof (prove)\nusing this:\n  Q1 \\<in> {p. \\<forall>i. poly.coeff p i \\<in> \\<rat>}\n\ngoal (1 subgoal):\n 1. (\\<And>Q2.\n        Q1 = map_poly of_rat Q2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using ratpolyE[of Q1]"], ["proof (prove)\nusing this:\n  Q1 \\<in> {p. \\<forall>i. poly.coeff p i \\<in> \\<rat>}\n  \\<lbrakk>\\<forall>i. poly.coeff Q1 i \\<in> \\<rat>;\n   \\<And>q. Q1 = map_poly of_rat q \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>Q2.\n        Q1 = map_poly of_rat Q2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  Q1 = map_poly of_rat Q2\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>\\<And>X.\n                    X \\<in> Roots_ms \\<Longrightarrow>\n                    poly_roots (Ring_Hom_Poly.of_int_poly (Q X)) = R X;\n         \\<And>X.\n            X \\<in> Roots_ms \\<Longrightarrow>\n            Polynomial.content (Q X) = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"Q1 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Q1 \\<noteq> 0", "unfolding Q1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>f\\<in>tuples X.\n       [:- (\\<Sum>\\<sigma> | \\<sigma> permutes Roots.\n              \\<sigma> (f \\<sigma>)),\n         1:]) \\<noteq>\n    0", "using fin_tuples[of X]"], ["proof (prove)\nusing this:\n  finite (tuples X)\n\ngoal (1 subgoal):\n 1. (\\<Prod>f\\<in>tuples X.\n       [:- (\\<Sum>\\<sigma> | \\<sigma> permutes Roots.\n              \\<sigma> (f \\<sigma>)),\n         1:]) \\<noteq>\n    0", "by auto"], ["proof (state)\nthis:\n  Q1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>\\<And>X.\n                    X \\<in> Roots_ms \\<Longrightarrow>\n                    poly_roots (Ring_Hom_Poly.of_int_poly (Q X)) = R X;\n         \\<And>X.\n            X \\<in> Roots_ms \\<Longrightarrow>\n            Polynomial.content (Q X) = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "with Q2"], ["proof (chain)\npicking this:\n  Q1 = map_poly of_rat Q2\n  Q1 \\<noteq> 0", "have \"Q2 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  Q1 = map_poly of_rat Q2\n  Q1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. Q2 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  Q2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>\\<And>X.\n                    X \\<in> Roots_ms \\<Longrightarrow>\n                    poly_roots (Ring_Hom_Poly.of_int_poly (Q X)) = R X;\n         \\<And>X.\n            X \\<in> Roots_ms \\<Longrightarrow>\n            Polynomial.content (Q X) = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "obtain Q3 :: \"int poly\" and lc :: rat\n        where Q3: \"Q2 = Polynomial.smult lc (of_int_poly Q3)\" and \"lc > 0\" and \"content Q3 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>lc Q3.\n        \\<lbrakk>Q2 = Polynomial.smult lc (Ring_Hom_Poly.of_int_poly Q3);\n         0 < lc; Polynomial.content Q3 = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using rat_to_normalized_int_poly_exists[OF \\<open>Q2 \\<noteq> 0\\<close>]"], ["proof (prove)\nusing this:\n  (\\<And>q lc.\n      \\<lbrakk>Q2 = Polynomial.smult lc (Ring_Hom_Poly.of_int_poly q);\n       0 < lc; Polynomial.content q = 1\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>lc Q3.\n        \\<lbrakk>Q2 = Polynomial.smult lc (Ring_Hom_Poly.of_int_poly Q3);\n         0 < lc; Polynomial.content Q3 = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  Q2 = Polynomial.smult lc (Ring_Hom_Poly.of_int_poly Q3)\n  0 < lc\n  Polynomial.content Q3 = 1\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>\\<And>X.\n                    X \\<in> Roots_ms \\<Longrightarrow>\n                    poly_roots (Ring_Hom_Poly.of_int_poly (Q X)) = R X;\n         \\<And>X.\n            X \\<in> Roots_ms \\<Longrightarrow>\n            Polynomial.content (Q X) = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"poly_roots (of_int_poly Q3) = poly_roots (map_poly (of_rat \\<circ> of_int) Q3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_roots (Ring_Hom_Poly.of_int_poly Q3) =\n    poly_roots (map_poly (of_rat \\<circ> rat_of_int) Q3)", "by simp"], ["proof (state)\nthis:\n  poly_roots (Ring_Hom_Poly.of_int_poly Q3) =\n  poly_roots (map_poly (of_rat \\<circ> rat_of_int) Q3)\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>\\<And>X.\n                    X \\<in> Roots_ms \\<Longrightarrow>\n                    poly_roots (Ring_Hom_Poly.of_int_poly (Q X)) = R X;\n         \\<And>X.\n            X \\<in> Roots_ms \\<Longrightarrow>\n            Polynomial.content (Q X) = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  poly_roots (Ring_Hom_Poly.of_int_poly Q3) =\n  poly_roots (map_poly (of_rat \\<circ> rat_of_int) Q3)\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>\\<And>X.\n                    X \\<in> Roots_ms \\<Longrightarrow>\n                    poly_roots (Ring_Hom_Poly.of_int_poly (Q X)) = R X;\n         \\<And>X.\n            X \\<in> Roots_ms \\<Longrightarrow>\n            Polynomial.content (Q X) = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"map_poly (of_rat \\<circ> of_int) Q3 = map_poly of_rat (map_poly of_int Q3)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly (of_rat \\<circ> rat_of_int) Q3 =\n    map_poly of_rat (Ring_Hom_Poly.of_int_poly Q3)", "by (subst map_poly_map_poly) auto"], ["proof (state)\nthis:\n  map_poly (of_rat \\<circ> rat_of_int) Q3 =\n  map_poly of_rat (Ring_Hom_Poly.of_int_poly Q3)\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>\\<And>X.\n                    X \\<in> Roots_ms \\<Longrightarrow>\n                    poly_roots (Ring_Hom_Poly.of_int_poly (Q X)) = R X;\n         \\<And>X.\n            X \\<in> Roots_ms \\<Longrightarrow>\n            Polynomial.content (Q X) = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  map_poly (of_rat \\<circ> rat_of_int) Q3 =\n  map_poly of_rat (Ring_Hom_Poly.of_int_poly Q3)\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>\\<And>X.\n                    X \\<in> Roots_ms \\<Longrightarrow>\n                    poly_roots (Ring_Hom_Poly.of_int_poly (Q X)) = R X;\n         \\<And>X.\n            X \\<in> Roots_ms \\<Longrightarrow>\n            Polynomial.content (Q X) = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"poly_roots \\<dots> = poly_roots (Polynomial.smult (of_rat lc) \\<dots>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_roots (map_poly of_rat (Ring_Hom_Poly.of_int_poly Q3)) =\n    poly_roots\n     (Polynomial.smult (of_rat lc)\n       (map_poly of_rat (Ring_Hom_Poly.of_int_poly Q3)))", "using \\<open>lc > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < lc\n\ngoal (1 subgoal):\n 1. poly_roots (map_poly of_rat (Ring_Hom_Poly.of_int_poly Q3)) =\n    poly_roots\n     (Polynomial.smult (of_rat lc)\n       (map_poly of_rat (Ring_Hom_Poly.of_int_poly Q3)))", "by simp"], ["proof (state)\nthis:\n  poly_roots (map_poly of_rat (Ring_Hom_Poly.of_int_poly Q3)) =\n  poly_roots\n   (Polynomial.smult (of_rat lc)\n     (map_poly of_rat (Ring_Hom_Poly.of_int_poly Q3)))\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>\\<And>X.\n                    X \\<in> Roots_ms \\<Longrightarrow>\n                    poly_roots (Ring_Hom_Poly.of_int_poly (Q X)) = R X;\n         \\<And>X.\n            X \\<in> Roots_ms \\<Longrightarrow>\n            Polynomial.content (Q X) = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  poly_roots (map_poly of_rat (Ring_Hom_Poly.of_int_poly Q3)) =\n  poly_roots\n   (Polynomial.smult (of_rat lc)\n     (map_poly of_rat (Ring_Hom_Poly.of_int_poly Q3)))\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>\\<And>X.\n                    X \\<in> Roots_ms \\<Longrightarrow>\n                    poly_roots (Ring_Hom_Poly.of_int_poly (Q X)) = R X;\n         \\<And>X.\n            X \\<in> Roots_ms \\<Longrightarrow>\n            Polynomial.content (Q X) = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"Polynomial.smult (of_rat lc) (map_poly of_rat (map_poly of_int Q3)) =\n                 map_poly of_rat (Polynomial.smult lc (map_poly of_int Q3))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.smult (of_rat lc)\n     (map_poly of_rat (Ring_Hom_Poly.of_int_poly Q3)) =\n    map_poly of_rat (Polynomial.smult lc (Ring_Hom_Poly.of_int_poly Q3))", "by (simp add: of_rat_hom.map_poly_hom_smult)"], ["proof (state)\nthis:\n  Polynomial.smult (of_rat lc)\n   (map_poly of_rat (Ring_Hom_Poly.of_int_poly Q3)) =\n  map_poly of_rat (Polynomial.smult lc (Ring_Hom_Poly.of_int_poly Q3))\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>\\<And>X.\n                    X \\<in> Roots_ms \\<Longrightarrow>\n                    poly_roots (Ring_Hom_Poly.of_int_poly (Q X)) = R X;\n         \\<And>X.\n            X \\<in> Roots_ms \\<Longrightarrow>\n            Polynomial.content (Q X) = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  Polynomial.smult (of_rat lc)\n   (map_poly of_rat (Ring_Hom_Poly.of_int_poly Q3)) =\n  map_poly of_rat (Polynomial.smult lc (Ring_Hom_Poly.of_int_poly Q3))\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>\\<And>X.\n                    X \\<in> Roots_ms \\<Longrightarrow>\n                    poly_roots (Ring_Hom_Poly.of_int_poly (Q X)) = R X;\n         \\<And>X.\n            X \\<in> Roots_ms \\<Longrightarrow>\n            Polynomial.content (Q X) = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<dots> = Q1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map_poly of_rat (Polynomial.smult lc (Ring_Hom_Poly.of_int_poly Q3)) =\n    Q1", "by (simp only: Q3 [symmetric] Q2 [symmetric])"], ["proof (state)\nthis:\n  map_poly of_rat (Polynomial.smult lc (Ring_Hom_Poly.of_int_poly Q3)) = Q1\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>\\<And>X.\n                    X \\<in> Roots_ms \\<Longrightarrow>\n                    poly_roots (Ring_Hom_Poly.of_int_poly (Q X)) = R X;\n         \\<And>X.\n            X \\<in> Roots_ms \\<Longrightarrow>\n            Polynomial.content (Q X) = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "also"], ["proof (state)\nthis:\n  map_poly of_rat (Polynomial.smult lc (Ring_Hom_Poly.of_int_poly Q3)) = Q1\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>\\<And>X.\n                    X \\<in> Roots_ms \\<Longrightarrow>\n                    poly_roots (Ring_Hom_Poly.of_int_poly (Q X)) = R X;\n         \\<And>X.\n            X \\<in> Roots_ms \\<Longrightarrow>\n            Polynomial.content (Q X) = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"poly_roots Q1 = R X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_roots Q1 = R X", "unfolding Q1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_roots\n     (\\<Prod>f\\<in>tuples X.\n        [:- (\\<Sum>\\<sigma> | \\<sigma> permutes Roots.\n               \\<sigma> (f \\<sigma>)),\n          1:]) =\n    R X", "by (subst poly_roots_prod, force, subst poly_roots_linear)\n           (auto simp: R_def perms_def sum_mset_image_mset_singleton sum_unfold_sum_mset)"], ["proof (state)\nthis:\n  poly_roots Q1 = R X\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>\\<And>X.\n                    X \\<in> Roots_ms \\<Longrightarrow>\n                    poly_roots (Ring_Hom_Poly.of_int_poly (Q X)) = R X;\n         \\<And>X.\n            X \\<in> Roots_ms \\<Longrightarrow>\n            Polynomial.content (Q X) = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "finally"], ["proof (chain)\npicking this:\n  poly_roots (Ring_Hom_Poly.of_int_poly Q3) = R X", "have \"\\<exists>Q. poly_roots (of_int_poly Q) = R X \\<and> content Q = 1\""], ["proof (prove)\nusing this:\n  poly_roots (Ring_Hom_Poly.of_int_poly Q3) = R X\n\ngoal (1 subgoal):\n 1. \\<exists>Q.\n       poly_roots (Ring_Hom_Poly.of_int_poly Q) = R X \\<and>\n       Polynomial.content Q = 1", "using \\<open>content Q3 = 1\\<close>"], ["proof (prove)\nusing this:\n  poly_roots (Ring_Hom_Poly.of_int_poly Q3) = R X\n  Polynomial.content Q3 = 1\n\ngoal (1 subgoal):\n 1. \\<exists>Q.\n       poly_roots (Ring_Hom_Poly.of_int_poly Q) = R X \\<and>\n       Polynomial.content Q = 1", "by metis"], ["proof (state)\nthis:\n  \\<exists>Q.\n     poly_roots (Ring_Hom_Poly.of_int_poly Q) = R X \\<and>\n     Polynomial.content Q = 1\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>\\<And>X.\n                    X \\<in> Roots_ms \\<Longrightarrow>\n                    poly_roots (Ring_Hom_Poly.of_int_poly (Q X)) = R X;\n         \\<And>X.\n            X \\<in> Roots_ms \\<Longrightarrow>\n            Polynomial.content (Q X) = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "}"], ["proof (state)\nthis:\n  ?Xa2 \\<in> Roots_ms \\<Longrightarrow>\n  \\<exists>Q.\n     poly_roots (Ring_Hom_Poly.of_int_poly Q) = R ?Xa2 \\<and>\n     Polynomial.content Q = 1\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>\\<And>X.\n                    X \\<in> Roots_ms \\<Longrightarrow>\n                    poly_roots (Ring_Hom_Poly.of_int_poly (Q X)) = R X;\n         \\<And>X.\n            X \\<in> Roots_ms \\<Longrightarrow>\n            Polynomial.content (Q X) = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"\\<exists>Q. \\<forall>X\\<in>Roots_ms. poly_roots (of_int_poly (Q X)) = R X \\<and> content (Q X) = 1\""], ["proof (prove)\nusing this:\n  ?Xa2 \\<in> Roots_ms \\<Longrightarrow>\n  \\<exists>Q.\n     poly_roots (Ring_Hom_Poly.of_int_poly Q) = R ?Xa2 \\<and>\n     Polynomial.content Q = 1\n\ngoal (1 subgoal):\n 1. \\<exists>Q.\n       \\<forall>X\\<in>Roots_ms.\n          poly_roots (Ring_Hom_Poly.of_int_poly (Q X)) = R X \\<and>\n          Polynomial.content (Q X) = 1", "by metis"], ["proof (state)\nthis:\n  \\<exists>Q.\n     \\<forall>X\\<in>Roots_ms.\n        poly_roots (Ring_Hom_Poly.of_int_poly (Q X)) = R X \\<and>\n        Polynomial.content (Q X) = 1\n\ngoal (1 subgoal):\n 1. (\\<And>Q.\n        \\<lbrakk>\\<And>X.\n                    X \\<in> Roots_ms \\<Longrightarrow>\n                    poly_roots (Ring_Hom_Poly.of_int_poly (Q X)) = R X;\n         \\<And>X.\n            X \\<in> Roots_ms \\<Longrightarrow>\n            Polynomial.content (Q X) = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>Q.\n     \\<forall>X\\<in>Roots_ms.\n        poly_roots (Ring_Hom_Poly.of_int_poly (Q X)) = R X \\<and>\n        Polynomial.content (Q X) = 1\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  \\<exists>Q.\n     \\<forall>X\\<in>Roots_ms.\n        poly_roots (Ring_Hom_Poly.of_int_poly (Q X)) = R X \\<and>\n        Polynomial.content (Q X) = 1\n  \\<lbrakk>\\<And>X.\n              X \\<in> Roots_ms \\<Longrightarrow>\n              poly_roots (Ring_Hom_Poly.of_int_poly (?Q X)) = R X;\n   \\<And>X.\n      X \\<in> Roots_ms \\<Longrightarrow>\n      Polynomial.content (?Q X) = 1\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. thesis", "by metis"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?X \\<in> Roots_ms \\<Longrightarrow>\n  poly_roots (Ring_Hom_Poly.of_int_poly (Q ?X)) = R ?X\n  ?X \\<in> Roots_ms \\<Longrightarrow> Polynomial.content (Q ?X) = 1\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "text \\<open>\n    We can now collect all the $e^{\\sum \\alpha_i}$ that happen to be equal and let the following\n    be their coefficients:\n  \\<close>"], ["proof (state)\nthis:\n  ?X \\<in> Roots_ms \\<Longrightarrow>\n  poly_roots (Ring_Hom_Poly.of_int_poly (Q ?X)) = R ?X\n  ?X \\<in> Roots_ms \\<Longrightarrow> Polynomial.content (Q ?X) = 1\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "define \\<beta>'' :: \"int poly \\<Rightarrow> int\"\n    where \"\\<beta>'' = (\\<lambda>q. \\<Sum>X\\<in>Roots_ms. int (count (prime_factorization (Q X)) q) * (\\<Prod>x\\<in>#X. \\<beta>' x))\""], ["proof (state)\nthis:\n  \\<beta>'' =\n  (\\<lambda>q.\n      \\<Sum>X\\<in>Roots_ms.\n        int (count (prime_factorization (Q X)) q) *\n        \\<Prod>\\<^sub># (image_mset \\<beta>' X))\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have supp_\\<beta>'': \"{q. \\<beta>'' q \\<noteq> 0} \\<subseteq> (\\<Union>X\\<in>Roots_ms. prime_factors (Q X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {q. \\<beta>'' q \\<noteq> 0}\n    \\<subseteq> (\\<Union>X\\<in>Roots_ms. prime_factors (Q X))", "unfolding \\<beta>''_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {q. (\\<Sum>X\\<in>Roots_ms.\n           int (count (prime_factorization (Q X)) q) *\n           \\<Prod>\\<^sub># (image_mset \\<beta>' X)) \\<noteq>\n        0}\n    \\<subseteq> (\\<Union>X\\<in>Roots_ms. prime_factors (Q X))", "using sum.not_neutral_contains_not_neutral"], ["proof (prove)\nusing this:\n  \\<lbrakk>sum ?g ?A \\<noteq> (0::?'a);\n   \\<And>a.\n      \\<lbrakk>a \\<in> ?A; ?g a \\<noteq> (0::?'a)\\<rbrakk>\n      \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. {q. (\\<Sum>X\\<in>Roots_ms.\n           int (count (prime_factorization (Q X)) q) *\n           \\<Prod>\\<^sub># (image_mset \\<beta>' X)) \\<noteq>\n        0}\n    \\<subseteq> (\\<Union>X\\<in>Roots_ms. prime_factors (Q X))", "by fastforce"], ["proof (state)\nthis:\n  {q. \\<beta>'' q \\<noteq> 0}\n  \\<subseteq> (\\<Union>X\\<in>Roots_ms. prime_factors (Q X))\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "text \\<open>\n    We have to prove that \\<open>\\<beta>''\\<close> is not zero everywhere. We do this by selecting the nonzero term\n    with the maximal exponent (w.r.t. the lexicographic ordering on the complex numbers) in every\n    factor of the product and show that there is no other summand corresponding to these, so\n    that their non-zero coefficient cannot get cancelled.\n  \\<close>"], ["proof (state)\nthis:\n  {q. \\<beta>'' q \\<noteq> 0}\n  \\<subseteq> (\\<Union>X\\<in>Roots_ms. prime_factors (Q X))\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have \"{q. \\<beta>'' q \\<noteq> 0} \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {q. \\<beta>'' q \\<noteq> 0} \\<noteq> {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. {q. \\<beta>'' q \\<noteq> 0} \\<noteq> {}", "define f where \"f = restrict (\\<lambda>\\<sigma>. inv_into UNIV \\<sigma> (complex_lex.Max (\\<sigma> ` X))) perms\""], ["proof (state)\nthis:\n  f =\n  (\\<lambda>\\<sigma>\\<in>perms.\n      inv \\<sigma> (complex_lex.Max (\\<sigma> ` X)))\n\ngoal (1 subgoal):\n 1. {q. \\<beta>'' q \\<noteq> 0} \\<noteq> {}", "have f: \"f \\<in> perms \\<rightarrow> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> perms \\<rightarrow> X", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> perms \\<Longrightarrow> f x \\<in> X", "fix \\<sigma>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> perms \\<Longrightarrow> f x \\<in> X", "assume \\<sigma>: \"\\<sigma> \\<in> perms\""], ["proof (state)\nthis:\n  \\<sigma> \\<in> perms\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> perms \\<Longrightarrow> f x \\<in> X", "have \"complex_lex.Max (\\<sigma> ` X) \\<in> \\<sigma> ` X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_lex.Max (\\<sigma> ` X) \\<in> \\<sigma> ` X", "using \\<open>X \\<noteq> {}\\<close>"], ["proof (prove)\nusing this:\n  X \\<noteq> {}\n\ngoal (1 subgoal):\n 1. complex_lex.Max (\\<sigma> ` X) \\<in> \\<sigma> ` X", "by (intro complex_lex.Max_in finite_imageI) auto"], ["proof (state)\nthis:\n  complex_lex.Max (\\<sigma> ` X) \\<in> \\<sigma> ` X\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> perms \\<Longrightarrow> f x \\<in> X", "thus \"f \\<sigma> \\<in> X\""], ["proof (prove)\nusing this:\n  complex_lex.Max (\\<sigma> ` X) \\<in> \\<sigma> ` X\n\ngoal (1 subgoal):\n 1. f \\<sigma> \\<in> X", "using \\<sigma>"], ["proof (prove)\nusing this:\n  complex_lex.Max (\\<sigma> ` X) \\<in> \\<sigma> ` X\n  \\<sigma> \\<in> perms\n\ngoal (1 subgoal):\n 1. f \\<sigma> \\<in> X", "by (auto simp: f_def permutes_inverses[of \\<sigma> Roots] perms_def)"], ["proof (state)\nthis:\n  f \\<sigma> \\<in> X\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f \\<in> perms \\<rightarrow> X\n\ngoal (1 subgoal):\n 1. {q. \\<beta>'' q \\<noteq> 0} \\<noteq> {}", "hence f': \"f \\<in> perms \\<rightarrow>\\<^sub>E Roots\""], ["proof (prove)\nusing this:\n  f \\<in> perms \\<rightarrow> X\n\ngoal (1 subgoal):\n 1. f \\<in> perms \\<rightarrow>\\<^sub>E Roots", "using \\<open>X \\<subseteq> Roots\\<close>"], ["proof (prove)\nusing this:\n  f \\<in> perms \\<rightarrow> X\n  X \\<subseteq> Roots\n\ngoal (1 subgoal):\n 1. f \\<in> perms \\<rightarrow>\\<^sub>E Roots", "by (auto simp: f_def PiE_def)"], ["proof (state)\nthis:\n  f \\<in> perms \\<rightarrow>\\<^sub>E Roots\n\ngoal (1 subgoal):\n 1. {q. \\<beta>'' q \\<noteq> 0} \\<noteq> {}", "define Y where \"Y = image_mset f (mset_set perms)\""], ["proof (state)\nthis:\n  Y = image_mset f (mset_set perms)\n\ngoal (1 subgoal):\n 1. {q. \\<beta>'' q \\<noteq> 0} \\<noteq> {}", "have \"Y \\<in> Roots_ms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y \\<in> Roots_ms", "using f' \\<open>finite perms\\<close>"], ["proof (prove)\nusing this:\n  f \\<in> perms \\<rightarrow>\\<^sub>E Roots\n  finite perms\n\ngoal (1 subgoal):\n 1. Y \\<in> Roots_ms", "by (auto simp: Roots_ms_def Y_def)"], ["proof (state)\nthis:\n  Y \\<in> Roots_ms\n\ngoal (1 subgoal):\n 1. {q. \\<beta>'' q \\<noteq> 0} \\<noteq> {}", "have \"(\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)) \\<in># R Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)) \\<in># R Y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)) \\<in># R Y", "from f'"], ["proof (chain)\npicking this:\n  f \\<in> perms \\<rightarrow>\\<^sub>E Roots", "have \"f \\<in> tuples Y\""], ["proof (prove)\nusing this:\n  f \\<in> perms \\<rightarrow>\\<^sub>E Roots\n\ngoal (1 subgoal):\n 1. f \\<in> tuples Y", "unfolding tuples_def Y_def"], ["proof (prove)\nusing this:\n  f \\<in> perms \\<rightarrow>\\<^sub>E Roots\n\ngoal (1 subgoal):\n 1. f \\<in> {fa \\<in> perms \\<rightarrow>\\<^sub>E Roots.\n             image_mset fa (mset_set perms) = image_mset f (mset_set perms)}", "by simp"], ["proof (state)\nthis:\n  f \\<in> tuples Y\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)) \\<in># R Y", "thus ?thesis"], ["proof (prove)\nusing this:\n  f \\<in> tuples Y\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)) \\<in># R Y", "unfolding R_def"], ["proof (prove)\nusing this:\n  f \\<in> tuples Y\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>))\n    \\<in># {#\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)\n           . f \\<in># mset_set (tuples Y)#}", "using fin_tuples[of Y]"], ["proof (prove)\nusing this:\n  f \\<in> tuples Y\n  finite (tuples Y)\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>))\n    \\<in># {#\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)\n           . f \\<in># mset_set (tuples Y)#}", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)) \\<in># R Y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)) \\<in># R Y\n\ngoal (1 subgoal):\n 1. {q. \\<beta>'' q \\<noteq> 0} \\<noteq> {}", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)) \\<in># R Y\n\ngoal (1 subgoal):\n 1. {q. \\<beta>'' q \\<noteq> 0} \\<noteq> {}", "have \"R Y = poly_roots (of_int_poly (Q Y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. R Y = poly_roots (Ring_Hom_Poly.of_int_poly (Q Y))", "by (rule Q(1) [symmetric]) fact"], ["proof (state)\nthis:\n  R Y = poly_roots (Ring_Hom_Poly.of_int_poly (Q Y))\n\ngoal (1 subgoal):\n 1. {q. \\<beta>'' q \\<noteq> 0} \\<noteq> {}", "also"], ["proof (state)\nthis:\n  R Y = poly_roots (Ring_Hom_Poly.of_int_poly (Q Y))\n\ngoal (1 subgoal):\n 1. {q. \\<beta>'' q \\<noteq> 0} \\<noteq> {}", "have \"\\<dots> = (\\<Sum>p\\<in>#prime_factorization (Q Y). poly_roots (of_int_poly p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_roots (Ring_Hom_Poly.of_int_poly (Q Y)) =\n    (\\<Sum>p\\<in>#prime_factorization\n                   (Q Y). poly_roots (Ring_Hom_Poly.of_int_poly p))", "by (rule poly_roots_of_int_conv_sum_prime_factors)"], ["proof (state)\nthis:\n  poly_roots (Ring_Hom_Poly.of_int_poly (Q Y)) =\n  (\\<Sum>p\\<in>#prime_factorization\n                 (Q Y). poly_roots (Ring_Hom_Poly.of_int_poly p))\n\ngoal (1 subgoal):\n 1. {q. \\<beta>'' q \\<noteq> 0} \\<noteq> {}", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>))\n  \\<in># (\\<Sum>p\\<in>#prime_factorization\n                        (Q Y). poly_roots (Ring_Hom_Poly.of_int_poly p))", "obtain q where q: \"q \\<in> prime_factors (Q Y)\" \"(\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)) \\<in># poly_roots (of_int_poly q)\""], ["proof (prove)\nusing this:\n  (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>))\n  \\<in># (\\<Sum>p\\<in>#prime_factorization\n                        (Q Y). poly_roots (Ring_Hom_Poly.of_int_poly p))\n\ngoal (1 subgoal):\n 1. (\\<And>q.\n        \\<lbrakk>q \\<in># prime_factorization (Q Y);\n         (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>))\n         \\<in># poly_roots (Ring_Hom_Poly.of_int_poly q)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  q \\<in># prime_factorization (Q Y)\n  (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>))\n  \\<in># poly_roots (Ring_Hom_Poly.of_int_poly q)\n\ngoal (1 subgoal):\n 1. {q. \\<beta>'' q \\<noteq> 0} \\<noteq> {}", "have \"\\<beta>'' q = (\\<Sum>X\\<in>{Y}. int (count (prime_factorization (Q X)) q) * prod_mset (image_mset \\<beta>' X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta>'' q =\n    (\\<Sum>X\\<in>{Y}.\n       int (count (prime_factorization (Q X)) q) *\n       \\<Prod>\\<^sub># (image_mset \\<beta>' X))", "unfolding \\<beta>''_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>X\\<in>Roots_ms.\n       int (count (prime_factorization (Q X)) q) *\n       \\<Prod>\\<^sub># (image_mset \\<beta>' X)) =\n    (\\<Sum>X\\<in>{Y}.\n       int (count (prime_factorization (Q X)) q) *\n       \\<Prod>\\<^sub># (image_mset \\<beta>' X))", "proof (intro sum.mono_neutral_right ballI)"], ["proof (state)\ngoal (3 subgoals):\n 1. finite Roots_ms\n 2. {Y} \\<subseteq> Roots_ms\n 3. \\<And>i.\n       i \\<in> Roots_ms - {Y} \\<Longrightarrow>\n       int (count (prime_factorization (Q i)) q) *\n       \\<Prod>\\<^sub># (image_mset \\<beta>' i) =\n       0", "fix Y'"], ["proof (state)\ngoal (3 subgoals):\n 1. finite Roots_ms\n 2. {Y} \\<subseteq> Roots_ms\n 3. \\<And>i.\n       i \\<in> Roots_ms - {Y} \\<Longrightarrow>\n       int (count (prime_factorization (Q i)) q) *\n       \\<Prod>\\<^sub># (image_mset \\<beta>' i) =\n       0", "assume Y': \"Y' \\<in> Roots_ms - {Y}\""], ["proof (state)\nthis:\n  Y' \\<in> Roots_ms - {Y}\n\ngoal (3 subgoals):\n 1. finite Roots_ms\n 2. {Y} \\<subseteq> Roots_ms\n 3. \\<And>i.\n       i \\<in> Roots_ms - {Y} \\<Longrightarrow>\n       int (count (prime_factorization (Q i)) q) *\n       \\<Prod>\\<^sub># (image_mset \\<beta>' i) =\n       0", "show \"int (count (prime_factorization (Q Y')) q) * \\<Prod>\\<^sub># (image_mset \\<beta>' Y') = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (count (prime_factorization (Q Y')) q) *\n    \\<Prod>\\<^sub># (image_mset \\<beta>' Y') =\n    0", "proof (cases \"set_mset Y' \\<subseteq> X\")"], ["proof (state)\ngoal (2 subgoals):\n 1. set_mset Y' \\<subseteq> X \\<Longrightarrow>\n    int (count (prime_factorization (Q Y')) q) *\n    \\<Prod>\\<^sub># (image_mset \\<beta>' Y') =\n    0\n 2. \\<not> set_mset Y' \\<subseteq> X \\<Longrightarrow>\n    int (count (prime_factorization (Q Y')) q) *\n    \\<Prod>\\<^sub># (image_mset \\<beta>' Y') =\n    0", "case Y'_subset: True"], ["proof (state)\nthis:\n  set_mset Y' \\<subseteq> X\n\ngoal (2 subgoals):\n 1. set_mset Y' \\<subseteq> X \\<Longrightarrow>\n    int (count (prime_factorization (Q Y')) q) *\n    \\<Prod>\\<^sub># (image_mset \\<beta>' Y') =\n    0\n 2. \\<not> set_mset Y' \\<subseteq> X \\<Longrightarrow>\n    int (count (prime_factorization (Q Y')) q) *\n    \\<Prod>\\<^sub># (image_mset \\<beta>' Y') =\n    0", "have \"q \\<notin> prime_factors (Q Y')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q \\<notin> prime_factors (Q Y')", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. q \\<in># prime_factorization (Q Y') \\<Longrightarrow> False", "assume q': \"q \\<in> prime_factors (Q Y')\""], ["proof (state)\nthis:\n  q \\<in># prime_factorization (Q Y')\n\ngoal (1 subgoal):\n 1. q \\<in># prime_factorization (Q Y') \\<Longrightarrow> False", "have \"poly_roots (of_int_poly q :: complex poly) \\<subseteq>#\n                         poly_roots (of_int_poly (Q Y'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_roots (Ring_Hom_Poly.of_int_poly q) \\<subseteq>#\n    poly_roots (Ring_Hom_Poly.of_int_poly (Q Y'))", "using q'"], ["proof (prove)\nusing this:\n  q \\<in># prime_factorization (Q Y')\n\ngoal (1 subgoal):\n 1. poly_roots (Ring_Hom_Poly.of_int_poly q) \\<subseteq>#\n    poly_roots (Ring_Hom_Poly.of_int_poly (Q Y'))", "by (intro dvd_imp_poly_roots_subset of_int_poly_hom.hom_dvd) auto"], ["proof (state)\nthis:\n  poly_roots (Ring_Hom_Poly.of_int_poly q) \\<subseteq>#\n  poly_roots (Ring_Hom_Poly.of_int_poly (Q Y'))\n\ngoal (1 subgoal):\n 1. q \\<in># prime_factorization (Q Y') \\<Longrightarrow> False", "with q(2)"], ["proof (chain)\npicking this:\n  (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>))\n  \\<in># poly_roots (Ring_Hom_Poly.of_int_poly q)\n  poly_roots (Ring_Hom_Poly.of_int_poly q) \\<subseteq>#\n  poly_roots (Ring_Hom_Poly.of_int_poly (Q Y'))", "have \"(\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)) \\<in># poly_roots (of_int_poly (Q Y'))\""], ["proof (prove)\nusing this:\n  (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>))\n  \\<in># poly_roots (Ring_Hom_Poly.of_int_poly q)\n  poly_roots (Ring_Hom_Poly.of_int_poly q) \\<subseteq>#\n  poly_roots (Ring_Hom_Poly.of_int_poly (Q Y'))\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>))\n    \\<in># poly_roots (Ring_Hom_Poly.of_int_poly (Q Y'))", "by (meson mset_subset_eqD)"], ["proof (state)\nthis:\n  (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>))\n  \\<in># poly_roots (Ring_Hom_Poly.of_int_poly (Q Y'))\n\ngoal (1 subgoal):\n 1. q \\<in># prime_factorization (Q Y') \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>))\n  \\<in># poly_roots (Ring_Hom_Poly.of_int_poly (Q Y'))\n\ngoal (1 subgoal):\n 1. q \\<in># prime_factorization (Q Y') \\<Longrightarrow> False", "have \"poly_roots (of_int_poly (Q Y')) = R Y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. poly_roots (Ring_Hom_Poly.of_int_poly (Q Y')) = R Y'", "using Q(1)[of Y'] Y'"], ["proof (prove)\nusing this:\n  Y' \\<in> Roots_ms \\<Longrightarrow>\n  poly_roots (Ring_Hom_Poly.of_int_poly (Q Y')) = R Y'\n  Y' \\<in> Roots_ms - {Y}\n\ngoal (1 subgoal):\n 1. poly_roots (Ring_Hom_Poly.of_int_poly (Q Y')) = R Y'", "by auto"], ["proof (state)\nthis:\n  poly_roots (Ring_Hom_Poly.of_int_poly (Q Y')) = R Y'\n\ngoal (1 subgoal):\n 1. q \\<in># prime_factorization (Q Y') \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)) \\<in># R Y'", "obtain g where g: \"g \\<in> tuples Y'\" \"(\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)) = (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (g \\<sigma>))\""], ["proof (prove)\nusing this:\n  (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)) \\<in># R Y'\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g \\<in> tuples Y';\n         (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)) =\n         (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (g \\<sigma>))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding R_def"], ["proof (prove)\nusing this:\n  (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>))\n  \\<in># {#\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)\n         . f \\<in># mset_set (tuples Y')#}\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g \\<in> tuples Y';\n         (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)) =\n         (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (g \\<sigma>))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using fin_tuples[of Y']"], ["proof (prove)\nusing this:\n  (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>))\n  \\<in># {#\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)\n         . f \\<in># mset_set (tuples Y')#}\n  finite (tuples Y')\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<lbrakk>g \\<in> tuples Y';\n         (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)) =\n         (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (g \\<sigma>))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  g \\<in> tuples Y'\n  (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)) =\n  (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (g \\<sigma>))\n\ngoal (1 subgoal):\n 1. q \\<in># prime_factorization (Q Y') \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  g \\<in> tuples Y'\n  (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)) =\n  (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (g \\<sigma>))\n\ngoal (1 subgoal):\n 1. q \\<in># prime_factorization (Q Y') \\<Longrightarrow> False", "have \"(\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (g \\<sigma>)) <\\<^sub>\\<complex> (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (g \\<sigma>)) <\\<^sub>\\<complex>\n    (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>))", "proof (rule sum_strict_mono_ex1_complex_lex)"], ["proof (state)\ngoal (3 subgoals):\n 1. finite perms\n 2. \\<forall>x\\<in>perms. x (g x) \\<le>\\<^sub>\\<complex> x (f x)\n 3. \\<exists>a\\<in>perms. a (g a) <\\<^sub>\\<complex> a (f a)", "show le: \"\\<forall>\\<sigma>\\<in>perms. \\<sigma> (g \\<sigma>) \\<le>\\<^sub>\\<complex> \\<sigma> (f \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>\\<in>perms.\n       \\<sigma> (g \\<sigma>) \\<le>\\<^sub>\\<complex> \\<sigma> (f \\<sigma>)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> perms \\<Longrightarrow>\n       \\<sigma> (g \\<sigma>) \\<le>\\<^sub>\\<complex> \\<sigma> (f \\<sigma>)", "fix \\<sigma>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> perms \\<Longrightarrow>\n       \\<sigma> (g \\<sigma>) \\<le>\\<^sub>\\<complex> \\<sigma> (f \\<sigma>)", "assume \\<sigma>: \"\\<sigma> \\<in> perms\""], ["proof (state)\nthis:\n  \\<sigma> \\<in> perms\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> perms \\<Longrightarrow>\n       \\<sigma> (g \\<sigma>) \\<le>\\<^sub>\\<complex> \\<sigma> (f \\<sigma>)", "hence \\<sigma>': \"\\<sigma> permutes Roots\""], ["proof (prove)\nusing this:\n  \\<sigma> \\<in> perms\n\ngoal (1 subgoal):\n 1. \\<sigma> permutes Roots", "by (auto simp: perms_def)"], ["proof (state)\nthis:\n  \\<sigma> permutes Roots\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> perms \\<Longrightarrow>\n       \\<sigma> (g \\<sigma>) \\<le>\\<^sub>\\<complex> \\<sigma> (f \\<sigma>)", "have \"image_mset g (mset_set perms) = Y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. image_mset g (mset_set perms) = Y'", "using g"], ["proof (prove)\nusing this:\n  g \\<in> tuples Y'\n  (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)) =\n  (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (g \\<sigma>))\n\ngoal (1 subgoal):\n 1. image_mset g (mset_set perms) = Y'", "by (auto simp: tuples_def)"], ["proof (state)\nthis:\n  image_mset g (mset_set perms) = Y'\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> perms \\<Longrightarrow>\n       \\<sigma> (g \\<sigma>) \\<le>\\<^sub>\\<complex> \\<sigma> (f \\<sigma>)", "also"], ["proof (state)\nthis:\n  image_mset g (mset_set perms) = Y'\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> perms \\<Longrightarrow>\n       \\<sigma> (g \\<sigma>) \\<le>\\<^sub>\\<complex> \\<sigma> (f \\<sigma>)", "have \"set_mset \\<dots> \\<subseteq> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_mset Y' \\<subseteq> X", "by fact"], ["proof (state)\nthis:\n  set_mset Y' \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> perms \\<Longrightarrow>\n       \\<sigma> (g \\<sigma>) \\<le>\\<^sub>\\<complex> \\<sigma> (f \\<sigma>)", "finally"], ["proof (chain)\npicking this:\n  set_mset (image_mset g (mset_set perms)) \\<subseteq> X", "have \"g ` perms \\<subseteq> X\""], ["proof (prove)\nusing this:\n  set_mset (image_mset g (mset_set perms)) \\<subseteq> X\n\ngoal (1 subgoal):\n 1. g ` perms \\<subseteq> X", "using \\<open>finite perms\\<close>"], ["proof (prove)\nusing this:\n  set_mset (image_mset g (mset_set perms)) \\<subseteq> X\n  finite perms\n\ngoal (1 subgoal):\n 1. g ` perms \\<subseteq> X", "by auto"], ["proof (state)\nthis:\n  g ` perms \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> perms \\<Longrightarrow>\n       \\<sigma> (g \\<sigma>) \\<le>\\<^sub>\\<complex> \\<sigma> (f \\<sigma>)", "hence \"\\<sigma> (g \\<sigma>) \\<le>\\<^sub>\\<complex> complex_lex.Max (\\<sigma> ` X)\""], ["proof (prove)\nusing this:\n  g ` perms \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<sigma> (g \\<sigma>) \\<le>\\<^sub>\\<complex>\n    complex_lex.Max (\\<sigma> ` X)", "using \\<open>finite perms\\<close> \\<sigma>"], ["proof (prove)\nusing this:\n  g ` perms \\<subseteq> X\n  finite perms\n  \\<sigma> \\<in> perms\n\ngoal (1 subgoal):\n 1. \\<sigma> (g \\<sigma>) \\<le>\\<^sub>\\<complex>\n    complex_lex.Max (\\<sigma> ` X)", "by (intro complex_lex.Max.coboundedI finite_imageI imageI)\n                   (auto simp: tuples_def)"], ["proof (state)\nthis:\n  \\<sigma> (g \\<sigma>) \\<le>\\<^sub>\\<complex>\n  complex_lex.Max (\\<sigma> ` X)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> perms \\<Longrightarrow>\n       \\<sigma> (g \\<sigma>) \\<le>\\<^sub>\\<complex> \\<sigma> (f \\<sigma>)", "also"], ["proof (state)\nthis:\n  \\<sigma> (g \\<sigma>) \\<le>\\<^sub>\\<complex>\n  complex_lex.Max (\\<sigma> ` X)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> perms \\<Longrightarrow>\n       \\<sigma> (g \\<sigma>) \\<le>\\<^sub>\\<complex> \\<sigma> (f \\<sigma>)", "have \"\\<dots> = \\<sigma> (f \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_lex.Max (\\<sigma> ` X) = \\<sigma> (f \\<sigma>)", "using \\<sigma>"], ["proof (prove)\nusing this:\n  \\<sigma> \\<in> perms\n\ngoal (1 subgoal):\n 1. complex_lex.Max (\\<sigma> ` X) = \\<sigma> (f \\<sigma>)", "by (simp add: f_def permutes_inverses[OF \\<sigma>'])"], ["proof (state)\nthis:\n  complex_lex.Max (\\<sigma> ` X) = \\<sigma> (f \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<sigma> \\<in> perms \\<Longrightarrow>\n       \\<sigma> (g \\<sigma>) \\<le>\\<^sub>\\<complex> \\<sigma> (f \\<sigma>)", "finally"], ["proof (chain)\npicking this:\n  \\<sigma> (g \\<sigma>) \\<le>\\<^sub>\\<complex> \\<sigma> (f \\<sigma>)", "show \"\\<sigma> (g \\<sigma>) \\<le>\\<^sub>\\<complex> \\<sigma> (f \\<sigma>)\""], ["proof (prove)\nusing this:\n  \\<sigma> (g \\<sigma>) \\<le>\\<^sub>\\<complex> \\<sigma> (f \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<sigma> (g \\<sigma>) \\<le>\\<^sub>\\<complex> \\<sigma> (f \\<sigma>)", "."], ["proof (state)\nthis:\n  \\<sigma> (g \\<sigma>) \\<le>\\<^sub>\\<complex> \\<sigma> (f \\<sigma>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>\\<sigma>\\<in>perms.\n     \\<sigma> (g \\<sigma>) \\<le>\\<^sub>\\<complex> \\<sigma> (f \\<sigma>)\n\ngoal (2 subgoals):\n 1. finite perms\n 2. \\<exists>a\\<in>perms. a (g a) <\\<^sub>\\<complex> a (f a)", "have \"image_mset g (mset_set perms) \\<noteq> image_mset f (mset_set perms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. image_mset g (mset_set perms) \\<noteq> image_mset f (mset_set perms)", "using Y' g"], ["proof (prove)\nusing this:\n  Y' \\<in> Roots_ms - {Y}\n  g \\<in> tuples Y'\n  (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)) =\n  (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (g \\<sigma>))\n\ngoal (1 subgoal):\n 1. image_mset g (mset_set perms) \\<noteq> image_mset f (mset_set perms)", "by (auto simp: tuples_def Y_def)"], ["proof (state)\nthis:\n  image_mset g (mset_set perms) \\<noteq> image_mset f (mset_set perms)\n\ngoal (2 subgoals):\n 1. finite perms\n 2. \\<exists>a\\<in>perms. a (g a) <\\<^sub>\\<complex> a (f a)", "then"], ["proof (chain)\npicking this:\n  image_mset g (mset_set perms) \\<noteq> image_mset f (mset_set perms)", "obtain \\<sigma> where \\<sigma>: \"\\<sigma> \\<in># mset_set perms\" \"g \\<sigma> \\<noteq> f \\<sigma>\""], ["proof (prove)\nusing this:\n  image_mset g (mset_set perms) \\<noteq> image_mset f (mset_set perms)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>.\n        \\<lbrakk>\\<sigma> \\<in># mset_set perms;\n         g \\<sigma> \\<noteq> f \\<sigma>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (meson multiset.map_cong)"], ["proof (state)\nthis:\n  \\<sigma> \\<in># mset_set perms\n  g \\<sigma> \\<noteq> f \\<sigma>\n\ngoal (2 subgoals):\n 1. finite perms\n 2. \\<exists>a\\<in>perms. a (g a) <\\<^sub>\\<complex> a (f a)", "have \"\\<sigma> permutes Roots\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> permutes Roots", "using \\<sigma> \\<open>finite perms\\<close>"], ["proof (prove)\nusing this:\n  \\<sigma> \\<in># mset_set perms\n  g \\<sigma> \\<noteq> f \\<sigma>\n  finite perms\n\ngoal (1 subgoal):\n 1. \\<sigma> permutes Roots", "by (auto simp: perms_def)"], ["proof (state)\nthis:\n  \\<sigma> permutes Roots\n\ngoal (2 subgoals):\n 1. finite perms\n 2. \\<exists>a\\<in>perms. a (g a) <\\<^sub>\\<complex> a (f a)", "have \"\\<sigma> (g \\<sigma>) \\<noteq> \\<sigma> (f \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> (g \\<sigma>) \\<noteq> \\<sigma> (f \\<sigma>)", "using permutes_inj[OF \\<open>\\<sigma> permutes Roots\\<close>] \\<sigma>"], ["proof (prove)\nusing this:\n  inj \\<sigma>\n  \\<sigma> \\<in># mset_set perms\n  g \\<sigma> \\<noteq> f \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<sigma> (g \\<sigma>) \\<noteq> \\<sigma> (f \\<sigma>)", "by (auto simp: inj_def)"], ["proof (state)\nthis:\n  \\<sigma> (g \\<sigma>) \\<noteq> \\<sigma> (f \\<sigma>)\n\ngoal (2 subgoals):\n 1. finite perms\n 2. \\<exists>a\\<in>perms. a (g a) <\\<^sub>\\<complex> a (f a)", "moreover"], ["proof (state)\nthis:\n  \\<sigma> (g \\<sigma>) \\<noteq> \\<sigma> (f \\<sigma>)\n\ngoal (2 subgoals):\n 1. finite perms\n 2. \\<exists>a\\<in>perms. a (g a) <\\<^sub>\\<complex> a (f a)", "have \"\\<sigma> (g \\<sigma>) \\<le>\\<^sub>\\<complex> \\<sigma> (f \\<sigma>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma> (g \\<sigma>) \\<le>\\<^sub>\\<complex> \\<sigma> (f \\<sigma>)", "using le \\<sigma> \\<open>finite perms\\<close>"], ["proof (prove)\nusing this:\n  \\<forall>\\<sigma>\\<in>perms.\n     \\<sigma> (g \\<sigma>) \\<le>\\<^sub>\\<complex> \\<sigma> (f \\<sigma>)\n  \\<sigma> \\<in># mset_set perms\n  g \\<sigma> \\<noteq> f \\<sigma>\n  finite perms\n\ngoal (1 subgoal):\n 1. \\<sigma> (g \\<sigma>) \\<le>\\<^sub>\\<complex> \\<sigma> (f \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  \\<sigma> (g \\<sigma>) \\<le>\\<^sub>\\<complex> \\<sigma> (f \\<sigma>)\n\ngoal (2 subgoals):\n 1. finite perms\n 2. \\<exists>a\\<in>perms. a (g a) <\\<^sub>\\<complex> a (f a)", "ultimately"], ["proof (chain)\npicking this:\n  \\<sigma> (g \\<sigma>) \\<noteq> \\<sigma> (f \\<sigma>)\n  \\<sigma> (g \\<sigma>) \\<le>\\<^sub>\\<complex> \\<sigma> (f \\<sigma>)", "have \"\\<sigma> (g \\<sigma>) <\\<^sub>\\<complex> \\<sigma> (f \\<sigma>)\""], ["proof (prove)\nusing this:\n  \\<sigma> (g \\<sigma>) \\<noteq> \\<sigma> (f \\<sigma>)\n  \\<sigma> (g \\<sigma>) \\<le>\\<^sub>\\<complex> \\<sigma> (f \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<sigma> (g \\<sigma>) <\\<^sub>\\<complex> \\<sigma> (f \\<sigma>)", "by simp"], ["proof (state)\nthis:\n  \\<sigma> (g \\<sigma>) <\\<^sub>\\<complex> \\<sigma> (f \\<sigma>)\n\ngoal (2 subgoals):\n 1. finite perms\n 2. \\<exists>a\\<in>perms. a (g a) <\\<^sub>\\<complex> a (f a)", "thus \"\\<exists>\\<sigma>\\<in>perms. \\<sigma> (g \\<sigma>) <\\<^sub>\\<complex> \\<sigma> (f \\<sigma>)\""], ["proof (prove)\nusing this:\n  \\<sigma> (g \\<sigma>) <\\<^sub>\\<complex> \\<sigma> (f \\<sigma>)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>\\<in>perms.\n       \\<sigma> (g \\<sigma>) <\\<^sub>\\<complex> \\<sigma> (f \\<sigma>)", "using \\<sigma> \\<open>finite perms\\<close>"], ["proof (prove)\nusing this:\n  \\<sigma> (g \\<sigma>) <\\<^sub>\\<complex> \\<sigma> (f \\<sigma>)\n  \\<sigma> \\<in># mset_set perms\n  g \\<sigma> \\<noteq> f \\<sigma>\n  finite perms\n\ngoal (1 subgoal):\n 1. \\<exists>\\<sigma>\\<in>perms.\n       \\<sigma> (g \\<sigma>) <\\<^sub>\\<complex> \\<sigma> (f \\<sigma>)", "by auto"], ["proof (state)\nthis:\n  \\<exists>\\<sigma>\\<in>perms.\n     \\<sigma> (g \\<sigma>) <\\<^sub>\\<complex> \\<sigma> (f \\<sigma>)\n\ngoal (1 subgoal):\n 1. finite perms", "qed (use \\<open>finite perms\\<close> in simp_all)"], ["proof (state)\nthis:\n  (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (g \\<sigma>)) <\\<^sub>\\<complex>\n  (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>))\n\ngoal (1 subgoal):\n 1. q \\<in># prime_factorization (Q Y') \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  g \\<in> tuples Y'\n  (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)) =\n  (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (g \\<sigma>))\n  (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (g \\<sigma>)) <\\<^sub>\\<complex>\n  (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>))", "show False"], ["proof (prove)\nusing this:\n  g \\<in> tuples Y'\n  (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)) =\n  (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (g \\<sigma>))\n  (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (g \\<sigma>)) <\\<^sub>\\<complex>\n  (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>))\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  q \\<notin> prime_factors (Q Y')\n\ngoal (2 subgoals):\n 1. set_mset Y' \\<subseteq> X \\<Longrightarrow>\n    int (count (prime_factorization (Q Y')) q) *\n    \\<Prod>\\<^sub># (image_mset \\<beta>' Y') =\n    0\n 2. \\<not> set_mset Y' \\<subseteq> X \\<Longrightarrow>\n    int (count (prime_factorization (Q Y')) q) *\n    \\<Prod>\\<^sub># (image_mset \\<beta>' Y') =\n    0", "thus ?thesis"], ["proof (prove)\nusing this:\n  q \\<notin> prime_factors (Q Y')\n\ngoal (1 subgoal):\n 1. int (count (prime_factorization (Q Y')) q) *\n    \\<Prod>\\<^sub># (image_mset \\<beta>' Y') =\n    0", "by auto"], ["proof (state)\nthis:\n  int (count (prime_factorization (Q Y')) q) *\n  \\<Prod>\\<^sub># (image_mset \\<beta>' Y') =\n  0\n\ngoal (1 subgoal):\n 1. \\<not> set_mset Y' \\<subseteq> X \\<Longrightarrow>\n    int (count (prime_factorization (Q Y')) q) *\n    \\<Prod>\\<^sub># (image_mset \\<beta>' Y') =\n    0", "qed (auto simp: \\<beta>'_def)"], ["proof (state)\nthis:\n  int (count (prime_factorization (Q Y')) q) *\n  \\<Prod>\\<^sub># (image_mset \\<beta>' Y') =\n  0\n\ngoal (2 subgoals):\n 1. finite Roots_ms\n 2. {Y} \\<subseteq> Roots_ms", "qed (use \\<open>Y \\<in> Roots_ms\\<close> in auto)"], ["proof (state)\nthis:\n  \\<beta>'' q =\n  (\\<Sum>X\\<in>{Y}.\n     int (count (prime_factorization (Q X)) q) *\n     \\<Prod>\\<^sub># (image_mset \\<beta>' X))\n\ngoal (1 subgoal):\n 1. {q. \\<beta>'' q \\<noteq> 0} \\<noteq> {}", "also"], ["proof (state)\nthis:\n  \\<beta>'' q =\n  (\\<Sum>X\\<in>{Y}.\n     int (count (prime_factorization (Q X)) q) *\n     \\<Prod>\\<^sub># (image_mset \\<beta>' X))\n\ngoal (1 subgoal):\n 1. {q. \\<beta>'' q \\<noteq> 0} \\<noteq> {}", "have \"\\<dots> = int (count (prime_factorization (Q Y)) q) * prod_mset (image_mset \\<beta>' Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>X\\<in>{Y}.\n       int (count (prime_factorization (Q X)) q) *\n       \\<Prod>\\<^sub># (image_mset \\<beta>' X)) =\n    int (count (prime_factorization (Q Y)) q) *\n    \\<Prod>\\<^sub># (image_mset \\<beta>' Y)", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>X\\<in>{Y}.\n     int (count (prime_factorization (Q X)) q) *\n     \\<Prod>\\<^sub># (image_mset \\<beta>' X)) =\n  int (count (prime_factorization (Q Y)) q) *\n  \\<Prod>\\<^sub># (image_mset \\<beta>' Y)\n\ngoal (1 subgoal):\n 1. {q. \\<beta>'' q \\<noteq> 0} \\<noteq> {}", "also"], ["proof (state)\nthis:\n  (\\<Sum>X\\<in>{Y}.\n     int (count (prime_factorization (Q X)) q) *\n     \\<Prod>\\<^sub># (image_mset \\<beta>' X)) =\n  int (count (prime_factorization (Q Y)) q) *\n  \\<Prod>\\<^sub># (image_mset \\<beta>' Y)\n\ngoal (1 subgoal):\n 1. {q. \\<beta>'' q \\<noteq> 0} \\<noteq> {}", "have \"\\<dots> \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (count (prime_factorization (Q Y)) q) *\n    \\<Prod>\\<^sub># (image_mset \\<beta>' Y) \\<noteq>\n    0", "using q nz \\<open>finite X\\<close> \\<open>X \\<noteq> {}\\<close> \\<open>finite perms\\<close> f"], ["proof (prove)\nusing this:\n  q \\<in># prime_factorization (Q Y)\n  (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>))\n  \\<in># poly_roots (Ring_Hom_Poly.of_int_poly q)\n  ?x \\<in> X \\<Longrightarrow> \\<beta> ?x \\<noteq> 0\n  finite X\n  X \\<noteq> {}\n  finite perms\n  f \\<in> perms \\<rightarrow> X\n\ngoal (1 subgoal):\n 1. int (count (prime_factorization (Q Y)) q) *\n    \\<Prod>\\<^sub># (image_mset \\<beta>' Y) \\<noteq>\n    0", "by (auto simp: \\<beta>'_def Y_def)"], ["proof (state)\nthis:\n  int (count (prime_factorization (Q Y)) q) *\n  \\<Prod>\\<^sub># (image_mset \\<beta>' Y) \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. {q. \\<beta>'' q \\<noteq> 0} \\<noteq> {}", "finally"], ["proof (chain)\npicking this:\n  \\<beta>'' q \\<noteq> 0", "show \"{q. \\<beta>'' q \\<noteq> 0} \\<noteq> {}\""], ["proof (prove)\nusing this:\n  \\<beta>'' q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. {q. \\<beta>'' q \\<noteq> 0} \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  {q. \\<beta>'' q \\<noteq> 0} \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {q. \\<beta>'' q \\<noteq> 0} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "text \\<open>\n    We are now ready for the final push: we start with the original sum that we know to be zero,\n    multiply it with the other permutations, and then multiply out the sum.\n  \\<close>"], ["proof (state)\nthis:\n  {q. \\<beta>'' q \\<noteq> 0} \\<noteq> {}\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have \"0 = (\\<Sum>x\\<in>X. \\<beta> x * exp x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = (\\<Sum>x\\<in>X. of_int (\\<beta> x) * exp x)", "using sum0"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>X. of_int (\\<beta> x) * exp x) = 0\n\ngoal (1 subgoal):\n 1. 0 = (\\<Sum>x\\<in>X. of_int (\\<beta> x) * exp x)", ".."], ["proof (state)\nthis:\n  0 = (\\<Sum>x\\<in>X. of_int (\\<beta> x) * exp x)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  0 = (\\<Sum>x\\<in>X. of_int (\\<beta> x) * exp x)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have \"\\<dots> = (\\<Sum>x\\<in>Roots. \\<beta>' x * exp x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>X. of_int (\\<beta> x) * exp x) =\n    (\\<Sum>x\\<in>Roots. of_int (\\<beta>' x) * exp x)", "by (intro sum.mono_neutral_cong_left \\<open>X \\<subseteq> Roots\\<close>) (auto simp: \\<beta>'_def)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>X. of_int (\\<beta> x) * exp x) =\n  (\\<Sum>x\\<in>Roots. of_int (\\<beta>' x) * exp x)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>X. of_int (\\<beta> x) * exp x) =\n  (\\<Sum>x\\<in>Roots. of_int (\\<beta>' x) * exp x)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have \"\\<dots> dvd (\\<Prod>\\<sigma>\\<in>perms. \\<Sum>x\\<in>Roots. \\<beta>' x * exp (\\<sigma> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>Roots. of_int (\\<beta>' x) * exp x) dvd\n    (\\<Prod>\\<sigma>\\<in>perms.\n       \\<Sum>x\\<in>Roots. of_int (\\<beta>' x) * exp (\\<sigma> x))", "by (rule dvd_prodI[OF \\<open>finite perms\\<close>])\n       (use permutes_id[of Roots] in \\<open>simp_all add: id_def perms_def\\<close>)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>Roots. of_int (\\<beta>' x) * exp x) dvd\n  (\\<Prod>\\<sigma>\\<in>perms.\n     \\<Sum>x\\<in>Roots. of_int (\\<beta>' x) * exp (\\<sigma> x))\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>Roots. of_int (\\<beta>' x) * exp x) dvd\n  (\\<Prod>\\<sigma>\\<in>perms.\n     \\<Sum>x\\<in>Roots. of_int (\\<beta>' x) * exp (\\<sigma> x))\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have \"\\<dots> = (\\<Sum>f\\<in>perms \\<rightarrow>\\<^sub>E Roots. \\<Prod>\\<sigma>\\<in>perms. \\<beta>' (f \\<sigma>) * exp (\\<sigma> (f \\<sigma>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>\\<sigma>\\<in>perms.\n       \\<Sum>x\\<in>Roots. of_int (\\<beta>' x) * exp (\\<sigma> x)) =\n    (\\<Sum>f\\<in>perms \\<rightarrow>\\<^sub>E Roots.\n       \\<Prod>\\<sigma>\\<in>perms.\n         of_int (\\<beta>' (f \\<sigma>)) * exp (\\<sigma> (f \\<sigma>)))", "by (rule prod_sum_PiE) auto"], ["proof (state)\nthis:\n  (\\<Prod>\\<sigma>\\<in>perms.\n     \\<Sum>x\\<in>Roots. of_int (\\<beta>' x) * exp (\\<sigma> x)) =\n  (\\<Sum>f\\<in>perms \\<rightarrow>\\<^sub>E Roots.\n     \\<Prod>\\<sigma>\\<in>perms.\n       of_int (\\<beta>' (f \\<sigma>)) * exp (\\<sigma> (f \\<sigma>)))\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Prod>\\<sigma>\\<in>perms.\n     \\<Sum>x\\<in>Roots. of_int (\\<beta>' x) * exp (\\<sigma> x)) =\n  (\\<Sum>f\\<in>perms \\<rightarrow>\\<^sub>E Roots.\n     \\<Prod>\\<sigma>\\<in>perms.\n       of_int (\\<beta>' (f \\<sigma>)) * exp (\\<sigma> (f \\<sigma>)))\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have \"\\<dots> = (\\<Sum>f\\<in>perms \\<rightarrow>\\<^sub>E Roots. (\\<Prod>\\<sigma>\\<in>perms. \\<beta>' (f \\<sigma>)) * exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>f\\<in>perms \\<rightarrow>\\<^sub>E Roots.\n       \\<Prod>\\<sigma>\\<in>perms.\n         of_int (\\<beta>' (f \\<sigma>)) * exp (\\<sigma> (f \\<sigma>))) =\n    (\\<Sum>f\\<in>perms \\<rightarrow>\\<^sub>E Roots.\n       of_int (\\<Prod>\\<sigma>\\<in>perms. \\<beta>' (f \\<sigma>)) *\n       exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)))", "using \\<open>finite perms\\<close>"], ["proof (prove)\nusing this:\n  finite perms\n\ngoal (1 subgoal):\n 1. (\\<Sum>f\\<in>perms \\<rightarrow>\\<^sub>E Roots.\n       \\<Prod>\\<sigma>\\<in>perms.\n         of_int (\\<beta>' (f \\<sigma>)) * exp (\\<sigma> (f \\<sigma>))) =\n    (\\<Sum>f\\<in>perms \\<rightarrow>\\<^sub>E Roots.\n       of_int (\\<Prod>\\<sigma>\\<in>perms. \\<beta>' (f \\<sigma>)) *\n       exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)))", "by (simp add: prod.distrib exp_sum)"], ["proof (state)\nthis:\n  (\\<Sum>f\\<in>perms \\<rightarrow>\\<^sub>E Roots.\n     \\<Prod>\\<sigma>\\<in>perms.\n       of_int (\\<beta>' (f \\<sigma>)) * exp (\\<sigma> (f \\<sigma>))) =\n  (\\<Sum>f\\<in>perms \\<rightarrow>\\<^sub>E Roots.\n     of_int (\\<Prod>\\<sigma>\\<in>perms. \\<beta>' (f \\<sigma>)) *\n     exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)))\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Sum>f\\<in>perms \\<rightarrow>\\<^sub>E Roots.\n     \\<Prod>\\<sigma>\\<in>perms.\n       of_int (\\<beta>' (f \\<sigma>)) * exp (\\<sigma> (f \\<sigma>))) =\n  (\\<Sum>f\\<in>perms \\<rightarrow>\\<^sub>E Roots.\n     of_int (\\<Prod>\\<sigma>\\<in>perms. \\<beta>' (f \\<sigma>)) *\n     exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)))\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have \"\\<dots> = (\\<Sum>(X,f)\\<in>tuples'. (\\<Prod>\\<sigma>\\<in>perms. \\<beta>' (f \\<sigma>)) * exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>f\\<in>perms \\<rightarrow>\\<^sub>E Roots.\n       of_int (\\<Prod>\\<sigma>\\<in>perms. \\<beta>' (f \\<sigma>)) *\n       exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>))) =\n    (\\<Sum>(X, f)\\<in>tuples'.\n       of_int (\\<Prod>\\<sigma>\\<in>perms. \\<beta>' (f \\<sigma>)) *\n       exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)))", "using \\<open>finite perms\\<close>"], ["proof (prove)\nusing this:\n  finite perms\n\ngoal (1 subgoal):\n 1. (\\<Sum>f\\<in>perms \\<rightarrow>\\<^sub>E Roots.\n       of_int (\\<Prod>\\<sigma>\\<in>perms. \\<beta>' (f \\<sigma>)) *\n       exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>))) =\n    (\\<Sum>(X, f)\\<in>tuples'.\n       of_int (\\<Prod>\\<sigma>\\<in>perms. \\<beta>' (f \\<sigma>)) *\n       exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)))", "by (intro sum.reindex_bij_witness[of _ snd \"\\<lambda>f. (image_mset f (mset_set perms), f)\"])\n       (auto simp: tuples'_def tuples_def Roots_ms_def PiE_def Pi_def)"], ["proof (state)\nthis:\n  (\\<Sum>f\\<in>perms \\<rightarrow>\\<^sub>E Roots.\n     of_int (\\<Prod>\\<sigma>\\<in>perms. \\<beta>' (f \\<sigma>)) *\n     exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>))) =\n  (\\<Sum>(X, f)\\<in>tuples'.\n     of_int (\\<Prod>\\<sigma>\\<in>perms. \\<beta>' (f \\<sigma>)) *\n     exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)))\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Sum>f\\<in>perms \\<rightarrow>\\<^sub>E Roots.\n     of_int (\\<Prod>\\<sigma>\\<in>perms. \\<beta>' (f \\<sigma>)) *\n     exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>))) =\n  (\\<Sum>(X, f)\\<in>tuples'.\n     of_int (\\<Prod>\\<sigma>\\<in>perms. \\<beta>' (f \\<sigma>)) *\n     exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)))\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have \"\\<dots> = (\\<Sum>(X,f)\\<in>tuples'. (\\<Prod>x\\<in>#X. \\<beta>' x) * exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(X, f)\\<in>tuples'.\n       of_int (\\<Prod>\\<sigma>\\<in>perms. \\<beta>' (f \\<sigma>)) *\n       exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>))) =\n    (\\<Sum>(X, f)\\<in>tuples'.\n       of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n       exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)))", "proof (safe intro!: sum.cong)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> tuples' \\<Longrightarrow>\n       of_int (\\<Prod>\\<sigma>\\<in>perms. \\<beta>' (b \\<sigma>)) *\n       exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (b \\<sigma>)) =\n       of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' a)) *\n       exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (b \\<sigma>))", "fix X :: \"complex multiset\" and f :: \"(complex \\<Rightarrow> complex) \\<Rightarrow> complex\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> tuples' \\<Longrightarrow>\n       of_int (\\<Prod>\\<sigma>\\<in>perms. \\<beta>' (b \\<sigma>)) *\n       exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (b \\<sigma>)) =\n       of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' a)) *\n       exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (b \\<sigma>))", "assume \"(X, f) \\<in> tuples'\""], ["proof (state)\nthis:\n  (X, f) \\<in> tuples'\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> tuples' \\<Longrightarrow>\n       of_int (\\<Prod>\\<sigma>\\<in>perms. \\<beta>' (b \\<sigma>)) *\n       exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (b \\<sigma>)) =\n       of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' a)) *\n       exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (b \\<sigma>))", "hence X: \"X \\<in> Roots_ms\" \"X = image_mset f (mset_set perms)\" and f: \"f \\<in> perms \\<rightarrow>\\<^sub>E Roots\""], ["proof (prove)\nusing this:\n  (X, f) \\<in> tuples'\n\ngoal (1 subgoal):\n 1. (X \\<in> Roots_ms &&& X = image_mset f (mset_set perms)) &&&\n    f \\<in> perms \\<rightarrow>\\<^sub>E Roots", "by (auto simp: tuples'_def tuples_def)"], ["proof (state)\nthis:\n  X \\<in> Roots_ms\n  X = image_mset f (mset_set perms)\n  f \\<in> perms \\<rightarrow>\\<^sub>E Roots\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> tuples' \\<Longrightarrow>\n       of_int (\\<Prod>\\<sigma>\\<in>perms. \\<beta>' (b \\<sigma>)) *\n       exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (b \\<sigma>)) =\n       of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' a)) *\n       exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (b \\<sigma>))", "have \"(\\<Prod>\\<sigma>\\<in>perms. \\<beta>' (f \\<sigma>)) = (\\<Prod>\\<sigma>\\<in>#mset_set perms. \\<beta>' (f \\<sigma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>\\<sigma>\\<in>perms. \\<beta>' (f \\<sigma>)) =\n    (\\<Prod>\\<sigma>\\<in>#mset_set perms. \\<beta>' (f \\<sigma>))", "by (meson prod_unfold_prod_mset)"], ["proof (state)\nthis:\n  (\\<Prod>\\<sigma>\\<in>perms. \\<beta>' (f \\<sigma>)) =\n  (\\<Prod>\\<sigma>\\<in>#mset_set perms. \\<beta>' (f \\<sigma>))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> tuples' \\<Longrightarrow>\n       of_int (\\<Prod>\\<sigma>\\<in>perms. \\<beta>' (b \\<sigma>)) *\n       exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (b \\<sigma>)) =\n       of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' a)) *\n       exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (b \\<sigma>))", "also"], ["proof (state)\nthis:\n  (\\<Prod>\\<sigma>\\<in>perms. \\<beta>' (f \\<sigma>)) =\n  (\\<Prod>\\<sigma>\\<in>#mset_set perms. \\<beta>' (f \\<sigma>))\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> tuples' \\<Longrightarrow>\n       of_int (\\<Prod>\\<sigma>\\<in>perms. \\<beta>' (b \\<sigma>)) *\n       exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (b \\<sigma>)) =\n       of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' a)) *\n       exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (b \\<sigma>))", "have \"\\<dots> = (\\<Prod>x\\<in>#X. \\<beta>' x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>\\<sigma>\\<in>#mset_set perms. \\<beta>' (f \\<sigma>)) =\n    \\<Prod>\\<^sub># (image_mset \\<beta>' X)", "unfolding X(2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>\\<sigma>\\<in>#mset_set perms. \\<beta>' (f \\<sigma>)) =\n    \\<Prod>\\<^sub># (image_mset \\<beta>' (image_mset f (mset_set perms)))", "by (simp add: multiset.map_comp o_def)"], ["proof (state)\nthis:\n  (\\<Prod>\\<sigma>\\<in>#mset_set perms. \\<beta>' (f \\<sigma>)) =\n  \\<Prod>\\<^sub># (image_mset \\<beta>' X)\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       (a, b) \\<in> tuples' \\<Longrightarrow>\n       of_int (\\<Prod>\\<sigma>\\<in>perms. \\<beta>' (b \\<sigma>)) *\n       exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (b \\<sigma>)) =\n       of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' a)) *\n       exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (b \\<sigma>))", "finally"], ["proof (chain)\npicking this:\n  (\\<Prod>\\<sigma>\\<in>perms. \\<beta>' (f \\<sigma>)) =\n  \\<Prod>\\<^sub># (image_mset \\<beta>' X)", "show \"(\\<Prod>\\<sigma>\\<in>perms. \\<beta>' (f \\<sigma>)) * exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)) =\n                  (\\<Prod>x\\<in>#X. \\<beta>' x) * exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>))\""], ["proof (prove)\nusing this:\n  (\\<Prod>\\<sigma>\\<in>perms. \\<beta>' (f \\<sigma>)) =\n  \\<Prod>\\<^sub># (image_mset \\<beta>' X)\n\ngoal (1 subgoal):\n 1. of_int (\\<Prod>\\<sigma>\\<in>perms. \\<beta>' (f \\<sigma>)) *\n    exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)) =\n    of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n    exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>))", "by simp"], ["proof (state)\nthis:\n  of_int (\\<Prod>\\<sigma>\\<in>perms. \\<beta>' (f \\<sigma>)) *\n  exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)) =\n  of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n  exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Sum>(X, f)\\<in>tuples'.\n     of_int (\\<Prod>\\<sigma>\\<in>perms. \\<beta>' (f \\<sigma>)) *\n     exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>))) =\n  (\\<Sum>(X, f)\\<in>tuples'.\n     of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n     exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)))\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Sum>(X, f)\\<in>tuples'.\n     of_int (\\<Prod>\\<sigma>\\<in>perms. \\<beta>' (f \\<sigma>)) *\n     exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>))) =\n  (\\<Sum>(X, f)\\<in>tuples'.\n     of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n     exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)))\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have \"\\<dots> = (\\<Sum>X\\<in>Roots_ms. \\<Sum>f\\<in>tuples X. (\\<Prod>x\\<in>#X. \\<beta>' x) * exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(X, f)\\<in>tuples'.\n       of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n       exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>))) =\n    (\\<Sum>X\\<in>Roots_ms.\n       \\<Sum>f\\<in>tuples X.\n         of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n         exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)))", "unfolding tuples'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(X, f)\\<in>Sigma Roots_ms tuples.\n       of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n       exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>))) =\n    (\\<Sum>X\\<in>Roots_ms.\n       \\<Sum>f\\<in>tuples X.\n         of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n         exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)))", "by (intro sum.Sigma [symmetric]) auto"], ["proof (state)\nthis:\n  (\\<Sum>(X, f)\\<in>tuples'.\n     of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n     exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>))) =\n  (\\<Sum>X\\<in>Roots_ms.\n     \\<Sum>f\\<in>tuples X.\n       of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n       exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)))\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Sum>(X, f)\\<in>tuples'.\n     of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n     exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>))) =\n  (\\<Sum>X\\<in>Roots_ms.\n     \\<Sum>f\\<in>tuples X.\n       of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n       exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)))\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have \"\\<dots> = (\\<Sum>X\\<in>Roots_ms. of_int (\\<Prod>x\\<in>#X. \\<beta>' x) * (\\<Sum>f\\<in>tuples X. exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>X\\<in>Roots_ms.\n       \\<Sum>f\\<in>tuples X.\n         of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n         exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>))) =\n    (\\<Sum>X\\<in>Roots_ms.\n       of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n       (\\<Sum>f\\<in>tuples X.\n          exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>))))", "by (simp add: sum_distrib_left)"], ["proof (state)\nthis:\n  (\\<Sum>X\\<in>Roots_ms.\n     \\<Sum>f\\<in>tuples X.\n       of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n       exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>))) =\n  (\\<Sum>X\\<in>Roots_ms.\n     of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n     (\\<Sum>f\\<in>tuples X.\n        exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>))))\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Sum>X\\<in>Roots_ms.\n     \\<Sum>f\\<in>tuples X.\n       of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n       exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>))) =\n  (\\<Sum>X\\<in>Roots_ms.\n     of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n     (\\<Sum>f\\<in>tuples X.\n        exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>))))\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have \"\\<dots> = (\\<Sum>X\\<in>Roots_ms. of_int (\\<Prod>x\\<in>#X. \\<beta>' x) * (\\<Sum>x\\<in>#R X. exp x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>X\\<in>Roots_ms.\n       of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n       (\\<Sum>f\\<in>tuples X.\n          exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)))) =\n    (\\<Sum>X\\<in>Roots_ms.\n       of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n       \\<Sum>\\<^sub># (image_mset exp (R X)))", "by (simp only: R_def multiset.map_comp o_def sum_unfold_sum_mset)"], ["proof (state)\nthis:\n  (\\<Sum>X\\<in>Roots_ms.\n     of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n     (\\<Sum>f\\<in>tuples X.\n        exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)))) =\n  (\\<Sum>X\\<in>Roots_ms.\n     of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n     \\<Sum>\\<^sub># (image_mset exp (R X)))\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Sum>X\\<in>Roots_ms.\n     of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n     (\\<Sum>f\\<in>tuples X.\n        exp (\\<Sum>\\<sigma>\\<in>perms. \\<sigma> (f \\<sigma>)))) =\n  (\\<Sum>X\\<in>Roots_ms.\n     of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n     \\<Sum>\\<^sub># (image_mset exp (R X)))\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have \"\\<dots> = (\\<Sum>X\\<in>Roots_ms. of_int (\\<Prod>x\\<in>#X. \\<beta>' x) * (\\<Sum>x\\<in>#poly_roots (of_int_poly (Q X)). exp x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>X\\<in>Roots_ms.\n       of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n       \\<Sum>\\<^sub># (image_mset exp (R X))) =\n    (\\<Sum>X\\<in>Roots_ms.\n       of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n       \\<Sum>\\<^sub>#\n        (image_mset exp (poly_roots (Ring_Hom_Poly.of_int_poly (Q X)))))", "by (intro sum.cong) (simp_all flip: Q)"], ["proof (state)\nthis:\n  (\\<Sum>X\\<in>Roots_ms.\n     of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n     \\<Sum>\\<^sub># (image_mset exp (R X))) =\n  (\\<Sum>X\\<in>Roots_ms.\n     of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n     \\<Sum>\\<^sub>#\n      (image_mset exp (poly_roots (Ring_Hom_Poly.of_int_poly (Q X)))))\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "text \\<open>\n    Our problem now is that the polynomials \\<open>Q X\\<close> can still contain multiple roots and that their\n    roots might not be disjoint. We therefore split them all into irreducible factors and collect\n    equal terms.\n  \\<close>"], ["proof (state)\nthis:\n  (\\<Sum>X\\<in>Roots_ms.\n     of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n     \\<Sum>\\<^sub># (image_mset exp (R X))) =\n  (\\<Sum>X\\<in>Roots_ms.\n     of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n     \\<Sum>\\<^sub>#\n      (image_mset exp (poly_roots (Ring_Hom_Poly.of_int_poly (Q X)))))\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Sum>X\\<in>Roots_ms.\n     of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n     \\<Sum>\\<^sub># (image_mset exp (R X))) =\n  (\\<Sum>X\\<in>Roots_ms.\n     of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n     \\<Sum>\\<^sub>#\n      (image_mset exp (poly_roots (Ring_Hom_Poly.of_int_poly (Q X)))))\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have \"\\<dots> = (\\<Sum>X\\<in>Roots_ms. (\\<Sum>p. of_int (int (count (prime_factorization (Q X)) p) *\n                      (\\<Prod>x\\<in>#X. \\<beta>' x)) * (\\<Sum>x | ipoly p x = 0. exp x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>X\\<in>Roots_ms.\n       of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n       \\<Sum>\\<^sub>#\n        (image_mset exp (poly_roots (Ring_Hom_Poly.of_int_poly (Q X))))) =\n    (\\<Sum>X\\<in>Roots_ms.\n       \\<Sum>p. of_int\n                 (int (count (prime_factorization (Q X)) p) *\n                  \\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n                (\\<Sum>x | ipoly p x = 0. exp x))", "proof (rule sum.cong, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. Roots_ms = Roots_ms\n 2. \\<And>x.\n       x \\<in> Roots_ms \\<Longrightarrow>\n       of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' x)) *\n       \\<Sum>\\<^sub>#\n        (image_mset exp (poly_roots (Ring_Hom_Poly.of_int_poly (Q x)))) =\n       (\\<Sum>p. of_int\n                  (int (count (prime_factorization (Q x)) p) *\n                   \\<Prod>\\<^sub># (image_mset \\<beta>' x)) *\n                 (\\<Sum>x | ipoly p x = 0. exp x))", "case (2 X)"], ["proof (state)\nthis:\n  X \\<in> Roots_ms\n\ngoal (2 subgoals):\n 1. Roots_ms = Roots_ms\n 2. \\<And>x.\n       x \\<in> Roots_ms \\<Longrightarrow>\n       of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' x)) *\n       \\<Sum>\\<^sub>#\n        (image_mset exp (poly_roots (Ring_Hom_Poly.of_int_poly (Q x)))) =\n       (\\<Sum>p. of_int\n                  (int (count (prime_factorization (Q x)) p) *\n                   \\<Prod>\\<^sub># (image_mset \\<beta>' x)) *\n                 (\\<Sum>x | ipoly p x = 0. exp x))", "have \"(\\<Sum>x\\<in>#poly_roots (of_int_poly (Q X) :: complex poly). exp x) =\n          (\\<Sum>x \\<in># (\\<Sum>p\\<in>#prime_factorization (Q X). poly_roots (of_int_poly p)). exp x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub>#\n     (image_mset exp (poly_roots (Ring_Hom_Poly.of_int_poly (Q X)))) =\n    \\<Sum>\\<^sub>#\n     (image_mset exp\n       (\\<Sum>p\\<in>#prime_factorization\n                      (Q X). poly_roots (Ring_Hom_Poly.of_int_poly p)))", "by (subst poly_roots_of_int_conv_sum_prime_factors) (rule refl)"], ["proof (state)\nthis:\n  \\<Sum>\\<^sub>#\n   (image_mset exp (poly_roots (Ring_Hom_Poly.of_int_poly (Q X)))) =\n  \\<Sum>\\<^sub>#\n   (image_mset exp\n     (\\<Sum>p\\<in>#prime_factorization\n                    (Q X). poly_roots (Ring_Hom_Poly.of_int_poly p)))\n\ngoal (2 subgoals):\n 1. Roots_ms = Roots_ms\n 2. \\<And>x.\n       x \\<in> Roots_ms \\<Longrightarrow>\n       of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' x)) *\n       \\<Sum>\\<^sub>#\n        (image_mset exp (poly_roots (Ring_Hom_Poly.of_int_poly (Q x)))) =\n       (\\<Sum>p. of_int\n                  (int (count (prime_factorization (Q x)) p) *\n                   \\<Prod>\\<^sub># (image_mset \\<beta>' x)) *\n                 (\\<Sum>x | ipoly p x = 0. exp x))", "also"], ["proof (state)\nthis:\n  \\<Sum>\\<^sub>#\n   (image_mset exp (poly_roots (Ring_Hom_Poly.of_int_poly (Q X)))) =\n  \\<Sum>\\<^sub>#\n   (image_mset exp\n     (\\<Sum>p\\<in>#prime_factorization\n                    (Q X). poly_roots (Ring_Hom_Poly.of_int_poly p)))\n\ngoal (2 subgoals):\n 1. Roots_ms = Roots_ms\n 2. \\<And>x.\n       x \\<in> Roots_ms \\<Longrightarrow>\n       of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' x)) *\n       \\<Sum>\\<^sub>#\n        (image_mset exp (poly_roots (Ring_Hom_Poly.of_int_poly (Q x)))) =\n       (\\<Sum>p. of_int\n                  (int (count (prime_factorization (Q x)) p) *\n                   \\<Prod>\\<^sub># (image_mset \\<beta>' x)) *\n                 (\\<Sum>x | ipoly p x = 0. exp x))", "have \"\\<dots> = (\\<Sum>p\\<in>#prime_factorization (Q X). \\<Sum>x\\<in>#poly_roots (of_int_poly p). exp x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub>#\n     (image_mset exp\n       (\\<Sum>p\\<in>#prime_factorization\n                      (Q X). poly_roots (Ring_Hom_Poly.of_int_poly p))) =\n    (\\<Sum>p\\<in>#prime_factorization\n                   (Q X). \\<Sum>\\<^sub>#\n                           (image_mset exp\n                             (poly_roots (Ring_Hom_Poly.of_int_poly p))))", "by (rule sum_mset_image_mset_sum_mset_image_mset)"], ["proof (state)\nthis:\n  \\<Sum>\\<^sub>#\n   (image_mset exp\n     (\\<Sum>p\\<in>#prime_factorization\n                    (Q X). poly_roots (Ring_Hom_Poly.of_int_poly p))) =\n  (\\<Sum>p\\<in>#prime_factorization\n                 (Q X). \\<Sum>\\<^sub>#\n                         (image_mset exp\n                           (poly_roots (Ring_Hom_Poly.of_int_poly p))))\n\ngoal (2 subgoals):\n 1. Roots_ms = Roots_ms\n 2. \\<And>x.\n       x \\<in> Roots_ms \\<Longrightarrow>\n       of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' x)) *\n       \\<Sum>\\<^sub>#\n        (image_mset exp (poly_roots (Ring_Hom_Poly.of_int_poly (Q x)))) =\n       (\\<Sum>p. of_int\n                  (int (count (prime_factorization (Q x)) p) *\n                   \\<Prod>\\<^sub># (image_mset \\<beta>' x)) *\n                 (\\<Sum>x | ipoly p x = 0. exp x))", "also"], ["proof (state)\nthis:\n  \\<Sum>\\<^sub>#\n   (image_mset exp\n     (\\<Sum>p\\<in>#prime_factorization\n                    (Q X). poly_roots (Ring_Hom_Poly.of_int_poly p))) =\n  (\\<Sum>p\\<in>#prime_factorization\n                 (Q X). \\<Sum>\\<^sub>#\n                         (image_mset exp\n                           (poly_roots (Ring_Hom_Poly.of_int_poly p))))\n\ngoal (2 subgoals):\n 1. Roots_ms = Roots_ms\n 2. \\<And>x.\n       x \\<in> Roots_ms \\<Longrightarrow>\n       of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' x)) *\n       \\<Sum>\\<^sub>#\n        (image_mset exp (poly_roots (Ring_Hom_Poly.of_int_poly (Q x)))) =\n       (\\<Sum>p. of_int\n                  (int (count (prime_factorization (Q x)) p) *\n                   \\<Prod>\\<^sub># (image_mset \\<beta>' x)) *\n                 (\\<Sum>x | ipoly p x = 0. exp x))", "have \"rsquarefree (of_int_poly p :: complex poly)\" if \"p \\<in> prime_factors (Q X)\" for p"], ["proof (prove)\ngoal (1 subgoal):\n 1. rsquarefree (Ring_Hom_Poly.of_int_poly p)", "proof (rule irreducible_imp_rsquarefree_of_int_poly)"], ["proof (state)\ngoal (2 subgoals):\n 1. irreducible p\n 2. 0 < Polynomial.degree p", "have \"prime p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prime p", "using that"], ["proof (prove)\nusing this:\n  p \\<in># prime_factorization (Q X)\n\ngoal (1 subgoal):\n 1. prime p", "by auto"], ["proof (state)\nthis:\n  prime p\n\ngoal (2 subgoals):\n 1. irreducible p\n 2. 0 < Polynomial.degree p", "thus \"irreducible p\""], ["proof (prove)\nusing this:\n  prime p\n\ngoal (1 subgoal):\n 1. irreducible p", "by blast"], ["proof (state)\nthis:\n  irreducible p\n\ngoal (1 subgoal):\n 1. 0 < Polynomial.degree p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 0 < Polynomial.degree p", "show \"Polynomial.degree p > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < Polynomial.degree p", "by (intro content_1_imp_nonconstant_prime_factors[OF Q(2) that] 2)"], ["proof (state)\nthis:\n  0 < Polynomial.degree p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?p \\<in># prime_factorization (Q X) \\<Longrightarrow>\n  rsquarefree (Ring_Hom_Poly.of_int_poly ?p)\n\ngoal (2 subgoals):\n 1. Roots_ms = Roots_ms\n 2. \\<And>x.\n       x \\<in> Roots_ms \\<Longrightarrow>\n       of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' x)) *\n       \\<Sum>\\<^sub>#\n        (image_mset exp (poly_roots (Ring_Hom_Poly.of_int_poly (Q x)))) =\n       (\\<Sum>p. of_int\n                  (int (count (prime_factorization (Q x)) p) *\n                   \\<Prod>\\<^sub># (image_mset \\<beta>' x)) *\n                 (\\<Sum>x | ipoly p x = 0. exp x))", "hence \"(\\<Sum>p\\<in>#prime_factorization (Q X). \\<Sum>x\\<in>#poly_roots (of_int_poly p). exp x) =\n           (\\<Sum>p\\<in>#prime_factorization (Q X). \\<Sum>x | ipoly p x = 0. exp (x :: complex))\""], ["proof (prove)\nusing this:\n  ?p \\<in># prime_factorization (Q X) \\<Longrightarrow>\n  rsquarefree (Ring_Hom_Poly.of_int_poly ?p)\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>#prime_factorization\n                   (Q X). \\<Sum>\\<^sub>#\n                           (image_mset exp\n                             (poly_roots (Ring_Hom_Poly.of_int_poly p)))) =\n    (\\<Sum>p\\<in>#prime_factorization (Q X). \\<Sum>x | ipoly p x = 0. exp x)", "unfolding sum_unfold_sum_mset"], ["proof (prove)\nusing this:\n  ?p \\<in># prime_factorization (Q X) \\<Longrightarrow>\n  rsquarefree (Ring_Hom_Poly.of_int_poly ?p)\n\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>#prime_factorization\n                   (Q X). \\<Sum>\\<^sub>#\n                           (image_mset exp\n                             (poly_roots (Ring_Hom_Poly.of_int_poly p)))) =\n    (\\<Sum>p\\<in>#prime_factorization\n                   (Q X). \\<Sum>\\<^sub>#\n                           (image_mset exp (mset_set {x. ipoly p x = 0})))", "by (intro arg_cong[of _ _ sum_mset] image_mset_cong sum.cong refl,\n          subst rsquarefree_poly_roots_eq) auto"], ["proof (state)\nthis:\n  (\\<Sum>p\\<in>#prime_factorization\n                 (Q X). \\<Sum>\\<^sub>#\n                         (image_mset exp\n                           (poly_roots (Ring_Hom_Poly.of_int_poly p)))) =\n  (\\<Sum>p\\<in>#prime_factorization (Q X). \\<Sum>x | ipoly p x = 0. exp x)\n\ngoal (2 subgoals):\n 1. Roots_ms = Roots_ms\n 2. \\<And>x.\n       x \\<in> Roots_ms \\<Longrightarrow>\n       of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' x)) *\n       \\<Sum>\\<^sub>#\n        (image_mset exp (poly_roots (Ring_Hom_Poly.of_int_poly (Q x)))) =\n       (\\<Sum>p. of_int\n                  (int (count (prime_factorization (Q x)) p) *\n                   \\<Prod>\\<^sub># (image_mset \\<beta>' x)) *\n                 (\\<Sum>x | ipoly p x = 0. exp x))", "also"], ["proof (state)\nthis:\n  (\\<Sum>p\\<in>#prime_factorization\n                 (Q X). \\<Sum>\\<^sub>#\n                         (image_mset exp\n                           (poly_roots (Ring_Hom_Poly.of_int_poly p)))) =\n  (\\<Sum>p\\<in>#prime_factorization (Q X). \\<Sum>x | ipoly p x = 0. exp x)\n\ngoal (2 subgoals):\n 1. Roots_ms = Roots_ms\n 2. \\<And>x.\n       x \\<in> Roots_ms \\<Longrightarrow>\n       of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' x)) *\n       \\<Sum>\\<^sub>#\n        (image_mset exp (poly_roots (Ring_Hom_Poly.of_int_poly (Q x)))) =\n       (\\<Sum>p. of_int\n                  (int (count (prime_factorization (Q x)) p) *\n                   \\<Prod>\\<^sub># (image_mset \\<beta>' x)) *\n                 (\\<Sum>x | ipoly p x = 0. exp x))", "have \"\\<dots> = (\\<Sum>p. count (prime_factorization (Q X)) p * (\\<Sum>x | ipoly p x = 0. exp (x :: complex)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>p\\<in>#prime_factorization\n                   (Q X). \\<Sum>x | ipoly p x = 0. exp x) =\n    (\\<Sum>p. of_nat (count (prime_factorization (Q X)) p) *\n              (\\<Sum>x | ipoly p x = 0. exp x))", "by (rule sum_mset_conv_Sum_any)"], ["proof (state)\nthis:\n  (\\<Sum>p\\<in>#prime_factorization (Q X). \\<Sum>x | ipoly p x = 0. exp x) =\n  (\\<Sum>p. of_nat (count (prime_factorization (Q X)) p) *\n            (\\<Sum>x | ipoly p x = 0. exp x))\n\ngoal (2 subgoals):\n 1. Roots_ms = Roots_ms\n 2. \\<And>x.\n       x \\<in> Roots_ms \\<Longrightarrow>\n       of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' x)) *\n       \\<Sum>\\<^sub>#\n        (image_mset exp (poly_roots (Ring_Hom_Poly.of_int_poly (Q x)))) =\n       (\\<Sum>p. of_int\n                  (int (count (prime_factorization (Q x)) p) *\n                   \\<Prod>\\<^sub># (image_mset \\<beta>' x)) *\n                 (\\<Sum>x | ipoly p x = 0. exp x))", "also"], ["proof (state)\nthis:\n  (\\<Sum>p\\<in>#prime_factorization (Q X). \\<Sum>x | ipoly p x = 0. exp x) =\n  (\\<Sum>p. of_nat (count (prime_factorization (Q X)) p) *\n            (\\<Sum>x | ipoly p x = 0. exp x))\n\ngoal (2 subgoals):\n 1. Roots_ms = Roots_ms\n 2. \\<And>x.\n       x \\<in> Roots_ms \\<Longrightarrow>\n       of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' x)) *\n       \\<Sum>\\<^sub>#\n        (image_mset exp (poly_roots (Ring_Hom_Poly.of_int_poly (Q x)))) =\n       (\\<Sum>p. of_int\n                  (int (count (prime_factorization (Q x)) p) *\n                   \\<Prod>\\<^sub># (image_mset \\<beta>' x)) *\n                 (\\<Sum>x | ipoly p x = 0. exp x))", "have \"of_int (\\<Prod>x\\<in>#X. \\<beta>' x) * \\<dots> =\n               (\\<Sum>p. of_int (int (count (prime_factorization (Q X)) p) * (\\<Prod>x\\<in>#X. \\<beta>' x)) * (\\<Sum>x | ipoly p x = 0. exp x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n    (\\<Sum>p. of_nat (count (prime_factorization (Q X)) p) *\n              (\\<Sum>x | ipoly p x = 0. exp x)) =\n    (\\<Sum>p. of_int\n               (int (count (prime_factorization (Q X)) p) *\n                \\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n              (\\<Sum>x | ipoly p x = 0. exp x))", "by (subst Sum_any_right_distrib) (auto simp: mult_ac)"], ["proof (state)\nthis:\n  of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n  (\\<Sum>p. of_nat (count (prime_factorization (Q X)) p) *\n            (\\<Sum>x | ipoly p x = 0. exp x)) =\n  (\\<Sum>p. of_int\n             (int (count (prime_factorization (Q X)) p) *\n              \\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n            (\\<Sum>x | ipoly p x = 0. exp x))\n\ngoal (2 subgoals):\n 1. Roots_ms = Roots_ms\n 2. \\<And>x.\n       x \\<in> Roots_ms \\<Longrightarrow>\n       of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' x)) *\n       \\<Sum>\\<^sub>#\n        (image_mset exp (poly_roots (Ring_Hom_Poly.of_int_poly (Q x)))) =\n       (\\<Sum>p. of_int\n                  (int (count (prime_factorization (Q x)) p) *\n                   \\<Prod>\\<^sub># (image_mset \\<beta>' x)) *\n                 (\\<Sum>x | ipoly p x = 0. exp x))", "finally"], ["proof (chain)\npicking this:\n  of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n  \\<Sum>\\<^sub>#\n   (image_mset exp (poly_roots (Ring_Hom_Poly.of_int_poly (Q X)))) =\n  (\\<Sum>p. of_int\n             (int (count (prime_factorization (Q X)) p) *\n              \\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n            (\\<Sum>x | ipoly p x = 0. exp x))", "show ?case"], ["proof (prove)\nusing this:\n  of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n  \\<Sum>\\<^sub>#\n   (image_mset exp (poly_roots (Ring_Hom_Poly.of_int_poly (Q X)))) =\n  (\\<Sum>p. of_int\n             (int (count (prime_factorization (Q X)) p) *\n              \\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n            (\\<Sum>x | ipoly p x = 0. exp x))\n\ngoal (1 subgoal):\n 1. of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n    \\<Sum>\\<^sub>#\n     (image_mset exp (poly_roots (Ring_Hom_Poly.of_int_poly (Q X)))) =\n    (\\<Sum>p. of_int\n               (int (count (prime_factorization (Q X)) p) *\n                \\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n              (\\<Sum>x | ipoly p x = 0. exp x))", "by simp"], ["proof (state)\nthis:\n  of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n  \\<Sum>\\<^sub>#\n   (image_mset exp (poly_roots (Ring_Hom_Poly.of_int_poly (Q X)))) =\n  (\\<Sum>p. of_int\n             (int (count (prime_factorization (Q X)) p) *\n              \\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n            (\\<Sum>x | ipoly p x = 0. exp x))\n\ngoal (1 subgoal):\n 1. Roots_ms = Roots_ms", "qed auto"], ["proof (state)\nthis:\n  (\\<Sum>X\\<in>Roots_ms.\n     of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n     \\<Sum>\\<^sub>#\n      (image_mset exp (poly_roots (Ring_Hom_Poly.of_int_poly (Q X))))) =\n  (\\<Sum>X\\<in>Roots_ms.\n     \\<Sum>p. of_int\n               (int (count (prime_factorization (Q X)) p) *\n                \\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n              (\\<Sum>x | ipoly p x = 0. exp x))\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Sum>X\\<in>Roots_ms.\n     of_int (\\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n     \\<Sum>\\<^sub>#\n      (image_mset exp (poly_roots (Ring_Hom_Poly.of_int_poly (Q X))))) =\n  (\\<Sum>X\\<in>Roots_ms.\n     \\<Sum>p. of_int\n               (int (count (prime_factorization (Q X)) p) *\n                \\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n              (\\<Sum>x | ipoly p x = 0. exp x))\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have \"\\<dots> = (\\<Sum>q. of_int (\\<beta>'' q) * (\\<Sum>x | ipoly q x = 0. exp x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>X\\<in>Roots_ms.\n       \\<Sum>p. of_int\n                 (int (count (prime_factorization (Q X)) p) *\n                  \\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n                (\\<Sum>x | ipoly p x = 0. exp x)) =\n    (\\<Sum>q. of_int (\\<beta>'' q) * (\\<Sum>x | ipoly q x = 0. exp x))", "unfolding \\<beta>''_def of_int_sum"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>X\\<in>Roots_ms.\n       \\<Sum>p. of_int\n                 (int (count (prime_factorization (Q X)) p) *\n                  \\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n                (\\<Sum>x | ipoly p x = 0. exp x)) =\n    (\\<Sum>q. (\\<Sum>x\\<in>Roots_ms.\n                 of_int\n                  (int (count (prime_factorization (Q x)) q) *\n                   \\<Prod>\\<^sub># (image_mset \\<beta>' x))) *\n              (\\<Sum>x | ipoly q x = 0. exp x))", "by (subst Sum_any_sum_swap [symmetric]) (auto simp: sum_distrib_right)"], ["proof (state)\nthis:\n  (\\<Sum>X\\<in>Roots_ms.\n     \\<Sum>p. of_int\n               (int (count (prime_factorization (Q X)) p) *\n                \\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n              (\\<Sum>x | ipoly p x = 0. exp x)) =\n  (\\<Sum>q. of_int (\\<beta>'' q) * (\\<Sum>x | ipoly q x = 0. exp x))\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Sum>X\\<in>Roots_ms.\n     \\<Sum>p. of_int\n               (int (count (prime_factorization (Q X)) p) *\n                \\<Prod>\\<^sub># (image_mset \\<beta>' X)) *\n              (\\<Sum>x | ipoly p x = 0. exp x)) =\n  (\\<Sum>q. of_int (\\<beta>'' q) * (\\<Sum>x | ipoly q x = 0. exp x))\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have \"\\<dots> = (\\<Sum>q | \\<beta>'' q \\<noteq> 0. of_int (\\<beta>'' q) * (\\<Sum>x | ipoly q x = 0. exp x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>q. of_int (\\<beta>'' q) * (\\<Sum>x | ipoly q x = 0. exp x)) =\n    (\\<Sum>q | \\<beta>'' q \\<noteq> 0.\n       of_int (\\<beta>'' q) * (\\<Sum>x | ipoly q x = 0. exp x))", "by (intro Sum_any.expand_superset finite_subset[OF supp_\\<beta>'']) auto"], ["proof (state)\nthis:\n  (\\<Sum>q. of_int (\\<beta>'' q) * (\\<Sum>x | ipoly q x = 0. exp x)) =\n  (\\<Sum>q | \\<beta>'' q \\<noteq> 0.\n     of_int (\\<beta>'' q) * (\\<Sum>x | ipoly q x = 0. exp x))\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  0 dvd\n  (\\<Sum>q | \\<beta>'' q \\<noteq> 0.\n     of_int (\\<beta>'' q) * (\\<Sum>x | ipoly q x = 0. exp x))", "have \"(\\<Sum>q | \\<beta>'' q \\<noteq> 0. of_int (\\<beta>'' q) * (\\<Sum>x | ipoly q x = 0. exp (x :: complex))) = 0\""], ["proof (prove)\nusing this:\n  0 dvd\n  (\\<Sum>q | \\<beta>'' q \\<noteq> 0.\n     of_int (\\<beta>'' q) * (\\<Sum>x | ipoly q x = 0. exp x))\n\ngoal (1 subgoal):\n 1. (\\<Sum>q | \\<beta>'' q \\<noteq> 0.\n       of_int (\\<beta>'' q) * (\\<Sum>x | ipoly q x = 0. exp x)) =\n    0", "by simp"], ["proof (state)\nthis:\n  (\\<Sum>q | \\<beta>'' q \\<noteq> 0.\n     of_int (\\<beta>'' q) * (\\<Sum>x | ipoly q x = 0. exp x)) =\n  0\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "text \\<open>\n    We are now in the situation of our the specialised Hermite--Lindemann Theorem we proved\n    earlier and can easily derive a contradiction.\n  \\<close>"], ["proof (state)\nthis:\n  (\\<Sum>q | \\<beta>'' q \\<noteq> 0.\n     of_int (\\<beta>'' q) * (\\<Sum>x | ipoly q x = 0. exp x)) =\n  0\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  (\\<Sum>q | \\<beta>'' q \\<noteq> 0.\n     of_int (\\<beta>'' q) * (\\<Sum>x | ipoly q x = 0. exp x)) =\n  0\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have \"(\\<Sum>q | \\<beta>'' q \\<noteq> 0. of_int (\\<beta>'' q) * (\\<Sum>x | ipoly q x = 0. exp (x :: complex))) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>q | \\<beta>'' q \\<noteq> 0.\n       of_int (\\<beta>'' q) * (\\<Sum>x | ipoly q x = 0. exp x)) \\<noteq>\n    0", "proof (rule Hermite_Lindemann_aux1)"], ["proof (state)\ngoal (6 subgoals):\n 1. finite {q. \\<beta>'' q \\<noteq> 0}\n 2. {q. \\<beta>'' q \\<noteq> 0} \\<noteq> {}\n 3. pairwise algebraic_semidom_class.coprime {q. \\<beta>'' q \\<noteq> 0}\n 4. \\<And>q.\n       q \\<in> {q. \\<beta>'' q \\<noteq> 0} \\<Longrightarrow> irreducible q\n 5. \\<And>q.\n       q \\<in> {q. \\<beta>'' q \\<noteq> 0} \\<Longrightarrow>\n       0 < Polynomial.degree q\n 6. \\<And>q.\n       q \\<in> {q. \\<beta>'' q \\<noteq> 0} \\<Longrightarrow>\n       \\<beta>'' q \\<noteq> 0", "show \"finite {q. \\<beta>'' q \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {q. \\<beta>'' q \\<noteq> 0}", "by (rule finite_subset[OF supp_\\<beta>'']) auto"], ["proof (state)\nthis:\n  finite {q. \\<beta>'' q \\<noteq> 0}\n\ngoal (5 subgoals):\n 1. {q. \\<beta>'' q \\<noteq> 0} \\<noteq> {}\n 2. pairwise algebraic_semidom_class.coprime {q. \\<beta>'' q \\<noteq> 0}\n 3. \\<And>q.\n       q \\<in> {q. \\<beta>'' q \\<noteq> 0} \\<Longrightarrow> irreducible q\n 4. \\<And>q.\n       q \\<in> {q. \\<beta>'' q \\<noteq> 0} \\<Longrightarrow>\n       0 < Polynomial.degree q\n 5. \\<And>q.\n       q \\<in> {q. \\<beta>'' q \\<noteq> 0} \\<Longrightarrow>\n       \\<beta>'' q \\<noteq> 0", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. {q. \\<beta>'' q \\<noteq> 0} \\<noteq> {}\n 2. pairwise algebraic_semidom_class.coprime {q. \\<beta>'' q \\<noteq> 0}\n 3. \\<And>q.\n       q \\<in> {q. \\<beta>'' q \\<noteq> 0} \\<Longrightarrow> irreducible q\n 4. \\<And>q.\n       q \\<in> {q. \\<beta>'' q \\<noteq> 0} \\<Longrightarrow>\n       0 < Polynomial.degree q\n 5. \\<And>q.\n       q \\<in> {q. \\<beta>'' q \\<noteq> 0} \\<Longrightarrow>\n       \\<beta>'' q \\<noteq> 0", "show \"pairwise Rings.coprime {q. \\<beta>'' q \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pairwise algebraic_semidom_class.coprime {q. \\<beta>'' q \\<noteq> 0}", "proof (rule pairwiseI, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<noteq> y; \\<beta>'' x \\<noteq> 0;\n        \\<beta>'' y \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime x y", "fix p q"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<noteq> y; \\<beta>'' x \\<noteq> 0;\n        \\<beta>'' y \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime x y", "assume pq: \"p \\<noteq> q\" \"\\<beta>'' p \\<noteq> 0\" \"\\<beta>'' q \\<noteq> 0\""], ["proof (state)\nthis:\n  p \\<noteq> q\n  \\<beta>'' p \\<noteq> 0\n  \\<beta>'' q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<noteq> y; \\<beta>'' x \\<noteq> 0;\n        \\<beta>'' y \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime x y", "hence \"prime p\" \"prime q\""], ["proof (prove)\nusing this:\n  p \\<noteq> q\n  \\<beta>'' p \\<noteq> 0\n  \\<beta>'' q \\<noteq> 0\n\ngoal (1 subgoal):\n 1. prime p &&& prime q", "using supp_\\<beta>'' Q(2)"], ["proof (prove)\nusing this:\n  p \\<noteq> q\n  \\<beta>'' p \\<noteq> 0\n  \\<beta>'' q \\<noteq> 0\n  {q. \\<beta>'' q \\<noteq> 0}\n  \\<subseteq> (\\<Union>X\\<in>Roots_ms. prime_factors (Q X))\n  ?X \\<in> Roots_ms \\<Longrightarrow> Polynomial.content (Q ?X) = 1\n\ngoal (1 subgoal):\n 1. prime p &&& prime q", "by auto"], ["proof (state)\nthis:\n  prime p\n  prime q\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<noteq> y; \\<beta>'' x \\<noteq> 0;\n        \\<beta>'' y \\<noteq> 0\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime x y", "with pq"], ["proof (chain)\npicking this:\n  p \\<noteq> q\n  \\<beta>'' p \\<noteq> 0\n  \\<beta>'' q \\<noteq> 0\n  prime p\n  prime q", "show \"Rings.coprime p q\""], ["proof (prove)\nusing this:\n  p \\<noteq> q\n  \\<beta>'' p \\<noteq> 0\n  \\<beta>'' q \\<noteq> 0\n  prime p\n  prime q\n\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime p q", "by (simp add: primes_coprime)"], ["proof (state)\nthis:\n  algebraic_semidom_class.coprime p q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  pairwise algebraic_semidom_class.coprime {q. \\<beta>'' q \\<noteq> 0}\n\ngoal (4 subgoals):\n 1. {q. \\<beta>'' q \\<noteq> 0} \\<noteq> {}\n 2. \\<And>q.\n       q \\<in> {q. \\<beta>'' q \\<noteq> 0} \\<Longrightarrow> irreducible q\n 3. \\<And>q.\n       q \\<in> {q. \\<beta>'' q \\<noteq> 0} \\<Longrightarrow>\n       0 < Polynomial.degree q\n 4. \\<And>q.\n       q \\<in> {q. \\<beta>'' q \\<noteq> 0} \\<Longrightarrow>\n       \\<beta>'' q \\<noteq> 0", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. {q. \\<beta>'' q \\<noteq> 0} \\<noteq> {}\n 2. \\<And>q.\n       q \\<in> {q. \\<beta>'' q \\<noteq> 0} \\<Longrightarrow> irreducible q\n 3. \\<And>q.\n       q \\<in> {q. \\<beta>'' q \\<noteq> 0} \\<Longrightarrow>\n       0 < Polynomial.degree q\n 4. \\<And>q.\n       q \\<in> {q. \\<beta>'' q \\<noteq> 0} \\<Longrightarrow>\n       \\<beta>'' q \\<noteq> 0", "fix q :: \"int poly\""], ["proof (state)\ngoal (4 subgoals):\n 1. {q. \\<beta>'' q \\<noteq> 0} \\<noteq> {}\n 2. \\<And>q.\n       q \\<in> {q. \\<beta>'' q \\<noteq> 0} \\<Longrightarrow> irreducible q\n 3. \\<And>q.\n       q \\<in> {q. \\<beta>'' q \\<noteq> 0} \\<Longrightarrow>\n       0 < Polynomial.degree q\n 4. \\<And>q.\n       q \\<in> {q. \\<beta>'' q \\<noteq> 0} \\<Longrightarrow>\n       \\<beta>'' q \\<noteq> 0", "assume q: \"q \\<in> {q. \\<beta>'' q \\<noteq> 0}\""], ["proof (state)\nthis:\n  q \\<in> {q. \\<beta>'' q \\<noteq> 0}\n\ngoal (4 subgoals):\n 1. {q. \\<beta>'' q \\<noteq> 0} \\<noteq> {}\n 2. \\<And>q.\n       q \\<in> {q. \\<beta>'' q \\<noteq> 0} \\<Longrightarrow> irreducible q\n 3. \\<And>q.\n       q \\<in> {q. \\<beta>'' q \\<noteq> 0} \\<Longrightarrow>\n       0 < Polynomial.degree q\n 4. \\<And>q.\n       q \\<in> {q. \\<beta>'' q \\<noteq> 0} \\<Longrightarrow>\n       \\<beta>'' q \\<noteq> 0", "also"], ["proof (state)\nthis:\n  q \\<in> {q. \\<beta>'' q \\<noteq> 0}\n\ngoal (4 subgoals):\n 1. {q. \\<beta>'' q \\<noteq> 0} \\<noteq> {}\n 2. \\<And>q.\n       q \\<in> {q. \\<beta>'' q \\<noteq> 0} \\<Longrightarrow> irreducible q\n 3. \\<And>q.\n       q \\<in> {q. \\<beta>'' q \\<noteq> 0} \\<Longrightarrow>\n       0 < Polynomial.degree q\n 4. \\<And>q.\n       q \\<in> {q. \\<beta>'' q \\<noteq> 0} \\<Longrightarrow>\n       \\<beta>'' q \\<noteq> 0", "note supp_\\<beta>''"], ["proof (state)\nthis:\n  {q. \\<beta>'' q \\<noteq> 0}\n  \\<subseteq> (\\<Union>X\\<in>Roots_ms. prime_factors (Q X))\n\ngoal (4 subgoals):\n 1. {q. \\<beta>'' q \\<noteq> 0} \\<noteq> {}\n 2. \\<And>q.\n       q \\<in> {q. \\<beta>'' q \\<noteq> 0} \\<Longrightarrow> irreducible q\n 3. \\<And>q.\n       q \\<in> {q. \\<beta>'' q \\<noteq> 0} \\<Longrightarrow>\n       0 < Polynomial.degree q\n 4. \\<And>q.\n       q \\<in> {q. \\<beta>'' q \\<noteq> 0} \\<Longrightarrow>\n       \\<beta>'' q \\<noteq> 0", "finally"], ["proof (chain)\npicking this:\n  q \\<in> (\\<Union>X\\<in>Roots_ms. prime_factors (Q X))", "obtain X where X: \"X \\<in> Roots_ms\" \"q \\<in> prime_factors (Q X)\""], ["proof (prove)\nusing this:\n  q \\<in> (\\<Union>X\\<in>Roots_ms. prime_factors (Q X))\n\ngoal (1 subgoal):\n 1. (\\<And>X.\n        \\<lbrakk>X \\<in> Roots_ms;\n         q \\<in># prime_factorization (Q X)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  X \\<in> Roots_ms\n  q \\<in># prime_factorization (Q X)\n\ngoal (4 subgoals):\n 1. {q. \\<beta>'' q \\<noteq> 0} \\<noteq> {}\n 2. \\<And>q.\n       q \\<in> {q. \\<beta>'' q \\<noteq> 0} \\<Longrightarrow> irreducible q\n 3. \\<And>q.\n       q \\<in> {q. \\<beta>'' q \\<noteq> 0} \\<Longrightarrow>\n       0 < Polynomial.degree q\n 4. \\<And>q.\n       q \\<in> {q. \\<beta>'' q \\<noteq> 0} \\<Longrightarrow>\n       \\<beta>'' q \\<noteq> 0", "show \"irreducible q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. irreducible q", "using X"], ["proof (prove)\nusing this:\n  X \\<in> Roots_ms\n  q \\<in># prime_factorization (Q X)\n\ngoal (1 subgoal):\n 1. irreducible q", "by (intro prime_elem_imp_irreducible prime_imp_prime_elem) auto"], ["proof (state)\nthis:\n  irreducible q\n\ngoal (3 subgoals):\n 1. {q. \\<beta>'' q \\<noteq> 0} \\<noteq> {}\n 2. \\<And>q.\n       q \\<in> {q. \\<beta>'' q \\<noteq> 0} \\<Longrightarrow>\n       0 < Polynomial.degree q\n 3. \\<And>q.\n       q \\<in> {q. \\<beta>'' q \\<noteq> 0} \\<Longrightarrow>\n       \\<beta>'' q \\<noteq> 0", "show \"Polynomial.degree q > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < Polynomial.degree q", "using X"], ["proof (prove)\nusing this:\n  X \\<in> Roots_ms\n  q \\<in># prime_factorization (Q X)\n\ngoal (1 subgoal):\n 1. 0 < Polynomial.degree q", "by (intro content_1_imp_nonconstant_prime_factors[OF Q(2)[of X]])"], ["proof (state)\nthis:\n  0 < Polynomial.degree q\n\ngoal (2 subgoals):\n 1. {q. \\<beta>'' q \\<noteq> 0} \\<noteq> {}\n 2. \\<And>q.\n       q \\<in> {q. \\<beta>'' q \\<noteq> 0} \\<Longrightarrow>\n       \\<beta>'' q \\<noteq> 0", "qed (use \\<open>{x. \\<beta>'' x \\<noteq> 0} \\<noteq> {}\\<close> in auto)"], ["proof (state)\nthis:\n  (\\<Sum>q | \\<beta>'' q \\<noteq> 0.\n     of_int (\\<beta>'' q) * (\\<Sum>x | ipoly q x = 0. exp x)) \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  (\\<Sum>q | \\<beta>'' q \\<noteq> 0.\n     of_int (\\<beta>'' q) * (\\<Sum>x | ipoly q x = 0. exp x)) =\n  0\n  (\\<Sum>q | \\<beta>'' q \\<noteq> 0.\n     of_int (\\<beta>'' q) * (\\<Sum>x | ipoly q x = 0. exp x)) \\<noteq>\n  0", "show False"], ["proof (prove)\nusing this:\n  (\\<Sum>q | \\<beta>'' q \\<noteq> 0.\n     of_int (\\<beta>'' q) * (\\<Sum>x | ipoly q x = 0. exp x)) =\n  0\n  (\\<Sum>q | \\<beta>'' q \\<noteq> 0.\n     of_int (\\<beta>'' q) * (\\<Sum>x | ipoly q x = 0. exp x)) \\<noteq>\n  0\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Removing the restriction to integer coefficients\\<close>"], ["", "text \\<open>\n  Next, we weaken the restriction that the $\\beta_i$ must be integers to the restriction\n  that they must be rationals. This is done simply by multiplying with the least common multiple\n  of the demoninators.\n\\<close>"], ["", "lemma Hermite_Lindemann_aux3:\n  fixes X :: \"complex set\" and \\<beta> :: \"complex \\<Rightarrow> rat\"\n  assumes \"finite X\"\n  assumes nz:   \"\\<And>x. x \\<in> X \\<Longrightarrow> \\<beta> x \\<noteq> 0\"\n  assumes alg:  \"\\<And>x. x \\<in> X \\<Longrightarrow> algebraic x\"\n  assumes sum0: \"(\\<Sum>x\\<in>X. of_rat (\\<beta> x) * exp x) = 0\"\n  shows   \"X = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. X = {}", "define l :: int where \"l = Lcm ((snd \\<circ> quotient_of \\<circ> \\<beta>) ` X)\""], ["proof (state)\nthis:\n  l = Lcm ((snd \\<circ> quotient_of \\<circ> \\<beta>) ` X)\n\ngoal (1 subgoal):\n 1. X = {}", "have [simp]: \"snd (quotient_of r) \\<noteq> 0\" for r"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (quotient_of r) \\<noteq> 0", "using quotient_of_denom_pos'[of r]"], ["proof (prove)\nusing this:\n  0 < snd (quotient_of r)\n\ngoal (1 subgoal):\n 1. snd (quotient_of r) \\<noteq> 0", "by simp"], ["proof (state)\nthis:\n  snd (quotient_of ?r) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. X = {}", "have [simp]: \"l \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l \\<noteq> 0", "using \\<open>finite X\\<close>"], ["proof (prove)\nusing this:\n  finite X\n\ngoal (1 subgoal):\n 1. l \\<noteq> 0", "by (auto simp: l_def Lcm_0_iff)"], ["proof (state)\nthis:\n  l \\<noteq> 0\n\ngoal (1 subgoal):\n 1. X = {}", "have \"of_int l * \\<beta> x \\<in> \\<int>\" if \"x \\<in> X\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int l * \\<beta> x \\<in> \\<int>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. rat_of_int l * \\<beta> x \\<in> \\<int>", "define a b where \"a = fst (quotient_of (\\<beta> x))\" and \"b = snd (quotient_of (\\<beta> x))\""], ["proof (state)\nthis:\n  a = fst (quotient_of (\\<beta> x))\n  b = snd (quotient_of (\\<beta> x))\n\ngoal (1 subgoal):\n 1. rat_of_int l * \\<beta> x \\<in> \\<int>", "have \"b > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < b", "using quotient_of_denom_pos'[of \"\\<beta> x\"]"], ["proof (prove)\nusing this:\n  0 < snd (quotient_of (\\<beta> x))\n\ngoal (1 subgoal):\n 1. 0 < b", "by (auto simp: b_def)"], ["proof (state)\nthis:\n  0 < b\n\ngoal (1 subgoal):\n 1. rat_of_int l * \\<beta> x \\<in> \\<int>", "have \"\\<beta> x = of_int a / of_int b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta> x = rat_of_int a / rat_of_int b", "by (intro quotient_of_div) (auto simp: a_def b_def)"], ["proof (state)\nthis:\n  \\<beta> x = rat_of_int a / rat_of_int b\n\ngoal (1 subgoal):\n 1. rat_of_int l * \\<beta> x \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  \\<beta> x = rat_of_int a / rat_of_int b\n\ngoal (1 subgoal):\n 1. rat_of_int l * \\<beta> x \\<in> \\<int>", "have \"of_int l * \\<dots> = of_int (l * a) / of_int b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int l * (rat_of_int a / rat_of_int b) =\n    rat_of_int (l * a) / rat_of_int b", "using \\<open>b > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < b\n\ngoal (1 subgoal):\n 1. rat_of_int l * (rat_of_int a / rat_of_int b) =\n    rat_of_int (l * a) / rat_of_int b", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  rat_of_int l * (rat_of_int a / rat_of_int b) =\n  rat_of_int (l * a) / rat_of_int b\n\ngoal (1 subgoal):\n 1. rat_of_int l * \\<beta> x \\<in> \\<int>", "also"], ["proof (state)\nthis:\n  rat_of_int l * (rat_of_int a / rat_of_int b) =\n  rat_of_int (l * a) / rat_of_int b\n\ngoal (1 subgoal):\n 1. rat_of_int l * \\<beta> x \\<in> \\<int>", "have \"\\<dots> \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int (l * a) / rat_of_int b \\<in> \\<int>", "using that"], ["proof (prove)\nusing this:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. rat_of_int (l * a) / rat_of_int b \\<in> \\<int>", "by (intro of_int_divide_in_Ints) (auto simp: l_def b_def)"], ["proof (state)\nthis:\n  rat_of_int (l * a) / rat_of_int b \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. rat_of_int l * \\<beta> x \\<in> \\<int>", "finally"], ["proof (chain)\npicking this:\n  rat_of_int l * \\<beta> x \\<in> \\<int>", "show ?thesis"], ["proof (prove)\nusing this:\n  rat_of_int l * \\<beta> x \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. rat_of_int l * \\<beta> x \\<in> \\<int>", "."], ["proof (state)\nthis:\n  rat_of_int l * \\<beta> x \\<in> \\<int>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> X \\<Longrightarrow> rat_of_int l * \\<beta> ?x \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. X = {}", "hence \"\\<forall>x\\<in>X. \\<exists>n. of_int n = of_int l * \\<beta> x\""], ["proof (prove)\nusing this:\n  ?x \\<in> X \\<Longrightarrow> rat_of_int l * \\<beta> ?x \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>X. \\<exists>n. rat_of_int n = rat_of_int l * \\<beta> x", "using Ints_cases"], ["proof (prove)\nusing this:\n  ?x \\<in> X \\<Longrightarrow> rat_of_int l * \\<beta> ?x \\<in> \\<int>\n  \\<lbrakk>?q \\<in> \\<int>;\n   \\<And>z. ?q = of_int z \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>X. \\<exists>n. rat_of_int n = rat_of_int l * \\<beta> x", "by metis"], ["proof (state)\nthis:\n  \\<forall>x\\<in>X. \\<exists>n. rat_of_int n = rat_of_int l * \\<beta> x\n\ngoal (1 subgoal):\n 1. X = {}", "then"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>X. \\<exists>n. rat_of_int n = rat_of_int l * \\<beta> x", "obtain \\<beta>' where \\<beta>': \"of_int (\\<beta>' x) = of_int l * \\<beta> x\" if \"x \\<in> X\" for x"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>X. \\<exists>n. rat_of_int n = rat_of_int l * \\<beta> x\n\ngoal (1 subgoal):\n 1. (\\<And>\\<beta>'.\n        (\\<And>x.\n            x \\<in> X \\<Longrightarrow>\n            rat_of_int (\\<beta>' x) =\n            rat_of_int l * \\<beta> x) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  ?x \\<in> X \\<Longrightarrow>\n  rat_of_int (\\<beta>' ?x) = rat_of_int l * \\<beta> ?x\n\ngoal (1 subgoal):\n 1. X = {}", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. X = {}", "proof (rule Hermite_Lindemann_aux2)"], ["proof (state)\ngoal (4 subgoals):\n 1. finite X\n 2. \\<And>x. x \\<in> X \\<Longrightarrow> ?\\<beta> x \\<noteq> 0\n 3. \\<And>x. x \\<in> X \\<Longrightarrow> algebraic x\n 4. (\\<Sum>x\\<in>X. of_int (?\\<beta> x) * exp x) = 0", "have \"0 = of_int l * (\\<Sum>x\\<in>X. of_rat (\\<beta> x) * exp x :: complex)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = of_int l * (\\<Sum>x\\<in>X. of_rat (\\<beta> x) * exp x)", "by (simp add: sum0)"], ["proof (state)\nthis:\n  0 = of_int l * (\\<Sum>x\\<in>X. of_rat (\\<beta> x) * exp x)\n\ngoal (4 subgoals):\n 1. finite X\n 2. \\<And>x. x \\<in> X \\<Longrightarrow> ?\\<beta> x \\<noteq> 0\n 3. \\<And>x. x \\<in> X \\<Longrightarrow> algebraic x\n 4. (\\<Sum>x\\<in>X. of_int (?\\<beta> x) * exp x) = 0", "also"], ["proof (state)\nthis:\n  0 = of_int l * (\\<Sum>x\\<in>X. of_rat (\\<beta> x) * exp x)\n\ngoal (4 subgoals):\n 1. finite X\n 2. \\<And>x. x \\<in> X \\<Longrightarrow> ?\\<beta> x \\<noteq> 0\n 3. \\<And>x. x \\<in> X \\<Longrightarrow> algebraic x\n 4. (\\<Sum>x\\<in>X. of_int (?\\<beta> x) * exp x) = 0", "have \"\\<dots> = (\\<Sum>x\\<in>X. of_int (\\<beta>' x) * exp x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int l * (\\<Sum>x\\<in>X. of_rat (\\<beta> x) * exp x) =\n    (\\<Sum>x\\<in>X. of_int (\\<beta>' x) * exp x)", "unfolding sum_distrib_left"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>n\\<in>X. of_int l * (of_rat (\\<beta> n) * exp n)) =\n    (\\<Sum>x\\<in>X. of_int (\\<beta>' x) * exp x)", "proof (rule sum.cong, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. X = X\n 2. \\<And>x.\n       x \\<in> X \\<Longrightarrow>\n       of_int l * (of_rat (\\<beta> x) * exp x) = of_int (\\<beta>' x) * exp x", "case (2 x)"], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (2 subgoals):\n 1. X = X\n 2. \\<And>x.\n       x \\<in> X \\<Longrightarrow>\n       of_int l * (of_rat (\\<beta> x) * exp x) = of_int (\\<beta>' x) * exp x", "have \"of_int l * of_rat (\\<beta> x) = of_rat (of_int l * \\<beta> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int l * of_rat (\\<beta> x) = of_rat (rat_of_int l * \\<beta> x)", "by (simp add: of_rat_mult)"], ["proof (state)\nthis:\n  of_int l * of_rat (\\<beta> x) = of_rat (rat_of_int l * \\<beta> x)\n\ngoal (2 subgoals):\n 1. X = X\n 2. \\<And>x.\n       x \\<in> X \\<Longrightarrow>\n       of_int l * (of_rat (\\<beta> x) * exp x) = of_int (\\<beta>' x) * exp x", "also"], ["proof (state)\nthis:\n  of_int l * of_rat (\\<beta> x) = of_rat (rat_of_int l * \\<beta> x)\n\ngoal (2 subgoals):\n 1. X = X\n 2. \\<And>x.\n       x \\<in> X \\<Longrightarrow>\n       of_int l * (of_rat (\\<beta> x) * exp x) = of_int (\\<beta>' x) * exp x", "have \"of_int l * \\<beta> x = of_int (\\<beta>' x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rat_of_int l * \\<beta> x = rat_of_int (\\<beta>' x)", "using 2"], ["proof (prove)\nusing this:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. rat_of_int l * \\<beta> x = rat_of_int (\\<beta>' x)", "by (rule \\<beta>' [symmetric])"], ["proof (state)\nthis:\n  rat_of_int l * \\<beta> x = rat_of_int (\\<beta>' x)\n\ngoal (2 subgoals):\n 1. X = X\n 2. \\<And>x.\n       x \\<in> X \\<Longrightarrow>\n       of_int l * (of_rat (\\<beta> x) * exp x) = of_int (\\<beta>' x) * exp x", "finally"], ["proof (chain)\npicking this:\n  of_int l * of_rat (\\<beta> x) = of_rat (rat_of_int (\\<beta>' x))", "show ?case"], ["proof (prove)\nusing this:\n  of_int l * of_rat (\\<beta> x) = of_rat (rat_of_int (\\<beta>' x))\n\ngoal (1 subgoal):\n 1. of_int l * (of_rat (\\<beta> x) * exp x) = of_int (\\<beta>' x) * exp x", "by (simp add: mult_ac)"], ["proof (state)\nthis:\n  of_int l * (of_rat (\\<beta> x) * exp x) = of_int (\\<beta>' x) * exp x\n\ngoal (1 subgoal):\n 1. X = X", "qed simp_all"], ["proof (state)\nthis:\n  of_int l * (\\<Sum>x\\<in>X. of_rat (\\<beta> x) * exp x) =\n  (\\<Sum>x\\<in>X. of_int (\\<beta>' x) * exp x)\n\ngoal (4 subgoals):\n 1. finite X\n 2. \\<And>x. x \\<in> X \\<Longrightarrow> ?\\<beta> x \\<noteq> 0\n 3. \\<And>x. x \\<in> X \\<Longrightarrow> algebraic x\n 4. (\\<Sum>x\\<in>X. of_int (?\\<beta> x) * exp x) = 0", "finally"], ["proof (chain)\npicking this:\n  0 = (\\<Sum>x\\<in>X. of_int (\\<beta>' x) * exp x)", "show \"\\<dots> = 0\""], ["proof (prove)\nusing this:\n  0 = (\\<Sum>x\\<in>X. of_int (\\<beta>' x) * exp x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>X. of_int (\\<beta>' x) * exp x) = 0", ".."], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>X. of_int (\\<beta>' x) * exp x) = 0\n\ngoal (3 subgoals):\n 1. finite X\n 2. \\<And>x. x \\<in> X \\<Longrightarrow> \\<beta>' x \\<noteq> 0\n 3. \\<And>x. x \\<in> X \\<Longrightarrow> algebraic x", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. finite X\n 2. \\<And>x. x \\<in> X \\<Longrightarrow> \\<beta>' x \\<noteq> 0\n 3. \\<And>x. x \\<in> X \\<Longrightarrow> algebraic x", "fix x"], ["proof (state)\ngoal (3 subgoals):\n 1. finite X\n 2. \\<And>x. x \\<in> X \\<Longrightarrow> \\<beta>' x \\<noteq> 0\n 3. \\<And>x. x \\<in> X \\<Longrightarrow> algebraic x", "assume \"x \\<in> X\""], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (3 subgoals):\n 1. finite X\n 2. \\<And>x. x \\<in> X \\<Longrightarrow> \\<beta>' x \\<noteq> 0\n 3. \\<And>x. x \\<in> X \\<Longrightarrow> algebraic x", "hence \"of_int (\\<beta>' x) \\<noteq> (0 :: rat)\""], ["proof (prove)\nusing this:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. rat_of_int (\\<beta>' x) \\<noteq> 0", "using nz"], ["proof (prove)\nusing this:\n  x \\<in> X\n  ?x \\<in> X \\<Longrightarrow> \\<beta> ?x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. rat_of_int (\\<beta>' x) \\<noteq> 0", "by (subst \\<beta>') auto"], ["proof (state)\nthis:\n  rat_of_int (\\<beta>' x) \\<noteq> 0\n\ngoal (3 subgoals):\n 1. finite X\n 2. \\<And>x. x \\<in> X \\<Longrightarrow> \\<beta>' x \\<noteq> 0\n 3. \\<And>x. x \\<in> X \\<Longrightarrow> algebraic x", "thus \"\\<beta>' x \\<noteq> 0\""], ["proof (prove)\nusing this:\n  rat_of_int (\\<beta>' x) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<beta>' x \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  \\<beta>' x \\<noteq> 0\n\ngoal (2 subgoals):\n 1. finite X\n 2. \\<And>x. x \\<in> X \\<Longrightarrow> algebraic x", "qed (use alg \\<open>finite X\\<close> in auto)"], ["proof (state)\nthis:\n  X = {}\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Next, we weaken the restriction that the $\\beta_i$ must be rational to them being algebraic.\n  Similarly to before, this is done by multiplying over all possible permutations of the $\\beta_i$\n  (in some sense) to introduce more symmetry, from which it then follows by the fundamental theorem\n  of symmetric polynomials that the resulting coefficients are rational.\n\\<close>"], ["", "lemma Hermite_Lindemann_aux4:\n  fixes \\<beta> :: \"complex \\<Rightarrow> complex\"\n  assumes [intro]: \"finite X\"\n  assumes alg1: \"\\<And>x. x \\<in> X \\<Longrightarrow> algebraic x\"\n  assumes alg2: \"\\<And>x. x \\<in> X \\<Longrightarrow> algebraic (\\<beta> x)\"\n  assumes nz:   \"\\<And>x. x \\<in> X \\<Longrightarrow> \\<beta> x \\<noteq> 0\"\n  assumes sum0: \"(\\<Sum>x\\<in>X. \\<beta> x * exp x) = 0\"\n  shows   \"X = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X = {}", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "assume X: \"X \\<noteq> {}\""], ["proof (state)\nthis:\n  X \\<noteq> {}\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "note [intro!] = finite_PiE"], ["proof (state)\nthis:\n  \\<lbrakk>finite ?S;\n   \\<And>i. i \\<in> ?S \\<Longrightarrow> finite (?T i)\\<rbrakk>\n  \\<Longrightarrow> finite (Pi\\<^sub>E ?S ?T)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "text \\<open>\n    We now take more or less the same approach as before, except that now we find a polynomial\n    that has all of the conjugates of the coefficients \\<open>\\<beta>\\<close> as roots. Note that this is a slight\n    deviation from Baker's proof, who picks one polynomial for each \\<open>\\<beta>\\<close> independently. I did it\n    this way because, as Bernard~\\cite{bernard} observed, it makes the proof a bit easier.\n  \\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>finite ?S;\n   \\<And>i. i \\<in> ?S \\<Longrightarrow> finite (?T i)\\<rbrakk>\n  \\<Longrightarrow> finite (Pi\\<^sub>E ?S ?T)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "define P :: \"int poly\" where \"P = \\<Prod>((min_int_poly \\<circ> \\<beta>) ` X)\""], ["proof (state)\nthis:\n  P = \\<Prod>((min_int_poly \\<circ> \\<beta>) ` X)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "define Roots :: \"complex set\" where \"Roots = {x. ipoly P x = 0}\""], ["proof (state)\nthis:\n  Roots = {x. ipoly P x = 0}\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have \"0 \\<notin> Roots\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> Roots", "using \\<open>finite X\\<close> alg2 nz"], ["proof (prove)\nusing this:\n  finite X\n  ?x \\<in> X \\<Longrightarrow> algebraic (\\<beta> ?x)\n  ?x \\<in> X \\<Longrightarrow> \\<beta> ?x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 0 \\<notin> Roots", "by (auto simp: Roots_def P_def poly_prod)"], ["proof (state)\nthis:\n  0 \\<notin> Roots\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have [simp]: \"P \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P \\<noteq> 0", "using \\<open>finite X\\<close>"], ["proof (prove)\nusing this:\n  finite X\n\ngoal (1 subgoal):\n 1. P \\<noteq> 0", "by (auto simp: P_def)"], ["proof (state)\nthis:\n  P \\<noteq> 0\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have [intro]: \"finite Roots\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite Roots", "unfolding Roots_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {x. ipoly P x = 0}", "by (intro poly_roots_finite) auto"], ["proof (state)\nthis:\n  finite Roots\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have \"\\<beta> ` X \\<subseteq> Roots\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta> ` X \\<subseteq> Roots", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa. xa \\<in> X \\<Longrightarrow> \\<beta> xa \\<in> Roots", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa. xa \\<in> X \\<Longrightarrow> \\<beta> xa \\<in> Roots", "assume \"x \\<in> X\""], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>x xa. xa \\<in> X \\<Longrightarrow> \\<beta> xa \\<in> Roots", "hence \"ipoly (min_int_poly (\\<beta> x)) (\\<beta> x) = 0\""], ["proof (prove)\nusing this:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. ipoly (min_int_poly (\\<beta> x)) (\\<beta> x) = 0", "by (intro ipoly_min_int_poly alg2)"], ["proof (state)\nthis:\n  ipoly (min_int_poly (\\<beta> x)) (\\<beta> x) = 0\n\ngoal (1 subgoal):\n 1. \\<And>x xa. xa \\<in> X \\<Longrightarrow> \\<beta> xa \\<in> Roots", "thus \"\\<beta> x \\<in> Roots\""], ["proof (prove)\nusing this:\n  ipoly (min_int_poly (\\<beta> x)) (\\<beta> x) = 0\n\ngoal (1 subgoal):\n 1. \\<beta> x \\<in> Roots", "using \\<open>finite X\\<close> \\<open>x \\<in> X\\<close>"], ["proof (prove)\nusing this:\n  ipoly (min_int_poly (\\<beta> x)) (\\<beta> x) = 0\n  finite X\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. \\<beta> x \\<in> Roots", "by (auto simp: Roots_def P_def of_int_poly_hom.hom_prod poly_prod)"], ["proof (state)\nthis:\n  \\<beta> x \\<in> Roots\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<beta> ` X \\<subseteq> Roots\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have \"squarefree (of_int_poly P :: complex poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. squarefree (Ring_Hom_Poly.of_int_poly P)", "unfolding P_def of_int_poly_hom.hom_prod o_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. squarefree\n     (prod Ring_Hom_Poly.of_int_poly\n       ((\\<lambda>x. min_int_poly (\\<beta> x)) ` X))", "proof (rule squarefree_prod_coprime; safe)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b x xa.\n       \\<lbrakk>min_int_poly (\\<beta> x) \\<noteq> min_int_poly (\\<beta> xa);\n        x \\<in> X; xa \\<in> X\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime\n                          (Ring_Hom_Poly.of_int_poly\n                            (min_int_poly (\\<beta> x)))\n                          (Ring_Hom_Poly.of_int_poly\n                            (min_int_poly (\\<beta> xa)))\n 2. \\<And>a x.\n       x \\<in> X \\<Longrightarrow>\n       squarefree (Ring_Hom_Poly.of_int_poly (min_int_poly (\\<beta> x)))", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b x xa.\n       \\<lbrakk>min_int_poly (\\<beta> x) \\<noteq> min_int_poly (\\<beta> xa);\n        x \\<in> X; xa \\<in> X\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime\n                          (Ring_Hom_Poly.of_int_poly\n                            (min_int_poly (\\<beta> x)))\n                          (Ring_Hom_Poly.of_int_poly\n                            (min_int_poly (\\<beta> xa)))\n 2. \\<And>a x.\n       x \\<in> X \\<Longrightarrow>\n       squarefree (Ring_Hom_Poly.of_int_poly (min_int_poly (\\<beta> x)))", "assume \"x \\<in> X\""], ["proof (state)\nthis:\n  x \\<in> X\n\ngoal (2 subgoals):\n 1. \\<And>a b x xa.\n       \\<lbrakk>min_int_poly (\\<beta> x) \\<noteq> min_int_poly (\\<beta> xa);\n        x \\<in> X; xa \\<in> X\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime\n                          (Ring_Hom_Poly.of_int_poly\n                            (min_int_poly (\\<beta> x)))\n                          (Ring_Hom_Poly.of_int_poly\n                            (min_int_poly (\\<beta> xa)))\n 2. \\<And>a x.\n       x \\<in> X \\<Longrightarrow>\n       squarefree (Ring_Hom_Poly.of_int_poly (min_int_poly (\\<beta> x)))", "thus \"squarefree (of_int_poly (min_int_poly (\\<beta> x)) :: complex poly)\""], ["proof (prove)\nusing this:\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. squarefree (Ring_Hom_Poly.of_int_poly (min_int_poly (\\<beta> x)))", "by (intro squarefree_of_int_polyI) auto"], ["proof (state)\nthis:\n  squarefree (Ring_Hom_Poly.of_int_poly (min_int_poly (\\<beta> x)))\n\ngoal (1 subgoal):\n 1. \\<And>a b x xa.\n       \\<lbrakk>min_int_poly (\\<beta> x) \\<noteq> min_int_poly (\\<beta> xa);\n        x \\<in> X; xa \\<in> X\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime\n                          (Ring_Hom_Poly.of_int_poly\n                            (min_int_poly (\\<beta> x)))\n                          (Ring_Hom_Poly.of_int_poly\n                            (min_int_poly (\\<beta> xa)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b x xa.\n       \\<lbrakk>min_int_poly (\\<beta> x) \\<noteq> min_int_poly (\\<beta> xa);\n        x \\<in> X; xa \\<in> X\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime\n                          (Ring_Hom_Poly.of_int_poly\n                            (min_int_poly (\\<beta> x)))\n                          (Ring_Hom_Poly.of_int_poly\n                            (min_int_poly (\\<beta> xa)))", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b x xa.\n       \\<lbrakk>min_int_poly (\\<beta> x) \\<noteq> min_int_poly (\\<beta> xa);\n        x \\<in> X; xa \\<in> X\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime\n                          (Ring_Hom_Poly.of_int_poly\n                            (min_int_poly (\\<beta> x)))\n                          (Ring_Hom_Poly.of_int_poly\n                            (min_int_poly (\\<beta> xa)))", "assume xy: \"x \\<in> X\" \"y \\<in> X\" \"min_int_poly (\\<beta> x) \\<noteq> min_int_poly (\\<beta> y)\""], ["proof (state)\nthis:\n  x \\<in> X\n  y \\<in> X\n  min_int_poly (\\<beta> x) \\<noteq> min_int_poly (\\<beta> y)\n\ngoal (1 subgoal):\n 1. \\<And>a b x xa.\n       \\<lbrakk>min_int_poly (\\<beta> x) \\<noteq> min_int_poly (\\<beta> xa);\n        x \\<in> X; xa \\<in> X\\<rbrakk>\n       \\<Longrightarrow> algebraic_semidom_class.coprime\n                          (Ring_Hom_Poly.of_int_poly\n                            (min_int_poly (\\<beta> x)))\n                          (Ring_Hom_Poly.of_int_poly\n                            (min_int_poly (\\<beta> xa)))", "thus \"Rings.coprime (of_int_poly (min_int_poly (\\<beta> x)))\n            (of_int_poly (min_int_poly (\\<beta> y)) :: complex poly)\""], ["proof (prove)\nusing this:\n  x \\<in> X\n  y \\<in> X\n  min_int_poly (\\<beta> x) \\<noteq> min_int_poly (\\<beta> y)\n\ngoal (1 subgoal):\n 1. algebraic_semidom_class.coprime\n     (Ring_Hom_Poly.of_int_poly (min_int_poly (\\<beta> x)))\n     (Ring_Hom_Poly.of_int_poly (min_int_poly (\\<beta> y)))", "by (intro coprime_of_int_polyI[OF primes_coprime]) auto"], ["proof (state)\nthis:\n  algebraic_semidom_class.coprime\n   (Ring_Hom_Poly.of_int_poly (min_int_poly (\\<beta> x)))\n   (Ring_Hom_Poly.of_int_poly (min_int_poly (\\<beta> y)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  squarefree (Ring_Hom_Poly.of_int_poly P)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "define n where \"n = card Roots\""], ["proof (state)\nthis:\n  n = card Roots\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "define m where \"m = card X\""], ["proof (state)\nthis:\n  m = card X\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have \"Roots \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Roots \\<noteq> {}", "using \\<open>\\<beta> ` X \\<subseteq> Roots\\<close> \\<open>X \\<noteq> {}\\<close>"], ["proof (prove)\nusing this:\n  \\<beta> ` X \\<subseteq> Roots\n  X \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Roots \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  Roots \\<noteq> {}\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "hence \"n > 0\" \"m > 0\""], ["proof (prove)\nusing this:\n  Roots \\<noteq> {}\n\ngoal (1 subgoal):\n 1. 0 < n &&& 0 < m", "using \\<open>finite Roots\\<close> \\<open>finite X\\<close> \\<open>X \\<noteq> {}\\<close>"], ["proof (prove)\nusing this:\n  Roots \\<noteq> {}\n  finite Roots\n  finite X\n  X \\<noteq> {}\n\ngoal (1 subgoal):\n 1. 0 < n &&& 0 < m", "by (auto simp: n_def m_def)"], ["proof (state)\nthis:\n  0 < n\n  0 < m\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have fin1 [simp]: \"finite (X \\<rightarrow>\\<^sub>E Roots)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (X \\<rightarrow>\\<^sub>E Roots)", "by auto"], ["proof (state)\nthis:\n  finite (X \\<rightarrow>\\<^sub>E Roots)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have [simp]: \"card (X \\<rightarrow>\\<^sub>E Roots) = n ^ m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card (X \\<rightarrow>\\<^sub>E Roots) = n ^ m", "by (subst card_PiE) (auto simp: m_def n_def)"], ["proof (state)\nthis:\n  card (X \\<rightarrow>\\<^sub>E Roots) = n ^ m\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "text \\<open>\n    We again find a bijection between the roots and the natural numbers less than \\<open>n\\<close>:\n  \\<close>"], ["proof (state)\nthis:\n  card (X \\<rightarrow>\\<^sub>E Roots) = n ^ m\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "obtain Root where Root: \"bij_betw Root {..<n} Roots\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Root.\n        bij_betw Root {..<n} Roots \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ex_bij_betw_nat_finite[OF \\<open>finite Roots\\<close>]"], ["proof (prove)\nusing this:\n  \\<exists>h. bij_betw h {0..<card Roots} Roots\n\ngoal (1 subgoal):\n 1. (\\<And>Root.\n        bij_betw Root {..<n} Roots \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding n_def atLeast0LessThan"], ["proof (prove)\nusing this:\n  \\<exists>h. bij_betw h {..<card Roots} Roots\n\ngoal (1 subgoal):\n 1. (\\<And>Root.\n        bij_betw Root {..<card Roots} Roots \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  bij_betw Root {..<n} Roots\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "define unRoot :: \"complex \\<Rightarrow> nat\" where \"unRoot = inv_into {..<n} Root\""], ["proof (state)\nthis:\n  unRoot = inv_into {..<n} Root\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have unRoot: \"bij_betw unRoot Roots {..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw unRoot Roots {..<n}", "unfolding unRoot_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (inv_into {..<n} Root) Roots {..<n}", "by (intro bij_betw_inv_into Root)"], ["proof (state)\nthis:\n  bij_betw unRoot Roots {..<n}\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have unRoot_Root [simp]: \"unRoot (Root i) = i\" if \"i < n\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. unRoot (Root i) = i", "unfolding unRoot_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_into {..<n} Root (Root i) = i", "using Root that"], ["proof (prove)\nusing this:\n  bij_betw Root {..<n} Roots\n  i < n\n\ngoal (1 subgoal):\n 1. inv_into {..<n} Root (Root i) = i", "by (subst inv_into_f_f) (auto simp: bij_betw_def)"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow> unRoot (Root ?i) = ?i\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have Root_unRoot [simp]: \"Root (unRoot x) = x\" if \"x \\<in> Roots\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. Root (unRoot x) = x", "unfolding unRoot_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Root (inv_into {..<n} Root x) = x", "using Root that"], ["proof (prove)\nusing this:\n  bij_betw Root {..<n} Roots\n  x \\<in> Roots\n\ngoal (1 subgoal):\n 1. Root (inv_into {..<n} Root x) = x", "by (subst f_inv_into_f) (auto simp: bij_betw_def)"], ["proof (state)\nthis:\n  ?x \\<in> Roots \\<Longrightarrow> Root (unRoot ?x) = ?x\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have [simp, intro]: \"Root i \\<in> Roots\" if \"i < n\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. Root i \\<in> Roots", "using Root that"], ["proof (prove)\nusing this:\n  bij_betw Root {..<n} Roots\n  i < n\n\ngoal (1 subgoal):\n 1. Root i \\<in> Roots", "by (auto simp: bij_betw_def)"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow> Root ?i \\<in> Roots\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have [simp, intro]: \"unRoot x < n\" if \"x \\<in> Roots\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. unRoot x < n", "using unRoot that"], ["proof (prove)\nusing this:\n  bij_betw unRoot Roots {..<n}\n  x \\<in> Roots\n\ngoal (1 subgoal):\n 1. unRoot x < n", "by (auto simp: bij_betw_def)"], ["proof (state)\nthis:\n  ?x \\<in> Roots \\<Longrightarrow> unRoot ?x < n\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "text \\<open>\n    And we again define the set of multisets and tuples that we will get in the expanded product.\n  \\<close>"], ["proof (state)\nthis:\n  ?x \\<in> Roots \\<Longrightarrow> unRoot ?x < n\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "define Roots_ms :: \"complex multiset set\" where\n    \"Roots_ms = {Y. set_mset Y \\<subseteq> X \\<and> size Y = n ^ m}\""], ["proof (state)\nthis:\n  Roots_ms = {Y. set_mset Y \\<subseteq> X \\<and> size Y = n ^ m}\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have [intro]: \"finite Roots_ms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite Roots_ms", "unfolding Roots_ms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {Y. set_mset Y \\<subseteq> X \\<and> size Y = n ^ m}", "by (rule finite_multisets_of_size) auto"], ["proof (state)\nthis:\n  finite Roots_ms\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "define tuples :: \"complex multiset \\<Rightarrow> ((complex \\<Rightarrow> complex) \\<Rightarrow> complex) set\"\n    where \"tuples = (\\<lambda>Y. {f\\<in>(X \\<rightarrow>\\<^sub>E Roots) \\<rightarrow>\\<^sub>E X. image_mset f (mset_set (X \\<rightarrow>\\<^sub>E Roots)) = Y})\""], ["proof (state)\nthis:\n  tuples =\n  (\\<lambda>Y.\n      {f \\<in> (X \\<rightarrow>\\<^sub>E Roots) \\<rightarrow>\\<^sub>E X.\n       image_mset f (mset_set (X \\<rightarrow>\\<^sub>E Roots)) = Y})\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have [intro]: \"finite (tuples Y)\" for Y"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (tuples Y)", "unfolding tuples_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {f \\<in> (X \\<rightarrow>\\<^sub>E Roots) \\<rightarrow>\\<^sub>E X.\n      image_mset f (mset_set (X \\<rightarrow>\\<^sub>E Roots)) = Y}", "by (rule finite_subset[of _ \"(X \\<rightarrow>\\<^sub>E Roots) \\<rightarrow>\\<^sub>E X\"]) auto"], ["proof (state)\nthis:\n  finite (tuples ?Y)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "text \\<open>\n    We will also need to convert permutations over the natural and over the roots again.\n  \\<close>"], ["proof (state)\nthis:\n  finite (tuples ?Y)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "define convert_perm :: \"(nat \\<Rightarrow> nat) \\<Rightarrow> (complex \\<Rightarrow> complex)\" where\n    \"convert_perm = (\\<lambda>\\<sigma> x. if x \\<in> Roots then Root (\\<sigma> (unRoot x)) else x)\""], ["proof (state)\nthis:\n  convert_perm =\n  (\\<lambda>\\<sigma> x.\n      if x \\<in> Roots then Root (\\<sigma> (unRoot x)) else x)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have bij_convert: \"bij_betw convert_perm {\\<sigma>. \\<sigma> permutes {..<n}} {\\<sigma>. \\<sigma> permutes Roots}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw convert_perm {\\<sigma>. \\<sigma> permutes {..<n}}\n     {\\<sigma>. \\<sigma> permutes Roots}", "using bij_betw_permutations[OF Root]"], ["proof (prove)\nusing this:\n  bij_betw\n   (\\<lambda>\\<pi> x.\n       if x \\<in> Roots then Root (\\<pi> (inv_into {..<n} Root x)) else x)\n   {\\<pi>. \\<pi> permutes {..<n}} {\\<pi>. \\<pi> permutes Roots}\n\ngoal (1 subgoal):\n 1. bij_betw convert_perm {\\<sigma>. \\<sigma> permutes {..<n}}\n     {\\<sigma>. \\<sigma> permutes Roots}", "unfolding convert_perm_def unRoot_def"], ["proof (prove)\nusing this:\n  bij_betw\n   (\\<lambda>\\<pi> x.\n       if x \\<in> Roots then Root (\\<pi> (inv_into {..<n} Root x)) else x)\n   {\\<pi>. \\<pi> permutes {..<n}} {\\<pi>. \\<pi> permutes Roots}\n\ngoal (1 subgoal):\n 1. bij_betw\n     (\\<lambda>\\<sigma> x.\n         if x \\<in> Roots then Root (\\<sigma> (inv_into {..<n} Root x))\n         else x)\n     {\\<sigma>. \\<sigma> permutes {..<n}}\n     {\\<sigma>. \\<sigma> permutes Roots}", "."], ["proof (state)\nthis:\n  bij_betw convert_perm {\\<sigma>. \\<sigma> permutes {..<n}}\n   {\\<sigma>. \\<sigma> permutes Roots}\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have permutes_convert_perm [intro]: \"convert_perm \\<sigma> permutes Roots\" if \"\\<sigma> permutes {..<n}\" for \\<sigma>"], ["proof (prove)\ngoal (1 subgoal):\n 1. convert_perm \\<sigma> permutes Roots", "using that bij_convert"], ["proof (prove)\nusing this:\n  \\<sigma> permutes {..<n}\n  bij_betw convert_perm {\\<sigma>. \\<sigma> permutes {..<n}}\n   {\\<sigma>. \\<sigma> permutes Roots}\n\ngoal (1 subgoal):\n 1. convert_perm \\<sigma> permutes Roots", "unfolding bij_betw_def"], ["proof (prove)\nusing this:\n  \\<sigma> permutes {..<n}\n  inj_on convert_perm {\\<sigma>. \\<sigma> permutes {..<n}} \\<and>\n  convert_perm ` {\\<sigma>. \\<sigma> permutes {..<n}} =\n  {\\<sigma>. \\<sigma> permutes Roots}\n\ngoal (1 subgoal):\n 1. convert_perm \\<sigma> permutes Roots", "by blast"], ["proof (state)\nthis:\n  ?\\<sigma> permutes {..<n} \\<Longrightarrow>\n  convert_perm ?\\<sigma> permutes Roots\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "text \\<open>\n    We also need a small lemma showing that our tuples are stable under permutation of the roots.\n  \\<close>"], ["proof (state)\nthis:\n  ?\\<sigma> permutes {..<n} \\<Longrightarrow>\n  convert_perm ?\\<sigma> permutes Roots\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have bij_betw_compose_perm: \n    \"bij_betw (\\<lambda>f. restrict (\\<lambda>g. f (restrict (\\<pi> \\<circ> g) X)) (X \\<rightarrow>\\<^sub>E Roots)) (tuples Y) (tuples Y)\"\n    if \\<pi>: \"\\<pi> permutes Roots\" and \"Y \\<in> Roots_ms\" for \\<pi> Y"], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw\n     (\\<lambda>f.\n         \\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n            f (restrict (\\<pi> \\<circ> g) X))\n     (tuples Y) (tuples Y)", "proof (rule bij_betwI)"], ["proof (state)\ngoal (4 subgoals):\n 1. (\\<lambda>f.\n        \\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n           f (restrict (\\<pi> \\<circ> g) X))\n    \\<in> tuples Y \\<rightarrow> tuples Y\n 2. ?g \\<in> tuples Y \\<rightarrow> tuples Y\n 3. \\<And>x.\n       x \\<in> tuples Y \\<Longrightarrow>\n       ?g (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n              x (restrict (\\<pi> \\<circ> g) X)) =\n       x\n 4. \\<And>y.\n       y \\<in> tuples Y \\<Longrightarrow>\n       (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n           ?g y (restrict (\\<pi> \\<circ> g) X)) =\n       y", "have *: \"(\\<lambda>f. restrict (\\<lambda>g. f (restrict (\\<pi> \\<circ> g) X)) (X \\<rightarrow>\\<^sub>E Roots)) \\<in> tuples Y \\<rightarrow> tuples Y\"\n      if \\<pi>: \"\\<pi> permutes Roots\" for \\<pi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f.\n        \\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n           f (restrict (\\<pi> \\<circ> g) X))\n    \\<in> tuples Y \\<rightarrow> tuples Y", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> tuples Y \\<Longrightarrow>\n       (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n           x (restrict (\\<pi> \\<circ> g) X))\n       \\<in> tuples Y", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> tuples Y \\<Longrightarrow>\n       (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n           x (restrict (\\<pi> \\<circ> g) X))\n       \\<in> tuples Y", "assume f: \"f \\<in> tuples Y\""], ["proof (state)\nthis:\n  f \\<in> tuples Y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> tuples Y \\<Longrightarrow>\n       (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n           x (restrict (\\<pi> \\<circ> g) X))\n       \\<in> tuples Y", "hence f': \"f \\<in> (X \\<rightarrow>\\<^sub>E Roots) \\<rightarrow>\\<^sub>E X\""], ["proof (prove)\nusing this:\n  f \\<in> tuples Y\n\ngoal (1 subgoal):\n 1. f \\<in> (X \\<rightarrow>\\<^sub>E Roots) \\<rightarrow>\\<^sub>E X", "by (auto simp: tuples_def)"], ["proof (state)\nthis:\n  f \\<in> (X \\<rightarrow>\\<^sub>E Roots) \\<rightarrow>\\<^sub>E X\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> tuples Y \\<Longrightarrow>\n       (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n           x (restrict (\\<pi> \\<circ> g) X))\n       \\<in> tuples Y", "define f' where \"f' = (\\<lambda>g. f (restrict (\\<pi> \\<circ> g) X))\""], ["proof (state)\nthis:\n  f' = (\\<lambda>g. f (restrict (\\<pi> \\<circ> g) X))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> tuples Y \\<Longrightarrow>\n       (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n           x (restrict (\\<pi> \\<circ> g) X))\n       \\<in> tuples Y", "have \"f' \\<in> (X \\<rightarrow>\\<^sub>E Roots) \\<rightarrow> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f' \\<in> (X \\<rightarrow>\\<^sub>E Roots) \\<rightarrow> X", "unfolding f'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>g. f (restrict (\\<pi> \\<circ> g) X))\n    \\<in> (X \\<rightarrow>\\<^sub>E Roots) \\<rightarrow> X", "using f' bij_betw_apply[OF bij_betw_compose_left_perm_PiE[OF \\<pi>, of X]]"], ["proof (prove)\nusing this:\n  f \\<in> (X \\<rightarrow>\\<^sub>E Roots) \\<rightarrow>\\<^sub>E X\n  ?a \\<in> X \\<rightarrow>\\<^sub>E Roots \\<Longrightarrow>\n  restrict (\\<pi> \\<circ> ?a) X \\<in> X \\<rightarrow>\\<^sub>E Roots\n\ngoal (1 subgoal):\n 1. (\\<lambda>g. f (restrict (\\<pi> \\<circ> g) X))\n    \\<in> (X \\<rightarrow>\\<^sub>E Roots) \\<rightarrow> X", "by blast"], ["proof (state)\nthis:\n  f' \\<in> (X \\<rightarrow>\\<^sub>E Roots) \\<rightarrow> X\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> tuples Y \\<Longrightarrow>\n       (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n           x (restrict (\\<pi> \\<circ> g) X))\n       \\<in> tuples Y", "hence \"restrict f' (X \\<rightarrow>\\<^sub>E Roots) \\<in> (X \\<rightarrow>\\<^sub>E Roots) \\<rightarrow>\\<^sub>E X\""], ["proof (prove)\nusing this:\n  f' \\<in> (X \\<rightarrow>\\<^sub>E Roots) \\<rightarrow> X\n\ngoal (1 subgoal):\n 1. restrict f' (X \\<rightarrow>\\<^sub>E Roots)\n    \\<in> (X \\<rightarrow>\\<^sub>E Roots) \\<rightarrow>\\<^sub>E X", "by simp"], ["proof (state)\nthis:\n  restrict f' (X \\<rightarrow>\\<^sub>E Roots)\n  \\<in> (X \\<rightarrow>\\<^sub>E Roots) \\<rightarrow>\\<^sub>E X\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> tuples Y \\<Longrightarrow>\n       (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n           x (restrict (\\<pi> \\<circ> g) X))\n       \\<in> tuples Y", "moreover"], ["proof (state)\nthis:\n  restrict f' (X \\<rightarrow>\\<^sub>E Roots)\n  \\<in> (X \\<rightarrow>\\<^sub>E Roots) \\<rightarrow>\\<^sub>E X\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> tuples Y \\<Longrightarrow>\n       (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n           x (restrict (\\<pi> \\<circ> g) X))\n       \\<in> tuples Y", "have \"image_mset (restrict f' (X \\<rightarrow>\\<^sub>E Roots)) (mset_set (X \\<rightarrow>\\<^sub>E Roots)) = Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. image_mset (restrict f' (X \\<rightarrow>\\<^sub>E Roots))\n     (mset_set (X \\<rightarrow>\\<^sub>E Roots)) =\n    Y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. image_mset (restrict f' (X \\<rightarrow>\\<^sub>E Roots))\n     (mset_set (X \\<rightarrow>\\<^sub>E Roots)) =\n    Y", "have \"image_mset (restrict f' (X \\<rightarrow>\\<^sub>E Roots)) (mset_set (X \\<rightarrow>\\<^sub>E Roots)) =\n              image_mset f' (mset_set (X \\<rightarrow>\\<^sub>E Roots))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. image_mset (restrict f' (X \\<rightarrow>\\<^sub>E Roots))\n     (mset_set (X \\<rightarrow>\\<^sub>E Roots)) =\n    image_mset f' (mset_set (X \\<rightarrow>\\<^sub>E Roots))", "by (intro image_mset_cong) auto"], ["proof (state)\nthis:\n  image_mset (restrict f' (X \\<rightarrow>\\<^sub>E Roots))\n   (mset_set (X \\<rightarrow>\\<^sub>E Roots)) =\n  image_mset f' (mset_set (X \\<rightarrow>\\<^sub>E Roots))\n\ngoal (1 subgoal):\n 1. image_mset (restrict f' (X \\<rightarrow>\\<^sub>E Roots))\n     (mset_set (X \\<rightarrow>\\<^sub>E Roots)) =\n    Y", "also"], ["proof (state)\nthis:\n  image_mset (restrict f' (X \\<rightarrow>\\<^sub>E Roots))\n   (mset_set (X \\<rightarrow>\\<^sub>E Roots)) =\n  image_mset f' (mset_set (X \\<rightarrow>\\<^sub>E Roots))\n\ngoal (1 subgoal):\n 1. image_mset (restrict f' (X \\<rightarrow>\\<^sub>E Roots))\n     (mset_set (X \\<rightarrow>\\<^sub>E Roots)) =\n    Y", "have \"\\<dots> = image_mset f (image_mset (\\<lambda>g. restrict (\\<pi> \\<circ> g) X) (mset_set (X \\<rightarrow>\\<^sub>E Roots)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. image_mset f' (mset_set (X \\<rightarrow>\\<^sub>E Roots)) =\n    image_mset f\n     {#restrict (\\<pi> \\<circ> g) X\n     . g \\<in># mset_set (X \\<rightarrow>\\<^sub>E Roots)#}", "unfolding f'_def o_def multiset.map_comp"], ["proof (prove)\ngoal (1 subgoal):\n 1. {#f (\\<lambda>x\\<in>X. \\<pi> (g x))\n    . g \\<in># mset_set (X \\<rightarrow>\\<^sub>E Roots)#} =\n    {#f (\\<lambda>xa\\<in>X. \\<pi> (x xa))\n    . x \\<in># mset_set (X \\<rightarrow>\\<^sub>E Roots)#}", "by (simp add: o_def)"], ["proof (state)\nthis:\n  image_mset f' (mset_set (X \\<rightarrow>\\<^sub>E Roots)) =\n  image_mset f\n   {#restrict (\\<pi> \\<circ> g) X\n   . g \\<in># mset_set (X \\<rightarrow>\\<^sub>E Roots)#}\n\ngoal (1 subgoal):\n 1. image_mset (restrict f' (X \\<rightarrow>\\<^sub>E Roots))\n     (mset_set (X \\<rightarrow>\\<^sub>E Roots)) =\n    Y", "also"], ["proof (state)\nthis:\n  image_mset f' (mset_set (X \\<rightarrow>\\<^sub>E Roots)) =\n  image_mset f\n   {#restrict (\\<pi> \\<circ> g) X\n   . g \\<in># mset_set (X \\<rightarrow>\\<^sub>E Roots)#}\n\ngoal (1 subgoal):\n 1. image_mset (restrict f' (X \\<rightarrow>\\<^sub>E Roots))\n     (mset_set (X \\<rightarrow>\\<^sub>E Roots)) =\n    Y", "have \"image_mset (\\<lambda>g. restrict (\\<pi> \\<circ> g) X) (mset_set (X \\<rightarrow>\\<^sub>E Roots)) =\n                   mset_set (X \\<rightarrow>\\<^sub>E Roots)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#restrict (\\<pi> \\<circ> g) X\n    . g \\<in># mset_set (X \\<rightarrow>\\<^sub>E Roots)#} =\n    mset_set (X \\<rightarrow>\\<^sub>E Roots)", "by (intro bij_betw_image_mset_set bij_betw_compose_left_perm_PiE \\<pi>)"], ["proof (state)\nthis:\n  {#restrict (\\<pi> \\<circ> g) X\n  . g \\<in># mset_set (X \\<rightarrow>\\<^sub>E Roots)#} =\n  mset_set (X \\<rightarrow>\\<^sub>E Roots)\n\ngoal (1 subgoal):\n 1. image_mset (restrict f' (X \\<rightarrow>\\<^sub>E Roots))\n     (mset_set (X \\<rightarrow>\\<^sub>E Roots)) =\n    Y", "also"], ["proof (state)\nthis:\n  {#restrict (\\<pi> \\<circ> g) X\n  . g \\<in># mset_set (X \\<rightarrow>\\<^sub>E Roots)#} =\n  mset_set (X \\<rightarrow>\\<^sub>E Roots)\n\ngoal (1 subgoal):\n 1. image_mset (restrict f' (X \\<rightarrow>\\<^sub>E Roots))\n     (mset_set (X \\<rightarrow>\\<^sub>E Roots)) =\n    Y", "have \"image_mset f \\<dots> = Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. image_mset f (mset_set (X \\<rightarrow>\\<^sub>E Roots)) = Y", "using f"], ["proof (prove)\nusing this:\n  f \\<in> tuples Y\n\ngoal (1 subgoal):\n 1. image_mset f (mset_set (X \\<rightarrow>\\<^sub>E Roots)) = Y", "by (simp add: tuples_def)"], ["proof (state)\nthis:\n  image_mset f (mset_set (X \\<rightarrow>\\<^sub>E Roots)) = Y\n\ngoal (1 subgoal):\n 1. image_mset (restrict f' (X \\<rightarrow>\\<^sub>E Roots))\n     (mset_set (X \\<rightarrow>\\<^sub>E Roots)) =\n    Y", "finally"], ["proof (chain)\npicking this:\n  image_mset (restrict f' (X \\<rightarrow>\\<^sub>E Roots))\n   (mset_set (X \\<rightarrow>\\<^sub>E Roots)) =\n  Y", "show ?thesis"], ["proof (prove)\nusing this:\n  image_mset (restrict f' (X \\<rightarrow>\\<^sub>E Roots))\n   (mset_set (X \\<rightarrow>\\<^sub>E Roots)) =\n  Y\n\ngoal (1 subgoal):\n 1. image_mset (restrict f' (X \\<rightarrow>\\<^sub>E Roots))\n     (mset_set (X \\<rightarrow>\\<^sub>E Roots)) =\n    Y", "."], ["proof (state)\nthis:\n  image_mset (restrict f' (X \\<rightarrow>\\<^sub>E Roots))\n   (mset_set (X \\<rightarrow>\\<^sub>E Roots)) =\n  Y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  image_mset (restrict f' (X \\<rightarrow>\\<^sub>E Roots))\n   (mset_set (X \\<rightarrow>\\<^sub>E Roots)) =\n  Y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> tuples Y \\<Longrightarrow>\n       (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n           x (restrict (\\<pi> \\<circ> g) X))\n       \\<in> tuples Y", "ultimately"], ["proof (chain)\npicking this:\n  restrict f' (X \\<rightarrow>\\<^sub>E Roots)\n  \\<in> (X \\<rightarrow>\\<^sub>E Roots) \\<rightarrow>\\<^sub>E X\n  image_mset (restrict f' (X \\<rightarrow>\\<^sub>E Roots))\n   (mset_set (X \\<rightarrow>\\<^sub>E Roots)) =\n  Y", "show \"restrict f' (X \\<rightarrow>\\<^sub>E Roots) \\<in> tuples Y\""], ["proof (prove)\nusing this:\n  restrict f' (X \\<rightarrow>\\<^sub>E Roots)\n  \\<in> (X \\<rightarrow>\\<^sub>E Roots) \\<rightarrow>\\<^sub>E X\n  image_mset (restrict f' (X \\<rightarrow>\\<^sub>E Roots))\n   (mset_set (X \\<rightarrow>\\<^sub>E Roots)) =\n  Y\n\ngoal (1 subgoal):\n 1. restrict f' (X \\<rightarrow>\\<^sub>E Roots) \\<in> tuples Y", "by (auto simp: tuples_def)"], ["proof (state)\nthis:\n  restrict f' (X \\<rightarrow>\\<^sub>E Roots) \\<in> tuples Y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?\\<pi> permutes Roots \\<Longrightarrow>\n  (\\<lambda>f.\n      \\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n         f (restrict (?\\<pi> \\<circ> g) X))\n  \\<in> tuples Y \\<rightarrow> tuples Y\n\ngoal (4 subgoals):\n 1. (\\<lambda>f.\n        \\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n           f (restrict (\\<pi> \\<circ> g) X))\n    \\<in> tuples Y \\<rightarrow> tuples Y\n 2. ?g \\<in> tuples Y \\<rightarrow> tuples Y\n 3. \\<And>x.\n       x \\<in> tuples Y \\<Longrightarrow>\n       ?g (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n              x (restrict (\\<pi> \\<circ> g) X)) =\n       x\n 4. \\<And>y.\n       y \\<in> tuples Y \\<Longrightarrow>\n       (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n           ?g y (restrict (\\<pi> \\<circ> g) X)) =\n       y", "show \"(\\<lambda>f. restrict (\\<lambda>g. f (restrict (\\<pi> \\<circ> g) X)) (X \\<rightarrow>\\<^sub>E Roots)) \\<in> tuples Y \\<rightarrow> tuples Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f.\n        \\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n           f (restrict (\\<pi> \\<circ> g) X))\n    \\<in> tuples Y \\<rightarrow> tuples Y", "by (intro * \\<pi>)"], ["proof (state)\nthis:\n  (\\<lambda>f.\n      \\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n         f (restrict (\\<pi> \\<circ> g) X))\n  \\<in> tuples Y \\<rightarrow> tuples Y\n\ngoal (3 subgoals):\n 1. ?g \\<in> tuples Y \\<rightarrow> tuples Y\n 2. \\<And>x.\n       x \\<in> tuples Y \\<Longrightarrow>\n       ?g (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n              x (restrict (\\<pi> \\<circ> g) X)) =\n       x\n 3. \\<And>y.\n       y \\<in> tuples Y \\<Longrightarrow>\n       (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n           ?g y (restrict (\\<pi> \\<circ> g) X)) =\n       y", "show \"(\\<lambda>f. restrict (\\<lambda>g. f (restrict (inv_into UNIV \\<pi> \\<circ> g) X)) (X \\<rightarrow>\\<^sub>E Roots)) \\<in> tuples Y \\<rightarrow> tuples Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f.\n        \\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n           f (restrict (inv \\<pi> \\<circ> g) X))\n    \\<in> tuples Y \\<rightarrow> tuples Y", "by (intro * permutes_inv \\<pi>)"], ["proof (state)\nthis:\n  (\\<lambda>f.\n      \\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n         f (restrict (inv \\<pi> \\<circ> g) X))\n  \\<in> tuples Y \\<rightarrow> tuples Y\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> tuples Y \\<Longrightarrow>\n       (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n           (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n               x (restrict (\\<pi> \\<circ> g) X))\n            (restrict (inv \\<pi> \\<circ> g) X)) =\n       x\n 2. \\<And>y.\n       y \\<in> tuples Y \\<Longrightarrow>\n       (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n           (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n               y (restrict (inv \\<pi> \\<circ> g) X))\n            (restrict (\\<pi> \\<circ> g) X)) =\n       y", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> tuples Y \\<Longrightarrow>\n       (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n           (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n               x (restrict (\\<pi> \\<circ> g) X))\n            (restrict (inv \\<pi> \\<circ> g) X)) =\n       x\n 2. \\<And>y.\n       y \\<in> tuples Y \\<Longrightarrow>\n       (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n           (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n               y (restrict (inv \\<pi> \\<circ> g) X))\n            (restrict (\\<pi> \\<circ> g) X)) =\n       y", "have *: \"(\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots. (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots. f (restrict (\\<pi> \\<circ> g) X))\n                (restrict (inv_into UNIV \\<pi> \\<circ> g) X)) = f\" (is \"?lhs = _\")\n      if f: \"f \\<in> tuples Y\" and \\<pi>: \"\\<pi> permutes Roots\" for f \\<pi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n        (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n            f (restrict (\\<pi> \\<circ> g) X))\n         (restrict (inv \\<pi> \\<circ> g) X)) =\n    f", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n           (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n               f (restrict (\\<pi> \\<circ> g) X))\n            (restrict (inv \\<pi> \\<circ> g) X))\n        x =\n       f x", "fix g"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n           (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n               f (restrict (\\<pi> \\<circ> g) X))\n            (restrict (inv \\<pi> \\<circ> g) X))\n        x =\n       f x", "show \"?lhs g = f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n        (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n            f (restrict (\\<pi> \\<circ> g) X))\n         (restrict (inv \\<pi> \\<circ> g) X))\n     g =\n    f g", "proof (cases \"g \\<in> X \\<rightarrow>\\<^sub>E Roots\")"], ["proof (state)\ngoal (2 subgoals):\n 1. g \\<in> X \\<rightarrow>\\<^sub>E Roots \\<Longrightarrow>\n    (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n        (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n            f (restrict (\\<pi> \\<circ> g) X))\n         (restrict (inv \\<pi> \\<circ> g) X))\n     g =\n    f g\n 2. g \\<notin> X \\<rightarrow>\\<^sub>E Roots \\<Longrightarrow>\n    (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n        (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n            f (restrict (\\<pi> \\<circ> g) X))\n         (restrict (inv \\<pi> \\<circ> g) X))\n     g =\n    f g", "case True"], ["proof (state)\nthis:\n  g \\<in> X \\<rightarrow>\\<^sub>E Roots\n\ngoal (2 subgoals):\n 1. g \\<in> X \\<rightarrow>\\<^sub>E Roots \\<Longrightarrow>\n    (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n        (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n            f (restrict (\\<pi> \\<circ> g) X))\n         (restrict (inv \\<pi> \\<circ> g) X))\n     g =\n    f g\n 2. g \\<notin> X \\<rightarrow>\\<^sub>E Roots \\<Longrightarrow>\n    (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n        (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n            f (restrict (\\<pi> \\<circ> g) X))\n         (restrict (inv \\<pi> \\<circ> g) X))\n     g =\n    f g", "have \"restrict (\\<pi> \\<circ> restrict (inv_into UNIV \\<pi> \\<circ> g) X) X = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict (\\<pi> \\<circ> restrict (inv \\<pi> \\<circ> g) X) X = g", "using True"], ["proof (prove)\nusing this:\n  g \\<in> X \\<rightarrow>\\<^sub>E Roots\n\ngoal (1 subgoal):\n 1. restrict (\\<pi> \\<circ> restrict (inv \\<pi> \\<circ> g) X) X = g", "by (intro ext) (auto simp: permutes_inverses[OF \\<pi>])"], ["proof (state)\nthis:\n  restrict (\\<pi> \\<circ> restrict (inv \\<pi> \\<circ> g) X) X = g\n\ngoal (2 subgoals):\n 1. g \\<in> X \\<rightarrow>\\<^sub>E Roots \\<Longrightarrow>\n    (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n        (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n            f (restrict (\\<pi> \\<circ> g) X))\n         (restrict (inv \\<pi> \\<circ> g) X))\n     g =\n    f g\n 2. g \\<notin> X \\<rightarrow>\\<^sub>E Roots \\<Longrightarrow>\n    (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n        (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n            f (restrict (\\<pi> \\<circ> g) X))\n         (restrict (inv \\<pi> \\<circ> g) X))\n     g =\n    f g", "thus ?thesis"], ["proof (prove)\nusing this:\n  restrict (\\<pi> \\<circ> restrict (inv \\<pi> \\<circ> g) X) X = g\n\ngoal (1 subgoal):\n 1. (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n        (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n            f (restrict (\\<pi> \\<circ> g) X))\n         (restrict (inv \\<pi> \\<circ> g) X))\n     g =\n    f g", "using True"], ["proof (prove)\nusing this:\n  restrict (\\<pi> \\<circ> restrict (inv \\<pi> \\<circ> g) X) X = g\n  g \\<in> X \\<rightarrow>\\<^sub>E Roots\n\ngoal (1 subgoal):\n 1. (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n        (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n            f (restrict (\\<pi> \\<circ> g) X))\n         (restrict (inv \\<pi> \\<circ> g) X))\n     g =\n    f g", "by (auto simp: permutes_in_image[OF permutes_inv[OF \\<pi>]])"], ["proof (state)\nthis:\n  (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n      (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n          f (restrict (\\<pi> \\<circ> g) X))\n       (restrict (inv \\<pi> \\<circ> g) X))\n   g =\n  f g\n\ngoal (1 subgoal):\n 1. g \\<notin> X \\<rightarrow>\\<^sub>E Roots \\<Longrightarrow>\n    (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n        (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n            f (restrict (\\<pi> \\<circ> g) X))\n         (restrict (inv \\<pi> \\<circ> g) X))\n     g =\n    f g", "qed (use f in \\<open>auto simp: tuples_def\\<close>)"], ["proof (state)\nthis:\n  (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n      (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n          f (restrict (\\<pi> \\<circ> g) X))\n       (restrict (inv \\<pi> \\<circ> g) X))\n   g =\n  f g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?f \\<in> tuples Y; ?\\<pi> permutes Roots\\<rbrakk>\n  \\<Longrightarrow> (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n                        (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n                            ?f (restrict (?\\<pi> \\<circ> g) X))\n                         (restrict (inv ?\\<pi> \\<circ> g) X)) =\n                    ?f\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> tuples Y \\<Longrightarrow>\n       (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n           (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n               x (restrict (\\<pi> \\<circ> g) X))\n            (restrict (inv \\<pi> \\<circ> g) X)) =\n       x\n 2. \\<And>y.\n       y \\<in> tuples Y \\<Longrightarrow>\n       (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n           (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n               y (restrict (inv \\<pi> \\<circ> g) X))\n            (restrict (\\<pi> \\<circ> g) X)) =\n       y", "show \"(\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots. (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots. f (restrict (\\<pi> \\<circ> g) X))\n                (restrict (inv_into UNIV \\<pi> \\<circ> g) X)) = f\" if \"f \\<in> tuples Y\" for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n        (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n            f (restrict (\\<pi> \\<circ> g) X))\n         (restrict (inv \\<pi> \\<circ> g) X)) =\n    f", "using *[OF that \\<pi>]"], ["proof (prove)\nusing this:\n  (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n      (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n          f (restrict (\\<pi> \\<circ> g) X))\n       (restrict (inv \\<pi> \\<circ> g) X)) =\n  f\n\ngoal (1 subgoal):\n 1. (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n        (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n            f (restrict (\\<pi> \\<circ> g) X))\n         (restrict (inv \\<pi> \\<circ> g) X)) =\n    f", "."], ["proof (state)\nthis:\n  ?f \\<in> tuples Y \\<Longrightarrow>\n  (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n      (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n          ?f (restrict (\\<pi> \\<circ> g) X))\n       (restrict (inv \\<pi> \\<circ> g) X)) =\n  ?f\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> tuples Y \\<Longrightarrow>\n       (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n           (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n               y (restrict (inv \\<pi> \\<circ> g) X))\n            (restrict (\\<pi> \\<circ> g) X)) =\n       y", "show \"(\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots. (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots. f (restrict (inv_into UNIV \\<pi> \\<circ> g) X))\n                (restrict (\\<pi> \\<circ> g) X)) = f\" if \"f \\<in> tuples Y\" for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n        (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n            f (restrict (inv \\<pi> \\<circ> g) X))\n         (restrict (\\<pi> \\<circ> g) X)) =\n    f", "using *[OF that permutes_inv[OF \\<pi>]] permutes_inv_inv[OF \\<pi>]"], ["proof (prove)\nusing this:\n  (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n      (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n          f (restrict (inv \\<pi> \\<circ> g) X))\n       (restrict (inv (inv \\<pi>) \\<circ> g) X)) =\n  f\n  inv (inv \\<pi>) = \\<pi>\n\ngoal (1 subgoal):\n 1. (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n        (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n            f (restrict (inv \\<pi> \\<circ> g) X))\n         (restrict (\\<pi> \\<circ> g) X)) =\n    f", "by simp"], ["proof (state)\nthis:\n  ?f \\<in> tuples Y \\<Longrightarrow>\n  (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n      (\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n          ?f (restrict (inv \\<pi> \\<circ> g) X))\n       (restrict (\\<pi> \\<circ> g) X)) =\n  ?f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?\\<pi> permutes Roots; ?Y \\<in> Roots_ms\\<rbrakk>\n  \\<Longrightarrow> bij_betw\n                     (\\<lambda>f.\n                         \\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n                            f (restrict (?\\<pi> \\<circ> g) X))\n                     (tuples ?Y) (tuples ?Y)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "text \\<open>\n    We show that the coefficients in the expanded new sum are rational -- again using the \n    fundamental theorem of symmetric polynomials.\n  \\<close>"], ["proof (state)\nthis:\n  \\<lbrakk>?\\<pi> permutes Roots; ?Y \\<in> Roots_ms\\<rbrakk>\n  \\<Longrightarrow> bij_betw\n                     (\\<lambda>f.\n                         \\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n                            f (restrict (?\\<pi> \\<circ> g) X))\n                     (tuples ?Y) (tuples ?Y)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "define \\<beta>' :: \"complex multiset \\<Rightarrow> complex\"\n    where \"\\<beta>' = (\\<lambda>Y. \\<Sum>f\\<in>tuples Y. \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g (f g))\""], ["proof (state)\nthis:\n  \\<beta>' =\n  (\\<lambda>Y.\n      \\<Sum>f\\<in>tuples Y.\n        \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g (f g))\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have \"\\<beta>' Y \\<in> \\<rat>\" if Y: \"Y \\<in> Roots_ms\" for Y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta>' Y \\<in> \\<rat>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<beta>' Y \\<in> \\<rat>", "define Q :: \"complex mpoly\"\n      where \"Q = (\\<Sum>f\\<in>tuples Y. \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. Var (unRoot (g (f g))))\""], ["proof (state)\nthis:\n  Q =\n  (\\<Sum>f\\<in>tuples Y.\n     \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. Var (unRoot (g (f g))))\n\ngoal (1 subgoal):\n 1. \\<beta>' Y \\<in> \\<rat>", "have \"insertion Root Q \\<in> \\<rat>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion Root Q \\<in> \\<rat>", "proof (rule symmetric_poly_of_roots_in_subring)"], ["proof (state)\ngoal (10 subgoals):\n 1. ring_closed \\<rat>\n 2. \\<forall>m. MPoly_Type.coeff Q m \\<in> \\<rat>\n 3. ring_homomorphism (\\<lambda>a. a)\n 4. finite ?A\n 5. symmetric_mpoly ?A Q\n 6. vars Q \\<subseteq> ?A\n 7. ?cinv * ?c = 1\n 8. ?cinv \\<in> \\<rat>\n 9. ?p = Polynomial.smult ?c (\\<Prod>i\\<in>?A. [:- Root i, 1:])\n 10. \\<forall>i. poly.coeff ?p i \\<in> \\<rat>", "show \"ring_closed (\\<rat> :: complex set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ring_closed \\<rat>", "by standard auto"], ["proof (state)\nthis:\n  ring_closed \\<rat>\n\ngoal (9 subgoals):\n 1. \\<forall>m. MPoly_Type.coeff Q m \\<in> \\<rat>\n 2. ring_homomorphism (\\<lambda>a. a)\n 3. finite ?A\n 4. symmetric_mpoly ?A Q\n 5. vars Q \\<subseteq> ?A\n 6. ?cinv * ?c = 1\n 7. ?cinv \\<in> \\<rat>\n 8. ?p = Polynomial.smult ?c (\\<Prod>i\\<in>?A. [:- Root i, 1:])\n 9. \\<forall>i. poly.coeff ?p i \\<in> \\<rat>", "then"], ["proof (chain)\npicking this:\n  ring_closed \\<rat>", "interpret ring_closed \"\\<rat> :: complex set\""], ["proof (prove)\nusing this:\n  ring_closed \\<rat>\n\ngoal (1 subgoal):\n 1. ring_closed \\<rat>", "."], ["proof (state)\ngoal (9 subgoals):\n 1. \\<forall>m. MPoly_Type.coeff Q m \\<in> \\<rat>\n 2. ring_homomorphism (\\<lambda>a. a)\n 3. finite ?A\n 4. symmetric_mpoly ?A Q\n 5. vars Q \\<subseteq> ?A\n 6. ?cinv * ?c = 1\n 7. ?cinv \\<in> \\<rat>\n 8. ?p = Polynomial.smult ?c (\\<Prod>i\\<in>?A. [:- Root i, 1:])\n 9. \\<forall>i. poly.coeff ?p i \\<in> \\<rat>", "show \"\\<forall>m. coeff Q m \\<in> \\<rat>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>m. MPoly_Type.coeff Q m \\<in> \\<rat>", "by (auto simp: Q_def coeff_Var when_def intro!: sum_in_Rats coeff_prod_closed)"], ["proof (state)\nthis:\n  \\<forall>m. MPoly_Type.coeff Q m \\<in> \\<rat>\n\ngoal (8 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite ?A\n 3. symmetric_mpoly ?A Q\n 4. vars Q \\<subseteq> ?A\n 5. ?cinv * ?c = 1\n 6. ?cinv \\<in> \\<rat>\n 7. ?p = Polynomial.smult ?c (\\<Prod>i\\<in>?A. [:- Root i, 1:])\n 8. \\<forall>i. poly.coeff ?p i \\<in> \\<rat>", "next"], ["proof (state)\ngoal (8 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite ?A\n 3. symmetric_mpoly ?A Q\n 4. vars Q \\<subseteq> ?A\n 5. ?cinv * ?c = 1\n 6. ?cinv \\<in> \\<rat>\n 7. ?p = Polynomial.smult ?c (\\<Prod>i\\<in>?A. [:- Root i, 1:])\n 8. \\<forall>i. poly.coeff ?p i \\<in> \\<rat>", "show \"symmetric_mpoly {..<n} Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric_mpoly {..<n} Q", "unfolding symmetric_mpoly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<pi>.\n       \\<pi> permutes {..<n} \\<longrightarrow> mpoly_map_vars \\<pi> Q = Q", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes {..<n} \\<Longrightarrow> mpoly_map_vars \\<pi> Q = Q", "fix \\<pi>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes {..<n} \\<Longrightarrow> mpoly_map_vars \\<pi> Q = Q", "assume \\<pi>: \"\\<pi> permutes {..<n}\""], ["proof (state)\nthis:\n  \\<pi> permutes {..<n}\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes {..<n} \\<Longrightarrow> mpoly_map_vars \\<pi> Q = Q", "define \\<pi>' where \"\\<pi>' = convert_perm (inv_into UNIV \\<pi>)\""], ["proof (state)\nthis:\n  \\<pi>' = convert_perm (inv \\<pi>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes {..<n} \\<Longrightarrow> mpoly_map_vars \\<pi> Q = Q", "have \\<pi>': \"\\<pi>' permutes Roots\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>' permutes Roots", "unfolding \\<pi>'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. convert_perm (inv \\<pi>) permutes Roots", "by (intro permutes_convert_perm permutes_inv \\<pi>)"], ["proof (state)\nthis:\n  \\<pi>' permutes Roots\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes {..<n} \\<Longrightarrow> mpoly_map_vars \\<pi> Q = Q", "have \"mpoly_map_vars \\<pi> Q = (\\<Sum>f\\<in>tuples Y. \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. Var (\\<pi> (unRoot (g (f g)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_map_vars \\<pi> Q =\n    (\\<Sum>f\\<in>tuples Y.\n       \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n         Var (\\<pi> (unRoot (g (f g)))))", "unfolding Q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_map_vars \\<pi>\n     (\\<Sum>f\\<in>tuples Y.\n        \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n          Var (unRoot (g (f g)))) =\n    (\\<Sum>f\\<in>tuples Y.\n       \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n         Var (\\<pi> (unRoot (g (f g)))))", "by (simp add: permutes_bij[OF \\<pi>])"], ["proof (state)\nthis:\n  mpoly_map_vars \\<pi> Q =\n  (\\<Sum>f\\<in>tuples Y.\n     \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n       Var (\\<pi> (unRoot (g (f g)))))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes {..<n} \\<Longrightarrow> mpoly_map_vars \\<pi> Q = Q", "also"], ["proof (state)\nthis:\n  mpoly_map_vars \\<pi> Q =\n  (\\<Sum>f\\<in>tuples Y.\n     \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n       Var (\\<pi> (unRoot (g (f g)))))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes {..<n} \\<Longrightarrow> mpoly_map_vars \\<pi> Q = Q", "have \"\\<dots> = (\\<Sum>f\\<in>tuples Y. \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. Var (unRoot (g (f (restrict (\\<pi>' \\<circ> g) X)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>f\\<in>tuples Y.\n       \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n         Var (\\<pi> (unRoot (g (f g))))) =\n    (\\<Sum>f\\<in>tuples Y.\n       \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n         Var (unRoot (g (f (restrict (\\<pi>' \\<circ> g) X)))))", "proof (rule sum.cong, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. tuples Y = tuples Y\n 2. \\<And>x.\n       x \\<in> tuples Y \\<Longrightarrow>\n       (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n          Var (\\<pi> (unRoot (g (x g))))) =\n       (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n          Var (unRoot (g (x (restrict (\\<pi>' \\<circ> g) X)))))", "case (2 f)"], ["proof (state)\nthis:\n  f \\<in> tuples Y\n\ngoal (2 subgoals):\n 1. tuples Y = tuples Y\n 2. \\<And>x.\n       x \\<in> tuples Y \\<Longrightarrow>\n       (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n          Var (\\<pi> (unRoot (g (x g))))) =\n       (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n          Var (unRoot (g (x (restrict (\\<pi>' \\<circ> g) X)))))", "have f: \"f \\<in> (X \\<rightarrow>\\<^sub>E Roots) \\<rightarrow>\\<^sub>E X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> (X \\<rightarrow>\\<^sub>E Roots) \\<rightarrow>\\<^sub>E X", "using 2"], ["proof (prove)\nusing this:\n  f \\<in> tuples Y\n\ngoal (1 subgoal):\n 1. f \\<in> (X \\<rightarrow>\\<^sub>E Roots) \\<rightarrow>\\<^sub>E X", "by (auto simp: tuples_def)"], ["proof (state)\nthis:\n  f \\<in> (X \\<rightarrow>\\<^sub>E Roots) \\<rightarrow>\\<^sub>E X\n\ngoal (2 subgoals):\n 1. tuples Y = tuples Y\n 2. \\<And>x.\n       x \\<in> tuples Y \\<Longrightarrow>\n       (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n          Var (\\<pi> (unRoot (g (x g))))) =\n       (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n          Var (unRoot (g (x (restrict (\\<pi>' \\<circ> g) X)))))", "have \"(\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. Var (\\<pi> (unRoot (g (f g))))) =\n                (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. Var (\\<pi> (unRoot (restrict (\\<pi>' \\<circ> g) X (f (restrict (\\<pi>' \\<circ> g) X))))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n       Var (\\<pi> (unRoot (g (f g))))) =\n    (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n       Var (\\<pi>\n             (unRoot\n               (restrict (\\<pi>' \\<circ> g) X\n                 (f (restrict (\\<pi>' \\<circ> g) X))))))", "using \\<pi>'"], ["proof (prove)\nusing this:\n  \\<pi>' permutes Roots\n\ngoal (1 subgoal):\n 1. (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n       Var (\\<pi> (unRoot (g (f g))))) =\n    (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n       Var (\\<pi>\n             (unRoot\n               (restrict (\\<pi>' \\<circ> g) X\n                 (f (restrict (\\<pi>' \\<circ> g) X))))))", "by (intro prod.reindex_bij_betw [symmetric] bij_betw_compose_left_perm_PiE)"], ["proof (state)\nthis:\n  (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n     Var (\\<pi> (unRoot (g (f g))))) =\n  (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n     Var (\\<pi>\n           (unRoot\n             (restrict (\\<pi>' \\<circ> g) X\n               (f (restrict (\\<pi>' \\<circ> g) X))))))\n\ngoal (2 subgoals):\n 1. tuples Y = tuples Y\n 2. \\<And>x.\n       x \\<in> tuples Y \\<Longrightarrow>\n       (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n          Var (\\<pi> (unRoot (g (x g))))) =\n       (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n          Var (unRoot (g (x (restrict (\\<pi>' \\<circ> g) X)))))", "also"], ["proof (state)\nthis:\n  (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n     Var (\\<pi> (unRoot (g (f g))))) =\n  (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n     Var (\\<pi>\n           (unRoot\n             (restrict (\\<pi>' \\<circ> g) X\n               (f (restrict (\\<pi>' \\<circ> g) X))))))\n\ngoal (2 subgoals):\n 1. tuples Y = tuples Y\n 2. \\<And>x.\n       x \\<in> tuples Y \\<Longrightarrow>\n       (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n          Var (\\<pi> (unRoot (g (x g))))) =\n       (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n          Var (unRoot (g (x (restrict (\\<pi>' \\<circ> g) X)))))", "have \"\\<dots> = (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. Var (unRoot (g (f (restrict (\\<pi>' \\<circ> g) X)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n       Var (\\<pi>\n             (unRoot\n               (restrict (\\<pi>' \\<circ> g) X\n                 (f (restrict (\\<pi>' \\<circ> g) X)))))) =\n    (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n       Var (unRoot (g (f (restrict (\\<pi>' \\<circ> g) X)))))", "proof (intro prod.cong refl arg_cong[of _ _ Var])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<rightarrow>\\<^sub>E Roots \\<Longrightarrow>\n       \\<pi>\n        (unRoot\n          (restrict (\\<pi>' \\<circ> x) X\n            (f (restrict (\\<pi>' \\<circ> x) X)))) =\n       unRoot (x (f (restrict (\\<pi>' \\<circ> x) X)))", "fix g"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<rightarrow>\\<^sub>E Roots \\<Longrightarrow>\n       \\<pi>\n        (unRoot\n          (restrict (\\<pi>' \\<circ> x) X\n            (f (restrict (\\<pi>' \\<circ> x) X)))) =\n       unRoot (x (f (restrict (\\<pi>' \\<circ> x) X)))", "assume g: \"g \\<in> X \\<rightarrow>\\<^sub>E Roots\""], ["proof (state)\nthis:\n  g \\<in> X \\<rightarrow>\\<^sub>E Roots\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<rightarrow>\\<^sub>E Roots \\<Longrightarrow>\n       \\<pi>\n        (unRoot\n          (restrict (\\<pi>' \\<circ> x) X\n            (f (restrict (\\<pi>' \\<circ> x) X)))) =\n       unRoot (x (f (restrict (\\<pi>' \\<circ> x) X)))", "have \"restrict (\\<pi>' \\<circ> g) X \\<in> X \\<rightarrow>\\<^sub>E Roots\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict (\\<pi>' \\<circ> g) X \\<in> X \\<rightarrow>\\<^sub>E Roots", "using bij_betw_compose_left_perm_PiE[OF \\<pi>', of X] g"], ["proof (prove)\nusing this:\n  bij_betw (\\<lambda>f. restrict (\\<pi>' \\<circ> f) X)\n   (X \\<rightarrow>\\<^sub>E Roots) (X \\<rightarrow>\\<^sub>E Roots)\n  g \\<in> X \\<rightarrow>\\<^sub>E Roots\n\ngoal (1 subgoal):\n 1. restrict (\\<pi>' \\<circ> g) X \\<in> X \\<rightarrow>\\<^sub>E Roots", "unfolding bij_betw_def"], ["proof (prove)\nusing this:\n  inj_on (\\<lambda>f. restrict (\\<pi>' \\<circ> f) X)\n   (X \\<rightarrow>\\<^sub>E Roots) \\<and>\n  (\\<lambda>f. restrict (\\<pi>' \\<circ> f) X) `\n  (X \\<rightarrow>\\<^sub>E Roots) =\n  X \\<rightarrow>\\<^sub>E Roots\n  g \\<in> X \\<rightarrow>\\<^sub>E Roots\n\ngoal (1 subgoal):\n 1. restrict (\\<pi>' \\<circ> g) X \\<in> X \\<rightarrow>\\<^sub>E Roots", "by blast"], ["proof (state)\nthis:\n  restrict (\\<pi>' \\<circ> g) X \\<in> X \\<rightarrow>\\<^sub>E Roots\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<rightarrow>\\<^sub>E Roots \\<Longrightarrow>\n       \\<pi>\n        (unRoot\n          (restrict (\\<pi>' \\<circ> x) X\n            (f (restrict (\\<pi>' \\<circ> x) X)))) =\n       unRoot (x (f (restrict (\\<pi>' \\<circ> x) X)))", "hence *: \"f (restrict (\\<pi>' \\<circ> g) X) \\<in> X\""], ["proof (prove)\nusing this:\n  restrict (\\<pi>' \\<circ> g) X \\<in> X \\<rightarrow>\\<^sub>E Roots\n\ngoal (1 subgoal):\n 1. f (restrict (\\<pi>' \\<circ> g) X) \\<in> X", "by (rule PiE_mem[OF f])"], ["proof (state)\nthis:\n  f (restrict (\\<pi>' \\<circ> g) X) \\<in> X\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<rightarrow>\\<^sub>E Roots \\<Longrightarrow>\n       \\<pi>\n        (unRoot\n          (restrict (\\<pi>' \\<circ> x) X\n            (f (restrict (\\<pi>' \\<circ> x) X)))) =\n       unRoot (x (f (restrict (\\<pi>' \\<circ> x) X)))", "hence **: \"g (f (restrict (\\<pi>' \\<circ> g) X)) \\<in> Roots\""], ["proof (prove)\nusing this:\n  f (restrict (\\<pi>' \\<circ> g) X) \\<in> X\n\ngoal (1 subgoal):\n 1. g (f (restrict (\\<pi>' \\<circ> g) X)) \\<in> Roots", "by (rule PiE_mem[OF g])"], ["proof (state)\nthis:\n  g (f (restrict (\\<pi>' \\<circ> g) X)) \\<in> Roots\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<rightarrow>\\<^sub>E Roots \\<Longrightarrow>\n       \\<pi>\n        (unRoot\n          (restrict (\\<pi>' \\<circ> x) X\n            (f (restrict (\\<pi>' \\<circ> x) X)))) =\n       unRoot (x (f (restrict (\\<pi>' \\<circ> x) X)))", "have \"unRoot (restrict (\\<pi>' \\<circ> g) X (f (restrict (\\<pi>' \\<circ> g) X))) =\n                   unRoot (Root (inv_into UNIV \\<pi> (unRoot (g (f (restrict (\\<pi>' \\<circ> g) X))))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unRoot\n     (restrict (\\<pi>' \\<circ> g) X (f (restrict (\\<pi>' \\<circ> g) X))) =\n    unRoot\n     (Root (inv \\<pi> (unRoot (g (f (restrict (\\<pi>' \\<circ> g) X))))))", "using * **"], ["proof (prove)\nusing this:\n  f (restrict (\\<pi>' \\<circ> g) X) \\<in> X\n  g (f (restrict (\\<pi>' \\<circ> g) X)) \\<in> Roots\n\ngoal (1 subgoal):\n 1. unRoot\n     (restrict (\\<pi>' \\<circ> g) X (f (restrict (\\<pi>' \\<circ> g) X))) =\n    unRoot\n     (Root (inv \\<pi> (unRoot (g (f (restrict (\\<pi>' \\<circ> g) X))))))", "by (subst \\<pi>'_def) (auto simp: convert_perm_def)"], ["proof (state)\nthis:\n  unRoot\n   (restrict (\\<pi>' \\<circ> g) X (f (restrict (\\<pi>' \\<circ> g) X))) =\n  unRoot (Root (inv \\<pi> (unRoot (g (f (restrict (\\<pi>' \\<circ> g) X))))))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<rightarrow>\\<^sub>E Roots \\<Longrightarrow>\n       \\<pi>\n        (unRoot\n          (restrict (\\<pi>' \\<circ> x) X\n            (f (restrict (\\<pi>' \\<circ> x) X)))) =\n       unRoot (x (f (restrict (\\<pi>' \\<circ> x) X)))", "also"], ["proof (state)\nthis:\n  unRoot\n   (restrict (\\<pi>' \\<circ> g) X (f (restrict (\\<pi>' \\<circ> g) X))) =\n  unRoot (Root (inv \\<pi> (unRoot (g (f (restrict (\\<pi>' \\<circ> g) X))))))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<rightarrow>\\<^sub>E Roots \\<Longrightarrow>\n       \\<pi>\n        (unRoot\n          (restrict (\\<pi>' \\<circ> x) X\n            (f (restrict (\\<pi>' \\<circ> x) X)))) =\n       unRoot (x (f (restrict (\\<pi>' \\<circ> x) X)))", "have \"inv_into UNIV \\<pi> (unRoot (g (f (restrict (\\<pi>' \\<circ> g) X)))) \\<in> {..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv \\<pi> (unRoot (g (f (restrict (\\<pi>' \\<circ> g) X)))) \\<in> {..<n}", "using **"], ["proof (prove)\nusing this:\n  g (f (restrict (\\<pi>' \\<circ> g) X)) \\<in> Roots\n\ngoal (1 subgoal):\n 1. inv \\<pi> (unRoot (g (f (restrict (\\<pi>' \\<circ> g) X)))) \\<in> {..<n}", "by (subst permutes_in_image[OF permutes_inv[OF \\<pi>]]) auto"], ["proof (state)\nthis:\n  inv \\<pi> (unRoot (g (f (restrict (\\<pi>' \\<circ> g) X)))) \\<in> {..<n}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<rightarrow>\\<^sub>E Roots \\<Longrightarrow>\n       \\<pi>\n        (unRoot\n          (restrict (\\<pi>' \\<circ> x) X\n            (f (restrict (\\<pi>' \\<circ> x) X)))) =\n       unRoot (x (f (restrict (\\<pi>' \\<circ> x) X)))", "hence \"unRoot (Root (inv_into UNIV \\<pi> (unRoot (g (f (restrict (\\<pi>' \\<circ> g) X)))))) =\n                   inv_into UNIV \\<pi> (unRoot (g (f (restrict (\\<pi>' \\<circ> g) X))))\""], ["proof (prove)\nusing this:\n  inv \\<pi> (unRoot (g (f (restrict (\\<pi>' \\<circ> g) X)))) \\<in> {..<n}\n\ngoal (1 subgoal):\n 1. unRoot\n     (Root (inv \\<pi> (unRoot (g (f (restrict (\\<pi>' \\<circ> g) X)))))) =\n    inv \\<pi> (unRoot (g (f (restrict (\\<pi>' \\<circ> g) X))))", "by (intro unRoot_Root) auto"], ["proof (state)\nthis:\n  unRoot\n   (Root (inv \\<pi> (unRoot (g (f (restrict (\\<pi>' \\<circ> g) X)))))) =\n  inv \\<pi> (unRoot (g (f (restrict (\\<pi>' \\<circ> g) X))))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<rightarrow>\\<^sub>E Roots \\<Longrightarrow>\n       \\<pi>\n        (unRoot\n          (restrict (\\<pi>' \\<circ> x) X\n            (f (restrict (\\<pi>' \\<circ> x) X)))) =\n       unRoot (x (f (restrict (\\<pi>' \\<circ> x) X)))", "also"], ["proof (state)\nthis:\n  unRoot\n   (Root (inv \\<pi> (unRoot (g (f (restrict (\\<pi>' \\<circ> g) X)))))) =\n  inv \\<pi> (unRoot (g (f (restrict (\\<pi>' \\<circ> g) X))))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<rightarrow>\\<^sub>E Roots \\<Longrightarrow>\n       \\<pi>\n        (unRoot\n          (restrict (\\<pi>' \\<circ> x) X\n            (f (restrict (\\<pi>' \\<circ> x) X)))) =\n       unRoot (x (f (restrict (\\<pi>' \\<circ> x) X)))", "have \"\\<pi> \\<dots> = unRoot (g (f (restrict (\\<pi>' \\<circ> g) X)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> (inv \\<pi> (unRoot (g (f (restrict (\\<pi>' \\<circ> g) X))))) =\n    unRoot (g (f (restrict (\\<pi>' \\<circ> g) X)))", "by (rule permutes_inverses[OF \\<pi>])"], ["proof (state)\nthis:\n  \\<pi> (inv \\<pi> (unRoot (g (f (restrict (\\<pi>' \\<circ> g) X))))) =\n  unRoot (g (f (restrict (\\<pi>' \\<circ> g) X)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> X \\<rightarrow>\\<^sub>E Roots \\<Longrightarrow>\n       \\<pi>\n        (unRoot\n          (restrict (\\<pi>' \\<circ> x) X\n            (f (restrict (\\<pi>' \\<circ> x) X)))) =\n       unRoot (x (f (restrict (\\<pi>' \\<circ> x) X)))", "finally"], ["proof (chain)\npicking this:\n  \\<pi>\n   (unRoot\n     (restrict (\\<pi>' \\<circ> g) X (f (restrict (\\<pi>' \\<circ> g) X)))) =\n  unRoot (g (f (restrict (\\<pi>' \\<circ> g) X)))", "show \"\\<pi> (unRoot (restrict (\\<pi>' \\<circ> g) X (f (restrict (\\<pi>' \\<circ> g) X)))) =\n                          unRoot (g (f (restrict (\\<pi>' \\<circ> g) X)))\""], ["proof (prove)\nusing this:\n  \\<pi>\n   (unRoot\n     (restrict (\\<pi>' \\<circ> g) X (f (restrict (\\<pi>' \\<circ> g) X)))) =\n  unRoot (g (f (restrict (\\<pi>' \\<circ> g) X)))\n\ngoal (1 subgoal):\n 1. \\<pi>\n     (unRoot\n       (restrict (\\<pi>' \\<circ> g) X\n         (f (restrict (\\<pi>' \\<circ> g) X)))) =\n    unRoot (g (f (restrict (\\<pi>' \\<circ> g) X)))", "."], ["proof (state)\nthis:\n  \\<pi>\n   (unRoot\n     (restrict (\\<pi>' \\<circ> g) X (f (restrict (\\<pi>' \\<circ> g) X)))) =\n  unRoot (g (f (restrict (\\<pi>' \\<circ> g) X)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n     Var (\\<pi>\n           (unRoot\n             (restrict (\\<pi>' \\<circ> g) X\n               (f (restrict (\\<pi>' \\<circ> g) X)))))) =\n  (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n     Var (unRoot (g (f (restrict (\\<pi>' \\<circ> g) X)))))\n\ngoal (2 subgoals):\n 1. tuples Y = tuples Y\n 2. \\<And>x.\n       x \\<in> tuples Y \\<Longrightarrow>\n       (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n          Var (\\<pi> (unRoot (g (x g))))) =\n       (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n          Var (unRoot (g (x (restrict (\\<pi>' \\<circ> g) X)))))", "finally"], ["proof (chain)\npicking this:\n  (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n     Var (\\<pi> (unRoot (g (f g))))) =\n  (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n     Var (unRoot (g (f (restrict (\\<pi>' \\<circ> g) X)))))", "show ?case"], ["proof (prove)\nusing this:\n  (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n     Var (\\<pi> (unRoot (g (f g))))) =\n  (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n     Var (unRoot (g (f (restrict (\\<pi>' \\<circ> g) X)))))\n\ngoal (1 subgoal):\n 1. (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n       Var (\\<pi> (unRoot (g (f g))))) =\n    (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n       Var (unRoot (g (f (restrict (\\<pi>' \\<circ> g) X)))))", "."], ["proof (state)\nthis:\n  (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n     Var (\\<pi> (unRoot (g (f g))))) =\n  (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n     Var (unRoot (g (f (restrict (\\<pi>' \\<circ> g) X)))))\n\ngoal (1 subgoal):\n 1. tuples Y = tuples Y", "qed simp_all"], ["proof (state)\nthis:\n  (\\<Sum>f\\<in>tuples Y.\n     \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n       Var (\\<pi> (unRoot (g (f g))))) =\n  (\\<Sum>f\\<in>tuples Y.\n     \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n       Var (unRoot (g (f (restrict (\\<pi>' \\<circ> g) X)))))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes {..<n} \\<Longrightarrow> mpoly_map_vars \\<pi> Q = Q", "also"], ["proof (state)\nthis:\n  (\\<Sum>f\\<in>tuples Y.\n     \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n       Var (\\<pi> (unRoot (g (f g))))) =\n  (\\<Sum>f\\<in>tuples Y.\n     \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n       Var (unRoot (g (f (restrict (\\<pi>' \\<circ> g) X)))))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes {..<n} \\<Longrightarrow> mpoly_map_vars \\<pi> Q = Q", "have \"\\<dots> = (\\<Sum>x\\<in>tuples Y. \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. Var (unRoot (g ((\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots. x (restrict (\\<pi>' \\<circ> g) X)) g))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>f\\<in>tuples Y.\n       \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n         Var (unRoot (g (f (restrict (\\<pi>' \\<circ> g) X))))) =\n    (\\<Sum>x\\<in>tuples Y.\n       \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n         Var (unRoot\n               (g ((\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n                       x (restrict (\\<pi>' \\<circ> g) X))\n                    g))))", "by (intro sum.cong prod.cong refl) auto"], ["proof (state)\nthis:\n  (\\<Sum>f\\<in>tuples Y.\n     \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n       Var (unRoot (g (f (restrict (\\<pi>' \\<circ> g) X))))) =\n  (\\<Sum>x\\<in>tuples Y.\n     \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n       Var (unRoot\n             (g ((\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n                     x (restrict (\\<pi>' \\<circ> g) X))\n                  g))))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes {..<n} \\<Longrightarrow> mpoly_map_vars \\<pi> Q = Q", "also"], ["proof (state)\nthis:\n  (\\<Sum>f\\<in>tuples Y.\n     \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n       Var (unRoot (g (f (restrict (\\<pi>' \\<circ> g) X))))) =\n  (\\<Sum>x\\<in>tuples Y.\n     \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n       Var (unRoot\n             (g ((\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n                     x (restrict (\\<pi>' \\<circ> g) X))\n                  g))))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes {..<n} \\<Longrightarrow> mpoly_map_vars \\<pi> Q = Q", "have \"\\<dots> = Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>tuples Y.\n       \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n         Var (unRoot\n               (g ((\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n                       x (restrict (\\<pi>' \\<circ> g) X))\n                    g)))) =\n    Q", "unfolding Q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>tuples Y.\n       \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n         Var (unRoot\n               (g ((\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n                       x (restrict (\\<pi>' \\<circ> g) X))\n                    g)))) =\n    (\\<Sum>f\\<in>tuples Y.\n       \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. Var (unRoot (g (f g))))", "by (rule sum.reindex_bij_betw[OF bij_betw_compose_perm]) (use \\<pi>' Y in simp_all)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>tuples Y.\n     \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n       Var (unRoot\n             (g ((\\<lambda>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n                     x (restrict (\\<pi>' \\<circ> g) X))\n                  g)))) =\n  Q\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes {..<n} \\<Longrightarrow> mpoly_map_vars \\<pi> Q = Q", "finally"], ["proof (chain)\npicking this:\n  mpoly_map_vars \\<pi> Q = Q", "show \"mpoly_map_vars \\<pi> Q = Q\""], ["proof (prove)\nusing this:\n  mpoly_map_vars \\<pi> Q = Q\n\ngoal (1 subgoal):\n 1. mpoly_map_vars \\<pi> Q = Q", "."], ["proof (state)\nthis:\n  mpoly_map_vars \\<pi> Q = Q\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  symmetric_mpoly {..<n} Q\n\ngoal (7 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<n}\n 3. vars Q \\<subseteq> {..<n}\n 4. ?cinv * ?c = 1\n 5. ?cinv \\<in> \\<rat>\n 6. ?p = Polynomial.smult ?c (\\<Prod>i<n. [:- Root i, 1:])\n 7. \\<forall>i. poly.coeff ?p i \\<in> \\<rat>", "next"], ["proof (state)\ngoal (7 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<n}\n 3. vars Q \\<subseteq> {..<n}\n 4. ?cinv * ?c = 1\n 5. ?cinv \\<in> \\<rat>\n 6. ?p = Polynomial.smult ?c (\\<Prod>i<n. [:- Root i, 1:])\n 7. \\<forall>i. poly.coeff ?p i \\<in> \\<rat>", "show \"vars Q \\<subseteq> {..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars Q \\<subseteq> {..<n}", "unfolding Q_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars\n     (\\<Sum>f\\<in>tuples Y.\n        \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. Var (unRoot (g (f g))))\n    \\<subseteq> {..<n}", "by (intro order.trans[OF vars_sum] UN_least order.trans[OF vars_prod])\n           (auto simp: vars_Var tuples_def)"], ["proof (state)\nthis:\n  vars Q \\<subseteq> {..<n}\n\ngoal (6 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<n}\n 3. ?cinv * ?c = 1\n 4. ?cinv \\<in> \\<rat>\n 5. ?p = Polynomial.smult ?c (\\<Prod>i<n. [:- Root i, 1:])\n 6. \\<forall>i. poly.coeff ?p i \\<in> \\<rat>", "next"], ["proof (state)\ngoal (6 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<n}\n 3. ?cinv * ?c = 1\n 4. ?cinv \\<in> \\<rat>\n 5. ?p = Polynomial.smult ?c (\\<Prod>i<n. [:- Root i, 1:])\n 6. \\<forall>i. poly.coeff ?p i \\<in> \\<rat>", "define lc where \"lc = Polynomial.lead_coeff P\""], ["proof (state)\nthis:\n  lc = Polynomial.lead_coeff P\n\ngoal (6 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<n}\n 3. ?cinv * ?c = 1\n 4. ?cinv \\<in> \\<rat>\n 5. ?p = Polynomial.smult ?c (\\<Prod>i<n. [:- Root i, 1:])\n 6. \\<forall>i. poly.coeff ?p i \\<in> \\<rat>", "have \"lc \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lc \\<noteq> 0", "unfolding lc_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Polynomial.lead_coeff P \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  lc \\<noteq> 0\n\ngoal (6 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<n}\n 3. ?cinv * ?c = 1\n 4. ?cinv \\<in> \\<rat>\n 5. ?p = Polynomial.smult ?c (\\<Prod>i<n. [:- Root i, 1:])\n 6. \\<forall>i. poly.coeff ?p i \\<in> \\<rat>", "thus \"inverse (of_int lc) * (of_int lc :: complex) = 1\" and \"inverse (of_int lc) \\<in> \\<rat>\""], ["proof (prove)\nusing this:\n  lc \\<noteq> 0\n\ngoal (1 subgoal):\n 1. inverse (of_int lc) * of_int lc = 1 &&& inverse (of_int lc) \\<in> \\<rat>", "by auto"], ["proof (state)\nthis:\n  inverse (of_int lc) * of_int lc = 1\n  inverse (of_int lc) \\<in> \\<rat>\n\ngoal (4 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<n}\n 3. ?p =\n    Polynomial.smult (of_int (Polynomial.lead_coeff P))\n     (\\<Prod>i<n. [:- Root i, 1:])\n 4. \\<forall>i. poly.coeff ?p i \\<in> \\<rat>", "have \"rsquarefree (of_int_poly P :: complex poly)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. rsquarefree (Ring_Hom_Poly.of_int_poly P)", "using \\<open>squarefree (of_int_poly P :: complex poly)\\<close>"], ["proof (prove)\nusing this:\n  squarefree (Ring_Hom_Poly.of_int_poly P)\n\ngoal (1 subgoal):\n 1. rsquarefree (Ring_Hom_Poly.of_int_poly P)", "by (intro squarefree_imp_rsquarefree)"], ["proof (state)\nthis:\n  rsquarefree (Ring_Hom_Poly.of_int_poly P)\n\ngoal (4 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<n}\n 3. ?p =\n    Polynomial.smult (of_int (Polynomial.lead_coeff P))\n     (\\<Prod>i<n. [:- Root i, 1:])\n 4. \\<forall>i. poly.coeff ?p i \\<in> \\<rat>", "hence \"of_int_poly P = Polynomial.smult (of_int lc) (\\<Prod>x\\<in>Roots. [:-x, 1:])\""], ["proof (prove)\nusing this:\n  rsquarefree (Ring_Hom_Poly.of_int_poly P)\n\ngoal (1 subgoal):\n 1. Ring_Hom_Poly.of_int_poly P =\n    Polynomial.smult (of_int lc) (\\<Prod>x\\<in>Roots. [:- x, 1:])", "unfolding lc_def of_int_hom.hom_lead_coeff[symmetric] Roots_def"], ["proof (prove)\nusing this:\n  rsquarefree (Ring_Hom_Poly.of_int_poly P)\n\ngoal (1 subgoal):\n 1. Ring_Hom_Poly.of_int_poly P =\n    Polynomial.smult (Polynomial.lead_coeff (Ring_Hom_Poly.of_int_poly P))\n     (\\<Prod>x\\<in>{x. ipoly P x = 0}. [:- x, 1:])", "by (rule complex_poly_decompose_rsquarefree [symmetric])"], ["proof (state)\nthis:\n  Ring_Hom_Poly.of_int_poly P =\n  Polynomial.smult (of_int lc) (\\<Prod>x\\<in>Roots. [:- x, 1:])\n\ngoal (4 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<n}\n 3. ?p =\n    Polynomial.smult (of_int (Polynomial.lead_coeff P))\n     (\\<Prod>i<n. [:- Root i, 1:])\n 4. \\<forall>i. poly.coeff ?p i \\<in> \\<rat>", "also"], ["proof (state)\nthis:\n  Ring_Hom_Poly.of_int_poly P =\n  Polynomial.smult (of_int lc) (\\<Prod>x\\<in>Roots. [:- x, 1:])\n\ngoal (4 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<n}\n 3. ?p =\n    Polynomial.smult (of_int (Polynomial.lead_coeff P))\n     (\\<Prod>i<n. [:- Root i, 1:])\n 4. \\<forall>i. poly.coeff ?p i \\<in> \\<rat>", "have \"(\\<Prod>x\\<in>Roots. [:-x, 1:]) = (\\<Prod>i<n. [:-Root i, 1:])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<in>Roots. [:- x, 1:]) = (\\<Prod>i<n. [:- Root i, 1:])", "by (rule prod.reindex_bij_betw[OF Root, symmetric])"], ["proof (state)\nthis:\n  (\\<Prod>x\\<in>Roots. [:- x, 1:]) = (\\<Prod>i<n. [:- Root i, 1:])\n\ngoal (4 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<n}\n 3. ?p =\n    Polynomial.smult (of_int (Polynomial.lead_coeff P))\n     (\\<Prod>i<n. [:- Root i, 1:])\n 4. \\<forall>i. poly.coeff ?p i \\<in> \\<rat>", "finally"], ["proof (chain)\npicking this:\n  Ring_Hom_Poly.of_int_poly P =\n  Polynomial.smult (of_int lc) (\\<Prod>i<n. [:- Root i, 1:])", "show \"of_int_poly P = Polynomial.smult (of_int lc) (\\<Prod>i<n. [:- Root i, 1:])\""], ["proof (prove)\nusing this:\n  Ring_Hom_Poly.of_int_poly P =\n  Polynomial.smult (of_int lc) (\\<Prod>i<n. [:- Root i, 1:])\n\ngoal (1 subgoal):\n 1. Ring_Hom_Poly.of_int_poly P =\n    Polynomial.smult (of_int lc) (\\<Prod>i<n. [:- Root i, 1:])", "."], ["proof (state)\nthis:\n  Ring_Hom_Poly.of_int_poly P =\n  Polynomial.smult (of_int lc) (\\<Prod>i<n. [:- Root i, 1:])\n\ngoal (3 subgoals):\n 1. ring_homomorphism (\\<lambda>a. a)\n 2. finite {..<n}\n 3. \\<forall>i. poly.coeff (Ring_Hom_Poly.of_int_poly P) i \\<in> \\<rat>", "qed auto"], ["proof (state)\nthis:\n  insertion Root Q \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. \\<beta>' Y \\<in> \\<rat>", "also"], ["proof (state)\nthis:\n  insertion Root Q \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. \\<beta>' Y \\<in> \\<rat>", "have \"insertion Root Q = (\\<Sum>f\\<in>tuples Y. \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. Root (unRoot (g (f g))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion Root Q =\n    (\\<Sum>f\\<in>tuples Y.\n       \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. Root (unRoot (g (f g))))", "by (simp add: Q_def insertion_sum insertion_prod)"], ["proof (state)\nthis:\n  insertion Root Q =\n  (\\<Sum>f\\<in>tuples Y.\n     \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. Root (unRoot (g (f g))))\n\ngoal (1 subgoal):\n 1. \\<beta>' Y \\<in> \\<rat>", "also"], ["proof (state)\nthis:\n  insertion Root Q =\n  (\\<Sum>f\\<in>tuples Y.\n     \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. Root (unRoot (g (f g))))\n\ngoal (1 subgoal):\n 1. \\<beta>' Y \\<in> \\<rat>", "have \"\\<dots> = \\<beta>' Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>f\\<in>tuples Y.\n       \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n         Root (unRoot (g (f g)))) =\n    \\<beta>' Y", "unfolding \\<beta>'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>f\\<in>tuples Y.\n       \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots.\n         Root (unRoot (g (f g)))) =\n    (\\<Sum>f\\<in>tuples Y.\n       \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g (f g))", "by (intro sum.cong prod.cong refl Root_unRoot) (auto simp: tuples_def)"], ["proof (state)\nthis:\n  (\\<Sum>f\\<in>tuples Y.\n     \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. Root (unRoot (g (f g)))) =\n  \\<beta>' Y\n\ngoal (1 subgoal):\n 1. \\<beta>' Y \\<in> \\<rat>", "finally"], ["proof (chain)\npicking this:\n  \\<beta>' Y \\<in> \\<rat>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<beta>' Y \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. \\<beta>' Y \\<in> \\<rat>", "."], ["proof (state)\nthis:\n  \\<beta>' Y \\<in> \\<rat>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?Y \\<in> Roots_ms \\<Longrightarrow> \\<beta>' ?Y \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "hence \"\\<forall>Y\\<in>Roots_ms. \\<exists>x. \\<beta>' Y = of_rat x\""], ["proof (prove)\nusing this:\n  ?Y \\<in> Roots_ms \\<Longrightarrow> \\<beta>' ?Y \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. \\<forall>Y\\<in>Roots_ms. \\<exists>x. \\<beta>' Y = of_rat x", "by (auto elim!: Rats_cases)"], ["proof (state)\nthis:\n  \\<forall>Y\\<in>Roots_ms. \\<exists>x. \\<beta>' Y = of_rat x\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  \\<forall>Y\\<in>Roots_ms. \\<exists>x. \\<beta>' Y = of_rat x", "obtain \\<beta>'' :: \"complex multiset \\<Rightarrow> rat\"\n    where \\<beta>'': \"\\<And>Y. Y \\<in> Roots_ms \\<Longrightarrow> \\<beta>' Y = of_rat (\\<beta>'' Y)\""], ["proof (prove)\nusing this:\n  \\<forall>Y\\<in>Roots_ms. \\<exists>x. \\<beta>' Y = of_rat x\n\ngoal (1 subgoal):\n 1. (\\<And>\\<beta>''.\n        (\\<And>Y.\n            Y \\<in> Roots_ms \\<Longrightarrow>\n            \\<beta>' Y = of_rat (\\<beta>'' Y)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  ?Y \\<in> Roots_ms \\<Longrightarrow> \\<beta>' ?Y = of_rat (\\<beta>'' ?Y)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "text \\<open>\n    We again collect all the terms that happen to have equal exponents and call their\n    coefficients \\<open>\\<beta>''\\<close>:\n  \\<close>"], ["proof (state)\nthis:\n  ?Y \\<in> Roots_ms \\<Longrightarrow> \\<beta>' ?Y = of_rat (\\<beta>'' ?Y)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "define \\<beta>''' :: \"complex \\<Rightarrow> rat\" where \"\\<beta>''' = (\\<lambda>\\<alpha>. \\<Sum>Y\\<in>Roots_ms. (\\<beta>'' Y when \\<Sum>\\<^sub>#Y = \\<alpha>))\""], ["proof (state)\nthis:\n  \\<beta>''' =\n  (\\<lambda>\\<alpha>.\n      \\<Sum>Y\\<in>Roots_ms. \\<beta>'' Y when \\<Sum>\\<^sub># Y = \\<alpha>)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have supp_\\<beta>''': \"{x. \\<beta>''' x \\<noteq> 0} \\<subseteq> sum_mset ` Roots_ms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. \\<beta>''' x \\<noteq> 0} \\<subseteq> \\<Sum>\\<^sub># ` Roots_ms", "by (auto simp: \\<beta>'''_def when_def elim!: sum.not_neutral_contains_not_neutral split: if_splits)"], ["proof (state)\nthis:\n  {x. \\<beta>''' x \\<noteq> 0} \\<subseteq> \\<Sum>\\<^sub># ` Roots_ms\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "text \\<open>\n    We again start with the sum that we now to be zero and multiply it with all the sums that can\n    be obtained with different choices for the roots.\n  \\<close>"], ["proof (state)\nthis:\n  {x. \\<beta>''' x \\<noteq> 0} \\<subseteq> \\<Sum>\\<^sub># ` Roots_ms\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have \"0 = (\\<Sum>x\\<in>X. \\<beta> x * exp x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = (\\<Sum>x\\<in>X. \\<beta> x * exp x)", "using sum0"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>X. \\<beta> x * exp x) = 0\n\ngoal (1 subgoal):\n 1. 0 = (\\<Sum>x\\<in>X. \\<beta> x * exp x)", ".."], ["proof (state)\nthis:\n  0 = (\\<Sum>x\\<in>X. \\<beta> x * exp x)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  0 = (\\<Sum>x\\<in>X. \\<beta> x * exp x)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have \"\\<dots> = (\\<Sum>x\\<in>X. restrict \\<beta> X x * exp x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>X. \\<beta> x * exp x) =\n    (\\<Sum>x\\<in>X. restrict \\<beta> X x * exp x)", "by (intro sum.cong) auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>X. \\<beta> x * exp x) =\n  (\\<Sum>x\\<in>X. restrict \\<beta> X x * exp x)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>X. \\<beta> x * exp x) =\n  (\\<Sum>x\\<in>X. restrict \\<beta> X x * exp x)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have \"\\<dots> dvd (\\<Prod>f \\<in> X \\<rightarrow>\\<^sub>E Roots. \\<Sum>x\\<in>X. f x * exp x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>X. restrict \\<beta> X x * exp x) dvd\n    (\\<Prod>f\\<in>X \\<rightarrow>\\<^sub>E Roots. \\<Sum>x\\<in>X. f x * exp x)", "by (rule dvd_prodI) (use \\<open>\\<beta> ` X \\<subseteq> Roots\\<close> in \\<open>auto simp: id_def\\<close>)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>X. restrict \\<beta> X x * exp x) dvd\n  (\\<Prod>f\\<in>X \\<rightarrow>\\<^sub>E Roots. \\<Sum>x\\<in>X. f x * exp x)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>X. restrict \\<beta> X x * exp x) dvd\n  (\\<Prod>f\\<in>X \\<rightarrow>\\<^sub>E Roots. \\<Sum>x\\<in>X. f x * exp x)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have \"\\<dots> = (\\<Sum>f\\<in>(X \\<rightarrow>\\<^sub>E Roots) \\<rightarrow>\\<^sub>E X. \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g (f g) * exp (f g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>f\\<in>X \\<rightarrow>\\<^sub>E Roots.\n       \\<Sum>x\\<in>X. f x * exp x) =\n    (\\<Sum>f\\<in>(X \\<rightarrow>\\<^sub>E Roots) \\<rightarrow>\\<^sub>E X.\n       \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g (f g) * exp (f g))", "by (rule prod_sum_PiE) auto"], ["proof (state)\nthis:\n  (\\<Prod>f\\<in>X \\<rightarrow>\\<^sub>E Roots. \\<Sum>x\\<in>X. f x * exp x) =\n  (\\<Sum>f\\<in>(X \\<rightarrow>\\<^sub>E Roots) \\<rightarrow>\\<^sub>E X.\n     \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g (f g) * exp (f g))\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Prod>f\\<in>X \\<rightarrow>\\<^sub>E Roots. \\<Sum>x\\<in>X. f x * exp x) =\n  (\\<Sum>f\\<in>(X \\<rightarrow>\\<^sub>E Roots) \\<rightarrow>\\<^sub>E X.\n     \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g (f g) * exp (f g))\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have \"\\<dots> = (\\<Sum>f\\<in>(X \\<rightarrow>\\<^sub>E Roots) \\<rightarrow>\\<^sub>E X. (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g (f g)) * exp (\\<Sum>g\\<in>X \\<rightarrow>\\<^sub>E Roots. f g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>f\\<in>(X \\<rightarrow>\\<^sub>E Roots) \\<rightarrow>\\<^sub>E X.\n       \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g (f g) * exp (f g)) =\n    (\\<Sum>f\\<in>(X \\<rightarrow>\\<^sub>E Roots) \\<rightarrow>\\<^sub>E X.\n       (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g (f g)) *\n       exp (sum f (X \\<rightarrow>\\<^sub>E Roots)))", "by (simp add: prod.distrib exp_sum)"], ["proof (state)\nthis:\n  (\\<Sum>f\\<in>(X \\<rightarrow>\\<^sub>E Roots) \\<rightarrow>\\<^sub>E X.\n     \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g (f g) * exp (f g)) =\n  (\\<Sum>f\\<in>(X \\<rightarrow>\\<^sub>E Roots) \\<rightarrow>\\<^sub>E X.\n     (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g (f g)) *\n     exp (sum f (X \\<rightarrow>\\<^sub>E Roots)))\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Sum>f\\<in>(X \\<rightarrow>\\<^sub>E Roots) \\<rightarrow>\\<^sub>E X.\n     \\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g (f g) * exp (f g)) =\n  (\\<Sum>f\\<in>(X \\<rightarrow>\\<^sub>E Roots) \\<rightarrow>\\<^sub>E X.\n     (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g (f g)) *\n     exp (sum f (X \\<rightarrow>\\<^sub>E Roots)))\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have \"\\<dots> = (\\<Sum>(Y,f)\\<in>Sigma Roots_ms tuples.\n                    (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g (f g)) * exp (\\<Sum>g\\<in>X \\<rightarrow>\\<^sub>E Roots. f g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>f\\<in>(X \\<rightarrow>\\<^sub>E Roots) \\<rightarrow>\\<^sub>E X.\n       (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g (f g)) *\n       exp (sum f (X \\<rightarrow>\\<^sub>E Roots))) =\n    (\\<Sum>(Y, f)\\<in>Sigma Roots_ms tuples.\n       (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g (f g)) *\n       exp (sum f (X \\<rightarrow>\\<^sub>E Roots)))", "by (intro sum.reindex_bij_witness[of _ snd \"\\<lambda>f. (image_mset f (mset_set (X \\<rightarrow>\\<^sub>E Roots)), f)\"])\n       (auto simp: Roots_ms_def tuples_def)"], ["proof (state)\nthis:\n  (\\<Sum>f\\<in>(X \\<rightarrow>\\<^sub>E Roots) \\<rightarrow>\\<^sub>E X.\n     (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g (f g)) *\n     exp (sum f (X \\<rightarrow>\\<^sub>E Roots))) =\n  (\\<Sum>(Y, f)\\<in>Sigma Roots_ms tuples.\n     (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g (f g)) *\n     exp (sum f (X \\<rightarrow>\\<^sub>E Roots)))\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Sum>f\\<in>(X \\<rightarrow>\\<^sub>E Roots) \\<rightarrow>\\<^sub>E X.\n     (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g (f g)) *\n     exp (sum f (X \\<rightarrow>\\<^sub>E Roots))) =\n  (\\<Sum>(Y, f)\\<in>Sigma Roots_ms tuples.\n     (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g (f g)) *\n     exp (sum f (X \\<rightarrow>\\<^sub>E Roots)))\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have \"\\<dots> = (\\<Sum>(Y,f)\\<in>Sigma Roots_ms tuples. (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g (f g)) * exp (\\<Sum>\\<^sub>#Y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(Y, f)\\<in>Sigma Roots_ms tuples.\n       (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g (f g)) *\n       exp (sum f (X \\<rightarrow>\\<^sub>E Roots))) =\n    (\\<Sum>(Y, f)\\<in>Sigma Roots_ms tuples.\n       (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g (f g)) *\n       exp (\\<Sum>\\<^sub># Y))", "by (intro sum.cong) (auto simp: tuples_def sum_unfold_sum_mset)"], ["proof (state)\nthis:\n  (\\<Sum>(Y, f)\\<in>Sigma Roots_ms tuples.\n     (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g (f g)) *\n     exp (sum f (X \\<rightarrow>\\<^sub>E Roots))) =\n  (\\<Sum>(Y, f)\\<in>Sigma Roots_ms tuples.\n     (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g (f g)) *\n     exp (\\<Sum>\\<^sub># Y))\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Sum>(Y, f)\\<in>Sigma Roots_ms tuples.\n     (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g (f g)) *\n     exp (sum f (X \\<rightarrow>\\<^sub>E Roots))) =\n  (\\<Sum>(Y, f)\\<in>Sigma Roots_ms tuples.\n     (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g (f g)) *\n     exp (\\<Sum>\\<^sub># Y))\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have \"\\<dots> = (\\<Sum>Y\\<in>Roots_ms. \\<beta>' Y * exp (\\<Sum>\\<^sub>#Y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(Y, f)\\<in>Sigma Roots_ms tuples.\n       (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g (f g)) *\n       exp (\\<Sum>\\<^sub># Y)) =\n    (\\<Sum>Y\\<in>Roots_ms. \\<beta>' Y * exp (\\<Sum>\\<^sub># Y))", "unfolding \\<beta>'_def sum_distrib_right"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(Y, f)\\<in>Sigma Roots_ms tuples.\n       (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g (f g)) *\n       exp (\\<Sum>\\<^sub># Y)) =\n    (\\<Sum>Y\\<in>Roots_ms.\n       \\<Sum>n\\<in>tuples Y.\n         (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g (n g)) *\n         exp (\\<Sum>\\<^sub># Y))", "by (rule sum.Sigma [symmetric]) auto"], ["proof (state)\nthis:\n  (\\<Sum>(Y, f)\\<in>Sigma Roots_ms tuples.\n     (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g (f g)) *\n     exp (\\<Sum>\\<^sub># Y)) =\n  (\\<Sum>Y\\<in>Roots_ms. \\<beta>' Y * exp (\\<Sum>\\<^sub># Y))\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Sum>(Y, f)\\<in>Sigma Roots_ms tuples.\n     (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g (f g)) *\n     exp (\\<Sum>\\<^sub># Y)) =\n  (\\<Sum>Y\\<in>Roots_ms. \\<beta>' Y * exp (\\<Sum>\\<^sub># Y))\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have \"\\<dots> = (\\<Sum>Y\\<in>Roots_ms. of_rat (\\<beta>'' Y) * exp (\\<Sum>\\<^sub>#Y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>Y\\<in>Roots_ms. \\<beta>' Y * exp (\\<Sum>\\<^sub># Y)) =\n    (\\<Sum>Y\\<in>Roots_ms. of_rat (\\<beta>'' Y) * exp (\\<Sum>\\<^sub># Y))", "by (intro sum.cong) (auto simp: \\<beta>'')"], ["proof (state)\nthis:\n  (\\<Sum>Y\\<in>Roots_ms. \\<beta>' Y * exp (\\<Sum>\\<^sub># Y)) =\n  (\\<Sum>Y\\<in>Roots_ms. of_rat (\\<beta>'' Y) * exp (\\<Sum>\\<^sub># Y))\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Sum>Y\\<in>Roots_ms. \\<beta>' Y * exp (\\<Sum>\\<^sub># Y)) =\n  (\\<Sum>Y\\<in>Roots_ms. of_rat (\\<beta>'' Y) * exp (\\<Sum>\\<^sub># Y))\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have \"\\<dots> = (\\<Sum>Y\\<in>Roots_ms. Sum_any (\\<lambda>\\<alpha>. of_rat (\\<beta>'' Y when \\<Sum>\\<^sub># Y = \\<alpha>) * exp \\<alpha>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>Y\\<in>Roots_ms. of_rat (\\<beta>'' Y) * exp (\\<Sum>\\<^sub># Y)) =\n    (\\<Sum>Y\\<in>Roots_ms.\n       \\<Sum>\\<alpha>. of_rat\n                        (\\<beta>'' Y when \\<Sum>\\<^sub># Y = \\<alpha>) *\n                       exp \\<alpha>)", "proof (rule sum.cong, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. Roots_ms = Roots_ms\n 2. \\<And>x.\n       x \\<in> Roots_ms \\<Longrightarrow>\n       of_rat (\\<beta>'' x) * exp (\\<Sum>\\<^sub># x) =\n       (\\<Sum>\\<alpha>. of_rat\n                         (\\<beta>'' x when \\<Sum>\\<^sub># x = \\<alpha>) *\n                        exp \\<alpha>)", "case (2 Y)"], ["proof (state)\nthis:\n  Y \\<in> Roots_ms\n\ngoal (2 subgoals):\n 1. Roots_ms = Roots_ms\n 2. \\<And>x.\n       x \\<in> Roots_ms \\<Longrightarrow>\n       of_rat (\\<beta>'' x) * exp (\\<Sum>\\<^sub># x) =\n       (\\<Sum>\\<alpha>. of_rat\n                         (\\<beta>'' x when \\<Sum>\\<^sub># x = \\<alpha>) *\n                        exp \\<alpha>)", "have \"Sum_any (\\<lambda>\\<alpha>. of_rat (\\<beta>'' Y when \\<Sum>\\<^sub># Y = \\<alpha>) * exp \\<alpha>) =\n          (\\<Sum>\\<alpha>\\<in>{\\<Sum>\\<^sub># Y}. of_rat (\\<beta>'' Y when \\<Sum>\\<^sub># Y = \\<alpha>) * exp \\<alpha>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<alpha>. of_rat (\\<beta>'' Y when \\<Sum>\\<^sub># Y = \\<alpha>) *\n                     exp \\<alpha>) =\n    (\\<Sum>\\<alpha>\\<in>{\\<Sum>\\<^sub># Y}.\n       of_rat (\\<beta>'' Y when \\<Sum>\\<^sub># Y = \\<alpha>) * exp \\<alpha>)", "by (intro Sum_any.expand_superset) auto"], ["proof (state)\nthis:\n  (\\<Sum>\\<alpha>. of_rat (\\<beta>'' Y when \\<Sum>\\<^sub># Y = \\<alpha>) *\n                   exp \\<alpha>) =\n  (\\<Sum>\\<alpha>\\<in>{\\<Sum>\\<^sub># Y}.\n     of_rat (\\<beta>'' Y when \\<Sum>\\<^sub># Y = \\<alpha>) * exp \\<alpha>)\n\ngoal (2 subgoals):\n 1. Roots_ms = Roots_ms\n 2. \\<And>x.\n       x \\<in> Roots_ms \\<Longrightarrow>\n       of_rat (\\<beta>'' x) * exp (\\<Sum>\\<^sub># x) =\n       (\\<Sum>\\<alpha>. of_rat\n                         (\\<beta>'' x when \\<Sum>\\<^sub># x = \\<alpha>) *\n                        exp \\<alpha>)", "thus ?case"], ["proof (prove)\nusing this:\n  (\\<Sum>\\<alpha>. of_rat (\\<beta>'' Y when \\<Sum>\\<^sub># Y = \\<alpha>) *\n                   exp \\<alpha>) =\n  (\\<Sum>\\<alpha>\\<in>{\\<Sum>\\<^sub># Y}.\n     of_rat (\\<beta>'' Y when \\<Sum>\\<^sub># Y = \\<alpha>) * exp \\<alpha>)\n\ngoal (1 subgoal):\n 1. of_rat (\\<beta>'' Y) * exp (\\<Sum>\\<^sub># Y) =\n    (\\<Sum>\\<alpha>. of_rat (\\<beta>'' Y when \\<Sum>\\<^sub># Y = \\<alpha>) *\n                     exp \\<alpha>)", "by simp"], ["proof (state)\nthis:\n  of_rat (\\<beta>'' Y) * exp (\\<Sum>\\<^sub># Y) =\n  (\\<Sum>\\<alpha>. of_rat (\\<beta>'' Y when \\<Sum>\\<^sub># Y = \\<alpha>) *\n                   exp \\<alpha>)\n\ngoal (1 subgoal):\n 1. Roots_ms = Roots_ms", "qed auto"], ["proof (state)\nthis:\n  (\\<Sum>Y\\<in>Roots_ms. of_rat (\\<beta>'' Y) * exp (\\<Sum>\\<^sub># Y)) =\n  (\\<Sum>Y\\<in>Roots_ms.\n     \\<Sum>\\<alpha>. of_rat (\\<beta>'' Y when \\<Sum>\\<^sub># Y = \\<alpha>) *\n                     exp \\<alpha>)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Sum>Y\\<in>Roots_ms. of_rat (\\<beta>'' Y) * exp (\\<Sum>\\<^sub># Y)) =\n  (\\<Sum>Y\\<in>Roots_ms.\n     \\<Sum>\\<alpha>. of_rat (\\<beta>'' Y when \\<Sum>\\<^sub># Y = \\<alpha>) *\n                     exp \\<alpha>)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have \"\\<dots> = Sum_any (\\<lambda>\\<alpha>. of_rat (\\<beta>''' \\<alpha>) * exp \\<alpha>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>Y\\<in>Roots_ms.\n       \\<Sum>\\<alpha>. of_rat\n                        (\\<beta>'' Y when \\<Sum>\\<^sub># Y = \\<alpha>) *\n                       exp \\<alpha>) =\n    (\\<Sum>\\<alpha>. of_rat (\\<beta>''' \\<alpha>) * exp \\<alpha>)", "unfolding \\<beta>'''_def of_rat_sum sum_distrib_right"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>Y\\<in>Roots_ms.\n       \\<Sum>\\<alpha>. of_rat\n                        (\\<beta>'' Y when \\<Sum>\\<^sub># Y = \\<alpha>) *\n                       exp \\<alpha>) =\n    (\\<Sum>\\<alpha>. \\<Sum>n\\<in>Roots_ms.\n                       of_rat\n                        (\\<beta>'' n when \\<Sum>\\<^sub># n = \\<alpha>) *\n                       exp \\<alpha>)", "by (subst Sum_any_sum_swap) auto"], ["proof (state)\nthis:\n  (\\<Sum>Y\\<in>Roots_ms.\n     \\<Sum>\\<alpha>. of_rat (\\<beta>'' Y when \\<Sum>\\<^sub># Y = \\<alpha>) *\n                     exp \\<alpha>) =\n  (\\<Sum>\\<alpha>. of_rat (\\<beta>''' \\<alpha>) * exp \\<alpha>)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (\\<Sum>Y\\<in>Roots_ms.\n     \\<Sum>\\<alpha>. of_rat (\\<beta>'' Y when \\<Sum>\\<^sub># Y = \\<alpha>) *\n                     exp \\<alpha>) =\n  (\\<Sum>\\<alpha>. of_rat (\\<beta>''' \\<alpha>) * exp \\<alpha>)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have \"\\<dots> = (\\<Sum>\\<alpha> | \\<beta>''' \\<alpha> \\<noteq> 0. of_rat (\\<beta>''' \\<alpha>) * exp \\<alpha>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<alpha>. of_rat (\\<beta>''' \\<alpha>) * exp \\<alpha>) =\n    (\\<Sum>\\<alpha> | \\<beta>''' \\<alpha> \\<noteq> 0.\n       of_rat (\\<beta>''' \\<alpha>) * exp \\<alpha>)", "by (intro Sum_any.expand_superset finite_subset[OF supp_\\<beta>''']) auto"], ["proof (state)\nthis:\n  (\\<Sum>\\<alpha>. of_rat (\\<beta>''' \\<alpha>) * exp \\<alpha>) =\n  (\\<Sum>\\<alpha> | \\<beta>''' \\<alpha> \\<noteq> 0.\n     of_rat (\\<beta>''' \\<alpha>) * exp \\<alpha>)\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  0 dvd\n  (\\<Sum>\\<alpha> | \\<beta>''' \\<alpha> \\<noteq> 0.\n     of_rat (\\<beta>''' \\<alpha>) * exp \\<alpha>)", "have \"(\\<Sum>\\<alpha> | \\<beta>''' \\<alpha> \\<noteq> 0. of_rat (\\<beta>''' \\<alpha>) * exp \\<alpha>) = 0\""], ["proof (prove)\nusing this:\n  0 dvd\n  (\\<Sum>\\<alpha> | \\<beta>''' \\<alpha> \\<noteq> 0.\n     of_rat (\\<beta>''' \\<alpha>) * exp \\<alpha>)\n\ngoal (1 subgoal):\n 1. (\\<Sum>\\<alpha> | \\<beta>''' \\<alpha> \\<noteq> 0.\n       of_rat (\\<beta>''' \\<alpha>) * exp \\<alpha>) =\n    0", "by auto"], ["proof (state)\nthis:\n  (\\<Sum>\\<alpha> | \\<beta>''' \\<alpha> \\<noteq> 0.\n     of_rat (\\<beta>''' \\<alpha>) * exp \\<alpha>) =\n  0\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "text \\<open>\n    We are now in the situation of our previous version of the theorem and can apply it to find\n    that all the coefficients are zero.\n  \\<close>"], ["proof (state)\nthis:\n  (\\<Sum>\\<alpha> | \\<beta>''' \\<alpha> \\<noteq> 0.\n     of_rat (\\<beta>''' \\<alpha>) * exp \\<alpha>) =\n  0\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have \"{\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0} = {}", "proof (rule Hermite_Lindemann_aux3)"], ["proof (state)\ngoal (4 subgoals):\n 1. finite {\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0}\n 2. \\<And>x.\n       x \\<in> {\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0} \\<Longrightarrow>\n       ?\\<beta> x \\<noteq> 0\n 3. \\<And>x.\n       x \\<in> {\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0} \\<Longrightarrow>\n       algebraic x\n 4. (\\<Sum>x\\<in>{\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0}.\n       of_rat (?\\<beta> x) * exp x) =\n    0", "show \"finite {\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite {\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0}", "by (rule finite_subset[OF supp_\\<beta>''']) auto"], ["proof (state)\nthis:\n  finite {\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0}\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> {\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0} \\<Longrightarrow>\n       ?\\<beta> x \\<noteq> 0\n 2. \\<And>x.\n       x \\<in> {\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0} \\<Longrightarrow>\n       algebraic x\n 3. (\\<Sum>x\\<in>{\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0}.\n       of_rat (?\\<beta> x) * exp x) =\n    0", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> {\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0} \\<Longrightarrow>\n       ?\\<beta> x \\<noteq> 0\n 2. \\<And>x.\n       x \\<in> {\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0} \\<Longrightarrow>\n       algebraic x\n 3. (\\<Sum>x\\<in>{\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0}.\n       of_rat (?\\<beta> x) * exp x) =\n    0", "show \"(\\<Sum>\\<alpha> | \\<beta>''' \\<alpha> \\<noteq> 0. of_rat (\\<beta>''' \\<alpha>) * exp \\<alpha>) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>\\<alpha> | \\<beta>''' \\<alpha> \\<noteq> 0.\n       of_rat (\\<beta>''' \\<alpha>) * exp \\<alpha>) =\n    0", "by fact"], ["proof (state)\nthis:\n  (\\<Sum>\\<alpha> | \\<beta>''' \\<alpha> \\<noteq> 0.\n     of_rat (\\<beta>''' \\<alpha>) * exp \\<alpha>) =\n  0\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0} \\<Longrightarrow>\n       \\<beta>''' x \\<noteq> 0\n 2. \\<And>x.\n       x \\<in> {\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0} \\<Longrightarrow>\n       algebraic x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0} \\<Longrightarrow>\n       \\<beta>''' x \\<noteq> 0\n 2. \\<And>x.\n       x \\<in> {\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0} \\<Longrightarrow>\n       algebraic x", "fix \\<alpha>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0} \\<Longrightarrow>\n       \\<beta>''' x \\<noteq> 0\n 2. \\<And>x.\n       x \\<in> {\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0} \\<Longrightarrow>\n       algebraic x", "assume \\<alpha>: \"\\<alpha> \\<in> {\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0}\""], ["proof (state)\nthis:\n  \\<alpha> \\<in> {\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0} \\<Longrightarrow>\n       \\<beta>''' x \\<noteq> 0\n 2. \\<And>x.\n       x \\<in> {\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0} \\<Longrightarrow>\n       algebraic x", "then"], ["proof (chain)\npicking this:\n  \\<alpha> \\<in> {\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0}", "obtain Y where Y: \"Y \\<in> Roots_ms\" \"\\<alpha> = sum_mset Y\""], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> {\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>Y \\<in> Roots_ms; \\<alpha> = \\<Sum>\\<^sub># Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using supp_\\<beta>'''"], ["proof (prove)\nusing this:\n  \\<alpha> \\<in> {\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0}\n  {x. \\<beta>''' x \\<noteq> 0} \\<subseteq> \\<Sum>\\<^sub># ` Roots_ms\n\ngoal (1 subgoal):\n 1. (\\<And>Y.\n        \\<lbrakk>Y \\<in> Roots_ms; \\<alpha> = \\<Sum>\\<^sub># Y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Y \\<in> Roots_ms\n  \\<alpha> = \\<Sum>\\<^sub># Y\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> {\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0} \\<Longrightarrow>\n       \\<beta>''' x \\<noteq> 0\n 2. \\<And>x.\n       x \\<in> {\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0} \\<Longrightarrow>\n       algebraic x", "thus \"algebraic \\<alpha>\""], ["proof (prove)\nusing this:\n  Y \\<in> Roots_ms\n  \\<alpha> = \\<Sum>\\<^sub># Y\n\ngoal (1 subgoal):\n 1. algebraic \\<alpha>", "using alg1"], ["proof (prove)\nusing this:\n  Y \\<in> Roots_ms\n  \\<alpha> = \\<Sum>\\<^sub># Y\n  ?x \\<in> X \\<Longrightarrow> algebraic ?x\n\ngoal (1 subgoal):\n 1. algebraic \\<alpha>", "by (auto simp: Roots_ms_def)"], ["proof (state)\nthis:\n  algebraic \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> {\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0} \\<Longrightarrow>\n       \\<beta>''' x \\<noteq> 0", "qed auto"], ["proof (state)\nthis:\n  {\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0} = {}\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "text \\<open>\n    However, similarly to before, we can show that the coefficient corresponding to the\n    term with the lexicographically greatest exponent (which is obtained by picking the\n    term with the lexicographically greatest term in each of the factors of our big product)\n    is non-zero.\n  \\<close>"], ["proof (state)\nthis:\n  {\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0} = {}\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  {\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0} = {}\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "have \"\\<exists>\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0", "define \\<alpha>_max where \"\\<alpha>_max = complex_lex.Max X\""], ["proof (state)\nthis:\n  \\<alpha>_max = complex_lex.Max X\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0", "have [simp]: \"\\<alpha>_max \\<in> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>_max \\<in> X", "unfolding \\<alpha>_max_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_lex.Max X \\<in> X", "using \\<open>X \\<noteq> {}\\<close>"], ["proof (prove)\nusing this:\n  X \\<noteq> {}\n\ngoal (1 subgoal):\n 1. complex_lex.Max X \\<in> X", "by (intro complex_lex.Max_in) auto"], ["proof (state)\nthis:\n  \\<alpha>_max \\<in> X\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0", "define Y_max :: \"complex multiset\" where \"Y_max = replicate_mset (n ^ m) \\<alpha>_max\""], ["proof (state)\nthis:\n  Y_max = replicate_mset (n ^ m) \\<alpha>_max\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0", "define f_max where \"f_max = restrict (\\<lambda>_. \\<alpha>_max) (X \\<rightarrow>\\<^sub>E Roots)\""], ["proof (state)\nthis:\n  f_max = (\\<lambda>_\\<in>X \\<rightarrow>\\<^sub>E Roots. \\<alpha>_max)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0", "have [simp]: \"Y_max \\<in> Roots_ms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y_max \\<in> Roots_ms", "by (auto simp: Y_max_def Roots_ms_def)"], ["proof (state)\nthis:\n  Y_max \\<in> Roots_ms\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0", "have \"tuples Y_max = {f_max}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tuples Y_max = {f_max}", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> tuples Y_max; x \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> x = f_max\n 2. \\<And>x. f_max \\<in> tuples Y_max", "have \"image_mset (\\<lambda>_\\<in>X \\<rightarrow>\\<^sub>E Roots. \\<alpha>_max) (mset_set (X \\<rightarrow>\\<^sub>E Roots)) =\n            image_mset (\\<lambda>_. \\<alpha>_max) (mset_set (X \\<rightarrow>\\<^sub>E Roots))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. image_mset (\\<lambda>_\\<in>X \\<rightarrow>\\<^sub>E Roots. \\<alpha>_max)\n     (mset_set (X \\<rightarrow>\\<^sub>E Roots)) =\n    {#\\<alpha>_max. _ \\<in># mset_set (X \\<rightarrow>\\<^sub>E Roots)#}", "by (intro image_mset_cong) auto"], ["proof (state)\nthis:\n  image_mset (\\<lambda>_\\<in>X \\<rightarrow>\\<^sub>E Roots. \\<alpha>_max)\n   (mset_set (X \\<rightarrow>\\<^sub>E Roots)) =\n  {#\\<alpha>_max. _ \\<in># mset_set (X \\<rightarrow>\\<^sub>E Roots)#}\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> tuples Y_max; x \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> x = f_max\n 2. \\<And>x. f_max \\<in> tuples Y_max", "thus \"f_max \\<in> tuples Y_max\""], ["proof (prove)\nusing this:\n  image_mset (\\<lambda>_\\<in>X \\<rightarrow>\\<^sub>E Roots. \\<alpha>_max)\n   (mset_set (X \\<rightarrow>\\<^sub>E Roots)) =\n  {#\\<alpha>_max. _ \\<in># mset_set (X \\<rightarrow>\\<^sub>E Roots)#}\n\ngoal (1 subgoal):\n 1. f_max \\<in> tuples Y_max", "by (auto simp: f_max_def tuples_def Y_max_def image_mset_const_eq)"], ["proof (state)\nthis:\n  f_max \\<in> tuples Y_max\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> tuples Y_max; x \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> x = f_max", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> tuples Y_max; x \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> x = f_max", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> tuples Y_max; x \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> x = f_max", "assume \"f \\<in> tuples Y_max\""], ["proof (state)\nthis:\n  f \\<in> tuples Y_max\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> tuples Y_max; x \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> x = f_max", "hence f: \"f \\<in> (X \\<rightarrow>\\<^sub>E Roots) \\<rightarrow>\\<^sub>E X\" \"image_mset f (mset_set (X \\<rightarrow>\\<^sub>E Roots)) = Y_max\""], ["proof (prove)\nusing this:\n  f \\<in> tuples Y_max\n\ngoal (1 subgoal):\n 1. f \\<in> (X \\<rightarrow>\\<^sub>E Roots) \\<rightarrow>\\<^sub>E X &&&\n    image_mset f (mset_set (X \\<rightarrow>\\<^sub>E Roots)) = Y_max", "by (auto simp: tuples_def)"], ["proof (state)\nthis:\n  f \\<in> (X \\<rightarrow>\\<^sub>E Roots) \\<rightarrow>\\<^sub>E X\n  image_mset f (mset_set (X \\<rightarrow>\\<^sub>E Roots)) = Y_max\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> tuples Y_max; x \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> x = f_max", "hence \"\\<forall>g \\<in># mset_set (X \\<rightarrow>\\<^sub>E Roots). f g = \\<alpha>_max\""], ["proof (prove)\nusing this:\n  f \\<in> (X \\<rightarrow>\\<^sub>E Roots) \\<rightarrow>\\<^sub>E X\n  image_mset f (mset_set (X \\<rightarrow>\\<^sub>E Roots)) = Y_max\n\ngoal (1 subgoal):\n 1. \\<forall>g\\<in>#mset_set (X \\<rightarrow>\\<^sub>E Roots).\n       f g = \\<alpha>_max", "by (intro image_mset_eq_replicate_msetD[where n = \"n ^ m\"]) (auto simp: Y_max_def)"], ["proof (state)\nthis:\n  \\<forall>g\\<in>#mset_set (X \\<rightarrow>\\<^sub>E Roots).\n     f g = \\<alpha>_max\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> tuples Y_max; x \\<notin> {}\\<rbrakk>\n       \\<Longrightarrow> x = f_max", "thus \"f = f_max\""], ["proof (prove)\nusing this:\n  \\<forall>g\\<in>#mset_set (X \\<rightarrow>\\<^sub>E Roots).\n     f g = \\<alpha>_max\n\ngoal (1 subgoal):\n 1. f = f_max", "using f"], ["proof (prove)\nusing this:\n  \\<forall>g\\<in>#mset_set (X \\<rightarrow>\\<^sub>E Roots).\n     f g = \\<alpha>_max\n  f \\<in> (X \\<rightarrow>\\<^sub>E Roots) \\<rightarrow>\\<^sub>E X\n  image_mset f (mset_set (X \\<rightarrow>\\<^sub>E Roots)) = Y_max\n\ngoal (1 subgoal):\n 1. f = f_max", "by (auto simp: Y_max_def fun_eq_iff f_max_def)"], ["proof (state)\nthis:\n  f = f_max\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  tuples Y_max = {f_max}\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0", "have \"\\<beta>''' (of_nat (n ^ m) * \\<alpha>_max) = (\\<Sum>Y\\<in>Roots_ms. \\<beta>'' Y when \\<Sum>\\<^sub># Y = of_nat (n ^ m) * \\<alpha>_max)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta>''' (of_nat (n ^ m) * \\<alpha>_max) =\n    (\\<Sum>Y\\<in>Roots_ms.\n       \\<beta>'' Y when \\<Sum>\\<^sub># Y = of_nat (n ^ m) * \\<alpha>_max)", "unfolding \\<beta>'''_def Roots_ms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>Y | set_mset Y \\<subseteq> X \\<and> size Y = n ^ m.\n       \\<beta>'' Y when \\<Sum>\\<^sub># Y = of_nat (n ^ m) * \\<alpha>_max) =\n    (\\<Sum>Y | set_mset Y \\<subseteq> X \\<and> size Y = n ^ m.\n       \\<beta>'' Y when \\<Sum>\\<^sub># Y = of_nat (n ^ m) * \\<alpha>_max)", ".."], ["proof (state)\nthis:\n  \\<beta>''' (of_nat (n ^ m) * \\<alpha>_max) =\n  (\\<Sum>Y\\<in>Roots_ms.\n     \\<beta>'' Y when \\<Sum>\\<^sub># Y = of_nat (n ^ m) * \\<alpha>_max)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0", "also"], ["proof (state)\nthis:\n  \\<beta>''' (of_nat (n ^ m) * \\<alpha>_max) =\n  (\\<Sum>Y\\<in>Roots_ms.\n     \\<beta>'' Y when \\<Sum>\\<^sub># Y = of_nat (n ^ m) * \\<alpha>_max)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0", "have \"\\<Sum>\\<^sub># Y \\<noteq> of_nat n ^ m * \\<alpha>_max\" if \"Y \\<in> Roots_ms\" \"Y \\<noteq> Y_max\" for Y"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># Y \\<noteq> of_nat n ^ m * \\<alpha>_max", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># Y \\<noteq> of_nat n ^ m * \\<alpha>_max", "have \"\\<not>set_mset Y \\<subseteq> {\\<alpha>_max}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> set_mset Y \\<subseteq> {\\<alpha>_max}", "using set_mset_subset_singletonD[of Y \"\\<alpha>_max\"] that"], ["proof (prove)\nusing this:\n  set_mset Y \\<subseteq> {\\<alpha>_max} \\<Longrightarrow>\n  Y = replicate_mset (size Y) \\<alpha>_max\n  Y \\<in> Roots_ms\n  Y \\<noteq> Y_max\n\ngoal (1 subgoal):\n 1. \\<not> set_mset Y \\<subseteq> {\\<alpha>_max}", "by (auto simp: Roots_ms_def Y_max_def split: if_splits)"], ["proof (state)\nthis:\n  \\<not> set_mset Y \\<subseteq> {\\<alpha>_max}\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># Y \\<noteq> of_nat n ^ m * \\<alpha>_max", "then"], ["proof (chain)\npicking this:\n  \\<not> set_mset Y \\<subseteq> {\\<alpha>_max}", "obtain y where y: \"y \\<in># Y\" \"y \\<noteq> \\<alpha>_max\""], ["proof (prove)\nusing this:\n  \\<not> set_mset Y \\<subseteq> {\\<alpha>_max}\n\ngoal (1 subgoal):\n 1. (\\<And>y.\n        \\<lbrakk>y \\<in># Y; y \\<noteq> \\<alpha>_max\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  y \\<in># Y\n  y \\<noteq> \\<alpha>_max\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># Y \\<noteq> of_nat n ^ m * \\<alpha>_max", "have \"y \\<in> X\" \"set_mset (Y - {#y#}) \\<subseteq> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> X &&& set_mset (Y - {#y#}) \\<subseteq> X", "using y that"], ["proof (prove)\nusing this:\n  y \\<in># Y\n  y \\<noteq> \\<alpha>_max\n  Y \\<in> Roots_ms\n  Y \\<noteq> Y_max\n\ngoal (1 subgoal):\n 1. y \\<in> X &&& set_mset (Y - {#y#}) \\<subseteq> X", "by (auto simp: Roots_ms_def dest: in_diffD)"], ["proof (state)\nthis:\n  y \\<in> X\n  set_mset (Y - {#y#}) \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># Y \\<noteq> of_nat n ^ m * \\<alpha>_max", "hence \"y \\<le>\\<^sub>\\<complex> \\<alpha>_max\""], ["proof (prove)\nusing this:\n  y \\<in> X\n  set_mset (Y - {#y#}) \\<subseteq> X\n\ngoal (1 subgoal):\n 1. y \\<le>\\<^sub>\\<complex> \\<alpha>_max", "using y"], ["proof (prove)\nusing this:\n  y \\<in> X\n  set_mset (Y - {#y#}) \\<subseteq> X\n  y \\<in># Y\n  y \\<noteq> \\<alpha>_max\n\ngoal (1 subgoal):\n 1. y \\<le>\\<^sub>\\<complex> \\<alpha>_max", "unfolding \\<alpha>_max_def"], ["proof (prove)\nusing this:\n  y \\<in> X\n  set_mset (Y - {#y#}) \\<subseteq> X\n  y \\<in># Y\n  y \\<noteq> complex_lex.Max X\n\ngoal (1 subgoal):\n 1. y \\<le>\\<^sub>\\<complex> complex_lex.Max X", "by (intro complex_lex.Max_ge) auto"], ["proof (state)\nthis:\n  y \\<le>\\<^sub>\\<complex> \\<alpha>_max\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># Y \\<noteq> of_nat n ^ m * \\<alpha>_max", "with y"], ["proof (chain)\npicking this:\n  y \\<in># Y\n  y \\<noteq> \\<alpha>_max\n  y \\<le>\\<^sub>\\<complex> \\<alpha>_max", "have \"y <\\<^sub>\\<complex> \\<alpha>_max\""], ["proof (prove)\nusing this:\n  y \\<in># Y\n  y \\<noteq> \\<alpha>_max\n  y \\<le>\\<^sub>\\<complex> \\<alpha>_max\n\ngoal (1 subgoal):\n 1. y <\\<^sub>\\<complex> \\<alpha>_max", "by auto"], ["proof (state)\nthis:\n  y <\\<^sub>\\<complex> \\<alpha>_max\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># Y \\<noteq> of_nat n ^ m * \\<alpha>_max", "have *: \"Y = {#y#} + (Y - {#y#})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y = {#y#} + (Y - {#y#})", "using y"], ["proof (prove)\nusing this:\n  y \\<in># Y\n  y \\<noteq> \\<alpha>_max\n\ngoal (1 subgoal):\n 1. Y = {#y#} + (Y - {#y#})", "by simp"], ["proof (state)\nthis:\n  Y = {#y#} + (Y - {#y#})\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># Y \\<noteq> of_nat n ^ m * \\<alpha>_max", "have \"sum_mset Y = y + sum_mset (Y - {#y#})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># Y = y + \\<Sum>\\<^sub># (Y - {#y#})", "by (subst *) auto"], ["proof (state)\nthis:\n  \\<Sum>\\<^sub># Y = y + \\<Sum>\\<^sub># (Y - {#y#})\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># Y \\<noteq> of_nat n ^ m * \\<alpha>_max", "also"], ["proof (state)\nthis:\n  \\<Sum>\\<^sub># Y = y + \\<Sum>\\<^sub># (Y - {#y#})\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># Y \\<noteq> of_nat n ^ m * \\<alpha>_max", "have \"\\<dots> <\\<^sub>\\<complex> \\<alpha>_max + sum_mset (Y - {#y#})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y + \\<Sum>\\<^sub># (Y - {#y#}) <\\<^sub>\\<complex>\n    \\<alpha>_max + \\<Sum>\\<^sub># (Y - {#y#})", "by (intro complex_lex.add_strict_right_mono) fact"], ["proof (state)\nthis:\n  y + \\<Sum>\\<^sub># (Y - {#y#}) <\\<^sub>\\<complex>\n  \\<alpha>_max + \\<Sum>\\<^sub># (Y - {#y#})\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># Y \\<noteq> of_nat n ^ m * \\<alpha>_max", "also"], ["proof (state)\nthis:\n  y + \\<Sum>\\<^sub># (Y - {#y#}) <\\<^sub>\\<complex>\n  \\<alpha>_max + \\<Sum>\\<^sub># (Y - {#y#})\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># Y \\<noteq> of_nat n ^ m * \\<alpha>_max", "have \"\\<dots> \\<le>\\<^sub>\\<complex> \\<alpha>_max + sum_mset (replicate_mset (n ^ m - 1) \\<alpha>_max)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>_max + \\<Sum>\\<^sub># (Y - {#y#}) \\<le>\\<^sub>\\<complex>\n    \\<alpha>_max + \\<Sum>\\<^sub># (replicate_mset (n ^ m - 1) \\<alpha>_max)", "unfolding \\<alpha>_max_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_lex.Max X + \\<Sum>\\<^sub># (Y - {#y#}) \\<le>\\<^sub>\\<complex>\n    complex_lex.Max X +\n    \\<Sum>\\<^sub># (replicate_mset (n ^ m - 1) (complex_lex.Max X))", "using that y \\<open>set_mset (Y - {#y#}) \\<subseteq> X\\<close>"], ["proof (prove)\nusing this:\n  Y \\<in> Roots_ms\n  Y \\<noteq> Y_max\n  y \\<in># Y\n  y \\<noteq> \\<alpha>_max\n  set_mset (Y - {#y#}) \\<subseteq> X\n\ngoal (1 subgoal):\n 1. complex_lex.Max X + \\<Sum>\\<^sub># (Y - {#y#}) \\<le>\\<^sub>\\<complex>\n    complex_lex.Max X +\n    \\<Sum>\\<^sub># (replicate_mset (n ^ m - 1) (complex_lex.Max X))", "by (intro complex_lex.add_left_mono sum_mset_mono_complex_lex\n                  rel_mset_replicate_mset_right complex_lex.Max_ge)\n           (auto simp: Roots_ms_def size_Diff_singleton)"], ["proof (state)\nthis:\n  \\<alpha>_max + \\<Sum>\\<^sub># (Y - {#y#}) \\<le>\\<^sub>\\<complex>\n  \\<alpha>_max + \\<Sum>\\<^sub># (replicate_mset (n ^ m - 1) \\<alpha>_max)\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># Y \\<noteq> of_nat n ^ m * \\<alpha>_max", "also"], ["proof (state)\nthis:\n  \\<alpha>_max + \\<Sum>\\<^sub># (Y - {#y#}) \\<le>\\<^sub>\\<complex>\n  \\<alpha>_max + \\<Sum>\\<^sub># (replicate_mset (n ^ m - 1) \\<alpha>_max)\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># Y \\<noteq> of_nat n ^ m * \\<alpha>_max", "have \"\\<dots> = of_nat (Suc (n ^ m - 1)) * \\<alpha>_max\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<alpha>_max +\n    \\<Sum>\\<^sub># (replicate_mset (n ^ m - 1) \\<alpha>_max) =\n    of_nat (Suc (n ^ m - 1)) * \\<alpha>_max", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  \\<alpha>_max + \\<Sum>\\<^sub># (replicate_mset (n ^ m - 1) \\<alpha>_max) =\n  of_nat (Suc (n ^ m - 1)) * \\<alpha>_max\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># Y \\<noteq> of_nat n ^ m * \\<alpha>_max", "also"], ["proof (state)\nthis:\n  \\<alpha>_max + \\<Sum>\\<^sub># (replicate_mset (n ^ m - 1) \\<alpha>_max) =\n  of_nat (Suc (n ^ m - 1)) * \\<alpha>_max\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># Y \\<noteq> of_nat n ^ m * \\<alpha>_max", "have \"Suc (n ^ m - 1) = n ^ m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Suc (n ^ m - 1) = n ^ m", "using \\<open>n > 0\\<close>"], ["proof (prove)\nusing this:\n  0 < n\n\ngoal (1 subgoal):\n 1. Suc (n ^ m - 1) = n ^ m", "by simp"], ["proof (state)\nthis:\n  Suc (n ^ m - 1) = n ^ m\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># Y \\<noteq> of_nat n ^ m * \\<alpha>_max", "finally"], ["proof (chain)\npicking this:\n  \\<Sum>\\<^sub># Y <\\<^sub>\\<complex> of_nat (n ^ m) * \\<alpha>_max", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Sum>\\<^sub># Y <\\<^sub>\\<complex> of_nat (n ^ m) * \\<alpha>_max\n\ngoal (1 subgoal):\n 1. \\<Sum>\\<^sub># Y \\<noteq> of_nat n ^ m * \\<alpha>_max", "by simp"], ["proof (state)\nthis:\n  \\<Sum>\\<^sub># Y \\<noteq> of_nat n ^ m * \\<alpha>_max\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?Y \\<in> Roots_ms; ?Y \\<noteq> Y_max\\<rbrakk>\n  \\<Longrightarrow> \\<Sum>\\<^sub># ?Y \\<noteq> of_nat n ^ m * \\<alpha>_max\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0", "hence \"(\\<Sum>Y\\<in>Roots_ms. \\<beta>'' Y when \\<Sum>\\<^sub># Y = of_nat (n ^ m) * \\<alpha>_max) = (\\<Sum>Y\\<in>{Y_max}. \\<beta>'' Y when \\<Sum>\\<^sub># Y = of_nat (n ^ m) * \\<alpha>_max)\""], ["proof (prove)\nusing this:\n  \\<lbrakk>?Y \\<in> Roots_ms; ?Y \\<noteq> Y_max\\<rbrakk>\n  \\<Longrightarrow> \\<Sum>\\<^sub># ?Y \\<noteq> of_nat n ^ m * \\<alpha>_max\n\ngoal (1 subgoal):\n 1. (\\<Sum>Y\\<in>Roots_ms.\n       \\<beta>'' Y when \\<Sum>\\<^sub># Y = of_nat (n ^ m) * \\<alpha>_max) =\n    (\\<Sum>Y\\<in>{Y_max}.\n       \\<beta>'' Y when \\<Sum>\\<^sub># Y = of_nat (n ^ m) * \\<alpha>_max)", "by (intro sum.mono_neutral_right ballI) auto"], ["proof (state)\nthis:\n  (\\<Sum>Y\\<in>Roots_ms.\n     \\<beta>'' Y when \\<Sum>\\<^sub># Y = of_nat (n ^ m) * \\<alpha>_max) =\n  (\\<Sum>Y\\<in>{Y_max}.\n     \\<beta>'' Y when \\<Sum>\\<^sub># Y = of_nat (n ^ m) * \\<alpha>_max)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0", "also"], ["proof (state)\nthis:\n  (\\<Sum>Y\\<in>Roots_ms.\n     \\<beta>'' Y when \\<Sum>\\<^sub># Y = of_nat (n ^ m) * \\<alpha>_max) =\n  (\\<Sum>Y\\<in>{Y_max}.\n     \\<beta>'' Y when \\<Sum>\\<^sub># Y = of_nat (n ^ m) * \\<alpha>_max)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0", "have \"\\<dots> = \\<beta>'' Y_max\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>Y\\<in>{Y_max}.\n       \\<beta>'' Y when \\<Sum>\\<^sub># Y = of_nat (n ^ m) * \\<alpha>_max) =\n    \\<beta>'' Y_max", "by (auto simp: when_def Y_max_def)"], ["proof (state)\nthis:\n  (\\<Sum>Y\\<in>{Y_max}.\n     \\<beta>'' Y when \\<Sum>\\<^sub># Y = of_nat (n ^ m) * \\<alpha>_max) =\n  \\<beta>'' Y_max\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0", "also"], ["proof (state)\nthis:\n  (\\<Sum>Y\\<in>{Y_max}.\n     \\<beta>'' Y when \\<Sum>\\<^sub># Y = of_nat (n ^ m) * \\<alpha>_max) =\n  \\<beta>'' Y_max\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0", "have \"of_rat \\<dots> = \\<beta>' Y_max\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_rat (\\<beta>'' Y_max) = \\<beta>' Y_max", "using \\<beta>''[of Y_max]"], ["proof (prove)\nusing this:\n  Y_max \\<in> Roots_ms \\<Longrightarrow>\n  \\<beta>' Y_max = of_rat (\\<beta>'' Y_max)\n\ngoal (1 subgoal):\n 1. of_rat (\\<beta>'' Y_max) = \\<beta>' Y_max", "by auto"], ["proof (state)\nthis:\n  of_rat (\\<beta>'' Y_max) = \\<beta>' Y_max\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0", "also"], ["proof (state)\nthis:\n  of_rat (\\<beta>'' Y_max) = \\<beta>' Y_max\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0", "have \"\\<dots> = (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g (f_max g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<beta>' Y_max =\n    (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g (f_max g))", "by (auto simp: \\<beta>'_def \\<open>tuples Y_max = {f_max}\\<close>)"], ["proof (state)\nthis:\n  \\<beta>' Y_max = (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g (f_max g))\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0", "also"], ["proof (state)\nthis:\n  \\<beta>' Y_max = (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g (f_max g))\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0", "have \"\\<dots> = (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g \\<alpha>_max)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g (f_max g)) =\n    (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g \\<alpha>_max)", "by (intro prod.cong) (auto simp: f_max_def)"], ["proof (state)\nthis:\n  (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g (f_max g)) =\n  (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g \\<alpha>_max)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0", "also"], ["proof (state)\nthis:\n  (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g (f_max g)) =\n  (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g \\<alpha>_max)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0", "have \"\\<dots> \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g \\<alpha>_max) \\<noteq> 0", "using \\<open>0 \\<notin> Roots\\<close> \\<open>\\<alpha>_max \\<in> X\\<close>"], ["proof (prove)\nusing this:\n  0 \\<notin> Roots\n  \\<alpha>_max \\<in> X\n\ngoal (1 subgoal):\n 1. (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g \\<alpha>_max) \\<noteq> 0", "by (intro prod_nonzeroI) (metis PiE_mem)"], ["proof (state)\nthis:\n  (\\<Prod>g\\<in>X \\<rightarrow>\\<^sub>E Roots. g \\<alpha>_max) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0", "finally"], ["proof (chain)\npicking this:\n  of_rat (\\<beta>''' (of_nat (n ^ m) * \\<alpha>_max)) \\<noteq> 0", "show ?thesis"], ["proof (prove)\nusing this:\n  of_rat (\\<beta>''' (of_nat (n ^ m) * \\<alpha>_max)) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<exists>\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0", "by blast"], ["proof (state)\nthis:\n  \\<exists>\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. X \\<noteq> {} \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  {\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0} = {}\n  \\<exists>\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0", "show False"], ["proof (prove)\nusing this:\n  {\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0} = {}\n  \\<exists>\\<alpha>. \\<beta>''' \\<alpha> \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The final theorem\\<close>"], ["", "text \\<open>\n  We now additionally allow some of the $\\beta_i$ to be zero:\n\\<close>"], ["", "lemma Hermite_Lindemann':\n  fixes \\<beta> :: \"complex \\<Rightarrow> complex\"\n  assumes \"finite X\"\n  assumes \"\\<And>x. x \\<in> X \\<Longrightarrow> algebraic x\"\n  assumes \"\\<And>x. x \\<in> X \\<Longrightarrow> algebraic (\\<beta> x)\"\n  assumes \"(\\<Sum>x\\<in>X. \\<beta> x * exp x) = 0\"\n  shows   \"\\<forall>x\\<in>X. \\<beta> x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>X. \\<beta> x = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>X. \\<beta> x = 0", "have \"{x\\<in>X. \\<beta> x \\<noteq> 0} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x \\<in> X. \\<beta> x \\<noteq> 0} = {}", "proof (rule Hermite_Lindemann_aux4)"], ["proof (state)\ngoal (5 subgoals):\n 1. finite {x \\<in> X. \\<beta> x \\<noteq> 0}\n 2. \\<And>x.\n       x \\<in> {x \\<in> X. \\<beta> x \\<noteq> 0} \\<Longrightarrow>\n       algebraic x\n 3. \\<And>x.\n       x \\<in> {x \\<in> X. \\<beta> x \\<noteq> 0} \\<Longrightarrow>\n       algebraic (?\\<beta> x)\n 4. \\<And>x.\n       x \\<in> {x \\<in> X. \\<beta> x \\<noteq> 0} \\<Longrightarrow>\n       ?\\<beta> x \\<noteq> 0\n 5. (\\<Sum>x | x \\<in> X \\<and> \\<beta> x \\<noteq> 0. ?\\<beta> x * exp x) =\n    0", "have \"(\\<Sum>x | x \\<in> X \\<and> \\<beta> x \\<noteq> 0. \\<beta> x * exp x) = (\\<Sum>x\\<in>X. \\<beta> x * exp x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x | x \\<in> X \\<and> \\<beta> x \\<noteq> 0. \\<beta> x * exp x) =\n    (\\<Sum>x\\<in>X. \\<beta> x * exp x)", "by (intro sum.mono_neutral_left assms(1)) auto"], ["proof (state)\nthis:\n  (\\<Sum>x | x \\<in> X \\<and> \\<beta> x \\<noteq> 0. \\<beta> x * exp x) =\n  (\\<Sum>x\\<in>X. \\<beta> x * exp x)\n\ngoal (5 subgoals):\n 1. finite {x \\<in> X. \\<beta> x \\<noteq> 0}\n 2. \\<And>x.\n       x \\<in> {x \\<in> X. \\<beta> x \\<noteq> 0} \\<Longrightarrow>\n       algebraic x\n 3. \\<And>x.\n       x \\<in> {x \\<in> X. \\<beta> x \\<noteq> 0} \\<Longrightarrow>\n       algebraic (?\\<beta> x)\n 4. \\<And>x.\n       x \\<in> {x \\<in> X. \\<beta> x \\<noteq> 0} \\<Longrightarrow>\n       ?\\<beta> x \\<noteq> 0\n 5. (\\<Sum>x | x \\<in> X \\<and> \\<beta> x \\<noteq> 0. ?\\<beta> x * exp x) =\n    0", "also"], ["proof (state)\nthis:\n  (\\<Sum>x | x \\<in> X \\<and> \\<beta> x \\<noteq> 0. \\<beta> x * exp x) =\n  (\\<Sum>x\\<in>X. \\<beta> x * exp x)\n\ngoal (5 subgoals):\n 1. finite {x \\<in> X. \\<beta> x \\<noteq> 0}\n 2. \\<And>x.\n       x \\<in> {x \\<in> X. \\<beta> x \\<noteq> 0} \\<Longrightarrow>\n       algebraic x\n 3. \\<And>x.\n       x \\<in> {x \\<in> X. \\<beta> x \\<noteq> 0} \\<Longrightarrow>\n       algebraic (?\\<beta> x)\n 4. \\<And>x.\n       x \\<in> {x \\<in> X. \\<beta> x \\<noteq> 0} \\<Longrightarrow>\n       ?\\<beta> x \\<noteq> 0\n 5. (\\<Sum>x | x \\<in> X \\<and> \\<beta> x \\<noteq> 0. ?\\<beta> x * exp x) =\n    0", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>X. \\<beta> x * exp x) = 0", "by fact"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>X. \\<beta> x * exp x) = 0\n\ngoal (5 subgoals):\n 1. finite {x \\<in> X. \\<beta> x \\<noteq> 0}\n 2. \\<And>x.\n       x \\<in> {x \\<in> X. \\<beta> x \\<noteq> 0} \\<Longrightarrow>\n       algebraic x\n 3. \\<And>x.\n       x \\<in> {x \\<in> X. \\<beta> x \\<noteq> 0} \\<Longrightarrow>\n       algebraic (?\\<beta> x)\n 4. \\<And>x.\n       x \\<in> {x \\<in> X. \\<beta> x \\<noteq> 0} \\<Longrightarrow>\n       ?\\<beta> x \\<noteq> 0\n 5. (\\<Sum>x | x \\<in> X \\<and> \\<beta> x \\<noteq> 0. ?\\<beta> x * exp x) =\n    0", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>x | x \\<in> X \\<and> \\<beta> x \\<noteq> 0. \\<beta> x * exp x) = 0", "show \"(\\<Sum>x | x \\<in> X \\<and> \\<beta> x \\<noteq> 0. \\<beta> x * exp x) = 0\""], ["proof (prove)\nusing this:\n  (\\<Sum>x | x \\<in> X \\<and> \\<beta> x \\<noteq> 0. \\<beta> x * exp x) = 0\n\ngoal (1 subgoal):\n 1. (\\<Sum>x | x \\<in> X \\<and> \\<beta> x \\<noteq> 0. \\<beta> x * exp x) = 0", "."], ["proof (state)\nthis:\n  (\\<Sum>x | x \\<in> X \\<and> \\<beta> x \\<noteq> 0. \\<beta> x * exp x) = 0\n\ngoal (4 subgoals):\n 1. finite {x \\<in> X. \\<beta> x \\<noteq> 0}\n 2. \\<And>x.\n       x \\<in> {x \\<in> X. \\<beta> x \\<noteq> 0} \\<Longrightarrow>\n       algebraic x\n 3. \\<And>x.\n       x \\<in> {x \\<in> X. \\<beta> x \\<noteq> 0} \\<Longrightarrow>\n       algebraic (\\<beta> x)\n 4. \\<And>x.\n       x \\<in> {x \\<in> X. \\<beta> x \\<noteq> 0} \\<Longrightarrow>\n       \\<beta> x \\<noteq> 0", "qed (use assms in auto)"], ["proof (state)\nthis:\n  {x \\<in> X. \\<beta> x \\<noteq> 0} = {}\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>X. \\<beta> x = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  {x \\<in> X. \\<beta> x \\<noteq> 0} = {}\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>X. \\<beta> x = 0", "by blast"], ["proof (state)\nthis:\n  \\<forall>x\\<in>X. \\<beta> x = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Lastly, we switch to indexed summation in order to obtain a version of the theorem that\n  is somewhat nicer to use:\n\\<close>"], ["", "theorem Hermite_Lindemann:\n  fixes \\<alpha> \\<beta> :: \"'a \\<Rightarrow> complex\"\n  assumes \"finite I\"\n  assumes \"\\<And>x. x \\<in> I \\<Longrightarrow> algebraic (\\<alpha> x)\"\n  assumes \"\\<And>x. x \\<in> I \\<Longrightarrow> algebraic (\\<beta> x)\"\n  assumes \"inj_on \\<alpha> I\"\n  assumes \"(\\<Sum>x\\<in>I. \\<beta> x * exp (\\<alpha> x)) = 0\"\n  shows   \"\\<forall>x\\<in>I. \\<beta> x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>I. \\<beta> x = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>I. \\<beta> x = 0", "define f where \"f = inv_into I \\<alpha>\""], ["proof (state)\nthis:\n  f = inv_into I \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>I. \\<beta> x = 0", "have [simp]: \"f (\\<alpha> x) = x\" if \"x \\<in> I\" for x"], ["proof (prove)\ngoal (1 subgoal):\n 1. f (\\<alpha> x) = x", "using that"], ["proof (prove)\nusing this:\n  x \\<in> I\n\ngoal (1 subgoal):\n 1. f (\\<alpha> x) = x", "by (auto simp: f_def inv_into_f_f[OF assms(4)])"], ["proof (state)\nthis:\n  ?x \\<in> I \\<Longrightarrow> f (\\<alpha> ?x) = ?x\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>I. \\<beta> x = 0", "have \"\\<forall>x\\<in>\\<alpha>`I. (\\<beta> \\<circ> f) x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>\\<alpha> ` I. (\\<beta> \\<circ> f) x = 0", "proof (rule Hermite_Lindemann')"], ["proof (state)\ngoal (4 subgoals):\n 1. finite (\\<alpha> ` I)\n 2. \\<And>x. x \\<in> \\<alpha> ` I \\<Longrightarrow> algebraic x\n 3. \\<And>x.\n       x \\<in> \\<alpha> ` I \\<Longrightarrow>\n       algebraic ((\\<beta> \\<circ> f) x)\n 4. (\\<Sum>x\\<in>\\<alpha> ` I. (\\<beta> \\<circ> f) x * exp x) = 0", "have \"0 = (\\<Sum>x\\<in>I. \\<beta> x * exp (\\<alpha> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = (\\<Sum>x\\<in>I. \\<beta> x * exp (\\<alpha> x))", "using assms(5)"], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>I. \\<beta> x * exp (\\<alpha> x)) = 0\n\ngoal (1 subgoal):\n 1. 0 = (\\<Sum>x\\<in>I. \\<beta> x * exp (\\<alpha> x))", ".."], ["proof (state)\nthis:\n  0 = (\\<Sum>x\\<in>I. \\<beta> x * exp (\\<alpha> x))\n\ngoal (4 subgoals):\n 1. finite (\\<alpha> ` I)\n 2. \\<And>x. x \\<in> \\<alpha> ` I \\<Longrightarrow> algebraic x\n 3. \\<And>x.\n       x \\<in> \\<alpha> ` I \\<Longrightarrow>\n       algebraic ((\\<beta> \\<circ> f) x)\n 4. (\\<Sum>x\\<in>\\<alpha> ` I. (\\<beta> \\<circ> f) x * exp x) = 0", "also"], ["proof (state)\nthis:\n  0 = (\\<Sum>x\\<in>I. \\<beta> x * exp (\\<alpha> x))\n\ngoal (4 subgoals):\n 1. finite (\\<alpha> ` I)\n 2. \\<And>x. x \\<in> \\<alpha> ` I \\<Longrightarrow> algebraic x\n 3. \\<And>x.\n       x \\<in> \\<alpha> ` I \\<Longrightarrow>\n       algebraic ((\\<beta> \\<circ> f) x)\n 4. (\\<Sum>x\\<in>\\<alpha> ` I. (\\<beta> \\<circ> f) x * exp x) = 0", "have \"\\<dots> = (\\<Sum>x\\<in>I. (\\<beta> \\<circ> f) (\\<alpha> x) * exp (\\<alpha> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>I. \\<beta> x * exp (\\<alpha> x)) =\n    (\\<Sum>x\\<in>I. (\\<beta> \\<circ> f) (\\<alpha> x) * exp (\\<alpha> x))", "by (intro sum.cong) auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>I. \\<beta> x * exp (\\<alpha> x)) =\n  (\\<Sum>x\\<in>I. (\\<beta> \\<circ> f) (\\<alpha> x) * exp (\\<alpha> x))\n\ngoal (4 subgoals):\n 1. finite (\\<alpha> ` I)\n 2. \\<And>x. x \\<in> \\<alpha> ` I \\<Longrightarrow> algebraic x\n 3. \\<And>x.\n       x \\<in> \\<alpha> ` I \\<Longrightarrow>\n       algebraic ((\\<beta> \\<circ> f) x)\n 4. (\\<Sum>x\\<in>\\<alpha> ` I. (\\<beta> \\<circ> f) x * exp x) = 0", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>I. \\<beta> x * exp (\\<alpha> x)) =\n  (\\<Sum>x\\<in>I. (\\<beta> \\<circ> f) (\\<alpha> x) * exp (\\<alpha> x))\n\ngoal (4 subgoals):\n 1. finite (\\<alpha> ` I)\n 2. \\<And>x. x \\<in> \\<alpha> ` I \\<Longrightarrow> algebraic x\n 3. \\<And>x.\n       x \\<in> \\<alpha> ` I \\<Longrightarrow>\n       algebraic ((\\<beta> \\<circ> f) x)\n 4. (\\<Sum>x\\<in>\\<alpha> ` I. (\\<beta> \\<circ> f) x * exp x) = 0", "have \"\\<dots> = (\\<Sum>x\\<in>\\<alpha>`I. (\\<beta> \\<circ> f) x * exp x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>I. (\\<beta> \\<circ> f) (\\<alpha> x) * exp (\\<alpha> x)) =\n    (\\<Sum>x\\<in>\\<alpha> ` I. (\\<beta> \\<circ> f) x * exp x)", "using assms(4)"], ["proof (prove)\nusing this:\n  inj_on \\<alpha> I\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>I. (\\<beta> \\<circ> f) (\\<alpha> x) * exp (\\<alpha> x)) =\n    (\\<Sum>x\\<in>\\<alpha> ` I. (\\<beta> \\<circ> f) x * exp x)", "by (subst sum.reindex) auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>I. (\\<beta> \\<circ> f) (\\<alpha> x) * exp (\\<alpha> x)) =\n  (\\<Sum>x\\<in>\\<alpha> ` I. (\\<beta> \\<circ> f) x * exp x)\n\ngoal (4 subgoals):\n 1. finite (\\<alpha> ` I)\n 2. \\<And>x. x \\<in> \\<alpha> ` I \\<Longrightarrow> algebraic x\n 3. \\<And>x.\n       x \\<in> \\<alpha> ` I \\<Longrightarrow>\n       algebraic ((\\<beta> \\<circ> f) x)\n 4. (\\<Sum>x\\<in>\\<alpha> ` I. (\\<beta> \\<circ> f) x * exp x) = 0", "finally"], ["proof (chain)\npicking this:\n  0 = (\\<Sum>x\\<in>\\<alpha> ` I. (\\<beta> \\<circ> f) x * exp x)", "show \"(\\<Sum>x\\<in>\\<alpha> ` I. (\\<beta> \\<circ> f) x * exp x) = 0\""], ["proof (prove)\nusing this:\n  0 = (\\<Sum>x\\<in>\\<alpha> ` I. (\\<beta> \\<circ> f) x * exp x)\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>\\<alpha> ` I. (\\<beta> \\<circ> f) x * exp x) = 0", ".."], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>\\<alpha> ` I. (\\<beta> \\<circ> f) x * exp x) = 0\n\ngoal (3 subgoals):\n 1. finite (\\<alpha> ` I)\n 2. \\<And>x. x \\<in> \\<alpha> ` I \\<Longrightarrow> algebraic x\n 3. \\<And>x.\n       x \\<in> \\<alpha> ` I \\<Longrightarrow>\n       algebraic ((\\<beta> \\<circ> f) x)", "qed (use assms in auto)"], ["proof (state)\nthis:\n  \\<forall>x\\<in>\\<alpha> ` I. (\\<beta> \\<circ> f) x = 0\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>I. \\<beta> x = 0", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>\\<alpha> ` I. (\\<beta> \\<circ> f) x = 0\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>I. \\<beta> x = 0", "by auto"], ["proof (state)\nthis:\n  \\<forall>x\\<in>I. \\<beta> x = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  The following version using lists instead of sequences is even more convenient to use\n  in practice:\n\\<close>"], ["", "corollary Hermite_Lindemann_list:\n  fixes xs :: \"(complex \\<times> complex) list\"\n  assumes alg:      \"\\<forall>(x,y)\\<in>set xs. algebraic x \\<and> algebraic y\"\n  assumes distinct: \"distinct (map snd xs)\"\n  assumes sum0:     \"(\\<Sum>(c,\\<alpha>)\\<leftarrow>xs. c * exp \\<alpha>) = 0\"\n  shows   \"\\<forall>c\\<in>(fst ` set xs). c = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>fst ` set xs. c = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>fst ` set xs. c = 0", "define n where \"n = length xs\""], ["proof (state)\nthis:\n  n = length xs\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>fst ` set xs. c = 0", "have *: \"\\<forall>i\\<in>{..<n}. fst (xs ! i) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i\\<in>{..<n}. fst (xs ! i) = 0", "proof (rule Hermite_Lindemann)"], ["proof (state)\ngoal (5 subgoals):\n 1. finite {..<n}\n 2. \\<And>i. i \\<in> {..<n} \\<Longrightarrow> algebraic (?\\<alpha> i)\n 3. \\<And>i. i \\<in> {..<n} \\<Longrightarrow> algebraic (fst (xs ! i))\n 4. inj_on ?\\<alpha> {..<n}\n 5. (\\<Sum>i<n. fst (xs ! i) * exp (?\\<alpha> i)) = 0", "from distinct"], ["proof (chain)\npicking this:\n  distinct (map snd xs)", "have \"inj_on (\\<lambda>i. map snd xs ! i) {..<n}\""], ["proof (prove)\nusing this:\n  distinct (map snd xs)\n\ngoal (1 subgoal):\n 1. inj_on ((!) (map snd xs)) {..<n}", "by (intro inj_on_nth) (auto simp: n_def)"], ["proof (state)\nthis:\n  inj_on ((!) (map snd xs)) {..<n}\n\ngoal (5 subgoals):\n 1. finite {..<n}\n 2. \\<And>i. i \\<in> {..<n} \\<Longrightarrow> algebraic (?\\<alpha> i)\n 3. \\<And>i. i \\<in> {..<n} \\<Longrightarrow> algebraic (fst (xs ! i))\n 4. inj_on ?\\<alpha> {..<n}\n 5. (\\<Sum>i<n. fst (xs ! i) * exp (?\\<alpha> i)) = 0", "also"], ["proof (state)\nthis:\n  inj_on ((!) (map snd xs)) {..<n}\n\ngoal (5 subgoals):\n 1. finite {..<n}\n 2. \\<And>i. i \\<in> {..<n} \\<Longrightarrow> algebraic (?\\<alpha> i)\n 3. \\<And>i. i \\<in> {..<n} \\<Longrightarrow> algebraic (fst (xs ! i))\n 4. inj_on ?\\<alpha> {..<n}\n 5. (\\<Sum>i<n. fst (xs ! i) * exp (?\\<alpha> i)) = 0", "have \"?this \\<longleftrightarrow> inj_on (\\<lambda>i. snd (xs ! i)) {..<n}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on ((!) (map snd xs)) {..<n} =\n    inj_on (\\<lambda>i. snd (xs ! i)) {..<n}", "by (intro inj_on_cong) (auto simp: n_def)"], ["proof (state)\nthis:\n  inj_on ((!) (map snd xs)) {..<n} =\n  inj_on (\\<lambda>i. snd (xs ! i)) {..<n}\n\ngoal (5 subgoals):\n 1. finite {..<n}\n 2. \\<And>i. i \\<in> {..<n} \\<Longrightarrow> algebraic (?\\<alpha> i)\n 3. \\<And>i. i \\<in> {..<n} \\<Longrightarrow> algebraic (fst (xs ! i))\n 4. inj_on ?\\<alpha> {..<n}\n 5. (\\<Sum>i<n. fst (xs ! i) * exp (?\\<alpha> i)) = 0", "finally"], ["proof (chain)\npicking this:\n  inj_on (\\<lambda>i. snd (xs ! i)) {..<n}", "show \"inj_on (\\<lambda>i. snd (xs ! i)) {..<n}\""], ["proof (prove)\nusing this:\n  inj_on (\\<lambda>i. snd (xs ! i)) {..<n}\n\ngoal (1 subgoal):\n 1. inj_on (\\<lambda>i. snd (xs ! i)) {..<n}", "."], ["proof (state)\nthis:\n  inj_on (\\<lambda>i. snd (xs ! i)) {..<n}\n\ngoal (4 subgoals):\n 1. finite {..<n}\n 2. \\<And>i. i \\<in> {..<n} \\<Longrightarrow> algebraic (snd (xs ! i))\n 3. \\<And>i. i \\<in> {..<n} \\<Longrightarrow> algebraic (fst (xs ! i))\n 4. (\\<Sum>i<n. fst (xs ! i) * exp (snd (xs ! i))) = 0", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. finite {..<n}\n 2. \\<And>i. i \\<in> {..<n} \\<Longrightarrow> algebraic (snd (xs ! i))\n 3. \\<And>i. i \\<in> {..<n} \\<Longrightarrow> algebraic (fst (xs ! i))\n 4. (\\<Sum>i<n. fst (xs ! i) * exp (snd (xs ! i))) = 0", "have \"0 = (\\<Sum>(c,\\<alpha>)\\<leftarrow>xs. c * exp \\<alpha>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = (\\<Sum>(c, \\<alpha>)\\<leftarrow>xs. c * exp \\<alpha>)", "using sum0"], ["proof (prove)\nusing this:\n  (\\<Sum>(c, \\<alpha>)\\<leftarrow>xs. c * exp \\<alpha>) = 0\n\ngoal (1 subgoal):\n 1. 0 = (\\<Sum>(c, \\<alpha>)\\<leftarrow>xs. c * exp \\<alpha>)", ".."], ["proof (state)\nthis:\n  0 = (\\<Sum>(c, \\<alpha>)\\<leftarrow>xs. c * exp \\<alpha>)\n\ngoal (4 subgoals):\n 1. finite {..<n}\n 2. \\<And>i. i \\<in> {..<n} \\<Longrightarrow> algebraic (snd (xs ! i))\n 3. \\<And>i. i \\<in> {..<n} \\<Longrightarrow> algebraic (fst (xs ! i))\n 4. (\\<Sum>i<n. fst (xs ! i) * exp (snd (xs ! i))) = 0", "also"], ["proof (state)\nthis:\n  0 = (\\<Sum>(c, \\<alpha>)\\<leftarrow>xs. c * exp \\<alpha>)\n\ngoal (4 subgoals):\n 1. finite {..<n}\n 2. \\<And>i. i \\<in> {..<n} \\<Longrightarrow> algebraic (snd (xs ! i))\n 3. \\<And>i. i \\<in> {..<n} \\<Longrightarrow> algebraic (fst (xs ! i))\n 4. (\\<Sum>i<n. fst (xs ! i) * exp (snd (xs ! i))) = 0", "have \"\\<dots> = (\\<Sum>i<n. fst (xs ! i) * exp (snd (xs ! i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(c, \\<alpha>)\\<leftarrow>xs. c * exp \\<alpha>) =\n    (\\<Sum>i<n. fst (xs ! i) * exp (snd (xs ! i)))", "unfolding sum_list_sum_nth"], ["proof (prove)\ngoal (1 subgoal):\n 1. sum ((!) (map (\\<lambda>(c, \\<alpha>). c * exp \\<alpha>) xs))\n     {0..<length (map (\\<lambda>(c, \\<alpha>). c * exp \\<alpha>) xs)} =\n    (\\<Sum>i<n. fst (xs ! i) * exp (snd (xs ! i)))", "by (intro sum.cong) (auto simp: n_def case_prod_unfold)"], ["proof (state)\nthis:\n  (\\<Sum>(c, \\<alpha>)\\<leftarrow>xs. c * exp \\<alpha>) =\n  (\\<Sum>i<n. fst (xs ! i) * exp (snd (xs ! i)))\n\ngoal (4 subgoals):\n 1. finite {..<n}\n 2. \\<And>i. i \\<in> {..<n} \\<Longrightarrow> algebraic (snd (xs ! i))\n 3. \\<And>i. i \\<in> {..<n} \\<Longrightarrow> algebraic (fst (xs ! i))\n 4. (\\<Sum>i<n. fst (xs ! i) * exp (snd (xs ! i))) = 0", "finally"], ["proof (chain)\npicking this:\n  0 = (\\<Sum>i<n. fst (xs ! i) * exp (snd (xs ! i)))", "show \"\\<dots> = 0\""], ["proof (prove)\nusing this:\n  0 = (\\<Sum>i<n. fst (xs ! i) * exp (snd (xs ! i)))\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. fst (xs ! i) * exp (snd (xs ! i))) = 0", ".."], ["proof (state)\nthis:\n  (\\<Sum>i<n. fst (xs ! i) * exp (snd (xs ! i))) = 0\n\ngoal (3 subgoals):\n 1. finite {..<n}\n 2. \\<And>i. i \\<in> {..<n} \\<Longrightarrow> algebraic (snd (xs ! i))\n 3. \\<And>i. i \\<in> {..<n} \\<Longrightarrow> algebraic (fst (xs ! i))", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. finite {..<n}\n 2. \\<And>i. i \\<in> {..<n} \\<Longrightarrow> algebraic (snd (xs ! i))\n 3. \\<And>i. i \\<in> {..<n} \\<Longrightarrow> algebraic (fst (xs ! i))", "fix i"], ["proof (state)\ngoal (3 subgoals):\n 1. finite {..<n}\n 2. \\<And>i. i \\<in> {..<n} \\<Longrightarrow> algebraic (snd (xs ! i))\n 3. \\<And>i. i \\<in> {..<n} \\<Longrightarrow> algebraic (fst (xs ! i))", "assume i: \"i \\<in> {..<n}\""], ["proof (state)\nthis:\n  i \\<in> {..<n}\n\ngoal (3 subgoals):\n 1. finite {..<n}\n 2. \\<And>i. i \\<in> {..<n} \\<Longrightarrow> algebraic (snd (xs ! i))\n 3. \\<And>i. i \\<in> {..<n} \\<Longrightarrow> algebraic (fst (xs ! i))", "hence \"(fst (xs ! i), snd (xs ! i)) \\<in> set xs\""], ["proof (prove)\nusing this:\n  i \\<in> {..<n}\n\ngoal (1 subgoal):\n 1. (fst (xs ! i), snd (xs ! i)) \\<in> set xs", "by (auto simp: n_def)"], ["proof (state)\nthis:\n  (fst (xs ! i), snd (xs ! i)) \\<in> set xs\n\ngoal (3 subgoals):\n 1. finite {..<n}\n 2. \\<And>i. i \\<in> {..<n} \\<Longrightarrow> algebraic (snd (xs ! i))\n 3. \\<And>i. i \\<in> {..<n} \\<Longrightarrow> algebraic (fst (xs ! i))", "with alg"], ["proof (chain)\npicking this:\n  \\<forall>(x, y)\\<in>set xs. algebraic x \\<and> algebraic y\n  (fst (xs ! i), snd (xs ! i)) \\<in> set xs", "show \"algebraic (fst (xs ! i))\" \"algebraic (snd (xs ! i))\""], ["proof (prove)\nusing this:\n  \\<forall>(x, y)\\<in>set xs. algebraic x \\<and> algebraic y\n  (fst (xs ! i), snd (xs ! i)) \\<in> set xs\n\ngoal (1 subgoal):\n 1. algebraic (fst (xs ! i)) &&& algebraic (snd (xs ! i))", "by blast+"], ["proof (state)\nthis:\n  algebraic (fst (xs ! i))\n  algebraic (snd (xs ! i))\n\ngoal (1 subgoal):\n 1. finite {..<n}", "qed auto"], ["proof (state)\nthis:\n  \\<forall>i\\<in>{..<n}. fst (xs ! i) = 0\n\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>fst ` set xs. c = 0", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>fst ` set xs. c = 0", "proof (intro ballI, elim imageE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c x.\n       \\<lbrakk>c = fst x; x \\<in> set xs\\<rbrakk> \\<Longrightarrow> c = 0", "fix c x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c x.\n       \\<lbrakk>c = fst x; x \\<in> set xs\\<rbrakk> \\<Longrightarrow> c = 0", "assume cx: \"c = fst x\" \"x \\<in> set xs\""], ["proof (state)\nthis:\n  c = fst x\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. \\<And>c x.\n       \\<lbrakk>c = fst x; x \\<in> set xs\\<rbrakk> \\<Longrightarrow> c = 0", "then"], ["proof (chain)\npicking this:\n  c = fst x\n  x \\<in> set xs", "obtain i where \"i \\<in> {..<n}\" \"x = xs ! i\""], ["proof (prove)\nusing this:\n  c = fst x\n  x \\<in> set xs\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        \\<lbrakk>i \\<in> {..<n}; x = xs ! i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: set_conv_nth n_def)"], ["proof (state)\nthis:\n  i \\<in> {..<n}\n  x = xs ! i\n\ngoal (1 subgoal):\n 1. \\<And>c x.\n       \\<lbrakk>c = fst x; x \\<in> set xs\\<rbrakk> \\<Longrightarrow> c = 0", "with * cx"], ["proof (chain)\npicking this:\n  \\<forall>i\\<in>{..<n}. fst (xs ! i) = 0\n  c = fst x\n  x \\<in> set xs\n  i \\<in> {..<n}\n  x = xs ! i", "show \"c = 0\""], ["proof (prove)\nusing this:\n  \\<forall>i\\<in>{..<n}. fst (xs ! i) = 0\n  c = fst x\n  x \\<in> set xs\n  i \\<in> {..<n}\n  x = xs ! i\n\ngoal (1 subgoal):\n 1. c = 0", "by blast"], ["proof (state)\nthis:\n  c = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>c\\<in>fst ` set xs. c = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>The traditional formulation of the theorem\\<close>"], ["", "text \\<open>\n  What we proved above was actually Baker's reformulation of the theorem. Thus, we now also derive\n  the original one, which uses linear independence and algebraic independence.\n\n  It states that if $\\alpha_1, \\ldots, \\alpha_n$ are algebraic numbers that are linearly\n  independent over \\<open>\\<int>\\<close>, then $e^{\\alpha_1}, \\ldots, e^{\\alpha_n}$ are algebraically independent\n  over \\<open>\\<rat>\\<close>.\n\\<close>"], ["", "text \\<open>\n  Linear independence over the integers is just independence of a set of complex numbers when\n  viewing the complex numbers as a \\<open>\\<int>\\<close>-module.\n\\<close>"], ["", "definition linearly_independent_over_int :: \"'a :: field_char_0 set \\<Rightarrow> bool\" where\n  \"linearly_independent_over_int = module.independent (\\<lambda>r x. of_int r * x)\""], ["", "text \\<open>\n  Algebraic independence over the rationals means that the given set \\<open>X\\<close> of numbers fulfils\n  no non-trivial polynomial equation with rational coefficients, i.e. there is no non-zero\n  multivariate polynomial with rational coefficients that, when inserting the numbers from \\<open>X\\<close>,\n  becomes zero.\n\n  Note that we could easily replace `rational coefficients' with `algebraic coefficients' here\n  and the proof would still go through without any modifications.\n\\<close>"], ["", "definition algebraically_independent_over_rat :: \"nat \\<Rightarrow> (nat \\<Rightarrow> 'a :: field_char_0) \\<Rightarrow> bool\" where\n  \"algebraically_independent_over_rat n a \\<longleftrightarrow>\n     (\\<forall>p. vars p \\<subseteq> {..<n} \\<and> (\\<forall>m. coeff p m \\<in> \\<rat>) \\<and> insertion a p = 0 \\<longrightarrow> p = 0)\""], ["", "corollary Hermite_Lindemann_original:\n  fixes n :: nat and \\<alpha> :: \"nat \\<Rightarrow> complex\"\n  assumes \"inj_on \\<alpha> {..<n}\"\n  assumes \"\\<And>i. i < n \\<Longrightarrow> algebraic (\\<alpha> i)\"\n  assumes \"linearly_independent_over_int (\\<alpha> ` {..<n})\"\n  shows   \"algebraically_independent_over_rat n (\\<lambda>i. exp (\\<alpha> i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraically_independent_over_rat n (\\<lambda>i. exp (\\<alpha> i))", "unfolding algebraically_independent_over_rat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>p.\n       vars p \\<subseteq> {..<n} \\<and>\n       (\\<forall>m. MPoly_Type.coeff p m \\<in> \\<rat>) \\<and>\n       insertion (\\<lambda>i. exp (\\<alpha> i)) p = 0 \\<longrightarrow>\n       p = 0", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>vars p \\<subseteq> {..<n};\n        \\<forall>m. MPoly_Type.coeff p m \\<in> \\<rat>;\n        insertion (\\<lambda>i. exp (\\<alpha> i)) p = 0\\<rbrakk>\n       \\<Longrightarrow> p = 0", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>vars p \\<subseteq> {..<n};\n        \\<forall>m. MPoly_Type.coeff p m \\<in> \\<rat>;\n        insertion (\\<lambda>i. exp (\\<alpha> i)) p = 0\\<rbrakk>\n       \\<Longrightarrow> p = 0", "assume p: \"vars p \\<subseteq> {..<n}\" \"\\<forall>m. coeff p m \\<in> \\<rat>\" \"insertion (\\<lambda>i. exp (\\<alpha> i)) p = 0\""], ["proof (state)\nthis:\n  vars p \\<subseteq> {..<n}\n  \\<forall>m. MPoly_Type.coeff p m \\<in> \\<rat>\n  insertion (\\<lambda>i. exp (\\<alpha> i)) p = 0\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>vars p \\<subseteq> {..<n};\n        \\<forall>m. MPoly_Type.coeff p m \\<in> \\<rat>;\n        insertion (\\<lambda>i. exp (\\<alpha> i)) p = 0\\<rbrakk>\n       \\<Longrightarrow> p = 0", "define \\<alpha>' where \"\\<alpha>' = (\\<lambda>m. \\<Sum>i<n. of_nat (lookup m i) * \\<alpha> i)\""], ["proof (state)\nthis:\n  \\<alpha>' = (\\<lambda>m. \\<Sum>i<n. of_nat (lookup m i) * \\<alpha> i)\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>vars p \\<subseteq> {..<n};\n        \\<forall>m. MPoly_Type.coeff p m \\<in> \\<rat>;\n        insertion (\\<lambda>i. exp (\\<alpha> i)) p = 0\\<rbrakk>\n       \\<Longrightarrow> p = 0", "define I where \"I = {m. coeff p m \\<noteq> 0}\""], ["proof (state)\nthis:\n  I = {m. MPoly_Type.coeff p m \\<noteq> 0}\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>vars p \\<subseteq> {..<n};\n        \\<forall>m. MPoly_Type.coeff p m \\<in> \\<rat>;\n        insertion (\\<lambda>i. exp (\\<alpha> i)) p = 0\\<rbrakk>\n       \\<Longrightarrow> p = 0", "have lookup_eq_0: \"lookup m i = 0\" if \"m \\<in> I\" \"i \\<notin> {..<n}\" for i m"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup m i = 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lookup m i = 0", "have \"keys m \\<subseteq> vars p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. keys m \\<subseteq> vars p", "using that coeff_notin_vars[of m p]"], ["proof (prove)\nusing this:\n  m \\<in> I\n  i \\<notin> {..<n}\n  \\<not> keys m \\<subseteq> vars p \\<Longrightarrow>\n  MPoly_Type.coeff p m = 0\n\ngoal (1 subgoal):\n 1. keys m \\<subseteq> vars p", "by (auto simp: I_def)"], ["proof (state)\nthis:\n  keys m \\<subseteq> vars p\n\ngoal (1 subgoal):\n 1. lookup m i = 0", "thus \"lookup m i = 0\""], ["proof (prove)\nusing this:\n  keys m \\<subseteq> vars p\n\ngoal (1 subgoal):\n 1. lookup m i = 0", "using in_keys_iff[of i m] that p(1)"], ["proof (prove)\nusing this:\n  keys m \\<subseteq> vars p\n  (i \\<in> keys m) = (lookup m i \\<noteq> 0)\n  m \\<in> I\n  i \\<notin> {..<n}\n  vars p \\<subseteq> {..<n}\n\ngoal (1 subgoal):\n 1. lookup m i = 0", "by blast"], ["proof (state)\nthis:\n  lookup m i = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?m \\<in> I; ?i \\<notin> {..<n}\\<rbrakk>\n  \\<Longrightarrow> lookup ?m ?i = 0\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>vars p \\<subseteq> {..<n};\n        \\<forall>m. MPoly_Type.coeff p m \\<in> \\<rat>;\n        insertion (\\<lambda>i. exp (\\<alpha> i)) p = 0\\<rbrakk>\n       \\<Longrightarrow> p = 0", "have \"\\<forall>x\\<in>I. coeff p x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>I. MPoly_Type.coeff p x = 0", "proof (rule Hermite_Lindemann)"], ["proof (state)\ngoal (5 subgoals):\n 1. finite I\n 2. \\<And>x. x \\<in> I \\<Longrightarrow> algebraic (?\\<alpha> x)\n 3. \\<And>x. x \\<in> I \\<Longrightarrow> algebraic (MPoly_Type.coeff p x)\n 4. inj_on ?\\<alpha> I\n 5. (\\<Sum>x\\<in>I. MPoly_Type.coeff p x * exp (?\\<alpha> x)) = 0", "show \"finite I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite I", "by (auto simp: I_def)"], ["proof (state)\nthis:\n  finite I\n\ngoal (4 subgoals):\n 1. \\<And>x. x \\<in> I \\<Longrightarrow> algebraic (?\\<alpha> x)\n 2. \\<And>x. x \\<in> I \\<Longrightarrow> algebraic (MPoly_Type.coeff p x)\n 3. inj_on ?\\<alpha> I\n 4. (\\<Sum>x\\<in>I. MPoly_Type.coeff p x * exp (?\\<alpha> x)) = 0", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>x. x \\<in> I \\<Longrightarrow> algebraic (?\\<alpha> x)\n 2. \\<And>x. x \\<in> I \\<Longrightarrow> algebraic (MPoly_Type.coeff p x)\n 3. inj_on ?\\<alpha> I\n 4. (\\<Sum>x\\<in>I. MPoly_Type.coeff p x * exp (?\\<alpha> x)) = 0", "show \"algebraic (\\<alpha>' m)\" if \"m \\<in> I\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic (\\<alpha>' m)", "unfolding \\<alpha>'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic (\\<Sum>i<n. of_nat (lookup m i) * \\<alpha> i)", "using assms(2)"], ["proof (prove)\nusing this:\n  ?i < n \\<Longrightarrow> algebraic (\\<alpha> ?i)\n\ngoal (1 subgoal):\n 1. algebraic (\\<Sum>i<n. of_nat (lookup m i) * \\<alpha> i)", "by fastforce"], ["proof (state)\nthis:\n  ?m \\<in> I \\<Longrightarrow> algebraic (\\<alpha>' ?m)\n\ngoal (3 subgoals):\n 1. \\<And>x. x \\<in> I \\<Longrightarrow> algebraic (MPoly_Type.coeff p x)\n 2. inj_on \\<alpha>' I\n 3. (\\<Sum>x\\<in>I. MPoly_Type.coeff p x * exp (\\<alpha>' x)) = 0", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<in> I \\<Longrightarrow> algebraic (MPoly_Type.coeff p x)\n 2. inj_on \\<alpha>' I\n 3. (\\<Sum>x\\<in>I. MPoly_Type.coeff p x * exp (\\<alpha>' x)) = 0", "show \"algebraic (coeff p m)\" if \"m \\<in> I\" for m"], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic (MPoly_Type.coeff p m)", "unfolding \\<alpha>'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic (MPoly_Type.coeff p m)", "using p(2)"], ["proof (prove)\nusing this:\n  \\<forall>m. MPoly_Type.coeff p m \\<in> \\<rat>\n\ngoal (1 subgoal):\n 1. algebraic (MPoly_Type.coeff p m)", "by blast"], ["proof (state)\nthis:\n  ?m \\<in> I \\<Longrightarrow> algebraic (MPoly_Type.coeff p ?m)\n\ngoal (2 subgoals):\n 1. inj_on \\<alpha>' I\n 2. (\\<Sum>x\\<in>I. MPoly_Type.coeff p x * exp (\\<alpha>' x)) = 0", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on \\<alpha>' I\n 2. (\\<Sum>x\\<in>I. MPoly_Type.coeff p x * exp (\\<alpha>' x)) = 0", "show \"inj_on \\<alpha>' I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on \\<alpha>' I", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> I; y \\<in> I; \\<alpha>' x = \\<alpha>' y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix m1 m2"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> I; y \\<in> I; \\<alpha>' x = \\<alpha>' y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume m12: \"m1 \\<in> I\" \"m2 \\<in> I\" \"\\<alpha>' m1 = \\<alpha>' m2\""], ["proof (state)\nthis:\n  m1 \\<in> I\n  m2 \\<in> I\n  \\<alpha>' m1 = \\<alpha>' m2\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> I; y \\<in> I; \\<alpha>' x = \\<alpha>' y\\<rbrakk>\n       \\<Longrightarrow> x = y", "define lu :: \"(nat \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow> nat \\<Rightarrow> int\" where \"lu = (\\<lambda>m i. int (lookup m i))\""], ["proof (state)\nthis:\n  lu = (\\<lambda>m i. int (lookup m i))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> I; y \\<in> I; \\<alpha>' x = \\<alpha>' y\\<rbrakk>\n       \\<Longrightarrow> x = y", "interpret int: Modules.module \"\\<lambda>r x. of_int r * (x :: complex)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Modules.module (\\<lambda>r. (*) (of_int r))", "by standard (auto simp: algebra_simps of_rat_mult of_rat_add)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> I; y \\<in> I; \\<alpha>' x = \\<alpha>' y\\<rbrakk>\n       \\<Longrightarrow> x = y", "define idx where \"idx = inv_into {..<n} \\<alpha>\""], ["proof (state)\nthis:\n  idx = inv_into {..<n} \\<alpha>\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> I; y \\<in> I; \\<alpha>' x = \\<alpha>' y\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"lu m1 i = lu m2 i\" if \"i < n\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. lu m1 i = lu m2 i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. lu m1 i = lu m2 i", "have \"lu m1 (idx (\\<alpha> i)) - lu m2 (idx (\\<alpha> i)) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lu m1 (idx (\\<alpha> i)) - lu m2 (idx (\\<alpha> i)) = 0", "proof (rule int.independentD)"], ["proof (state)\ngoal (5 subgoals):\n 1. int.independent ?s\n 2. finite ?t\n 3. ?t \\<subseteq> ?s\n 4. (\\<Sum>v\\<in>?t. of_int (lu m1 (idx v) - lu m2 (idx v)) * v) = 0\n 5. \\<alpha> i \\<in> ?t", "show \"int.independent (\\<alpha> ` {..<n})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int.independent (\\<alpha> ` {..<n})", "using assms(3)"], ["proof (prove)\nusing this:\n  linearly_independent_over_int (\\<alpha> ` {..<n})\n\ngoal (1 subgoal):\n 1. int.independent (\\<alpha> ` {..<n})", "by (simp add: linearly_independent_over_int_def)"], ["proof (state)\nthis:\n  int.independent (\\<alpha> ` {..<n})\n\ngoal (4 subgoals):\n 1. finite ?t\n 2. ?t \\<subseteq> \\<alpha> ` {..<n}\n 3. (\\<Sum>v\\<in>?t. of_int (lu m1 (idx v) - lu m2 (idx v)) * v) = 0\n 4. \\<alpha> i \\<in> ?t", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. finite ?t\n 2. ?t \\<subseteq> \\<alpha> ` {..<n}\n 3. (\\<Sum>v\\<in>?t. of_int (lu m1 (idx v) - lu m2 (idx v)) * v) = 0\n 4. \\<alpha> i \\<in> ?t", "have \"(\\<Sum>x\\<in>\\<alpha>`{..<n}. of_int (lu m1 (idx x) - lu m2 (idx x)) * x) =\n                (\\<Sum>i<n. of_int (lu m1 (idx (\\<alpha> i)) - lu m2 (idx (\\<alpha> i))) * \\<alpha> i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>\\<alpha> ` {..<n}.\n       of_int (lu m1 (idx x) - lu m2 (idx x)) * x) =\n    (\\<Sum>i<n.\n        of_int (lu m1 (idx (\\<alpha> i)) - lu m2 (idx (\\<alpha> i))) *\n        \\<alpha> i)", "using assms(1)"], ["proof (prove)\nusing this:\n  inj_on \\<alpha> {..<n}\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>\\<alpha> ` {..<n}.\n       of_int (lu m1 (idx x) - lu m2 (idx x)) * x) =\n    (\\<Sum>i<n.\n        of_int (lu m1 (idx (\\<alpha> i)) - lu m2 (idx (\\<alpha> i))) *\n        \\<alpha> i)", "by (subst sum.reindex) auto"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>\\<alpha> ` {..<n}.\n     of_int (lu m1 (idx x) - lu m2 (idx x)) * x) =\n  (\\<Sum>i<n.\n      of_int (lu m1 (idx (\\<alpha> i)) - lu m2 (idx (\\<alpha> i))) *\n      \\<alpha> i)\n\ngoal (4 subgoals):\n 1. finite ?t\n 2. ?t \\<subseteq> \\<alpha> ` {..<n}\n 3. (\\<Sum>v\\<in>?t. of_int (lu m1 (idx v) - lu m2 (idx v)) * v) = 0\n 4. \\<alpha> i \\<in> ?t", "also"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>\\<alpha> ` {..<n}.\n     of_int (lu m1 (idx x) - lu m2 (idx x)) * x) =\n  (\\<Sum>i<n.\n      of_int (lu m1 (idx (\\<alpha> i)) - lu m2 (idx (\\<alpha> i))) *\n      \\<alpha> i)\n\ngoal (4 subgoals):\n 1. finite ?t\n 2. ?t \\<subseteq> \\<alpha> ` {..<n}\n 3. (\\<Sum>v\\<in>?t. of_int (lu m1 (idx v) - lu m2 (idx v)) * v) = 0\n 4. \\<alpha> i \\<in> ?t", "have \"\\<dots> = (\\<Sum>i<n. of_int (lu m1 i - lu m2 i) * \\<alpha> i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n.\n        of_int (lu m1 (idx (\\<alpha> i)) - lu m2 (idx (\\<alpha> i))) *\n        \\<alpha> i) =\n    (\\<Sum>i<n. of_int (lu m1 i - lu m2 i) * \\<alpha> i)", "by (intro sum.cong) (auto simp: idx_def inv_into_f_f[OF assms(1)])"], ["proof (state)\nthis:\n  (\\<Sum>i<n.\n      of_int (lu m1 (idx (\\<alpha> i)) - lu m2 (idx (\\<alpha> i))) *\n      \\<alpha> i) =\n  (\\<Sum>i<n. of_int (lu m1 i - lu m2 i) * \\<alpha> i)\n\ngoal (4 subgoals):\n 1. finite ?t\n 2. ?t \\<subseteq> \\<alpha> ` {..<n}\n 3. (\\<Sum>v\\<in>?t. of_int (lu m1 (idx v) - lu m2 (idx v)) * v) = 0\n 4. \\<alpha> i \\<in> ?t", "also"], ["proof (state)\nthis:\n  (\\<Sum>i<n.\n      of_int (lu m1 (idx (\\<alpha> i)) - lu m2 (idx (\\<alpha> i))) *\n      \\<alpha> i) =\n  (\\<Sum>i<n. of_int (lu m1 i - lu m2 i) * \\<alpha> i)\n\ngoal (4 subgoals):\n 1. finite ?t\n 2. ?t \\<subseteq> \\<alpha> ` {..<n}\n 3. (\\<Sum>v\\<in>?t. of_int (lu m1 (idx v) - lu m2 (idx v)) * v) = 0\n 4. \\<alpha> i \\<in> ?t", "have \"\\<dots> = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. of_int (lu m1 i - lu m2 i) * \\<alpha> i) = 0", "using m12"], ["proof (prove)\nusing this:\n  m1 \\<in> I\n  m2 \\<in> I\n  \\<alpha>' m1 = \\<alpha>' m2\n\ngoal (1 subgoal):\n 1. (\\<Sum>i<n. of_int (lu m1 i - lu m2 i) * \\<alpha> i) = 0", "by (simp add: \\<alpha>'_def ring_distribs of_rat_diff sum_subtractf lu_def)"], ["proof (state)\nthis:\n  (\\<Sum>i<n. of_int (lu m1 i - lu m2 i) * \\<alpha> i) = 0\n\ngoal (4 subgoals):\n 1. finite ?t\n 2. ?t \\<subseteq> \\<alpha> ` {..<n}\n 3. (\\<Sum>v\\<in>?t. of_int (lu m1 (idx v) - lu m2 (idx v)) * v) = 0\n 4. \\<alpha> i \\<in> ?t", "finally"], ["proof (chain)\npicking this:\n  (\\<Sum>x\\<in>\\<alpha> ` {..<n}.\n     of_int (lu m1 (idx x) - lu m2 (idx x)) * x) =\n  0", "show \"(\\<Sum>x\\<in>\\<alpha>`{..<n}. of_int (lu m1 (idx x) - lu m2 (idx x)) * x) = 0\""], ["proof (prove)\nusing this:\n  (\\<Sum>x\\<in>\\<alpha> ` {..<n}.\n     of_int (lu m1 (idx x) - lu m2 (idx x)) * x) =\n  0\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>\\<alpha> ` {..<n}.\n       of_int (lu m1 (idx x) - lu m2 (idx x)) * x) =\n    0", "by (simp add: \\<alpha>'_def ring_distribs of_rat_diff sum_subtractf lu_def)"], ["proof (state)\nthis:\n  (\\<Sum>x\\<in>\\<alpha> ` {..<n}.\n     of_int (lu m1 (idx x) - lu m2 (idx x)) * x) =\n  0\n\ngoal (3 subgoals):\n 1. finite (\\<alpha> ` {..<n})\n 2. \\<alpha> ` {..<n} \\<subseteq> \\<alpha> ` {..<n}\n 3. \\<alpha> i \\<in> \\<alpha> ` {..<n}", "qed (use that in auto)"], ["proof (state)\nthis:\n  lu m1 (idx (\\<alpha> i)) - lu m2 (idx (\\<alpha> i)) = 0\n\ngoal (1 subgoal):\n 1. lu m1 i = lu m2 i", "thus ?thesis"], ["proof (prove)\nusing this:\n  lu m1 (idx (\\<alpha> i)) - lu m2 (idx (\\<alpha> i)) = 0\n\ngoal (1 subgoal):\n 1. lu m1 i = lu m2 i", "using that"], ["proof (prove)\nusing this:\n  lu m1 (idx (\\<alpha> i)) - lu m2 (idx (\\<alpha> i)) = 0\n  i < n\n\ngoal (1 subgoal):\n 1. lu m1 i = lu m2 i", "by (auto simp: idx_def inv_into_f_f[OF assms(1)])"], ["proof (state)\nthis:\n  lu m1 i = lu m2 i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i < n \\<Longrightarrow> lu m1 ?i = lu m2 ?i\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> I; y \\<in> I; \\<alpha>' x = \\<alpha>' y\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence \"lookup m1 i = lookup m2 i\" for i"], ["proof (prove)\nusing this:\n  ?i < n \\<Longrightarrow> lu m1 ?i = lu m2 ?i\n\ngoal (1 subgoal):\n 1. lookup m1 i = lookup m2 i", "using m12"], ["proof (prove)\nusing this:\n  ?i < n \\<Longrightarrow> lu m1 ?i = lu m2 ?i\n  m1 \\<in> I\n  m2 \\<in> I\n  \\<alpha>' m1 = \\<alpha>' m2\n\ngoal (1 subgoal):\n 1. lookup m1 i = lookup m2 i", "by (cases \"i < n\") (auto simp: lu_def lookup_eq_0)"], ["proof (state)\nthis:\n  lookup m1 ?i = lookup m2 ?i\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> I; y \\<in> I; \\<alpha>' x = \\<alpha>' y\\<rbrakk>\n       \\<Longrightarrow> x = y", "thus \"m1 = m2\""], ["proof (prove)\nusing this:\n  lookup m1 ?i = lookup m2 ?i\n\ngoal (1 subgoal):\n 1. m1 = m2", "by (rule poly_mapping_eqI)"], ["proof (state)\nthis:\n  m1 = m2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on \\<alpha>' I\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>I. MPoly_Type.coeff p x * exp (\\<alpha>' x)) = 0", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>I. MPoly_Type.coeff p x * exp (\\<alpha>' x)) = 0", "have \"0 = insertion (\\<lambda>i. exp (\\<alpha> i)) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 = insertion (\\<lambda>i. exp (\\<alpha> i)) p", "using p(3)"], ["proof (prove)\nusing this:\n  insertion (\\<lambda>i. exp (\\<alpha> i)) p = 0\n\ngoal (1 subgoal):\n 1. 0 = insertion (\\<lambda>i. exp (\\<alpha> i)) p", ".."], ["proof (state)\nthis:\n  0 = insertion (\\<lambda>i. exp (\\<alpha> i)) p\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>I. MPoly_Type.coeff p x * exp (\\<alpha>' x)) = 0", "also"], ["proof (state)\nthis:\n  0 = insertion (\\<lambda>i. exp (\\<alpha> i)) p\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>I. MPoly_Type.coeff p x * exp (\\<alpha>' x)) = 0", "have \"\\<dots> = (\\<Sum>m\\<in>I. coeff p m * Prod_any (\\<lambda>i. exp (\\<alpha> i) ^ lookup m i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion (\\<lambda>i. exp (\\<alpha> i)) p =\n    (\\<Sum>m\\<in>I.\n       MPoly_Type.coeff p m * (\\<Prod>i. exp (\\<alpha> i) ^ lookup m i))", "unfolding insertion_altdef"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m. MPoly_Type.coeff p m *\n              (\\<Prod>i. exp (\\<alpha> i) ^ lookup m i)) =\n    (\\<Sum>m\\<in>I.\n       MPoly_Type.coeff p m * (\\<Prod>i. exp (\\<alpha> i) ^ lookup m i))", "by (rule Sum_any.expand_superset) (auto simp: I_def)"], ["proof (state)\nthis:\n  insertion (\\<lambda>i. exp (\\<alpha> i)) p =\n  (\\<Sum>m\\<in>I.\n     MPoly_Type.coeff p m * (\\<Prod>i. exp (\\<alpha> i) ^ lookup m i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>I. MPoly_Type.coeff p x * exp (\\<alpha>' x)) = 0", "also"], ["proof (state)\nthis:\n  insertion (\\<lambda>i. exp (\\<alpha> i)) p =\n  (\\<Sum>m\\<in>I.\n     MPoly_Type.coeff p m * (\\<Prod>i. exp (\\<alpha> i) ^ lookup m i))\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>I. MPoly_Type.coeff p x * exp (\\<alpha>' x)) = 0", "have \"\\<dots> = (\\<Sum>m\\<in>I. coeff p m * exp (\\<alpha>' m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>I.\n       MPoly_Type.coeff p m * (\\<Prod>i. exp (\\<alpha> i) ^ lookup m i)) =\n    (\\<Sum>m\\<in>I. MPoly_Type.coeff p m * exp (\\<alpha>' m))", "proof (intro sum.cong, goal_cases)"], ["proof (state)\ngoal (2 subgoals):\n 1. I = I\n 2. \\<And>x.\n       x \\<in> I \\<Longrightarrow>\n       MPoly_Type.coeff p x * (\\<Prod>i. exp (\\<alpha> i) ^ lookup x i) =\n       MPoly_Type.coeff p x * exp (\\<alpha>' x)", "case (2 m)"], ["proof (state)\nthis:\n  m \\<in> I\n\ngoal (2 subgoals):\n 1. I = I\n 2. \\<And>x.\n       x \\<in> I \\<Longrightarrow>\n       MPoly_Type.coeff p x * (\\<Prod>i. exp (\\<alpha> i) ^ lookup x i) =\n       MPoly_Type.coeff p x * exp (\\<alpha>' x)", "have \"Prod_any (\\<lambda>i. exp (\\<alpha> i) ^ lookup m i) = (\\<Prod>i<n. exp (\\<alpha> i) ^ lookup m i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i. exp (\\<alpha> i) ^ lookup m i) =\n    (\\<Prod>i<n. exp (\\<alpha> i) ^ lookup m i)", "using 2 lookup_eq_0[of m]"], ["proof (prove)\nusing this:\n  m \\<in> I\n  \\<lbrakk>m \\<in> I; ?i \\<notin> {..<n}\\<rbrakk>\n  \\<Longrightarrow> lookup m ?i = 0\n\ngoal (1 subgoal):\n 1. (\\<Prod>i. exp (\\<alpha> i) ^ lookup m i) =\n    (\\<Prod>i<n. exp (\\<alpha> i) ^ lookup m i)", "by (intro Prod_any.expand_superset; force)"], ["proof (state)\nthis:\n  (\\<Prod>i. exp (\\<alpha> i) ^ lookup m i) =\n  (\\<Prod>i<n. exp (\\<alpha> i) ^ lookup m i)\n\ngoal (2 subgoals):\n 1. I = I\n 2. \\<And>x.\n       x \\<in> I \\<Longrightarrow>\n       MPoly_Type.coeff p x * (\\<Prod>i. exp (\\<alpha> i) ^ lookup x i) =\n       MPoly_Type.coeff p x * exp (\\<alpha>' x)", "also"], ["proof (state)\nthis:\n  (\\<Prod>i. exp (\\<alpha> i) ^ lookup m i) =\n  (\\<Prod>i<n. exp (\\<alpha> i) ^ lookup m i)\n\ngoal (2 subgoals):\n 1. I = I\n 2. \\<And>x.\n       x \\<in> I \\<Longrightarrow>\n       MPoly_Type.coeff p x * (\\<Prod>i. exp (\\<alpha> i) ^ lookup x i) =\n       MPoly_Type.coeff p x * exp (\\<alpha>' x)", "have \"\\<dots> = exp (\\<alpha>' m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>i<n. exp (\\<alpha> i) ^ lookup m i) = exp (\\<alpha>' m)", "by (simp add: exp_sum exp_of_nat_mult \\<alpha>'_def)"], ["proof (state)\nthis:\n  (\\<Prod>i<n. exp (\\<alpha> i) ^ lookup m i) = exp (\\<alpha>' m)\n\ngoal (2 subgoals):\n 1. I = I\n 2. \\<And>x.\n       x \\<in> I \\<Longrightarrow>\n       MPoly_Type.coeff p x * (\\<Prod>i. exp (\\<alpha> i) ^ lookup x i) =\n       MPoly_Type.coeff p x * exp (\\<alpha>' x)", "finally"], ["proof (chain)\npicking this:\n  (\\<Prod>i. exp (\\<alpha> i) ^ lookup m i) = exp (\\<alpha>' m)", "show ?case"], ["proof (prove)\nusing this:\n  (\\<Prod>i. exp (\\<alpha> i) ^ lookup m i) = exp (\\<alpha>' m)\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff p m * (\\<Prod>i. exp (\\<alpha> i) ^ lookup m i) =\n    MPoly_Type.coeff p m * exp (\\<alpha>' m)", "by simp"], ["proof (state)\nthis:\n  MPoly_Type.coeff p m * (\\<Prod>i. exp (\\<alpha> i) ^ lookup m i) =\n  MPoly_Type.coeff p m * exp (\\<alpha>' m)\n\ngoal (1 subgoal):\n 1. I = I", "qed simp_all"], ["proof (state)\nthis:\n  (\\<Sum>m\\<in>I.\n     MPoly_Type.coeff p m * (\\<Prod>i. exp (\\<alpha> i) ^ lookup m i)) =\n  (\\<Sum>m\\<in>I. MPoly_Type.coeff p m * exp (\\<alpha>' m))\n\ngoal (1 subgoal):\n 1. (\\<Sum>x\\<in>I. MPoly_Type.coeff p x * exp (\\<alpha>' x)) = 0", "finally"], ["proof (chain)\npicking this:\n  0 = (\\<Sum>m\\<in>I. MPoly_Type.coeff p m * exp (\\<alpha>' m))", "show \"(\\<Sum>m\\<in>I. coeff p m * exp (\\<alpha>' m)) = 0\""], ["proof (prove)\nusing this:\n  0 = (\\<Sum>m\\<in>I. MPoly_Type.coeff p m * exp (\\<alpha>' m))\n\ngoal (1 subgoal):\n 1. (\\<Sum>m\\<in>I. MPoly_Type.coeff p m * exp (\\<alpha>' m)) = 0", ".."], ["proof (state)\nthis:\n  (\\<Sum>m\\<in>I. MPoly_Type.coeff p m * exp (\\<alpha>' m)) = 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>x\\<in>I. MPoly_Type.coeff p x = 0\n\ngoal (1 subgoal):\n 1. \\<And>p.\n       \\<lbrakk>vars p \\<subseteq> {..<n};\n        \\<forall>m. MPoly_Type.coeff p m \\<in> \\<rat>;\n        insertion (\\<lambda>i. exp (\\<alpha> i)) p = 0\\<rbrakk>\n       \\<Longrightarrow> p = 0", "thus \"p = 0\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>I. MPoly_Type.coeff p x = 0\n\ngoal (1 subgoal):\n 1. p = 0", "by (intro mpoly_eqI) (auto simp: I_def)"], ["proof (state)\nthis:\n  p = 0\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Simple corollaries\\<close>"], ["", "text \\<open>\n  Now, we derive all the usual obvious corollaries of the theorem in the obvious way.\n\n  First, the exponential of a non-zero algebraic number is transcendental.\n\\<close>"], ["", "corollary algebraic_exp_complex_iff:\n  assumes \"algebraic x\"\n  shows   \"algebraic (exp x :: complex) \\<longleftrightarrow> x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic (exp x) = (x = 0)", "using Hermite_Lindemann_list[of \"[(1, x), (-exp x, 0)]\"] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>(x, y)\\<in>set [(1, x), (- exp x, 0)].\n              algebraic x \\<and> algebraic y;\n   distinct (map snd [(1, x), (- exp x, 0)]);\n   (\\<Sum>(c,\n       \\<alpha>)\\<leftarrow>[(1, x), (- exp x, 0)]. c * exp \\<alpha>) =\n   0\\<rbrakk>\n  \\<Longrightarrow> \\<forall>c\\<in>fst ` set [(1, x), (- exp x, 0)]. c = 0\n  algebraic x\n\ngoal (1 subgoal):\n 1. algebraic (exp x) = (x = 0)", "by auto"], ["", "text \\<open>\n  More generally, any sum of exponentials with algebraic coefficients and exponents is\n  transcendental if the exponents are all distinct and non-zero and at least one coefficient\n  is non-zero.\n\\<close>"], ["", "corollary sum_of_exp_transcendentalI:\n  fixes xs :: \"(complex \\<times> complex) list\"\n  assumes \"\\<forall>(x,y)\\<in>set xs. algebraic x \\<and> algebraic y \\<and> y \\<noteq> 0\"\n  assumes \"\\<exists>x\\<in>fst`set xs. x \\<noteq> 0\"\n  assumes distinct: \"distinct (map snd xs)\"\n  shows   \"\\<not>algebraic (\\<Sum>(c,\\<alpha>)\\<leftarrow>xs. c * exp \\<alpha>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> algebraic (\\<Sum>(c, \\<alpha>)\\<leftarrow>xs. c * exp \\<alpha>)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. algebraic\n     (\\<Sum>(c, \\<alpha>)\\<leftarrow>xs. c * exp \\<alpha>) \\<Longrightarrow>\n    False", "define S where \"S = (\\<Sum>(c,\\<alpha>)\\<leftarrow>xs. c * exp \\<alpha>)\""], ["proof (state)\nthis:\n  S = (\\<Sum>(c, \\<alpha>)\\<leftarrow>xs. c * exp \\<alpha>)\n\ngoal (1 subgoal):\n 1. algebraic\n     (\\<Sum>(c, \\<alpha>)\\<leftarrow>xs. c * exp \\<alpha>) \\<Longrightarrow>\n    False", "assume S: \"algebraic S\""], ["proof (state)\nthis:\n  algebraic S\n\ngoal (1 subgoal):\n 1. algebraic\n     (\\<Sum>(c, \\<alpha>)\\<leftarrow>xs. c * exp \\<alpha>) \\<Longrightarrow>\n    False", "have \"\\<forall>c\\<in>fst`set ((-S,0) # xs). c = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c\\<in>fst ` set ((- S, 0) # xs). c = 0", "proof (rule Hermite_Lindemann_list)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<forall>(x, y)\\<in>set ((- S, 0) # xs). algebraic x \\<and> algebraic y\n 2. distinct (map snd ((- S, 0) # xs))\n 3. (\\<Sum>(c, \\<alpha>)\\<leftarrow>(- S, 0) # xs. c * exp \\<alpha>) = 0", "show \"(\\<Sum>(c, \\<alpha>)\\<leftarrow>(- S, 0) # xs. c * exp \\<alpha>) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(c, \\<alpha>)\\<leftarrow>(- S, 0) # xs. c * exp \\<alpha>) = 0", "by (auto simp: S_def)"], ["proof (state)\nthis:\n  (\\<Sum>(c, \\<alpha>)\\<leftarrow>(- S, 0) # xs. c * exp \\<alpha>) = 0\n\ngoal (2 subgoals):\n 1. \\<forall>(x, y)\\<in>set ((- S, 0) # xs). algebraic x \\<and> algebraic y\n 2. distinct (map snd ((- S, 0) # xs))", "qed (use S assms in auto)"], ["proof (state)\nthis:\n  \\<forall>c\\<in>fst ` set ((- S, 0) # xs). c = 0\n\ngoal (1 subgoal):\n 1. algebraic\n     (\\<Sum>(c, \\<alpha>)\\<leftarrow>xs. c * exp \\<alpha>) \\<Longrightarrow>\n    False", "with assms(2)"], ["proof (chain)\npicking this:\n  \\<exists>x\\<in>fst ` set xs. x \\<noteq> 0\n  \\<forall>c\\<in>fst ` set ((- S, 0) # xs). c = 0", "show False"], ["proof (prove)\nusing this:\n  \\<exists>x\\<in>fst ` set xs. x \\<noteq> 0\n  \\<forall>c\\<in>fst ` set ((- S, 0) # xs). c = 0\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n  Any complex logarithm of an algebraic number other than 1 is transcendental\n  (no matter which branch cut).\n\\<close>"], ["", "corollary transcendental_complex_logarithm:\n  assumes \"algebraic x\" \"exp y = (x :: complex)\" \"x \\<noteq> 1\"\n  shows   \"\\<not>algebraic y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> algebraic y", "using algebraic_exp_complex_iff[of y] assms"], ["proof (prove)\nusing this:\n  algebraic y \\<Longrightarrow> algebraic (exp y) = (y = 0)\n  algebraic x\n  exp y = x\n  x \\<noteq> 1\n\ngoal (1 subgoal):\n 1. \\<not> algebraic y", "by auto"], ["", "text \\<open>\n  In particular, this holds for the standard branch of the logarithm.\n\\<close>"], ["", "corollary transcendental_Ln:\n  assumes \"algebraic x\" \"x \\<noteq> 0\" \"x \\<noteq> 1\"\n  shows   \"\\<not>algebraic (Ln x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> algebraic (Ln x)", "by (rule transcendental_complex_logarithm) (use assms in auto)"], ["", "text \\<open>\n  The transcendence of \\<open>e\\<close> and \\<open>\\<pi>\\<close>, which I have already formalised directly in other AFP\n  entries, now follows as a simple corollary.\n\\<close>"], ["", "corollary exp_1_complex_transcendental: \"\\<not>algebraic (exp 1 :: complex)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> algebraic (exp 1)", "by (subst algebraic_exp_complex_iff) auto"], ["", "corollary pi_transcendental: \"\\<not>algebraic pi\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> algebraic pi", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> algebraic pi", "have \"\\<not>algebraic (\\<i> * pi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> algebraic (\\<i> * complex_of_real pi)", "by (rule transcendental_complex_logarithm[of \"-1\"]) auto"], ["proof (state)\nthis:\n  \\<not> algebraic (\\<i> * complex_of_real pi)\n\ngoal (1 subgoal):\n 1. \\<not> algebraic pi", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> algebraic (\\<i> * complex_of_real pi)\n\ngoal (1 subgoal):\n 1. \\<not> algebraic pi", "by simp"], ["proof (state)\nthis:\n  \\<not> algebraic pi\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Transcendence of the trigonometric and hyperbolic functions\\<close>"], ["", "text \\<open>\n  In a similar fashion, we can also prove the transcendence of all the trigonometric and\n  hyperbolic functions such as $\\sin$, $\\tan$, $\\sinh$, $\\arcsin$, etc.\n\\<close>"], ["", "lemma transcendental_sinh:\n  assumes \"algebraic z\" \"z \\<noteq> 0\"\n  shows   \"\\<not>algebraic (sinh z :: complex)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> algebraic (sinh z)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> algebraic (sinh z)", "have \"\\<not>algebraic (\\<Sum>(a,b)\\<leftarrow>[(1/2, z), (-1/2, -z)]. a * exp b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> algebraic\n            (\\<Sum>(a,\n                b)\\<leftarrow>[(1 / 2, z), (- 1 / 2, - z)]. a * exp b)", "using assms"], ["proof (prove)\nusing this:\n  algebraic z\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> algebraic\n            (\\<Sum>(a,\n                b)\\<leftarrow>[(1 / 2, z), (- 1 / 2, - z)]. a * exp b)", "by (intro sum_of_exp_transcendentalI) auto"], ["proof (state)\nthis:\n  \\<not> algebraic\n          (\\<Sum>(a, b)\\<leftarrow>[(1 / 2, z), (- 1 / 2, - z)]. a * exp b)\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (sinh z)", "also"], ["proof (state)\nthis:\n  \\<not> algebraic\n          (\\<Sum>(a, b)\\<leftarrow>[(1 / 2, z), (- 1 / 2, - z)]. a * exp b)\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (sinh z)", "have \"(\\<Sum>(a,b)\\<leftarrow>[(1/2, z), (-1/2, -z)]. a * exp b) = sinh z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(a, b)\\<leftarrow>[(1 / 2, z), (- 1 / 2, - z)]. a * exp b) =\n    sinh z", "by (simp add: sinh_def field_simps scaleR_conv_of_real)"], ["proof (state)\nthis:\n  (\\<Sum>(a, b)\\<leftarrow>[(1 / 2, z), (- 1 / 2, - z)]. a * exp b) = sinh z\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (sinh z)", "finally"], ["proof (chain)\npicking this:\n  \\<not> algebraic (sinh z)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> algebraic (sinh z)\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (sinh z)", "."], ["proof (state)\nthis:\n  \\<not> algebraic (sinh z)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma transcendental_cosh:\n  assumes \"algebraic z\" \"z \\<noteq> 0\"\n  shows   \"\\<not>algebraic (cosh z :: complex)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> algebraic (cosh z)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> algebraic (cosh z)", "have \"\\<not>algebraic (\\<Sum>(a,b)\\<leftarrow>[(1/2, z), (1/2, -z)]. a * exp b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> algebraic\n            (\\<Sum>(a, b)\\<leftarrow>[(1 / 2, z), (1 / 2, - z)]. a * exp b)", "using assms"], ["proof (prove)\nusing this:\n  algebraic z\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> algebraic\n            (\\<Sum>(a, b)\\<leftarrow>[(1 / 2, z), (1 / 2, - z)]. a * exp b)", "by (intro sum_of_exp_transcendentalI) auto"], ["proof (state)\nthis:\n  \\<not> algebraic\n          (\\<Sum>(a, b)\\<leftarrow>[(1 / 2, z), (1 / 2, - z)]. a * exp b)\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (cosh z)", "also"], ["proof (state)\nthis:\n  \\<not> algebraic\n          (\\<Sum>(a, b)\\<leftarrow>[(1 / 2, z), (1 / 2, - z)]. a * exp b)\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (cosh z)", "have \"(\\<Sum>(a,b)\\<leftarrow>[(1/2, z), (1/2, -z)]. a * exp b) = cosh z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>(a, b)\\<leftarrow>[(1 / 2, z), (1 / 2, - z)]. a * exp b) = cosh z", "by (simp add: cosh_def field_simps scaleR_conv_of_real)"], ["proof (state)\nthis:\n  (\\<Sum>(a, b)\\<leftarrow>[(1 / 2, z), (1 / 2, - z)]. a * exp b) = cosh z\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (cosh z)", "finally"], ["proof (chain)\npicking this:\n  \\<not> algebraic (cosh z)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> algebraic (cosh z)\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (cosh z)", "."], ["proof (state)\nthis:\n  \\<not> algebraic (cosh z)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma transcendental_sin:\n  assumes \"algebraic z\" \"z \\<noteq> 0\"\n  shows   \"\\<not>algebraic (sin z :: complex)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> algebraic (sin z)", "unfolding sin_conv_sinh"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> algebraic (- \\<i> * sinh (\\<i> * z))", "using transcendental_sinh[of \"\\<i> * z\"] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>algebraic (\\<i> * z); \\<i> * z \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> \\<not> algebraic (sinh (\\<i> * z))\n  algebraic z\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (- \\<i> * sinh (\\<i> * z))", "by simp"], ["", "lemma transcendental_cos:\n  assumes \"algebraic z\" \"z \\<noteq> 0\"\n  shows   \"\\<not>algebraic (cos z :: complex)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> algebraic (cos z)", "unfolding cos_conv_cosh"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> algebraic (cosh (\\<i> * z))", "using transcendental_cosh[of \"\\<i> * z\"] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>algebraic (\\<i> * z); \\<i> * z \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> \\<not> algebraic (cosh (\\<i> * z))\n  algebraic z\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (cosh (\\<i> * z))", "by simp"], ["", "(* TODO: Move? *)"], ["", "lemma tan_square_neq_neg1: \"tan (z :: complex) ^ 2 \\<noteq> -1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (tan z)\\<^sup>2 \\<noteq> - 1", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (tan z)\\<^sup>2 = - 1 \\<Longrightarrow> False", "assume \"tan z ^ 2 = -1\""], ["proof (state)\nthis:\n  (tan z)\\<^sup>2 = - 1\n\ngoal (1 subgoal):\n 1. (tan z)\\<^sup>2 = - 1 \\<Longrightarrow> False", "hence \"sin z ^ 2 = -(cos z ^ 2)\""], ["proof (prove)\nusing this:\n  (tan z)\\<^sup>2 = - 1\n\ngoal (1 subgoal):\n 1. (sin z)\\<^sup>2 = - (cos z)\\<^sup>2", "by (auto simp: tan_def divide_simps split: if_splits)"], ["proof (state)\nthis:\n  (sin z)\\<^sup>2 = - (cos z)\\<^sup>2\n\ngoal (1 subgoal):\n 1. (tan z)\\<^sup>2 = - 1 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (sin z)\\<^sup>2 = - (cos z)\\<^sup>2\n\ngoal (1 subgoal):\n 1. (tan z)\\<^sup>2 = - 1 \\<Longrightarrow> False", "have \"cos z ^ 2 = 1 - sin z ^ 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cos z)\\<^sup>2 = 1 - (sin z)\\<^sup>2", "by (simp add: cos_squared_eq)"], ["proof (state)\nthis:\n  (cos z)\\<^sup>2 = 1 - (sin z)\\<^sup>2\n\ngoal (1 subgoal):\n 1. (tan z)\\<^sup>2 = - 1 \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  (sin z)\\<^sup>2 = - (1 - (sin z)\\<^sup>2)", "show False"], ["proof (prove)\nusing this:\n  (sin z)\\<^sup>2 = - (1 - (sin z)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma transcendental_tan:\n  assumes \"algebraic z\" \"z \\<noteq> 0\"\n  shows   \"\\<not>algebraic (tan z :: complex)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> algebraic (tan z)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. algebraic (tan z) \\<Longrightarrow> False", "assume \"algebraic (tan z)\""], ["proof (state)\nthis:\n  algebraic (tan z)\n\ngoal (1 subgoal):\n 1. algebraic (tan z) \\<Longrightarrow> False", "have nz1: \"real_of_int n + 1 / 2 \\<noteq> 0\" for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int n + 1 / 2 \\<noteq> 0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. real_of_int n + 1 / 2 \\<noteq> 0", "have \"real_of_int (2 * n + 1) / real_of_int 2 \\<notin> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (2 * n + 1) / real_of_int 2 \\<notin> \\<int>", "by (intro fraction_not_in_ints) auto"], ["proof (state)\nthis:\n  real_of_int (2 * n + 1) / real_of_int 2 \\<notin> \\<int>\n\ngoal (1 subgoal):\n 1. real_of_int n + 1 / 2 \\<noteq> 0", "also"], ["proof (state)\nthis:\n  real_of_int (2 * n + 1) / real_of_int 2 \\<notin> \\<int>\n\ngoal (1 subgoal):\n 1. real_of_int n + 1 / 2 \\<noteq> 0", "have \"real_of_int (2 * n + 1) / real_of_int 2 = real_of_int n + 1 / 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. real_of_int (2 * n + 1) / real_of_int 2 = real_of_int n + 1 / 2", "by simp"], ["proof (state)\nthis:\n  real_of_int (2 * n + 1) / real_of_int 2 = real_of_int n + 1 / 2\n\ngoal (1 subgoal):\n 1. real_of_int n + 1 / 2 \\<noteq> 0", "finally"], ["proof (chain)\npicking this:\n  real_of_int n + 1 / 2 \\<notin> \\<int>", "show \"\\<dots> \\<noteq> 0\""], ["proof (prove)\nusing this:\n  real_of_int n + 1 / 2 \\<notin> \\<int>\n\ngoal (1 subgoal):\n 1. real_of_int n + 1 / 2 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  real_of_int n + 1 / 2 \\<noteq> 0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  real_of_int ?n + 1 / 2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. algebraic (tan z) \\<Longrightarrow> False", "have nz2: \"1 + tan z ^ 2 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 + (tan z)\\<^sup>2 \\<noteq> 0", "using tan_square_neq_neg1[of z]"], ["proof (prove)\nusing this:\n  (tan z)\\<^sup>2 \\<noteq> - 1\n\ngoal (1 subgoal):\n 1. 1 + (tan z)\\<^sup>2 \\<noteq> 0", "by (subst add_eq_0_iff)"], ["proof (state)\nthis:\n  1 + (tan z)\\<^sup>2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. algebraic (tan z) \\<Longrightarrow> False", "have nz3: \"cos z \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cos z \\<noteq> 0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. cos z = 0 \\<Longrightarrow> False", "assume \"cos z = 0\""], ["proof (state)\nthis:\n  cos z = 0\n\ngoal (1 subgoal):\n 1. cos z = 0 \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  cos z = 0", "obtain n where \"z = complex_of_real (real_of_int n * pi) + complex_of_real pi / 2\""], ["proof (prove)\nusing this:\n  cos z = 0\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        z =\n        complex_of_real (real_of_int n * pi) +\n        complex_of_real pi / 2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (subst (asm) cos_eq_0) blast"], ["proof (state)\nthis:\n  z = complex_of_real (real_of_int n * pi) + complex_of_real pi / 2\n\ngoal (1 subgoal):\n 1. cos z = 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  z = complex_of_real (real_of_int n * pi) + complex_of_real pi / 2\n\ngoal (1 subgoal):\n 1. cos z = 0 \\<Longrightarrow> False", "have \"\\<dots> = complex_of_real ((real_of_int n + 1 / 2) * pi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. complex_of_real (real_of_int n * pi) + complex_of_real pi / 2 =\n    complex_of_real ((real_of_int n + 1 / 2) * pi)", "by (simp add: ring_distribs)"], ["proof (state)\nthis:\n  complex_of_real (real_of_int n * pi) + complex_of_real pi / 2 =\n  complex_of_real ((real_of_int n + 1 / 2) * pi)\n\ngoal (1 subgoal):\n 1. cos z = 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  complex_of_real (real_of_int n * pi) + complex_of_real pi / 2 =\n  complex_of_real ((real_of_int n + 1 / 2) * pi)\n\ngoal (1 subgoal):\n 1. cos z = 0 \\<Longrightarrow> False", "have \"algebraic \\<dots> \\<longleftrightarrow> algebraic ((real_of_int n + 1 / 2) * pi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic (complex_of_real ((real_of_int n + 1 / 2) * pi)) =\n    algebraic ((real_of_int n + 1 / 2) * pi)", "by (rule algebraic_of_real_iff)"], ["proof (state)\nthis:\n  algebraic (complex_of_real ((real_of_int n + 1 / 2) * pi)) =\n  algebraic ((real_of_int n + 1 / 2) * pi)\n\ngoal (1 subgoal):\n 1. cos z = 0 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  algebraic (complex_of_real ((real_of_int n + 1 / 2) * pi)) =\n  algebraic ((real_of_int n + 1 / 2) * pi)\n\ngoal (1 subgoal):\n 1. cos z = 0 \\<Longrightarrow> False", "have \"\\<not>algebraic ((real_of_int n + 1 / 2) * pi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> algebraic ((real_of_int n + 1 / 2) * pi)", "using nz1[of n] transcendental_pi"], ["proof (prove)\nusing this:\n  real_of_int n + 1 / 2 \\<noteq> 0\n  \\<not> algebraic pi\n\ngoal (1 subgoal):\n 1. \\<not> algebraic ((real_of_int n + 1 / 2) * pi)", "by simp"], ["proof (state)\nthis:\n  \\<not> algebraic ((real_of_int n + 1 / 2) * pi)\n\ngoal (1 subgoal):\n 1. cos z = 0 \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  \\<not> algebraic z", "show False"], ["proof (prove)\nusing this:\n  \\<not> algebraic z\n\ngoal (1 subgoal):\n 1. False", "using assms(1)"], ["proof (prove)\nusing this:\n  \\<not> algebraic z\n  algebraic z\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  cos z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. algebraic (tan z) \\<Longrightarrow> False", "from nz3"], ["proof (chain)\npicking this:\n  cos z \\<noteq> 0", "have *: \"sin z ^ 2 = tan z ^ 2 * cos z ^ 2\""], ["proof (prove)\nusing this:\n  cos z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (sin z)\\<^sup>2 = (tan z)\\<^sup>2 * (cos z)\\<^sup>2", "by (simp add: tan_def field_simps)"], ["proof (state)\nthis:\n  (sin z)\\<^sup>2 = (tan z)\\<^sup>2 * (cos z)\\<^sup>2\n\ngoal (1 subgoal):\n 1. algebraic (tan z) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (sin z)\\<^sup>2 = (tan z)\\<^sup>2 * (cos z)\\<^sup>2\n\ngoal (1 subgoal):\n 1. algebraic (tan z) \\<Longrightarrow> False", "have \"cos z ^ 2 = 1 - sin z ^ 2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cos z)\\<^sup>2 = 1 - (sin z)\\<^sup>2", "by (simp add: cos_squared_eq)"], ["proof (state)\nthis:\n  (cos z)\\<^sup>2 = 1 - (sin z)\\<^sup>2\n\ngoal (1 subgoal):\n 1. algebraic (tan z) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  (sin z)\\<^sup>2 = (tan z)\\<^sup>2 * (1 - (sin z)\\<^sup>2)", "have \"sin z ^ 2 * (1 + tan z ^ 2) = tan z ^ 2\""], ["proof (prove)\nusing this:\n  (sin z)\\<^sup>2 = (tan z)\\<^sup>2 * (1 - (sin z)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. (sin z)\\<^sup>2 * (1 + (tan z)\\<^sup>2) = (tan z)\\<^sup>2", "by (simp add: algebra_simps)"], ["proof (state)\nthis:\n  (sin z)\\<^sup>2 * (1 + (tan z)\\<^sup>2) = (tan z)\\<^sup>2\n\ngoal (1 subgoal):\n 1. algebraic (tan z) \\<Longrightarrow> False", "hence \"sin z ^ 2 = tan z ^ 2 / (1 + tan z ^ 2)\""], ["proof (prove)\nusing this:\n  (sin z)\\<^sup>2 * (1 + (tan z)\\<^sup>2) = (tan z)\\<^sup>2\n\ngoal (1 subgoal):\n 1. (sin z)\\<^sup>2 = (tan z)\\<^sup>2 / (1 + (tan z)\\<^sup>2)", "using nz2"], ["proof (prove)\nusing this:\n  (sin z)\\<^sup>2 * (1 + (tan z)\\<^sup>2) = (tan z)\\<^sup>2\n  1 + (tan z)\\<^sup>2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (sin z)\\<^sup>2 = (tan z)\\<^sup>2 / (1 + (tan z)\\<^sup>2)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  (sin z)\\<^sup>2 = (tan z)\\<^sup>2 / (1 + (tan z)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. algebraic (tan z) \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  (sin z)\\<^sup>2 = (tan z)\\<^sup>2 / (1 + (tan z)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. algebraic (tan z) \\<Longrightarrow> False", "have \"algebraic (tan z ^ 2 / (1 + tan z ^ 2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic ((tan z)\\<^sup>2 / (1 + (tan z)\\<^sup>2))", "using \\<open>algebraic (tan z)\\<close>"], ["proof (prove)\nusing this:\n  algebraic (tan z)\n\ngoal (1 subgoal):\n 1. algebraic ((tan z)\\<^sup>2 / (1 + (tan z)\\<^sup>2))", "by auto"], ["proof (state)\nthis:\n  algebraic ((tan z)\\<^sup>2 / (1 + (tan z)\\<^sup>2))\n\ngoal (1 subgoal):\n 1. algebraic (tan z) \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  algebraic ((sin z)\\<^sup>2)", "have \"algebraic (sin z ^ 2)\""], ["proof (prove)\nusing this:\n  algebraic ((sin z)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. algebraic ((sin z)\\<^sup>2)", "."], ["proof (state)\nthis:\n  algebraic ((sin z)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. algebraic (tan z) \\<Longrightarrow> False", "hence \"algebraic (sin z)\""], ["proof (prove)\nusing this:\n  algebraic ((sin z)\\<^sup>2)\n\ngoal (1 subgoal):\n 1. algebraic (sin z)", "by simp"], ["proof (state)\nthis:\n  algebraic (sin z)\n\ngoal (1 subgoal):\n 1. algebraic (tan z) \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  algebraic (sin z)\n\ngoal (1 subgoal):\n 1. False", "using transcendental_sin[OF \\<open>algebraic z\\<close> \\<open>z \\<noteq> 0\\<close>]"], ["proof (prove)\nusing this:\n  algebraic (sin z)\n  \\<not> algebraic (sin z)\n\ngoal (1 subgoal):\n 1. False", "by contradiction"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma transcendental_cot:\n  assumes \"algebraic z\" \"z \\<noteq> 0\"\n  shows   \"\\<not>algebraic (cot z :: complex)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> algebraic (cot z)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> algebraic (cot z)", "have \"\\<not>algebraic (tan z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> algebraic (tan z)", "by (rule transcendental_tan) fact+"], ["proof (state)\nthis:\n  \\<not> algebraic (tan z)\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (cot z)", "also"], ["proof (state)\nthis:\n  \\<not> algebraic (tan z)\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (cot z)", "have \"algebraic (tan z) \\<longleftrightarrow> algebraic (inverse (tan z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic (tan z) = algebraic (inverse (tan z))", "by simp"], ["proof (state)\nthis:\n  algebraic (tan z) = algebraic (inverse (tan z))\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (cot z)", "also"], ["proof (state)\nthis:\n  algebraic (tan z) = algebraic (inverse (tan z))\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (cot z)", "have \"inverse (tan z) = cot z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse (tan z) = cot z", "by (simp add: cot_def tan_def)"], ["proof (state)\nthis:\n  inverse (tan z) = cot z\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (cot z)", "finally"], ["proof (chain)\npicking this:\n  \\<not> algebraic (cot z)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> algebraic (cot z)\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (cot z)", "."], ["proof (state)\nthis:\n  \\<not> algebraic (cot z)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma transcendental_tanh:\n  assumes \"algebraic z\" \"z \\<noteq> 0\" \"cosh z \\<noteq> 0\"\n  shows   \"\\<not>algebraic (tanh z :: complex)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> algebraic (tanh z)", "using transcendental_tan[of \"\\<i> * z\"] assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>algebraic (\\<i> * z); \\<i> * z \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> \\<not> algebraic (tan (\\<i> * z))\n  algebraic z\n  z \\<noteq> 0\n  cosh z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (tanh z)", "unfolding tanh_conv_tan"], ["proof (prove)\nusing this:\n  \\<lbrakk>algebraic (\\<i> * z); \\<i> * z \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> \\<not> algebraic (tan (\\<i> * z))\n  algebraic z\n  z \\<noteq> 0\n  cosh z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (- \\<i> * tan (\\<i> * z))", "by simp"], ["", "lemma transcendental_Arcsin:\n  assumes \"algebraic z\" \"z \\<noteq> 0\"\n  shows   \"\\<not>algebraic (Arcsin z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> algebraic (Arcsin z)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> algebraic (Arcsin z)", "have \"\\<i> * z + csqrt (1 - z\\<^sup>2) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<i> * z + csqrt (1 - z\\<^sup>2) \\<noteq> 0", "using Arcsin_body_lemma"], ["proof (prove)\nusing this:\n  \\<i> * ?z + csqrt (1 - ?z\\<^sup>2) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<i> * z + csqrt (1 - z\\<^sup>2) \\<noteq> 0", "by blast"], ["proof (state)\nthis:\n  \\<i> * z + csqrt (1 - z\\<^sup>2) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (Arcsin z)", "moreover"], ["proof (state)\nthis:\n  \\<i> * z + csqrt (1 - z\\<^sup>2) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (Arcsin z)", "have \"\\<i> * z + csqrt (1 - z\\<^sup>2) \\<noteq> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<i> * z + csqrt (1 - z\\<^sup>2) \\<noteq> 1", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<i> * z + csqrt (1 - z\\<^sup>2) = 1 \\<Longrightarrow> False", "assume \"\\<i> * z + csqrt (1 - z\\<^sup>2) = 1\""], ["proof (state)\nthis:\n  \\<i> * z + csqrt (1 - z\\<^sup>2) = 1\n\ngoal (1 subgoal):\n 1. \\<i> * z + csqrt (1 - z\\<^sup>2) = 1 \\<Longrightarrow> False", "hence \"Arcsin z = 0\""], ["proof (prove)\nusing this:\n  \\<i> * z + csqrt (1 - z\\<^sup>2) = 1\n\ngoal (1 subgoal):\n 1. Arcsin z = 0", "by (simp add: Arcsin_def)"], ["proof (state)\nthis:\n  Arcsin z = 0\n\ngoal (1 subgoal):\n 1. \\<i> * z + csqrt (1 - z\\<^sup>2) = 1 \\<Longrightarrow> False", "hence \"sin (Arcsin z) = 0\""], ["proof (prove)\nusing this:\n  Arcsin z = 0\n\ngoal (1 subgoal):\n 1. sin (Arcsin z) = 0", "by (simp only: sin_zero)"], ["proof (state)\nthis:\n  sin (Arcsin z) = 0\n\ngoal (1 subgoal):\n 1. \\<i> * z + csqrt (1 - z\\<^sup>2) = 1 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  sin (Arcsin z) = 0\n\ngoal (1 subgoal):\n 1. \\<i> * z + csqrt (1 - z\\<^sup>2) = 1 \\<Longrightarrow> False", "have \"sin (Arcsin z) = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sin (Arcsin z) = z", "by simp"], ["proof (state)\nthis:\n  sin (Arcsin z) = z\n\ngoal (1 subgoal):\n 1. \\<i> * z + csqrt (1 - z\\<^sup>2) = 1 \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  z = 0", "show False"], ["proof (prove)\nusing this:\n  z = 0\n\ngoal (1 subgoal):\n 1. False", "using \\<open>z \\<noteq> 0\\<close>"], ["proof (prove)\nusing this:\n  z = 0\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<i> * z + csqrt (1 - z\\<^sup>2) \\<noteq> 1\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (Arcsin z)", "ultimately"], ["proof (chain)\npicking this:\n  \\<i> * z + csqrt (1 - z\\<^sup>2) \\<noteq> 0\n  \\<i> * z + csqrt (1 - z\\<^sup>2) \\<noteq> 1", "have \"\\<not> algebraic (Ln (\\<i> * z + csqrt (1 - z\\<^sup>2)))\""], ["proof (prove)\nusing this:\n  \\<i> * z + csqrt (1 - z\\<^sup>2) \\<noteq> 0\n  \\<i> * z + csqrt (1 - z\\<^sup>2) \\<noteq> 1\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (Ln (\\<i> * z + csqrt (1 - z\\<^sup>2)))", "using assms"], ["proof (prove)\nusing this:\n  \\<i> * z + csqrt (1 - z\\<^sup>2) \\<noteq> 0\n  \\<i> * z + csqrt (1 - z\\<^sup>2) \\<noteq> 1\n  algebraic z\n  z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (Ln (\\<i> * z + csqrt (1 - z\\<^sup>2)))", "by (intro transcendental_Ln) auto"], ["proof (state)\nthis:\n  \\<not> algebraic (Ln (\\<i> * z + csqrt (1 - z\\<^sup>2)))\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (Arcsin z)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> algebraic (Ln (\\<i> * z + csqrt (1 - z\\<^sup>2)))\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (Arcsin z)", "by (simp add: Arcsin_def)"], ["proof (state)\nthis:\n  \\<not> algebraic (Arcsin z)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma transcendental_Arccos:\n  assumes \"algebraic z\" \"z \\<noteq> 1\"\n  shows   \"\\<not>algebraic (Arccos z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> algebraic (Arccos z)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> algebraic (Arccos z)", "have \"z + \\<i> * csqrt (1 - z\\<^sup>2) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z + \\<i> * csqrt (1 - z\\<^sup>2) \\<noteq> 0", "using Arccos_body_lemma"], ["proof (prove)\nusing this:\n  ?z + \\<i> * csqrt (1 - ?z\\<^sup>2) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. z + \\<i> * csqrt (1 - z\\<^sup>2) \\<noteq> 0", "by blast"], ["proof (state)\nthis:\n  z + \\<i> * csqrt (1 - z\\<^sup>2) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (Arccos z)", "moreover"], ["proof (state)\nthis:\n  z + \\<i> * csqrt (1 - z\\<^sup>2) \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (Arccos z)", "have \"z + \\<i> * csqrt (1 - z\\<^sup>2) \\<noteq> 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z + \\<i> * csqrt (1 - z\\<^sup>2) \\<noteq> 1", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. z + \\<i> * csqrt (1 - z\\<^sup>2) = 1 \\<Longrightarrow> False", "assume \"z + \\<i> * csqrt (1 - z\\<^sup>2) = 1\""], ["proof (state)\nthis:\n  z + \\<i> * csqrt (1 - z\\<^sup>2) = 1\n\ngoal (1 subgoal):\n 1. z + \\<i> * csqrt (1 - z\\<^sup>2) = 1 \\<Longrightarrow> False", "hence \"Arccos z = 0\""], ["proof (prove)\nusing this:\n  z + \\<i> * csqrt (1 - z\\<^sup>2) = 1\n\ngoal (1 subgoal):\n 1. Arccos z = 0", "by (simp add: Arccos_def)"], ["proof (state)\nthis:\n  Arccos z = 0\n\ngoal (1 subgoal):\n 1. z + \\<i> * csqrt (1 - z\\<^sup>2) = 1 \\<Longrightarrow> False", "hence \"cos (Arccos z) = 1\""], ["proof (prove)\nusing this:\n  Arccos z = 0\n\ngoal (1 subgoal):\n 1. cos (Arccos z) = 1", "by (simp only: cos_zero)"], ["proof (state)\nthis:\n  cos (Arccos z) = 1\n\ngoal (1 subgoal):\n 1. z + \\<i> * csqrt (1 - z\\<^sup>2) = 1 \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  cos (Arccos z) = 1\n\ngoal (1 subgoal):\n 1. z + \\<i> * csqrt (1 - z\\<^sup>2) = 1 \\<Longrightarrow> False", "have \"cos (Arccos z) = z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cos (Arccos z) = z", "by simp"], ["proof (state)\nthis:\n  cos (Arccos z) = z\n\ngoal (1 subgoal):\n 1. z + \\<i> * csqrt (1 - z\\<^sup>2) = 1 \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  z = 1", "show False"], ["proof (prove)\nusing this:\n  z = 1\n\ngoal (1 subgoal):\n 1. False", "using \\<open>z \\<noteq> 1\\<close>"], ["proof (prove)\nusing this:\n  z = 1\n  z \\<noteq> 1\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  z + \\<i> * csqrt (1 - z\\<^sup>2) \\<noteq> 1\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (Arccos z)", "ultimately"], ["proof (chain)\npicking this:\n  z + \\<i> * csqrt (1 - z\\<^sup>2) \\<noteq> 0\n  z + \\<i> * csqrt (1 - z\\<^sup>2) \\<noteq> 1", "have \"\\<not> algebraic (Ln (z + \\<i> * csqrt (1 - z\\<^sup>2)))\""], ["proof (prove)\nusing this:\n  z + \\<i> * csqrt (1 - z\\<^sup>2) \\<noteq> 0\n  z + \\<i> * csqrt (1 - z\\<^sup>2) \\<noteq> 1\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (Ln (z + \\<i> * csqrt (1 - z\\<^sup>2)))", "using assms"], ["proof (prove)\nusing this:\n  z + \\<i> * csqrt (1 - z\\<^sup>2) \\<noteq> 0\n  z + \\<i> * csqrt (1 - z\\<^sup>2) \\<noteq> 1\n  algebraic z\n  z \\<noteq> 1\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (Ln (z + \\<i> * csqrt (1 - z\\<^sup>2)))", "by (intro transcendental_Ln) auto"], ["proof (state)\nthis:\n  \\<not> algebraic (Ln (z + \\<i> * csqrt (1 - z\\<^sup>2)))\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (Arccos z)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> algebraic (Ln (z + \\<i> * csqrt (1 - z\\<^sup>2)))\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (Arccos z)", "by (simp add: Arccos_def)"], ["proof (state)\nthis:\n  \\<not> algebraic (Arccos z)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma transcendental_Arctan:\n  assumes \"algebraic z\" \"z \\<notin> {0, \\<i>, -\\<i>}\"\n  shows   \"\\<not>algebraic (Arctan z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> algebraic (Arctan z)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> algebraic (Arctan z)", "have \"\\<i> * z \\<noteq> 1\" \"1 + \\<i> * z \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<i> * z \\<noteq> 1 &&& 1 + \\<i> * z \\<noteq> 0", "using assms(2)"], ["proof (prove)\nusing this:\n  z \\<notin> {0, \\<i>, - \\<i>}\n\ngoal (1 subgoal):\n 1. \\<i> * z \\<noteq> 1 &&& 1 + \\<i> * z \\<noteq> 0", "by (auto simp: complex_eq_iff)"], ["proof (state)\nthis:\n  \\<i> * z \\<noteq> 1\n  1 + \\<i> * z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (Arctan z)", "hence \"\\<not> algebraic (Ln ((1 - \\<i> * z) / (1 + \\<i> * z)))\""], ["proof (prove)\nusing this:\n  \\<i> * z \\<noteq> 1\n  1 + \\<i> * z \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (Ln ((1 - \\<i> * z) / (1 + \\<i> * z)))", "using assms"], ["proof (prove)\nusing this:\n  \\<i> * z \\<noteq> 1\n  1 + \\<i> * z \\<noteq> 0\n  algebraic z\n  z \\<notin> {0, \\<i>, - \\<i>}\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (Ln ((1 - \\<i> * z) / (1 + \\<i> * z)))", "by (intro transcendental_Ln) auto"], ["proof (state)\nthis:\n  \\<not> algebraic (Ln ((1 - \\<i> * z) / (1 + \\<i> * z)))\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (Arctan z)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> algebraic (Ln ((1 - \\<i> * z) / (1 + \\<i> * z)))\n\ngoal (1 subgoal):\n 1. \\<not> algebraic (Arctan z)", "by (simp add: Arctan_def)"], ["proof (state)\nthis:\n  \\<not> algebraic (Arctan z)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}