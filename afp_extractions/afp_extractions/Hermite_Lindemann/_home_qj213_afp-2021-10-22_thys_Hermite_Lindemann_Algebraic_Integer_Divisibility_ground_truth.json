{"file_name": "/home/qj213/afp-2021-10-22/thys/Hermite_Lindemann/Algebraic_Integer_Divisibility.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Hermite_Lindemann", "problem_names": ["lemma alg_dvd_imp_algebraic_int:\n  fixes x y :: \"'a :: field_char_0\"\n  shows \"x alg_dvd y \\<Longrightarrow> algebraic_int x \\<Longrightarrow> algebraic_int y\"", "lemma alg_dvd_0_left_iff [simp]: \"0 alg_dvd x \\<longleftrightarrow> x = 0\"", "lemma alg_dvd_0_right [iff]: \"x alg_dvd 0\"", "lemma one_alg_dvd_iff [simp]: \"1 alg_dvd x \\<longleftrightarrow> algebraic_int x\"", "lemma alg_dvd_of_int [intro]:\n  assumes \"x dvd y\"\n  shows   \"of_int x alg_dvd of_int y\"", "lemma alg_dvd_of_nat [intro]:\n  assumes \"x dvd y\"\n  shows   \"of_nat x alg_dvd of_nat y\"", "lemma alg_dvd_of_int_iff [simp]:\n  \"(of_int x :: 'a :: field_char_0) alg_dvd of_int y \\<longleftrightarrow> x dvd y\"", "lemma alg_dvd_of_nat_iff [simp]:\n  \"(of_nat x :: 'a :: field_char_0) alg_dvd of_nat y \\<longleftrightarrow> x dvd y\"", "lemma alg_dvd_add [intro]:\n  fixes x y z :: \"'a :: field_char_0\"\n  shows \"x alg_dvd y \\<Longrightarrow> x alg_dvd z \\<Longrightarrow> x alg_dvd (y + z)\"", "lemma alg_dvd_uminus_right [intro]: \"x alg_dvd y \\<Longrightarrow> x alg_dvd -y\"", "lemma alg_dvd_uminus_right_iff [simp]: \"x alg_dvd -y \\<longleftrightarrow> x alg_dvd y\"", "lemma alg_dvd_diff [intro]:\n  fixes x y z :: \"'a :: field_char_0\"\n  shows \"x alg_dvd y \\<Longrightarrow> x alg_dvd z \\<Longrightarrow> x alg_dvd (y - z)\"", "lemma alg_dvd_triv_left [intro]: \"algebraic_int y \\<Longrightarrow> x alg_dvd x * y\"", "lemma alg_dvd_triv_right [intro]: \"algebraic_int x \\<Longrightarrow> y alg_dvd x * y\"", "lemma alg_dvd_triv_left_iff: \"x alg_dvd x * y \\<longleftrightarrow> x = 0 \\<or> algebraic_int y\"", "lemma alg_dvd_triv_right_iff: \"y alg_dvd x * y \\<longleftrightarrow> y = 0 \\<or> algebraic_int x\"", "lemma alg_dvd_triv_left_iff' [simp]: \"x \\<noteq> 0 \\<Longrightarrow> x alg_dvd x * y \\<longleftrightarrow> algebraic_int y\"", "lemma alg_dvd_triv_right_iff' [simp]: \"y \\<noteq> 0 \\<Longrightarrow> y alg_dvd x * y \\<longleftrightarrow> algebraic_int x\"", "lemma alg_dvd_trans [trans]:\n  fixes x y z :: \"'a :: field_char_0\"\n  shows \"x alg_dvd y \\<Longrightarrow> y alg_dvd z \\<Longrightarrow> x alg_dvd z\"", "lemma alg_dvd_mono [simp]: \n  fixes a b c d :: \"'a :: field_char_0\"\n  shows \"a alg_dvd c \\<Longrightarrow> b alg_dvd d \\<Longrightarrow> (a * b) alg_dvd (c * d)\"", "lemma alg_dvd_mult [simp]: \n  fixes a b c :: \"'a :: field_char_0\"\n  shows \"a alg_dvd c \\<Longrightarrow> algebraic_int b \\<Longrightarrow> a alg_dvd (b * c)\"", "lemma alg_dvd_mult2 [simp]:\n  fixes a b c :: \"'a :: field_char_0\"\n  shows \"a alg_dvd b \\<Longrightarrow> algebraic_int c \\<Longrightarrow> a alg_dvd (b * c)\"", "lemma alg_dvd_int_rat:\n  fixes y :: \"'a :: field_char_0\"\n  assumes \"of_int x alg_dvd y\" and \"y \\<in> \\<rat>\"\n  shows   \"\\<exists>n. y = of_int n \\<and> x dvd n\"", "lemma prod_alg_dvd_prod:\n  fixes f :: \"'a \\<Rightarrow> 'b :: field_char_0\"\n  assumes \"\\<And>x. x \\<in> A \\<Longrightarrow> f x alg_dvd g x\"\n  shows   \"prod f A alg_dvd prod g A\"", "lemma alg_dvd_sum:\n  fixes f :: \"'a \\<Rightarrow> 'b :: field_char_0\"\n  assumes \"\\<And>x. x \\<in> A \\<Longrightarrow> y alg_dvd f x\"\n  shows   \"y alg_dvd sum f A\"", "lemma not_alg_dvd_sum:\n  fixes f :: \"'a \\<Rightarrow> 'b :: field_char_0\"\n  assumes \"\\<And>x. x \\<in> A-{x'} \\<Longrightarrow> y alg_dvd f x\"\n  assumes \"\\<not>y alg_dvd f x'\"\n  assumes \"x' \\<in> A\" \"finite A\"\n  shows   \"\\<not>y alg_dvd sum f A\"", "lemma fact_dvd_pochhammer:\n  assumes \"m \\<le> n + 1\"\n  shows   \"fact m dvd pochhammer (int n - int m + 1) m\"", "lemma coeff_higher_pderiv:\n  \"coeff ((pderiv ^^ m) f) n = pochhammer (of_nat (Suc n)) m * coeff f (n + m)\"", "lemma fact_alg_dvd_poly_higher_pderiv:\n  fixes p :: \"'a :: field_char_0 poly\"\n  assumes \"\\<And>i. algebraic_int (poly.coeff p i)\" \"algebraic_int x\" \"m \\<le> k\"\n  shows   \"fact m alg_dvd poly ((pderiv ^^ k) p) x\""], "translations": [["", "lemma alg_dvd_imp_algebraic_int:\n  fixes x y :: \"'a :: field_char_0\"\n  shows \"x alg_dvd y \\<Longrightarrow> algebraic_int x \\<Longrightarrow> algebraic_int y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x alg_dvd y; algebraic_int x\\<rbrakk>\n    \\<Longrightarrow> algebraic_int y", "using algebraic_int_times[of \"y / x\" x]"], ["proof (prove)\nusing this:\n  \\<lbrakk>algebraic_int (y / x); algebraic_int x\\<rbrakk>\n  \\<Longrightarrow> algebraic_int (y / x * x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x alg_dvd y; algebraic_int x\\<rbrakk>\n    \\<Longrightarrow> algebraic_int y", "by (auto simp: alg_dvd_def)"], ["", "lemma alg_dvd_0_left_iff [simp]: \"0 alg_dvd x \\<longleftrightarrow> x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((0::'a) alg_dvd x) = (x = (0::'a))", "by (auto simp: alg_dvd_def)"], ["", "lemma alg_dvd_0_right [iff]: \"x alg_dvd 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x alg_dvd (0::'a)", "by (auto simp: alg_dvd_def)"], ["", "lemma one_alg_dvd_iff [simp]: \"1 alg_dvd x \\<longleftrightarrow> algebraic_int x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((1::'a) alg_dvd x) = algebraic_int x", "by (auto simp: alg_dvd_def)"], ["", "lemma alg_dvd_of_int [intro]:\n  assumes \"x dvd y\"\n  shows   \"of_int x alg_dvd of_int y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int x alg_dvd of_int y", "proof (cases \"of_int x = (0 :: 'a)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. of_int x = (0::'a) \\<Longrightarrow> of_int x alg_dvd of_int y\n 2. of_int x \\<noteq> (0::'a) \\<Longrightarrow> of_int x alg_dvd of_int y", "case False"], ["proof (state)\nthis:\n  of_int x \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. of_int x = (0::'a) \\<Longrightarrow> of_int x alg_dvd of_int y\n 2. of_int x \\<noteq> (0::'a) \\<Longrightarrow> of_int x alg_dvd of_int y", "from assms"], ["proof (chain)\npicking this:\n  x dvd y", "obtain z where z: \"y = x * z\""], ["proof (prove)\nusing this:\n  x dvd y\n\ngoal (1 subgoal):\n 1. (\\<And>z. y = x * z \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by (elim dvdE)"], ["proof (state)\nthis:\n  y = x * z\n\ngoal (2 subgoals):\n 1. of_int x = (0::'a) \\<Longrightarrow> of_int x alg_dvd of_int y\n 2. of_int x \\<noteq> (0::'a) \\<Longrightarrow> of_int x alg_dvd of_int y", "have \"algebraic_int (of_int z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic_int (of_int z)", "by auto"], ["proof (state)\nthis:\n  algebraic_int (of_int z)\n\ngoal (2 subgoals):\n 1. of_int x = (0::'a) \\<Longrightarrow> of_int x alg_dvd of_int y\n 2. of_int x \\<noteq> (0::'a) \\<Longrightarrow> of_int x alg_dvd of_int y", "also"], ["proof (state)\nthis:\n  algebraic_int (of_int z)\n\ngoal (2 subgoals):\n 1. of_int x = (0::'a) \\<Longrightarrow> of_int x alg_dvd of_int y\n 2. of_int x \\<noteq> (0::'a) \\<Longrightarrow> of_int x alg_dvd of_int y", "have \"of_int z = of_int y / (of_int x :: 'a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int z = of_int y / of_int x", "using False"], ["proof (prove)\nusing this:\n  of_int x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. of_int z = of_int y / of_int x", "by (simp add: z field_simps)"], ["proof (state)\nthis:\n  of_int z = of_int y / of_int x\n\ngoal (2 subgoals):\n 1. of_int x = (0::'a) \\<Longrightarrow> of_int x alg_dvd of_int y\n 2. of_int x \\<noteq> (0::'a) \\<Longrightarrow> of_int x alg_dvd of_int y", "finally"], ["proof (chain)\npicking this:\n  algebraic_int (of_int y / of_int x)", "show ?thesis"], ["proof (prove)\nusing this:\n  algebraic_int (of_int y / of_int x)\n\ngoal (1 subgoal):\n 1. of_int x alg_dvd of_int y", "using False"], ["proof (prove)\nusing this:\n  algebraic_int (of_int y / of_int x)\n  of_int x \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. of_int x alg_dvd of_int y", "by (simp add: alg_dvd_def)"], ["proof (state)\nthis:\n  of_int x alg_dvd of_int y\n\ngoal (1 subgoal):\n 1. of_int x = (0::'a) \\<Longrightarrow> of_int x alg_dvd of_int y", "qed (use assms in \\<open>auto simp: alg_dvd_def\\<close>)"], ["", "lemma alg_dvd_of_nat [intro]:\n  assumes \"x dvd y\"\n  shows   \"of_nat x alg_dvd of_nat y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat x alg_dvd of_nat y", "using alg_dvd_of_int[of \"int x\" \"int y\"] assms"], ["proof (prove)\nusing this:\n  int x dvd int y \\<Longrightarrow> of_int (int x) alg_dvd of_int (int y)\n  x dvd y\n\ngoal (1 subgoal):\n 1. of_nat x alg_dvd of_nat y", "by simp"], ["", "lemma alg_dvd_of_int_iff [simp]:\n  \"(of_int x :: 'a :: field_char_0) alg_dvd of_int y \\<longleftrightarrow> x dvd y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_int x alg_dvd of_int y) = (x dvd y)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. of_int x alg_dvd of_int y \\<Longrightarrow> x dvd y\n 2. x dvd y \\<Longrightarrow> of_int x alg_dvd of_int y", "assume \"(of_int x :: 'a) alg_dvd of_int y\""], ["proof (state)\nthis:\n  of_int x alg_dvd of_int y\n\ngoal (2 subgoals):\n 1. of_int x alg_dvd of_int y \\<Longrightarrow> x dvd y\n 2. x dvd y \\<Longrightarrow> of_int x alg_dvd of_int y", "hence \"of_int y / (of_int x :: 'a) \\<in> \\<int>\" and nz: \"of_int x = (0::'a) \\<longrightarrow> of_int y = (0::'a)\""], ["proof (prove)\nusing this:\n  of_int x alg_dvd of_int y\n\ngoal (1 subgoal):\n 1. of_int y / of_int x \\<in> \\<int> &&&\n    of_int x = (0::'a) \\<longrightarrow> of_int y = (0::'a)", "by (auto simp: alg_dvd_def dest!: rational_algebraic_int_is_int)"], ["proof (state)\nthis:\n  of_int y / of_int x \\<in> \\<int>\n  of_int x = (0::'a) \\<longrightarrow> of_int y = (0::'a)\n\ngoal (2 subgoals):\n 1. of_int x alg_dvd of_int y \\<Longrightarrow> x dvd y\n 2. x dvd y \\<Longrightarrow> of_int x alg_dvd of_int y", "then"], ["proof (chain)\npicking this:\n  of_int y / of_int x \\<in> \\<int>\n  of_int x = (0::'a) \\<longrightarrow> of_int y = (0::'a)", "obtain n where \"of_int y / of_int x = (of_int n :: 'a)\""], ["proof (prove)\nusing this:\n  of_int y / of_int x \\<in> \\<int>\n  of_int x = (0::'a) \\<longrightarrow> of_int y = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        of_int y / of_int x = of_int n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (elim Ints_cases)"], ["proof (state)\nthis:\n  of_int y / of_int x = of_int n\n\ngoal (2 subgoals):\n 1. of_int x alg_dvd of_int y \\<Longrightarrow> x dvd y\n 2. x dvd y \\<Longrightarrow> of_int x alg_dvd of_int y", "hence \"of_int y = (of_int (x * n) :: 'a)\""], ["proof (prove)\nusing this:\n  of_int y / of_int x = of_int n\n\ngoal (1 subgoal):\n 1. of_int y = of_int (x * n)", "unfolding of_int_mult"], ["proof (prove)\nusing this:\n  of_int y / of_int x = of_int n\n\ngoal (1 subgoal):\n 1. of_int y = of_int x * of_int n", "using nz"], ["proof (prove)\nusing this:\n  of_int y / of_int x = of_int n\n  of_int x = (0::'a) \\<longrightarrow> of_int y = (0::'a)\n\ngoal (1 subgoal):\n 1. of_int y = of_int x * of_int n", "by (auto simp: field_simps)"], ["proof (state)\nthis:\n  of_int y = of_int (x * n)\n\ngoal (2 subgoals):\n 1. of_int x alg_dvd of_int y \\<Longrightarrow> x dvd y\n 2. x dvd y \\<Longrightarrow> of_int x alg_dvd of_int y", "hence \"y = x * n\""], ["proof (prove)\nusing this:\n  of_int y = of_int (x * n)\n\ngoal (1 subgoal):\n 1. y = x * n", "by (subst (asm) of_int_eq_iff)"], ["proof (state)\nthis:\n  y = x * n\n\ngoal (2 subgoals):\n 1. of_int x alg_dvd of_int y \\<Longrightarrow> x dvd y\n 2. x dvd y \\<Longrightarrow> of_int x alg_dvd of_int y", "thus \"x dvd y\""], ["proof (prove)\nusing this:\n  y = x * n\n\ngoal (1 subgoal):\n 1. x dvd y", "by auto"], ["proof (state)\nthis:\n  x dvd y\n\ngoal (1 subgoal):\n 1. x dvd y \\<Longrightarrow> of_int x alg_dvd of_int y", "qed blast"], ["", "lemma alg_dvd_of_nat_iff [simp]:\n  \"(of_nat x :: 'a :: field_char_0) alg_dvd of_nat y \\<longleftrightarrow> x dvd y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_nat x alg_dvd of_nat y) = (x dvd y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (of_nat x alg_dvd of_nat y) = (x dvd y)", "have \"(of_int (int x) :: 'a) alg_dvd of_int (int y) \\<longleftrightarrow> x dvd y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (of_int (int x) alg_dvd of_int (int y)) = (x dvd y)", "by (subst alg_dvd_of_int_iff) auto"], ["proof (state)\nthis:\n  (of_int (int x) alg_dvd of_int (int y)) = (x dvd y)\n\ngoal (1 subgoal):\n 1. (of_nat x alg_dvd of_nat y) = (x dvd y)", "thus ?thesis"], ["proof (prove)\nusing this:\n  (of_int (int x) alg_dvd of_int (int y)) = (x dvd y)\n\ngoal (1 subgoal):\n 1. (of_nat x alg_dvd of_nat y) = (x dvd y)", "unfolding of_int_of_nat_eq"], ["proof (prove)\nusing this:\n  (of_nat x alg_dvd of_nat y) = (x dvd y)\n\ngoal (1 subgoal):\n 1. (of_nat x alg_dvd of_nat y) = (x dvd y)", "."], ["proof (state)\nthis:\n  (of_nat x alg_dvd of_nat y) = (x dvd y)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma alg_dvd_add [intro]:\n  fixes x y z :: \"'a :: field_char_0\"\n  shows \"x alg_dvd y \\<Longrightarrow> x alg_dvd z \\<Longrightarrow> x alg_dvd (y + z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x alg_dvd y; x alg_dvd z\\<rbrakk>\n    \\<Longrightarrow> x alg_dvd y + z", "unfolding alg_dvd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x = (0::'a) \\<longrightarrow> y = (0::'a)) \\<and>\n             algebraic_int (y / x);\n     (x = (0::'a) \\<longrightarrow> z = (0::'a)) \\<and>\n     algebraic_int (z / x)\\<rbrakk>\n    \\<Longrightarrow> (x = (0::'a) \\<longrightarrow> y + z = (0::'a)) \\<and>\n                      algebraic_int ((y + z) / x)", "by (auto simp: add_divide_distrib)"], ["", "lemma alg_dvd_uminus_right [intro]: \"x alg_dvd y \\<Longrightarrow> x alg_dvd -y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x alg_dvd y \\<Longrightarrow> x alg_dvd - y", "by (auto simp: alg_dvd_def)"], ["", "lemma alg_dvd_uminus_right_iff [simp]: \"x alg_dvd -y \\<longleftrightarrow> x alg_dvd y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x alg_dvd - y) = (x alg_dvd y)", "using alg_dvd_uminus_right[of x y] alg_dvd_uminus_right[of x \"-y\"]"], ["proof (prove)\nusing this:\n  x alg_dvd y \\<Longrightarrow> x alg_dvd - y\n  x alg_dvd - y \\<Longrightarrow> x alg_dvd - (- y)\n\ngoal (1 subgoal):\n 1. (x alg_dvd - y) = (x alg_dvd y)", "by auto"], ["", "lemma alg_dvd_diff [intro]:\n  fixes x y z :: \"'a :: field_char_0\"\n  shows \"x alg_dvd y \\<Longrightarrow> x alg_dvd z \\<Longrightarrow> x alg_dvd (y - z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x alg_dvd y; x alg_dvd z\\<rbrakk>\n    \\<Longrightarrow> x alg_dvd y - z", "unfolding alg_dvd_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(x = (0::'a) \\<longrightarrow> y = (0::'a)) \\<and>\n             algebraic_int (y / x);\n     (x = (0::'a) \\<longrightarrow> z = (0::'a)) \\<and>\n     algebraic_int (z / x)\\<rbrakk>\n    \\<Longrightarrow> (x = (0::'a) \\<longrightarrow> y - z = (0::'a)) \\<and>\n                      algebraic_int ((y - z) / x)", "by (auto simp: diff_divide_distrib)"], ["", "lemma alg_dvd_triv_left [intro]: \"algebraic_int y \\<Longrightarrow> x alg_dvd x * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic_int y \\<Longrightarrow> x alg_dvd x * y", "by (auto simp: alg_dvd_def)"], ["", "lemma alg_dvd_triv_right [intro]: \"algebraic_int x \\<Longrightarrow> y alg_dvd x * y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. algebraic_int x \\<Longrightarrow> y alg_dvd x * y", "by (auto simp: alg_dvd_def)"], ["", "lemma alg_dvd_triv_left_iff: \"x alg_dvd x * y \\<longleftrightarrow> x = 0 \\<or> algebraic_int y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x alg_dvd x * y) = (x = (0::'a) \\<or> algebraic_int y)", "by (auto simp: alg_dvd_def)"], ["", "lemma alg_dvd_triv_right_iff: \"y alg_dvd x * y \\<longleftrightarrow> y = 0 \\<or> algebraic_int x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (y alg_dvd x * y) = (y = (0::'a) \\<or> algebraic_int x)", "by (auto simp: alg_dvd_def)"], ["", "lemma alg_dvd_triv_left_iff' [simp]: \"x \\<noteq> 0 \\<Longrightarrow> x alg_dvd x * y \\<longleftrightarrow> algebraic_int y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> (0::'a) \\<Longrightarrow> (x alg_dvd x * y) = algebraic_int y", "by (simp add: alg_dvd_triv_left_iff)"], ["", "lemma alg_dvd_triv_right_iff' [simp]: \"y \\<noteq> 0 \\<Longrightarrow> y alg_dvd x * y \\<longleftrightarrow> algebraic_int x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<noteq> (0::'a) \\<Longrightarrow> (y alg_dvd x * y) = algebraic_int x", "by (simp add: alg_dvd_triv_right_iff)"], ["", "lemma alg_dvd_trans [trans]:\n  fixes x y z :: \"'a :: field_char_0\"\n  shows \"x alg_dvd y \\<Longrightarrow> y alg_dvd z \\<Longrightarrow> x alg_dvd z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x alg_dvd y; y alg_dvd z\\<rbrakk> \\<Longrightarrow> x alg_dvd z", "using algebraic_int_times[of \"y / x\" \"z / y\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>algebraic_int (y / x); algebraic_int (z / y)\\<rbrakk>\n  \\<Longrightarrow> algebraic_int (y / x * (z / y))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x alg_dvd y; y alg_dvd z\\<rbrakk> \\<Longrightarrow> x alg_dvd z", "by (auto simp: alg_dvd_def)"], ["", "lemma alg_dvd_mono [simp]: \n  fixes a b c d :: \"'a :: field_char_0\"\n  shows \"a alg_dvd c \\<Longrightarrow> b alg_dvd d \\<Longrightarrow> (a * b) alg_dvd (c * d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a alg_dvd c; b alg_dvd d\\<rbrakk>\n    \\<Longrightarrow> a * b alg_dvd c * d", "using algebraic_int_times[of \"c / a\" \"d / b\"]"], ["proof (prove)\nusing this:\n  \\<lbrakk>algebraic_int (c / a); algebraic_int (d / b)\\<rbrakk>\n  \\<Longrightarrow> algebraic_int (c / a * (d / b))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a alg_dvd c; b alg_dvd d\\<rbrakk>\n    \\<Longrightarrow> a * b alg_dvd c * d", "by (auto simp: alg_dvd_def)"], ["", "lemma alg_dvd_mult [simp]: \n  fixes a b c :: \"'a :: field_char_0\"\n  shows \"a alg_dvd c \\<Longrightarrow> algebraic_int b \\<Longrightarrow> a alg_dvd (b * c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a alg_dvd c; algebraic_int b\\<rbrakk>\n    \\<Longrightarrow> a alg_dvd b * c", "using alg_dvd_mono[of a c 1 b]"], ["proof (prove)\nusing this:\n  \\<lbrakk>a alg_dvd c; (1::'a) alg_dvd b\\<rbrakk>\n  \\<Longrightarrow> a * (1::'a) alg_dvd c * b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a alg_dvd c; algebraic_int b\\<rbrakk>\n    \\<Longrightarrow> a alg_dvd b * c", "by (auto simp: mult.commute)"], ["", "lemma alg_dvd_mult2 [simp]:\n  fixes a b c :: \"'a :: field_char_0\"\n  shows \"a alg_dvd b \\<Longrightarrow> algebraic_int c \\<Longrightarrow> a alg_dvd (b * c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>a alg_dvd b; algebraic_int c\\<rbrakk>\n    \\<Longrightarrow> a alg_dvd b * c", "using alg_dvd_mult[of a b c]"], ["proof (prove)\nusing this:\n  \\<lbrakk>a alg_dvd b; algebraic_int c\\<rbrakk>\n  \\<Longrightarrow> a alg_dvd c * b\n\ngoal (1 subgoal):\n 1. \\<lbrakk>a alg_dvd b; algebraic_int c\\<rbrakk>\n    \\<Longrightarrow> a alg_dvd b * c", "by (simp add: mult.commute)"], ["", "text \\<open>\n  A crucial theorem: if an integer \\<open>x\\<close> divides a rational number \\<open>y\\<close>, then \\<open>y\\<close> is in fact\n  also an integer, and that integer is a multiple of \\<open>x\\<close>.\n\\<close>"], ["", "lemma alg_dvd_int_rat:\n  fixes y :: \"'a :: field_char_0\"\n  assumes \"of_int x alg_dvd y\" and \"y \\<in> \\<rat>\"\n  shows   \"\\<exists>n. y = of_int n \\<and> x dvd n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. y = of_int n \\<and> x dvd n", "proof (cases \"x = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> \\<exists>n. y = of_int n \\<and> x dvd n\n 2. x \\<noteq> 0 \\<Longrightarrow> \\<exists>n. y = of_int n \\<and> x dvd n", "case False"], ["proof (state)\nthis:\n  x \\<noteq> 0\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> \\<exists>n. y = of_int n \\<and> x dvd n\n 2. x \\<noteq> 0 \\<Longrightarrow> \\<exists>n. y = of_int n \\<and> x dvd n", "have \"y / of_int x \\<in> \\<int>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y / of_int x \\<in> \\<int>", "by (intro rational_algebraic_int_is_int) (use assms in \\<open>auto simp: alg_dvd_def\\<close>)"], ["proof (state)\nthis:\n  y / of_int x \\<in> \\<int>\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> \\<exists>n. y = of_int n \\<and> x dvd n\n 2. x \\<noteq> 0 \\<Longrightarrow> \\<exists>n. y = of_int n \\<and> x dvd n", "then"], ["proof (chain)\npicking this:\n  y / of_int x \\<in> \\<int>", "obtain n where n: \"of_int n = y / (of_int x :: 'a)\""], ["proof (prove)\nusing this:\n  y / of_int x \\<in> \\<int>\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        of_int n = y / of_int x \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (elim Ints_cases) auto"], ["proof (state)\nthis:\n  of_int n = y / of_int x\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> \\<exists>n. y = of_int n \\<and> x dvd n\n 2. x \\<noteq> 0 \\<Longrightarrow> \\<exists>n. y = of_int n \\<and> x dvd n", "hence \"y = of_int (n * x)\""], ["proof (prove)\nusing this:\n  of_int n = y / of_int x\n\ngoal (1 subgoal):\n 1. y = of_int (n * x)", "using False"], ["proof (prove)\nusing this:\n  of_int n = y / of_int x\n  x \\<noteq> 0\n\ngoal (1 subgoal):\n 1. y = of_int (n * x)", "by (simp add: field_simps)"], ["proof (state)\nthis:\n  y = of_int (n * x)\n\ngoal (2 subgoals):\n 1. x = 0 \\<Longrightarrow> \\<exists>n. y = of_int n \\<and> x dvd n\n 2. x \\<noteq> 0 \\<Longrightarrow> \\<exists>n. y = of_int n \\<and> x dvd n", "thus ?thesis"], ["proof (prove)\nusing this:\n  y = of_int (n * x)\n\ngoal (1 subgoal):\n 1. \\<exists>n. y = of_int n \\<and> x dvd n", "by (intro exI[of _ \"x * n\"]) auto"], ["proof (state)\nthis:\n  \\<exists>n. y = of_int n \\<and> x dvd n\n\ngoal (1 subgoal):\n 1. x = 0 \\<Longrightarrow> \\<exists>n. y = of_int n \\<and> x dvd n", "qed (use assms in auto)"], ["", "lemma prod_alg_dvd_prod:\n  fixes f :: \"'a \\<Rightarrow> 'b :: field_char_0\"\n  assumes \"\\<And>x. x \\<in> A \\<Longrightarrow> f x alg_dvd g x\"\n  shows   \"prod f A alg_dvd prod g A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prod f A alg_dvd prod g A", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> A \\<Longrightarrow> f ?x alg_dvd g ?x\n\ngoal (1 subgoal):\n 1. prod f A alg_dvd prod g A", "by (induction A rule: infinite_finite_induct) auto"], ["", "lemma alg_dvd_sum:\n  fixes f :: \"'a \\<Rightarrow> 'b :: field_char_0\"\n  assumes \"\\<And>x. x \\<in> A \\<Longrightarrow> y alg_dvd f x\"\n  shows   \"y alg_dvd sum f A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y alg_dvd sum f A", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> A \\<Longrightarrow> y alg_dvd f ?x\n\ngoal (1 subgoal):\n 1. y alg_dvd sum f A", "by (induction A rule: infinite_finite_induct) auto"], ["", "lemma not_alg_dvd_sum:\n  fixes f :: \"'a \\<Rightarrow> 'b :: field_char_0\"\n  assumes \"\\<And>x. x \\<in> A-{x'} \\<Longrightarrow> y alg_dvd f x\"\n  assumes \"\\<not>y alg_dvd f x'\"\n  assumes \"x' \\<in> A\" \"finite A\"\n  shows   \"\\<not>y alg_dvd sum f A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> y alg_dvd sum f A", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. y alg_dvd sum f A \\<Longrightarrow> False", "assume *: \"y alg_dvd sum f A\""], ["proof (state)\nthis:\n  y alg_dvd sum f A\n\ngoal (1 subgoal):\n 1. y alg_dvd sum f A \\<Longrightarrow> False", "have \"y alg_dvd sum f A - sum f (A - {x'})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y alg_dvd sum f A - sum f (A - {x'})", "using \\<open>x' \\<in> A\\<close>"], ["proof (prove)\nusing this:\n  x' \\<in> A\n\ngoal (1 subgoal):\n 1. y alg_dvd sum f A - sum f (A - {x'})", "by (intro alg_dvd_diff[OF * alg_dvd_sum] assms) auto"], ["proof (state)\nthis:\n  y alg_dvd sum f A - sum f (A - {x'})\n\ngoal (1 subgoal):\n 1. y alg_dvd sum f A \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  y alg_dvd sum f A - sum f (A - {x'})\n\ngoal (1 subgoal):\n 1. y alg_dvd sum f A \\<Longrightarrow> False", "have \"\\<dots> = sum f (A - (A - {x'}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum f A - sum f (A - {x'}) = sum f (A - (A - {x'}))", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> A - {x'} \\<Longrightarrow> y alg_dvd f ?x\n  \\<not> y alg_dvd f x'\n  x' \\<in> A\n  finite A\n\ngoal (1 subgoal):\n 1. sum f A - sum f (A - {x'}) = sum f (A - (A - {x'}))", "by (subst sum_diff) auto"], ["proof (state)\nthis:\n  sum f A - sum f (A - {x'}) = sum f (A - (A - {x'}))\n\ngoal (1 subgoal):\n 1. y alg_dvd sum f A \\<Longrightarrow> False", "also"], ["proof (state)\nthis:\n  sum f A - sum f (A - {x'}) = sum f (A - (A - {x'}))\n\ngoal (1 subgoal):\n 1. y alg_dvd sum f A \\<Longrightarrow> False", "have \"A - (A - {x'}) = {x'}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A - (A - {x'}) = {x'}", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> A - {x'} \\<Longrightarrow> y alg_dvd f ?x\n  \\<not> y alg_dvd f x'\n  x' \\<in> A\n  finite A\n\ngoal (1 subgoal):\n 1. A - (A - {x'}) = {x'}", "by auto"], ["proof (state)\nthis:\n  A - (A - {x'}) = {x'}\n\ngoal (1 subgoal):\n 1. y alg_dvd sum f A \\<Longrightarrow> False", "finally"], ["proof (chain)\npicking this:\n  y alg_dvd sum f {x'}", "show False"], ["proof (prove)\nusing this:\n  y alg_dvd sum f {x'}\n\ngoal (1 subgoal):\n 1. False", "using assms"], ["proof (prove)\nusing this:\n  y alg_dvd sum f {x'}\n  ?x \\<in> A - {x'} \\<Longrightarrow> y alg_dvd f ?x\n  \\<not> y alg_dvd f x'\n  x' \\<in> A\n  finite A\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fact_dvd_pochhammer:\n  assumes \"m \\<le> n + 1\"\n  shows   \"fact m dvd pochhammer (int n - int m + 1) m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fact m dvd pochhammer (int n - int m + 1) m", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. fact m dvd pochhammer (int n - int m + 1) m", "have \"(real n gchoose m) * fact m = of_int (pochhammer (int n - int m + 1) m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (real n gchoose m) * fact m =\n    real_of_int (pochhammer (int n - int m + 1) m)", "by (simp add: gbinomial_pochhammer' pochhammer_of_int [symmetric])"], ["proof (state)\nthis:\n  (real n gchoose m) * fact m =\n  real_of_int (pochhammer (int n - int m + 1) m)\n\ngoal (1 subgoal):\n 1. fact m dvd pochhammer (int n - int m + 1) m", "also"], ["proof (state)\nthis:\n  (real n gchoose m) * fact m =\n  real_of_int (pochhammer (int n - int m + 1) m)\n\ngoal (1 subgoal):\n 1. fact m dvd pochhammer (int n - int m + 1) m", "have \"(real n gchoose m) * fact m = of_int (int (n choose m) * fact m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (real n gchoose m) * fact m = real_of_int (int (n choose m) * fact m)", "by (simp add: binomial_gbinomial)"], ["proof (state)\nthis:\n  (real n gchoose m) * fact m = real_of_int (int (n choose m) * fact m)\n\ngoal (1 subgoal):\n 1. fact m dvd pochhammer (int n - int m + 1) m", "finally"], ["proof (chain)\npicking this:\n  real_of_int (int (n choose m) * fact m) =\n  real_of_int (pochhammer (int n - int m + 1) m)", "have \"int (n choose m) * fact m = pochhammer (int n - int m + 1) m\""], ["proof (prove)\nusing this:\n  real_of_int (int (n choose m) * fact m) =\n  real_of_int (pochhammer (int n - int m + 1) m)\n\ngoal (1 subgoal):\n 1. int (n choose m) * fact m = pochhammer (int n - int m + 1) m", "by (subst (asm) of_int_eq_iff)"], ["proof (state)\nthis:\n  int (n choose m) * fact m = pochhammer (int n - int m + 1) m\n\ngoal (1 subgoal):\n 1. fact m dvd pochhammer (int n - int m + 1) m", "from this [symmetric]"], ["proof (chain)\npicking this:\n  pochhammer (int n - int m + 1) m = int (n choose m) * fact m", "show ?thesis"], ["proof (prove)\nusing this:\n  pochhammer (int n - int m + 1) m = int (n choose m) * fact m\n\ngoal (1 subgoal):\n 1. fact m dvd pochhammer (int n - int m + 1) m", "by simp"], ["proof (state)\nthis:\n  fact m dvd pochhammer (int n - int m + 1) m\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma coeff_higher_pderiv:\n  \"coeff ((pderiv ^^ m) f) n = pochhammer (of_nat (Suc n)) m * coeff f (n + m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff ((pderiv ^^ m) f) n =\n    pochhammer (of_nat (Suc n)) m * coeff f (n + m)", "by (induction m arbitrary: n) (simp_all add: coeff_pderiv pochhammer_rec algebra_simps)"], ["", "lemma fact_alg_dvd_poly_higher_pderiv:\n  fixes p :: \"'a :: field_char_0 poly\"\n  assumes \"\\<And>i. algebraic_int (poly.coeff p i)\" \"algebraic_int x\" \"m \\<le> k\"\n  shows   \"fact m alg_dvd poly ((pderiv ^^ k) p) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fact m alg_dvd poly ((pderiv ^^ k) p) x", "unfolding poly_altdef"], ["proof (prove)\ngoal (1 subgoal):\n 1. fact m alg_dvd\n    (\\<Sum>i\\<le>degree ((pderiv ^^ k) p).\n        coeff ((pderiv ^^ k) p) i * x ^ i)", "proof (intro alg_dvd_sum, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {..degree ((pderiv ^^ k) p)} \\<Longrightarrow>\n       fact m alg_dvd coeff ((pderiv ^^ k) p) xa * x ^ xa", "case (1 i)"], ["proof (state)\nthis:\n  i \\<in> {..degree ((pderiv ^^ k) p)}\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {..degree ((pderiv ^^ k) p)} \\<Longrightarrow>\n       fact m alg_dvd coeff ((pderiv ^^ k) p) xa * x ^ xa", "have \"(of_int (fact m) :: 'a) alg_dvd (of_int (fact k))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (fact m) alg_dvd of_int (fact k)", "by (intro alg_dvd_of_int fact_dvd assms)"], ["proof (state)\nthis:\n  of_int (fact m) alg_dvd of_int (fact k)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {..degree ((pderiv ^^ k) p)} \\<Longrightarrow>\n       fact m alg_dvd coeff ((pderiv ^^ k) p) xa * x ^ xa", "also"], ["proof (state)\nthis:\n  of_int (fact m) alg_dvd of_int (fact k)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {..degree ((pderiv ^^ k) p)} \\<Longrightarrow>\n       fact m alg_dvd coeff ((pderiv ^^ k) p) xa * x ^ xa", "have \"(of_int (fact k) :: 'a) alg_dvd of_int (pochhammer (int i + 1) k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_int (fact k) alg_dvd of_int (pochhammer (int i + 1) k)", "using fact_dvd_pochhammer[of k \"i + k\"]"], ["proof (prove)\nusing this:\n  k \\<le> i + k + 1 \\<Longrightarrow>\n  fact k dvd pochhammer (int (i + k) - int k + 1) k\n\ngoal (1 subgoal):\n 1. of_int (fact k) alg_dvd of_int (pochhammer (int i + 1) k)", "by (intro alg_dvd_of_int fact_dvd_pochhammer) (auto simp: algebra_simps)"], ["proof (state)\nthis:\n  of_int (fact k) alg_dvd of_int (pochhammer (int i + 1) k)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {..degree ((pderiv ^^ k) p)} \\<Longrightarrow>\n       fact m alg_dvd coeff ((pderiv ^^ k) p) xa * x ^ xa", "finally"], ["proof (chain)\npicking this:\n  of_int (fact m) alg_dvd of_int (pochhammer (int i + 1) k)", "have \"fact m alg_dvd (pochhammer (of_nat i + 1) k :: 'a)\""], ["proof (prove)\nusing this:\n  of_int (fact m) alg_dvd of_int (pochhammer (int i + 1) k)\n\ngoal (1 subgoal):\n 1. fact m alg_dvd pochhammer (of_nat i + (1::'a)) k", "by (simp flip: pochhammer_of_int)"], ["proof (state)\nthis:\n  fact m alg_dvd pochhammer (of_nat i + (1::'a)) k\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {..degree ((pderiv ^^ k) p)} \\<Longrightarrow>\n       fact m alg_dvd coeff ((pderiv ^^ k) p) xa * x ^ xa", "also"], ["proof (state)\nthis:\n  fact m alg_dvd pochhammer (of_nat i + (1::'a)) k\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {..degree ((pderiv ^^ k) p)} \\<Longrightarrow>\n       fact m alg_dvd coeff ((pderiv ^^ k) p) xa * x ^ xa", "have \"\\<dots> alg_dvd pochhammer (of_nat i + 1) k * poly.coeff p (i + k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pochhammer (of_nat i + (1::'a)) k alg_dvd\n    pochhammer (of_nat i + (1::'a)) k * coeff p (i + k)", "by (rule alg_dvd_triv_left) (rule assms)"], ["proof (state)\nthis:\n  pochhammer (of_nat i + (1::'a)) k alg_dvd\n  pochhammer (of_nat i + (1::'a)) k * coeff p (i + k)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {..degree ((pderiv ^^ k) p)} \\<Longrightarrow>\n       fact m alg_dvd coeff ((pderiv ^^ k) p) xa * x ^ xa", "also"], ["proof (state)\nthis:\n  pochhammer (of_nat i + (1::'a)) k alg_dvd\n  pochhammer (of_nat i + (1::'a)) k * coeff p (i + k)\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {..degree ((pderiv ^^ k) p)} \\<Longrightarrow>\n       fact m alg_dvd coeff ((pderiv ^^ k) p) xa * x ^ xa", "have \"\\<dots> = poly.coeff ((pderiv ^^ k) p) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pochhammer (of_nat i + (1::'a)) k * coeff p (i + k) =\n    coeff ((pderiv ^^ k) p) i", "unfolding coeff_higher_pderiv"], ["proof (prove)\ngoal (1 subgoal):\n 1. pochhammer (of_nat i + (1::'a)) k * coeff p (i + k) =\n    pochhammer (of_nat (Suc i)) k * coeff p (i + k)", "by (simp add: add_ac flip: pochhammer_of_int)"], ["proof (state)\nthis:\n  pochhammer (of_nat i + (1::'a)) k * coeff p (i + k) =\n  coeff ((pderiv ^^ k) p) i\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {..degree ((pderiv ^^ k) p)} \\<Longrightarrow>\n       fact m alg_dvd coeff ((pderiv ^^ k) p) xa * x ^ xa", "also"], ["proof (state)\nthis:\n  pochhammer (of_nat i + (1::'a)) k * coeff p (i + k) =\n  coeff ((pderiv ^^ k) p) i\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {..degree ((pderiv ^^ k) p)} \\<Longrightarrow>\n       fact m alg_dvd coeff ((pderiv ^^ k) p) xa * x ^ xa", "have \"\\<dots> alg_dvd poly.coeff ((pderiv ^^ k) p) i * x ^ i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coeff ((pderiv ^^ k) p) i alg_dvd coeff ((pderiv ^^ k) p) i * x ^ i", "by (intro alg_dvd_triv_left algebraic_int_power assms)"], ["proof (state)\nthis:\n  coeff ((pderiv ^^ k) p) i alg_dvd coeff ((pderiv ^^ k) p) i * x ^ i\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       xa \\<in> {..degree ((pderiv ^^ k) p)} \\<Longrightarrow>\n       fact m alg_dvd coeff ((pderiv ^^ k) p) xa * x ^ xa", "finally"], ["proof (chain)\npicking this:\n  fact m alg_dvd coeff ((pderiv ^^ k) p) i * x ^ i", "show ?case"], ["proof (prove)\nusing this:\n  fact m alg_dvd coeff ((pderiv ^^ k) p) i * x ^ i\n\ngoal (1 subgoal):\n 1. fact m alg_dvd coeff ((pderiv ^^ k) p) i * x ^ i", "."], ["proof (state)\nthis:\n  fact m alg_dvd coeff ((pderiv ^^ k) p) i * x ^ i\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}