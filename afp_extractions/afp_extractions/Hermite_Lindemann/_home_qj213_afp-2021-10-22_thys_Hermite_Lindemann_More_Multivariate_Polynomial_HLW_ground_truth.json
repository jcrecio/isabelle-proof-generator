{"file_name": "/home/qj213/afp-2021-10-22/thys/Hermite_Lindemann/More_Multivariate_Polynomial_HLW.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Hermite_Lindemann", "problem_names": ["lemma Var_altdef: \"Var i = monom (Poly_Mapping.single i 1) 1\"", "lemma Const_conv_monom: \"Const c = monom 0 c\"", "lemma smult_conv_mult_Const: \"smult c p = Const c * p\"", "lemma mpoly_map_vars_Var [simp]: \"bij f \\<Longrightarrow> mpoly_map_vars f (Var i) = Var (f i)\"", "lemma symmetric_mpoly_symmetric_prod':\n  assumes \"\\<And>\\<pi>. \\<pi> permutes A \\<Longrightarrow> g \\<pi> permutes X\"\n  assumes \"\\<And>x \\<pi>. x \\<in> X \\<Longrightarrow> \\<pi> permutes A \\<Longrightarrow> mpoly_map_vars \\<pi> (f x) = f (g \\<pi> x)\"\n  shows \"symmetric_mpoly A (\\<Prod>x\\<in>X. f x)\"", "lemma mpoly_of_poly_0 [simp]: \"mpoly_of_poly i 0 = 0\"", "lemma coeff_mpoly_of_poly1 [simp]:\n  \"coeff (mpoly_of_poly i p) (Poly_Mapping.single i n) = poly.coeff p n\"", "lemma coeff_mpoly_of_poly2 [simp]:\n  assumes \"\\<not>keys x \\<subseteq> {i}\"\n  shows \"coeff (mpoly_of_poly i p) x = 0\"", "lemma coeff_mpoly_of_poly:\n  \"coeff (mpoly_of_poly i p) m =\n     (poly.coeff p (Poly_Mapping.lookup m i) when keys m \\<subseteq> {i})\"", "lemma poly_mapping_single_eq_0_iff [simp]: \"Poly_Mapping.single i n = 0 \\<longleftrightarrow> n = 0\"", "lemma mpoly_of_poly_pCons [simp]:\n  fixes p :: \"'a :: semiring_1 poly\"\n  shows \"mpoly_of_poly i (pCons c p) = Const c + Var i * mpoly_of_poly i p\"", "lemma mpoly_of_poly_1 [simp]: \"mpoly_of_poly i 1 = 1\"", "lemma mpoly_of_poly_uminus [simp]: \"mpoly_of_poly i (-p) = -mpoly_of_poly i p\"", "lemma mpoly_of_poly_add [simp]: \"mpoly_of_poly i (p + q) = mpoly_of_poly i p + mpoly_of_poly i q\"", "lemma mpoly_of_poly_diff [simp]: \"mpoly_of_poly i (p - q) = mpoly_of_poly i p - mpoly_of_poly i q\"", "lemma mpoly_of_poly_smult [simp]:\n  \"mpoly_of_poly i (Polynomial.smult c p) = smult c (mpoly_of_poly i p)\"", "lemma mpoly_of_poly_mult [simp]:\n  fixes p q :: \"'a :: comm_semiring_1 poly\"\n  shows \"mpoly_of_poly i (p * q) = mpoly_of_poly i p * mpoly_of_poly i q\"", "lemma insertion_mpoly_of_poly [simp]: \"insertion f (mpoly_of_poly i p) = poly p (f i)\"", "lemma mapping_of_mpoly_of_poly [simp]: \"mapping_of (mpoly_of_poly i p) = mpoly_of_poly_aux i p\"", "lemma vars_mpoly_of_poly: \"vars (mpoly_of_poly i p) \\<subseteq> {i}\"", "lemma mpoly_map_vars_mpoly_of_poly [simp]:\n  assumes \"bij f\"\n  shows   \"mpoly_map_vars f (mpoly_of_poly i p) = mpoly_of_poly (f i) p\""], "translations": [["", "lemma Var_altdef: \"Var i = monom (Poly_Mapping.single i 1) 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Var i = MPoly_Type.monom (Poly_Mapping.single i 1) (1::'a)", "by transfer' (simp add: Var\\<^sub>0_def)"], ["", "lemma Const_conv_monom: \"Const c = monom 0 c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Const c = MPoly_Type.monom 0 c", "by transfer' (auto simp: Const\\<^sub>0_def)"], ["", "lemma smult_conv_mult_Const: \"smult c p = Const c * p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.smult c p = Const c * p", "by (simp add: smult_conv_mult Const_conv_monom)"], ["", "lemma mpoly_map_vars_Var [simp]: \"bij f \\<Longrightarrow> mpoly_map_vars f (Var i) = Var (f i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij f \\<Longrightarrow> mpoly_map_vars f (Var i) = Var (f i)", "unfolding Var_altdef"], ["proof (prove)\ngoal (1 subgoal):\n 1. bij f \\<Longrightarrow>\n    mpoly_map_vars f (MPoly_Type.monom (Poly_Mapping.single i 1) (1::'a)) =\n    MPoly_Type.monom (Poly_Mapping.single (f i) 1) (1::'a)", "by (subst mpoly_map_vars_monom) (auto simp: permutep_single bij_imp_bij_inv inv_inv_eq)"], ["", "lemma symmetric_mpoly_symmetric_prod':\n  assumes \"\\<And>\\<pi>. \\<pi> permutes A \\<Longrightarrow> g \\<pi> permutes X\"\n  assumes \"\\<And>x \\<pi>. x \\<in> X \\<Longrightarrow> \\<pi> permutes A \\<Longrightarrow> mpoly_map_vars \\<pi> (f x) = f (g \\<pi> x)\"\n  shows \"symmetric_mpoly A (\\<Prod>x\\<in>X. f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. symmetric_mpoly A (prod f X)", "unfolding symmetric_mpoly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<pi>.\n       \\<pi> permutes A \\<longrightarrow>\n       mpoly_map_vars \\<pi> (prod f X) = prod f X", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (prod f X) = prod f X", "fix \\<pi>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (prod f X) = prod f X", "assume \\<pi>: \"\\<pi> permutes A\""], ["proof (state)\nthis:\n  \\<pi> permutes A\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (prod f X) = prod f X", "have \"mpoly_map_vars \\<pi> (prod f X) = (\\<Prod>x\\<in>X. mpoly_map_vars \\<pi> (f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_map_vars \\<pi> (prod f X) =\n    (\\<Prod>x\\<in>X. mpoly_map_vars \\<pi> (f x))", "by simp"], ["proof (state)\nthis:\n  mpoly_map_vars \\<pi> (prod f X) =\n  (\\<Prod>x\\<in>X. mpoly_map_vars \\<pi> (f x))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (prod f X) = prod f X", "also"], ["proof (state)\nthis:\n  mpoly_map_vars \\<pi> (prod f X) =\n  (\\<Prod>x\\<in>X. mpoly_map_vars \\<pi> (f x))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (prod f X) = prod f X", "have \"\\<dots> = (\\<Prod>x\\<in>X. f (g \\<pi> x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<in>X. mpoly_map_vars \\<pi> (f x)) =\n    (\\<Prod>x\\<in>X. f (g \\<pi> x))", "by (intro prod.cong assms \\<pi> refl)"], ["proof (state)\nthis:\n  (\\<Prod>x\\<in>X. mpoly_map_vars \\<pi> (f x)) =\n  (\\<Prod>x\\<in>X. f (g \\<pi> x))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (prod f X) = prod f X", "also"], ["proof (state)\nthis:\n  (\\<Prod>x\\<in>X. mpoly_map_vars \\<pi> (f x)) =\n  (\\<Prod>x\\<in>X. f (g \\<pi> x))\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (prod f X) = prod f X", "have \"\\<dots> = (\\<Prod>x\\<in>g \\<pi>`X. f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<in>X. f (g \\<pi> x)) = prod f (g \\<pi> ` X)", "using assms(1)[OF \\<pi>]"], ["proof (prove)\nusing this:\n  g \\<pi> permutes X\n\ngoal (1 subgoal):\n 1. (\\<Prod>x\\<in>X. f (g \\<pi> x)) = prod f (g \\<pi> ` X)", "by (subst prod.reindex) (auto simp: permutes_inj_on)"], ["proof (state)\nthis:\n  (\\<Prod>x\\<in>X. f (g \\<pi> x)) = prod f (g \\<pi> ` X)\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (prod f X) = prod f X", "also"], ["proof (state)\nthis:\n  (\\<Prod>x\\<in>X. f (g \\<pi> x)) = prod f (g \\<pi> ` X)\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (prod f X) = prod f X", "have \"g \\<pi> ` X = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<pi> ` X = X", "using assms(1)[OF \\<pi>]"], ["proof (prove)\nusing this:\n  g \\<pi> permutes X\n\ngoal (1 subgoal):\n 1. g \\<pi> ` X = X", "by (simp add: permutes_image)"], ["proof (state)\nthis:\n  g \\<pi> ` X = X\n\ngoal (1 subgoal):\n 1. \\<And>\\<pi>.\n       \\<pi> permutes A \\<Longrightarrow>\n       mpoly_map_vars \\<pi> (prod f X) = prod f X", "finally"], ["proof (chain)\npicking this:\n  mpoly_map_vars \\<pi> (prod f X) = prod f X", "show \"mpoly_map_vars \\<pi> (prod f X) = prod f X\""], ["proof (prove)\nusing this:\n  mpoly_map_vars \\<pi> (prod f X) = prod f X\n\ngoal (1 subgoal):\n 1. mpoly_map_vars \\<pi> (prod f X) = prod f X", "."], ["proof (state)\nthis:\n  mpoly_map_vars \\<pi> (prod f X) = prod f X\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Converting a univariate polynomial into a multivariate one\\<close>"], ["", "lift_definition mpoly_of_poly_aux :: \"nat \\<Rightarrow> 'a :: zero poly \\<Rightarrow> (nat \\<Rightarrow>\\<^sub>0 nat) \\<Rightarrow>\\<^sub>0 'a\" is\n  \"\\<lambda>i c m. if Poly_Mapping.keys m \\<subseteq> {i} then c (Poly_Mapping.lookup m i) else 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>nat fun.\n       \\<forall>\\<^sub>\\<infinity>n. fun n = (0::'a) \\<Longrightarrow>\n       finite\n        {x. (if keys x \\<subseteq> {nat} then fun (lookup x nat)\n             else (0::'a)) \\<noteq>\n            (0::'a)}", "proof goal_cases"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat fun.\n       \\<forall>\\<^sub>\\<infinity>n. fun n = (0::'a) \\<Longrightarrow>\n       finite\n        {x. (if keys x \\<subseteq> {nat} then fun (lookup x nat)\n             else (0::'a)) \\<noteq>\n            (0::'a)}", "case (1 i c)"], ["proof (state)\nthis:\n  \\<forall>\\<^sub>\\<infinity>n. c n = (0::'a)\n\ngoal (1 subgoal):\n 1. \\<And>nat fun.\n       \\<forall>\\<^sub>\\<infinity>n. fun n = (0::'a) \\<Longrightarrow>\n       finite\n        {x. (if keys x \\<subseteq> {nat} then fun (lookup x nat)\n             else (0::'a)) \\<noteq>\n            (0::'a)}", "hence fin: \"finite {n. c n \\<noteq> 0}\""], ["proof (prove)\nusing this:\n  \\<forall>\\<^sub>\\<infinity>n. c n = (0::'a)\n\ngoal (1 subgoal):\n 1. finite {n. c n \\<noteq> (0::'a)}", "by (metis eventually_cofinite)"], ["proof (state)\nthis:\n  finite {n. c n \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. \\<And>nat fun.\n       \\<forall>\\<^sub>\\<infinity>n. fun n = (0::'a) \\<Longrightarrow>\n       finite\n        {x. (if keys x \\<subseteq> {nat} then fun (lookup x nat)\n             else (0::'a)) \\<noteq>\n            (0::'a)}", "show \"finite {x. (if keys x \\<subseteq> {i} then c (lookup x i) else 0) \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     {x. (if keys x \\<subseteq> {i} then c (lookup x i)\n          else (0::'a)) \\<noteq>\n         (0::'a)}", "proof (rule finite_subset)"], ["proof (state)\ngoal (2 subgoals):\n 1. {x. (if keys x \\<subseteq> {i} then c (lookup x i)\n         else (0::'a)) \\<noteq>\n        (0::'a)}\n    \\<subseteq> ?B\n 2. finite ?B", "show \"finite (Poly_Mapping.single i ` {n. c n \\<noteq> 0})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Poly_Mapping.single i ` {n. c n \\<noteq> (0::'a)})", "by (intro finite_imageI fin)"], ["proof (state)\nthis:\n  finite (Poly_Mapping.single i ` {n. c n \\<noteq> (0::'a)})\n\ngoal (1 subgoal):\n 1. {x. (if keys x \\<subseteq> {i} then c (lookup x i)\n         else (0::'a)) \\<noteq>\n        (0::'a)}\n    \\<subseteq> Poly_Mapping.single i ` {n. c n \\<noteq> (0::'a)}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. {x. (if keys x \\<subseteq> {i} then c (lookup x i)\n         else (0::'a)) \\<noteq>\n        (0::'a)}\n    \\<subseteq> Poly_Mapping.single i ` {n. c n \\<noteq> (0::'a)}", "show \"{x. (if keys x \\<subseteq> {i} then c (lookup x i) else 0) \\<noteq> 0} \\<subseteq>\n            Poly_Mapping.single i ` {n. c n \\<noteq> 0}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. (if keys x \\<subseteq> {i} then c (lookup x i)\n         else (0::'a)) \\<noteq>\n        (0::'a)}\n    \\<subseteq> Poly_Mapping.single i ` {n. c n \\<noteq> (0::'a)}", "proof (safe, split if_splits)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>keys x \\<subseteq> {i};\n        c (lookup x i) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> Poly_Mapping.single i `\n                                 {n. c n \\<noteq> (0::'a)}\n 2. \\<And>x.\n       \\<lbrakk>\\<not> keys x \\<subseteq> {i};\n        (0::'a) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> Poly_Mapping.single i `\n                                 {n. c n \\<noteq> (0::'a)}", "fix x :: \"(nat \\<Rightarrow>\\<^sub>0 nat)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>keys x \\<subseteq> {i};\n        c (lookup x i) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> Poly_Mapping.single i `\n                                 {n. c n \\<noteq> (0::'a)}\n 2. \\<And>x.\n       \\<lbrakk>\\<not> keys x \\<subseteq> {i};\n        (0::'a) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> Poly_Mapping.single i `\n                                 {n. c n \\<noteq> (0::'a)}", "assume x: \"keys x \\<subseteq> {i}\" \"c (lookup x i) \\<noteq> 0\""], ["proof (state)\nthis:\n  keys x \\<subseteq> {i}\n  c (lookup x i) \\<noteq> (0::'a)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>keys x \\<subseteq> {i};\n        c (lookup x i) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> Poly_Mapping.single i `\n                                 {n. c n \\<noteq> (0::'a)}\n 2. \\<And>x.\n       \\<lbrakk>\\<not> keys x \\<subseteq> {i};\n        (0::'a) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> Poly_Mapping.single i `\n                                 {n. c n \\<noteq> (0::'a)}", "hence \"x = Poly_Mapping.single i (lookup x i)\""], ["proof (prove)\nusing this:\n  keys x \\<subseteq> {i}\n  c (lookup x i) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. x = Poly_Mapping.single i (lookup x i)", "by (metis Diff_eq_empty_iff keys_empty_iff lookup_single_eq\n                  remove_key_keys remove_key_single remove_key_sum)"], ["proof (state)\nthis:\n  x = Poly_Mapping.single i (lookup x i)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>keys x \\<subseteq> {i};\n        c (lookup x i) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> Poly_Mapping.single i `\n                                 {n. c n \\<noteq> (0::'a)}\n 2. \\<And>x.\n       \\<lbrakk>\\<not> keys x \\<subseteq> {i};\n        (0::'a) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> Poly_Mapping.single i `\n                                 {n. c n \\<noteq> (0::'a)}", "thus \"x \\<in> Poly_Mapping.single i ` {n. c n \\<noteq> 0}\""], ["proof (prove)\nusing this:\n  x = Poly_Mapping.single i (lookup x i)\n\ngoal (1 subgoal):\n 1. x \\<in> Poly_Mapping.single i ` {n. c n \\<noteq> (0::'a)}", "using x"], ["proof (prove)\nusing this:\n  x = Poly_Mapping.single i (lookup x i)\n  keys x \\<subseteq> {i}\n  c (lookup x i) \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. x \\<in> Poly_Mapping.single i ` {n. c n \\<noteq> (0::'a)}", "by blast"], ["proof (state)\nthis:\n  x \\<in> Poly_Mapping.single i ` {n. c n \\<noteq> (0::'a)}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<not> keys x \\<subseteq> {i};\n        (0::'a) \\<noteq> (0::'a)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> Poly_Mapping.single i `\n                                 {n. c n \\<noteq> (0::'a)}", "qed auto"], ["proof (state)\nthis:\n  {x. (if keys x \\<subseteq> {i} then c (lookup x i) else (0::'a)) \\<noteq>\n      (0::'a)}\n  \\<subseteq> Poly_Mapping.single i ` {n. c n \\<noteq> (0::'a)}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite\n   {x. (if keys x \\<subseteq> {i} then c (lookup x i) else (0::'a)) \\<noteq>\n       (0::'a)}\n\ngoal:\nNo subgoals!", "qed"], ["", "lift_definition mpoly_of_poly :: \"nat \\<Rightarrow> 'a :: zero poly \\<Rightarrow> 'a mpoly\" is\n  \"mpoly_of_poly_aux\""], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma mpoly_of_poly_0 [simp]: \"mpoly_of_poly i 0 = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_of_poly i 0 = 0", "by (transfer', transfer) auto"], ["", "lemma coeff_mpoly_of_poly1 [simp]:\n  \"coeff (mpoly_of_poly i p) (Poly_Mapping.single i n) = poly.coeff p n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (mpoly_of_poly i p) (Poly_Mapping.single i n) =\n    poly.coeff p n", "by (transfer', transfer') auto"], ["", "lemma coeff_mpoly_of_poly2 [simp]:\n  assumes \"\\<not>keys x \\<subseteq> {i}\"\n  shows \"coeff (mpoly_of_poly i p) x = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (mpoly_of_poly i p) x = (0::'a)", "using assms"], ["proof (prove)\nusing this:\n  \\<not> keys x \\<subseteq> {i}\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (mpoly_of_poly i p) x = (0::'a)", "by (transfer', transfer') auto"], ["", "lemma coeff_mpoly_of_poly:\n  \"coeff (mpoly_of_poly i p) m =\n     (poly.coeff p (Poly_Mapping.lookup m i) when keys m \\<subseteq> {i})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (mpoly_of_poly i p) m =\n    (poly.coeff p (lookup m i) when keys m \\<subseteq> {i})", "by (transfer', transfer') auto"], ["", "lemma poly_mapping_single_eq_0_iff [simp]: \"Poly_Mapping.single i n = 0 \\<longleftrightarrow> n = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Poly_Mapping.single i n = 0) = (n = (0::'b))", "by (metis lookup_single_eq single_zero)"], ["", "lemma mpoly_of_poly_pCons [simp]:\n  fixes p :: \"'a :: semiring_1 poly\"\n  shows \"mpoly_of_poly i (pCons c p) = Const c + Var i * mpoly_of_poly i p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_of_poly i (pCons c p) = Const c + Var i * mpoly_of_poly i p", "proof (rule mpoly_eqI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>mon.\n       MPoly_Type.coeff (mpoly_of_poly i (pCons c p)) mon =\n       MPoly_Type.coeff (Const c + Var i * mpoly_of_poly i p) mon", "fix mon :: \"nat \\<Rightarrow>\\<^sub>0 nat\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>mon.\n       MPoly_Type.coeff (mpoly_of_poly i (pCons c p)) mon =\n       MPoly_Type.coeff (Const c + Var i * mpoly_of_poly i p) mon", "define moni :: \"nat \\<Rightarrow>\\<^sub>0 nat\" where \"moni = Poly_Mapping.single i 1\""], ["proof (state)\nthis:\n  moni = Poly_Mapping.single i 1\n\ngoal (1 subgoal):\n 1. \\<And>mon.\n       MPoly_Type.coeff (mpoly_of_poly i (pCons c p)) mon =\n       MPoly_Type.coeff (Const c + Var i * mpoly_of_poly i p) mon", "have \"coeff (Var i * mpoly_of_poly i p) mon =\n          (\\<Sum>l. (1 when l = moni) * (\\<Sum>q. coeff (mpoly_of_poly i p) q when mon = moni + q))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (Var i * mpoly_of_poly i p) mon =\n    (\\<Sum>l. ((1::'a) when l = moni) *\n              (\\<Sum>q. MPoly_Type.coeff (mpoly_of_poly i p) q when\n                        mon = moni + q))", "unfolding coeff_mpoly_times prod_fun_def coeff_Var moni_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>l. ((1::'a) when l = Poly_Mapping.single i 1) *\n              (\\<Sum>q. MPoly_Type.coeff (mpoly_of_poly i p) q when\n                        mon = l + q)) =\n    (\\<Sum>l. ((1::'a) when l = Poly_Mapping.single i 1) *\n              (\\<Sum>q. MPoly_Type.coeff (mpoly_of_poly i p) q when\n                        mon = Poly_Mapping.single i 1 + q))", "by (rule Sum_any.cong) (auto simp: when_def)"], ["proof (state)\nthis:\n  MPoly_Type.coeff (Var i * mpoly_of_poly i p) mon =\n  (\\<Sum>l. ((1::'a) when l = moni) *\n            (\\<Sum>q. MPoly_Type.coeff (mpoly_of_poly i p) q when\n                      mon = moni + q))\n\ngoal (1 subgoal):\n 1. \\<And>mon.\n       MPoly_Type.coeff (mpoly_of_poly i (pCons c p)) mon =\n       MPoly_Type.coeff (Const c + Var i * mpoly_of_poly i p) mon", "also"], ["proof (state)\nthis:\n  MPoly_Type.coeff (Var i * mpoly_of_poly i p) mon =\n  (\\<Sum>l. ((1::'a) when l = moni) *\n            (\\<Sum>q. MPoly_Type.coeff (mpoly_of_poly i p) q when\n                      mon = moni + q))\n\ngoal (1 subgoal):\n 1. \\<And>mon.\n       MPoly_Type.coeff (mpoly_of_poly i (pCons c p)) mon =\n       MPoly_Type.coeff (Const c + Var i * mpoly_of_poly i p) mon", "have \"\\<dots> = (\\<Sum>a. coeff (mpoly_of_poly i p) a when mon = moni + a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>l. ((1::'a) when l = moni) *\n              (\\<Sum>q. MPoly_Type.coeff (mpoly_of_poly i p) q when\n                        mon = moni + q)) =\n    (\\<Sum>a. MPoly_Type.coeff (mpoly_of_poly i p) a when mon = moni + a)", "by (subst Sum_any_left_distrib [symmetric]) simp_all"], ["proof (state)\nthis:\n  (\\<Sum>l. ((1::'a) when l = moni) *\n            (\\<Sum>q. MPoly_Type.coeff (mpoly_of_poly i p) q when\n                      mon = moni + q)) =\n  (\\<Sum>a. MPoly_Type.coeff (mpoly_of_poly i p) a when mon = moni + a)\n\ngoal (1 subgoal):\n 1. \\<And>mon.\n       MPoly_Type.coeff (mpoly_of_poly i (pCons c p)) mon =\n       MPoly_Type.coeff (Const c + Var i * mpoly_of_poly i p) mon", "finally"], ["proof (chain)\npicking this:\n  MPoly_Type.coeff (Var i * mpoly_of_poly i p) mon =\n  (\\<Sum>a. MPoly_Type.coeff (mpoly_of_poly i p) a when mon = moni + a)", "have eq: \"coeff (Var i * mpoly_of_poly i p) mon = \\<dots>\""], ["proof (prove)\nusing this:\n  MPoly_Type.coeff (Var i * mpoly_of_poly i p) mon =\n  (\\<Sum>a. MPoly_Type.coeff (mpoly_of_poly i p) a when mon = moni + a)\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (Var i * mpoly_of_poly i p) mon =\n    (\\<Sum>a. MPoly_Type.coeff (mpoly_of_poly i p) a when mon = moni + a)", "."], ["proof (state)\nthis:\n  MPoly_Type.coeff (Var i * mpoly_of_poly i p) mon =\n  (\\<Sum>a. MPoly_Type.coeff (mpoly_of_poly i p) a when mon = moni + a)\n\ngoal (1 subgoal):\n 1. \\<And>mon.\n       MPoly_Type.coeff (mpoly_of_poly i (pCons c p)) mon =\n       MPoly_Type.coeff (Const c + Var i * mpoly_of_poly i p) mon", "show \"coeff (mpoly_of_poly i (pCons c p)) mon = coeff (Const c + Var i * mpoly_of_poly i p) mon\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (mpoly_of_poly i (pCons c p)) mon =\n    MPoly_Type.coeff (Const c + Var i * mpoly_of_poly i p) mon", "proof (cases \"keys mon \\<subseteq> {i}\")"], ["proof (state)\ngoal (2 subgoals):\n 1. keys mon \\<subseteq> {i} \\<Longrightarrow>\n    MPoly_Type.coeff (mpoly_of_poly i (pCons c p)) mon =\n    MPoly_Type.coeff (Const c + Var i * mpoly_of_poly i p) mon\n 2. \\<not> keys mon \\<subseteq> {i} \\<Longrightarrow>\n    MPoly_Type.coeff (mpoly_of_poly i (pCons c p)) mon =\n    MPoly_Type.coeff (Const c + Var i * mpoly_of_poly i p) mon", "case False"], ["proof (state)\nthis:\n  \\<not> keys mon \\<subseteq> {i}\n\ngoal (2 subgoals):\n 1. keys mon \\<subseteq> {i} \\<Longrightarrow>\n    MPoly_Type.coeff (mpoly_of_poly i (pCons c p)) mon =\n    MPoly_Type.coeff (Const c + Var i * mpoly_of_poly i p) mon\n 2. \\<not> keys mon \\<subseteq> {i} \\<Longrightarrow>\n    MPoly_Type.coeff (mpoly_of_poly i (pCons c p)) mon =\n    MPoly_Type.coeff (Const c + Var i * mpoly_of_poly i p) mon", "hence [simp]: \"mon \\<noteq> 0\""], ["proof (prove)\nusing this:\n  \\<not> keys mon \\<subseteq> {i}\n\ngoal (1 subgoal):\n 1. mon \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  mon \\<noteq> 0\n\ngoal (2 subgoals):\n 1. keys mon \\<subseteq> {i} \\<Longrightarrow>\n    MPoly_Type.coeff (mpoly_of_poly i (pCons c p)) mon =\n    MPoly_Type.coeff (Const c + Var i * mpoly_of_poly i p) mon\n 2. \\<not> keys mon \\<subseteq> {i} \\<Longrightarrow>\n    MPoly_Type.coeff (mpoly_of_poly i (pCons c p)) mon =\n    MPoly_Type.coeff (Const c + Var i * mpoly_of_poly i p) mon", "obtain j where j: \"j \\<in> keys mon\" \"j \\<noteq> i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>j \\<in> keys mon; j \\<noteq> i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using False"], ["proof (prove)\nusing this:\n  \\<not> keys mon \\<subseteq> {i}\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        \\<lbrakk>j \\<in> keys mon; j \\<noteq> i\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  j \\<in> keys mon\n  j \\<noteq> i\n\ngoal (2 subgoals):\n 1. keys mon \\<subseteq> {i} \\<Longrightarrow>\n    MPoly_Type.coeff (mpoly_of_poly i (pCons c p)) mon =\n    MPoly_Type.coeff (Const c + Var i * mpoly_of_poly i p) mon\n 2. \\<not> keys mon \\<subseteq> {i} \\<Longrightarrow>\n    MPoly_Type.coeff (mpoly_of_poly i (pCons c p)) mon =\n    MPoly_Type.coeff (Const c + Var i * mpoly_of_poly i p) mon", "have \"coeff (mpoly_of_poly i p) mon' = 0\" if mon_eq: \"mon = moni + mon'\" for mon'"], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (mpoly_of_poly i p) mon' = (0::'a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (mpoly_of_poly i p) mon' = (0::'a)", "have \"Poly_Mapping.lookup mon j \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup mon j \\<noteq> 0", "using j"], ["proof (prove)\nusing this:\n  j \\<in> keys mon\n  j \\<noteq> i\n\ngoal (1 subgoal):\n 1. lookup mon j \\<noteq> 0", "by (meson lookup_eq_zero_in_keys_contradict)"], ["proof (state)\nthis:\n  lookup mon j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (mpoly_of_poly i p) mon' = (0::'a)", "also"], ["proof (state)\nthis:\n  lookup mon j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (mpoly_of_poly i p) mon' = (0::'a)", "have \"Poly_Mapping.lookup mon j = Poly_Mapping.lookup mon' j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup mon j = lookup mon' j", "unfolding mon_eq moni_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. lookup (Poly_Mapping.single i 1 + mon') j = lookup mon' j", "using j"], ["proof (prove)\nusing this:\n  j \\<in> keys mon\n  j \\<noteq> i\n\ngoal (1 subgoal):\n 1. lookup (Poly_Mapping.single i 1 + mon') j = lookup mon' j", "by (simp add: lookup_add lookup_single)"], ["proof (state)\nthis:\n  lookup mon j = lookup mon' j\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (mpoly_of_poly i p) mon' = (0::'a)", "finally"], ["proof (chain)\npicking this:\n  lookup mon' j \\<noteq> 0", "have \"j \\<in> keys mon'\""], ["proof (prove)\nusing this:\n  lookup mon' j \\<noteq> 0\n\ngoal (1 subgoal):\n 1. j \\<in> keys mon'", "by (meson lookup_not_eq_zero_eq_in_keys)"], ["proof (state)\nthis:\n  j \\<in> keys mon'\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (mpoly_of_poly i p) mon' = (0::'a)", "with j"], ["proof (chain)\npicking this:\n  j \\<in> keys mon\n  j \\<noteq> i\n  j \\<in> keys mon'", "have \"\\<not>keys mon' \\<subseteq> {i}\""], ["proof (prove)\nusing this:\n  j \\<in> keys mon\n  j \\<noteq> i\n  j \\<in> keys mon'\n\ngoal (1 subgoal):\n 1. \\<not> keys mon' \\<subseteq> {i}", "by blast"], ["proof (state)\nthis:\n  \\<not> keys mon' \\<subseteq> {i}\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (mpoly_of_poly i p) mon' = (0::'a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> keys mon' \\<subseteq> {i}\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (mpoly_of_poly i p) mon' = (0::'a)", "by simp"], ["proof (state)\nthis:\n  MPoly_Type.coeff (mpoly_of_poly i p) mon' = (0::'a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mon = moni + ?mon' \\<Longrightarrow>\n  MPoly_Type.coeff (mpoly_of_poly i p) ?mon' = (0::'a)\n\ngoal (2 subgoals):\n 1. keys mon \\<subseteq> {i} \\<Longrightarrow>\n    MPoly_Type.coeff (mpoly_of_poly i (pCons c p)) mon =\n    MPoly_Type.coeff (Const c + Var i * mpoly_of_poly i p) mon\n 2. \\<not> keys mon \\<subseteq> {i} \\<Longrightarrow>\n    MPoly_Type.coeff (mpoly_of_poly i (pCons c p)) mon =\n    MPoly_Type.coeff (Const c + Var i * mpoly_of_poly i p) mon", "hence \"coeff (Var i * mpoly_of_poly i p) mon = 0\""], ["proof (prove)\nusing this:\n  mon = moni + ?mon' \\<Longrightarrow>\n  MPoly_Type.coeff (mpoly_of_poly i p) ?mon' = (0::'a)\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (Var i * mpoly_of_poly i p) mon = (0::'a)", "unfolding eq"], ["proof (prove)\nusing this:\n  mon = moni + ?mon' \\<Longrightarrow>\n  MPoly_Type.coeff (mpoly_of_poly i p) ?mon' = (0::'a)\n\ngoal (1 subgoal):\n 1. (\\<Sum>a. MPoly_Type.coeff (mpoly_of_poly i p) a when mon = moni + a) =\n    (0::'a)", "by (intro Sum_any_zeroI) (auto simp: when_def)"], ["proof (state)\nthis:\n  MPoly_Type.coeff (Var i * mpoly_of_poly i p) mon = (0::'a)\n\ngoal (2 subgoals):\n 1. keys mon \\<subseteq> {i} \\<Longrightarrow>\n    MPoly_Type.coeff (mpoly_of_poly i (pCons c p)) mon =\n    MPoly_Type.coeff (Const c + Var i * mpoly_of_poly i p) mon\n 2. \\<not> keys mon \\<subseteq> {i} \\<Longrightarrow>\n    MPoly_Type.coeff (mpoly_of_poly i (pCons c p)) mon =\n    MPoly_Type.coeff (Const c + Var i * mpoly_of_poly i p) mon", "thus ?thesis"], ["proof (prove)\nusing this:\n  MPoly_Type.coeff (Var i * mpoly_of_poly i p) mon = (0::'a)\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (mpoly_of_poly i (pCons c p)) mon =\n    MPoly_Type.coeff (Const c + Var i * mpoly_of_poly i p) mon", "using False"], ["proof (prove)\nusing this:\n  MPoly_Type.coeff (Var i * mpoly_of_poly i p) mon = (0::'a)\n  \\<not> keys mon \\<subseteq> {i}\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (mpoly_of_poly i (pCons c p)) mon =\n    MPoly_Type.coeff (Const c + Var i * mpoly_of_poly i p) mon", "by (simp add: mpoly_coeff_Const)"], ["proof (state)\nthis:\n  MPoly_Type.coeff (mpoly_of_poly i (pCons c p)) mon =\n  MPoly_Type.coeff (Const c + Var i * mpoly_of_poly i p) mon\n\ngoal (1 subgoal):\n 1. keys mon \\<subseteq> {i} \\<Longrightarrow>\n    MPoly_Type.coeff (mpoly_of_poly i (pCons c p)) mon =\n    MPoly_Type.coeff (Const c + Var i * mpoly_of_poly i p) mon", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. keys mon \\<subseteq> {i} \\<Longrightarrow>\n    MPoly_Type.coeff (mpoly_of_poly i (pCons c p)) mon =\n    MPoly_Type.coeff (Const c + Var i * mpoly_of_poly i p) mon", "case True"], ["proof (state)\nthis:\n  keys mon \\<subseteq> {i}\n\ngoal (1 subgoal):\n 1. keys mon \\<subseteq> {i} \\<Longrightarrow>\n    MPoly_Type.coeff (mpoly_of_poly i (pCons c p)) mon =\n    MPoly_Type.coeff (Const c + Var i * mpoly_of_poly i p) mon", "define n where \"n = Poly_Mapping.lookup mon i\""], ["proof (state)\nthis:\n  n = lookup mon i\n\ngoal (1 subgoal):\n 1. keys mon \\<subseteq> {i} \\<Longrightarrow>\n    MPoly_Type.coeff (mpoly_of_poly i (pCons c p)) mon =\n    MPoly_Type.coeff (Const c + Var i * mpoly_of_poly i p) mon", "have mon_eq: \"mon = Poly_Mapping.single i n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mon = Poly_Mapping.single i n", "using True"], ["proof (prove)\nusing this:\n  keys mon \\<subseteq> {i}\n\ngoal (1 subgoal):\n 1. mon = Poly_Mapping.single i n", "unfolding n_def"], ["proof (prove)\nusing this:\n  keys mon \\<subseteq> {i}\n\ngoal (1 subgoal):\n 1. mon = Poly_Mapping.single i (lookup mon i)", "by (metis Diff_eq_empty_iff add_cancel_right_left keys_empty_iff remove_key_keys remove_key_sum)"], ["proof (state)\nthis:\n  mon = Poly_Mapping.single i n\n\ngoal (1 subgoal):\n 1. keys mon \\<subseteq> {i} \\<Longrightarrow>\n    MPoly_Type.coeff (mpoly_of_poly i (pCons c p)) mon =\n    MPoly_Type.coeff (Const c + Var i * mpoly_of_poly i p) mon", "have eq': \"mon = moni + mon' \\<longleftrightarrow> n > 0 \\<and> mon' = Poly_Mapping.single i (n - 1)\" for mon'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (mon = moni + mon') =\n    (0 < n \\<and> mon' = Poly_Mapping.single i (n - 1))", "proof safe"], ["proof (state)\ngoal (3 subgoals):\n 1. mon = moni + mon' \\<Longrightarrow> 0 < n\n 2. mon = moni + mon' \\<Longrightarrow> mon' = Poly_Mapping.single i (n - 1)\n 3. \\<lbrakk>0 < n; mon' = Poly_Mapping.single i (n - 1)\\<rbrakk>\n    \\<Longrightarrow> mon = moni + Poly_Mapping.single i (n - 1)", "assume eq: \"mon = moni + mon'\""], ["proof (state)\nthis:\n  mon = moni + mon'\n\ngoal (3 subgoals):\n 1. mon = moni + mon' \\<Longrightarrow> 0 < n\n 2. mon = moni + mon' \\<Longrightarrow> mon' = Poly_Mapping.single i (n - 1)\n 3. \\<lbrakk>0 < n; mon' = Poly_Mapping.single i (n - 1)\\<rbrakk>\n    \\<Longrightarrow> mon = moni + Poly_Mapping.single i (n - 1)", "thus \"n > 0\" \"mon' = Poly_Mapping.single i (n - 1)\""], ["proof (prove)\nusing this:\n  mon = moni + mon'\n\ngoal (1 subgoal):\n 1. 0 < n &&& mon' = Poly_Mapping.single i (n - 1)", "unfolding moni_def mon_eq"], ["proof (prove)\nusing this:\n  Poly_Mapping.single i n = Poly_Mapping.single i 1 + mon'\n\ngoal (1 subgoal):\n 1. 0 < n &&& mon' = Poly_Mapping.single i (n - 1)", "using gr0I"], ["proof (prove)\nusing this:\n  Poly_Mapping.single i n = Poly_Mapping.single i 1 + mon'\n  (?n = 0 \\<Longrightarrow> False) \\<Longrightarrow> 0 < ?n\n\ngoal (1 subgoal):\n 1. 0 < n &&& mon' = Poly_Mapping.single i (n - 1)", "by (force simp: single_diff)+"], ["proof (state)\nthis:\n  0 < n\n  mon' = Poly_Mapping.single i (n - 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; mon' = Poly_Mapping.single i (n - 1)\\<rbrakk>\n    \\<Longrightarrow> mon = moni + Poly_Mapping.single i (n - 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; mon' = Poly_Mapping.single i (n - 1)\\<rbrakk>\n    \\<Longrightarrow> mon = moni + Poly_Mapping.single i (n - 1)", "assume \"n > 0\" \"mon' = Poly_Mapping.single i (n - 1)\""], ["proof (state)\nthis:\n  0 < n\n  mon' = Poly_Mapping.single i (n - 1)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>0 < n; mon' = Poly_Mapping.single i (n - 1)\\<rbrakk>\n    \\<Longrightarrow> mon = moni + Poly_Mapping.single i (n - 1)", "thus \"mon = moni + Poly_Mapping.single i (n - 1)\""], ["proof (prove)\nusing this:\n  0 < n\n  mon' = Poly_Mapping.single i (n - 1)\n\ngoal (1 subgoal):\n 1. mon = moni + Poly_Mapping.single i (n - 1)", "unfolding mon_eq moni_def"], ["proof (prove)\nusing this:\n  0 < n\n  mon' = Poly_Mapping.single i (n - 1)\n\ngoal (1 subgoal):\n 1. Poly_Mapping.single i n =\n    Poly_Mapping.single i 1 + Poly_Mapping.single i (n - 1)", "by (subst single_add [symmetric]) auto"], ["proof (state)\nthis:\n  mon = moni + Poly_Mapping.single i (n - 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (mon = moni + ?mon') =\n  (0 < n \\<and> ?mon' = Poly_Mapping.single i (n - 1))\n\ngoal (1 subgoal):\n 1. keys mon \\<subseteq> {i} \\<Longrightarrow>\n    MPoly_Type.coeff (mpoly_of_poly i (pCons c p)) mon =\n    MPoly_Type.coeff (Const c + Var i * mpoly_of_poly i p) mon", "have \"coeff (Var i * mpoly_of_poly i p) mon = (poly.coeff p (n - 1) when (n > 0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (Var i * mpoly_of_poly i p) mon =\n    (poly.coeff p (n - 1) when 0 < n)", "unfolding eq eq'"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Sum>a. MPoly_Type.coeff (mpoly_of_poly i p) a when\n              0 < n \\<and> a = Poly_Mapping.single i (n - 1)) =\n    (poly.coeff p (n - 1) when 0 < n)", "by (auto simp: when_def)"], ["proof (state)\nthis:\n  MPoly_Type.coeff (Var i * mpoly_of_poly i p) mon =\n  (poly.coeff p (n - 1) when 0 < n)\n\ngoal (1 subgoal):\n 1. keys mon \\<subseteq> {i} \\<Longrightarrow>\n    MPoly_Type.coeff (mpoly_of_poly i (pCons c p)) mon =\n    MPoly_Type.coeff (Const c + Var i * mpoly_of_poly i p) mon", "thus ?thesis"], ["proof (prove)\nusing this:\n  MPoly_Type.coeff (Var i * mpoly_of_poly i p) mon =\n  (poly.coeff p (n - 1) when 0 < n)\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (mpoly_of_poly i (pCons c p)) mon =\n    MPoly_Type.coeff (Const c + Var i * mpoly_of_poly i p) mon", "by (auto simp: mon_eq when_def mpoly_coeff_Const coeff_pCons split: nat.splits)"], ["proof (state)\nthis:\n  MPoly_Type.coeff (mpoly_of_poly i (pCons c p)) mon =\n  MPoly_Type.coeff (Const c + Var i * mpoly_of_poly i p) mon\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  MPoly_Type.coeff (mpoly_of_poly i (pCons c p)) mon =\n  MPoly_Type.coeff (Const c + Var i * mpoly_of_poly i p) mon\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mpoly_of_poly_1 [simp]: \"mpoly_of_poly i 1 = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_of_poly i 1 = 1", "unfolding one_pCons mpoly_of_poly_pCons mpoly_of_poly_0"], ["proof (prove)\ngoal (1 subgoal):\n 1. Const (1::'a) + Var i * 0 = 1", "by simp"], ["", "lemma mpoly_of_poly_uminus [simp]: \"mpoly_of_poly i (-p) = -mpoly_of_poly i p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_of_poly i (- p) = - mpoly_of_poly i p", "by (rule mpoly_eqI) (auto simp: coeff_mpoly_of_poly when_def)"], ["", "lemma mpoly_of_poly_add [simp]: \"mpoly_of_poly i (p + q) = mpoly_of_poly i p + mpoly_of_poly i q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_of_poly i (p + q) = mpoly_of_poly i p + mpoly_of_poly i q", "by (rule mpoly_eqI) (auto simp: coeff_mpoly_of_poly when_def)"], ["", "lemma mpoly_of_poly_diff [simp]: \"mpoly_of_poly i (p - q) = mpoly_of_poly i p - mpoly_of_poly i q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_of_poly i (p - q) = mpoly_of_poly i p - mpoly_of_poly i q", "by (rule mpoly_eqI) (auto simp: coeff_mpoly_of_poly when_def)"], ["", "lemma mpoly_of_poly_smult [simp]:\n  \"mpoly_of_poly i (Polynomial.smult c p) = smult c (mpoly_of_poly i p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_of_poly i (Polynomial.smult c p) =\n    MPoly_Type.smult c (mpoly_of_poly i p)", "by (rule mpoly_eqI) (auto simp: coeff_mpoly_of_poly when_def)"], ["", "lemma mpoly_of_poly_mult [simp]:\n  fixes p q :: \"'a :: comm_semiring_1 poly\"\n  shows \"mpoly_of_poly i (p * q) = mpoly_of_poly i p * mpoly_of_poly i q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_of_poly i (p * q) = mpoly_of_poly i p * mpoly_of_poly i q", "by (induction p) (auto simp: algebra_simps smult_conv_mult_Const)"], ["", "lemma insertion_mpoly_of_poly [simp]: \"insertion f (mpoly_of_poly i p) = poly p (f i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insertion f (mpoly_of_poly i p) = poly p (f i)", "by (induction p) (auto simp: insertion_add insertion_mult)"], ["", "lemma mapping_of_mpoly_of_poly [simp]: \"mapping_of (mpoly_of_poly i p) = mpoly_of_poly_aux i p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mapping_of (mpoly_of_poly i p) = mpoly_of_poly_aux i p", "by transfer' simp"], ["", "lemma vars_mpoly_of_poly: \"vars (mpoly_of_poly i p) \\<subseteq> {i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (mpoly_of_poly i p) \\<subseteq> {i}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. vars (mpoly_of_poly i p) \\<subseteq> {i}", "have \"x = i\" if \"xa \\<in> keys (mpoly_of_poly_aux i p)\" \"x \\<in> keys xa\" for x xa"], ["proof (prove)\ngoal (1 subgoal):\n 1. x = i", "using that"], ["proof (prove)\nusing this:\n  xa \\<in> keys (mpoly_of_poly_aux i p)\n  x \\<in> keys xa\n\ngoal (1 subgoal):\n 1. x = i", "by (meson in_mono lookup_eq_zero_in_keys_contradict mpoly_of_poly_aux.rep_eq singletonD)"], ["proof (state)\nthis:\n  \\<lbrakk>?xa \\<in> keys (mpoly_of_poly_aux i p);\n   ?x \\<in> keys ?xa\\<rbrakk>\n  \\<Longrightarrow> ?x = i\n\ngoal (1 subgoal):\n 1. vars (mpoly_of_poly i p) \\<subseteq> {i}", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>?xa \\<in> keys (mpoly_of_poly_aux i p);\n   ?x \\<in> keys ?xa\\<rbrakk>\n  \\<Longrightarrow> ?x = i\n\ngoal (1 subgoal):\n 1. vars (mpoly_of_poly i p) \\<subseteq> {i}", "by (auto simp: vars_def)"], ["proof (state)\nthis:\n  vars (mpoly_of_poly i p) \\<subseteq> {i}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mpoly_map_vars_mpoly_of_poly [simp]:\n  assumes \"bij f\"\n  shows   \"mpoly_map_vars f (mpoly_of_poly i p) = mpoly_of_poly (f i) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mpoly_map_vars f (mpoly_of_poly i p) = mpoly_of_poly (f i) p", "proof (rule mpoly_eqI, goal_cases)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>mon.\n       MPoly_Type.coeff (mpoly_map_vars f (mpoly_of_poly i p)) mon =\n       MPoly_Type.coeff (mpoly_of_poly (f i) p) mon", "case (1 mon)"], ["proof (state)\nthis:\n  \n\ngoal (1 subgoal):\n 1. \\<And>mon.\n       MPoly_Type.coeff (mpoly_map_vars f (mpoly_of_poly i p)) mon =\n       MPoly_Type.coeff (mpoly_of_poly (f i) p) mon", "have \"f -` keys mon \\<subseteq> {i} \\<longleftrightarrow> keys mon \\<subseteq> {f i}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f -` keys mon \\<subseteq> {i}) = (keys mon \\<subseteq> {f i})", "using assms"], ["proof (prove)\nusing this:\n  bij f\n\ngoal (1 subgoal):\n 1. (f -` keys mon \\<subseteq> {i}) = (keys mon \\<subseteq> {f i})", "by (simp add: vimage_subset_eq)"], ["proof (state)\nthis:\n  (f -` keys mon \\<subseteq> {i}) = (keys mon \\<subseteq> {f i})\n\ngoal (1 subgoal):\n 1. \\<And>mon.\n       MPoly_Type.coeff (mpoly_map_vars f (mpoly_of_poly i p)) mon =\n       MPoly_Type.coeff (mpoly_of_poly (f i) p) mon", "thus ?case"], ["proof (prove)\nusing this:\n  (f -` keys mon \\<subseteq> {i}) = (keys mon \\<subseteq> {f i})\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (mpoly_map_vars f (mpoly_of_poly i p)) mon =\n    MPoly_Type.coeff (mpoly_of_poly (f i) p) mon", "using assms"], ["proof (prove)\nusing this:\n  (f -` keys mon \\<subseteq> {i}) = (keys mon \\<subseteq> {f i})\n  bij f\n\ngoal (1 subgoal):\n 1. MPoly_Type.coeff (mpoly_map_vars f (mpoly_of_poly i p)) mon =\n    MPoly_Type.coeff (mpoly_of_poly (f i) p) mon", "by (simp add: coeff_mpoly_map_vars coeff_mpoly_of_poly lookup_permutep keys_permutep when_def)"], ["proof (state)\nthis:\n  MPoly_Type.coeff (mpoly_map_vars f (mpoly_of_poly i p)) mon =\n  MPoly_Type.coeff (mpoly_of_poly (f i) p) mon\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}