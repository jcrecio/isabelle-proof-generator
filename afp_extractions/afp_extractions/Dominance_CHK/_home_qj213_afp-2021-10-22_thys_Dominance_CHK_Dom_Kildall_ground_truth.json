{"file_name": "/home/qj213/afp-2021-10-22/thys/Dominance_CHK/Dom_Kildall.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Dominance_CHK", "problem_names": ["lemma init_worklist_is_sorted: \"sorted (unstables r step \\<tau>s)\"", "lemma transf_res_is_rev: \"sorted (rev ns) \\<Longrightarrow> n > hd ns  \\<Longrightarrow> sorted (rev ((transf n ( ns))))\"", "lemma dom_refl: \"dom i i\"", "lemma strict_domI1: \"(dom_kildall ([] # (replicate (length (g_V G) - 1) ( (rev[0..<length(g_V G)])))))!j =  res \\<Longrightarrow> i \\<in> set res \\<Longrightarrow> strict_dom i j\"", "lemma strict_domD: \n  \"strict_dom i j \\<Longrightarrow> \n  dom_kildall (( [] # (replicate (length (g_V G) - 1) ( (rev[0..<length(g_V G)])))))!j  =  a \\<Longrightarrow> \n  i \\<in> set a\"", "lemma sdom_dom: \"strict_dom i j \\<Longrightarrow> dom i j\"", "lemma not_sdom_not_dom: \"\\<not>strict_dom i j \\<Longrightarrow> i \\<noteq> j \\<Longrightarrow> \\<not>dom i j\"", "lemma dom_sdom: \"dom i j \\<Longrightarrow> i \\<noteq> j \\<Longrightarrow> strict_dom i j\""], "translations": [["", "lemma init_worklist_is_sorted: \"sorted (unstables r step \\<tau>s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Sorted_Less.sorted (unstables r step \\<tau>s)", "by (simp add:sorted_less_sorted_list_of_set unstables_def)"], ["", "definition  kildall :: \"state_dom ord \\<Rightarrow>state_dom binop  \\<Rightarrow> state_dom step_type \\<Rightarrow> state_dom list \\<Rightarrow> state_dom list\" where\n  \"kildall r f step \\<tau>s = fst(iter f step \\<tau>s (unstables r step \\<tau>s))\""], ["", "context cfg_doms\n\nbegin"], ["", "definition transf :: \"node \\<Rightarrow> state_dom \\<Rightarrow> state_dom \" where \n\"transf n input \\<equiv>  (n # input)\""], ["", "definition exec :: \"node \\<Rightarrow> state_dom \\<Rightarrow> (node \\<times> state_dom) list\"\n  where \"exec n xs = map (\\<lambda>pc. (pc, (transf n xs))) (rev (sorted_list_of_set(succs n)))\""], ["", "lemma transf_res_is_rev: \"sorted (rev ns) \\<Longrightarrow> n > hd ns  \\<Longrightarrow> sorted (rev ((transf n ( ns))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Sorted_Less.sorted (rev ns); hd ns < n\\<rbrakk>\n    \\<Longrightarrow> Sorted_Less.sorted (rev (transf n ns))", "by (induct ns) (auto simp add:transf_def sorted_wrt_append)"], ["", "abbreviation \"start \\<equiv>  [] # (replicate (length (g_V G) - 1) ( (rev[0..<length(g_V G)])))\""], ["", "definition dom_kildall :: \"state_dom list \\<Rightarrow> state_dom list\"\n  where \"dom_kildall = kildall (fst (snd nodes_semi)) (snd (snd nodes_semi)) exec\""], ["", "definition dom:: \"nat \\<Rightarrow> nat \\<Rightarrow> bool\" where\n\"dom i j \\<equiv>(let res = (dom_kildall start) !j in i \\<in> (set res) \\<or> i = j )\""], ["", "lemma dom_refl: \"dom i i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dom i i", "by (unfold dom_def) simp"], ["", "definition strict_dom :: \"nat \\<Rightarrow> nat \\<Rightarrow> bool\" where\n\"strict_dom i j \\<equiv> (let res = (dom_kildall start) !j in  i \\<in> set res)\""], ["", "lemma strict_domI1: \"(dom_kildall ([] # (replicate (length (g_V G) - 1) ( (rev[0..<length(g_V G)])))))!j =  res \\<Longrightarrow> i \\<in> set res \\<Longrightarrow> strict_dom i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>dom_kildall start ! j = res; i \\<in> set res\\<rbrakk>\n    \\<Longrightarrow> strict_dom i j", "by (auto simp add:strict_dom_def )"], ["", "lemma strict_domD: \n  \"strict_dom i j \\<Longrightarrow> \n  dom_kildall (( [] # (replicate (length (g_V G) - 1) ( (rev[0..<length(g_V G)])))))!j  =  a \\<Longrightarrow> \n  i \\<in> set a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>strict_dom i j; dom_kildall start ! j = a\\<rbrakk>\n    \\<Longrightarrow> i \\<in> set a", "by (auto simp add:strict_dom_def )"], ["", "lemma sdom_dom: \"strict_dom i j \\<Longrightarrow> dom i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strict_dom i j \\<Longrightarrow> local.dom i j", "by (unfold strict_dom_def) (auto simp add:dom_def)"], ["", "lemma not_sdom_not_dom: \"\\<not>strict_dom i j \\<Longrightarrow> i \\<noteq> j \\<Longrightarrow> \\<not>dom i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> strict_dom i j; i \\<noteq> j\\<rbrakk>\n    \\<Longrightarrow> \\<not> local.dom i j", "by (unfold strict_dom_def) (auto simp add:dom_def)"], ["", "lemma dom_sdom: \"dom i j \\<Longrightarrow> i \\<noteq> j \\<Longrightarrow> strict_dom i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>local.dom i j; i \\<noteq> j\\<rbrakk>\n    \\<Longrightarrow> strict_dom i j", "by (unfold dom_def)  (auto simp add:dom_def strict_dom_def)"], ["", "end"], ["", "definition stables :: \"'s ord \\<Rightarrow> 's step_type \\<Rightarrow> 's list \\<Rightarrow> bool\"\nwhere                                                             \n  \"stables r step \\<tau>s \\<longleftrightarrow> (\\<forall>p < size \\<tau>s. stable r step \\<tau>s p)\""], ["", "definition lesubstep_type :: \"(nat \\<times> 's) set \\<Rightarrow> 's ord \\<Rightarrow> (nat \\<times> 's) set \\<Rightarrow> bool\"\n    (\"(_ /{\\<sqsubseteq>\\<^bsub>_\\<^esub>} _)\" [50, 0, 51] 50)\n  where \"A {\\<sqsubseteq>\\<^bsub>r\\<^esub>} B \\<equiv> \\<forall>(p,\\<tau>) \\<in> A. \\<exists>\\<tau>'. (p,\\<tau>') \\<in> B \\<and> \\<tau> \\<sqsubseteq>\\<^sub>r \\<tau>'\""], ["", "notation (ASCII)\n  lesubstep_type  (\"(_ /{<='__} _)\" [50, 0, 51] 50)"], ["", "primrec pluslussub :: \"'a list \\<Rightarrow> ('a \\<Rightarrow> 'a \\<Rightarrow> 'a) \\<Rightarrow> 'a \\<Rightarrow> 'a\"  (\"(_ /\\<Squnion>\\<^bsub>_\\<^esub> _)\" [65, 0, 66] 65)\nwhere\n  \"pluslussub [] f y = y\"\n| \"pluslussub (x#xs) f y = pluslussub xs f (x \\<squnion>\\<^sub>f y)\""], ["", "(*<*)"], ["", "notation (ASCII)\n  pluslussub  (\"(_ /++'__ _)\" [65, 1000, 66] 65)"], ["", "(*>*)"], ["", "definition bounded :: \"'s step_type \\<Rightarrow> nat \\<Rightarrow> bool\"\nwhere\n  \"bounded step n \\<longleftrightarrow> (\\<forall>p<n. \\<forall>\\<tau>. \\<forall>(q,\\<tau>') \\<in> set (step p \\<tau>). q<n)\""], ["", "definition pres_type :: \"'s step_type \\<Rightarrow> nat \\<Rightarrow> 's set \\<Rightarrow> bool\"\nwhere\n  \"pres_type step n A \\<longleftrightarrow> (\\<forall>\\<tau>\\<in>A. \\<forall>p<n. \\<forall>(q,\\<tau>') \\<in> set (step p \\<tau>). \\<tau>' \\<in> A)\""], ["", "definition mono :: \"'s ord \\<Rightarrow> 's step_type \\<Rightarrow> nat \\<Rightarrow> 's set \\<Rightarrow> bool\"\nwhere\n  \"mono r step n A \\<longleftrightarrow>\n    (\\<forall>\\<tau> p \\<tau>'. \\<tau> \\<in> A \\<and> p<n \\<and> \\<tau> \\<sqsubseteq>\\<^sub>r \\<tau>' \\<longrightarrow> set (step p \\<tau>) {\\<sqsubseteq>\\<^bsub>r\\<^esub>} set (step p \\<tau>'))\""], ["", "end"]]}