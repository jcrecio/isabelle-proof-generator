{"file_name": "/home/qj213/afp-2021-10-22/thys/Bounded_Deducibility_Security/IO_Automaton.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Bounded_Deducibility_Security", "problem_names": ["lemma reach_PairI:\nassumes \"reach s\" and \"step s a = (ou, s')\"\nshows \"reach s'\"", "lemma holdsIstate_invar:\nassumes h: \"holdsIstate \\<phi>\" and i: \"invar \\<phi>\" and a: \"reach s\"\nshows \"\\<phi> s\"", "lemma validTrans:\n\"validTrans trn =\n (step (srcOf trn) (actOf trn) = (outOf trn, tgtOf trn))\"", "lemma Nil_not_valid[simp]: \"\\<not> valid []\"", "lemma Nil_not_valid2[simp]: \"\\<not> valid2 []\"", "lemma valid_Rcons:\nassumes \"valid tr\" and \"tgtOf (last tr) = srcOf trn\" and \"validTrans trn\"\nshows \"valid (tr ## trn)\"", "lemma valid_hd_Rcons[simp]:\nassumes \"valid tr\"\nshows \"hd (tr ## tran) = hd tr\"", "lemma valid2_hd_Rcons[simp]:\nassumes \"valid2 tr\"\nshows \"hd (tr ## tran) = hd tr\"", "lemma valid2_last_Cons[simp]:\nassumes \"valid2 tr\"\nshows \"last (tran # tr) = last tr\"", "lemma valid2_Cons:\nassumes \"valid2 tr\" and \"tgtOf trn = srcOf (hd tr)\" and \"validTrans trn\"\nshows \"valid2 (trn # tr)\"", "lemma valid_valid2: \"valid = valid2\"", "lemmas valid2_valid = valid_valid2[symmetric]", "lemma validFrom_Nil[simp,intro!]: \"validFrom s []\"", "lemma validFrom_valid[simp,intro]: \"valid tr \\<and> srcOf (hd tr) = s \\<Longrightarrow> validFrom s tr\"", "lemma validFrom_validTrans[intro]:\nassumes \"validTrans (Trans s a ou s')\" and \"validFrom s' tr\"\nshows \"validFrom s (Trans s a ou s' # tr)\"", "lemma valid_reach_src_tgt:\nassumes \"valid tr\" and \"reach (srcOf (hd tr))\"\nshows \"reach (tgtOf (last tr))\"", "lemma valid_init_reach:\nassumes \"valid tr\" and \"srcOf (hd tr) = istate\"\nshows \"reach (tgtOf (last tr))\"", "lemma Trans_fst_sndI:\n\"valid [Trans s a (fst (step s a)) (snd (step s a))]\"", "lemma reach_init_valid:\nassumes \"reach s\"\nshows\n\"s = istate\n \\<or>\n (\\<exists> tr. valid tr \\<and> srcOf (hd tr) = istate \\<and> tgtOf (last tr) = s)\"", "lemma reach_validFrom:\nassumes \"reach s'\"\nshows \"\\<exists> s tr. s = istate \\<and> (s = s' \\<or> (validFrom s tr \\<and> tgtOf (last tr) = s'))\""], "translations": [["", "lemma reach_PairI:\nassumes \"reach s\" and \"step s a = (ou, s')\"\nshows \"reach s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach s'", "by (metis Step assms assms snd_eqD)"], ["", "(* holds at the initial state: *)"], ["", "definition holdsIstate :: \"('state \\<Rightarrow> bool) \\<Rightarrow> bool\" where\n\"holdsIstate \\<phi> \\<equiv> \\<phi> istate\""], ["", "(* is invariant: *)"], ["", "definition invar :: \"('state \\<Rightarrow> bool) \\<Rightarrow> bool\" where\n\"invar \\<phi> \\<equiv> \\<forall> s a. reach s \\<and> \\<phi> s \\<longrightarrow> \\<phi> (snd (step s a))\""], ["", "lemma holdsIstate_invar:\nassumes h: \"holdsIstate \\<phi>\" and i: \"invar \\<phi>\" and a: \"reach s\"\nshows \"\\<phi> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> s", "using a"], ["proof (prove)\nusing this:\n  reach s\n\ngoal (1 subgoal):\n 1. \\<phi> s", "apply (induct rule: reach.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<phi> istate\n 2. \\<And>s a.\n       \\<lbrakk>reach s; \\<phi> s\\<rbrakk>\n       \\<Longrightarrow> \\<phi> (snd (step s a))", "using h i"], ["proof (prove)\nusing this:\n  holdsIstate \\<phi>\n  invar \\<phi>\n\ngoal (2 subgoals):\n 1. \\<phi> istate\n 2. \\<And>s a.\n       \\<lbrakk>reach s; \\<phi> s\\<rbrakk>\n       \\<Longrightarrow> \\<phi> (snd (step s a))", "unfolding holdsIstate_def invar_def"], ["proof (prove)\nusing this:\n  \\<phi> istate\n  \\<forall>s a.\n     reach s \\<and> \\<phi> s \\<longrightarrow> \\<phi> (snd (step s a))\n\ngoal (2 subgoals):\n 1. \\<phi> istate\n 2. \\<And>s a.\n       \\<lbrakk>reach s; \\<phi> s\\<rbrakk>\n       \\<Longrightarrow> \\<phi> (snd (step s a))", "by auto"], ["", "subsection\\<open>System traces\\<close>"], ["", "(* The output and effect of an action on a state: *)"], ["", "definition out :: \"'state \\<Rightarrow> 'act \\<Rightarrow> 'out\" where \"out s a \\<equiv> fst (step s a)\""], ["", "definition eff :: \"'state \\<Rightarrow> 'act \\<Rightarrow> 'state\" where \"eff s a \\<equiv> snd (step s a)\""], ["", "primrec validTrans :: \"('state,'act,'out) trans \\<Rightarrow> bool\" where\n\"validTrans (Trans s a ou s') = (step s a = (ou, s'))\""], ["", "lemma validTrans:\n\"validTrans trn =\n (step (srcOf trn) (actOf trn) = (outOf trn, tgtOf trn))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. validTrans trn = (step (srcOf trn) (actOf trn) = (outOf trn, tgtOf trn))", "by (cases trn) auto"], ["", "(* Traces allowed by the system (starting in any given state) *)\n(* Two alternative definitions: growing from the left and growing from the right: *)"], ["", "inductive valid :: \"('state,'act,'out) trace \\<Rightarrow> bool\" where\nSingl[simp,intro!]:\n\"validTrans trn\n \\<Longrightarrow>\n valid [trn]\"\n|\nCons[intro]:\n\"\\<lbrakk>validTrans trn; tgtOf trn = srcOf (hd tr); valid tr\\<rbrakk>\n \\<Longrightarrow>\n valid (trn # tr)\""], ["", "inductive_cases valid_SinglE[elim!]: \"valid [trn]\""], ["", "inductive_cases valid_ConsE[elim]: \"valid (trn # tr)\""], ["", "inductive valid2 :: \"('state,'act,'out) trace \\<Rightarrow> bool\" where\nSingl[simp,intro!]:\n\"validTrans trn\n \\<Longrightarrow>\n valid2 [trn]\"\n|\nRcons[intro]:\n\"\\<lbrakk>valid2 tr; tgtOf (last tr) = srcOf trn; validTrans trn\\<rbrakk>\n \\<Longrightarrow>\n valid2 (tr ## trn)\""], ["", "inductive_cases valid2_SinglE[elim!]: \"valid2 [trn]\""], ["", "inductive_cases valid2_RconsE[elim]: \"valid2 (tr ## trn)\""], ["", "lemma Nil_not_valid[simp]: \"\\<not> valid []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> valid []", "by (metis valid.simps neq_Nil_conv)"], ["", "lemma Nil_not_valid2[simp]: \"\\<not> valid2 []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> valid2 []", "by (metis valid2.cases append_Nil butlast.simps butlast_snoc not_Cons_self2)"], ["", "lemma valid_Rcons:\nassumes \"valid tr\" and \"tgtOf (last tr) = srcOf trn\" and \"validTrans trn\"\nshows \"valid (tr ## trn)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid (tr ## trn)", "using assms"], ["proof (prove)\nusing this:\n  valid tr\n  tgtOf (last tr) = srcOf trn\n  validTrans trn\n\ngoal (1 subgoal):\n 1. valid (tr ## trn)", "proof(induct arbitrary: trn)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>trn trna.\n       \\<lbrakk>validTrans trn; tgtOf (last [trn]) = srcOf trna;\n        validTrans trna\\<rbrakk>\n       \\<Longrightarrow> valid ([trn] ## trna)\n 2. \\<And>trn tr trna.\n       \\<lbrakk>validTrans trn; tgtOf trn = srcOf (hd tr); valid tr;\n        \\<And>trn.\n           \\<lbrakk>tgtOf (last tr) = srcOf trn; validTrans trn\\<rbrakk>\n           \\<Longrightarrow> valid (tr ## trn);\n        tgtOf (last (trn # tr)) = srcOf trna; validTrans trna\\<rbrakk>\n       \\<Longrightarrow> valid ((trn # tr) ## trna)", "case (Cons trn tr trna)"], ["proof (state)\nthis:\n  validTrans trn\n  tgtOf trn = srcOf (hd tr)\n  valid tr\n  \\<lbrakk>tgtOf (last tr) = srcOf ?trn; validTrans ?trn\\<rbrakk>\n  \\<Longrightarrow> valid (tr ## ?trn)\n  tgtOf (last (trn # tr)) = srcOf trna\n  validTrans trna\n\ngoal (2 subgoals):\n 1. \\<And>trn trna.\n       \\<lbrakk>validTrans trn; tgtOf (last [trn]) = srcOf trna;\n        validTrans trna\\<rbrakk>\n       \\<Longrightarrow> valid ([trn] ## trna)\n 2. \\<And>trn tr trna.\n       \\<lbrakk>validTrans trn; tgtOf trn = srcOf (hd tr); valid tr;\n        \\<And>trn.\n           \\<lbrakk>tgtOf (last tr) = srcOf trn; validTrans trn\\<rbrakk>\n           \\<Longrightarrow> valid (tr ## trn);\n        tgtOf (last (trn # tr)) = srcOf trna; validTrans trna\\<rbrakk>\n       \\<Longrightarrow> valid ((trn # tr) ## trna)", "thus ?case"], ["proof (prove)\nusing this:\n  validTrans trn\n  tgtOf trn = srcOf (hd tr)\n  valid tr\n  \\<lbrakk>tgtOf (last tr) = srcOf ?trn; validTrans ?trn\\<rbrakk>\n  \\<Longrightarrow> valid (tr ## ?trn)\n  tgtOf (last (trn # tr)) = srcOf trna\n  validTrans trna\n\ngoal (1 subgoal):\n 1. valid ((trn # tr) ## trna)", "by (cases tr) (auto intro: valid.Cons)"], ["proof (state)\nthis:\n  valid ((trn # tr) ## trna)\n\ngoal (1 subgoal):\n 1. \\<And>trn trna.\n       \\<lbrakk>validTrans trn; tgtOf (last [trn]) = srcOf trna;\n        validTrans trna\\<rbrakk>\n       \\<Longrightarrow> valid ([trn] ## trna)", "qed(auto intro: valid.intros)"], ["", "lemma valid_hd_Rcons[simp]:\nassumes \"valid tr\"\nshows \"hd (tr ## tran) = hd tr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (tr ## tran) = hd tr", "by (metis Nil_not_valid assms hd_append)"], ["", "lemma valid2_hd_Rcons[simp]:\nassumes \"valid2 tr\"\nshows \"hd (tr ## tran) = hd tr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (tr ## tran) = hd tr", "by (metis Nil_not_valid2 assms hd_append)"], ["", "lemma valid2_last_Cons[simp]:\nassumes \"valid2 tr\"\nshows \"last (tran # tr) = last tr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. last (tran # tr) = last tr", "by (metis Nil_not_valid2 assms last.simps)"], ["", "lemma valid2_Cons:\nassumes \"valid2 tr\" and \"tgtOf trn = srcOf (hd tr)\" and \"validTrans trn\"\nshows \"valid2 (trn # tr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid2 (trn # tr)", "using assms"], ["proof (prove)\nusing this:\n  valid2 tr\n  tgtOf trn = srcOf (hd tr)\n  validTrans trn\n\ngoal (1 subgoal):\n 1. valid2 (trn # tr)", "proof(induct arbitrary: trn)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>trn trna.\n       \\<lbrakk>validTrans trn; tgtOf trna = srcOf (hd [trn]);\n        validTrans trna\\<rbrakk>\n       \\<Longrightarrow> valid2 [trna, trn]\n 2. \\<And>tr trn trna.\n       \\<lbrakk>valid2 tr;\n        \\<And>trn.\n           \\<lbrakk>tgtOf trn = srcOf (hd tr); validTrans trn\\<rbrakk>\n           \\<Longrightarrow> valid2 (trn # tr);\n        tgtOf (last tr) = srcOf trn; validTrans trn;\n        tgtOf trna = srcOf (hd (tr ## trn)); validTrans trna\\<rbrakk>\n       \\<Longrightarrow> valid2 (trna # tr ## trn)", "case Singl"], ["proof (state)\nthis:\n  validTrans trn_\n  tgtOf trn = srcOf (hd [trn_])\n  validTrans trn\n\ngoal (2 subgoals):\n 1. \\<And>trn trna.\n       \\<lbrakk>validTrans trn; tgtOf trna = srcOf (hd [trn]);\n        validTrans trna\\<rbrakk>\n       \\<Longrightarrow> valid2 [trna, trn]\n 2. \\<And>tr trn trna.\n       \\<lbrakk>valid2 tr;\n        \\<And>trn.\n           \\<lbrakk>tgtOf trn = srcOf (hd tr); validTrans trn\\<rbrakk>\n           \\<Longrightarrow> valid2 (trn # tr);\n        tgtOf (last tr) = srcOf trn; validTrans trn;\n        tgtOf trna = srcOf (hd (tr ## trn)); validTrans trna\\<rbrakk>\n       \\<Longrightarrow> valid2 (trna # tr ## trn)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid2 [trn, trn_]", "unfolding two_singl_Rcons"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid2 ([trn] ## trn_)", "using Singl"], ["proof (prove)\nusing this:\n  validTrans trn_\n  tgtOf trn = srcOf (hd [trn_])\n  validTrans trn\n\ngoal (1 subgoal):\n 1. valid2 ([trn] ## trn_)", "by (intro valid2.Rcons) (auto intro: valid2.Singl)"], ["proof (state)\nthis:\n  valid2 [trn, trn_]\n\ngoal (1 subgoal):\n 1. \\<And>tr trn trna.\n       \\<lbrakk>valid2 tr;\n        \\<And>trn.\n           \\<lbrakk>tgtOf trn = srcOf (hd tr); validTrans trn\\<rbrakk>\n           \\<Longrightarrow> valid2 (trn # tr);\n        tgtOf (last tr) = srcOf trn; validTrans trn;\n        tgtOf trna = srcOf (hd (tr ## trn)); validTrans trna\\<rbrakk>\n       \\<Longrightarrow> valid2 (trna # tr ## trn)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>tr trn trna.\n       \\<lbrakk>valid2 tr;\n        \\<And>trn.\n           \\<lbrakk>tgtOf trn = srcOf (hd tr); validTrans trn\\<rbrakk>\n           \\<Longrightarrow> valid2 (trn # tr);\n        tgtOf (last tr) = srcOf trn; validTrans trn;\n        tgtOf trna = srcOf (hd (tr ## trn)); validTrans trna\\<rbrakk>\n       \\<Longrightarrow> valid2 (trna # tr ## trn)", "case Rcons"], ["proof (state)\nthis:\n  valid2 tr_\n  \\<lbrakk>tgtOf ?trn = srcOf (hd tr_); validTrans ?trn\\<rbrakk>\n  \\<Longrightarrow> valid2 (?trn # tr_)\n  tgtOf (last tr_) = srcOf trn_\n  validTrans trn_\n  tgtOf trn = srcOf (hd (tr_ ## trn_))\n  validTrans trn\n\ngoal (1 subgoal):\n 1. \\<And>tr trn trna.\n       \\<lbrakk>valid2 tr;\n        \\<And>trn.\n           \\<lbrakk>tgtOf trn = srcOf (hd tr); validTrans trn\\<rbrakk>\n           \\<Longrightarrow> valid2 (trn # tr);\n        tgtOf (last tr) = srcOf trn; validTrans trn;\n        tgtOf trna = srcOf (hd (tr ## trn)); validTrans trna\\<rbrakk>\n       \\<Longrightarrow> valid2 (trna # tr ## trn)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid2 (trn # tr_ ## trn_)", "unfolding append.append_Cons[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid2 ((trn # tr_) ## trn_)", "using Rcons"], ["proof (prove)\nusing this:\n  valid2 tr_\n  \\<lbrakk>tgtOf ?trn = srcOf (hd tr_); validTrans ?trn\\<rbrakk>\n  \\<Longrightarrow> valid2 (?trn # tr_)\n  tgtOf (last tr_) = srcOf trn_\n  validTrans trn_\n  tgtOf trn = srcOf (hd (tr_ ## trn_))\n  validTrans trn\n\ngoal (1 subgoal):\n 1. valid2 ((trn # tr_) ## trn_)", "by (intro valid2.Rcons) auto"], ["proof (state)\nthis:\n  valid2 (trn # tr_ ## trn_)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma valid_valid2: \"valid = valid2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid = valid2", "proof(rule ext, safe)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. valid x \\<Longrightarrow> valid2 x\n 2. \\<And>x. valid2 x \\<Longrightarrow> valid x", "fix tr"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. valid x \\<Longrightarrow> valid2 x\n 2. \\<And>x. valid2 x \\<Longrightarrow> valid x", "assume \"valid tr\""], ["proof (state)\nthis:\n  valid tr\n\ngoal (2 subgoals):\n 1. \\<And>x. valid x \\<Longrightarrow> valid2 x\n 2. \\<And>x. valid2 x \\<Longrightarrow> valid x", "thus \"valid2 tr\""], ["proof (prove)\nusing this:\n  valid tr\n\ngoal (1 subgoal):\n 1. valid2 tr", "by (induct) (auto intro: valid2.Singl valid2_Cons)"], ["proof (state)\nthis:\n  valid2 tr\n\ngoal (1 subgoal):\n 1. \\<And>x. valid2 x \\<Longrightarrow> valid x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. valid2 x \\<Longrightarrow> valid x", "fix tr"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. valid2 x \\<Longrightarrow> valid x", "assume \"valid2 tr\""], ["proof (state)\nthis:\n  valid2 tr\n\ngoal (1 subgoal):\n 1. \\<And>x. valid2 x \\<Longrightarrow> valid x", "thus \"valid tr\""], ["proof (prove)\nusing this:\n  valid2 tr\n\ngoal (1 subgoal):\n 1. valid tr", "by (induct) (auto intro: valid.Singl valid_Rcons)"], ["proof (state)\nthis:\n  valid tr\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas valid2_valid = valid_valid2[symmetric]"], ["", "definition validFrom :: \"'state \\<Rightarrow> ('state,'act,'out) trace \\<Rightarrow> bool\" where\n\"validFrom s tr \\<equiv> tr = [] \\<or> (valid tr \\<and> srcOf (hd tr) = s)\""], ["", "lemma validFrom_Nil[simp,intro!]: \"validFrom s []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. validFrom s []", "unfolding validFrom_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. [] = [] \\<or> valid [] \\<and> srcOf (hd []) = s", "by auto"], ["", "lemma validFrom_valid[simp,intro]: \"valid tr \\<and> srcOf (hd tr) = s \\<Longrightarrow> validFrom s tr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid tr \\<and> srcOf (hd tr) = s \\<Longrightarrow> validFrom s tr", "unfolding validFrom_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. valid tr \\<and> srcOf (hd tr) = s \\<Longrightarrow>\n    tr = [] \\<or> valid tr \\<and> srcOf (hd tr) = s", "by auto"], ["", "lemma validFrom_validTrans[intro]:\nassumes \"validTrans (Trans s a ou s')\" and \"validFrom s' tr\"\nshows \"validFrom s (Trans s a ou s' # tr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. validFrom s (Trans s a ou s' # tr)", "using assms"], ["proof (prove)\nusing this:\n  validTrans (Trans s a ou s')\n  validFrom s' tr\n\ngoal (1 subgoal):\n 1. validFrom s (Trans s a ou s' # tr)", "unfolding validFrom_def"], ["proof (prove)\nusing this:\n  validTrans (Trans s a ou s')\n  tr = [] \\<or> valid tr \\<and> srcOf (hd tr) = s'\n\ngoal (1 subgoal):\n 1. Trans s a ou s' # tr = [] \\<or>\n    valid (Trans s a ou s' # tr) \\<and>\n    srcOf (hd (Trans s a ou s' # tr)) = s", "by auto"], ["", "subsection \\<open>Traces versus reachability\\<close>"], ["", "lemma valid_reach_src_tgt:\nassumes \"valid tr\" and \"reach (srcOf (hd tr))\"\nshows \"reach (tgtOf (last tr))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach (tgtOf (last tr))", "using assms"], ["proof (prove)\nusing this:\n  valid tr\n  reach (srcOf (hd tr))\n\ngoal (1 subgoal):\n 1. reach (tgtOf (last tr))", "by induct (auto intro: reach_PairI simp: validTrans)"], ["", "lemma valid_init_reach:\nassumes \"valid tr\" and \"srcOf (hd tr) = istate\"\nshows \"reach (tgtOf (last tr))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach (tgtOf (last tr))", "using valid_reach_src_tgt assms reach.Istate"], ["proof (prove)\nusing this:\n  \\<lbrakk>valid ?tr; reach (srcOf (hd ?tr))\\<rbrakk>\n  \\<Longrightarrow> reach (tgtOf (last ?tr))\n  valid tr\n  srcOf (hd tr) = istate\n  reach istate\n\ngoal (1 subgoal):\n 1. reach (tgtOf (last tr))", "by metis"], ["", "lemma Trans_fst_sndI:\n\"valid [Trans s a (fst (step s a)) (snd (step s a))]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. valid [Trans s a (fst (step s a)) (snd (step s a))]", "by (metis valid.Singl surjective_pairing validTrans.simps)"], ["", "lemma reach_init_valid:\nassumes \"reach s\"\nshows\n\"s = istate\n \\<or>\n (\\<exists> tr. valid tr \\<and> srcOf (hd tr) = istate \\<and> tgtOf (last tr) = s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s = istate \\<or>\n    (\\<exists>tr.\n        valid tr \\<and> srcOf (hd tr) = istate \\<and> tgtOf (last tr) = s)", "using assms"], ["proof (prove)\nusing this:\n  reach s\n\ngoal (1 subgoal):\n 1. s = istate \\<or>\n    (\\<exists>tr.\n        valid tr \\<and> srcOf (hd tr) = istate \\<and> tgtOf (last tr) = s)", "proof induction"], ["proof (state)\ngoal (2 subgoals):\n 1. istate = istate \\<or>\n    (\\<exists>tr.\n        valid tr \\<and>\n        srcOf (hd tr) = istate \\<and> tgtOf (last tr) = istate)\n 2. \\<And>s a.\n       \\<lbrakk>reach s;\n        s = istate \\<or>\n        (\\<exists>tr.\n            valid tr \\<and>\n            srcOf (hd tr) = istate \\<and> tgtOf (last tr) = s)\\<rbrakk>\n       \\<Longrightarrow> snd (step s a) = istate \\<or>\n                         (\\<exists>tr.\n                             valid tr \\<and>\n                             srcOf (hd tr) = istate \\<and>\n                             tgtOf (last tr) = snd (step s a))", "case (Step s a)"], ["proof (state)\nthis:\n  reach s\n  s = istate \\<or>\n  (\\<exists>tr.\n      valid tr \\<and> srcOf (hd tr) = istate \\<and> tgtOf (last tr) = s)\n\ngoal (2 subgoals):\n 1. istate = istate \\<or>\n    (\\<exists>tr.\n        valid tr \\<and>\n        srcOf (hd tr) = istate \\<and> tgtOf (last tr) = istate)\n 2. \\<And>s a.\n       \\<lbrakk>reach s;\n        s = istate \\<or>\n        (\\<exists>tr.\n            valid tr \\<and>\n            srcOf (hd tr) = istate \\<and> tgtOf (last tr) = s)\\<rbrakk>\n       \\<Longrightarrow> snd (step s a) = istate \\<or>\n                         (\\<exists>tr.\n                             valid tr \\<and>\n                             srcOf (hd tr) = istate \\<and>\n                             tgtOf (last tr) = snd (step s a))", "thus ?case"], ["proof (prove)\nusing this:\n  reach s\n  s = istate \\<or>\n  (\\<exists>tr.\n      valid tr \\<and> srcOf (hd tr) = istate \\<and> tgtOf (last tr) = s)\n\ngoal (1 subgoal):\n 1. snd (step s a) = istate \\<or>\n    (\\<exists>tr.\n        valid tr \\<and>\n        srcOf (hd tr) = istate \\<and> tgtOf (last tr) = snd (step s a))", "proof(elim disjE exE conjE)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>reach s; s = istate\\<rbrakk>\n    \\<Longrightarrow> snd (step s a) = istate \\<or>\n                      (\\<exists>tr.\n                          valid tr \\<and>\n                          srcOf (hd tr) = istate \\<and>\n                          tgtOf (last tr) = snd (step s a))\n 2. \\<And>tr.\n       \\<lbrakk>reach s; valid tr; srcOf (hd tr) = istate;\n        tgtOf (last tr) = s\\<rbrakk>\n       \\<Longrightarrow> snd (step s a) = istate \\<or>\n                         (\\<exists>tr.\n                             valid tr \\<and>\n                             srcOf (hd tr) = istate \\<and>\n                             tgtOf (last tr) = snd (step s a))", "assume s: \"s = istate\""], ["proof (state)\nthis:\n  s = istate\n\ngoal (2 subgoals):\n 1. \\<lbrakk>reach s; s = istate\\<rbrakk>\n    \\<Longrightarrow> snd (step s a) = istate \\<or>\n                      (\\<exists>tr.\n                          valid tr \\<and>\n                          srcOf (hd tr) = istate \\<and>\n                          tgtOf (last tr) = snd (step s a))\n 2. \\<And>tr.\n       \\<lbrakk>reach s; valid tr; srcOf (hd tr) = istate;\n        tgtOf (last tr) = s\\<rbrakk>\n       \\<Longrightarrow> snd (step s a) = istate \\<or>\n                         (\\<exists>tr.\n                             valid tr \\<and>\n                             srcOf (hd tr) = istate \\<and>\n                             tgtOf (last tr) = snd (step s a))", "let ?ou = \"fst (step s a)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>reach s; s = istate\\<rbrakk>\n    \\<Longrightarrow> snd (step s a) = istate \\<or>\n                      (\\<exists>tr.\n                          valid tr \\<and>\n                          srcOf (hd tr) = istate \\<and>\n                          tgtOf (last tr) = snd (step s a))\n 2. \\<And>tr.\n       \\<lbrakk>reach s; valid tr; srcOf (hd tr) = istate;\n        tgtOf (last tr) = s\\<rbrakk>\n       \\<Longrightarrow> snd (step s a) = istate \\<or>\n                         (\\<exists>tr.\n                             valid tr \\<and>\n                             srcOf (hd tr) = istate \\<and>\n                             tgtOf (last tr) = snd (step s a))", "let ?s' = \"snd (step s a)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>reach s; s = istate\\<rbrakk>\n    \\<Longrightarrow> snd (step s a) = istate \\<or>\n                      (\\<exists>tr.\n                          valid tr \\<and>\n                          srcOf (hd tr) = istate \\<and>\n                          tgtOf (last tr) = snd (step s a))\n 2. \\<And>tr.\n       \\<lbrakk>reach s; valid tr; srcOf (hd tr) = istate;\n        tgtOf (last tr) = s\\<rbrakk>\n       \\<Longrightarrow> snd (step s a) = istate \\<or>\n                         (\\<exists>tr.\n                             valid tr \\<and>\n                             srcOf (hd tr) = istate \\<and>\n                             tgtOf (last tr) = snd (step s a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (step s a) = istate \\<or>\n    (\\<exists>tr.\n        valid tr \\<and>\n        srcOf (hd tr) = istate \\<and> tgtOf (last tr) = snd (step s a))", "using s"], ["proof (prove)\nusing this:\n  s = istate\n\ngoal (1 subgoal):\n 1. snd (step s a) = istate \\<or>\n    (\\<exists>tr.\n        valid tr \\<and>\n        srcOf (hd tr) = istate \\<and> tgtOf (last tr) = snd (step s a))", "by (intro disjI2 exI[of _ \"[Trans s a ?ou ?s']\"]) auto"], ["proof (state)\nthis:\n  snd (step s a) = istate \\<or>\n  (\\<exists>tr.\n      valid tr \\<and>\n      srcOf (hd tr) = istate \\<and> tgtOf (last tr) = snd (step s a))\n\ngoal (1 subgoal):\n 1. \\<And>tr.\n       \\<lbrakk>reach s; valid tr; srcOf (hd tr) = istate;\n        tgtOf (last tr) = s\\<rbrakk>\n       \\<Longrightarrow> snd (step s a) = istate \\<or>\n                         (\\<exists>tr.\n                             valid tr \\<and>\n                             srcOf (hd tr) = istate \\<and>\n                             tgtOf (last tr) = snd (step s a))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>tr.\n       \\<lbrakk>reach s; valid tr; srcOf (hd tr) = istate;\n        tgtOf (last tr) = s\\<rbrakk>\n       \\<Longrightarrow> snd (step s a) = istate \\<or>\n                         (\\<exists>tr.\n                             valid tr \\<and>\n                             srcOf (hd tr) = istate \\<and>\n                             tgtOf (last tr) = snd (step s a))", "fix tr"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>tr.\n       \\<lbrakk>reach s; valid tr; srcOf (hd tr) = istate;\n        tgtOf (last tr) = s\\<rbrakk>\n       \\<Longrightarrow> snd (step s a) = istate \\<or>\n                         (\\<exists>tr.\n                             valid tr \\<and>\n                             srcOf (hd tr) = istate \\<and>\n                             tgtOf (last tr) = snd (step s a))", "assume v: \"valid tr\" and s: \"srcOf (hd tr) = istate\" and t: \"tgtOf (last tr) = s\""], ["proof (state)\nthis:\n  valid tr\n  srcOf (hd tr) = istate\n  tgtOf (last tr) = s\n\ngoal (1 subgoal):\n 1. \\<And>tr.\n       \\<lbrakk>reach s; valid tr; srcOf (hd tr) = istate;\n        tgtOf (last tr) = s\\<rbrakk>\n       \\<Longrightarrow> snd (step s a) = istate \\<or>\n                         (\\<exists>tr.\n                             valid tr \\<and>\n                             srcOf (hd tr) = istate \\<and>\n                             tgtOf (last tr) = snd (step s a))", "let ?ou = \"fst (step s a)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>tr.\n       \\<lbrakk>reach s; valid tr; srcOf (hd tr) = istate;\n        tgtOf (last tr) = s\\<rbrakk>\n       \\<Longrightarrow> snd (step s a) = istate \\<or>\n                         (\\<exists>tr.\n                             valid tr \\<and>\n                             srcOf (hd tr) = istate \\<and>\n                             tgtOf (last tr) = snd (step s a))", "let ?s' = \"snd (step s a)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>tr.\n       \\<lbrakk>reach s; valid tr; srcOf (hd tr) = istate;\n        tgtOf (last tr) = s\\<rbrakk>\n       \\<Longrightarrow> snd (step s a) = istate \\<or>\n                         (\\<exists>tr.\n                             valid tr \\<and>\n                             srcOf (hd tr) = istate \\<and>\n                             tgtOf (last tr) = snd (step s a))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (step s a) = istate \\<or>\n    (\\<exists>tr.\n        valid tr \\<and>\n        srcOf (hd tr) = istate \\<and> tgtOf (last tr) = snd (step s a))", "using v t s"], ["proof (prove)\nusing this:\n  valid tr\n  tgtOf (last tr) = s\n  srcOf (hd tr) = istate\n\ngoal (1 subgoal):\n 1. snd (step s a) = istate \\<or>\n    (\\<exists>tr.\n        valid tr \\<and>\n        srcOf (hd tr) = istate \\<and> tgtOf (last tr) = snd (step s a))", "by (intro disjI2 exI[of _ \"tr ## Trans s a ?ou ?s'\"]) (auto intro: valid_Rcons)"], ["proof (state)\nthis:\n  snd (step s a) = istate \\<or>\n  (\\<exists>tr.\n      valid tr \\<and>\n      srcOf (hd tr) = istate \\<and> tgtOf (last tr) = snd (step s a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  snd (step s a) = istate \\<or>\n  (\\<exists>tr.\n      valid tr \\<and>\n      srcOf (hd tr) = istate \\<and> tgtOf (last tr) = snd (step s a))\n\ngoal (1 subgoal):\n 1. istate = istate \\<or>\n    (\\<exists>tr.\n        valid tr \\<and>\n        srcOf (hd tr) = istate \\<and> tgtOf (last tr) = istate)", "qed auto"], ["", "lemma reach_validFrom:\nassumes \"reach s'\"\nshows \"\\<exists> s tr. s = istate \\<and> (s = s' \\<or> (validFrom s tr \\<and> tgtOf (last tr) = s'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>s tr.\n       s = istate \\<and>\n       (s = s' \\<or> validFrom s tr \\<and> tgtOf (last tr) = s')", "using reach_init_valid[OF assms]"], ["proof (prove)\nusing this:\n  s' = istate \\<or>\n  (\\<exists>tr.\n      valid tr \\<and> srcOf (hd tr) = istate \\<and> tgtOf (last tr) = s')\n\ngoal (1 subgoal):\n 1. \\<exists>s tr.\n       s = istate \\<and>\n       (s = s' \\<or> validFrom s tr \\<and> tgtOf (last tr) = s')", "unfolding validFrom_def"], ["proof (prove)\nusing this:\n  s' = istate \\<or>\n  (\\<exists>tr.\n      valid tr \\<and> srcOf (hd tr) = istate \\<and> tgtOf (last tr) = s')\n\ngoal (1 subgoal):\n 1. \\<exists>s tr.\n       s = istate \\<and>\n       (s = s' \\<or>\n        (tr = [] \\<or> valid tr \\<and> srcOf (hd tr) = s) \\<and>\n        tgtOf (last tr) = s')", "by auto"], ["", "(*<*)"], ["", "end"], ["", "(* locale IO_Automaton *)"], ["", "end"], ["", "(*>*)"]]}