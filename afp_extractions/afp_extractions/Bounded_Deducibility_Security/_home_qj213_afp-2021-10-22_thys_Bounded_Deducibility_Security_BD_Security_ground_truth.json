{"file_name": "/home/qj213/afp-2021-10-22/thys/Bounded_Deducibility_Security/BD_Security.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Bounded_Deducibility_Security", "problem_names": ["lemma V_simps[simp]:\n\"V [] = []\"  \"\\<not> \\<phi> trn \\<Longrightarrow> V (trn # tr) = V tr\"  \"\\<phi> trn \\<Longrightarrow> V (trn # tr) = f trn # V tr\"", "lemma O_simps[simp]:\n\"O [] = []\"  \"\\<not> \\<gamma> trn \\<Longrightarrow> O (trn # tr) = O tr\"  \"\\<gamma> trn \\<Longrightarrow> O (trn # tr) = g trn # O tr\"", "lemma reachNT_PairI:\nassumes \"reachNT s\" and \"step s a = (ou, s')\" and \"\\<not> T (Trans s a ou s')\"\nshows \"reachNT s'\"", "lemma reachNT_reach: assumes \"reachNT s\"  shows \"reach s\"", "lemma reachNT_stateO_aux:\nassumes \"reachNT s\"\nshows \"s = istate \\<or> (\\<exists>sh a ou. reach sh \\<and> step sh a = (ou,s) \\<and> \\<not>T (Trans sh a ou s))\"", "lemma reachNT_state_cases[cases set,consumes 1, case_names init step]:\nassumes \"reachNT s\"\nobtains \"s = istate\"\n| sh a ou where \"reach sh\" \"step sh a = (ou,s)\" \"\\<not>T (Trans sh a ou s)\"", "lemma invarNT_disj:\nassumes \"invarNT Inv1\" and \"invarNT Inv2\"\nshows \"invarNT (\\<lambda> s. Inv1 s \\<or> Inv2 s)\"", "lemma invarNT_conj:\nassumes \"invarNT Inv1\" and \"invarNT Inv2\"\nshows \"invarNT (\\<lambda> s. Inv1 s \\<and> Inv2 s)\"", "lemma holdsIstate_invarNT:\nassumes h: \"holdsIstate Inv\" and i: \"invarNT Inv\" and a: \"reachNT s\"\nshows \"Inv s\"", "lemma V_iff_non_\\<phi>[simp]: \"V (trn # tr) = V tr \\<longleftrightarrow> \\<not> \\<phi> trn\"", "lemma V_imp_\\<phi>: \"V (trn # tr) = v # V tr \\<Longrightarrow> \\<phi> trn\"", "lemma V_imp_Nil: \"V (trn # tr) = [] \\<Longrightarrow> V tr = []\"", "lemma V_iff_Nil[simp]: \"V (trn # tr) = [] \\<longleftrightarrow> \\<not> \\<phi> trn \\<and> V tr = []\"", "lemma length_consume[simp]:\n\"consume trn vl vl' \\<Longrightarrow> length vl' < Suc (length vl)\"", "lemma ex_consume_\\<phi>:\nassumes \"\\<not> \\<phi> trn\"\nobtains vl' where \"consume trn vl vl'\"", "lemma ex_consume_NO:\nassumes \"vl \\<noteq> []\" and \"f trn = hd vl\"\nobtains vl' where \"consume trn vl vl'\"", "lemma iactionI[intro?]:\nassumes \"step s1 a1 = (ou1, s1')\" and \"\\<phi> (Trans s1 a1 ou1 s1')\"\nand \"consume (Trans s1 a1 ou1 s1') vl1 vl1'\"\nand \"\\<not> \\<gamma> (Trans s1 a1 ou1 s1')\" and \"\\<Delta> s vl s1' vl1'\"\nshows \"iaction \\<Delta> s vl s1 vl1\"", "lemma matchI[intro?]:\nassumes \"validTrans (Trans s1 a1 ou1 s1')\"\nand \"consume (Trans s1 a1 ou1 s1') vl1 vl1'\" and \"\\<gamma> (Trans s a ou s') = \\<gamma> (Trans s1 a1 ou1 s1')\"\nand \"\\<gamma> (Trans s a ou s') \\<Longrightarrow> g (Trans s a ou s') = g (Trans s1 a1 ou1 s1')\"\nand \"\\<Delta> s' vl' s1' vl1'\"\nshows \"match \\<Delta> s s1 vl1 a ou s' vl'\"", "lemma ignoreI[intro?]:\nassumes \"\\<not> \\<gamma> (Trans s a ou s')\" and \"\\<Delta> s' vl' s1 vl1\"\nshows \"ignore \\<Delta> s s1 vl1 a ou s' vl'\"", "lemma reactionI[intro?]:\nassumes\n\"\\<And>a ou s' vl'.\n   \\<lbrakk>step s a = (ou, s'); \\<not> T (Trans s a ou s');\n    consume (Trans s a ou s') vl vl'\\<rbrakk>\n   \\<Longrightarrow>\n   match \\<Delta> s s1 vl1 a ou s' vl' \\<or> ignore \\<Delta> s s1 vl1 a ou s' vl'\"\nshows \"reaction \\<Delta> s vl s1 vl1\"", "lemma exit_coind:\nassumes K: \"K s\"\nand I: \"\\<And> trn. \\<lbrakk>K (srcOf trn); validTrans trn; \\<not> T trn\\<rbrakk>\n        \\<Longrightarrow> (\\<phi> trn \\<longrightarrow> f trn \\<noteq> v) \\<and> K (tgtOf trn)\"\nshows \"exit s v\"", "lemma noVal_disj:\nassumes \"noVal Inv1 v\" and \"noVal Inv2 v\"\nshows \"noVal (\\<lambda> s. Inv1 s \\<or> Inv2 s) v\"", "lemma noVal_conj:\nassumes \"noVal Inv1 v\" and \"noVal Inv2 v\"\nshows \"noVal (\\<lambda> s. Inv1 s \\<and> Inv2 s) v\"", "lemma no\\<phi>_noVal: \"no\\<phi> K \\<Longrightarrow> noVal K v\"", "lemma exitI[consumes 2, induct pred: \"exit\"]:\nassumes rs: \"reachNT s\" and K: \"K s\"\nand I:\n\"\\<And> s a ou s'.\n   \\<lbrakk>reach s; reachNT s; step s a = (ou,s'); K s\\<rbrakk>\n   \\<Longrightarrow> (\\<phi> (Trans s a ou s') \\<longrightarrow> f (Trans s a ou s') \\<noteq> v) \\<and> K s'\"\nshows \"exit s v\"", "lemma exitI2:\nassumes rs: \"reachNT s\" and K: \"K s\"\nand \"invarNT K\" and \"noVal K v\"\nshows \"exit s v\"", "lemma noVal2_disj:\nassumes \"noVal2 Inv1 v\" and \"noVal2 Inv2 v\"\nshows \"noVal2 (\\<lambda> s v. Inv1 s v \\<or> Inv2 s v) v\"", "lemma noVal2_conj:\nassumes \"noVal2 Inv1 v\" and \"noVal2 Inv2 v\"\nshows \"noVal2 (\\<lambda> s v. Inv1 s v \\<and> Inv2 s v) v\"", "lemma noVal_noVal2: \"noVal K v \\<Longrightarrow> noVal2 (\\<lambda> s v. K s) v\"", "lemma exitI_noVal2[consumes 2, induct pred: \"exit\"]:\nassumes rs: \"reachNT s\" and K: \"K s v\"\nand I:\n\"\\<And> s a ou s'.\n   \\<lbrakk>reach s; reachNT s; step s a = (ou,s'); K s v\\<rbrakk>\n   \\<Longrightarrow> (\\<phi> (Trans s a ou s') \\<longrightarrow> f (Trans s a ou s') \\<noteq> v) \\<and> K s' v\"\nshows \"exit s v\"", "lemma exitI2_noVal2:\nassumes rs: \"reachNT s\" and K: \"K s v\"\nand \"invarNT (\\<lambda> s. K s v)\" and \"noVal2 K v\"\nshows \"exit s v\"", "lemma exit_validFrom:\nassumes vl: \"vl \\<noteq> []\" and i: \"exit s (hd vl)\" and v: \"validFrom s tr\" and V: \"V tr = vl\"\nand T: \"never T tr\"\nshows False", "lemma unwindI[intro?]:\nassumes\n\"\\<And> s vl s1 vl1.\n   \\<lbrakk>reachNT s; reach s1; \\<Delta> s vl s1 vl1\\<rbrakk>\n   \\<Longrightarrow>\n   (vl \\<noteq> [] \\<and> exit s (hd vl))\n   \\<or>\n   iaction \\<Delta> s vl s1 vl1\n   \\<or>\n   ((vl \\<noteq> [] \\<or> vl1 = []) \\<and> reaction \\<Delta> s vl s1 vl1)\"\nshows \"unwind \\<Delta>\"", "lemma unwind_trace:\nassumes unwind: \"unwind \\<Delta>\" and \"reachNT s\" and \"reach s1\" and \"\\<Delta> s vl s1 vl1\"\nand \"validFrom s tr\" and \"never T tr\" and \"V tr = vl\"\nshows \"\\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1\"", "theorem unwind_secure:\nassumes init: \"\\<And> vl vl1. B vl vl1 \\<Longrightarrow> \\<Delta> istate vl istate vl1\"\nand unwind: \"unwind \\<Delta>\"\nshows secure"], "translations": [["", "lemma V_simps[simp]:\n\"V [] = []\"  \"\\<not> \\<phi> trn \\<Longrightarrow> V (trn # tr) = V tr\"  \"\\<phi> trn \\<Longrightarrow> V (trn # tr) = f trn # V tr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V [] = [] &&&\n    (\\<not> \\<phi> trn \\<Longrightarrow> V (trn # tr) = V tr) &&&\n    (\\<phi> trn \\<Longrightarrow> V (trn # tr) = f trn # V tr)", "unfolding V_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. BD_Security.filtermap \\<phi> f [] = [] &&&\n    (\\<not> \\<phi> trn \\<Longrightarrow>\n     BD_Security.filtermap \\<phi> f (trn # tr) =\n     BD_Security.filtermap \\<phi> f tr) &&&\n    (\\<phi> trn \\<Longrightarrow>\n     BD_Security.filtermap \\<phi> f (trn # tr) =\n     f trn # BD_Security.filtermap \\<phi> f tr)", "by auto"], ["", "lemma O_simps[simp]:\n\"O [] = []\"  \"\\<not> \\<gamma> trn \\<Longrightarrow> O (trn # tr) = O tr\"  \"\\<gamma> trn \\<Longrightarrow> O (trn # tr) = g trn # O tr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. O [] = [] &&&\n    (\\<not> \\<gamma> trn \\<Longrightarrow> O (trn # tr) = O tr) &&&\n    (\\<gamma> trn \\<Longrightarrow> O (trn # tr) = g trn # O tr)", "unfolding O_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. BD_Security.filtermap \\<gamma> g [] = [] &&&\n    (\\<not> \\<gamma> trn \\<Longrightarrow>\n     BD_Security.filtermap \\<gamma> g (trn # tr) =\n     BD_Security.filtermap \\<gamma> g tr) &&&\n    (\\<gamma> trn \\<Longrightarrow>\n     BD_Security.filtermap \\<gamma> g (trn # tr) =\n     g trn # BD_Security.filtermap \\<gamma> g tr)", "by auto"], ["", "(* Reachable states by transitions satisfying T: *)"], ["", "inductive reachNT:: \"'state \\<Rightarrow> bool\" where\nIstate: \"reachNT istate\"\n|\nStep:\n\"\\<lbrakk>reachNT (srcOf trn); step (srcOf trn) (actOf trn) = (outOf trn, tgtOf trn); \\<not> T trn\\<rbrakk>\n \\<Longrightarrow> reachNT (tgtOf trn)\""], ["", "lemma reachNT_PairI:\nassumes \"reachNT s\" and \"step s a = (ou, s')\" and \"\\<not> T (Trans s a ou s')\"\nshows \"reachNT s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachNT s'", "by (metis BD_Security.reachNT.simps assms trans.sel)"], ["", "lemma reachNT_reach: assumes \"reachNT s\"  shows \"reach s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach s", "using assms"], ["proof (prove)\nusing this:\n  reachNT s\n\ngoal (1 subgoal):\n 1. reach s", "by induct (auto intro: reach.intros, metis reach.Step snd_conv validTrans)"], ["", "lemma reachNT_stateO_aux:\nassumes \"reachNT s\"\nshows \"s = istate \\<or> (\\<exists>sh a ou. reach sh \\<and> step sh a = (ou,s) \\<and> \\<not>T (Trans sh a ou s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s = istate \\<or>\n    (\\<exists>sh a ou.\n        reach sh \\<and>\n        step sh a = (ou, s) \\<and> \\<not> T (Trans sh a ou s))", "using assms"], ["proof (prove)\nusing this:\n  reachNT s\n\ngoal (1 subgoal):\n 1. s = istate \\<or>\n    (\\<exists>sh a ou.\n        reach sh \\<and>\n        step sh a = (ou, s) \\<and> \\<not> T (Trans sh a ou s))", "by induct (clarsimp, metis BD_Security.reachNT_reach trans.exhaust_sel)"], ["", "lemma reachNT_state_cases[cases set,consumes 1, case_names init step]:\nassumes \"reachNT s\"\nobtains \"s = istate\"\n| sh a ou where \"reach sh\" \"step sh a = (ou,s)\" \"\\<not>T (Trans sh a ou s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>s = istate \\<Longrightarrow> thesis;\n     \\<And>sh a ou.\n        \\<lbrakk>reach sh; step sh a = (ou, s);\n         \\<not> T (Trans sh a ou s)\\<rbrakk>\n        \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (metis reachNT_stateO_aux[OF assms])"], ["", "(* This is assumed to be an invariant only modulo non T  *)"], ["", "definition invarNT where\n\"invarNT Inv \\<equiv> \\<forall> s a ou s'. reachNT s \\<and> Inv s \\<and> \\<not> T (Trans s a ou s') \\<and> step s a = (ou,s') \\<longrightarrow> Inv s'\""], ["", "lemma invarNT_disj:\nassumes \"invarNT Inv1\" and \"invarNT Inv2\"\nshows \"invarNT (\\<lambda> s. Inv1 s \\<or> Inv2 s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invarNT (\\<lambda>s. Inv1 s \\<or> Inv2 s)", "using assms"], ["proof (prove)\nusing this:\n  invarNT Inv1\n  invarNT Inv2\n\ngoal (1 subgoal):\n 1. invarNT (\\<lambda>s. Inv1 s \\<or> Inv2 s)", "unfolding invarNT_def"], ["proof (prove)\nusing this:\n  \\<forall>s a ou s'.\n     reachNT s \\<and>\n     Inv1 s \\<and>\n     \\<not> T (Trans s a ou s') \\<and> step s a = (ou, s') \\<longrightarrow>\n     Inv1 s'\n  \\<forall>s a ou s'.\n     reachNT s \\<and>\n     Inv2 s \\<and>\n     \\<not> T (Trans s a ou s') \\<and> step s a = (ou, s') \\<longrightarrow>\n     Inv2 s'\n\ngoal (1 subgoal):\n 1. \\<forall>s a ou s'.\n       reachNT s \\<and>\n       (Inv1 s \\<or> Inv2 s) \\<and>\n       \\<not> T (Trans s a ou s') \\<and>\n       step s a = (ou, s') \\<longrightarrow>\n       Inv1 s' \\<or> Inv2 s'", "by blast"], ["", "lemma invarNT_conj:\nassumes \"invarNT Inv1\" and \"invarNT Inv2\"\nshows \"invarNT (\\<lambda> s. Inv1 s \\<and> Inv2 s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invarNT (\\<lambda>s. Inv1 s \\<and> Inv2 s)", "using assms"], ["proof (prove)\nusing this:\n  invarNT Inv1\n  invarNT Inv2\n\ngoal (1 subgoal):\n 1. invarNT (\\<lambda>s. Inv1 s \\<and> Inv2 s)", "unfolding invarNT_def"], ["proof (prove)\nusing this:\n  \\<forall>s a ou s'.\n     reachNT s \\<and>\n     Inv1 s \\<and>\n     \\<not> T (Trans s a ou s') \\<and> step s a = (ou, s') \\<longrightarrow>\n     Inv1 s'\n  \\<forall>s a ou s'.\n     reachNT s \\<and>\n     Inv2 s \\<and>\n     \\<not> T (Trans s a ou s') \\<and> step s a = (ou, s') \\<longrightarrow>\n     Inv2 s'\n\ngoal (1 subgoal):\n 1. \\<forall>s a ou s'.\n       reachNT s \\<and>\n       (Inv1 s \\<and> Inv2 s) \\<and>\n       \\<not> T (Trans s a ou s') \\<and>\n       step s a = (ou, s') \\<longrightarrow>\n       Inv1 s' \\<and> Inv2 s'", "by blast"], ["", "lemma holdsIstate_invarNT:\nassumes h: \"holdsIstate Inv\" and i: \"invarNT Inv\" and a: \"reachNT s\"\nshows \"Inv s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Inv s", "using a"], ["proof (prove)\nusing this:\n  reachNT s\n\ngoal (1 subgoal):\n 1. Inv s", "using h i"], ["proof (prove)\nusing this:\n  reachNT s\n  holdsIstate Inv\n  invarNT Inv\n\ngoal (1 subgoal):\n 1. Inv s", "unfolding holdsIstate_def invarNT_def"], ["proof (prove)\nusing this:\n  reachNT s\n  Inv istate\n  \\<forall>s a ou s'.\n     reachNT s \\<and>\n     Inv s \\<and>\n     \\<not> T (Trans s a ou s') \\<and> step s a = (ou, s') \\<longrightarrow>\n     Inv s'\n\ngoal (1 subgoal):\n 1. Inv s", "by (induct rule: reachNT.induct) (metis i invarNT_def trans.exhaust_sel)+"], ["", "(* BD security: *)"], ["", "definition secure :: bool where\n\"secure \\<equiv>\n \\<forall> tr vl vl1.\n   validFrom istate tr \\<and> never T tr \\<and> B vl vl1 \\<and> V tr = vl \\<longrightarrow>\n   (\\<exists> tr1. validFrom istate tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1)\""], ["", "lemma V_iff_non_\\<phi>[simp]: \"V (trn # tr) = V tr \\<longleftrightarrow> \\<not> \\<phi> trn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (V (trn # tr) = V tr) = (\\<not> \\<phi> trn)", "by (cases \"\\<phi> trn\") auto"], ["", "lemma V_imp_\\<phi>: \"V (trn # tr) = v # V tr \\<Longrightarrow> \\<phi> trn\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V (trn # tr) = v # V tr \\<Longrightarrow> \\<phi> trn", "by (cases \"\\<phi> trn\") auto"], ["", "lemma V_imp_Nil: \"V (trn # tr) = [] \\<Longrightarrow> V tr = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V (trn # tr) = [] \\<Longrightarrow> V tr = []", "by (metis V_simps list.distinct trans.exhaust)"], ["", "lemma V_iff_Nil[simp]: \"V (trn # tr) = [] \\<longleftrightarrow> \\<not> \\<phi> trn \\<and> V tr = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (V (trn # tr) = []) = (\\<not> \\<phi> trn \\<and> V tr = [])", "by (metis V_iff_non_\\<phi> V_imp_Nil)"], ["", "end"], ["", "(* context BD_Security *)"], ["", "subsection\\<open>Unwinding proof method\\<close>"], ["", "context BD_Security\nbegin"], ["", "definition consume :: \"('state,'act,'out) trans \\<Rightarrow> 'value list \\<Rightarrow> 'value list \\<Rightarrow> bool\" where\n\"consume trn vl vl' \\<equiv>\n if \\<phi> trn then vl \\<noteq> [] \\<and> f trn = hd vl \\<and> vl' = tl vl\n else vl' = vl\""], ["", "lemma length_consume[simp]:\n\"consume trn vl vl' \\<Longrightarrow> length vl' < Suc (length vl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. consume trn vl vl' \\<Longrightarrow> length vl' < Suc (length vl)", "unfolding consume_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. if \\<phi> trn\n    then vl \\<noteq> [] \\<and> f trn = hd vl \\<and> vl' = tl vl\n    else vl' = vl \\<Longrightarrow>\n    length vl' < Suc (length vl)", "by (auto split: if_splits)"], ["", "lemma ex_consume_\\<phi>:\nassumes \"\\<not> \\<phi> trn\"\nobtains vl' where \"consume trn vl vl'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>vl'.\n        consume trn vl vl' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  \\<not> \\<phi> trn\n\ngoal (1 subgoal):\n 1. (\\<And>vl'.\n        consume trn vl vl' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding consume_def"], ["proof (prove)\nusing this:\n  \\<not> \\<phi> trn\n\ngoal (1 subgoal):\n 1. (\\<And>vl'.\n        if \\<phi> trn\n        then vl \\<noteq> [] \\<and> f trn = hd vl \\<and> vl' = tl vl\n        else vl' = vl \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["", "lemma ex_consume_NO:\nassumes \"vl \\<noteq> []\" and \"f trn = hd vl\"\nobtains vl' where \"consume trn vl vl'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>vl'.\n        consume trn vl vl' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  vl \\<noteq> []\n  f trn = hd vl\n\ngoal (1 subgoal):\n 1. (\\<And>vl'.\n        consume trn vl vl' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding consume_def"], ["proof (prove)\nusing this:\n  vl \\<noteq> []\n  f trn = hd vl\n\ngoal (1 subgoal):\n 1. (\\<And>vl'.\n        if \\<phi> trn\n        then vl \\<noteq> [] \\<and> f trn = hd vl \\<and> vl' = tl vl\n        else vl' = vl \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"\\<phi> trn\") auto"], ["", "(* independent action: *)"], ["", "definition iaction where\n\"iaction \\<Delta> s vl s1 vl1 \\<equiv>\n \\<exists> a1 ou1 s1' vl1'.\n   let trn1 = Trans s1 a1 ou1 s1' in\n   validTrans trn1 \\<and>\n   \\<phi> trn1 \\<and> consume trn1 vl1 vl1' \\<and>\n   \\<not> \\<gamma> trn1\n   \\<and>\n   \\<Delta> s vl s1' vl1'\""], ["", "lemma iactionI[intro?]:\nassumes \"step s1 a1 = (ou1, s1')\" and \"\\<phi> (Trans s1 a1 ou1 s1')\"\nand \"consume (Trans s1 a1 ou1 s1') vl1 vl1'\"\nand \"\\<not> \\<gamma> (Trans s1 a1 ou1 s1')\" and \"\\<Delta> s vl s1' vl1'\"\nshows \"iaction \\<Delta> s vl s1 vl1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. iaction \\<Delta> s vl s1 vl1", "unfolding iaction_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a1 ou1 s1' vl1'.\n       let trn1 = Trans s1 a1 ou1 s1'\n       in validTrans trn1 \\<and>\n          \\<phi> trn1 \\<and>\n          consume trn1 vl1 vl1' \\<and>\n          \\<not> \\<gamma> trn1 \\<and> \\<Delta> s vl s1' vl1'", "using assms"], ["proof (prove)\nusing this:\n  step s1 a1 = (ou1, s1')\n  \\<phi> (Trans s1 a1 ou1 s1')\n  consume (Trans s1 a1 ou1 s1') vl1 vl1'\n  \\<not> \\<gamma> (Trans s1 a1 ou1 s1')\n  \\<Delta> s vl s1' vl1'\n\ngoal (1 subgoal):\n 1. \\<exists>a1 ou1 s1' vl1'.\n       let trn1 = Trans s1 a1 ou1 s1'\n       in validTrans trn1 \\<and>\n          \\<phi> trn1 \\<and>\n          consume trn1 vl1 vl1' \\<and>\n          \\<not> \\<gamma> trn1 \\<and> \\<Delta> s vl s1' vl1'", "by auto"], ["", "definition match where\n\"match \\<Delta> s s1 vl1 a ou s' vl' \\<equiv>\n \\<exists> a1 ou1 s1' vl1'.\n    let trn = Trans s a ou s'; trn1 = Trans s1 a1 ou1 s1' in\n    validTrans trn1 \\<and>\n    consume trn1 vl1 vl1' \\<and>\n    \\<gamma> trn = \\<gamma> trn1 \\<and> (\\<gamma> trn \\<longrightarrow> g trn = g trn1) \\<and>\n    \\<Delta> s' vl' s1' vl1'\""], ["", "lemma matchI[intro?]:\nassumes \"validTrans (Trans s1 a1 ou1 s1')\"\nand \"consume (Trans s1 a1 ou1 s1') vl1 vl1'\" and \"\\<gamma> (Trans s a ou s') = \\<gamma> (Trans s1 a1 ou1 s1')\"\nand \"\\<gamma> (Trans s a ou s') \\<Longrightarrow> g (Trans s a ou s') = g (Trans s1 a1 ou1 s1')\"\nand \"\\<Delta> s' vl' s1' vl1'\"\nshows \"match \\<Delta> s s1 vl1 a ou s' vl'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match \\<Delta> s s1 vl1 a ou s' vl'", "unfolding match_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a1 ou1 s1' vl1'.\n       let trn = Trans s a ou s'; trn1 = Trans s1 a1 ou1 s1'\n       in validTrans trn1 \\<and>\n          consume trn1 vl1 vl1' \\<and>\n          \\<gamma> trn = \\<gamma> trn1 \\<and>\n          (\\<gamma> trn \\<longrightarrow> g trn = g trn1) \\<and>\n          \\<Delta> s' vl' s1' vl1'", "using assms"], ["proof (prove)\nusing this:\n  validTrans (Trans s1 a1 ou1 s1')\n  consume (Trans s1 a1 ou1 s1') vl1 vl1'\n  \\<gamma> (Trans s a ou s') = \\<gamma> (Trans s1 a1 ou1 s1')\n  \\<gamma> (Trans s a ou s') \\<Longrightarrow>\n  g (Trans s a ou s') = g (Trans s1 a1 ou1 s1')\n  \\<Delta> s' vl' s1' vl1'\n\ngoal (1 subgoal):\n 1. \\<exists>a1 ou1 s1' vl1'.\n       let trn = Trans s a ou s'; trn1 = Trans s1 a1 ou1 s1'\n       in validTrans trn1 \\<and>\n          consume trn1 vl1 vl1' \\<and>\n          \\<gamma> trn = \\<gamma> trn1 \\<and>\n          (\\<gamma> trn \\<longrightarrow> g trn = g trn1) \\<and>\n          \\<Delta> s' vl' s1' vl1'", "by auto"], ["", "definition ignore where\n\"ignore \\<Delta> s s1 vl1 a ou s' vl' \\<equiv>\n \\<not> \\<gamma> (Trans s a ou s') \\<and>\n \\<Delta> s' vl' s1 vl1\""], ["", "lemma ignoreI[intro?]:\nassumes \"\\<not> \\<gamma> (Trans s a ou s')\" and \"\\<Delta> s' vl' s1 vl1\"\nshows \"ignore \\<Delta> s s1 vl1 a ou s' vl'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ignore \\<Delta> s s1 vl1 a ou s' vl'", "unfolding ignore_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> \\<gamma> (Trans s a ou s') \\<and> \\<Delta> s' vl' s1 vl1", "using assms"], ["proof (prove)\nusing this:\n  \\<not> \\<gamma> (Trans s a ou s')\n  \\<Delta> s' vl' s1 vl1\n\ngoal (1 subgoal):\n 1. \\<not> \\<gamma> (Trans s a ou s') \\<and> \\<Delta> s' vl' s1 vl1", "by auto"], ["", "(* reaction: *)"], ["", "definition reaction where\n\"reaction \\<Delta> s vl s1 vl1 \\<equiv>\n \\<forall> a ou s' vl'.\n   let trn = Trans s a ou s' in\n   validTrans trn \\<and> \\<not> T trn \\<and>\n   consume trn vl vl'\n   \\<longrightarrow>\n   match \\<Delta> s s1 vl1 a ou s' vl'\n   \\<or>\n   ignore \\<Delta> s s1 vl1 a ou s' vl'\""], ["", "lemma reactionI[intro?]:\nassumes\n\"\\<And>a ou s' vl'.\n   \\<lbrakk>step s a = (ou, s'); \\<not> T (Trans s a ou s');\n    consume (Trans s a ou s') vl vl'\\<rbrakk>\n   \\<Longrightarrow>\n   match \\<Delta> s s1 vl1 a ou s' vl' \\<or> ignore \\<Delta> s s1 vl1 a ou s' vl'\"\nshows \"reaction \\<Delta> s vl s1 vl1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reaction \\<Delta> s vl s1 vl1", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>step s ?a3 = (?ou3, ?s'3); \\<not> T (Trans s ?a3 ?ou3 ?s'3);\n   consume (Trans s ?a3 ?ou3 ?s'3) vl ?vl'3\\<rbrakk>\n  \\<Longrightarrow> match \\<Delta> s s1 vl1 ?a3 ?ou3 ?s'3 ?vl'3 \\<or>\n                    ignore \\<Delta> s s1 vl1 ?a3 ?ou3 ?s'3 ?vl'3\n\ngoal (1 subgoal):\n 1. reaction \\<Delta> s vl s1 vl1", "unfolding reaction_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>step s ?a3 = (?ou3, ?s'3); \\<not> T (Trans s ?a3 ?ou3 ?s'3);\n   consume (Trans s ?a3 ?ou3 ?s'3) vl ?vl'3\\<rbrakk>\n  \\<Longrightarrow> match \\<Delta> s s1 vl1 ?a3 ?ou3 ?s'3 ?vl'3 \\<or>\n                    ignore \\<Delta> s s1 vl1 ?a3 ?ou3 ?s'3 ?vl'3\n\ngoal (1 subgoal):\n 1. \\<forall>a ou s' vl'.\n       let trn = Trans s a ou s'\n       in validTrans trn \\<and>\n          \\<not> T trn \\<and> consume trn vl vl' \\<longrightarrow>\n          match \\<Delta> s s1 vl1 a ou s' vl' \\<or>\n          ignore \\<Delta> s s1 vl1 a ou s' vl'", "by auto"], ["", "definition \"exit\" :: \"'state \\<Rightarrow> 'value \\<Rightarrow> bool\" where\n\"exit s v \\<equiv> \\<forall> tr trn. validFrom s (tr ## trn) \\<and> never T (tr ## trn) \\<and> \\<phi> trn \\<longrightarrow> f trn \\<noteq> v\""], ["", "lemma exit_coind:\nassumes K: \"K s\"\nand I: \"\\<And> trn. \\<lbrakk>K (srcOf trn); validTrans trn; \\<not> T trn\\<rbrakk>\n        \\<Longrightarrow> (\\<phi> trn \\<longrightarrow> f trn \\<noteq> v) \\<and> K (tgtOf trn)\"\nshows \"exit s v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exit s v", "using K"], ["proof (prove)\nusing this:\n  K s\n\ngoal (1 subgoal):\n 1. exit s v", "unfolding exit_def"], ["proof (prove)\nusing this:\n  K s\n\ngoal (1 subgoal):\n 1. \\<forall>tr trn.\n       validFrom s (tr ## trn) \\<and>\n       never T (tr ## trn) \\<and> \\<phi> trn \\<longrightarrow>\n       f trn \\<noteq> v", "proof(intro allI conjI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>tr trn.\n       \\<lbrakk>K s;\n        validFrom s (tr ## trn) \\<and>\n        never T (tr ## trn) \\<and> \\<phi> trn\\<rbrakk>\n       \\<Longrightarrow> f trn \\<noteq> v", "fix tr trn"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>tr trn.\n       \\<lbrakk>K s;\n        validFrom s (tr ## trn) \\<and>\n        never T (tr ## trn) \\<and> \\<phi> trn\\<rbrakk>\n       \\<Longrightarrow> f trn \\<noteq> v", "assume \"K s\" and \"validFrom s (tr ## trn) \\<and> never T (tr ## trn) \\<and> \\<phi> trn\""], ["proof (state)\nthis:\n  K s\n  validFrom s (tr ## trn) \\<and> never T (tr ## trn) \\<and> \\<phi> trn\n\ngoal (1 subgoal):\n 1. \\<And>tr trn.\n       \\<lbrakk>K s;\n        validFrom s (tr ## trn) \\<and>\n        never T (tr ## trn) \\<and> \\<phi> trn\\<rbrakk>\n       \\<Longrightarrow> f trn \\<noteq> v", "thus \"f trn \\<noteq> v\""], ["proof (prove)\nusing this:\n  K s\n  validFrom s (tr ## trn) \\<and> never T (tr ## trn) \\<and> \\<phi> trn\n\ngoal (1 subgoal):\n 1. f trn \\<noteq> v", "using I"], ["proof (prove)\nusing this:\n  K s\n  validFrom s (tr ## trn) \\<and> never T (tr ## trn) \\<and> \\<phi> trn\n  \\<lbrakk>K (srcOf ?trn3); validTrans ?trn3; \\<not> T ?trn3\\<rbrakk>\n  \\<Longrightarrow> (\\<phi> ?trn3 \\<longrightarrow>\n                     f ?trn3 \\<noteq> v) \\<and>\n                    K (tgtOf ?trn3)\n\ngoal (1 subgoal):\n 1. f trn \\<noteq> v", "unfolding validFrom_def"], ["proof (prove)\nusing this:\n  K s\n  (tr ## trn = [] \\<or>\n   valid (tr ## trn) \\<and> srcOf (hd (tr ## trn)) = s) \\<and>\n  never T (tr ## trn) \\<and> \\<phi> trn\n  \\<lbrakk>K (srcOf ?trn3); validTrans ?trn3; \\<not> T ?trn3\\<rbrakk>\n  \\<Longrightarrow> (\\<phi> ?trn3 \\<longrightarrow>\n                     f ?trn3 \\<noteq> v) \\<and>\n                    K (tgtOf ?trn3)\n\ngoal (1 subgoal):\n 1. f trn \\<noteq> v", "by (induction tr arbitrary: s trn)\n  (auto, metis neq_Nil_conv rotate1.simps(2) rotate1_is_Nil_conv valid_ConsE)"], ["proof (state)\nthis:\n  f trn \\<noteq> v\n\ngoal:\nNo subgoals!", "qed"], ["", "definition noVal where\n\"noVal K v \\<equiv>\n \\<forall> s a ou s'. reachNT s \\<and> K s \\<and> step s a = (ou,s') \\<and> \\<phi> (Trans s a ou s') \\<longrightarrow> f (Trans s a ou s') \\<noteq> v\""], ["", "lemma noVal_disj:\nassumes \"noVal Inv1 v\" and \"noVal Inv2 v\"\nshows \"noVal (\\<lambda> s. Inv1 s \\<or> Inv2 s) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. noVal (\\<lambda>s. Inv1 s \\<or> Inv2 s) v", "using assms"], ["proof (prove)\nusing this:\n  noVal Inv1 v\n  noVal Inv2 v\n\ngoal (1 subgoal):\n 1. noVal (\\<lambda>s. Inv1 s \\<or> Inv2 s) v", "unfolding noVal_def"], ["proof (prove)\nusing this:\n  \\<forall>s a ou s'.\n     reachNT s \\<and>\n     Inv1 s \\<and>\n     step s a = (ou, s') \\<and> \\<phi> (Trans s a ou s') \\<longrightarrow>\n     f (Trans s a ou s') \\<noteq> v\n  \\<forall>s a ou s'.\n     reachNT s \\<and>\n     Inv2 s \\<and>\n     step s a = (ou, s') \\<and> \\<phi> (Trans s a ou s') \\<longrightarrow>\n     f (Trans s a ou s') \\<noteq> v\n\ngoal (1 subgoal):\n 1. \\<forall>s a ou s'.\n       reachNT s \\<and>\n       (Inv1 s \\<or> Inv2 s) \\<and>\n       step s a = (ou, s') \\<and> \\<phi> (Trans s a ou s') \\<longrightarrow>\n       f (Trans s a ou s') \\<noteq> v", "by metis"], ["", "lemma noVal_conj:\nassumes \"noVal Inv1 v\" and \"noVal Inv2 v\"\nshows \"noVal (\\<lambda> s. Inv1 s \\<and> Inv2 s) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. noVal (\\<lambda>s. Inv1 s \\<and> Inv2 s) v", "using assms"], ["proof (prove)\nusing this:\n  noVal Inv1 v\n  noVal Inv2 v\n\ngoal (1 subgoal):\n 1. noVal (\\<lambda>s. Inv1 s \\<and> Inv2 s) v", "unfolding noVal_def"], ["proof (prove)\nusing this:\n  \\<forall>s a ou s'.\n     reachNT s \\<and>\n     Inv1 s \\<and>\n     step s a = (ou, s') \\<and> \\<phi> (Trans s a ou s') \\<longrightarrow>\n     f (Trans s a ou s') \\<noteq> v\n  \\<forall>s a ou s'.\n     reachNT s \\<and>\n     Inv2 s \\<and>\n     step s a = (ou, s') \\<and> \\<phi> (Trans s a ou s') \\<longrightarrow>\n     f (Trans s a ou s') \\<noteq> v\n\ngoal (1 subgoal):\n 1. \\<forall>s a ou s'.\n       reachNT s \\<and>\n       (Inv1 s \\<and> Inv2 s) \\<and>\n       step s a = (ou, s') \\<and> \\<phi> (Trans s a ou s') \\<longrightarrow>\n       f (Trans s a ou s') \\<noteq> v", "by blast"], ["", "(* Often encountered sufficient criterion for noVal: *)"], ["", "definition no\\<phi> where\n\"no\\<phi> K \\<equiv> \\<forall> s a ou s'. reachNT s \\<and> K s \\<and> step s a = (ou,s') \\<longrightarrow> \\<not> \\<phi> (Trans s a ou s')\""], ["", "lemma no\\<phi>_noVal: \"no\\<phi> K \\<Longrightarrow> noVal K v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no\\<phi> K \\<Longrightarrow> noVal K v", "unfolding no\\<phi>_def noVal_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s a ou s'.\n       reachNT s \\<and> K s \\<and> step s a = (ou, s') \\<longrightarrow>\n       \\<not> \\<phi> (Trans s a ou s') \\<Longrightarrow>\n    \\<forall>s a ou s'.\n       reachNT s \\<and>\n       K s \\<and>\n       step s a = (ou, s') \\<and> \\<phi> (Trans s a ou s') \\<longrightarrow>\n       f (Trans s a ou s') \\<noteq> v", "by auto"], ["", "(* intro rule for quick inline checks: *)"], ["", "lemma exitI[consumes 2, induct pred: \"exit\"]:\nassumes rs: \"reachNT s\" and K: \"K s\"\nand I:\n\"\\<And> s a ou s'.\n   \\<lbrakk>reach s; reachNT s; step s a = (ou,s'); K s\\<rbrakk>\n   \\<Longrightarrow> (\\<phi> (Trans s a ou s') \\<longrightarrow> f (Trans s a ou s') \\<noteq> v) \\<and> K s'\"\nshows \"exit s v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exit s v", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. exit s v", "let ?K = \"\\<lambda> s. reachNT s \\<and> K s\""], ["proof (state)\ngoal (1 subgoal):\n 1. exit s v", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. exit s v", "using assms"], ["proof (prove)\nusing this:\n  reachNT s\n  K s\n  \\<lbrakk>reach ?s3; reachNT ?s3; step ?s3 ?a3 = (?ou3, ?s'3);\n   K ?s3\\<rbrakk>\n  \\<Longrightarrow> (\\<phi> (Trans ?s3 ?a3 ?ou3 ?s'3) \\<longrightarrow>\n                     f (Trans ?s3 ?a3 ?ou3 ?s'3) \\<noteq> v) \\<and>\n                    K ?s'3\n\ngoal (1 subgoal):\n 1. exit s v", "by (intro exit_coind[of ?K])\n  (metis BD_Security.reachNT_reach IO_Automaton.validTrans reachNT.Step trans.exhaust_sel)+"], ["proof (state)\nthis:\n  exit s v\n\ngoal:\nNo subgoals!", "qed"], ["", "(* intro rule for more elaborate checks: *)"], ["", "lemma exitI2:\nassumes rs: \"reachNT s\" and K: \"K s\"\nand \"invarNT K\" and \"noVal K v\"\nshows \"exit s v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exit s v", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. exit s v", "let ?K = \"\\<lambda> s. reachNT s \\<and> K s\""], ["proof (state)\ngoal (1 subgoal):\n 1. exit s v", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. exit s v", "using assms"], ["proof (prove)\nusing this:\n  reachNT s\n  K s\n  invarNT K\n  noVal K v\n\ngoal (1 subgoal):\n 1. exit s v", "unfolding invarNT_def noVal_def"], ["proof (prove)\nusing this:\n  reachNT s\n  K s\n  \\<forall>s a ou s'.\n     reachNT s \\<and>\n     K s \\<and>\n     \\<not> T (Trans s a ou s') \\<and> step s a = (ou, s') \\<longrightarrow>\n     K s'\n  \\<forall>s a ou s'.\n     reachNT s \\<and>\n     K s \\<and>\n     step s a = (ou, s') \\<and> \\<phi> (Trans s a ou s') \\<longrightarrow>\n     f (Trans s a ou s') \\<noteq> v\n\ngoal (1 subgoal):\n 1. exit s v", "apply(intro exit_coind[of ?K])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>reachNT s; K s;\n     \\<forall>s a ou s'.\n        reachNT s \\<and>\n        K s \\<and>\n        \\<not> T (Trans s a ou s') \\<and>\n        step s a = (ou, s') \\<longrightarrow>\n        K s';\n     \\<forall>s a ou s'.\n        reachNT s \\<and>\n        K s \\<and>\n        step s a = (ou, s') \\<and>\n        \\<phi> (Trans s a ou s') \\<longrightarrow>\n        f (Trans s a ou s') \\<noteq> v\\<rbrakk>\n    \\<Longrightarrow> reachNT s \\<and> K s\n 2. \\<And>trn.\n       \\<lbrakk>reachNT s; K s;\n        \\<forall>s a ou s'.\n           reachNT s \\<and>\n           K s \\<and>\n           \\<not> T (Trans s a ou s') \\<and>\n           step s a = (ou, s') \\<longrightarrow>\n           K s';\n        \\<forall>s a ou s'.\n           reachNT s \\<and>\n           K s \\<and>\n           step s a = (ou, s') \\<and>\n           \\<phi> (Trans s a ou s') \\<longrightarrow>\n           f (Trans s a ou s') \\<noteq> v;\n        reachNT (srcOf trn) \\<and> K (srcOf trn); validTrans trn;\n        \\<not> T trn\\<rbrakk>\n       \\<Longrightarrow> (\\<phi> trn \\<longrightarrow>\n                          f trn \\<noteq> v) \\<and>\n                         reachNT (tgtOf trn) \\<and> K (tgtOf trn)", "by metis (metis IO_Automaton.validTrans reachNT.Step trans.exhaust_sel)"], ["proof (state)\nthis:\n  exit s v\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Binary version of the invariant: *)"], ["", "definition noVal2 where\n\"noVal2 K v \\<equiv>\n \\<forall> s a ou s'. reachNT s \\<and> K s v \\<and> step s a = (ou,s') \\<and> \\<phi> (Trans s a ou s') \\<longrightarrow> f (Trans s a ou s') \\<noteq> v\""], ["", "lemma noVal2_disj:\nassumes \"noVal2 Inv1 v\" and \"noVal2 Inv2 v\"\nshows \"noVal2 (\\<lambda> s v. Inv1 s v \\<or> Inv2 s v) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. noVal2 (\\<lambda>s v. Inv1 s v \\<or> Inv2 s v) v", "using assms"], ["proof (prove)\nusing this:\n  noVal2 Inv1 v\n  noVal2 Inv2 v\n\ngoal (1 subgoal):\n 1. noVal2 (\\<lambda>s v. Inv1 s v \\<or> Inv2 s v) v", "unfolding noVal2_def"], ["proof (prove)\nusing this:\n  \\<forall>s a ou s'.\n     reachNT s \\<and>\n     Inv1 s v \\<and>\n     step s a = (ou, s') \\<and> \\<phi> (Trans s a ou s') \\<longrightarrow>\n     f (Trans s a ou s') \\<noteq> v\n  \\<forall>s a ou s'.\n     reachNT s \\<and>\n     Inv2 s v \\<and>\n     step s a = (ou, s') \\<and> \\<phi> (Trans s a ou s') \\<longrightarrow>\n     f (Trans s a ou s') \\<noteq> v\n\ngoal (1 subgoal):\n 1. \\<forall>s a ou s'.\n       reachNT s \\<and>\n       (Inv1 s v \\<or> Inv2 s v) \\<and>\n       step s a = (ou, s') \\<and> \\<phi> (Trans s a ou s') \\<longrightarrow>\n       f (Trans s a ou s') \\<noteq> v", "by metis"], ["", "lemma noVal2_conj:\nassumes \"noVal2 Inv1 v\" and \"noVal2 Inv2 v\"\nshows \"noVal2 (\\<lambda> s v. Inv1 s v \\<and> Inv2 s v) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. noVal2 (\\<lambda>s v. Inv1 s v \\<and> Inv2 s v) v", "using assms"], ["proof (prove)\nusing this:\n  noVal2 Inv1 v\n  noVal2 Inv2 v\n\ngoal (1 subgoal):\n 1. noVal2 (\\<lambda>s v. Inv1 s v \\<and> Inv2 s v) v", "unfolding noVal2_def"], ["proof (prove)\nusing this:\n  \\<forall>s a ou s'.\n     reachNT s \\<and>\n     Inv1 s v \\<and>\n     step s a = (ou, s') \\<and> \\<phi> (Trans s a ou s') \\<longrightarrow>\n     f (Trans s a ou s') \\<noteq> v\n  \\<forall>s a ou s'.\n     reachNT s \\<and>\n     Inv2 s v \\<and>\n     step s a = (ou, s') \\<and> \\<phi> (Trans s a ou s') \\<longrightarrow>\n     f (Trans s a ou s') \\<noteq> v\n\ngoal (1 subgoal):\n 1. \\<forall>s a ou s'.\n       reachNT s \\<and>\n       (Inv1 s v \\<and> Inv2 s v) \\<and>\n       step s a = (ou, s') \\<and> \\<phi> (Trans s a ou s') \\<longrightarrow>\n       f (Trans s a ou s') \\<noteq> v", "by blast"], ["", "lemma noVal_noVal2: \"noVal K v \\<Longrightarrow> noVal2 (\\<lambda> s v. K s) v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. noVal K v \\<Longrightarrow> noVal2 (\\<lambda>s v. K s) v", "unfolding noVal_def noVal2_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s a ou s'.\n       reachNT s \\<and>\n       K s \\<and>\n       step s a = (ou, s') \\<and> \\<phi> (Trans s a ou s') \\<longrightarrow>\n       f (Trans s a ou s') \\<noteq> v \\<Longrightarrow>\n    \\<forall>s a ou s'.\n       reachNT s \\<and>\n       K s \\<and>\n       step s a = (ou, s') \\<and> \\<phi> (Trans s a ou s') \\<longrightarrow>\n       f (Trans s a ou s') \\<noteq> v", "by auto"], ["", "lemma exitI_noVal2[consumes 2, induct pred: \"exit\"]:\nassumes rs: \"reachNT s\" and K: \"K s v\"\nand I:\n\"\\<And> s a ou s'.\n   \\<lbrakk>reach s; reachNT s; step s a = (ou,s'); K s v\\<rbrakk>\n   \\<Longrightarrow> (\\<phi> (Trans s a ou s') \\<longrightarrow> f (Trans s a ou s') \\<noteq> v) \\<and> K s' v\"\nshows \"exit s v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exit s v", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. exit s v", "let ?K = \"\\<lambda> s. reachNT s \\<and> K s v\""], ["proof (state)\ngoal (1 subgoal):\n 1. exit s v", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. exit s v", "using assms"], ["proof (prove)\nusing this:\n  reachNT s\n  K s v\n  \\<lbrakk>reach ?s3; reachNT ?s3; step ?s3 ?a3 = (?ou3, ?s'3);\n   K ?s3 v\\<rbrakk>\n  \\<Longrightarrow> (\\<phi> (Trans ?s3 ?a3 ?ou3 ?s'3) \\<longrightarrow>\n                     f (Trans ?s3 ?a3 ?ou3 ?s'3) \\<noteq> v) \\<and>\n                    K ?s'3 v\n\ngoal (1 subgoal):\n 1. exit s v", "by (intro exit_coind[of ?K])\n  (metis BD_Security.reachNT_reach IO_Automaton.validTrans reachNT.Step trans.exhaust_sel)+"], ["proof (state)\nthis:\n  exit s v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma exitI2_noVal2:\nassumes rs: \"reachNT s\" and K: \"K s v\"\nand \"invarNT (\\<lambda> s. K s v)\" and \"noVal2 K v\"\nshows \"exit s v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exit s v", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. exit s v", "let ?K = \"\\<lambda> s. reachNT s \\<and> K s v\""], ["proof (state)\ngoal (1 subgoal):\n 1. exit s v", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. exit s v", "using assms"], ["proof (prove)\nusing this:\n  reachNT s\n  K s v\n  invarNT (\\<lambda>s. K s v)\n  noVal2 K v\n\ngoal (1 subgoal):\n 1. exit s v", "unfolding invarNT_def noVal2_def"], ["proof (prove)\nusing this:\n  reachNT s\n  K s v\n  \\<forall>s a ou s'.\n     reachNT s \\<and>\n     K s v \\<and>\n     \\<not> T (Trans s a ou s') \\<and> step s a = (ou, s') \\<longrightarrow>\n     K s' v\n  \\<forall>s a ou s'.\n     reachNT s \\<and>\n     K s v \\<and>\n     step s a = (ou, s') \\<and> \\<phi> (Trans s a ou s') \\<longrightarrow>\n     f (Trans s a ou s') \\<noteq> v\n\ngoal (1 subgoal):\n 1. exit s v", "by (intro exit_coind[of ?K]) (metis IO_Automaton.validTrans reachNT.Step trans.exhaust_sel)+"], ["proof (state)\nthis:\n  exit s v\n\ngoal:\nNo subgoals!", "qed"], ["", "(* end binary version *)"], ["", "lemma exit_validFrom:\nassumes vl: \"vl \\<noteq> []\" and i: \"exit s (hd vl)\" and v: \"validFrom s tr\" and V: \"V tr = vl\"\nand T: \"never T tr\"\nshows False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using i v V T"], ["proof (prove)\nusing this:\n  exit s (hd vl)\n  validFrom s tr\n  V tr = vl\n  never T tr\n\ngoal (1 subgoal):\n 1. False", "proof(induction tr arbitrary: s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>exit s (hd vl); validFrom s []; V [] = vl;\n        never T []\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a tr s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>exit s (hd vl); validFrom s tr; V tr = vl;\n                    never T tr\\<rbrakk>\n                   \\<Longrightarrow> False;\n        exit s (hd vl); validFrom s (a # tr); V (a # tr) = vl;\n        never T (a # tr)\\<rbrakk>\n       \\<Longrightarrow> False", "case Nil"], ["proof (state)\nthis:\n  exit s (hd vl)\n  validFrom s []\n  V [] = vl\n  never T []\n\ngoal (2 subgoals):\n 1. \\<And>s.\n       \\<lbrakk>exit s (hd vl); validFrom s []; V [] = vl;\n        never T []\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>a tr s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>exit s (hd vl); validFrom s tr; V tr = vl;\n                    never T tr\\<rbrakk>\n                   \\<Longrightarrow> False;\n        exit s (hd vl); validFrom s (a # tr); V (a # tr) = vl;\n        never T (a # tr)\\<rbrakk>\n       \\<Longrightarrow> False", "thus ?case"], ["proof (prove)\nusing this:\n  exit s (hd vl)\n  validFrom s []\n  V [] = vl\n  never T []\n\ngoal (1 subgoal):\n 1. False", "by (metis V_simps(1) vl)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a tr s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>exit s (hd vl); validFrom s tr; V tr = vl;\n                    never T tr\\<rbrakk>\n                   \\<Longrightarrow> False;\n        exit s (hd vl); validFrom s (a # tr); V (a # tr) = vl;\n        never T (a # tr)\\<rbrakk>\n       \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a tr s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>exit s (hd vl); validFrom s tr; V tr = vl;\n                    never T tr\\<rbrakk>\n                   \\<Longrightarrow> False;\n        exit s (hd vl); validFrom s (a # tr); V (a # tr) = vl;\n        never T (a # tr)\\<rbrakk>\n       \\<Longrightarrow> False", "case (Cons trn tr s)"], ["proof (state)\nthis:\n  \\<lbrakk>exit ?s3 (hd vl); validFrom ?s3 tr; V tr = vl;\n   never T tr\\<rbrakk>\n  \\<Longrightarrow> False\n  exit s (hd vl)\n  validFrom s (trn # tr)\n  V (trn # tr) = vl\n  never T (trn # tr)\n\ngoal (1 subgoal):\n 1. \\<And>a tr s.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>exit s (hd vl); validFrom s tr; V tr = vl;\n                    never T tr\\<rbrakk>\n                   \\<Longrightarrow> False;\n        exit s (hd vl); validFrom s (a # tr); V (a # tr) = vl;\n        never T (a # tr)\\<rbrakk>\n       \\<Longrightarrow> False", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof(cases \"\\<phi> trn\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<phi> trn \\<Longrightarrow> False\n 2. \\<not> \\<phi> trn \\<Longrightarrow> False", "case True"], ["proof (state)\nthis:\n  \\<phi> trn\n\ngoal (2 subgoals):\n 1. \\<phi> trn \\<Longrightarrow> False\n 2. \\<not> \\<phi> trn \\<Longrightarrow> False", "hence \"f trn = hd vl\""], ["proof (prove)\nusing this:\n  \\<phi> trn\n\ngoal (1 subgoal):\n 1. f trn = hd vl", "using Cons"], ["proof (prove)\nusing this:\n  \\<phi> trn\n  \\<lbrakk>exit ?s3 (hd vl); validFrom ?s3 tr; V tr = vl;\n   never T tr\\<rbrakk>\n  \\<Longrightarrow> False\n  exit s (hd vl)\n  validFrom s (trn # tr)\n  V (trn # tr) = vl\n  never T (trn # tr)\n\ngoal (1 subgoal):\n 1. f trn = hd vl", "by (metis V_simps(3) hd_Cons_tl list.inject vl)"], ["proof (state)\nthis:\n  f trn = hd vl\n\ngoal (2 subgoals):\n 1. \\<phi> trn \\<Longrightarrow> False\n 2. \\<not> \\<phi> trn \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  f trn = hd vl\n\ngoal (2 subgoals):\n 1. \\<phi> trn \\<Longrightarrow> False\n 2. \\<not> \\<phi> trn \\<Longrightarrow> False", "have \"validFrom s [trn]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. validFrom s [trn]", "using \\<open>validFrom s (trn # tr)\\<close>"], ["proof (prove)\nusing this:\n  validFrom s (trn # tr)\n\ngoal (1 subgoal):\n 1. validFrom s [trn]", "unfolding validFrom_def"], ["proof (prove)\nusing this:\n  trn # tr = [] \\<or> valid (trn # tr) \\<and> srcOf (hd (trn # tr)) = s\n\ngoal (1 subgoal):\n 1. [trn] = [] \\<or> valid [trn] \\<and> srcOf (hd [trn]) = s", "by auto"], ["proof (state)\nthis:\n  validFrom s [trn]\n\ngoal (2 subgoals):\n 1. \\<phi> trn \\<Longrightarrow> False\n 2. \\<not> \\<phi> trn \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  f trn = hd vl\n  validFrom s [trn]", "show ?thesis"], ["proof (prove)\nusing this:\n  f trn = hd vl\n  validFrom s [trn]\n\ngoal (1 subgoal):\n 1. False", "using Cons True"], ["proof (prove)\nusing this:\n  f trn = hd vl\n  validFrom s [trn]\n  \\<lbrakk>exit ?s3 (hd vl); validFrom ?s3 tr; V tr = vl;\n   never T tr\\<rbrakk>\n  \\<Longrightarrow> False\n  exit s (hd vl)\n  validFrom s (trn # tr)\n  V (trn # tr) = vl\n  never T (trn # tr)\n  \\<phi> trn\n\ngoal (1 subgoal):\n 1. False", "unfolding exit_def"], ["proof (prove)\nusing this:\n  f trn = hd vl\n  validFrom s [trn]\n  \\<lbrakk>\\<forall>tr trn.\n              validFrom ?s3 (tr ## trn) \\<and>\n              never T (tr ## trn) \\<and> \\<phi> trn \\<longrightarrow>\n              f trn \\<noteq> hd vl;\n   validFrom ?s3 tr; V tr = vl; never T tr\\<rbrakk>\n  \\<Longrightarrow> False\n  \\<forall>tr trn.\n     validFrom s (tr ## trn) \\<and>\n     never T (tr ## trn) \\<and> \\<phi> trn \\<longrightarrow>\n     f trn \\<noteq> hd vl\n  validFrom s (trn # tr)\n  V (trn # tr) = vl\n  never T (trn # tr)\n  \\<phi> trn\n\ngoal (1 subgoal):\n 1. False", "by (elim allE[of _ \"[]\"]) auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<not> \\<phi> trn \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> \\<phi> trn \\<Longrightarrow> False", "case False"], ["proof (state)\nthis:\n  \\<not> \\<phi> trn\n\ngoal (1 subgoal):\n 1. \\<not> \\<phi> trn \\<Longrightarrow> False", "hence \"V tr = vl\""], ["proof (prove)\nusing this:\n  \\<not> \\<phi> trn\n\ngoal (1 subgoal):\n 1. V tr = vl", "using Cons"], ["proof (prove)\nusing this:\n  \\<not> \\<phi> trn\n  \\<lbrakk>exit ?s3 (hd vl); validFrom ?s3 tr; V tr = vl;\n   never T tr\\<rbrakk>\n  \\<Longrightarrow> False\n  exit s (hd vl)\n  validFrom s (trn # tr)\n  V (trn # tr) = vl\n  never T (trn # tr)\n\ngoal (1 subgoal):\n 1. V tr = vl", "by auto"], ["proof (state)\nthis:\n  V tr = vl\n\ngoal (1 subgoal):\n 1. \\<not> \\<phi> trn \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  V tr = vl\n\ngoal (1 subgoal):\n 1. \\<not> \\<phi> trn \\<Longrightarrow> False", "have \"never T tr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. never T tr", "by (metis Cons.prems list_all_simps)"], ["proof (state)\nthis:\n  never T tr\n\ngoal (1 subgoal):\n 1. \\<not> \\<phi> trn \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  never T tr\n\ngoal (1 subgoal):\n 1. \\<not> \\<phi> trn \\<Longrightarrow> False", "from \\<open>validFrom s (trn # tr)\\<close>"], ["proof (chain)\npicking this:\n  validFrom s (trn # tr)", "have \"validFrom (tgtOf trn) tr\" and s: \"s = srcOf trn\""], ["proof (prove)\nusing this:\n  validFrom s (trn # tr)\n\ngoal (1 subgoal):\n 1. validFrom (tgtOf trn) tr &&& s = srcOf trn", "by (metis list.distinct(1) validFrom_def valid_ConsE Cons.prems(2) \n              IO_Automaton.validFrom_def list.discI list.sel(1))+"], ["proof (state)\nthis:\n  validFrom (tgtOf trn) tr\n  s = srcOf trn\n\ngoal (1 subgoal):\n 1. \\<not> \\<phi> trn \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  validFrom (tgtOf trn) tr\n  s = srcOf trn\n\ngoal (1 subgoal):\n 1. \\<not> \\<phi> trn \\<Longrightarrow> False", "have \"exit (tgtOf trn) (hd vl)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. exit (tgtOf trn) (hd vl)", "using \\<open>exit s (hd vl)\\<close>"], ["proof (prove)\nusing this:\n  exit s (hd vl)\n\ngoal (1 subgoal):\n 1. exit (tgtOf trn) (hd vl)", "unfolding exit_def s"], ["proof (prove)\nusing this:\n  \\<forall>tr trna.\n     validFrom (srcOf trn) (tr ## trna) \\<and>\n     never T (tr ## trna) \\<and> \\<phi> trna \\<longrightarrow>\n     f trna \\<noteq> hd vl\n\ngoal (1 subgoal):\n 1. \\<forall>tr trna.\n       validFrom (tgtOf trn) (tr ## trna) \\<and>\n       never T (tr ## trna) \\<and> \\<phi> trna \\<longrightarrow>\n       f trna \\<noteq> hd vl", "by simp\n    (metis (no_types) Cons.prems(2) Cons.prems(4) append_Cons list.sel(1)\n           list.distinct list_all_simps valid.Cons validFrom_def valid_ConsE)"], ["proof (state)\nthis:\n  exit (tgtOf trn) (hd vl)\n\ngoal (1 subgoal):\n 1. \\<not> \\<phi> trn \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  V tr = vl\n  never T tr\n  validFrom (tgtOf trn) tr\n  s = srcOf trn\n  exit (tgtOf trn) (hd vl)", "show ?thesis"], ["proof (prove)\nusing this:\n  V tr = vl\n  never T tr\n  validFrom (tgtOf trn) tr\n  s = srcOf trn\n  exit (tgtOf trn) (hd vl)\n\ngoal (1 subgoal):\n 1. False", "using Cons(1)"], ["proof (prove)\nusing this:\n  V tr = vl\n  never T tr\n  validFrom (tgtOf trn) tr\n  s = srcOf trn\n  exit (tgtOf trn) (hd vl)\n  \\<lbrakk>exit ?s3 (hd vl); validFrom ?s3 tr; V tr = vl;\n   never T tr\\<rbrakk>\n  \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "definition unwind where\n\"unwind \\<Delta> \\<equiv>\n \\<forall> s vl s1 vl1.\n   reachNT s \\<and> reach s1 \\<and> \\<Delta> s vl s1 vl1\n   \\<longrightarrow>\n   (vl \\<noteq> [] \\<and> exit s (hd vl))\n   \\<or>\n   iaction \\<Delta> s vl s1 vl1\n   \\<or>\n   ((vl \\<noteq> [] \\<or> vl1 = []) \\<and> reaction \\<Delta> s vl s1 vl1)\""], ["", "lemma unwindI[intro?]:\nassumes\n\"\\<And> s vl s1 vl1.\n   \\<lbrakk>reachNT s; reach s1; \\<Delta> s vl s1 vl1\\<rbrakk>\n   \\<Longrightarrow>\n   (vl \\<noteq> [] \\<and> exit s (hd vl))\n   \\<or>\n   iaction \\<Delta> s vl s1 vl1\n   \\<or>\n   ((vl \\<noteq> [] \\<or> vl1 = []) \\<and> reaction \\<Delta> s vl s1 vl1)\"\nshows \"unwind \\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unwind \\<Delta>", "using assms"], ["proof (prove)\nusing this:\n  \\<lbrakk>reachNT ?s3; reach ?s1.3; \\<Delta> ?s3 ?vl3 ?s1.3 ?vl1.3\\<rbrakk>\n  \\<Longrightarrow> ?vl3 \\<noteq> [] \\<and> exit ?s3 (hd ?vl3) \\<or>\n                    iaction \\<Delta> ?s3 ?vl3 ?s1.3 ?vl1.3 \\<or>\n                    (?vl3 \\<noteq> [] \\<or> ?vl1.3 = []) \\<and>\n                    reaction \\<Delta> ?s3 ?vl3 ?s1.3 ?vl1.3\n\ngoal (1 subgoal):\n 1. unwind \\<Delta>", "unfolding unwind_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>reachNT ?s3; reach ?s1.3; \\<Delta> ?s3 ?vl3 ?s1.3 ?vl1.3\\<rbrakk>\n  \\<Longrightarrow> ?vl3 \\<noteq> [] \\<and> exit ?s3 (hd ?vl3) \\<or>\n                    iaction \\<Delta> ?s3 ?vl3 ?s1.3 ?vl1.3 \\<or>\n                    (?vl3 \\<noteq> [] \\<or> ?vl1.3 = []) \\<and>\n                    reaction \\<Delta> ?s3 ?vl3 ?s1.3 ?vl1.3\n\ngoal (1 subgoal):\n 1. \\<forall>s vl s1 vl1.\n       reachNT s \\<and>\n       reach s1 \\<and> \\<Delta> s vl s1 vl1 \\<longrightarrow>\n       vl \\<noteq> [] \\<and> exit s (hd vl) \\<or>\n       iaction \\<Delta> s vl s1 vl1 \\<or>\n       (vl \\<noteq> [] \\<or> vl1 = []) \\<and> reaction \\<Delta> s vl s1 vl1", "by auto"], ["", "lemma unwind_trace:\nassumes unwind: \"unwind \\<Delta>\" and \"reachNT s\" and \"reach s1\" and \"\\<Delta> s vl s1 vl1\"\nand \"validFrom s tr\" and \"never T tr\" and \"V tr = vl\"\nshows \"\\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "let ?S = \"\\<lambda> tr vl1.\n  \\<forall> s vl s1. reachNT s \\<and> reach s1 \\<and> \\<Delta> s vl s1 vl1 \\<and> validFrom s tr \\<and> never T tr \\<and> V tr = vl \\<longrightarrow>\n          (\\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "let ?f = \"\\<lambda> tr vl1. length tr + length vl1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "have \"?S tr vl1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s vl s1.\n       reachNT s \\<and>\n       reach s1 \\<and>\n       \\<Delta> s vl s1 vl1 \\<and>\n       validFrom s tr \\<and> never T tr \\<and> V tr = vl \\<longrightarrow>\n       (\\<exists>tr1.\n           validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1)", "proof(induct rule: measure_induct2[of ?f ?S])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       (\\<And>y1 y2.\n           length y1 + length y2 < length x1 + length x2 \\<Longrightarrow>\n           \\<forall>s vl s1.\n              reachNT s \\<and>\n              reach s1 \\<and>\n              \\<Delta> s vl s1 y2 \\<and>\n              validFrom s y1 \\<and>\n              never T y1 \\<and> V y1 = vl \\<longrightarrow>\n              (\\<exists>tr1.\n                  validFrom s1 tr1 \\<and>\n                  O tr1 = O y1 \\<and> V tr1 = y2)) \\<Longrightarrow>\n       \\<forall>s vl s1.\n          reachNT s \\<and>\n          reach s1 \\<and>\n          \\<Delta> s vl s1 x2 \\<and>\n          validFrom s x1 \\<and>\n          never T x1 \\<and> V x1 = vl \\<longrightarrow>\n          (\\<exists>tr1.\n              validFrom s1 tr1 \\<and> O tr1 = O x1 \\<and> V tr1 = x2)", "case (1 tr vl1)"], ["proof (state)\nthis:\n  length ?y1.4 + length ?y2.4 < length tr + length vl1 \\<Longrightarrow>\n  \\<forall>s vl s1.\n     reachNT s \\<and>\n     reach s1 \\<and>\n     \\<Delta> s vl s1 ?y2.4 \\<and>\n     validFrom s ?y1.4 \\<and>\n     never T ?y1.4 \\<and> V ?y1.4 = vl \\<longrightarrow>\n     (\\<exists>tr1.\n         validFrom s1 tr1 \\<and> O tr1 = O ?y1.4 \\<and> V tr1 = ?y2.4)\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2.\n       (\\<And>y1 y2.\n           length y1 + length y2 < length x1 + length x2 \\<Longrightarrow>\n           \\<forall>s vl s1.\n              reachNT s \\<and>\n              reach s1 \\<and>\n              \\<Delta> s vl s1 y2 \\<and>\n              validFrom s y1 \\<and>\n              never T y1 \\<and> V y1 = vl \\<longrightarrow>\n              (\\<exists>tr1.\n                  validFrom s1 tr1 \\<and>\n                  O tr1 = O y1 \\<and> V tr1 = y2)) \\<Longrightarrow>\n       \\<forall>s vl s1.\n          reachNT s \\<and>\n          reach s1 \\<and>\n          \\<Delta> s vl s1 x2 \\<and>\n          validFrom s x1 \\<and>\n          never T x1 \\<and> V x1 = vl \\<longrightarrow>\n          (\\<exists>tr1.\n              validFrom s1 tr1 \\<and> O tr1 = O x1 \\<and> V tr1 = x2)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s vl s1.\n       reachNT s \\<and>\n       reach s1 \\<and>\n       \\<Delta> s vl s1 vl1 \\<and>\n       validFrom s tr \\<and> never T tr \\<and> V tr = vl \\<longrightarrow>\n       (\\<exists>tr1.\n           validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1)", "proof(intro allI impI, elim conjE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s vl s1.\n       \\<lbrakk>reachNT s; reach s1; \\<Delta> s vl s1 vl1; validFrom s tr;\n        never T tr; V tr = vl\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tr1.\n                            validFrom s1 tr1 \\<and>\n                            O tr1 = O tr \\<and> V tr1 = vl1", "fix s vl s1"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s vl s1.\n       \\<lbrakk>reachNT s; reach s1; \\<Delta> s vl s1 vl1; validFrom s tr;\n        never T tr; V tr = vl\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tr1.\n                            validFrom s1 tr1 \\<and>\n                            O tr1 = O tr \\<and> V tr1 = vl1", "assume rs: \"reachNT s\" and rs1: \"reach s1\" and \\<Delta>: \"\\<Delta> s vl s1 vl1\"\n      and v: \"validFrom s tr\" and NT: \"never T tr\" and V: \"V tr = vl\""], ["proof (state)\nthis:\n  reachNT s\n  reach s1\n  \\<Delta> s vl s1 vl1\n  validFrom s tr\n  never T tr\n  V tr = vl\n\ngoal (1 subgoal):\n 1. \\<And>s vl s1.\n       \\<lbrakk>reachNT s; reach s1; \\<Delta> s vl s1 vl1; validFrom s tr;\n        never T tr; V tr = vl\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tr1.\n                            validFrom s1 tr1 \\<and>\n                            O tr1 = O tr \\<and> V tr1 = vl1", "hence \"(vl \\<noteq> [] \\<and> exit s (hd vl)) \\<or>\n             iaction \\<Delta> s vl s1 vl1 \\<or>\n             (reaction \\<Delta> s vl s1 vl1 \\<and> \\<not> iaction \\<Delta> s vl s1 vl1)\"\n      (is \"?exit \\<or> ?iact \\<or> ?react \\<and> _\")"], ["proof (prove)\nusing this:\n  reachNT s\n  reach s1\n  \\<Delta> s vl s1 vl1\n  validFrom s tr\n  never T tr\n  V tr = vl\n\ngoal (1 subgoal):\n 1. vl \\<noteq> [] \\<and> exit s (hd vl) \\<or>\n    iaction \\<Delta> s vl s1 vl1 \\<or>\n    reaction \\<Delta> s vl s1 vl1 \\<and> \\<not> iaction \\<Delta> s vl s1 vl1", "using unwind"], ["proof (prove)\nusing this:\n  reachNT s\n  reach s1\n  \\<Delta> s vl s1 vl1\n  validFrom s tr\n  never T tr\n  V tr = vl\n  unwind \\<Delta>\n\ngoal (1 subgoal):\n 1. vl \\<noteq> [] \\<and> exit s (hd vl) \\<or>\n    iaction \\<Delta> s vl s1 vl1 \\<or>\n    reaction \\<Delta> s vl s1 vl1 \\<and> \\<not> iaction \\<Delta> s vl s1 vl1", "unfolding unwind_def"], ["proof (prove)\nusing this:\n  reachNT s\n  reach s1\n  \\<Delta> s vl s1 vl1\n  validFrom s tr\n  never T tr\n  V tr = vl\n  \\<forall>s vl s1 vl1.\n     reachNT s \\<and> reach s1 \\<and> \\<Delta> s vl s1 vl1 \\<longrightarrow>\n     vl \\<noteq> [] \\<and> exit s (hd vl) \\<or>\n     iaction \\<Delta> s vl s1 vl1 \\<or>\n     (vl \\<noteq> [] \\<or> vl1 = []) \\<and> reaction \\<Delta> s vl s1 vl1\n\ngoal (1 subgoal):\n 1. vl \\<noteq> [] \\<and> exit s (hd vl) \\<or>\n    iaction \\<Delta> s vl s1 vl1 \\<or>\n    reaction \\<Delta> s vl s1 vl1 \\<and> \\<not> iaction \\<Delta> s vl s1 vl1", "by metis"], ["proof (state)\nthis:\n  vl \\<noteq> [] \\<and> exit s (hd vl) \\<or>\n  iaction \\<Delta> s vl s1 vl1 \\<or>\n  reaction \\<Delta> s vl s1 vl1 \\<and> \\<not> iaction \\<Delta> s vl s1 vl1\n\ngoal (1 subgoal):\n 1. \\<And>s vl s1.\n       \\<lbrakk>reachNT s; reach s1; \\<Delta> s vl s1 vl1; validFrom s tr;\n        never T tr; V tr = vl\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tr1.\n                            validFrom s1 tr1 \\<and>\n                            O tr1 = O tr \\<and> V tr1 = vl1", "thus \"\\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1\""], ["proof (prove)\nusing this:\n  vl \\<noteq> [] \\<and> exit s (hd vl) \\<or>\n  iaction \\<Delta> s vl s1 vl1 \\<or>\n  reaction \\<Delta> s vl s1 vl1 \\<and> \\<not> iaction \\<Delta> s vl s1 vl1\n\ngoal (1 subgoal):\n 1. \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "proof safe"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>vl \\<noteq> []; exit s (hd vl)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tr1.\n                         validFrom s1 tr1 \\<and>\n                         O tr1 = O tr \\<and> V tr1 = vl1\n 2. iaction \\<Delta> s vl s1 vl1 \\<Longrightarrow>\n    \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1\n 3. \\<lbrakk>reaction \\<Delta> s vl s1 vl1;\n     \\<not> iaction \\<Delta> s vl s1 vl1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tr1.\n                         validFrom s1 tr1 \\<and>\n                         O tr1 = O tr \\<and> V tr1 = vl1", "assume \"vl \\<noteq> []\" and \"exit s (hd vl)\""], ["proof (state)\nthis:\n  vl \\<noteq> []\n  exit s (hd vl)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>vl \\<noteq> []; exit s (hd vl)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tr1.\n                         validFrom s1 tr1 \\<and>\n                         O tr1 = O tr \\<and> V tr1 = vl1\n 2. iaction \\<Delta> s vl s1 vl1 \\<Longrightarrow>\n    \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1\n 3. \\<lbrakk>reaction \\<Delta> s vl s1 vl1;\n     \\<not> iaction \\<Delta> s vl s1 vl1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tr1.\n                         validFrom s1 tr1 \\<and>\n                         O tr1 = O tr \\<and> V tr1 = vl1", "hence False"], ["proof (prove)\nusing this:\n  vl \\<noteq> []\n  exit s (hd vl)\n\ngoal (1 subgoal):\n 1. False", "using v V exit_validFrom NT"], ["proof (prove)\nusing this:\n  vl \\<noteq> []\n  exit s (hd vl)\n  validFrom s tr\n  V tr = vl\n  \\<lbrakk>?vl \\<noteq> []; exit ?s (hd ?vl); validFrom ?s ?tr; V ?tr = ?vl;\n   never T ?tr\\<rbrakk>\n  \\<Longrightarrow> False\n  never T tr\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<lbrakk>vl \\<noteq> []; exit s (hd vl)\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tr1.\n                         validFrom s1 tr1 \\<and>\n                         O tr1 = O tr \\<and> V tr1 = vl1\n 2. iaction \\<Delta> s vl s1 vl1 \\<Longrightarrow>\n    \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1\n 3. \\<lbrakk>reaction \\<Delta> s vl s1 vl1;\n     \\<not> iaction \\<Delta> s vl s1 vl1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tr1.\n                         validFrom s1 tr1 \\<and>\n                         O tr1 = O tr \\<and> V tr1 = vl1", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "by auto"], ["proof (state)\nthis:\n  \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1\n\ngoal (2 subgoals):\n 1. iaction \\<Delta> s vl s1 vl1 \\<Longrightarrow>\n    \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1\n 2. \\<lbrakk>reaction \\<Delta> s vl s1 vl1;\n     \\<not> iaction \\<Delta> s vl s1 vl1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tr1.\n                         validFrom s1 tr1 \\<and>\n                         O tr1 = O tr \\<and> V tr1 = vl1", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. iaction \\<Delta> s vl s1 vl1 \\<Longrightarrow>\n    \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1\n 2. \\<lbrakk>reaction \\<Delta> s vl s1 vl1;\n     \\<not> iaction \\<Delta> s vl s1 vl1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tr1.\n                         validFrom s1 tr1 \\<and>\n                         O tr1 = O tr \\<and> V tr1 = vl1", "assume ?iact"], ["proof (state)\nthis:\n  iaction \\<Delta> s vl s1 vl1\n\ngoal (2 subgoals):\n 1. iaction \\<Delta> s vl s1 vl1 \\<Longrightarrow>\n    \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1\n 2. \\<lbrakk>reaction \\<Delta> s vl s1 vl1;\n     \\<not> iaction \\<Delta> s vl s1 vl1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tr1.\n                         validFrom s1 tr1 \\<and>\n                         O tr1 = O tr \\<and> V tr1 = vl1", "thus ?thesis"], ["proof (prove)\nusing this:\n  iaction \\<Delta> s vl s1 vl1\n\ngoal (1 subgoal):\n 1. \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "unfolding iaction_def Let_def"], ["proof (prove)\nusing this:\n  \\<exists>a1 ou1 s1' vl1'.\n     validTrans (Trans s1 a1 ou1 s1') \\<and>\n     \\<phi> (Trans s1 a1 ou1 s1') \\<and>\n     consume (Trans s1 a1 ou1 s1') vl1 vl1' \\<and>\n     \\<not> \\<gamma> (Trans s1 a1 ou1 s1') \\<and> \\<Delta> s vl s1' vl1'\n\ngoal (1 subgoal):\n 1. \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "proof safe"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a1 ou1 s1' vl1'.\n       \\<lbrakk>validTrans (Trans s1 a1 ou1 s1');\n        \\<phi> (Trans s1 a1 ou1 s1');\n        consume (Trans s1 a1 ou1 s1') vl1 vl1';\n        \\<not> \\<gamma> (Trans s1 a1 ou1 s1');\n        \\<Delta> s vl s1' vl1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tr1.\n                            validFrom s1 tr1 \\<and>\n                            O tr1 = O tr \\<and> V tr1 = vl1", "fix a1 :: 'act and ou1 :: 'out and s1' :: 'state and vl1'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a1 ou1 s1' vl1'.\n       \\<lbrakk>validTrans (Trans s1 a1 ou1 s1');\n        \\<phi> (Trans s1 a1 ou1 s1');\n        consume (Trans s1 a1 ou1 s1') vl1 vl1';\n        \\<not> \\<gamma> (Trans s1 a1 ou1 s1');\n        \\<Delta> s vl s1' vl1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tr1.\n                            validFrom s1 tr1 \\<and>\n                            O tr1 = O tr \\<and> V tr1 = vl1", "let ?trn1 = \"Trans s1 a1 ou1 s1'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a1 ou1 s1' vl1'.\n       \\<lbrakk>validTrans (Trans s1 a1 ou1 s1');\n        \\<phi> (Trans s1 a1 ou1 s1');\n        consume (Trans s1 a1 ou1 s1') vl1 vl1';\n        \\<not> \\<gamma> (Trans s1 a1 ou1 s1');\n        \\<Delta> s vl s1' vl1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tr1.\n                            validFrom s1 tr1 \\<and>\n                            O tr1 = O tr \\<and> V tr1 = vl1", "assume vtrans1: \"validTrans ?trn1\" and \\<phi>1: \"\\<phi> ?trn1\"\n          and c: \"consume ?trn1 vl1 vl1'\" and \\<gamma>: \"\\<not> \\<gamma> ?trn1\" and \\<Delta>: \"\\<Delta> s vl s1' vl1'\""], ["proof (state)\nthis:\n  validTrans (Trans s1 a1 ou1 s1')\n  \\<phi> (Trans s1 a1 ou1 s1')\n  consume (Trans s1 a1 ou1 s1') vl1 vl1'\n  \\<not> \\<gamma> (Trans s1 a1 ou1 s1')\n  \\<Delta> s vl s1' vl1'\n\ngoal (1 subgoal):\n 1. \\<And>a1 ou1 s1' vl1'.\n       \\<lbrakk>validTrans (Trans s1 a1 ou1 s1');\n        \\<phi> (Trans s1 a1 ou1 s1');\n        consume (Trans s1 a1 ou1 s1') vl1 vl1';\n        \\<not> \\<gamma> (Trans s1 a1 ou1 s1');\n        \\<Delta> s vl s1' vl1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tr1.\n                            validFrom s1 tr1 \\<and>\n                            O tr1 = O tr \\<and> V tr1 = vl1", "from \\<phi>1 c"], ["proof (chain)\npicking this:\n  \\<phi> (Trans s1 a1 ou1 s1')\n  consume (Trans s1 a1 ou1 s1') vl1 vl1'", "obtain v1 where vl1: \"vl1 = v1 # vl1'\" and f1: \"f ?trn1 = v1\""], ["proof (prove)\nusing this:\n  \\<phi> (Trans s1 a1 ou1 s1')\n  consume (Trans s1 a1 ou1 s1') vl1 vl1'\n\ngoal (1 subgoal):\n 1. (\\<And>v1.\n        \\<lbrakk>vl1 = v1 # vl1'; f (Trans s1 a1 ou1 s1') = v1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding consume_def"], ["proof (prove)\nusing this:\n  \\<phi> (Trans s1 a1 ou1 s1')\n  if \\<phi> (Trans s1 a1 ou1 s1')\n  then vl1 \\<noteq> [] \\<and>\n       f (Trans s1 a1 ou1 s1') = hd vl1 \\<and> vl1' = tl vl1\n  else vl1' = vl1\n\ngoal (1 subgoal):\n 1. (\\<And>v1.\n        \\<lbrakk>vl1 = v1 # vl1'; f (Trans s1 a1 ou1 s1') = v1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases vl1) auto"], ["proof (state)\nthis:\n  vl1 = v1 # vl1'\n  f (Trans s1 a1 ou1 s1') = v1\n\ngoal (1 subgoal):\n 1. \\<And>a1 ou1 s1' vl1'.\n       \\<lbrakk>validTrans (Trans s1 a1 ou1 s1');\n        \\<phi> (Trans s1 a1 ou1 s1');\n        consume (Trans s1 a1 ou1 s1') vl1 vl1';\n        \\<not> \\<gamma> (Trans s1 a1 ou1 s1');\n        \\<Delta> s vl s1' vl1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tr1.\n                            validFrom s1 tr1 \\<and>\n                            O tr1 = O tr \\<and> V tr1 = vl1", "have rs1': \"reach s1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach s1'", "using rs1 vtrans1"], ["proof (prove)\nusing this:\n  reach s1\n  validTrans (Trans s1 a1 ou1 s1')\n\ngoal (1 subgoal):\n 1. reach s1'", "by (auto intro: reach_PairI)"], ["proof (state)\nthis:\n  reach s1'\n\ngoal (1 subgoal):\n 1. \\<And>a1 ou1 s1' vl1'.\n       \\<lbrakk>validTrans (Trans s1 a1 ou1 s1');\n        \\<phi> (Trans s1 a1 ou1 s1');\n        consume (Trans s1 a1 ou1 s1') vl1 vl1';\n        \\<not> \\<gamma> (Trans s1 a1 ou1 s1');\n        \\<Delta> s vl s1' vl1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tr1.\n                            validFrom s1 tr1 \\<and>\n                            O tr1 = O tr \\<and> V tr1 = vl1", "obtain tr1 where v1: \"validFrom s1' tr1\" and O: \"O tr1 = O tr\" and V: \"V tr1 = vl1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tr1.\n        \\<lbrakk>validFrom s1' tr1; O tr1 = O tr; V tr1 = vl1'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 1[of tr vl1'] rs rs1' \\<Delta> v NT V"], ["proof (prove)\nusing this:\n  length tr + length vl1' < length tr + length vl1 \\<Longrightarrow>\n  \\<forall>s vl s1.\n     reachNT s \\<and>\n     reach s1 \\<and>\n     \\<Delta> s vl s1 vl1' \\<and>\n     validFrom s tr \\<and> never T tr \\<and> V tr = vl \\<longrightarrow>\n     (\\<exists>tr1.\n         validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1')\n  reachNT s\n  reach s1'\n  \\<Delta> s vl s1' vl1'\n  validFrom s tr\n  never T tr\n  V tr = vl\n\ngoal (1 subgoal):\n 1. (\\<And>tr1.\n        \\<lbrakk>validFrom s1' tr1; O tr1 = O tr; V tr1 = vl1'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding vl1"], ["proof (prove)\nusing this:\n  length tr + length vl1' < length tr + length (v1 # vl1') \\<Longrightarrow>\n  \\<forall>s vl s1.\n     reachNT s \\<and>\n     reach s1 \\<and>\n     \\<Delta> s vl s1 vl1' \\<and>\n     validFrom s tr \\<and> never T tr \\<and> V tr = vl \\<longrightarrow>\n     (\\<exists>tr1.\n         validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1')\n  reachNT s\n  reach s1'\n  \\<Delta> s vl s1' vl1'\n  validFrom s tr\n  never T tr\n  V tr = vl\n\ngoal (1 subgoal):\n 1. (\\<And>tr1.\n        \\<lbrakk>validFrom s1' tr1; O tr1 = O tr; V tr1 = vl1'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  validFrom s1' tr1\n  O tr1 = O tr\n  V tr1 = vl1'\n\ngoal (1 subgoal):\n 1. \\<And>a1 ou1 s1' vl1'.\n       \\<lbrakk>validTrans (Trans s1 a1 ou1 s1');\n        \\<phi> (Trans s1 a1 ou1 s1');\n        consume (Trans s1 a1 ou1 s1') vl1 vl1';\n        \\<not> \\<gamma> (Trans s1 a1 ou1 s1');\n        \\<Delta> s vl s1' vl1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tr1.\n                            validFrom s1 tr1 \\<and>\n                            O tr1 = O tr \\<and> V tr1 = vl1", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "using vtrans1 v1 O \\<gamma> V \\<phi>1 f1"], ["proof (prove)\nusing this:\n  validTrans (Trans s1 a1 ou1 s1')\n  validFrom s1' tr1\n  O tr1 = O tr\n  \\<not> \\<gamma> (Trans s1 a1 ou1 s1')\n  V tr1 = vl1'\n  \\<phi> (Trans s1 a1 ou1 s1')\n  f (Trans s1 a1 ou1 s1') = v1\n\ngoal (1 subgoal):\n 1. \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "unfolding vl1"], ["proof (prove)\nusing this:\n  validTrans (Trans s1 a1 ou1 s1')\n  validFrom s1' tr1\n  O tr1 = O tr\n  \\<not> \\<gamma> (Trans s1 a1 ou1 s1')\n  V tr1 = vl1'\n  \\<phi> (Trans s1 a1 ou1 s1')\n  f (Trans s1 a1 ou1 s1') = v1\n\ngoal (1 subgoal):\n 1. \\<exists>tr1.\n       validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = v1 # vl1'", "by (intro exI[of _ \"?trn1 # tr1\"]) auto"], ["proof (state)\nthis:\n  \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>reaction \\<Delta> s vl s1 vl1;\n     \\<not> iaction \\<Delta> s vl s1 vl1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tr1.\n                         validFrom s1 tr1 \\<and>\n                         O tr1 = O tr \\<and> V tr1 = vl1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>reaction \\<Delta> s vl s1 vl1;\n     \\<not> iaction \\<Delta> s vl s1 vl1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tr1.\n                         validFrom s1 tr1 \\<and>\n                         O tr1 = O tr \\<and> V tr1 = vl1", "assume react: ?react and iact: \"\\<not> ?iact\""], ["proof (state)\nthis:\n  reaction \\<Delta> s vl s1 vl1\n  \\<not> iaction \\<Delta> s vl s1 vl1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>reaction \\<Delta> s vl s1 vl1;\n     \\<not> iaction \\<Delta> s vl s1 vl1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tr1.\n                         validFrom s1 tr1 \\<and>\n                         O tr1 = O tr \\<and> V tr1 = vl1", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "proof(cases tr)"], ["proof (state)\ngoal (2 subgoals):\n 1. tr = [] \\<Longrightarrow>\n    \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1\n 2. \\<And>a list.\n       tr = a # list \\<Longrightarrow>\n       \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "case Nil"], ["proof (state)\nthis:\n  tr = []\n\ngoal (2 subgoals):\n 1. tr = [] \\<Longrightarrow>\n    \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1\n 2. \\<And>a list.\n       tr = a # list \\<Longrightarrow>\n       \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "note tr = Nil"], ["proof (state)\nthis:\n  tr = []\n\ngoal (2 subgoals):\n 1. tr = [] \\<Longrightarrow>\n    \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1\n 2. \\<And>a list.\n       tr = a # list \\<Longrightarrow>\n       \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "hence vl: \"vl = []\""], ["proof (prove)\nusing this:\n  tr = []\n\ngoal (1 subgoal):\n 1. vl = []", "using V"], ["proof (prove)\nusing this:\n  tr = []\n  V tr = vl\n\ngoal (1 subgoal):\n 1. vl = []", "by simp"], ["proof (state)\nthis:\n  vl = []\n\ngoal (2 subgoals):\n 1. tr = [] \\<Longrightarrow>\n    \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1\n 2. \\<And>a list.\n       tr = a # list \\<Longrightarrow>\n       \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "proof(cases vl1)"], ["proof (state)\ngoal (2 subgoals):\n 1. vl1 = [] \\<Longrightarrow>\n    \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1\n 2. \\<And>a list.\n       vl1 = a # list \\<Longrightarrow>\n       \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "case Nil"], ["proof (state)\nthis:\n  vl1 = []\n\ngoal (2 subgoals):\n 1. vl1 = [] \\<Longrightarrow>\n    \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1\n 2. \\<And>a list.\n       vl1 = a # list \\<Longrightarrow>\n       \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "note vl1 = Nil"], ["proof (state)\nthis:\n  vl1 = []\n\ngoal (2 subgoals):\n 1. vl1 = [] \\<Longrightarrow>\n    \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1\n 2. \\<And>a list.\n       vl1 = a # list \\<Longrightarrow>\n       \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "using 1[of tr vl1] \\<Delta> V NT V"], ["proof (prove)\nusing this:\n  length tr + length vl1 < length tr + length vl1 \\<Longrightarrow>\n  \\<forall>s vl s1.\n     reachNT s \\<and>\n     reach s1 \\<and>\n     \\<Delta> s vl s1 vl1 \\<and>\n     validFrom s tr \\<and> never T tr \\<and> V tr = vl \\<longrightarrow>\n     (\\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1)\n  \\<Delta> s vl s1 vl1\n  V tr = vl\n  never T tr\n  V tr = vl\n\ngoal (1 subgoal):\n 1. \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "unfolding tr vl1"], ["proof (prove)\nusing this:\n  length [] + length [] < length [] + length [] \\<Longrightarrow>\n  \\<forall>s vl s1.\n     reachNT s \\<and>\n     reach s1 \\<and>\n     \\<Delta> s vl s1 [] \\<and>\n     validFrom s [] \\<and> never T [] \\<and> V [] = vl \\<longrightarrow>\n     (\\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O [] \\<and> V tr1 = [])\n  \\<Delta> s vl s1 []\n  V [] = vl\n  never T []\n  V [] = vl\n\ngoal (1 subgoal):\n 1. \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O [] \\<and> V tr1 = []", "by auto"], ["proof (state)\nthis:\n  \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       vl1 = a # list \\<Longrightarrow>\n       \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       vl1 = a # list \\<Longrightarrow>\n       \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "case Cons"], ["proof (state)\nthis:\n  vl1 = a_ # list_\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       vl1 = a # list \\<Longrightarrow>\n       \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "hence False"], ["proof (prove)\nusing this:\n  vl1 = a_ # list_\n\ngoal (1 subgoal):\n 1. False", "using vl unwind rs rs1 \\<Delta> iact"], ["proof (prove)\nusing this:\n  vl1 = a_ # list_\n  vl = []\n  unwind \\<Delta>\n  reachNT s\n  reach s1\n  \\<Delta> s vl s1 vl1\n  \\<not> iaction \\<Delta> s vl s1 vl1\n\ngoal (1 subgoal):\n 1. False", "unfolding unwind_def"], ["proof (prove)\nusing this:\n  vl1 = a_ # list_\n  vl = []\n  \\<forall>s vl s1 vl1.\n     reachNT s \\<and> reach s1 \\<and> \\<Delta> s vl s1 vl1 \\<longrightarrow>\n     vl \\<noteq> [] \\<and> exit s (hd vl) \\<or>\n     iaction \\<Delta> s vl s1 vl1 \\<or>\n     (vl \\<noteq> [] \\<or> vl1 = []) \\<and> reaction \\<Delta> s vl s1 vl1\n  reachNT s\n  reach s1\n  \\<Delta> s vl s1 vl1\n  \\<not> iaction \\<Delta> s vl s1 vl1\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       vl1 = a # list \\<Longrightarrow>\n       \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "by auto"], ["proof (state)\nthis:\n  \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       tr = a # list \\<Longrightarrow>\n       \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       tr = a # list \\<Longrightarrow>\n       \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "case (Cons trn tr')"], ["proof (state)\nthis:\n  tr = trn # tr'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       tr = a # list \\<Longrightarrow>\n       \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "note tr = Cons"], ["proof (state)\nthis:\n  tr = trn # tr'\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       tr = a # list \\<Longrightarrow>\n       \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "proof(cases trn)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       trn = Trans x1 x2 x3 x4 \\<Longrightarrow>\n       \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "case (Trans ss a ou s')"], ["proof (state)\nthis:\n  trn = Trans ss a ou s'\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       trn = Trans x1 x2 x3 x4 \\<Longrightarrow>\n       \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "note trn = Trans"], ["proof (state)\nthis:\n  trn = Trans ss a ou s'\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       trn = Trans x1 x2 x3 x4 \\<Longrightarrow>\n       \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "let ?trn = \"Trans s a ou s'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       trn = Trans x1 x2 x3 x4 \\<Longrightarrow>\n       \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "have ss: \"ss = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ss = s", "using trn v"], ["proof (prove)\nusing this:\n  trn = Trans ss a ou s'\n  validFrom s tr\n\ngoal (1 subgoal):\n 1. ss = s", "unfolding tr validFrom_def"], ["proof (prove)\nusing this:\n  trn = Trans ss a ou s'\n  trn # tr' = [] \\<or> valid (trn # tr') \\<and> srcOf (hd (trn # tr')) = s\n\ngoal (1 subgoal):\n 1. ss = s", "by auto"], ["proof (state)\nthis:\n  ss = s\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       trn = Trans x1 x2 x3 x4 \\<Longrightarrow>\n       \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "have Ta: \"\\<not> T ?trn\" and s: \"s = srcOf trn\" and vtrans: \"validTrans ?trn\"\n            and v': \"validFrom s' tr'\" and NT': \"never T tr'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> T (Trans s a ou s') &&& s = srcOf trn) &&&\n    validTrans (Trans s a ou s') &&& validFrom s' tr' &&& never T tr'", "using v NT V"], ["proof (prove)\nusing this:\n  validFrom s tr\n  never T tr\n  V tr = vl\n\ngoal (1 subgoal):\n 1. (\\<not> T (Trans s a ou s') &&& s = srcOf trn) &&&\n    validTrans (Trans s a ou s') &&& validFrom s' tr' &&& never T tr'", "unfolding tr validFrom_def trn"], ["proof (prove)\nusing this:\n  Trans ss a ou s' # tr' = [] \\<or>\n  valid (Trans ss a ou s' # tr') \\<and>\n  srcOf (hd (Trans ss a ou s' # tr')) = s\n  never T (Trans ss a ou s' # tr')\n  V (Trans ss a ou s' # tr') = vl\n\ngoal (1 subgoal):\n 1. (\\<not> T (Trans s a ou s') &&& s = srcOf (Trans ss a ou s')) &&&\n    validTrans (Trans s a ou s') &&&\n    tr' = [] \\<or> valid tr' \\<and> srcOf (hd tr') = s' &&& never T tr'", "by auto"], ["proof (state)\nthis:\n  \\<not> T (Trans s a ou s')\n  s = srcOf trn\n  validTrans (Trans s a ou s')\n  validFrom s' tr'\n  never T tr'\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       trn = Trans x1 x2 x3 x4 \\<Longrightarrow>\n       \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "have rs': \"reachNT s'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachNT s'", "using rs vtrans Ta"], ["proof (prove)\nusing this:\n  reachNT s\n  validTrans (Trans s a ou s')\n  \\<not> T (Trans s a ou s')\n\ngoal (1 subgoal):\n 1. reachNT s'", "by (auto intro: reachNT_PairI)"], ["proof (state)\nthis:\n  reachNT s'\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       trn = Trans x1 x2 x3 x4 \\<Longrightarrow>\n       \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "{"], ["proof (state)\nthis:\n  reachNT s'\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       trn = Trans x1 x2 x3 x4 \\<Longrightarrow>\n       \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "assume \"\\<phi> ?trn\""], ["proof (state)\nthis:\n  \\<phi> (Trans s a ou s')\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       trn = Trans x1 x2 x3 x4 \\<Longrightarrow>\n       \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "hence \"vl \\<noteq> [] \\<and> f ?trn = hd vl\""], ["proof (prove)\nusing this:\n  \\<phi> (Trans s a ou s')\n\ngoal (1 subgoal):\n 1. vl \\<noteq> [] \\<and> f (Trans s a ou s') = hd vl", "using V"], ["proof (prove)\nusing this:\n  \\<phi> (Trans s a ou s')\n  V tr = vl\n\ngoal (1 subgoal):\n 1. vl \\<noteq> [] \\<and> f (Trans s a ou s') = hd vl", "unfolding tr trn ss"], ["proof (prove)\nusing this:\n  \\<phi> (Trans s a ou s')\n  V (Trans s a ou s' # tr') = vl\n\ngoal (1 subgoal):\n 1. vl \\<noteq> [] \\<and> f (Trans s a ou s') = hd vl", "by auto"], ["proof (state)\nthis:\n  vl \\<noteq> [] \\<and> f (Trans s a ou s') = hd vl\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       trn = Trans x1 x2 x3 x4 \\<Longrightarrow>\n       \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "}"], ["proof (state)\nthis:\n  \\<phi> (Trans s a ou s') \\<Longrightarrow>\n  vl \\<noteq> [] \\<and> f (Trans s a ou s') = hd vl\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       trn = Trans x1 x2 x3 x4 \\<Longrightarrow>\n       \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "then"], ["proof (chain)\npicking this:\n  \\<phi> (Trans s a ou s') \\<Longrightarrow>\n  vl \\<noteq> [] \\<and> f (Trans s a ou s') = hd vl", "obtain vl' where c: \"consume ?trn vl vl'\""], ["proof (prove)\nusing this:\n  \\<phi> (Trans s a ou s') \\<Longrightarrow>\n  vl \\<noteq> [] \\<and> f (Trans s a ou s') = hd vl\n\ngoal (1 subgoal):\n 1. (\\<And>vl'.\n        consume (Trans s a ou s') vl vl' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using ex_consume_\\<phi> ex_consume_NO"], ["proof (prove)\nusing this:\n  \\<phi> (Trans s a ou s') \\<Longrightarrow>\n  vl \\<noteq> [] \\<and> f (Trans s a ou s') = hd vl\n  \\<lbrakk>\\<not> \\<phi> ?trn;\n   \\<And>vl'. consume ?trn ?vl vl' \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n  \\<lbrakk>?vl \\<noteq> []; f ?trn = hd ?vl;\n   \\<And>vl'. consume ?trn ?vl vl' \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>vl'.\n        consume (Trans s a ou s') vl vl' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  consume (Trans s a ou s') vl vl'\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       trn = Trans x1 x2 x3 x4 \\<Longrightarrow>\n       \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "have V': \"V tr' = vl'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V tr' = vl'", "using V c"], ["proof (prove)\nusing this:\n  V tr = vl\n  consume (Trans s a ou s') vl vl'\n\ngoal (1 subgoal):\n 1. V tr' = vl'", "unfolding tr trn ss consume_def"], ["proof (prove)\nusing this:\n  V (Trans s a ou s' # tr') = vl\n  if \\<phi> (Trans s a ou s')\n  then vl \\<noteq> [] \\<and> f (Trans s a ou s') = hd vl \\<and> vl' = tl vl\n  else vl' = vl\n\ngoal (1 subgoal):\n 1. V tr' = vl'", "by (cases \"\\<phi> ?trn\") (simp_all, metis list.sel(2-3))"], ["proof (state)\nthis:\n  V tr' = vl'\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       trn = Trans x1 x2 x3 x4 \\<Longrightarrow>\n       \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "have \"match \\<Delta> s s1 vl1 a ou s' vl' \\<or> ignore \\<Delta> s s1 vl1 a ou s' vl'\" (is \"?match \\<or> ?ignore\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. match \\<Delta> s s1 vl1 a ou s' vl' \\<or>\n    ignore \\<Delta> s s1 vl1 a ou s' vl'", "using react"], ["proof (prove)\nusing this:\n  reaction \\<Delta> s vl s1 vl1\n\ngoal (1 subgoal):\n 1. match \\<Delta> s s1 vl1 a ou s' vl' \\<or>\n    ignore \\<Delta> s s1 vl1 a ou s' vl'", "unfolding reaction_def"], ["proof (prove)\nusing this:\n  \\<forall>a ou s' vl'.\n     let trn = Trans s a ou s'\n     in validTrans trn \\<and>\n        \\<not> T trn \\<and> consume trn vl vl' \\<longrightarrow>\n        match \\<Delta> s s1 vl1 a ou s' vl' \\<or>\n        ignore \\<Delta> s s1 vl1 a ou s' vl'\n\ngoal (1 subgoal):\n 1. match \\<Delta> s s1 vl1 a ou s' vl' \\<or>\n    ignore \\<Delta> s s1 vl1 a ou s' vl'", "using vtrans Ta c"], ["proof (prove)\nusing this:\n  \\<forall>a ou s' vl'.\n     let trn = Trans s a ou s'\n     in validTrans trn \\<and>\n        \\<not> T trn \\<and> consume trn vl vl' \\<longrightarrow>\n        match \\<Delta> s s1 vl1 a ou s' vl' \\<or>\n        ignore \\<Delta> s s1 vl1 a ou s' vl'\n  validTrans (Trans s a ou s')\n  \\<not> T (Trans s a ou s')\n  consume (Trans s a ou s') vl vl'\n\ngoal (1 subgoal):\n 1. match \\<Delta> s s1 vl1 a ou s' vl' \\<or>\n    ignore \\<Delta> s s1 vl1 a ou s' vl'", "by auto"], ["proof (state)\nthis:\n  match \\<Delta> s s1 vl1 a ou s' vl' \\<or>\n  ignore \\<Delta> s s1 vl1 a ou s' vl'\n\ngoal (1 subgoal):\n 1. \\<And>x1 x2 x3 x4.\n       trn = Trans x1 x2 x3 x4 \\<Longrightarrow>\n       \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "thus ?thesis"], ["proof (prove)\nusing this:\n  match \\<Delta> s s1 vl1 a ou s' vl' \\<or>\n  ignore \\<Delta> s s1 vl1 a ou s' vl'\n\ngoal (1 subgoal):\n 1. \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "proof safe"], ["proof (state)\ngoal (2 subgoals):\n 1. match \\<Delta> s s1 vl1 a ou s' vl' \\<Longrightarrow>\n    \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1\n 2. ignore \\<Delta> s s1 vl1 a ou s' vl' \\<Longrightarrow>\n    \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "assume ?match"], ["proof (state)\nthis:\n  match \\<Delta> s s1 vl1 a ou s' vl'\n\ngoal (2 subgoals):\n 1. match \\<Delta> s s1 vl1 a ou s' vl' \\<Longrightarrow>\n    \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1\n 2. ignore \\<Delta> s s1 vl1 a ou s' vl' \\<Longrightarrow>\n    \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "thus ?thesis"], ["proof (prove)\nusing this:\n  match \\<Delta> s s1 vl1 a ou s' vl'\n\ngoal (1 subgoal):\n 1. \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "unfolding match_def Let_def"], ["proof (prove)\nusing this:\n  \\<exists>a1 ou1 s1' vl1'.\n     validTrans (Trans s1 a1 ou1 s1') \\<and>\n     consume (Trans s1 a1 ou1 s1') vl1 vl1' \\<and>\n     \\<gamma> (Trans s a ou s') = \\<gamma> (Trans s1 a1 ou1 s1') \\<and>\n     (\\<gamma> (Trans s a ou s') \\<longrightarrow>\n      g (Trans s a ou s') = g (Trans s1 a1 ou1 s1')) \\<and>\n     \\<Delta> s' vl' s1' vl1'\n\ngoal (1 subgoal):\n 1. \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "proof (elim exE conjE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a1 ou1 s1' vl1'.\n       \\<lbrakk>validTrans (Trans s1 a1 ou1 s1');\n        consume (Trans s1 a1 ou1 s1') vl1 vl1';\n        \\<gamma> (Trans s a ou s') = \\<gamma> (Trans s1 a1 ou1 s1');\n        \\<gamma> (Trans s a ou s') \\<longrightarrow>\n        g (Trans s a ou s') = g (Trans s1 a1 ou1 s1');\n        \\<Delta> s' vl' s1' vl1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tr1.\n                            validFrom s1 tr1 \\<and>\n                            O tr1 = O tr \\<and> V tr1 = vl1", "fix a1 :: 'act and ou1 :: 'out and s1' :: 'state and vl1'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a1 ou1 s1' vl1'.\n       \\<lbrakk>validTrans (Trans s1 a1 ou1 s1');\n        consume (Trans s1 a1 ou1 s1') vl1 vl1';\n        \\<gamma> (Trans s a ou s') = \\<gamma> (Trans s1 a1 ou1 s1');\n        \\<gamma> (Trans s a ou s') \\<longrightarrow>\n        g (Trans s a ou s') = g (Trans s1 a1 ou1 s1');\n        \\<Delta> s' vl' s1' vl1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tr1.\n                            validFrom s1 tr1 \\<and>\n                            O tr1 = O tr \\<and> V tr1 = vl1", "let ?trn1 = \"Trans s1 a1 ou1 s1'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a1 ou1 s1' vl1'.\n       \\<lbrakk>validTrans (Trans s1 a1 ou1 s1');\n        consume (Trans s1 a1 ou1 s1') vl1 vl1';\n        \\<gamma> (Trans s a ou s') = \\<gamma> (Trans s1 a1 ou1 s1');\n        \\<gamma> (Trans s a ou s') \\<longrightarrow>\n        g (Trans s a ou s') = g (Trans s1 a1 ou1 s1');\n        \\<Delta> s' vl' s1' vl1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tr1.\n                            validFrom s1 tr1 \\<and>\n                            O tr1 = O tr \\<and> V tr1 = vl1", "assume \\<Delta>: \"\\<Delta> s' vl' s1' vl1'\" and vtrans1: \"validTrans ?trn1\"\n                and c1: \"consume ?trn1 vl1 vl1'\" and \\<gamma>: \"\\<gamma> ?trn = \\<gamma> ?trn1\"\n                and g: \"\\<gamma> ?trn \\<longrightarrow> g ?trn = g ?trn1\""], ["proof (state)\nthis:\n  \\<Delta> s' vl' s1' vl1'\n  validTrans (Trans s1 a1 ou1 s1')\n  consume (Trans s1 a1 ou1 s1') vl1 vl1'\n  \\<gamma> (Trans s a ou s') = \\<gamma> (Trans s1 a1 ou1 s1')\n  \\<gamma> (Trans s a ou s') \\<longrightarrow>\n  g (Trans s a ou s') = g (Trans s1 a1 ou1 s1')\n\ngoal (1 subgoal):\n 1. \\<And>a1 ou1 s1' vl1'.\n       \\<lbrakk>validTrans (Trans s1 a1 ou1 s1');\n        consume (Trans s1 a1 ou1 s1') vl1 vl1';\n        \\<gamma> (Trans s a ou s') = \\<gamma> (Trans s1 a1 ou1 s1');\n        \\<gamma> (Trans s a ou s') \\<longrightarrow>\n        g (Trans s a ou s') = g (Trans s1 a1 ou1 s1');\n        \\<Delta> s' vl' s1' vl1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tr1.\n                            validFrom s1 tr1 \\<and>\n                            O tr1 = O tr \\<and> V tr1 = vl1", "have rs1': \"reach s1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reach s1'", "using rs rs1 vtrans vtrans1"], ["proof (prove)\nusing this:\n  reachNT s\n  reach s1\n  validTrans (Trans s a ou s')\n  validTrans (Trans s1 a1 ou1 s1')\n\ngoal (1 subgoal):\n 1. reach s1'", "by (auto intro: reach_PairI)"], ["proof (state)\nthis:\n  reach s1'\n\ngoal (1 subgoal):\n 1. \\<And>a1 ou1 s1' vl1'.\n       \\<lbrakk>validTrans (Trans s1 a1 ou1 s1');\n        consume (Trans s1 a1 ou1 s1') vl1 vl1';\n        \\<gamma> (Trans s a ou s') = \\<gamma> (Trans s1 a1 ou1 s1');\n        \\<gamma> (Trans s a ou s') \\<longrightarrow>\n        g (Trans s a ou s') = g (Trans s1 a1 ou1 s1');\n        \\<Delta> s' vl' s1' vl1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tr1.\n                            validFrom s1 tr1 \\<and>\n                            O tr1 = O tr \\<and> V tr1 = vl1", "obtain tr1 where v1: \"validFrom s1' tr1\" and O: \"O tr1 = O tr'\" and V: \"V tr1 = vl1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tr1.\n        \\<lbrakk>validFrom s1' tr1; O tr1 = O tr'; V tr1 = vl1'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 1[of tr' vl1'] rs' rs1' \\<Delta> v' NT' V' c1"], ["proof (prove)\nusing this:\n  length tr' + length vl1' < length tr + length vl1 \\<Longrightarrow>\n  \\<forall>s vl s1.\n     reachNT s \\<and>\n     reach s1 \\<and>\n     \\<Delta> s vl s1 vl1' \\<and>\n     validFrom s tr' \\<and> never T tr' \\<and> V tr' = vl \\<longrightarrow>\n     (\\<exists>tr1.\n         validFrom s1 tr1 \\<and> O tr1 = O tr' \\<and> V tr1 = vl1')\n  reachNT s'\n  reach s1'\n  \\<Delta> s' vl' s1' vl1'\n  validFrom s' tr'\n  never T tr'\n  V tr' = vl'\n  consume (Trans s1 a1 ou1 s1') vl1 vl1'\n\ngoal (1 subgoal):\n 1. (\\<And>tr1.\n        \\<lbrakk>validFrom s1' tr1; O tr1 = O tr'; V tr1 = vl1'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding tr"], ["proof (prove)\nusing this:\n  length tr' + length vl1'\n  < length (trn # tr') + length vl1 \\<Longrightarrow>\n  \\<forall>s vl s1.\n     reachNT s \\<and>\n     reach s1 \\<and>\n     \\<Delta> s vl s1 vl1' \\<and>\n     validFrom s tr' \\<and> never T tr' \\<and> V tr' = vl \\<longrightarrow>\n     (\\<exists>tr1.\n         validFrom s1 tr1 \\<and> O tr1 = O tr' \\<and> V tr1 = vl1')\n  reachNT s'\n  reach s1'\n  \\<Delta> s' vl' s1' vl1'\n  validFrom s' tr'\n  never T tr'\n  V tr' = vl'\n  consume (Trans s1 a1 ou1 s1') vl1 vl1'\n\ngoal (1 subgoal):\n 1. (\\<And>tr1.\n        \\<lbrakk>validFrom s1' tr1; O tr1 = O tr'; V tr1 = vl1'\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  validFrom s1' tr1\n  O tr1 = O tr'\n  V tr1 = vl1'\n\ngoal (1 subgoal):\n 1. \\<And>a1 ou1 s1' vl1'.\n       \\<lbrakk>validTrans (Trans s1 a1 ou1 s1');\n        consume (Trans s1 a1 ou1 s1') vl1 vl1';\n        \\<gamma> (Trans s a ou s') = \\<gamma> (Trans s1 a1 ou1 s1');\n        \\<gamma> (Trans s a ou s') \\<longrightarrow>\n        g (Trans s a ou s') = g (Trans s1 a1 ou1 s1');\n        \\<Delta> s' vl' s1' vl1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tr1.\n                            validFrom s1 tr1 \\<and>\n                            O tr1 = O tr \\<and> V tr1 = vl1", "have \"V (?trn1 # tr1) = vl1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. V (Trans s1 a1 ou1 s1' # tr1) = vl1", "using c1 V"], ["proof (prove)\nusing this:\n  consume (Trans s1 a1 ou1 s1') vl1 vl1'\n  V tr1 = vl1'\n\ngoal (1 subgoal):\n 1. V (Trans s1 a1 ou1 s1' # tr1) = vl1", "unfolding consume_def"], ["proof (prove)\nusing this:\n  if \\<phi> (Trans s1 a1 ou1 s1')\n  then vl1 \\<noteq> [] \\<and>\n       f (Trans s1 a1 ou1 s1') = hd vl1 \\<and> vl1' = tl vl1\n  else vl1' = vl1\n  V tr1 = vl1'\n\ngoal (1 subgoal):\n 1. V (Trans s1 a1 ou1 s1' # tr1) = vl1", "by (cases \"\\<phi> ?trn1\") auto"], ["proof (state)\nthis:\n  V (Trans s1 a1 ou1 s1' # tr1) = vl1\n\ngoal (1 subgoal):\n 1. \\<And>a1 ou1 s1' vl1'.\n       \\<lbrakk>validTrans (Trans s1 a1 ou1 s1');\n        consume (Trans s1 a1 ou1 s1') vl1 vl1';\n        \\<gamma> (Trans s a ou s') = \\<gamma> (Trans s1 a1 ou1 s1');\n        \\<gamma> (Trans s a ou s') \\<longrightarrow>\n        g (Trans s a ou s') = g (Trans s1 a1 ou1 s1');\n        \\<Delta> s' vl' s1' vl1'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>tr1.\n                            validFrom s1 tr1 \\<and>\n                            O tr1 = O tr \\<and> V tr1 = vl1", "thus ?thesis"], ["proof (prove)\nusing this:\n  V (Trans s1 a1 ou1 s1' # tr1) = vl1\n\ngoal (1 subgoal):\n 1. \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "apply(intro exI[of _ \"Trans s1 a1 ou1 s1' # tr1\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. V (Trans s1 a1 ou1 s1' # tr1) = vl1 \\<Longrightarrow>\n    validFrom s1 (Trans s1 a1 ou1 s1' # tr1) \\<and>\n    O (Trans s1 a1 ou1 s1' # tr1) = O tr \\<and>\n    V (Trans s1 a1 ou1 s1' # tr1) = vl1", "using vtrans1 v1 O \\<gamma> g V"], ["proof (prove)\nusing this:\n  validTrans (Trans s1 a1 ou1 s1')\n  validFrom s1' tr1\n  O tr1 = O tr'\n  \\<gamma> (Trans s a ou s') = \\<gamma> (Trans s1 a1 ou1 s1')\n  \\<gamma> (Trans s a ou s') \\<longrightarrow>\n  g (Trans s a ou s') = g (Trans s1 a1 ou1 s1')\n  V tr1 = vl1'\n\ngoal (1 subgoal):\n 1. V (Trans s1 a1 ou1 s1' # tr1) = vl1 \\<Longrightarrow>\n    validFrom s1 (Trans s1 a1 ou1 s1' # tr1) \\<and>\n    O (Trans s1 a1 ou1 s1' # tr1) = O tr \\<and>\n    V (Trans s1 a1 ou1 s1' # tr1) = vl1", "unfolding tr trn ss"], ["proof (prove)\nusing this:\n  validTrans (Trans s1 a1 ou1 s1')\n  validFrom s1' tr1\n  O tr1 = O tr'\n  \\<gamma> (Trans s a ou s') = \\<gamma> (Trans s1 a1 ou1 s1')\n  \\<gamma> (Trans s a ou s') \\<longrightarrow>\n  g (Trans s a ou s') = g (Trans s1 a1 ou1 s1')\n  V tr1 = vl1'\n\ngoal (1 subgoal):\n 1. V (Trans s1 a1 ou1 s1' # tr1) = vl1 \\<Longrightarrow>\n    validFrom s1 (Trans s1 a1 ou1 s1' # tr1) \\<and>\n    O (Trans s1 a1 ou1 s1' # tr1) = O (Trans s a ou s' # tr') \\<and>\n    V (Trans s1 a1 ou1 s1' # tr1) = vl1", "by auto"], ["proof (state)\nthis:\n  \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1\n\ngoal (1 subgoal):\n 1. ignore \\<Delta> s s1 vl1 a ou s' vl' \\<Longrightarrow>\n    \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ignore \\<Delta> s s1 vl1 a ou s' vl' \\<Longrightarrow>\n    \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "assume ?ignore"], ["proof (state)\nthis:\n  ignore \\<Delta> s s1 vl1 a ou s' vl'\n\ngoal (1 subgoal):\n 1. ignore \\<Delta> s s1 vl1 a ou s' vl' \\<Longrightarrow>\n    \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "thus ?thesis"], ["proof (prove)\nusing this:\n  ignore \\<Delta> s s1 vl1 a ou s' vl'\n\ngoal (1 subgoal):\n 1. \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "unfolding ignore_def Let_def"], ["proof (prove)\nusing this:\n  \\<not> \\<gamma> (Trans s a ou s') \\<and> \\<Delta> s' vl' s1 vl1\n\ngoal (1 subgoal):\n 1. \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "proof (elim exE conjE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> \\<gamma> (Trans s a ou s');\n     \\<Delta> s' vl' s1 vl1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tr1.\n                         validFrom s1 tr1 \\<and>\n                         O tr1 = O tr \\<and> V tr1 = vl1", "assume \\<gamma>: \"\\<not> \\<gamma> ?trn\" and \\<Delta>: \"\\<Delta> s' vl' s1 vl1\""], ["proof (state)\nthis:\n  \\<not> \\<gamma> (Trans s a ou s')\n  \\<Delta> s' vl' s1 vl1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> \\<gamma> (Trans s a ou s');\n     \\<Delta> s' vl' s1 vl1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tr1.\n                         validFrom s1 tr1 \\<and>\n                         O tr1 = O tr \\<and> V tr1 = vl1", "obtain tr1 where v1: \"validFrom s1 tr1\" and O: \"O tr1 = O tr'\" and V: \"V tr1 = vl1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>tr1.\n        \\<lbrakk>validFrom s1 tr1; O tr1 = O tr'; V tr1 = vl1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 1[of tr' vl1] rs' rs1 \\<Delta> v' NT' V' c"], ["proof (prove)\nusing this:\n  length tr' + length vl1 < length tr + length vl1 \\<Longrightarrow>\n  \\<forall>s vl s1.\n     reachNT s \\<and>\n     reach s1 \\<and>\n     \\<Delta> s vl s1 vl1 \\<and>\n     validFrom s tr' \\<and> never T tr' \\<and> V tr' = vl \\<longrightarrow>\n     (\\<exists>tr1.\n         validFrom s1 tr1 \\<and> O tr1 = O tr' \\<and> V tr1 = vl1)\n  reachNT s'\n  reach s1\n  \\<Delta> s' vl' s1 vl1\n  validFrom s' tr'\n  never T tr'\n  V tr' = vl'\n  consume (Trans s a ou s') vl vl'\n\ngoal (1 subgoal):\n 1. (\\<And>tr1.\n        \\<lbrakk>validFrom s1 tr1; O tr1 = O tr'; V tr1 = vl1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding tr"], ["proof (prove)\nusing this:\n  length tr' + length vl1\n  < length (trn # tr') + length vl1 \\<Longrightarrow>\n  \\<forall>s vl s1.\n     reachNT s \\<and>\n     reach s1 \\<and>\n     \\<Delta> s vl s1 vl1 \\<and>\n     validFrom s tr' \\<and> never T tr' \\<and> V tr' = vl \\<longrightarrow>\n     (\\<exists>tr1.\n         validFrom s1 tr1 \\<and> O tr1 = O tr' \\<and> V tr1 = vl1)\n  reachNT s'\n  reach s1\n  \\<Delta> s' vl' s1 vl1\n  validFrom s' tr'\n  never T tr'\n  V tr' = vl'\n  consume (Trans s a ou s') vl vl'\n\ngoal (1 subgoal):\n 1. (\\<And>tr1.\n        \\<lbrakk>validFrom s1 tr1; O tr1 = O tr'; V tr1 = vl1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  validFrom s1 tr1\n  O tr1 = O tr'\n  V tr1 = vl1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> \\<gamma> (Trans s a ou s');\n     \\<Delta> s' vl' s1 vl1\\<rbrakk>\n    \\<Longrightarrow> \\<exists>tr1.\n                         validFrom s1 tr1 \\<and>\n                         O tr1 = O tr \\<and> V tr1 = vl1", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "apply(intro exI[of _ tr1])"], ["proof (prove)\ngoal (1 subgoal):\n 1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "using v1 O V \\<gamma>"], ["proof (prove)\nusing this:\n  validFrom s1 tr1\n  O tr1 = O tr'\n  V tr1 = vl1\n  \\<not> \\<gamma> (Trans s a ou s')\n\ngoal (1 subgoal):\n 1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "unfolding tr trn ss"], ["proof (prove)\nusing this:\n  validFrom s1 tr1\n  O tr1 = O tr'\n  V tr1 = vl1\n  \\<not> \\<gamma> (Trans s a ou s')\n\ngoal (1 subgoal):\n 1. validFrom s1 tr1 \\<and>\n    O tr1 = O (Trans s a ou s' # tr') \\<and> V tr1 = vl1", "by auto"], ["proof (state)\nthis:\n  \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>s vl s1.\n     reachNT s \\<and>\n     reach s1 \\<and>\n     \\<Delta> s vl s1 vl1 \\<and>\n     validFrom s tr \\<and> never T tr \\<and> V tr = vl \\<longrightarrow>\n     (\\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>s vl s1.\n     reachNT s \\<and>\n     reach s1 \\<and>\n     \\<Delta> s vl s1 vl1 \\<and>\n     validFrom s tr \\<and> never T tr \\<and> V tr = vl \\<longrightarrow>\n     (\\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1)\n\ngoal (1 subgoal):\n 1. \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>s vl s1.\n     reachNT s \\<and>\n     reach s1 \\<and>\n     \\<Delta> s vl s1 vl1 \\<and>\n     validFrom s tr \\<and> never T tr \\<and> V tr = vl \\<longrightarrow>\n     (\\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1)\n\ngoal (1 subgoal):\n 1. \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>s vl s1.\n     reachNT s \\<and>\n     reach s1 \\<and>\n     \\<Delta> s vl s1 vl1 \\<and>\n     validFrom s tr \\<and> never T tr \\<and> V tr = vl \\<longrightarrow>\n     (\\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1)\n  unwind \\<Delta>\n  reachNT s\n  reach s1\n  \\<Delta> s vl s1 vl1\n  validFrom s tr\n  never T tr\n  V tr = vl\n\ngoal (1 subgoal):\n 1. \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1", "by auto"], ["proof (state)\nthis:\n  \\<exists>tr1. validFrom s1 tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem unwind_secure:\nassumes init: \"\\<And> vl vl1. B vl vl1 \\<Longrightarrow> \\<Delta> istate vl istate vl1\"\nand unwind: \"unwind \\<Delta>\"\nshows secure"], ["proof (prove)\ngoal (1 subgoal):\n 1. secure", "using assms unwind_trace"], ["proof (prove)\nusing this:\n  B ?vl3 ?vl1.3 \\<Longrightarrow> \\<Delta> istate ?vl3 istate ?vl1.3\n  unwind \\<Delta>\n  \\<lbrakk>unwind ?\\<Delta>; reachNT ?s; reach ?s1.0;\n   ?\\<Delta> ?s ?vl ?s1.0 ?vl1.0; validFrom ?s ?tr; never T ?tr;\n   V ?tr = ?vl\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tr1.\n                       validFrom ?s1.0 tr1 \\<and>\n                       O tr1 = O ?tr \\<and> V tr1 = ?vl1.0\n\ngoal (1 subgoal):\n 1. secure", "unfolding secure_def"], ["proof (prove)\nusing this:\n  B ?vl3 ?vl1.3 \\<Longrightarrow> \\<Delta> istate ?vl3 istate ?vl1.3\n  unwind \\<Delta>\n  \\<lbrakk>unwind ?\\<Delta>; reachNT ?s; reach ?s1.0;\n   ?\\<Delta> ?s ?vl ?s1.0 ?vl1.0; validFrom ?s ?tr; never T ?tr;\n   V ?tr = ?vl\\<rbrakk>\n  \\<Longrightarrow> \\<exists>tr1.\n                       validFrom ?s1.0 tr1 \\<and>\n                       O tr1 = O ?tr \\<and> V tr1 = ?vl1.0\n\ngoal (1 subgoal):\n 1. \\<forall>tr vl vl1.\n       validFrom istate tr \\<and>\n       never T tr \\<and> B vl vl1 \\<and> V tr = vl \\<longrightarrow>\n       (\\<exists>tr1.\n           validFrom istate tr1 \\<and> O tr1 = O tr \\<and> V tr1 = vl1)", "by (blast intro: reach.Istate reachNT.Istate)"], ["", "(*<*)"], ["", "end"], ["", "(* locale BD_Security *)"], ["", "end"], ["", "(*>*)"]]}