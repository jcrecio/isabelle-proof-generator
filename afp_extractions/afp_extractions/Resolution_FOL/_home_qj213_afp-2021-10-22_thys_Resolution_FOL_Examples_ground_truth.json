{"file_name": "/home/qj213/afp-2021-10-22/thys/Resolution_FOL/Examples.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Resolution_FOL", "problem_names": ["lemma \"eval\\<^sub>t E\\<^sub>n\\<^sub>a\\<^sub>t F\\<^sub>n\\<^sub>a\\<^sub>t (Var ''x'') = 26\"", "lemma \"eval\\<^sub>t E\\<^sub>n\\<^sub>a\\<^sub>t F\\<^sub>n\\<^sub>a\\<^sub>t (Fun ''one'' []) = 1\"", "lemma \"eval\\<^sub>t E\\<^sub>n\\<^sub>a\\<^sub>t F\\<^sub>n\\<^sub>a\\<^sub>t (Fun ''mul'' [Var ''y'',Var ''y'']) = 25\"", "lemma \n  \"eval\\<^sub>t E\\<^sub>n\\<^sub>a\\<^sub>t F\\<^sub>n\\<^sub>a\\<^sub>t (Fun ''add'' [Fun ''mul'' [Var ''y'',Var ''y''], Fun ''one'' []]) = 26\"", "lemma \"eval\\<^sub>l E\\<^sub>n\\<^sub>a\\<^sub>t F\\<^sub>n\\<^sub>a\\<^sub>t G\\<^sub>n\\<^sub>a\\<^sub>t (Pos ''greater'' [Var ''x'', Var ''y'']) = True\"", "lemma \"eval\\<^sub>l E\\<^sub>n\\<^sub>a\\<^sub>t F\\<^sub>n\\<^sub>a\\<^sub>t G\\<^sub>n\\<^sub>a\\<^sub>t (Neg ''less'' [Var ''x'', Var ''y'']) = True\"", "lemma \"eval\\<^sub>l E\\<^sub>n\\<^sub>a\\<^sub>t F\\<^sub>n\\<^sub>a\\<^sub>t G\\<^sub>n\\<^sub>a\\<^sub>t (Pos ''less'' [Var ''x'', Var ''y'']) = False\"", "lemma \"eval\\<^sub>l E\\<^sub>n\\<^sub>a\\<^sub>t F\\<^sub>n\\<^sub>a\\<^sub>t G\\<^sub>n\\<^sub>a\\<^sub>t \n       (Pos ''equals'' \n         [Fun ''add'' [Fun ''mul'' [Var ''y'',Var ''y''],Fun ''one'' []]\n         ,Var ''x'']\n       ) = True\"", "theorem empty_mgu: \n  assumes \"unifier\\<^sub>l\\<^sub>s \\<epsilon> L\"\n  shows \"mgu\\<^sub>l\\<^sub>s \\<epsilon> L\"", "theorem unifier_single: \"unifier\\<^sub>l\\<^sub>s \\<sigma> {l}\"", "theorem resolution_rule':\n  assumes \"C\\<^sub>1 \\<in> Cs\"\n  assumes \"C\\<^sub>2 \\<in> Cs\"\n  assumes \"applicable C\\<^sub>1 C\\<^sub>2 L\\<^sub>1 L\\<^sub>2 \\<sigma>\"\n  assumes \"C = {resolution C\\<^sub>1 C\\<^sub>2 L\\<^sub>1 L\\<^sub>2 \\<sigma>}\"\n  shows \"resolution_step Cs (Cs \\<union> C)\"", "lemma resolution_example1: \n   \"resolution_deriv {{NP,PQ},{NQ},{PP,PQ}} \n                              {{NP,PQ},{NQ},{PP,PQ},{NP},{PP},{}}\"", "lemma mguPaaPax_mgu: \"mgu\\<^sub>l\\<^sub>s mguPaaPax {Paa,Pax}\"", "lemma resolution_example2: \n   \"resolution_deriv {{Nb,Na},{Pax},{Pa},{Na,Pb,Naa}}\n                              {{Nb,Na},{Pax},{Pa},{Na,Pb,Naa},{Na,Pb},{Na},{}}\"", "lemma resolution_example1_sem: \"\\<not>eval\\<^sub>c\\<^sub>s F G {{NP, PQ}, {NQ}, {PP, PQ}}\"", "lemma resolution_example2_sem: \"\\<not>eval\\<^sub>c\\<^sub>s F G {{Nb,Na},{Pax},{Pa},{Na,Pb,Naa}}\""], "translations": [["", "lemma \"eval\\<^sub>t E\\<^sub>n\\<^sub>a\\<^sub>t F\\<^sub>n\\<^sub>a\\<^sub>t (Var ''x'') = 26\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\\<^sub>t E\\<^sub>n\\<^sub>a\\<^sub>t F\\<^sub>n\\<^sub>a\\<^sub>t\n     (\\<epsilon> ''x'') =\n    26", "by auto"], ["", "lemma \"eval\\<^sub>t E\\<^sub>n\\<^sub>a\\<^sub>t F\\<^sub>n\\<^sub>a\\<^sub>t (Fun ''one'' []) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\\<^sub>t E\\<^sub>n\\<^sub>a\\<^sub>t F\\<^sub>n\\<^sub>a\\<^sub>t\n     (Fun ''one'' []) =\n    1", "by auto"], ["", "lemma \"eval\\<^sub>t E\\<^sub>n\\<^sub>a\\<^sub>t F\\<^sub>n\\<^sub>a\\<^sub>t (Fun ''mul'' [Var ''y'',Var ''y'']) = 25\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\\<^sub>t E\\<^sub>n\\<^sub>a\\<^sub>t F\\<^sub>n\\<^sub>a\\<^sub>t\n     (Fun ''mul'' [\\<epsilon> ''y'', \\<epsilon> ''y'']) =\n    25", "by auto"], ["", "lemma \n  \"eval\\<^sub>t E\\<^sub>n\\<^sub>a\\<^sub>t F\\<^sub>n\\<^sub>a\\<^sub>t (Fun ''add'' [Fun ''mul'' [Var ''y'',Var ''y''], Fun ''one'' []]) = 26\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\\<^sub>t E\\<^sub>n\\<^sub>a\\<^sub>t F\\<^sub>n\\<^sub>a\\<^sub>t\n     (Fun ''add''\n       [Fun ''mul'' [\\<epsilon> ''y'', \\<epsilon> ''y''], Fun ''one'' []]) =\n    26", "by auto"], ["", "lemma \"eval\\<^sub>l E\\<^sub>n\\<^sub>a\\<^sub>t F\\<^sub>n\\<^sub>a\\<^sub>t G\\<^sub>n\\<^sub>a\\<^sub>t (Pos ''greater'' [Var ''x'', Var ''y'']) = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\\<^sub>l E\\<^sub>n\\<^sub>a\\<^sub>t F\\<^sub>n\\<^sub>a\\<^sub>t\n     G\\<^sub>n\\<^sub>a\\<^sub>t\n     (Pos ''greater'' [\\<epsilon> ''x'', \\<epsilon> ''y'']) =\n    True", "by auto"], ["", "lemma \"eval\\<^sub>l E\\<^sub>n\\<^sub>a\\<^sub>t F\\<^sub>n\\<^sub>a\\<^sub>t G\\<^sub>n\\<^sub>a\\<^sub>t (Neg ''less'' [Var ''x'', Var ''y'']) = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\\<^sub>l E\\<^sub>n\\<^sub>a\\<^sub>t F\\<^sub>n\\<^sub>a\\<^sub>t\n     G\\<^sub>n\\<^sub>a\\<^sub>t\n     (Neg ''less'' [\\<epsilon> ''x'', \\<epsilon> ''y'']) =\n    True", "by auto"], ["", "lemma \"eval\\<^sub>l E\\<^sub>n\\<^sub>a\\<^sub>t F\\<^sub>n\\<^sub>a\\<^sub>t G\\<^sub>n\\<^sub>a\\<^sub>t (Pos ''less'' [Var ''x'', Var ''y'']) = False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\\<^sub>l E\\<^sub>n\\<^sub>a\\<^sub>t F\\<^sub>n\\<^sub>a\\<^sub>t\n     G\\<^sub>n\\<^sub>a\\<^sub>t\n     (Pos ''less'' [\\<epsilon> ''x'', \\<epsilon> ''y'']) =\n    False", "by auto"], ["", "lemma \"eval\\<^sub>l E\\<^sub>n\\<^sub>a\\<^sub>t F\\<^sub>n\\<^sub>a\\<^sub>t G\\<^sub>n\\<^sub>a\\<^sub>t \n       (Pos ''equals'' \n         [Fun ''add'' [Fun ''mul'' [Var ''y'',Var ''y''],Fun ''one'' []]\n         ,Var ''x'']\n       ) = True\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval\\<^sub>l E\\<^sub>n\\<^sub>a\\<^sub>t F\\<^sub>n\\<^sub>a\\<^sub>t\n     G\\<^sub>n\\<^sub>a\\<^sub>t\n     (Pos ''equals''\n       [Fun ''add''\n         [Fun ''mul'' [\\<epsilon> ''y'', \\<epsilon> ''y''], Fun ''one'' []],\n        \\<epsilon> ''x'']) =\n    True", "by auto"], ["", "definition PP :: \"fterm literal\" where\n  \"PP = Pos ''P'' [Fun ''c'' []]\""], ["", "definition PQ :: \"fterm literal\" where\n  \"PQ = Pos ''Q'' [Fun ''d'' []]\""], ["", "definition NP :: \"fterm literal\" where\n  \"NP = Neg ''P'' [Fun ''c'' []]\""], ["", "definition NQ :: \"fterm literal\" where\n  \"NQ = Neg ''Q'' [Fun ''d'' []]\""], ["", "theorem empty_mgu: \n  assumes \"unifier\\<^sub>l\\<^sub>s \\<epsilon> L\"\n  shows \"mgu\\<^sub>l\\<^sub>s \\<epsilon> L\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mgu\\<^sub>l\\<^sub>s \\<epsilon> L", "using assms"], ["proof (prove)\nusing this:\n  unifier\\<^sub>l\\<^sub>s \\<epsilon> L\n\ngoal (1 subgoal):\n 1. mgu\\<^sub>l\\<^sub>s \\<epsilon> L", "unfolding unifier\\<^sub>l\\<^sub>s_def mgu\\<^sub>l\\<^sub>s_def"], ["proof (prove)\nusing this:\n  \\<exists>l'. \\<forall>l\\<in>L. l \\<cdot>\\<^sub>l \\<epsilon> = l'\n\ngoal (1 subgoal):\n 1. (\\<exists>l'.\n        \\<forall>l\\<in>L. l \\<cdot>\\<^sub>l \\<epsilon> = l') \\<and>\n    (\\<forall>u.\n        (\\<exists>l'.\n            \\<forall>l\\<in>L. l \\<cdot>\\<^sub>l u = l') \\<longrightarrow>\n        (\\<exists>i. u = \\<epsilon> \\<cdot> i))", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l' u l'a.\n       \\<lbrakk>\\<forall>l\\<in>L. l \\<cdot>\\<^sub>l \\<epsilon> = l';\n        \\<forall>l\\<in>L. l \\<cdot>\\<^sub>l u = l'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>i. u = \\<epsilon> \\<cdot> i", "apply (rule_tac x=u in exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l' u l'a.\n       \\<lbrakk>\\<forall>l\\<in>L. l \\<cdot>\\<^sub>l \\<epsilon> = l';\n        \\<forall>l\\<in>L. l \\<cdot>\\<^sub>l u = l'a\\<rbrakk>\n       \\<Longrightarrow> u = \\<epsilon> \\<cdot> u", "using empty_comp1 empty_comp2"], ["proof (prove)\nusing this:\n  ?\\<sigma> \\<cdot> \\<epsilon> = ?\\<sigma>\n  \\<epsilon> \\<cdot> ?\\<sigma> = ?\\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>l' u l'a.\n       \\<lbrakk>\\<forall>l\\<in>L. l \\<cdot>\\<^sub>l \\<epsilon> = l';\n        \\<forall>l\\<in>L. l \\<cdot>\\<^sub>l u = l'a\\<rbrakk>\n       \\<Longrightarrow> u = \\<epsilon> \\<cdot> u", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "theorem unifier_single: \"unifier\\<^sub>l\\<^sub>s \\<sigma> {l}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unifier\\<^sub>l\\<^sub>s \\<sigma> {l}", "unfolding unifier\\<^sub>l\\<^sub>s_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l'. \\<forall>l\\<in>{l}. l \\<cdot>\\<^sub>l \\<sigma> = l'", "by auto"], ["", "theorem resolution_rule':\n  assumes \"C\\<^sub>1 \\<in> Cs\"\n  assumes \"C\\<^sub>2 \\<in> Cs\"\n  assumes \"applicable C\\<^sub>1 C\\<^sub>2 L\\<^sub>1 L\\<^sub>2 \\<sigma>\"\n  assumes \"C = {resolution C\\<^sub>1 C\\<^sub>2 L\\<^sub>1 L\\<^sub>2 \\<sigma>}\"\n  shows \"resolution_step Cs (Cs \\<union> C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. resolution_step Cs (Cs \\<union> C)", "using assms resolution_rule"], ["proof (prove)\nusing this:\n  C\\<^sub>1 \\<in> Cs\n  C\\<^sub>2 \\<in> Cs\n  applicable C\\<^sub>1 C\\<^sub>2 L\\<^sub>1 L\\<^sub>2 \\<sigma>\n  C = {resolution C\\<^sub>1 C\\<^sub>2 L\\<^sub>1 L\\<^sub>2 \\<sigma>}\n  \\<lbrakk>?C\\<^sub>1 \\<in> ?Cs; ?C\\<^sub>2 \\<in> ?Cs;\n   applicable ?C\\<^sub>1 ?C\\<^sub>2 ?L\\<^sub>1 ?L\\<^sub>2 ?\\<sigma>\\<rbrakk>\n  \\<Longrightarrow> resolution_step ?Cs\n                     (?Cs \\<union>\n                      {resolution ?C\\<^sub>1 ?C\\<^sub>2 ?L\\<^sub>1\n                        ?L\\<^sub>2 ?\\<sigma>})\n\ngoal (1 subgoal):\n 1. resolution_step Cs (Cs \\<union> C)", "by auto"], ["", "lemma resolution_example1: \n   \"resolution_deriv {{NP,PQ},{NQ},{PP,PQ}} \n                              {{NP,PQ},{NQ},{PP,PQ},{NP},{PP},{}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. resolution_deriv {{NP, PQ}, {NQ}, {PP, PQ}}\n     {{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}, {}}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. resolution_deriv {{NP, PQ}, {NQ}, {PP, PQ}}\n     {{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}, {}}", "have \"resolution_step \n          {{NP,PQ},{NQ},{PP,PQ}}\n         ({{NP,PQ},{NQ},{PP,PQ}} \\<union> {{NP}})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. resolution_step {{NP, PQ}, {NQ}, {PP, PQ}}\n     ({{NP, PQ}, {NQ}, {PP, PQ}} \\<union> {{NP}})", "apply (rule resolution_rule'[of \"{NP,PQ}\" _ \"{NQ}\" \"{PQ}\" \"{NQ}\" \\<epsilon>])"], ["proof (prove)\ngoal (4 subgoals):\n 1. {NP, PQ} \\<in> {{NP, PQ}, {NQ}, {PP, PQ}}\n 2. {NQ} \\<in> {{NP, PQ}, {NQ}, {PP, PQ}}\n 3. applicable {NP, PQ} {NQ} {PQ} {NQ} \\<epsilon>\n 4. {{NP}} = {resolution {NP, PQ} {NQ} {PQ} {NQ} \\<epsilon>}", "unfolding applicable_def vars\\<^sub>l\\<^sub>s_def  vars\\<^sub>l_def \n              NQ_def NP_def PQ_def PP_def resolution_def"], ["proof (prove)\ngoal (4 subgoals):\n 1. {Neg ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]}\n    \\<in> {{Neg ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]},\n           {Neg ''Q'' [Fun ''d'' []]},\n           {Pos ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]}}\n 2. {Neg ''Q'' [Fun ''d'' []]}\n    \\<in> {{Neg ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]},\n           {Neg ''Q'' [Fun ''d'' []]},\n           {Pos ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]}}\n 3. {Neg ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]} \\<noteq> {} \\<and>\n    {Neg ''Q'' [Fun ''d'' []]} \\<noteq> {} \\<and>\n    {Pos ''Q'' [Fun ''d'' []]} \\<noteq> {} \\<and>\n    {Neg ''Q'' [Fun ''d'' []]} \\<noteq> {} \\<and>\n    (\\<Union>l\\<in>{Neg ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]}.\n        vars\\<^sub>t\\<^sub>s (get_terms l)) \\<inter>\n    (\\<Union>l\\<in>{Neg ''Q'' [Fun ''d'' []]}.\n        vars\\<^sub>t\\<^sub>s (get_terms l)) =\n    {} \\<and>\n    {Pos ''Q'' [Fun ''d'' []]}\n    \\<subseteq> {Neg ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]} \\<and>\n    {Neg ''Q'' [Fun ''d'' []]} \\<subseteq> {Neg ''Q'' [Fun ''d'' []]} \\<and>\n    mgu\\<^sub>l\\<^sub>s \\<epsilon>\n     ({Pos ''Q'' [Fun ''d'' []]} \\<union>\n      {Neg ''Q'' [Fun ''d'' []]}\\<^sup>C)\n 4. {{Neg ''P'' [Fun ''c'' []]}} =\n    {{Neg ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]} -\n     {Pos ''Q'' [Fun ''d'' []]} \\<union>\n     ({Neg ''Q'' [Fun ''d'' []]} -\n      {Neg ''Q'' [Fun ''d'' []]}) \\<cdot>\\<^sub>l\\<^sub>s\n     \\<epsilon>}", "using unifier_single empty_mgu"], ["proof (prove)\nusing this:\n  unifier\\<^sub>l\\<^sub>s ?\\<sigma> {?l}\n  unifier\\<^sub>l\\<^sub>s \\<epsilon> ?L \\<Longrightarrow>\n  mgu\\<^sub>l\\<^sub>s \\<epsilon> ?L\n\ngoal (4 subgoals):\n 1. {Neg ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]}\n    \\<in> {{Neg ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]},\n           {Neg ''Q'' [Fun ''d'' []]},\n           {Pos ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]}}\n 2. {Neg ''Q'' [Fun ''d'' []]}\n    \\<in> {{Neg ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]},\n           {Neg ''Q'' [Fun ''d'' []]},\n           {Pos ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]}}\n 3. {Neg ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]} \\<noteq> {} \\<and>\n    {Neg ''Q'' [Fun ''d'' []]} \\<noteq> {} \\<and>\n    {Pos ''Q'' [Fun ''d'' []]} \\<noteq> {} \\<and>\n    {Neg ''Q'' [Fun ''d'' []]} \\<noteq> {} \\<and>\n    (\\<Union>l\\<in>{Neg ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]}.\n        vars\\<^sub>t\\<^sub>s (get_terms l)) \\<inter>\n    (\\<Union>l\\<in>{Neg ''Q'' [Fun ''d'' []]}.\n        vars\\<^sub>t\\<^sub>s (get_terms l)) =\n    {} \\<and>\n    {Pos ''Q'' [Fun ''d'' []]}\n    \\<subseteq> {Neg ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]} \\<and>\n    {Neg ''Q'' [Fun ''d'' []]} \\<subseteq> {Neg ''Q'' [Fun ''d'' []]} \\<and>\n    mgu\\<^sub>l\\<^sub>s \\<epsilon>\n     ({Pos ''Q'' [Fun ''d'' []]} \\<union>\n      {Neg ''Q'' [Fun ''d'' []]}\\<^sup>C)\n 4. {{Neg ''P'' [Fun ''c'' []]}} =\n    {{Neg ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]} -\n     {Pos ''Q'' [Fun ''d'' []]} \\<union>\n     ({Neg ''Q'' [Fun ''d'' []]} -\n      {Neg ''Q'' [Fun ''d'' []]}) \\<cdot>\\<^sub>l\\<^sub>s\n     \\<epsilon>}", "using empty_subls"], ["proof (prove)\nusing this:\n  unifier\\<^sub>l\\<^sub>s ?\\<sigma> {?l}\n  unifier\\<^sub>l\\<^sub>s \\<epsilon> ?L \\<Longrightarrow>\n  mgu\\<^sub>l\\<^sub>s \\<epsilon> ?L\n  ?L \\<cdot>\\<^sub>l\\<^sub>s \\<epsilon> = ?L\n\ngoal (4 subgoals):\n 1. {Neg ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]}\n    \\<in> {{Neg ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]},\n           {Neg ''Q'' [Fun ''d'' []]},\n           {Pos ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]}}\n 2. {Neg ''Q'' [Fun ''d'' []]}\n    \\<in> {{Neg ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]},\n           {Neg ''Q'' [Fun ''d'' []]},\n           {Pos ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]}}\n 3. {Neg ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]} \\<noteq> {} \\<and>\n    {Neg ''Q'' [Fun ''d'' []]} \\<noteq> {} \\<and>\n    {Pos ''Q'' [Fun ''d'' []]} \\<noteq> {} \\<and>\n    {Neg ''Q'' [Fun ''d'' []]} \\<noteq> {} \\<and>\n    (\\<Union>l\\<in>{Neg ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]}.\n        vars\\<^sub>t\\<^sub>s (get_terms l)) \\<inter>\n    (\\<Union>l\\<in>{Neg ''Q'' [Fun ''d'' []]}.\n        vars\\<^sub>t\\<^sub>s (get_terms l)) =\n    {} \\<and>\n    {Pos ''Q'' [Fun ''d'' []]}\n    \\<subseteq> {Neg ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]} \\<and>\n    {Neg ''Q'' [Fun ''d'' []]} \\<subseteq> {Neg ''Q'' [Fun ''d'' []]} \\<and>\n    mgu\\<^sub>l\\<^sub>s \\<epsilon>\n     ({Pos ''Q'' [Fun ''d'' []]} \\<union>\n      {Neg ''Q'' [Fun ''d'' []]}\\<^sup>C)\n 4. {{Neg ''P'' [Fun ''c'' []]}} =\n    {{Neg ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]} -\n     {Pos ''Q'' [Fun ''d'' []]} \\<union>\n     ({Neg ''Q'' [Fun ''d'' []]} -\n      {Neg ''Q'' [Fun ''d'' []]}) \\<cdot>\\<^sub>l\\<^sub>s\n     \\<epsilon>}", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  resolution_step {{NP, PQ}, {NQ}, {PP, PQ}}\n   ({{NP, PQ}, {NQ}, {PP, PQ}} \\<union> {{NP}})\n\ngoal (1 subgoal):\n 1. resolution_deriv {{NP, PQ}, {NQ}, {PP, PQ}}\n     {{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}, {}}", "then"], ["proof (chain)\npicking this:\n  resolution_step {{NP, PQ}, {NQ}, {PP, PQ}}\n   ({{NP, PQ}, {NQ}, {PP, PQ}} \\<union> {{NP}})", "have \"resolution_step \n          {{NP,PQ},{NQ},{PP,PQ}}\n         ({{NP,PQ},{NQ},{PP,PQ},{NP}})\""], ["proof (prove)\nusing this:\n  resolution_step {{NP, PQ}, {NQ}, {PP, PQ}}\n   ({{NP, PQ}, {NQ}, {PP, PQ}} \\<union> {{NP}})\n\ngoal (1 subgoal):\n 1. resolution_step {{NP, PQ}, {NQ}, {PP, PQ}}\n     {{NP, PQ}, {NQ}, {PP, PQ}, {NP}}", "by (simp add: insert_commute)"], ["proof (state)\nthis:\n  resolution_step {{NP, PQ}, {NQ}, {PP, PQ}}\n   {{NP, PQ}, {NQ}, {PP, PQ}, {NP}}\n\ngoal (1 subgoal):\n 1. resolution_deriv {{NP, PQ}, {NQ}, {PP, PQ}}\n     {{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}, {}}", "moreover"], ["proof (state)\nthis:\n  resolution_step {{NP, PQ}, {NQ}, {PP, PQ}}\n   {{NP, PQ}, {NQ}, {PP, PQ}, {NP}}\n\ngoal (1 subgoal):\n 1. resolution_deriv {{NP, PQ}, {NQ}, {PP, PQ}}\n     {{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}, {}}", "have \"resolution_step\n         {{NP,PQ},{NQ},{PP,PQ},{NP}}\n        ({{NP,PQ},{NQ},{PP,PQ},{NP}} \\<union> {{PP}})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. resolution_step {{NP, PQ}, {NQ}, {PP, PQ}, {NP}}\n     ({{NP, PQ}, {NQ}, {PP, PQ}, {NP}} \\<union> {{PP}})", "apply (rule resolution_rule'[of \"{NQ}\" _ \"{PP,PQ}\" \"{NQ}\" \"{PQ}\" \\<epsilon>])"], ["proof (prove)\ngoal (4 subgoals):\n 1. {NQ} \\<in> {{NP, PQ}, {NQ}, {PP, PQ}, {NP}}\n 2. {PP, PQ} \\<in> {{NP, PQ}, {NQ}, {PP, PQ}, {NP}}\n 3. applicable {NQ} {PP, PQ} {NQ} {PQ} \\<epsilon>\n 4. {{PP}} = {resolution {NQ} {PP, PQ} {NQ} {PQ} \\<epsilon>}", "unfolding applicable_def vars\\<^sub>l\\<^sub>s_def  vars\\<^sub>l_def \n              NQ_def NP_def PQ_def PP_def resolution_def"], ["proof (prove)\ngoal (4 subgoals):\n 1. {Neg ''Q'' [Fun ''d'' []]}\n    \\<in> {{Neg ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]},\n           {Neg ''Q'' [Fun ''d'' []]},\n           {Pos ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]},\n           {Neg ''P'' [Fun ''c'' []]}}\n 2. {Pos ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]}\n    \\<in> {{Neg ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]},\n           {Neg ''Q'' [Fun ''d'' []]},\n           {Pos ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]},\n           {Neg ''P'' [Fun ''c'' []]}}\n 3. {Neg ''Q'' [Fun ''d'' []]} \\<noteq> {} \\<and>\n    {Pos ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]} \\<noteq> {} \\<and>\n    {Neg ''Q'' [Fun ''d'' []]} \\<noteq> {} \\<and>\n    {Pos ''Q'' [Fun ''d'' []]} \\<noteq> {} \\<and>\n    (\\<Union>l\\<in>{Neg ''Q'' [Fun ''d'' []]}.\n        vars\\<^sub>t\\<^sub>s (get_terms l)) \\<inter>\n    (\\<Union>l\\<in>{Pos ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]}.\n        vars\\<^sub>t\\<^sub>s (get_terms l)) =\n    {} \\<and>\n    {Neg ''Q'' [Fun ''d'' []]} \\<subseteq> {Neg ''Q'' [Fun ''d'' []]} \\<and>\n    {Pos ''Q'' [Fun ''d'' []]}\n    \\<subseteq> {Pos ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]} \\<and>\n    mgu\\<^sub>l\\<^sub>s \\<epsilon>\n     ({Neg ''Q'' [Fun ''d'' []]} \\<union>\n      {Pos ''Q'' [Fun ''d'' []]}\\<^sup>C)\n 4. {{Pos ''P'' [Fun ''c'' []]}} =\n    {{Neg ''Q'' [Fun ''d'' []]} - {Neg ''Q'' [Fun ''d'' []]} \\<union>\n     ({Pos ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]} -\n      {Pos ''Q'' [Fun ''d'' []]}) \\<cdot>\\<^sub>l\\<^sub>s\n     \\<epsilon>}", "using unifier_single empty_mgu empty_subls"], ["proof (prove)\nusing this:\n  unifier\\<^sub>l\\<^sub>s ?\\<sigma> {?l}\n  unifier\\<^sub>l\\<^sub>s \\<epsilon> ?L \\<Longrightarrow>\n  mgu\\<^sub>l\\<^sub>s \\<epsilon> ?L\n  ?L \\<cdot>\\<^sub>l\\<^sub>s \\<epsilon> = ?L\n\ngoal (4 subgoals):\n 1. {Neg ''Q'' [Fun ''d'' []]}\n    \\<in> {{Neg ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]},\n           {Neg ''Q'' [Fun ''d'' []]},\n           {Pos ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]},\n           {Neg ''P'' [Fun ''c'' []]}}\n 2. {Pos ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]}\n    \\<in> {{Neg ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]},\n           {Neg ''Q'' [Fun ''d'' []]},\n           {Pos ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]},\n           {Neg ''P'' [Fun ''c'' []]}}\n 3. {Neg ''Q'' [Fun ''d'' []]} \\<noteq> {} \\<and>\n    {Pos ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]} \\<noteq> {} \\<and>\n    {Neg ''Q'' [Fun ''d'' []]} \\<noteq> {} \\<and>\n    {Pos ''Q'' [Fun ''d'' []]} \\<noteq> {} \\<and>\n    (\\<Union>l\\<in>{Neg ''Q'' [Fun ''d'' []]}.\n        vars\\<^sub>t\\<^sub>s (get_terms l)) \\<inter>\n    (\\<Union>l\\<in>{Pos ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]}.\n        vars\\<^sub>t\\<^sub>s (get_terms l)) =\n    {} \\<and>\n    {Neg ''Q'' [Fun ''d'' []]} \\<subseteq> {Neg ''Q'' [Fun ''d'' []]} \\<and>\n    {Pos ''Q'' [Fun ''d'' []]}\n    \\<subseteq> {Pos ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]} \\<and>\n    mgu\\<^sub>l\\<^sub>s \\<epsilon>\n     ({Neg ''Q'' [Fun ''d'' []]} \\<union>\n      {Pos ''Q'' [Fun ''d'' []]}\\<^sup>C)\n 4. {{Pos ''P'' [Fun ''c'' []]}} =\n    {{Neg ''Q'' [Fun ''d'' []]} - {Neg ''Q'' [Fun ''d'' []]} \\<union>\n     ({Pos ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]} -\n      {Pos ''Q'' [Fun ''d'' []]}) \\<cdot>\\<^sub>l\\<^sub>s\n     \\<epsilon>}", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  resolution_step {{NP, PQ}, {NQ}, {PP, PQ}, {NP}}\n   ({{NP, PQ}, {NQ}, {PP, PQ}, {NP}} \\<union> {{PP}})\n\ngoal (1 subgoal):\n 1. resolution_deriv {{NP, PQ}, {NQ}, {PP, PQ}}\n     {{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}, {}}", "then"], ["proof (chain)\npicking this:\n  resolution_step {{NP, PQ}, {NQ}, {PP, PQ}, {NP}}\n   ({{NP, PQ}, {NQ}, {PP, PQ}, {NP}} \\<union> {{PP}})", "have \"resolution_step\n         {{NP,PQ},{NQ},{PP,PQ},{NP}}\n        ({{NP,PQ},{NQ},{PP,PQ},{NP},{PP}})\""], ["proof (prove)\nusing this:\n  resolution_step {{NP, PQ}, {NQ}, {PP, PQ}, {NP}}\n   ({{NP, PQ}, {NQ}, {PP, PQ}, {NP}} \\<union> {{PP}})\n\ngoal (1 subgoal):\n 1. resolution_step {{NP, PQ}, {NQ}, {PP, PQ}, {NP}}\n     {{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}}", "by (simp add: insert_commute)"], ["proof (state)\nthis:\n  resolution_step {{NP, PQ}, {NQ}, {PP, PQ}, {NP}}\n   {{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}}\n\ngoal (1 subgoal):\n 1. resolution_deriv {{NP, PQ}, {NQ}, {PP, PQ}}\n     {{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}, {}}", "moreover"], ["proof (state)\nthis:\n  resolution_step {{NP, PQ}, {NQ}, {PP, PQ}, {NP}}\n   {{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}}\n\ngoal (1 subgoal):\n 1. resolution_deriv {{NP, PQ}, {NQ}, {PP, PQ}}\n     {{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}, {}}", "have \"resolution_step\n         {{NP,PQ},{NQ},{PP,PQ},{NP},{PP}}\n        ({{NP,PQ},{NQ},{PP,PQ},{NP},{PP}} \\<union> {{}})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. resolution_step {{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}}\n     ({{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}} \\<union> {{}})", "apply (rule resolution_rule'[of \"{NP}\" _ \"{PP}\" \"{NP}\" \"{PP}\" \\<epsilon>])"], ["proof (prove)\ngoal (4 subgoals):\n 1. {NP} \\<in> {{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}}\n 2. {PP} \\<in> {{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}}\n 3. applicable {NP} {PP} {NP} {PP} \\<epsilon>\n 4. {{}} = {resolution {NP} {PP} {NP} {PP} \\<epsilon>}", "unfolding applicable_def vars\\<^sub>l\\<^sub>s_def  vars\\<^sub>l_def \n              NQ_def NP_def PQ_def PP_def resolution_def"], ["proof (prove)\ngoal (4 subgoals):\n 1. {Neg ''P'' [Fun ''c'' []]}\n    \\<in> {{Neg ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]},\n           {Neg ''Q'' [Fun ''d'' []]},\n           {Pos ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]},\n           {Neg ''P'' [Fun ''c'' []]}, {Pos ''P'' [Fun ''c'' []]}}\n 2. {Pos ''P'' [Fun ''c'' []]}\n    \\<in> {{Neg ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]},\n           {Neg ''Q'' [Fun ''d'' []]},\n           {Pos ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]},\n           {Neg ''P'' [Fun ''c'' []]}, {Pos ''P'' [Fun ''c'' []]}}\n 3. {Neg ''P'' [Fun ''c'' []]} \\<noteq> {} \\<and>\n    {Pos ''P'' [Fun ''c'' []]} \\<noteq> {} \\<and>\n    {Neg ''P'' [Fun ''c'' []]} \\<noteq> {} \\<and>\n    {Pos ''P'' [Fun ''c'' []]} \\<noteq> {} \\<and>\n    (\\<Union>l\\<in>{Neg ''P'' [Fun ''c'' []]}.\n        vars\\<^sub>t\\<^sub>s (get_terms l)) \\<inter>\n    (\\<Union>l\\<in>{Pos ''P'' [Fun ''c'' []]}.\n        vars\\<^sub>t\\<^sub>s (get_terms l)) =\n    {} \\<and>\n    {Neg ''P'' [Fun ''c'' []]} \\<subseteq> {Neg ''P'' [Fun ''c'' []]} \\<and>\n    {Pos ''P'' [Fun ''c'' []]} \\<subseteq> {Pos ''P'' [Fun ''c'' []]} \\<and>\n    mgu\\<^sub>l\\<^sub>s \\<epsilon>\n     ({Neg ''P'' [Fun ''c'' []]} \\<union>\n      {Pos ''P'' [Fun ''c'' []]}\\<^sup>C)\n 4. {{}} =\n    {{Neg ''P'' [Fun ''c'' []]} - {Neg ''P'' [Fun ''c'' []]} \\<union>\n     ({Pos ''P'' [Fun ''c'' []]} -\n      {Pos ''P'' [Fun ''c'' []]}) \\<cdot>\\<^sub>l\\<^sub>s\n     \\<epsilon>}", "using unifier_single empty_mgu"], ["proof (prove)\nusing this:\n  unifier\\<^sub>l\\<^sub>s ?\\<sigma> {?l}\n  unifier\\<^sub>l\\<^sub>s \\<epsilon> ?L \\<Longrightarrow>\n  mgu\\<^sub>l\\<^sub>s \\<epsilon> ?L\n\ngoal (4 subgoals):\n 1. {Neg ''P'' [Fun ''c'' []]}\n    \\<in> {{Neg ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]},\n           {Neg ''Q'' [Fun ''d'' []]},\n           {Pos ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]},\n           {Neg ''P'' [Fun ''c'' []]}, {Pos ''P'' [Fun ''c'' []]}}\n 2. {Pos ''P'' [Fun ''c'' []]}\n    \\<in> {{Neg ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]},\n           {Neg ''Q'' [Fun ''d'' []]},\n           {Pos ''P'' [Fun ''c'' []], Pos ''Q'' [Fun ''d'' []]},\n           {Neg ''P'' [Fun ''c'' []]}, {Pos ''P'' [Fun ''c'' []]}}\n 3. {Neg ''P'' [Fun ''c'' []]} \\<noteq> {} \\<and>\n    {Pos ''P'' [Fun ''c'' []]} \\<noteq> {} \\<and>\n    {Neg ''P'' [Fun ''c'' []]} \\<noteq> {} \\<and>\n    {Pos ''P'' [Fun ''c'' []]} \\<noteq> {} \\<and>\n    (\\<Union>l\\<in>{Neg ''P'' [Fun ''c'' []]}.\n        vars\\<^sub>t\\<^sub>s (get_terms l)) \\<inter>\n    (\\<Union>l\\<in>{Pos ''P'' [Fun ''c'' []]}.\n        vars\\<^sub>t\\<^sub>s (get_terms l)) =\n    {} \\<and>\n    {Neg ''P'' [Fun ''c'' []]} \\<subseteq> {Neg ''P'' [Fun ''c'' []]} \\<and>\n    {Pos ''P'' [Fun ''c'' []]} \\<subseteq> {Pos ''P'' [Fun ''c'' []]} \\<and>\n    mgu\\<^sub>l\\<^sub>s \\<epsilon>\n     ({Neg ''P'' [Fun ''c'' []]} \\<union>\n      {Pos ''P'' [Fun ''c'' []]}\\<^sup>C)\n 4. {{}} =\n    {{Neg ''P'' [Fun ''c'' []]} - {Neg ''P'' [Fun ''c'' []]} \\<union>\n     ({Pos ''P'' [Fun ''c'' []]} -\n      {Pos ''P'' [Fun ''c'' []]}) \\<cdot>\\<^sub>l\\<^sub>s\n     \\<epsilon>}", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  resolution_step {{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}}\n   ({{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}} \\<union> {{}})\n\ngoal (1 subgoal):\n 1. resolution_deriv {{NP, PQ}, {NQ}, {PP, PQ}}\n     {{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}, {}}", "then"], ["proof (chain)\npicking this:\n  resolution_step {{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}}\n   ({{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}} \\<union> {{}})", "have \"resolution_step\n         {{NP,PQ},{NQ},{PP,PQ},{NP},{PP}}\n        ({{NP,PQ},{NQ},{PP,PQ},{NP},{PP},{}})\""], ["proof (prove)\nusing this:\n  resolution_step {{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}}\n   ({{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}} \\<union> {{}})\n\ngoal (1 subgoal):\n 1. resolution_step {{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}}\n     {{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}, {}}", "by (simp add: insert_commute)"], ["proof (state)\nthis:\n  resolution_step {{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}}\n   {{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}, {}}\n\ngoal (1 subgoal):\n 1. resolution_deriv {{NP, PQ}, {NQ}, {PP, PQ}}\n     {{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}, {}}", "ultimately"], ["proof (chain)\npicking this:\n  resolution_step {{NP, PQ}, {NQ}, {PP, PQ}}\n   {{NP, PQ}, {NQ}, {PP, PQ}, {NP}}\n  resolution_step {{NP, PQ}, {NQ}, {PP, PQ}, {NP}}\n   {{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}}\n  resolution_step {{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}}\n   {{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}, {}}", "have \"resolution_deriv {{NP,PQ},{NQ},{PP,PQ}} \n                         {{NP,PQ},{NQ},{PP,PQ},{NP},{PP},{}}\""], ["proof (prove)\nusing this:\n  resolution_step {{NP, PQ}, {NQ}, {PP, PQ}}\n   {{NP, PQ}, {NQ}, {PP, PQ}, {NP}}\n  resolution_step {{NP, PQ}, {NQ}, {PP, PQ}, {NP}}\n   {{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}}\n  resolution_step {{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}}\n   {{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}, {}}\n\ngoal (1 subgoal):\n 1. resolution_deriv {{NP, PQ}, {NQ}, {PP, PQ}}\n     {{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}, {}}", "unfolding resolution_deriv_def"], ["proof (prove)\nusing this:\n  resolution_step {{NP, PQ}, {NQ}, {PP, PQ}}\n   {{NP, PQ}, {NQ}, {PP, PQ}, {NP}}\n  resolution_step {{NP, PQ}, {NQ}, {PP, PQ}, {NP}}\n   {{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}}\n  resolution_step {{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}}\n   {{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}, {}}\n\ngoal (1 subgoal):\n 1. resolution_step\\<^sup>*\\<^sup>* {{NP, PQ}, {NQ}, {PP, PQ}}\n     {{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}, {}}", "by auto"], ["proof (state)\nthis:\n  resolution_deriv {{NP, PQ}, {NQ}, {PP, PQ}}\n   {{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}, {}}\n\ngoal (1 subgoal):\n 1. resolution_deriv {{NP, PQ}, {NQ}, {PP, PQ}}\n     {{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}, {}}", "then"], ["proof (chain)\npicking this:\n  resolution_deriv {{NP, PQ}, {NQ}, {PP, PQ}}\n   {{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}, {}}", "show ?thesis"], ["proof (prove)\nusing this:\n  resolution_deriv {{NP, PQ}, {NQ}, {PP, PQ}}\n   {{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}, {}}\n\ngoal (1 subgoal):\n 1. resolution_deriv {{NP, PQ}, {NQ}, {PP, PQ}}\n     {{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}, {}}", "by auto"], ["proof (state)\nthis:\n  resolution_deriv {{NP, PQ}, {NQ}, {PP, PQ}}\n   {{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}, {}}\n\ngoal:\nNo subgoals!", "qed"], ["", "definition Pa :: \"fterm literal\" where\n  \"Pa = Pos ''a'' []\""], ["", "definition Na :: \"fterm literal\" where\n  \"Na = Neg ''a'' []\""], ["", "definition Pb :: \"fterm literal\" where\n  \"Pb = Pos ''b'' []\""], ["", "definition Nb :: \"fterm literal\" where\n  \"Nb = Neg ''b'' []\""], ["", "definition Paa :: \"fterm literal\" where\n  \"Paa = Pos ''a'' [Fun ''a'' []]\""], ["", "definition Naa :: \"fterm literal\" where\n  \"Naa = Neg ''a'' [Fun ''a'' []]\""], ["", "definition Pax :: \"fterm literal\" where\n  \"Pax = Pos ''a'' [Var ''x'']\""], ["", "definition Nax :: \"fterm literal\" where\n  \"Nax = Neg ''a'' [Var ''x'']\""], ["", "definition mguPaaPax :: substitution where\n  \"mguPaaPax = (\\<lambda>x. if x = ''x'' then Fun ''a'' [] else Var x)\""], ["", "lemma mguPaaPax_mgu: \"mgu\\<^sub>l\\<^sub>s mguPaaPax {Paa,Pax}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mgu\\<^sub>l\\<^sub>s mguPaaPax {Paa, Pax}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mgu\\<^sub>l\\<^sub>s mguPaaPax {Paa, Pax}", "let ?\\<sigma> = \"\\<lambda>x. if x = ''x'' then Fun ''a'' [] else Var x\""], ["proof (state)\ngoal (1 subgoal):\n 1. mgu\\<^sub>l\\<^sub>s mguPaaPax {Paa, Pax}", "have a: \"unifier\\<^sub>l\\<^sub>s (\\<lambda>x. if x = ''x'' then Fun ''a'' [] else Var x) {Paa,Pax}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unifier\\<^sub>l\\<^sub>s\n     (\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x)\n     {Paa, Pax}", "unfolding Paa_def Pax_def unifier\\<^sub>l\\<^sub>s_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l'.\n       \\<forall>l\\<in>{Pos ''a'' [Fun ''a'' []],\n                       Pos ''a'' [\\<epsilon> ''x'']}.\n          l \\<cdot>\\<^sub>l\n          (\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) =\n          l'", "by auto"], ["proof (state)\nthis:\n  unifier\\<^sub>l\\<^sub>s\n   (\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) {Paa, Pax}\n\ngoal (1 subgoal):\n 1. mgu\\<^sub>l\\<^sub>s mguPaaPax {Paa, Pax}", "have b: \"\\<forall>u. unifier\\<^sub>l\\<^sub>s u {Paa,Pax} \\<longrightarrow> (\\<exists>i. u = ?\\<sigma> \\<cdot> i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>u.\n       unifier\\<^sub>l\\<^sub>s u {Paa, Pax} \\<longrightarrow>\n       (\\<exists>i.\n           u =\n           (\\<lambda>x.\n               if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot>\n           i)", "proof (rule;rule)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       unifier\\<^sub>l\\<^sub>s u {Paa, Pax} \\<Longrightarrow>\n       \\<exists>i.\n          u =\n          (\\<lambda>x.\n              if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot>\n          i", "fix u"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>u.\n       unifier\\<^sub>l\\<^sub>s u {Paa, Pax} \\<Longrightarrow>\n       \\<exists>i.\n          u =\n          (\\<lambda>x.\n              if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot>\n          i", "assume \"unifier\\<^sub>l\\<^sub>s u {Paa,Pax}\""], ["proof (state)\nthis:\n  unifier\\<^sub>l\\<^sub>s u {Paa, Pax}\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       unifier\\<^sub>l\\<^sub>s u {Paa, Pax} \\<Longrightarrow>\n       \\<exists>i.\n          u =\n          (\\<lambda>x.\n              if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot>\n          i", "then"], ["proof (chain)\npicking this:\n  unifier\\<^sub>l\\<^sub>s u {Paa, Pax}", "have uuu: \"u ''x'' = Fun ''a'' []\""], ["proof (prove)\nusing this:\n  unifier\\<^sub>l\\<^sub>s u {Paa, Pax}\n\ngoal (1 subgoal):\n 1. u ''x'' = Fun ''a'' []", "unfolding unifier\\<^sub>l\\<^sub>s_def Paa_def Pax_def"], ["proof (prove)\nusing this:\n  \\<exists>l'.\n     \\<forall>l\\<in>{Pos ''a'' [Fun ''a'' []],\n                     Pos ''a'' [\\<epsilon> ''x'']}.\n        l \\<cdot>\\<^sub>l u = l'\n\ngoal (1 subgoal):\n 1. u ''x'' = Fun ''a'' []", "by auto"], ["proof (state)\nthis:\n  u ''x'' = Fun ''a'' []\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       unifier\\<^sub>l\\<^sub>s u {Paa, Pax} \\<Longrightarrow>\n       \\<exists>i.\n          u =\n          (\\<lambda>x.\n              if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot>\n          i", "have \"?\\<sigma> \\<cdot> u = u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot>\n    u =\n    u", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       ((\\<lambda>x.\n            if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot>\n        u)\n        x =\n       u x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       ((\\<lambda>x.\n            if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot>\n        u)\n        x =\n       u x", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       ((\\<lambda>x.\n            if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot>\n        u)\n        x =\n       u x", "assume \"x=''x''\""], ["proof (state)\nthis:\n  x = ''x''\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       ((\\<lambda>x.\n            if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot>\n        u)\n        x =\n       u x", "moreover"], ["proof (state)\nthis:\n  x = ''x''\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       ((\\<lambda>x.\n            if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot>\n        u)\n        x =\n       u x", "have \"(?\\<sigma> \\<cdot> u) ''x'' =  Fun ''a'' []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot>\n     u)\n     ''x'' =\n    Fun ''a'' []", "unfolding composition_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if ''x'' = ''x'' then Fun ''a'' []\n     else \\<epsilon> ''x'') \\<cdot>\\<^sub>t\n    u =\n    Fun ''a'' []", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot> u)\n   ''x'' =\n  Fun ''a'' []\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       ((\\<lambda>x.\n            if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot>\n        u)\n        x =\n       u x", "ultimately"], ["proof (chain)\npicking this:\n  x = ''x''\n  ((\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot> u)\n   ''x'' =\n  Fun ''a'' []", "have \"(?\\<sigma> \\<cdot> u) x = u x\""], ["proof (prove)\nusing this:\n  x = ''x''\n  ((\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot> u)\n   ''x'' =\n  Fun ''a'' []\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot>\n     u)\n     x =\n    u x", "using uuu"], ["proof (prove)\nusing this:\n  x = ''x''\n  ((\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot> u)\n   ''x'' =\n  Fun ''a'' []\n  u ''x'' = Fun ''a'' []\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot>\n     u)\n     x =\n    u x", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot> u)\n   x =\n  u x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       ((\\<lambda>x.\n            if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot>\n        u)\n        x =\n       u x", "}"], ["proof (state)\nthis:\n  x = ''x'' \\<Longrightarrow>\n  ((\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot> u)\n   x =\n  u x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       ((\\<lambda>x.\n            if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot>\n        u)\n        x =\n       u x", "moreover"], ["proof (state)\nthis:\n  x = ''x'' \\<Longrightarrow>\n  ((\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot> u)\n   x =\n  u x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       ((\\<lambda>x.\n            if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot>\n        u)\n        x =\n       u x", "{"], ["proof (state)\nthis:\n  x = ''x'' \\<Longrightarrow>\n  ((\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot> u)\n   x =\n  u x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       ((\\<lambda>x.\n            if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot>\n        u)\n        x =\n       u x", "assume \"x\\<noteq>''x''\""], ["proof (state)\nthis:\n  x \\<noteq> ''x''\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       ((\\<lambda>x.\n            if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot>\n        u)\n        x =\n       u x", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> ''x''", "have \"(?\\<sigma> \\<cdot> u) x = (\\<epsilon> x) \\<cdot>\\<^sub>t u\""], ["proof (prove)\nusing this:\n  x \\<noteq> ''x''\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot>\n     u)\n     x =\n    \\<epsilon> x \\<cdot>\\<^sub>t u", "unfolding composition_def"], ["proof (prove)\nusing this:\n  x \\<noteq> ''x''\n\ngoal (1 subgoal):\n 1. (if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot>\\<^sub>t u =\n    \\<epsilon> x \\<cdot>\\<^sub>t u", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot> u)\n   x =\n  \\<epsilon> x \\<cdot>\\<^sub>t u\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       ((\\<lambda>x.\n            if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot>\n        u)\n        x =\n       u x", "then"], ["proof (chain)\npicking this:\n  ((\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot> u)\n   x =\n  \\<epsilon> x \\<cdot>\\<^sub>t u", "have \"(?\\<sigma> \\<cdot> u) x = u x\""], ["proof (prove)\nusing this:\n  ((\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot> u)\n   x =\n  \\<epsilon> x \\<cdot>\\<^sub>t u\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot>\n     u)\n     x =\n    u x", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot> u)\n   x =\n  u x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       ((\\<lambda>x.\n            if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot>\n        u)\n        x =\n       u x", "}"], ["proof (state)\nthis:\n  x \\<noteq> ''x'' \\<Longrightarrow>\n  ((\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot> u)\n   x =\n  u x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       ((\\<lambda>x.\n            if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot>\n        u)\n        x =\n       u x", "ultimately"], ["proof (chain)\npicking this:\n  x = ''x'' \\<Longrightarrow>\n  ((\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot> u)\n   x =\n  u x\n  x \\<noteq> ''x'' \\<Longrightarrow>\n  ((\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot> u)\n   x =\n  u x", "show \"(?\\<sigma> \\<cdot> u) x = u x\""], ["proof (prove)\nusing this:\n  x = ''x'' \\<Longrightarrow>\n  ((\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot> u)\n   x =\n  u x\n  x \\<noteq> ''x'' \\<Longrightarrow>\n  ((\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot> u)\n   x =\n  u x\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot>\n     u)\n     x =\n    u x", "by auto"], ["proof (state)\nthis:\n  ((\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot> u)\n   x =\n  u x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot> u =\n  u\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       unifier\\<^sub>l\\<^sub>s u {Paa, Pax} \\<Longrightarrow>\n       \\<exists>i.\n          u =\n          (\\<lambda>x.\n              if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot>\n          i", "then"], ["proof (chain)\npicking this:\n  (\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot> u =\n  u", "have \"\\<exists>i. ?\\<sigma> \\<cdot> i = u\""], ["proof (prove)\nusing this:\n  (\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot> u =\n  u\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       (\\<lambda>x.\n           if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot>\n       i =\n       u", "by auto"], ["proof (state)\nthis:\n  \\<exists>i.\n     (\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot>\n     i =\n     u\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       unifier\\<^sub>l\\<^sub>s u {Paa, Pax} \\<Longrightarrow>\n       \\<exists>i.\n          u =\n          (\\<lambda>x.\n              if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot>\n          i", "then"], ["proof (chain)\npicking this:\n  \\<exists>i.\n     (\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot>\n     i =\n     u", "show \"\\<exists>i. u = ?\\<sigma> \\<cdot> i\""], ["proof (prove)\nusing this:\n  \\<exists>i.\n     (\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot>\n     i =\n     u\n\ngoal (1 subgoal):\n 1. \\<exists>i.\n       u =\n       (\\<lambda>x.\n           if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot>\n       i", "by auto"], ["proof (state)\nthis:\n  \\<exists>i.\n     u =\n     (\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot>\n     i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>u.\n     unifier\\<^sub>l\\<^sub>s u {Paa, Pax} \\<longrightarrow>\n     (\\<exists>i.\n         u =\n         (\\<lambda>x.\n             if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot>\n         i)\n\ngoal (1 subgoal):\n 1. mgu\\<^sub>l\\<^sub>s mguPaaPax {Paa, Pax}", "from a b"], ["proof (chain)\npicking this:\n  unifier\\<^sub>l\\<^sub>s\n   (\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) {Paa, Pax}\n  \\<forall>u.\n     unifier\\<^sub>l\\<^sub>s u {Paa, Pax} \\<longrightarrow>\n     (\\<exists>i.\n         u =\n         (\\<lambda>x.\n             if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot>\n         i)", "show ?thesis"], ["proof (prove)\nusing this:\n  unifier\\<^sub>l\\<^sub>s\n   (\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) {Paa, Pax}\n  \\<forall>u.\n     unifier\\<^sub>l\\<^sub>s u {Paa, Pax} \\<longrightarrow>\n     (\\<exists>i.\n         u =\n         (\\<lambda>x.\n             if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot>\n         i)\n\ngoal (1 subgoal):\n 1. mgu\\<^sub>l\\<^sub>s mguPaaPax {Paa, Pax}", "unfolding mgu\\<^sub>l\\<^sub>s_def"], ["proof (prove)\nusing this:\n  unifier\\<^sub>l\\<^sub>s\n   (\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) {Paa, Pax}\n  \\<forall>u.\n     unifier\\<^sub>l\\<^sub>s u {Paa, Pax} \\<longrightarrow>\n     (\\<exists>i.\n         u =\n         (\\<lambda>x.\n             if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot>\n         i)\n\ngoal (1 subgoal):\n 1. unifier\\<^sub>l\\<^sub>s mguPaaPax {Paa, Pax} \\<and>\n    (\\<forall>u.\n        unifier\\<^sub>l\\<^sub>s u {Paa, Pax} \\<longrightarrow>\n        (\\<exists>i. u = mguPaaPax \\<cdot> i))", "unfolding mguPaaPax_def"], ["proof (prove)\nusing this:\n  unifier\\<^sub>l\\<^sub>s\n   (\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) {Paa, Pax}\n  \\<forall>u.\n     unifier\\<^sub>l\\<^sub>s u {Paa, Pax} \\<longrightarrow>\n     (\\<exists>i.\n         u =\n         (\\<lambda>x.\n             if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot>\n         i)\n\ngoal (1 subgoal):\n 1. unifier\\<^sub>l\\<^sub>s\n     (\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x)\n     {Paa, Pax} \\<and>\n    (\\<forall>u.\n        unifier\\<^sub>l\\<^sub>s u {Paa, Pax} \\<longrightarrow>\n        (\\<exists>i.\n            u =\n            (\\<lambda>x.\n                if x = ''x'' then Fun ''a'' [] else \\<epsilon> x) \\<cdot>\n            i))", "by auto"], ["proof (state)\nthis:\n  mgu\\<^sub>l\\<^sub>s mguPaaPax {Paa, Pax}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma resolution_example2: \n   \"resolution_deriv {{Nb,Na},{Pax},{Pa},{Na,Pb,Naa}}\n                              {{Nb,Na},{Pax},{Pa},{Na,Pb,Naa},{Na,Pb},{Na},{}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. resolution_deriv {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}}\n     {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}, {}}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. resolution_deriv {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}}\n     {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}, {}}", "have \"resolution_step \n          {{Nb,Na},{Pax},{Pa},{Na,Pb,Naa}}\n         ({{Nb,Na},{Pax},{Pa},{Na,Pb,Naa}} \\<union> {{Na,Pb}})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. resolution_step {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}}\n     ({{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}} \\<union> {{Na, Pb}})", "apply (rule resolution_rule'[of \"{Pax}\" _ \"{Na,Pb,Naa}\" \"{Pax}\" \"{Naa}\" mguPaaPax ])"], ["proof (prove)\ngoal (4 subgoals):\n 1. {Pax} \\<in> {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}}\n 2. {Na, Pb, Naa} \\<in> {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}}\n 3. applicable {Pax} {Na, Pb, Naa} {Pax} {Naa} mguPaaPax\n 4. {{Na, Pb}} = {resolution {Pax} {Na, Pb, Naa} {Pax} {Naa} mguPaaPax}", "using mguPaaPax_mgu"], ["proof (prove)\nusing this:\n  mgu\\<^sub>l\\<^sub>s mguPaaPax {Paa, Pax}\n\ngoal (4 subgoals):\n 1. {Pax} \\<in> {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}}\n 2. {Na, Pb, Naa} \\<in> {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}}\n 3. applicable {Pax} {Na, Pb, Naa} {Pax} {Naa} mguPaaPax\n 4. {{Na, Pb}} = {resolution {Pax} {Na, Pb, Naa} {Pax} {Naa} mguPaaPax}", "unfolding applicable_def vars\\<^sub>l\\<^sub>s_def  vars\\<^sub>l_def \n          Nb_def Na_def Pax_def Pa_def Pb_def Naa_def Paa_def mguPaaPax_def resolution_def"], ["proof (prove)\nusing this:\n  mgu\\<^sub>l\\<^sub>s\n   (\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x)\n   {Pos ''a'' [Fun ''a'' []], Pos ''a'' [\\<epsilon> ''x'']}\n\ngoal (4 subgoals):\n 1. {Pos ''a'' [\\<epsilon> ''x'']}\n    \\<in> {{Neg ''b'' [], Neg ''a'' []}, {Pos ''a'' [\\<epsilon> ''x'']},\n           {Pos ''a'' []},\n           {Neg ''a'' [], Pos ''b'' [], Neg ''a'' [Fun ''a'' []]}}\n 2. {Neg ''a'' [], Pos ''b'' [], Neg ''a'' [Fun ''a'' []]}\n    \\<in> {{Neg ''b'' [], Neg ''a'' []}, {Pos ''a'' [\\<epsilon> ''x'']},\n           {Pos ''a'' []},\n           {Neg ''a'' [], Pos ''b'' [], Neg ''a'' [Fun ''a'' []]}}\n 3. {Pos ''a'' [\\<epsilon> ''x'']} \\<noteq> {} \\<and>\n    {Neg ''a'' [], Pos ''b'' [], Neg ''a'' [Fun ''a'' []]} \\<noteq>\n    {} \\<and>\n    {Pos ''a'' [\\<epsilon> ''x'']} \\<noteq> {} \\<and>\n    {Neg ''a'' [Fun ''a'' []]} \\<noteq> {} \\<and>\n    (\\<Union>l\\<in>{Pos ''a'' [\\<epsilon> ''x'']}.\n        vars\\<^sub>t\\<^sub>s (get_terms l)) \\<inter>\n    (\\<Union>l\\<in>{Neg ''a'' [], Pos ''b'' [], Neg ''a'' [Fun ''a'' []]}.\n        vars\\<^sub>t\\<^sub>s (get_terms l)) =\n    {} \\<and>\n    {Pos ''a'' [\\<epsilon> ''x'']}\n    \\<subseteq> {Pos ''a'' [\\<epsilon> ''x'']} \\<and>\n    {Neg ''a'' [Fun ''a'' []]}\n    \\<subseteq> {Neg ''a'' [], Pos ''b'' [],\n                 Neg ''a'' [Fun ''a'' []]} \\<and>\n    mgu\\<^sub>l\\<^sub>s\n     (\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x)\n     ({Pos ''a'' [\\<epsilon> ''x'']} \\<union>\n      {Neg ''a'' [Fun ''a'' []]}\\<^sup>C)\n 4. {{Neg ''a'' [], Pos ''b'' []}} =\n    {{Pos ''a'' [\\<epsilon> ''x'']} -\n     {Pos ''a'' [\\<epsilon> ''x'']} \\<union>\n     ({Neg ''a'' [], Pos ''b'' [], Neg ''a'' [Fun ''a'' []]} -\n      {Neg ''a'' [Fun ''a'' []]}) \\<cdot>\\<^sub>l\\<^sub>s\n     (\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x)}", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. mgu\\<^sub>l\\<^sub>s\n     (\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x)\n     {Pos ''a'' [Fun ''a'' []],\n      Pos ''a'' [\\<epsilon> ''x'']} \\<Longrightarrow>\n    Neg ''a'' []\n    \\<in> {Neg ''a'' [], Pos ''b'' [], Neg ''a'' [Fun ''a'' []]} -\n          {Neg ''a'' [Fun ''a'' []]} \\<cdot>\\<^sub>l\\<^sub>s\n          (\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x)\n 2. mgu\\<^sub>l\\<^sub>s\n     (\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x)\n     {Pos ''a'' [Fun ''a'' []],\n      Pos ''a'' [\\<epsilon> ''x'']} \\<Longrightarrow>\n    Pos ''b'' []\n    \\<in> {Neg ''a'' [], Pos ''b'' [], Neg ''a'' [Fun ''a'' []]} -\n          {Neg ''a'' [Fun ''a'' []]} \\<cdot>\\<^sub>l\\<^sub>s\n          (\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x)", "apply (rule_tac x=Na in image_eqI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. mgu\\<^sub>l\\<^sub>s\n     (\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x)\n     {Pos ''a'' [Fun ''a'' []],\n      Pos ''a'' [\\<epsilon> ''x'']} \\<Longrightarrow>\n    Neg ''a'' [] =\n    Na \\<cdot>\\<^sub>l\n    (\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x)\n 2. mgu\\<^sub>l\\<^sub>s\n     (\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x)\n     {Pos ''a'' [Fun ''a'' []],\n      Pos ''a'' [\\<epsilon> ''x'']} \\<Longrightarrow>\n    Na \\<in> {Neg ''a'' [], Pos ''b'' [], Neg ''a'' [Fun ''a'' []]} -\n             {Neg ''a'' [Fun ''a'' []]}\n 3. mgu\\<^sub>l\\<^sub>s\n     (\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x)\n     {Pos ''a'' [Fun ''a'' []],\n      Pos ''a'' [\\<epsilon> ''x'']} \\<Longrightarrow>\n    Pos ''b'' []\n    \\<in> {Neg ''a'' [], Pos ''b'' [], Neg ''a'' [Fun ''a'' []]} -\n          {Neg ''a'' [Fun ''a'' []]} \\<cdot>\\<^sub>l\\<^sub>s\n          (\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x)", "unfolding Na_def"], ["proof (prove)\ngoal (3 subgoals):\n 1. mgu\\<^sub>l\\<^sub>s\n     (\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x)\n     {Pos ''a'' [Fun ''a'' []],\n      Pos ''a'' [\\<epsilon> ''x'']} \\<Longrightarrow>\n    Neg ''a'' [] =\n    Neg ''a'' [] \\<cdot>\\<^sub>l\n    (\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x)\n 2. mgu\\<^sub>l\\<^sub>s\n     (\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x)\n     {Pos ''a'' [Fun ''a'' []],\n      Pos ''a'' [\\<epsilon> ''x'']} \\<Longrightarrow>\n    Neg ''a'' []\n    \\<in> {Neg ''a'' [], Pos ''b'' [], Neg ''a'' [Fun ''a'' []]} -\n          {Neg ''a'' [Fun ''a'' []]}\n 3. mgu\\<^sub>l\\<^sub>s\n     (\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x)\n     {Pos ''a'' [Fun ''a'' []],\n      Pos ''a'' [\\<epsilon> ''x'']} \\<Longrightarrow>\n    Pos ''b'' []\n    \\<in> {Neg ''a'' [], Pos ''b'' [], Neg ''a'' [Fun ''a'' []]} -\n          {Neg ''a'' [Fun ''a'' []]} \\<cdot>\\<^sub>l\\<^sub>s\n          (\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. mgu\\<^sub>l\\<^sub>s\n     (\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x)\n     {Pos ''a'' [Fun ''a'' []],\n      Pos ''a'' [\\<epsilon> ''x'']} \\<Longrightarrow>\n    Pos ''b'' []\n    \\<in> {Neg ''a'' [], Pos ''b'' [], Neg ''a'' [Fun ''a'' []]} -\n          {Neg ''a'' [Fun ''a'' []]} \\<cdot>\\<^sub>l\\<^sub>s\n          (\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x)", "apply (rule_tac x=Pb in image_eqI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. mgu\\<^sub>l\\<^sub>s\n     (\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x)\n     {Pos ''a'' [Fun ''a'' []],\n      Pos ''a'' [\\<epsilon> ''x'']} \\<Longrightarrow>\n    Pos ''b'' [] =\n    Pb \\<cdot>\\<^sub>l\n    (\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x)\n 2. mgu\\<^sub>l\\<^sub>s\n     (\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x)\n     {Pos ''a'' [Fun ''a'' []],\n      Pos ''a'' [\\<epsilon> ''x'']} \\<Longrightarrow>\n    Pb \\<in> {Neg ''a'' [], Pos ''b'' [], Neg ''a'' [Fun ''a'' []]} -\n             {Neg ''a'' [Fun ''a'' []]}", "unfolding Pb_def"], ["proof (prove)\ngoal (2 subgoals):\n 1. mgu\\<^sub>l\\<^sub>s\n     (\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x)\n     {Pos ''a'' [Fun ''a'' []],\n      Pos ''a'' [\\<epsilon> ''x'']} \\<Longrightarrow>\n    Pos ''b'' [] =\n    Pos ''b'' [] \\<cdot>\\<^sub>l\n    (\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x)\n 2. mgu\\<^sub>l\\<^sub>s\n     (\\<lambda>x. if x = ''x'' then Fun ''a'' [] else \\<epsilon> x)\n     {Pos ''a'' [Fun ''a'' []],\n      Pos ''a'' [\\<epsilon> ''x'']} \\<Longrightarrow>\n    Pos ''b'' []\n    \\<in> {Neg ''a'' [], Pos ''b'' [], Neg ''a'' [Fun ''a'' []]} -\n          {Neg ''a'' [Fun ''a'' []]}", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  resolution_step {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}}\n   ({{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}} \\<union> {{Na, Pb}})\n\ngoal (1 subgoal):\n 1. resolution_deriv {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}}\n     {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}, {}}", "then"], ["proof (chain)\npicking this:\n  resolution_step {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}}\n   ({{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}} \\<union> {{Na, Pb}})", "have \"resolution_step \n          {{Nb,Na},{Pax},{Pa},{Na,Pb,Naa}}\n         ({{Nb,Na},{Pax},{Pa},{Na,Pb,Naa},{Na,Pb}})\""], ["proof (prove)\nusing this:\n  resolution_step {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}}\n   ({{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}} \\<union> {{Na, Pb}})\n\ngoal (1 subgoal):\n 1. resolution_step {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}}\n     {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}}", "by (simp add: insert_commute)"], ["proof (state)\nthis:\n  resolution_step {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}}\n   {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}}\n\ngoal (1 subgoal):\n 1. resolution_deriv {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}}\n     {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}, {}}", "moreover"], ["proof (state)\nthis:\n  resolution_step {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}}\n   {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}}\n\ngoal (1 subgoal):\n 1. resolution_deriv {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}}\n     {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}, {}}", "have \"resolution_step \n          {{Nb,Na},{Pax},{Pa},{Na,Pb,Naa},{Na,Pb}}\n         ({{Nb,Na},{Pax},{Pa},{Na,Pb,Naa},{Na,Pb}} \\<union> {{Na}})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. resolution_step {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}}\n     ({{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}} \\<union> {{Na}})", "apply (rule resolution_rule'[of \"{Nb,Na}\" _ \"{Na,Pb}\" \"{Nb}\" \"{Pb}\" \\<epsilon>])"], ["proof (prove)\ngoal (4 subgoals):\n 1. {Nb, Na} \\<in> {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}}\n 2. {Na, Pb} \\<in> {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}}\n 3. applicable {Nb, Na} {Na, Pb} {Nb} {Pb} \\<epsilon>\n 4. {{Na}} = {resolution {Nb, Na} {Na, Pb} {Nb} {Pb} \\<epsilon>}", "unfolding applicable_def vars\\<^sub>l\\<^sub>s_def  vars\\<^sub>l_def \n                 Pb_def Nb_def Na_def PP_def resolution_def"], ["proof (prove)\ngoal (4 subgoals):\n 1. {Neg ''b'' [], Neg ''a'' []}\n    \\<in> {{Neg ''b'' [], Neg ''a'' []}, {Pax}, {Pa},\n           {Neg ''a'' [], Pos ''b'' [], Naa}, {Neg ''a'' [], Pos ''b'' []}}\n 2. {Neg ''a'' [], Pos ''b'' []}\n    \\<in> {{Neg ''b'' [], Neg ''a'' []}, {Pax}, {Pa},\n           {Neg ''a'' [], Pos ''b'' [], Naa}, {Neg ''a'' [], Pos ''b'' []}}\n 3. {Neg ''b'' [], Neg ''a'' []} \\<noteq> {} \\<and>\n    {Neg ''a'' [], Pos ''b'' []} \\<noteq> {} \\<and>\n    {Neg ''b'' []} \\<noteq> {} \\<and>\n    {Pos ''b'' []} \\<noteq> {} \\<and>\n    (\\<Union>l\\<in>{Neg ''b'' [], Neg ''a'' []}.\n        vars\\<^sub>t\\<^sub>s (get_terms l)) \\<inter>\n    (\\<Union>l\\<in>{Neg ''a'' [], Pos ''b'' []}.\n        vars\\<^sub>t\\<^sub>s (get_terms l)) =\n    {} \\<and>\n    {Neg ''b'' []} \\<subseteq> {Neg ''b'' [], Neg ''a'' []} \\<and>\n    {Pos ''b'' []} \\<subseteq> {Neg ''a'' [], Pos ''b'' []} \\<and>\n    mgu\\<^sub>l\\<^sub>s \\<epsilon>\n     ({Neg ''b'' []} \\<union> {Pos ''b'' []}\\<^sup>C)\n 4. {{Neg ''a'' []}} =\n    {{Neg ''b'' [], Neg ''a'' []} - {Neg ''b'' []} \\<union>\n     ({Neg ''a'' [], Pos ''b'' []} - {Pos ''b'' []}) \\<cdot>\\<^sub>l\\<^sub>s\n     \\<epsilon>}", "using unifier_single empty_mgu"], ["proof (prove)\nusing this:\n  unifier\\<^sub>l\\<^sub>s ?\\<sigma> {?l}\n  unifier\\<^sub>l\\<^sub>s \\<epsilon> ?L \\<Longrightarrow>\n  mgu\\<^sub>l\\<^sub>s \\<epsilon> ?L\n\ngoal (4 subgoals):\n 1. {Neg ''b'' [], Neg ''a'' []}\n    \\<in> {{Neg ''b'' [], Neg ''a'' []}, {Pax}, {Pa},\n           {Neg ''a'' [], Pos ''b'' [], Naa}, {Neg ''a'' [], Pos ''b'' []}}\n 2. {Neg ''a'' [], Pos ''b'' []}\n    \\<in> {{Neg ''b'' [], Neg ''a'' []}, {Pax}, {Pa},\n           {Neg ''a'' [], Pos ''b'' [], Naa}, {Neg ''a'' [], Pos ''b'' []}}\n 3. {Neg ''b'' [], Neg ''a'' []} \\<noteq> {} \\<and>\n    {Neg ''a'' [], Pos ''b'' []} \\<noteq> {} \\<and>\n    {Neg ''b'' []} \\<noteq> {} \\<and>\n    {Pos ''b'' []} \\<noteq> {} \\<and>\n    (\\<Union>l\\<in>{Neg ''b'' [], Neg ''a'' []}.\n        vars\\<^sub>t\\<^sub>s (get_terms l)) \\<inter>\n    (\\<Union>l\\<in>{Neg ''a'' [], Pos ''b'' []}.\n        vars\\<^sub>t\\<^sub>s (get_terms l)) =\n    {} \\<and>\n    {Neg ''b'' []} \\<subseteq> {Neg ''b'' [], Neg ''a'' []} \\<and>\n    {Pos ''b'' []} \\<subseteq> {Neg ''a'' [], Pos ''b'' []} \\<and>\n    mgu\\<^sub>l\\<^sub>s \\<epsilon>\n     ({Neg ''b'' []} \\<union> {Pos ''b'' []}\\<^sup>C)\n 4. {{Neg ''a'' []}} =\n    {{Neg ''b'' [], Neg ''a'' []} - {Neg ''b'' []} \\<union>\n     ({Neg ''a'' [], Pos ''b'' []} - {Pos ''b'' []}) \\<cdot>\\<^sub>l\\<^sub>s\n     \\<epsilon>}", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  resolution_step {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}}\n   ({{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}} \\<union> {{Na}})\n\ngoal (1 subgoal):\n 1. resolution_deriv {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}}\n     {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}, {}}", "then"], ["proof (chain)\npicking this:\n  resolution_step {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}}\n   ({{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}} \\<union> {{Na}})", "have \"resolution_step \n          {{Nb,Na},{Pax},{Pa},{Na,Pb,Naa},{Na,Pb}}\n         ({{Nb,Na},{Pax},{Pa},{Na,Pb,Naa},{Na,Pb},{Na}})\""], ["proof (prove)\nusing this:\n  resolution_step {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}}\n   ({{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}} \\<union> {{Na}})\n\ngoal (1 subgoal):\n 1. resolution_step {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}}\n     {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}}", "by (simp add: insert_commute)"], ["proof (state)\nthis:\n  resolution_step {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}}\n   {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}}\n\ngoal (1 subgoal):\n 1. resolution_deriv {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}}\n     {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}, {}}", "moreover"], ["proof (state)\nthis:\n  resolution_step {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}}\n   {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}}\n\ngoal (1 subgoal):\n 1. resolution_deriv {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}}\n     {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}, {}}", "have \"resolution_step \n          {{Nb,Na},{Pax},{Pa},{Na,Pb,Naa},{Na,Pb},{Na}}\n         ({{Nb,Na},{Pax},{Pa},{Na,Pb,Naa},{Na,Pb},{Na}} \\<union> {{}})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. resolution_step {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}}\n     ({{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}} \\<union> {{}})", "apply (rule resolution_rule'[of \"{Na}\" _ \"{Pa}\" \"{Na}\" \"{Pa}\" \\<epsilon>])"], ["proof (prove)\ngoal (4 subgoals):\n 1. {Na} \\<in> {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}}\n 2. {Pa} \\<in> {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}}\n 3. applicable {Na} {Pa} {Na} {Pa} \\<epsilon>\n 4. {{}} = {resolution {Na} {Pa} {Na} {Pa} \\<epsilon>}", "unfolding applicable_def vars\\<^sub>l\\<^sub>s_def  vars\\<^sub>l_def \n                  Pa_def Nb_def Na_def PP_def resolution_def"], ["proof (prove)\ngoal (4 subgoals):\n 1. {Neg ''a'' []}\n    \\<in> {{Neg ''b'' [], Neg ''a'' []}, {Pax}, {Pos ''a'' []},\n           {Neg ''a'' [], Pb, Naa}, {Neg ''a'' [], Pb}, {Neg ''a'' []}}\n 2. {Pos ''a'' []}\n    \\<in> {{Neg ''b'' [], Neg ''a'' []}, {Pax}, {Pos ''a'' []},\n           {Neg ''a'' [], Pb, Naa}, {Neg ''a'' [], Pb}, {Neg ''a'' []}}\n 3. {Neg ''a'' []} \\<noteq> {} \\<and>\n    {Pos ''a'' []} \\<noteq> {} \\<and>\n    {Neg ''a'' []} \\<noteq> {} \\<and>\n    {Pos ''a'' []} \\<noteq> {} \\<and>\n    (\\<Union>l\\<in>{Neg ''a'' []}.\n        vars\\<^sub>t\\<^sub>s (get_terms l)) \\<inter>\n    (\\<Union>l\\<in>{Pos ''a'' []}. vars\\<^sub>t\\<^sub>s (get_terms l)) =\n    {} \\<and>\n    {Neg ''a'' []} \\<subseteq> {Neg ''a'' []} \\<and>\n    {Pos ''a'' []} \\<subseteq> {Pos ''a'' []} \\<and>\n    mgu\\<^sub>l\\<^sub>s \\<epsilon>\n     ({Neg ''a'' []} \\<union> {Pos ''a'' []}\\<^sup>C)\n 4. {{}} =\n    {{Neg ''a'' []} - {Neg ''a'' []} \\<union>\n     ({Pos ''a'' []} - {Pos ''a'' []}) \\<cdot>\\<^sub>l\\<^sub>s\n     \\<epsilon>}", "using unifier_single empty_mgu"], ["proof (prove)\nusing this:\n  unifier\\<^sub>l\\<^sub>s ?\\<sigma> {?l}\n  unifier\\<^sub>l\\<^sub>s \\<epsilon> ?L \\<Longrightarrow>\n  mgu\\<^sub>l\\<^sub>s \\<epsilon> ?L\n\ngoal (4 subgoals):\n 1. {Neg ''a'' []}\n    \\<in> {{Neg ''b'' [], Neg ''a'' []}, {Pax}, {Pos ''a'' []},\n           {Neg ''a'' [], Pb, Naa}, {Neg ''a'' [], Pb}, {Neg ''a'' []}}\n 2. {Pos ''a'' []}\n    \\<in> {{Neg ''b'' [], Neg ''a'' []}, {Pax}, {Pos ''a'' []},\n           {Neg ''a'' [], Pb, Naa}, {Neg ''a'' [], Pb}, {Neg ''a'' []}}\n 3. {Neg ''a'' []} \\<noteq> {} \\<and>\n    {Pos ''a'' []} \\<noteq> {} \\<and>\n    {Neg ''a'' []} \\<noteq> {} \\<and>\n    {Pos ''a'' []} \\<noteq> {} \\<and>\n    (\\<Union>l\\<in>{Neg ''a'' []}.\n        vars\\<^sub>t\\<^sub>s (get_terms l)) \\<inter>\n    (\\<Union>l\\<in>{Pos ''a'' []}. vars\\<^sub>t\\<^sub>s (get_terms l)) =\n    {} \\<and>\n    {Neg ''a'' []} \\<subseteq> {Neg ''a'' []} \\<and>\n    {Pos ''a'' []} \\<subseteq> {Pos ''a'' []} \\<and>\n    mgu\\<^sub>l\\<^sub>s \\<epsilon>\n     ({Neg ''a'' []} \\<union> {Pos ''a'' []}\\<^sup>C)\n 4. {{}} =\n    {{Neg ''a'' []} - {Neg ''a'' []} \\<union>\n     ({Pos ''a'' []} - {Pos ''a'' []}) \\<cdot>\\<^sub>l\\<^sub>s\n     \\<epsilon>}", "apply auto"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  resolution_step {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}}\n   ({{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}} \\<union> {{}})\n\ngoal (1 subgoal):\n 1. resolution_deriv {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}}\n     {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}, {}}", "then"], ["proof (chain)\npicking this:\n  resolution_step {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}}\n   ({{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}} \\<union> {{}})", "have \"resolution_step \n          {{Nb,Na},{Pax},{Pa},{Na,Pb,Naa},{Na,Pb},{Na}}\n         ({{Nb,Na},{Pax},{Pa},{Na,Pb,Naa},{Na,Pb},{Na},{}})\""], ["proof (prove)\nusing this:\n  resolution_step {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}}\n   ({{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}} \\<union> {{}})\n\ngoal (1 subgoal):\n 1. resolution_step {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}}\n     {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}, {}}", "by (simp add: insert_commute)"], ["proof (state)\nthis:\n  resolution_step {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}}\n   {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}, {}}\n\ngoal (1 subgoal):\n 1. resolution_deriv {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}}\n     {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}, {}}", "ultimately"], ["proof (chain)\npicking this:\n  resolution_step {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}}\n   {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}}\n  resolution_step {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}}\n   {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}}\n  resolution_step {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}}\n   {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}, {}}", "have \"resolution_deriv {{Nb,Na},{Pax},{Pa},{Na,Pb,Naa}} \n          {{Nb,Na},{Pax},{Pa},{Na,Pb,Naa},{Na,Pb},{Na},{}}\""], ["proof (prove)\nusing this:\n  resolution_step {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}}\n   {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}}\n  resolution_step {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}}\n   {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}}\n  resolution_step {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}}\n   {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}, {}}\n\ngoal (1 subgoal):\n 1. resolution_deriv {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}}\n     {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}, {}}", "unfolding resolution_deriv_def"], ["proof (prove)\nusing this:\n  resolution_step {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}}\n   {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}}\n  resolution_step {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}}\n   {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}}\n  resolution_step {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}}\n   {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}, {}}\n\ngoal (1 subgoal):\n 1. resolution_step\\<^sup>*\\<^sup>* {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}}\n     {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}, {}}", "by auto"], ["proof (state)\nthis:\n  resolution_deriv {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}}\n   {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}, {}}\n\ngoal (1 subgoal):\n 1. resolution_deriv {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}}\n     {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}, {}}", "then"], ["proof (chain)\npicking this:\n  resolution_deriv {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}}\n   {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}, {}}", "show ?thesis"], ["proof (prove)\nusing this:\n  resolution_deriv {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}}\n   {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}, {}}\n\ngoal (1 subgoal):\n 1. resolution_deriv {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}}\n     {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}, {}}", "by auto"], ["proof (state)\nthis:\n  resolution_deriv {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}}\n   {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}, {}}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma resolution_example1_sem: \"\\<not>eval\\<^sub>c\\<^sub>s F G {{NP, PQ}, {NQ}, {PP, PQ}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> eval\\<^sub>c\\<^sub>s F G {{NP, PQ}, {NQ}, {PP, PQ}}", "using resolution_example1 derivation_sound_refute"], ["proof (prove)\nusing this:\n  resolution_deriv {{NP, PQ}, {NQ}, {PP, PQ}}\n   {{NP, PQ}, {NQ}, {PP, PQ}, {NP}, {PP}, {}}\n  resolution_deriv ?Cs ?Cs' \\<and> {} \\<in> ?Cs' \\<Longrightarrow>\n  \\<not> eval\\<^sub>c\\<^sub>s ?F ?G ?Cs\n\ngoal (1 subgoal):\n 1. \\<not> eval\\<^sub>c\\<^sub>s F G {{NP, PQ}, {NQ}, {PP, PQ}}", "by auto"], ["", "lemma resolution_example2_sem: \"\\<not>eval\\<^sub>c\\<^sub>s F G {{Nb,Na},{Pax},{Pa},{Na,Pb,Naa}}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> eval\\<^sub>c\\<^sub>s F G {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}}", "using resolution_example2 derivation_sound_refute"], ["proof (prove)\nusing this:\n  resolution_deriv {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}}\n   {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}, {Na, Pb}, {Na}, {}}\n  resolution_deriv ?Cs ?Cs' \\<and> {} \\<in> ?Cs' \\<Longrightarrow>\n  \\<not> eval\\<^sub>c\\<^sub>s ?F ?G ?Cs\n\ngoal (1 subgoal):\n 1. \\<not> eval\\<^sub>c\\<^sub>s F G {{Nb, Na}, {Pax}, {Pa}, {Na, Pb, Naa}}", "by auto"], ["", "end"]]}