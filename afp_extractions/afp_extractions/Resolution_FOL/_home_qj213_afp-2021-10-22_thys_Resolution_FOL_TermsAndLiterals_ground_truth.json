{"file_name": "/home/qj213/afp-2021-10-22/thys/Resolution_FOL/TermsAndLiterals.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Resolution_FOL", "problem_names": ["lemma ground\\<^sub>l_ground_fatom: \n  assumes \"ground\\<^sub>l l\"\n  shows \"get_atom l \\<in> ground_fatoms\"", "lemma infinity:\n  assumes inj: \"\\<forall>n :: nat. undiago (diago n) = n\" \n  assumes all_tree: \"\\<forall>n :: nat. (diago n) \\<in> S\"\n  shows \"\\<not>finite S\"", "lemma inv_into_f_f:\n  assumes \"bij_betw f A B\"\n  assumes \"a\\<in>A\"\n  shows \"(inv_into A f) (f a) = a\"", "lemma f_inv_into_f:\n  assumes \"bij_betw f A B\"\n  assumes \"b\\<in>B\"\n  shows \"f ((inv_into A f) b) = b\"", "lemma hterm_of_fterm_fterm_of_hterm[simp]: \"hterm_of_fterm (fterm_of_hterm t) = t\"", "lemma hterms_of_fterms_fterms_of_hterms[simp]: \"hterms_of_fterms (fterms_of_hterms ts) = ts\"", "lemma fterm_of_hterm_hterm_of_fterm[simp]:\n  assumes \"ground\\<^sub>t t\"\n  shows \"fterm_of_hterm (hterm_of_fterm t) = t\"", "lemma fterms_of_hterms_hterms_of_fterms[simp]: \n  assumes \"ground\\<^sub>t\\<^sub>s ts\"\n  shows \"fterms_of_hterms (hterms_of_fterms ts) = ts\"", "lemma ground_fterm_of_hterm:  \"ground\\<^sub>t (fterm_of_hterm t)\"", "lemma ground_fterms_of_hterms: \"ground\\<^sub>t\\<^sub>s (fterms_of_hterms ts)\"", "lemma ground_flit_of_hlit: \"ground\\<^sub>l (flit_of_hlit l)\"", "theorem hlit_of_flit_flit_of_hlit [simp]: \"hlit_of_flit (flit_of_hlit l) =  l\"", "theorem flit_of_hlit_hlit_of_flit [simp]:\n  assumes \"ground\\<^sub>l l\"\n  shows \"flit_of_hlit (hlit_of_flit l) = l\"", "lemma sign_flit_of_hlit: \"sign (flit_of_hlit l) = sign l\"", "lemma hlit_of_flit_bij: \"bij_betw hlit_of_flit {l. ground\\<^sub>l l} UNIV\"", "lemma flit_of_hlit_bij: \"bij_betw flit_of_hlit UNIV {l. ground\\<^sub>l l}\"", "lemma ground_fatom_of_hatom: \"ground\\<^sub>t\\<^sub>s (snd (fatom_of_hatom a))\"", "theorem hatom_of_fatom_fatom_of_hatom [simp]: \"hatom_of_fatom (fatom_of_hatom l) = l\"", "theorem fatom_of_hatom_hatom_of_fatom [simp]: \n  assumes \"ground\\<^sub>t\\<^sub>s (snd l)\"\n  shows \"fatom_of_hatom (hatom_of_fatom l) = l\"", "lemma hatom_of_fatom_bij: \"bij_betw hatom_of_fatom ground_fatoms UNIV\"", "lemma fatom_of_hatom_bij: \"bij_betw fatom_of_hatom UNIV ground_fatoms\"", "lemma nat_of_string_bij: \"bij nat_of_string\"", "lemma string_of_nat_bij: \"bij string_of_nat\"", "lemma nat_of_string_string_of_nat[simp]: \"nat_of_string (string_of_nat n) = n\"", "lemma string_of_nat_nat_of_string[simp]: \"string_of_nat (nat_of_string n) = n\"", "lemma infinite_hatoms: \"infinite (UNIV :: ('t atom) set)\"", "lemma nat_of_hatom_bij: \"bij nat_of_hatom\"", "lemma hatom_of_nat_bij: \"bij hatom_of_nat\"", "lemma nat_of_hatom_hatom_of_nat[simp]: \"nat_of_hatom (hatom_of_nat n) = n\"", "lemma hatom_of_nat_nat_of_hatom[simp]: \"hatom_of_nat (nat_of_hatom l) = l\"", "theorem diag_undiag_fatom[simp]: \n  assumes \"ground\\<^sub>t\\<^sub>s ts\"\n  shows \"fatom_of_nat (nat_of_fatom (p,ts)) = (p,ts)\"", "theorem undiag_diag_fatom[simp]: \"nat_of_fatom (fatom_of_nat n) = n\"", "lemma fatom_of_nat_bij: \"bij_betw fatom_of_nat UNIV ground_fatoms\"", "lemma ground_fatom_of_nat: \"ground\\<^sub>t\\<^sub>s (snd (fatom_of_nat x))\"", "lemma nat_of_fatom_bij: \"bij_betw nat_of_fatom ground_fatoms UNIV\""], "translations": [["", "lemma ground\\<^sub>l_ground_fatom: \n  assumes \"ground\\<^sub>l l\"\n  shows \"get_atom l \\<in> ground_fatoms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. get_atom l \\<in> ground_fatoms", "using assms"], ["proof (prove)\nusing this:\n  ground\\<^sub>l l\n\ngoal (1 subgoal):\n 1. get_atom l \\<in> ground_fatoms", "unfolding ground_fatoms_def"], ["proof (prove)\nusing this:\n  ground\\<^sub>l l\n\ngoal (1 subgoal):\n 1. get_atom l \\<in> {a. ground\\<^sub>t\\<^sub>s (snd a)}", "by (induction l) auto"], ["", "subsection \\<open>Auxiliary\\<close>"], ["", "lemma infinity:\n  assumes inj: \"\\<forall>n :: nat. undiago (diago n) = n\" \n  assumes all_tree: \"\\<forall>n :: nat. (diago n) \\<in> S\"\n  shows \"\\<not>finite S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite S", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite S", "from inj all_tree"], ["proof (chain)\npicking this:\n  \\<forall>n. undiago (diago n) = n\n  \\<forall>n. diago n \\<in> S", "have \"\\<forall>n. n = undiago (diago n) \\<and> (diago n) \\<in> S\""], ["proof (prove)\nusing this:\n  \\<forall>n. undiago (diago n) = n\n  \\<forall>n. diago n \\<in> S\n\ngoal (1 subgoal):\n 1. \\<forall>n. n = undiago (diago n) \\<and> diago n \\<in> S", "by auto"], ["proof (state)\nthis:\n  \\<forall>n. n = undiago (diago n) \\<and> diago n \\<in> S\n\ngoal (1 subgoal):\n 1. infinite S", "then"], ["proof (chain)\npicking this:\n  \\<forall>n. n = undiago (diago n) \\<and> diago n \\<in> S", "have \"\\<forall>n. \\<exists>ds. n = undiago ds \\<and> ds \\<in> S\""], ["proof (prove)\nusing this:\n  \\<forall>n. n = undiago (diago n) \\<and> diago n \\<in> S\n\ngoal (1 subgoal):\n 1. \\<forall>n. \\<exists>ds. n = undiago ds \\<and> ds \\<in> S", "by auto"], ["proof (state)\nthis:\n  \\<forall>n. \\<exists>ds. n = undiago ds \\<and> ds \\<in> S\n\ngoal (1 subgoal):\n 1. infinite S", "then"], ["proof (chain)\npicking this:\n  \\<forall>n. \\<exists>ds. n = undiago ds \\<and> ds \\<in> S", "have \"undiago ` S = (UNIV :: nat set)\""], ["proof (prove)\nusing this:\n  \\<forall>n. \\<exists>ds. n = undiago ds \\<and> ds \\<in> S\n\ngoal (1 subgoal):\n 1. undiago ` S = UNIV", "by auto"], ["proof (state)\nthis:\n  undiago ` S = UNIV\n\ngoal (1 subgoal):\n 1. infinite S", "then"], ["proof (chain)\npicking this:\n  undiago ` S = UNIV", "show \"\\<not>finite S\""], ["proof (prove)\nusing this:\n  undiago ` S = UNIV\n\ngoal (1 subgoal):\n 1. infinite S", "by (metis finite_imageI infinite_UNIV_nat)"], ["proof (state)\nthis:\n  infinite S\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inv_into_f_f:\n  assumes \"bij_betw f A B\"\n  assumes \"a\\<in>A\"\n  shows \"(inv_into A f) (f a) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_into A f (f a) = a", "using assms bij_betw_inv_into_left"], ["proof (prove)\nusing this:\n  bij_betw f A B\n  a \\<in> A\n  \\<lbrakk>bij_betw ?f ?A ?A'; ?a \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> inv_into ?A ?f (?f ?a) = ?a\n\ngoal (1 subgoal):\n 1. inv_into A f (f a) = a", "by metis"], ["", "lemma f_inv_into_f:\n  assumes \"bij_betw f A B\"\n  assumes \"b\\<in>B\"\n  shows \"f ((inv_into A f) b) = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (inv_into A f b) = b", "using assms bij_betw_inv_into_right"], ["proof (prove)\nusing this:\n  bij_betw f A B\n  b \\<in> B\n  \\<lbrakk>bij_betw ?f ?A ?A'; ?a' \\<in> ?A'\\<rbrakk>\n  \\<Longrightarrow> ?f (inv_into ?A ?f ?a') = ?a'\n\ngoal (1 subgoal):\n 1. f (inv_into A f b) = b", "by metis"], ["", "subsection \\<open>Conversions\\<close>"], ["", "subsubsection \\<open>Conversions - Terms and Herbrand Terms\\<close>"], ["", "fun fterm_of_hterm :: \"hterm \\<Rightarrow> fterm\" where\n  \"fterm_of_hterm (HFun p ts) = Fun p (map fterm_of_hterm ts)\""], ["", "definition fterms_of_hterms :: \"hterm list \\<Rightarrow> fterm list\" where\n  \"fterms_of_hterms ts \\<equiv> map fterm_of_hterm ts\""], ["", "fun hterm_of_fterm :: \"fterm \\<Rightarrow> hterm\" where\n  \"hterm_of_fterm (Fun p ts) = HFun p (map hterm_of_fterm ts)\""], ["", "definition hterms_of_fterms :: \"fterm list \\<Rightarrow> hterm list\" where\n\"hterms_of_fterms ts \\<equiv> map hterm_of_fterm ts\""], ["", "lemma hterm_of_fterm_fterm_of_hterm[simp]: \"hterm_of_fterm (fterm_of_hterm t) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hterm_of_fterm (fterm_of_hterm t) = t", "by (induction t) (simp add: map_idI)"], ["", "lemma hterms_of_fterms_fterms_of_hterms[simp]: \"hterms_of_fterms (fterms_of_hterms ts) = ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hterms_of_fterms (fterms_of_hterms ts) = ts", "unfolding hterms_of_fterms_def fterms_of_hterms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. map hterm_of_fterm (map fterm_of_hterm ts) = ts", "by (simp add: map_idI)"], ["", "lemma fterm_of_hterm_hterm_of_fterm[simp]:\n  assumes \"ground\\<^sub>t t\"\n  shows \"fterm_of_hterm (hterm_of_fterm t) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fterm_of_hterm (hterm_of_fterm t) = t", "using assms"], ["proof (prove)\nusing this:\n  ground\\<^sub>t t\n\ngoal (1 subgoal):\n 1. fterm_of_hterm (hterm_of_fterm t) = t", "by (induction t) (auto simp add: map_idI)"], ["", "lemma fterms_of_hterms_hterms_of_fterms[simp]: \n  assumes \"ground\\<^sub>t\\<^sub>s ts\"\n  shows \"fterms_of_hterms (hterms_of_fterms ts) = ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fterms_of_hterms (hterms_of_fterms ts) = ts", "using assms"], ["proof (prove)\nusing this:\n  ground\\<^sub>t\\<^sub>s ts\n\ngoal (1 subgoal):\n 1. fterms_of_hterms (hterms_of_fterms ts) = ts", "unfolding fterms_of_hterms_def hterms_of_fterms_def"], ["proof (prove)\nusing this:\n  ground\\<^sub>t\\<^sub>s ts\n\ngoal (1 subgoal):\n 1. map fterm_of_hterm (map hterm_of_fterm ts) = ts", "by (simp add: map_idI)"], ["", "lemma ground_fterm_of_hterm:  \"ground\\<^sub>t (fterm_of_hterm t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ground\\<^sub>t (fterm_of_hterm t)", "by (induction t) (auto simp add: map_idI)"], ["", "lemma ground_fterms_of_hterms: \"ground\\<^sub>t\\<^sub>s (fterms_of_hterms ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ground\\<^sub>t\\<^sub>s (fterms_of_hterms ts)", "unfolding fterms_of_hterms_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ground\\<^sub>t\\<^sub>s (map fterm_of_hterm ts)", "using ground_fterm_of_hterm"], ["proof (prove)\nusing this:\n  ground\\<^sub>t (fterm_of_hterm ?t)\n\ngoal (1 subgoal):\n 1. ground\\<^sub>t\\<^sub>s (map fterm_of_hterm ts)", "by auto"], ["", "subsubsection \\<open>Conversions -  Literals and Herbrand Literals\\<close>"], ["", "fun flit_of_hlit :: \"hterm literal \\<Rightarrow> fterm literal\" where\n  \"flit_of_hlit (Pos p ts) = Pos p (fterms_of_hterms ts)\"\n| \"flit_of_hlit (Neg p ts) = Neg p (fterms_of_hterms ts)\""], ["", "fun hlit_of_flit :: \"fterm literal \\<Rightarrow> hterm literal\" where\n  \"hlit_of_flit (Pos p ts) = Pos p (hterms_of_fterms ts)\"\n| \"hlit_of_flit (Neg p ts) = Neg p (hterms_of_fterms ts)\""], ["", "lemma ground_flit_of_hlit: \"ground\\<^sub>l (flit_of_hlit l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ground\\<^sub>l (flit_of_hlit l)", "by  (induction l)  (simp add: ground_fterms_of_hterms)+"], ["", "theorem hlit_of_flit_flit_of_hlit [simp]: \"hlit_of_flit (flit_of_hlit l) =  l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hlit_of_flit (flit_of_hlit l) = l", "by (cases l) auto"], ["", "theorem flit_of_hlit_hlit_of_flit [simp]:\n  assumes \"ground\\<^sub>l l\"\n  shows \"flit_of_hlit (hlit_of_flit l) = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. flit_of_hlit (hlit_of_flit l) = l", "using assms"], ["proof (prove)\nusing this:\n  ground\\<^sub>l l\n\ngoal (1 subgoal):\n 1. flit_of_hlit (hlit_of_flit l) = l", "by (cases l) auto"], ["", "lemma sign_flit_of_hlit: \"sign (flit_of_hlit l) = sign l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sign (flit_of_hlit l) = sign l", "by (cases l) auto"], ["", "lemma hlit_of_flit_bij: \"bij_betw hlit_of_flit {l. ground\\<^sub>l l} UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw hlit_of_flit {l. ground\\<^sub>l l} UNIV", "unfolding bij_betw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on hlit_of_flit {l. ground\\<^sub>l l} \\<and>\n    hlit_of_flit ` {l. ground\\<^sub>l l} = UNIV", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on hlit_of_flit {l. ground\\<^sub>l l}\n 2. hlit_of_flit ` {l. ground\\<^sub>l l} = UNIV", "show \"inj_on hlit_of_flit {l. ground\\<^sub>l l}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on hlit_of_flit {l. ground\\<^sub>l l}", "using inj_on_inverseI flit_of_hlit_hlit_of_flit"], ["proof (prove)\nusing this:\n  (\\<And>x. x \\<in> ?A \\<Longrightarrow> ?g (?f x) = x) \\<Longrightarrow>\n  inj_on ?f ?A\n  ground\\<^sub>l ?l \\<Longrightarrow> flit_of_hlit (hlit_of_flit ?l) = ?l\n\ngoal (1 subgoal):\n 1. inj_on hlit_of_flit {l. ground\\<^sub>l l}", "by (metis (mono_tags, lifting) mem_Collect_eq)"], ["proof (state)\nthis:\n  inj_on hlit_of_flit {l. ground\\<^sub>l l}\n\ngoal (1 subgoal):\n 1. hlit_of_flit ` {l. ground\\<^sub>l l} = UNIV", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. hlit_of_flit ` {l. ground\\<^sub>l l} = UNIV", "have \"\\<forall>l. \\<exists>l'. ground\\<^sub>l l' \\<and> l = hlit_of_flit l'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l. \\<exists>l'. ground\\<^sub>l l' \\<and> l = hlit_of_flit l'", "using ground_flit_of_hlit hlit_of_flit_flit_of_hlit"], ["proof (prove)\nusing this:\n  ground\\<^sub>l (flit_of_hlit ?l)\n  hlit_of_flit (flit_of_hlit ?l) = ?l\n\ngoal (1 subgoal):\n 1. \\<forall>l. \\<exists>l'. ground\\<^sub>l l' \\<and> l = hlit_of_flit l'", "by metis"], ["proof (state)\nthis:\n  \\<forall>l. \\<exists>l'. ground\\<^sub>l l' \\<and> l = hlit_of_flit l'\n\ngoal (1 subgoal):\n 1. hlit_of_flit ` {l. ground\\<^sub>l l} = UNIV", "then"], ["proof (chain)\npicking this:\n  \\<forall>l. \\<exists>l'. ground\\<^sub>l l' \\<and> l = hlit_of_flit l'", "show \"hlit_of_flit ` {l. ground\\<^sub>l l} = UNIV\""], ["proof (prove)\nusing this:\n  \\<forall>l. \\<exists>l'. ground\\<^sub>l l' \\<and> l = hlit_of_flit l'\n\ngoal (1 subgoal):\n 1. hlit_of_flit ` {l. ground\\<^sub>l l} = UNIV", "by auto"], ["proof (state)\nthis:\n  hlit_of_flit ` {l. ground\\<^sub>l l} = UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma flit_of_hlit_bij: \"bij_betw flit_of_hlit UNIV {l. ground\\<^sub>l l}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw flit_of_hlit UNIV {l. ground\\<^sub>l l}", "unfolding bij_betw_def inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>UNIV.\n        \\<forall>y\\<in>UNIV.\n           flit_of_hlit x = flit_of_hlit y \\<longrightarrow> x = y) \\<and>\n    range flit_of_hlit = {l. ground\\<^sub>l l}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>UNIV.\n       \\<forall>y\\<in>UNIV.\n          flit_of_hlit x = flit_of_hlit y \\<longrightarrow> x = y\n 2. range flit_of_hlit = {l. ground\\<^sub>l l}", "show \"\\<forall>x\\<in>UNIV. \\<forall>y\\<in>UNIV. flit_of_hlit x = flit_of_hlit y \\<longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>UNIV.\n       \\<forall>y\\<in>UNIV.\n          flit_of_hlit x = flit_of_hlit y \\<longrightarrow> x = y", "using ground_flit_of_hlit hlit_of_flit_flit_of_hlit"], ["proof (prove)\nusing this:\n  ground\\<^sub>l (flit_of_hlit ?l)\n  hlit_of_flit (flit_of_hlit ?l) = ?l\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>UNIV.\n       \\<forall>y\\<in>UNIV.\n          flit_of_hlit x = flit_of_hlit y \\<longrightarrow> x = y", "by metis"], ["proof (state)\nthis:\n  \\<forall>x\\<in>UNIV.\n     \\<forall>y\\<in>UNIV.\n        flit_of_hlit x = flit_of_hlit y \\<longrightarrow> x = y\n\ngoal (1 subgoal):\n 1. range flit_of_hlit = {l. ground\\<^sub>l l}", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. range flit_of_hlit = {l. ground\\<^sub>l l}", "have \"\\<forall>l. ground\\<^sub>l l \\<longrightarrow> (l = flit_of_hlit (hlit_of_flit l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l.\n       ground\\<^sub>l l \\<longrightarrow> l = flit_of_hlit (hlit_of_flit l)", "using hlit_of_flit_flit_of_hlit"], ["proof (prove)\nusing this:\n  hlit_of_flit (flit_of_hlit ?l) = ?l\n\ngoal (1 subgoal):\n 1. \\<forall>l.\n       ground\\<^sub>l l \\<longrightarrow> l = flit_of_hlit (hlit_of_flit l)", "by auto"], ["proof (state)\nthis:\n  \\<forall>l.\n     ground\\<^sub>l l \\<longrightarrow> l = flit_of_hlit (hlit_of_flit l)\n\ngoal (1 subgoal):\n 1. range flit_of_hlit = {l. ground\\<^sub>l l}", "then"], ["proof (chain)\npicking this:\n  \\<forall>l.\n     ground\\<^sub>l l \\<longrightarrow> l = flit_of_hlit (hlit_of_flit l)", "have \"{l. ground\\<^sub>l l}  \\<subseteq> flit_of_hlit ` UNIV \""], ["proof (prove)\nusing this:\n  \\<forall>l.\n     ground\\<^sub>l l \\<longrightarrow> l = flit_of_hlit (hlit_of_flit l)\n\ngoal (1 subgoal):\n 1. {l. ground\\<^sub>l l} \\<subseteq> range flit_of_hlit", "by blast"], ["proof (state)\nthis:\n  {l. ground\\<^sub>l l} \\<subseteq> range flit_of_hlit\n\ngoal (1 subgoal):\n 1. range flit_of_hlit = {l. ground\\<^sub>l l}", "moreover"], ["proof (state)\nthis:\n  {l. ground\\<^sub>l l} \\<subseteq> range flit_of_hlit\n\ngoal (1 subgoal):\n 1. range flit_of_hlit = {l. ground\\<^sub>l l}", "have \"\\<forall>l. ground\\<^sub>l (flit_of_hlit l)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l. ground\\<^sub>l (flit_of_hlit l)", "using ground_flit_of_hlit"], ["proof (prove)\nusing this:\n  ground\\<^sub>l (flit_of_hlit ?l)\n\ngoal (1 subgoal):\n 1. \\<forall>l. ground\\<^sub>l (flit_of_hlit l)", "by auto"], ["proof (state)\nthis:\n  \\<forall>l. ground\\<^sub>l (flit_of_hlit l)\n\ngoal (1 subgoal):\n 1. range flit_of_hlit = {l. ground\\<^sub>l l}", "ultimately"], ["proof (chain)\npicking this:\n  {l. ground\\<^sub>l l} \\<subseteq> range flit_of_hlit\n  \\<forall>l. ground\\<^sub>l (flit_of_hlit l)", "show \"flit_of_hlit ` UNIV = {l. ground\\<^sub>l l}\""], ["proof (prove)\nusing this:\n  {l. ground\\<^sub>l l} \\<subseteq> range flit_of_hlit\n  \\<forall>l. ground\\<^sub>l (flit_of_hlit l)\n\ngoal (1 subgoal):\n 1. range flit_of_hlit = {l. ground\\<^sub>l l}", "using hlit_of_flit_flit_of_hlit ground_flit_of_hlit"], ["proof (prove)\nusing this:\n  {l. ground\\<^sub>l l} \\<subseteq> range flit_of_hlit\n  \\<forall>l. ground\\<^sub>l (flit_of_hlit l)\n  hlit_of_flit (flit_of_hlit ?l) = ?l\n  ground\\<^sub>l (flit_of_hlit ?l)\n\ngoal (1 subgoal):\n 1. range flit_of_hlit = {l. ground\\<^sub>l l}", "by auto"], ["proof (state)\nthis:\n  range flit_of_hlit = {l. ground\\<^sub>l l}\n\ngoal:\nNo subgoals!", "qed"], ["", "subsubsection \\<open>Conversions - Atoms and Herbrand Atoms\\<close>"], ["", "fun fatom_of_hatom :: \"hterm atom \\<Rightarrow> fterm atom\" where\n  \"fatom_of_hatom (p, ts) = (p, fterms_of_hterms ts)\""], ["", "fun hatom_of_fatom :: \"fterm atom \\<Rightarrow> hterm atom\" where\n  \"hatom_of_fatom (p, ts) = (p, hterms_of_fterms ts)\""], ["", "lemma ground_fatom_of_hatom: \"ground\\<^sub>t\\<^sub>s (snd (fatom_of_hatom a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ground\\<^sub>t\\<^sub>s (snd (fatom_of_hatom a))", "by  (induction a) (simp add: ground_fterms_of_hterms)+"], ["", "theorem hatom_of_fatom_fatom_of_hatom [simp]: \"hatom_of_fatom (fatom_of_hatom l) = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hatom_of_fatom (fatom_of_hatom l) = l", "by (cases l) auto"], ["", "theorem fatom_of_hatom_hatom_of_fatom [simp]: \n  assumes \"ground\\<^sub>t\\<^sub>s (snd l)\"\n  shows \"fatom_of_hatom (hatom_of_fatom l) = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fatom_of_hatom (hatom_of_fatom l) = l", "using assms"], ["proof (prove)\nusing this:\n  ground\\<^sub>t\\<^sub>s (snd l)\n\ngoal (1 subgoal):\n 1. fatom_of_hatom (hatom_of_fatom l) = l", "by (cases l) auto"], ["", "lemma hatom_of_fatom_bij: \"bij_betw hatom_of_fatom ground_fatoms UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw hatom_of_fatom ground_fatoms UNIV", "unfolding bij_betw_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on hatom_of_fatom ground_fatoms \\<and>\n    hatom_of_fatom ` ground_fatoms = UNIV", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. inj_on hatom_of_fatom ground_fatoms\n 2. hatom_of_fatom ` ground_fatoms = UNIV", "show \"inj_on hatom_of_fatom ground_fatoms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on hatom_of_fatom ground_fatoms", "using inj_on_inverseI fatom_of_hatom_hatom_of_fatom"], ["proof (prove)\nusing this:\n  (\\<And>x. x \\<in> ?A \\<Longrightarrow> ?g (?f x) = x) \\<Longrightarrow>\n  inj_on ?f ?A\n  ground\\<^sub>t\\<^sub>s (snd ?l) \\<Longrightarrow>\n  fatom_of_hatom (hatom_of_fatom ?l) = ?l\n\ngoal (1 subgoal):\n 1. inj_on hatom_of_fatom ground_fatoms", "unfolding ground_fatoms_def"], ["proof (prove)\nusing this:\n  (\\<And>x. x \\<in> ?A \\<Longrightarrow> ?g (?f x) = x) \\<Longrightarrow>\n  inj_on ?f ?A\n  ground\\<^sub>t\\<^sub>s (snd ?l) \\<Longrightarrow>\n  fatom_of_hatom (hatom_of_fatom ?l) = ?l\n\ngoal (1 subgoal):\n 1. inj_on hatom_of_fatom {a. ground\\<^sub>t\\<^sub>s (snd a)}", "by (metis (mono_tags, lifting) mem_Collect_eq)"], ["proof (state)\nthis:\n  inj_on hatom_of_fatom ground_fatoms\n\ngoal (1 subgoal):\n 1. hatom_of_fatom ` ground_fatoms = UNIV", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. hatom_of_fatom ` ground_fatoms = UNIV", "have \"\\<forall>a. \\<exists>a'. ground\\<^sub>t\\<^sub>s (snd a') \\<and> a = hatom_of_fatom a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a.\n       \\<exists>a'.\n          ground\\<^sub>t\\<^sub>s (snd a') \\<and> a = hatom_of_fatom a'", "using ground_fatom_of_hatom hatom_of_fatom_fatom_of_hatom"], ["proof (prove)\nusing this:\n  ground\\<^sub>t\\<^sub>s (snd (fatom_of_hatom ?a))\n  hatom_of_fatom (fatom_of_hatom ?l) = ?l\n\ngoal (1 subgoal):\n 1. \\<forall>a.\n       \\<exists>a'.\n          ground\\<^sub>t\\<^sub>s (snd a') \\<and> a = hatom_of_fatom a'", "by metis"], ["proof (state)\nthis:\n  \\<forall>a.\n     \\<exists>a'.\n        ground\\<^sub>t\\<^sub>s (snd a') \\<and> a = hatom_of_fatom a'\n\ngoal (1 subgoal):\n 1. hatom_of_fatom ` ground_fatoms = UNIV", "then"], ["proof (chain)\npicking this:\n  \\<forall>a.\n     \\<exists>a'.\n        ground\\<^sub>t\\<^sub>s (snd a') \\<and> a = hatom_of_fatom a'", "show \"hatom_of_fatom ` ground_fatoms = UNIV\""], ["proof (prove)\nusing this:\n  \\<forall>a.\n     \\<exists>a'.\n        ground\\<^sub>t\\<^sub>s (snd a') \\<and> a = hatom_of_fatom a'\n\ngoal (1 subgoal):\n 1. hatom_of_fatom ` ground_fatoms = UNIV", "unfolding ground_fatoms_def"], ["proof (prove)\nusing this:\n  \\<forall>a.\n     \\<exists>a'.\n        ground\\<^sub>t\\<^sub>s (snd a') \\<and> a = hatom_of_fatom a'\n\ngoal (1 subgoal):\n 1. hatom_of_fatom ` {a. ground\\<^sub>t\\<^sub>s (snd a)} = UNIV", "by blast"], ["proof (state)\nthis:\n  hatom_of_fatom ` ground_fatoms = UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fatom_of_hatom_bij: \"bij_betw fatom_of_hatom UNIV ground_fatoms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw fatom_of_hatom UNIV ground_fatoms", "unfolding bij_betw_def inj_on_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>UNIV.\n        \\<forall>y\\<in>UNIV.\n           fatom_of_hatom x = fatom_of_hatom y \\<longrightarrow>\n           x = y) \\<and>\n    range fatom_of_hatom = ground_fatoms", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>UNIV.\n       \\<forall>y\\<in>UNIV.\n          fatom_of_hatom x = fatom_of_hatom y \\<longrightarrow> x = y\n 2. range fatom_of_hatom = ground_fatoms", "show \"\\<forall>x\\<in>UNIV. \\<forall>y\\<in>UNIV. fatom_of_hatom x = fatom_of_hatom y \\<longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>UNIV.\n       \\<forall>y\\<in>UNIV.\n          fatom_of_hatom x = fatom_of_hatom y \\<longrightarrow> x = y", "using ground_fatom_of_hatom hatom_of_fatom_fatom_of_hatom"], ["proof (prove)\nusing this:\n  ground\\<^sub>t\\<^sub>s (snd (fatom_of_hatom ?a))\n  hatom_of_fatom (fatom_of_hatom ?l) = ?l\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>UNIV.\n       \\<forall>y\\<in>UNIV.\n          fatom_of_hatom x = fatom_of_hatom y \\<longrightarrow> x = y", "by metis"], ["proof (state)\nthis:\n  \\<forall>x\\<in>UNIV.\n     \\<forall>y\\<in>UNIV.\n        fatom_of_hatom x = fatom_of_hatom y \\<longrightarrow> x = y\n\ngoal (1 subgoal):\n 1. range fatom_of_hatom = ground_fatoms", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. range fatom_of_hatom = ground_fatoms", "have \"\\<forall>a. ground\\<^sub>t\\<^sub>s (snd a) \\<longrightarrow> (a = fatom_of_hatom (hatom_of_fatom a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a.\n       ground\\<^sub>t\\<^sub>s (snd a) \\<longrightarrow>\n       a = fatom_of_hatom (hatom_of_fatom a)", "using hatom_of_fatom_fatom_of_hatom"], ["proof (prove)\nusing this:\n  hatom_of_fatom (fatom_of_hatom ?l) = ?l\n\ngoal (1 subgoal):\n 1. \\<forall>a.\n       ground\\<^sub>t\\<^sub>s (snd a) \\<longrightarrow>\n       a = fatom_of_hatom (hatom_of_fatom a)", "by auto"], ["proof (state)\nthis:\n  \\<forall>a.\n     ground\\<^sub>t\\<^sub>s (snd a) \\<longrightarrow>\n     a = fatom_of_hatom (hatom_of_fatom a)\n\ngoal (1 subgoal):\n 1. range fatom_of_hatom = ground_fatoms", "then"], ["proof (chain)\npicking this:\n  \\<forall>a.\n     ground\\<^sub>t\\<^sub>s (snd a) \\<longrightarrow>\n     a = fatom_of_hatom (hatom_of_fatom a)", "have \"ground_fatoms  \\<subseteq> fatom_of_hatom ` UNIV \""], ["proof (prove)\nusing this:\n  \\<forall>a.\n     ground\\<^sub>t\\<^sub>s (snd a) \\<longrightarrow>\n     a = fatom_of_hatom (hatom_of_fatom a)\n\ngoal (1 subgoal):\n 1. ground_fatoms \\<subseteq> range fatom_of_hatom", "unfolding ground_fatoms_def"], ["proof (prove)\nusing this:\n  \\<forall>a.\n     ground\\<^sub>t\\<^sub>s (snd a) \\<longrightarrow>\n     a = fatom_of_hatom (hatom_of_fatom a)\n\ngoal (1 subgoal):\n 1. {a. ground\\<^sub>t\\<^sub>s (snd a)} \\<subseteq> range fatom_of_hatom", "by blast"], ["proof (state)\nthis:\n  ground_fatoms \\<subseteq> range fatom_of_hatom\n\ngoal (1 subgoal):\n 1. range fatom_of_hatom = ground_fatoms", "moreover"], ["proof (state)\nthis:\n  ground_fatoms \\<subseteq> range fatom_of_hatom\n\ngoal (1 subgoal):\n 1. range fatom_of_hatom = ground_fatoms", "have \"\\<forall>l. ground\\<^sub>t\\<^sub>s (snd (fatom_of_hatom l))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>l. ground\\<^sub>t\\<^sub>s (snd (fatom_of_hatom l))", "using ground_fatom_of_hatom"], ["proof (prove)\nusing this:\n  ground\\<^sub>t\\<^sub>s (snd (fatom_of_hatom ?a))\n\ngoal (1 subgoal):\n 1. \\<forall>l. ground\\<^sub>t\\<^sub>s (snd (fatom_of_hatom l))", "by auto"], ["proof (state)\nthis:\n  \\<forall>l. ground\\<^sub>t\\<^sub>s (snd (fatom_of_hatom l))\n\ngoal (1 subgoal):\n 1. range fatom_of_hatom = ground_fatoms", "ultimately"], ["proof (chain)\npicking this:\n  ground_fatoms \\<subseteq> range fatom_of_hatom\n  \\<forall>l. ground\\<^sub>t\\<^sub>s (snd (fatom_of_hatom l))", "show \"fatom_of_hatom ` UNIV = ground_fatoms\""], ["proof (prove)\nusing this:\n  ground_fatoms \\<subseteq> range fatom_of_hatom\n  \\<forall>l. ground\\<^sub>t\\<^sub>s (snd (fatom_of_hatom l))\n\ngoal (1 subgoal):\n 1. range fatom_of_hatom = ground_fatoms", "using hatom_of_fatom_fatom_of_hatom ground_fatom_of_hatom"], ["proof (prove)\nusing this:\n  ground_fatoms \\<subseteq> range fatom_of_hatom\n  \\<forall>l. ground\\<^sub>t\\<^sub>s (snd (fatom_of_hatom l))\n  hatom_of_fatom (fatom_of_hatom ?l) = ?l\n  ground\\<^sub>t\\<^sub>s (snd (fatom_of_hatom ?a))\n\ngoal (1 subgoal):\n 1. range fatom_of_hatom = ground_fatoms", "unfolding ground_fatoms_def"], ["proof (prove)\nusing this:\n  {a. ground\\<^sub>t\\<^sub>s (snd a)} \\<subseteq> range fatom_of_hatom\n  \\<forall>l. ground\\<^sub>t\\<^sub>s (snd (fatom_of_hatom l))\n  hatom_of_fatom (fatom_of_hatom ?l) = ?l\n  ground\\<^sub>t\\<^sub>s (snd (fatom_of_hatom ?a))\n\ngoal (1 subgoal):\n 1. range fatom_of_hatom = {a. ground\\<^sub>t\\<^sub>s (snd a)}", "by auto"], ["proof (state)\nthis:\n  range fatom_of_hatom = ground_fatoms\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Enumerations\\<close>"], ["", "subsubsection \\<open>Enumerating Strings\\<close>"], ["", "definition nat_of_string:: \"string \\<Rightarrow> nat\" where\n  \"nat_of_string \\<equiv> (SOME f. bij f)\""], ["", "definition string_of_nat:: \"nat \\<Rightarrow> string\" where\n  \"string_of_nat \\<equiv> inv nat_of_string\""], ["", "lemma nat_of_string_bij: \"bij nat_of_string\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij nat_of_string", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bij nat_of_string", "have \"countable (UNIV::string set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable UNIV", "by auto"], ["proof (state)\nthis:\n  countable UNIV\n\ngoal (1 subgoal):\n 1. bij nat_of_string", "moreover"], ["proof (state)\nthis:\n  countable UNIV\n\ngoal (1 subgoal):\n 1. bij nat_of_string", "have \"infinite (UNIV::string set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite UNIV", "using infinite_UNIV_listI"], ["proof (prove)\nusing this:\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. infinite UNIV", "by auto"], ["proof (state)\nthis:\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. bij nat_of_string", "ultimately"], ["proof (chain)\npicking this:\n  countable UNIV\n  infinite UNIV", "obtain x where \"bij (x:: string \\<Rightarrow> nat)\""], ["proof (prove)\nusing this:\n  countable UNIV\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>x. bij x \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using countableE_infinite[of UNIV]"], ["proof (prove)\nusing this:\n  countable UNIV\n  infinite UNIV\n  \\<lbrakk>countable UNIV; infinite UNIV;\n   \\<And>e. bij e \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>x. bij x \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  bij x\n\ngoal (1 subgoal):\n 1. bij nat_of_string", "then"], ["proof (chain)\npicking this:\n  bij x", "show \"?thesis\""], ["proof (prove)\nusing this:\n  bij x\n\ngoal (1 subgoal):\n 1. bij nat_of_string", "unfolding nat_of_string_def"], ["proof (prove)\nusing this:\n  bij x\n\ngoal (1 subgoal):\n 1. bij (SOME f. bij f)", "using someI"], ["proof (prove)\nusing this:\n  bij x\n  ?P ?x \\<Longrightarrow> ?P (Eps ?P)\n\ngoal (1 subgoal):\n 1. bij (SOME f. bij f)", "by metis"], ["proof (state)\nthis:\n  bij nat_of_string\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma string_of_nat_bij: \"bij string_of_nat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij string_of_nat", "unfolding string_of_nat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bij (inv nat_of_string)", "using nat_of_string_bij bij_betw_inv_into"], ["proof (prove)\nusing this:\n  bij nat_of_string\n  bij_betw ?f ?A ?B \\<Longrightarrow> bij_betw (inv_into ?A ?f) ?B ?A\n\ngoal (1 subgoal):\n 1. bij (inv nat_of_string)", "by auto"], ["", "lemma nat_of_string_string_of_nat[simp]: \"nat_of_string (string_of_nat n) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_of_string (string_of_nat n) = n", "unfolding string_of_nat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_of_string (inv nat_of_string n) = n", "using nat_of_string_bij f_inv_into_f[of nat_of_string]"], ["proof (prove)\nusing this:\n  bij nat_of_string\n  \\<lbrakk>bij_betw nat_of_string ?A ?B; ?b \\<in> ?B\\<rbrakk>\n  \\<Longrightarrow> nat_of_string (inv_into ?A nat_of_string ?b) = ?b\n\ngoal (1 subgoal):\n 1. nat_of_string (inv nat_of_string n) = n", "by simp"], ["", "lemma string_of_nat_nat_of_string[simp]: \"string_of_nat (nat_of_string n) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. string_of_nat (nat_of_string n) = n", "unfolding string_of_nat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inv nat_of_string (nat_of_string n) = n", "using nat_of_string_bij inv_into_f_f[of nat_of_string]"], ["proof (prove)\nusing this:\n  bij nat_of_string\n  \\<lbrakk>bij_betw nat_of_string ?A ?B; ?a \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> inv_into ?A nat_of_string (nat_of_string ?a) = ?a\n\ngoal (1 subgoal):\n 1. inv nat_of_string (nat_of_string n) = n", "by simp"], ["", "subsubsection \\<open>Enumerating Herbrand Atoms\\<close>"], ["", "definition nat_of_hatom:: \"hterm atom \\<Rightarrow> nat\" where\n  \"nat_of_hatom \\<equiv> (SOME f. bij f)\""], ["", "definition hatom_of_nat:: \"nat \\<Rightarrow> hterm atom\" where\n  \"hatom_of_nat \\<equiv> inv nat_of_hatom\""], ["", "instantiation hterm :: countable begin"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(hterm, countable_class)", "by countable_datatype"], ["", "end"], ["", "lemma infinite_hatoms: \"infinite (UNIV :: ('t atom) set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite UNIV", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite UNIV", "let ?diago = \"\\<lambda>n. (string_of_nat n,[])\""], ["proof (state)\ngoal (1 subgoal):\n 1. infinite UNIV", "let ?undiago = \"\\<lambda>a. nat_of_string (fst a)\""], ["proof (state)\ngoal (1 subgoal):\n 1. infinite UNIV", "have \"\\<forall>n. ?undiago (?diago n) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. nat_of_string (fst (string_of_nat n, [])) = n", "using nat_of_string_string_of_nat"], ["proof (prove)\nusing this:\n  nat_of_string (string_of_nat ?n) = ?n\n\ngoal (1 subgoal):\n 1. \\<forall>n. nat_of_string (fst (string_of_nat n, [])) = n", "by auto"], ["proof (state)\nthis:\n  \\<forall>n. nat_of_string (fst (string_of_nat n, [])) = n\n\ngoal (1 subgoal):\n 1. infinite UNIV", "moreover"], ["proof (state)\nthis:\n  \\<forall>n. nat_of_string (fst (string_of_nat n, [])) = n\n\ngoal (1 subgoal):\n 1. infinite UNIV", "have \"\\<forall>n. ?diago n \\<in> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>n. (string_of_nat n, []) \\<in> UNIV", "by auto"], ["proof (state)\nthis:\n  \\<forall>n. (string_of_nat n, []) \\<in> UNIV\n\ngoal (1 subgoal):\n 1. infinite UNIV", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>n. nat_of_string (fst (string_of_nat n, [])) = n\n  \\<forall>n. (string_of_nat n, []) \\<in> UNIV", "show \"infinite (UNIV :: ('t atom) set)\""], ["proof (prove)\nusing this:\n  \\<forall>n. nat_of_string (fst (string_of_nat n, [])) = n\n  \\<forall>n. (string_of_nat n, []) \\<in> UNIV\n\ngoal (1 subgoal):\n 1. infinite UNIV", "using infinity[of ?undiago ?diago UNIV]"], ["proof (prove)\nusing this:\n  \\<forall>n. nat_of_string (fst (string_of_nat n, [])) = n\n  \\<forall>n. (string_of_nat n, []) \\<in> UNIV\n  \\<lbrakk>\\<forall>n. nat_of_string (fst (string_of_nat n, [])) = n;\n   \\<forall>n. (string_of_nat n, []) \\<in> UNIV\\<rbrakk>\n  \\<Longrightarrow> infinite UNIV\n\ngoal (1 subgoal):\n 1. infinite UNIV", "by simp"], ["proof (state)\nthis:\n  infinite UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma nat_of_hatom_bij: \"bij nat_of_hatom\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij nat_of_hatom", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. bij nat_of_hatom", "let ?S = \"UNIV :: (('t::countable) atom) set\""], ["proof (state)\ngoal (1 subgoal):\n 1. bij nat_of_hatom", "have \"countable ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. countable UNIV", "by auto"], ["proof (state)\nthis:\n  countable UNIV\n\ngoal (1 subgoal):\n 1. bij nat_of_hatom", "moreover"], ["proof (state)\nthis:\n  countable UNIV\n\ngoal (1 subgoal):\n 1. bij nat_of_hatom", "have \"infinite ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite UNIV", "using infinite_hatoms"], ["proof (prove)\nusing this:\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. infinite UNIV", "by auto"], ["proof (state)\nthis:\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. bij nat_of_hatom", "ultimately"], ["proof (chain)\npicking this:\n  countable UNIV\n  infinite UNIV", "obtain x where \"bij (x :: hterm atom \\<Rightarrow> nat)\""], ["proof (prove)\nusing this:\n  countable UNIV\n  infinite UNIV\n\ngoal (1 subgoal):\n 1. (\\<And>x. bij x \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using countableE_infinite[of ?S]"], ["proof (prove)\nusing this:\n  countable UNIV\n  infinite UNIV\n  \\<lbrakk>countable UNIV; infinite UNIV;\n   \\<And>e. bij e \\<Longrightarrow> ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>x. bij x \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  bij x\n\ngoal (1 subgoal):\n 1. bij nat_of_hatom", "then"], ["proof (chain)\npicking this:\n  bij x", "have \"bij nat_of_hatom\""], ["proof (prove)\nusing this:\n  bij x\n\ngoal (1 subgoal):\n 1. bij nat_of_hatom", "unfolding nat_of_hatom_def"], ["proof (prove)\nusing this:\n  bij x\n\ngoal (1 subgoal):\n 1. bij (SOME f. bij f)", "using someI"], ["proof (prove)\nusing this:\n  bij x\n  ?P ?x \\<Longrightarrow> ?P (Eps ?P)\n\ngoal (1 subgoal):\n 1. bij (SOME f. bij f)", "by metis"], ["proof (state)\nthis:\n  bij nat_of_hatom\n\ngoal (1 subgoal):\n 1. bij nat_of_hatom", "then"], ["proof (chain)\npicking this:\n  bij nat_of_hatom", "show \"?thesis\""], ["proof (prove)\nusing this:\n  bij nat_of_hatom\n\ngoal (1 subgoal):\n 1. bij nat_of_hatom", "unfolding bij_betw_def inj_on_def"], ["proof (prove)\nusing this:\n  (\\<forall>x\\<in>UNIV.\n      \\<forall>y\\<in>UNIV.\n         nat_of_hatom x = nat_of_hatom y \\<longrightarrow> x = y) \\<and>\n  surj nat_of_hatom\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>UNIV.\n        \\<forall>y\\<in>UNIV.\n           nat_of_hatom x = nat_of_hatom y \\<longrightarrow> x = y) \\<and>\n    surj nat_of_hatom", "unfolding nat_of_hatom_def"], ["proof (prove)\nusing this:\n  (\\<forall>x\\<in>UNIV.\n      \\<forall>y\\<in>UNIV.\n         Eps bij x = Eps bij y \\<longrightarrow> x = y) \\<and>\n  surj (SOME f. bij f)\n\ngoal (1 subgoal):\n 1. (\\<forall>x\\<in>UNIV.\n        \\<forall>y\\<in>UNIV.\n           Eps bij x = Eps bij y \\<longrightarrow> x = y) \\<and>\n    surj (SOME f. bij f)", "by simp"], ["proof (state)\nthis:\n  bij nat_of_hatom\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hatom_of_nat_bij: \"bij hatom_of_nat\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij hatom_of_nat", "unfolding hatom_of_nat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. bij (inv nat_of_hatom)", "using nat_of_hatom_bij bij_betw_inv_into"], ["proof (prove)\nusing this:\n  bij nat_of_hatom\n  bij_betw ?f ?A ?B \\<Longrightarrow> bij_betw (inv_into ?A ?f) ?B ?A\n\ngoal (1 subgoal):\n 1. bij (inv nat_of_hatom)", "by auto"], ["", "lemma nat_of_hatom_hatom_of_nat[simp]: \"nat_of_hatom (hatom_of_nat n) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_of_hatom (hatom_of_nat n) = n", "unfolding hatom_of_nat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_of_hatom (inv nat_of_hatom n) = n", "using nat_of_hatom_bij f_inv_into_f[of nat_of_hatom]"], ["proof (prove)\nusing this:\n  bij nat_of_hatom\n  \\<lbrakk>bij_betw nat_of_hatom ?A ?B; ?b \\<in> ?B\\<rbrakk>\n  \\<Longrightarrow> nat_of_hatom (inv_into ?A nat_of_hatom ?b) = ?b\n\ngoal (1 subgoal):\n 1. nat_of_hatom (inv nat_of_hatom n) = n", "by simp"], ["", "lemma hatom_of_nat_nat_of_hatom[simp]: \"hatom_of_nat (nat_of_hatom l) = l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hatom_of_nat (nat_of_hatom l) = l", "unfolding hatom_of_nat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. inv nat_of_hatom (nat_of_hatom l) = l", "using nat_of_hatom_bij inv_into_f_f[of nat_of_hatom _ UNIV]"], ["proof (prove)\nusing this:\n  bij nat_of_hatom\n  \\<lbrakk>bij_betw nat_of_hatom ?A UNIV; ?a \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> inv_into ?A nat_of_hatom (nat_of_hatom ?a) = ?a\n\ngoal (1 subgoal):\n 1. inv nat_of_hatom (nat_of_hatom l) = l", "by simp"], ["", "subsubsection \\<open>Enumerating Ground Atoms\\<close>"], ["", "definition fatom_of_nat :: \"nat \\<Rightarrow> fterm atom\" where\n  \"fatom_of_nat = (\\<lambda>n. fatom_of_hatom (hatom_of_nat n))\""], ["", "definition nat_of_fatom :: \"fterm atom \\<Rightarrow> nat\" where\n  \"nat_of_fatom = (\\<lambda>t. nat_of_hatom (hatom_of_fatom t))\""], ["", "theorem diag_undiag_fatom[simp]: \n  assumes \"ground\\<^sub>t\\<^sub>s ts\"\n  shows \"fatom_of_nat (nat_of_fatom (p,ts)) = (p,ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fatom_of_nat (nat_of_fatom (p, ts)) = (p, ts)", "using assms"], ["proof (prove)\nusing this:\n  ground\\<^sub>t\\<^sub>s ts\n\ngoal (1 subgoal):\n 1. fatom_of_nat (nat_of_fatom (p, ts)) = (p, ts)", "unfolding fatom_of_nat_def nat_of_fatom_def"], ["proof (prove)\nusing this:\n  ground\\<^sub>t\\<^sub>s ts\n\ngoal (1 subgoal):\n 1. fatom_of_hatom (hatom_of_nat (nat_of_hatom (hatom_of_fatom (p, ts)))) =\n    (p, ts)", "by auto"], ["", "theorem undiag_diag_fatom[simp]: \"nat_of_fatom (fatom_of_nat n) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_of_fatom (fatom_of_nat n) = n", "unfolding fatom_of_nat_def nat_of_fatom_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. nat_of_hatom (hatom_of_fatom (fatom_of_hatom (hatom_of_nat n))) = n", "by auto"], ["", "lemma fatom_of_nat_bij: \"bij_betw fatom_of_nat UNIV ground_fatoms\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw fatom_of_nat UNIV ground_fatoms", "using hatom_of_nat_bij bij_betw_trans fatom_of_hatom_bij hatom_of_nat_bij"], ["proof (prove)\nusing this:\n  bij hatom_of_nat\n  \\<lbrakk>bij_betw ?f ?A ?B; bij_betw ?g ?B ?C\\<rbrakk>\n  \\<Longrightarrow> bij_betw (?g \\<circ> ?f) ?A ?C\n  bij_betw fatom_of_hatom UNIV ground_fatoms\n  bij hatom_of_nat\n\ngoal (1 subgoal):\n 1. bij_betw fatom_of_nat UNIV ground_fatoms", "unfolding fatom_of_nat_def comp_def"], ["proof (prove)\nusing this:\n  bij hatom_of_nat\n  \\<lbrakk>bij_betw ?f ?A ?B; bij_betw ?g ?B ?C\\<rbrakk>\n  \\<Longrightarrow> bij_betw (\\<lambda>x. ?g (?f x)) ?A ?C\n  bij_betw fatom_of_hatom UNIV ground_fatoms\n  bij hatom_of_nat\n\ngoal (1 subgoal):\n 1. bij_betw (\\<lambda>n. fatom_of_hatom (hatom_of_nat n)) UNIV\n     ground_fatoms", "by blast"], ["", "lemma ground_fatom_of_nat: \"ground\\<^sub>t\\<^sub>s (snd (fatom_of_nat x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ground\\<^sub>t\\<^sub>s (snd (fatom_of_nat x))", "unfolding fatom_of_nat_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ground\\<^sub>t\\<^sub>s (snd (fatom_of_hatom (hatom_of_nat x)))", "using ground_fatom_of_hatom"], ["proof (prove)\nusing this:\n  ground\\<^sub>t\\<^sub>s (snd (fatom_of_hatom ?a))\n\ngoal (1 subgoal):\n 1. ground\\<^sub>t\\<^sub>s (snd (fatom_of_hatom (hatom_of_nat x)))", "by auto"], ["", "lemma nat_of_fatom_bij: \"bij_betw nat_of_fatom ground_fatoms UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw nat_of_fatom ground_fatoms UNIV", "using nat_of_hatom_bij bij_betw_trans hatom_of_fatom_bij hatom_of_nat_bij"], ["proof (prove)\nusing this:\n  bij nat_of_hatom\n  \\<lbrakk>bij_betw ?f ?A ?B; bij_betw ?g ?B ?C\\<rbrakk>\n  \\<Longrightarrow> bij_betw (?g \\<circ> ?f) ?A ?C\n  bij_betw hatom_of_fatom ground_fatoms UNIV\n  bij hatom_of_nat\n\ngoal (1 subgoal):\n 1. bij_betw nat_of_fatom ground_fatoms UNIV", "unfolding nat_of_fatom_def comp_def"], ["proof (prove)\nusing this:\n  bij nat_of_hatom\n  \\<lbrakk>bij_betw ?f ?A ?B; bij_betw ?g ?B ?C\\<rbrakk>\n  \\<Longrightarrow> bij_betw (\\<lambda>x. ?g (?f x)) ?A ?C\n  bij_betw hatom_of_fatom ground_fatoms UNIV\n  bij hatom_of_nat\n\ngoal (1 subgoal):\n 1. bij_betw (\\<lambda>t. nat_of_hatom (hatom_of_fatom t)) ground_fatoms\n     UNIV", "by blast"], ["", "end"]]}