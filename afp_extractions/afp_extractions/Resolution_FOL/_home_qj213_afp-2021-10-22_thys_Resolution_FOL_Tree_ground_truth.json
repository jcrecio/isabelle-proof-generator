{"file_name": "/home/qj213/afp-2021-10-22/thys/Resolution_FOL/Tree.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Resolution_FOL", "problem_names": ["lemma treesize_Leaf:\n  assumes \"treesize T = 0\"\n  shows \"T = Leaf\"", "lemma treesize_Branching:\n  assumes \"treesize T = Suc n\"\n  shows \"\\<exists>l r. T = Branching l r\"", "lemma path_inv_Leaf: \"path p Leaf \\<longleftrightarrow> p = []\"", "lemma path_inv_Cons: \"path (a#ds) T \\<longrightarrow> (\\<exists>l r. T=Branching l r)\"", "lemma path_inv_Branching_Left: \"path (Left#p) (Branching l r) \\<longleftrightarrow> path p l\"", "lemma path_inv_Branching_Right: \"path (Right#p) (Branching l r) \\<longleftrightarrow> path p r\"", "lemma path_inv_Branching: \n  \"path p (Branching l r) \\<longleftrightarrow> (p=[] \\<or> (\\<exists>a p'. p=a#p'\\<and> (a \\<longrightarrow> path p' l) \\<and> (\\<not>a \\<longrightarrow> path p' r)))\" (is \"?L \\<longleftrightarrow> ?R\")", "lemma path_prefix: \n  assumes \"path (ds1@ds2) T\"\n  shows \"path ds1 T\"", "lemma has_branch: \"\\<exists>b. branch b T\"", "lemma branch_inv_Leaf: \"branch b Leaf \\<longleftrightarrow> b = []\"", "lemma branch_inv_Branching_Left:  \n  \"branch (Left#b) (Branching l r) \\<longleftrightarrow> branch b l\"", "lemma branch_inv_Branching_Right: \n  \"branch (Right#b) (Branching l r) \\<longleftrightarrow> branch b r\"", "lemma branch_inv_Branching: \n  \"branch b (Branching l r) \\<longleftrightarrow> \n     (\\<exists>a b'. b=a#b'\\<and> (a \\<longrightarrow> branch b' l) \\<and> (\\<not>a \\<longrightarrow>  branch b' r))\"", "lemma branch_inv_Leaf2:\n  \"T = Leaf \\<longleftrightarrow> (\\<forall>b. branch b T \\<longrightarrow> b = [])\"", "lemma branch_is_path: \n  assumes\"branch ds T\"\n  shows \"path ds T\"", "lemma Branching_Leaf_Leaf_Tree:\n  assumes \"T = Branching T1 T2\"\n  shows \"(\\<exists>B. branch (B@[True]) T \\<and> branch (B@[False]) T)\"", "lemma internal_inv_Leaf: \"\\<not>internal b Leaf\"", "lemma internal_inv_Branching_Left:  \n  \"internal (Left#b) (Branching l r) \\<longleftrightarrow> internal b l\"", "lemma internal_inv_Branching_Right: \n  \"internal (Right#b) (Branching l r) \\<longleftrightarrow> internal b r\"", "lemma internal_inv_Branching: \n  \"internal p (Branching l r) \\<longleftrightarrow> (p=[] \\<or> (\\<exists>a p'. p=a#p'\\<and> (a \\<longrightarrow> internal p' l) \\<and> (\\<not>a \\<longrightarrow> internal p' r)))\" (is \"?L \\<longleftrightarrow> ?R\")", "lemma internal_is_path: \n  assumes \"internal ds T\"\n  shows \"path ds T\"", "lemma internal_prefix:\n  assumes \"internal (ds1@ds2@[d]) T\"\n  shows \"internal ds1 T\"", "lemma internal_branch:\n  assumes \"branch (ds1@ds2@[d]) T\"\n  shows \"internal ds1 T\"", "lemma delete_Leaf: \"delete T Leaf = Leaf\"", "lemma path_delete: \n  assumes \"path p (delete ds T)\"\n  shows \"path p T \"", "lemma branch_delete:\n  assumes \"branch p (delete ds T)\"\n  shows \"branch p T \\<or> p=ds\"", "lemma branch_delete_postfix: \n  assumes \"path p (delete ds T)\"\n  shows \"\\<not>(\\<exists>c cs. p = ds @ c#cs)\"", "lemma treezise_delete: \n  assumes \"internal p T\"\n  shows \"treesize (delete p T) < treesize T\"", "lemma treesize_cutoff: \"treesize (cutoff red ds T) \\<le> treesize T\"", "lemma cutoff_branch': \n  assumes \"anybranch T (\\<lambda>b. red(ds@b))\"\n  shows \"anybranch (cutoff red ds T) (\\<lambda>b. red(ds@b))\"", "lemma cutoff_branch: \n  assumes \"anybranch T (\\<lambda>p. red p)\"\n  shows \"anybranch (cutoff red [] T) (\\<lambda>p. red p)\"", "lemma cutoff_internal': \n  assumes \"anybranch T (\\<lambda>b. red(ds@b))\" \n  shows \"anyinternal (cutoff red ds T) (\\<lambda>b. \\<not>red(ds@b))\"", "lemma cutoff_internal:\n  assumes  \"anybranch T red\"\n  shows \"anyinternal (cutoff red [] T) (\\<lambda>p. \\<not>red p)\"", "lemma cutoff_branch_internal': \n  assumes \"anybranch T red\"\n  shows \"anyinternal (cutoff red [] T) (\\<lambda>p. \\<not>red p) \\<and> anybranch (cutoff red [] T) (\\<lambda>p. red p)\"", "lemma cutoff_branch_internal: \n  assumes \"anybranch T red\"\n  shows \"\\<exists>T'. anyinternal T' (\\<lambda>p. \\<not>red p) \\<and> anybranch T' (\\<lambda>p. red p)\"", "lemma subtree_pos: \n  \"subtree T ds \\<subseteq> subtree T (ds @ [Left]) \\<union> subtree T (ds @ [Right]) \\<union> {ds}\"", "lemma infpath_length:\n  assumes \"wf_infpath f\"\n  shows \"length (f n) = n\"", "lemma chain_prefix: \n  assumes \"wf_infpath f\"\n  assumes \"n\\<^sub>1 \\<le> n\\<^sub>2\"\n  shows \"\\<exists>a. (f n\\<^sub>1) @ a = (f n\\<^sub>2)\"", "lemma ith_in_extension:\n  assumes chain: \"wf_infpath f\"\n  assumes smalli: \"i < length (f n\\<^sub>1)\"\n  assumes n\\<^sub>1n\\<^sub>2: \"n\\<^sub>1 \\<le> n\\<^sub>2\"\n  shows \"f n\\<^sub>1 ! i = f n\\<^sub>2 ! i\"", "lemma inf_subs: \n  assumes inf: \"\\<not>finite(subtree T ds)\"\n  shows \"\\<not>finite(subtree T (ds @ [Left])) \\<or> \\<not>finite(subtree T (ds @ [Right]))\"", "lemma konig:\n  assumes inf: \"\\<not>finite T\"\n  assumes wellformed: \"wf_tree T\"\n  shows \"\\<exists>c. wf_infpath c \\<and> (\\<forall>n. (c n) \\<in> T)\""], "translations": [["", "lemma treesize_Leaf:\n  assumes \"treesize T = 0\"\n  shows \"T = Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T = Leaf", "using assms"], ["proof (prove)\nusing this:\n  treesize T = 0\n\ngoal (1 subgoal):\n 1. T = Leaf", "by (cases T) auto"], ["", "lemma treesize_Branching:\n  assumes \"treesize T = Suc n\"\n  shows \"\\<exists>l r. T = Branching l r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>l r. T = Branching l r", "using assms"], ["proof (prove)\nusing this:\n  treesize T = Suc n\n\ngoal (1 subgoal):\n 1. \\<exists>l r. T = Branching l r", "by (cases T) auto"], ["", "subsection \\<open>Paths\\<close>"], ["", "fun path :: \"dir list \\<Rightarrow> tree \\<Rightarrow> bool\" where\n  \"path [] T \\<longleftrightarrow> True\"\n| \"path (d#ds) (Branching T1 T2) \\<longleftrightarrow> (if d then path ds T1 else path ds T2)\"\n| \"path _ _ \\<longleftrightarrow> False\""], ["", "lemma path_inv_Leaf: \"path p Leaf \\<longleftrightarrow> p = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path p Leaf = (p = [])", "by (induction p)  auto"], ["", "lemma path_inv_Cons: \"path (a#ds) T \\<longrightarrow> (\\<exists>l r. T=Branching l r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (a # ds) T \\<longrightarrow> (\\<exists>l r. T = Branching l r)", "by  (cases T) (auto simp add: path_inv_Leaf)"], ["", "lemma path_inv_Branching_Left: \"path (Left#p) (Branching l r) \\<longleftrightarrow> path p l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (Left # p) (Branching l r) = path p l", "using Left_def Right_def path.cases"], ["proof (prove)\nusing this:\n  Left = True\n  Right = False\n  \\<lbrakk>\\<And>T. ?x = ([], T) \\<Longrightarrow> ?P;\n   \\<And>d ds T1 T2. ?x = (d # ds, Branching T1 T2) \\<Longrightarrow> ?P;\n   \\<And>v va. ?x = (v # va, Leaf) \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. path (Left # p) (Branching l r) = path p l", "by (induction p) auto"], ["", "lemma path_inv_Branching_Right: \"path (Right#p) (Branching l r) \\<longleftrightarrow> path p r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (Right # p) (Branching l r) = path p r", "using Left_def Right_def path.cases"], ["proof (prove)\nusing this:\n  Left = True\n  Right = False\n  \\<lbrakk>\\<And>T. ?x = ([], T) \\<Longrightarrow> ?P;\n   \\<And>d ds T1 T2. ?x = (d # ds, Branching T1 T2) \\<Longrightarrow> ?P;\n   \\<And>v va. ?x = (v # va, Leaf) \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. path (Right # p) (Branching l r) = path p r", "by (induction p)  auto"], ["", "lemma path_inv_Branching: \n  \"path p (Branching l r) \\<longleftrightarrow> (p=[] \\<or> (\\<exists>a p'. p=a#p'\\<and> (a \\<longrightarrow> path p' l) \\<and> (\\<not>a \\<longrightarrow> path p' r)))\" (is \"?L \\<longleftrightarrow> ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. path p (Branching l r) =\n    (p = [] \\<or>\n     (\\<exists>a p'.\n         p = a # p' \\<and>\n         (a \\<longrightarrow> path p' l) \\<and>\n         (\\<not> a \\<longrightarrow> path p' r)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. path p (Branching l r) \\<Longrightarrow>\n    p = [] \\<or>\n    (\\<exists>a p'.\n        p = a # p' \\<and>\n        (a \\<longrightarrow> path p' l) \\<and>\n        (\\<not> a \\<longrightarrow> path p' r))\n 2. p = [] \\<or>\n    (\\<exists>a p'.\n        p = a # p' \\<and>\n        (a \\<longrightarrow> path p' l) \\<and>\n        (\\<not> a \\<longrightarrow> path p' r)) \\<Longrightarrow>\n    path p (Branching l r)", "assume ?L"], ["proof (state)\nthis:\n  path p (Branching l r)\n\ngoal (2 subgoals):\n 1. path p (Branching l r) \\<Longrightarrow>\n    p = [] \\<or>\n    (\\<exists>a p'.\n        p = a # p' \\<and>\n        (a \\<longrightarrow> path p' l) \\<and>\n        (\\<not> a \\<longrightarrow> path p' r))\n 2. p = [] \\<or>\n    (\\<exists>a p'.\n        p = a # p' \\<and>\n        (a \\<longrightarrow> path p' l) \\<and>\n        (\\<not> a \\<longrightarrow> path p' r)) \\<Longrightarrow>\n    path p (Branching l r)", "then"], ["proof (chain)\npicking this:\n  path p (Branching l r)", "show ?R"], ["proof (prove)\nusing this:\n  path p (Branching l r)\n\ngoal (1 subgoal):\n 1. p = [] \\<or>\n    (\\<exists>a p'.\n        p = a # p' \\<and>\n        (a \\<longrightarrow> path p' l) \\<and>\n        (\\<not> a \\<longrightarrow> path p' r))", "by (induction p) auto"], ["proof (state)\nthis:\n  p = [] \\<or>\n  (\\<exists>a p'.\n      p = a # p' \\<and>\n      (a \\<longrightarrow> path p' l) \\<and>\n      (\\<not> a \\<longrightarrow> path p' r))\n\ngoal (1 subgoal):\n 1. p = [] \\<or>\n    (\\<exists>a p'.\n        p = a # p' \\<and>\n        (a \\<longrightarrow> path p' l) \\<and>\n        (\\<not> a \\<longrightarrow> path p' r)) \\<Longrightarrow>\n    path p (Branching l r)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p = [] \\<or>\n    (\\<exists>a p'.\n        p = a # p' \\<and>\n        (a \\<longrightarrow> path p' l) \\<and>\n        (\\<not> a \\<longrightarrow> path p' r)) \\<Longrightarrow>\n    path p (Branching l r)", "assume r: ?R"], ["proof (state)\nthis:\n  p = [] \\<or>\n  (\\<exists>a p'.\n      p = a # p' \\<and>\n      (a \\<longrightarrow> path p' l) \\<and>\n      (\\<not> a \\<longrightarrow> path p' r))\n\ngoal (1 subgoal):\n 1. p = [] \\<or>\n    (\\<exists>a p'.\n        p = a # p' \\<and>\n        (a \\<longrightarrow> path p' l) \\<and>\n        (\\<not> a \\<longrightarrow> path p' r)) \\<Longrightarrow>\n    path p (Branching l r)", "then"], ["proof (chain)\npicking this:\n  p = [] \\<or>\n  (\\<exists>a p'.\n      p = a # p' \\<and>\n      (a \\<longrightarrow> path p' l) \\<and>\n      (\\<not> a \\<longrightarrow> path p' r))", "show ?L"], ["proof (prove)\nusing this:\n  p = [] \\<or>\n  (\\<exists>a p'.\n      p = a # p' \\<and>\n      (a \\<longrightarrow> path p' l) \\<and>\n      (\\<not> a \\<longrightarrow> path p' r))\n\ngoal (1 subgoal):\n 1. path p (Branching l r)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow> path p (Branching l r)\n 2. \\<exists>a p'.\n       p = a # p' \\<and>\n       (a \\<longrightarrow> path p' l) \\<and>\n       (\\<not> a \\<longrightarrow> path p' r) \\<Longrightarrow>\n    path p (Branching l r)", "assume \"p = []\""], ["proof (state)\nthis:\n  p = []\n\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow> path p (Branching l r)\n 2. \\<exists>a p'.\n       p = a # p' \\<and>\n       (a \\<longrightarrow> path p' l) \\<and>\n       (\\<not> a \\<longrightarrow> path p' r) \\<Longrightarrow>\n    path p (Branching l r)", "then"], ["proof (chain)\npicking this:\n  p = []", "show ?L"], ["proof (prove)\nusing this:\n  p = []\n\ngoal (1 subgoal):\n 1. path p (Branching l r)", "by auto"], ["proof (state)\nthis:\n  path p (Branching l r)\n\ngoal (1 subgoal):\n 1. \\<exists>a p'.\n       p = a # p' \\<and>\n       (a \\<longrightarrow> path p' l) \\<and>\n       (\\<not> a \\<longrightarrow> path p' r) \\<Longrightarrow>\n    path p (Branching l r)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a p'.\n       p = a # p' \\<and>\n       (a \\<longrightarrow> path p' l) \\<and>\n       (\\<not> a \\<longrightarrow> path p' r) \\<Longrightarrow>\n    path p (Branching l r)", "assume \"\\<exists>a p'. p=a#p'\\<and> (a \\<longrightarrow> path p' l) \\<and> (\\<not>a \\<longrightarrow> path p' r)\""], ["proof (state)\nthis:\n  \\<exists>a p'.\n     p = a # p' \\<and>\n     (a \\<longrightarrow> path p' l) \\<and>\n     (\\<not> a \\<longrightarrow> path p' r)\n\ngoal (1 subgoal):\n 1. \\<exists>a p'.\n       p = a # p' \\<and>\n       (a \\<longrightarrow> path p' l) \\<and>\n       (\\<not> a \\<longrightarrow> path p' r) \\<Longrightarrow>\n    path p (Branching l r)", "then"], ["proof (chain)\npicking this:\n  \\<exists>a p'.\n     p = a # p' \\<and>\n     (a \\<longrightarrow> path p' l) \\<and>\n     (\\<not> a \\<longrightarrow> path p' r)", "obtain a p' where \"p=a#p'\\<and> (a \\<longrightarrow> path p' l) \\<and> (\\<not>a \\<longrightarrow> path p' r)\""], ["proof (prove)\nusing this:\n  \\<exists>a p'.\n     p = a # p' \\<and>\n     (a \\<longrightarrow> path p' l) \\<and>\n     (\\<not> a \\<longrightarrow> path p' r)\n\ngoal (1 subgoal):\n 1. (\\<And>a p'.\n        p = a # p' \\<and>\n        (a \\<longrightarrow> path p' l) \\<and>\n        (\\<not> a \\<longrightarrow> path p' r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p = a # p' \\<and>\n  (a \\<longrightarrow> path p' l) \\<and>\n  (\\<not> a \\<longrightarrow> path p' r)\n\ngoal (1 subgoal):\n 1. \\<exists>a p'.\n       p = a # p' \\<and>\n       (a \\<longrightarrow> path p' l) \\<and>\n       (\\<not> a \\<longrightarrow> path p' r) \\<Longrightarrow>\n    path p (Branching l r)", "then"], ["proof (chain)\npicking this:\n  p = a # p' \\<and>\n  (a \\<longrightarrow> path p' l) \\<and>\n  (\\<not> a \\<longrightarrow> path p' r)", "show ?L"], ["proof (prove)\nusing this:\n  p = a # p' \\<and>\n  (a \\<longrightarrow> path p' l) \\<and>\n  (\\<not> a \\<longrightarrow> path p' r)\n\ngoal (1 subgoal):\n 1. path p (Branching l r)", "by (cases a) auto"], ["proof (state)\nthis:\n  path p (Branching l r)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  path p (Branching l r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma path_prefix: \n  assumes \"path (ds1@ds2) T\"\n  shows \"path ds1 T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path ds1 T", "using assms"], ["proof (prove)\nusing this:\n  path (ds1 @ ds2) T\n\ngoal (1 subgoal):\n 1. path ds1 T", "proof (induction ds1 arbitrary: T)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>T. path ([] @ ds2) T \\<Longrightarrow> path [] T\n 2. \\<And>a ds1 T.\n       \\<lbrakk>\\<And>T. path (ds1 @ ds2) T \\<Longrightarrow> path ds1 T;\n        path ((a # ds1) @ ds2) T\\<rbrakk>\n       \\<Longrightarrow> path (a # ds1) T", "case (Cons a ds1)"], ["proof (state)\nthis:\n  path (ds1 @ ds2) ?T \\<Longrightarrow> path ds1 ?T\n  path ((a # ds1) @ ds2) T\n\ngoal (2 subgoals):\n 1. \\<And>T. path ([] @ ds2) T \\<Longrightarrow> path [] T\n 2. \\<And>a ds1 T.\n       \\<lbrakk>\\<And>T. path (ds1 @ ds2) T \\<Longrightarrow> path ds1 T;\n        path ((a # ds1) @ ds2) T\\<rbrakk>\n       \\<Longrightarrow> path (a # ds1) T", "then"], ["proof (chain)\npicking this:\n  path (ds1 @ ds2) ?T \\<Longrightarrow> path ds1 ?T\n  path ((a # ds1) @ ds2) T", "have \"\\<exists>l r. T = Branching l r\""], ["proof (prove)\nusing this:\n  path (ds1 @ ds2) ?T \\<Longrightarrow> path ds1 ?T\n  path ((a # ds1) @ ds2) T\n\ngoal (1 subgoal):\n 1. \\<exists>l r. T = Branching l r", "using path_inv_Leaf"], ["proof (prove)\nusing this:\n  path (ds1 @ ds2) ?T \\<Longrightarrow> path ds1 ?T\n  path ((a # ds1) @ ds2) T\n  path ?p Leaf = (?p = [])\n\ngoal (1 subgoal):\n 1. \\<exists>l r. T = Branching l r", "by (cases T) auto"], ["proof (state)\nthis:\n  \\<exists>l r. T = Branching l r\n\ngoal (2 subgoals):\n 1. \\<And>T. path ([] @ ds2) T \\<Longrightarrow> path [] T\n 2. \\<And>a ds1 T.\n       \\<lbrakk>\\<And>T. path (ds1 @ ds2) T \\<Longrightarrow> path ds1 T;\n        path ((a # ds1) @ ds2) T\\<rbrakk>\n       \\<Longrightarrow> path (a # ds1) T", "then"], ["proof (chain)\npicking this:\n  \\<exists>l r. T = Branching l r", "obtain l r where p_lr: \"T = Branching l r\""], ["proof (prove)\nusing this:\n  \\<exists>l r. T = Branching l r\n\ngoal (1 subgoal):\n 1. (\\<And>l r.\n        T = Branching l r \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  T = Branching l r\n\ngoal (2 subgoals):\n 1. \\<And>T. path ([] @ ds2) T \\<Longrightarrow> path [] T\n 2. \\<And>a ds1 T.\n       \\<lbrakk>\\<And>T. path (ds1 @ ds2) T \\<Longrightarrow> path ds1 T;\n        path ((a # ds1) @ ds2) T\\<rbrakk>\n       \\<Longrightarrow> path (a # ds1) T", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. path (a # ds1) T", "proof (cases a)"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<Longrightarrow> path (a # ds1) T\n 2. \\<not> a \\<Longrightarrow> path (a # ds1) T", "assume atrue: \"a\""], ["proof (state)\nthis:\n  a\n\ngoal (2 subgoals):\n 1. a \\<Longrightarrow> path (a # ds1) T\n 2. \\<not> a \\<Longrightarrow> path (a # ds1) T", "then"], ["proof (chain)\npicking this:\n  a", "have \"path ((ds1) @ ds2) l\""], ["proof (prove)\nusing this:\n  a\n\ngoal (1 subgoal):\n 1. path (ds1 @ ds2) l", "using p_lr Cons(2) path_inv_Branching"], ["proof (prove)\nusing this:\n  a\n  T = Branching l r\n  path ((a # ds1) @ ds2) T\n  path ?p (Branching ?l ?r) =\n  (?p = [] \\<or>\n   (\\<exists>a p'.\n       ?p = a # p' \\<and>\n       (a \\<longrightarrow> path p' ?l) \\<and>\n       (\\<not> a \\<longrightarrow> path p' ?r)))\n\ngoal (1 subgoal):\n 1. path (ds1 @ ds2) l", "by auto"], ["proof (state)\nthis:\n  path (ds1 @ ds2) l\n\ngoal (2 subgoals):\n 1. a \\<Longrightarrow> path (a # ds1) T\n 2. \\<not> a \\<Longrightarrow> path (a # ds1) T", "then"], ["proof (chain)\npicking this:\n  path (ds1 @ ds2) l", "have \"path ds1 l\""], ["proof (prove)\nusing this:\n  path (ds1 @ ds2) l\n\ngoal (1 subgoal):\n 1. path ds1 l", "using Cons(1)"], ["proof (prove)\nusing this:\n  path (ds1 @ ds2) l\n  path (ds1 @ ds2) ?T \\<Longrightarrow> path ds1 ?T\n\ngoal (1 subgoal):\n 1. path ds1 l", "by auto"], ["proof (state)\nthis:\n  path ds1 l\n\ngoal (2 subgoals):\n 1. a \\<Longrightarrow> path (a # ds1) T\n 2. \\<not> a \\<Longrightarrow> path (a # ds1) T", "then"], ["proof (chain)\npicking this:\n  path ds1 l", "show \"path (a # ds1) T\""], ["proof (prove)\nusing this:\n  path ds1 l\n\ngoal (1 subgoal):\n 1. path (a # ds1) T", "using p_lr atrue"], ["proof (prove)\nusing this:\n  path ds1 l\n  T = Branching l r\n  a\n\ngoal (1 subgoal):\n 1. path (a # ds1) T", "by auto"], ["proof (state)\nthis:\n  path (a # ds1) T\n\ngoal (1 subgoal):\n 1. \\<not> a \\<Longrightarrow> path (a # ds1) T", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> a \\<Longrightarrow> path (a # ds1) T", "assume afalse: \"\\<not>a\""], ["proof (state)\nthis:\n  \\<not> a\n\ngoal (1 subgoal):\n 1. \\<not> a \\<Longrightarrow> path (a # ds1) T", "then"], ["proof (chain)\npicking this:\n  \\<not> a", "have \"path ((ds1) @ ds2) r\""], ["proof (prove)\nusing this:\n  \\<not> a\n\ngoal (1 subgoal):\n 1. path (ds1 @ ds2) r", "using p_lr Cons(2) path_inv_Branching"], ["proof (prove)\nusing this:\n  \\<not> a\n  T = Branching l r\n  path ((a # ds1) @ ds2) T\n  path ?p (Branching ?l ?r) =\n  (?p = [] \\<or>\n   (\\<exists>a p'.\n       ?p = a # p' \\<and>\n       (a \\<longrightarrow> path p' ?l) \\<and>\n       (\\<not> a \\<longrightarrow> path p' ?r)))\n\ngoal (1 subgoal):\n 1. path (ds1 @ ds2) r", "by auto"], ["proof (state)\nthis:\n  path (ds1 @ ds2) r\n\ngoal (1 subgoal):\n 1. \\<not> a \\<Longrightarrow> path (a # ds1) T", "then"], ["proof (chain)\npicking this:\n  path (ds1 @ ds2) r", "have \"path ds1 r\""], ["proof (prove)\nusing this:\n  path (ds1 @ ds2) r\n\ngoal (1 subgoal):\n 1. path ds1 r", "using Cons(1)"], ["proof (prove)\nusing this:\n  path (ds1 @ ds2) r\n  path (ds1 @ ds2) ?T \\<Longrightarrow> path ds1 ?T\n\ngoal (1 subgoal):\n 1. path ds1 r", "by auto"], ["proof (state)\nthis:\n  path ds1 r\n\ngoal (1 subgoal):\n 1. \\<not> a \\<Longrightarrow> path (a # ds1) T", "then"], ["proof (chain)\npicking this:\n  path ds1 r", "show \"path (a # ds1) T\""], ["proof (prove)\nusing this:\n  path ds1 r\n\ngoal (1 subgoal):\n 1. path (a # ds1) T", "using p_lr afalse"], ["proof (prove)\nusing this:\n  path ds1 r\n  T = Branching l r\n  \\<not> a\n\ngoal (1 subgoal):\n 1. path (a # ds1) T", "by auto"], ["proof (state)\nthis:\n  path (a # ds1) T\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  path (a # ds1) T\n\ngoal (1 subgoal):\n 1. \\<And>T. path ([] @ ds2) T \\<Longrightarrow> path [] T", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T. path ([] @ ds2) T \\<Longrightarrow> path [] T", "case (Nil)"], ["proof (state)\nthis:\n  path ([] @ ds2) T\n\ngoal (1 subgoal):\n 1. \\<And>T. path ([] @ ds2) T \\<Longrightarrow> path [] T", "then"], ["proof (chain)\npicking this:\n  path ([] @ ds2) T", "show ?case"], ["proof (prove)\nusing this:\n  path ([] @ ds2) T\n\ngoal (1 subgoal):\n 1. path [] T", "by auto"], ["proof (state)\nthis:\n  path [] T\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Branches\\<close>"], ["", "fun branch :: \"dir list \\<Rightarrow> tree \\<Rightarrow> bool\" where\n  \"branch [] Leaf \\<longleftrightarrow> True\"    \n| \"branch (d # ds) (Branching l r) \\<longleftrightarrow> (if d then branch ds l else branch ds r)\"\n| \"branch _ _ \\<longleftrightarrow> False\""], ["", "lemma has_branch: \"\\<exists>b. branch b T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b. branch b T", "proof (induction T)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>b. branch b Leaf\n 2. \\<And>T1 T2.\n       \\<lbrakk>\\<exists>b. branch b T1; \\<exists>b. branch b T2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b. branch b (Branching T1 T2)", "case (Leaf)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<exists>b. branch b Leaf\n 2. \\<And>T1 T2.\n       \\<lbrakk>\\<exists>b. branch b T1; \\<exists>b. branch b T2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b. branch b (Branching T1 T2)", "have \"branch [] Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. branch [] Leaf", "by auto"], ["proof (state)\nthis:\n  branch [] Leaf\n\ngoal (2 subgoals):\n 1. \\<exists>b. branch b Leaf\n 2. \\<And>T1 T2.\n       \\<lbrakk>\\<exists>b. branch b T1; \\<exists>b. branch b T2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b. branch b (Branching T1 T2)", "then"], ["proof (chain)\npicking this:\n  branch [] Leaf", "show ?case"], ["proof (prove)\nusing this:\n  branch [] Leaf\n\ngoal (1 subgoal):\n 1. \\<exists>b. branch b Leaf", "by blast"], ["proof (state)\nthis:\n  \\<exists>b. branch b Leaf\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2.\n       \\<lbrakk>\\<exists>b. branch b T1; \\<exists>b. branch b T2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b. branch b (Branching T1 T2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T1 T2.\n       \\<lbrakk>\\<exists>b. branch b T1; \\<exists>b. branch b T2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b. branch b (Branching T1 T2)", "case (Branching T\\<^sub>1 T\\<^sub>2)"], ["proof (state)\nthis:\n  \\<exists>b. branch b T\\<^sub>1\n  \\<exists>b. branch b T\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2.\n       \\<lbrakk>\\<exists>b. branch b T1; \\<exists>b. branch b T2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b. branch b (Branching T1 T2)", "then"], ["proof (chain)\npicking this:\n  \\<exists>b. branch b T\\<^sub>1\n  \\<exists>b. branch b T\\<^sub>2", "obtain b where \"branch b T\\<^sub>1\""], ["proof (prove)\nusing this:\n  \\<exists>b. branch b T\\<^sub>1\n  \\<exists>b. branch b T\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>b. branch b T\\<^sub>1 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  branch b T\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2.\n       \\<lbrakk>\\<exists>b. branch b T1; \\<exists>b. branch b T2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b. branch b (Branching T1 T2)", "then"], ["proof (chain)\npicking this:\n  branch b T\\<^sub>1", "have \"branch (Left#b) (Branching T\\<^sub>1 T\\<^sub>2)\""], ["proof (prove)\nusing this:\n  branch b T\\<^sub>1\n\ngoal (1 subgoal):\n 1. branch (Left # b) (Branching T\\<^sub>1 T\\<^sub>2)", "by auto"], ["proof (state)\nthis:\n  branch (Left # b) (Branching T\\<^sub>1 T\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2.\n       \\<lbrakk>\\<exists>b. branch b T1; \\<exists>b. branch b T2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>b. branch b (Branching T1 T2)", "then"], ["proof (chain)\npicking this:\n  branch (Left # b) (Branching T\\<^sub>1 T\\<^sub>2)", "show ?case"], ["proof (prove)\nusing this:\n  branch (Left # b) (Branching T\\<^sub>1 T\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<exists>b. branch b (Branching T\\<^sub>1 T\\<^sub>2)", "by blast"], ["proof (state)\nthis:\n  \\<exists>b. branch b (Branching T\\<^sub>1 T\\<^sub>2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma branch_inv_Leaf: \"branch b Leaf \\<longleftrightarrow> b = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. branch b Leaf = (b = [])", "by (cases b) auto"], ["", "lemma branch_inv_Branching_Left:  \n  \"branch (Left#b) (Branching l r) \\<longleftrightarrow> branch b l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. branch (Left # b) (Branching l r) = branch b l", "by auto"], ["", "lemma branch_inv_Branching_Right: \n  \"branch (Right#b) (Branching l r) \\<longleftrightarrow> branch b r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. branch (Right # b) (Branching l r) = branch b r", "by auto"], ["", "lemma branch_inv_Branching: \n  \"branch b (Branching l r) \\<longleftrightarrow> \n     (\\<exists>a b'. b=a#b'\\<and> (a \\<longrightarrow> branch b' l) \\<and> (\\<not>a \\<longrightarrow>  branch b' r))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. branch b (Branching l r) =\n    (\\<exists>a b'.\n        b = a # b' \\<and>\n        (a \\<longrightarrow> branch b' l) \\<and>\n        (\\<not> a \\<longrightarrow> branch b' r))", "by (induction b) auto"], ["", "lemma branch_inv_Leaf2:\n  \"T = Leaf \\<longleftrightarrow> (\\<forall>b. branch b T \\<longrightarrow> b = [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (T = Leaf) = (\\<forall>b. branch b T \\<longrightarrow> b = [])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (T = Leaf) = (\\<forall>b. branch b T \\<longrightarrow> b = [])", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (T = Leaf) = (\\<forall>b. branch b T \\<longrightarrow> b = [])", "assume \"T=Leaf\""], ["proof (state)\nthis:\n  T = Leaf\n\ngoal (1 subgoal):\n 1. (T = Leaf) = (\\<forall>b. branch b T \\<longrightarrow> b = [])", "then"], ["proof (chain)\npicking this:\n  T = Leaf", "have \"\\<forall>b. branch b T \\<longrightarrow> b = []\""], ["proof (prove)\nusing this:\n  T = Leaf\n\ngoal (1 subgoal):\n 1. \\<forall>b. branch b T \\<longrightarrow> b = []", "using branch_inv_Leaf"], ["proof (prove)\nusing this:\n  T = Leaf\n  branch ?b Leaf = (?b = [])\n\ngoal (1 subgoal):\n 1. \\<forall>b. branch b T \\<longrightarrow> b = []", "by auto"], ["proof (state)\nthis:\n  \\<forall>b. branch b T \\<longrightarrow> b = []\n\ngoal (1 subgoal):\n 1. (T = Leaf) = (\\<forall>b. branch b T \\<longrightarrow> b = [])", "}"], ["proof (state)\nthis:\n  T = Leaf \\<Longrightarrow> \\<forall>b. branch b T \\<longrightarrow> b = []\n\ngoal (1 subgoal):\n 1. (T = Leaf) = (\\<forall>b. branch b T \\<longrightarrow> b = [])", "moreover"], ["proof (state)\nthis:\n  T = Leaf \\<Longrightarrow> \\<forall>b. branch b T \\<longrightarrow> b = []\n\ngoal (1 subgoal):\n 1. (T = Leaf) = (\\<forall>b. branch b T \\<longrightarrow> b = [])", "{"], ["proof (state)\nthis:\n  T = Leaf \\<Longrightarrow> \\<forall>b. branch b T \\<longrightarrow> b = []\n\ngoal (1 subgoal):\n 1. (T = Leaf) = (\\<forall>b. branch b T \\<longrightarrow> b = [])", "assume \"\\<forall>b. branch b T \\<longrightarrow> b = []\""], ["proof (state)\nthis:\n  \\<forall>b. branch b T \\<longrightarrow> b = []\n\ngoal (1 subgoal):\n 1. (T = Leaf) = (\\<forall>b. branch b T \\<longrightarrow> b = [])", "then"], ["proof (chain)\npicking this:\n  \\<forall>b. branch b T \\<longrightarrow> b = []", "have \"\\<forall>b. branch b T \\<longrightarrow> \\<not>(\\<exists>a b'. b = a # b')\""], ["proof (prove)\nusing this:\n  \\<forall>b. branch b T \\<longrightarrow> b = []\n\ngoal (1 subgoal):\n 1. \\<forall>b. branch b T \\<longrightarrow> (\\<nexists>a b'. b = a # b')", "by auto"], ["proof (state)\nthis:\n  \\<forall>b. branch b T \\<longrightarrow> (\\<nexists>a b'. b = a # b')\n\ngoal (1 subgoal):\n 1. (T = Leaf) = (\\<forall>b. branch b T \\<longrightarrow> b = [])", "then"], ["proof (chain)\npicking this:\n  \\<forall>b. branch b T \\<longrightarrow> (\\<nexists>a b'. b = a # b')", "have \"\\<forall>b. branch b T \\<longrightarrow> \\<not>(\\<exists>l r. branch b (Branching l r))\""], ["proof (prove)\nusing this:\n  \\<forall>b. branch b T \\<longrightarrow> (\\<nexists>a b'. b = a # b')\n\ngoal (1 subgoal):\n 1. \\<forall>b.\n       branch b T \\<longrightarrow>\n       (\\<nexists>l r. branch b (Branching l r))", "using branch_inv_Branching"], ["proof (prove)\nusing this:\n  \\<forall>b. branch b T \\<longrightarrow> (\\<nexists>a b'. b = a # b')\n  branch ?b (Branching ?l ?r) =\n  (\\<exists>a b'.\n      ?b = a # b' \\<and>\n      (a \\<longrightarrow> branch b' ?l) \\<and>\n      (\\<not> a \\<longrightarrow> branch b' ?r))\n\ngoal (1 subgoal):\n 1. \\<forall>b.\n       branch b T \\<longrightarrow>\n       (\\<nexists>l r. branch b (Branching l r))", "by auto"], ["proof (state)\nthis:\n  \\<forall>b.\n     branch b T \\<longrightarrow> (\\<nexists>l r. branch b (Branching l r))\n\ngoal (1 subgoal):\n 1. (T = Leaf) = (\\<forall>b. branch b T \\<longrightarrow> b = [])", "then"], ["proof (chain)\npicking this:\n  \\<forall>b.\n     branch b T \\<longrightarrow> (\\<nexists>l r. branch b (Branching l r))", "have \"T=Leaf\""], ["proof (prove)\nusing this:\n  \\<forall>b.\n     branch b T \\<longrightarrow> (\\<nexists>l r. branch b (Branching l r))\n\ngoal (1 subgoal):\n 1. T = Leaf", "using has_branch[of T]"], ["proof (prove)\nusing this:\n  \\<forall>b.\n     branch b T \\<longrightarrow> (\\<nexists>l r. branch b (Branching l r))\n  \\<exists>b. branch b T\n\ngoal (1 subgoal):\n 1. T = Leaf", "by (metis branch.elims(2))"], ["proof (state)\nthis:\n  T = Leaf\n\ngoal (1 subgoal):\n 1. (T = Leaf) = (\\<forall>b. branch b T \\<longrightarrow> b = [])", "}"], ["proof (state)\nthis:\n  \\<forall>b. branch b T \\<longrightarrow> b = [] \\<Longrightarrow> T = Leaf\n\ngoal (1 subgoal):\n 1. (T = Leaf) = (\\<forall>b. branch b T \\<longrightarrow> b = [])", "ultimately"], ["proof (chain)\npicking this:\n  T = Leaf \\<Longrightarrow> \\<forall>b. branch b T \\<longrightarrow> b = []\n  \\<forall>b. branch b T \\<longrightarrow> b = [] \\<Longrightarrow> T = Leaf", "show \"T = Leaf \\<longleftrightarrow> (\\<forall>b. branch b T \\<longrightarrow> b = [])\""], ["proof (prove)\nusing this:\n  T = Leaf \\<Longrightarrow> \\<forall>b. branch b T \\<longrightarrow> b = []\n  \\<forall>b. branch b T \\<longrightarrow> b = [] \\<Longrightarrow> T = Leaf\n\ngoal (1 subgoal):\n 1. (T = Leaf) = (\\<forall>b. branch b T \\<longrightarrow> b = [])", "by auto"], ["proof (state)\nthis:\n  (T = Leaf) = (\\<forall>b. branch b T \\<longrightarrow> b = [])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma branch_is_path: \n  assumes\"branch ds T\"\n  shows \"path ds T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path ds T", "using assms"], ["proof (prove)\nusing this:\n  branch ds T\n\ngoal (1 subgoal):\n 1. path ds T", "proof (induction T arbitrary: ds)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ds. branch ds Leaf \\<Longrightarrow> path ds Leaf\n 2. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds. branch ds T1 \\<Longrightarrow> path ds T1;\n        \\<And>ds. branch ds T2 \\<Longrightarrow> path ds T2;\n        branch ds (Branching T1 T2)\\<rbrakk>\n       \\<Longrightarrow> path ds (Branching T1 T2)", "case Leaf"], ["proof (state)\nthis:\n  branch ds Leaf\n\ngoal (2 subgoals):\n 1. \\<And>ds. branch ds Leaf \\<Longrightarrow> path ds Leaf\n 2. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds. branch ds T1 \\<Longrightarrow> path ds T1;\n        \\<And>ds. branch ds T2 \\<Longrightarrow> path ds T2;\n        branch ds (Branching T1 T2)\\<rbrakk>\n       \\<Longrightarrow> path ds (Branching T1 T2)", "then"], ["proof (chain)\npicking this:\n  branch ds Leaf", "have \"ds = []\""], ["proof (prove)\nusing this:\n  branch ds Leaf\n\ngoal (1 subgoal):\n 1. ds = []", "using branch_inv_Leaf"], ["proof (prove)\nusing this:\n  branch ds Leaf\n  branch ?b Leaf = (?b = [])\n\ngoal (1 subgoal):\n 1. ds = []", "by auto"], ["proof (state)\nthis:\n  ds = []\n\ngoal (2 subgoals):\n 1. \\<And>ds. branch ds Leaf \\<Longrightarrow> path ds Leaf\n 2. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds. branch ds T1 \\<Longrightarrow> path ds T1;\n        \\<And>ds. branch ds T2 \\<Longrightarrow> path ds T2;\n        branch ds (Branching T1 T2)\\<rbrakk>\n       \\<Longrightarrow> path ds (Branching T1 T2)", "then"], ["proof (chain)\npicking this:\n  ds = []", "show ?case"], ["proof (prove)\nusing this:\n  ds = []\n\ngoal (1 subgoal):\n 1. path ds Leaf", "by auto"], ["proof (state)\nthis:\n  path ds Leaf\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds. branch ds T1 \\<Longrightarrow> path ds T1;\n        \\<And>ds. branch ds T2 \\<Longrightarrow> path ds T2;\n        branch ds (Branching T1 T2)\\<rbrakk>\n       \\<Longrightarrow> path ds (Branching T1 T2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds. branch ds T1 \\<Longrightarrow> path ds T1;\n        \\<And>ds. branch ds T2 \\<Longrightarrow> path ds T2;\n        branch ds (Branching T1 T2)\\<rbrakk>\n       \\<Longrightarrow> path ds (Branching T1 T2)", "case (Branching T\\<^sub>1 T\\<^sub>2)"], ["proof (state)\nthis:\n  branch ?ds T\\<^sub>1 \\<Longrightarrow> path ?ds T\\<^sub>1\n  branch ?ds T\\<^sub>2 \\<Longrightarrow> path ?ds T\\<^sub>2\n  branch ds (Branching T\\<^sub>1 T\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds. branch ds T1 \\<Longrightarrow> path ds T1;\n        \\<And>ds. branch ds T2 \\<Longrightarrow> path ds T2;\n        branch ds (Branching T1 T2)\\<rbrakk>\n       \\<Longrightarrow> path ds (Branching T1 T2)", "then"], ["proof (chain)\npicking this:\n  branch ?ds T\\<^sub>1 \\<Longrightarrow> path ?ds T\\<^sub>1\n  branch ?ds T\\<^sub>2 \\<Longrightarrow> path ?ds T\\<^sub>2\n  branch ds (Branching T\\<^sub>1 T\\<^sub>2)", "obtain a b where ds_p: \"ds = a # b \\<and> (a \\<longrightarrow> branch b T\\<^sub>1) \\<and> (\\<not> a \\<longrightarrow> branch b T\\<^sub>2)\""], ["proof (prove)\nusing this:\n  branch ?ds T\\<^sub>1 \\<Longrightarrow> path ?ds T\\<^sub>1\n  branch ?ds T\\<^sub>2 \\<Longrightarrow> path ?ds T\\<^sub>2\n  branch ds (Branching T\\<^sub>1 T\\<^sub>2)\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        ds = a # b \\<and>\n        (a \\<longrightarrow> branch b T\\<^sub>1) \\<and>\n        (\\<not> a \\<longrightarrow> branch b T\\<^sub>2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using branch_inv_Branching[of ds]"], ["proof (prove)\nusing this:\n  branch ?ds T\\<^sub>1 \\<Longrightarrow> path ?ds T\\<^sub>1\n  branch ?ds T\\<^sub>2 \\<Longrightarrow> path ?ds T\\<^sub>2\n  branch ds (Branching T\\<^sub>1 T\\<^sub>2)\n  branch ds (Branching ?l ?r) =\n  (\\<exists>a b'.\n      ds = a # b' \\<and>\n      (a \\<longrightarrow> branch b' ?l) \\<and>\n      (\\<not> a \\<longrightarrow> branch b' ?r))\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        ds = a # b \\<and>\n        (a \\<longrightarrow> branch b T\\<^sub>1) \\<and>\n        (\\<not> a \\<longrightarrow> branch b T\\<^sub>2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ds = a # b \\<and>\n  (a \\<longrightarrow> branch b T\\<^sub>1) \\<and>\n  (\\<not> a \\<longrightarrow> branch b T\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds. branch ds T1 \\<Longrightarrow> path ds T1;\n        \\<And>ds. branch ds T2 \\<Longrightarrow> path ds T2;\n        branch ds (Branching T1 T2)\\<rbrakk>\n       \\<Longrightarrow> path ds (Branching T1 T2)", "then"], ["proof (chain)\npicking this:\n  ds = a # b \\<and>\n  (a \\<longrightarrow> branch b T\\<^sub>1) \\<and>\n  (\\<not> a \\<longrightarrow> branch b T\\<^sub>2)", "have \"(a \\<longrightarrow> path b T\\<^sub>1) \\<and> (\\<not>a \\<longrightarrow> path b T\\<^sub>2)\""], ["proof (prove)\nusing this:\n  ds = a # b \\<and>\n  (a \\<longrightarrow> branch b T\\<^sub>1) \\<and>\n  (\\<not> a \\<longrightarrow> branch b T\\<^sub>2)\n\ngoal (1 subgoal):\n 1. (a \\<longrightarrow> path b T\\<^sub>1) \\<and>\n    (\\<not> a \\<longrightarrow> path b T\\<^sub>2)", "using Branching"], ["proof (prove)\nusing this:\n  ds = a # b \\<and>\n  (a \\<longrightarrow> branch b T\\<^sub>1) \\<and>\n  (\\<not> a \\<longrightarrow> branch b T\\<^sub>2)\n  branch ?ds T\\<^sub>1 \\<Longrightarrow> path ?ds T\\<^sub>1\n  branch ?ds T\\<^sub>2 \\<Longrightarrow> path ?ds T\\<^sub>2\n  branch ds (Branching T\\<^sub>1 T\\<^sub>2)\n\ngoal (1 subgoal):\n 1. (a \\<longrightarrow> path b T\\<^sub>1) \\<and>\n    (\\<not> a \\<longrightarrow> path b T\\<^sub>2)", "by auto"], ["proof (state)\nthis:\n  (a \\<longrightarrow> path b T\\<^sub>1) \\<and>\n  (\\<not> a \\<longrightarrow> path b T\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds. branch ds T1 \\<Longrightarrow> path ds T1;\n        \\<And>ds. branch ds T2 \\<Longrightarrow> path ds T2;\n        branch ds (Branching T1 T2)\\<rbrakk>\n       \\<Longrightarrow> path ds (Branching T1 T2)", "then"], ["proof (chain)\npicking this:\n  (a \\<longrightarrow> path b T\\<^sub>1) \\<and>\n  (\\<not> a \\<longrightarrow> path b T\\<^sub>2)", "show \"?case\""], ["proof (prove)\nusing this:\n  (a \\<longrightarrow> path b T\\<^sub>1) \\<and>\n  (\\<not> a \\<longrightarrow> path b T\\<^sub>2)\n\ngoal (1 subgoal):\n 1. path ds (Branching T\\<^sub>1 T\\<^sub>2)", "using ds_p"], ["proof (prove)\nusing this:\n  (a \\<longrightarrow> path b T\\<^sub>1) \\<and>\n  (\\<not> a \\<longrightarrow> path b T\\<^sub>2)\n  ds = a # b \\<and>\n  (a \\<longrightarrow> branch b T\\<^sub>1) \\<and>\n  (\\<not> a \\<longrightarrow> branch b T\\<^sub>2)\n\ngoal (1 subgoal):\n 1. path ds (Branching T\\<^sub>1 T\\<^sub>2)", "by (cases a) auto"], ["proof (state)\nthis:\n  path ds (Branching T\\<^sub>1 T\\<^sub>2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Branching_Leaf_Leaf_Tree:\n  assumes \"T = Branching T1 T2\"\n  shows \"(\\<exists>B. branch (B@[True]) T \\<and> branch (B@[False]) T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>B. branch (B @ [True]) T \\<and> branch (B @ [False]) T", "using assms"], ["proof (prove)\nusing this:\n  T = Branching T1 T2\n\ngoal (1 subgoal):\n 1. \\<exists>B. branch (B @ [True]) T \\<and> branch (B @ [False]) T", "proof (induction T arbitrary: T1 T2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>T1 T2.\n       Leaf = Branching T1 T2 \\<Longrightarrow>\n       \\<exists>B. branch (B @ [True]) Leaf \\<and> branch (B @ [False]) Leaf\n 2. \\<And>T1 T2 T1a T2a.\n       \\<lbrakk>\\<And>T1a T2.\n                   T1 = Branching T1a T2 \\<Longrightarrow>\n                   \\<exists>B.\n                      branch (B @ [True]) T1 \\<and> branch (B @ [False]) T1;\n        \\<And>T1 T2a.\n           T2 = Branching T1 T2a \\<Longrightarrow>\n           \\<exists>B.\n              branch (B @ [True]) T2 \\<and> branch (B @ [False]) T2;\n        Branching T1 T2 = Branching T1a T2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B.\n                            branch (B @ [True]) (Branching T1 T2) \\<and>\n                            branch (B @ [False]) (Branching T1 T2)", "case Leaf"], ["proof (state)\nthis:\n  Leaf = Branching T1 T2\n\ngoal (2 subgoals):\n 1. \\<And>T1 T2.\n       Leaf = Branching T1 T2 \\<Longrightarrow>\n       \\<exists>B. branch (B @ [True]) Leaf \\<and> branch (B @ [False]) Leaf\n 2. \\<And>T1 T2 T1a T2a.\n       \\<lbrakk>\\<And>T1a T2.\n                   T1 = Branching T1a T2 \\<Longrightarrow>\n                   \\<exists>B.\n                      branch (B @ [True]) T1 \\<and> branch (B @ [False]) T1;\n        \\<And>T1 T2a.\n           T2 = Branching T1 T2a \\<Longrightarrow>\n           \\<exists>B.\n              branch (B @ [True]) T2 \\<and> branch (B @ [False]) T2;\n        Branching T1 T2 = Branching T1a T2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B.\n                            branch (B @ [True]) (Branching T1 T2) \\<and>\n                            branch (B @ [False]) (Branching T1 T2)", "then"], ["proof (chain)\npicking this:\n  Leaf = Branching T1 T2", "show ?case"], ["proof (prove)\nusing this:\n  Leaf = Branching T1 T2\n\ngoal (1 subgoal):\n 1. \\<exists>B. branch (B @ [True]) Leaf \\<and> branch (B @ [False]) Leaf", "by auto"], ["proof (state)\nthis:\n  \\<exists>B. branch (B @ [True]) Leaf \\<and> branch (B @ [False]) Leaf\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 T1a T2a.\n       \\<lbrakk>\\<And>T1a T2.\n                   T1 = Branching T1a T2 \\<Longrightarrow>\n                   \\<exists>B.\n                      branch (B @ [True]) T1 \\<and> branch (B @ [False]) T1;\n        \\<And>T1 T2a.\n           T2 = Branching T1 T2a \\<Longrightarrow>\n           \\<exists>B.\n              branch (B @ [True]) T2 \\<and> branch (B @ [False]) T2;\n        Branching T1 T2 = Branching T1a T2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B.\n                            branch (B @ [True]) (Branching T1 T2) \\<and>\n                            branch (B @ [False]) (Branching T1 T2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T1 T2 T1a T2a.\n       \\<lbrakk>\\<And>T1a T2.\n                   T1 = Branching T1a T2 \\<Longrightarrow>\n                   \\<exists>B.\n                      branch (B @ [True]) T1 \\<and> branch (B @ [False]) T1;\n        \\<And>T1 T2a.\n           T2 = Branching T1 T2a \\<Longrightarrow>\n           \\<exists>B.\n              branch (B @ [True]) T2 \\<and> branch (B @ [False]) T2;\n        Branching T1 T2 = Branching T1a T2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B.\n                            branch (B @ [True]) (Branching T1 T2) \\<and>\n                            branch (B @ [False]) (Branching T1 T2)", "case (Branching T1' T2')"], ["proof (state)\nthis:\n  T1' = Branching ?T1.0 ?T2.0 \\<Longrightarrow>\n  \\<exists>B. branch (B @ [True]) T1' \\<and> branch (B @ [False]) T1'\n  T2' = Branching ?T1.0 ?T2.0 \\<Longrightarrow>\n  \\<exists>B. branch (B @ [True]) T2' \\<and> branch (B @ [False]) T2'\n  Branching T1' T2' = Branching T1 T2\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 T1a T2a.\n       \\<lbrakk>\\<And>T1a T2.\n                   T1 = Branching T1a T2 \\<Longrightarrow>\n                   \\<exists>B.\n                      branch (B @ [True]) T1 \\<and> branch (B @ [False]) T1;\n        \\<And>T1 T2a.\n           T2 = Branching T1 T2a \\<Longrightarrow>\n           \\<exists>B.\n              branch (B @ [True]) T2 \\<and> branch (B @ [False]) T2;\n        Branching T1 T2 = Branching T1a T2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B.\n                            branch (B @ [True]) (Branching T1 T2) \\<and>\n                            branch (B @ [False]) (Branching T1 T2)", "{"], ["proof (state)\nthis:\n  T1' = Branching ?T1.0 ?T2.0 \\<Longrightarrow>\n  \\<exists>B. branch (B @ [True]) T1' \\<and> branch (B @ [False]) T1'\n  T2' = Branching ?T1.0 ?T2.0 \\<Longrightarrow>\n  \\<exists>B. branch (B @ [True]) T2' \\<and> branch (B @ [False]) T2'\n  Branching T1' T2' = Branching T1 T2\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 T1a T2a.\n       \\<lbrakk>\\<And>T1a T2.\n                   T1 = Branching T1a T2 \\<Longrightarrow>\n                   \\<exists>B.\n                      branch (B @ [True]) T1 \\<and> branch (B @ [False]) T1;\n        \\<And>T1 T2a.\n           T2 = Branching T1 T2a \\<Longrightarrow>\n           \\<exists>B.\n              branch (B @ [True]) T2 \\<and> branch (B @ [False]) T2;\n        Branching T1 T2 = Branching T1a T2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B.\n                            branch (B @ [True]) (Branching T1 T2) \\<and>\n                            branch (B @ [False]) (Branching T1 T2)", "assume \"T1'=Leaf \\<and> T2'=Leaf\""], ["proof (state)\nthis:\n  T1' = Leaf \\<and> T2' = Leaf\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 T1a T2a.\n       \\<lbrakk>\\<And>T1a T2.\n                   T1 = Branching T1a T2 \\<Longrightarrow>\n                   \\<exists>B.\n                      branch (B @ [True]) T1 \\<and> branch (B @ [False]) T1;\n        \\<And>T1 T2a.\n           T2 = Branching T1 T2a \\<Longrightarrow>\n           \\<exists>B.\n              branch (B @ [True]) T2 \\<and> branch (B @ [False]) T2;\n        Branching T1 T2 = Branching T1a T2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B.\n                            branch (B @ [True]) (Branching T1 T2) \\<and>\n                            branch (B @ [False]) (Branching T1 T2)", "then"], ["proof (chain)\npicking this:\n  T1' = Leaf \\<and> T2' = Leaf", "have \"branch ([] @ [True]) (Branching T1' T2') \\<and> branch ([] @ [False]) (Branching T1' T2')\""], ["proof (prove)\nusing this:\n  T1' = Leaf \\<and> T2' = Leaf\n\ngoal (1 subgoal):\n 1. branch ([] @ [True]) (Branching T1' T2') \\<and>\n    branch ([] @ [False]) (Branching T1' T2')", "by auto"], ["proof (state)\nthis:\n  branch ([] @ [True]) (Branching T1' T2') \\<and>\n  branch ([] @ [False]) (Branching T1' T2')\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 T1a T2a.\n       \\<lbrakk>\\<And>T1a T2.\n                   T1 = Branching T1a T2 \\<Longrightarrow>\n                   \\<exists>B.\n                      branch (B @ [True]) T1 \\<and> branch (B @ [False]) T1;\n        \\<And>T1 T2a.\n           T2 = Branching T1 T2a \\<Longrightarrow>\n           \\<exists>B.\n              branch (B @ [True]) T2 \\<and> branch (B @ [False]) T2;\n        Branching T1 T2 = Branching T1a T2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B.\n                            branch (B @ [True]) (Branching T1 T2) \\<and>\n                            branch (B @ [False]) (Branching T1 T2)", "then"], ["proof (chain)\npicking this:\n  branch ([] @ [True]) (Branching T1' T2') \\<and>\n  branch ([] @ [False]) (Branching T1' T2')", "have ?case"], ["proof (prove)\nusing this:\n  branch ([] @ [True]) (Branching T1' T2') \\<and>\n  branch ([] @ [False]) (Branching T1' T2')\n\ngoal (1 subgoal):\n 1. \\<exists>B.\n       branch (B @ [True]) (Branching T1' T2') \\<and>\n       branch (B @ [False]) (Branching T1' T2')", "by metis"], ["proof (state)\nthis:\n  \\<exists>B.\n     branch (B @ [True]) (Branching T1' T2') \\<and>\n     branch (B @ [False]) (Branching T1' T2')\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 T1a T2a.\n       \\<lbrakk>\\<And>T1a T2.\n                   T1 = Branching T1a T2 \\<Longrightarrow>\n                   \\<exists>B.\n                      branch (B @ [True]) T1 \\<and> branch (B @ [False]) T1;\n        \\<And>T1 T2a.\n           T2 = Branching T1 T2a \\<Longrightarrow>\n           \\<exists>B.\n              branch (B @ [True]) T2 \\<and> branch (B @ [False]) T2;\n        Branching T1 T2 = Branching T1a T2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B.\n                            branch (B @ [True]) (Branching T1 T2) \\<and>\n                            branch (B @ [False]) (Branching T1 T2)", "}"], ["proof (state)\nthis:\n  T1' = Leaf \\<and> T2' = Leaf \\<Longrightarrow>\n  \\<exists>B.\n     branch (B @ [True]) (Branching T1' T2') \\<and>\n     branch (B @ [False]) (Branching T1' T2')\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 T1a T2a.\n       \\<lbrakk>\\<And>T1a T2.\n                   T1 = Branching T1a T2 \\<Longrightarrow>\n                   \\<exists>B.\n                      branch (B @ [True]) T1 \\<and> branch (B @ [False]) T1;\n        \\<And>T1 T2a.\n           T2 = Branching T1 T2a \\<Longrightarrow>\n           \\<exists>B.\n              branch (B @ [True]) T2 \\<and> branch (B @ [False]) T2;\n        Branching T1 T2 = Branching T1a T2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B.\n                            branch (B @ [True]) (Branching T1 T2) \\<and>\n                            branch (B @ [False]) (Branching T1 T2)", "moreover"], ["proof (state)\nthis:\n  T1' = Leaf \\<and> T2' = Leaf \\<Longrightarrow>\n  \\<exists>B.\n     branch (B @ [True]) (Branching T1' T2') \\<and>\n     branch (B @ [False]) (Branching T1' T2')\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 T1a T2a.\n       \\<lbrakk>\\<And>T1a T2.\n                   T1 = Branching T1a T2 \\<Longrightarrow>\n                   \\<exists>B.\n                      branch (B @ [True]) T1 \\<and> branch (B @ [False]) T1;\n        \\<And>T1 T2a.\n           T2 = Branching T1 T2a \\<Longrightarrow>\n           \\<exists>B.\n              branch (B @ [True]) T2 \\<and> branch (B @ [False]) T2;\n        Branching T1 T2 = Branching T1a T2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B.\n                            branch (B @ [True]) (Branching T1 T2) \\<and>\n                            branch (B @ [False]) (Branching T1 T2)", "{"], ["proof (state)\nthis:\n  T1' = Leaf \\<and> T2' = Leaf \\<Longrightarrow>\n  \\<exists>B.\n     branch (B @ [True]) (Branching T1' T2') \\<and>\n     branch (B @ [False]) (Branching T1' T2')\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 T1a T2a.\n       \\<lbrakk>\\<And>T1a T2.\n                   T1 = Branching T1a T2 \\<Longrightarrow>\n                   \\<exists>B.\n                      branch (B @ [True]) T1 \\<and> branch (B @ [False]) T1;\n        \\<And>T1 T2a.\n           T2 = Branching T1 T2a \\<Longrightarrow>\n           \\<exists>B.\n              branch (B @ [True]) T2 \\<and> branch (B @ [False]) T2;\n        Branching T1 T2 = Branching T1a T2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B.\n                            branch (B @ [True]) (Branching T1 T2) \\<and>\n                            branch (B @ [False]) (Branching T1 T2)", "fix T11 T12"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T1 T2 T1a T2a.\n       \\<lbrakk>\\<And>T1a T2.\n                   T1 = Branching T1a T2 \\<Longrightarrow>\n                   \\<exists>B.\n                      branch (B @ [True]) T1 \\<and> branch (B @ [False]) T1;\n        \\<And>T1 T2a.\n           T2 = Branching T1 T2a \\<Longrightarrow>\n           \\<exists>B.\n              branch (B @ [True]) T2 \\<and> branch (B @ [False]) T2;\n        Branching T1 T2 = Branching T1a T2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B.\n                            branch (B @ [True]) (Branching T1 T2) \\<and>\n                            branch (B @ [False]) (Branching T1 T2)", "assume \"T1' = Branching T11 T12\""], ["proof (state)\nthis:\n  T1' = Branching T11 T12\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 T1a T2a.\n       \\<lbrakk>\\<And>T1a T2.\n                   T1 = Branching T1a T2 \\<Longrightarrow>\n                   \\<exists>B.\n                      branch (B @ [True]) T1 \\<and> branch (B @ [False]) T1;\n        \\<And>T1 T2a.\n           T2 = Branching T1 T2a \\<Longrightarrow>\n           \\<exists>B.\n              branch (B @ [True]) T2 \\<and> branch (B @ [False]) T2;\n        Branching T1 T2 = Branching T1a T2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B.\n                            branch (B @ [True]) (Branching T1 T2) \\<and>\n                            branch (B @ [False]) (Branching T1 T2)", "then"], ["proof (chain)\npicking this:\n  T1' = Branching T11 T12", "obtain B where \"branch (B @ [True]) T1' \n                       \\<and> branch (B @ [False]) T1'\""], ["proof (prove)\nusing this:\n  T1' = Branching T11 T12\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        branch (B @ [True]) T1' \\<and>\n        branch (B @ [False]) T1' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Branching"], ["proof (prove)\nusing this:\n  T1' = Branching T11 T12\n  T1' = Branching ?T1.0 ?T2.0 \\<Longrightarrow>\n  \\<exists>B. branch (B @ [True]) T1' \\<and> branch (B @ [False]) T1'\n  T2' = Branching ?T1.0 ?T2.0 \\<Longrightarrow>\n  \\<exists>B. branch (B @ [True]) T2' \\<and> branch (B @ [False]) T2'\n  Branching T1' T2' = Branching T1 T2\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        branch (B @ [True]) T1' \\<and>\n        branch (B @ [False]) T1' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  branch (B @ [True]) T1' \\<and> branch (B @ [False]) T1'\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 T1a T2a.\n       \\<lbrakk>\\<And>T1a T2.\n                   T1 = Branching T1a T2 \\<Longrightarrow>\n                   \\<exists>B.\n                      branch (B @ [True]) T1 \\<and> branch (B @ [False]) T1;\n        \\<And>T1 T2a.\n           T2 = Branching T1 T2a \\<Longrightarrow>\n           \\<exists>B.\n              branch (B @ [True]) T2 \\<and> branch (B @ [False]) T2;\n        Branching T1 T2 = Branching T1a T2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B.\n                            branch (B @ [True]) (Branching T1 T2) \\<and>\n                            branch (B @ [False]) (Branching T1 T2)", "then"], ["proof (chain)\npicking this:\n  branch (B @ [True]) T1' \\<and> branch (B @ [False]) T1'", "have \"branch (([True] @ B) @ [True]) (Branching T1' T2') \n             \\<and> branch (([True] @ B) @ [False]) (Branching T1' T2')\""], ["proof (prove)\nusing this:\n  branch (B @ [True]) T1' \\<and> branch (B @ [False]) T1'\n\ngoal (1 subgoal):\n 1. branch (([True] @ B) @ [True]) (Branching T1' T2') \\<and>\n    branch (([True] @ B) @ [False]) (Branching T1' T2')", "by auto"], ["proof (state)\nthis:\n  branch (([True] @ B) @ [True]) (Branching T1' T2') \\<and>\n  branch (([True] @ B) @ [False]) (Branching T1' T2')\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 T1a T2a.\n       \\<lbrakk>\\<And>T1a T2.\n                   T1 = Branching T1a T2 \\<Longrightarrow>\n                   \\<exists>B.\n                      branch (B @ [True]) T1 \\<and> branch (B @ [False]) T1;\n        \\<And>T1 T2a.\n           T2 = Branching T1 T2a \\<Longrightarrow>\n           \\<exists>B.\n              branch (B @ [True]) T2 \\<and> branch (B @ [False]) T2;\n        Branching T1 T2 = Branching T1a T2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B.\n                            branch (B @ [True]) (Branching T1 T2) \\<and>\n                            branch (B @ [False]) (Branching T1 T2)", "then"], ["proof (chain)\npicking this:\n  branch (([True] @ B) @ [True]) (Branching T1' T2') \\<and>\n  branch (([True] @ B) @ [False]) (Branching T1' T2')", "have ?case"], ["proof (prove)\nusing this:\n  branch (([True] @ B) @ [True]) (Branching T1' T2') \\<and>\n  branch (([True] @ B) @ [False]) (Branching T1' T2')\n\ngoal (1 subgoal):\n 1. \\<exists>B.\n       branch (B @ [True]) (Branching T1' T2') \\<and>\n       branch (B @ [False]) (Branching T1' T2')", "by blast"], ["proof (state)\nthis:\n  \\<exists>B.\n     branch (B @ [True]) (Branching T1' T2') \\<and>\n     branch (B @ [False]) (Branching T1' T2')\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 T1a T2a.\n       \\<lbrakk>\\<And>T1a T2.\n                   T1 = Branching T1a T2 \\<Longrightarrow>\n                   \\<exists>B.\n                      branch (B @ [True]) T1 \\<and> branch (B @ [False]) T1;\n        \\<And>T1 T2a.\n           T2 = Branching T1 T2a \\<Longrightarrow>\n           \\<exists>B.\n              branch (B @ [True]) T2 \\<and> branch (B @ [False]) T2;\n        Branching T1 T2 = Branching T1a T2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B.\n                            branch (B @ [True]) (Branching T1 T2) \\<and>\n                            branch (B @ [False]) (Branching T1 T2)", "}"], ["proof (state)\nthis:\n  T1' = Branching ?T11.2 ?T12.2 \\<Longrightarrow>\n  \\<exists>B.\n     branch (B @ [True]) (Branching T1' T2') \\<and>\n     branch (B @ [False]) (Branching T1' T2')\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 T1a T2a.\n       \\<lbrakk>\\<And>T1a T2.\n                   T1 = Branching T1a T2 \\<Longrightarrow>\n                   \\<exists>B.\n                      branch (B @ [True]) T1 \\<and> branch (B @ [False]) T1;\n        \\<And>T1 T2a.\n           T2 = Branching T1 T2a \\<Longrightarrow>\n           \\<exists>B.\n              branch (B @ [True]) T2 \\<and> branch (B @ [False]) T2;\n        Branching T1 T2 = Branching T1a T2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B.\n                            branch (B @ [True]) (Branching T1 T2) \\<and>\n                            branch (B @ [False]) (Branching T1 T2)", "moreover"], ["proof (state)\nthis:\n  T1' = Branching ?T11.2 ?T12.2 \\<Longrightarrow>\n  \\<exists>B.\n     branch (B @ [True]) (Branching T1' T2') \\<and>\n     branch (B @ [False]) (Branching T1' T2')\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 T1a T2a.\n       \\<lbrakk>\\<And>T1a T2.\n                   T1 = Branching T1a T2 \\<Longrightarrow>\n                   \\<exists>B.\n                      branch (B @ [True]) T1 \\<and> branch (B @ [False]) T1;\n        \\<And>T1 T2a.\n           T2 = Branching T1 T2a \\<Longrightarrow>\n           \\<exists>B.\n              branch (B @ [True]) T2 \\<and> branch (B @ [False]) T2;\n        Branching T1 T2 = Branching T1a T2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B.\n                            branch (B @ [True]) (Branching T1 T2) \\<and>\n                            branch (B @ [False]) (Branching T1 T2)", "{"], ["proof (state)\nthis:\n  T1' = Branching ?T11.2 ?T12.2 \\<Longrightarrow>\n  \\<exists>B.\n     branch (B @ [True]) (Branching T1' T2') \\<and>\n     branch (B @ [False]) (Branching T1' T2')\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 T1a T2a.\n       \\<lbrakk>\\<And>T1a T2.\n                   T1 = Branching T1a T2 \\<Longrightarrow>\n                   \\<exists>B.\n                      branch (B @ [True]) T1 \\<and> branch (B @ [False]) T1;\n        \\<And>T1 T2a.\n           T2 = Branching T1 T2a \\<Longrightarrow>\n           \\<exists>B.\n              branch (B @ [True]) T2 \\<and> branch (B @ [False]) T2;\n        Branching T1 T2 = Branching T1a T2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B.\n                            branch (B @ [True]) (Branching T1 T2) \\<and>\n                            branch (B @ [False]) (Branching T1 T2)", "fix T11 T12"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T1 T2 T1a T2a.\n       \\<lbrakk>\\<And>T1a T2.\n                   T1 = Branching T1a T2 \\<Longrightarrow>\n                   \\<exists>B.\n                      branch (B @ [True]) T1 \\<and> branch (B @ [False]) T1;\n        \\<And>T1 T2a.\n           T2 = Branching T1 T2a \\<Longrightarrow>\n           \\<exists>B.\n              branch (B @ [True]) T2 \\<and> branch (B @ [False]) T2;\n        Branching T1 T2 = Branching T1a T2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B.\n                            branch (B @ [True]) (Branching T1 T2) \\<and>\n                            branch (B @ [False]) (Branching T1 T2)", "assume \"T2' = Branching T11 T12\""], ["proof (state)\nthis:\n  T2' = Branching T11 T12\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 T1a T2a.\n       \\<lbrakk>\\<And>T1a T2.\n                   T1 = Branching T1a T2 \\<Longrightarrow>\n                   \\<exists>B.\n                      branch (B @ [True]) T1 \\<and> branch (B @ [False]) T1;\n        \\<And>T1 T2a.\n           T2 = Branching T1 T2a \\<Longrightarrow>\n           \\<exists>B.\n              branch (B @ [True]) T2 \\<and> branch (B @ [False]) T2;\n        Branching T1 T2 = Branching T1a T2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B.\n                            branch (B @ [True]) (Branching T1 T2) \\<and>\n                            branch (B @ [False]) (Branching T1 T2)", "then"], ["proof (chain)\npicking this:\n  T2' = Branching T11 T12", "obtain B where \"branch (B @ [True]) T2' \n                       \\<and> branch (B @ [False]) T2'\""], ["proof (prove)\nusing this:\n  T2' = Branching T11 T12\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        branch (B @ [True]) T2' \\<and>\n        branch (B @ [False]) T2' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Branching"], ["proof (prove)\nusing this:\n  T2' = Branching T11 T12\n  T1' = Branching ?T1.0 ?T2.0 \\<Longrightarrow>\n  \\<exists>B. branch (B @ [True]) T1' \\<and> branch (B @ [False]) T1'\n  T2' = Branching ?T1.0 ?T2.0 \\<Longrightarrow>\n  \\<exists>B. branch (B @ [True]) T2' \\<and> branch (B @ [False]) T2'\n  Branching T1' T2' = Branching T1 T2\n\ngoal (1 subgoal):\n 1. (\\<And>B.\n        branch (B @ [True]) T2' \\<and>\n        branch (B @ [False]) T2' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  branch (B @ [True]) T2' \\<and> branch (B @ [False]) T2'\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 T1a T2a.\n       \\<lbrakk>\\<And>T1a T2.\n                   T1 = Branching T1a T2 \\<Longrightarrow>\n                   \\<exists>B.\n                      branch (B @ [True]) T1 \\<and> branch (B @ [False]) T1;\n        \\<And>T1 T2a.\n           T2 = Branching T1 T2a \\<Longrightarrow>\n           \\<exists>B.\n              branch (B @ [True]) T2 \\<and> branch (B @ [False]) T2;\n        Branching T1 T2 = Branching T1a T2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B.\n                            branch (B @ [True]) (Branching T1 T2) \\<and>\n                            branch (B @ [False]) (Branching T1 T2)", "then"], ["proof (chain)\npicking this:\n  branch (B @ [True]) T2' \\<and> branch (B @ [False]) T2'", "have \"branch (([False] @ B) @ [True]) (Branching T1' T2') \n             \\<and> branch (([False] @ B) @ [False]) (Branching T1' T2')\""], ["proof (prove)\nusing this:\n  branch (B @ [True]) T2' \\<and> branch (B @ [False]) T2'\n\ngoal (1 subgoal):\n 1. branch (([False] @ B) @ [True]) (Branching T1' T2') \\<and>\n    branch (([False] @ B) @ [False]) (Branching T1' T2')", "by auto"], ["proof (state)\nthis:\n  branch (([False] @ B) @ [True]) (Branching T1' T2') \\<and>\n  branch (([False] @ B) @ [False]) (Branching T1' T2')\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 T1a T2a.\n       \\<lbrakk>\\<And>T1a T2.\n                   T1 = Branching T1a T2 \\<Longrightarrow>\n                   \\<exists>B.\n                      branch (B @ [True]) T1 \\<and> branch (B @ [False]) T1;\n        \\<And>T1 T2a.\n           T2 = Branching T1 T2a \\<Longrightarrow>\n           \\<exists>B.\n              branch (B @ [True]) T2 \\<and> branch (B @ [False]) T2;\n        Branching T1 T2 = Branching T1a T2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B.\n                            branch (B @ [True]) (Branching T1 T2) \\<and>\n                            branch (B @ [False]) (Branching T1 T2)", "then"], ["proof (chain)\npicking this:\n  branch (([False] @ B) @ [True]) (Branching T1' T2') \\<and>\n  branch (([False] @ B) @ [False]) (Branching T1' T2')", "have ?case"], ["proof (prove)\nusing this:\n  branch (([False] @ B) @ [True]) (Branching T1' T2') \\<and>\n  branch (([False] @ B) @ [False]) (Branching T1' T2')\n\ngoal (1 subgoal):\n 1. \\<exists>B.\n       branch (B @ [True]) (Branching T1' T2') \\<and>\n       branch (B @ [False]) (Branching T1' T2')", "by blast"], ["proof (state)\nthis:\n  \\<exists>B.\n     branch (B @ [True]) (Branching T1' T2') \\<and>\n     branch (B @ [False]) (Branching T1' T2')\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 T1a T2a.\n       \\<lbrakk>\\<And>T1a T2.\n                   T1 = Branching T1a T2 \\<Longrightarrow>\n                   \\<exists>B.\n                      branch (B @ [True]) T1 \\<and> branch (B @ [False]) T1;\n        \\<And>T1 T2a.\n           T2 = Branching T1 T2a \\<Longrightarrow>\n           \\<exists>B.\n              branch (B @ [True]) T2 \\<and> branch (B @ [False]) T2;\n        Branching T1 T2 = Branching T1a T2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B.\n                            branch (B @ [True]) (Branching T1 T2) \\<and>\n                            branch (B @ [False]) (Branching T1 T2)", "}"], ["proof (state)\nthis:\n  T2' = Branching ?T11.2 ?T12.2 \\<Longrightarrow>\n  \\<exists>B.\n     branch (B @ [True]) (Branching T1' T2') \\<and>\n     branch (B @ [False]) (Branching T1' T2')\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 T1a T2a.\n       \\<lbrakk>\\<And>T1a T2.\n                   T1 = Branching T1a T2 \\<Longrightarrow>\n                   \\<exists>B.\n                      branch (B @ [True]) T1 \\<and> branch (B @ [False]) T1;\n        \\<And>T1 T2a.\n           T2 = Branching T1 T2a \\<Longrightarrow>\n           \\<exists>B.\n              branch (B @ [True]) T2 \\<and> branch (B @ [False]) T2;\n        Branching T1 T2 = Branching T1a T2a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>B.\n                            branch (B @ [True]) (Branching T1 T2) \\<and>\n                            branch (B @ [False]) (Branching T1 T2)", "ultimately"], ["proof (chain)\npicking this:\n  T1' = Leaf \\<and> T2' = Leaf \\<Longrightarrow>\n  \\<exists>B.\n     branch (B @ [True]) (Branching T1' T2') \\<and>\n     branch (B @ [False]) (Branching T1' T2')\n  T1' = Branching ?T11.2 ?T12.2 \\<Longrightarrow>\n  \\<exists>B.\n     branch (B @ [True]) (Branching T1' T2') \\<and>\n     branch (B @ [False]) (Branching T1' T2')\n  T2' = Branching ?T11.2 ?T12.2 \\<Longrightarrow>\n  \\<exists>B.\n     branch (B @ [True]) (Branching T1' T2') \\<and>\n     branch (B @ [False]) (Branching T1' T2')", "show ?case"], ["proof (prove)\nusing this:\n  T1' = Leaf \\<and> T2' = Leaf \\<Longrightarrow>\n  \\<exists>B.\n     branch (B @ [True]) (Branching T1' T2') \\<and>\n     branch (B @ [False]) (Branching T1' T2')\n  T1' = Branching ?T11.2 ?T12.2 \\<Longrightarrow>\n  \\<exists>B.\n     branch (B @ [True]) (Branching T1' T2') \\<and>\n     branch (B @ [False]) (Branching T1' T2')\n  T2' = Branching ?T11.2 ?T12.2 \\<Longrightarrow>\n  \\<exists>B.\n     branch (B @ [True]) (Branching T1' T2') \\<and>\n     branch (B @ [False]) (Branching T1' T2')\n\ngoal (1 subgoal):\n 1. \\<exists>B.\n       branch (B @ [True]) (Branching T1' T2') \\<and>\n       branch (B @ [False]) (Branching T1' T2')", "using tree.exhaust"], ["proof (prove)\nusing this:\n  T1' = Leaf \\<and> T2' = Leaf \\<Longrightarrow>\n  \\<exists>B.\n     branch (B @ [True]) (Branching T1' T2') \\<and>\n     branch (B @ [False]) (Branching T1' T2')\n  T1' = Branching ?T11.2 ?T12.2 \\<Longrightarrow>\n  \\<exists>B.\n     branch (B @ [True]) (Branching T1' T2') \\<and>\n     branch (B @ [False]) (Branching T1' T2')\n  T2' = Branching ?T11.2 ?T12.2 \\<Longrightarrow>\n  \\<exists>B.\n     branch (B @ [True]) (Branching T1' T2') \\<and>\n     branch (B @ [False]) (Branching T1' T2')\n  \\<lbrakk>?y = Leaf \\<Longrightarrow> ?P;\n   \\<And>x21 x22. ?y = Branching x21 x22 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. \\<exists>B.\n       branch (B @ [True]) (Branching T1' T2') \\<and>\n       branch (B @ [False]) (Branching T1' T2')", "by blast"], ["proof (state)\nthis:\n  \\<exists>B.\n     branch (B @ [True]) (Branching T1' T2') \\<and>\n     branch (B @ [False]) (Branching T1' T2')\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Internal Paths\\<close>"], ["", "fun internal :: \"dir list \\<Rightarrow> tree \\<Rightarrow> bool\" where\n  \"internal [] (Branching l r) \\<longleftrightarrow> True\"\n| \"internal (d#ds) (Branching l r) \\<longleftrightarrow> (if d then internal ds l else internal ds r)\"\n| \"internal _ _ \\<longleftrightarrow> False\""], ["", "lemma internal_inv_Leaf: \"\\<not>internal b Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> internal b Leaf", "using internal.simps"], ["proof (prove)\nusing this:\n  internal [] (Branching ?l ?r) = True\n  internal (?d # ?ds) (Branching ?l ?r) =\n  (if ?d then internal ?ds ?l else internal ?ds ?r)\n  internal (?v # ?va) Leaf = False\n  internal ?uu Leaf = False\n\ngoal (1 subgoal):\n 1. \\<not> internal b Leaf", "by blast"], ["", "lemma internal_inv_Branching_Left:  \n  \"internal (Left#b) (Branching l r) \\<longleftrightarrow> internal b l\""], ["proof (prove)\ngoal (1 subgoal):\n 1. internal (Left # b) (Branching l r) = internal b l", "by auto"], ["", "lemma internal_inv_Branching_Right: \n  \"internal (Right#b) (Branching l r) \\<longleftrightarrow> internal b r\""], ["proof (prove)\ngoal (1 subgoal):\n 1. internal (Right # b) (Branching l r) = internal b r", "by auto"], ["", "lemma internal_inv_Branching: \n  \"internal p (Branching l r) \\<longleftrightarrow> (p=[] \\<or> (\\<exists>a p'. p=a#p'\\<and> (a \\<longrightarrow> internal p' l) \\<and> (\\<not>a \\<longrightarrow> internal p' r)))\" (is \"?L \\<longleftrightarrow> ?R\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. internal p (Branching l r) =\n    (p = [] \\<or>\n     (\\<exists>a p'.\n         p = a # p' \\<and>\n         (a \\<longrightarrow> internal p' l) \\<and>\n         (\\<not> a \\<longrightarrow> internal p' r)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. internal p (Branching l r) \\<Longrightarrow>\n    p = [] \\<or>\n    (\\<exists>a p'.\n        p = a # p' \\<and>\n        (a \\<longrightarrow> internal p' l) \\<and>\n        (\\<not> a \\<longrightarrow> internal p' r))\n 2. p = [] \\<or>\n    (\\<exists>a p'.\n        p = a # p' \\<and>\n        (a \\<longrightarrow> internal p' l) \\<and>\n        (\\<not> a \\<longrightarrow> internal p' r)) \\<Longrightarrow>\n    internal p (Branching l r)", "assume ?L"], ["proof (state)\nthis:\n  internal p (Branching l r)\n\ngoal (2 subgoals):\n 1. internal p (Branching l r) \\<Longrightarrow>\n    p = [] \\<or>\n    (\\<exists>a p'.\n        p = a # p' \\<and>\n        (a \\<longrightarrow> internal p' l) \\<and>\n        (\\<not> a \\<longrightarrow> internal p' r))\n 2. p = [] \\<or>\n    (\\<exists>a p'.\n        p = a # p' \\<and>\n        (a \\<longrightarrow> internal p' l) \\<and>\n        (\\<not> a \\<longrightarrow> internal p' r)) \\<Longrightarrow>\n    internal p (Branching l r)", "then"], ["proof (chain)\npicking this:\n  internal p (Branching l r)", "show ?R"], ["proof (prove)\nusing this:\n  internal p (Branching l r)\n\ngoal (1 subgoal):\n 1. p = [] \\<or>\n    (\\<exists>a p'.\n        p = a # p' \\<and>\n        (a \\<longrightarrow> internal p' l) \\<and>\n        (\\<not> a \\<longrightarrow> internal p' r))", "by (metis internal.simps(2) neq_Nil_conv)"], ["proof (state)\nthis:\n  p = [] \\<or>\n  (\\<exists>a p'.\n      p = a # p' \\<and>\n      (a \\<longrightarrow> internal p' l) \\<and>\n      (\\<not> a \\<longrightarrow> internal p' r))\n\ngoal (1 subgoal):\n 1. p = [] \\<or>\n    (\\<exists>a p'.\n        p = a # p' \\<and>\n        (a \\<longrightarrow> internal p' l) \\<and>\n        (\\<not> a \\<longrightarrow> internal p' r)) \\<Longrightarrow>\n    internal p (Branching l r)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p = [] \\<or>\n    (\\<exists>a p'.\n        p = a # p' \\<and>\n        (a \\<longrightarrow> internal p' l) \\<and>\n        (\\<not> a \\<longrightarrow> internal p' r)) \\<Longrightarrow>\n    internal p (Branching l r)", "assume r: ?R"], ["proof (state)\nthis:\n  p = [] \\<or>\n  (\\<exists>a p'.\n      p = a # p' \\<and>\n      (a \\<longrightarrow> internal p' l) \\<and>\n      (\\<not> a \\<longrightarrow> internal p' r))\n\ngoal (1 subgoal):\n 1. p = [] \\<or>\n    (\\<exists>a p'.\n        p = a # p' \\<and>\n        (a \\<longrightarrow> internal p' l) \\<and>\n        (\\<not> a \\<longrightarrow> internal p' r)) \\<Longrightarrow>\n    internal p (Branching l r)", "then"], ["proof (chain)\npicking this:\n  p = [] \\<or>\n  (\\<exists>a p'.\n      p = a # p' \\<and>\n      (a \\<longrightarrow> internal p' l) \\<and>\n      (\\<not> a \\<longrightarrow> internal p' r))", "show ?L"], ["proof (prove)\nusing this:\n  p = [] \\<or>\n  (\\<exists>a p'.\n      p = a # p' \\<and>\n      (a \\<longrightarrow> internal p' l) \\<and>\n      (\\<not> a \\<longrightarrow> internal p' r))\n\ngoal (1 subgoal):\n 1. internal p (Branching l r)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow> internal p (Branching l r)\n 2. \\<exists>a p'.\n       p = a # p' \\<and>\n       (a \\<longrightarrow> internal p' l) \\<and>\n       (\\<not> a \\<longrightarrow> internal p' r) \\<Longrightarrow>\n    internal p (Branching l r)", "assume \"p = []\""], ["proof (state)\nthis:\n  p = []\n\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow> internal p (Branching l r)\n 2. \\<exists>a p'.\n       p = a # p' \\<and>\n       (a \\<longrightarrow> internal p' l) \\<and>\n       (\\<not> a \\<longrightarrow> internal p' r) \\<Longrightarrow>\n    internal p (Branching l r)", "then"], ["proof (chain)\npicking this:\n  p = []", "show ?L"], ["proof (prove)\nusing this:\n  p = []\n\ngoal (1 subgoal):\n 1. internal p (Branching l r)", "by auto"], ["proof (state)\nthis:\n  internal p (Branching l r)\n\ngoal (1 subgoal):\n 1. \\<exists>a p'.\n       p = a # p' \\<and>\n       (a \\<longrightarrow> internal p' l) \\<and>\n       (\\<not> a \\<longrightarrow> internal p' r) \\<Longrightarrow>\n    internal p (Branching l r)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a p'.\n       p = a # p' \\<and>\n       (a \\<longrightarrow> internal p' l) \\<and>\n       (\\<not> a \\<longrightarrow> internal p' r) \\<Longrightarrow>\n    internal p (Branching l r)", "assume \"\\<exists>a p'. p=a#p'\\<and> (a \\<longrightarrow> internal p' l) \\<and> (\\<not>a \\<longrightarrow> internal p' r)\""], ["proof (state)\nthis:\n  \\<exists>a p'.\n     p = a # p' \\<and>\n     (a \\<longrightarrow> internal p' l) \\<and>\n     (\\<not> a \\<longrightarrow> internal p' r)\n\ngoal (1 subgoal):\n 1. \\<exists>a p'.\n       p = a # p' \\<and>\n       (a \\<longrightarrow> internal p' l) \\<and>\n       (\\<not> a \\<longrightarrow> internal p' r) \\<Longrightarrow>\n    internal p (Branching l r)", "then"], ["proof (chain)\npicking this:\n  \\<exists>a p'.\n     p = a # p' \\<and>\n     (a \\<longrightarrow> internal p' l) \\<and>\n     (\\<not> a \\<longrightarrow> internal p' r)", "obtain a p' where \"p=a#p'\\<and> (a \\<longrightarrow> internal p' l) \\<and> (\\<not>a \\<longrightarrow> internal p' r)\""], ["proof (prove)\nusing this:\n  \\<exists>a p'.\n     p = a # p' \\<and>\n     (a \\<longrightarrow> internal p' l) \\<and>\n     (\\<not> a \\<longrightarrow> internal p' r)\n\ngoal (1 subgoal):\n 1. (\\<And>a p'.\n        p = a # p' \\<and>\n        (a \\<longrightarrow> internal p' l) \\<and>\n        (\\<not> a \\<longrightarrow> internal p' r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p = a # p' \\<and>\n  (a \\<longrightarrow> internal p' l) \\<and>\n  (\\<not> a \\<longrightarrow> internal p' r)\n\ngoal (1 subgoal):\n 1. \\<exists>a p'.\n       p = a # p' \\<and>\n       (a \\<longrightarrow> internal p' l) \\<and>\n       (\\<not> a \\<longrightarrow> internal p' r) \\<Longrightarrow>\n    internal p (Branching l r)", "then"], ["proof (chain)\npicking this:\n  p = a # p' \\<and>\n  (a \\<longrightarrow> internal p' l) \\<and>\n  (\\<not> a \\<longrightarrow> internal p' r)", "show ?L"], ["proof (prove)\nusing this:\n  p = a # p' \\<and>\n  (a \\<longrightarrow> internal p' l) \\<and>\n  (\\<not> a \\<longrightarrow> internal p' r)\n\ngoal (1 subgoal):\n 1. internal p (Branching l r)", "by (cases a) auto"], ["proof (state)\nthis:\n  internal p (Branching l r)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  internal p (Branching l r)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma internal_is_path: \n  assumes \"internal ds T\"\n  shows \"path ds T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path ds T", "using assms"], ["proof (prove)\nusing this:\n  internal ds T\n\ngoal (1 subgoal):\n 1. path ds T", "proof (induction T arbitrary: ds)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ds. internal ds Leaf \\<Longrightarrow> path ds Leaf\n 2. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds. internal ds T1 \\<Longrightarrow> path ds T1;\n        \\<And>ds. internal ds T2 \\<Longrightarrow> path ds T2;\n        internal ds (Branching T1 T2)\\<rbrakk>\n       \\<Longrightarrow> path ds (Branching T1 T2)", "case Leaf"], ["proof (state)\nthis:\n  internal ds Leaf\n\ngoal (2 subgoals):\n 1. \\<And>ds. internal ds Leaf \\<Longrightarrow> path ds Leaf\n 2. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds. internal ds T1 \\<Longrightarrow> path ds T1;\n        \\<And>ds. internal ds T2 \\<Longrightarrow> path ds T2;\n        internal ds (Branching T1 T2)\\<rbrakk>\n       \\<Longrightarrow> path ds (Branching T1 T2)", "then"], ["proof (chain)\npicking this:\n  internal ds Leaf", "have \"False\""], ["proof (prove)\nusing this:\n  internal ds Leaf\n\ngoal (1 subgoal):\n 1. False", "using internal_inv_Leaf"], ["proof (prove)\nusing this:\n  internal ds Leaf\n  \\<not> internal ?b Leaf\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>ds. internal ds Leaf \\<Longrightarrow> path ds Leaf\n 2. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds. internal ds T1 \\<Longrightarrow> path ds T1;\n        \\<And>ds. internal ds T2 \\<Longrightarrow> path ds T2;\n        internal ds (Branching T1 T2)\\<rbrakk>\n       \\<Longrightarrow> path ds (Branching T1 T2)", "then"], ["proof (chain)\npicking this:\n  False", "show ?case"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. path ds Leaf", "by auto"], ["proof (state)\nthis:\n  path ds Leaf\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds. internal ds T1 \\<Longrightarrow> path ds T1;\n        \\<And>ds. internal ds T2 \\<Longrightarrow> path ds T2;\n        internal ds (Branching T1 T2)\\<rbrakk>\n       \\<Longrightarrow> path ds (Branching T1 T2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds. internal ds T1 \\<Longrightarrow> path ds T1;\n        \\<And>ds. internal ds T2 \\<Longrightarrow> path ds T2;\n        internal ds (Branching T1 T2)\\<rbrakk>\n       \\<Longrightarrow> path ds (Branching T1 T2)", "case (Branching T\\<^sub>1 T\\<^sub>2)"], ["proof (state)\nthis:\n  internal ?ds T\\<^sub>1 \\<Longrightarrow> path ?ds T\\<^sub>1\n  internal ?ds T\\<^sub>2 \\<Longrightarrow> path ?ds T\\<^sub>2\n  internal ds (Branching T\\<^sub>1 T\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds. internal ds T1 \\<Longrightarrow> path ds T1;\n        \\<And>ds. internal ds T2 \\<Longrightarrow> path ds T2;\n        internal ds (Branching T1 T2)\\<rbrakk>\n       \\<Longrightarrow> path ds (Branching T1 T2)", "then"], ["proof (chain)\npicking this:\n  internal ?ds T\\<^sub>1 \\<Longrightarrow> path ?ds T\\<^sub>1\n  internal ?ds T\\<^sub>2 \\<Longrightarrow> path ?ds T\\<^sub>2\n  internal ds (Branching T\\<^sub>1 T\\<^sub>2)", "obtain a b where ds_p: \"ds=[] \\<or> ds = a # b \\<and> (a \\<longrightarrow> internal b T\\<^sub>1) \\<and> (\\<not> a \\<longrightarrow> internal b T\\<^sub>2)\""], ["proof (prove)\nusing this:\n  internal ?ds T\\<^sub>1 \\<Longrightarrow> path ?ds T\\<^sub>1\n  internal ?ds T\\<^sub>2 \\<Longrightarrow> path ?ds T\\<^sub>2\n  internal ds (Branching T\\<^sub>1 T\\<^sub>2)\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        ds = [] \\<or>\n        ds = a # b \\<and>\n        (a \\<longrightarrow> internal b T\\<^sub>1) \\<and>\n        (\\<not> a \\<longrightarrow> internal b T\\<^sub>2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using internal_inv_Branching"], ["proof (prove)\nusing this:\n  internal ?ds T\\<^sub>1 \\<Longrightarrow> path ?ds T\\<^sub>1\n  internal ?ds T\\<^sub>2 \\<Longrightarrow> path ?ds T\\<^sub>2\n  internal ds (Branching T\\<^sub>1 T\\<^sub>2)\n  internal ?p (Branching ?l ?r) =\n  (?p = [] \\<or>\n   (\\<exists>a p'.\n       ?p = a # p' \\<and>\n       (a \\<longrightarrow> internal p' ?l) \\<and>\n       (\\<not> a \\<longrightarrow> internal p' ?r)))\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        ds = [] \\<or>\n        ds = a # b \\<and>\n        (a \\<longrightarrow> internal b T\\<^sub>1) \\<and>\n        (\\<not> a \\<longrightarrow> internal b T\\<^sub>2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ds = [] \\<or>\n  ds = a # b \\<and>\n  (a \\<longrightarrow> internal b T\\<^sub>1) \\<and>\n  (\\<not> a \\<longrightarrow> internal b T\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds. internal ds T1 \\<Longrightarrow> path ds T1;\n        \\<And>ds. internal ds T2 \\<Longrightarrow> path ds T2;\n        internal ds (Branching T1 T2)\\<rbrakk>\n       \\<Longrightarrow> path ds (Branching T1 T2)", "then"], ["proof (chain)\npicking this:\n  ds = [] \\<or>\n  ds = a # b \\<and>\n  (a \\<longrightarrow> internal b T\\<^sub>1) \\<and>\n  (\\<not> a \\<longrightarrow> internal b T\\<^sub>2)", "have \"ds = [] \\<or> (a \\<longrightarrow> path b T\\<^sub>1) \\<and> (\\<not>a \\<longrightarrow> path b T\\<^sub>2)\""], ["proof (prove)\nusing this:\n  ds = [] \\<or>\n  ds = a # b \\<and>\n  (a \\<longrightarrow> internal b T\\<^sub>1) \\<and>\n  (\\<not> a \\<longrightarrow> internal b T\\<^sub>2)\n\ngoal (1 subgoal):\n 1. ds = [] \\<or>\n    (a \\<longrightarrow> path b T\\<^sub>1) \\<and>\n    (\\<not> a \\<longrightarrow> path b T\\<^sub>2)", "using Branching"], ["proof (prove)\nusing this:\n  ds = [] \\<or>\n  ds = a # b \\<and>\n  (a \\<longrightarrow> internal b T\\<^sub>1) \\<and>\n  (\\<not> a \\<longrightarrow> internal b T\\<^sub>2)\n  internal ?ds T\\<^sub>1 \\<Longrightarrow> path ?ds T\\<^sub>1\n  internal ?ds T\\<^sub>2 \\<Longrightarrow> path ?ds T\\<^sub>2\n  internal ds (Branching T\\<^sub>1 T\\<^sub>2)\n\ngoal (1 subgoal):\n 1. ds = [] \\<or>\n    (a \\<longrightarrow> path b T\\<^sub>1) \\<and>\n    (\\<not> a \\<longrightarrow> path b T\\<^sub>2)", "by auto"], ["proof (state)\nthis:\n  ds = [] \\<or>\n  (a \\<longrightarrow> path b T\\<^sub>1) \\<and>\n  (\\<not> a \\<longrightarrow> path b T\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds. internal ds T1 \\<Longrightarrow> path ds T1;\n        \\<And>ds. internal ds T2 \\<Longrightarrow> path ds T2;\n        internal ds (Branching T1 T2)\\<rbrakk>\n       \\<Longrightarrow> path ds (Branching T1 T2)", "then"], ["proof (chain)\npicking this:\n  ds = [] \\<or>\n  (a \\<longrightarrow> path b T\\<^sub>1) \\<and>\n  (\\<not> a \\<longrightarrow> path b T\\<^sub>2)", "show \"?case\""], ["proof (prove)\nusing this:\n  ds = [] \\<or>\n  (a \\<longrightarrow> path b T\\<^sub>1) \\<and>\n  (\\<not> a \\<longrightarrow> path b T\\<^sub>2)\n\ngoal (1 subgoal):\n 1. path ds (Branching T\\<^sub>1 T\\<^sub>2)", "using ds_p"], ["proof (prove)\nusing this:\n  ds = [] \\<or>\n  (a \\<longrightarrow> path b T\\<^sub>1) \\<and>\n  (\\<not> a \\<longrightarrow> path b T\\<^sub>2)\n  ds = [] \\<or>\n  ds = a # b \\<and>\n  (a \\<longrightarrow> internal b T\\<^sub>1) \\<and>\n  (\\<not> a \\<longrightarrow> internal b T\\<^sub>2)\n\ngoal (1 subgoal):\n 1. path ds (Branching T\\<^sub>1 T\\<^sub>2)", "by (cases a) auto"], ["proof (state)\nthis:\n  path ds (Branching T\\<^sub>1 T\\<^sub>2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma internal_prefix:\n  assumes \"internal (ds1@ds2@[d]) T\"\n  shows \"internal ds1 T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. internal ds1 T", "(* more or less copy paste of path_prefix *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. internal ds1 T", "using assms"], ["proof (prove)\nusing this:\n  internal (ds1 @ ds2 @ [d]) T\n\ngoal (1 subgoal):\n 1. internal ds1 T", "proof (induction ds1 arbitrary: T)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>T. internal ([] @ ds2 @ [d]) T \\<Longrightarrow> internal [] T\n 2. \\<And>a ds1 T.\n       \\<lbrakk>\\<And>T.\n                   internal (ds1 @ ds2 @ [d]) T \\<Longrightarrow>\n                   internal ds1 T;\n        internal ((a # ds1) @ ds2 @ [d]) T\\<rbrakk>\n       \\<Longrightarrow> internal (a # ds1) T", "case (Cons a ds1)"], ["proof (state)\nthis:\n  internal (ds1 @ ds2 @ [d]) ?T \\<Longrightarrow> internal ds1 ?T\n  internal ((a # ds1) @ ds2 @ [d]) T\n\ngoal (2 subgoals):\n 1. \\<And>T. internal ([] @ ds2 @ [d]) T \\<Longrightarrow> internal [] T\n 2. \\<And>a ds1 T.\n       \\<lbrakk>\\<And>T.\n                   internal (ds1 @ ds2 @ [d]) T \\<Longrightarrow>\n                   internal ds1 T;\n        internal ((a # ds1) @ ds2 @ [d]) T\\<rbrakk>\n       \\<Longrightarrow> internal (a # ds1) T", "then"], ["proof (chain)\npicking this:\n  internal (ds1 @ ds2 @ [d]) ?T \\<Longrightarrow> internal ds1 ?T\n  internal ((a # ds1) @ ds2 @ [d]) T", "have \"\\<exists>l r. T = Branching l r\""], ["proof (prove)\nusing this:\n  internal (ds1 @ ds2 @ [d]) ?T \\<Longrightarrow> internal ds1 ?T\n  internal ((a # ds1) @ ds2 @ [d]) T\n\ngoal (1 subgoal):\n 1. \\<exists>l r. T = Branching l r", "using internal_inv_Leaf"], ["proof (prove)\nusing this:\n  internal (ds1 @ ds2 @ [d]) ?T \\<Longrightarrow> internal ds1 ?T\n  internal ((a # ds1) @ ds2 @ [d]) T\n  \\<not> internal ?b Leaf\n\ngoal (1 subgoal):\n 1. \\<exists>l r. T = Branching l r", "by (cases T) auto"], ["proof (state)\nthis:\n  \\<exists>l r. T = Branching l r\n\ngoal (2 subgoals):\n 1. \\<And>T. internal ([] @ ds2 @ [d]) T \\<Longrightarrow> internal [] T\n 2. \\<And>a ds1 T.\n       \\<lbrakk>\\<And>T.\n                   internal (ds1 @ ds2 @ [d]) T \\<Longrightarrow>\n                   internal ds1 T;\n        internal ((a # ds1) @ ds2 @ [d]) T\\<rbrakk>\n       \\<Longrightarrow> internal (a # ds1) T", "then"], ["proof (chain)\npicking this:\n  \\<exists>l r. T = Branching l r", "obtain l r where p_lr: \"T = Branching l r\""], ["proof (prove)\nusing this:\n  \\<exists>l r. T = Branching l r\n\ngoal (1 subgoal):\n 1. (\\<And>l r.\n        T = Branching l r \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  T = Branching l r\n\ngoal (2 subgoals):\n 1. \\<And>T. internal ([] @ ds2 @ [d]) T \\<Longrightarrow> internal [] T\n 2. \\<And>a ds1 T.\n       \\<lbrakk>\\<And>T.\n                   internal (ds1 @ ds2 @ [d]) T \\<Longrightarrow>\n                   internal ds1 T;\n        internal ((a # ds1) @ ds2 @ [d]) T\\<rbrakk>\n       \\<Longrightarrow> internal (a # ds1) T", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. internal (a # ds1) T", "proof (cases a)"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<Longrightarrow> internal (a # ds1) T\n 2. \\<not> a \\<Longrightarrow> internal (a # ds1) T", "assume atrue: \"a\""], ["proof (state)\nthis:\n  a\n\ngoal (2 subgoals):\n 1. a \\<Longrightarrow> internal (a # ds1) T\n 2. \\<not> a \\<Longrightarrow> internal (a # ds1) T", "then"], ["proof (chain)\npicking this:\n  a", "have \"internal ((ds1) @ ds2 @[d]) l\""], ["proof (prove)\nusing this:\n  a\n\ngoal (1 subgoal):\n 1. internal (ds1 @ ds2 @ [d]) l", "using p_lr Cons(2) internal_inv_Branching"], ["proof (prove)\nusing this:\n  a\n  T = Branching l r\n  internal ((a # ds1) @ ds2 @ [d]) T\n  internal ?p (Branching ?l ?r) =\n  (?p = [] \\<or>\n   (\\<exists>a p'.\n       ?p = a # p' \\<and>\n       (a \\<longrightarrow> internal p' ?l) \\<and>\n       (\\<not> a \\<longrightarrow> internal p' ?r)))\n\ngoal (1 subgoal):\n 1. internal (ds1 @ ds2 @ [d]) l", "by auto"], ["proof (state)\nthis:\n  internal (ds1 @ ds2 @ [d]) l\n\ngoal (2 subgoals):\n 1. a \\<Longrightarrow> internal (a # ds1) T\n 2. \\<not> a \\<Longrightarrow> internal (a # ds1) T", "then"], ["proof (chain)\npicking this:\n  internal (ds1 @ ds2 @ [d]) l", "have \"internal ds1 l\""], ["proof (prove)\nusing this:\n  internal (ds1 @ ds2 @ [d]) l\n\ngoal (1 subgoal):\n 1. internal ds1 l", "using Cons(1)"], ["proof (prove)\nusing this:\n  internal (ds1 @ ds2 @ [d]) l\n  internal (ds1 @ ds2 @ [d]) ?T \\<Longrightarrow> internal ds1 ?T\n\ngoal (1 subgoal):\n 1. internal ds1 l", "by auto"], ["proof (state)\nthis:\n  internal ds1 l\n\ngoal (2 subgoals):\n 1. a \\<Longrightarrow> internal (a # ds1) T\n 2. \\<not> a \\<Longrightarrow> internal (a # ds1) T", "then"], ["proof (chain)\npicking this:\n  internal ds1 l", "show \"internal (a # ds1) T\""], ["proof (prove)\nusing this:\n  internal ds1 l\n\ngoal (1 subgoal):\n 1. internal (a # ds1) T", "using p_lr atrue"], ["proof (prove)\nusing this:\n  internal ds1 l\n  T = Branching l r\n  a\n\ngoal (1 subgoal):\n 1. internal (a # ds1) T", "by auto"], ["proof (state)\nthis:\n  internal (a # ds1) T\n\ngoal (1 subgoal):\n 1. \\<not> a \\<Longrightarrow> internal (a # ds1) T", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> a \\<Longrightarrow> internal (a # ds1) T", "assume afalse: \"~a\""], ["proof (state)\nthis:\n  \\<not> a\n\ngoal (1 subgoal):\n 1. \\<not> a \\<Longrightarrow> internal (a # ds1) T", "then"], ["proof (chain)\npicking this:\n  \\<not> a", "have \"internal ((ds1) @ ds2 @[d]) r\""], ["proof (prove)\nusing this:\n  \\<not> a\n\ngoal (1 subgoal):\n 1. internal (ds1 @ ds2 @ [d]) r", "using p_lr Cons(2) internal_inv_Branching"], ["proof (prove)\nusing this:\n  \\<not> a\n  T = Branching l r\n  internal ((a # ds1) @ ds2 @ [d]) T\n  internal ?p (Branching ?l ?r) =\n  (?p = [] \\<or>\n   (\\<exists>a p'.\n       ?p = a # p' \\<and>\n       (a \\<longrightarrow> internal p' ?l) \\<and>\n       (\\<not> a \\<longrightarrow> internal p' ?r)))\n\ngoal (1 subgoal):\n 1. internal (ds1 @ ds2 @ [d]) r", "by auto"], ["proof (state)\nthis:\n  internal (ds1 @ ds2 @ [d]) r\n\ngoal (1 subgoal):\n 1. \\<not> a \\<Longrightarrow> internal (a # ds1) T", "then"], ["proof (chain)\npicking this:\n  internal (ds1 @ ds2 @ [d]) r", "have \"internal ds1 r\""], ["proof (prove)\nusing this:\n  internal (ds1 @ ds2 @ [d]) r\n\ngoal (1 subgoal):\n 1. internal ds1 r", "using Cons(1)"], ["proof (prove)\nusing this:\n  internal (ds1 @ ds2 @ [d]) r\n  internal (ds1 @ ds2 @ [d]) ?T \\<Longrightarrow> internal ds1 ?T\n\ngoal (1 subgoal):\n 1. internal ds1 r", "by auto"], ["proof (state)\nthis:\n  internal ds1 r\n\ngoal (1 subgoal):\n 1. \\<not> a \\<Longrightarrow> internal (a # ds1) T", "then"], ["proof (chain)\npicking this:\n  internal ds1 r", "show \"internal (a # ds1) T\""], ["proof (prove)\nusing this:\n  internal ds1 r\n\ngoal (1 subgoal):\n 1. internal (a # ds1) T", "using p_lr afalse"], ["proof (prove)\nusing this:\n  internal ds1 r\n  T = Branching l r\n  \\<not> a\n\ngoal (1 subgoal):\n 1. internal (a # ds1) T", "by auto"], ["proof (state)\nthis:\n  internal (a # ds1) T\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  internal (a # ds1) T\n\ngoal (1 subgoal):\n 1. \\<And>T. internal ([] @ ds2 @ [d]) T \\<Longrightarrow> internal [] T", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T. internal ([] @ ds2 @ [d]) T \\<Longrightarrow> internal [] T", "case (Nil)"], ["proof (state)\nthis:\n  internal ([] @ ds2 @ [d]) T\n\ngoal (1 subgoal):\n 1. \\<And>T. internal ([] @ ds2 @ [d]) T \\<Longrightarrow> internal [] T", "then"], ["proof (chain)\npicking this:\n  internal ([] @ ds2 @ [d]) T", "have \"\\<exists>l r. T = Branching l r\""], ["proof (prove)\nusing this:\n  internal ([] @ ds2 @ [d]) T\n\ngoal (1 subgoal):\n 1. \\<exists>l r. T = Branching l r", "using internal_inv_Leaf"], ["proof (prove)\nusing this:\n  internal ([] @ ds2 @ [d]) T\n  \\<not> internal ?b Leaf\n\ngoal (1 subgoal):\n 1. \\<exists>l r. T = Branching l r", "by (cases T) auto"], ["proof (state)\nthis:\n  \\<exists>l r. T = Branching l r\n\ngoal (1 subgoal):\n 1. \\<And>T. internal ([] @ ds2 @ [d]) T \\<Longrightarrow> internal [] T", "then"], ["proof (chain)\npicking this:\n  \\<exists>l r. T = Branching l r", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>l r. T = Branching l r\n\ngoal (1 subgoal):\n 1. internal [] T", "by auto"], ["proof (state)\nthis:\n  internal [] T\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma internal_branch:\n  assumes \"branch (ds1@ds2@[d]) T\"\n  shows \"internal ds1 T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. internal ds1 T", "(* more or less copy paste of path_prefix *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. internal ds1 T", "using assms"], ["proof (prove)\nusing this:\n  branch (ds1 @ ds2 @ [d]) T\n\ngoal (1 subgoal):\n 1. internal ds1 T", "proof (induction ds1 arbitrary: T)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>T. branch ([] @ ds2 @ [d]) T \\<Longrightarrow> internal [] T\n 2. \\<And>a ds1 T.\n       \\<lbrakk>\\<And>T.\n                   branch (ds1 @ ds2 @ [d]) T \\<Longrightarrow>\n                   internal ds1 T;\n        branch ((a # ds1) @ ds2 @ [d]) T\\<rbrakk>\n       \\<Longrightarrow> internal (a # ds1) T", "case (Cons a ds1)"], ["proof (state)\nthis:\n  branch (ds1 @ ds2 @ [d]) ?T \\<Longrightarrow> internal ds1 ?T\n  branch ((a # ds1) @ ds2 @ [d]) T\n\ngoal (2 subgoals):\n 1. \\<And>T. branch ([] @ ds2 @ [d]) T \\<Longrightarrow> internal [] T\n 2. \\<And>a ds1 T.\n       \\<lbrakk>\\<And>T.\n                   branch (ds1 @ ds2 @ [d]) T \\<Longrightarrow>\n                   internal ds1 T;\n        branch ((a # ds1) @ ds2 @ [d]) T\\<rbrakk>\n       \\<Longrightarrow> internal (a # ds1) T", "then"], ["proof (chain)\npicking this:\n  branch (ds1 @ ds2 @ [d]) ?T \\<Longrightarrow> internal ds1 ?T\n  branch ((a # ds1) @ ds2 @ [d]) T", "have \"\\<exists>l r. T = Branching l r\""], ["proof (prove)\nusing this:\n  branch (ds1 @ ds2 @ [d]) ?T \\<Longrightarrow> internal ds1 ?T\n  branch ((a # ds1) @ ds2 @ [d]) T\n\ngoal (1 subgoal):\n 1. \\<exists>l r. T = Branching l r", "using branch_inv_Leaf"], ["proof (prove)\nusing this:\n  branch (ds1 @ ds2 @ [d]) ?T \\<Longrightarrow> internal ds1 ?T\n  branch ((a # ds1) @ ds2 @ [d]) T\n  branch ?b Leaf = (?b = [])\n\ngoal (1 subgoal):\n 1. \\<exists>l r. T = Branching l r", "by (cases T) auto"], ["proof (state)\nthis:\n  \\<exists>l r. T = Branching l r\n\ngoal (2 subgoals):\n 1. \\<And>T. branch ([] @ ds2 @ [d]) T \\<Longrightarrow> internal [] T\n 2. \\<And>a ds1 T.\n       \\<lbrakk>\\<And>T.\n                   branch (ds1 @ ds2 @ [d]) T \\<Longrightarrow>\n                   internal ds1 T;\n        branch ((a # ds1) @ ds2 @ [d]) T\\<rbrakk>\n       \\<Longrightarrow> internal (a # ds1) T", "then"], ["proof (chain)\npicking this:\n  \\<exists>l r. T = Branching l r", "obtain l r where p_lr: \"T = Branching l r\""], ["proof (prove)\nusing this:\n  \\<exists>l r. T = Branching l r\n\ngoal (1 subgoal):\n 1. (\\<And>l r.\n        T = Branching l r \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  T = Branching l r\n\ngoal (2 subgoals):\n 1. \\<And>T. branch ([] @ ds2 @ [d]) T \\<Longrightarrow> internal [] T\n 2. \\<And>a ds1 T.\n       \\<lbrakk>\\<And>T.\n                   branch (ds1 @ ds2 @ [d]) T \\<Longrightarrow>\n                   internal ds1 T;\n        branch ((a # ds1) @ ds2 @ [d]) T\\<rbrakk>\n       \\<Longrightarrow> internal (a # ds1) T", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. internal (a # ds1) T", "proof (cases a)"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<Longrightarrow> internal (a # ds1) T\n 2. \\<not> a \\<Longrightarrow> internal (a # ds1) T", "assume atrue: \"a\""], ["proof (state)\nthis:\n  a\n\ngoal (2 subgoals):\n 1. a \\<Longrightarrow> internal (a # ds1) T\n 2. \\<not> a \\<Longrightarrow> internal (a # ds1) T", "then"], ["proof (chain)\npicking this:\n  a", "have \"branch (ds1 @ ds2 @ [d]) l\""], ["proof (prove)\nusing this:\n  a\n\ngoal (1 subgoal):\n 1. branch (ds1 @ ds2 @ [d]) l", "using p_lr Cons(2) branch_inv_Branching"], ["proof (prove)\nusing this:\n  a\n  T = Branching l r\n  branch ((a # ds1) @ ds2 @ [d]) T\n  branch ?b (Branching ?l ?r) =\n  (\\<exists>a b'.\n      ?b = a # b' \\<and>\n      (a \\<longrightarrow> branch b' ?l) \\<and>\n      (\\<not> a \\<longrightarrow> branch b' ?r))\n\ngoal (1 subgoal):\n 1. branch (ds1 @ ds2 @ [d]) l", "by auto"], ["proof (state)\nthis:\n  branch (ds1 @ ds2 @ [d]) l\n\ngoal (2 subgoals):\n 1. a \\<Longrightarrow> internal (a # ds1) T\n 2. \\<not> a \\<Longrightarrow> internal (a # ds1) T", "then"], ["proof (chain)\npicking this:\n  branch (ds1 @ ds2 @ [d]) l", "have \"internal ds1 l\""], ["proof (prove)\nusing this:\n  branch (ds1 @ ds2 @ [d]) l\n\ngoal (1 subgoal):\n 1. internal ds1 l", "using Cons(1)"], ["proof (prove)\nusing this:\n  branch (ds1 @ ds2 @ [d]) l\n  branch (ds1 @ ds2 @ [d]) ?T \\<Longrightarrow> internal ds1 ?T\n\ngoal (1 subgoal):\n 1. internal ds1 l", "by auto"], ["proof (state)\nthis:\n  internal ds1 l\n\ngoal (2 subgoals):\n 1. a \\<Longrightarrow> internal (a # ds1) T\n 2. \\<not> a \\<Longrightarrow> internal (a # ds1) T", "then"], ["proof (chain)\npicking this:\n  internal ds1 l", "show \"internal (a # ds1) T\""], ["proof (prove)\nusing this:\n  internal ds1 l\n\ngoal (1 subgoal):\n 1. internal (a # ds1) T", "using p_lr atrue"], ["proof (prove)\nusing this:\n  internal ds1 l\n  T = Branching l r\n  a\n\ngoal (1 subgoal):\n 1. internal (a # ds1) T", "by auto"], ["proof (state)\nthis:\n  internal (a # ds1) T\n\ngoal (1 subgoal):\n 1. \\<not> a \\<Longrightarrow> internal (a # ds1) T", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> a \\<Longrightarrow> internal (a # ds1) T", "assume afalse: \"~a\""], ["proof (state)\nthis:\n  \\<not> a\n\ngoal (1 subgoal):\n 1. \\<not> a \\<Longrightarrow> internal (a # ds1) T", "then"], ["proof (chain)\npicking this:\n  \\<not> a", "have \"branch ((ds1) @ ds2 @[d]) r\""], ["proof (prove)\nusing this:\n  \\<not> a\n\ngoal (1 subgoal):\n 1. branch (ds1 @ ds2 @ [d]) r", "using p_lr Cons(2) branch_inv_Branching"], ["proof (prove)\nusing this:\n  \\<not> a\n  T = Branching l r\n  branch ((a # ds1) @ ds2 @ [d]) T\n  branch ?b (Branching ?l ?r) =\n  (\\<exists>a b'.\n      ?b = a # b' \\<and>\n      (a \\<longrightarrow> branch b' ?l) \\<and>\n      (\\<not> a \\<longrightarrow> branch b' ?r))\n\ngoal (1 subgoal):\n 1. branch (ds1 @ ds2 @ [d]) r", "by auto"], ["proof (state)\nthis:\n  branch (ds1 @ ds2 @ [d]) r\n\ngoal (1 subgoal):\n 1. \\<not> a \\<Longrightarrow> internal (a # ds1) T", "then"], ["proof (chain)\npicking this:\n  branch (ds1 @ ds2 @ [d]) r", "have \"internal ds1 r\""], ["proof (prove)\nusing this:\n  branch (ds1 @ ds2 @ [d]) r\n\ngoal (1 subgoal):\n 1. internal ds1 r", "using Cons(1)"], ["proof (prove)\nusing this:\n  branch (ds1 @ ds2 @ [d]) r\n  branch (ds1 @ ds2 @ [d]) ?T \\<Longrightarrow> internal ds1 ?T\n\ngoal (1 subgoal):\n 1. internal ds1 r", "by auto"], ["proof (state)\nthis:\n  internal ds1 r\n\ngoal (1 subgoal):\n 1. \\<not> a \\<Longrightarrow> internal (a # ds1) T", "then"], ["proof (chain)\npicking this:\n  internal ds1 r", "show \"internal (a # ds1) T\""], ["proof (prove)\nusing this:\n  internal ds1 r\n\ngoal (1 subgoal):\n 1. internal (a # ds1) T", "using p_lr afalse"], ["proof (prove)\nusing this:\n  internal ds1 r\n  T = Branching l r\n  \\<not> a\n\ngoal (1 subgoal):\n 1. internal (a # ds1) T", "by auto"], ["proof (state)\nthis:\n  internal (a # ds1) T\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  internal (a # ds1) T\n\ngoal (1 subgoal):\n 1. \\<And>T. branch ([] @ ds2 @ [d]) T \\<Longrightarrow> internal [] T", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T. branch ([] @ ds2 @ [d]) T \\<Longrightarrow> internal [] T", "case (Nil)"], ["proof (state)\nthis:\n  branch ([] @ ds2 @ [d]) T\n\ngoal (1 subgoal):\n 1. \\<And>T. branch ([] @ ds2 @ [d]) T \\<Longrightarrow> internal [] T", "then"], ["proof (chain)\npicking this:\n  branch ([] @ ds2 @ [d]) T", "have \"\\<exists>l r. T = Branching l r\""], ["proof (prove)\nusing this:\n  branch ([] @ ds2 @ [d]) T\n\ngoal (1 subgoal):\n 1. \\<exists>l r. T = Branching l r", "using branch_inv_Leaf"], ["proof (prove)\nusing this:\n  branch ([] @ ds2 @ [d]) T\n  branch ?b Leaf = (?b = [])\n\ngoal (1 subgoal):\n 1. \\<exists>l r. T = Branching l r", "by (cases T) auto"], ["proof (state)\nthis:\n  \\<exists>l r. T = Branching l r\n\ngoal (1 subgoal):\n 1. \\<And>T. branch ([] @ ds2 @ [d]) T \\<Longrightarrow> internal [] T", "then"], ["proof (chain)\npicking this:\n  \\<exists>l r. T = Branching l r", "show ?case"], ["proof (prove)\nusing this:\n  \\<exists>l r. T = Branching l r\n\ngoal (1 subgoal):\n 1. internal [] T", "by auto"], ["proof (state)\nthis:\n  internal [] T\n\ngoal:\nNo subgoals!", "qed"], ["", "fun parent :: \"dir list \\<Rightarrow> dir list\" where\n  \"parent ds = tl ds\""], ["", "subsection \\<open>Deleting Nodes\\<close>"], ["", "fun delete :: \"dir list \\<Rightarrow> tree \\<Rightarrow> tree\" where\n  \"delete [] T = Leaf\"\n| \"delete (True#ds)  (Branching T\\<^sub>1 T\\<^sub>2) = Branching (delete ds T\\<^sub>1) T\\<^sub>2\"\n| \"delete (False#ds) (Branching T\\<^sub>1 T\\<^sub>2) = Branching T\\<^sub>1 (delete ds T\\<^sub>2)\"\n| \"delete (a#ds) Leaf = Leaf\""], ["", "lemma delete_Leaf: \"delete T Leaf = Leaf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. delete T Leaf = Leaf", "by (cases T) auto"], ["", "lemma path_delete: \n  assumes \"path p (delete ds T)\"\n  shows \"path p T \""], ["proof (prove)\ngoal (1 subgoal):\n 1. path p T", "(* What a huge proof... But the four cases can be proven shorter *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. path p T", "using assms"], ["proof (prove)\nusing this:\n  path p (delete ds T)\n\ngoal (1 subgoal):\n 1. path p T", "proof (induction p arbitrary: T ds)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>T ds. path [] (delete ds T) \\<Longrightarrow> path [] T\n 2. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "case Nil"], ["proof (state)\nthis:\n  path [] (delete ds T)\n\ngoal (2 subgoals):\n 1. \\<And>T ds. path [] (delete ds T) \\<Longrightarrow> path [] T\n 2. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "then"], ["proof (chain)\npicking this:\n  path [] (delete ds T)", "show ?case"], ["proof (prove)\nusing this:\n  path [] (delete ds T)\n\ngoal (1 subgoal):\n 1. path [] T", "by simp"], ["proof (state)\nthis:\n  path [] T\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "case (Cons a p)"], ["proof (state)\nthis:\n  path p (delete ?ds ?T) \\<Longrightarrow> path p ?T\n  path (a # p) (delete ds T)\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "then"], ["proof (chain)\npicking this:\n  path p (delete ?ds ?T) \\<Longrightarrow> path p ?T\n  path (a # p) (delete ds T)", "obtain b ds' where bds'_p: \"ds=b#ds'\""], ["proof (prove)\nusing this:\n  path p (delete ?ds ?T) \\<Longrightarrow> path p ?T\n  path (a # p) (delete ds T)\n\ngoal (1 subgoal):\n 1. (\\<And>b ds'. ds = b # ds' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases ds) auto"], ["proof (state)\nthis:\n  ds = b # ds'\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "have \"\\<exists>dT1 dT2. delete ds T = Branching dT1 dT2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>dT1 dT2. delete ds T = Branching dT1 dT2", "using Cons path_inv_Cons"], ["proof (prove)\nusing this:\n  path p (delete ?ds ?T) \\<Longrightarrow> path p ?T\n  path (a # p) (delete ds T)\n  path (?a # ?ds) ?T \\<longrightarrow> (\\<exists>l r. ?T = Branching l r)\n\ngoal (1 subgoal):\n 1. \\<exists>dT1 dT2. delete ds T = Branching dT1 dT2", "by auto"], ["proof (state)\nthis:\n  \\<exists>dT1 dT2. delete ds T = Branching dT1 dT2\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "then"], ["proof (chain)\npicking this:\n  \\<exists>dT1 dT2. delete ds T = Branching dT1 dT2", "obtain dT1 dT2 where \"delete ds T = Branching dT1 dT2\""], ["proof (prove)\nusing this:\n  \\<exists>dT1 dT2. delete ds T = Branching dT1 dT2\n\ngoal (1 subgoal):\n 1. (\\<And>dT1 dT2.\n        delete ds T = Branching dT1 dT2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  delete ds T = Branching dT1 dT2\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "then"], ["proof (chain)\npicking this:\n  delete ds T = Branching dT1 dT2", "have \"\\<exists>T1 T2. T=Branching T1 T2\""], ["proof (prove)\nusing this:\n  delete ds T = Branching dT1 dT2\n\ngoal (1 subgoal):\n 1. \\<exists>T1 T2. T = Branching T1 T2", "(* Is there a lemma hidden here that I could extract? *)"], ["proof (prove)\nusing this:\n  delete ds T = Branching dT1 dT2\n\ngoal (1 subgoal):\n 1. \\<exists>T1 T2. T = Branching T1 T2", "by (cases T; cases ds) auto"], ["proof (state)\nthis:\n  \\<exists>T1 T2. T = Branching T1 T2\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "then"], ["proof (chain)\npicking this:\n  \\<exists>T1 T2. T = Branching T1 T2", "obtain T1 T2 where T1T2_p: \"T=Branching T1 T2\""], ["proof (prove)\nusing this:\n  \\<exists>T1 T2. T = Branching T1 T2\n\ngoal (1 subgoal):\n 1. (\\<And>T1 T2.\n        T = Branching T1 T2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  T = Branching T1 T2\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "{"], ["proof (state)\nthis:\n  T = Branching T1 T2\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "assume a_p: \"a\""], ["proof (state)\nthis:\n  a\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "assume b_p: \"\\<not>b\""], ["proof (state)\nthis:\n  \\<not> b\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "have \"path (a # p) (delete ds T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (a # p) (delete ds T)", "using Cons"], ["proof (prove)\nusing this:\n  path p (delete ?ds ?T) \\<Longrightarrow> path p ?T\n  path (a # p) (delete ds T)\n\ngoal (1 subgoal):\n 1. path (a # p) (delete ds T)", "by -"], ["proof (state)\nthis:\n  path (a # p) (delete ds T)\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "then"], ["proof (chain)\npicking this:\n  path (a # p) (delete ds T)", "have \"path (a # p) (Branching (T1) (delete ds' T2))\""], ["proof (prove)\nusing this:\n  path (a # p) (delete ds T)\n\ngoal (1 subgoal):\n 1. path (a # p) (Branching T1 (delete ds' T2))", "using b_p bds'_p T1T2_p"], ["proof (prove)\nusing this:\n  path (a # p) (delete ds T)\n  \\<not> b\n  ds = b # ds'\n  T = Branching T1 T2\n\ngoal (1 subgoal):\n 1. path (a # p) (Branching T1 (delete ds' T2))", "by auto"], ["proof (state)\nthis:\n  path (a # p) (Branching T1 (delete ds' T2))\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "then"], ["proof (chain)\npicking this:\n  path (a # p) (Branching T1 (delete ds' T2))", "have \"path p T1\""], ["proof (prove)\nusing this:\n  path (a # p) (Branching T1 (delete ds' T2))\n\ngoal (1 subgoal):\n 1. path p T1", "using a_p"], ["proof (prove)\nusing this:\n  path (a # p) (Branching T1 (delete ds' T2))\n  a\n\ngoal (1 subgoal):\n 1. path p T1", "by auto"], ["proof (state)\nthis:\n  path p T1\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "then"], ["proof (chain)\npicking this:\n  path p T1", "have ?case"], ["proof (prove)\nusing this:\n  path p T1\n\ngoal (1 subgoal):\n 1. path (a # p) T", "using T1T2_p a_p"], ["proof (prove)\nusing this:\n  path p T1\n  T = Branching T1 T2\n  a\n\ngoal (1 subgoal):\n 1. path (a # p) T", "by auto"], ["proof (state)\nthis:\n  path (a # p) T\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "}"], ["proof (state)\nthis:\n  \\<lbrakk>a; \\<not> b\\<rbrakk> \\<Longrightarrow> path (a # p) T\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>a; \\<not> b\\<rbrakk> \\<Longrightarrow> path (a # p) T\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "{"], ["proof (state)\nthis:\n  \\<lbrakk>a; \\<not> b\\<rbrakk> \\<Longrightarrow> path (a # p) T\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "assume a_p: \"\\<not>a\""], ["proof (state)\nthis:\n  \\<not> a\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "assume b_p: \"b\""], ["proof (state)\nthis:\n  b\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "have \"path (a # p) (delete ds T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (a # p) (delete ds T)", "using Cons"], ["proof (prove)\nusing this:\n  path p (delete ?ds ?T) \\<Longrightarrow> path p ?T\n  path (a # p) (delete ds T)\n\ngoal (1 subgoal):\n 1. path (a # p) (delete ds T)", "by -"], ["proof (state)\nthis:\n  path (a # p) (delete ds T)\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "then"], ["proof (chain)\npicking this:\n  path (a # p) (delete ds T)", "have \"path (a # p) (Branching (delete ds' T1) T2)\""], ["proof (prove)\nusing this:\n  path (a # p) (delete ds T)\n\ngoal (1 subgoal):\n 1. path (a # p) (Branching (delete ds' T1) T2)", "using b_p bds'_p T1T2_p"], ["proof (prove)\nusing this:\n  path (a # p) (delete ds T)\n  b\n  ds = b # ds'\n  T = Branching T1 T2\n\ngoal (1 subgoal):\n 1. path (a # p) (Branching (delete ds' T1) T2)", "by auto"], ["proof (state)\nthis:\n  path (a # p) (Branching (delete ds' T1) T2)\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "then"], ["proof (chain)\npicking this:\n  path (a # p) (Branching (delete ds' T1) T2)", "have \"path p T2\""], ["proof (prove)\nusing this:\n  path (a # p) (Branching (delete ds' T1) T2)\n\ngoal (1 subgoal):\n 1. path p T2", "using a_p"], ["proof (prove)\nusing this:\n  path (a # p) (Branching (delete ds' T1) T2)\n  \\<not> a\n\ngoal (1 subgoal):\n 1. path p T2", "by auto"], ["proof (state)\nthis:\n  path p T2\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "then"], ["proof (chain)\npicking this:\n  path p T2", "have ?case"], ["proof (prove)\nusing this:\n  path p T2\n\ngoal (1 subgoal):\n 1. path (a # p) T", "using T1T2_p a_p"], ["proof (prove)\nusing this:\n  path p T2\n  T = Branching T1 T2\n  \\<not> a\n\ngoal (1 subgoal):\n 1. path (a # p) T", "by auto"], ["proof (state)\nthis:\n  path (a # p) T\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> a; b\\<rbrakk> \\<Longrightarrow> path (a # p) T\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> a; b\\<rbrakk> \\<Longrightarrow> path (a # p) T\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "{"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> a; b\\<rbrakk> \\<Longrightarrow> path (a # p) T\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "assume a_p: \"a\""], ["proof (state)\nthis:\n  a\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "assume b_p: \"b\""], ["proof (state)\nthis:\n  b\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "have \"path (a # p) (delete ds T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (a # p) (delete ds T)", "using Cons"], ["proof (prove)\nusing this:\n  path p (delete ?ds ?T) \\<Longrightarrow> path p ?T\n  path (a # p) (delete ds T)\n\ngoal (1 subgoal):\n 1. path (a # p) (delete ds T)", "by -"], ["proof (state)\nthis:\n  path (a # p) (delete ds T)\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "then"], ["proof (chain)\npicking this:\n  path (a # p) (delete ds T)", "have \"path (a # p) (Branching (delete ds' T1) T2)\""], ["proof (prove)\nusing this:\n  path (a # p) (delete ds T)\n\ngoal (1 subgoal):\n 1. path (a # p) (Branching (delete ds' T1) T2)", "using b_p bds'_p T1T2_p"], ["proof (prove)\nusing this:\n  path (a # p) (delete ds T)\n  b\n  ds = b # ds'\n  T = Branching T1 T2\n\ngoal (1 subgoal):\n 1. path (a # p) (Branching (delete ds' T1) T2)", "by auto"], ["proof (state)\nthis:\n  path (a # p) (Branching (delete ds' T1) T2)\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "then"], ["proof (chain)\npicking this:\n  path (a # p) (Branching (delete ds' T1) T2)", "have \"path p (delete ds' T1)\""], ["proof (prove)\nusing this:\n  path (a # p) (Branching (delete ds' T1) T2)\n\ngoal (1 subgoal):\n 1. path p (delete ds' T1)", "using a_p"], ["proof (prove)\nusing this:\n  path (a # p) (Branching (delete ds' T1) T2)\n  a\n\ngoal (1 subgoal):\n 1. path p (delete ds' T1)", "by auto"], ["proof (state)\nthis:\n  path p (delete ds' T1)\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "then"], ["proof (chain)\npicking this:\n  path p (delete ds' T1)", "have \"path p T1\""], ["proof (prove)\nusing this:\n  path p (delete ds' T1)\n\ngoal (1 subgoal):\n 1. path p T1", "using Cons"], ["proof (prove)\nusing this:\n  path p (delete ds' T1)\n  path p (delete ?ds ?T) \\<Longrightarrow> path p ?T\n  path (a # p) (delete ds T)\n\ngoal (1 subgoal):\n 1. path p T1", "by auto"], ["proof (state)\nthis:\n  path p T1\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "then"], ["proof (chain)\npicking this:\n  path p T1", "have ?case"], ["proof (prove)\nusing this:\n  path p T1\n\ngoal (1 subgoal):\n 1. path (a # p) T", "using T1T2_p a_p"], ["proof (prove)\nusing this:\n  path p T1\n  T = Branching T1 T2\n  a\n\ngoal (1 subgoal):\n 1. path (a # p) T", "by auto"], ["proof (state)\nthis:\n  path (a # p) T\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "}"], ["proof (state)\nthis:\n  \\<lbrakk>a; b\\<rbrakk> \\<Longrightarrow> path (a # p) T\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>a; b\\<rbrakk> \\<Longrightarrow> path (a # p) T\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "{"], ["proof (state)\nthis:\n  \\<lbrakk>a; b\\<rbrakk> \\<Longrightarrow> path (a # p) T\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "assume a_p: \"\\<not>a\""], ["proof (state)\nthis:\n  \\<not> a\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "assume b_p: \"\\<not>b\""], ["proof (state)\nthis:\n  \\<not> b\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "have \"path (a # p) (delete ds T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (a # p) (delete ds T)", "using Cons"], ["proof (prove)\nusing this:\n  path p (delete ?ds ?T) \\<Longrightarrow> path p ?T\n  path (a # p) (delete ds T)\n\ngoal (1 subgoal):\n 1. path (a # p) (delete ds T)", "by -"], ["proof (state)\nthis:\n  path (a # p) (delete ds T)\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "then"], ["proof (chain)\npicking this:\n  path (a # p) (delete ds T)", "have \"path (a # p) (Branching T1 (delete ds' T2))\""], ["proof (prove)\nusing this:\n  path (a # p) (delete ds T)\n\ngoal (1 subgoal):\n 1. path (a # p) (Branching T1 (delete ds' T2))", "using b_p bds'_p T1T2_p"], ["proof (prove)\nusing this:\n  path (a # p) (delete ds T)\n  \\<not> b\n  ds = b # ds'\n  T = Branching T1 T2\n\ngoal (1 subgoal):\n 1. path (a # p) (Branching T1 (delete ds' T2))", "by auto"], ["proof (state)\nthis:\n  path (a # p) (Branching T1 (delete ds' T2))\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "then"], ["proof (chain)\npicking this:\n  path (a # p) (Branching T1 (delete ds' T2))", "have \"path p (delete ds' T2)\""], ["proof (prove)\nusing this:\n  path (a # p) (Branching T1 (delete ds' T2))\n\ngoal (1 subgoal):\n 1. path p (delete ds' T2)", "using a_p"], ["proof (prove)\nusing this:\n  path (a # p) (Branching T1 (delete ds' T2))\n  \\<not> a\n\ngoal (1 subgoal):\n 1. path p (delete ds' T2)", "by auto"], ["proof (state)\nthis:\n  path p (delete ds' T2)\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "then"], ["proof (chain)\npicking this:\n  path p (delete ds' T2)", "have \"path p T2\""], ["proof (prove)\nusing this:\n  path p (delete ds' T2)\n\ngoal (1 subgoal):\n 1. path p T2", "using Cons"], ["proof (prove)\nusing this:\n  path p (delete ds' T2)\n  path p (delete ?ds ?T) \\<Longrightarrow> path p ?T\n  path (a # p) (delete ds T)\n\ngoal (1 subgoal):\n 1. path p T2", "by auto"], ["proof (state)\nthis:\n  path p T2\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "then"], ["proof (chain)\npicking this:\n  path p T2", "have ?case"], ["proof (prove)\nusing this:\n  path p T2\n\ngoal (1 subgoal):\n 1. path (a # p) T", "using T1T2_p a_p"], ["proof (prove)\nusing this:\n  path p T2\n  T = Branching T1 T2\n  \\<not> a\n\ngoal (1 subgoal):\n 1. path (a # p) T", "by auto"], ["proof (state)\nthis:\n  path (a # p) T\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> a; \\<not> b\\<rbrakk> \\<Longrightarrow> path (a # p) T\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds. path p (delete ds T) \\<Longrightarrow> path p T;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> path (a # p) T", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>a; \\<not> b\\<rbrakk> \\<Longrightarrow> path (a # p) T\n  \\<lbrakk>\\<not> a; b\\<rbrakk> \\<Longrightarrow> path (a # p) T\n  \\<lbrakk>a; b\\<rbrakk> \\<Longrightarrow> path (a # p) T\n  \\<lbrakk>\\<not> a; \\<not> b\\<rbrakk> \\<Longrightarrow> path (a # p) T", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>a; \\<not> b\\<rbrakk> \\<Longrightarrow> path (a # p) T\n  \\<lbrakk>\\<not> a; b\\<rbrakk> \\<Longrightarrow> path (a # p) T\n  \\<lbrakk>a; b\\<rbrakk> \\<Longrightarrow> path (a # p) T\n  \\<lbrakk>\\<not> a; \\<not> b\\<rbrakk> \\<Longrightarrow> path (a # p) T\n\ngoal (1 subgoal):\n 1. path (a # p) T", "by blast"], ["proof (state)\nthis:\n  path (a # p) T\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma branch_delete:\n  assumes \"branch p (delete ds T)\"\n  shows \"branch p T \\<or> p=ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. branch p T \\<or> p = ds", "(* Adapted from above *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. branch p T \\<or> p = ds", "using assms"], ["proof (prove)\nusing this:\n  branch p (delete ds T)\n\ngoal (1 subgoal):\n 1. branch p T \\<or> p = ds", "proof (induction p arbitrary: T ds)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>T ds.\n       branch [] (delete ds T) \\<Longrightarrow> branch [] T \\<or> [] = ds\n 2. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "case Nil"], ["proof (state)\nthis:\n  branch [] (delete ds T)\n\ngoal (2 subgoals):\n 1. \\<And>T ds.\n       branch [] (delete ds T) \\<Longrightarrow> branch [] T \\<or> [] = ds\n 2. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "then"], ["proof (chain)\npicking this:\n  branch [] (delete ds T)", "have \"delete ds T = Leaf\""], ["proof (prove)\nusing this:\n  branch [] (delete ds T)\n\ngoal (1 subgoal):\n 1. delete ds T = Leaf", "by (cases \"delete ds T\") auto"], ["proof (state)\nthis:\n  delete ds T = Leaf\n\ngoal (2 subgoals):\n 1. \\<And>T ds.\n       branch [] (delete ds T) \\<Longrightarrow> branch [] T \\<or> [] = ds\n 2. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "then"], ["proof (chain)\npicking this:\n  delete ds T = Leaf", "have \"ds = [] \\<or> T = Leaf\""], ["proof (prove)\nusing this:\n  delete ds T = Leaf\n\ngoal (1 subgoal):\n 1. ds = [] \\<or> T = Leaf", "using delete.elims"], ["proof (prove)\nusing this:\n  delete ds T = Leaf\n  \\<lbrakk>delete ?x ?xa = ?y;\n   \\<And>T.\n      \\<lbrakk>?x = []; ?xa = T; ?y = Leaf\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>ds T\\<^sub>1 T\\<^sub>2.\n      \\<lbrakk>?x = True # ds; ?xa = Branching T\\<^sub>1 T\\<^sub>2;\n       ?y = Branching (delete ds T\\<^sub>1) T\\<^sub>2\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>ds T\\<^sub>1 T\\<^sub>2.\n      \\<lbrakk>?x = False # ds; ?xa = Branching T\\<^sub>1 T\\<^sub>2;\n       ?y = Branching T\\<^sub>1 (delete ds T\\<^sub>2)\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>a ds.\n      \\<lbrakk>?x = a # ds; ?xa = Leaf; ?y = Leaf\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. ds = [] \\<or> T = Leaf", "by blast"], ["proof (state)\nthis:\n  ds = [] \\<or> T = Leaf\n\ngoal (2 subgoals):\n 1. \\<And>T ds.\n       branch [] (delete ds T) \\<Longrightarrow> branch [] T \\<or> [] = ds\n 2. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "then"], ["proof (chain)\npicking this:\n  ds = [] \\<or> T = Leaf", "show ?case"], ["proof (prove)\nusing this:\n  ds = [] \\<or> T = Leaf\n\ngoal (1 subgoal):\n 1. branch [] T \\<or> [] = ds", "by auto"], ["proof (state)\nthis:\n  branch [] T \\<or> [] = ds\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "case (Cons a p)"], ["proof (state)\nthis:\n  branch p (delete ?ds ?T) \\<Longrightarrow> branch p ?T \\<or> p = ?ds\n  branch (a # p) (delete ds T)\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "then"], ["proof (chain)\npicking this:\n  branch p (delete ?ds ?T) \\<Longrightarrow> branch p ?T \\<or> p = ?ds\n  branch (a # p) (delete ds T)", "obtain b ds' where bds'_p: \"ds=b#ds'\""], ["proof (prove)\nusing this:\n  branch p (delete ?ds ?T) \\<Longrightarrow> branch p ?T \\<or> p = ?ds\n  branch (a # p) (delete ds T)\n\ngoal (1 subgoal):\n 1. (\\<And>b ds'. ds = b # ds' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases ds) auto"], ["proof (state)\nthis:\n  ds = b # ds'\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "have \"\\<exists>dT1 dT2. delete ds T = Branching dT1 dT2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>dT1 dT2. delete ds T = Branching dT1 dT2", "using Cons path_inv_Cons branch_is_path"], ["proof (prove)\nusing this:\n  branch p (delete ?ds ?T) \\<Longrightarrow> branch p ?T \\<or> p = ?ds\n  branch (a # p) (delete ds T)\n  path (?a # ?ds) ?T \\<longrightarrow> (\\<exists>l r. ?T = Branching l r)\n  branch ?ds ?T \\<Longrightarrow> path ?ds ?T\n\ngoal (1 subgoal):\n 1. \\<exists>dT1 dT2. delete ds T = Branching dT1 dT2", "by blast"], ["proof (state)\nthis:\n  \\<exists>dT1 dT2. delete ds T = Branching dT1 dT2\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "then"], ["proof (chain)\npicking this:\n  \\<exists>dT1 dT2. delete ds T = Branching dT1 dT2", "obtain dT1 dT2 where \"delete ds T = Branching dT1 dT2\""], ["proof (prove)\nusing this:\n  \\<exists>dT1 dT2. delete ds T = Branching dT1 dT2\n\ngoal (1 subgoal):\n 1. (\\<And>dT1 dT2.\n        delete ds T = Branching dT1 dT2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  delete ds T = Branching dT1 dT2\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "then"], ["proof (chain)\npicking this:\n  delete ds T = Branching dT1 dT2", "have \"\\<exists>T1 T2. T=Branching T1 T2\""], ["proof (prove)\nusing this:\n  delete ds T = Branching dT1 dT2\n\ngoal (1 subgoal):\n 1. \\<exists>T1 T2. T = Branching T1 T2", "(* Is there a lemma hidden here that I could extract? *)"], ["proof (prove)\nusing this:\n  delete ds T = Branching dT1 dT2\n\ngoal (1 subgoal):\n 1. \\<exists>T1 T2. T = Branching T1 T2", "by (cases T; cases ds) auto"], ["proof (state)\nthis:\n  \\<exists>T1 T2. T = Branching T1 T2\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "then"], ["proof (chain)\npicking this:\n  \\<exists>T1 T2. T = Branching T1 T2", "obtain T1 T2 where T1T2_p: \"T=Branching T1 T2\""], ["proof (prove)\nusing this:\n  \\<exists>T1 T2. T = Branching T1 T2\n\ngoal (1 subgoal):\n 1. (\\<And>T1 T2.\n        T = Branching T1 T2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  T = Branching T1 T2\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "{"], ["proof (state)\nthis:\n  T = Branching T1 T2\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "assume a_p: \"a\""], ["proof (state)\nthis:\n  a\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "assume b_p: \"\\<not>b\""], ["proof (state)\nthis:\n  \\<not> b\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "have \"branch (a # p) (delete ds T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. branch (a # p) (delete ds T)", "using Cons"], ["proof (prove)\nusing this:\n  branch p (delete ?ds ?T) \\<Longrightarrow> branch p ?T \\<or> p = ?ds\n  branch (a # p) (delete ds T)\n\ngoal (1 subgoal):\n 1. branch (a # p) (delete ds T)", "by -"], ["proof (state)\nthis:\n  branch (a # p) (delete ds T)\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "then"], ["proof (chain)\npicking this:\n  branch (a # p) (delete ds T)", "have \"branch (a # p) (Branching (T1) (delete ds' T2))\""], ["proof (prove)\nusing this:\n  branch (a # p) (delete ds T)\n\ngoal (1 subgoal):\n 1. branch (a # p) (Branching T1 (delete ds' T2))", "using b_p bds'_p T1T2_p"], ["proof (prove)\nusing this:\n  branch (a # p) (delete ds T)\n  \\<not> b\n  ds = b # ds'\n  T = Branching T1 T2\n\ngoal (1 subgoal):\n 1. branch (a # p) (Branching T1 (delete ds' T2))", "by auto"], ["proof (state)\nthis:\n  branch (a # p) (Branching T1 (delete ds' T2))\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "then"], ["proof (chain)\npicking this:\n  branch (a # p) (Branching T1 (delete ds' T2))", "have \"branch p T1\""], ["proof (prove)\nusing this:\n  branch (a # p) (Branching T1 (delete ds' T2))\n\ngoal (1 subgoal):\n 1. branch p T1", "using a_p"], ["proof (prove)\nusing this:\n  branch (a # p) (Branching T1 (delete ds' T2))\n  a\n\ngoal (1 subgoal):\n 1. branch p T1", "by auto"], ["proof (state)\nthis:\n  branch p T1\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "then"], ["proof (chain)\npicking this:\n  branch p T1", "have ?case"], ["proof (prove)\nusing this:\n  branch p T1\n\ngoal (1 subgoal):\n 1. branch (a # p) T \\<or> a # p = ds", "using T1T2_p a_p"], ["proof (prove)\nusing this:\n  branch p T1\n  T = Branching T1 T2\n  a\n\ngoal (1 subgoal):\n 1. branch (a # p) T \\<or> a # p = ds", "by auto"], ["proof (state)\nthis:\n  branch (a # p) T \\<or> a # p = ds\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "}"], ["proof (state)\nthis:\n  \\<lbrakk>a; \\<not> b\\<rbrakk>\n  \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>a; \\<not> b\\<rbrakk>\n  \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "{"], ["proof (state)\nthis:\n  \\<lbrakk>a; \\<not> b\\<rbrakk>\n  \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "assume a_p: \"\\<not>a\""], ["proof (state)\nthis:\n  \\<not> a\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "assume b_p: \"b\""], ["proof (state)\nthis:\n  b\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "have \"branch (a # p) (delete ds T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. branch (a # p) (delete ds T)", "using Cons"], ["proof (prove)\nusing this:\n  branch p (delete ?ds ?T) \\<Longrightarrow> branch p ?T \\<or> p = ?ds\n  branch (a # p) (delete ds T)\n\ngoal (1 subgoal):\n 1. branch (a # p) (delete ds T)", "by -"], ["proof (state)\nthis:\n  branch (a # p) (delete ds T)\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "then"], ["proof (chain)\npicking this:\n  branch (a # p) (delete ds T)", "have \"branch (a # p) (Branching (delete ds' T1) T2)\""], ["proof (prove)\nusing this:\n  branch (a # p) (delete ds T)\n\ngoal (1 subgoal):\n 1. branch (a # p) (Branching (delete ds' T1) T2)", "using b_p bds'_p T1T2_p"], ["proof (prove)\nusing this:\n  branch (a # p) (delete ds T)\n  b\n  ds = b # ds'\n  T = Branching T1 T2\n\ngoal (1 subgoal):\n 1. branch (a # p) (Branching (delete ds' T1) T2)", "by auto"], ["proof (state)\nthis:\n  branch (a # p) (Branching (delete ds' T1) T2)\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "then"], ["proof (chain)\npicking this:\n  branch (a # p) (Branching (delete ds' T1) T2)", "have \"branch p T2\""], ["proof (prove)\nusing this:\n  branch (a # p) (Branching (delete ds' T1) T2)\n\ngoal (1 subgoal):\n 1. branch p T2", "using a_p"], ["proof (prove)\nusing this:\n  branch (a # p) (Branching (delete ds' T1) T2)\n  \\<not> a\n\ngoal (1 subgoal):\n 1. branch p T2", "by auto"], ["proof (state)\nthis:\n  branch p T2\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "then"], ["proof (chain)\npicking this:\n  branch p T2", "have ?case"], ["proof (prove)\nusing this:\n  branch p T2\n\ngoal (1 subgoal):\n 1. branch (a # p) T \\<or> a # p = ds", "using T1T2_p a_p"], ["proof (prove)\nusing this:\n  branch p T2\n  T = Branching T1 T2\n  \\<not> a\n\ngoal (1 subgoal):\n 1. branch (a # p) T \\<or> a # p = ds", "by auto"], ["proof (state)\nthis:\n  branch (a # p) T \\<or> a # p = ds\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> a; b\\<rbrakk>\n  \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> a; b\\<rbrakk>\n  \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "{"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> a; b\\<rbrakk>\n  \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "assume a_p: \"a\""], ["proof (state)\nthis:\n  a\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "assume b_p: \"b\""], ["proof (state)\nthis:\n  b\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "have \"branch (a # p) (delete ds T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. branch (a # p) (delete ds T)", "using Cons"], ["proof (prove)\nusing this:\n  branch p (delete ?ds ?T) \\<Longrightarrow> branch p ?T \\<or> p = ?ds\n  branch (a # p) (delete ds T)\n\ngoal (1 subgoal):\n 1. branch (a # p) (delete ds T)", "by -"], ["proof (state)\nthis:\n  branch (a # p) (delete ds T)\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "then"], ["proof (chain)\npicking this:\n  branch (a # p) (delete ds T)", "have \"branch (a # p) (Branching (delete ds' T1) T2)\""], ["proof (prove)\nusing this:\n  branch (a # p) (delete ds T)\n\ngoal (1 subgoal):\n 1. branch (a # p) (Branching (delete ds' T1) T2)", "using b_p bds'_p T1T2_p"], ["proof (prove)\nusing this:\n  branch (a # p) (delete ds T)\n  b\n  ds = b # ds'\n  T = Branching T1 T2\n\ngoal (1 subgoal):\n 1. branch (a # p) (Branching (delete ds' T1) T2)", "by auto"], ["proof (state)\nthis:\n  branch (a # p) (Branching (delete ds' T1) T2)\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "then"], ["proof (chain)\npicking this:\n  branch (a # p) (Branching (delete ds' T1) T2)", "have \"branch p (delete ds' T1)\""], ["proof (prove)\nusing this:\n  branch (a # p) (Branching (delete ds' T1) T2)\n\ngoal (1 subgoal):\n 1. branch p (delete ds' T1)", "using a_p"], ["proof (prove)\nusing this:\n  branch (a # p) (Branching (delete ds' T1) T2)\n  a\n\ngoal (1 subgoal):\n 1. branch p (delete ds' T1)", "by auto"], ["proof (state)\nthis:\n  branch p (delete ds' T1)\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "then"], ["proof (chain)\npicking this:\n  branch p (delete ds' T1)", "have \"branch p T1 \\<or> p = ds'\""], ["proof (prove)\nusing this:\n  branch p (delete ds' T1)\n\ngoal (1 subgoal):\n 1. branch p T1 \\<or> p = ds'", "using Cons"], ["proof (prove)\nusing this:\n  branch p (delete ds' T1)\n  branch p (delete ?ds ?T) \\<Longrightarrow> branch p ?T \\<or> p = ?ds\n  branch (a # p) (delete ds T)\n\ngoal (1 subgoal):\n 1. branch p T1 \\<or> p = ds'", "by metis"], ["proof (state)\nthis:\n  branch p T1 \\<or> p = ds'\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "then"], ["proof (chain)\npicking this:\n  branch p T1 \\<or> p = ds'", "have ?case"], ["proof (prove)\nusing this:\n  branch p T1 \\<or> p = ds'\n\ngoal (1 subgoal):\n 1. branch (a # p) T \\<or> a # p = ds", "using T1T2_p a_p"], ["proof (prove)\nusing this:\n  branch p T1 \\<or> p = ds'\n  T = Branching T1 T2\n  a\n\ngoal (1 subgoal):\n 1. branch (a # p) T \\<or> a # p = ds", "using bds'_p a_p b_p"], ["proof (prove)\nusing this:\n  branch p T1 \\<or> p = ds'\n  T = Branching T1 T2\n  a\n  ds = b # ds'\n  a\n  b\n\ngoal (1 subgoal):\n 1. branch (a # p) T \\<or> a # p = ds", "by auto"], ["proof (state)\nthis:\n  branch (a # p) T \\<or> a # p = ds\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "}"], ["proof (state)\nthis:\n  \\<lbrakk>a; b\\<rbrakk> \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>a; b\\<rbrakk> \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "{"], ["proof (state)\nthis:\n  \\<lbrakk>a; b\\<rbrakk> \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "assume a_p: \"\\<not>a\""], ["proof (state)\nthis:\n  \\<not> a\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "assume b_p: \"\\<not>b\""], ["proof (state)\nthis:\n  \\<not> b\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "have \"branch (a # p) (delete ds T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. branch (a # p) (delete ds T)", "using Cons"], ["proof (prove)\nusing this:\n  branch p (delete ?ds ?T) \\<Longrightarrow> branch p ?T \\<or> p = ?ds\n  branch (a # p) (delete ds T)\n\ngoal (1 subgoal):\n 1. branch (a # p) (delete ds T)", "by -"], ["proof (state)\nthis:\n  branch (a # p) (delete ds T)\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "then"], ["proof (chain)\npicking this:\n  branch (a # p) (delete ds T)", "have \"branch (a # p) (Branching T1 (delete ds' T2))\""], ["proof (prove)\nusing this:\n  branch (a # p) (delete ds T)\n\ngoal (1 subgoal):\n 1. branch (a # p) (Branching T1 (delete ds' T2))", "using b_p bds'_p T1T2_p"], ["proof (prove)\nusing this:\n  branch (a # p) (delete ds T)\n  \\<not> b\n  ds = b # ds'\n  T = Branching T1 T2\n\ngoal (1 subgoal):\n 1. branch (a # p) (Branching T1 (delete ds' T2))", "by auto"], ["proof (state)\nthis:\n  branch (a # p) (Branching T1 (delete ds' T2))\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "then"], ["proof (chain)\npicking this:\n  branch (a # p) (Branching T1 (delete ds' T2))", "have \"branch p (delete ds' T2)\""], ["proof (prove)\nusing this:\n  branch (a # p) (Branching T1 (delete ds' T2))\n\ngoal (1 subgoal):\n 1. branch p (delete ds' T2)", "using a_p"], ["proof (prove)\nusing this:\n  branch (a # p) (Branching T1 (delete ds' T2))\n  \\<not> a\n\ngoal (1 subgoal):\n 1. branch p (delete ds' T2)", "by auto"], ["proof (state)\nthis:\n  branch p (delete ds' T2)\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "then"], ["proof (chain)\npicking this:\n  branch p (delete ds' T2)", "have \"branch p T2 \\<or> p = ds'\""], ["proof (prove)\nusing this:\n  branch p (delete ds' T2)\n\ngoal (1 subgoal):\n 1. branch p T2 \\<or> p = ds'", "using Cons"], ["proof (prove)\nusing this:\n  branch p (delete ds' T2)\n  branch p (delete ?ds ?T) \\<Longrightarrow> branch p ?T \\<or> p = ?ds\n  branch (a # p) (delete ds T)\n\ngoal (1 subgoal):\n 1. branch p T2 \\<or> p = ds'", "by metis"], ["proof (state)\nthis:\n  branch p T2 \\<or> p = ds'\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "then"], ["proof (chain)\npicking this:\n  branch p T2 \\<or> p = ds'", "have ?case"], ["proof (prove)\nusing this:\n  branch p T2 \\<or> p = ds'\n\ngoal (1 subgoal):\n 1. branch (a # p) T \\<or> a # p = ds", "using T1T2_p a_p"], ["proof (prove)\nusing this:\n  branch p T2 \\<or> p = ds'\n  T = Branching T1 T2\n  \\<not> a\n\ngoal (1 subgoal):\n 1. branch (a # p) T \\<or> a # p = ds", "using bds'_p a_p b_p"], ["proof (prove)\nusing this:\n  branch p T2 \\<or> p = ds'\n  T = Branching T1 T2\n  \\<not> a\n  ds = b # ds'\n  \\<not> a\n  \\<not> b\n\ngoal (1 subgoal):\n 1. branch (a # p) T \\<or> a # p = ds", "by auto"], ["proof (state)\nthis:\n  branch (a # p) T \\<or> a # p = ds\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> a; \\<not> b\\<rbrakk>\n  \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   branch p (delete ds T) \\<Longrightarrow>\n                   branch p T \\<or> p = ds;\n        branch (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>a; \\<not> b\\<rbrakk>\n  \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds\n  \\<lbrakk>\\<not> a; b\\<rbrakk>\n  \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds\n  \\<lbrakk>a; b\\<rbrakk> \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds\n  \\<lbrakk>\\<not> a; \\<not> b\\<rbrakk>\n  \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>a; \\<not> b\\<rbrakk>\n  \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds\n  \\<lbrakk>\\<not> a; b\\<rbrakk>\n  \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds\n  \\<lbrakk>a; b\\<rbrakk> \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds\n  \\<lbrakk>\\<not> a; \\<not> b\\<rbrakk>\n  \\<Longrightarrow> branch (a # p) T \\<or> a # p = ds\n\ngoal (1 subgoal):\n 1. branch (a # p) T \\<or> a # p = ds", "by blast"], ["proof (state)\nthis:\n  branch (a # p) T \\<or> a # p = ds\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma branch_delete_postfix: \n  assumes \"path p (delete ds T)\"\n  shows \"\\<not>(\\<exists>c cs. p = ds @ c#cs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>c cs. p = ds @ c # cs", "(* Adapted from previous proof *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<nexists>c cs. p = ds @ c # cs", "using assms"], ["proof (prove)\nusing this:\n  path p (delete ds T)\n\ngoal (1 subgoal):\n 1. \\<nexists>c cs. p = ds @ c # cs", "proof (induction p arbitrary: T ds)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>T ds.\n       path [] (delete ds T) \\<Longrightarrow>\n       \\<nexists>c cs. [] = ds @ c # cs\n 2. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   path p (delete ds T) \\<Longrightarrow>\n                   \\<nexists>c cs. p = ds @ c # cs;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs", "case Nil"], ["proof (state)\nthis:\n  path [] (delete ds T)\n\ngoal (2 subgoals):\n 1. \\<And>T ds.\n       path [] (delete ds T) \\<Longrightarrow>\n       \\<nexists>c cs. [] = ds @ c # cs\n 2. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   path p (delete ds T) \\<Longrightarrow>\n                   \\<nexists>c cs. p = ds @ c # cs;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs", "then"], ["proof (chain)\npicking this:\n  path [] (delete ds T)", "show ?case"], ["proof (prove)\nusing this:\n  path [] (delete ds T)\n\ngoal (1 subgoal):\n 1. \\<nexists>c cs. [] = ds @ c # cs", "by simp"], ["proof (state)\nthis:\n  \\<nexists>c cs. [] = ds @ c # cs\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   path p (delete ds T) \\<Longrightarrow>\n                   \\<nexists>c cs. p = ds @ c # cs;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   path p (delete ds T) \\<Longrightarrow>\n                   \\<nexists>c cs. p = ds @ c # cs;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs", "case (Cons a p)"], ["proof (state)\nthis:\n  path p (delete ?ds ?T) \\<Longrightarrow> \\<nexists>c cs. p = ?ds @ c # cs\n  path (a # p) (delete ds T)\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   path p (delete ds T) \\<Longrightarrow>\n                   \\<nexists>c cs. p = ds @ c # cs;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs", "then"], ["proof (chain)\npicking this:\n  path p (delete ?ds ?T) \\<Longrightarrow> \\<nexists>c cs. p = ?ds @ c # cs\n  path (a # p) (delete ds T)", "obtain b ds' where bds'_p: \"ds=b#ds'\""], ["proof (prove)\nusing this:\n  path p (delete ?ds ?T) \\<Longrightarrow> \\<nexists>c cs. p = ?ds @ c # cs\n  path (a # p) (delete ds T)\n\ngoal (1 subgoal):\n 1. (\\<And>b ds'. ds = b # ds' \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases ds) auto"], ["proof (state)\nthis:\n  ds = b # ds'\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   path p (delete ds T) \\<Longrightarrow>\n                   \\<nexists>c cs. p = ds @ c # cs;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs", "have \"\\<exists>dT1 dT2. delete ds T = Branching dT1 dT2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>dT1 dT2. delete ds T = Branching dT1 dT2", "using Cons path_inv_Cons"], ["proof (prove)\nusing this:\n  path p (delete ?ds ?T) \\<Longrightarrow> \\<nexists>c cs. p = ?ds @ c # cs\n  path (a # p) (delete ds T)\n  path (?a # ?ds) ?T \\<longrightarrow> (\\<exists>l r. ?T = Branching l r)\n\ngoal (1 subgoal):\n 1. \\<exists>dT1 dT2. delete ds T = Branching dT1 dT2", "by auto"], ["proof (state)\nthis:\n  \\<exists>dT1 dT2. delete ds T = Branching dT1 dT2\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   path p (delete ds T) \\<Longrightarrow>\n                   \\<nexists>c cs. p = ds @ c # cs;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs", "then"], ["proof (chain)\npicking this:\n  \\<exists>dT1 dT2. delete ds T = Branching dT1 dT2", "obtain dT1 dT2 where \"delete ds T = Branching dT1 dT2\""], ["proof (prove)\nusing this:\n  \\<exists>dT1 dT2. delete ds T = Branching dT1 dT2\n\ngoal (1 subgoal):\n 1. (\\<And>dT1 dT2.\n        delete ds T = Branching dT1 dT2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  delete ds T = Branching dT1 dT2\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   path p (delete ds T) \\<Longrightarrow>\n                   \\<nexists>c cs. p = ds @ c # cs;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs", "then"], ["proof (chain)\npicking this:\n  delete ds T = Branching dT1 dT2", "have \"\\<exists>T1 T2. T=Branching T1 T2\""], ["proof (prove)\nusing this:\n  delete ds T = Branching dT1 dT2\n\ngoal (1 subgoal):\n 1. \\<exists>T1 T2. T = Branching T1 T2", "(* Is there a lemma hidden here that I could extract? *)"], ["proof (prove)\nusing this:\n  delete ds T = Branching dT1 dT2\n\ngoal (1 subgoal):\n 1. \\<exists>T1 T2. T = Branching T1 T2", "by (cases T; cases ds) auto"], ["proof (state)\nthis:\n  \\<exists>T1 T2. T = Branching T1 T2\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   path p (delete ds T) \\<Longrightarrow>\n                   \\<nexists>c cs. p = ds @ c # cs;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs", "then"], ["proof (chain)\npicking this:\n  \\<exists>T1 T2. T = Branching T1 T2", "obtain T1 T2 where T1T2_p: \"T=Branching T1 T2\""], ["proof (prove)\nusing this:\n  \\<exists>T1 T2. T = Branching T1 T2\n\ngoal (1 subgoal):\n 1. (\\<And>T1 T2.\n        T = Branching T1 T2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  T = Branching T1 T2\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   path p (delete ds T) \\<Longrightarrow>\n                   \\<nexists>c cs. p = ds @ c # cs;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs", "{"], ["proof (state)\nthis:\n  T = Branching T1 T2\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   path p (delete ds T) \\<Longrightarrow>\n                   \\<nexists>c cs. p = ds @ c # cs;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs", "assume a_p: \"a\""], ["proof (state)\nthis:\n  a\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   path p (delete ds T) \\<Longrightarrow>\n                   \\<nexists>c cs. p = ds @ c # cs;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs", "assume b_p: \"\\<not>b\""], ["proof (state)\nthis:\n  \\<not> b\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   path p (delete ds T) \\<Longrightarrow>\n                   \\<nexists>c cs. p = ds @ c # cs;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs", "then"], ["proof (chain)\npicking this:\n  \\<not> b", "have ?case"], ["proof (prove)\nusing this:\n  \\<not> b\n\ngoal (1 subgoal):\n 1. \\<nexists>c cs. a # p = ds @ c # cs", "using T1T2_p a_p b_p bds'_p"], ["proof (prove)\nusing this:\n  \\<not> b\n  T = Branching T1 T2\n  a\n  \\<not> b\n  ds = b # ds'\n\ngoal (1 subgoal):\n 1. \\<nexists>c cs. a # p = ds @ c # cs", "by auto"], ["proof (state)\nthis:\n  \\<nexists>c cs. a # p = ds @ c # cs\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   path p (delete ds T) \\<Longrightarrow>\n                   \\<nexists>c cs. p = ds @ c # cs;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs", "}"], ["proof (state)\nthis:\n  \\<lbrakk>a; \\<not> b\\<rbrakk>\n  \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   path p (delete ds T) \\<Longrightarrow>\n                   \\<nexists>c cs. p = ds @ c # cs;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>a; \\<not> b\\<rbrakk>\n  \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   path p (delete ds T) \\<Longrightarrow>\n                   \\<nexists>c cs. p = ds @ c # cs;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs", "{"], ["proof (state)\nthis:\n  \\<lbrakk>a; \\<not> b\\<rbrakk>\n  \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   path p (delete ds T) \\<Longrightarrow>\n                   \\<nexists>c cs. p = ds @ c # cs;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs", "assume a_p: \"\\<not>a\""], ["proof (state)\nthis:\n  \\<not> a\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   path p (delete ds T) \\<Longrightarrow>\n                   \\<nexists>c cs. p = ds @ c # cs;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs", "assume b_p: \"b\""], ["proof (state)\nthis:\n  b\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   path p (delete ds T) \\<Longrightarrow>\n                   \\<nexists>c cs. p = ds @ c # cs;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs", "then"], ["proof (chain)\npicking this:\n  b", "have ?case"], ["proof (prove)\nusing this:\n  b\n\ngoal (1 subgoal):\n 1. \\<nexists>c cs. a # p = ds @ c # cs", "using T1T2_p a_p b_p bds'_p"], ["proof (prove)\nusing this:\n  b\n  T = Branching T1 T2\n  \\<not> a\n  b\n  ds = b # ds'\n\ngoal (1 subgoal):\n 1. \\<nexists>c cs. a # p = ds @ c # cs", "by auto"], ["proof (state)\nthis:\n  \\<nexists>c cs. a # p = ds @ c # cs\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   path p (delete ds T) \\<Longrightarrow>\n                   \\<nexists>c cs. p = ds @ c # cs;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> a; b\\<rbrakk>\n  \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   path p (delete ds T) \\<Longrightarrow>\n                   \\<nexists>c cs. p = ds @ c # cs;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> a; b\\<rbrakk>\n  \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   path p (delete ds T) \\<Longrightarrow>\n                   \\<nexists>c cs. p = ds @ c # cs;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs", "{"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> a; b\\<rbrakk>\n  \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   path p (delete ds T) \\<Longrightarrow>\n                   \\<nexists>c cs. p = ds @ c # cs;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs", "assume a_p: \"a\""], ["proof (state)\nthis:\n  a\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   path p (delete ds T) \\<Longrightarrow>\n                   \\<nexists>c cs. p = ds @ c # cs;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs", "assume b_p: \"b\""], ["proof (state)\nthis:\n  b\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   path p (delete ds T) \\<Longrightarrow>\n                   \\<nexists>c cs. p = ds @ c # cs;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs", "have \"path (a # p) (delete ds T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (a # p) (delete ds T)", "using Cons"], ["proof (prove)\nusing this:\n  path p (delete ?ds ?T) \\<Longrightarrow> \\<nexists>c cs. p = ?ds @ c # cs\n  path (a # p) (delete ds T)\n\ngoal (1 subgoal):\n 1. path (a # p) (delete ds T)", "by -"], ["proof (state)\nthis:\n  path (a # p) (delete ds T)\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   path p (delete ds T) \\<Longrightarrow>\n                   \\<nexists>c cs. p = ds @ c # cs;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs", "then"], ["proof (chain)\npicking this:\n  path (a # p) (delete ds T)", "have \"path (a # p) (Branching (delete ds' T1) T2)\""], ["proof (prove)\nusing this:\n  path (a # p) (delete ds T)\n\ngoal (1 subgoal):\n 1. path (a # p) (Branching (delete ds' T1) T2)", "using b_p bds'_p T1T2_p"], ["proof (prove)\nusing this:\n  path (a # p) (delete ds T)\n  b\n  ds = b # ds'\n  T = Branching T1 T2\n\ngoal (1 subgoal):\n 1. path (a # p) (Branching (delete ds' T1) T2)", "by auto"], ["proof (state)\nthis:\n  path (a # p) (Branching (delete ds' T1) T2)\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   path p (delete ds T) \\<Longrightarrow>\n                   \\<nexists>c cs. p = ds @ c # cs;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs", "then"], ["proof (chain)\npicking this:\n  path (a # p) (Branching (delete ds' T1) T2)", "have \"path p (delete ds' T1)\""], ["proof (prove)\nusing this:\n  path (a # p) (Branching (delete ds' T1) T2)\n\ngoal (1 subgoal):\n 1. path p (delete ds' T1)", "using a_p"], ["proof (prove)\nusing this:\n  path (a # p) (Branching (delete ds' T1) T2)\n  a\n\ngoal (1 subgoal):\n 1. path p (delete ds' T1)", "by auto"], ["proof (state)\nthis:\n  path p (delete ds' T1)\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   path p (delete ds T) \\<Longrightarrow>\n                   \\<nexists>c cs. p = ds @ c # cs;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs", "then"], ["proof (chain)\npicking this:\n  path p (delete ds' T1)", "have \"\\<not> (\\<exists>c cs. p = ds' @ c # cs)\""], ["proof (prove)\nusing this:\n  path p (delete ds' T1)\n\ngoal (1 subgoal):\n 1. \\<nexists>c cs. p = ds' @ c # cs", "using Cons"], ["proof (prove)\nusing this:\n  path p (delete ds' T1)\n  path p (delete ?ds ?T) \\<Longrightarrow> \\<nexists>c cs. p = ?ds @ c # cs\n  path (a # p) (delete ds T)\n\ngoal (1 subgoal):\n 1. \\<nexists>c cs. p = ds' @ c # cs", "by auto"], ["proof (state)\nthis:\n  \\<nexists>c cs. p = ds' @ c # cs\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   path p (delete ds T) \\<Longrightarrow>\n                   \\<nexists>c cs. p = ds @ c # cs;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs", "then"], ["proof (chain)\npicking this:\n  \\<nexists>c cs. p = ds' @ c # cs", "have ?case"], ["proof (prove)\nusing this:\n  \\<nexists>c cs. p = ds' @ c # cs\n\ngoal (1 subgoal):\n 1. \\<nexists>c cs. a # p = ds @ c # cs", "using T1T2_p a_p b_p bds'_p"], ["proof (prove)\nusing this:\n  \\<nexists>c cs. p = ds' @ c # cs\n  T = Branching T1 T2\n  a\n  b\n  ds = b # ds'\n\ngoal (1 subgoal):\n 1. \\<nexists>c cs. a # p = ds @ c # cs", "by auto"], ["proof (state)\nthis:\n  \\<nexists>c cs. a # p = ds @ c # cs\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   path p (delete ds T) \\<Longrightarrow>\n                   \\<nexists>c cs. p = ds @ c # cs;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs", "}"], ["proof (state)\nthis:\n  \\<lbrakk>a; b\\<rbrakk>\n  \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   path p (delete ds T) \\<Longrightarrow>\n                   \\<nexists>c cs. p = ds @ c # cs;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>a; b\\<rbrakk>\n  \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   path p (delete ds T) \\<Longrightarrow>\n                   \\<nexists>c cs. p = ds @ c # cs;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs", "{"], ["proof (state)\nthis:\n  \\<lbrakk>a; b\\<rbrakk>\n  \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   path p (delete ds T) \\<Longrightarrow>\n                   \\<nexists>c cs. p = ds @ c # cs;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs", "assume a_p: \"\\<not>a\""], ["proof (state)\nthis:\n  \\<not> a\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   path p (delete ds T) \\<Longrightarrow>\n                   \\<nexists>c cs. p = ds @ c # cs;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs", "assume b_p: \"\\<not>b\""], ["proof (state)\nthis:\n  \\<not> b\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   path p (delete ds T) \\<Longrightarrow>\n                   \\<nexists>c cs. p = ds @ c # cs;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs", "have \"path (a # p) (delete ds T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. path (a # p) (delete ds T)", "using Cons"], ["proof (prove)\nusing this:\n  path p (delete ?ds ?T) \\<Longrightarrow> \\<nexists>c cs. p = ?ds @ c # cs\n  path (a # p) (delete ds T)\n\ngoal (1 subgoal):\n 1. path (a # p) (delete ds T)", "by -"], ["proof (state)\nthis:\n  path (a # p) (delete ds T)\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   path p (delete ds T) \\<Longrightarrow>\n                   \\<nexists>c cs. p = ds @ c # cs;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs", "then"], ["proof (chain)\npicking this:\n  path (a # p) (delete ds T)", "have \"path (a # p) (Branching T1 (delete ds' T2))\""], ["proof (prove)\nusing this:\n  path (a # p) (delete ds T)\n\ngoal (1 subgoal):\n 1. path (a # p) (Branching T1 (delete ds' T2))", "using b_p bds'_p T1T2_p"], ["proof (prove)\nusing this:\n  path (a # p) (delete ds T)\n  \\<not> b\n  ds = b # ds'\n  T = Branching T1 T2\n\ngoal (1 subgoal):\n 1. path (a # p) (Branching T1 (delete ds' T2))", "by auto"], ["proof (state)\nthis:\n  path (a # p) (Branching T1 (delete ds' T2))\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   path p (delete ds T) \\<Longrightarrow>\n                   \\<nexists>c cs. p = ds @ c # cs;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs", "then"], ["proof (chain)\npicking this:\n  path (a # p) (Branching T1 (delete ds' T2))", "have \"path p (delete ds' T2)\""], ["proof (prove)\nusing this:\n  path (a # p) (Branching T1 (delete ds' T2))\n\ngoal (1 subgoal):\n 1. path p (delete ds' T2)", "using a_p"], ["proof (prove)\nusing this:\n  path (a # p) (Branching T1 (delete ds' T2))\n  \\<not> a\n\ngoal (1 subgoal):\n 1. path p (delete ds' T2)", "by auto"], ["proof (state)\nthis:\n  path p (delete ds' T2)\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   path p (delete ds T) \\<Longrightarrow>\n                   \\<nexists>c cs. p = ds @ c # cs;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs", "then"], ["proof (chain)\npicking this:\n  path p (delete ds' T2)", "have \"\\<not> (\\<exists>c cs. p = ds' @ c # cs)\""], ["proof (prove)\nusing this:\n  path p (delete ds' T2)\n\ngoal (1 subgoal):\n 1. \\<nexists>c cs. p = ds' @ c # cs", "using Cons"], ["proof (prove)\nusing this:\n  path p (delete ds' T2)\n  path p (delete ?ds ?T) \\<Longrightarrow> \\<nexists>c cs. p = ?ds @ c # cs\n  path (a # p) (delete ds T)\n\ngoal (1 subgoal):\n 1. \\<nexists>c cs. p = ds' @ c # cs", "by auto"], ["proof (state)\nthis:\n  \\<nexists>c cs. p = ds' @ c # cs\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   path p (delete ds T) \\<Longrightarrow>\n                   \\<nexists>c cs. p = ds @ c # cs;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs", "then"], ["proof (chain)\npicking this:\n  \\<nexists>c cs. p = ds' @ c # cs", "have ?case"], ["proof (prove)\nusing this:\n  \\<nexists>c cs. p = ds' @ c # cs\n\ngoal (1 subgoal):\n 1. \\<nexists>c cs. a # p = ds @ c # cs", "using T1T2_p a_p b_p bds'_p"], ["proof (prove)\nusing this:\n  \\<nexists>c cs. p = ds' @ c # cs\n  T = Branching T1 T2\n  \\<not> a\n  \\<not> b\n  ds = b # ds'\n\ngoal (1 subgoal):\n 1. \\<nexists>c cs. a # p = ds @ c # cs", "by auto"], ["proof (state)\nthis:\n  \\<nexists>c cs. a # p = ds @ c # cs\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   path p (delete ds T) \\<Longrightarrow>\n                   \\<nexists>c cs. p = ds @ c # cs;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs", "}"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> a; \\<not> b\\<rbrakk>\n  \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs\n\ngoal (1 subgoal):\n 1. \\<And>a p T ds.\n       \\<lbrakk>\\<And>T ds.\n                   path p (delete ds T) \\<Longrightarrow>\n                   \\<nexists>c cs. p = ds @ c # cs;\n        path (a # p) (delete ds T)\\<rbrakk>\n       \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs", "ultimately"], ["proof (chain)\npicking this:\n  \\<lbrakk>a; \\<not> b\\<rbrakk>\n  \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs\n  \\<lbrakk>\\<not> a; b\\<rbrakk>\n  \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs\n  \\<lbrakk>a; b\\<rbrakk>\n  \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs\n  \\<lbrakk>\\<not> a; \\<not> b\\<rbrakk>\n  \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>a; \\<not> b\\<rbrakk>\n  \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs\n  \\<lbrakk>\\<not> a; b\\<rbrakk>\n  \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs\n  \\<lbrakk>a; b\\<rbrakk>\n  \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs\n  \\<lbrakk>\\<not> a; \\<not> b\\<rbrakk>\n  \\<Longrightarrow> \\<nexists>c cs. a # p = ds @ c # cs\n\ngoal (1 subgoal):\n 1. \\<nexists>c cs. a # p = ds @ c # cs", "by blast"], ["proof (state)\nthis:\n  \\<nexists>c cs. a # p = ds @ c # cs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma treezise_delete: \n  assumes \"internal p T\"\n  shows \"treesize (delete p T) < treesize T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. treesize (delete p T) < treesize T", "using assms"], ["proof (prove)\nusing this:\n  internal p T\n\ngoal (1 subgoal):\n 1. treesize (delete p T) < treesize T", "proof (induction p arbitrary: T)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>T.\n       internal [] T \\<Longrightarrow> treesize (delete [] T) < treesize T\n 2. \\<And>a p T.\n       \\<lbrakk>\\<And>T.\n                   internal p T \\<Longrightarrow>\n                   treesize (delete p T) < treesize T;\n        internal (a # p) T\\<rbrakk>\n       \\<Longrightarrow> treesize (delete (a # p) T) < treesize T", "case (Nil)"], ["proof (state)\nthis:\n  internal [] T\n\ngoal (2 subgoals):\n 1. \\<And>T.\n       internal [] T \\<Longrightarrow> treesize (delete [] T) < treesize T\n 2. \\<And>a p T.\n       \\<lbrakk>\\<And>T.\n                   internal p T \\<Longrightarrow>\n                   treesize (delete p T) < treesize T;\n        internal (a # p) T\\<rbrakk>\n       \\<Longrightarrow> treesize (delete (a # p) T) < treesize T", "then"], ["proof (chain)\npicking this:\n  internal [] T", "have \"\\<exists>T1 T2. T = Branching T1 T2\""], ["proof (prove)\nusing this:\n  internal [] T\n\ngoal (1 subgoal):\n 1. \\<exists>T1 T2. T = Branching T1 T2", "by (cases T) auto"], ["proof (state)\nthis:\n  \\<exists>T1 T2. T = Branching T1 T2\n\ngoal (2 subgoals):\n 1. \\<And>T.\n       internal [] T \\<Longrightarrow> treesize (delete [] T) < treesize T\n 2. \\<And>a p T.\n       \\<lbrakk>\\<And>T.\n                   internal p T \\<Longrightarrow>\n                   treesize (delete p T) < treesize T;\n        internal (a # p) T\\<rbrakk>\n       \\<Longrightarrow> treesize (delete (a # p) T) < treesize T", "then"], ["proof (chain)\npicking this:\n  \\<exists>T1 T2. T = Branching T1 T2", "obtain T1 T2 where T1T2_p: \"T = Branching T1 T2\""], ["proof (prove)\nusing this:\n  \\<exists>T1 T2. T = Branching T1 T2\n\ngoal (1 subgoal):\n 1. (\\<And>T1 T2.\n        T = Branching T1 T2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  T = Branching T1 T2\n\ngoal (2 subgoals):\n 1. \\<And>T.\n       internal [] T \\<Longrightarrow> treesize (delete [] T) < treesize T\n 2. \\<And>a p T.\n       \\<lbrakk>\\<And>T.\n                   internal p T \\<Longrightarrow>\n                   treesize (delete p T) < treesize T;\n        internal (a # p) T\\<rbrakk>\n       \\<Longrightarrow> treesize (delete (a # p) T) < treesize T", "then"], ["proof (chain)\npicking this:\n  T = Branching T1 T2", "show ?case"], ["proof (prove)\nusing this:\n  T = Branching T1 T2\n\ngoal (1 subgoal):\n 1. treesize (delete [] T) < treesize T", "by auto"], ["proof (state)\nthis:\n  treesize (delete [] T) < treesize T\n\ngoal (1 subgoal):\n 1. \\<And>a p T.\n       \\<lbrakk>\\<And>T.\n                   internal p T \\<Longrightarrow>\n                   treesize (delete p T) < treesize T;\n        internal (a # p) T\\<rbrakk>\n       \\<Longrightarrow> treesize (delete (a # p) T) < treesize T", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a p T.\n       \\<lbrakk>\\<And>T.\n                   internal p T \\<Longrightarrow>\n                   treesize (delete p T) < treesize T;\n        internal (a # p) T\\<rbrakk>\n       \\<Longrightarrow> treesize (delete (a # p) T) < treesize T", "case (Cons a p)"], ["proof (state)\nthis:\n  internal p ?T \\<Longrightarrow> treesize (delete p ?T) < treesize ?T\n  internal (a # p) T\n\ngoal (1 subgoal):\n 1. \\<And>a p T.\n       \\<lbrakk>\\<And>T.\n                   internal p T \\<Longrightarrow>\n                   treesize (delete p T) < treesize T;\n        internal (a # p) T\\<rbrakk>\n       \\<Longrightarrow> treesize (delete (a # p) T) < treesize T", "then"], ["proof (chain)\npicking this:\n  internal p ?T \\<Longrightarrow> treesize (delete p ?T) < treesize ?T\n  internal (a # p) T", "have \"\\<exists>T1 T2. T = Branching T1 T2\""], ["proof (prove)\nusing this:\n  internal p ?T \\<Longrightarrow> treesize (delete p ?T) < treesize ?T\n  internal (a # p) T\n\ngoal (1 subgoal):\n 1. \\<exists>T1 T2. T = Branching T1 T2", "using path_inv_Cons internal_is_path"], ["proof (prove)\nusing this:\n  internal p ?T \\<Longrightarrow> treesize (delete p ?T) < treesize ?T\n  internal (a # p) T\n  path (?a # ?ds) ?T \\<longrightarrow> (\\<exists>l r. ?T = Branching l r)\n  internal ?ds ?T \\<Longrightarrow> path ?ds ?T\n\ngoal (1 subgoal):\n 1. \\<exists>T1 T2. T = Branching T1 T2", "by blast"], ["proof (state)\nthis:\n  \\<exists>T1 T2. T = Branching T1 T2\n\ngoal (1 subgoal):\n 1. \\<And>a p T.\n       \\<lbrakk>\\<And>T.\n                   internal p T \\<Longrightarrow>\n                   treesize (delete p T) < treesize T;\n        internal (a # p) T\\<rbrakk>\n       \\<Longrightarrow> treesize (delete (a # p) T) < treesize T", "then"], ["proof (chain)\npicking this:\n  \\<exists>T1 T2. T = Branching T1 T2", "obtain T1 T2 where T1T2_p: \"T = Branching T1 T2\""], ["proof (prove)\nusing this:\n  \\<exists>T1 T2. T = Branching T1 T2\n\ngoal (1 subgoal):\n 1. (\\<And>T1 T2.\n        T = Branching T1 T2 \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  T = Branching T1 T2\n\ngoal (1 subgoal):\n 1. \\<And>a p T.\n       \\<lbrakk>\\<And>T.\n                   internal p T \\<Longrightarrow>\n                   treesize (delete p T) < treesize T;\n        internal (a # p) T\\<rbrakk>\n       \\<Longrightarrow> treesize (delete (a # p) T) < treesize T", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. treesize (delete (a # p) T) < treesize T", "proof (cases a)"], ["proof (state)\ngoal (2 subgoals):\n 1. a \\<Longrightarrow> treesize (delete (a # p) T) < treesize T\n 2. \\<not> a \\<Longrightarrow> treesize (delete (a # p) T) < treesize T", "assume a_p: a"], ["proof (state)\nthis:\n  a\n\ngoal (2 subgoals):\n 1. a \\<Longrightarrow> treesize (delete (a # p) T) < treesize T\n 2. \\<not> a \\<Longrightarrow> treesize (delete (a # p) T) < treesize T", "from a_p"], ["proof (chain)\npicking this:\n  a", "have \"delete (a#p) T = (Branching (delete p T1) T2)\""], ["proof (prove)\nusing this:\n  a\n\ngoal (1 subgoal):\n 1. delete (a # p) T = Branching (delete p T1) T2", "using T1T2_p"], ["proof (prove)\nusing this:\n  a\n  T = Branching T1 T2\n\ngoal (1 subgoal):\n 1. delete (a # p) T = Branching (delete p T1) T2", "by auto"], ["proof (state)\nthis:\n  delete (a # p) T = Branching (delete p T1) T2\n\ngoal (2 subgoals):\n 1. a \\<Longrightarrow> treesize (delete (a # p) T) < treesize T\n 2. \\<not> a \\<Longrightarrow> treesize (delete (a # p) T) < treesize T", "moreover"], ["proof (state)\nthis:\n  delete (a # p) T = Branching (delete p T1) T2\n\ngoal (2 subgoals):\n 1. a \\<Longrightarrow> treesize (delete (a # p) T) < treesize T\n 2. \\<not> a \\<Longrightarrow> treesize (delete (a # p) T) < treesize T", "from a_p"], ["proof (chain)\npicking this:\n  a", "have \"internal p T1\""], ["proof (prove)\nusing this:\n  a\n\ngoal (1 subgoal):\n 1. internal p T1", "using T1T2_p Cons"], ["proof (prove)\nusing this:\n  a\n  T = Branching T1 T2\n  internal p ?T \\<Longrightarrow> treesize (delete p ?T) < treesize ?T\n  internal (a # p) T\n\ngoal (1 subgoal):\n 1. internal p T1", "by auto"], ["proof (state)\nthis:\n  internal p T1\n\ngoal (2 subgoals):\n 1. a \\<Longrightarrow> treesize (delete (a # p) T) < treesize T\n 2. \\<not> a \\<Longrightarrow> treesize (delete (a # p) T) < treesize T", "then"], ["proof (chain)\npicking this:\n  internal p T1", "have \"treesize (delete p T1) < treesize T1\""], ["proof (prove)\nusing this:\n  internal p T1\n\ngoal (1 subgoal):\n 1. treesize (delete p T1) < treesize T1", "using Cons"], ["proof (prove)\nusing this:\n  internal p T1\n  internal p ?T \\<Longrightarrow> treesize (delete p ?T) < treesize ?T\n  internal (a # p) T\n\ngoal (1 subgoal):\n 1. treesize (delete p T1) < treesize T1", "by auto"], ["proof (state)\nthis:\n  treesize (delete p T1) < treesize T1\n\ngoal (2 subgoals):\n 1. a \\<Longrightarrow> treesize (delete (a # p) T) < treesize T\n 2. \\<not> a \\<Longrightarrow> treesize (delete (a # p) T) < treesize T", "ultimately"], ["proof (chain)\npicking this:\n  delete (a # p) T = Branching (delete p T1) T2\n  treesize (delete p T1) < treesize T1", "show ?thesis"], ["proof (prove)\nusing this:\n  delete (a # p) T = Branching (delete p T1) T2\n  treesize (delete p T1) < treesize T1\n\ngoal (1 subgoal):\n 1. treesize (delete (a # p) T) < treesize T", "using T1T2_p"], ["proof (prove)\nusing this:\n  delete (a # p) T = Branching (delete p T1) T2\n  treesize (delete p T1) < treesize T1\n  T = Branching T1 T2\n\ngoal (1 subgoal):\n 1. treesize (delete (a # p) T) < treesize T", "by auto"], ["proof (state)\nthis:\n  treesize (delete (a # p) T) < treesize T\n\ngoal (1 subgoal):\n 1. \\<not> a \\<Longrightarrow> treesize (delete (a # p) T) < treesize T", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> a \\<Longrightarrow> treesize (delete (a # p) T) < treesize T", "assume a_p: \"\\<not>a\""], ["proof (state)\nthis:\n  \\<not> a\n\ngoal (1 subgoal):\n 1. \\<not> a \\<Longrightarrow> treesize (delete (a # p) T) < treesize T", "from a_p"], ["proof (chain)\npicking this:\n  \\<not> a", "have \"delete (a#p) T = (Branching T1 (delete p T2))\""], ["proof (prove)\nusing this:\n  \\<not> a\n\ngoal (1 subgoal):\n 1. delete (a # p) T = Branching T1 (delete p T2)", "using T1T2_p"], ["proof (prove)\nusing this:\n  \\<not> a\n  T = Branching T1 T2\n\ngoal (1 subgoal):\n 1. delete (a # p) T = Branching T1 (delete p T2)", "by auto"], ["proof (state)\nthis:\n  delete (a # p) T = Branching T1 (delete p T2)\n\ngoal (1 subgoal):\n 1. \\<not> a \\<Longrightarrow> treesize (delete (a # p) T) < treesize T", "moreover"], ["proof (state)\nthis:\n  delete (a # p) T = Branching T1 (delete p T2)\n\ngoal (1 subgoal):\n 1. \\<not> a \\<Longrightarrow> treesize (delete (a # p) T) < treesize T", "from a_p"], ["proof (chain)\npicking this:\n  \\<not> a", "have \"internal p T2\""], ["proof (prove)\nusing this:\n  \\<not> a\n\ngoal (1 subgoal):\n 1. internal p T2", "using T1T2_p Cons"], ["proof (prove)\nusing this:\n  \\<not> a\n  T = Branching T1 T2\n  internal p ?T \\<Longrightarrow> treesize (delete p ?T) < treesize ?T\n  internal (a # p) T\n\ngoal (1 subgoal):\n 1. internal p T2", "by auto"], ["proof (state)\nthis:\n  internal p T2\n\ngoal (1 subgoal):\n 1. \\<not> a \\<Longrightarrow> treesize (delete (a # p) T) < treesize T", "then"], ["proof (chain)\npicking this:\n  internal p T2", "have \"treesize (delete p T2) < treesize T2\""], ["proof (prove)\nusing this:\n  internal p T2\n\ngoal (1 subgoal):\n 1. treesize (delete p T2) < treesize T2", "using Cons"], ["proof (prove)\nusing this:\n  internal p T2\n  internal p ?T \\<Longrightarrow> treesize (delete p ?T) < treesize ?T\n  internal (a # p) T\n\ngoal (1 subgoal):\n 1. treesize (delete p T2) < treesize T2", "by auto"], ["proof (state)\nthis:\n  treesize (delete p T2) < treesize T2\n\ngoal (1 subgoal):\n 1. \\<not> a \\<Longrightarrow> treesize (delete (a # p) T) < treesize T", "ultimately"], ["proof (chain)\npicking this:\n  delete (a # p) T = Branching T1 (delete p T2)\n  treesize (delete p T2) < treesize T2", "show ?thesis"], ["proof (prove)\nusing this:\n  delete (a # p) T = Branching T1 (delete p T2)\n  treesize (delete p T2) < treesize T2\n\ngoal (1 subgoal):\n 1. treesize (delete (a # p) T) < treesize T", "using T1T2_p"], ["proof (prove)\nusing this:\n  delete (a # p) T = Branching T1 (delete p T2)\n  treesize (delete p T2) < treesize T2\n  T = Branching T1 T2\n\ngoal (1 subgoal):\n 1. treesize (delete (a # p) T) < treesize T", "by auto"], ["proof (state)\nthis:\n  treesize (delete (a # p) T) < treesize T\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  treesize (delete (a # p) T) < treesize T\n\ngoal:\nNo subgoals!", "qed"], ["", "fun cutoff :: \"(dir list \\<Rightarrow> bool) \\<Rightarrow> dir list \\<Rightarrow> tree \\<Rightarrow> tree\" where\n  \"cutoff red ds (Branching T\\<^sub>1 T\\<^sub>2) = \n     (if red ds then Leaf else Branching (cutoff red (ds@[Left])  T\\<^sub>1) (cutoff red (ds@[Right]) T\\<^sub>2))\"\n| \"cutoff red ds Leaf = Leaf\""], ["", "text \\<open>Initially you should call @{const cutoff} with @{term \"ds = []\"}.\n If all branches are red, then @{const cutoff} gives a subtree.\n If all branches are red, then so are the ones in @{const cutoff}.\n The internal paths of @{const cutoff} are not red.\\<close>"], ["", "lemma treesize_cutoff: \"treesize (cutoff red ds T) \\<le> treesize T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. treesize (cutoff red ds T) \\<le> treesize T", "proof (induction T arbitrary: ds)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ds. treesize (cutoff red ds Leaf) \\<le> treesize Leaf\n 2. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds. treesize (cutoff red ds T1) \\<le> treesize T1;\n        \\<And>ds. treesize (cutoff red ds T2) \\<le> treesize T2\\<rbrakk>\n       \\<Longrightarrow> treesize (cutoff red ds (Branching T1 T2))\n                         \\<le> treesize (Branching T1 T2)", "case Leaf"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>ds. treesize (cutoff red ds Leaf) \\<le> treesize Leaf\n 2. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds. treesize (cutoff red ds T1) \\<le> treesize T1;\n        \\<And>ds. treesize (cutoff red ds T2) \\<le> treesize T2\\<rbrakk>\n       \\<Longrightarrow> treesize (cutoff red ds (Branching T1 T2))\n                         \\<le> treesize (Branching T1 T2)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. treesize (cutoff red ds Leaf) \\<le> treesize Leaf", "by auto"], ["proof (state)\nthis:\n  treesize (cutoff red ds Leaf) \\<le> treesize Leaf\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds. treesize (cutoff red ds T1) \\<le> treesize T1;\n        \\<And>ds. treesize (cutoff red ds T2) \\<le> treesize T2\\<rbrakk>\n       \\<Longrightarrow> treesize (cutoff red ds (Branching T1 T2))\n                         \\<le> treesize (Branching T1 T2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds. treesize (cutoff red ds T1) \\<le> treesize T1;\n        \\<And>ds. treesize (cutoff red ds T2) \\<le> treesize T2\\<rbrakk>\n       \\<Longrightarrow> treesize (cutoff red ds (Branching T1 T2))\n                         \\<le> treesize (Branching T1 T2)", "case (Branching T1 T2)"], ["proof (state)\nthis:\n  treesize (cutoff red ?ds T1) \\<le> treesize T1\n  treesize (cutoff red ?ds T2) \\<le> treesize T2\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds. treesize (cutoff red ds T1) \\<le> treesize T1;\n        \\<And>ds. treesize (cutoff red ds T2) \\<le> treesize T2\\<rbrakk>\n       \\<Longrightarrow> treesize (cutoff red ds (Branching T1 T2))\n                         \\<le> treesize (Branching T1 T2)", "then"], ["proof (chain)\npicking this:\n  treesize (cutoff red ?ds T1) \\<le> treesize T1\n  treesize (cutoff red ?ds T2) \\<le> treesize T2", "have \"treesize (cutoff red (ds@[Left]) T1) + treesize (cutoff red (ds@[Right]) T2) \\<le> treesize T1 + treesize T2\""], ["proof (prove)\nusing this:\n  treesize (cutoff red ?ds T1) \\<le> treesize T1\n  treesize (cutoff red ?ds T2) \\<le> treesize T2\n\ngoal (1 subgoal):\n 1. treesize (cutoff red (ds @ [Left]) T1) +\n    treesize (cutoff red (ds @ [Right]) T2)\n    \\<le> treesize T1 + treesize T2", "using add_mono"], ["proof (prove)\nusing this:\n  treesize (cutoff red ?ds T1) \\<le> treesize T1\n  treesize (cutoff red ?ds T2) \\<le> treesize T2\n  \\<lbrakk>?a \\<le> ?b; ?c \\<le> ?d\\<rbrakk>\n  \\<Longrightarrow> ?a + ?c \\<le> ?b + ?d\n\ngoal (1 subgoal):\n 1. treesize (cutoff red (ds @ [Left]) T1) +\n    treesize (cutoff red (ds @ [Right]) T2)\n    \\<le> treesize T1 + treesize T2", "by blast"], ["proof (state)\nthis:\n  treesize (cutoff red (ds @ [Left]) T1) +\n  treesize (cutoff red (ds @ [Right]) T2)\n  \\<le> treesize T1 + treesize T2\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds. treesize (cutoff red ds T1) \\<le> treesize T1;\n        \\<And>ds. treesize (cutoff red ds T2) \\<le> treesize T2\\<rbrakk>\n       \\<Longrightarrow> treesize (cutoff red ds (Branching T1 T2))\n                         \\<le> treesize (Branching T1 T2)", "then"], ["proof (chain)\npicking this:\n  treesize (cutoff red (ds @ [Left]) T1) +\n  treesize (cutoff red (ds @ [Right]) T2)\n  \\<le> treesize T1 + treesize T2", "show ?case"], ["proof (prove)\nusing this:\n  treesize (cutoff red (ds @ [Left]) T1) +\n  treesize (cutoff red (ds @ [Right]) T2)\n  \\<le> treesize T1 + treesize T2\n\ngoal (1 subgoal):\n 1. treesize (cutoff red ds (Branching T1 T2))\n    \\<le> treesize (Branching T1 T2)", "by auto"], ["proof (state)\nthis:\n  treesize (cutoff red ds (Branching T1 T2))\n  \\<le> treesize (Branching T1 T2)\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation anypath :: \"tree \\<Rightarrow> (dir list \\<Rightarrow> bool) \\<Rightarrow> bool\" where\n  \"anypath T P \\<equiv> \\<forall>p. path p T \\<longrightarrow> P p\""], ["", "abbreviation anybranch :: \"tree \\<Rightarrow> (dir list \\<Rightarrow> bool) \\<Rightarrow> bool\" where\n  \"anybranch T P \\<equiv> \\<forall>p. branch p T \\<longrightarrow> P p\""], ["", "abbreviation anyinternal :: \"tree \\<Rightarrow> (dir list \\<Rightarrow> bool) \\<Rightarrow> bool\" where\n  \"anyinternal T P \\<equiv> \\<forall>p. internal p T \\<longrightarrow> P p\""], ["", "lemma cutoff_branch': \n  assumes \"anybranch T (\\<lambda>b. red(ds@b))\"\n  shows \"anybranch (cutoff red ds T) (\\<lambda>b. red(ds@b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. anybranch (cutoff red ds T) (\\<lambda>p. red (ds @ p))", "using assms"], ["proof (prove)\nusing this:\n  anybranch T (\\<lambda>p. red (ds @ p))\n\ngoal (1 subgoal):\n 1. anybranch (cutoff red ds T) (\\<lambda>p. red (ds @ p))", "proof (induction T arbitrary: ds)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ds.\n       anybranch Leaf (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n       anybranch (cutoff red ds Leaf) (\\<lambda>p. red (ds @ p))\n 2. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anybranch (cutoff red ds T1) (\\<lambda>p. red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anybranch (cutoff red ds T2) (\\<lambda>p. red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anybranch (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. red (ds @ p))", "(* This proof seems a bit excessive for such a simple theorem *)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ds.\n       anybranch Leaf (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n       anybranch (cutoff red ds Leaf) (\\<lambda>p. red (ds @ p))\n 2. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anybranch (cutoff red ds T1) (\\<lambda>p. red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anybranch (cutoff red ds T2) (\\<lambda>p. red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anybranch (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. red (ds @ p))", "case (Leaf)"], ["proof (state)\nthis:\n  anybranch Leaf (\\<lambda>p. red (ds @ p))\n\ngoal (2 subgoals):\n 1. \\<And>ds.\n       anybranch Leaf (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n       anybranch (cutoff red ds Leaf) (\\<lambda>p. red (ds @ p))\n 2. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anybranch (cutoff red ds T1) (\\<lambda>p. red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anybranch (cutoff red ds T2) (\\<lambda>p. red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anybranch (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. red (ds @ p))", "let ?T = \"cutoff red ds Leaf\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ds.\n       anybranch Leaf (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n       anybranch (cutoff red ds Leaf) (\\<lambda>p. red (ds @ p))\n 2. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anybranch (cutoff red ds T1) (\\<lambda>p. red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anybranch (cutoff red ds T2) (\\<lambda>p. red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anybranch (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. red (ds @ p))", "{"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ds.\n       anybranch Leaf (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n       anybranch (cutoff red ds Leaf) (\\<lambda>p. red (ds @ p))\n 2. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anybranch (cutoff red ds T1) (\\<lambda>p. red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anybranch (cutoff red ds T2) (\\<lambda>p. red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anybranch (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. red (ds @ p))", "fix b"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ds.\n       anybranch Leaf (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n       anybranch (cutoff red ds Leaf) (\\<lambda>p. red (ds @ p))\n 2. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anybranch (cutoff red ds T1) (\\<lambda>p. red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anybranch (cutoff red ds T2) (\\<lambda>p. red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anybranch (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. red (ds @ p))", "assume \"branch b ?T\""], ["proof (state)\nthis:\n  branch b (cutoff red ds Leaf)\n\ngoal (2 subgoals):\n 1. \\<And>ds.\n       anybranch Leaf (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n       anybranch (cutoff red ds Leaf) (\\<lambda>p. red (ds @ p))\n 2. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anybranch (cutoff red ds T1) (\\<lambda>p. red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anybranch (cutoff red ds T2) (\\<lambda>p. red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anybranch (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. red (ds @ p))", "then"], ["proof (chain)\npicking this:\n  branch b (cutoff red ds Leaf)", "have \"branch b Leaf\""], ["proof (prove)\nusing this:\n  branch b (cutoff red ds Leaf)\n\ngoal (1 subgoal):\n 1. branch b Leaf", "by auto"], ["proof (state)\nthis:\n  branch b Leaf\n\ngoal (2 subgoals):\n 1. \\<And>ds.\n       anybranch Leaf (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n       anybranch (cutoff red ds Leaf) (\\<lambda>p. red (ds @ p))\n 2. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anybranch (cutoff red ds T1) (\\<lambda>p. red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anybranch (cutoff red ds T2) (\\<lambda>p. red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anybranch (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. red (ds @ p))", "then"], ["proof (chain)\npicking this:\n  branch b Leaf", "have \"red(ds@b)\""], ["proof (prove)\nusing this:\n  branch b Leaf\n\ngoal (1 subgoal):\n 1. red (ds @ b)", "using Leaf"], ["proof (prove)\nusing this:\n  branch b Leaf\n  anybranch Leaf (\\<lambda>p. red (ds @ p))\n\ngoal (1 subgoal):\n 1. red (ds @ b)", "by auto"], ["proof (state)\nthis:\n  red (ds @ b)\n\ngoal (2 subgoals):\n 1. \\<And>ds.\n       anybranch Leaf (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n       anybranch (cutoff red ds Leaf) (\\<lambda>p. red (ds @ p))\n 2. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anybranch (cutoff red ds T1) (\\<lambda>p. red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anybranch (cutoff red ds T2) (\\<lambda>p. red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anybranch (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. red (ds @ p))", "}"], ["proof (state)\nthis:\n  branch ?b2 (cutoff red ds Leaf) \\<Longrightarrow> red (ds @ ?b2)\n\ngoal (2 subgoals):\n 1. \\<And>ds.\n       anybranch Leaf (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n       anybranch (cutoff red ds Leaf) (\\<lambda>p. red (ds @ p))\n 2. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anybranch (cutoff red ds T1) (\\<lambda>p. red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anybranch (cutoff red ds T2) (\\<lambda>p. red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anybranch (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. red (ds @ p))", "then"], ["proof (chain)\npicking this:\n  branch ?b2 (cutoff red ds Leaf) \\<Longrightarrow> red (ds @ ?b2)", "show ?case"], ["proof (prove)\nusing this:\n  branch ?b2 (cutoff red ds Leaf) \\<Longrightarrow> red (ds @ ?b2)\n\ngoal (1 subgoal):\n 1. anybranch (cutoff red ds Leaf) (\\<lambda>p. red (ds @ p))", "by simp"], ["proof (state)\nthis:\n  anybranch (cutoff red ds Leaf) (\\<lambda>p. red (ds @ p))\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anybranch (cutoff red ds T1) (\\<lambda>p. red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anybranch (cutoff red ds T2) (\\<lambda>p. red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anybranch (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. red (ds @ p))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anybranch (cutoff red ds T1) (\\<lambda>p. red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anybranch (cutoff red ds T2) (\\<lambda>p. red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anybranch (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. red (ds @ p))", "case (Branching T\\<^sub>1 T\\<^sub>2)"], ["proof (state)\nthis:\n  anybranch T\\<^sub>1 (\\<lambda>p. red (?ds @ p)) \\<Longrightarrow>\n  anybranch (cutoff red ?ds T\\<^sub>1) (\\<lambda>p. red (?ds @ p))\n  anybranch T\\<^sub>2 (\\<lambda>p. red (?ds @ p)) \\<Longrightarrow>\n  anybranch (cutoff red ?ds T\\<^sub>2) (\\<lambda>p. red (?ds @ p))\n  anybranch (Branching T\\<^sub>1 T\\<^sub>2) (\\<lambda>p. red (ds @ p))\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anybranch (cutoff red ds T1) (\\<lambda>p. red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anybranch (cutoff red ds T2) (\\<lambda>p. red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anybranch (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. red (ds @ p))", "let ?T = \"cutoff red ds (Branching T\\<^sub>1 T\\<^sub>2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anybranch (cutoff red ds T1) (\\<lambda>p. red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anybranch (cutoff red ds T2) (\\<lambda>p. red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anybranch (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. red (ds @ p))", "from Branching"], ["proof (chain)\npicking this:\n  anybranch T\\<^sub>1 (\\<lambda>p. red (?ds @ p)) \\<Longrightarrow>\n  anybranch (cutoff red ?ds T\\<^sub>1) (\\<lambda>p. red (?ds @ p))\n  anybranch T\\<^sub>2 (\\<lambda>p. red (?ds @ p)) \\<Longrightarrow>\n  anybranch (cutoff red ?ds T\\<^sub>2) (\\<lambda>p. red (?ds @ p))\n  anybranch (Branching T\\<^sub>1 T\\<^sub>2) (\\<lambda>p. red (ds @ p))", "have \"\\<forall>p. branch (Left#p) (Branching T\\<^sub>1 T\\<^sub>2) \\<longrightarrow> red (ds @ (Left#p))\""], ["proof (prove)\nusing this:\n  anybranch T\\<^sub>1 (\\<lambda>p. red (?ds @ p)) \\<Longrightarrow>\n  anybranch (cutoff red ?ds T\\<^sub>1) (\\<lambda>p. red (?ds @ p))\n  anybranch T\\<^sub>2 (\\<lambda>p. red (?ds @ p)) \\<Longrightarrow>\n  anybranch (cutoff red ?ds T\\<^sub>2) (\\<lambda>p. red (?ds @ p))\n  anybranch (Branching T\\<^sub>1 T\\<^sub>2) (\\<lambda>p. red (ds @ p))\n\ngoal (1 subgoal):\n 1. \\<forall>p.\n       branch (Left # p) (Branching T\\<^sub>1 T\\<^sub>2) \\<longrightarrow>\n       red (ds @ Left # p)", "by blast"], ["proof (state)\nthis:\n  \\<forall>p.\n     branch (Left # p) (Branching T\\<^sub>1 T\\<^sub>2) \\<longrightarrow>\n     red (ds @ Left # p)\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anybranch (cutoff red ds T1) (\\<lambda>p. red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anybranch (cutoff red ds T2) (\\<lambda>p. red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anybranch (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. red (ds @ p))", "then"], ["proof (chain)\npicking this:\n  \\<forall>p.\n     branch (Left # p) (Branching T\\<^sub>1 T\\<^sub>2) \\<longrightarrow>\n     red (ds @ Left # p)", "have \"\\<forall>p. branch p T\\<^sub>1 \\<longrightarrow> red (ds @ (Left#p))\""], ["proof (prove)\nusing this:\n  \\<forall>p.\n     branch (Left # p) (Branching T\\<^sub>1 T\\<^sub>2) \\<longrightarrow>\n     red (ds @ Left # p)\n\ngoal (1 subgoal):\n 1. anybranch T\\<^sub>1 (\\<lambda>p. red (ds @ Left # p))", "by auto"], ["proof (state)\nthis:\n  anybranch T\\<^sub>1 (\\<lambda>p. red (ds @ Left # p))\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anybranch (cutoff red ds T1) (\\<lambda>p. red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anybranch (cutoff red ds T2) (\\<lambda>p. red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anybranch (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. red (ds @ p))", "then"], ["proof (chain)\npicking this:\n  anybranch T\\<^sub>1 (\\<lambda>p. red (ds @ Left # p))", "have \"anybranch T\\<^sub>1 (\\<lambda>p. red ((ds @ [Left]) @ p))\""], ["proof (prove)\nusing this:\n  anybranch T\\<^sub>1 (\\<lambda>p. red (ds @ Left # p))\n\ngoal (1 subgoal):\n 1. anybranch T\\<^sub>1 (\\<lambda>p. red ((ds @ [Left]) @ p))", "by auto"], ["proof (state)\nthis:\n  anybranch T\\<^sub>1 (\\<lambda>p. red ((ds @ [Left]) @ p))\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anybranch (cutoff red ds T1) (\\<lambda>p. red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anybranch (cutoff red ds T2) (\\<lambda>p. red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anybranch (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. red (ds @ p))", "then"], ["proof (chain)\npicking this:\n  anybranch T\\<^sub>1 (\\<lambda>p. red ((ds @ [Left]) @ p))", "have aa: \"anybranch (cutoff red (ds @ [Left]) T\\<^sub>1) (\\<lambda>p. red ((ds @ [Left]) @ p)) \n         \""], ["proof (prove)\nusing this:\n  anybranch T\\<^sub>1 (\\<lambda>p. red ((ds @ [Left]) @ p))\n\ngoal (1 subgoal):\n 1. anybranch (cutoff red (ds @ [Left]) T\\<^sub>1)\n     (\\<lambda>p. red ((ds @ [Left]) @ p))", "using Branching"], ["proof (prove)\nusing this:\n  anybranch T\\<^sub>1 (\\<lambda>p. red ((ds @ [Left]) @ p))\n  anybranch T\\<^sub>1 (\\<lambda>p. red (?ds @ p)) \\<Longrightarrow>\n  anybranch (cutoff red ?ds T\\<^sub>1) (\\<lambda>p. red (?ds @ p))\n  anybranch T\\<^sub>2 (\\<lambda>p. red (?ds @ p)) \\<Longrightarrow>\n  anybranch (cutoff red ?ds T\\<^sub>2) (\\<lambda>p. red (?ds @ p))\n  anybranch (Branching T\\<^sub>1 T\\<^sub>2) (\\<lambda>p. red (ds @ p))\n\ngoal (1 subgoal):\n 1. anybranch (cutoff red (ds @ [Left]) T\\<^sub>1)\n     (\\<lambda>p. red ((ds @ [Left]) @ p))", "by blast"], ["proof (state)\nthis:\n  anybranch (cutoff red (ds @ [Left]) T\\<^sub>1)\n   (\\<lambda>p. red ((ds @ [Left]) @ p))\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anybranch (cutoff red ds T1) (\\<lambda>p. red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anybranch (cutoff red ds T2) (\\<lambda>p. red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anybranch (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. red (ds @ p))", "from Branching"], ["proof (chain)\npicking this:\n  anybranch T\\<^sub>1 (\\<lambda>p. red (?ds @ p)) \\<Longrightarrow>\n  anybranch (cutoff red ?ds T\\<^sub>1) (\\<lambda>p. red (?ds @ p))\n  anybranch T\\<^sub>2 (\\<lambda>p. red (?ds @ p)) \\<Longrightarrow>\n  anybranch (cutoff red ?ds T\\<^sub>2) (\\<lambda>p. red (?ds @ p))\n  anybranch (Branching T\\<^sub>1 T\\<^sub>2) (\\<lambda>p. red (ds @ p))", "have \"\\<forall>p. branch (Right#p) (Branching T\\<^sub>1 T\\<^sub>2) \\<longrightarrow> red (ds @ (Right#p))\""], ["proof (prove)\nusing this:\n  anybranch T\\<^sub>1 (\\<lambda>p. red (?ds @ p)) \\<Longrightarrow>\n  anybranch (cutoff red ?ds T\\<^sub>1) (\\<lambda>p. red (?ds @ p))\n  anybranch T\\<^sub>2 (\\<lambda>p. red (?ds @ p)) \\<Longrightarrow>\n  anybranch (cutoff red ?ds T\\<^sub>2) (\\<lambda>p. red (?ds @ p))\n  anybranch (Branching T\\<^sub>1 T\\<^sub>2) (\\<lambda>p. red (ds @ p))\n\ngoal (1 subgoal):\n 1. \\<forall>p.\n       branch (Right # p) (Branching T\\<^sub>1 T\\<^sub>2) \\<longrightarrow>\n       red (ds @ Right # p)", "by blast"], ["proof (state)\nthis:\n  \\<forall>p.\n     branch (Right # p) (Branching T\\<^sub>1 T\\<^sub>2) \\<longrightarrow>\n     red (ds @ Right # p)\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anybranch (cutoff red ds T1) (\\<lambda>p. red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anybranch (cutoff red ds T2) (\\<lambda>p. red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anybranch (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. red (ds @ p))", "then"], ["proof (chain)\npicking this:\n  \\<forall>p.\n     branch (Right # p) (Branching T\\<^sub>1 T\\<^sub>2) \\<longrightarrow>\n     red (ds @ Right # p)", "have \"\\<forall>p. branch p T\\<^sub>2 \\<longrightarrow> red (ds @ (Right#p))\""], ["proof (prove)\nusing this:\n  \\<forall>p.\n     branch (Right # p) (Branching T\\<^sub>1 T\\<^sub>2) \\<longrightarrow>\n     red (ds @ Right # p)\n\ngoal (1 subgoal):\n 1. anybranch T\\<^sub>2 (\\<lambda>p. red (ds @ Right # p))", "by auto"], ["proof (state)\nthis:\n  anybranch T\\<^sub>2 (\\<lambda>p. red (ds @ Right # p))\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anybranch (cutoff red ds T1) (\\<lambda>p. red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anybranch (cutoff red ds T2) (\\<lambda>p. red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anybranch (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. red (ds @ p))", "then"], ["proof (chain)\npicking this:\n  anybranch T\\<^sub>2 (\\<lambda>p. red (ds @ Right # p))", "have \"anybranch T\\<^sub>2 (\\<lambda>p. red ((ds @ [Right]) @ p))\""], ["proof (prove)\nusing this:\n  anybranch T\\<^sub>2 (\\<lambda>p. red (ds @ Right # p))\n\ngoal (1 subgoal):\n 1. anybranch T\\<^sub>2 (\\<lambda>p. red ((ds @ [Right]) @ p))", "by auto"], ["proof (state)\nthis:\n  anybranch T\\<^sub>2 (\\<lambda>p. red ((ds @ [Right]) @ p))\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anybranch (cutoff red ds T1) (\\<lambda>p. red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anybranch (cutoff red ds T2) (\\<lambda>p. red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anybranch (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. red (ds @ p))", "then"], ["proof (chain)\npicking this:\n  anybranch T\\<^sub>2 (\\<lambda>p. red ((ds @ [Right]) @ p))", "have bb: \"anybranch (cutoff red (ds @ [Right]) T\\<^sub>2) (\\<lambda>p. red ((ds @ [Right]) @ p)) \n         \""], ["proof (prove)\nusing this:\n  anybranch T\\<^sub>2 (\\<lambda>p. red ((ds @ [Right]) @ p))\n\ngoal (1 subgoal):\n 1. anybranch (cutoff red (ds @ [Right]) T\\<^sub>2)\n     (\\<lambda>p. red ((ds @ [Right]) @ p))", "using Branching"], ["proof (prove)\nusing this:\n  anybranch T\\<^sub>2 (\\<lambda>p. red ((ds @ [Right]) @ p))\n  anybranch T\\<^sub>1 (\\<lambda>p. red (?ds @ p)) \\<Longrightarrow>\n  anybranch (cutoff red ?ds T\\<^sub>1) (\\<lambda>p. red (?ds @ p))\n  anybranch T\\<^sub>2 (\\<lambda>p. red (?ds @ p)) \\<Longrightarrow>\n  anybranch (cutoff red ?ds T\\<^sub>2) (\\<lambda>p. red (?ds @ p))\n  anybranch (Branching T\\<^sub>1 T\\<^sub>2) (\\<lambda>p. red (ds @ p))\n\ngoal (1 subgoal):\n 1. anybranch (cutoff red (ds @ [Right]) T\\<^sub>2)\n     (\\<lambda>p. red ((ds @ [Right]) @ p))", "by blast"], ["proof (state)\nthis:\n  anybranch (cutoff red (ds @ [Right]) T\\<^sub>2)\n   (\\<lambda>p. red ((ds @ [Right]) @ p))\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anybranch (cutoff red ds T1) (\\<lambda>p. red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anybranch (cutoff red ds T2) (\\<lambda>p. red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anybranch (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. red (ds @ p))", "{"], ["proof (state)\nthis:\n  anybranch (cutoff red (ds @ [Right]) T\\<^sub>2)\n   (\\<lambda>p. red ((ds @ [Right]) @ p))\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anybranch (cutoff red ds T1) (\\<lambda>p. red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anybranch (cutoff red ds T2) (\\<lambda>p. red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anybranch (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. red (ds @ p))", "fix b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anybranch (cutoff red ds T1) (\\<lambda>p. red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anybranch (cutoff red ds T2) (\\<lambda>p. red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anybranch (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. red (ds @ p))", "assume b_p: \"branch b ?T\""], ["proof (state)\nthis:\n  branch b (cutoff red ds (Branching T\\<^sub>1 T\\<^sub>2))\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anybranch (cutoff red ds T1) (\\<lambda>p. red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anybranch (cutoff red ds T2) (\\<lambda>p. red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anybranch (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. red (ds @ p))", "have \"red ds \\<or> \\<not>red ds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. red ds \\<or> \\<not> red ds", "by auto"], ["proof (state)\nthis:\n  red ds \\<or> \\<not> red ds\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anybranch (cutoff red ds T1) (\\<lambda>p. red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anybranch (cutoff red ds T2) (\\<lambda>p. red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anybranch (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. red (ds @ p))", "then"], ["proof (chain)\npicking this:\n  red ds \\<or> \\<not> red ds", "have \"red(ds@b)\""], ["proof (prove)\nusing this:\n  red ds \\<or> \\<not> red ds\n\ngoal (1 subgoal):\n 1. red (ds @ b)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. red ds \\<Longrightarrow> red (ds @ b)\n 2. \\<not> red ds \\<Longrightarrow> red (ds @ b)", "assume ds_p: \"red ds\""], ["proof (state)\nthis:\n  red ds\n\ngoal (2 subgoals):\n 1. red ds \\<Longrightarrow> red (ds @ b)\n 2. \\<not> red ds \\<Longrightarrow> red (ds @ b)", "then"], ["proof (chain)\npicking this:\n  red ds", "have \"?T = Leaf\""], ["proof (prove)\nusing this:\n  red ds\n\ngoal (1 subgoal):\n 1. cutoff red ds (Branching T\\<^sub>1 T\\<^sub>2) = Leaf", "by auto"], ["proof (state)\nthis:\n  cutoff red ds (Branching T\\<^sub>1 T\\<^sub>2) = Leaf\n\ngoal (2 subgoals):\n 1. red ds \\<Longrightarrow> red (ds @ b)\n 2. \\<not> red ds \\<Longrightarrow> red (ds @ b)", "then"], ["proof (chain)\npicking this:\n  cutoff red ds (Branching T\\<^sub>1 T\\<^sub>2) = Leaf", "have \"b = []\""], ["proof (prove)\nusing this:\n  cutoff red ds (Branching T\\<^sub>1 T\\<^sub>2) = Leaf\n\ngoal (1 subgoal):\n 1. b = []", "using b_p branch_inv_Leaf"], ["proof (prove)\nusing this:\n  cutoff red ds (Branching T\\<^sub>1 T\\<^sub>2) = Leaf\n  branch b (cutoff red ds (Branching T\\<^sub>1 T\\<^sub>2))\n  branch ?b Leaf = (?b = [])\n\ngoal (1 subgoal):\n 1. b = []", "by auto"], ["proof (state)\nthis:\n  b = []\n\ngoal (2 subgoals):\n 1. red ds \\<Longrightarrow> red (ds @ b)\n 2. \\<not> red ds \\<Longrightarrow> red (ds @ b)", "then"], ["proof (chain)\npicking this:\n  b = []", "show \"red(ds@b)\""], ["proof (prove)\nusing this:\n  b = []\n\ngoal (1 subgoal):\n 1. red (ds @ b)", "using ds_p"], ["proof (prove)\nusing this:\n  b = []\n  red ds\n\ngoal (1 subgoal):\n 1. red (ds @ b)", "by auto"], ["proof (state)\nthis:\n  red (ds @ b)\n\ngoal (1 subgoal):\n 1. \\<not> red ds \\<Longrightarrow> red (ds @ b)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> red ds \\<Longrightarrow> red (ds @ b)", "assume ds_p: \"\\<not>red ds\""], ["proof (state)\nthis:\n  \\<not> red ds\n\ngoal (1 subgoal):\n 1. \\<not> red ds \\<Longrightarrow> red (ds @ b)", "let ?T\\<^sub>1' = \"cutoff red (ds@[Left])  T\\<^sub>1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> red ds \\<Longrightarrow> red (ds @ b)", "let ?T\\<^sub>2' = \"cutoff red (ds@[Right]) T\\<^sub>2\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> red ds \\<Longrightarrow> red (ds @ b)", "from ds_p"], ["proof (chain)\npicking this:\n  \\<not> red ds", "have \"?T = Branching ?T\\<^sub>1' ?T\\<^sub>2'\""], ["proof (prove)\nusing this:\n  \\<not> red ds\n\ngoal (1 subgoal):\n 1. cutoff red ds (Branching T\\<^sub>1 T\\<^sub>2) =\n    Branching (cutoff red (ds @ [Left]) T\\<^sub>1)\n     (cutoff red (ds @ [Right]) T\\<^sub>2)", "by auto"], ["proof (state)\nthis:\n  cutoff red ds (Branching T\\<^sub>1 T\\<^sub>2) =\n  Branching (cutoff red (ds @ [Left]) T\\<^sub>1)\n   (cutoff red (ds @ [Right]) T\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<not> red ds \\<Longrightarrow> red (ds @ b)", "from this b_p"], ["proof (chain)\npicking this:\n  cutoff red ds (Branching T\\<^sub>1 T\\<^sub>2) =\n  Branching (cutoff red (ds @ [Left]) T\\<^sub>1)\n   (cutoff red (ds @ [Right]) T\\<^sub>2)\n  branch b (cutoff red ds (Branching T\\<^sub>1 T\\<^sub>2))", "obtain a b' where \"b = a # b' \\<and> (a \\<longrightarrow> branch b' ?T\\<^sub>1') \\<and> (\\<not>a \\<longrightarrow> branch b' ?T\\<^sub>2' )\""], ["proof (prove)\nusing this:\n  cutoff red ds (Branching T\\<^sub>1 T\\<^sub>2) =\n  Branching (cutoff red (ds @ [Left]) T\\<^sub>1)\n   (cutoff red (ds @ [Right]) T\\<^sub>2)\n  branch b (cutoff red ds (Branching T\\<^sub>1 T\\<^sub>2))\n\ngoal (1 subgoal):\n 1. (\\<And>a b'.\n        b = a # b' \\<and>\n        (a \\<longrightarrow>\n         branch b' (cutoff red (ds @ [Left]) T\\<^sub>1)) \\<and>\n        (\\<not> a \\<longrightarrow>\n         branch b' (cutoff red (ds @ [Right]) T\\<^sub>2)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using branch_inv_Branching[of b ?T\\<^sub>1' ?T\\<^sub>2']"], ["proof (prove)\nusing this:\n  cutoff red ds (Branching T\\<^sub>1 T\\<^sub>2) =\n  Branching (cutoff red (ds @ [Left]) T\\<^sub>1)\n   (cutoff red (ds @ [Right]) T\\<^sub>2)\n  branch b (cutoff red ds (Branching T\\<^sub>1 T\\<^sub>2))\n  branch b\n   (Branching (cutoff red (ds @ [Left]) T\\<^sub>1)\n     (cutoff red (ds @ [Right]) T\\<^sub>2)) =\n  (\\<exists>a b'.\n      b = a # b' \\<and>\n      (a \\<longrightarrow>\n       branch b' (cutoff red (ds @ [Left]) T\\<^sub>1)) \\<and>\n      (\\<not> a \\<longrightarrow>\n       branch b' (cutoff red (ds @ [Right]) T\\<^sub>2)))\n\ngoal (1 subgoal):\n 1. (\\<And>a b'.\n        b = a # b' \\<and>\n        (a \\<longrightarrow>\n         branch b' (cutoff red (ds @ [Left]) T\\<^sub>1)) \\<and>\n        (\\<not> a \\<longrightarrow>\n         branch b' (cutoff red (ds @ [Right]) T\\<^sub>2)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  b = a # b' \\<and>\n  (a \\<longrightarrow>\n   branch b' (cutoff red (ds @ [Left]) T\\<^sub>1)) \\<and>\n  (\\<not> a \\<longrightarrow>\n   branch b' (cutoff red (ds @ [Right]) T\\<^sub>2))\n\ngoal (1 subgoal):\n 1. \\<not> red ds \\<Longrightarrow> red (ds @ b)", "then"], ["proof (chain)\npicking this:\n  b = a # b' \\<and>\n  (a \\<longrightarrow>\n   branch b' (cutoff red (ds @ [Left]) T\\<^sub>1)) \\<and>\n  (\\<not> a \\<longrightarrow>\n   branch b' (cutoff red (ds @ [Right]) T\\<^sub>2))", "show \"red(ds@b)\""], ["proof (prove)\nusing this:\n  b = a # b' \\<and>\n  (a \\<longrightarrow>\n   branch b' (cutoff red (ds @ [Left]) T\\<^sub>1)) \\<and>\n  (\\<not> a \\<longrightarrow>\n   branch b' (cutoff red (ds @ [Right]) T\\<^sub>2))\n\ngoal (1 subgoal):\n 1. red (ds @ b)", "using aa bb"], ["proof (prove)\nusing this:\n  b = a # b' \\<and>\n  (a \\<longrightarrow>\n   branch b' (cutoff red (ds @ [Left]) T\\<^sub>1)) \\<and>\n  (\\<not> a \\<longrightarrow>\n   branch b' (cutoff red (ds @ [Right]) T\\<^sub>2))\n  anybranch (cutoff red (ds @ [Left]) T\\<^sub>1)\n   (\\<lambda>p. red ((ds @ [Left]) @ p))\n  anybranch (cutoff red (ds @ [Right]) T\\<^sub>2)\n   (\\<lambda>p. red ((ds @ [Right]) @ p))\n\ngoal (1 subgoal):\n 1. red (ds @ b)", "by (cases a) auto"], ["proof (state)\nthis:\n  red (ds @ b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  red (ds @ b)\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anybranch (cutoff red ds T1) (\\<lambda>p. red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anybranch (cutoff red ds T2) (\\<lambda>p. red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anybranch (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. red (ds @ p))", "}"], ["proof (state)\nthis:\n  branch ?b2\n   (cutoff red ds (Branching T\\<^sub>1 T\\<^sub>2)) \\<Longrightarrow>\n  red (ds @ ?b2)\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anybranch (cutoff red ds T1) (\\<lambda>p. red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anybranch (cutoff red ds T2) (\\<lambda>p. red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anybranch (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. red (ds @ p))", "then"], ["proof (chain)\npicking this:\n  branch ?b2\n   (cutoff red ds (Branching T\\<^sub>1 T\\<^sub>2)) \\<Longrightarrow>\n  red (ds @ ?b2)", "show ?case"], ["proof (prove)\nusing this:\n  branch ?b2\n   (cutoff red ds (Branching T\\<^sub>1 T\\<^sub>2)) \\<Longrightarrow>\n  red (ds @ ?b2)\n\ngoal (1 subgoal):\n 1. anybranch (cutoff red ds (Branching T\\<^sub>1 T\\<^sub>2))\n     (\\<lambda>p. red (ds @ p))", "by blast"], ["proof (state)\nthis:\n  anybranch (cutoff red ds (Branching T\\<^sub>1 T\\<^sub>2))\n   (\\<lambda>p. red (ds @ p))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cutoff_branch: \n  assumes \"anybranch T (\\<lambda>p. red p)\"\n  shows \"anybranch (cutoff red [] T) (\\<lambda>p. red p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. anybranch (cutoff red [] T) red", "using assms cutoff_branch'[of T red \"[]\"]"], ["proof (prove)\nusing this:\n  anybranch T red\n  anybranch T (\\<lambda>p. red ([] @ p)) \\<Longrightarrow>\n  anybranch (cutoff red [] T) (\\<lambda>p. red ([] @ p))\n\ngoal (1 subgoal):\n 1. anybranch (cutoff red [] T) red", "by auto"], ["", "lemma cutoff_internal': \n  assumes \"anybranch T (\\<lambda>b. red(ds@b))\" \n  shows \"anyinternal (cutoff red ds T) (\\<lambda>b. \\<not>red(ds@b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. anyinternal (cutoff red ds T) (\\<lambda>p. \\<not> red (ds @ p))", "using assms"], ["proof (prove)\nusing this:\n  anybranch T (\\<lambda>p. red (ds @ p))\n\ngoal (1 subgoal):\n 1. anyinternal (cutoff red ds T) (\\<lambda>p. \\<not> red (ds @ p))", "proof (induction T arbitrary: ds)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ds.\n       anybranch Leaf (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n       anyinternal (cutoff red ds Leaf) (\\<lambda>p. \\<not> red (ds @ p))\n 2. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anyinternal (cutoff red ds T1)\n                    (\\<lambda>p. \\<not> red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anyinternal (cutoff red ds T2) (\\<lambda>p. \\<not> red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anyinternal (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. \\<not> red (ds @ p))", "(* This proof seems a bit excessive for such a simple theorem *)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ds.\n       anybranch Leaf (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n       anyinternal (cutoff red ds Leaf) (\\<lambda>p. \\<not> red (ds @ p))\n 2. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anyinternal (cutoff red ds T1)\n                    (\\<lambda>p. \\<not> red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anyinternal (cutoff red ds T2) (\\<lambda>p. \\<not> red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anyinternal (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. \\<not> red (ds @ p))", "case (Leaf)"], ["proof (state)\nthis:\n  anybranch Leaf (\\<lambda>p. red (ds @ p))\n\ngoal (2 subgoals):\n 1. \\<And>ds.\n       anybranch Leaf (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n       anyinternal (cutoff red ds Leaf) (\\<lambda>p. \\<not> red (ds @ p))\n 2. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anyinternal (cutoff red ds T1)\n                    (\\<lambda>p. \\<not> red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anyinternal (cutoff red ds T2) (\\<lambda>p. \\<not> red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anyinternal (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. \\<not> red (ds @ p))", "then"], ["proof (chain)\npicking this:\n  anybranch Leaf (\\<lambda>p. red (ds @ p))", "show ?case"], ["proof (prove)\nusing this:\n  anybranch Leaf (\\<lambda>p. red (ds @ p))\n\ngoal (1 subgoal):\n 1. anyinternal (cutoff red ds Leaf) (\\<lambda>p. \\<not> red (ds @ p))", "using internal_inv_Leaf"], ["proof (prove)\nusing this:\n  anybranch Leaf (\\<lambda>p. red (ds @ p))\n  \\<not> internal ?b Leaf\n\ngoal (1 subgoal):\n 1. anyinternal (cutoff red ds Leaf) (\\<lambda>p. \\<not> red (ds @ p))", "by simp"], ["proof (state)\nthis:\n  anyinternal (cutoff red ds Leaf) (\\<lambda>p. \\<not> red (ds @ p))\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anyinternal (cutoff red ds T1)\n                    (\\<lambda>p. \\<not> red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anyinternal (cutoff red ds T2) (\\<lambda>p. \\<not> red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anyinternal (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. \\<not> red (ds @ p))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anyinternal (cutoff red ds T1)\n                    (\\<lambda>p. \\<not> red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anyinternal (cutoff red ds T2) (\\<lambda>p. \\<not> red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anyinternal (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. \\<not> red (ds @ p))", "case (Branching T\\<^sub>1 T\\<^sub>2)"], ["proof (state)\nthis:\n  anybranch T\\<^sub>1 (\\<lambda>p. red (?ds @ p)) \\<Longrightarrow>\n  anyinternal (cutoff red ?ds T\\<^sub>1) (\\<lambda>p. \\<not> red (?ds @ p))\n  anybranch T\\<^sub>2 (\\<lambda>p. red (?ds @ p)) \\<Longrightarrow>\n  anyinternal (cutoff red ?ds T\\<^sub>2) (\\<lambda>p. \\<not> red (?ds @ p))\n  anybranch (Branching T\\<^sub>1 T\\<^sub>2) (\\<lambda>p. red (ds @ p))\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anyinternal (cutoff red ds T1)\n                    (\\<lambda>p. \\<not> red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anyinternal (cutoff red ds T2) (\\<lambda>p. \\<not> red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anyinternal (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. \\<not> red (ds @ p))", "let ?T = \"cutoff red ds (Branching T\\<^sub>1 T\\<^sub>2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anyinternal (cutoff red ds T1)\n                    (\\<lambda>p. \\<not> red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anyinternal (cutoff red ds T2) (\\<lambda>p. \\<not> red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anyinternal (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. \\<not> red (ds @ p))", "from Branching"], ["proof (chain)\npicking this:\n  anybranch T\\<^sub>1 (\\<lambda>p. red (?ds @ p)) \\<Longrightarrow>\n  anyinternal (cutoff red ?ds T\\<^sub>1) (\\<lambda>p. \\<not> red (?ds @ p))\n  anybranch T\\<^sub>2 (\\<lambda>p. red (?ds @ p)) \\<Longrightarrow>\n  anyinternal (cutoff red ?ds T\\<^sub>2) (\\<lambda>p. \\<not> red (?ds @ p))\n  anybranch (Branching T\\<^sub>1 T\\<^sub>2) (\\<lambda>p. red (ds @ p))", "have \"\\<forall>p. branch (Left#p) (Branching T\\<^sub>1 T\\<^sub>2) \\<longrightarrow> red (ds @ (Left#p))\""], ["proof (prove)\nusing this:\n  anybranch T\\<^sub>1 (\\<lambda>p. red (?ds @ p)) \\<Longrightarrow>\n  anyinternal (cutoff red ?ds T\\<^sub>1) (\\<lambda>p. \\<not> red (?ds @ p))\n  anybranch T\\<^sub>2 (\\<lambda>p. red (?ds @ p)) \\<Longrightarrow>\n  anyinternal (cutoff red ?ds T\\<^sub>2) (\\<lambda>p. \\<not> red (?ds @ p))\n  anybranch (Branching T\\<^sub>1 T\\<^sub>2) (\\<lambda>p. red (ds @ p))\n\ngoal (1 subgoal):\n 1. \\<forall>p.\n       branch (Left # p) (Branching T\\<^sub>1 T\\<^sub>2) \\<longrightarrow>\n       red (ds @ Left # p)", "by blast"], ["proof (state)\nthis:\n  \\<forall>p.\n     branch (Left # p) (Branching T\\<^sub>1 T\\<^sub>2) \\<longrightarrow>\n     red (ds @ Left # p)\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anyinternal (cutoff red ds T1)\n                    (\\<lambda>p. \\<not> red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anyinternal (cutoff red ds T2) (\\<lambda>p. \\<not> red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anyinternal (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. \\<not> red (ds @ p))", "then"], ["proof (chain)\npicking this:\n  \\<forall>p.\n     branch (Left # p) (Branching T\\<^sub>1 T\\<^sub>2) \\<longrightarrow>\n     red (ds @ Left # p)", "have \"\\<forall>p. branch p T\\<^sub>1 \\<longrightarrow> red (ds @ (Left#p))\""], ["proof (prove)\nusing this:\n  \\<forall>p.\n     branch (Left # p) (Branching T\\<^sub>1 T\\<^sub>2) \\<longrightarrow>\n     red (ds @ Left # p)\n\ngoal (1 subgoal):\n 1. anybranch T\\<^sub>1 (\\<lambda>p. red (ds @ Left # p))", "by auto"], ["proof (state)\nthis:\n  anybranch T\\<^sub>1 (\\<lambda>p. red (ds @ Left # p))\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anyinternal (cutoff red ds T1)\n                    (\\<lambda>p. \\<not> red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anyinternal (cutoff red ds T2) (\\<lambda>p. \\<not> red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anyinternal (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. \\<not> red (ds @ p))", "then"], ["proof (chain)\npicking this:\n  anybranch T\\<^sub>1 (\\<lambda>p. red (ds @ Left # p))", "have \"anybranch T\\<^sub>1 (\\<lambda>p. red ((ds @ [Left]) @ p))\""], ["proof (prove)\nusing this:\n  anybranch T\\<^sub>1 (\\<lambda>p. red (ds @ Left # p))\n\ngoal (1 subgoal):\n 1. anybranch T\\<^sub>1 (\\<lambda>p. red ((ds @ [Left]) @ p))", "by auto"], ["proof (state)\nthis:\n  anybranch T\\<^sub>1 (\\<lambda>p. red ((ds @ [Left]) @ p))\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anyinternal (cutoff red ds T1)\n                    (\\<lambda>p. \\<not> red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anyinternal (cutoff red ds T2) (\\<lambda>p. \\<not> red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anyinternal (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. \\<not> red (ds @ p))", "then"], ["proof (chain)\npicking this:\n  anybranch T\\<^sub>1 (\\<lambda>p. red ((ds @ [Left]) @ p))", "have aa: \"anyinternal (cutoff red (ds @ [Left]) T\\<^sub>1) (\\<lambda>p. \\<not> red ((ds @ [Left]) @ p))\""], ["proof (prove)\nusing this:\n  anybranch T\\<^sub>1 (\\<lambda>p. red ((ds @ [Left]) @ p))\n\ngoal (1 subgoal):\n 1. anyinternal (cutoff red (ds @ [Left]) T\\<^sub>1)\n     (\\<lambda>p. \\<not> red ((ds @ [Left]) @ p))", "using Branching"], ["proof (prove)\nusing this:\n  anybranch T\\<^sub>1 (\\<lambda>p. red ((ds @ [Left]) @ p))\n  anybranch T\\<^sub>1 (\\<lambda>p. red (?ds @ p)) \\<Longrightarrow>\n  anyinternal (cutoff red ?ds T\\<^sub>1) (\\<lambda>p. \\<not> red (?ds @ p))\n  anybranch T\\<^sub>2 (\\<lambda>p. red (?ds @ p)) \\<Longrightarrow>\n  anyinternal (cutoff red ?ds T\\<^sub>2) (\\<lambda>p. \\<not> red (?ds @ p))\n  anybranch (Branching T\\<^sub>1 T\\<^sub>2) (\\<lambda>p. red (ds @ p))\n\ngoal (1 subgoal):\n 1. anyinternal (cutoff red (ds @ [Left]) T\\<^sub>1)\n     (\\<lambda>p. \\<not> red ((ds @ [Left]) @ p))", "by blast"], ["proof (state)\nthis:\n  anyinternal (cutoff red (ds @ [Left]) T\\<^sub>1)\n   (\\<lambda>p. \\<not> red ((ds @ [Left]) @ p))\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anyinternal (cutoff red ds T1)\n                    (\\<lambda>p. \\<not> red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anyinternal (cutoff red ds T2) (\\<lambda>p. \\<not> red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anyinternal (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. \\<not> red (ds @ p))", "from Branching"], ["proof (chain)\npicking this:\n  anybranch T\\<^sub>1 (\\<lambda>p. red (?ds @ p)) \\<Longrightarrow>\n  anyinternal (cutoff red ?ds T\\<^sub>1) (\\<lambda>p. \\<not> red (?ds @ p))\n  anybranch T\\<^sub>2 (\\<lambda>p. red (?ds @ p)) \\<Longrightarrow>\n  anyinternal (cutoff red ?ds T\\<^sub>2) (\\<lambda>p. \\<not> red (?ds @ p))\n  anybranch (Branching T\\<^sub>1 T\\<^sub>2) (\\<lambda>p. red (ds @ p))", "have \"\\<forall>p. branch (Right#p) (Branching T\\<^sub>1 T\\<^sub>2) \\<longrightarrow> red (ds @ (Right#p))\""], ["proof (prove)\nusing this:\n  anybranch T\\<^sub>1 (\\<lambda>p. red (?ds @ p)) \\<Longrightarrow>\n  anyinternal (cutoff red ?ds T\\<^sub>1) (\\<lambda>p. \\<not> red (?ds @ p))\n  anybranch T\\<^sub>2 (\\<lambda>p. red (?ds @ p)) \\<Longrightarrow>\n  anyinternal (cutoff red ?ds T\\<^sub>2) (\\<lambda>p. \\<not> red (?ds @ p))\n  anybranch (Branching T\\<^sub>1 T\\<^sub>2) (\\<lambda>p. red (ds @ p))\n\ngoal (1 subgoal):\n 1. \\<forall>p.\n       branch (Right # p) (Branching T\\<^sub>1 T\\<^sub>2) \\<longrightarrow>\n       red (ds @ Right # p)", "by blast"], ["proof (state)\nthis:\n  \\<forall>p.\n     branch (Right # p) (Branching T\\<^sub>1 T\\<^sub>2) \\<longrightarrow>\n     red (ds @ Right # p)\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anyinternal (cutoff red ds T1)\n                    (\\<lambda>p. \\<not> red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anyinternal (cutoff red ds T2) (\\<lambda>p. \\<not> red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anyinternal (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. \\<not> red (ds @ p))", "then"], ["proof (chain)\npicking this:\n  \\<forall>p.\n     branch (Right # p) (Branching T\\<^sub>1 T\\<^sub>2) \\<longrightarrow>\n     red (ds @ Right # p)", "have \"\\<forall>p. branch p T\\<^sub>2 \\<longrightarrow> red (ds @ (Right#p))\""], ["proof (prove)\nusing this:\n  \\<forall>p.\n     branch (Right # p) (Branching T\\<^sub>1 T\\<^sub>2) \\<longrightarrow>\n     red (ds @ Right # p)\n\ngoal (1 subgoal):\n 1. anybranch T\\<^sub>2 (\\<lambda>p. red (ds @ Right # p))", "by auto"], ["proof (state)\nthis:\n  anybranch T\\<^sub>2 (\\<lambda>p. red (ds @ Right # p))\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anyinternal (cutoff red ds T1)\n                    (\\<lambda>p. \\<not> red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anyinternal (cutoff red ds T2) (\\<lambda>p. \\<not> red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anyinternal (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. \\<not> red (ds @ p))", "then"], ["proof (chain)\npicking this:\n  anybranch T\\<^sub>2 (\\<lambda>p. red (ds @ Right # p))", "have \"anybranch T\\<^sub>2 (\\<lambda>p. red ((ds @ [Right]) @ p))\""], ["proof (prove)\nusing this:\n  anybranch T\\<^sub>2 (\\<lambda>p. red (ds @ Right # p))\n\ngoal (1 subgoal):\n 1. anybranch T\\<^sub>2 (\\<lambda>p. red ((ds @ [Right]) @ p))", "by auto"], ["proof (state)\nthis:\n  anybranch T\\<^sub>2 (\\<lambda>p. red ((ds @ [Right]) @ p))\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anyinternal (cutoff red ds T1)\n                    (\\<lambda>p. \\<not> red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anyinternal (cutoff red ds T2) (\\<lambda>p. \\<not> red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anyinternal (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. \\<not> red (ds @ p))", "then"], ["proof (chain)\npicking this:\n  anybranch T\\<^sub>2 (\\<lambda>p. red ((ds @ [Right]) @ p))", "have bb: \"anyinternal (cutoff red (ds @ [Right]) T\\<^sub>2) (\\<lambda>p. \\<not> red ((ds @ [Right]) @ p))\""], ["proof (prove)\nusing this:\n  anybranch T\\<^sub>2 (\\<lambda>p. red ((ds @ [Right]) @ p))\n\ngoal (1 subgoal):\n 1. anyinternal (cutoff red (ds @ [Right]) T\\<^sub>2)\n     (\\<lambda>p. \\<not> red ((ds @ [Right]) @ p))", "using Branching"], ["proof (prove)\nusing this:\n  anybranch T\\<^sub>2 (\\<lambda>p. red ((ds @ [Right]) @ p))\n  anybranch T\\<^sub>1 (\\<lambda>p. red (?ds @ p)) \\<Longrightarrow>\n  anyinternal (cutoff red ?ds T\\<^sub>1) (\\<lambda>p. \\<not> red (?ds @ p))\n  anybranch T\\<^sub>2 (\\<lambda>p. red (?ds @ p)) \\<Longrightarrow>\n  anyinternal (cutoff red ?ds T\\<^sub>2) (\\<lambda>p. \\<not> red (?ds @ p))\n  anybranch (Branching T\\<^sub>1 T\\<^sub>2) (\\<lambda>p. red (ds @ p))\n\ngoal (1 subgoal):\n 1. anyinternal (cutoff red (ds @ [Right]) T\\<^sub>2)\n     (\\<lambda>p. \\<not> red ((ds @ [Right]) @ p))", "by blast"], ["proof (state)\nthis:\n  anyinternal (cutoff red (ds @ [Right]) T\\<^sub>2)\n   (\\<lambda>p. \\<not> red ((ds @ [Right]) @ p))\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anyinternal (cutoff red ds T1)\n                    (\\<lambda>p. \\<not> red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anyinternal (cutoff red ds T2) (\\<lambda>p. \\<not> red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anyinternal (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. \\<not> red (ds @ p))", "{"], ["proof (state)\nthis:\n  anyinternal (cutoff red (ds @ [Right]) T\\<^sub>2)\n   (\\<lambda>p. \\<not> red ((ds @ [Right]) @ p))\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anyinternal (cutoff red ds T1)\n                    (\\<lambda>p. \\<not> red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anyinternal (cutoff red ds T2) (\\<lambda>p. \\<not> red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anyinternal (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. \\<not> red (ds @ p))", "fix p"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anyinternal (cutoff red ds T1)\n                    (\\<lambda>p. \\<not> red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anyinternal (cutoff red ds T2) (\\<lambda>p. \\<not> red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anyinternal (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. \\<not> red (ds @ p))", "assume b_p: \"internal p ?T\""], ["proof (state)\nthis:\n  internal p (cutoff red ds (Branching T\\<^sub>1 T\\<^sub>2))\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anyinternal (cutoff red ds T1)\n                    (\\<lambda>p. \\<not> red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anyinternal (cutoff red ds T2) (\\<lambda>p. \\<not> red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anyinternal (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. \\<not> red (ds @ p))", "then"], ["proof (chain)\npicking this:\n  internal p (cutoff red ds (Branching T\\<^sub>1 T\\<^sub>2))", "have ds_p: \"\\<not>red ds\""], ["proof (prove)\nusing this:\n  internal p (cutoff red ds (Branching T\\<^sub>1 T\\<^sub>2))\n\ngoal (1 subgoal):\n 1. \\<not> red ds", "using internal_inv_Leaf"], ["proof (prove)\nusing this:\n  internal p (cutoff red ds (Branching T\\<^sub>1 T\\<^sub>2))\n  \\<not> internal ?b Leaf\n\ngoal (1 subgoal):\n 1. \\<not> red ds", "by auto"], ["proof (state)\nthis:\n  \\<not> red ds\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anyinternal (cutoff red ds T1)\n                    (\\<lambda>p. \\<not> red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anyinternal (cutoff red ds T2) (\\<lambda>p. \\<not> red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anyinternal (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. \\<not> red (ds @ p))", "have \"p=[] \\<or> p\\<noteq>[]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p = [] \\<or> p \\<noteq> []", "by auto"], ["proof (state)\nthis:\n  p = [] \\<or> p \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anyinternal (cutoff red ds T1)\n                    (\\<lambda>p. \\<not> red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anyinternal (cutoff red ds T2) (\\<lambda>p. \\<not> red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anyinternal (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. \\<not> red (ds @ p))", "then"], ["proof (chain)\npicking this:\n  p = [] \\<or> p \\<noteq> []", "have \"\\<not>red(ds@p)\""], ["proof (prove)\nusing this:\n  p = [] \\<or> p \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<not> red (ds @ p)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow> \\<not> red (ds @ p)\n 2. p \\<noteq> [] \\<Longrightarrow> \\<not> red (ds @ p)", "assume \"p=[]\""], ["proof (state)\nthis:\n  p = []\n\ngoal (2 subgoals):\n 1. p = [] \\<Longrightarrow> \\<not> red (ds @ p)\n 2. p \\<noteq> [] \\<Longrightarrow> \\<not> red (ds @ p)", "then"], ["proof (chain)\npicking this:\n  p = []", "show \"\\<not>red(ds@p)\""], ["proof (prove)\nusing this:\n  p = []\n\ngoal (1 subgoal):\n 1. \\<not> red (ds @ p)", "using ds_p"], ["proof (prove)\nusing this:\n  p = []\n  \\<not> red ds\n\ngoal (1 subgoal):\n 1. \\<not> red (ds @ p)", "by auto"], ["proof (state)\nthis:\n  \\<not> red (ds @ p)\n\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow> \\<not> red (ds @ p)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow> \\<not> red (ds @ p)", "let ?T\\<^sub>1' = \"cutoff red (ds@[Left])  T\\<^sub>1\""], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow> \\<not> red (ds @ p)", "let ?T\\<^sub>2' = \"cutoff red (ds@[Right]) T\\<^sub>2\""], ["proof (state)\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow> \\<not> red (ds @ p)", "assume \"p\\<noteq>[]\""], ["proof (state)\nthis:\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow> \\<not> red (ds @ p)", "moreover"], ["proof (state)\nthis:\n  p \\<noteq> []\n\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow> \\<not> red (ds @ p)", "have \"?T = Branching ?T\\<^sub>1' ?T\\<^sub>2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cutoff red ds (Branching T\\<^sub>1 T\\<^sub>2) =\n    Branching (cutoff red (ds @ [Left]) T\\<^sub>1)\n     (cutoff red (ds @ [Right]) T\\<^sub>2)", "using ds_p"], ["proof (prove)\nusing this:\n  \\<not> red ds\n\ngoal (1 subgoal):\n 1. cutoff red ds (Branching T\\<^sub>1 T\\<^sub>2) =\n    Branching (cutoff red (ds @ [Left]) T\\<^sub>1)\n     (cutoff red (ds @ [Right]) T\\<^sub>2)", "by auto"], ["proof (state)\nthis:\n  cutoff red ds (Branching T\\<^sub>1 T\\<^sub>2) =\n  Branching (cutoff red (ds @ [Left]) T\\<^sub>1)\n   (cutoff red (ds @ [Right]) T\\<^sub>2)\n\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow> \\<not> red (ds @ p)", "ultimately"], ["proof (chain)\npicking this:\n  p \\<noteq> []\n  cutoff red ds (Branching T\\<^sub>1 T\\<^sub>2) =\n  Branching (cutoff red (ds @ [Left]) T\\<^sub>1)\n   (cutoff red (ds @ [Right]) T\\<^sub>2)", "obtain a p' where b_p: \"p = a # p' \\<and>\n             (a \\<longrightarrow> internal p' (cutoff red (ds @ [Left]) T\\<^sub>1)) \\<and>\n             (\\<not> a \\<longrightarrow> internal p' (cutoff red (ds @ [Right]) T\\<^sub>2))\""], ["proof (prove)\nusing this:\n  p \\<noteq> []\n  cutoff red ds (Branching T\\<^sub>1 T\\<^sub>2) =\n  Branching (cutoff red (ds @ [Left]) T\\<^sub>1)\n   (cutoff red (ds @ [Right]) T\\<^sub>2)\n\ngoal (1 subgoal):\n 1. (\\<And>a p'.\n        p = a # p' \\<and>\n        (a \\<longrightarrow>\n         internal p' (cutoff red (ds @ [Left]) T\\<^sub>1)) \\<and>\n        (\\<not> a \\<longrightarrow>\n         internal p'\n          (cutoff red (ds @ [Right]) T\\<^sub>2)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using b_p internal_inv_Branching[of p ?T\\<^sub>1' ?T\\<^sub>2']"], ["proof (prove)\nusing this:\n  p \\<noteq> []\n  cutoff red ds (Branching T\\<^sub>1 T\\<^sub>2) =\n  Branching (cutoff red (ds @ [Left]) T\\<^sub>1)\n   (cutoff red (ds @ [Right]) T\\<^sub>2)\n  internal p (cutoff red ds (Branching T\\<^sub>1 T\\<^sub>2))\n  internal p\n   (Branching (cutoff red (ds @ [Left]) T\\<^sub>1)\n     (cutoff red (ds @ [Right]) T\\<^sub>2)) =\n  (p = [] \\<or>\n   (\\<exists>a p'.\n       p = a # p' \\<and>\n       (a \\<longrightarrow>\n        internal p' (cutoff red (ds @ [Left]) T\\<^sub>1)) \\<and>\n       (\\<not> a \\<longrightarrow>\n        internal p' (cutoff red (ds @ [Right]) T\\<^sub>2))))\n\ngoal (1 subgoal):\n 1. (\\<And>a p'.\n        p = a # p' \\<and>\n        (a \\<longrightarrow>\n         internal p' (cutoff red (ds @ [Left]) T\\<^sub>1)) \\<and>\n        (\\<not> a \\<longrightarrow>\n         internal p'\n          (cutoff red (ds @ [Right]) T\\<^sub>2)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  p = a # p' \\<and>\n  (a \\<longrightarrow>\n   internal p' (cutoff red (ds @ [Left]) T\\<^sub>1)) \\<and>\n  (\\<not> a \\<longrightarrow>\n   internal p' (cutoff red (ds @ [Right]) T\\<^sub>2))\n\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow> \\<not> red (ds @ p)", "then"], ["proof (chain)\npicking this:\n  p = a # p' \\<and>\n  (a \\<longrightarrow>\n   internal p' (cutoff red (ds @ [Left]) T\\<^sub>1)) \\<and>\n  (\\<not> a \\<longrightarrow>\n   internal p' (cutoff red (ds @ [Right]) T\\<^sub>2))", "have \"\\<not>red(ds @ [a] @ p')\""], ["proof (prove)\nusing this:\n  p = a # p' \\<and>\n  (a \\<longrightarrow>\n   internal p' (cutoff red (ds @ [Left]) T\\<^sub>1)) \\<and>\n  (\\<not> a \\<longrightarrow>\n   internal p' (cutoff red (ds @ [Right]) T\\<^sub>2))\n\ngoal (1 subgoal):\n 1. \\<not> red (ds @ [a] @ p')", "using aa bb"], ["proof (prove)\nusing this:\n  p = a # p' \\<and>\n  (a \\<longrightarrow>\n   internal p' (cutoff red (ds @ [Left]) T\\<^sub>1)) \\<and>\n  (\\<not> a \\<longrightarrow>\n   internal p' (cutoff red (ds @ [Right]) T\\<^sub>2))\n  anyinternal (cutoff red (ds @ [Left]) T\\<^sub>1)\n   (\\<lambda>p. \\<not> red ((ds @ [Left]) @ p))\n  anyinternal (cutoff red (ds @ [Right]) T\\<^sub>2)\n   (\\<lambda>p. \\<not> red ((ds @ [Right]) @ p))\n\ngoal (1 subgoal):\n 1. \\<not> red (ds @ [a] @ p')", "by (cases a) auto"], ["proof (state)\nthis:\n  \\<not> red (ds @ [a] @ p')\n\ngoal (1 subgoal):\n 1. p \\<noteq> [] \\<Longrightarrow> \\<not> red (ds @ p)", "then"], ["proof (chain)\npicking this:\n  \\<not> red (ds @ [a] @ p')", "show \"\\<not>red(ds @ p)\""], ["proof (prove)\nusing this:\n  \\<not> red (ds @ [a] @ p')\n\ngoal (1 subgoal):\n 1. \\<not> red (ds @ p)", "using b_p"], ["proof (prove)\nusing this:\n  \\<not> red (ds @ [a] @ p')\n  p = a # p' \\<and>\n  (a \\<longrightarrow>\n   internal p' (cutoff red (ds @ [Left]) T\\<^sub>1)) \\<and>\n  (\\<not> a \\<longrightarrow>\n   internal p' (cutoff red (ds @ [Right]) T\\<^sub>2))\n\ngoal (1 subgoal):\n 1. \\<not> red (ds @ p)", "by simp"], ["proof (state)\nthis:\n  \\<not> red (ds @ p)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> red (ds @ p)\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anyinternal (cutoff red ds T1)\n                    (\\<lambda>p. \\<not> red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anyinternal (cutoff red ds T2) (\\<lambda>p. \\<not> red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anyinternal (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. \\<not> red (ds @ p))", "}"], ["proof (state)\nthis:\n  internal ?p2\n   (cutoff red ds (Branching T\\<^sub>1 T\\<^sub>2)) \\<Longrightarrow>\n  \\<not> red (ds @ ?p2)\n\ngoal (1 subgoal):\n 1. \\<And>T1 T2 ds.\n       \\<lbrakk>\\<And>ds.\n                   anybranch T1 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n                   anyinternal (cutoff red ds T1)\n                    (\\<lambda>p. \\<not> red (ds @ p));\n        \\<And>ds.\n           anybranch T2 (\\<lambda>p. red (ds @ p)) \\<Longrightarrow>\n           anyinternal (cutoff red ds T2) (\\<lambda>p. \\<not> red (ds @ p));\n        anybranch (Branching T1 T2) (\\<lambda>p. red (ds @ p))\\<rbrakk>\n       \\<Longrightarrow> anyinternal (cutoff red ds (Branching T1 T2))\n                          (\\<lambda>p. \\<not> red (ds @ p))", "then"], ["proof (chain)\npicking this:\n  internal ?p2\n   (cutoff red ds (Branching T\\<^sub>1 T\\<^sub>2)) \\<Longrightarrow>\n  \\<not> red (ds @ ?p2)", "show ?case"], ["proof (prove)\nusing this:\n  internal ?p2\n   (cutoff red ds (Branching T\\<^sub>1 T\\<^sub>2)) \\<Longrightarrow>\n  \\<not> red (ds @ ?p2)\n\ngoal (1 subgoal):\n 1. anyinternal (cutoff red ds (Branching T\\<^sub>1 T\\<^sub>2))\n     (\\<lambda>p. \\<not> red (ds @ p))", "by blast"], ["proof (state)\nthis:\n  anyinternal (cutoff red ds (Branching T\\<^sub>1 T\\<^sub>2))\n   (\\<lambda>p. \\<not> red (ds @ p))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cutoff_internal:\n  assumes  \"anybranch T red\"\n  shows \"anyinternal (cutoff red [] T) (\\<lambda>p. \\<not>red p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. anyinternal (cutoff red [] T) (\\<lambda>p. \\<not> red p)", "using assms cutoff_internal'[of T red \"[]\"]"], ["proof (prove)\nusing this:\n  anybranch T red\n  anybranch T (\\<lambda>p. red ([] @ p)) \\<Longrightarrow>\n  anyinternal (cutoff red [] T) (\\<lambda>p. \\<not> red ([] @ p))\n\ngoal (1 subgoal):\n 1. anyinternal (cutoff red [] T) (\\<lambda>p. \\<not> red p)", "by auto"], ["", "lemma cutoff_branch_internal': \n  assumes \"anybranch T red\"\n  shows \"anyinternal (cutoff red [] T) (\\<lambda>p. \\<not>red p) \\<and> anybranch (cutoff red [] T) (\\<lambda>p. red p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. anyinternal (cutoff red [] T) (\\<lambda>p. \\<not> red p) \\<and>\n    anybranch (cutoff red [] T) red", "using assms cutoff_internal[of T] cutoff_branch[of T]"], ["proof (prove)\nusing this:\n  anybranch T red\n  anybranch T ?red \\<Longrightarrow>\n  anyinternal (cutoff ?red [] T) (\\<lambda>p. \\<not> ?red p)\n  anybranch T ?red \\<Longrightarrow> anybranch (cutoff ?red [] T) ?red\n\ngoal (1 subgoal):\n 1. anyinternal (cutoff red [] T) (\\<lambda>p. \\<not> red p) \\<and>\n    anybranch (cutoff red [] T) red", "by blast"], ["", "lemma cutoff_branch_internal: \n  assumes \"anybranch T red\"\n  shows \"\\<exists>T'. anyinternal T' (\\<lambda>p. \\<not>red p) \\<and> anybranch T' (\\<lambda>p. red p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>T'.\n       anyinternal T' (\\<lambda>p. \\<not> red p) \\<and> anybranch T' red", "using assms cutoff_branch_internal'"], ["proof (prove)\nusing this:\n  anybranch T red\n  anybranch ?T ?red \\<Longrightarrow>\n  anyinternal (cutoff ?red [] ?T) (\\<lambda>p. \\<not> ?red p) \\<and>\n  anybranch (cutoff ?red [] ?T) ?red\n\ngoal (1 subgoal):\n 1. \\<exists>T'.\n       anyinternal T' (\\<lambda>p. \\<not> red p) \\<and> anybranch T' red", "by blast"], ["", "section \\<open>Possibly Infinite Trees\\<close>"], ["", "text \\<open>Possibly infinite trees are of type @{typ \"dir list set\"}.\\<close>"], ["", "abbreviation wf_tree :: \"dir list set \\<Rightarrow> bool\" where\n  \"wf_tree T \\<equiv> (\\<forall>ds d. (ds @ d) \\<in> T \\<longrightarrow> ds \\<in> T)\""], ["", "text \\<open>The subtree in with root r\\<close>"], ["", "fun subtree :: \"dir list set \\<Rightarrow> dir list \\<Rightarrow> dir list set\" where \n  \"subtree T r = {ds \\<in> T. \\<exists>ds'. ds = r @ ds'}\""], ["", "text \\<open>A subtree of a tree is either in the left branch, the right branch, or is the tree itself\\<close>"], ["", "lemma subtree_pos: \n  \"subtree T ds \\<subseteq> subtree T (ds @ [Left]) \\<union> subtree T (ds @ [Right]) \\<union> {ds}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subtree T ds\n    \\<subseteq> subtree T (ds @ [Left]) \\<union>\n                subtree T (ds @ [Right]) \\<union>\n                {ds}", "proof (rule subsetI; rule Set.UnCI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> subtree T ds; x \\<notin> {ds}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> subtree T (ds @ [Left]) \\<union>\n                                 subtree T (ds @ [Right])", "let ?subtree = \"subtree T\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> subtree T ds; x \\<notin> {ds}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> subtree T (ds @ [Left]) \\<union>\n                                 subtree T (ds @ [Right])", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> subtree T ds; x \\<notin> {ds}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> subtree T (ds @ [Left]) \\<union>\n                                 subtree T (ds @ [Right])", "assume asm: \"x \\<in> ?subtree ds\""], ["proof (state)\nthis:\n  x \\<in> subtree T ds\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> subtree T ds; x \\<notin> {ds}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> subtree T (ds @ [Left]) \\<union>\n                                 subtree T (ds @ [Right])", "assume \"x \\<notin> {ds}\""], ["proof (state)\nthis:\n  x \\<notin> {ds}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> subtree T ds; x \\<notin> {ds}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> subtree T (ds @ [Left]) \\<union>\n                                 subtree T (ds @ [Right])", "then"], ["proof (chain)\npicking this:\n  x \\<notin> {ds}", "have \"x \\<noteq> ds\""], ["proof (prove)\nusing this:\n  x \\<notin> {ds}\n\ngoal (1 subgoal):\n 1. x \\<noteq> ds", "by simp"], ["proof (state)\nthis:\n  x \\<noteq> ds\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> subtree T ds; x \\<notin> {ds}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> subtree T (ds @ [Left]) \\<union>\n                                 subtree T (ds @ [Right])", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> ds", "have \"\\<exists>e d. x = ds @ [d] @ e\""], ["proof (prove)\nusing this:\n  x \\<noteq> ds\n\ngoal (1 subgoal):\n 1. \\<exists>e d. x = ds @ [d] @ e", "using asm list.exhaust"], ["proof (prove)\nusing this:\n  x \\<noteq> ds\n  x \\<in> subtree T ds\n  \\<lbrakk>?y = [] \\<Longrightarrow> ?P;\n   \\<And>x21 x22. ?y = x21 # x22 \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. \\<exists>e d. x = ds @ [d] @ e", "by auto"], ["proof (state)\nthis:\n  \\<exists>e d. x = ds @ [d] @ e\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> subtree T ds; x \\<notin> {ds}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> subtree T (ds @ [Left]) \\<union>\n                                 subtree T (ds @ [Right])", "then"], ["proof (chain)\npicking this:\n  \\<exists>e d. x = ds @ [d] @ e", "have \"(\\<exists>e. x = ds @ [Left] @ e) \\<or> (\\<exists>e. x = ds @ [Right] @ e)\""], ["proof (prove)\nusing this:\n  \\<exists>e d. x = ds @ [d] @ e\n\ngoal (1 subgoal):\n 1. (\\<exists>e. x = ds @ [Left] @ e) \\<or>\n    (\\<exists>e. x = ds @ [Right] @ e)", "using bool.exhaust"], ["proof (prove)\nusing this:\n  \\<exists>e d. x = ds @ [d] @ e\n  \\<lbrakk>?y = True \\<Longrightarrow> ?P;\n   ?y = False \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. (\\<exists>e. x = ds @ [Left] @ e) \\<or>\n    (\\<exists>e. x = ds @ [Right] @ e)", "by auto"], ["proof (state)\nthis:\n  (\\<exists>e. x = ds @ [Left] @ e) \\<or> (\\<exists>e. x = ds @ [Right] @ e)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> subtree T ds; x \\<notin> {ds}\\<rbrakk>\n       \\<Longrightarrow> x \\<in> subtree T (ds @ [Left]) \\<union>\n                                 subtree T (ds @ [Right])", "then"], ["proof (chain)\npicking this:\n  (\\<exists>e. x = ds @ [Left] @ e) \\<or> (\\<exists>e. x = ds @ [Right] @ e)", "show \"x \\<in> ?subtree (ds @ [Left]) \\<union> ?subtree (ds @ [Right])\""], ["proof (prove)\nusing this:\n  (\\<exists>e. x = ds @ [Left] @ e) \\<or> (\\<exists>e. x = ds @ [Right] @ e)\n\ngoal (1 subgoal):\n 1. x \\<in> subtree T (ds @ [Left]) \\<union> subtree T (ds @ [Right])", "using asm"], ["proof (prove)\nusing this:\n  (\\<exists>e. x = ds @ [Left] @ e) \\<or> (\\<exists>e. x = ds @ [Right] @ e)\n  x \\<in> subtree T ds\n\ngoal (1 subgoal):\n 1. x \\<in> subtree T (ds @ [Left]) \\<union> subtree T (ds @ [Right])", "by auto"], ["proof (state)\nthis:\n  x \\<in> subtree T (ds @ [Left]) \\<union> subtree T (ds @ [Right])\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Infinite Paths\\<close>"], ["", "abbreviation wf_infpath :: \"(nat \\<Rightarrow> 'a list) \\<Rightarrow> bool\" where\n  \"wf_infpath f \\<equiv> (f 0 = []) \\<and> (\\<forall>n. \\<exists>a. f (Suc n) = (f n) @ [a])\""], ["", "lemma infpath_length:\n  assumes \"wf_infpath f\"\n  shows \"length (f n) = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length (f n) = n", "using assms"], ["proof (prove)\nusing this:\n  wf_infpath f\n\ngoal (1 subgoal):\n 1. length (f n) = n", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. wf_infpath f \\<Longrightarrow> length (f 0) = 0\n 2. \\<And>n.\n       \\<lbrakk>wf_infpath f \\<Longrightarrow> length (f n) = n;\n        wf_infpath f\\<rbrakk>\n       \\<Longrightarrow> length (f (Suc n)) = Suc n", "case 0"], ["proof (state)\nthis:\n  wf_infpath f\n\ngoal (2 subgoals):\n 1. wf_infpath f \\<Longrightarrow> length (f 0) = 0\n 2. \\<And>n.\n       \\<lbrakk>wf_infpath f \\<Longrightarrow> length (f n) = n;\n        wf_infpath f\\<rbrakk>\n       \\<Longrightarrow> length (f (Suc n)) = Suc n", "then"], ["proof (chain)\npicking this:\n  wf_infpath f", "show ?case"], ["proof (prove)\nusing this:\n  wf_infpath f\n\ngoal (1 subgoal):\n 1. length (f 0) = 0", "by auto"], ["proof (state)\nthis:\n  length (f 0) = 0\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>wf_infpath f \\<Longrightarrow> length (f n) = n;\n        wf_infpath f\\<rbrakk>\n       \\<Longrightarrow> length (f (Suc n)) = Suc n", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>wf_infpath f \\<Longrightarrow> length (f n) = n;\n        wf_infpath f\\<rbrakk>\n       \\<Longrightarrow> length (f (Suc n)) = Suc n", "case (Suc n)"], ["proof (state)\nthis:\n  wf_infpath f \\<Longrightarrow> length (f n) = n\n  wf_infpath f\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>wf_infpath f \\<Longrightarrow> length (f n) = n;\n        wf_infpath f\\<rbrakk>\n       \\<Longrightarrow> length (f (Suc n)) = Suc n", "then"], ["proof (chain)\npicking this:\n  wf_infpath f \\<Longrightarrow> length (f n) = n\n  wf_infpath f", "show ?case"], ["proof (prove)\nusing this:\n  wf_infpath f \\<Longrightarrow> length (f n) = n\n  wf_infpath f\n\ngoal (1 subgoal):\n 1. length (f (Suc n)) = Suc n", "by (metis length_append_singleton)"], ["proof (state)\nthis:\n  length (f (Suc n)) = Suc n\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma chain_prefix: \n  assumes \"wf_infpath f\"\n  assumes \"n\\<^sub>1 \\<le> n\\<^sub>2\"\n  shows \"\\<exists>a. (f n\\<^sub>1) @ a = (f n\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a. f n\\<^sub>1 @ a = f n\\<^sub>2", "using assms"], ["proof (prove)\nusing this:\n  wf_infpath f\n  n\\<^sub>1 \\<le> n\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<exists>a. f n\\<^sub>1 @ a = f n\\<^sub>2", "proof (induction n\\<^sub>2)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_infpath f; n\\<^sub>1 \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a. f n\\<^sub>1 @ a = f 0\n 2. \\<And>n\\<^sub>2.\n       \\<lbrakk>\\<lbrakk>wf_infpath f; n\\<^sub>1 \\<le> n\\<^sub>2\\<rbrakk>\n                \\<Longrightarrow> \\<exists>a. f n\\<^sub>1 @ a = f n\\<^sub>2;\n        wf_infpath f; n\\<^sub>1 \\<le> Suc n\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a. f n\\<^sub>1 @ a = f (Suc n\\<^sub>2)", "case (Suc n\\<^sub>2)"], ["proof (state)\nthis:\n  \\<lbrakk>wf_infpath f; n\\<^sub>1 \\<le> n\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a. f n\\<^sub>1 @ a = f n\\<^sub>2\n  wf_infpath f\n  n\\<^sub>1 \\<le> Suc n\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_infpath f; n\\<^sub>1 \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a. f n\\<^sub>1 @ a = f 0\n 2. \\<And>n\\<^sub>2.\n       \\<lbrakk>\\<lbrakk>wf_infpath f; n\\<^sub>1 \\<le> n\\<^sub>2\\<rbrakk>\n                \\<Longrightarrow> \\<exists>a. f n\\<^sub>1 @ a = f n\\<^sub>2;\n        wf_infpath f; n\\<^sub>1 \\<le> Suc n\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a. f n\\<^sub>1 @ a = f (Suc n\\<^sub>2)", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>wf_infpath f; n\\<^sub>1 \\<le> n\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a. f n\\<^sub>1 @ a = f n\\<^sub>2\n  wf_infpath f\n  n\\<^sub>1 \\<le> Suc n\\<^sub>2", "have \"n\\<^sub>1 \\<le> n\\<^sub>2 \\<or> n\\<^sub>1 = Suc n\\<^sub>2\""], ["proof (prove)\nusing this:\n  \\<lbrakk>wf_infpath f; n\\<^sub>1 \\<le> n\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a. f n\\<^sub>1 @ a = f n\\<^sub>2\n  wf_infpath f\n  n\\<^sub>1 \\<le> Suc n\\<^sub>2\n\ngoal (1 subgoal):\n 1. n\\<^sub>1 \\<le> n\\<^sub>2 \\<or> n\\<^sub>1 = Suc n\\<^sub>2", "by auto"], ["proof (state)\nthis:\n  n\\<^sub>1 \\<le> n\\<^sub>2 \\<or> n\\<^sub>1 = Suc n\\<^sub>2\n\ngoal (2 subgoals):\n 1. \\<lbrakk>wf_infpath f; n\\<^sub>1 \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a. f n\\<^sub>1 @ a = f 0\n 2. \\<And>n\\<^sub>2.\n       \\<lbrakk>\\<lbrakk>wf_infpath f; n\\<^sub>1 \\<le> n\\<^sub>2\\<rbrakk>\n                \\<Longrightarrow> \\<exists>a. f n\\<^sub>1 @ a = f n\\<^sub>2;\n        wf_infpath f; n\\<^sub>1 \\<le> Suc n\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a. f n\\<^sub>1 @ a = f (Suc n\\<^sub>2)", "then"], ["proof (chain)\npicking this:\n  n\\<^sub>1 \\<le> n\\<^sub>2 \\<or> n\\<^sub>1 = Suc n\\<^sub>2", "show ?case"], ["proof (prove)\nusing this:\n  n\\<^sub>1 \\<le> n\\<^sub>2 \\<or> n\\<^sub>1 = Suc n\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<exists>a. f n\\<^sub>1 @ a = f (Suc n\\<^sub>2)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. n\\<^sub>1 \\<le> n\\<^sub>2 \\<Longrightarrow>\n    \\<exists>a. f n\\<^sub>1 @ a = f (Suc n\\<^sub>2)\n 2. n\\<^sub>1 = Suc n\\<^sub>2 \\<Longrightarrow>\n    \\<exists>a. f n\\<^sub>1 @ a = f (Suc n\\<^sub>2)", "assume \"n\\<^sub>1 \\<le> n\\<^sub>2\""], ["proof (state)\nthis:\n  n\\<^sub>1 \\<le> n\\<^sub>2\n\ngoal (2 subgoals):\n 1. n\\<^sub>1 \\<le> n\\<^sub>2 \\<Longrightarrow>\n    \\<exists>a. f n\\<^sub>1 @ a = f (Suc n\\<^sub>2)\n 2. n\\<^sub>1 = Suc n\\<^sub>2 \\<Longrightarrow>\n    \\<exists>a. f n\\<^sub>1 @ a = f (Suc n\\<^sub>2)", "then"], ["proof (chain)\npicking this:\n  n\\<^sub>1 \\<le> n\\<^sub>2", "obtain a where a: \"f n\\<^sub>1 @ a = f n\\<^sub>2\""], ["proof (prove)\nusing this:\n  n\\<^sub>1 \\<le> n\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        f n\\<^sub>1 @ a = f n\\<^sub>2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using Suc"], ["proof (prove)\nusing this:\n  n\\<^sub>1 \\<le> n\\<^sub>2\n  \\<lbrakk>wf_infpath f; n\\<^sub>1 \\<le> n\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a. f n\\<^sub>1 @ a = f n\\<^sub>2\n  wf_infpath f\n  n\\<^sub>1 \\<le> Suc n\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        f n\\<^sub>1 @ a = f n\\<^sub>2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f n\\<^sub>1 @ a = f n\\<^sub>2\n\ngoal (2 subgoals):\n 1. n\\<^sub>1 \\<le> n\\<^sub>2 \\<Longrightarrow>\n    \\<exists>a. f n\\<^sub>1 @ a = f (Suc n\\<^sub>2)\n 2. n\\<^sub>1 = Suc n\\<^sub>2 \\<Longrightarrow>\n    \\<exists>a. f n\\<^sub>1 @ a = f (Suc n\\<^sub>2)", "have b: \"\\<exists>b. f (Suc n\\<^sub>2) = f n\\<^sub>2 @ [b]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>b. f (Suc n\\<^sub>2) = f n\\<^sub>2 @ [b]", "using Suc"], ["proof (prove)\nusing this:\n  \\<lbrakk>wf_infpath f; n\\<^sub>1 \\<le> n\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a. f n\\<^sub>1 @ a = f n\\<^sub>2\n  wf_infpath f\n  n\\<^sub>1 \\<le> Suc n\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<exists>b. f (Suc n\\<^sub>2) = f n\\<^sub>2 @ [b]", "by auto"], ["proof (state)\nthis:\n  \\<exists>b. f (Suc n\\<^sub>2) = f n\\<^sub>2 @ [b]\n\ngoal (2 subgoals):\n 1. n\\<^sub>1 \\<le> n\\<^sub>2 \\<Longrightarrow>\n    \\<exists>a. f n\\<^sub>1 @ a = f (Suc n\\<^sub>2)\n 2. n\\<^sub>1 = Suc n\\<^sub>2 \\<Longrightarrow>\n    \\<exists>a. f n\\<^sub>1 @ a = f (Suc n\\<^sub>2)", "from a b"], ["proof (chain)\npicking this:\n  f n\\<^sub>1 @ a = f n\\<^sub>2\n  \\<exists>b. f (Suc n\\<^sub>2) = f n\\<^sub>2 @ [b]", "have \"\\<exists>b. f n\\<^sub>1 @ (a @ [b]) = f (Suc n\\<^sub>2)\""], ["proof (prove)\nusing this:\n  f n\\<^sub>1 @ a = f n\\<^sub>2\n  \\<exists>b. f (Suc n\\<^sub>2) = f n\\<^sub>2 @ [b]\n\ngoal (1 subgoal):\n 1. \\<exists>b. f n\\<^sub>1 @ a @ [b] = f (Suc n\\<^sub>2)", "by auto"], ["proof (state)\nthis:\n  \\<exists>b. f n\\<^sub>1 @ a @ [b] = f (Suc n\\<^sub>2)\n\ngoal (2 subgoals):\n 1. n\\<^sub>1 \\<le> n\\<^sub>2 \\<Longrightarrow>\n    \\<exists>a. f n\\<^sub>1 @ a = f (Suc n\\<^sub>2)\n 2. n\\<^sub>1 = Suc n\\<^sub>2 \\<Longrightarrow>\n    \\<exists>a. f n\\<^sub>1 @ a = f (Suc n\\<^sub>2)", "then"], ["proof (chain)\npicking this:\n  \\<exists>b. f n\\<^sub>1 @ a @ [b] = f (Suc n\\<^sub>2)", "show \"\\<exists>c. f n\\<^sub>1 @ c = f (Suc n\\<^sub>2)\""], ["proof (prove)\nusing this:\n  \\<exists>b. f n\\<^sub>1 @ a @ [b] = f (Suc n\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<exists>c. f n\\<^sub>1 @ c = f (Suc n\\<^sub>2)", "by blast"], ["proof (state)\nthis:\n  \\<exists>c. f n\\<^sub>1 @ c = f (Suc n\\<^sub>2)\n\ngoal (1 subgoal):\n 1. n\\<^sub>1 = Suc n\\<^sub>2 \\<Longrightarrow>\n    \\<exists>a. f n\\<^sub>1 @ a = f (Suc n\\<^sub>2)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. n\\<^sub>1 = Suc n\\<^sub>2 \\<Longrightarrow>\n    \\<exists>a. f n\\<^sub>1 @ a = f (Suc n\\<^sub>2)", "assume \"n\\<^sub>1 = Suc n\\<^sub>2\""], ["proof (state)\nthis:\n  n\\<^sub>1 = Suc n\\<^sub>2\n\ngoal (1 subgoal):\n 1. n\\<^sub>1 = Suc n\\<^sub>2 \\<Longrightarrow>\n    \\<exists>a. f n\\<^sub>1 @ a = f (Suc n\\<^sub>2)", "then"], ["proof (chain)\npicking this:\n  n\\<^sub>1 = Suc n\\<^sub>2", "have \"f n\\<^sub>1 @ [] = f (Suc n\\<^sub>2)\""], ["proof (prove)\nusing this:\n  n\\<^sub>1 = Suc n\\<^sub>2\n\ngoal (1 subgoal):\n 1. f n\\<^sub>1 @ [] = f (Suc n\\<^sub>2)", "by auto"], ["proof (state)\nthis:\n  f n\\<^sub>1 @ [] = f (Suc n\\<^sub>2)\n\ngoal (1 subgoal):\n 1. n\\<^sub>1 = Suc n\\<^sub>2 \\<Longrightarrow>\n    \\<exists>a. f n\\<^sub>1 @ a = f (Suc n\\<^sub>2)", "then"], ["proof (chain)\npicking this:\n  f n\\<^sub>1 @ [] = f (Suc n\\<^sub>2)", "show \"\\<exists>a. f n\\<^sub>1 @ a = f (Suc n\\<^sub>2)\""], ["proof (prove)\nusing this:\n  f n\\<^sub>1 @ [] = f (Suc n\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<exists>a. f n\\<^sub>1 @ a = f (Suc n\\<^sub>2)", "by auto"], ["proof (state)\nthis:\n  \\<exists>a. f n\\<^sub>1 @ a = f (Suc n\\<^sub>2)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a. f n\\<^sub>1 @ a = f (Suc n\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wf_infpath f; n\\<^sub>1 \\<le> 0\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a. f n\\<^sub>1 @ a = f 0", "qed auto"], ["", "text \\<open>If we make a lookup in a list, then looking up in an extension gives us the same value.\\<close>"], ["", "lemma ith_in_extension:\n  assumes chain: \"wf_infpath f\"\n  assumes smalli: \"i < length (f n\\<^sub>1)\"\n  assumes n\\<^sub>1n\\<^sub>2: \"n\\<^sub>1 \\<le> n\\<^sub>2\"\n  shows \"f n\\<^sub>1 ! i = f n\\<^sub>2 ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f n\\<^sub>1 ! i = f n\\<^sub>2 ! i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f n\\<^sub>1 ! i = f n\\<^sub>2 ! i", "from chain n\\<^sub>1n\\<^sub>2"], ["proof (chain)\npicking this:\n  wf_infpath f\n  n\\<^sub>1 \\<le> n\\<^sub>2", "have \"\\<exists>a. f n\\<^sub>1 @ a = f n\\<^sub>2\""], ["proof (prove)\nusing this:\n  wf_infpath f\n  n\\<^sub>1 \\<le> n\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<exists>a. f n\\<^sub>1 @ a = f n\\<^sub>2", "using chain_prefix"], ["proof (prove)\nusing this:\n  wf_infpath f\n  n\\<^sub>1 \\<le> n\\<^sub>2\n  \\<lbrakk>wf_infpath ?f; ?n\\<^sub>1 \\<le> ?n\\<^sub>2\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a. ?f ?n\\<^sub>1 @ a = ?f ?n\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<exists>a. f n\\<^sub>1 @ a = f n\\<^sub>2", "by blast"], ["proof (state)\nthis:\n  \\<exists>a. f n\\<^sub>1 @ a = f n\\<^sub>2\n\ngoal (1 subgoal):\n 1. f n\\<^sub>1 ! i = f n\\<^sub>2 ! i", "then"], ["proof (chain)\npicking this:\n  \\<exists>a. f n\\<^sub>1 @ a = f n\\<^sub>2", "obtain a where a_p: \"f n\\<^sub>1 @ a = f n\\<^sub>2\""], ["proof (prove)\nusing this:\n  \\<exists>a. f n\\<^sub>1 @ a = f n\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        f n\\<^sub>1 @ a = f n\\<^sub>2 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  f n\\<^sub>1 @ a = f n\\<^sub>2\n\ngoal (1 subgoal):\n 1. f n\\<^sub>1 ! i = f n\\<^sub>2 ! i", "have \"(f n\\<^sub>1 @ a) ! i = f n\\<^sub>1 ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f n\\<^sub>1 @ a) ! i = f n\\<^sub>1 ! i", "using smalli"], ["proof (prove)\nusing this:\n  i < length (f n\\<^sub>1)\n\ngoal (1 subgoal):\n 1. (f n\\<^sub>1 @ a) ! i = f n\\<^sub>1 ! i", "by (simp add: nth_append)"], ["proof (state)\nthis:\n  (f n\\<^sub>1 @ a) ! i = f n\\<^sub>1 ! i\n\ngoal (1 subgoal):\n 1. f n\\<^sub>1 ! i = f n\\<^sub>2 ! i", "then"], ["proof (chain)\npicking this:\n  (f n\\<^sub>1 @ a) ! i = f n\\<^sub>1 ! i", "show ?thesis"], ["proof (prove)\nusing this:\n  (f n\\<^sub>1 @ a) ! i = f n\\<^sub>1 ! i\n\ngoal (1 subgoal):\n 1. f n\\<^sub>1 ! i = f n\\<^sub>2 ! i", "using a_p"], ["proof (prove)\nusing this:\n  (f n\\<^sub>1 @ a) ! i = f n\\<^sub>1 ! i\n  f n\\<^sub>1 @ a = f n\\<^sub>2\n\ngoal (1 subgoal):\n 1. f n\\<^sub>1 ! i = f n\\<^sub>2 ! i", "by auto"], ["proof (state)\nthis:\n  f n\\<^sub>1 ! i = f n\\<^sub>2 ! i\n\ngoal:\nNo subgoals!", "qed"], ["", "section \\<open>K?nig's Lemma\\<close>"], ["", "lemma inf_subs: \n  assumes inf: \"\\<not>finite(subtree T ds)\"\n  shows \"\\<not>finite(subtree T (ds @ [Left])) \\<or> \\<not>finite(subtree T (ds @ [Right]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. infinite (subtree T (ds @ [Left])) \\<or>\n    infinite (subtree T (ds @ [Right]))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite (subtree T (ds @ [Left])) \\<or>\n    infinite (subtree T (ds @ [Right]))", "let ?subtree = \"subtree T\""], ["proof (state)\ngoal (1 subgoal):\n 1. infinite (subtree T (ds @ [Left])) \\<or>\n    infinite (subtree T (ds @ [Right]))", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. infinite (subtree T (ds @ [Left])) \\<or>\n    infinite (subtree T (ds @ [Right]))", "assume asms: \"finite(?subtree(ds @ [Left]))\"\n                 \"finite(?subtree(ds @ [Right]))\""], ["proof (state)\nthis:\n  finite (subtree T (ds @ [Left]))\n  finite (subtree T (ds @ [Right]))\n\ngoal (1 subgoal):\n 1. infinite (subtree T (ds @ [Left])) \\<or>\n    infinite (subtree T (ds @ [Right]))", "have \"?subtree ds \\<subseteq> ?subtree (ds @ [Left] ) \\<union> ?subtree (ds @ [Right]) \\<union> {ds} \""], ["proof (prove)\ngoal (1 subgoal):\n 1. subtree T ds\n    \\<subseteq> subtree T (ds @ [Left]) \\<union>\n                subtree T (ds @ [Right]) \\<union>\n                {ds}", "using subtree_pos"], ["proof (prove)\nusing this:\n  subtree ?T ?ds\n  \\<subseteq> subtree ?T (?ds @ [Left]) \\<union>\n              subtree ?T (?ds @ [Right]) \\<union>\n              {?ds}\n\ngoal (1 subgoal):\n 1. subtree T ds\n    \\<subseteq> subtree T (ds @ [Left]) \\<union>\n                subtree T (ds @ [Right]) \\<union>\n                {ds}", "by auto"], ["proof (state)\nthis:\n  subtree T ds\n  \\<subseteq> subtree T (ds @ [Left]) \\<union>\n              subtree T (ds @ [Right]) \\<union>\n              {ds}\n\ngoal (1 subgoal):\n 1. infinite (subtree T (ds @ [Left])) \\<or>\n    infinite (subtree T (ds @ [Right]))", "then"], ["proof (chain)\npicking this:\n  subtree T ds\n  \\<subseteq> subtree T (ds @ [Left]) \\<union>\n              subtree T (ds @ [Right]) \\<union>\n              {ds}", "have \"finite(?subtree (ds))\""], ["proof (prove)\nusing this:\n  subtree T ds\n  \\<subseteq> subtree T (ds @ [Left]) \\<union>\n              subtree T (ds @ [Right]) \\<union>\n              {ds}\n\ngoal (1 subgoal):\n 1. finite (subtree T ds)", "using asms"], ["proof (prove)\nusing this:\n  subtree T ds\n  \\<subseteq> subtree T (ds @ [Left]) \\<union>\n              subtree T (ds @ [Right]) \\<union>\n              {ds}\n  finite (subtree T (ds @ [Left]))\n  finite (subtree T (ds @ [Right]))\n\ngoal (1 subgoal):\n 1. finite (subtree T ds)", "by (simp add: finite_subset)"], ["proof (state)\nthis:\n  finite (subtree T ds)\n\ngoal (1 subgoal):\n 1. infinite (subtree T (ds @ [Left])) \\<or>\n    infinite (subtree T (ds @ [Right]))", "}"], ["proof (state)\nthis:\n  \\<lbrakk>finite (subtree T (ds @ [Left]));\n   finite (subtree T (ds @ [Right]))\\<rbrakk>\n  \\<Longrightarrow> finite (subtree T ds)\n\ngoal (1 subgoal):\n 1. infinite (subtree T (ds @ [Left])) \\<or>\n    infinite (subtree T (ds @ [Right]))", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>finite (subtree T (ds @ [Left]));\n   finite (subtree T (ds @ [Right]))\\<rbrakk>\n  \\<Longrightarrow> finite (subtree T ds)", "show \"\\<not>finite(?subtree (ds @ [Left])) \\<or> \\<not>finite(?subtree (ds @ [Right]))\""], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (subtree T (ds @ [Left]));\n   finite (subtree T (ds @ [Right]))\\<rbrakk>\n  \\<Longrightarrow> finite (subtree T ds)\n\ngoal (1 subgoal):\n 1. infinite (subtree T (ds @ [Left])) \\<or>\n    infinite (subtree T (ds @ [Right]))", "using inf"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite (subtree T (ds @ [Left]));\n   finite (subtree T (ds @ [Right]))\\<rbrakk>\n  \\<Longrightarrow> finite (subtree T ds)\n  infinite (subtree T ds)\n\ngoal (1 subgoal):\n 1. infinite (subtree T (ds @ [Left])) \\<or>\n    infinite (subtree T (ds @ [Right]))", "by auto"], ["proof (state)\nthis:\n  infinite (subtree T (ds @ [Left])) \\<or>\n  infinite (subtree T (ds @ [Right]))\n\ngoal:\nNo subgoals!", "qed"], ["", "fun buildchain :: \"(dir list \\<Rightarrow> dir list) \\<Rightarrow> nat \\<Rightarrow> dir list\" where\n  \"buildchain next 0 = []\"\n| \"buildchain next (Suc n) = next (buildchain next n)\""], ["", "lemma konig:\n  assumes inf: \"\\<not>finite T\"\n  assumes wellformed: \"wf_tree T\"\n  shows \"\\<exists>c. wf_infpath c \\<and> (\\<forall>n. (c n) \\<in> T)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c. wf_infpath c \\<and> (\\<forall>n. c n \\<in> T)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_infpath ?c \\<and> (\\<forall>n. ?c n \\<in> T)", "let ?subtree = \"subtree T\""], ["proof (state)\ngoal (1 subgoal):\n 1. wf_infpath ?c \\<and> (\\<forall>n. ?c n \\<in> T)", "let ?nextnode = \"\\<lambda>ds. (if \\<not>finite (?subtree (ds @ [Left])) then ds @ [Left] else ds @ [Right])\""], ["proof (state)\ngoal (1 subgoal):\n 1. wf_infpath ?c \\<and> (\\<forall>n. ?c n \\<in> T)", "let ?c = \"buildchain ?nextnode\""], ["proof (state)\ngoal (1 subgoal):\n 1. wf_infpath ?c \\<and> (\\<forall>n. ?c n \\<in> T)", "have is_chain: \"wf_infpath ?c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf_infpath\n     (buildchain\n       (\\<lambda>ds.\n           if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n           else ds @ [Right]))", "by auto"], ["proof (state)\nthis:\n  wf_infpath\n   (buildchain\n     (\\<lambda>ds.\n         if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n         else ds @ [Right]))\n\ngoal (1 subgoal):\n 1. wf_infpath ?c \\<and> (\\<forall>n. ?c n \\<in> T)", "from wellformed"], ["proof (chain)\npicking this:\n  wf_tree T", "have prefix: \"\\<forall>ds d. (ds @ d) \\<in> T \\<longrightarrow> ds \\<in> T\""], ["proof (prove)\nusing this:\n  wf_tree T\n\ngoal (1 subgoal):\n 1. wf_tree T", "by blast"], ["proof (state)\nthis:\n  wf_tree T\n\ngoal (1 subgoal):\n 1. wf_infpath ?c \\<and> (\\<forall>n. ?c n \\<in> T)", "{"], ["proof (state)\nthis:\n  wf_tree T\n\ngoal (1 subgoal):\n 1. wf_infpath ?c \\<and> (\\<forall>n. ?c n \\<in> T)", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. wf_infpath ?c \\<and> (\\<forall>n. ?c n \\<in> T)", "have \"(?c n) \\<in> T \\<and> \\<not>finite (?subtree (?c n))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. buildchain\n     (\\<lambda>ds.\n         if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n         else ds @ [Right])\n     n\n    \\<in> T \\<and>\n    infinite\n     (subtree T\n       (buildchain\n         (\\<lambda>ds.\n             if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n             else ds @ [Right])\n         n))", "proof (induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. buildchain\n     (\\<lambda>ds.\n         if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n         else ds @ [Right])\n     0\n    \\<in> T \\<and>\n    infinite\n     (subtree T\n       (buildchain\n         (\\<lambda>ds.\n             if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n             else ds @ [Right])\n         0))\n 2. \\<And>n.\n       buildchain\n        (\\<lambda>ds.\n            if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n            else ds @ [Right])\n        n\n       \\<in> T \\<and>\n       infinite\n        (subtree T\n          (buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            n)) \\<Longrightarrow>\n       buildchain\n        (\\<lambda>ds.\n            if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n            else ds @ [Right])\n        (Suc n)\n       \\<in> T \\<and>\n       infinite\n        (subtree T\n          (buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            (Suc n)))", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. buildchain\n     (\\<lambda>ds.\n         if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n         else ds @ [Right])\n     0\n    \\<in> T \\<and>\n    infinite\n     (subtree T\n       (buildchain\n         (\\<lambda>ds.\n             if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n             else ds @ [Right])\n         0))\n 2. \\<And>n.\n       buildchain\n        (\\<lambda>ds.\n            if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n            else ds @ [Right])\n        n\n       \\<in> T \\<and>\n       infinite\n        (subtree T\n          (buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            n)) \\<Longrightarrow>\n       buildchain\n        (\\<lambda>ds.\n            if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n            else ds @ [Right])\n        (Suc n)\n       \\<in> T \\<and>\n       infinite\n        (subtree T\n          (buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            (Suc n)))", "have \"\\<exists>ds. ds \\<in> T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>ds. ds \\<in> T", "using inf"], ["proof (prove)\nusing this:\n  infinite T\n\ngoal (1 subgoal):\n 1. \\<exists>ds. ds \\<in> T", "by (simp add: not_finite_existsD)"], ["proof (state)\nthis:\n  \\<exists>ds. ds \\<in> T\n\ngoal (2 subgoals):\n 1. buildchain\n     (\\<lambda>ds.\n         if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n         else ds @ [Right])\n     0\n    \\<in> T \\<and>\n    infinite\n     (subtree T\n       (buildchain\n         (\\<lambda>ds.\n             if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n             else ds @ [Right])\n         0))\n 2. \\<And>n.\n       buildchain\n        (\\<lambda>ds.\n            if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n            else ds @ [Right])\n        n\n       \\<in> T \\<and>\n       infinite\n        (subtree T\n          (buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            n)) \\<Longrightarrow>\n       buildchain\n        (\\<lambda>ds.\n            if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n            else ds @ [Right])\n        (Suc n)\n       \\<in> T \\<and>\n       infinite\n        (subtree T\n          (buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            (Suc n)))", "then"], ["proof (chain)\npicking this:\n  \\<exists>ds. ds \\<in> T", "obtain ds where \"ds \\<in> T\""], ["proof (prove)\nusing this:\n  \\<exists>ds. ds \\<in> T\n\ngoal (1 subgoal):\n 1. (\\<And>ds. ds \\<in> T \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  ds \\<in> T\n\ngoal (2 subgoals):\n 1. buildchain\n     (\\<lambda>ds.\n         if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n         else ds @ [Right])\n     0\n    \\<in> T \\<and>\n    infinite\n     (subtree T\n       (buildchain\n         (\\<lambda>ds.\n             if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n             else ds @ [Right])\n         0))\n 2. \\<And>n.\n       buildchain\n        (\\<lambda>ds.\n            if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n            else ds @ [Right])\n        n\n       \\<in> T \\<and>\n       infinite\n        (subtree T\n          (buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            n)) \\<Longrightarrow>\n       buildchain\n        (\\<lambda>ds.\n            if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n            else ds @ [Right])\n        (Suc n)\n       \\<in> T \\<and>\n       infinite\n        (subtree T\n          (buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            (Suc n)))", "then"], ["proof (chain)\npicking this:\n  ds \\<in> T", "have \"([]@ds) \\<in> T\""], ["proof (prove)\nusing this:\n  ds \\<in> T\n\ngoal (1 subgoal):\n 1. [] @ ds \\<in> T", "by auto"], ["proof (state)\nthis:\n  [] @ ds \\<in> T\n\ngoal (2 subgoals):\n 1. buildchain\n     (\\<lambda>ds.\n         if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n         else ds @ [Right])\n     0\n    \\<in> T \\<and>\n    infinite\n     (subtree T\n       (buildchain\n         (\\<lambda>ds.\n             if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n             else ds @ [Right])\n         0))\n 2. \\<And>n.\n       buildchain\n        (\\<lambda>ds.\n            if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n            else ds @ [Right])\n        n\n       \\<in> T \\<and>\n       infinite\n        (subtree T\n          (buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            n)) \\<Longrightarrow>\n       buildchain\n        (\\<lambda>ds.\n            if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n            else ds @ [Right])\n        (Suc n)\n       \\<in> T \\<and>\n       infinite\n        (subtree T\n          (buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            (Suc n)))", "then"], ["proof (chain)\npicking this:\n  [] @ ds \\<in> T", "have \"[] \\<in> T\""], ["proof (prove)\nusing this:\n  [] @ ds \\<in> T\n\ngoal (1 subgoal):\n 1. [] \\<in> T", "using prefix"], ["proof (prove)\nusing this:\n  [] @ ds \\<in> T\n  wf_tree T\n\ngoal (1 subgoal):\n 1. [] \\<in> T", "by blast"], ["proof (state)\nthis:\n  [] \\<in> T\n\ngoal (2 subgoals):\n 1. buildchain\n     (\\<lambda>ds.\n         if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n         else ds @ [Right])\n     0\n    \\<in> T \\<and>\n    infinite\n     (subtree T\n       (buildchain\n         (\\<lambda>ds.\n             if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n             else ds @ [Right])\n         0))\n 2. \\<And>n.\n       buildchain\n        (\\<lambda>ds.\n            if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n            else ds @ [Right])\n        n\n       \\<in> T \\<and>\n       infinite\n        (subtree T\n          (buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            n)) \\<Longrightarrow>\n       buildchain\n        (\\<lambda>ds.\n            if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n            else ds @ [Right])\n        (Suc n)\n       \\<in> T \\<and>\n       infinite\n        (subtree T\n          (buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            (Suc n)))", "then"], ["proof (chain)\npicking this:\n  [] \\<in> T", "show ?case"], ["proof (prove)\nusing this:\n  [] \\<in> T\n\ngoal (1 subgoal):\n 1. buildchain\n     (\\<lambda>ds.\n         if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n         else ds @ [Right])\n     0\n    \\<in> T \\<and>\n    infinite\n     (subtree T\n       (buildchain\n         (\\<lambda>ds.\n             if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n             else ds @ [Right])\n         0))", "using inf"], ["proof (prove)\nusing this:\n  [] \\<in> T\n  infinite T\n\ngoal (1 subgoal):\n 1. buildchain\n     (\\<lambda>ds.\n         if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n         else ds @ [Right])\n     0\n    \\<in> T \\<and>\n    infinite\n     (subtree T\n       (buildchain\n         (\\<lambda>ds.\n             if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n             else ds @ [Right])\n         0))", "by auto"], ["proof (state)\nthis:\n  buildchain\n   (\\<lambda>ds.\n       if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n       else ds @ [Right])\n   0\n  \\<in> T \\<and>\n  infinite\n   (subtree T\n     (buildchain\n       (\\<lambda>ds.\n           if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n           else ds @ [Right])\n       0))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       buildchain\n        (\\<lambda>ds.\n            if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n            else ds @ [Right])\n        n\n       \\<in> T \\<and>\n       infinite\n        (subtree T\n          (buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            n)) \\<Longrightarrow>\n       buildchain\n        (\\<lambda>ds.\n            if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n            else ds @ [Right])\n        (Suc n)\n       \\<in> T \\<and>\n       infinite\n        (subtree T\n          (buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            (Suc n)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       buildchain\n        (\\<lambda>ds.\n            if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n            else ds @ [Right])\n        n\n       \\<in> T \\<and>\n       infinite\n        (subtree T\n          (buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            n)) \\<Longrightarrow>\n       buildchain\n        (\\<lambda>ds.\n            if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n            else ds @ [Right])\n        (Suc n)\n       \\<in> T \\<and>\n       infinite\n        (subtree T\n          (buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            (Suc n)))", "case (Suc n)"], ["proof (state)\nthis:\n  buildchain\n   (\\<lambda>ds.\n       if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n       else ds @ [Right])\n   n\n  \\<in> T \\<and>\n  infinite\n   (subtree T\n     (buildchain\n       (\\<lambda>ds.\n           if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n           else ds @ [Right])\n       n))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       buildchain\n        (\\<lambda>ds.\n            if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n            else ds @ [Right])\n        n\n       \\<in> T \\<and>\n       infinite\n        (subtree T\n          (buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            n)) \\<Longrightarrow>\n       buildchain\n        (\\<lambda>ds.\n            if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n            else ds @ [Right])\n        (Suc n)\n       \\<in> T \\<and>\n       infinite\n        (subtree T\n          (buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            (Suc n)))", "from Suc"], ["proof (chain)\npicking this:\n  buildchain\n   (\\<lambda>ds.\n       if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n       else ds @ [Right])\n   n\n  \\<in> T \\<and>\n  infinite\n   (subtree T\n     (buildchain\n       (\\<lambda>ds.\n           if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n           else ds @ [Right])\n       n))", "have next_in:  \"(?c n) \\<in> T\""], ["proof (prove)\nusing this:\n  buildchain\n   (\\<lambda>ds.\n       if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n       else ds @ [Right])\n   n\n  \\<in> T \\<and>\n  infinite\n   (subtree T\n     (buildchain\n       (\\<lambda>ds.\n           if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n           else ds @ [Right])\n       n))\n\ngoal (1 subgoal):\n 1. buildchain\n     (\\<lambda>ds.\n         if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n         else ds @ [Right])\n     n\n    \\<in> T", "by auto"], ["proof (state)\nthis:\n  buildchain\n   (\\<lambda>ds.\n       if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n       else ds @ [Right])\n   n\n  \\<in> T\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       buildchain\n        (\\<lambda>ds.\n            if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n            else ds @ [Right])\n        n\n       \\<in> T \\<and>\n       infinite\n        (subtree T\n          (buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            n)) \\<Longrightarrow>\n       buildchain\n        (\\<lambda>ds.\n            if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n            else ds @ [Right])\n        (Suc n)\n       \\<in> T \\<and>\n       infinite\n        (subtree T\n          (buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            (Suc n)))", "from Suc"], ["proof (chain)\npicking this:\n  buildchain\n   (\\<lambda>ds.\n       if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n       else ds @ [Right])\n   n\n  \\<in> T \\<and>\n  infinite\n   (subtree T\n     (buildchain\n       (\\<lambda>ds.\n           if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n           else ds @ [Right])\n       n))", "have next_inf: \"\\<not>finite (?subtree (?c n))\""], ["proof (prove)\nusing this:\n  buildchain\n   (\\<lambda>ds.\n       if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n       else ds @ [Right])\n   n\n  \\<in> T \\<and>\n  infinite\n   (subtree T\n     (buildchain\n       (\\<lambda>ds.\n           if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n           else ds @ [Right])\n       n))\n\ngoal (1 subgoal):\n 1. infinite\n     (subtree T\n       (buildchain\n         (\\<lambda>ds.\n             if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n             else ds @ [Right])\n         n))", "by auto"], ["proof (state)\nthis:\n  infinite\n   (subtree T\n     (buildchain\n       (\\<lambda>ds.\n           if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n           else ds @ [Right])\n       n))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       buildchain\n        (\\<lambda>ds.\n            if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n            else ds @ [Right])\n        n\n       \\<in> T \\<and>\n       infinite\n        (subtree T\n          (buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            n)) \\<Longrightarrow>\n       buildchain\n        (\\<lambda>ds.\n            if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n            else ds @ [Right])\n        (Suc n)\n       \\<in> T \\<and>\n       infinite\n        (subtree T\n          (buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            (Suc n)))", "from next_inf"], ["proof (chain)\npicking this:\n  infinite\n   (subtree T\n     (buildchain\n       (\\<lambda>ds.\n           if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n           else ds @ [Right])\n       n))", "have next_next_inf:\n           \"\\<not>finite (?subtree (?nextnode (?c n)))\""], ["proof (prove)\nusing this:\n  infinite\n   (subtree T\n     (buildchain\n       (\\<lambda>ds.\n           if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n           else ds @ [Right])\n       n))\n\ngoal (1 subgoal):\n 1. infinite\n     (subtree T\n       (if infinite\n            (subtree T\n              (buildchain\n                (\\<lambda>ds.\n                    if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                    else ds @ [Right])\n                n @\n               [Left]))\n        then buildchain\n              (\\<lambda>ds.\n                  if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                  else ds @ [Right])\n              n @\n             [Left]\n        else buildchain\n              (\\<lambda>ds.\n                  if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                  else ds @ [Right])\n              n @\n             [Right]))", "using inf_subs"], ["proof (prove)\nusing this:\n  infinite\n   (subtree T\n     (buildchain\n       (\\<lambda>ds.\n           if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n           else ds @ [Right])\n       n))\n  infinite (subtree ?T ?ds) \\<Longrightarrow>\n  infinite (subtree ?T (?ds @ [Left])) \\<or>\n  infinite (subtree ?T (?ds @ [Right]))\n\ngoal (1 subgoal):\n 1. infinite\n     (subtree T\n       (if infinite\n            (subtree T\n              (buildchain\n                (\\<lambda>ds.\n                    if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                    else ds @ [Right])\n                n @\n               [Left]))\n        then buildchain\n              (\\<lambda>ds.\n                  if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                  else ds @ [Right])\n              n @\n             [Left]\n        else buildchain\n              (\\<lambda>ds.\n                  if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                  else ds @ [Right])\n              n @\n             [Right]))", "by auto"], ["proof (state)\nthis:\n  infinite\n   (subtree T\n     (if infinite\n          (subtree T\n            (buildchain\n              (\\<lambda>ds.\n                  if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                  else ds @ [Right])\n              n @\n             [Left]))\n      then buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            n @\n           [Left]\n      else buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            n @\n           [Right]))\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       buildchain\n        (\\<lambda>ds.\n            if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n            else ds @ [Right])\n        n\n       \\<in> T \\<and>\n       infinite\n        (subtree T\n          (buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            n)) \\<Longrightarrow>\n       buildchain\n        (\\<lambda>ds.\n            if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n            else ds @ [Right])\n        (Suc n)\n       \\<in> T \\<and>\n       infinite\n        (subtree T\n          (buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            (Suc n)))", "then"], ["proof (chain)\npicking this:\n  infinite\n   (subtree T\n     (if infinite\n          (subtree T\n            (buildchain\n              (\\<lambda>ds.\n                  if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                  else ds @ [Right])\n              n @\n             [Left]))\n      then buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            n @\n           [Left]\n      else buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            n @\n           [Right]))", "have \"\\<exists>ds. ds \\<in> ?subtree (?nextnode (?c n))\""], ["proof (prove)\nusing this:\n  infinite\n   (subtree T\n     (if infinite\n          (subtree T\n            (buildchain\n              (\\<lambda>ds.\n                  if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                  else ds @ [Right])\n              n @\n             [Left]))\n      then buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            n @\n           [Left]\n      else buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            n @\n           [Right]))\n\ngoal (1 subgoal):\n 1. \\<exists>ds.\n       ds \\<in> subtree T\n                 (if infinite\n                      (subtree T\n                        (buildchain\n                          (\\<lambda>ds.\n                              if infinite (subtree T (ds @ [Left]))\n                              then ds @ [Left] else ds @ [Right])\n                          n @\n                         [Left]))\n                  then buildchain\n                        (\\<lambda>ds.\n                            if infinite (subtree T (ds @ [Left]))\n                            then ds @ [Left] else ds @ [Right])\n                        n @\n                       [Left]\n                  else buildchain\n                        (\\<lambda>ds.\n                            if infinite (subtree T (ds @ [Left]))\n                            then ds @ [Left] else ds @ [Right])\n                        n @\n                       [Right])", "by (simp add: not_finite_existsD)"], ["proof (state)\nthis:\n  \\<exists>ds.\n     ds \\<in> subtree T\n               (if infinite\n                    (subtree T\n                      (buildchain\n                        (\\<lambda>ds.\n                            if infinite (subtree T (ds @ [Left]))\n                            then ds @ [Left] else ds @ [Right])\n                        n @\n                       [Left]))\n                then buildchain\n                      (\\<lambda>ds.\n                          if infinite (subtree T (ds @ [Left]))\n                          then ds @ [Left] else ds @ [Right])\n                      n @\n                     [Left]\n                else buildchain\n                      (\\<lambda>ds.\n                          if infinite (subtree T (ds @ [Left]))\n                          then ds @ [Left] else ds @ [Right])\n                      n @\n                     [Right])\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       buildchain\n        (\\<lambda>ds.\n            if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n            else ds @ [Right])\n        n\n       \\<in> T \\<and>\n       infinite\n        (subtree T\n          (buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            n)) \\<Longrightarrow>\n       buildchain\n        (\\<lambda>ds.\n            if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n            else ds @ [Right])\n        (Suc n)\n       \\<in> T \\<and>\n       infinite\n        (subtree T\n          (buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            (Suc n)))", "then"], ["proof (chain)\npicking this:\n  \\<exists>ds.\n     ds \\<in> subtree T\n               (if infinite\n                    (subtree T\n                      (buildchain\n                        (\\<lambda>ds.\n                            if infinite (subtree T (ds @ [Left]))\n                            then ds @ [Left] else ds @ [Right])\n                        n @\n                       [Left]))\n                then buildchain\n                      (\\<lambda>ds.\n                          if infinite (subtree T (ds @ [Left]))\n                          then ds @ [Left] else ds @ [Right])\n                      n @\n                     [Left]\n                else buildchain\n                      (\\<lambda>ds.\n                          if infinite (subtree T (ds @ [Left]))\n                          then ds @ [Left] else ds @ [Right])\n                      n @\n                     [Right])", "obtain ds where dss: \"ds \\<in> ?subtree (?nextnode (?c n))\""], ["proof (prove)\nusing this:\n  \\<exists>ds.\n     ds \\<in> subtree T\n               (if infinite\n                    (subtree T\n                      (buildchain\n                        (\\<lambda>ds.\n                            if infinite (subtree T (ds @ [Left]))\n                            then ds @ [Left] else ds @ [Right])\n                        n @\n                       [Left]))\n                then buildchain\n                      (\\<lambda>ds.\n                          if infinite (subtree T (ds @ [Left]))\n                          then ds @ [Left] else ds @ [Right])\n                      n @\n                     [Left]\n                else buildchain\n                      (\\<lambda>ds.\n                          if infinite (subtree T (ds @ [Left]))\n                          then ds @ [Left] else ds @ [Right])\n                      n @\n                     [Right])\n\ngoal (1 subgoal):\n 1. (\\<And>ds.\n        ds \\<in> subtree T\n                  (if infinite\n                       (subtree T\n                         (buildchain\n                           (\\<lambda>ds.\n                               if infinite (subtree T (ds @ [Left]))\n                               then ds @ [Left] else ds @ [Right])\n                           n @\n                          [Left]))\n                   then buildchain\n                         (\\<lambda>ds.\n                             if infinite (subtree T (ds @ [Left]))\n                             then ds @ [Left] else ds @ [Right])\n                         n @\n                        [Left]\n                   else buildchain\n                         (\\<lambda>ds.\n                             if infinite (subtree T (ds @ [Left]))\n                             then ds @ [Left] else ds @ [Right])\n                         n @\n                        [Right]) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ds \\<in> subtree T\n            (if infinite\n                 (subtree T\n                   (buildchain\n                     (\\<lambda>ds.\n                         if infinite (subtree T (ds @ [Left]))\n                         then ds @ [Left] else ds @ [Right])\n                     n @\n                    [Left]))\n             then buildchain\n                   (\\<lambda>ds.\n                       if infinite (subtree T (ds @ [Left]))\n                       then ds @ [Left] else ds @ [Right])\n                   n @\n                  [Left]\n             else buildchain\n                   (\\<lambda>ds.\n                       if infinite (subtree T (ds @ [Left]))\n                       then ds @ [Left] else ds @ [Right])\n                   n @\n                  [Right])\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       buildchain\n        (\\<lambda>ds.\n            if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n            else ds @ [Right])\n        n\n       \\<in> T \\<and>\n       infinite\n        (subtree T\n          (buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            n)) \\<Longrightarrow>\n       buildchain\n        (\\<lambda>ds.\n            if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n            else ds @ [Right])\n        (Suc n)\n       \\<in> T \\<and>\n       infinite\n        (subtree T\n          (buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            (Suc n)))", "then"], ["proof (chain)\npicking this:\n  ds \\<in> subtree T\n            (if infinite\n                 (subtree T\n                   (buildchain\n                     (\\<lambda>ds.\n                         if infinite (subtree T (ds @ [Left]))\n                         then ds @ [Left] else ds @ [Right])\n                     n @\n                    [Left]))\n             then buildchain\n                   (\\<lambda>ds.\n                       if infinite (subtree T (ds @ [Left]))\n                       then ds @ [Left] else ds @ [Right])\n                   n @\n                  [Left]\n             else buildchain\n                   (\\<lambda>ds.\n                       if infinite (subtree T (ds @ [Left]))\n                       then ds @ [Left] else ds @ [Right])\n                   n @\n                  [Right])", "have \"ds \\<in> T\" \"\\<exists>suf. ds = (?nextnode (?c n)) @ suf\""], ["proof (prove)\nusing this:\n  ds \\<in> subtree T\n            (if infinite\n                 (subtree T\n                   (buildchain\n                     (\\<lambda>ds.\n                         if infinite (subtree T (ds @ [Left]))\n                         then ds @ [Left] else ds @ [Right])\n                     n @\n                    [Left]))\n             then buildchain\n                   (\\<lambda>ds.\n                       if infinite (subtree T (ds @ [Left]))\n                       then ds @ [Left] else ds @ [Right])\n                   n @\n                  [Left]\n             else buildchain\n                   (\\<lambda>ds.\n                       if infinite (subtree T (ds @ [Left]))\n                       then ds @ [Left] else ds @ [Right])\n                   n @\n                  [Right])\n\ngoal (1 subgoal):\n 1. ds \\<in> T &&&\n    \\<exists>suf.\n       ds =\n       (if infinite\n            (subtree T\n              (buildchain\n                (\\<lambda>ds.\n                    if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                    else ds @ [Right])\n                n @\n               [Left]))\n        then buildchain\n              (\\<lambda>ds.\n                  if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                  else ds @ [Right])\n              n @\n             [Left]\n        else buildchain\n              (\\<lambda>ds.\n                  if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                  else ds @ [Right])\n              n @\n             [Right]) @\n       suf", "by auto"], ["proof (state)\nthis:\n  ds \\<in> T\n  \\<exists>suf.\n     ds =\n     (if infinite\n          (subtree T\n            (buildchain\n              (\\<lambda>ds.\n                  if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                  else ds @ [Right])\n              n @\n             [Left]))\n      then buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            n @\n           [Left]\n      else buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            n @\n           [Right]) @\n     suf\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       buildchain\n        (\\<lambda>ds.\n            if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n            else ds @ [Right])\n        n\n       \\<in> T \\<and>\n       infinite\n        (subtree T\n          (buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            n)) \\<Longrightarrow>\n       buildchain\n        (\\<lambda>ds.\n            if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n            else ds @ [Right])\n        (Suc n)\n       \\<in> T \\<and>\n       infinite\n        (subtree T\n          (buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            (Suc n)))", "then"], ["proof (chain)\npicking this:\n  ds \\<in> T\n  \\<exists>suf.\n     ds =\n     (if infinite\n          (subtree T\n            (buildchain\n              (\\<lambda>ds.\n                  if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                  else ds @ [Right])\n              n @\n             [Left]))\n      then buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            n @\n           [Left]\n      else buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            n @\n           [Right]) @\n     suf", "obtain suf where \"ds \\<in> T \\<and> ds = (?nextnode (?c n)) @ suf\""], ["proof (prove)\nusing this:\n  ds \\<in> T\n  \\<exists>suf.\n     ds =\n     (if infinite\n          (subtree T\n            (buildchain\n              (\\<lambda>ds.\n                  if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                  else ds @ [Right])\n              n @\n             [Left]))\n      then buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            n @\n           [Left]\n      else buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            n @\n           [Right]) @\n     suf\n\ngoal (1 subgoal):\n 1. (\\<And>suf.\n        ds \\<in> T \\<and>\n        ds =\n        (if infinite\n             (subtree T\n               (buildchain\n                 (\\<lambda>ds.\n                     if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                     else ds @ [Right])\n                 n @\n                [Left]))\n         then buildchain\n               (\\<lambda>ds.\n                   if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                   else ds @ [Right])\n               n @\n              [Left]\n         else buildchain\n               (\\<lambda>ds.\n                   if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                   else ds @ [Right])\n               n @\n              [Right]) @\n        suf \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ds \\<in> T \\<and>\n  ds =\n  (if infinite\n       (subtree T\n         (buildchain\n           (\\<lambda>ds.\n               if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n               else ds @ [Right])\n           n @\n          [Left]))\n   then buildchain\n         (\\<lambda>ds.\n             if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n             else ds @ [Right])\n         n @\n        [Left]\n   else buildchain\n         (\\<lambda>ds.\n             if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n             else ds @ [Right])\n         n @\n        [Right]) @\n  suf\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       buildchain\n        (\\<lambda>ds.\n            if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n            else ds @ [Right])\n        n\n       \\<in> T \\<and>\n       infinite\n        (subtree T\n          (buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            n)) \\<Longrightarrow>\n       buildchain\n        (\\<lambda>ds.\n            if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n            else ds @ [Right])\n        (Suc n)\n       \\<in> T \\<and>\n       infinite\n        (subtree T\n          (buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            (Suc n)))", "then"], ["proof (chain)\npicking this:\n  ds \\<in> T \\<and>\n  ds =\n  (if infinite\n       (subtree T\n         (buildchain\n           (\\<lambda>ds.\n               if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n               else ds @ [Right])\n           n @\n          [Left]))\n   then buildchain\n         (\\<lambda>ds.\n             if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n             else ds @ [Right])\n         n @\n        [Left]\n   else buildchain\n         (\\<lambda>ds.\n             if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n             else ds @ [Right])\n         n @\n        [Right]) @\n  suf", "have \"(?nextnode (?c n)) \\<in> T\""], ["proof (prove)\nusing this:\n  ds \\<in> T \\<and>\n  ds =\n  (if infinite\n       (subtree T\n         (buildchain\n           (\\<lambda>ds.\n               if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n               else ds @ [Right])\n           n @\n          [Left]))\n   then buildchain\n         (\\<lambda>ds.\n             if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n             else ds @ [Right])\n         n @\n        [Left]\n   else buildchain\n         (\\<lambda>ds.\n             if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n             else ds @ [Right])\n         n @\n        [Right]) @\n  suf\n\ngoal (1 subgoal):\n 1. (if infinite\n         (subtree T\n           (buildchain\n             (\\<lambda>ds.\n                 if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                 else ds @ [Right])\n             n @\n            [Left]))\n     then buildchain\n           (\\<lambda>ds.\n               if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n               else ds @ [Right])\n           n @\n          [Left]\n     else buildchain\n           (\\<lambda>ds.\n               if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n               else ds @ [Right])\n           n @\n          [Right])\n    \\<in> T", "using prefix"], ["proof (prove)\nusing this:\n  ds \\<in> T \\<and>\n  ds =\n  (if infinite\n       (subtree T\n         (buildchain\n           (\\<lambda>ds.\n               if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n               else ds @ [Right])\n           n @\n          [Left]))\n   then buildchain\n         (\\<lambda>ds.\n             if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n             else ds @ [Right])\n         n @\n        [Left]\n   else buildchain\n         (\\<lambda>ds.\n             if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n             else ds @ [Right])\n         n @\n        [Right]) @\n  suf\n  wf_tree T\n\ngoal (1 subgoal):\n 1. (if infinite\n         (subtree T\n           (buildchain\n             (\\<lambda>ds.\n                 if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                 else ds @ [Right])\n             n @\n            [Left]))\n     then buildchain\n           (\\<lambda>ds.\n               if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n               else ds @ [Right])\n           n @\n          [Left]\n     else buildchain\n           (\\<lambda>ds.\n               if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n               else ds @ [Right])\n           n @\n          [Right])\n    \\<in> T", "by blast"], ["proof (state)\nthis:\n  (if infinite\n       (subtree T\n         (buildchain\n           (\\<lambda>ds.\n               if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n               else ds @ [Right])\n           n @\n          [Left]))\n   then buildchain\n         (\\<lambda>ds.\n             if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n             else ds @ [Right])\n         n @\n        [Left]\n   else buildchain\n         (\\<lambda>ds.\n             if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n             else ds @ [Right])\n         n @\n        [Right])\n  \\<in> T\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       buildchain\n        (\\<lambda>ds.\n            if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n            else ds @ [Right])\n        n\n       \\<in> T \\<and>\n       infinite\n        (subtree T\n          (buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            n)) \\<Longrightarrow>\n       buildchain\n        (\\<lambda>ds.\n            if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n            else ds @ [Right])\n        (Suc n)\n       \\<in> T \\<and>\n       infinite\n        (subtree T\n          (buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            (Suc n)))", "then"], ["proof (chain)\npicking this:\n  (if infinite\n       (subtree T\n         (buildchain\n           (\\<lambda>ds.\n               if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n               else ds @ [Right])\n           n @\n          [Left]))\n   then buildchain\n         (\\<lambda>ds.\n             if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n             else ds @ [Right])\n         n @\n        [Left]\n   else buildchain\n         (\\<lambda>ds.\n             if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n             else ds @ [Right])\n         n @\n        [Right])\n  \\<in> T", "have \"(?c (Suc n)) \\<in> T\""], ["proof (prove)\nusing this:\n  (if infinite\n       (subtree T\n         (buildchain\n           (\\<lambda>ds.\n               if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n               else ds @ [Right])\n           n @\n          [Left]))\n   then buildchain\n         (\\<lambda>ds.\n             if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n             else ds @ [Right])\n         n @\n        [Left]\n   else buildchain\n         (\\<lambda>ds.\n             if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n             else ds @ [Right])\n         n @\n        [Right])\n  \\<in> T\n\ngoal (1 subgoal):\n 1. buildchain\n     (\\<lambda>ds.\n         if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n         else ds @ [Right])\n     (Suc n)\n    \\<in> T", "by auto"], ["proof (state)\nthis:\n  buildchain\n   (\\<lambda>ds.\n       if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n       else ds @ [Right])\n   (Suc n)\n  \\<in> T\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       buildchain\n        (\\<lambda>ds.\n            if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n            else ds @ [Right])\n        n\n       \\<in> T \\<and>\n       infinite\n        (subtree T\n          (buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            n)) \\<Longrightarrow>\n       buildchain\n        (\\<lambda>ds.\n            if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n            else ds @ [Right])\n        (Suc n)\n       \\<in> T \\<and>\n       infinite\n        (subtree T\n          (buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            (Suc n)))", "then"], ["proof (chain)\npicking this:\n  buildchain\n   (\\<lambda>ds.\n       if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n       else ds @ [Right])\n   (Suc n)\n  \\<in> T", "show ?case"], ["proof (prove)\nusing this:\n  buildchain\n   (\\<lambda>ds.\n       if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n       else ds @ [Right])\n   (Suc n)\n  \\<in> T\n\ngoal (1 subgoal):\n 1. buildchain\n     (\\<lambda>ds.\n         if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n         else ds @ [Right])\n     (Suc n)\n    \\<in> T \\<and>\n    infinite\n     (subtree T\n       (buildchain\n         (\\<lambda>ds.\n             if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n             else ds @ [Right])\n         (Suc n)))", "using next_next_inf"], ["proof (prove)\nusing this:\n  buildchain\n   (\\<lambda>ds.\n       if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n       else ds @ [Right])\n   (Suc n)\n  \\<in> T\n  infinite\n   (subtree T\n     (if infinite\n          (subtree T\n            (buildchain\n              (\\<lambda>ds.\n                  if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                  else ds @ [Right])\n              n @\n             [Left]))\n      then buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            n @\n           [Left]\n      else buildchain\n            (\\<lambda>ds.\n                if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n                else ds @ [Right])\n            n @\n           [Right]))\n\ngoal (1 subgoal):\n 1. buildchain\n     (\\<lambda>ds.\n         if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n         else ds @ [Right])\n     (Suc n)\n    \\<in> T \\<and>\n    infinite\n     (subtree T\n       (buildchain\n         (\\<lambda>ds.\n             if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n             else ds @ [Right])\n         (Suc n)))", "by auto"], ["proof (state)\nthis:\n  buildchain\n   (\\<lambda>ds.\n       if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n       else ds @ [Right])\n   (Suc n)\n  \\<in> T \\<and>\n  infinite\n   (subtree T\n     (buildchain\n       (\\<lambda>ds.\n           if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n           else ds @ [Right])\n       (Suc n)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  buildchain\n   (\\<lambda>ds.\n       if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n       else ds @ [Right])\n   n\n  \\<in> T \\<and>\n  infinite\n   (subtree T\n     (buildchain\n       (\\<lambda>ds.\n           if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n           else ds @ [Right])\n       n))\n\ngoal (1 subgoal):\n 1. wf_infpath ?c \\<and> (\\<forall>n. ?c n \\<in> T)", "}"], ["proof (state)\nthis:\n  buildchain\n   (\\<lambda>ds.\n       if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n       else ds @ [Right])\n   ?n2\n  \\<in> T \\<and>\n  infinite\n   (subtree T\n     (buildchain\n       (\\<lambda>ds.\n           if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n           else ds @ [Right])\n       ?n2))\n\ngoal (1 subgoal):\n 1. wf_infpath ?c \\<and> (\\<forall>n. ?c n \\<in> T)", "then"], ["proof (chain)\npicking this:\n  buildchain\n   (\\<lambda>ds.\n       if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n       else ds @ [Right])\n   ?n2\n  \\<in> T \\<and>\n  infinite\n   (subtree T\n     (buildchain\n       (\\<lambda>ds.\n           if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n           else ds @ [Right])\n       ?n2))", "show \"wf_infpath ?c \\<and> (\\<forall>n. (?c n)\\<in> T) \""], ["proof (prove)\nusing this:\n  buildchain\n   (\\<lambda>ds.\n       if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n       else ds @ [Right])\n   ?n2\n  \\<in> T \\<and>\n  infinite\n   (subtree T\n     (buildchain\n       (\\<lambda>ds.\n           if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n           else ds @ [Right])\n       ?n2))\n\ngoal (1 subgoal):\n 1. wf_infpath\n     (buildchain\n       (\\<lambda>ds.\n           if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n           else ds @ [Right])) \\<and>\n    (\\<forall>n.\n        buildchain\n         (\\<lambda>ds.\n             if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n             else ds @ [Right])\n         n\n        \\<in> T)", "using is_chain"], ["proof (prove)\nusing this:\n  buildchain\n   (\\<lambda>ds.\n       if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n       else ds @ [Right])\n   ?n2\n  \\<in> T \\<and>\n  infinite\n   (subtree T\n     (buildchain\n       (\\<lambda>ds.\n           if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n           else ds @ [Right])\n       ?n2))\n  wf_infpath\n   (buildchain\n     (\\<lambda>ds.\n         if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n         else ds @ [Right]))\n\ngoal (1 subgoal):\n 1. wf_infpath\n     (buildchain\n       (\\<lambda>ds.\n           if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n           else ds @ [Right])) \\<and>\n    (\\<forall>n.\n        buildchain\n         (\\<lambda>ds.\n             if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n             else ds @ [Right])\n         n\n        \\<in> T)", "by auto"], ["proof (state)\nthis:\n  wf_infpath\n   (buildchain\n     (\\<lambda>ds.\n         if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n         else ds @ [Right])) \\<and>\n  (\\<forall>n.\n      buildchain\n       (\\<lambda>ds.\n           if infinite (subtree T (ds @ [Left])) then ds @ [Left]\n           else ds @ [Right])\n       n\n      \\<in> T)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"]]}