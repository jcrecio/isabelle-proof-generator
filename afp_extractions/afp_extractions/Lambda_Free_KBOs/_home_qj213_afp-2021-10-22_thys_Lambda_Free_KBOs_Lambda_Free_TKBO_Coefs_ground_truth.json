{"file_name": "/home/qj213/afp-2021-10-22/thys/Lambda_Free_KBOs/Lambda_Free_TKBO_Coefs.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Lambda_Free_KBOs", "problem_names": ["lemma arity\\<^sub>h_conv: \"arity\\<^sub>h s = arity_hd\\<^sub>h (head s) - of_nat (num_args s)\"", "lemma arity\\<^sub>h_App[simp]: \"arity\\<^sub>h (App s t) = arity\\<^sub>h s - 1\"", "lemmas wary_App\\<^sub>h[intro] = wary_App[folded of_nat_lt_hmset_of_enat_iff]", "lemmas wary_AppE\\<^sub>h = wary_AppE[folded of_nat_lt_hmset_of_enat_iff]", "lemmas wary_num_args_le_arity_head\\<^sub>h =\n  wary_num_args_le_arity_head[folded of_nat_le_hmset_of_enat_iff]", "lemmas wary_apps\\<^sub>h = wary_apps[folded of_nat_le_hmset_of_enat_iff]", "lemmas wary_cases_apps\\<^sub>h[consumes 1, case_names apps] =\n  wary_cases_apps[folded of_nat_le_hmset_of_enat_iff]", "lemmas ground_heads_arity\\<^sub>h = ground_heads_arity[folded hmset_of_enat_le]", "lemmas some_ground_head_arity\\<^sub>h = some_ground_head_arity[folded hmset_of_enat_le]", "lemmas \\<epsilon>\\<^sub>h_gt_0 = \\<epsilon>_gt_0[folded of_nat_less_hmset, unfolded of_nat_0]", "lemmas \\<delta>\\<^sub>h_le_\\<epsilon>\\<^sub>h = \\<delta>_le_\\<epsilon>[folded of_nat_le_hmset]", "lemmas arity_hd\\<^sub>h_lt_\\<omega>_if_\\<delta>\\<^sub>h_gt_0 = arity_hd_ne_infinity_if_\\<delta>_gt_0\n  [folded of_nat_less_hmset, unfolded of_nat_0, folded hmset_of_enat_lt_iff_ne_infinity]", "lemma wt_sym_ge\\<^sub>h: \"wt_sym f \\<ge> \\<epsilon>\\<^sub>h - \\<delta>\\<^sub>h * arity_sym\\<^sub>h f\"", "lemmas unary_wt_sym_0_gt\\<^sub>h = unary_wt_sym_0_gt[folded hmset_of_enat_inject, unfolded hmset_of_enat_1]", "lemmas unary_wt_sym_0_imp_\\<delta>\\<^sub>h_eq_\\<epsilon>\\<^sub>h = unary_wt_sym_0_imp_\\<delta>_eq_\\<epsilon>\n  [folded of_nat_inject_hmset, unfolded of_nat_0]", "lemmas extf_ext_snoc_if_\\<delta>\\<^sub>h_eq_\\<epsilon>\\<^sub>h = extf_ext_snoc_if_\\<delta>_eq_\\<epsilon>[folded of_nat_inject_hmset]", "lemmas extf_snoc_if_\\<delta>\\<^sub>h_eq_\\<epsilon>\\<^sub>h = ext_snoc.snoc[OF extf_ext_snoc_if_\\<delta>\\<^sub>h_eq_\\<epsilon>\\<^sub>h]", "lemmas arity_sym\\<^sub>h_lt_\\<omega>_if_\\<delta>\\<^sub>h_gt_0 = arity_sym_ne_infinity_if_\\<delta>_gt_0\n  [folded of_nat_less_hmset hmset_of_enat_lt_iff_ne_infinity, unfolded of_nat_0]", "lemmas arity_var\\<^sub>h_lt_\\<omega>_if_\\<delta>\\<^sub>h_gt_0 = arity_var_ne_infinity_if_\\<delta>_gt_0\n  [folded of_nat_less_hmset hmset_of_enat_lt_iff_ne_infinity, unfolded of_nat_0]", "lemmas arity\\<^sub>h_lt_\\<omega>_if_\\<delta>\\<^sub>h_gt_0 = arity_ne_infinity_if_\\<delta>_gt_0\n  [folded of_nat_less_hmset hmset_of_enat_lt_iff_ne_infinity, unfolded of_nat_0]", "lemmas warywary_subst_subst\\<^sub>h_conv = wary_subst_def[folded hmset_of_enat_le]", "lemmas extf_singleton_nil_if_\\<delta>\\<^sub>h_eq_\\<epsilon>\\<^sub>h = extf_singleton_nil_if_\\<delta>_eq_\\<epsilon>[folded of_nat_inject_hmset]", "lemma arity_sym\\<^sub>h_if_\\<delta>\\<^sub>h_gt_0_E:\n  assumes \\<delta>_gt_0: \"\\<delta>\\<^sub>h > 0\"\n  obtains n where \"arity_sym\\<^sub>h f = of_nat n\"", "lemma arity_var\\<^sub>h_if_\\<delta>\\<^sub>h_gt_0_E:\n  assumes \\<delta>_gt_0: \"\\<delta>\\<^sub>h > 0\"\n  obtains n where \"arity_var\\<^sub>h f = of_nat n\"", "lemma eval_tpoly_eq_eval_ztpoly[simp]:\n  \"zhmset_of (eval_tpoly A p) = eval_ztpoly (\\<lambda>v. zhmset_of (A v)) p\"", "lemma min_zpassign_simps[simp]:\n  \"min_zpassign (PWt x) = zhmset_of (wt_sym (min_ground_head (Var x)))\"\n  \"min_zpassign (PCoef x i) = 1\"", "lemma legal_min_passign: \"legal_passign min_passign\"", "lemma legal_min_zpassign: \"legal_zpassign min_zpassign\"", "lemma assign_ge_0[intro]: \"legal_zpassign A \\<Longrightarrow> A x \\<ge> 0\"", "lemma gt_tpoly_imp_ge[intro]: \"q >\\<^sub>p p \\<Longrightarrow> q \\<ge>\\<^sub>p p\"", "lemma eq_tpoly_refl[simp]: \"p =\\<^sub>p p\"", "lemma ge_tpoly_refl[simp]: \"p \\<ge>\\<^sub>p p\"", "lemma gt_tpoly_irrefl: \"\\<not> p >\\<^sub>p p\"", "lemma\n  eq_eq_tpoly_trans: \"r =\\<^sub>p q \\<Longrightarrow> q =\\<^sub>p p \\<Longrightarrow> r =\\<^sub>p p\" and\n  eq_ge_tpoly_trans: \"r =\\<^sub>p q \\<Longrightarrow> q \\<ge>\\<^sub>p p \\<Longrightarrow> r \\<ge>\\<^sub>p p\" and\n  eq_gt_tpoly_trans: \"r =\\<^sub>p q \\<Longrightarrow> q >\\<^sub>p p \\<Longrightarrow> r >\\<^sub>p p\" and\n  ge_eq_tpoly_trans: \"r \\<ge>\\<^sub>p q \\<Longrightarrow> q =\\<^sub>p p \\<Longrightarrow> r \\<ge>\\<^sub>p p\" and\n  ge_ge_tpoly_trans: \"r \\<ge>\\<^sub>p q \\<Longrightarrow> q \\<ge>\\<^sub>p p \\<Longrightarrow> r \\<ge>\\<^sub>p p\" and\n  ge_gt_tpoly_trans: \"r \\<ge>\\<^sub>p q \\<Longrightarrow> q >\\<^sub>p p \\<Longrightarrow> r >\\<^sub>p p\" and\n  gt_eq_tpoly_trans: \"r >\\<^sub>p q \\<Longrightarrow> q =\\<^sub>p p \\<Longrightarrow> r >\\<^sub>p p\" and\n  gt_ge_tpoly_trans: \"r >\\<^sub>p q \\<Longrightarrow> q \\<ge>\\<^sub>p p \\<Longrightarrow> r >\\<^sub>p p\" and\n  gt_gt_tpoly_trans: \"r >\\<^sub>p q \\<Longrightarrow> q >\\<^sub>p p \\<Longrightarrow> r >\\<^sub>p p\"", "lemma coef_hd_gt_0:\n  assumes legal: \"legal_zpassign A\"\n  shows \"eval_ztpoly A (coef_hd \\<zeta> i) > 0\"", "lemma coef_apps[simp]: \"coef (apps s ss) i = coef s (i + length ss)\"", "lemma coef_gt_0: \"legal_zpassign A \\<Longrightarrow> eval_ztpoly A (coef s i) > 0\"", "lemma exists_min_ground_head:\n  \"\\<exists>f. f \\<in> ground_heads \\<zeta> \\<and>\n     (\\<forall>g \\<in> ground_heads \\<zeta>. wt_sym g + \\<delta>\\<^sub>h * arity_sym\\<^sub>h g \\<ge> wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f)\"", "lemma min_ground_head_Sym[simp]: \"min_ground_head (Sym f) = f\"", "lemma min_ground_head_in_ground_heads: \"min_ground_head \\<zeta> \\<in> ground_heads \\<zeta>\"", "lemma min_ground_head_min:\n  \"f \\<in> ground_heads \\<zeta> \\<Longrightarrow>\n   wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f \\<ge> wt_sym (min_ground_head \\<zeta>) + \\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>)\"", "lemma min_ground_head_antimono:\n  \"ground_heads \\<zeta> \\<subseteq> ground_heads \\<xi> \\<Longrightarrow>\n   wt_sym (min_ground_head \\<zeta>) + \\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>)\n   \\<ge> wt_sym (min_ground_head \\<xi>) + \\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<xi>)\"", "lemma wt0_ge_min_ground_head:\n  \"legal_zpassign A \\<Longrightarrow> eval_ztpoly A (wt0 \\<zeta>) \\<ge> zhmset_of (wt_sym (min_ground_head \\<zeta>))\"", "lemma eval_ztpoly_nonneg: \"legal_zpassign A \\<Longrightarrow> eval_ztpoly A p \\<ge> 0\"", "lemma in_zip_imp_size_lt_apps: \"(s, y) \\<in> set (zip ss ys) \\<Longrightarrow> size s < size (apps (Hd \\<zeta>) ss)\"", "lemma wt_Hd[simp]: \"wt (Hd \\<zeta>) = PSum [wt0 \\<zeta>, PNum (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))]\"", "lemma coef_hd_cong:\n  \"(\\<forall>x \\<in> vars_hd \\<zeta>. \\<forall>i. A (PCoef x i) = B (PCoef x i)) \\<Longrightarrow>\n   eval_ztpoly A (coef_hd \\<zeta> i) = eval_ztpoly B (coef_hd \\<zeta> i)\"", "lemma wt0_cong:\n  assumes pwt_eq: \"\\<forall>x \\<in> vars_hd \\<zeta>. A (PWt x) = B (PWt x)\"\n  shows \"eval_ztpoly A (wt0 \\<zeta>) = eval_ztpoly B (wt0 \\<zeta>)\"", "lemma wt_cong:\n  assumes\n    \"\\<forall>x \\<in> vars s. A (PWt x) = B (PWt x)\" and\n    \"\\<forall>x \\<in> vars s. \\<forall>i. A (PCoef x i) = B (PCoef x i)\"\n  shows \"eval_ztpoly A (wt s) = eval_ztpoly B (wt s)\"", "lemma ground_eval_ztpoly_wt_eq: \"ground s \\<Longrightarrow> eval_ztpoly A (wt s) = eval_ztpoly B (wt s)\"", "lemma exists_wt_sym:\n  assumes legal: \"legal_zpassign A\"\n  shows \"\\<exists>f \\<in> ground_heads \\<zeta>. eval_ztpoly A (wt (Hd \\<zeta>)) \\<ge> zhmset_of (wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f)\"", "lemma wt_ge_\\<epsilon>\\<^sub>h:\n  assumes legal: \"legal_zpassign A\"\n  shows \"eval_ztpoly A (wt s) \\<ge> zhmset_of \\<epsilon>\\<^sub>h\"", "lemma wt_args_ge_length_times_\\<epsilon>\\<^sub>h:\n  assumes legal: \"legal_zpassign A\"\n  shows \"wt_args i A \\<zeta> ss \\<ge> of_nat (length ss) * zhmset_of \\<epsilon>\\<^sub>h\"", "lemma wt_ge_\\<delta>\\<^sub>h: \"legal_zpassign A \\<Longrightarrow> eval_ztpoly A (wt s) \\<ge> zhmset_of \\<delta>\\<^sub>h\"", "lemma wt_gt_0: \"legal_zpassign A \\<Longrightarrow> eval_ztpoly A (wt s) > 0\"", "lemma wt_gt_\\<delta>\\<^sub>h_if_superunary:\n  assumes\n    legal: \"legal_zpassign A\" and\n    superunary: \"arity_hd\\<^sub>h (head s) > 1\"\n  shows \"eval_ztpoly A (wt s) > zhmset_of \\<delta>\\<^sub>h\"", "lemma wt_App_plus_\\<delta>\\<^sub>h_ge:\n  \"eval_ztpoly A (wt (App s t)) + zhmset_of \\<delta>\\<^sub>h\n   \\<ge> eval_ztpoly A (wt s) + eval_ztpoly A (coef s 0) * eval_ztpoly A (wt t)\"", "lemma wt_App_fun_\\<delta>\\<^sub>h:\n  assumes\n    legal: \"legal_zpassign A\" and\n    wt_st: \"eval_ztpoly A (wt (App s t)) = eval_ztpoly A (wt t)\"\n  shows \"eval_ztpoly A (wt s) = zhmset_of \\<delta>\\<^sub>h\"", "lemma wt_App_arg_\\<delta>\\<^sub>h:\n  assumes\n    legal: \"legal_zpassign A\" and\n    wt_st: \"eval_ztpoly A (wt (App s t)) = eval_ztpoly A (wt s)\"\n  shows \"eval_ztpoly A (wt t) = zhmset_of \\<delta>\\<^sub>h\"", "lemma wt_App_ge_fun: \"wt (App s t) \\<ge>\\<^sub>p wt s\"", "lemma wt_App_ge_arg: \"wt (App s t) \\<ge>\\<^sub>p wt t\"", "lemma wt_\\<delta>\\<^sub>h_imp_\\<delta>\\<^sub>h_eq_\\<epsilon>\\<^sub>h:\n  assumes\n    legal: \"legal_zpassign A\" and\n    wt_s_eq_\\<delta>: \"eval_ztpoly A (wt s) = zhmset_of \\<delta>\\<^sub>h\"\n  shows \"\\<delta>\\<^sub>h = \\<epsilon>\\<^sub>h\"", "lemma wt_ge_vars: \"wt t \\<ge>\\<^sub>p wt s \\<Longrightarrow> vars t \\<supseteq> vars s\"", "lemma sum_coefs_ge_num_args_if_\\<delta>\\<^sub>h_eq_0:\n  assumes\n    legal: \"legal_passign A\" and\n    \\<delta>_eq_0: \"\\<delta>\\<^sub>h = 0\" and\n    wary_s: \"wary s\"\n  shows \"sum_coefs (eval_tpoly A (wt s)) \\<ge> num_args s\"", "lemma gt_iff_wt_unary_diff_same: \"t >\\<^sub>t s \\<longleftrightarrow> gt_wt t s \\<or> gt_unary t s \\<or> gt_diff t s \\<or> gt_same t s\"", "lemma gt_imp_wt: \"t >\\<^sub>t s \\<Longrightarrow> wt t \\<ge>\\<^sub>p wt s\"", "lemma gt_imp_vars: \"t >\\<^sub>t s \\<Longrightarrow> vars t \\<supseteq> vars s\"", "theorem gt_irrefl: \"wary s \\<Longrightarrow> \\<not> s >\\<^sub>t s\"", "lemma not_extf_gt_nil_singleton_if_\\<delta>\\<^sub>h_eq_\\<epsilon>\\<^sub>h:\n  assumes wary_s: \"wary s\" and \\<delta>_eq_\\<epsilon>: \"\\<delta>\\<^sub>h = \\<epsilon>\\<^sub>h\"\n  shows \"\\<not> extf f (>\\<^sub>t) [] [s]\"", "lemma gt_sub_arg: \"wary (App s t) \\<Longrightarrow> App s t >\\<^sub>t t\"", "lemma gt_arg: \"wary s \\<Longrightarrow> is_App s \\<Longrightarrow> s >\\<^sub>t arg s\"", "theorem gt_trans: \"wary u \\<Longrightarrow> wary t \\<Longrightarrow> wary s \\<Longrightarrow> u >\\<^sub>t t \\<Longrightarrow> t >\\<^sub>t s \\<Longrightarrow> u >\\<^sub>t s\"", "lemma gt_antisym: \"wary s \\<Longrightarrow> wary t \\<Longrightarrow> t >\\<^sub>t s \\<Longrightarrow> \\<not> s >\\<^sub>t t\"", "lemma gt_sub_fun: \"App s t >\\<^sub>t s\"", "theorem gt_proper_sub: \"wary t \\<Longrightarrow> proper_sub s t \\<Longrightarrow> t >\\<^sub>t s\"", "lemma gt_compat_fun:\n  assumes\n    wary_t: \"wary t\" and\n    t'_gt_t: \"t' >\\<^sub>t t\"\n  shows \"App s t' >\\<^sub>t App s t\"", "theorem gt_compat_fun_strong:\n  assumes\n    wary_t: \"wary t\" and\n    t'_gt_t: \"t' >\\<^sub>t t\"\n  shows \"apps s (t' # us) >\\<^sub>t apps s (t # us)\"", "theorem gt_compat_arg_weak:\n  assumes\n    wary_st: \"wary (App s t)\" and\n    wary_s't: \"wary (App s' t)\" and\n    coef_s'_0_ge_s: \"coef s' 0 \\<ge>\\<^sub>p coef s 0\" and\n    s'_gt_s: \"s' >\\<^sub>t s\"\n  shows \"App s' t >\\<^sub>t App s t\"", "lemma legal_subst_zpassign:\n  assumes\n    legal: \"legal_zpassign A\" and\n    wary_\\<rho>: \"wary_subst \\<rho>\"\n  shows \"legal_zpassign (subst_zpassign \\<rho> A)\"", "lemma wt_subst:\n  assumes\n    legal: \"legal_zpassign A\" and\n    wary_\\<rho>: \"wary_subst \\<rho>\"\n  shows \"wary s \\<Longrightarrow> eval_ztpoly A (wt (subst \\<rho> s)) = eval_ztpoly (subst_zpassign \\<rho> A) (wt s)\"", "theorem gt_subst:\n  assumes wary_\\<rho>: \"wary_subst \\<rho>\"\n  shows \"wary t \\<Longrightarrow> wary s \\<Longrightarrow> t >\\<^sub>t s \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\"", "lemma wt_total_ground:\n  assumes\n    gr_t: \"ground t\" and\n    gr_s: \"ground s\"\n  shows \"wt t >\\<^sub>p wt s \\<or> wt s >\\<^sub>p wt t \\<or> wt t =\\<^sub>p wt s\"", "theorem gt_total_ground:\n  assumes extf_total: \"\\<And>f. ext_total (extf f)\"\n  shows \"ground t \\<Longrightarrow> ground s \\<Longrightarrow> t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s\"", "lemma ground_gt_unary:\n  assumes gr_t: \"ground t\"\n  shows \"\\<not> gt_unary t s\"", "theorem gt_wf: \"wfP (\\<lambda>s t. t >\\<^sub>t\\<^sub>w s)\""], "translations": [["", "lemma arity\\<^sub>h_conv: \"arity\\<^sub>h s = arity_hd\\<^sub>h (head s) - of_nat (num_args s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arity\\<^sub>h s = arity_hd\\<^sub>h (head s) - of_nat (num_args s)", "unfolding arity_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hmset_of_enat (arity_hd (head s) - enat (num_args s)) =\n    arity_hd\\<^sub>h (head s) - of_nat (num_args s)", "by simp"], ["", "lemma arity\\<^sub>h_App[simp]: \"arity\\<^sub>h (App s t) = arity\\<^sub>h s - 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arity\\<^sub>h (App s t) = arity\\<^sub>h s - 1", "by (simp add: one_enat_def)"], ["", "lemmas wary_App\\<^sub>h[intro] = wary_App[folded of_nat_lt_hmset_of_enat_iff]"], ["", "lemmas wary_AppE\\<^sub>h = wary_AppE[folded of_nat_lt_hmset_of_enat_iff]"], ["", "lemmas wary_num_args_le_arity_head\\<^sub>h =\n  wary_num_args_le_arity_head[folded of_nat_le_hmset_of_enat_iff]"], ["", "lemmas wary_apps\\<^sub>h = wary_apps[folded of_nat_le_hmset_of_enat_iff]"], ["", "lemmas wary_cases_apps\\<^sub>h[consumes 1, case_names apps] =\n  wary_cases_apps[folded of_nat_le_hmset_of_enat_iff]"], ["", "lemmas ground_heads_arity\\<^sub>h = ground_heads_arity[folded hmset_of_enat_le]"], ["", "lemmas some_ground_head_arity\\<^sub>h = some_ground_head_arity[folded hmset_of_enat_le]"], ["", "lemmas \\<epsilon>\\<^sub>h_gt_0 = \\<epsilon>_gt_0[folded of_nat_less_hmset, unfolded of_nat_0]"], ["", "lemmas \\<delta>\\<^sub>h_le_\\<epsilon>\\<^sub>h = \\<delta>_le_\\<epsilon>[folded of_nat_le_hmset]"], ["", "lemmas arity_hd\\<^sub>h_lt_\\<omega>_if_\\<delta>\\<^sub>h_gt_0 = arity_hd_ne_infinity_if_\\<delta>_gt_0\n  [folded of_nat_less_hmset, unfolded of_nat_0, folded hmset_of_enat_lt_iff_ne_infinity]"], ["", "lemma wt_sym_ge\\<^sub>h: \"wt_sym f \\<ge> \\<epsilon>\\<^sub>h - \\<delta>\\<^sub>h * arity_sym\\<^sub>h f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<epsilon>\\<^sub>h - \\<delta>\\<^sub>h * arity_sym\\<^sub>h f\n    \\<le> wt_sym f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<epsilon>\\<^sub>h - \\<delta>\\<^sub>h * arity_sym\\<^sub>h f\n    \\<le> wt_sym f", "have \"of_nat (the_enat (of_nat \\<delta> * arity_sym f)) = \\<delta>\\<^sub>h * arity_sym\\<^sub>h f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (the_enat (of_nat \\<delta> * arity_sym f)) =\n    \\<delta>\\<^sub>h * arity_sym\\<^sub>h f", "by (cases \"arity_sym f\", simp add: of_nat_eq_enat,\n    metis arity_sym_ne_infinity_if_\\<delta>_gt_0 gr_zeroI mult_eq_0_iff of_nat_0 the_enat_0)"], ["proof (state)\nthis:\n  of_nat (the_enat (of_nat \\<delta> * arity_sym f)) =\n  \\<delta>\\<^sub>h * arity_sym\\<^sub>h f\n\ngoal (1 subgoal):\n 1. \\<epsilon>\\<^sub>h - \\<delta>\\<^sub>h * arity_sym\\<^sub>h f\n    \\<le> wt_sym f", "thus ?thesis"], ["proof (prove)\nusing this:\n  of_nat (the_enat (of_nat \\<delta> * arity_sym f)) =\n  \\<delta>\\<^sub>h * arity_sym\\<^sub>h f\n\ngoal (1 subgoal):\n 1. \\<epsilon>\\<^sub>h - \\<delta>\\<^sub>h * arity_sym\\<^sub>h f\n    \\<le> wt_sym f", "using wt_sym_ge[unfolded of_nat_minus_hmset]"], ["proof (prove)\nusing this:\n  of_nat (the_enat (of_nat \\<delta> * arity_sym f)) =\n  \\<delta>\\<^sub>h * arity_sym\\<^sub>h f\n  \\<epsilon>\\<^sub>h - of_nat (the_enat (of_nat \\<delta> * arity_sym ?f))\n  \\<le> wt_sym ?f\n\ngoal (1 subgoal):\n 1. \\<epsilon>\\<^sub>h - \\<delta>\\<^sub>h * arity_sym\\<^sub>h f\n    \\<le> wt_sym f", "by metis"], ["proof (state)\nthis:\n  \\<epsilon>\\<^sub>h - \\<delta>\\<^sub>h * arity_sym\\<^sub>h f \\<le> wt_sym f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemmas unary_wt_sym_0_gt\\<^sub>h = unary_wt_sym_0_gt[folded hmset_of_enat_inject, unfolded hmset_of_enat_1]"], ["", "lemmas unary_wt_sym_0_imp_\\<delta>\\<^sub>h_eq_\\<epsilon>\\<^sub>h = unary_wt_sym_0_imp_\\<delta>_eq_\\<epsilon>\n  [folded of_nat_inject_hmset, unfolded of_nat_0]"], ["", "lemmas extf_ext_snoc_if_\\<delta>\\<^sub>h_eq_\\<epsilon>\\<^sub>h = extf_ext_snoc_if_\\<delta>_eq_\\<epsilon>[folded of_nat_inject_hmset]"], ["", "lemmas extf_snoc_if_\\<delta>\\<^sub>h_eq_\\<epsilon>\\<^sub>h = ext_snoc.snoc[OF extf_ext_snoc_if_\\<delta>\\<^sub>h_eq_\\<epsilon>\\<^sub>h]"], ["", "lemmas arity_sym\\<^sub>h_lt_\\<omega>_if_\\<delta>\\<^sub>h_gt_0 = arity_sym_ne_infinity_if_\\<delta>_gt_0\n  [folded of_nat_less_hmset hmset_of_enat_lt_iff_ne_infinity, unfolded of_nat_0]"], ["", "lemmas arity_var\\<^sub>h_lt_\\<omega>_if_\\<delta>\\<^sub>h_gt_0 = arity_var_ne_infinity_if_\\<delta>_gt_0\n  [folded of_nat_less_hmset hmset_of_enat_lt_iff_ne_infinity, unfolded of_nat_0]"], ["", "lemmas arity\\<^sub>h_lt_\\<omega>_if_\\<delta>\\<^sub>h_gt_0 = arity_ne_infinity_if_\\<delta>_gt_0\n  [folded of_nat_less_hmset hmset_of_enat_lt_iff_ne_infinity, unfolded of_nat_0]"], ["", "lemmas warywary_subst_subst\\<^sub>h_conv = wary_subst_def[folded hmset_of_enat_le]"], ["", "lemmas extf_singleton_nil_if_\\<delta>\\<^sub>h_eq_\\<epsilon>\\<^sub>h = extf_singleton_nil_if_\\<delta>_eq_\\<epsilon>[folded of_nat_inject_hmset]"], ["", "lemma arity_sym\\<^sub>h_if_\\<delta>\\<^sub>h_gt_0_E:\n  assumes \\<delta>_gt_0: \"\\<delta>\\<^sub>h > 0\"\n  obtains n where \"arity_sym\\<^sub>h f = of_nat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        arity_sym\\<^sub>h f = of_nat n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using arity_sym\\<^sub>h_lt_\\<omega>_if_\\<delta>\\<^sub>h_gt_0 assms lt_\\<omega>_imp_ex_of_nat"], ["proof (prove)\nusing this:\n  0 < \\<delta>\\<^sub>h \\<Longrightarrow> arity_sym\\<^sub>h ?f < \\<omega>\n  0 < \\<delta>\\<^sub>h\n  ?M < \\<omega> \\<Longrightarrow> \\<exists>n. ?M = of_nat n\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        arity_sym\\<^sub>h f = of_nat n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["", "lemma arity_var\\<^sub>h_if_\\<delta>\\<^sub>h_gt_0_E:\n  assumes \\<delta>_gt_0: \"\\<delta>\\<^sub>h > 0\"\n  obtains n where \"arity_var\\<^sub>h f = of_nat n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        arity_var\\<^sub>h f = of_nat n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using arity_var\\<^sub>h_lt_\\<omega>_if_\\<delta>\\<^sub>h_gt_0 assms lt_\\<omega>_imp_ex_of_nat"], ["proof (prove)\nusing this:\n  0 < \\<delta>\\<^sub>h \\<Longrightarrow> arity_var\\<^sub>h ?x < \\<omega>\n  0 < \\<delta>\\<^sub>h\n  ?M < \\<omega> \\<Longrightarrow> \\<exists>n. ?M = of_nat n\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        arity_var\\<^sub>h f = of_nat n \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["", "subsection \\<open>Weights and Subterm Coefficients\\<close>"], ["", "abbreviation zhmset_of_tpoly :: \"('a, hmultiset) tpoly \\<Rightarrow> ('a, zhmultiset) tpoly\" where\n  \"zhmset_of_tpoly \\<equiv> map_tpoly (\\<lambda>x. x) zhmset_of\""], ["", "abbreviation eval_ztpoly :: \"('a \\<Rightarrow> zhmultiset) \\<Rightarrow> ('a, hmultiset) tpoly \\<Rightarrow> zhmultiset\" where\n  \"eval_ztpoly A p \\<equiv> eval_tpoly A (zhmset_of_tpoly p)\""], ["", "lemma eval_tpoly_eq_eval_ztpoly[simp]:\n  \"zhmset_of (eval_tpoly A p) = eval_ztpoly (\\<lambda>v. zhmset_of (A v)) p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zhmset_of (eval_tpoly A p) =\n    eval_tpoly (\\<lambda>v. zhmset_of (A v))\n     (map_tpoly (\\<lambda>x. x) zhmset_of p)", "by (induct p, simp_all add: zhmset_of_sum_list zhmset_of_prod_list o_def,\n    simp_all cong: map_cong)"], ["", "definition min_ground_head :: \"('s, 'v) hd \\<Rightarrow> 's\" where\n  \"min_ground_head \\<zeta> =\n   (SOME f. f \\<in> ground_heads \\<zeta> \\<and>\n      (\\<forall>g \\<in> ground_heads \\<zeta>. wt_sym g + \\<delta>\\<^sub>h * arity_sym\\<^sub>h g \\<ge> wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f))\""], ["", "datatype 'va pvar =\n  PWt 'va\n| PCoef 'va nat"], ["", "primrec min_passign :: \"'v pvar \\<Rightarrow> hmultiset\" where\n  \"min_passign (PWt x) = wt_sym (min_ground_head (Var x))\"\n| \"min_passign (PCoef _ _) = 1\""], ["", "abbreviation min_zpassign :: \"'v pvar \\<Rightarrow> zhmultiset\" where\n  \"min_zpassign v \\<equiv> zhmset_of (min_passign v)\""], ["", "lemma min_zpassign_simps[simp]:\n  \"min_zpassign (PWt x) = zhmset_of (wt_sym (min_ground_head (Var x)))\"\n  \"min_zpassign (PCoef x i) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zhmset_of (min_passign (PWt x)) =\n    zhmset_of (wt_sym (min_ground_head (Var x))) &&&\n    zhmset_of (min_passign (PCoef x i)) = 1", "by (simp_all add: zhmset_of_1)"], ["", "definition legal_passign :: \"('v pvar \\<Rightarrow> hmultiset) \\<Rightarrow> bool\" where\n  \"legal_passign A \\<longleftrightarrow> (\\<forall>x. A x \\<ge> min_passign x)\""], ["", "definition legal_zpassign :: \"('v pvar \\<Rightarrow> zhmultiset) \\<Rightarrow> bool\" where\n  \"legal_zpassign A \\<longleftrightarrow> (\\<forall>x. A x \\<ge> min_zpassign x)\""], ["", "lemma legal_min_passign: \"legal_passign min_passign\""], ["proof (prove)\ngoal (1 subgoal):\n 1. legal_passign min_passign", "unfolding legal_passign_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. min_passign x \\<le> min_passign x", "by simp"], ["", "lemma legal_min_zpassign: \"legal_zpassign min_zpassign\""], ["proof (prove)\ngoal (1 subgoal):\n 1. legal_zpassign (\\<lambda>v. zhmset_of (min_passign v))", "unfolding legal_zpassign_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. zhmset_of (min_passign x) \\<le> zhmset_of (min_passign x)", "by simp"], ["", "lemma assign_ge_0[intro]: \"legal_zpassign A \\<Longrightarrow> A x \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. legal_zpassign A \\<Longrightarrow> 0 \\<le> A x", "unfolding legal_zpassign_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. zhmset_of (min_passign x) \\<le> A x \\<Longrightarrow>\n    0 \\<le> A x", "by (auto intro: dual_order.trans)"], ["", "definition\n  eq_tpoly :: \"('v pvar, hmultiset) tpoly \\<Rightarrow> ('v pvar, hmultiset) tpoly \\<Rightarrow> bool\" (infix \"=\\<^sub>p\" 50)\nwhere\n  \"q =\\<^sub>p p \\<longleftrightarrow> (\\<forall>A. legal_zpassign A \\<longrightarrow> eval_ztpoly A q = eval_ztpoly A p)\""], ["", "definition\n  ge_tpoly :: \"('v pvar, hmultiset) tpoly \\<Rightarrow> ('v pvar, hmultiset) tpoly \\<Rightarrow> bool\" (infix \"\\<ge>\\<^sub>p\" 50)\nwhere\n  \"q \\<ge>\\<^sub>p p \\<longleftrightarrow> (\\<forall>A. legal_zpassign A \\<longrightarrow> eval_ztpoly A q \\<ge> eval_ztpoly A p)\""], ["", "definition\n  gt_tpoly :: \"('v pvar, hmultiset) tpoly \\<Rightarrow> ('v pvar, hmultiset) tpoly \\<Rightarrow> bool\" (infix \">\\<^sub>p\" 50)\nwhere\n  \"q >\\<^sub>p p \\<longleftrightarrow> (\\<forall>A. legal_zpassign A \\<longrightarrow> eval_ztpoly A q > eval_ztpoly A p)\""], ["", "lemma gt_tpoly_imp_ge[intro]: \"q >\\<^sub>p p \\<Longrightarrow> q \\<ge>\\<^sub>p p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. q >\\<^sub>p p \\<Longrightarrow> q \\<ge>\\<^sub>p p", "unfolding ge_tpoly_def gt_tpoly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A.\n       legal_zpassign A \\<longrightarrow>\n       eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of p)\n       < eval_tpoly A\n          (map_tpoly (\\<lambda>x. x) zhmset_of q) \\<Longrightarrow>\n    \\<forall>A.\n       legal_zpassign A \\<longrightarrow>\n       eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of p)\n       \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of q)", "by (simp add: le_less)"], ["", "lemma eq_tpoly_refl[simp]: \"p =\\<^sub>p p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p =\\<^sub>p p", "unfolding eq_tpoly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A.\n       legal_zpassign A \\<longrightarrow>\n       eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of p) =\n       eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of p)", "by simp"], ["", "lemma ge_tpoly_refl[simp]: \"p \\<ge>\\<^sub>p p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p \\<ge>\\<^sub>p p", "unfolding ge_tpoly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A.\n       legal_zpassign A \\<longrightarrow>\n       eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of p)\n       \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of p)", "by simp"], ["", "lemma gt_tpoly_irrefl: \"\\<not> p >\\<^sub>p p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> p >\\<^sub>p p", "unfolding gt_tpoly_def legal_zpassign_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>A.\n               (\\<forall>x.\n                   zhmset_of (min_passign x) \\<le> A x) \\<longrightarrow>\n               eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of p)\n               < eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of p))", "by fast"], ["", "lemma\n  eq_eq_tpoly_trans: \"r =\\<^sub>p q \\<Longrightarrow> q =\\<^sub>p p \\<Longrightarrow> r =\\<^sub>p p\" and\n  eq_ge_tpoly_trans: \"r =\\<^sub>p q \\<Longrightarrow> q \\<ge>\\<^sub>p p \\<Longrightarrow> r \\<ge>\\<^sub>p p\" and\n  eq_gt_tpoly_trans: \"r =\\<^sub>p q \\<Longrightarrow> q >\\<^sub>p p \\<Longrightarrow> r >\\<^sub>p p\" and\n  ge_eq_tpoly_trans: \"r \\<ge>\\<^sub>p q \\<Longrightarrow> q =\\<^sub>p p \\<Longrightarrow> r \\<ge>\\<^sub>p p\" and\n  ge_ge_tpoly_trans: \"r \\<ge>\\<^sub>p q \\<Longrightarrow> q \\<ge>\\<^sub>p p \\<Longrightarrow> r \\<ge>\\<^sub>p p\" and\n  ge_gt_tpoly_trans: \"r \\<ge>\\<^sub>p q \\<Longrightarrow> q >\\<^sub>p p \\<Longrightarrow> r >\\<^sub>p p\" and\n  gt_eq_tpoly_trans: \"r >\\<^sub>p q \\<Longrightarrow> q =\\<^sub>p p \\<Longrightarrow> r >\\<^sub>p p\" and\n  gt_ge_tpoly_trans: \"r >\\<^sub>p q \\<Longrightarrow> q \\<ge>\\<^sub>p p \\<Longrightarrow> r >\\<^sub>p p\" and\n  gt_gt_tpoly_trans: \"r >\\<^sub>p q \\<Longrightarrow> q >\\<^sub>p p \\<Longrightarrow> r >\\<^sub>p p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (((\\<lbrakk>r =\\<^sub>p q; q =\\<^sub>p p\\<rbrakk>\n       \\<Longrightarrow> r =\\<^sub>p p) &&&\n      (\\<lbrakk>r =\\<^sub>p q; q \\<ge>\\<^sub>p p\\<rbrakk>\n       \\<Longrightarrow> r \\<ge>\\<^sub>p p)) &&&\n     (\\<lbrakk>r =\\<^sub>p q; q >\\<^sub>p p\\<rbrakk>\n      \\<Longrightarrow> r >\\<^sub>p p) &&&\n     (\\<lbrakk>r \\<ge>\\<^sub>p q; q =\\<^sub>p p\\<rbrakk>\n      \\<Longrightarrow> r \\<ge>\\<^sub>p p)) &&&\n    ((\\<lbrakk>r \\<ge>\\<^sub>p q; q \\<ge>\\<^sub>p p\\<rbrakk>\n      \\<Longrightarrow> r \\<ge>\\<^sub>p p) &&&\n     (\\<lbrakk>r \\<ge>\\<^sub>p q; q >\\<^sub>p p\\<rbrakk>\n      \\<Longrightarrow> r >\\<^sub>p p)) &&&\n    (\\<lbrakk>r >\\<^sub>p q; q =\\<^sub>p p\\<rbrakk>\n     \\<Longrightarrow> r >\\<^sub>p p) &&&\n    (\\<lbrakk>r >\\<^sub>p q; q \\<ge>\\<^sub>p p\\<rbrakk>\n     \\<Longrightarrow> r >\\<^sub>p p) &&&\n    (\\<lbrakk>r >\\<^sub>p q; q >\\<^sub>p p\\<rbrakk>\n     \\<Longrightarrow> r >\\<^sub>p p)", "unfolding eq_tpoly_def ge_tpoly_def gt_tpoly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (((\\<lbrakk>\\<forall>A.\n                   legal_zpassign A \\<longrightarrow>\n                   eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of r) =\n                   eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of q);\n        \\<forall>A.\n           legal_zpassign A \\<longrightarrow>\n           eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of q) =\n           eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of p)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>A.\n                            legal_zpassign A \\<longrightarrow>\n                            eval_tpoly A\n                             (map_tpoly (\\<lambda>x. x) zhmset_of r) =\n                            eval_tpoly A\n                             (map_tpoly (\\<lambda>x. x) zhmset_of p)) &&&\n      (\\<lbrakk>\\<forall>A.\n                   legal_zpassign A \\<longrightarrow>\n                   eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of r) =\n                   eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of q);\n        \\<forall>A.\n           legal_zpassign A \\<longrightarrow>\n           eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of p)\n           \\<le> eval_tpoly A\n                  (map_tpoly (\\<lambda>x. x) zhmset_of q)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>A.\n                            legal_zpassign A \\<longrightarrow>\n                            eval_tpoly A\n                             (map_tpoly (\\<lambda>x. x) zhmset_of p)\n                            \\<le> eval_tpoly A\n                                   (map_tpoly (\\<lambda>x. x) zhmset_of\n                                     r))) &&&\n     (\\<lbrakk>\\<forall>A.\n                  legal_zpassign A \\<longrightarrow>\n                  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of r) =\n                  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of q);\n       \\<forall>A.\n          legal_zpassign A \\<longrightarrow>\n          eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of p)\n          < eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of q)\\<rbrakk>\n      \\<Longrightarrow> \\<forall>A.\n                           legal_zpassign A \\<longrightarrow>\n                           eval_tpoly A\n                            (map_tpoly (\\<lambda>x. x) zhmset_of p)\n                           < eval_tpoly A\n                              (map_tpoly (\\<lambda>x. x) zhmset_of r)) &&&\n     (\\<lbrakk>\\<forall>A.\n                  legal_zpassign A \\<longrightarrow>\n                  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of q)\n                  \\<le> eval_tpoly A\n                         (map_tpoly (\\<lambda>x. x) zhmset_of r);\n       \\<forall>A.\n          legal_zpassign A \\<longrightarrow>\n          eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of q) =\n          eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of p)\\<rbrakk>\n      \\<Longrightarrow> \\<forall>A.\n                           legal_zpassign A \\<longrightarrow>\n                           eval_tpoly A\n                            (map_tpoly (\\<lambda>x. x) zhmset_of p)\n                           \\<le> eval_tpoly A\n                                  (map_tpoly (\\<lambda>x. x) zhmset_of\n                                    r))) &&&\n    ((\\<lbrakk>\\<forall>A.\n                  legal_zpassign A \\<longrightarrow>\n                  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of q)\n                  \\<le> eval_tpoly A\n                         (map_tpoly (\\<lambda>x. x) zhmset_of r);\n       \\<forall>A.\n          legal_zpassign A \\<longrightarrow>\n          eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of p)\n          \\<le> eval_tpoly A\n                 (map_tpoly (\\<lambda>x. x) zhmset_of q)\\<rbrakk>\n      \\<Longrightarrow> \\<forall>A.\n                           legal_zpassign A \\<longrightarrow>\n                           eval_tpoly A\n                            (map_tpoly (\\<lambda>x. x) zhmset_of p)\n                           \\<le> eval_tpoly A\n                                  (map_tpoly (\\<lambda>x. x) zhmset_of\n                                    r)) &&&\n     (\\<lbrakk>\\<forall>A.\n                  legal_zpassign A \\<longrightarrow>\n                  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of q)\n                  \\<le> eval_tpoly A\n                         (map_tpoly (\\<lambda>x. x) zhmset_of r);\n       \\<forall>A.\n          legal_zpassign A \\<longrightarrow>\n          eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of p)\n          < eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of q)\\<rbrakk>\n      \\<Longrightarrow> \\<forall>A.\n                           legal_zpassign A \\<longrightarrow>\n                           eval_tpoly A\n                            (map_tpoly (\\<lambda>x. x) zhmset_of p)\n                           < eval_tpoly A\n                              (map_tpoly (\\<lambda>x. x) zhmset_of r))) &&&\n    (\\<lbrakk>\\<forall>A.\n                 legal_zpassign A \\<longrightarrow>\n                 eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of q)\n                 < eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of r);\n      \\<forall>A.\n         legal_zpassign A \\<longrightarrow>\n         eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of q) =\n         eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of p)\\<rbrakk>\n     \\<Longrightarrow> \\<forall>A.\n                          legal_zpassign A \\<longrightarrow>\n                          eval_tpoly A\n                           (map_tpoly (\\<lambda>x. x) zhmset_of p)\n                          < eval_tpoly A\n                             (map_tpoly (\\<lambda>x. x) zhmset_of r)) &&&\n    (\\<lbrakk>\\<forall>A.\n                 legal_zpassign A \\<longrightarrow>\n                 eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of q)\n                 < eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of r);\n      \\<forall>A.\n         legal_zpassign A \\<longrightarrow>\n         eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of p)\n         \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of q)\\<rbrakk>\n     \\<Longrightarrow> \\<forall>A.\n                          legal_zpassign A \\<longrightarrow>\n                          eval_tpoly A\n                           (map_tpoly (\\<lambda>x. x) zhmset_of p)\n                          < eval_tpoly A\n                             (map_tpoly (\\<lambda>x. x) zhmset_of r)) &&&\n    (\\<lbrakk>\\<forall>A.\n                 legal_zpassign A \\<longrightarrow>\n                 eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of q)\n                 < eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of r);\n      \\<forall>A.\n         legal_zpassign A \\<longrightarrow>\n         eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of p)\n         < eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of q)\\<rbrakk>\n     \\<Longrightarrow> \\<forall>A.\n                          legal_zpassign A \\<longrightarrow>\n                          eval_tpoly A\n                           (map_tpoly (\\<lambda>x. x) zhmset_of p)\n                          < eval_tpoly A\n                             (map_tpoly (\\<lambda>x. x) zhmset_of r))", "by (auto intro: order.trans less_trans less_le_trans le_less_trans)+"], ["", "primrec coef_hd :: \"('s, 'v) hd \\<Rightarrow> nat \\<Rightarrow> ('v pvar, hmultiset) tpoly\" where\n  \"coef_hd (Var x) i = PVar (PCoef x i)\"\n| \"coef_hd (Sym f) i = PNum (coef_sym f i)\""], ["", "lemma coef_hd_gt_0:\n  assumes legal: \"legal_zpassign A\"\n  shows \"eval_ztpoly A (coef_hd \\<zeta> i) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < eval_tpoly A\n         (map_tpoly (\\<lambda>x. x) zhmset_of (coef_hd \\<zeta> i))", "unfolding legal_zpassign_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < eval_tpoly A\n         (map_tpoly (\\<lambda>x. x) zhmset_of (coef_hd \\<zeta> i))", "proof (cases \\<zeta>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<zeta> = Var x1 \\<Longrightarrow>\n       0 < eval_tpoly A\n            (map_tpoly (\\<lambda>x. x) zhmset_of (coef_hd \\<zeta> i))\n 2. \\<And>x2.\n       \\<zeta> = Sym x2 \\<Longrightarrow>\n       0 < eval_tpoly A\n            (map_tpoly (\\<lambda>x. x) zhmset_of (coef_hd \\<zeta> i))", "case (Var x1)"], ["proof (state)\nthis:\n  \\<zeta> = Var x1\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<zeta> = Var x1 \\<Longrightarrow>\n       0 < eval_tpoly A\n            (map_tpoly (\\<lambda>x. x) zhmset_of (coef_hd \\<zeta> i))\n 2. \\<And>x2.\n       \\<zeta> = Sym x2 \\<Longrightarrow>\n       0 < eval_tpoly A\n            (map_tpoly (\\<lambda>x. x) zhmset_of (coef_hd \\<zeta> i))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<zeta> = Var x1\n\ngoal (1 subgoal):\n 1. 0 < eval_tpoly A\n         (map_tpoly (\\<lambda>x. x) zhmset_of (coef_hd \\<zeta> i))", "using legal[unfolded legal_zpassign_def, rule_format, of \"PCoef x i\" for x]"], ["proof (prove)\nusing this:\n  \\<zeta> = Var x1\n  zhmset_of (min_passign (PCoef ?x2 i)) \\<le> A (PCoef ?x2 i)\n\ngoal (1 subgoal):\n 1. 0 < eval_tpoly A\n         (map_tpoly (\\<lambda>x. x) zhmset_of (coef_hd \\<zeta> i))", "by (auto simp: coef_sym_gt_0 zhmset_of_1 intro: dual_order.strict_trans1 zero_less_one)"], ["proof (state)\nthis:\n  0 < eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef_hd \\<zeta> i))\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<zeta> = Sym x2 \\<Longrightarrow>\n       0 < eval_tpoly A\n            (map_tpoly (\\<lambda>x. x) zhmset_of (coef_hd \\<zeta> i))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<zeta> = Sym x2 \\<Longrightarrow>\n       0 < eval_tpoly A\n            (map_tpoly (\\<lambda>x. x) zhmset_of (coef_hd \\<zeta> i))", "case (Sym x2)"], ["proof (state)\nthis:\n  \\<zeta> = Sym x2\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<zeta> = Sym x2 \\<Longrightarrow>\n       0 < eval_tpoly A\n            (map_tpoly (\\<lambda>x. x) zhmset_of (coef_hd \\<zeta> i))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<zeta> = Sym x2\n\ngoal (1 subgoal):\n 1. 0 < eval_tpoly A\n         (map_tpoly (\\<lambda>x. x) zhmset_of (coef_hd \\<zeta> i))", "using legal[unfolded legal_zpassign_def, rule_format, of \"PWt x\" for x]"], ["proof (prove)\nusing this:\n  \\<zeta> = Sym x2\n  zhmset_of (min_passign (PWt ?x2)) \\<le> A (PWt ?x2)\n\ngoal (1 subgoal):\n 1. 0 < eval_tpoly A\n         (map_tpoly (\\<lambda>x. x) zhmset_of (coef_hd \\<zeta> i))", "by simp (metis coef_sym_gt_0 zhmset_of_0 zhmset_of_less)"], ["proof (state)\nthis:\n  0 < eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef_hd \\<zeta> i))\n\ngoal:\nNo subgoals!", "qed"], ["", "primrec coef :: \"('s, 'v) tm \\<Rightarrow> nat \\<Rightarrow> ('v pvar, hmultiset) tpoly\" where\n  \"coef (Hd \\<zeta>) i = coef_hd \\<zeta> i\"\n| \"coef (App s _) i = coef s (i + 1)\""], ["", "lemma coef_apps[simp]: \"coef (apps s ss) i = coef s (i + length ss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coef (apps s ss) i = coef s (i + length ss)", "by (induct ss arbitrary: s i) auto"], ["", "lemma coef_gt_0: \"legal_zpassign A \\<Longrightarrow> eval_ztpoly A (coef s i) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. legal_zpassign A \\<Longrightarrow>\n    0 < eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s i))", "by (induct s arbitrary: i) (auto intro: coef_hd_gt_0)"], ["", "lemma exists_min_ground_head:\n  \"\\<exists>f. f \\<in> ground_heads \\<zeta> \\<and>\n     (\\<forall>g \\<in> ground_heads \\<zeta>. wt_sym g + \\<delta>\\<^sub>h * arity_sym\\<^sub>h g \\<ge> wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       f \\<in> local.ground_heads \\<zeta> \\<and>\n       (\\<forall>g\\<in>local.ground_heads \\<zeta>.\n           wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f\n           \\<le> wt_sym g + \\<delta>\\<^sub>h * arity_sym\\<^sub>h g)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       f \\<in> local.ground_heads \\<zeta> \\<and>\n       (\\<forall>g\\<in>local.ground_heads \\<zeta>.\n           wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f\n           \\<le> wt_sym g + \\<delta>\\<^sub>h * arity_sym\\<^sub>h g)", "let ?R = \"{(f, g). f \\<in> ground_heads \\<zeta> \\<and> g \\<in> ground_heads \\<zeta> \\<and>\n    wt_sym g + \\<delta>\\<^sub>h * arity_sym\\<^sub>h g > wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       f \\<in> local.ground_heads \\<zeta> \\<and>\n       (\\<forall>g\\<in>local.ground_heads \\<zeta>.\n           wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f\n           \\<le> wt_sym g + \\<delta>\\<^sub>h * arity_sym\\<^sub>h g)", "have wf_R: \"wf ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf {(f, g).\n        f \\<in> local.ground_heads \\<zeta> \\<and>\n        g \\<in> local.ground_heads \\<zeta> \\<and>\n        wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f\n        < wt_sym g + \\<delta>\\<^sub>h * arity_sym\\<^sub>h g}", "using wf_app[of \"{(M, N). M < N}\" \"\\<lambda>f. wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f\", OF wf]"], ["proof (prove)\nusing this:\n  wf {(x, y).\n      (wt_sym x + \\<delta>\\<^sub>h * arity_sym\\<^sub>h x,\n       wt_sym y + \\<delta>\\<^sub>h * arity_sym\\<^sub>h y)\n      \\<in> {(M, N). M < N}}\n\ngoal (1 subgoal):\n 1. wf {(f, g).\n        f \\<in> local.ground_heads \\<zeta> \\<and>\n        g \\<in> local.ground_heads \\<zeta> \\<and>\n        wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f\n        < wt_sym g + \\<delta>\\<^sub>h * arity_sym\\<^sub>h g}", "by (auto intro: wf_subset)"], ["proof (state)\nthis:\n  wf {(f, g).\n      f \\<in> local.ground_heads \\<zeta> \\<and>\n      g \\<in> local.ground_heads \\<zeta> \\<and>\n      wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f\n      < wt_sym g + \\<delta>\\<^sub>h * arity_sym\\<^sub>h g}\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       f \\<in> local.ground_heads \\<zeta> \\<and>\n       (\\<forall>g\\<in>local.ground_heads \\<zeta>.\n           wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f\n           \\<le> wt_sym g + \\<delta>\\<^sub>h * arity_sym\\<^sub>h g)", "have \"\\<exists>f. f \\<in> ground_heads \\<zeta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f. f \\<in> local.ground_heads \\<zeta>", "by (meson ground_heads_nonempty subsetI subset_empty)"], ["proof (state)\nthis:\n  \\<exists>f. f \\<in> local.ground_heads \\<zeta>\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       f \\<in> local.ground_heads \\<zeta> \\<and>\n       (\\<forall>g\\<in>local.ground_heads \\<zeta>.\n           wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f\n           \\<le> wt_sym g + \\<delta>\\<^sub>h * arity_sym\\<^sub>h g)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>f. f \\<in> local.ground_heads \\<zeta>\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       f \\<in> local.ground_heads \\<zeta> \\<and>\n       (\\<forall>g\\<in>local.ground_heads \\<zeta>.\n           wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f\n           \\<le> wt_sym g + \\<delta>\\<^sub>h * arity_sym\\<^sub>h g)", "using wf_eq_minimal[THEN iffD1, OF wf_R]"], ["proof (prove)\nusing this:\n  \\<exists>f. f \\<in> local.ground_heads \\<zeta>\n  \\<forall>Q x.\n     x \\<in> Q \\<longrightarrow>\n     (\\<exists>z\\<in>Q.\n         \\<forall>y.\n            (y, z)\n            \\<in> {(f, g).\n                   f \\<in> local.ground_heads \\<zeta> \\<and>\n                   g \\<in> local.ground_heads \\<zeta> \\<and>\n                   wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f\n                   < wt_sym g +\n                     \\<delta>\\<^sub>h *\n                     arity_sym\\<^sub>h g} \\<longrightarrow>\n            y \\<notin> Q)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       f \\<in> local.ground_heads \\<zeta> \\<and>\n       (\\<forall>g\\<in>local.ground_heads \\<zeta>.\n           wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f\n           \\<le> wt_sym g + \\<delta>\\<^sub>h * arity_sym\\<^sub>h g)", "by force"], ["proof (state)\nthis:\n  \\<exists>f.\n     f \\<in> local.ground_heads \\<zeta> \\<and>\n     (\\<forall>g\\<in>local.ground_heads \\<zeta>.\n         wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f\n         \\<le> wt_sym g + \\<delta>\\<^sub>h * arity_sym\\<^sub>h g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma min_ground_head_Sym[simp]: \"min_ground_head (Sym f) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_ground_head (Sym f) = f", "unfolding min_ground_head_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SOME fa.\n        fa \\<in> local.ground_heads (Sym f) \\<and>\n        (\\<forall>g\\<in>local.ground_heads (Sym f).\n            wt_sym fa + \\<delta>\\<^sub>h * arity_sym\\<^sub>h fa\n            \\<le> wt_sym g + \\<delta>\\<^sub>h * arity_sym\\<^sub>h g)) =\n    f", "by auto"], ["", "lemma min_ground_head_in_ground_heads: \"min_ground_head \\<zeta> \\<in> ground_heads \\<zeta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. min_ground_head \\<zeta> \\<in> local.ground_heads \\<zeta>", "unfolding min_ground_head_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (SOME f.\n        f \\<in> local.ground_heads \\<zeta> \\<and>\n        (\\<forall>g\\<in>local.ground_heads \\<zeta>.\n            wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f\n            \\<le> wt_sym g + \\<delta>\\<^sub>h * arity_sym\\<^sub>h g))\n    \\<in> local.ground_heads \\<zeta>", "using someI_ex[OF exists_min_ground_head]"], ["proof (prove)\nusing this:\n  (SOME x.\n      x \\<in> local.ground_heads ?\\<zeta>1 \\<and>\n      (\\<forall>g\\<in>local.ground_heads ?\\<zeta>1.\n          wt_sym x + \\<delta>\\<^sub>h * arity_sym\\<^sub>h x\n          \\<le> wt_sym g + \\<delta>\\<^sub>h * arity_sym\\<^sub>h g))\n  \\<in> local.ground_heads ?\\<zeta>1 \\<and>\n  (\\<forall>g\\<in>local.ground_heads ?\\<zeta>1.\n      wt_sym\n       (SOME x.\n           x \\<in> local.ground_heads ?\\<zeta>1 \\<and>\n           (\\<forall>g\\<in>local.ground_heads ?\\<zeta>1.\n               wt_sym x + \\<delta>\\<^sub>h * arity_sym\\<^sub>h x\n               \\<le> wt_sym g + \\<delta>\\<^sub>h * arity_sym\\<^sub>h g)) +\n      \\<delta>\\<^sub>h *\n      arity_sym\\<^sub>h\n       (SOME x.\n           x \\<in> local.ground_heads ?\\<zeta>1 \\<and>\n           (\\<forall>g\\<in>local.ground_heads ?\\<zeta>1.\n               wt_sym x + \\<delta>\\<^sub>h * arity_sym\\<^sub>h x\n               \\<le> wt_sym g + \\<delta>\\<^sub>h * arity_sym\\<^sub>h g))\n      \\<le> wt_sym g + \\<delta>\\<^sub>h * arity_sym\\<^sub>h g)\n\ngoal (1 subgoal):\n 1. (SOME f.\n        f \\<in> local.ground_heads \\<zeta> \\<and>\n        (\\<forall>g\\<in>local.ground_heads \\<zeta>.\n            wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f\n            \\<le> wt_sym g + \\<delta>\\<^sub>h * arity_sym\\<^sub>h g))\n    \\<in> local.ground_heads \\<zeta>", "by blast"], ["", "lemma min_ground_head_min:\n  \"f \\<in> ground_heads \\<zeta> \\<Longrightarrow>\n   wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f \\<ge> wt_sym (min_ground_head \\<zeta>) + \\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> local.ground_heads \\<zeta> \\<Longrightarrow>\n    wt_sym (min_ground_head \\<zeta>) +\n    \\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>)\n    \\<le> wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f", "unfolding min_ground_head_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> local.ground_heads \\<zeta> \\<Longrightarrow>\n    wt_sym\n     (SOME f.\n         f \\<in> local.ground_heads \\<zeta> \\<and>\n         (\\<forall>g\\<in>local.ground_heads \\<zeta>.\n             wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f\n             \\<le> wt_sym g + \\<delta>\\<^sub>h * arity_sym\\<^sub>h g)) +\n    \\<delta>\\<^sub>h *\n    arity_sym\\<^sub>h\n     (SOME f.\n         f \\<in> local.ground_heads \\<zeta> \\<and>\n         (\\<forall>g\\<in>local.ground_heads \\<zeta>.\n             wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f\n             \\<le> wt_sym g + \\<delta>\\<^sub>h * arity_sym\\<^sub>h g))\n    \\<le> wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f", "using someI_ex[OF exists_min_ground_head]"], ["proof (prove)\nusing this:\n  (SOME x.\n      x \\<in> local.ground_heads ?\\<zeta>1 \\<and>\n      (\\<forall>g\\<in>local.ground_heads ?\\<zeta>1.\n          wt_sym x + \\<delta>\\<^sub>h * arity_sym\\<^sub>h x\n          \\<le> wt_sym g + \\<delta>\\<^sub>h * arity_sym\\<^sub>h g))\n  \\<in> local.ground_heads ?\\<zeta>1 \\<and>\n  (\\<forall>g\\<in>local.ground_heads ?\\<zeta>1.\n      wt_sym\n       (SOME x.\n           x \\<in> local.ground_heads ?\\<zeta>1 \\<and>\n           (\\<forall>g\\<in>local.ground_heads ?\\<zeta>1.\n               wt_sym x + \\<delta>\\<^sub>h * arity_sym\\<^sub>h x\n               \\<le> wt_sym g + \\<delta>\\<^sub>h * arity_sym\\<^sub>h g)) +\n      \\<delta>\\<^sub>h *\n      arity_sym\\<^sub>h\n       (SOME x.\n           x \\<in> local.ground_heads ?\\<zeta>1 \\<and>\n           (\\<forall>g\\<in>local.ground_heads ?\\<zeta>1.\n               wt_sym x + \\<delta>\\<^sub>h * arity_sym\\<^sub>h x\n               \\<le> wt_sym g + \\<delta>\\<^sub>h * arity_sym\\<^sub>h g))\n      \\<le> wt_sym g + \\<delta>\\<^sub>h * arity_sym\\<^sub>h g)\n\ngoal (1 subgoal):\n 1. f \\<in> local.ground_heads \\<zeta> \\<Longrightarrow>\n    wt_sym\n     (SOME f.\n         f \\<in> local.ground_heads \\<zeta> \\<and>\n         (\\<forall>g\\<in>local.ground_heads \\<zeta>.\n             wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f\n             \\<le> wt_sym g + \\<delta>\\<^sub>h * arity_sym\\<^sub>h g)) +\n    \\<delta>\\<^sub>h *\n    arity_sym\\<^sub>h\n     (SOME f.\n         f \\<in> local.ground_heads \\<zeta> \\<and>\n         (\\<forall>g\\<in>local.ground_heads \\<zeta>.\n             wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f\n             \\<le> wt_sym g + \\<delta>\\<^sub>h * arity_sym\\<^sub>h g))\n    \\<le> wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f", "by blast"], ["", "lemma min_ground_head_antimono:\n  \"ground_heads \\<zeta> \\<subseteq> ground_heads \\<xi> \\<Longrightarrow>\n   wt_sym (min_ground_head \\<zeta>) + \\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>)\n   \\<ge> wt_sym (min_ground_head \\<xi>) + \\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<xi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.ground_heads \\<zeta>\n    \\<subseteq> local.ground_heads \\<xi> \\<Longrightarrow>\n    wt_sym (min_ground_head \\<xi>) +\n    \\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<xi>)\n    \\<le> wt_sym (min_ground_head \\<zeta>) +\n          \\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>)", "using min_ground_head_in_ground_heads min_ground_head_min"], ["proof (prove)\nusing this:\n  min_ground_head ?\\<zeta> \\<in> local.ground_heads ?\\<zeta>\n  ?f \\<in> local.ground_heads ?\\<zeta> \\<Longrightarrow>\n  wt_sym (min_ground_head ?\\<zeta>) +\n  \\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head ?\\<zeta>)\n  \\<le> wt_sym ?f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h ?f\n\ngoal (1 subgoal):\n 1. local.ground_heads \\<zeta>\n    \\<subseteq> local.ground_heads \\<xi> \\<Longrightarrow>\n    wt_sym (min_ground_head \\<xi>) +\n    \\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<xi>)\n    \\<le> wt_sym (min_ground_head \\<zeta>) +\n          \\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>)", "by blast"], ["", "primrec wt0 :: \"('s, 'v) hd \\<Rightarrow> ('v pvar, hmultiset) tpoly\" where\n  \"wt0 (Var x) = PVar (PWt x)\"\n| \"wt0 (Sym f) = PNum (wt_sym f)\""], ["", "lemma wt0_ge_min_ground_head:\n  \"legal_zpassign A \\<Longrightarrow> eval_ztpoly A (wt0 \\<zeta>) \\<ge> zhmset_of (wt_sym (min_ground_head \\<zeta>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. legal_zpassign A \\<Longrightarrow>\n    zhmset_of (wt_sym (min_ground_head \\<zeta>))\n    \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>))", "by (cases \\<zeta>, simp_all, metis legal_zpassign_def min_zpassign_simps(1))"], ["", "lemma eval_ztpoly_nonneg: \"legal_zpassign A \\<Longrightarrow> eval_ztpoly A p \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. legal_zpassign A \\<Longrightarrow>\n    0 \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of p)", "by (induct p) (auto cong: map_cong intro!: sum_list_nonneg prod_list_nonneg)"], ["", "lemma in_zip_imp_size_lt_apps: \"(s, y) \\<in> set (zip ss ys) \\<Longrightarrow> size s < size (apps (Hd \\<zeta>) ss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (s, y) \\<in> set (zip ss ys) \\<Longrightarrow>\n    size s < size (apps (Hd \\<zeta>) ss)", "by (auto dest!: set_zip_leftD simp: size_in_args)"], ["", "function wt :: \"('s, 'v) tm \\<Rightarrow> ('v pvar, hmultiset) tpoly\" where\n  \"wt (apps (Hd \\<zeta>) ss) =\n   PSum ([wt0 \\<zeta>, PNum (\\<delta>\\<^sub>h * (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss)))] @\n     map (\\<lambda>(s, i). PMult [coef_hd \\<zeta> i, wt s]) (zip ss [0..<length ss]))\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       (\\<And>\\<zeta> ss.\n           x = apps (Hd \\<zeta>) ss \\<Longrightarrow> P) \\<Longrightarrow>\n       P\n 2. \\<And>\\<zeta> ss \\<zeta>' ssa.\n       apps (Hd \\<zeta>) ss = apps (Hd \\<zeta>') ssa \\<Longrightarrow>\n       PSum\n        ([wt0 \\<zeta>,\n          PNum\n           (\\<delta>\\<^sub>h *\n            (arity_sym\\<^sub>h (min_ground_head \\<zeta>) -\n             of_nat (length ss)))] @\n         map2 (\\<lambda>s i. PMult [coef_hd \\<zeta> i, wt_sumC s]) ss\n          [0..<length ss]) =\n       PSum\n        ([wt0 \\<zeta>',\n          PNum\n           (\\<delta>\\<^sub>h *\n            (arity_sym\\<^sub>h (min_ground_head \\<zeta>') -\n             of_nat (length ssa)))] @\n         map2 (\\<lambda>s i. PMult [coef_hd \\<zeta>' i, wt_sumC s]) ssa\n          [0..<length ssa])", "by (erule tm_exhaust_apps) simp"], ["", "termination"], ["proof (prove)\ngoal (1 subgoal):\n 1. All wt_dom", "by (lexicographic_order simp: in_zip_imp_size_lt_apps)"], ["", "definition\n  wt_args :: \"nat \\<Rightarrow> ('v pvar \\<Rightarrow> zhmultiset) \\<Rightarrow> ('s, 'v) hd \\<Rightarrow> ('s, 'v) tm list \\<Rightarrow> zhmultiset\"\nwhere\n  \"wt_args i A \\<zeta> ss = sum_list\n     (map (eval_ztpoly A \\<circ> (\\<lambda>(s, i). PMult [coef_hd \\<zeta> i, wt s])) (zip ss [i..<i + length ss]))\""], ["", "lemma wt_Hd[simp]: \"wt (Hd \\<zeta>) = PSum [wt0 \\<zeta>, PNum (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wt (Hd \\<zeta>) =\n    PSum\n     [wt0 \\<zeta>,\n      PNum (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))]", "by (rule wt.simps[of _ \"[]\", simplified])"], ["", "lemma coef_hd_cong:\n  \"(\\<forall>x \\<in> vars_hd \\<zeta>. \\<forall>i. A (PCoef x i) = B (PCoef x i)) \\<Longrightarrow>\n   eval_ztpoly A (coef_hd \\<zeta> i) = eval_ztpoly B (coef_hd \\<zeta> i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars_hd \\<zeta>.\n       \\<forall>i. A (PCoef x i) = B (PCoef x i) \\<Longrightarrow>\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef_hd \\<zeta> i)) =\n    eval_tpoly B (map_tpoly (\\<lambda>x. x) zhmset_of (coef_hd \\<zeta> i))", "by (cases \\<zeta>) auto"], ["", "lemma wt0_cong:\n  assumes pwt_eq: \"\\<forall>x \\<in> vars_hd \\<zeta>. A (PWt x) = B (PWt x)\"\n  shows \"eval_ztpoly A (wt0 \\<zeta>) = eval_ztpoly B (wt0 \\<zeta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) =\n    eval_tpoly B (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>))", "using pwt_eq"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>vars_hd \\<zeta>. A (PWt x) = B (PWt x)\n\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) =\n    eval_tpoly B (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>))", "by (cases \\<zeta>) auto"], ["", "lemma wt_cong:\n  assumes\n    \"\\<forall>x \\<in> vars s. A (PWt x) = B (PWt x)\" and\n    \"\\<forall>x \\<in> vars s. \\<forall>i. A (PCoef x i) = B (PCoef x i)\"\n  shows \"eval_ztpoly A (wt s) = eval_ztpoly B (wt s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) =\n    eval_tpoly B (map_tpoly (\\<lambda>x. x) zhmset_of (wt s))", "using assms"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>vars s. A (PWt x) = B (PWt x)\n  \\<forall>x\\<in>vars s. \\<forall>i. A (PCoef x i) = B (PCoef x i)\n\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) =\n    eval_tpoly B (map_tpoly (\\<lambda>x. x) zhmset_of (wt s))", "proof (induct s rule: tm_induct_apps)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>s \\<in> set ss;\n                    \\<forall>x\\<in>vars s. A (PWt x) = B (PWt x);\n                    \\<forall>x\\<in>vars s.\n                       \\<forall>i. A (PCoef x i) = B (PCoef x i)\\<rbrakk>\n                   \\<Longrightarrow> eval_tpoly A\n(map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) =\n                                     eval_tpoly B\n(map_tpoly (\\<lambda>x. x) zhmset_of (wt s));\n        \\<forall>x\\<in>vars (apps (Hd \\<zeta>) ss). A (PWt x) = B (PWt x);\n        \\<forall>x\\<in>vars (apps (Hd \\<zeta>) ss).\n           \\<forall>i. A (PCoef x i) = B (PCoef x i)\\<rbrakk>\n       \\<Longrightarrow> eval_tpoly A\n                          (map_tpoly (\\<lambda>x. x) zhmset_of\n                            (wt (apps (Hd \\<zeta>) ss))) =\n                         eval_tpoly B\n                          (map_tpoly (\\<lambda>x. x) zhmset_of\n                            (wt (apps (Hd \\<zeta>) ss)))", "case (apps \\<zeta> ss)"], ["proof (state)\nthis:\n  \\<lbrakk>?s \\<in> set ss; \\<forall>x\\<in>vars ?s. A (PWt x) = B (PWt x);\n   \\<forall>x\\<in>vars ?s.\n      \\<forall>i. A (PCoef x i) = B (PCoef x i)\\<rbrakk>\n  \\<Longrightarrow> eval_tpoly A\n                     (map_tpoly (\\<lambda>x. x) zhmset_of (wt ?s)) =\n                    eval_tpoly B\n                     (map_tpoly (\\<lambda>x. x) zhmset_of (wt ?s))\n  \\<forall>x\\<in>vars (apps (Hd \\<zeta>) ss). A (PWt x) = B (PWt x)\n  \\<forall>x\\<in>vars (apps (Hd \\<zeta>) ss).\n     \\<forall>i. A (PCoef x i) = B (PCoef x i)\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>s \\<in> set ss;\n                    \\<forall>x\\<in>vars s. A (PWt x) = B (PWt x);\n                    \\<forall>x\\<in>vars s.\n                       \\<forall>i. A (PCoef x i) = B (PCoef x i)\\<rbrakk>\n                   \\<Longrightarrow> eval_tpoly A\n(map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) =\n                                     eval_tpoly B\n(map_tpoly (\\<lambda>x. x) zhmset_of (wt s));\n        \\<forall>x\\<in>vars (apps (Hd \\<zeta>) ss). A (PWt x) = B (PWt x);\n        \\<forall>x\\<in>vars (apps (Hd \\<zeta>) ss).\n           \\<forall>i. A (PCoef x i) = B (PCoef x i)\\<rbrakk>\n       \\<Longrightarrow> eval_tpoly A\n                          (map_tpoly (\\<lambda>x. x) zhmset_of\n                            (wt (apps (Hd \\<zeta>) ss))) =\n                         eval_tpoly B\n                          (map_tpoly (\\<lambda>x. x) zhmset_of\n                            (wt (apps (Hd \\<zeta>) ss)))", "note ih = this(1) and pwt_eq = this(2) and pcoef_eq = this(3)"], ["proof (state)\nthis:\n  \\<lbrakk>?s \\<in> set ss; \\<forall>x\\<in>vars ?s. A (PWt x) = B (PWt x);\n   \\<forall>x\\<in>vars ?s.\n      \\<forall>i. A (PCoef x i) = B (PCoef x i)\\<rbrakk>\n  \\<Longrightarrow> eval_tpoly A\n                     (map_tpoly (\\<lambda>x. x) zhmset_of (wt ?s)) =\n                    eval_tpoly B\n                     (map_tpoly (\\<lambda>x. x) zhmset_of (wt ?s))\n  \\<forall>x\\<in>vars (apps (Hd \\<zeta>) ss). A (PWt x) = B (PWt x)\n  \\<forall>x\\<in>vars (apps (Hd \\<zeta>) ss).\n     \\<forall>i. A (PCoef x i) = B (PCoef x i)\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>s \\<in> set ss;\n                    \\<forall>x\\<in>vars s. A (PWt x) = B (PWt x);\n                    \\<forall>x\\<in>vars s.\n                       \\<forall>i. A (PCoef x i) = B (PCoef x i)\\<rbrakk>\n                   \\<Longrightarrow> eval_tpoly A\n(map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) =\n                                     eval_tpoly B\n(map_tpoly (\\<lambda>x. x) zhmset_of (wt s));\n        \\<forall>x\\<in>vars (apps (Hd \\<zeta>) ss). A (PWt x) = B (PWt x);\n        \\<forall>x\\<in>vars (apps (Hd \\<zeta>) ss).\n           \\<forall>i. A (PCoef x i) = B (PCoef x i)\\<rbrakk>\n       \\<Longrightarrow> eval_tpoly A\n                          (map_tpoly (\\<lambda>x. x) zhmset_of\n                            (wt (apps (Hd \\<zeta>) ss))) =\n                         eval_tpoly B\n                          (map_tpoly (\\<lambda>x. x) zhmset_of\n                            (wt (apps (Hd \\<zeta>) ss)))", "have ih': \"eval_ztpoly A (wt s) = eval_ztpoly B (wt s)\" if s_in: \"s \\<in> set ss\" for s"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) =\n    eval_tpoly B (map_tpoly (\\<lambda>x. x) zhmset_of (wt s))", "proof (rule ih[OF s_in])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<forall>x\\<in>vars s. A (PWt x) = B (PWt x)\n 2. \\<forall>x\\<in>vars s. \\<forall>i. A (PCoef x i) = B (PCoef x i)", "show \"\\<forall>x \\<in> vars s. A (PWt x) = B (PWt x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars s. A (PWt x) = B (PWt x)", "using pwt_eq s_in"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>vars (apps (Hd \\<zeta>) ss). A (PWt x) = B (PWt x)\n  s \\<in> set ss\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars s. A (PWt x) = B (PWt x)", "by force"], ["proof (state)\nthis:\n  \\<forall>x\\<in>vars s. A (PWt x) = B (PWt x)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars s. \\<forall>i. A (PCoef x i) = B (PCoef x i)", "show \"\\<forall>x \\<in> vars s. \\<forall>i. A (PCoef x i) = B (PCoef x i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars s. \\<forall>i. A (PCoef x i) = B (PCoef x i)", "using pcoef_eq s_in"], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>vars (apps (Hd \\<zeta>) ss).\n     \\<forall>i. A (PCoef x i) = B (PCoef x i)\n  s \\<in> set ss\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>vars s. \\<forall>i. A (PCoef x i) = B (PCoef x i)", "by force"], ["proof (state)\nthis:\n  \\<forall>x\\<in>vars s. \\<forall>i. A (PCoef x i) = B (PCoef x i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?s \\<in> set ss \\<Longrightarrow>\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt ?s)) =\n  eval_tpoly B (map_tpoly (\\<lambda>x. x) zhmset_of (wt ?s))\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>s \\<in> set ss;\n                    \\<forall>x\\<in>vars s. A (PWt x) = B (PWt x);\n                    \\<forall>x\\<in>vars s.\n                       \\<forall>i. A (PCoef x i) = B (PCoef x i)\\<rbrakk>\n                   \\<Longrightarrow> eval_tpoly A\n(map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) =\n                                     eval_tpoly B\n(map_tpoly (\\<lambda>x. x) zhmset_of (wt s));\n        \\<forall>x\\<in>vars (apps (Hd \\<zeta>) ss). A (PWt x) = B (PWt x);\n        \\<forall>x\\<in>vars (apps (Hd \\<zeta>) ss).\n           \\<forall>i. A (PCoef x i) = B (PCoef x i)\\<rbrakk>\n       \\<Longrightarrow> eval_tpoly A\n                          (map_tpoly (\\<lambda>x. x) zhmset_of\n                            (wt (apps (Hd \\<zeta>) ss))) =\n                         eval_tpoly B\n                          (map_tpoly (\\<lambda>x. x) zhmset_of\n                            (wt (apps (Hd \\<zeta>) ss)))", "have wt0_eq: \"eval_ztpoly A (wt0 \\<zeta>) = eval_ztpoly B (wt0 \\<zeta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) =\n    eval_tpoly B (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>))", "by (rule wt0_cong) (simp add: pwt_eq)"], ["proof (state)\nthis:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) =\n  eval_tpoly B (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>))\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>s \\<in> set ss;\n                    \\<forall>x\\<in>vars s. A (PWt x) = B (PWt x);\n                    \\<forall>x\\<in>vars s.\n                       \\<forall>i. A (PCoef x i) = B (PCoef x i)\\<rbrakk>\n                   \\<Longrightarrow> eval_tpoly A\n(map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) =\n                                     eval_tpoly B\n(map_tpoly (\\<lambda>x. x) zhmset_of (wt s));\n        \\<forall>x\\<in>vars (apps (Hd \\<zeta>) ss). A (PWt x) = B (PWt x);\n        \\<forall>x\\<in>vars (apps (Hd \\<zeta>) ss).\n           \\<forall>i. A (PCoef x i) = B (PCoef x i)\\<rbrakk>\n       \\<Longrightarrow> eval_tpoly A\n                          (map_tpoly (\\<lambda>x. x) zhmset_of\n                            (wt (apps (Hd \\<zeta>) ss))) =\n                         eval_tpoly B\n                          (map_tpoly (\\<lambda>x. x) zhmset_of\n                            (wt (apps (Hd \\<zeta>) ss)))", "have coef_\\<zeta>_eq: \"eval_ztpoly A (coef_hd \\<zeta> i) = eval_ztpoly B (coef_hd \\<zeta> i)\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef_hd \\<zeta> i)) =\n    eval_tpoly B (map_tpoly (\\<lambda>x. x) zhmset_of (coef_hd \\<zeta> i))", "by (rule coef_hd_cong) (simp add: pcoef_eq)"], ["proof (state)\nthis:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef_hd \\<zeta> ?i)) =\n  eval_tpoly B (map_tpoly (\\<lambda>x. x) zhmset_of (coef_hd \\<zeta> ?i))\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>s \\<in> set ss;\n                    \\<forall>x\\<in>vars s. A (PWt x) = B (PWt x);\n                    \\<forall>x\\<in>vars s.\n                       \\<forall>i. A (PCoef x i) = B (PCoef x i)\\<rbrakk>\n                   \\<Longrightarrow> eval_tpoly A\n(map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) =\n                                     eval_tpoly B\n(map_tpoly (\\<lambda>x. x) zhmset_of (wt s));\n        \\<forall>x\\<in>vars (apps (Hd \\<zeta>) ss). A (PWt x) = B (PWt x);\n        \\<forall>x\\<in>vars (apps (Hd \\<zeta>) ss).\n           \\<forall>i. A (PCoef x i) = B (PCoef x i)\\<rbrakk>\n       \\<Longrightarrow> eval_tpoly A\n                          (map_tpoly (\\<lambda>x. x) zhmset_of\n                            (wt (apps (Hd \\<zeta>) ss))) =\n                         eval_tpoly B\n                          (map_tpoly (\\<lambda>x. x) zhmset_of\n                            (wt (apps (Hd \\<zeta>) ss)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_tpoly A\n     (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss))) =\n    eval_tpoly B\n     (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))", "using ih' wt0_eq coef_\\<zeta>_eq"], ["proof (prove)\nusing this:\n  ?s \\<in> set ss \\<Longrightarrow>\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt ?s)) =\n  eval_tpoly B (map_tpoly (\\<lambda>x. x) zhmset_of (wt ?s))\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) =\n  eval_tpoly B (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>))\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef_hd \\<zeta> ?i)) =\n  eval_tpoly B (map_tpoly (\\<lambda>x. x) zhmset_of (coef_hd \\<zeta> ?i))\n\ngoal (1 subgoal):\n 1. eval_tpoly A\n     (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss))) =\n    eval_tpoly B\n     (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))", "by (auto dest!: set_zip_leftD intro!: arg_cong[of _ _ sum_list])"], ["proof (state)\nthis:\n  eval_tpoly A\n   (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss))) =\n  eval_tpoly B\n   (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ground_eval_ztpoly_wt_eq: \"ground s \\<Longrightarrow> eval_ztpoly A (wt s) = eval_ztpoly B (wt s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ground s \\<Longrightarrow>\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) =\n    eval_tpoly B (map_tpoly (\\<lambda>x. x) zhmset_of (wt s))", "by (rule wt_cong) auto"], ["", "lemma exists_wt_sym:\n  assumes legal: \"legal_zpassign A\"\n  shows \"\\<exists>f \\<in> ground_heads \\<zeta>. eval_ztpoly A (wt (Hd \\<zeta>)) \\<ge> zhmset_of (wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>local.ground_heads \\<zeta>.\n       zhmset_of (wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f)\n       \\<le> eval_tpoly A\n              (map_tpoly (\\<lambda>x. x) zhmset_of (wt (Hd \\<zeta>)))", "unfolding eq_tpoly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>local.ground_heads \\<zeta>.\n       zhmset_of (wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f)\n       \\<le> eval_tpoly A\n              (map_tpoly (\\<lambda>x. x) zhmset_of (wt (Hd \\<zeta>)))", "proof (cases \\<zeta>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<zeta> = Var x1 \\<Longrightarrow>\n       \\<exists>f\\<in>local.ground_heads \\<zeta>.\n          zhmset_of (wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f)\n          \\<le> eval_tpoly A\n                 (map_tpoly (\\<lambda>x. x) zhmset_of (wt (Hd \\<zeta>)))\n 2. \\<And>x2.\n       \\<zeta> = Sym x2 \\<Longrightarrow>\n       \\<exists>f\\<in>local.ground_heads \\<zeta>.\n          zhmset_of (wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f)\n          \\<le> eval_tpoly A\n                 (map_tpoly (\\<lambda>x. x) zhmset_of (wt (Hd \\<zeta>)))", "case Var"], ["proof (state)\nthis:\n  \\<zeta> = Var x1_\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<zeta> = Var x1 \\<Longrightarrow>\n       \\<exists>f\\<in>local.ground_heads \\<zeta>.\n          zhmset_of (wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f)\n          \\<le> eval_tpoly A\n                 (map_tpoly (\\<lambda>x. x) zhmset_of (wt (Hd \\<zeta>)))\n 2. \\<And>x2.\n       \\<zeta> = Sym x2 \\<Longrightarrow>\n       \\<exists>f\\<in>local.ground_heads \\<zeta>.\n          zhmset_of (wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f)\n          \\<le> eval_tpoly A\n                 (map_tpoly (\\<lambda>x. x) zhmset_of (wt (Hd \\<zeta>)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<zeta> = Var x1_\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>local.ground_heads \\<zeta>.\n       zhmset_of (wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f)\n       \\<le> eval_tpoly A\n              (map_tpoly (\\<lambda>x. x) zhmset_of (wt (Hd \\<zeta>)))", "using legal[unfolded legal_zpassign_def]"], ["proof (prove)\nusing this:\n  \\<zeta> = Var x1_\n  \\<forall>x. zhmset_of (min_passign x) \\<le> A x\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>local.ground_heads \\<zeta>.\n       zhmset_of (wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f)\n       \\<le> eval_tpoly A\n              (map_tpoly (\\<lambda>x. x) zhmset_of (wt (Hd \\<zeta>)))", "by simp (metis add_le_cancel_right ground_heads.simps(1) min_ground_head_in_ground_heads\n      min_zpassign_simps(1) zhmset_of_plus)"], ["proof (state)\nthis:\n  \\<exists>f\\<in>local.ground_heads \\<zeta>.\n     zhmset_of (wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f)\n     \\<le> eval_tpoly A\n            (map_tpoly (\\<lambda>x. x) zhmset_of (wt (Hd \\<zeta>)))\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<zeta> = Sym x2 \\<Longrightarrow>\n       \\<exists>f\\<in>local.ground_heads \\<zeta>.\n          zhmset_of (wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f)\n          \\<le> eval_tpoly A\n                 (map_tpoly (\\<lambda>x. x) zhmset_of (wt (Hd \\<zeta>)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<zeta> = Sym x2 \\<Longrightarrow>\n       \\<exists>f\\<in>local.ground_heads \\<zeta>.\n          zhmset_of (wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f)\n          \\<le> eval_tpoly A\n                 (map_tpoly (\\<lambda>x. x) zhmset_of (wt (Hd \\<zeta>)))", "case Sym"], ["proof (state)\nthis:\n  \\<zeta> = Sym x2_\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<zeta> = Sym x2 \\<Longrightarrow>\n       \\<exists>f\\<in>local.ground_heads \\<zeta>.\n          zhmset_of (wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f)\n          \\<le> eval_tpoly A\n                 (map_tpoly (\\<lambda>x. x) zhmset_of (wt (Hd \\<zeta>)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<zeta> = Sym x2_\n\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>local.ground_heads \\<zeta>.\n       zhmset_of (wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f)\n       \\<le> eval_tpoly A\n              (map_tpoly (\\<lambda>x. x) zhmset_of (wt (Hd \\<zeta>)))", "by (simp add: zhmset_of_plus)"], ["proof (state)\nthis:\n  \\<exists>f\\<in>local.ground_heads \\<zeta>.\n     zhmset_of (wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f)\n     \\<le> eval_tpoly A\n            (map_tpoly (\\<lambda>x. x) zhmset_of (wt (Hd \\<zeta>)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wt_ge_\\<epsilon>\\<^sub>h:\n  assumes legal: \"legal_zpassign A\"\n  shows \"eval_ztpoly A (wt s) \\<ge> zhmset_of \\<epsilon>\\<^sub>h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zhmset_of \\<epsilon>\\<^sub>h\n    \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s))", "proof (induct s rule: tm_induct_apps)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       (\\<And>s.\n           s \\<in> set ss \\<Longrightarrow>\n           zhmset_of \\<epsilon>\\<^sub>h\n           \\<le> eval_tpoly A\n                  (map_tpoly (\\<lambda>x. x) zhmset_of\n                    (wt s))) \\<Longrightarrow>\n       zhmset_of \\<epsilon>\\<^sub>h\n       \\<le> eval_tpoly A\n              (map_tpoly (\\<lambda>x. x) zhmset_of\n                (wt (apps (Hd \\<zeta>) ss)))", "case (apps \\<zeta> ss)"], ["proof (state)\nthis:\n  ?s \\<in> set ss \\<Longrightarrow>\n  zhmset_of \\<epsilon>\\<^sub>h\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt ?s))\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       (\\<And>s.\n           s \\<in> set ss \\<Longrightarrow>\n           zhmset_of \\<epsilon>\\<^sub>h\n           \\<le> eval_tpoly A\n                  (map_tpoly (\\<lambda>x. x) zhmset_of\n                    (wt s))) \\<Longrightarrow>\n       zhmset_of \\<epsilon>\\<^sub>h\n       \\<le> eval_tpoly A\n              (map_tpoly (\\<lambda>x. x) zhmset_of\n                (wt (apps (Hd \\<zeta>) ss)))", "note ih = this(1)"], ["proof (state)\nthis:\n  ?s \\<in> set ss \\<Longrightarrow>\n  zhmset_of \\<epsilon>\\<^sub>h\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt ?s))\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       (\\<And>s.\n           s \\<in> set ss \\<Longrightarrow>\n           zhmset_of \\<epsilon>\\<^sub>h\n           \\<le> eval_tpoly A\n                  (map_tpoly (\\<lambda>x. x) zhmset_of\n                    (wt s))) \\<Longrightarrow>\n       zhmset_of \\<epsilon>\\<^sub>h\n       \\<le> eval_tpoly A\n              (map_tpoly (\\<lambda>x. x) zhmset_of\n                (wt (apps (Hd \\<zeta>) ss)))", "{"], ["proof (state)\nthis:\n  ?s \\<in> set ss \\<Longrightarrow>\n  zhmset_of \\<epsilon>\\<^sub>h\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt ?s))\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       (\\<And>s.\n           s \\<in> set ss \\<Longrightarrow>\n           zhmset_of \\<epsilon>\\<^sub>h\n           \\<le> eval_tpoly A\n                  (map_tpoly (\\<lambda>x. x) zhmset_of\n                    (wt s))) \\<Longrightarrow>\n       zhmset_of \\<epsilon>\\<^sub>h\n       \\<le> eval_tpoly A\n              (map_tpoly (\\<lambda>x. x) zhmset_of\n                (wt (apps (Hd \\<zeta>) ss)))", "assume ss_eq_nil: \"ss = []\""], ["proof (state)\nthis:\n  ss = []\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       (\\<And>s.\n           s \\<in> set ss \\<Longrightarrow>\n           zhmset_of \\<epsilon>\\<^sub>h\n           \\<le> eval_tpoly A\n                  (map_tpoly (\\<lambda>x. x) zhmset_of\n                    (wt s))) \\<Longrightarrow>\n       zhmset_of \\<epsilon>\\<^sub>h\n       \\<le> eval_tpoly A\n              (map_tpoly (\\<lambda>x. x) zhmset_of\n                (wt (apps (Hd \\<zeta>) ss)))", "have \"\\<epsilon>\\<^sub>h \\<le> wt_sym (min_ground_head \\<zeta>) + \\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<epsilon>\\<^sub>h\n    \\<le> wt_sym (min_ground_head \\<zeta>) +\n          \\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>)", "using wt_sym_ge\\<^sub>h[of \"min_ground_head \\<zeta>\"]"], ["proof (prove)\nusing this:\n  \\<epsilon>\\<^sub>h -\n  \\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>)\n  \\<le> wt_sym (min_ground_head \\<zeta>)\n\ngoal (1 subgoal):\n 1. \\<epsilon>\\<^sub>h\n    \\<le> wt_sym (min_ground_head \\<zeta>) +\n          \\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>)", "by (metis add_diff_cancel_left' leD leI le_imp_minus_plus_hmset le_minus_plus_same_hmset\n        less_le_trans)"], ["proof (state)\nthis:\n  \\<epsilon>\\<^sub>h\n  \\<le> wt_sym (min_ground_head \\<zeta>) +\n        \\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       (\\<And>s.\n           s \\<in> set ss \\<Longrightarrow>\n           zhmset_of \\<epsilon>\\<^sub>h\n           \\<le> eval_tpoly A\n                  (map_tpoly (\\<lambda>x. x) zhmset_of\n                    (wt s))) \\<Longrightarrow>\n       zhmset_of \\<epsilon>\\<^sub>h\n       \\<le> eval_tpoly A\n              (map_tpoly (\\<lambda>x. x) zhmset_of\n                (wt (apps (Hd \\<zeta>) ss)))", "hence \"zhmset_of \\<epsilon>\\<^sub>h\n      \\<le> zhmset_of (wt_sym (min_ground_head \\<zeta>)) + zhmset_of (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))\""], ["proof (prove)\nusing this:\n  \\<epsilon>\\<^sub>h\n  \\<le> wt_sym (min_ground_head \\<zeta>) +\n        \\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>)\n\ngoal (1 subgoal):\n 1. zhmset_of \\<epsilon>\\<^sub>h\n    \\<le> zhmset_of (wt_sym (min_ground_head \\<zeta>)) +\n          zhmset_of\n           (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))", "by (metis zhmset_of_le zhmset_of_plus)"], ["proof (state)\nthis:\n  zhmset_of \\<epsilon>\\<^sub>h\n  \\<le> zhmset_of (wt_sym (min_ground_head \\<zeta>)) +\n        zhmset_of\n         (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       (\\<And>s.\n           s \\<in> set ss \\<Longrightarrow>\n           zhmset_of \\<epsilon>\\<^sub>h\n           \\<le> eval_tpoly A\n                  (map_tpoly (\\<lambda>x. x) zhmset_of\n                    (wt s))) \\<Longrightarrow>\n       zhmset_of \\<epsilon>\\<^sub>h\n       \\<le> eval_tpoly A\n              (map_tpoly (\\<lambda>x. x) zhmset_of\n                (wt (apps (Hd \\<zeta>) ss)))", "also"], ["proof (state)\nthis:\n  zhmset_of \\<epsilon>\\<^sub>h\n  \\<le> zhmset_of (wt_sym (min_ground_head \\<zeta>)) +\n        zhmset_of\n         (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       (\\<And>s.\n           s \\<in> set ss \\<Longrightarrow>\n           zhmset_of \\<epsilon>\\<^sub>h\n           \\<le> eval_tpoly A\n                  (map_tpoly (\\<lambda>x. x) zhmset_of\n                    (wt s))) \\<Longrightarrow>\n       zhmset_of \\<epsilon>\\<^sub>h\n       \\<le> eval_tpoly A\n              (map_tpoly (\\<lambda>x. x) zhmset_of\n                (wt (apps (Hd \\<zeta>) ss)))", "have \"\\<dots>\n      \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>))\n        + zhmset_of (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zhmset_of (wt_sym (min_ground_head \\<zeta>)) +\n    zhmset_of\n     (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))\n    \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n          zhmset_of\n           (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))", "using wt0_ge_min_ground_head[OF legal]"], ["proof (prove)\nusing this:\n  zhmset_of (wt_sym (min_ground_head ?\\<zeta>))\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 ?\\<zeta>))\n\ngoal (1 subgoal):\n 1. zhmset_of (wt_sym (min_ground_head \\<zeta>)) +\n    zhmset_of\n     (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))\n    \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n          zhmset_of\n           (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))", "by simp"], ["proof (state)\nthis:\n  zhmset_of (wt_sym (min_ground_head \\<zeta>)) +\n  zhmset_of (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n        zhmset_of\n         (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       (\\<And>s.\n           s \\<in> set ss \\<Longrightarrow>\n           zhmset_of \\<epsilon>\\<^sub>h\n           \\<le> eval_tpoly A\n                  (map_tpoly (\\<lambda>x. x) zhmset_of\n                    (wt s))) \\<Longrightarrow>\n       zhmset_of \\<epsilon>\\<^sub>h\n       \\<le> eval_tpoly A\n              (map_tpoly (\\<lambda>x. x) zhmset_of\n                (wt (apps (Hd \\<zeta>) ss)))", "finally"], ["proof (chain)\npicking this:\n  zhmset_of \\<epsilon>\\<^sub>h\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n        zhmset_of\n         (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))", "have ?case"], ["proof (prove)\nusing this:\n  zhmset_of \\<epsilon>\\<^sub>h\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n        zhmset_of\n         (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))\n\ngoal (1 subgoal):\n 1. zhmset_of \\<epsilon>\\<^sub>h\n    \\<le> eval_tpoly A\n           (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))", "using ss_eq_nil"], ["proof (prove)\nusing this:\n  zhmset_of \\<epsilon>\\<^sub>h\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n        zhmset_of\n         (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))\n  ss = []\n\ngoal (1 subgoal):\n 1. zhmset_of \\<epsilon>\\<^sub>h\n    \\<le> eval_tpoly A\n           (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))", "by simp"], ["proof (state)\nthis:\n  zhmset_of \\<epsilon>\\<^sub>h\n  \\<le> eval_tpoly A\n         (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       (\\<And>s.\n           s \\<in> set ss \\<Longrightarrow>\n           zhmset_of \\<epsilon>\\<^sub>h\n           \\<le> eval_tpoly A\n                  (map_tpoly (\\<lambda>x. x) zhmset_of\n                    (wt s))) \\<Longrightarrow>\n       zhmset_of \\<epsilon>\\<^sub>h\n       \\<le> eval_tpoly A\n              (map_tpoly (\\<lambda>x. x) zhmset_of\n                (wt (apps (Hd \\<zeta>) ss)))", "}"], ["proof (state)\nthis:\n  ss = [] \\<Longrightarrow>\n  zhmset_of \\<epsilon>\\<^sub>h\n  \\<le> eval_tpoly A\n         (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       (\\<And>s.\n           s \\<in> set ss \\<Longrightarrow>\n           zhmset_of \\<epsilon>\\<^sub>h\n           \\<le> eval_tpoly A\n                  (map_tpoly (\\<lambda>x. x) zhmset_of\n                    (wt s))) \\<Longrightarrow>\n       zhmset_of \\<epsilon>\\<^sub>h\n       \\<le> eval_tpoly A\n              (map_tpoly (\\<lambda>x. x) zhmset_of\n                (wt (apps (Hd \\<zeta>) ss)))", "moreover"], ["proof (state)\nthis:\n  ss = [] \\<Longrightarrow>\n  zhmset_of \\<epsilon>\\<^sub>h\n  \\<le> eval_tpoly A\n         (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       (\\<And>s.\n           s \\<in> set ss \\<Longrightarrow>\n           zhmset_of \\<epsilon>\\<^sub>h\n           \\<le> eval_tpoly A\n                  (map_tpoly (\\<lambda>x. x) zhmset_of\n                    (wt s))) \\<Longrightarrow>\n       zhmset_of \\<epsilon>\\<^sub>h\n       \\<le> eval_tpoly A\n              (map_tpoly (\\<lambda>x. x) zhmset_of\n                (wt (apps (Hd \\<zeta>) ss)))", "{"], ["proof (state)\nthis:\n  ss = [] \\<Longrightarrow>\n  zhmset_of \\<epsilon>\\<^sub>h\n  \\<le> eval_tpoly A\n         (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       (\\<And>s.\n           s \\<in> set ss \\<Longrightarrow>\n           zhmset_of \\<epsilon>\\<^sub>h\n           \\<le> eval_tpoly A\n                  (map_tpoly (\\<lambda>x. x) zhmset_of\n                    (wt s))) \\<Longrightarrow>\n       zhmset_of \\<epsilon>\\<^sub>h\n       \\<le> eval_tpoly A\n              (map_tpoly (\\<lambda>x. x) zhmset_of\n                (wt (apps (Hd \\<zeta>) ss)))", "let ?arg_wt =\n      \"eval_tpoly A \\<circ> (map_tpoly (\\<lambda>x. x) zhmset_of \\<circ> (\\<lambda>(s, i). PMult [coef_hd \\<zeta> i, wt s]))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       (\\<And>s.\n           s \\<in> set ss \\<Longrightarrow>\n           zhmset_of \\<epsilon>\\<^sub>h\n           \\<le> eval_tpoly A\n                  (map_tpoly (\\<lambda>x. x) zhmset_of\n                    (wt s))) \\<Longrightarrow>\n       zhmset_of \\<epsilon>\\<^sub>h\n       \\<le> eval_tpoly A\n              (map_tpoly (\\<lambda>x. x) zhmset_of\n                (wt (apps (Hd \\<zeta>) ss)))", "assume ss_ne_nil: \"ss \\<noteq> []\""], ["proof (state)\nthis:\n  ss \\<noteq> []\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       (\\<And>s.\n           s \\<in> set ss \\<Longrightarrow>\n           zhmset_of \\<epsilon>\\<^sub>h\n           \\<le> eval_tpoly A\n                  (map_tpoly (\\<lambda>x. x) zhmset_of\n                    (wt s))) \\<Longrightarrow>\n       zhmset_of \\<epsilon>\\<^sub>h\n       \\<le> eval_tpoly A\n              (map_tpoly (\\<lambda>x. x) zhmset_of\n                (wt (apps (Hd \\<zeta>) ss)))", "hence \"zhmset_of \\<epsilon>\\<^sub>h\n      \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (PMult [coef_hd \\<zeta> 0, wt (hd ss)]))\""], ["proof (prove)\nusing this:\n  ss \\<noteq> []\n\ngoal (1 subgoal):\n 1. zhmset_of \\<epsilon>\\<^sub>h\n    \\<le> eval_tpoly A\n           (map_tpoly (\\<lambda>x. x) zhmset_of\n             (PMult [coef_hd \\<zeta> 0, wt (hd ss)]))", "by (simp add: ih coef_hd_gt_0[OF legal] nonneg_le_mult_right_mono_zhmset)"], ["proof (state)\nthis:\n  zhmset_of \\<epsilon>\\<^sub>h\n  \\<le> eval_tpoly A\n         (map_tpoly (\\<lambda>x. x) zhmset_of\n           (PMult [coef_hd \\<zeta> 0, wt (hd ss)]))\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       (\\<And>s.\n           s \\<in> set ss \\<Longrightarrow>\n           zhmset_of \\<epsilon>\\<^sub>h\n           \\<le> eval_tpoly A\n                  (map_tpoly (\\<lambda>x. x) zhmset_of\n                    (wt s))) \\<Longrightarrow>\n       zhmset_of \\<epsilon>\\<^sub>h\n       \\<le> eval_tpoly A\n              (map_tpoly (\\<lambda>x. x) zhmset_of\n                (wt (apps (Hd \\<zeta>) ss)))", "also"], ["proof (state)\nthis:\n  zhmset_of \\<epsilon>\\<^sub>h\n  \\<le> eval_tpoly A\n         (map_tpoly (\\<lambda>x. x) zhmset_of\n           (PMult [coef_hd \\<zeta> 0, wt (hd ss)]))\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       (\\<And>s.\n           s \\<in> set ss \\<Longrightarrow>\n           zhmset_of \\<epsilon>\\<^sub>h\n           \\<le> eval_tpoly A\n                  (map_tpoly (\\<lambda>x. x) zhmset_of\n                    (wt s))) \\<Longrightarrow>\n       zhmset_of \\<epsilon>\\<^sub>h\n       \\<le> eval_tpoly A\n              (map_tpoly (\\<lambda>x. x) zhmset_of\n                (wt (apps (Hd \\<zeta>) ss)))", "have \"\\<dots> = hd (map ?arg_wt (zip ss [0..<length ss]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_tpoly A\n     (map_tpoly (\\<lambda>x. x) zhmset_of\n       (PMult [coef_hd \\<zeta> 0, wt (hd ss)])) =\n    hd (map (eval_tpoly A \\<circ>\n             (map_tpoly (\\<lambda>x. x) zhmset_of \\<circ>\n              (\\<lambda>(s, i). PMult [coef_hd \\<zeta> i, wt s])))\n         (zip ss [0..<length ss]))", "using ss_ne_nil"], ["proof (prove)\nusing this:\n  ss \\<noteq> []\n\ngoal (1 subgoal):\n 1. eval_tpoly A\n     (map_tpoly (\\<lambda>x. x) zhmset_of\n       (PMult [coef_hd \\<zeta> 0, wt (hd ss)])) =\n    hd (map (eval_tpoly A \\<circ>\n             (map_tpoly (\\<lambda>x. x) zhmset_of \\<circ>\n              (\\<lambda>(s, i). PMult [coef_hd \\<zeta> i, wt s])))\n         (zip ss [0..<length ss]))", "by (simp add: hd_map zip_nth_conv hd_conv_nth)"], ["proof (state)\nthis:\n  eval_tpoly A\n   (map_tpoly (\\<lambda>x. x) zhmset_of\n     (PMult [coef_hd \\<zeta> 0, wt (hd ss)])) =\n  hd (map (eval_tpoly A \\<circ>\n           (map_tpoly (\\<lambda>x. x) zhmset_of \\<circ>\n            (\\<lambda>(s, i). PMult [coef_hd \\<zeta> i, wt s])))\n       (zip ss [0..<length ss]))\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       (\\<And>s.\n           s \\<in> set ss \\<Longrightarrow>\n           zhmset_of \\<epsilon>\\<^sub>h\n           \\<le> eval_tpoly A\n                  (map_tpoly (\\<lambda>x. x) zhmset_of\n                    (wt s))) \\<Longrightarrow>\n       zhmset_of \\<epsilon>\\<^sub>h\n       \\<le> eval_tpoly A\n              (map_tpoly (\\<lambda>x. x) zhmset_of\n                (wt (apps (Hd \\<zeta>) ss)))", "also"], ["proof (state)\nthis:\n  eval_tpoly A\n   (map_tpoly (\\<lambda>x. x) zhmset_of\n     (PMult [coef_hd \\<zeta> 0, wt (hd ss)])) =\n  hd (map (eval_tpoly A \\<circ>\n           (map_tpoly (\\<lambda>x. x) zhmset_of \\<circ>\n            (\\<lambda>(s, i). PMult [coef_hd \\<zeta> i, wt s])))\n       (zip ss [0..<length ss]))\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       (\\<And>s.\n           s \\<in> set ss \\<Longrightarrow>\n           zhmset_of \\<epsilon>\\<^sub>h\n           \\<le> eval_tpoly A\n                  (map_tpoly (\\<lambda>x. x) zhmset_of\n                    (wt s))) \\<Longrightarrow>\n       zhmset_of \\<epsilon>\\<^sub>h\n       \\<le> eval_tpoly A\n              (map_tpoly (\\<lambda>x. x) zhmset_of\n                (wt (apps (Hd \\<zeta>) ss)))", "have \"\\<dots> \\<le> sum_list (map ?arg_wt (zip ss [0..<length ss]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd (map (eval_tpoly A \\<circ>\n             (map_tpoly (\\<lambda>x. x) zhmset_of \\<circ>\n              (\\<lambda>(s, i). PMult [coef_hd \\<zeta> i, wt s])))\n         (zip ss [0..<length ss]))\n    \\<le> sum_list\n           (map (eval_tpoly A \\<circ>\n                 (map_tpoly (\\<lambda>x. x) zhmset_of \\<circ>\n                  (\\<lambda>(s, i). PMult [coef_hd \\<zeta> i, wt s])))\n             (zip ss [0..<length ss]))", "by (rule hd_le_sum_list,\n        metis (no_types, lifting) length_greater_0_conv list.collapse list.simps(3) list.simps(9)\n          ss_ne_nil upt_conv_Cons zip_Cons_Cons,\n        simp add: eval_ztpoly_nonneg legal)"], ["proof (state)\nthis:\n  hd (map (eval_tpoly A \\<circ>\n           (map_tpoly (\\<lambda>x. x) zhmset_of \\<circ>\n            (\\<lambda>(s, i). PMult [coef_hd \\<zeta> i, wt s])))\n       (zip ss [0..<length ss]))\n  \\<le> sum_list\n         (map (eval_tpoly A \\<circ>\n               (map_tpoly (\\<lambda>x. x) zhmset_of \\<circ>\n                (\\<lambda>(s, i). PMult [coef_hd \\<zeta> i, wt s])))\n           (zip ss [0..<length ss]))\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       (\\<And>s.\n           s \\<in> set ss \\<Longrightarrow>\n           zhmset_of \\<epsilon>\\<^sub>h\n           \\<le> eval_tpoly A\n                  (map_tpoly (\\<lambda>x. x) zhmset_of\n                    (wt s))) \\<Longrightarrow>\n       zhmset_of \\<epsilon>\\<^sub>h\n       \\<le> eval_tpoly A\n              (map_tpoly (\\<lambda>x. x) zhmset_of\n                (wt (apps (Hd \\<zeta>) ss)))", "also"], ["proof (state)\nthis:\n  hd (map (eval_tpoly A \\<circ>\n           (map_tpoly (\\<lambda>x. x) zhmset_of \\<circ>\n            (\\<lambda>(s, i). PMult [coef_hd \\<zeta> i, wt s])))\n       (zip ss [0..<length ss]))\n  \\<le> sum_list\n         (map (eval_tpoly A \\<circ>\n               (map_tpoly (\\<lambda>x. x) zhmset_of \\<circ>\n                (\\<lambda>(s, i). PMult [coef_hd \\<zeta> i, wt s])))\n           (zip ss [0..<length ss]))\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       (\\<And>s.\n           s \\<in> set ss \\<Longrightarrow>\n           zhmset_of \\<epsilon>\\<^sub>h\n           \\<le> eval_tpoly A\n                  (map_tpoly (\\<lambda>x. x) zhmset_of\n                    (wt s))) \\<Longrightarrow>\n       zhmset_of \\<epsilon>\\<^sub>h\n       \\<le> eval_tpoly A\n              (map_tpoly (\\<lambda>x. x) zhmset_of\n                (wt (apps (Hd \\<zeta>) ss)))", "have \"\\<dots>\n      \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n        (zhmset_of (\\<delta>\\<^sub>h * (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss))) +\n         sum_list (map ?arg_wt (zip ss [0..<length ss])))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sum_list\n     (map (eval_tpoly A \\<circ>\n           (map_tpoly (\\<lambda>x. x) zhmset_of \\<circ>\n            (\\<lambda>(s, i). PMult [coef_hd \\<zeta> i, wt s])))\n       (zip ss [0..<length ss]))\n    \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n          (zhmset_of\n            (\\<delta>\\<^sub>h *\n             (arity_sym\\<^sub>h (min_ground_head \\<zeta>) -\n              of_nat (length ss))) +\n           sum_list\n            (map (eval_tpoly A \\<circ>\n                  (map_tpoly (\\<lambda>x. x) zhmset_of \\<circ>\n                   (\\<lambda>(s, i). PMult [coef_hd \\<zeta> i, wt s])))\n              (zip ss [0..<length ss])))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sum_list\n     (map (eval_tpoly A \\<circ>\n           (map_tpoly (\\<lambda>x. x) zhmset_of \\<circ>\n            (\\<lambda>(s, i). PMult [coef_hd \\<zeta> i, wt s])))\n       (zip ss [0..<length ss]))\n    \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n          (zhmset_of\n            (\\<delta>\\<^sub>h *\n             (arity_sym\\<^sub>h (min_ground_head \\<zeta>) -\n              of_nat (length ss))) +\n           sum_list\n            (map (eval_tpoly A \\<circ>\n                  (map_tpoly (\\<lambda>x. x) zhmset_of \\<circ>\n                   (\\<lambda>(s, i). PMult [coef_hd \\<zeta> i, wt s])))\n              (zip ss [0..<length ss])))", "have \"0 \\<le> eval_tpoly A (map_tpoly (\\<lambda>p. p) zhmset_of (wt0 \\<zeta>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<le> eval_tpoly A (map_tpoly (\\<lambda>p. p) zhmset_of (wt0 \\<zeta>))", "using legal eval_ztpoly_nonneg"], ["proof (prove)\nusing this:\n  legal_zpassign A\n  legal_zpassign ?A \\<Longrightarrow>\n  0 \\<le> eval_tpoly ?A (map_tpoly (\\<lambda>x. x) zhmset_of ?p)\n\ngoal (1 subgoal):\n 1. 0 \\<le> eval_tpoly A (map_tpoly (\\<lambda>p. p) zhmset_of (wt0 \\<zeta>))", "by blast"], ["proof (state)\nthis:\n  0 \\<le> eval_tpoly A (map_tpoly (\\<lambda>p. p) zhmset_of (wt0 \\<zeta>))\n\ngoal (1 subgoal):\n 1. sum_list\n     (map (eval_tpoly A \\<circ>\n           (map_tpoly (\\<lambda>x. x) zhmset_of \\<circ>\n            (\\<lambda>(s, i). PMult [coef_hd \\<zeta> i, wt s])))\n       (zip ss [0..<length ss]))\n    \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n          (zhmset_of\n            (\\<delta>\\<^sub>h *\n             (arity_sym\\<^sub>h (min_ground_head \\<zeta>) -\n              of_nat (length ss))) +\n           sum_list\n            (map (eval_tpoly A \\<circ>\n                  (map_tpoly (\\<lambda>x. x) zhmset_of \\<circ>\n                   (\\<lambda>(s, i). PMult [coef_hd \\<zeta> i, wt s])))\n              (zip ss [0..<length ss])))", "then"], ["proof (chain)\npicking this:\n  0 \\<le> eval_tpoly A (map_tpoly (\\<lambda>p. p) zhmset_of (wt0 \\<zeta>))", "show ?thesis"], ["proof (prove)\nusing this:\n  0 \\<le> eval_tpoly A (map_tpoly (\\<lambda>p. p) zhmset_of (wt0 \\<zeta>))\n\ngoal (1 subgoal):\n 1. sum_list\n     (map (eval_tpoly A \\<circ>\n           (map_tpoly (\\<lambda>x. x) zhmset_of \\<circ>\n            (\\<lambda>(s, i). PMult [coef_hd \\<zeta> i, wt s])))\n       (zip ss [0..<length ss]))\n    \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n          (zhmset_of\n            (\\<delta>\\<^sub>h *\n             (arity_sym\\<^sub>h (min_ground_head \\<zeta>) -\n              of_nat (length ss))) +\n           sum_list\n            (map (eval_tpoly A \\<circ>\n                  (map_tpoly (\\<lambda>x. x) zhmset_of \\<circ>\n                   (\\<lambda>(s, i). PMult [coef_hd \\<zeta> i, wt s])))\n              (zip ss [0..<length ss])))", "by (meson leD leI le_add_same_cancel2 less_le_trans zhmset_of_nonneg)"], ["proof (state)\nthis:\n  sum_list\n   (map (eval_tpoly A \\<circ>\n         (map_tpoly (\\<lambda>x. x) zhmset_of \\<circ>\n          (\\<lambda>(s, i). PMult [coef_hd \\<zeta> i, wt s])))\n     (zip ss [0..<length ss]))\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n        (zhmset_of\n          (\\<delta>\\<^sub>h *\n           (arity_sym\\<^sub>h (min_ground_head \\<zeta>) -\n            of_nat (length ss))) +\n         sum_list\n          (map (eval_tpoly A \\<circ>\n                (map_tpoly (\\<lambda>x. x) zhmset_of \\<circ>\n                 (\\<lambda>(s, i). PMult [coef_hd \\<zeta> i, wt s])))\n            (zip ss [0..<length ss])))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  sum_list\n   (map (eval_tpoly A \\<circ>\n         (map_tpoly (\\<lambda>x. x) zhmset_of \\<circ>\n          (\\<lambda>(s, i). PMult [coef_hd \\<zeta> i, wt s])))\n     (zip ss [0..<length ss]))\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n        (zhmset_of\n          (\\<delta>\\<^sub>h *\n           (arity_sym\\<^sub>h (min_ground_head \\<zeta>) -\n            of_nat (length ss))) +\n         sum_list\n          (map (eval_tpoly A \\<circ>\n                (map_tpoly (\\<lambda>x. x) zhmset_of \\<circ>\n                 (\\<lambda>(s, i). PMult [coef_hd \\<zeta> i, wt s])))\n            (zip ss [0..<length ss])))\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       (\\<And>s.\n           s \\<in> set ss \\<Longrightarrow>\n           zhmset_of \\<epsilon>\\<^sub>h\n           \\<le> eval_tpoly A\n                  (map_tpoly (\\<lambda>x. x) zhmset_of\n                    (wt s))) \\<Longrightarrow>\n       zhmset_of \\<epsilon>\\<^sub>h\n       \\<le> eval_tpoly A\n              (map_tpoly (\\<lambda>x. x) zhmset_of\n                (wt (apps (Hd \\<zeta>) ss)))", "finally"], ["proof (chain)\npicking this:\n  zhmset_of \\<epsilon>\\<^sub>h\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n        (zhmset_of\n          (\\<delta>\\<^sub>h *\n           (arity_sym\\<^sub>h (min_ground_head \\<zeta>) -\n            of_nat (length ss))) +\n         sum_list\n          (map (eval_tpoly A \\<circ>\n                (map_tpoly (\\<lambda>x. x) zhmset_of \\<circ>\n                 (\\<lambda>(s, i). PMult [coef_hd \\<zeta> i, wt s])))\n            (zip ss [0..<length ss])))", "have ?case"], ["proof (prove)\nusing this:\n  zhmset_of \\<epsilon>\\<^sub>h\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n        (zhmset_of\n          (\\<delta>\\<^sub>h *\n           (arity_sym\\<^sub>h (min_ground_head \\<zeta>) -\n            of_nat (length ss))) +\n         sum_list\n          (map (eval_tpoly A \\<circ>\n                (map_tpoly (\\<lambda>x. x) zhmset_of \\<circ>\n                 (\\<lambda>(s, i). PMult [coef_hd \\<zeta> i, wt s])))\n            (zip ss [0..<length ss])))\n\ngoal (1 subgoal):\n 1. zhmset_of \\<epsilon>\\<^sub>h\n    \\<le> eval_tpoly A\n           (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))", "by simp"], ["proof (state)\nthis:\n  zhmset_of \\<epsilon>\\<^sub>h\n  \\<le> eval_tpoly A\n         (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       (\\<And>s.\n           s \\<in> set ss \\<Longrightarrow>\n           zhmset_of \\<epsilon>\\<^sub>h\n           \\<le> eval_tpoly A\n                  (map_tpoly (\\<lambda>x. x) zhmset_of\n                    (wt s))) \\<Longrightarrow>\n       zhmset_of \\<epsilon>\\<^sub>h\n       \\<le> eval_tpoly A\n              (map_tpoly (\\<lambda>x. x) zhmset_of\n                (wt (apps (Hd \\<zeta>) ss)))", "}"], ["proof (state)\nthis:\n  ss \\<noteq> [] \\<Longrightarrow>\n  zhmset_of \\<epsilon>\\<^sub>h\n  \\<le> eval_tpoly A\n         (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       (\\<And>s.\n           s \\<in> set ss \\<Longrightarrow>\n           zhmset_of \\<epsilon>\\<^sub>h\n           \\<le> eval_tpoly A\n                  (map_tpoly (\\<lambda>x. x) zhmset_of\n                    (wt s))) \\<Longrightarrow>\n       zhmset_of \\<epsilon>\\<^sub>h\n       \\<le> eval_tpoly A\n              (map_tpoly (\\<lambda>x. x) zhmset_of\n                (wt (apps (Hd \\<zeta>) ss)))", "ultimately"], ["proof (chain)\npicking this:\n  ss = [] \\<Longrightarrow>\n  zhmset_of \\<epsilon>\\<^sub>h\n  \\<le> eval_tpoly A\n         (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))\n  ss \\<noteq> [] \\<Longrightarrow>\n  zhmset_of \\<epsilon>\\<^sub>h\n  \\<le> eval_tpoly A\n         (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))", "show ?case"], ["proof (prove)\nusing this:\n  ss = [] \\<Longrightarrow>\n  zhmset_of \\<epsilon>\\<^sub>h\n  \\<le> eval_tpoly A\n         (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))\n  ss \\<noteq> [] \\<Longrightarrow>\n  zhmset_of \\<epsilon>\\<^sub>h\n  \\<le> eval_tpoly A\n         (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))\n\ngoal (1 subgoal):\n 1. zhmset_of \\<epsilon>\\<^sub>h\n    \\<le> eval_tpoly A\n           (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))", "by linarith"], ["proof (state)\nthis:\n  zhmset_of \\<epsilon>\\<^sub>h\n  \\<le> eval_tpoly A\n         (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wt_args_ge_length_times_\\<epsilon>\\<^sub>h:\n  assumes legal: \"legal_zpassign A\"\n  shows \"wt_args i A \\<zeta> ss \\<ge> of_nat (length ss) * zhmset_of \\<epsilon>\\<^sub>h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (length ss) * zhmset_of \\<epsilon>\\<^sub>h\n    \\<le> wt_args i A \\<zeta> ss", "unfolding wt_args_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (length ss) * zhmset_of \\<epsilon>\\<^sub>h\n    \\<le> sum_list\n           (map ((\\<lambda>p.\n                     eval_tpoly A\n                      (map_tpoly (\\<lambda>x. x) zhmset_of p)) \\<circ>\n                 (\\<lambda>(s, i). PMult [coef_hd \\<zeta> i, wt s]))\n             (zip ss [i..<i + length ss]))", "by (rule sum_list_ge_length_times[unfolded wt_args_def,\n      of \"map (eval_ztpoly A \\<circ> (\\<lambda>(s, i). PMult [coef_hd \\<zeta> i, wt s])) (zip ss [i..<i + length ss])\",\n      simplified],\n    auto intro!: mult_le_mono_hmset[of 1, simplified] nonneg_le_mult_right_mono_zhmset coef_hd_gt_0\n      simp: legal zero_less_iff_1_le_hmset[symmetric] coef_hd_gt_0 wt_ge_\\<epsilon>\\<^sub>h)"], ["", "lemma wt_ge_\\<delta>\\<^sub>h: \"legal_zpassign A \\<Longrightarrow> eval_ztpoly A (wt s) \\<ge> zhmset_of \\<delta>\\<^sub>h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. legal_zpassign A \\<Longrightarrow>\n    zhmset_of \\<delta>\\<^sub>h\n    \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s))", "using \\<delta>\\<^sub>h_le_\\<epsilon>\\<^sub>h[folded zhmset_of_le] order.trans wt_ge_\\<epsilon>\\<^sub>h zhmset_of_le"], ["proof (prove)\nusing this:\n  zhmset_of \\<delta>\\<^sub>h \\<le> zhmset_of \\<epsilon>\\<^sub>h\n  \\<lbrakk>?a \\<le> ?b; ?b \\<le> ?c\\<rbrakk> \\<Longrightarrow> ?a \\<le> ?c\n  legal_zpassign ?A \\<Longrightarrow>\n  zhmset_of \\<epsilon>\\<^sub>h\n  \\<le> eval_tpoly ?A (map_tpoly (\\<lambda>x. x) zhmset_of (wt ?s))\n  (zhmset_of ?M \\<le> zhmset_of ?N) = (?M \\<le> ?N)\n\ngoal (1 subgoal):\n 1. legal_zpassign A \\<Longrightarrow>\n    zhmset_of \\<delta>\\<^sub>h\n    \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s))", "by blast"], ["", "lemma wt_gt_0: \"legal_zpassign A \\<Longrightarrow> eval_ztpoly A (wt s) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. legal_zpassign A \\<Longrightarrow>\n    0 < eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s))", "using \\<epsilon>\\<^sub>h_gt_0[folded zhmset_of_less, unfolded zhmset_of_0] wt_ge_\\<epsilon>\\<^sub>h"], ["proof (prove)\nusing this:\n  0 < zhmset_of \\<epsilon>\\<^sub>h\n  legal_zpassign ?A \\<Longrightarrow>\n  zhmset_of \\<epsilon>\\<^sub>h\n  \\<le> eval_tpoly ?A (map_tpoly (\\<lambda>x. x) zhmset_of (wt ?s))\n\ngoal (1 subgoal):\n 1. legal_zpassign A \\<Longrightarrow>\n    0 < eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s))", "by (blast intro: less_le_trans)"], ["", "lemma wt_gt_\\<delta>\\<^sub>h_if_superunary:\n  assumes\n    legal: \"legal_zpassign A\" and\n    superunary: \"arity_hd\\<^sub>h (head s) > 1\"\n  shows \"eval_ztpoly A (wt s) > zhmset_of \\<delta>\\<^sub>h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zhmset_of \\<delta>\\<^sub>h\n    < eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s))", "proof (cases \"\\<delta>\\<^sub>h = \\<epsilon>\\<^sub>h\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<delta>\\<^sub>h = \\<epsilon>\\<^sub>h \\<Longrightarrow>\n    zhmset_of \\<delta>\\<^sub>h\n    < eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s))\n 2. \\<delta>\\<^sub>h \\<noteq> \\<epsilon>\\<^sub>h \\<Longrightarrow>\n    zhmset_of \\<delta>\\<^sub>h\n    < eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s))", "case \\<delta>_ne_\\<epsilon>: False"], ["proof (state)\nthis:\n  \\<delta>\\<^sub>h \\<noteq> \\<epsilon>\\<^sub>h\n\ngoal (2 subgoals):\n 1. \\<delta>\\<^sub>h = \\<epsilon>\\<^sub>h \\<Longrightarrow>\n    zhmset_of \\<delta>\\<^sub>h\n    < eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s))\n 2. \\<delta>\\<^sub>h \\<noteq> \\<epsilon>\\<^sub>h \\<Longrightarrow>\n    zhmset_of \\<delta>\\<^sub>h\n    < eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. zhmset_of \\<delta>\\<^sub>h\n    < eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s))", "using order.not_eq_order_implies_strict[OF \\<delta>_ne_\\<epsilon> \\<delta>\\<^sub>h_le_\\<epsilon>\\<^sub>h, folded zhmset_of_less]\n      wt_ge_\\<epsilon>\\<^sub>h[OF legal]"], ["proof (prove)\nusing this:\n  zhmset_of \\<delta>\\<^sub>h < zhmset_of \\<epsilon>\\<^sub>h\n  zhmset_of \\<epsilon>\\<^sub>h\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt ?s))\n\ngoal (1 subgoal):\n 1. zhmset_of \\<delta>\\<^sub>h\n    < eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s))", "by (blast intro: less_le_trans)"], ["proof (state)\nthis:\n  zhmset_of \\<delta>\\<^sub>h\n  < eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s))\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>h = \\<epsilon>\\<^sub>h \\<Longrightarrow>\n    zhmset_of \\<delta>\\<^sub>h\n    < eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>h = \\<epsilon>\\<^sub>h \\<Longrightarrow>\n    zhmset_of \\<delta>\\<^sub>h\n    < eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s))", "case \\<delta>_eq_\\<epsilon>: True"], ["proof (state)\nthis:\n  \\<delta>\\<^sub>h = \\<epsilon>\\<^sub>h\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>h = \\<epsilon>\\<^sub>h \\<Longrightarrow>\n    zhmset_of \\<delta>\\<^sub>h\n    < eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. zhmset_of \\<delta>\\<^sub>h\n    < eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s))", "using superunary"], ["proof (prove)\nusing this:\n  1 < arity_hd\\<^sub>h (head s)\n\ngoal (1 subgoal):\n 1. zhmset_of \\<delta>\\<^sub>h\n    < eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s))", "proof (induct s rule: tm_induct_apps)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>s \\<in> set ss;\n                    1 < arity_hd\\<^sub>h (head s)\\<rbrakk>\n                   \\<Longrightarrow> zhmset_of \\<delta>\\<^sub>h\n                                     < eval_tpoly A\n  (map_tpoly (\\<lambda>x. x) zhmset_of (wt s));\n        1 < arity_hd\\<^sub>h (head (apps (Hd \\<zeta>) ss))\\<rbrakk>\n       \\<Longrightarrow> zhmset_of \\<delta>\\<^sub>h\n                         < eval_tpoly A\n                            (map_tpoly (\\<lambda>x. x) zhmset_of\n                              (wt (apps (Hd \\<zeta>) ss)))", "case (apps \\<zeta> ss)"], ["proof (state)\nthis:\n  \\<lbrakk>?s \\<in> set ss; 1 < arity_hd\\<^sub>h (head ?s)\\<rbrakk>\n  \\<Longrightarrow> zhmset_of \\<delta>\\<^sub>h\n                    < eval_tpoly A\n                       (map_tpoly (\\<lambda>x. x) zhmset_of (wt ?s))\n  1 < arity_hd\\<^sub>h (head (apps (Hd \\<zeta>) ss))\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>s \\<in> set ss;\n                    1 < arity_hd\\<^sub>h (head s)\\<rbrakk>\n                   \\<Longrightarrow> zhmset_of \\<delta>\\<^sub>h\n                                     < eval_tpoly A\n  (map_tpoly (\\<lambda>x. x) zhmset_of (wt s));\n        1 < arity_hd\\<^sub>h (head (apps (Hd \\<zeta>) ss))\\<rbrakk>\n       \\<Longrightarrow> zhmset_of \\<delta>\\<^sub>h\n                         < eval_tpoly A\n                            (map_tpoly (\\<lambda>x. x) zhmset_of\n                              (wt (apps (Hd \\<zeta>) ss)))", "have \"arity_hd\\<^sub>h \\<zeta> > 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 1 < arity_hd\\<^sub>h \\<zeta>", "using apps(2)"], ["proof (prove)\nusing this:\n  1 < arity_hd\\<^sub>h (head (apps (Hd \\<zeta>) ss))\n\ngoal (1 subgoal):\n 1. 1 < arity_hd\\<^sub>h \\<zeta>", "by simp"], ["proof (state)\nthis:\n  1 < arity_hd\\<^sub>h \\<zeta>\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>s \\<in> set ss;\n                    1 < arity_hd\\<^sub>h (head s)\\<rbrakk>\n                   \\<Longrightarrow> zhmset_of \\<delta>\\<^sub>h\n                                     < eval_tpoly A\n  (map_tpoly (\\<lambda>x. x) zhmset_of (wt s));\n        1 < arity_hd\\<^sub>h (head (apps (Hd \\<zeta>) ss))\\<rbrakk>\n       \\<Longrightarrow> zhmset_of \\<delta>\\<^sub>h\n                         < eval_tpoly A\n                            (map_tpoly (\\<lambda>x. x) zhmset_of\n                              (wt (apps (Hd \\<zeta>) ss)))", "hence min_gr_ary: \"arity_sym\\<^sub>h (min_ground_head \\<zeta>) > 1\""], ["proof (prove)\nusing this:\n  1 < arity_hd\\<^sub>h \\<zeta>\n\ngoal (1 subgoal):\n 1. 1 < arity_sym\\<^sub>h (min_ground_head \\<zeta>)", "using ground_heads_arity\\<^sub>h less_le_trans min_ground_head_in_ground_heads"], ["proof (prove)\nusing this:\n  1 < arity_hd\\<^sub>h \\<zeta>\n  ?f \\<in> local.ground_heads ?\\<zeta> \\<Longrightarrow>\n  arity_hd\\<^sub>h ?\\<zeta> \\<le> arity_sym\\<^sub>h ?f\n  \\<lbrakk>?x < ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n  min_ground_head ?\\<zeta> \\<in> local.ground_heads ?\\<zeta>\n\ngoal (1 subgoal):\n 1. 1 < arity_sym\\<^sub>h (min_ground_head \\<zeta>)", "by blast"], ["proof (state)\nthis:\n  1 < arity_sym\\<^sub>h (min_ground_head \\<zeta>)\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>s \\<in> set ss;\n                    1 < arity_hd\\<^sub>h (head s)\\<rbrakk>\n                   \\<Longrightarrow> zhmset_of \\<delta>\\<^sub>h\n                                     < eval_tpoly A\n  (map_tpoly (\\<lambda>x. x) zhmset_of (wt s));\n        1 < arity_hd\\<^sub>h (head (apps (Hd \\<zeta>) ss))\\<rbrakk>\n       \\<Longrightarrow> zhmset_of \\<delta>\\<^sub>h\n                         < eval_tpoly A\n                            (map_tpoly (\\<lambda>x. x) zhmset_of\n                              (wt (apps (Hd \\<zeta>) ss)))", "have \"zhmset_of \\<delta>\\<^sub>h < eval_ztpoly A (wt0 \\<zeta>) + zhmset_of (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zhmset_of \\<delta>\\<^sub>h\n    < eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n      zhmset_of\n       (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))", "unfolding \\<delta>_eq_\\<epsilon>"], ["proof (prove)\ngoal (1 subgoal):\n 1. zhmset_of \\<epsilon>\\<^sub>h\n    < eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n      zhmset_of\n       (\\<epsilon>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))", "by (rule add_strict_increasing2[OF eval_ztpoly_nonneg[OF legal]], unfold zhmset_of_less,\n        rule gt_0_lt_mult_gt_1_hmset[OF \\<epsilon>\\<^sub>h_gt_0 min_gr_ary])"], ["proof (state)\nthis:\n  zhmset_of \\<delta>\\<^sub>h\n  < eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n    zhmset_of\n     (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>s \\<in> set ss;\n                    1 < arity_hd\\<^sub>h (head s)\\<rbrakk>\n                   \\<Longrightarrow> zhmset_of \\<delta>\\<^sub>h\n                                     < eval_tpoly A\n  (map_tpoly (\\<lambda>x. x) zhmset_of (wt s));\n        1 < arity_hd\\<^sub>h (head (apps (Hd \\<zeta>) ss))\\<rbrakk>\n       \\<Longrightarrow> zhmset_of \\<delta>\\<^sub>h\n                         < eval_tpoly A\n                            (map_tpoly (\\<lambda>x. x) zhmset_of\n                              (wt (apps (Hd \\<zeta>) ss)))", "also"], ["proof (state)\nthis:\n  zhmset_of \\<delta>\\<^sub>h\n  < eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n    zhmset_of\n     (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>s \\<in> set ss;\n                    1 < arity_hd\\<^sub>h (head s)\\<rbrakk>\n                   \\<Longrightarrow> zhmset_of \\<delta>\\<^sub>h\n                                     < eval_tpoly A\n  (map_tpoly (\\<lambda>x. x) zhmset_of (wt s));\n        1 < arity_hd\\<^sub>h (head (apps (Hd \\<zeta>) ss))\\<rbrakk>\n       \\<Longrightarrow> zhmset_of \\<delta>\\<^sub>h\n                         < eval_tpoly A\n                            (map_tpoly (\\<lambda>x. x) zhmset_of\n                              (wt (apps (Hd \\<zeta>) ss)))", "have \"\\<dots> \\<le> eval_ztpoly A (wt0 \\<zeta>)\n      + zhmset_of (\\<delta>\\<^sub>h * (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss)))\n        + zhmset_of (of_nat (length ss) * \\<epsilon>\\<^sub>h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n    zhmset_of\n     (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))\n    \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n          zhmset_of\n           (\\<delta>\\<^sub>h *\n            (arity_sym\\<^sub>h (min_ground_head \\<zeta>) -\n             of_nat (length ss))) +\n          zhmset_of (of_nat (length ss) * \\<epsilon>\\<^sub>h)", "by (auto simp: \\<epsilon>\\<^sub>h_gt_0 \\<delta>_eq_\\<epsilon> zmset_of_le zhmset_of_plus[symmetric] algebra_simps\n            simp del: ring_distribs simp: ring_distribs[symmetric])\n        (metis add.commute le_minus_plus_same_hmset)"], ["proof (state)\nthis:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n  zhmset_of (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n        zhmset_of\n         (\\<delta>\\<^sub>h *\n          (arity_sym\\<^sub>h (min_ground_head \\<zeta>) -\n           of_nat (length ss))) +\n        zhmset_of (of_nat (length ss) * \\<epsilon>\\<^sub>h)\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>s \\<in> set ss;\n                    1 < arity_hd\\<^sub>h (head s)\\<rbrakk>\n                   \\<Longrightarrow> zhmset_of \\<delta>\\<^sub>h\n                                     < eval_tpoly A\n  (map_tpoly (\\<lambda>x. x) zhmset_of (wt s));\n        1 < arity_hd\\<^sub>h (head (apps (Hd \\<zeta>) ss))\\<rbrakk>\n       \\<Longrightarrow> zhmset_of \\<delta>\\<^sub>h\n                         < eval_tpoly A\n                            (map_tpoly (\\<lambda>x. x) zhmset_of\n                              (wt (apps (Hd \\<zeta>) ss)))", "also"], ["proof (state)\nthis:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n  zhmset_of (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n        zhmset_of\n         (\\<delta>\\<^sub>h *\n          (arity_sym\\<^sub>h (min_ground_head \\<zeta>) -\n           of_nat (length ss))) +\n        zhmset_of (of_nat (length ss) * \\<epsilon>\\<^sub>h)\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>s \\<in> set ss;\n                    1 < arity_hd\\<^sub>h (head s)\\<rbrakk>\n                   \\<Longrightarrow> zhmset_of \\<delta>\\<^sub>h\n                                     < eval_tpoly A\n  (map_tpoly (\\<lambda>x. x) zhmset_of (wt s));\n        1 < arity_hd\\<^sub>h (head (apps (Hd \\<zeta>) ss))\\<rbrakk>\n       \\<Longrightarrow> zhmset_of \\<delta>\\<^sub>h\n                         < eval_tpoly A\n                            (map_tpoly (\\<lambda>x. x) zhmset_of\n                              (wt (apps (Hd \\<zeta>) ss)))", "have \"\\<dots> \\<le> eval_ztpoly A (wt0 \\<zeta>)\n      + zhmset_of (\\<delta>\\<^sub>h * (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss))) + wt_args 0 A \\<zeta> ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n    zhmset_of\n     (\\<delta>\\<^sub>h *\n      (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss))) +\n    zhmset_of (of_nat (length ss) * \\<epsilon>\\<^sub>h)\n    \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n          zhmset_of\n           (\\<delta>\\<^sub>h *\n            (arity_sym\\<^sub>h (min_ground_head \\<zeta>) -\n             of_nat (length ss))) +\n          wt_args 0 A \\<zeta> ss", "using wt_args_ge_length_times_\\<epsilon>\\<^sub>h[OF legal]"], ["proof (prove)\nusing this:\n  of_nat (length ?ss) * zhmset_of \\<epsilon>\\<^sub>h\n  \\<le> wt_args ?i A ?\\<zeta> ?ss\n\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n    zhmset_of\n     (\\<delta>\\<^sub>h *\n      (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss))) +\n    zhmset_of (of_nat (length ss) * \\<epsilon>\\<^sub>h)\n    \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n          zhmset_of\n           (\\<delta>\\<^sub>h *\n            (arity_sym\\<^sub>h (min_ground_head \\<zeta>) -\n             of_nat (length ss))) +\n          wt_args 0 A \\<zeta> ss", "by (simp add: zhmset_of_times of_nat_zhmset)"], ["proof (state)\nthis:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n  zhmset_of\n   (\\<delta>\\<^sub>h *\n    (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss))) +\n  zhmset_of (of_nat (length ss) * \\<epsilon>\\<^sub>h)\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n        zhmset_of\n         (\\<delta>\\<^sub>h *\n          (arity_sym\\<^sub>h (min_ground_head \\<zeta>) -\n           of_nat (length ss))) +\n        wt_args 0 A \\<zeta> ss\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>s \\<in> set ss;\n                    1 < arity_hd\\<^sub>h (head s)\\<rbrakk>\n                   \\<Longrightarrow> zhmset_of \\<delta>\\<^sub>h\n                                     < eval_tpoly A\n  (map_tpoly (\\<lambda>x. x) zhmset_of (wt s));\n        1 < arity_hd\\<^sub>h (head (apps (Hd \\<zeta>) ss))\\<rbrakk>\n       \\<Longrightarrow> zhmset_of \\<delta>\\<^sub>h\n                         < eval_tpoly A\n                            (map_tpoly (\\<lambda>x. x) zhmset_of\n                              (wt (apps (Hd \\<zeta>) ss)))", "finally"], ["proof (chain)\npicking this:\n  zhmset_of \\<delta>\\<^sub>h\n  < eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n    zhmset_of\n     (\\<delta>\\<^sub>h *\n      (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss))) +\n    wt_args 0 A \\<zeta> ss", "show ?case"], ["proof (prove)\nusing this:\n  zhmset_of \\<delta>\\<^sub>h\n  < eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n    zhmset_of\n     (\\<delta>\\<^sub>h *\n      (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss))) +\n    wt_args 0 A \\<zeta> ss\n\ngoal (1 subgoal):\n 1. zhmset_of \\<delta>\\<^sub>h\n    < eval_tpoly A\n       (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))", "by (simp add: wt_args_def add_ac(1) comp_def)"], ["proof (state)\nthis:\n  zhmset_of \\<delta>\\<^sub>h\n  < eval_tpoly A\n     (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  zhmset_of \\<delta>\\<^sub>h\n  < eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wt_App_plus_\\<delta>\\<^sub>h_ge:\n  \"eval_ztpoly A (wt (App s t)) + zhmset_of \\<delta>\\<^sub>h\n   \\<ge> eval_ztpoly A (wt s) + eval_ztpoly A (coef s 0) * eval_ztpoly A (wt t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) +\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s 0)) *\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n    \\<le> eval_tpoly A\n           (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t))) +\n          zhmset_of \\<delta>\\<^sub>h", "proof (cases s rule: tm_exhaust_apps)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       s = apps (Hd \\<zeta>) ss \\<Longrightarrow>\n       eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) +\n       eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s 0)) *\n       eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n       \\<le> eval_tpoly A\n              (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t))) +\n             zhmset_of \\<delta>\\<^sub>h", "case s: (apps \\<zeta> ss)"], ["proof (state)\nthis:\n  s = apps (Hd \\<zeta>) ss\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       s = apps (Hd \\<zeta>) ss \\<Longrightarrow>\n       eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) +\n       eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s 0)) *\n       eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n       \\<le> eval_tpoly A\n              (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t))) +\n             zhmset_of \\<delta>\\<^sub>h", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) +\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s 0)) *\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n    \\<le> eval_tpoly A\n           (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t))) +\n          zhmset_of \\<delta>\\<^sub>h", "proof (cases \"arity_sym\\<^sub>h (min_ground_head \\<zeta>) = \\<omega>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. arity_sym\\<^sub>h (min_ground_head \\<zeta>) = \\<omega> \\<Longrightarrow>\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) +\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s 0)) *\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n    \\<le> eval_tpoly A\n           (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t))) +\n          zhmset_of \\<delta>\\<^sub>h\n 2. arity_sym\\<^sub>h (min_ground_head \\<zeta>) \\<noteq>\n    \\<omega> \\<Longrightarrow>\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) +\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s 0)) *\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n    \\<le> eval_tpoly A\n           (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t))) +\n          zhmset_of \\<delta>\\<^sub>h", "case ary_eq_\\<omega>: True"], ["proof (state)\nthis:\n  arity_sym\\<^sub>h (min_ground_head \\<zeta>) = \\<omega>\n\ngoal (2 subgoals):\n 1. arity_sym\\<^sub>h (min_ground_head \\<zeta>) = \\<omega> \\<Longrightarrow>\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) +\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s 0)) *\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n    \\<le> eval_tpoly A\n           (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t))) +\n          zhmset_of \\<delta>\\<^sub>h\n 2. arity_sym\\<^sub>h (min_ground_head \\<zeta>) \\<noteq>\n    \\<omega> \\<Longrightarrow>\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) +\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s 0)) *\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n    \\<le> eval_tpoly A\n           (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t))) +\n          zhmset_of \\<delta>\\<^sub>h", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) +\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s 0)) *\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n    \\<le> eval_tpoly A\n           (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t))) +\n          zhmset_of \\<delta>\\<^sub>h", "unfolding ary_eq_\\<omega> s App_apps wt.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_tpoly A\n     (map_tpoly (\\<lambda>x. x) zhmset_of\n       (PSum\n         ([wt0 \\<zeta>,\n           PNum (\\<delta>\\<^sub>h * (\\<omega> - of_nat (length ss)))] @\n          map2 (\\<lambda>s i. PMult [coef_hd \\<zeta> i, wt s]) ss\n           [0..<length ss]))) +\n    eval_tpoly A\n     (map_tpoly (\\<lambda>x. x) zhmset_of (coef (apps (Hd \\<zeta>) ss) 0)) *\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n    \\<le> eval_tpoly A\n           (map_tpoly (\\<lambda>x. x) zhmset_of\n             (PSum\n               ([wt0 \\<zeta>,\n                 PNum\n                  (\\<delta>\\<^sub>h *\n                   (\\<omega> - of_nat (length (ss @ [t]))))] @\n                map2 (\\<lambda>s i. PMult [coef_hd \\<zeta> i, wt s])\n                 (ss @ [t]) [0..<length (ss @ [t])]))) +\n          zhmset_of \\<delta>\\<^sub>h", "by (auto simp: diff_diff_add_hmset[symmetric] add.assoc)"], ["proof (state)\nthis:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) +\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s 0)) *\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t))) +\n        zhmset_of \\<delta>\\<^sub>h\n\ngoal (1 subgoal):\n 1. arity_sym\\<^sub>h (min_ground_head \\<zeta>) \\<noteq>\n    \\<omega> \\<Longrightarrow>\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) +\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s 0)) *\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n    \\<le> eval_tpoly A\n           (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t))) +\n          zhmset_of \\<delta>\\<^sub>h", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. arity_sym\\<^sub>h (min_ground_head \\<zeta>) \\<noteq>\n    \\<omega> \\<Longrightarrow>\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) +\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s 0)) *\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n    \\<le> eval_tpoly A\n           (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t))) +\n          zhmset_of \\<delta>\\<^sub>h", "case False"], ["proof (state)\nthis:\n  arity_sym\\<^sub>h (min_ground_head \\<zeta>) \\<noteq> \\<omega>\n\ngoal (1 subgoal):\n 1. arity_sym\\<^sub>h (min_ground_head \\<zeta>) \\<noteq>\n    \\<omega> \\<Longrightarrow>\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) +\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s 0)) *\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n    \\<le> eval_tpoly A\n           (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t))) +\n          zhmset_of \\<delta>\\<^sub>h", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) +\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s 0)) *\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n    \\<le> eval_tpoly A\n           (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t))) +\n          zhmset_of \\<delta>\\<^sub>h", "unfolding s App_apps wt.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_tpoly A\n     (map_tpoly (\\<lambda>x. x) zhmset_of\n       (PSum\n         ([wt0 \\<zeta>,\n           PNum\n            (\\<delta>\\<^sub>h *\n             (arity_sym\\<^sub>h (min_ground_head \\<zeta>) -\n              of_nat (length ss)))] @\n          map2 (\\<lambda>s i. PMult [coef_hd \\<zeta> i, wt s]) ss\n           [0..<length ss]))) +\n    eval_tpoly A\n     (map_tpoly (\\<lambda>x. x) zhmset_of (coef (apps (Hd \\<zeta>) ss) 0)) *\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n    \\<le> eval_tpoly A\n           (map_tpoly (\\<lambda>x. x) zhmset_of\n             (PSum\n               ([wt0 \\<zeta>,\n                 PNum\n                  (\\<delta>\\<^sub>h *\n                   (arity_sym\\<^sub>h (min_ground_head \\<zeta>) -\n                    of_nat (length (ss @ [t]))))] @\n                map2 (\\<lambda>s i. PMult [coef_hd \\<zeta> i, wt s])\n                 (ss @ [t]) [0..<length (ss @ [t])]))) +\n          zhmset_of \\<delta>\\<^sub>h", "by (simp add: algebra_simps zhmset_of_plus[symmetric] zmset_of_le,\n        simp del: diff_diff_add_hmset add: add.commute[of 1] le_minus_plus_same_hmset\n          distrib_left[of _ \"1 :: hmultiset\", unfolded mult.right_neutral, symmetric]\n          diff_diff_add_hmset[symmetric])"], ["proof (state)\nthis:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) +\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s 0)) *\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t))) +\n        zhmset_of \\<delta>\\<^sub>h\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) +\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s 0)) *\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t))) +\n        zhmset_of \\<delta>\\<^sub>h\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wt_App_fun_\\<delta>\\<^sub>h:\n  assumes\n    legal: \"legal_zpassign A\" and\n    wt_st: \"eval_ztpoly A (wt (App s t)) = eval_ztpoly A (wt t)\"\n  shows \"eval_ztpoly A (wt s) = zhmset_of \\<delta>\\<^sub>h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) =\n    zhmset_of \\<delta>\\<^sub>h", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) =\n    zhmset_of \\<delta>\\<^sub>h", "have \"eval_ztpoly A (wt (App s t)) = eval_ztpoly A (wt t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t))) =\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))", "using wt_st"], ["proof (prove)\nusing this:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t))) =\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t))) =\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))", "by simp"], ["proof (state)\nthis:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t))) =\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) =\n    zhmset_of \\<delta>\\<^sub>h", "hence wt_s_t_le_\\<delta>_t: \"eval_ztpoly A (wt s) + eval_ztpoly A (coef s 0) * eval_ztpoly A (wt t)\n     \\<le> zhmset_of \\<delta>\\<^sub>h + eval_ztpoly A (wt t)\""], ["proof (prove)\nusing this:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t))) =\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) +\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s 0)) *\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n    \\<le> zhmset_of \\<delta>\\<^sub>h +\n          eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))", "using wt_App_plus_\\<delta>\\<^sub>h_ge"], ["proof (prove)\nusing this:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t))) =\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n  eval_tpoly ?A (map_tpoly (\\<lambda>x. x) zhmset_of (wt ?s)) +\n  eval_tpoly ?A (map_tpoly (\\<lambda>x. x) zhmset_of (coef ?s 0)) *\n  eval_tpoly ?A (map_tpoly (\\<lambda>x. x) zhmset_of (wt ?t))\n  \\<le> eval_tpoly ?A\n         (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App ?s ?t))) +\n        zhmset_of \\<delta>\\<^sub>h\n\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) +\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s 0)) *\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n    \\<le> zhmset_of \\<delta>\\<^sub>h +\n          eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))", "by (metis add.commute)"], ["proof (state)\nthis:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) +\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s 0)) *\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n  \\<le> zhmset_of \\<delta>\\<^sub>h +\n        eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) =\n    zhmset_of \\<delta>\\<^sub>h", "also"], ["proof (state)\nthis:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) +\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s 0)) *\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n  \\<le> zhmset_of \\<delta>\\<^sub>h +\n        eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) =\n    zhmset_of \\<delta>\\<^sub>h", "have \"\\<dots> \\<le> eval_ztpoly A (wt s) + eval_ztpoly A (wt t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zhmset_of \\<delta>\\<^sub>h +\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n    \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) +\n          eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))", "using wt_ge_\\<delta>\\<^sub>h[OF legal]"], ["proof (prove)\nusing this:\n  zhmset_of \\<delta>\\<^sub>h\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt ?s))\n\ngoal (1 subgoal):\n 1. zhmset_of \\<delta>\\<^sub>h +\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n    \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) +\n          eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))", "by simp"], ["proof (state)\nthis:\n  zhmset_of \\<delta>\\<^sub>h +\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) +\n        eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) =\n    zhmset_of \\<delta>\\<^sub>h", "finally"], ["proof (chain)\npicking this:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) +\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s 0)) *\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) +\n        eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))", "have \"eval_ztpoly A (coef s 0) * eval_ztpoly A (wt t) \\<le> eval_ztpoly A (wt t)\""], ["proof (prove)\nusing this:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) +\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s 0)) *\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) +\n        eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s 0)) *\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n    \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))", "by simp"], ["proof (state)\nthis:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s 0)) *\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) =\n    zhmset_of \\<delta>\\<^sub>h", "hence \"eval_ztpoly A (coef s 0) = 1\""], ["proof (prove)\nusing this:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s 0)) *\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s 0)) = 1", "using eval_ztpoly_nonneg[OF legal]"], ["proof (prove)\nusing this:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s 0)) *\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n  0 \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of ?p)\n\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s 0)) = 1", "by (metis (no_types, lifting) coef_gt_0 dual_order.order_iff_strict leD legal mult_cancel_right1\n      nonneg_le_mult_right_mono_zhmset wt_gt_0)"], ["proof (state)\nthis:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s 0)) = 1\n\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) =\n    zhmset_of \\<delta>\\<^sub>h", "thus ?thesis"], ["proof (prove)\nusing this:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s 0)) = 1\n\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) =\n    zhmset_of \\<delta>\\<^sub>h", "using wt_s_t_le_\\<delta>_t"], ["proof (prove)\nusing this:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s 0)) = 1\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) +\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s 0)) *\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n  \\<le> zhmset_of \\<delta>\\<^sub>h +\n        eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) =\n    zhmset_of \\<delta>\\<^sub>h", "by (simp add: add.commute antisym wt_ge_\\<delta>\\<^sub>h[OF legal])"], ["proof (state)\nthis:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) =\n  zhmset_of \\<delta>\\<^sub>h\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wt_App_arg_\\<delta>\\<^sub>h:\n  assumes\n    legal: \"legal_zpassign A\" and\n    wt_st: \"eval_ztpoly A (wt (App s t)) = eval_ztpoly A (wt s)\"\n  shows \"eval_ztpoly A (wt t) = zhmset_of \\<delta>\\<^sub>h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t)) =\n    zhmset_of \\<delta>\\<^sub>h", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t)) =\n    zhmset_of \\<delta>\\<^sub>h", "have \"eval_ztpoly A (wt (App s t)) + zhmset_of \\<delta>\\<^sub>h = eval_ztpoly A (wt s) + zhmset_of \\<delta>\\<^sub>h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t))) +\n    zhmset_of \\<delta>\\<^sub>h =\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) +\n    zhmset_of \\<delta>\\<^sub>h", "using wt_st"], ["proof (prove)\nusing this:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t))) =\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s))\n\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t))) +\n    zhmset_of \\<delta>\\<^sub>h =\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) +\n    zhmset_of \\<delta>\\<^sub>h", "by simp"], ["proof (state)\nthis:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t))) +\n  zhmset_of \\<delta>\\<^sub>h =\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) +\n  zhmset_of \\<delta>\\<^sub>h\n\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t)) =\n    zhmset_of \\<delta>\\<^sub>h", "hence \"eval_ztpoly A (coef s 0) * eval_ztpoly A (wt t) \\<le> zhmset_of \\<delta>\\<^sub>h\" (is \"?k * ?w \\<le> _\")"], ["proof (prove)\nusing this:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t))) +\n  zhmset_of \\<delta>\\<^sub>h =\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) +\n  zhmset_of \\<delta>\\<^sub>h\n\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s 0)) *\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n    \\<le> zhmset_of \\<delta>\\<^sub>h", "by (metis add_le_cancel_left wt_App_plus_\\<delta>\\<^sub>h_ge)"], ["proof (state)\nthis:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s 0)) *\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n  \\<le> zhmset_of \\<delta>\\<^sub>h\n\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t)) =\n    zhmset_of \\<delta>\\<^sub>h", "hence \"?k * ?w = zhmset_of \\<delta>\\<^sub>h\""], ["proof (prove)\nusing this:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s 0)) *\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n  \\<le> zhmset_of \\<delta>\\<^sub>h\n\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s 0)) *\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t)) =\n    zhmset_of \\<delta>\\<^sub>h", "using wt_ge_\\<delta>\\<^sub>h[OF legal] coef_gt_0[OF legal, unfolded zero_less_iff_1_le_hmset]"], ["proof (prove)\nusing this:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s 0)) *\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n  \\<le> zhmset_of \\<delta>\\<^sub>h\n  zhmset_of \\<delta>\\<^sub>h\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt ?s))\n  0 < eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef ?s ?i))\n\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s 0)) *\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t)) =\n    zhmset_of \\<delta>\\<^sub>h", "by (simp add: antisym nonneg_le_mult_right_mono_zhmset)"], ["proof (state)\nthis:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s 0)) *\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t)) =\n  zhmset_of \\<delta>\\<^sub>h\n\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t)) =\n    zhmset_of \\<delta>\\<^sub>h", "hence \"?w \\<le> zhmset_of \\<delta>\\<^sub>h\""], ["proof (prove)\nusing this:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s 0)) *\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t)) =\n  zhmset_of \\<delta>\\<^sub>h\n\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n    \\<le> zhmset_of \\<delta>\\<^sub>h", "by (metis coef_gt_0[OF legal] dual_order.order_iff_strict eval_ztpoly_nonneg[OF legal]\n      nonneg_le_mult_right_mono_zhmset)"], ["proof (state)\nthis:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n  \\<le> zhmset_of \\<delta>\\<^sub>h\n\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t)) =\n    zhmset_of \\<delta>\\<^sub>h", "thus ?thesis"], ["proof (prove)\nusing this:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n  \\<le> zhmset_of \\<delta>\\<^sub>h\n\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t)) =\n    zhmset_of \\<delta>\\<^sub>h", "by (simp add: antisym wt_ge_\\<delta>\\<^sub>h[OF legal])"], ["proof (state)\nthis:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t)) =\n  zhmset_of \\<delta>\\<^sub>h\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wt_App_ge_fun: \"wt (App s t) \\<ge>\\<^sub>p wt s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wt (App s t) \\<ge>\\<^sub>p wt s", "unfolding ge_tpoly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A.\n       legal_zpassign A \\<longrightarrow>\n       eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s))\n       \\<le> eval_tpoly A\n              (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t)))", "proof clarify"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       legal_zpassign A \\<Longrightarrow>\n       eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s))\n       \\<le> eval_tpoly A\n              (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t)))", "fix A"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>A.\n       legal_zpassign A \\<Longrightarrow>\n       eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s))\n       \\<le> eval_tpoly A\n              (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t)))", "assume legal: \"legal_zpassign A\""], ["proof (state)\nthis:\n  legal_zpassign A\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       legal_zpassign A \\<Longrightarrow>\n       eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s))\n       \\<le> eval_tpoly A\n              (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t)))", "have \"zhmset_of \\<delta>\\<^sub>h \\<le> eval_ztpoly A (coef s 0) * eval_ztpoly A (wt t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zhmset_of \\<delta>\\<^sub>h\n    \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s 0)) *\n          eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))", "by (simp add: coef_gt_0 legal nonneg_le_mult_right_mono_zhmset wt_ge_\\<delta>\\<^sub>h)"], ["proof (state)\nthis:\n  zhmset_of \\<delta>\\<^sub>h\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s 0)) *\n        eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       legal_zpassign A \\<Longrightarrow>\n       eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s))\n       \\<le> eval_tpoly A\n              (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t)))", "hence \"eval_ztpoly A (wt s) + zhmset_of \\<delta>\\<^sub>h \\<le> eval_ztpoly A (wt (App s t)) + zhmset_of \\<delta>\\<^sub>h\""], ["proof (prove)\nusing this:\n  zhmset_of \\<delta>\\<^sub>h\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef s 0)) *\n        eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) +\n    zhmset_of \\<delta>\\<^sub>h\n    \\<le> eval_tpoly A\n           (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t))) +\n          zhmset_of \\<delta>\\<^sub>h", "by (metis add_le_cancel_right add_less_le_mono not_le wt_App_plus_\\<delta>\\<^sub>h_ge)"], ["proof (state)\nthis:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) +\n  zhmset_of \\<delta>\\<^sub>h\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t))) +\n        zhmset_of \\<delta>\\<^sub>h\n\ngoal (1 subgoal):\n 1. \\<And>A.\n       legal_zpassign A \\<Longrightarrow>\n       eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s))\n       \\<le> eval_tpoly A\n              (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t)))", "thus \"eval_ztpoly A (wt s) \\<le> eval_ztpoly A (wt (App s t))\""], ["proof (prove)\nusing this:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) +\n  zhmset_of \\<delta>\\<^sub>h\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t))) +\n        zhmset_of \\<delta>\\<^sub>h\n\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s))\n    \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t)))", "by simp"], ["proof (state)\nthis:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s))\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wt_App_ge_arg: \"wt (App s t) \\<ge>\\<^sub>p wt t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wt (App s t) \\<ge>\\<^sub>p wt t", "unfolding ge_tpoly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>A.\n       legal_zpassign A \\<longrightarrow>\n       eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n       \\<le> eval_tpoly A\n              (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t)))", "by (cases s rule: tm_exhaust_apps, simp, unfold App_apps wt.simps)\n    (auto simp: comp_def coef_hd_gt_0 eval_ztpoly_nonneg nonneg_le_mult_right_mono_zhmset\n       intro!: sum_list_nonneg eval_ztpoly_nonneg add_increasing)"], ["", "lemma wt_\\<delta>\\<^sub>h_imp_\\<delta>\\<^sub>h_eq_\\<epsilon>\\<^sub>h:\n  assumes\n    legal: \"legal_zpassign A\" and\n    wt_s_eq_\\<delta>: \"eval_ztpoly A (wt s) = zhmset_of \\<delta>\\<^sub>h\"\n  shows \"\\<delta>\\<^sub>h = \\<epsilon>\\<^sub>h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>h = \\<epsilon>\\<^sub>h", "using \\<delta>\\<^sub>h_le_\\<epsilon>\\<^sub>h wt_ge_\\<epsilon>\\<^sub>h[OF legal, of s, unfolded wt_s_eq_\\<delta> zhmset_of_le]"], ["proof (prove)\nusing this:\n  \\<delta>\\<^sub>h \\<le> \\<epsilon>\\<^sub>h\n  \\<epsilon>\\<^sub>h \\<le> \\<delta>\\<^sub>h\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>h = \\<epsilon>\\<^sub>h", "by (rule antisym)"], ["", "lemma wt_ge_vars: \"wt t \\<ge>\\<^sub>p wt s \\<Longrightarrow> vars t \\<supseteq> vars s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wt t \\<ge>\\<^sub>p wt s \\<Longrightarrow> vars s \\<subseteq> vars t", "proof (induct s)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       wt t \\<ge>\\<^sub>p wt (Hd x) \\<Longrightarrow>\n       vars (Hd x) \\<subseteq> vars t\n 2. \\<And>s1 s2.\n       \\<lbrakk>wt t \\<ge>\\<^sub>p wt s1 \\<Longrightarrow>\n                vars s1 \\<subseteq> vars t;\n        wt t \\<ge>\\<^sub>p wt s2 \\<Longrightarrow>\n        vars s2 \\<subseteq> vars t;\n        wt t \\<ge>\\<^sub>p wt (App s1 s2)\\<rbrakk>\n       \\<Longrightarrow> vars (App s1 s2) \\<subseteq> vars t", "case t: (Hd \\<zeta>)"], ["proof (state)\nthis:\n  wt t \\<ge>\\<^sub>p wt (Hd \\<zeta>)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       wt t \\<ge>\\<^sub>p wt (Hd x) \\<Longrightarrow>\n       vars (Hd x) \\<subseteq> vars t\n 2. \\<And>s1 s2.\n       \\<lbrakk>wt t \\<ge>\\<^sub>p wt s1 \\<Longrightarrow>\n                vars s1 \\<subseteq> vars t;\n        wt t \\<ge>\\<^sub>p wt s2 \\<Longrightarrow>\n        vars s2 \\<subseteq> vars t;\n        wt t \\<ge>\\<^sub>p wt (App s1 s2)\\<rbrakk>\n       \\<Longrightarrow> vars (App s1 s2) \\<subseteq> vars t", "note wt_ge_\\<zeta> = this(1)"], ["proof (state)\nthis:\n  wt t \\<ge>\\<^sub>p wt (Hd \\<zeta>)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       wt t \\<ge>\\<^sub>p wt (Hd x) \\<Longrightarrow>\n       vars (Hd x) \\<subseteq> vars t\n 2. \\<And>s1 s2.\n       \\<lbrakk>wt t \\<ge>\\<^sub>p wt s1 \\<Longrightarrow>\n                vars s1 \\<subseteq> vars t;\n        wt t \\<ge>\\<^sub>p wt s2 \\<Longrightarrow>\n        vars s2 \\<subseteq> vars t;\n        wt t \\<ge>\\<^sub>p wt (App s1 s2)\\<rbrakk>\n       \\<Longrightarrow> vars (App s1 s2) \\<subseteq> vars t", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars (Hd \\<zeta>) \\<subseteq> vars t", "proof (cases \\<zeta>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<zeta> = Var x1 \\<Longrightarrow>\n       vars (Hd \\<zeta>) \\<subseteq> vars t\n 2. \\<And>x2.\n       \\<zeta> = Sym x2 \\<Longrightarrow>\n       vars (Hd \\<zeta>) \\<subseteq> vars t", "case \\<zeta>: (Var x)"], ["proof (state)\nthis:\n  \\<zeta> = Var x\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<zeta> = Var x1 \\<Longrightarrow>\n       vars (Hd \\<zeta>) \\<subseteq> vars t\n 2. \\<And>x2.\n       \\<zeta> = Sym x2 \\<Longrightarrow>\n       vars (Hd \\<zeta>) \\<subseteq> vars t", "{"], ["proof (state)\nthis:\n  \\<zeta> = Var x\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<zeta> = Var x1 \\<Longrightarrow>\n       vars (Hd \\<zeta>) \\<subseteq> vars t\n 2. \\<And>x2.\n       \\<zeta> = Sym x2 \\<Longrightarrow>\n       vars (Hd \\<zeta>) \\<subseteq> vars t", "assume z_ni_t: \"x \\<notin> vars t\""], ["proof (state)\nthis:\n  x \\<notin> vars t\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<zeta> = Var x1 \\<Longrightarrow>\n       vars (Hd \\<zeta>) \\<subseteq> vars t\n 2. \\<And>x2.\n       \\<zeta> = Sym x2 \\<Longrightarrow>\n       vars (Hd \\<zeta>) \\<subseteq> vars t", "let ?A = min_zpassign"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<zeta> = Var x1 \\<Longrightarrow>\n       vars (Hd \\<zeta>) \\<subseteq> vars t\n 2. \\<And>x2.\n       \\<zeta> = Sym x2 \\<Longrightarrow>\n       vars (Hd \\<zeta>) \\<subseteq> vars t", "let ?B = \"\\<lambda>v. if v = PWt x then eval_ztpoly ?A (wt t) + ?A v + 1 else ?A v\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<zeta> = Var x1 \\<Longrightarrow>\n       vars (Hd \\<zeta>) \\<subseteq> vars t\n 2. \\<And>x2.\n       \\<zeta> = Sym x2 \\<Longrightarrow>\n       vars (Hd \\<zeta>) \\<subseteq> vars t", "have legal_B: \"legal_zpassign ?B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. legal_zpassign\n     (\\<lambda>v.\n         if v = PWt x\n         then eval_tpoly (\\<lambda>v. zhmset_of (min_passign v))\n               (map_tpoly (\\<lambda>x. x) zhmset_of (wt t)) +\n              zhmset_of (min_passign v) +\n              1\n         else zhmset_of (min_passign v))", "unfolding legal_zpassign_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>xa.\n       zhmset_of (min_passign xa)\n       \\<le> (if xa = PWt x\n              then eval_tpoly (\\<lambda>v. zhmset_of (min_passign v))\n                    (map_tpoly (\\<lambda>x. x) zhmset_of (wt t)) +\n                   zhmset_of (min_passign xa) +\n                   1\n              else zhmset_of (min_passign xa))", "by (auto simp: legal_min_zpassign intro!: add_increasing eval_ztpoly_nonneg)"], ["proof (state)\nthis:\n  legal_zpassign\n   (\\<lambda>v.\n       if v = PWt x\n       then eval_tpoly (\\<lambda>v. zhmset_of (min_passign v))\n             (map_tpoly (\\<lambda>x. x) zhmset_of (wt t)) +\n            zhmset_of (min_passign v) +\n            1\n       else zhmset_of (min_passign v))\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<zeta> = Var x1 \\<Longrightarrow>\n       vars (Hd \\<zeta>) \\<subseteq> vars t\n 2. \\<And>x2.\n       \\<zeta> = Sym x2 \\<Longrightarrow>\n       vars (Hd \\<zeta>) \\<subseteq> vars t", "have eval_B_eq_A: \"eval_ztpoly ?B (wt t) = eval_ztpoly ?A (wt t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_tpoly\n     (\\<lambda>v.\n         if v = PWt x\n         then eval_tpoly (\\<lambda>v. zhmset_of (min_passign v))\n               (map_tpoly (\\<lambda>x. x) zhmset_of (wt t)) +\n              zhmset_of (min_passign v) +\n              1\n         else zhmset_of (min_passign v))\n     (map_tpoly (\\<lambda>x. x) zhmset_of (wt t)) =\n    eval_tpoly (\\<lambda>v. zhmset_of (min_passign v))\n     (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))", "by (rule wt_cong) (auto simp: z_ni_t)"], ["proof (state)\nthis:\n  eval_tpoly\n   (\\<lambda>v.\n       if v = PWt x\n       then eval_tpoly (\\<lambda>v. zhmset_of (min_passign v))\n             (map_tpoly (\\<lambda>x. x) zhmset_of (wt t)) +\n            zhmset_of (min_passign v) +\n            1\n       else zhmset_of (min_passign v))\n   (map_tpoly (\\<lambda>x. x) zhmset_of (wt t)) =\n  eval_tpoly (\\<lambda>v. zhmset_of (min_passign v))\n   (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<zeta> = Var x1 \\<Longrightarrow>\n       vars (Hd \\<zeta>) \\<subseteq> vars t\n 2. \\<And>x2.\n       \\<zeta> = Sym x2 \\<Longrightarrow>\n       vars (Hd \\<zeta>) \\<subseteq> vars t", "have \"eval_ztpoly ?B (wt (Hd (Var x))) > eval_ztpoly ?B (wt t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_tpoly\n     (\\<lambda>v.\n         if v = PWt x\n         then eval_tpoly (\\<lambda>v. zhmset_of (min_passign v))\n               (map_tpoly (\\<lambda>x. x) zhmset_of (wt t)) +\n              zhmset_of (min_passign v) +\n              1\n         else zhmset_of (min_passign v))\n     (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n    < eval_tpoly\n       (\\<lambda>v.\n           if v = PWt x\n           then eval_tpoly (\\<lambda>v. zhmset_of (min_passign v))\n                 (map_tpoly (\\<lambda>x. x) zhmset_of (wt t)) +\n                zhmset_of (min_passign v) +\n                1\n           else zhmset_of (min_passign v))\n       (map_tpoly (\\<lambda>x. x) zhmset_of (wt (Hd (Var x))))", "by (auto simp: eval_B_eq_A zero_less_iff_1_le_zhmset zhmset_of_plus[symmetric]\n          algebra_simps)"], ["proof (state)\nthis:\n  eval_tpoly\n   (\\<lambda>v.\n       if v = PWt x\n       then eval_tpoly (\\<lambda>v. zhmset_of (min_passign v))\n             (map_tpoly (\\<lambda>x. x) zhmset_of (wt t)) +\n            zhmset_of (min_passign v) +\n            1\n       else zhmset_of (min_passign v))\n   (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n  < eval_tpoly\n     (\\<lambda>v.\n         if v = PWt x\n         then eval_tpoly (\\<lambda>v. zhmset_of (min_passign v))\n               (map_tpoly (\\<lambda>x. x) zhmset_of (wt t)) +\n              zhmset_of (min_passign v) +\n              1\n         else zhmset_of (min_passign v))\n     (map_tpoly (\\<lambda>x. x) zhmset_of (wt (Hd (Var x))))\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<zeta> = Var x1 \\<Longrightarrow>\n       vars (Hd \\<zeta>) \\<subseteq> vars t\n 2. \\<And>x2.\n       \\<zeta> = Sym x2 \\<Longrightarrow>\n       vars (Hd \\<zeta>) \\<subseteq> vars t", "hence False"], ["proof (prove)\nusing this:\n  eval_tpoly\n   (\\<lambda>v.\n       if v = PWt x\n       then eval_tpoly (\\<lambda>v. zhmset_of (min_passign v))\n             (map_tpoly (\\<lambda>x. x) zhmset_of (wt t)) +\n            zhmset_of (min_passign v) +\n            1\n       else zhmset_of (min_passign v))\n   (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n  < eval_tpoly\n     (\\<lambda>v.\n         if v = PWt x\n         then eval_tpoly (\\<lambda>v. zhmset_of (min_passign v))\n               (map_tpoly (\\<lambda>x. x) zhmset_of (wt t)) +\n              zhmset_of (min_passign v) +\n              1\n         else zhmset_of (min_passign v))\n     (map_tpoly (\\<lambda>x. x) zhmset_of (wt (Hd (Var x))))\n\ngoal (1 subgoal):\n 1. False", "using wt_ge_\\<zeta> \\<zeta>"], ["proof (prove)\nusing this:\n  eval_tpoly\n   (\\<lambda>v.\n       if v = PWt x\n       then eval_tpoly (\\<lambda>v. zhmset_of (min_passign v))\n             (map_tpoly (\\<lambda>x. x) zhmset_of (wt t)) +\n            zhmset_of (min_passign v) +\n            1\n       else zhmset_of (min_passign v))\n   (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n  < eval_tpoly\n     (\\<lambda>v.\n         if v = PWt x\n         then eval_tpoly (\\<lambda>v. zhmset_of (min_passign v))\n               (map_tpoly (\\<lambda>x. x) zhmset_of (wt t)) +\n              zhmset_of (min_passign v) +\n              1\n         else zhmset_of (min_passign v))\n     (map_tpoly (\\<lambda>x. x) zhmset_of (wt (Hd (Var x))))\n  wt t \\<ge>\\<^sub>p wt (Hd \\<zeta>)\n  \\<zeta> = Var x\n\ngoal (1 subgoal):\n 1. False", "unfolding ge_tpoly_def"], ["proof (prove)\nusing this:\n  eval_tpoly\n   (\\<lambda>v.\n       if v = PWt x\n       then eval_tpoly (\\<lambda>v. zhmset_of (min_passign v))\n             (map_tpoly (\\<lambda>x. x) zhmset_of (wt t)) +\n            zhmset_of (min_passign v) +\n            1\n       else zhmset_of (min_passign v))\n   (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n  < eval_tpoly\n     (\\<lambda>v.\n         if v = PWt x\n         then eval_tpoly (\\<lambda>v. zhmset_of (min_passign v))\n               (map_tpoly (\\<lambda>x. x) zhmset_of (wt t)) +\n              zhmset_of (min_passign v) +\n              1\n         else zhmset_of (min_passign v))\n     (map_tpoly (\\<lambda>x. x) zhmset_of (wt (Hd (Var x))))\n  \\<forall>A.\n     legal_zpassign A \\<longrightarrow>\n     eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt (Hd \\<zeta>)))\n     \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n  \\<zeta> = Var x\n\ngoal (1 subgoal):\n 1. False", "by (blast dest: leD intro: legal_B legal_min_zpassign)"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<zeta> = Var x1 \\<Longrightarrow>\n       vars (Hd \\<zeta>) \\<subseteq> vars t\n 2. \\<And>x2.\n       \\<zeta> = Sym x2 \\<Longrightarrow>\n       vars (Hd \\<zeta>) \\<subseteq> vars t", "}"], ["proof (state)\nthis:\n  x \\<notin> vars t \\<Longrightarrow> False\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<zeta> = Var x1 \\<Longrightarrow>\n       vars (Hd \\<zeta>) \\<subseteq> vars t\n 2. \\<And>x2.\n       \\<zeta> = Sym x2 \\<Longrightarrow>\n       vars (Hd \\<zeta>) \\<subseteq> vars t", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<notin> vars t \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. vars (Hd \\<zeta>) \\<subseteq> vars t", "by (auto simp: \\<zeta>)"], ["proof (state)\nthis:\n  vars (Hd \\<zeta>) \\<subseteq> vars t\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<zeta> = Sym x2 \\<Longrightarrow>\n       vars (Hd \\<zeta>) \\<subseteq> vars t", "qed simp"], ["proof (state)\nthis:\n  vars (Hd \\<zeta>) \\<subseteq> vars t\n\ngoal (1 subgoal):\n 1. \\<And>s1 s2.\n       \\<lbrakk>wt t \\<ge>\\<^sub>p wt s1 \\<Longrightarrow>\n                vars s1 \\<subseteq> vars t;\n        wt t \\<ge>\\<^sub>p wt s2 \\<Longrightarrow>\n        vars s2 \\<subseteq> vars t;\n        wt t \\<ge>\\<^sub>p wt (App s1 s2)\\<rbrakk>\n       \\<Longrightarrow> vars (App s1 s2) \\<subseteq> vars t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s1 s2.\n       \\<lbrakk>wt t \\<ge>\\<^sub>p wt s1 \\<Longrightarrow>\n                vars s1 \\<subseteq> vars t;\n        wt t \\<ge>\\<^sub>p wt s2 \\<Longrightarrow>\n        vars s2 \\<subseteq> vars t;\n        wt t \\<ge>\\<^sub>p wt (App s1 s2)\\<rbrakk>\n       \\<Longrightarrow> vars (App s1 s2) \\<subseteq> vars t", "case (App s1 s2)"], ["proof (state)\nthis:\n  wt t \\<ge>\\<^sub>p wt s1 \\<Longrightarrow> vars s1 \\<subseteq> vars t\n  wt t \\<ge>\\<^sub>p wt s2 \\<Longrightarrow> vars s2 \\<subseteq> vars t\n  wt t \\<ge>\\<^sub>p wt (App s1 s2)\n\ngoal (1 subgoal):\n 1. \\<And>s1 s2.\n       \\<lbrakk>wt t \\<ge>\\<^sub>p wt s1 \\<Longrightarrow>\n                vars s1 \\<subseteq> vars t;\n        wt t \\<ge>\\<^sub>p wt s2 \\<Longrightarrow>\n        vars s2 \\<subseteq> vars t;\n        wt t \\<ge>\\<^sub>p wt (App s1 s2)\\<rbrakk>\n       \\<Longrightarrow> vars (App s1 s2) \\<subseteq> vars t", "note ih1 = this(1) and ih2 = this(2) and wt_t_ge_wt_s1s2 = this(3)"], ["proof (state)\nthis:\n  wt t \\<ge>\\<^sub>p wt s1 \\<Longrightarrow> vars s1 \\<subseteq> vars t\n  wt t \\<ge>\\<^sub>p wt s2 \\<Longrightarrow> vars s2 \\<subseteq> vars t\n  wt t \\<ge>\\<^sub>p wt (App s1 s2)\n\ngoal (1 subgoal):\n 1. \\<And>s1 s2.\n       \\<lbrakk>wt t \\<ge>\\<^sub>p wt s1 \\<Longrightarrow>\n                vars s1 \\<subseteq> vars t;\n        wt t \\<ge>\\<^sub>p wt s2 \\<Longrightarrow>\n        vars s2 \\<subseteq> vars t;\n        wt t \\<ge>\\<^sub>p wt (App s1 s2)\\<rbrakk>\n       \\<Longrightarrow> vars (App s1 s2) \\<subseteq> vars t", "have \"vars s1 \\<subseteq> vars t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars s1 \\<subseteq> vars t", "using ih1 wt_t_ge_wt_s1s2 wt_App_ge_fun order_trans"], ["proof (prove)\nusing this:\n  wt t \\<ge>\\<^sub>p wt s1 \\<Longrightarrow> vars s1 \\<subseteq> vars t\n  wt t \\<ge>\\<^sub>p wt (App s1 s2)\n  wt (App ?s ?t) \\<ge>\\<^sub>p wt ?s\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n\ngoal (1 subgoal):\n 1. vars s1 \\<subseteq> vars t", "unfolding ge_tpoly_def"], ["proof (prove)\nusing this:\n  \\<forall>A.\n     legal_zpassign A \\<longrightarrow>\n     eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s1))\n     \\<le> eval_tpoly A\n            (map_tpoly (\\<lambda>x. x) zhmset_of (wt t)) \\<Longrightarrow>\n  vars s1 \\<subseteq> vars t\n  \\<forall>A.\n     legal_zpassign A \\<longrightarrow>\n     eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s1 s2)))\n     \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n  \\<forall>A.\n     legal_zpassign A \\<longrightarrow>\n     eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt ?s))\n     \\<le> eval_tpoly A\n            (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App ?s ?t)))\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n\ngoal (1 subgoal):\n 1. vars s1 \\<subseteq> vars t", "by blast"], ["proof (state)\nthis:\n  vars s1 \\<subseteq> vars t\n\ngoal (1 subgoal):\n 1. \\<And>s1 s2.\n       \\<lbrakk>wt t \\<ge>\\<^sub>p wt s1 \\<Longrightarrow>\n                vars s1 \\<subseteq> vars t;\n        wt t \\<ge>\\<^sub>p wt s2 \\<Longrightarrow>\n        vars s2 \\<subseteq> vars t;\n        wt t \\<ge>\\<^sub>p wt (App s1 s2)\\<rbrakk>\n       \\<Longrightarrow> vars (App s1 s2) \\<subseteq> vars t", "moreover"], ["proof (state)\nthis:\n  vars s1 \\<subseteq> vars t\n\ngoal (1 subgoal):\n 1. \\<And>s1 s2.\n       \\<lbrakk>wt t \\<ge>\\<^sub>p wt s1 \\<Longrightarrow>\n                vars s1 \\<subseteq> vars t;\n        wt t \\<ge>\\<^sub>p wt s2 \\<Longrightarrow>\n        vars s2 \\<subseteq> vars t;\n        wt t \\<ge>\\<^sub>p wt (App s1 s2)\\<rbrakk>\n       \\<Longrightarrow> vars (App s1 s2) \\<subseteq> vars t", "have \"vars s2 \\<subseteq> vars t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars s2 \\<subseteq> vars t", "using ih2 wt_t_ge_wt_s1s2 wt_App_ge_arg order_trans"], ["proof (prove)\nusing this:\n  wt t \\<ge>\\<^sub>p wt s2 \\<Longrightarrow> vars s2 \\<subseteq> vars t\n  wt t \\<ge>\\<^sub>p wt (App s1 s2)\n  wt (App ?s ?t) \\<ge>\\<^sub>p wt ?t\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n\ngoal (1 subgoal):\n 1. vars s2 \\<subseteq> vars t", "unfolding ge_tpoly_def"], ["proof (prove)\nusing this:\n  \\<forall>A.\n     legal_zpassign A \\<longrightarrow>\n     eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s2))\n     \\<le> eval_tpoly A\n            (map_tpoly (\\<lambda>x. x) zhmset_of (wt t)) \\<Longrightarrow>\n  vars s2 \\<subseteq> vars t\n  \\<forall>A.\n     legal_zpassign A \\<longrightarrow>\n     eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s1 s2)))\n     \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n  \\<forall>A.\n     legal_zpassign A \\<longrightarrow>\n     eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt ?t))\n     \\<le> eval_tpoly A\n            (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App ?s ?t)))\n  \\<lbrakk>?x \\<le> ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x \\<le> ?z\n\ngoal (1 subgoal):\n 1. vars s2 \\<subseteq> vars t", "by blast"], ["proof (state)\nthis:\n  vars s2 \\<subseteq> vars t\n\ngoal (1 subgoal):\n 1. \\<And>s1 s2.\n       \\<lbrakk>wt t \\<ge>\\<^sub>p wt s1 \\<Longrightarrow>\n                vars s1 \\<subseteq> vars t;\n        wt t \\<ge>\\<^sub>p wt s2 \\<Longrightarrow>\n        vars s2 \\<subseteq> vars t;\n        wt t \\<ge>\\<^sub>p wt (App s1 s2)\\<rbrakk>\n       \\<Longrightarrow> vars (App s1 s2) \\<subseteq> vars t", "ultimately"], ["proof (chain)\npicking this:\n  vars s1 \\<subseteq> vars t\n  vars s2 \\<subseteq> vars t", "show ?case"], ["proof (prove)\nusing this:\n  vars s1 \\<subseteq> vars t\n  vars s2 \\<subseteq> vars t\n\ngoal (1 subgoal):\n 1. vars (App s1 s2) \\<subseteq> vars t", "by simp"], ["proof (state)\nthis:\n  vars (App s1 s2) \\<subseteq> vars t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sum_coefs_ge_num_args_if_\\<delta>\\<^sub>h_eq_0:\n  assumes\n    legal: \"legal_passign A\" and\n    \\<delta>_eq_0: \"\\<delta>\\<^sub>h = 0\" and\n    wary_s: \"wary s\"\n  shows \"sum_coefs (eval_tpoly A (wt s)) \\<ge> num_args s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. num_args s \\<le> sum_coefs (eval_tpoly A (wt s))", "proof (cases s rule: tm_exhaust_apps)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       s = apps (Hd \\<zeta>) ss \\<Longrightarrow>\n       num_args s \\<le> sum_coefs (eval_tpoly A (wt s))", "case s: (apps \\<zeta> ss)"], ["proof (state)\nthis:\n  s = apps (Hd \\<zeta>) ss\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       s = apps (Hd \\<zeta>) ss \\<Longrightarrow>\n       num_args s \\<le> sum_coefs (eval_tpoly A (wt s))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. num_args s \\<le> sum_coefs (eval_tpoly A (wt s))", "unfolding s"], ["proof (prove)\ngoal (1 subgoal):\n 1. num_args (apps (Hd \\<zeta>) ss)\n    \\<le> sum_coefs (eval_tpoly A (wt (apps (Hd \\<zeta>) ss)))", "proof (induct ss rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. num_args (apps (Hd \\<zeta>) [])\n    \\<le> sum_coefs (eval_tpoly A (wt (apps (Hd \\<zeta>) [])))\n 2. \\<And>x xs.\n       num_args (apps (Hd \\<zeta>) xs)\n       \\<le> sum_coefs\n              (eval_tpoly A (wt (apps (Hd \\<zeta>) xs))) \\<Longrightarrow>\n       num_args (apps (Hd \\<zeta>) (xs @ [x]))\n       \\<le> sum_coefs (eval_tpoly A (wt (apps (Hd \\<zeta>) (xs @ [x]))))", "case (snoc sa ss)"], ["proof (state)\nthis:\n  num_args (apps (Hd \\<zeta>) ss)\n  \\<le> sum_coefs (eval_tpoly A (wt (apps (Hd \\<zeta>) ss)))\n\ngoal (2 subgoals):\n 1. num_args (apps (Hd \\<zeta>) [])\n    \\<le> sum_coefs (eval_tpoly A (wt (apps (Hd \\<zeta>) [])))\n 2. \\<And>x xs.\n       num_args (apps (Hd \\<zeta>) xs)\n       \\<le> sum_coefs\n              (eval_tpoly A (wt (apps (Hd \\<zeta>) xs))) \\<Longrightarrow>\n       num_args (apps (Hd \\<zeta>) (xs @ [x]))\n       \\<le> sum_coefs (eval_tpoly A (wt (apps (Hd \\<zeta>) (xs @ [x]))))", "note ih = this"], ["proof (state)\nthis:\n  num_args (apps (Hd \\<zeta>) ss)\n  \\<le> sum_coefs (eval_tpoly A (wt (apps (Hd \\<zeta>) ss)))\n\ngoal (2 subgoals):\n 1. num_args (apps (Hd \\<zeta>) [])\n    \\<le> sum_coefs (eval_tpoly A (wt (apps (Hd \\<zeta>) [])))\n 2. \\<And>x xs.\n       num_args (apps (Hd \\<zeta>) xs)\n       \\<le> sum_coefs\n              (eval_tpoly A (wt (apps (Hd \\<zeta>) xs))) \\<Longrightarrow>\n       num_args (apps (Hd \\<zeta>) (xs @ [x]))\n       \\<le> sum_coefs (eval_tpoly A (wt (apps (Hd \\<zeta>) (xs @ [x]))))", "let ?Az = \"\\<lambda>v. zhmset_of (A v)\""], ["proof (state)\ngoal (2 subgoals):\n 1. num_args (apps (Hd \\<zeta>) [])\n    \\<le> sum_coefs (eval_tpoly A (wt (apps (Hd \\<zeta>) [])))\n 2. \\<And>x xs.\n       num_args (apps (Hd \\<zeta>) xs)\n       \\<le> sum_coefs\n              (eval_tpoly A (wt (apps (Hd \\<zeta>) xs))) \\<Longrightarrow>\n       num_args (apps (Hd \\<zeta>) (xs @ [x]))\n       \\<le> sum_coefs (eval_tpoly A (wt (apps (Hd \\<zeta>) (xs @ [x]))))", "have legalz: \"legal_zpassign ?Az\""], ["proof (prove)\ngoal (1 subgoal):\n 1. legal_zpassign (\\<lambda>v. zhmset_of (A v))", "using legal"], ["proof (prove)\nusing this:\n  legal_passign A\n\ngoal (1 subgoal):\n 1. legal_zpassign (\\<lambda>v. zhmset_of (A v))", "unfolding legal_passign_def legal_zpassign_def zhmset_of_le"], ["proof (prove)\nusing this:\n  \\<forall>x. min_passign x \\<le> A x\n\ngoal (1 subgoal):\n 1. \\<forall>x. min_passign x \\<le> A x", "by assumption"], ["proof (state)\nthis:\n  legal_zpassign (\\<lambda>v. zhmset_of (A v))\n\ngoal (2 subgoals):\n 1. num_args (apps (Hd \\<zeta>) [])\n    \\<le> sum_coefs (eval_tpoly A (wt (apps (Hd \\<zeta>) [])))\n 2. \\<And>x xs.\n       num_args (apps (Hd \\<zeta>) xs)\n       \\<le> sum_coefs\n              (eval_tpoly A (wt (apps (Hd \\<zeta>) xs))) \\<Longrightarrow>\n       num_args (apps (Hd \\<zeta>) (xs @ [x]))\n       \\<le> sum_coefs (eval_tpoly A (wt (apps (Hd \\<zeta>) (xs @ [x]))))", "have \"eval_ztpoly ?Az (coef_hd \\<zeta> (length ss)) > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < eval_tpoly (\\<lambda>v. zhmset_of (A v))\n         (map_tpoly (\\<lambda>x. x) zhmset_of (coef_hd \\<zeta> (length ss)))", "using legal coef_hd_gt_0 eval_tpoly_eq_eval_ztpoly"], ["proof (prove)\nusing this:\n  legal_passign A\n  legal_zpassign ?A \\<Longrightarrow>\n  0 < eval_tpoly ?A\n       (map_tpoly (\\<lambda>x. x) zhmset_of (coef_hd ?\\<zeta> ?i))\n  zhmset_of (eval_tpoly ?A ?p) =\n  eval_tpoly (\\<lambda>v. zhmset_of (?A v))\n   (map_tpoly (\\<lambda>x. x) zhmset_of ?p)\n\ngoal (1 subgoal):\n 1. 0 < eval_tpoly (\\<lambda>v. zhmset_of (A v))\n         (map_tpoly (\\<lambda>x. x) zhmset_of (coef_hd \\<zeta> (length ss)))", "by (simp add: coef_hd_gt_0[OF legalz])"], ["proof (state)\nthis:\n  0 < eval_tpoly (\\<lambda>v. zhmset_of (A v))\n       (map_tpoly (\\<lambda>x. x) zhmset_of (coef_hd \\<zeta> (length ss)))\n\ngoal (2 subgoals):\n 1. num_args (apps (Hd \\<zeta>) [])\n    \\<le> sum_coefs (eval_tpoly A (wt (apps (Hd \\<zeta>) [])))\n 2. \\<And>x xs.\n       num_args (apps (Hd \\<zeta>) xs)\n       \\<le> sum_coefs\n              (eval_tpoly A (wt (apps (Hd \\<zeta>) xs))) \\<Longrightarrow>\n       num_args (apps (Hd \\<zeta>) (xs @ [x]))\n       \\<le> sum_coefs (eval_tpoly A (wt (apps (Hd \\<zeta>) (xs @ [x]))))", "hence k: \"eval_tpoly A (coef_hd \\<zeta> (length ss)) > 0\" (is \"?k > _\")"], ["proof (prove)\nusing this:\n  0 < eval_tpoly (\\<lambda>v. zhmset_of (A v))\n       (map_tpoly (\\<lambda>x. x) zhmset_of (coef_hd \\<zeta> (length ss)))\n\ngoal (1 subgoal):\n 1. 0 < eval_tpoly A (coef_hd \\<zeta> (length ss))", "unfolding eval_tpoly_eq_eval_ztpoly[symmetric] zhmset_of_less[symmetric] zhmset_of_0"], ["proof (prove)\nusing this:\n  0 < zhmset_of (eval_tpoly A (coef_hd \\<zeta> (length ss)))\n\ngoal (1 subgoal):\n 1. 0 < zhmset_of (eval_tpoly A (coef_hd \\<zeta> (length ss)))", "by assumption"], ["proof (state)\nthis:\n  0 < eval_tpoly A (coef_hd \\<zeta> (length ss))\n\ngoal (2 subgoals):\n 1. num_args (apps (Hd \\<zeta>) [])\n    \\<le> sum_coefs (eval_tpoly A (wt (apps (Hd \\<zeta>) [])))\n 2. \\<And>x xs.\n       num_args (apps (Hd \\<zeta>) xs)\n       \\<le> sum_coefs\n              (eval_tpoly A (wt (apps (Hd \\<zeta>) xs))) \\<Longrightarrow>\n       num_args (apps (Hd \\<zeta>) (xs @ [x]))\n       \\<le> sum_coefs (eval_tpoly A (wt (apps (Hd \\<zeta>) (xs @ [x]))))", "have \"eval_ztpoly ?Az (wt sa) > 0\" (is \"?w > _\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < eval_tpoly (\\<lambda>v. zhmset_of (A v))\n         (map_tpoly (\\<lambda>x. x) zhmset_of (wt sa))", "by (simp add: wt_gt_0[OF legalz])"], ["proof (state)\nthis:\n  0 < eval_tpoly (\\<lambda>v. zhmset_of (A v))\n       (map_tpoly (\\<lambda>x. x) zhmset_of (wt sa))\n\ngoal (2 subgoals):\n 1. num_args (apps (Hd \\<zeta>) [])\n    \\<le> sum_coefs (eval_tpoly A (wt (apps (Hd \\<zeta>) [])))\n 2. \\<And>x xs.\n       num_args (apps (Hd \\<zeta>) xs)\n       \\<le> sum_coefs\n              (eval_tpoly A (wt (apps (Hd \\<zeta>) xs))) \\<Longrightarrow>\n       num_args (apps (Hd \\<zeta>) (xs @ [x]))\n       \\<le> sum_coefs (eval_tpoly A (wt (apps (Hd \\<zeta>) (xs @ [x]))))", "hence w: \"eval_tpoly A (wt sa) > 0\" (is \"?w > _\")"], ["proof (prove)\nusing this:\n  0 < eval_tpoly (\\<lambda>v. zhmset_of (A v))\n       (map_tpoly (\\<lambda>x. x) zhmset_of (wt sa))\n\ngoal (1 subgoal):\n 1. 0 < eval_tpoly A (wt sa)", "unfolding eval_tpoly_eq_eval_ztpoly[symmetric] zhmset_of_less[symmetric] zhmset_of_0"], ["proof (prove)\nusing this:\n  0 < zhmset_of (eval_tpoly A (wt sa))\n\ngoal (1 subgoal):\n 1. 0 < zhmset_of (eval_tpoly A (wt sa))", "by assumption"], ["proof (state)\nthis:\n  0 < eval_tpoly A (wt sa)\n\ngoal (2 subgoals):\n 1. num_args (apps (Hd \\<zeta>) [])\n    \\<le> sum_coefs (eval_tpoly A (wt (apps (Hd \\<zeta>) [])))\n 2. \\<And>x xs.\n       num_args (apps (Hd \\<zeta>) xs)\n       \\<le> sum_coefs\n              (eval_tpoly A (wt (apps (Hd \\<zeta>) xs))) \\<Longrightarrow>\n       num_args (apps (Hd \\<zeta>) (xs @ [x]))\n       \\<le> sum_coefs (eval_tpoly A (wt (apps (Hd \\<zeta>) (xs @ [x]))))", "have \"?k * ?w > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < eval_tpoly A (coef_hd \\<zeta> (length ss)) * eval_tpoly A (wt sa)", "using k w"], ["proof (prove)\nusing this:\n  0 < eval_tpoly A (coef_hd \\<zeta> (length ss))\n  0 < eval_tpoly A (wt sa)\n\ngoal (1 subgoal):\n 1. 0 < eval_tpoly A (coef_hd \\<zeta> (length ss)) * eval_tpoly A (wt sa)", "by simp"], ["proof (state)\nthis:\n  0 < eval_tpoly A (coef_hd \\<zeta> (length ss)) * eval_tpoly A (wt sa)\n\ngoal (2 subgoals):\n 1. num_args (apps (Hd \\<zeta>) [])\n    \\<le> sum_coefs (eval_tpoly A (wt (apps (Hd \\<zeta>) [])))\n 2. \\<And>x xs.\n       num_args (apps (Hd \\<zeta>) xs)\n       \\<le> sum_coefs\n              (eval_tpoly A (wt (apps (Hd \\<zeta>) xs))) \\<Longrightarrow>\n       num_args (apps (Hd \\<zeta>) (xs @ [x]))\n       \\<le> sum_coefs (eval_tpoly A (wt (apps (Hd \\<zeta>) (xs @ [x]))))", "hence \"sum_coefs (?k * ?w) > 0\""], ["proof (prove)\nusing this:\n  0 < eval_tpoly A (coef_hd \\<zeta> (length ss)) * eval_tpoly A (wt sa)\n\ngoal (1 subgoal):\n 1. 0 < sum_coefs\n         (eval_tpoly A (coef_hd \\<zeta> (length ss)) * eval_tpoly A (wt sa))", "by (rule sum_coefs_gt_0[THEN iffD2])"], ["proof (state)\nthis:\n  0 < sum_coefs\n       (eval_tpoly A (coef_hd \\<zeta> (length ss)) * eval_tpoly A (wt sa))\n\ngoal (2 subgoals):\n 1. num_args (apps (Hd \\<zeta>) [])\n    \\<le> sum_coefs (eval_tpoly A (wt (apps (Hd \\<zeta>) [])))\n 2. \\<And>x xs.\n       num_args (apps (Hd \\<zeta>) xs)\n       \\<le> sum_coefs\n              (eval_tpoly A (wt (apps (Hd \\<zeta>) xs))) \\<Longrightarrow>\n       num_args (apps (Hd \\<zeta>) (xs @ [x]))\n       \\<le> sum_coefs (eval_tpoly A (wt (apps (Hd \\<zeta>) (xs @ [x]))))", "thus ?case"], ["proof (prove)\nusing this:\n  0 < sum_coefs\n       (eval_tpoly A (coef_hd \\<zeta> (length ss)) * eval_tpoly A (wt sa))\n\ngoal (1 subgoal):\n 1. num_args (apps (Hd \\<zeta>) (ss @ [sa]))\n    \\<le> sum_coefs (eval_tpoly A (wt (apps (Hd \\<zeta>) (ss @ [sa]))))", "using ih"], ["proof (prove)\nusing this:\n  0 < sum_coefs\n       (eval_tpoly A (coef_hd \\<zeta> (length ss)) * eval_tpoly A (wt sa))\n  num_args (apps (Hd \\<zeta>) ss)\n  \\<le> sum_coefs (eval_tpoly A (wt (apps (Hd \\<zeta>) ss)))\n\ngoal (1 subgoal):\n 1. num_args (apps (Hd \\<zeta>) (ss @ [sa]))\n    \\<le> sum_coefs (eval_tpoly A (wt (apps (Hd \\<zeta>) (ss @ [sa]))))", "by (simp del: apps_append add: s \\<delta>_eq_0)"], ["proof (state)\nthis:\n  num_args (apps (Hd \\<zeta>) (ss @ [sa]))\n  \\<le> sum_coefs (eval_tpoly A (wt (apps (Hd \\<zeta>) (ss @ [sa]))))\n\ngoal (1 subgoal):\n 1. num_args (apps (Hd \\<zeta>) [])\n    \\<le> sum_coefs (eval_tpoly A (wt (apps (Hd \\<zeta>) [])))", "qed simp"], ["proof (state)\nthis:\n  num_args s \\<le> sum_coefs (eval_tpoly A (wt s))\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Inductive Definitions\\<close>"], ["", "inductive gt :: \"('s, 'v) tm \\<Rightarrow> ('s, 'v) tm \\<Rightarrow> bool\" (infix \">\\<^sub>t\" 50) where\n  gt_wt: \"wt t >\\<^sub>p wt s \\<Longrightarrow> t >\\<^sub>t s\"\n| gt_unary: \"wt t \\<ge>\\<^sub>p wt s \\<Longrightarrow> \\<not> head t \\<le>\\<ge>\\<^sub>h\\<^sub>d head s \\<Longrightarrow> num_args t = 1 \\<Longrightarrow>\n    (\\<exists>f \\<in> ground_heads (head t). arity_sym f = 1 \\<and> wt_sym f = 0) \\<Longrightarrow> arg t >\\<^sub>t s \\<or> arg t = s \\<Longrightarrow>\n    t >\\<^sub>t s\"\n| gt_diff: \"wt t \\<ge>\\<^sub>p wt s \\<Longrightarrow> head t >\\<^sub>h\\<^sub>d head s \\<Longrightarrow> t >\\<^sub>t s\"\n| gt_same: \"wt t \\<ge>\\<^sub>p wt s \\<Longrightarrow> head t = head s \\<Longrightarrow>\n    (\\<forall>f \\<in> ground_heads (head t). extf f (>\\<^sub>t) (args t) (args s)) \\<Longrightarrow> t >\\<^sub>t s\""], ["", "abbreviation ge :: \"('s, 'v) tm \\<Rightarrow> ('s, 'v) tm \\<Rightarrow> bool\" (infix \"\\<ge>\\<^sub>t\" 50) where\n  \"t \\<ge>\\<^sub>t s \\<equiv> t >\\<^sub>t s \\<or> t = s\""], ["", "inductive gt_wt :: \"('s, 'v) tm \\<Rightarrow> ('s, 'v) tm \\<Rightarrow> bool\" where\n  gt_wtI: \"wt t >\\<^sub>p wt s \\<Longrightarrow> gt_wt t s\""], ["", "inductive gt_unary :: \"('s, 'v) tm \\<Rightarrow> ('s, 'v) tm \\<Rightarrow> bool\" where\n  gt_unaryI: \"wt t \\<ge>\\<^sub>p wt s \\<Longrightarrow> \\<not> head t \\<le>\\<ge>\\<^sub>h\\<^sub>d head s \\<Longrightarrow> num_args t = 1 \\<Longrightarrow>\n    (\\<exists>f \\<in> ground_heads (head t). arity_sym f = 1 \\<and> wt_sym f = 0) \\<Longrightarrow> arg t \\<ge>\\<^sub>t s \\<Longrightarrow> gt_unary t s\""], ["", "inductive gt_diff :: \"('s, 'v) tm \\<Rightarrow> ('s, 'v) tm \\<Rightarrow> bool\" where\n  gt_diffI: \"wt t \\<ge>\\<^sub>p wt s \\<Longrightarrow> head t >\\<^sub>h\\<^sub>d head s \\<Longrightarrow> gt_diff t s\""], ["", "inductive gt_same :: \"('s, 'v) tm \\<Rightarrow> ('s, 'v) tm \\<Rightarrow> bool\" where\n  gt_sameI: \"wt t \\<ge>\\<^sub>p wt s \\<Longrightarrow> head t = head s \\<Longrightarrow>\n    (\\<forall>f \\<in> ground_heads (head t). extf f (>\\<^sub>t) (args t) (args s)) \\<Longrightarrow> gt_same t s\""], ["", "lemma gt_iff_wt_unary_diff_same: \"t >\\<^sub>t s \\<longleftrightarrow> gt_wt t s \\<or> gt_unary t s \\<or> gt_diff t s \\<or> gt_same t s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (t >\\<^sub>t s) =\n    (gt_wt t s \\<or> gt_unary t s \\<or> gt_diff t s \\<or> gt_same t s)", "by (subst gt.simps) (auto simp: gt_wt.simps gt_unary.simps gt_diff.simps gt_same.simps)"], ["", "lemma gt_imp_wt: \"t >\\<^sub>t s \\<Longrightarrow> wt t \\<ge>\\<^sub>p wt s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t >\\<^sub>t s \\<Longrightarrow> wt t \\<ge>\\<^sub>p wt s", "by (blast elim: gt.cases)"], ["", "lemma gt_imp_vars: \"t >\\<^sub>t s \\<Longrightarrow> vars t \\<supseteq> vars s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t >\\<^sub>t s \\<Longrightarrow> vars s \\<subseteq> vars t", "by (erule wt_ge_vars[OF gt_imp_wt])"], ["", "subsection \\<open>Irreflexivity\\<close>"], ["", "theorem gt_irrefl: \"wary s \\<Longrightarrow> \\<not> s >\\<^sub>t s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wary s \\<Longrightarrow> \\<not> s >\\<^sub>t s", "proof (induct \"size s\" arbitrary: s rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>sa.\n                   \\<lbrakk>size sa < size s; wary sa\\<rbrakk>\n                   \\<Longrightarrow> \\<not> sa >\\<^sub>t sa;\n        wary s\\<rbrakk>\n       \\<Longrightarrow> \\<not> s >\\<^sub>t s", "case less"], ["proof (state)\nthis:\n  \\<lbrakk>size ?s < size s; wary ?s\\<rbrakk>\n  \\<Longrightarrow> \\<not> ?s >\\<^sub>t ?s\n  wary s\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>sa.\n                   \\<lbrakk>size sa < size s; wary sa\\<rbrakk>\n                   \\<Longrightarrow> \\<not> sa >\\<^sub>t sa;\n        wary s\\<rbrakk>\n       \\<Longrightarrow> \\<not> s >\\<^sub>t s", "note ih = this(1) and wary_s = this(2)"], ["proof (state)\nthis:\n  \\<lbrakk>size ?s < size s; wary ?s\\<rbrakk>\n  \\<Longrightarrow> \\<not> ?s >\\<^sub>t ?s\n  wary s\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<lbrakk>\\<And>sa.\n                   \\<lbrakk>size sa < size s; wary sa\\<rbrakk>\n                   \\<Longrightarrow> \\<not> sa >\\<^sub>t sa;\n        wary s\\<rbrakk>\n       \\<Longrightarrow> \\<not> s >\\<^sub>t s", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> s >\\<^sub>t s", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. s >\\<^sub>t s \\<Longrightarrow> False", "assume s_gt_s: \"s >\\<^sub>t s\""], ["proof (state)\nthis:\n  s >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. s >\\<^sub>t s \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using s_gt_s"], ["proof (prove)\nusing this:\n  s >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. False", "proof (cases rule: gt.cases)"], ["proof (state)\ngoal (4 subgoals):\n 1. wt s >\\<^sub>p wt s \\<Longrightarrow> False\n 2. \\<lbrakk>wt s \\<ge>\\<^sub>p wt s;\n     \\<not> head s \\<le>\\<ge>\\<^sub>h\\<^sub>d head s; num_args s = 1;\n     \\<exists>f\\<in>local.ground_heads (head s).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg s \\<ge>\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>wt s \\<ge>\\<^sub>p wt s;\n     head s >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n    \\<Longrightarrow> False\n 4. \\<lbrakk>wt s \\<ge>\\<^sub>p wt s; head s = head s;\n     \\<forall>f\\<in>local.ground_heads (head s).\n        extf f (>\\<^sub>t) (args s) (args s)\\<rbrakk>\n    \\<Longrightarrow> False", "case gt_same"], ["proof (state)\nthis:\n  wt s \\<ge>\\<^sub>p wt s\n  head s = head s\n  \\<forall>f\\<in>local.ground_heads (head s).\n     extf f (>\\<^sub>t) (args s) (args s)\n\ngoal (4 subgoals):\n 1. wt s >\\<^sub>p wt s \\<Longrightarrow> False\n 2. \\<lbrakk>wt s \\<ge>\\<^sub>p wt s;\n     \\<not> head s \\<le>\\<ge>\\<^sub>h\\<^sub>d head s; num_args s = 1;\n     \\<exists>f\\<in>local.ground_heads (head s).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg s \\<ge>\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>wt s \\<ge>\\<^sub>p wt s;\n     head s >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n    \\<Longrightarrow> False\n 4. \\<lbrakk>wt s \\<ge>\\<^sub>p wt s; head s = head s;\n     \\<forall>f\\<in>local.ground_heads (head s).\n        extf f (>\\<^sub>t) (args s) (args s)\\<rbrakk>\n    \\<Longrightarrow> False", "then"], ["proof (chain)\npicking this:\n  wt s \\<ge>\\<^sub>p wt s\n  head s = head s\n  \\<forall>f\\<in>local.ground_heads (head s).\n     extf f (>\\<^sub>t) (args s) (args s)", "obtain f where f: \"extf f (>\\<^sub>t) (args s) (args s)\""], ["proof (prove)\nusing this:\n  wt s \\<ge>\\<^sub>p wt s\n  head s = head s\n  \\<forall>f\\<in>local.ground_heads (head s).\n     extf f (>\\<^sub>t) (args s) (args s)\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        extf f (>\\<^sub>t) (args s) (args s) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  extf f (>\\<^sub>t) (args s) (args s)\n\ngoal (4 subgoals):\n 1. wt s >\\<^sub>p wt s \\<Longrightarrow> False\n 2. \\<lbrakk>wt s \\<ge>\\<^sub>p wt s;\n     \\<not> head s \\<le>\\<ge>\\<^sub>h\\<^sub>d head s; num_args s = 1;\n     \\<exists>f\\<in>local.ground_heads (head s).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg s \\<ge>\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>wt s \\<ge>\\<^sub>p wt s;\n     head s >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n    \\<Longrightarrow> False\n 4. \\<lbrakk>wt s \\<ge>\\<^sub>p wt s; head s = head s;\n     \\<forall>f\\<in>local.ground_heads (head s).\n        extf f (>\\<^sub>t) (args s) (args s)\\<rbrakk>\n    \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  extf f (>\\<^sub>t) (args s) (args s)\n\ngoal (1 subgoal):\n 1. False", "using wary_s ih"], ["proof (prove)\nusing this:\n  extf f (>\\<^sub>t) (args s) (args s)\n  wary s\n  \\<lbrakk>size ?s < size s; wary ?s\\<rbrakk>\n  \\<Longrightarrow> \\<not> ?s >\\<^sub>t ?s\n\ngoal (1 subgoal):\n 1. False", "by (metis wary_args extf_irrefl size_in_args)"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. wt s >\\<^sub>p wt s \\<Longrightarrow> False\n 2. \\<lbrakk>wt s \\<ge>\\<^sub>p wt s;\n     \\<not> head s \\<le>\\<ge>\\<^sub>h\\<^sub>d head s; num_args s = 1;\n     \\<exists>f\\<in>local.ground_heads (head s).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg s \\<ge>\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> False\n 3. \\<lbrakk>wt s \\<ge>\\<^sub>p wt s;\n     head s >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n    \\<Longrightarrow> False", "qed (auto simp: comp_hd_def gt_tpoly_irrefl gt_hd_irrefl)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> s >\\<^sub>t s\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Transitivity\\<close>"], ["", "lemma not_extf_gt_nil_singleton_if_\\<delta>\\<^sub>h_eq_\\<epsilon>\\<^sub>h:\n  assumes wary_s: \"wary s\" and \\<delta>_eq_\\<epsilon>: \"\\<delta>\\<^sub>h = \\<epsilon>\\<^sub>h\"\n  shows \"\\<not> extf f (>\\<^sub>t) [] [s]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> extf f (>\\<^sub>t) [] [s]", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. extf f (>\\<^sub>t) [] [s] \\<Longrightarrow> False", "assume nil_gt_s: \"extf f (>\\<^sub>t) [] [s]\""], ["proof (state)\nthis:\n  extf f (>\\<^sub>t) [] [s]\n\ngoal (1 subgoal):\n 1. extf f (>\\<^sub>t) [] [s] \\<Longrightarrow> False", "note s_gt_nil = extf_singleton_nil_if_\\<delta>\\<^sub>h_eq_\\<epsilon>\\<^sub>h[OF \\<delta>_eq_\\<epsilon>, of f gt s]"], ["proof (state)\nthis:\n  extf f (>\\<^sub>t) [s] []\n\ngoal (1 subgoal):\n 1. extf f (>\\<^sub>t) [] [s] \\<Longrightarrow> False", "have \"\\<not> extf f (>\\<^sub>t) [] []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> extf f (>\\<^sub>t) [] []", "by (rule extf_irrefl) simp"], ["proof (state)\nthis:\n  \\<not> extf f (>\\<^sub>t) [] []\n\ngoal (1 subgoal):\n 1. extf f (>\\<^sub>t) [] [s] \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  \\<not> extf f (>\\<^sub>t) [] []\n\ngoal (1 subgoal):\n 1. extf f (>\\<^sub>t) [] [s] \\<Longrightarrow> False", "have \"extf f (>\\<^sub>t) [] []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extf f (>\\<^sub>t) [] []", "using extf_trans_from_irrefl[of \"{s}\", OF _ _ _ _ _ _ nil_gt_s s_gt_nil] gt_irrefl[OF wary_s]"], ["proof (prove)\nusing this:\n  \\<lbrakk>finite {s}; [] \\<in> lists {s}; [s] \\<in> lists {s};\n   [] \\<in> lists {s}; \\<forall>x\\<in>{s}. \\<not> x >\\<^sub>t x;\n   \\<forall>z\\<in>{s}.\n      \\<forall>y\\<in>{s}.\n         \\<forall>x\\<in>{s}.\n            z >\\<^sub>t y \\<longrightarrow>\n            y >\\<^sub>t x \\<longrightarrow> z >\\<^sub>t x\\<rbrakk>\n  \\<Longrightarrow> extf f (>\\<^sub>t) [] []\n  \\<not> s >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. extf f (>\\<^sub>t) [] []", "by fastforce"], ["proof (state)\nthis:\n  extf f (>\\<^sub>t) [] []\n\ngoal (1 subgoal):\n 1. extf f (>\\<^sub>t) [] [s] \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> extf f (>\\<^sub>t) [] []\n  extf f (>\\<^sub>t) [] []", "show False"], ["proof (prove)\nusing this:\n  \\<not> extf f (>\\<^sub>t) [] []\n  extf f (>\\<^sub>t) [] []\n\ngoal (1 subgoal):\n 1. False", "by sat"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gt_sub_arg: \"wary (App s t) \\<Longrightarrow> App s t >\\<^sub>t t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wary (App s t) \\<Longrightarrow> App s t >\\<^sub>t t", "proof (induct t arbitrary: s rule: measure_induct_rule[of size])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>y s.\n                   \\<lbrakk>size y < size x; wary (App s y)\\<rbrakk>\n                   \\<Longrightarrow> App s y >\\<^sub>t y;\n        wary (App s x)\\<rbrakk>\n       \\<Longrightarrow> App s x >\\<^sub>t x", "case (less t)"], ["proof (state)\nthis:\n  \\<lbrakk>size ?y < size t; wary (App ?s ?y)\\<rbrakk>\n  \\<Longrightarrow> App ?s ?y >\\<^sub>t ?y\n  wary (App s t)\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>y s.\n                   \\<lbrakk>size y < size x; wary (App s y)\\<rbrakk>\n                   \\<Longrightarrow> App s y >\\<^sub>t y;\n        wary (App s x)\\<rbrakk>\n       \\<Longrightarrow> App s x >\\<^sub>t x", "note ih = this(1) and wary_st = this(2)"], ["proof (state)\nthis:\n  \\<lbrakk>size ?y < size t; wary (App ?s ?y)\\<rbrakk>\n  \\<Longrightarrow> App ?s ?y >\\<^sub>t ?y\n  wary (App s t)\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>y s.\n                   \\<lbrakk>size y < size x; wary (App s y)\\<rbrakk>\n                   \\<Longrightarrow> App s y >\\<^sub>t y;\n        wary (App s x)\\<rbrakk>\n       \\<Longrightarrow> App s x >\\<^sub>t x", "{"], ["proof (state)\nthis:\n  \\<lbrakk>size ?y < size t; wary (App ?s ?y)\\<rbrakk>\n  \\<Longrightarrow> App ?s ?y >\\<^sub>t ?y\n  wary (App s t)\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>y s.\n                   \\<lbrakk>size y < size x; wary (App s y)\\<rbrakk>\n                   \\<Longrightarrow> App s y >\\<^sub>t y;\n        wary (App s x)\\<rbrakk>\n       \\<Longrightarrow> App s x >\\<^sub>t x", "fix A"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>y s.\n                   \\<lbrakk>size y < size x; wary (App s y)\\<rbrakk>\n                   \\<Longrightarrow> App s y >\\<^sub>t y;\n        wary (App s x)\\<rbrakk>\n       \\<Longrightarrow> App s x >\\<^sub>t x", "assume\n      legal: \"legal_zpassign A\" and\n      wt_st: \"eval_ztpoly A (wt (App s t)) = eval_ztpoly A (wt t)\""], ["proof (state)\nthis:\n  legal_zpassign A\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t))) =\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>y s.\n                   \\<lbrakk>size y < size x; wary (App s y)\\<rbrakk>\n                   \\<Longrightarrow> App s y >\\<^sub>t y;\n        wary (App s x)\\<rbrakk>\n       \\<Longrightarrow> App s x >\\<^sub>t x", "have \\<delta>_eq_\\<epsilon>: \"\\<delta>\\<^sub>h = \\<epsilon>\\<^sub>h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>h = \\<epsilon>\\<^sub>h", "using wt_App_fun_\\<delta>\\<^sub>h[OF legal] wt_\\<delta>\\<^sub>h_imp_\\<delta>\\<^sub>h_eq_\\<epsilon>\\<^sub>h[OF legal] wt_st"], ["proof (prove)\nusing this:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App ?s ?t))) =\n  eval_tpoly A\n   (map_tpoly (\\<lambda>x. x) zhmset_of (wt ?t)) \\<Longrightarrow>\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt ?s)) =\n  zhmset_of \\<delta>\\<^sub>h\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt ?s)) =\n  zhmset_of \\<delta>\\<^sub>h \\<Longrightarrow>\n  \\<delta>\\<^sub>h = \\<epsilon>\\<^sub>h\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t))) =\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>h = \\<epsilon>\\<^sub>h", "by blast"], ["proof (state)\nthis:\n  \\<delta>\\<^sub>h = \\<epsilon>\\<^sub>h\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>y s.\n                   \\<lbrakk>size y < size x; wary (App s y)\\<rbrakk>\n                   \\<Longrightarrow> App s y >\\<^sub>t y;\n        wary (App s x)\\<rbrakk>\n       \\<Longrightarrow> App s x >\\<^sub>t x", "hence \\<delta>_gt_0: \"\\<delta>\\<^sub>h > 0\""], ["proof (prove)\nusing this:\n  \\<delta>\\<^sub>h = \\<epsilon>\\<^sub>h\n\ngoal (1 subgoal):\n 1. 0 < \\<delta>\\<^sub>h", "using \\<epsilon>\\<^sub>h_gt_0"], ["proof (prove)\nusing this:\n  \\<delta>\\<^sub>h = \\<epsilon>\\<^sub>h\n  0 < \\<epsilon>\\<^sub>h\n\ngoal (1 subgoal):\n 1. 0 < \\<delta>\\<^sub>h", "by simp"], ["proof (state)\nthis:\n  0 < \\<delta>\\<^sub>h\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>y s.\n                   \\<lbrakk>size y < size x; wary (App s y)\\<rbrakk>\n                   \\<Longrightarrow> App s y >\\<^sub>t y;\n        wary (App s x)\\<rbrakk>\n       \\<Longrightarrow> App s x >\\<^sub>t x", "have wt_s: \"eval_ztpoly A (wt s) = zhmset_of \\<delta>\\<^sub>h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) =\n    zhmset_of \\<delta>\\<^sub>h", "by (rule wt_App_fun_\\<delta>\\<^sub>h[OF legal wt_st])"], ["proof (state)\nthis:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) =\n  zhmset_of \\<delta>\\<^sub>h\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>y s.\n                   \\<lbrakk>size y < size x; wary (App s y)\\<rbrakk>\n                   \\<Longrightarrow> App s y >\\<^sub>t y;\n        wary (App s x)\\<rbrakk>\n       \\<Longrightarrow> App s x >\\<^sub>t x", "have wary_t: \"wary t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wary t", "by (rule wary_AppE\\<^sub>h[OF wary_st])"], ["proof (state)\nthis:\n  wary t\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>y s.\n                   \\<lbrakk>size y < size x; wary (App s y)\\<rbrakk>\n                   \\<Longrightarrow> App s y >\\<^sub>t y;\n        wary (App s x)\\<rbrakk>\n       \\<Longrightarrow> App s x >\\<^sub>t x", "have nargs_lt: \"of_nat (num_args s) < arity_hd\\<^sub>h (head s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (num_args s) < arity_hd\\<^sub>h (head s)", "by (rule wary_AppE\\<^sub>h[OF wary_st])"], ["proof (state)\nthis:\n  of_nat (num_args s) < arity_hd\\<^sub>h (head s)\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>y s.\n                   \\<lbrakk>size y < size x; wary (App s y)\\<rbrakk>\n                   \\<Longrightarrow> App s y >\\<^sub>t y;\n        wary (App s x)\\<rbrakk>\n       \\<Longrightarrow> App s x >\\<^sub>t x", "have ary_hd_s: \"arity_hd\\<^sub>h (head s) = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arity_hd\\<^sub>h (head s) = 1", "by (metis gr_implies_not_zero_hmset legal lt_1_iff_eq_0_hmset nargs_lt neq_iff\n        wt_gt_\\<delta>\\<^sub>h_if_superunary wt_s)"], ["proof (state)\nthis:\n  arity_hd\\<^sub>h (head s) = 1\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>y s.\n                   \\<lbrakk>size y < size x; wary (App s y)\\<rbrakk>\n                   \\<Longrightarrow> App s y >\\<^sub>t y;\n        wary (App s x)\\<rbrakk>\n       \\<Longrightarrow> App s x >\\<^sub>t x", "hence nargs_s: \"num_args s = 0\""], ["proof (prove)\nusing this:\n  arity_hd\\<^sub>h (head s) = 1\n\ngoal (1 subgoal):\n 1. num_args s = 0", "by (metis less_one nargs_lt of_nat_1 of_nat_less_hmset)"], ["proof (state)\nthis:\n  num_args s = 0\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>y s.\n                   \\<lbrakk>size y < size x; wary (App s y)\\<rbrakk>\n                   \\<Longrightarrow> App s y >\\<^sub>t y;\n        wary (App s x)\\<rbrakk>\n       \\<Longrightarrow> App s x >\\<^sub>t x", "hence s_eq_hd: \"s = Hd (head s)\""], ["proof (prove)\nusing this:\n  num_args s = 0\n\ngoal (1 subgoal):\n 1. s = Hd (head s)", "by (simp add: Hd_head_id)"], ["proof (state)\nthis:\n  s = Hd (head s)\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>y s.\n                   \\<lbrakk>size y < size x; wary (App s y)\\<rbrakk>\n                   \\<Longrightarrow> App s y >\\<^sub>t y;\n        wary (App s x)\\<rbrakk>\n       \\<Longrightarrow> App s x >\\<^sub>t x", "obtain f where\n      f_in: \"f \\<in> ground_heads (head s)\" and\n      wt_f_etc: \"wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f = \\<delta>\\<^sub>h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> local.ground_heads (head s);\n         wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f =\n         \\<delta>\\<^sub>h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> local.ground_heads (head s);\n         wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f =\n         \\<delta>\\<^sub>h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "assume a: \"\\<And>f. \\<lbrakk>f \\<in> local.ground_heads (head s); wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f = \\<delta>\\<^sub>h\\<rbrakk> \\<Longrightarrow> thesis\""], ["proof (state)\nthis:\n  \\<lbrakk>?f \\<in> local.ground_heads (head s);\n   wt_sym ?f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h ?f =\n   \\<delta>\\<^sub>h\\<rbrakk>\n  \\<Longrightarrow> thesis\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> local.ground_heads (head s);\n         wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f =\n         \\<delta>\\<^sub>h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "have \"\\<And>f. \\<delta>\\<^sub>h - \\<delta>\\<^sub>h * arity_sym\\<^sub>h f \\<le> wt_sym f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<delta>\\<^sub>h - \\<delta>\\<^sub>h * arity_sym\\<^sub>h f\n       \\<le> wt_sym f", "using wt_s"], ["proof (prove)\nusing this:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) =\n  zhmset_of \\<delta>\\<^sub>h\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<delta>\\<^sub>h - \\<delta>\\<^sub>h * arity_sym\\<^sub>h f\n       \\<le> wt_sym f", "by (metis legal wt_\\<delta>\\<^sub>h_imp_\\<delta>\\<^sub>h_eq_\\<epsilon>\\<^sub>h wt_sym_ge\\<^sub>h)"], ["proof (state)\nthis:\n  \\<delta>\\<^sub>h - \\<delta>\\<^sub>h * arity_sym\\<^sub>h ?f \\<le> wt_sym ?f\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> local.ground_heads (head s);\n         wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f =\n         \\<delta>\\<^sub>h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "hence \"\\<And>s. \\<not> \\<delta>\\<^sub>h * arity_sym\\<^sub>h s + wt_sym s < \\<delta>\\<^sub>h\""], ["proof (prove)\nusing this:\n  \\<delta>\\<^sub>h - \\<delta>\\<^sub>h * arity_sym\\<^sub>h ?f \\<le> wt_sym ?f\n\ngoal (1 subgoal):\n 1. \\<And>s.\n       \\<not> \\<delta>\\<^sub>h * arity_sym\\<^sub>h s + wt_sym s\n              < \\<delta>\\<^sub>h", "by (metis add_diff_cancel_left' le_imp_minus_plus_hmset leD le_minus_plus_same_hmset\n            less_le_trans)"], ["proof (state)\nthis:\n  \\<not> \\<delta>\\<^sub>h * arity_sym\\<^sub>h ?s + wt_sym ?s\n         < \\<delta>\\<^sub>h\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<lbrakk>f \\<in> local.ground_heads (head s);\n         wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f =\n         \\<delta>\\<^sub>h\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "thus thesis"], ["proof (prove)\nusing this:\n  \\<not> \\<delta>\\<^sub>h * arity_sym\\<^sub>h ?s + wt_sym ?s\n         < \\<delta>\\<^sub>h\n\ngoal (1 subgoal):\n 1. thesis", "using a wt_s s_eq_hd"], ["proof (prove)\nusing this:\n  \\<not> \\<delta>\\<^sub>h * arity_sym\\<^sub>h ?s + wt_sym ?s\n         < \\<delta>\\<^sub>h\n  \\<lbrakk>?f \\<in> local.ground_heads (head s);\n   wt_sym ?f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h ?f =\n   \\<delta>\\<^sub>h\\<rbrakk>\n  \\<Longrightarrow> thesis\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)) =\n  zhmset_of \\<delta>\\<^sub>h\n  s = Hd (head s)\n\ngoal (1 subgoal):\n 1. thesis", "by (metis exists_wt_sym legal add.commute order.not_eq_order_implies_strict zhmset_of_le)"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f \\<in> local.ground_heads (head s)\n  wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f = \\<delta>\\<^sub>h\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>y s.\n                   \\<lbrakk>size y < size x; wary (App s y)\\<rbrakk>\n                   \\<Longrightarrow> App s y >\\<^sub>t y;\n        wary (App s x)\\<rbrakk>\n       \\<Longrightarrow> App s x >\\<^sub>t x", "have ary_f_1: \"arity_sym f = 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arity_sym f = 1", "by (metis \\<delta>_gt_0 add_diff_cancel_left' ary_hd_s diff_le_self_hmset dual_order.order_iff_strict\n        f_in ground_heads_arity\\<^sub>h gt_0_lt_mult_gt_1_hmset hmset_of_enat_1 hmset_of_enat_inject leD\n        wt_f_etc)"], ["proof (state)\nthis:\n  arity_sym f = 1\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>y s.\n                   \\<lbrakk>size y < size x; wary (App s y)\\<rbrakk>\n                   \\<Longrightarrow> App s y >\\<^sub>t y;\n        wary (App s x)\\<rbrakk>\n       \\<Longrightarrow> App s x >\\<^sub>t x", "hence wt_f_0: \"wt_sym f = 0\""], ["proof (prove)\nusing this:\n  arity_sym f = 1\n\ngoal (1 subgoal):\n 1. wt_sym f = 0", "using wt_f_etc"], ["proof (prove)\nusing this:\n  arity_sym f = 1\n  wt_sym f + \\<delta>\\<^sub>h * arity_sym\\<^sub>h f = \\<delta>\\<^sub>h\n\ngoal (1 subgoal):\n 1. wt_sym f = 0", "by simp"], ["proof (state)\nthis:\n  wt_sym f = 0\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>y s.\n                   \\<lbrakk>size y < size x; wary (App s y)\\<rbrakk>\n                   \\<Longrightarrow> App s y >\\<^sub>t y;\n        wary (App s x)\\<rbrakk>\n       \\<Longrightarrow> App s x >\\<^sub>t x", "{"], ["proof (state)\nthis:\n  wt_sym f = 0\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>y s.\n                   \\<lbrakk>size y < size x; wary (App s y)\\<rbrakk>\n                   \\<Longrightarrow> App s y >\\<^sub>t y;\n        wary (App s x)\\<rbrakk>\n       \\<Longrightarrow> App s x >\\<^sub>t x", "assume hd_s_ncmp_t: \"\\<not> head s \\<le>\\<ge>\\<^sub>h\\<^sub>d head t\""], ["proof (state)\nthis:\n  \\<not> head s \\<le>\\<ge>\\<^sub>h\\<^sub>d head t\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>y s.\n                   \\<lbrakk>size y < size x; wary (App s y)\\<rbrakk>\n                   \\<Longrightarrow> App s y >\\<^sub>t y;\n        wary (App s x)\\<rbrakk>\n       \\<Longrightarrow> App s x >\\<^sub>t x", "have ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. App s t >\\<^sub>t t", "by (rule gt_unary[OF wt_App_ge_arg])\n          (auto simp: hd_s_ncmp_t nargs_s intro: f_in ary_f_1 wt_f_0)"], ["proof (state)\nthis:\n  App s t >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>y s.\n                   \\<lbrakk>size y < size x; wary (App s y)\\<rbrakk>\n                   \\<Longrightarrow> App s y >\\<^sub>t y;\n        wary (App s x)\\<rbrakk>\n       \\<Longrightarrow> App s x >\\<^sub>t x", "}"], ["proof (state)\nthis:\n  \\<not> head s \\<le>\\<ge>\\<^sub>h\\<^sub>d head t \\<Longrightarrow>\n  App s t >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>y s.\n                   \\<lbrakk>size y < size x; wary (App s y)\\<rbrakk>\n                   \\<Longrightarrow> App s y >\\<^sub>t y;\n        wary (App s x)\\<rbrakk>\n       \\<Longrightarrow> App s x >\\<^sub>t x", "moreover"], ["proof (state)\nthis:\n  \\<not> head s \\<le>\\<ge>\\<^sub>h\\<^sub>d head t \\<Longrightarrow>\n  App s t >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>y s.\n                   \\<lbrakk>size y < size x; wary (App s y)\\<rbrakk>\n                   \\<Longrightarrow> App s y >\\<^sub>t y;\n        wary (App s x)\\<rbrakk>\n       \\<Longrightarrow> App s x >\\<^sub>t x", "{"], ["proof (state)\nthis:\n  \\<not> head s \\<le>\\<ge>\\<^sub>h\\<^sub>d head t \\<Longrightarrow>\n  App s t >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>y s.\n                   \\<lbrakk>size y < size x; wary (App s y)\\<rbrakk>\n                   \\<Longrightarrow> App s y >\\<^sub>t y;\n        wary (App s x)\\<rbrakk>\n       \\<Longrightarrow> App s x >\\<^sub>t x", "assume hd_s_gt_t: \"head s >\\<^sub>h\\<^sub>d head t\""], ["proof (state)\nthis:\n  head s >\\<^sub>h\\<^sub>d head t\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>y s.\n                   \\<lbrakk>size y < size x; wary (App s y)\\<rbrakk>\n                   \\<Longrightarrow> App s y >\\<^sub>t y;\n        wary (App s x)\\<rbrakk>\n       \\<Longrightarrow> App s x >\\<^sub>t x", "have ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. App s t >\\<^sub>t t", "by (rule gt_diff[OF wt_App_ge_arg]) (simp add: hd_s_gt_t)"], ["proof (state)\nthis:\n  App s t >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>y s.\n                   \\<lbrakk>size y < size x; wary (App s y)\\<rbrakk>\n                   \\<Longrightarrow> App s y >\\<^sub>t y;\n        wary (App s x)\\<rbrakk>\n       \\<Longrightarrow> App s x >\\<^sub>t x", "}"], ["proof (state)\nthis:\n  head s >\\<^sub>h\\<^sub>d head t \\<Longrightarrow> App s t >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>y s.\n                   \\<lbrakk>size y < size x; wary (App s y)\\<rbrakk>\n                   \\<Longrightarrow> App s y >\\<^sub>t y;\n        wary (App s x)\\<rbrakk>\n       \\<Longrightarrow> App s x >\\<^sub>t x", "moreover"], ["proof (state)\nthis:\n  head s >\\<^sub>h\\<^sub>d head t \\<Longrightarrow> App s t >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>y s.\n                   \\<lbrakk>size y < size x; wary (App s y)\\<rbrakk>\n                   \\<Longrightarrow> App s y >\\<^sub>t y;\n        wary (App s x)\\<rbrakk>\n       \\<Longrightarrow> App s x >\\<^sub>t x", "{"], ["proof (state)\nthis:\n  head s >\\<^sub>h\\<^sub>d head t \\<Longrightarrow> App s t >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>y s.\n                   \\<lbrakk>size y < size x; wary (App s y)\\<rbrakk>\n                   \\<Longrightarrow> App s y >\\<^sub>t y;\n        wary (App s x)\\<rbrakk>\n       \\<Longrightarrow> App s x >\\<^sub>t x", "assume \"head t >\\<^sub>h\\<^sub>d head s\""], ["proof (state)\nthis:\n  head t >\\<^sub>h\\<^sub>d head s\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>y s.\n                   \\<lbrakk>size y < size x; wary (App s y)\\<rbrakk>\n                   \\<Longrightarrow> App s y >\\<^sub>t y;\n        wary (App s x)\\<rbrakk>\n       \\<Longrightarrow> App s x >\\<^sub>t x", "hence False"], ["proof (prove)\nusing this:\n  head t >\\<^sub>h\\<^sub>d head s\n\ngoal (1 subgoal):\n 1. False", "using ary_f_1 wt_f_0 f_in gt_hd_irrefl gt_sym_antisym unary_wt_sym_0_gt\\<^sub>h hmset_of_enat_1"], ["proof (prove)\nusing this:\n  head t >\\<^sub>h\\<^sub>d head s\n  arity_sym f = 1\n  wt_sym f = 0\n  f \\<in> local.ground_heads (head s)\n  \\<not> ?\\<zeta> >\\<^sub>h\\<^sub>d ?\\<zeta>\n  ?f >\\<^sub>s ?g \\<Longrightarrow> \\<not> ?g >\\<^sub>s ?f\n  \\<lbrakk>arity_sym\\<^sub>h ?f = 1; wt_sym ?f = 0\\<rbrakk>\n  \\<Longrightarrow> ?f >\\<^sub>s ?g \\<or> ?g = ?f\n  hmset_of_enat 1 = 1\n\ngoal (1 subgoal):\n 1. False", "unfolding gt_hd_def"], ["proof (prove)\nusing this:\n  \\<forall>g\\<in>local.ground_heads (head t).\n     Ball (local.ground_heads (head s)) ((>\\<^sub>s) g)\n  arity_sym f = 1\n  wt_sym f = 0\n  f \\<in> local.ground_heads (head s)\n  \\<not> (\\<forall>g\\<in>local.ground_heads ?\\<zeta>.\n             Ball (local.ground_heads ?\\<zeta>) ((>\\<^sub>s) g))\n  ?f >\\<^sub>s ?g \\<Longrightarrow> \\<not> ?g >\\<^sub>s ?f\n  \\<lbrakk>arity_sym\\<^sub>h ?f = 1; wt_sym ?f = 0\\<rbrakk>\n  \\<Longrightarrow> ?f >\\<^sub>s ?g \\<or> ?g = ?f\n  hmset_of_enat 1 = 1\n\ngoal (1 subgoal):\n 1. False", "by metis"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>y s.\n                   \\<lbrakk>size y < size x; wary (App s y)\\<rbrakk>\n                   \\<Longrightarrow> App s y >\\<^sub>t y;\n        wary (App s x)\\<rbrakk>\n       \\<Longrightarrow> App s x >\\<^sub>t x", "}"], ["proof (state)\nthis:\n  head t >\\<^sub>h\\<^sub>d head s \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>y s.\n                   \\<lbrakk>size y < size x; wary (App s y)\\<rbrakk>\n                   \\<Longrightarrow> App s y >\\<^sub>t y;\n        wary (App s x)\\<rbrakk>\n       \\<Longrightarrow> App s x >\\<^sub>t x", "moreover"], ["proof (state)\nthis:\n  head t >\\<^sub>h\\<^sub>d head s \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>y s.\n                   \\<lbrakk>size y < size x; wary (App s y)\\<rbrakk>\n                   \\<Longrightarrow> App s y >\\<^sub>t y;\n        wary (App s x)\\<rbrakk>\n       \\<Longrightarrow> App s x >\\<^sub>t x", "{"], ["proof (state)\nthis:\n  head t >\\<^sub>h\\<^sub>d head s \\<Longrightarrow> False\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>y s.\n                   \\<lbrakk>size y < size x; wary (App s y)\\<rbrakk>\n                   \\<Longrightarrow> App s y >\\<^sub>t y;\n        wary (App s x)\\<rbrakk>\n       \\<Longrightarrow> App s x >\\<^sub>t x", "assume hd_t_eq_s: \"head t = head s\""], ["proof (state)\nthis:\n  head t = head s\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>y s.\n                   \\<lbrakk>size y < size x; wary (App s y)\\<rbrakk>\n                   \\<Longrightarrow> App s y >\\<^sub>t y;\n        wary (App s x)\\<rbrakk>\n       \\<Longrightarrow> App s x >\\<^sub>t x", "hence nargs_t_le: \"num_args t \\<le> 1\""], ["proof (prove)\nusing this:\n  head t = head s\n\ngoal (1 subgoal):\n 1. num_args t \\<le> 1", "using ary_hd_s wary_num_args_le_arity_head\\<^sub>h[OF wary_t] of_nat_le_hmset"], ["proof (prove)\nusing this:\n  head t = head s\n  arity_hd\\<^sub>h (head s) = 1\n  of_nat (num_args t) \\<le> arity_hd\\<^sub>h (head t)\n  (of_nat ?M \\<le> of_nat ?N) = (?M \\<le> ?N)\n\ngoal (1 subgoal):\n 1. num_args t \\<le> 1", "by fastforce"], ["proof (state)\nthis:\n  num_args t \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>y s.\n                   \\<lbrakk>size y < size x; wary (App s y)\\<rbrakk>\n                   \\<Longrightarrow> App s y >\\<^sub>t y;\n        wary (App s x)\\<rbrakk>\n       \\<Longrightarrow> App s x >\\<^sub>t x", "have extf: \"extf f (>\\<^sub>t) [t] (args t)\" for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. extf f (>\\<^sub>t) [t] (args t)", "proof (cases \"args t\")"], ["proof (state)\ngoal (2 subgoals):\n 1. args t = [] \\<Longrightarrow> extf f (>\\<^sub>t) [t] (args t)\n 2. \\<And>a list.\n       args t = a # list \\<Longrightarrow> extf f (>\\<^sub>t) [t] (args t)", "case Nil"], ["proof (state)\nthis:\n  args t = []\n\ngoal (2 subgoals):\n 1. args t = [] \\<Longrightarrow> extf f (>\\<^sub>t) [t] (args t)\n 2. \\<And>a list.\n       args t = a # list \\<Longrightarrow> extf f (>\\<^sub>t) [t] (args t)", "thus ?thesis"], ["proof (prove)\nusing this:\n  args t = []\n\ngoal (1 subgoal):\n 1. extf f (>\\<^sub>t) [t] (args t)", "by (simp add: extf_singleton_nil_if_\\<delta>\\<^sub>h_eq_\\<epsilon>\\<^sub>h[OF \\<delta>_eq_\\<epsilon>])"], ["proof (state)\nthis:\n  extf f (>\\<^sub>t) [t] (args t)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       args t = a # list \\<Longrightarrow> extf f (>\\<^sub>t) [t] (args t)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       args t = a # list \\<Longrightarrow> extf f (>\\<^sub>t) [t] (args t)", "case args_t: (Cons ta ts)"], ["proof (state)\nthis:\n  args t = ta # ts\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       args t = a # list \\<Longrightarrow> extf f (>\\<^sub>t) [t] (args t)", "hence ts: \"ts = []\""], ["proof (prove)\nusing this:\n  args t = ta # ts\n\ngoal (1 subgoal):\n 1. ts = []", "using ary_hd_s[folded hd_t_eq_s] wary_num_args_le_arity_head\\<^sub>h[OF wary_t] of_nat_le_hmset\n            nargs_t_le"], ["proof (prove)\nusing this:\n  args t = ta # ts\n  arity_hd\\<^sub>h (head t) = 1\n  of_nat (num_args t) \\<le> arity_hd\\<^sub>h (head t)\n  (of_nat ?M \\<le> of_nat ?N) = (?M \\<le> ?N)\n  num_args t \\<le> 1\n\ngoal (1 subgoal):\n 1. ts = []", "by simp"], ["proof (state)\nthis:\n  ts = []\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       args t = a # list \\<Longrightarrow> extf f (>\\<^sub>t) [t] (args t)", "have ta: \"ta = arg t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ta = arg t", "by (metis apps.simps(1) apps.simps(2) args_t tm.sel(6) tm_collapse_apps ts)"], ["proof (state)\nthis:\n  ta = arg t\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       args t = a # list \\<Longrightarrow> extf f (>\\<^sub>t) [t] (args t)", "hence t: \"t = App (fun t) ta\""], ["proof (prove)\nusing this:\n  ta = arg t\n\ngoal (1 subgoal):\n 1. t = App (fun t) ta", "by (metis args.simps(1) args_t not_Cons_self2 tm.exhaust_sel ts)"], ["proof (state)\nthis:\n  t = App (fun t) ta\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       args t = a # list \\<Longrightarrow> extf f (>\\<^sub>t) [t] (args t)", "have \"t >\\<^sub>t ta\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t >\\<^sub>t ta", "by (rule ih[of ta \"fun t\", folded t, OF _ wary_t]) (metis ta size_arg_lt t tm.disc(2))"], ["proof (state)\nthis:\n  t >\\<^sub>t ta\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       args t = a # list \\<Longrightarrow> extf f (>\\<^sub>t) [t] (args t)", "thus ?thesis"], ["proof (prove)\nusing this:\n  t >\\<^sub>t ta\n\ngoal (1 subgoal):\n 1. extf f (>\\<^sub>t) [t] (args t)", "unfolding args_t ts"], ["proof (prove)\nusing this:\n  t >\\<^sub>t ta\n\ngoal (1 subgoal):\n 1. extf f (>\\<^sub>t) [t] [ta]", "by (metis extf_singleton gt_irrefl wary_t)"], ["proof (state)\nthis:\n  extf f (>\\<^sub>t) [t] (args t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  extf ?f (>\\<^sub>t) [t] (args t)\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>y s.\n                   \\<lbrakk>size y < size x; wary (App s y)\\<rbrakk>\n                   \\<Longrightarrow> App s y >\\<^sub>t y;\n        wary (App s x)\\<rbrakk>\n       \\<Longrightarrow> App s x >\\<^sub>t x", "have ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. App s t >\\<^sub>t t", "by (rule gt_same[OF wt_App_ge_arg])\n          (simp_all add: hd_t_eq_s length_0_conv[THEN iffD1, OF nargs_s] extf)"], ["proof (state)\nthis:\n  App s t >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>y s.\n                   \\<lbrakk>size y < size x; wary (App s y)\\<rbrakk>\n                   \\<Longrightarrow> App s y >\\<^sub>t y;\n        wary (App s x)\\<rbrakk>\n       \\<Longrightarrow> App s x >\\<^sub>t x", "}"], ["proof (state)\nthis:\n  head t = head s \\<Longrightarrow> App s t >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>y s.\n                   \\<lbrakk>size y < size x; wary (App s y)\\<rbrakk>\n                   \\<Longrightarrow> App s y >\\<^sub>t y;\n        wary (App s x)\\<rbrakk>\n       \\<Longrightarrow> App s x >\\<^sub>t x", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> head s \\<le>\\<ge>\\<^sub>h\\<^sub>d head t \\<Longrightarrow>\n  App s t >\\<^sub>t t\n  head s >\\<^sub>h\\<^sub>d head t \\<Longrightarrow> App s t >\\<^sub>t t\n  head t >\\<^sub>h\\<^sub>d head s \\<Longrightarrow> False\n  head t = head s \\<Longrightarrow> App s t >\\<^sub>t t", "have ?case"], ["proof (prove)\nusing this:\n  \\<not> head s \\<le>\\<ge>\\<^sub>h\\<^sub>d head t \\<Longrightarrow>\n  App s t >\\<^sub>t t\n  head s >\\<^sub>h\\<^sub>d head t \\<Longrightarrow> App s t >\\<^sub>t t\n  head t >\\<^sub>h\\<^sub>d head s \\<Longrightarrow> False\n  head t = head s \\<Longrightarrow> App s t >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. App s t >\\<^sub>t t", "unfolding comp_hd_def"], ["proof (prove)\nusing this:\n  \\<not> (head s = head t \\<or>\n          head s >\\<^sub>h\\<^sub>d head t \\<or>\n          head t >\\<^sub>h\\<^sub>d head s) \\<Longrightarrow>\n  App s t >\\<^sub>t t\n  head s >\\<^sub>h\\<^sub>d head t \\<Longrightarrow> App s t >\\<^sub>t t\n  head t >\\<^sub>h\\<^sub>d head s \\<Longrightarrow> False\n  head t = head s \\<Longrightarrow> App s t >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. App s t >\\<^sub>t t", "by metis"], ["proof (state)\nthis:\n  App s t >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>y s.\n                   \\<lbrakk>size y < size x; wary (App s y)\\<rbrakk>\n                   \\<Longrightarrow> App s y >\\<^sub>t y;\n        wary (App s x)\\<rbrakk>\n       \\<Longrightarrow> App s x >\\<^sub>t x", "}"], ["proof (state)\nthis:\n  \\<lbrakk>legal_zpassign ?A2;\n   eval_tpoly ?A2 (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t))) =\n   eval_tpoly ?A2 (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\\<rbrakk>\n  \\<Longrightarrow> App s t >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<And>x s.\n       \\<lbrakk>\\<And>y s.\n                   \\<lbrakk>size y < size x; wary (App s y)\\<rbrakk>\n                   \\<Longrightarrow> App s y >\\<^sub>t y;\n        wary (App s x)\\<rbrakk>\n       \\<Longrightarrow> App s x >\\<^sub>t x", "thus ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>legal_zpassign ?A2;\n   eval_tpoly ?A2 (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t))) =\n   eval_tpoly ?A2 (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\\<rbrakk>\n  \\<Longrightarrow> App s t >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. App s t >\\<^sub>t t", "using gt_wt"], ["proof (prove)\nusing this:\n  \\<lbrakk>legal_zpassign ?A2;\n   eval_tpoly ?A2 (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t))) =\n   eval_tpoly ?A2 (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\\<rbrakk>\n  \\<Longrightarrow> App s t >\\<^sub>t t\n  wt ?t >\\<^sub>p wt ?s \\<Longrightarrow> ?t >\\<^sub>t ?s\n\ngoal (1 subgoal):\n 1. App s t >\\<^sub>t t", "by (metis ge_tpoly_def gt_tpoly_def wt_App_ge_arg order.not_eq_order_implies_strict)"], ["proof (state)\nthis:\n  App s t >\\<^sub>t t\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gt_arg: \"wary s \\<Longrightarrow> is_App s \\<Longrightarrow> s >\\<^sub>t arg s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wary s; is_App s\\<rbrakk> \\<Longrightarrow> s >\\<^sub>t arg s", "by (cases s) (auto intro: gt_sub_arg)"], ["", "theorem gt_trans: \"wary u \\<Longrightarrow> wary t \\<Longrightarrow> wary s \\<Longrightarrow> u >\\<^sub>t t \\<Longrightarrow> t >\\<^sub>t s \\<Longrightarrow> u >\\<^sub>t s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wary u; wary t; wary s; u >\\<^sub>t t; t >\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "proof (simp only: atomize_imp,\n    rule measure_induct_rule[of \"\\<lambda>(u, t, s). {#size u, size t, size s#}\"\n        \"\\<lambda>(u, t, s). wary u \\<longrightarrow> wary t \\<longrightarrow> wary s \\<longrightarrow> u >\\<^sub>t t \\<longrightarrow> t >\\<^sub>t s \\<longrightarrow> u >\\<^sub>t s\" \"(u, t, s)\",\n      simplified prod.case],\n    simp only: split_paired_all prod.case atomize_imp[symmetric])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>\\<And>ab ac ba.\n                   \\<lbrakk>{#size ab, size ac, size ba#}\n                            < {#size a, size aa, size b#};\n                    wary ab; wary ac; wary ba; ab >\\<^sub>t ac;\n                    ac >\\<^sub>t ba\\<rbrakk>\n                   \\<Longrightarrow> ab >\\<^sub>t ba;\n        wary a; wary aa; wary b; a >\\<^sub>t aa; aa >\\<^sub>t b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b", "fix u t s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>\\<And>ab ac ba.\n                   \\<lbrakk>{#size ab, size ac, size ba#}\n                            < {#size a, size aa, size b#};\n                    wary ab; wary ac; wary ba; ab >\\<^sub>t ac;\n                    ac >\\<^sub>t ba\\<rbrakk>\n                   \\<Longrightarrow> ab >\\<^sub>t ba;\n        wary a; wary aa; wary b; a >\\<^sub>t aa; aa >\\<^sub>t b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b", "assume\n    ih: \"\\<And>ua ta sa. {#size ua, size ta, size sa#} < {#size u, size t, size s#} \\<Longrightarrow>\n      wary ua \\<Longrightarrow> wary ta \\<Longrightarrow> wary sa \\<Longrightarrow> ua >\\<^sub>t ta \\<Longrightarrow> ta >\\<^sub>t sa \\<Longrightarrow> ua >\\<^sub>t sa\" and\n    wary_u: \"wary u\" and wary_t: \"wary t\" and wary_s: \"wary s\" and\n    u_gt_t: \"u >\\<^sub>t t\" and t_gt_s: \"t >\\<^sub>t s\""], ["proof (state)\nthis:\n  \\<lbrakk>{#size ?ua, size ?ta, size ?sa#} < {#size u, size t, size s#};\n   wary ?ua; wary ?ta; wary ?sa; ?ua >\\<^sub>t ?ta;\n   ?ta >\\<^sub>t ?sa\\<rbrakk>\n  \\<Longrightarrow> ?ua >\\<^sub>t ?sa\n  wary u\n  wary t\n  wary s\n  u >\\<^sub>t t\n  t >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>\\<And>ab ac ba.\n                   \\<lbrakk>{#size ab, size ac, size ba#}\n                            < {#size a, size aa, size b#};\n                    wary ab; wary ac; wary ba; ab >\\<^sub>t ac;\n                    ac >\\<^sub>t ba\\<rbrakk>\n                   \\<Longrightarrow> ab >\\<^sub>t ba;\n        wary a; wary aa; wary b; a >\\<^sub>t aa; aa >\\<^sub>t b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b", "have wt_u_ge_t: \"wt u \\<ge>\\<^sub>p wt t\" and wt_t_ge_s: \"wt t \\<ge>\\<^sub>p wt s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wt u \\<ge>\\<^sub>p wt t &&& wt t \\<ge>\\<^sub>p wt s", "using gt_imp_wt u_gt_t t_gt_s"], ["proof (prove)\nusing this:\n  ?t >\\<^sub>t ?s \\<Longrightarrow> wt ?t \\<ge>\\<^sub>p wt ?s\n  u >\\<^sub>t t\n  t >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. wt u \\<ge>\\<^sub>p wt t &&& wt t \\<ge>\\<^sub>p wt s", "by auto"], ["proof (state)\nthis:\n  wt u \\<ge>\\<^sub>p wt t\n  wt t \\<ge>\\<^sub>p wt s\n\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>\\<And>ab ac ba.\n                   \\<lbrakk>{#size ab, size ac, size ba#}\n                            < {#size a, size aa, size b#};\n                    wary ab; wary ac; wary ba; ab >\\<^sub>t ac;\n                    ac >\\<^sub>t ba\\<rbrakk>\n                   \\<Longrightarrow> ab >\\<^sub>t ba;\n        wary a; wary aa; wary b; a >\\<^sub>t aa; aa >\\<^sub>t b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b", "hence wt_u_ge_s: \"wt u \\<ge>\\<^sub>p wt s\""], ["proof (prove)\nusing this:\n  wt u \\<ge>\\<^sub>p wt t\n  wt t \\<ge>\\<^sub>p wt s\n\ngoal (1 subgoal):\n 1. wt u \\<ge>\\<^sub>p wt s", "by (rule ge_ge_tpoly_trans)"], ["proof (state)\nthis:\n  wt u \\<ge>\\<^sub>p wt s\n\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>\\<And>ab ac ba.\n                   \\<lbrakk>{#size ab, size ac, size ba#}\n                            < {#size a, size aa, size b#};\n                    wary ab; wary ac; wary ba; ab >\\<^sub>t ac;\n                    ac >\\<^sub>t ba\\<rbrakk>\n                   \\<Longrightarrow> ab >\\<^sub>t ba;\n        wary a; wary aa; wary b; a >\\<^sub>t aa; aa >\\<^sub>t b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b", "have wary_arg_u: \"wary (arg u)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wary (arg u)", "by (rule wary_arg[OF wary_u])"], ["proof (state)\nthis:\n  wary (arg u)\n\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>\\<And>ab ac ba.\n                   \\<lbrakk>{#size ab, size ac, size ba#}\n                            < {#size a, size aa, size b#};\n                    wary ab; wary ac; wary ba; ab >\\<^sub>t ac;\n                    ac >\\<^sub>t ba\\<rbrakk>\n                   \\<Longrightarrow> ab >\\<^sub>t ba;\n        wary a; wary aa; wary b; a >\\<^sub>t aa; aa >\\<^sub>t b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b", "have wary_arg_t: \"wary (arg t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wary (arg t)", "by (rule wary_arg[OF wary_t])"], ["proof (state)\nthis:\n  wary (arg t)\n\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>\\<And>ab ac ba.\n                   \\<lbrakk>{#size ab, size ac, size ba#}\n                            < {#size a, size aa, size b#};\n                    wary ab; wary ac; wary ba; ab >\\<^sub>t ac;\n                    ac >\\<^sub>t ba\\<rbrakk>\n                   \\<Longrightarrow> ab >\\<^sub>t ba;\n        wary a; wary aa; wary b; a >\\<^sub>t aa; aa >\\<^sub>t b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b", "have wary_arg_s: \"wary (arg s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wary (arg s)", "by (rule wary_arg[OF wary_s])"], ["proof (state)\nthis:\n  wary (arg s)\n\ngoal (1 subgoal):\n 1. \\<And>a aa b.\n       \\<lbrakk>\\<And>ab ac ba.\n                   \\<lbrakk>{#size ab, size ac, size ba#}\n                            < {#size a, size aa, size b#};\n                    wary ab; wary ac; wary ba; ab >\\<^sub>t ac;\n                    ac >\\<^sub>t ba\\<rbrakk>\n                   \\<Longrightarrow> ab >\\<^sub>t ba;\n        wary a; wary aa; wary b; a >\\<^sub>t aa; aa >\\<^sub>t b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b", "show \"u >\\<^sub>t s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "using t_gt_s"], ["proof (prove)\nusing this:\n  t >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "proof cases"], ["proof (state)\ngoal (4 subgoals):\n 1. wt t >\\<^sub>p wt s \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     \\<not> head t \\<le>\\<ge>\\<^sub>h\\<^sub>d head s; num_args t = 1;\n     \\<exists>f\\<in>local.ground_heads (head t).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg t \\<ge>\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     head t >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 4. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "case gt_wt_t_s: gt_wt"], ["proof (state)\nthis:\n  wt t >\\<^sub>p wt s\n\ngoal (4 subgoals):\n 1. wt t >\\<^sub>p wt s \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     \\<not> head t \\<le>\\<ge>\\<^sub>h\\<^sub>d head s; num_args t = 1;\n     \\<exists>f\\<in>local.ground_heads (head t).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg t \\<ge>\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     head t >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 4. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "hence \"wt u >\\<^sub>p wt s\""], ["proof (prove)\nusing this:\n  wt t >\\<^sub>p wt s\n\ngoal (1 subgoal):\n 1. wt u >\\<^sub>p wt s", "using wt_u_ge_t ge_gt_tpoly_trans"], ["proof (prove)\nusing this:\n  wt t >\\<^sub>p wt s\n  wt u \\<ge>\\<^sub>p wt t\n  \\<lbrakk>?r \\<ge>\\<^sub>p ?q; ?q >\\<^sub>p ?p\\<rbrakk>\n  \\<Longrightarrow> ?r >\\<^sub>p ?p\n\ngoal (1 subgoal):\n 1. wt u >\\<^sub>p wt s", "by blast"], ["proof (state)\nthis:\n  wt u >\\<^sub>p wt s\n\ngoal (4 subgoals):\n 1. wt t >\\<^sub>p wt s \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     \\<not> head t \\<le>\\<ge>\\<^sub>h\\<^sub>d head s; num_args t = 1;\n     \\<exists>f\\<in>local.ground_heads (head t).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg t \\<ge>\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     head t >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 4. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "thus ?thesis"], ["proof (prove)\nusing this:\n  wt u >\\<^sub>p wt s\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "by (rule gt_wt)"], ["proof (state)\nthis:\n  u >\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     \\<not> head t \\<le>\\<ge>\\<^sub>h\\<^sub>d head s; num_args t = 1;\n     \\<exists>f\\<in>local.ground_heads (head t).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg t \\<ge>\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     head t >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     \\<not> head t \\<le>\\<ge>\\<^sub>h\\<^sub>d head s; num_args t = 1;\n     \\<exists>f\\<in>local.ground_heads (head t).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg t \\<ge>\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     head t >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "case gt_unary_t_s: gt_unary"], ["proof (state)\nthis:\n  wt t \\<ge>\\<^sub>p wt s\n  \\<not> head t \\<le>\\<ge>\\<^sub>h\\<^sub>d head s\n  num_args t = 1\n  \\<exists>f\\<in>local.ground_heads (head t).\n     arity_sym f = 1 \\<and> wt_sym f = 0\n  arg t \\<ge>\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     \\<not> head t \\<le>\\<ge>\\<^sub>h\\<^sub>d head s; num_args t = 1;\n     \\<exists>f\\<in>local.ground_heads (head t).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg t \\<ge>\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     head t >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "have t_app: \"is_App t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_App t", "by (metis args_Nil_iff_is_Hd gt_unary_t_s(3) length_greater_0_conv less_numeral_extra(1))"], ["proof (state)\nthis:\n  is_App t\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     \\<not> head t \\<le>\\<ge>\\<^sub>h\\<^sub>d head s; num_args t = 1;\n     \\<exists>f\\<in>local.ground_heads (head t).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg t \\<ge>\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     head t >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "hence nargs_fun_t: \"num_args (fun t) < arity_hd (head (fun t))\""], ["proof (prove)\nusing this:\n  is_App t\n\ngoal (1 subgoal):\n 1. enat (num_args (fun t)) < arity_hd (head (fun t))", "by (metis tm.collapse(2) wary_AppE wary_t)"], ["proof (state)\nthis:\n  enat (num_args (fun t)) < arity_hd (head (fun t))\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     \\<not> head t \\<le>\\<ge>\\<^sub>h\\<^sub>d head s; num_args t = 1;\n     \\<exists>f\\<in>local.ground_heads (head t).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg t \\<ge>\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     head t >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "have \\<delta>_eq_\\<epsilon>: \"\\<delta>\\<^sub>h = \\<epsilon>\\<^sub>h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>h = \\<epsilon>\\<^sub>h", "using gt_unary_t_s(4) unary_wt_sym_0_imp_\\<delta>\\<^sub>h_eq_\\<epsilon>\\<^sub>h"], ["proof (prove)\nusing this:\n  \\<exists>f\\<in>local.ground_heads (head t).\n     arity_sym f = 1 \\<and> wt_sym f = 0\n  \\<lbrakk>arity_sym ?f = 1; wt_sym ?f = 0\\<rbrakk>\n  \\<Longrightarrow> \\<delta>\\<^sub>h = \\<epsilon>\\<^sub>h\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>h = \\<epsilon>\\<^sub>h", "by blast"], ["proof (state)\nthis:\n  \\<delta>\\<^sub>h = \\<epsilon>\\<^sub>h\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     \\<not> head t \\<le>\\<ge>\\<^sub>h\\<^sub>d head s; num_args t = 1;\n     \\<exists>f\\<in>local.ground_heads (head t).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg t \\<ge>\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     head t >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "using u_gt_t"], ["proof (prove)\nusing this:\n  u >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "proof cases"], ["proof (state)\ngoal (4 subgoals):\n 1. wt u >\\<^sub>p wt t \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 4. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "case gt_wt_u_t: gt_wt"], ["proof (state)\nthis:\n  wt u >\\<^sub>p wt t\n\ngoal (4 subgoals):\n 1. wt u >\\<^sub>p wt t \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 4. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "hence \"wt u >\\<^sub>p wt s\""], ["proof (prove)\nusing this:\n  wt u >\\<^sub>p wt t\n\ngoal (1 subgoal):\n 1. wt u >\\<^sub>p wt s", "using wt_t_ge_s gt_ge_tpoly_trans"], ["proof (prove)\nusing this:\n  wt u >\\<^sub>p wt t\n  wt t \\<ge>\\<^sub>p wt s\n  \\<lbrakk>?r >\\<^sub>p ?q; ?q \\<ge>\\<^sub>p ?p\\<rbrakk>\n  \\<Longrightarrow> ?r >\\<^sub>p ?p\n\ngoal (1 subgoal):\n 1. wt u >\\<^sub>p wt s", "by blast"], ["proof (state)\nthis:\n  wt u >\\<^sub>p wt s\n\ngoal (4 subgoals):\n 1. wt u >\\<^sub>p wt t \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 4. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "thus ?thesis"], ["proof (prove)\nusing this:\n  wt u >\\<^sub>p wt s\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "by (rule gt_wt)"], ["proof (state)\nthis:\n  u >\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "case gt_unary_u_t: gt_unary"], ["proof (state)\nthis:\n  wt u \\<ge>\\<^sub>p wt t\n  \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t\n  num_args u = 1\n  \\<exists>f\\<in>local.ground_heads (head u).\n     arity_sym f = 1 \\<and> wt_sym f = 0\n  arg u \\<ge>\\<^sub>t t\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "have u_app: \"is_App u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_App u", "by (metis args_Nil_iff_is_Hd gt_unary_u_t(3) length_greater_0_conv less_numeral_extra(1))"], ["proof (state)\nthis:\n  is_App u\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "hence nargs_fun_u: \"num_args (fun u) = 0\""], ["proof (prove)\nusing this:\n  is_App u\n\ngoal (1 subgoal):\n 1. num_args (fun u) = 0", "by (metis args.simps(1) gt_unary_u_t(3) list.size(3) one_arg_imp_Hd tm.collapse(2))"], ["proof (state)\nthis:\n  num_args (fun u) = 0\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "have arg_u_gt_s: \"arg u >\\<^sub>t s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arg u >\\<^sub>t s", "using ih[of \"arg u\" t s] u_app gt_unary_u_t(5) t_gt_s size_arg_lt wary_arg_u wary_s wary_t"], ["proof (prove)\nusing this:\n  \\<lbrakk>{#size (arg u), size t, size s#} < {#size u, size t, size s#};\n   wary (arg u); wary t; wary s; arg u >\\<^sub>t t; t >\\<^sub>t s\\<rbrakk>\n  \\<Longrightarrow> arg u >\\<^sub>t s\n  is_App u\n  arg u \\<ge>\\<^sub>t t\n  t >\\<^sub>t s\n  is_App ?s \\<Longrightarrow> size (arg ?s) < size ?s\n  wary (arg u)\n  wary s\n  wary t\n\ngoal (1 subgoal):\n 1. arg u >\\<^sub>t s", "by force"], ["proof (state)\nthis:\n  arg u >\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "hence arg_u_ge_s: \"arg u \\<ge>\\<^sub>t s\""], ["proof (prove)\nusing this:\n  arg u >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. arg u \\<ge>\\<^sub>t s", "by sat"], ["proof (state)\nthis:\n  arg u \\<ge>\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "{"], ["proof (state)\nthis:\n  arg u \\<ge>\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "assume \"size (arg u) < size t\""], ["proof (state)\nthis:\n  size (arg u) < size t\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "hence \"{#size u, size (arg u), size s#} < {#size u, size t, size s#}\""], ["proof (prove)\nusing this:\n  size (arg u) < size t\n\ngoal (1 subgoal):\n 1. {#size u, size (arg u), size s#} < {#size u, size t, size s#}", "by simp"], ["proof (state)\nthis:\n  {#size u, size (arg u), size s#} < {#size u, size t, size s#}\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "hence ?thesis"], ["proof (prove)\nusing this:\n  {#size u, size (arg u), size s#} < {#size u, size t, size s#}\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "using ih[of u \"arg u\" s] arg_u_gt_s gt_arg u_app wary_s wary_u"], ["proof (prove)\nusing this:\n  {#size u, size (arg u), size s#} < {#size u, size t, size s#}\n  \\<lbrakk>{#size u, size (arg u), size s#} < {#size u, size t, size s#};\n   wary u; wary (arg u); wary s; u >\\<^sub>t arg u;\n   arg u >\\<^sub>t s\\<rbrakk>\n  \\<Longrightarrow> u >\\<^sub>t s\n  arg u >\\<^sub>t s\n  \\<lbrakk>wary ?s; is_App ?s\\<rbrakk> \\<Longrightarrow> ?s >\\<^sub>t arg ?s\n  is_App u\n  wary s\n  wary u\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "by blast"], ["proof (state)\nthis:\n  u >\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "}"], ["proof (state)\nthis:\n  size (arg u) < size t \\<Longrightarrow> u >\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "moreover"], ["proof (state)\nthis:\n  size (arg u) < size t \\<Longrightarrow> u >\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "{"], ["proof (state)\nthis:\n  size (arg u) < size t \\<Longrightarrow> u >\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "assume \"size (arg t) < size s\""], ["proof (state)\nthis:\n  size (arg t) < size s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "hence \"u >\\<^sub>t arg t\""], ["proof (prove)\nusing this:\n  size (arg t) < size s\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t arg t", "using ih[of u t \"arg t\"] args_Nil_iff_is_Hd gt_arg gt_unary_t_s(3) u_gt_t wary_t wary_u"], ["proof (prove)\nusing this:\n  size (arg t) < size s\n  \\<lbrakk>{#size u, size t, size (arg t)#} < {#size u, size t, size s#};\n   wary u; wary t; wary (arg t); u >\\<^sub>t t; t >\\<^sub>t arg t\\<rbrakk>\n  \\<Longrightarrow> u >\\<^sub>t arg t\n  (args ?s = []) = is_Hd ?s\n  \\<lbrakk>wary ?s; is_App ?s\\<rbrakk> \\<Longrightarrow> ?s >\\<^sub>t arg ?s\n  num_args t = 1\n  u >\\<^sub>t t\n  wary t\n  wary u\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t arg t", "by force"], ["proof (state)\nthis:\n  u >\\<^sub>t arg t\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "hence ?thesis"], ["proof (prove)\nusing this:\n  u >\\<^sub>t arg t\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "using ih[of u \"arg t\" s] args_Nil_iff_is_Hd gt_unary_t_s(3,5) size_arg_lt wary_arg_t\n            wary_s wary_u"], ["proof (prove)\nusing this:\n  u >\\<^sub>t arg t\n  \\<lbrakk>{#size u, size (arg t), size s#} < {#size u, size t, size s#};\n   wary u; wary (arg t); wary s; u >\\<^sub>t arg t;\n   arg t >\\<^sub>t s\\<rbrakk>\n  \\<Longrightarrow> u >\\<^sub>t s\n  (args ?s = []) = is_Hd ?s\n  num_args t = 1\n  arg t \\<ge>\\<^sub>t s\n  is_App ?s \\<Longrightarrow> size (arg ?s) < size ?s\n  wary (arg t)\n  wary s\n  wary u\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "by force"], ["proof (state)\nthis:\n  u >\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "}"], ["proof (state)\nthis:\n  size (arg t) < size s \\<Longrightarrow> u >\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "moreover"], ["proof (state)\nthis:\n  size (arg t) < size s \\<Longrightarrow> u >\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "{"], ["proof (state)\nthis:\n  size (arg t) < size s \\<Longrightarrow> u >\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "assume sz_u_gt_t: \"size u > size t\" and sz_t_gt_s: \"size t > size s\""], ["proof (state)\nthis:\n  size t < size u\n  size s < size t\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "{"], ["proof (state)\nthis:\n  size t < size u\n  size s < size t\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "assume hd_u_eq_s: \"head u = head s\""], ["proof (state)\nthis:\n  head u = head s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "hence ary_hd_s: \"arity_hd (head s) = 1\""], ["proof (prove)\nusing this:\n  head u = head s\n\ngoal (1 subgoal):\n 1. arity_hd (head s) = 1", "using ground_heads_arity gt_unary_u_t(3,4) hd_u_eq_s one_enat_def\n              wary_num_args_le_arity_head wary_u"], ["proof (prove)\nusing this:\n  head u = head s\n  ?f \\<in> local.ground_heads ?\\<zeta> \\<Longrightarrow>\n  arity_hd ?\\<zeta> \\<le> arity_sym ?f\n  num_args u = 1\n  \\<exists>f\\<in>local.ground_heads (head u).\n     arity_sym f = 1 \\<and> wt_sym f = 0\n  head u = head s\n  1 = enat 1\n  wary ?s \\<Longrightarrow> enat (num_args ?s) \\<le> arity_hd (head ?s)\n  wary u\n\ngoal (1 subgoal):\n 1. arity_hd (head s) = 1", "by fastforce"], ["proof (state)\nthis:\n  arity_hd (head s) = 1\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "have extf: \"extf f (>\\<^sub>t) (args u) (args s)\" for f"], ["proof (prove)\ngoal (1 subgoal):\n 1. extf f (>\\<^sub>t) (args u) (args s)", "proof (cases \"args s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. args s = [] \\<Longrightarrow> extf f (>\\<^sub>t) (args u) (args s)\n 2. \\<And>a list.\n       args s = a # list \\<Longrightarrow>\n       extf f (>\\<^sub>t) (args u) (args s)", "case Nil"], ["proof (state)\nthis:\n  args s = []\n\ngoal (2 subgoals):\n 1. args s = [] \\<Longrightarrow> extf f (>\\<^sub>t) (args u) (args s)\n 2. \\<And>a list.\n       args s = a # list \\<Longrightarrow>\n       extf f (>\\<^sub>t) (args u) (args s)", "thus ?thesis"], ["proof (prove)\nusing this:\n  args s = []\n\ngoal (1 subgoal):\n 1. extf f (>\\<^sub>t) (args u) (args s)", "by (metis \\<delta>_eq_\\<epsilon> args.elims args_Nil_iff_is_Hd extf_snoc_if_\\<delta>\\<^sub>h_eq_\\<epsilon>\\<^sub>h length_0_conv\n                nargs_fun_u tm.sel(4) u_app)"], ["proof (state)\nthis:\n  extf f (>\\<^sub>t) (args u) (args s)\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       args s = a # list \\<Longrightarrow>\n       extf f (>\\<^sub>t) (args u) (args s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       args s = a # list \\<Longrightarrow>\n       extf f (>\\<^sub>t) (args u) (args s)", "case args_s: (Cons sa ss)"], ["proof (state)\nthis:\n  args s = sa # ss\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       args s = a # list \\<Longrightarrow>\n       extf f (>\\<^sub>t) (args u) (args s)", "hence ss: \"ss = []\""], ["proof (prove)\nusing this:\n  args s = sa # ss\n\ngoal (1 subgoal):\n 1. ss = []", "by (cases s, simp, metis One_nat_def antisym_conv ary_hd_s diff_Suc_1\n                enat_ord_simps(1) le_add2 length_0_conv length_Cons list.size(4) one_enat_def\n                wary_num_args_le_arity_head wary_s)"], ["proof (state)\nthis:\n  ss = []\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       args s = a # list \\<Longrightarrow>\n       extf f (>\\<^sub>t) (args u) (args s)", "have sa: \"sa = arg s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sa = arg s", "by (metis apps.simps(1) apps.simps(2) args_s tm.sel(6) tm_collapse_apps ss)"], ["proof (state)\nthis:\n  sa = arg s\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       args s = a # list \\<Longrightarrow>\n       extf f (>\\<^sub>t) (args u) (args s)", "have s_app: \"is_App s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_App s", "using args_Nil_iff_is_Hd args_s"], ["proof (prove)\nusing this:\n  (args ?s = []) = is_Hd ?s\n  args s = sa # ss\n\ngoal (1 subgoal):\n 1. is_App s", "by force"], ["proof (state)\nthis:\n  is_App s\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       args s = a # list \\<Longrightarrow>\n       extf f (>\\<^sub>t) (args u) (args s)", "have args_u: \"args u = [arg u]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. args u = [arg u]", "by (metis append_Nil args.simps(2) args_Nil_iff_is_Hd gt_unary_u_t(3) length_0_conv\n                nargs_fun_u tm.collapse(2) zero_neq_one)"], ["proof (state)\nthis:\n  args u = [arg u]\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       args s = a # list \\<Longrightarrow>\n       extf f (>\\<^sub>t) (args u) (args s)", "have max_sz_arg_u_t_arg_t: \"Max {size (arg t), size t, size (arg u)} < size u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max {size (arg t), size t, size (arg u)} < size u", "using size_arg_lt sz_u_gt_t t_app u_app"], ["proof (prove)\nusing this:\n  is_App ?s \\<Longrightarrow> size (arg ?s) < size ?s\n  size t < size u\n  is_App t\n  is_App u\n\ngoal (1 subgoal):\n 1. Max {size (arg t), size t, size (arg u)} < size u", "by fastforce"], ["proof (state)\nthis:\n  Max {size (arg t), size t, size (arg u)} < size u\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       args s = a # list \\<Longrightarrow>\n       extf f (>\\<^sub>t) (args u) (args s)", "have \"{#size (arg u), size t, size (arg t)#} < {#size u, size t, size s#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#size (arg u), size t, size (arg t)#} < {#size u, size t, size s#}", "using max_sz_arg_u_t_arg_t"], ["proof (prove)\nusing this:\n  Max {size (arg t), size t, size (arg u)} < size u\n\ngoal (1 subgoal):\n 1. {#size (arg u), size t, size (arg t)#} < {#size u, size t, size s#}", "by (auto intro!: Max_lt_imp_lt_mset)"], ["proof (state)\nthis:\n  {#size (arg u), size t, size (arg t)#} < {#size u, size t, size s#}\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       args s = a # list \\<Longrightarrow>\n       extf f (>\\<^sub>t) (args u) (args s)", "hence arg_u_gt_arg_t: \"arg u >\\<^sub>t arg t\""], ["proof (prove)\nusing this:\n  {#size (arg u), size t, size (arg t)#} < {#size u, size t, size s#}\n\ngoal (1 subgoal):\n 1. arg u >\\<^sub>t arg t", "using ih[OF _ wary_arg_u wary_t wary_arg_t] args_Nil_iff_is_Hd gt_arg\n                gt_unary_t_s(3) gt_unary_u_t(5) wary_t"], ["proof (prove)\nusing this:\n  {#size (arg u), size t, size (arg t)#} < {#size u, size t, size s#}\n  \\<lbrakk>{#size (arg u), size t, size (arg t)#}\n           < {#size u, size t, size s#};\n   arg u >\\<^sub>t t; t >\\<^sub>t arg t\\<rbrakk>\n  \\<Longrightarrow> arg u >\\<^sub>t arg t\n  (args ?s = []) = is_Hd ?s\n  \\<lbrakk>wary ?s; is_App ?s\\<rbrakk> \\<Longrightarrow> ?s >\\<^sub>t arg ?s\n  num_args t = 1\n  arg u \\<ge>\\<^sub>t t\n  wary t\n\ngoal (1 subgoal):\n 1. arg u >\\<^sub>t arg t", "by force"], ["proof (state)\nthis:\n  arg u >\\<^sub>t arg t\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       args s = a # list \\<Longrightarrow>\n       extf f (>\\<^sub>t) (args u) (args s)", "have max_sz_arg_s_s_arg_t: \"Max {size (arg s), size s, size (arg t)} < size u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Max {size (arg s), size s, size (arg t)} < size u", "using s_app t_app size_arg_lt sz_t_gt_s sz_u_gt_t"], ["proof (prove)\nusing this:\n  is_App s\n  is_App t\n  is_App ?s \\<Longrightarrow> size (arg ?s) < size ?s\n  size s < size t\n  size t < size u\n\ngoal (1 subgoal):\n 1. Max {size (arg s), size s, size (arg t)} < size u", "by force"], ["proof (state)\nthis:\n  Max {size (arg s), size s, size (arg t)} < size u\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       args s = a # list \\<Longrightarrow>\n       extf f (>\\<^sub>t) (args u) (args s)", "have \"{#size (arg t), size s, size (arg s)#} < {#size u, size t, size s#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#size (arg t), size s, size (arg s)#} < {#size u, size t, size s#}", "using max_sz_arg_s_s_arg_t"], ["proof (prove)\nusing this:\n  Max {size (arg s), size s, size (arg t)} < size u\n\ngoal (1 subgoal):\n 1. {#size (arg t), size s, size (arg s)#} < {#size u, size t, size s#}", "by (auto intro!: Max_lt_imp_lt_mset)"], ["proof (state)\nthis:\n  {#size (arg t), size s, size (arg s)#} < {#size u, size t, size s#}\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       args s = a # list \\<Longrightarrow>\n       extf f (>\\<^sub>t) (args u) (args s)", "hence arg_t_gt_arg_s: \"arg t >\\<^sub>t arg s\""], ["proof (prove)\nusing this:\n  {#size (arg t), size s, size (arg s)#} < {#size u, size t, size s#}\n\ngoal (1 subgoal):\n 1. arg t >\\<^sub>t arg s", "using ih[OF _ wary_arg_t wary_s wary_arg_s]\n                gt_unary_t_s(5) gt_arg args_Nil_iff_is_Hd args_s wary_s"], ["proof (prove)\nusing this:\n  {#size (arg t), size s, size (arg s)#} < {#size u, size t, size s#}\n  \\<lbrakk>{#size (arg t), size s, size (arg s)#}\n           < {#size u, size t, size s#};\n   arg t >\\<^sub>t s; s >\\<^sub>t arg s\\<rbrakk>\n  \\<Longrightarrow> arg t >\\<^sub>t arg s\n  arg t \\<ge>\\<^sub>t s\n  \\<lbrakk>wary ?s; is_App ?s\\<rbrakk> \\<Longrightarrow> ?s >\\<^sub>t arg ?s\n  (args ?s = []) = is_Hd ?s\n  args s = sa # ss\n  wary s\n\ngoal (1 subgoal):\n 1. arg t >\\<^sub>t arg s", "by force"], ["proof (state)\nthis:\n  arg t >\\<^sub>t arg s\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       args s = a # list \\<Longrightarrow>\n       extf f (>\\<^sub>t) (args u) (args s)", "have \"{#size (arg u), size (arg t), size (arg s)#} < {#size u, size t, size s#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#size (arg u), size (arg t), size (arg s)#}\n    < {#size u, size t, size s#}", "by (auto intro!: add_mset_lt_lt_lt simp: size_arg_lt u_app t_app s_app)"], ["proof (state)\nthis:\n  {#size (arg u), size (arg t), size (arg s)#} < {#size u, size t, size s#}\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       args s = a # list \\<Longrightarrow>\n       extf f (>\\<^sub>t) (args u) (args s)", "hence \"arg u >\\<^sub>t arg s\""], ["proof (prove)\nusing this:\n  {#size (arg u), size (arg t), size (arg s)#} < {#size u, size t, size s#}\n\ngoal (1 subgoal):\n 1. arg u >\\<^sub>t arg s", "using ih[of \"arg u\" \"arg t\" \"arg s\"] arg_u_gt_arg_t arg_t_gt_arg_s wary_arg_s\n                wary_arg_t wary_arg_u"], ["proof (prove)\nusing this:\n  {#size (arg u), size (arg t), size (arg s)#} < {#size u, size t, size s#}\n  \\<lbrakk>{#size (arg u), size (arg t), size (arg s)#}\n           < {#size u, size t, size s#};\n   wary (arg u); wary (arg t); wary (arg s); arg u >\\<^sub>t arg t;\n   arg t >\\<^sub>t arg s\\<rbrakk>\n  \\<Longrightarrow> arg u >\\<^sub>t arg s\n  arg u >\\<^sub>t arg t\n  arg t >\\<^sub>t arg s\n  wary (arg s)\n  wary (arg t)\n  wary (arg u)\n\ngoal (1 subgoal):\n 1. arg u >\\<^sub>t arg s", "by blast"], ["proof (state)\nthis:\n  arg u >\\<^sub>t arg s\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       args s = a # list \\<Longrightarrow>\n       extf f (>\\<^sub>t) (args u) (args s)", "thus ?thesis"], ["proof (prove)\nusing this:\n  arg u >\\<^sub>t arg s\n\ngoal (1 subgoal):\n 1. extf f (>\\<^sub>t) (args u) (args s)", "unfolding args_u args_s ss sa"], ["proof (prove)\nusing this:\n  arg u >\\<^sub>t arg s\n\ngoal (1 subgoal):\n 1. extf f (>\\<^sub>t) [arg u] [arg s]", "by (metis extf_singleton gt_irrefl wary_arg_u)"], ["proof (state)\nthis:\n  extf f (>\\<^sub>t) (args u) (args s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  extf ?f (>\\<^sub>t) (args u) (args s)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "have ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "by (rule gt_same[OF wt_u_ge_s hd_u_eq_s]) (simp add: extf)"], ["proof (state)\nthis:\n  u >\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "}"], ["proof (state)\nthis:\n  head u = head s \\<Longrightarrow> u >\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "moreover"], ["proof (state)\nthis:\n  head u = head s \\<Longrightarrow> u >\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "{"], ["proof (state)\nthis:\n  head u = head s \\<Longrightarrow> u >\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "assume \"head u >\\<^sub>h\\<^sub>d head s\""], ["proof (state)\nthis:\n  head u >\\<^sub>h\\<^sub>d head s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "hence ?thesis"], ["proof (prove)\nusing this:\n  head u >\\<^sub>h\\<^sub>d head s\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "by (rule gt_diff[OF wt_u_ge_s])"], ["proof (state)\nthis:\n  u >\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "}"], ["proof (state)\nthis:\n  head u >\\<^sub>h\\<^sub>d head s \\<Longrightarrow> u >\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "moreover"], ["proof (state)\nthis:\n  head u >\\<^sub>h\\<^sub>d head s \\<Longrightarrow> u >\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "{"], ["proof (state)\nthis:\n  head u >\\<^sub>h\\<^sub>d head s \\<Longrightarrow> u >\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "assume \"head s >\\<^sub>h\\<^sub>d head u\""], ["proof (state)\nthis:\n  head s >\\<^sub>h\\<^sub>d head u\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "hence False"], ["proof (prove)\nusing this:\n  head s >\\<^sub>h\\<^sub>d head u\n\ngoal (1 subgoal):\n 1. False", "using gt_hd_def gt_hd_irrefl gt_sym_antisym gt_unary_u_t(4) unary_wt_sym_0_gt"], ["proof (prove)\nusing this:\n  head s >\\<^sub>h\\<^sub>d head u\n  (?\\<xi> >\\<^sub>h\\<^sub>d ?\\<zeta>) =\n  (\\<forall>g\\<in>local.ground_heads ?\\<xi>.\n      \\<forall>f\\<in>local.ground_heads ?\\<zeta>. g >\\<^sub>s f)\n  \\<not> ?\\<zeta> >\\<^sub>h\\<^sub>d ?\\<zeta>\n  ?f >\\<^sub>s ?g \\<Longrightarrow> \\<not> ?g >\\<^sub>s ?f\n  \\<exists>f\\<in>local.ground_heads (head u).\n     arity_sym f = 1 \\<and> wt_sym f = 0\n  \\<lbrakk>arity_sym ?f = 1; wt_sym ?f = 0\\<rbrakk>\n  \\<Longrightarrow> ?f >\\<^sub>s ?g \\<or> ?g = ?f\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "}"], ["proof (state)\nthis:\n  head s >\\<^sub>h\\<^sub>d head u \\<Longrightarrow> False\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "moreover"], ["proof (state)\nthis:\n  head s >\\<^sub>h\\<^sub>d head u \\<Longrightarrow> False\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "{"], ["proof (state)\nthis:\n  head s >\\<^sub>h\\<^sub>d head u \\<Longrightarrow> False\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "assume \"\\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head s\""], ["proof (state)\nthis:\n  \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "hence ?thesis"], ["proof (prove)\nusing this:\n  \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head s\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "by (rule gt_unary[OF wt_u_ge_s _ gt_unary_u_t(3,4) arg_u_ge_s])"], ["proof (state)\nthis:\n  u >\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "}"], ["proof (state)\nthis:\n  \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head s \\<Longrightarrow>\n  u >\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "ultimately"], ["proof (chain)\npicking this:\n  head u = head s \\<Longrightarrow> u >\\<^sub>t s\n  head u >\\<^sub>h\\<^sub>d head s \\<Longrightarrow> u >\\<^sub>t s\n  head s >\\<^sub>h\\<^sub>d head u \\<Longrightarrow> False\n  \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head s \\<Longrightarrow>\n  u >\\<^sub>t s", "have ?thesis"], ["proof (prove)\nusing this:\n  head u = head s \\<Longrightarrow> u >\\<^sub>t s\n  head u >\\<^sub>h\\<^sub>d head s \\<Longrightarrow> u >\\<^sub>t s\n  head s >\\<^sub>h\\<^sub>d head u \\<Longrightarrow> False\n  \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head s \\<Longrightarrow>\n  u >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "unfolding comp_hd_def"], ["proof (prove)\nusing this:\n  head u = head s \\<Longrightarrow> u >\\<^sub>t s\n  head u >\\<^sub>h\\<^sub>d head s \\<Longrightarrow> u >\\<^sub>t s\n  head s >\\<^sub>h\\<^sub>d head u \\<Longrightarrow> False\n  \\<not> (head u = head s \\<or>\n          head u >\\<^sub>h\\<^sub>d head s \\<or>\n          head s >\\<^sub>h\\<^sub>d head u) \\<Longrightarrow>\n  u >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "by sat"], ["proof (state)\nthis:\n  u >\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "}"], ["proof (state)\nthis:\n  \\<lbrakk>size t < size u; size s < size t\\<rbrakk>\n  \\<Longrightarrow> u >\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "ultimately"], ["proof (chain)\npicking this:\n  size (arg u) < size t \\<Longrightarrow> u >\\<^sub>t s\n  size (arg t) < size s \\<Longrightarrow> u >\\<^sub>t s\n  \\<lbrakk>size t < size u; size s < size t\\<rbrakk>\n  \\<Longrightarrow> u >\\<^sub>t s", "show ?thesis"], ["proof (prove)\nusing this:\n  size (arg u) < size t \\<Longrightarrow> u >\\<^sub>t s\n  size (arg t) < size s \\<Longrightarrow> u >\\<^sub>t s\n  \\<lbrakk>size t < size u; size s < size t\\<rbrakk>\n  \\<Longrightarrow> u >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "by (meson less_le_trans linorder_not_le size_arg_lt t_app u_app)"], ["proof (state)\nthis:\n  u >\\<^sub>t s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "case gt_diff_u_t: gt_diff"], ["proof (state)\nthis:\n  wt u \\<ge>\\<^sub>p wt t\n  head u >\\<^sub>h\\<^sub>d head t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "have False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using gt_diff_u_t(2) gt_hd_def gt_hd_irrefl gt_sym_antisym gt_unary_t_s(4) unary_wt_sym_0_gt"], ["proof (prove)\nusing this:\n  head u >\\<^sub>h\\<^sub>d head t\n  (?\\<xi> >\\<^sub>h\\<^sub>d ?\\<zeta>) =\n  (\\<forall>g\\<in>local.ground_heads ?\\<xi>.\n      \\<forall>f\\<in>local.ground_heads ?\\<zeta>. g >\\<^sub>s f)\n  \\<not> ?\\<zeta> >\\<^sub>h\\<^sub>d ?\\<zeta>\n  ?f >\\<^sub>s ?g \\<Longrightarrow> \\<not> ?g >\\<^sub>s ?f\n  \\<exists>f\\<in>local.ground_heads (head t).\n     arity_sym f = 1 \\<and> wt_sym f = 0\n  \\<lbrakk>arity_sym ?f = 1; wt_sym ?f = 0\\<rbrakk>\n  \\<Longrightarrow> ?f >\\<^sub>s ?g \\<or> ?g = ?f\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "by sat"], ["proof (state)\nthis:\n  u >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "case gt_same_u_t: gt_same"], ["proof (state)\nthis:\n  wt u \\<ge>\\<^sub>p wt t\n  head u = head t\n  \\<forall>f\\<in>local.ground_heads (head u).\n     extf f (>\\<^sub>t) (args u) (args t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "have hd_u_ncomp_s: \"\\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head s", "by (rule gt_unary_t_s(2)[folded gt_same_u_t(2)])"], ["proof (state)\nthis:\n  \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "have \"\\<exists>f \\<in> ground_heads (head u). arity_sym f = 1 \\<and> wt_sym f = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f\\<in>local.ground_heads (head u).\n       arity_sym f = 1 \\<and> wt_sym f = 0", "by (rule gt_unary_t_s(4)[folded gt_same_u_t(2)])"], ["proof (state)\nthis:\n  \\<exists>f\\<in>local.ground_heads (head u).\n     arity_sym f = 1 \\<and> wt_sym f = 0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "hence \"arity_hd (head u) = 1\""], ["proof (prove)\nusing this:\n  \\<exists>f\\<in>local.ground_heads (head u).\n     arity_sym f = 1 \\<and> wt_sym f = 0\n\ngoal (1 subgoal):\n 1. arity_hd (head u) = 1", "by (metis dual_order.order_iff_strict gr_implies_not_zero_hmset ground_heads_arity\n          gt_same_u_t(2) head_fun hmset_of_enat_1 hmset_of_enat_less lt_1_iff_eq_0_hmset\n          nargs_fun_t)"], ["proof (state)\nthis:\n  arity_hd (head u) = 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "hence \"num_args u \\<le> 1\""], ["proof (prove)\nusing this:\n  arity_hd (head u) = 1\n\ngoal (1 subgoal):\n 1. num_args u \\<le> 1", "using of_nat_le_hmset wary_num_args_le_arity_head\\<^sub>h wary_u"], ["proof (prove)\nusing this:\n  arity_hd (head u) = 1\n  (of_nat ?M \\<le> of_nat ?N) = (?M \\<le> ?N)\n  wary ?s \\<Longrightarrow>\n  of_nat (num_args ?s) \\<le> arity_hd\\<^sub>h (head ?s)\n  wary u\n\ngoal (1 subgoal):\n 1. num_args u \\<le> 1", "by fastforce"], ["proof (state)\nthis:\n  num_args u \\<le> 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "hence nargs_u: \"num_args u = 1\""], ["proof (prove)\nusing this:\n  num_args u \\<le> 1\n\ngoal (1 subgoal):\n 1. num_args u = 1", "by (cases \"args u\",\n          metis Hd_head_id \\<delta>_eq_\\<epsilon> append_Nil args.simps(2)\n            ex_in_conv[THEN iffD2, OF ground_heads_nonempty] gt_same_u_t(2,3) gt_unary_t_s(3)\n            head_fun list.size(3) not_extf_gt_nil_singleton_if_\\<delta>\\<^sub>h_eq_\\<epsilon>\\<^sub>h one_arg_imp_Hd\n            tm.collapse(2)[OF t_app] wary_arg_t,\n          simp)"], ["proof (state)\nthis:\n  num_args u = 1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "hence u_app: \"is_App u\""], ["proof (prove)\nusing this:\n  num_args u = 1\n\ngoal (1 subgoal):\n 1. is_App u", "by (cases u) auto"], ["proof (state)\nthis:\n  is_App u\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "have \"arg u >\\<^sub>t arg t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arg u >\\<^sub>t arg t", "by (metis extf_singleton[THEN iffD1] append_Nil args.simps args_Nil_iff_is_Hd comp_hd_def\n          gt_hd_def gt_irrefl gt_same_u_t(2,3) gt_unary_t_s(2,3) head_fun length_0_conv nargs_u\n          one_arg_imp_Hd t_app tm.collapse(2) u_gt_t wary_u)"], ["proof (state)\nthis:\n  arg u >\\<^sub>t arg t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "moreover"], ["proof (state)\nthis:\n  arg u >\\<^sub>t arg t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "have \"{#size (arg u), size (arg t), size s#} < {#size u, size t, size s#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {#size (arg u), size (arg t), size s#} < {#size u, size t, size s#}", "by (auto intro!: add_mset_lt_lt_lt simp: size_arg_lt u_app t_app)"], ["proof (state)\nthis:\n  {#size (arg u), size (arg t), size s#} < {#size u, size t, size s#}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "ultimately"], ["proof (chain)\npicking this:\n  arg u >\\<^sub>t arg t\n  {#size (arg u), size (arg t), size s#} < {#size u, size t, size s#}", "have \"arg u >\\<^sub>t s\""], ["proof (prove)\nusing this:\n  arg u >\\<^sub>t arg t\n  {#size (arg u), size (arg t), size s#} < {#size u, size t, size s#}\n\ngoal (1 subgoal):\n 1. arg u >\\<^sub>t s", "using ih[OF _ wary_arg_u wary_arg_t wary_s] gt_unary_t_s(5)"], ["proof (prove)\nusing this:\n  arg u >\\<^sub>t arg t\n  {#size (arg u), size (arg t), size s#} < {#size u, size t, size s#}\n  \\<lbrakk>{#size (arg u), size (arg t), size s#}\n           < {#size u, size t, size s#};\n   arg u >\\<^sub>t arg t; arg t >\\<^sub>t s\\<rbrakk>\n  \\<Longrightarrow> arg u >\\<^sub>t s\n  arg t \\<ge>\\<^sub>t s\n\ngoal (1 subgoal):\n 1. arg u >\\<^sub>t s", "by blast"], ["proof (state)\nthis:\n  arg u >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "hence arg_u_ge_s: \"arg u \\<ge>\\<^sub>t s\""], ["proof (prove)\nusing this:\n  arg u >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. arg u \\<ge>\\<^sub>t s", "by sat"], ["proof (state)\nthis:\n  arg u \\<ge>\\<^sub>t s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "by (rule gt_unary[OF wt_u_ge_s hd_u_ncomp_s nargs_u _ arg_u_ge_s])\n          (simp add: gt_same_u_t(2) gt_unary_t_s(4))"], ["proof (state)\nthis:\n  u >\\<^sub>t s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u >\\<^sub>t s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     head t >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     head t >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "case gt_diff_t_s: gt_diff"], ["proof (state)\nthis:\n  wt t \\<ge>\\<^sub>p wt s\n  head t >\\<^sub>h\\<^sub>d head s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     head t >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "using u_gt_t"], ["proof (prove)\nusing this:\n  u >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "proof cases"], ["proof (state)\ngoal (4 subgoals):\n 1. wt u >\\<^sub>p wt t \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 4. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "case gt_wt_u_t: gt_wt"], ["proof (state)\nthis:\n  wt u >\\<^sub>p wt t\n\ngoal (4 subgoals):\n 1. wt u >\\<^sub>p wt t \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 4. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "hence \"wt u >\\<^sub>p wt s\""], ["proof (prove)\nusing this:\n  wt u >\\<^sub>p wt t\n\ngoal (1 subgoal):\n 1. wt u >\\<^sub>p wt s", "using wt_t_ge_s gt_ge_tpoly_trans"], ["proof (prove)\nusing this:\n  wt u >\\<^sub>p wt t\n  wt t \\<ge>\\<^sub>p wt s\n  \\<lbrakk>?r >\\<^sub>p ?q; ?q \\<ge>\\<^sub>p ?p\\<rbrakk>\n  \\<Longrightarrow> ?r >\\<^sub>p ?p\n\ngoal (1 subgoal):\n 1. wt u >\\<^sub>p wt s", "by blast"], ["proof (state)\nthis:\n  wt u >\\<^sub>p wt s\n\ngoal (4 subgoals):\n 1. wt u >\\<^sub>p wt t \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 4. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "thus ?thesis"], ["proof (prove)\nusing this:\n  wt u >\\<^sub>p wt s\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "by (rule gt_wt)"], ["proof (state)\nthis:\n  u >\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "case gt_unary_u_t: gt_unary"], ["proof (state)\nthis:\n  wt u \\<ge>\\<^sub>p wt t\n  \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t\n  num_args u = 1\n  \\<exists>f\\<in>local.ground_heads (head u).\n     arity_sym f = 1 \\<and> wt_sym f = 0\n  arg u \\<ge>\\<^sub>t t\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "have u_app: \"is_App u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_App u", "by (metis args_Nil_iff_is_Hd gt_unary_u_t(3) length_greater_0_conv less_numeral_extra(1))"], ["proof (state)\nthis:\n  is_App u\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "hence \"arg u >\\<^sub>t s\""], ["proof (prove)\nusing this:\n  is_App u\n\ngoal (1 subgoal):\n 1. arg u >\\<^sub>t s", "using ih[of \"arg u\" t s] gt_unary_u_t(5) t_gt_s size_arg_lt wary_arg_u wary_s wary_t"], ["proof (prove)\nusing this:\n  is_App u\n  \\<lbrakk>{#size (arg u), size t, size s#} < {#size u, size t, size s#};\n   wary (arg u); wary t; wary s; arg u >\\<^sub>t t; t >\\<^sub>t s\\<rbrakk>\n  \\<Longrightarrow> arg u >\\<^sub>t s\n  arg u \\<ge>\\<^sub>t t\n  t >\\<^sub>t s\n  is_App ?s \\<Longrightarrow> size (arg ?s) < size ?s\n  wary (arg u)\n  wary s\n  wary t\n\ngoal (1 subgoal):\n 1. arg u >\\<^sub>t s", "by force"], ["proof (state)\nthis:\n  arg u >\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "hence arg_u_ge_s: \"arg u \\<ge>\\<^sub>t s\""], ["proof (prove)\nusing this:\n  arg u >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. arg u \\<ge>\\<^sub>t s", "by sat"], ["proof (state)\nthis:\n  arg u \\<ge>\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "{"], ["proof (state)\nthis:\n  arg u \\<ge>\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "assume \"head u = head s\""], ["proof (state)\nthis:\n  head u = head s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "hence False"], ["proof (prove)\nusing this:\n  head u = head s\n\ngoal (1 subgoal):\n 1. False", "using gt_diff_t_s(2) gt_unary_u_t(2)"], ["proof (prove)\nusing this:\n  head u = head s\n  head t >\\<^sub>h\\<^sub>d head s\n  \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t\n\ngoal (1 subgoal):\n 1. False", "unfolding comp_hd_def"], ["proof (prove)\nusing this:\n  head u = head s\n  head t >\\<^sub>h\\<^sub>d head s\n  \\<not> (head u = head t \\<or>\n          head u >\\<^sub>h\\<^sub>d head t \\<or>\n          head t >\\<^sub>h\\<^sub>d head u)\n\ngoal (1 subgoal):\n 1. False", "by force"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "}"], ["proof (state)\nthis:\n  head u = head s \\<Longrightarrow> False\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "moreover"], ["proof (state)\nthis:\n  head u = head s \\<Longrightarrow> False\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "{"], ["proof (state)\nthis:\n  head u = head s \\<Longrightarrow> False\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "assume \"head s >\\<^sub>h\\<^sub>d head u\""], ["proof (state)\nthis:\n  head s >\\<^sub>h\\<^sub>d head u\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "hence False"], ["proof (prove)\nusing this:\n  head s >\\<^sub>h\\<^sub>d head u\n\ngoal (1 subgoal):\n 1. False", "using gt_hd_def gt_hd_irrefl gt_sym_antisym gt_unary_u_t(4) unary_wt_sym_0_gt"], ["proof (prove)\nusing this:\n  head s >\\<^sub>h\\<^sub>d head u\n  (?\\<xi> >\\<^sub>h\\<^sub>d ?\\<zeta>) =\n  (\\<forall>g\\<in>local.ground_heads ?\\<xi>.\n      \\<forall>f\\<in>local.ground_heads ?\\<zeta>. g >\\<^sub>s f)\n  \\<not> ?\\<zeta> >\\<^sub>h\\<^sub>d ?\\<zeta>\n  ?f >\\<^sub>s ?g \\<Longrightarrow> \\<not> ?g >\\<^sub>s ?f\n  \\<exists>f\\<in>local.ground_heads (head u).\n     arity_sym f = 1 \\<and> wt_sym f = 0\n  \\<lbrakk>arity_sym ?f = 1; wt_sym ?f = 0\\<rbrakk>\n  \\<Longrightarrow> ?f >\\<^sub>s ?g \\<or> ?g = ?f\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "}"], ["proof (state)\nthis:\n  head s >\\<^sub>h\\<^sub>d head u \\<Longrightarrow> False\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "moreover"], ["proof (state)\nthis:\n  head s >\\<^sub>h\\<^sub>d head u \\<Longrightarrow> False\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "{"], ["proof (state)\nthis:\n  head s >\\<^sub>h\\<^sub>d head u \\<Longrightarrow> False\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "assume \"head u >\\<^sub>h\\<^sub>d head s\""], ["proof (state)\nthis:\n  head u >\\<^sub>h\\<^sub>d head s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "hence ?thesis"], ["proof (prove)\nusing this:\n  head u >\\<^sub>h\\<^sub>d head s\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "by (rule gt_diff[OF wt_u_ge_s])"], ["proof (state)\nthis:\n  u >\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "}"], ["proof (state)\nthis:\n  head u >\\<^sub>h\\<^sub>d head s \\<Longrightarrow> u >\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "moreover"], ["proof (state)\nthis:\n  head u >\\<^sub>h\\<^sub>d head s \\<Longrightarrow> u >\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "{"], ["proof (state)\nthis:\n  head u >\\<^sub>h\\<^sub>d head s \\<Longrightarrow> u >\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "assume \"\\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head s\""], ["proof (state)\nthis:\n  \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "hence ?thesis"], ["proof (prove)\nusing this:\n  \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head s\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "by (rule gt_unary[OF wt_u_ge_s _ gt_unary_u_t(3,4) arg_u_ge_s])"], ["proof (state)\nthis:\n  u >\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "}"], ["proof (state)\nthis:\n  \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head s \\<Longrightarrow>\n  u >\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "ultimately"], ["proof (chain)\npicking this:\n  head u = head s \\<Longrightarrow> False\n  head s >\\<^sub>h\\<^sub>d head u \\<Longrightarrow> False\n  head u >\\<^sub>h\\<^sub>d head s \\<Longrightarrow> u >\\<^sub>t s\n  \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head s \\<Longrightarrow>\n  u >\\<^sub>t s", "show ?thesis"], ["proof (prove)\nusing this:\n  head u = head s \\<Longrightarrow> False\n  head s >\\<^sub>h\\<^sub>d head u \\<Longrightarrow> False\n  head u >\\<^sub>h\\<^sub>d head s \\<Longrightarrow> u >\\<^sub>t s\n  \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head s \\<Longrightarrow>\n  u >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "unfolding comp_hd_def"], ["proof (prove)\nusing this:\n  head u = head s \\<Longrightarrow> False\n  head s >\\<^sub>h\\<^sub>d head u \\<Longrightarrow> False\n  head u >\\<^sub>h\\<^sub>d head s \\<Longrightarrow> u >\\<^sub>t s\n  \\<not> (head u = head s \\<or>\n          head u >\\<^sub>h\\<^sub>d head s \\<or>\n          head s >\\<^sub>h\\<^sub>d head u) \\<Longrightarrow>\n  u >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "by sat"], ["proof (state)\nthis:\n  u >\\<^sub>t s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "case gt_diff_u_t: gt_diff"], ["proof (state)\nthis:\n  wt u \\<ge>\\<^sub>p wt t\n  head u >\\<^sub>h\\<^sub>d head t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "have \"head u >\\<^sub>h\\<^sub>d head s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. head u >\\<^sub>h\\<^sub>d head s", "using gt_diff_u_t(2) gt_diff_t_s(2) gt_hd_trans"], ["proof (prove)\nusing this:\n  head u >\\<^sub>h\\<^sub>d head t\n  head t >\\<^sub>h\\<^sub>d head s\n  \\<lbrakk>?\\<chi> >\\<^sub>h\\<^sub>d ?\\<xi>;\n   ?\\<xi> >\\<^sub>h\\<^sub>d ?\\<zeta>\\<rbrakk>\n  \\<Longrightarrow> ?\\<chi> >\\<^sub>h\\<^sub>d ?\\<zeta>\n\ngoal (1 subgoal):\n 1. head u >\\<^sub>h\\<^sub>d head s", "by blast"], ["proof (state)\nthis:\n  head u >\\<^sub>h\\<^sub>d head s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "thus ?thesis"], ["proof (prove)\nusing this:\n  head u >\\<^sub>h\\<^sub>d head s\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "by (rule gt_diff[OF wt_u_ge_s])"], ["proof (state)\nthis:\n  u >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "case gt_same_u_t: gt_same"], ["proof (state)\nthis:\n  wt u \\<ge>\\<^sub>p wt t\n  head u = head t\n  \\<forall>f\\<in>local.ground_heads (head u).\n     extf f (>\\<^sub>t) (args u) (args t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "have \"head u >\\<^sub>h\\<^sub>d head s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. head u >\\<^sub>h\\<^sub>d head s", "using gt_diff_t_s(2) gt_same_u_t(2)"], ["proof (prove)\nusing this:\n  head t >\\<^sub>h\\<^sub>d head s\n  head u = head t\n\ngoal (1 subgoal):\n 1. head u >\\<^sub>h\\<^sub>d head s", "by simp"], ["proof (state)\nthis:\n  head u >\\<^sub>h\\<^sub>d head s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "thus ?thesis"], ["proof (prove)\nusing this:\n  head u >\\<^sub>h\\<^sub>d head s\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "by (rule gt_diff[OF wt_u_ge_s])"], ["proof (state)\nthis:\n  u >\\<^sub>t s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "case gt_same_t_s: gt_same"], ["proof (state)\nthis:\n  wt t \\<ge>\\<^sub>p wt s\n  head t = head s\n  \\<forall>f\\<in>local.ground_heads (head t).\n     extf f (>\\<^sub>t) (args t) (args s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "using u_gt_t"], ["proof (prove)\nusing this:\n  u >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "proof cases"], ["proof (state)\ngoal (4 subgoals):\n 1. wt u >\\<^sub>p wt t \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 4. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "case gt_wt_u_t: gt_wt"], ["proof (state)\nthis:\n  wt u >\\<^sub>p wt t\n\ngoal (4 subgoals):\n 1. wt u >\\<^sub>p wt t \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 4. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "hence \"wt u >\\<^sub>p wt s\""], ["proof (prove)\nusing this:\n  wt u >\\<^sub>p wt t\n\ngoal (1 subgoal):\n 1. wt u >\\<^sub>p wt s", "using wt_t_ge_s gt_ge_tpoly_trans"], ["proof (prove)\nusing this:\n  wt u >\\<^sub>p wt t\n  wt t \\<ge>\\<^sub>p wt s\n  \\<lbrakk>?r >\\<^sub>p ?q; ?q \\<ge>\\<^sub>p ?p\\<rbrakk>\n  \\<Longrightarrow> ?r >\\<^sub>p ?p\n\ngoal (1 subgoal):\n 1. wt u >\\<^sub>p wt s", "by blast"], ["proof (state)\nthis:\n  wt u >\\<^sub>p wt s\n\ngoal (4 subgoals):\n 1. wt u >\\<^sub>p wt t \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 4. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "thus ?thesis"], ["proof (prove)\nusing this:\n  wt u >\\<^sub>p wt s\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "by (rule gt_wt)"], ["proof (state)\nthis:\n  u >\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "case gt_unary_u_t: gt_unary"], ["proof (state)\nthis:\n  wt u \\<ge>\\<^sub>p wt t\n  \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t\n  num_args u = 1\n  \\<exists>f\\<in>local.ground_heads (head u).\n     arity_sym f = 1 \\<and> wt_sym f = 0\n  arg u \\<ge>\\<^sub>t t\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "have \"is_App u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_App u", "by (metis args_Nil_iff_is_Hd gt_unary_u_t(3) length_greater_0_conv less_numeral_extra(1))"], ["proof (state)\nthis:\n  is_App u\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "hence \"arg u >\\<^sub>t s\""], ["proof (prove)\nusing this:\n  is_App u\n\ngoal (1 subgoal):\n 1. arg u >\\<^sub>t s", "using ih[of \"arg u\" t s] gt_unary_u_t(5) t_gt_s size_arg_lt wary_arg_u wary_s wary_t"], ["proof (prove)\nusing this:\n  is_App u\n  \\<lbrakk>{#size (arg u), size t, size s#} < {#size u, size t, size s#};\n   wary (arg u); wary t; wary s; arg u >\\<^sub>t t; t >\\<^sub>t s\\<rbrakk>\n  \\<Longrightarrow> arg u >\\<^sub>t s\n  arg u \\<ge>\\<^sub>t t\n  t >\\<^sub>t s\n  is_App ?s \\<Longrightarrow> size (arg ?s) < size ?s\n  wary (arg u)\n  wary s\n  wary t\n\ngoal (1 subgoal):\n 1. arg u >\\<^sub>t s", "by force"], ["proof (state)\nthis:\n  arg u >\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "hence arg_u_ge_s: \"arg u \\<ge>\\<^sub>t s\""], ["proof (prove)\nusing this:\n  arg u >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. arg u \\<ge>\\<^sub>t s", "by sat"], ["proof (state)\nthis:\n  arg u \\<ge>\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "have \"\\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head s", "using gt_same_t_s(2) gt_unary_u_t(2)"], ["proof (prove)\nusing this:\n  head t = head s\n  \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t\n\ngoal (1 subgoal):\n 1. \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head s", "by simp"], ["proof (state)\nthis:\n  \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head t; num_args u = 1;\n     \\<exists>f\\<in>local.ground_heads (head u).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg u \\<ge>\\<^sub>t t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 3. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<not> head u \\<le>\\<ge>\\<^sub>h\\<^sub>d head s\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "by (rule gt_unary[OF wt_u_ge_s _ gt_unary_u_t(3,4) arg_u_ge_s])"], ["proof (state)\nthis:\n  u >\\<^sub>t s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "case gt_diff_u_t: gt_diff"], ["proof (state)\nthis:\n  wt u \\<ge>\\<^sub>p wt t\n  head u >\\<^sub>h\\<^sub>d head t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "have \"head u >\\<^sub>h\\<^sub>d head s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. head u >\\<^sub>h\\<^sub>d head s", "using gt_diff_u_t(2) gt_same_t_s(2)"], ["proof (prove)\nusing this:\n  head u >\\<^sub>h\\<^sub>d head t\n  head t = head s\n\ngoal (1 subgoal):\n 1. head u >\\<^sub>h\\<^sub>d head s", "by simp"], ["proof (state)\nthis:\n  head u >\\<^sub>h\\<^sub>d head s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t;\n     head u >\\<^sub>h\\<^sub>d head t\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s\n 2. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "thus ?thesis"], ["proof (prove)\nusing this:\n  head u >\\<^sub>h\\<^sub>d head s\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "by (rule gt_diff[OF wt_u_ge_s])"], ["proof (state)\nthis:\n  u >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "case gt_same_u_t: gt_same"], ["proof (state)\nthis:\n  wt u \\<ge>\\<^sub>p wt t\n  head u = head t\n  \\<forall>f\\<in>local.ground_heads (head u).\n     extf f (>\\<^sub>t) (args u) (args t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "have hd_u_s: \"head u = head s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. head u = head s", "by (simp only: gt_same_t_s(2) gt_same_u_t(2))"], ["proof (state)\nthis:\n  head u = head s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "let ?S = \"set (args u) \\<union> set (args t) \\<union> set (args s)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "have gt_trans_args: \"\\<forall>ua \\<in> ?S. \\<forall>ta \\<in> ?S. \\<forall>sa \\<in> ?S. ua >\\<^sub>t ta \\<longrightarrow> ta >\\<^sub>t sa \\<longrightarrow> ua >\\<^sub>t sa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>uaa\\<in>set (args u) \\<union> set (args t) \\<union>\n                     set (args s).\n       \\<forall>taa\\<in>set (args u) \\<union> set (args t) \\<union>\n                        set (args s).\n          \\<forall>sa\\<in>set (args u) \\<union> set (args t) \\<union>\n                          set (args s).\n             uaa >\\<^sub>t taa \\<longrightarrow>\n             taa >\\<^sub>t sa \\<longrightarrow> uaa >\\<^sub>t sa", "proof clarify"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>uaa taa saa.\n       \\<lbrakk>uaa\n                \\<in> set (args u) \\<union> set (args t) \\<union>\n                      set (args s);\n        taa \\<in> set (args u) \\<union> set (args t) \\<union> set (args s);\n        saa \\<in> set (args u) \\<union> set (args t) \\<union> set (args s);\n        uaa >\\<^sub>t taa; taa >\\<^sub>t saa\\<rbrakk>\n       \\<Longrightarrow> uaa >\\<^sub>t saa", "fix sa ta ua"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>uaa taa saa.\n       \\<lbrakk>uaa\n                \\<in> set (args u) \\<union> set (args t) \\<union>\n                      set (args s);\n        taa \\<in> set (args u) \\<union> set (args t) \\<union> set (args s);\n        saa \\<in> set (args u) \\<union> set (args t) \\<union> set (args s);\n        uaa >\\<^sub>t taa; taa >\\<^sub>t saa\\<rbrakk>\n       \\<Longrightarrow> uaa >\\<^sub>t saa", "assume\n          ua_in: \"ua \\<in> ?S\" and ta_in: \"ta \\<in> ?S\" and sa_in: \"sa \\<in> ?S\" and\n          ua_gt_ta: \"ua >\\<^sub>t ta\" and ta_gt_sa: \"ta >\\<^sub>t sa\""], ["proof (state)\nthis:\n  ua \\<in> set (args u) \\<union> set (args t) \\<union> set (args s)\n  ta \\<in> set (args u) \\<union> set (args t) \\<union> set (args s)\n  sa \\<in> set (args u) \\<union> set (args t) \\<union> set (args s)\n  ua >\\<^sub>t ta\n  ta >\\<^sub>t sa\n\ngoal (1 subgoal):\n 1. \\<And>uaa taa saa.\n       \\<lbrakk>uaa\n                \\<in> set (args u) \\<union> set (args t) \\<union>\n                      set (args s);\n        taa \\<in> set (args u) \\<union> set (args t) \\<union> set (args s);\n        saa \\<in> set (args u) \\<union> set (args t) \\<union> set (args s);\n        uaa >\\<^sub>t taa; taa >\\<^sub>t saa\\<rbrakk>\n       \\<Longrightarrow> uaa >\\<^sub>t saa", "have wary_sa: \"wary sa\" and wary_ta: \"wary ta\" and wary_ua: \"wary ua\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wary sa &&& wary ta &&& wary ua", "using wary_args ua_in ta_in sa_in wary_u wary_t wary_s"], ["proof (prove)\nusing this:\n  \\<lbrakk>?s \\<in> set (args ?t); wary ?t\\<rbrakk>\n  \\<Longrightarrow> wary ?s\n  ua \\<in> set (args u) \\<union> set (args t) \\<union> set (args s)\n  ta \\<in> set (args u) \\<union> set (args t) \\<union> set (args s)\n  sa \\<in> set (args u) \\<union> set (args t) \\<union> set (args s)\n  wary u\n  wary t\n  wary s\n\ngoal (1 subgoal):\n 1. wary sa &&& wary ta &&& wary ua", "by blast+"], ["proof (state)\nthis:\n  wary sa\n  wary ta\n  wary ua\n\ngoal (1 subgoal):\n 1. \\<And>uaa taa saa.\n       \\<lbrakk>uaa\n                \\<in> set (args u) \\<union> set (args t) \\<union>\n                      set (args s);\n        taa \\<in> set (args u) \\<union> set (args t) \\<union> set (args s);\n        saa \\<in> set (args u) \\<union> set (args t) \\<union> set (args s);\n        uaa >\\<^sub>t taa; taa >\\<^sub>t saa\\<rbrakk>\n       \\<Longrightarrow> uaa >\\<^sub>t saa", "show \"ua >\\<^sub>t sa\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ua >\\<^sub>t sa", "by (auto intro!: ih[OF Max_lt_imp_lt_mset wary_ua wary_ta wary_sa ua_gt_ta ta_gt_sa])\n            (meson ua_in ta_in sa_in Un_iff max.strict_coboundedI1 max.strict_coboundedI2\n               size_in_args)+"], ["proof (state)\nthis:\n  ua >\\<^sub>t sa\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>uaa\\<in>set (args u) \\<union> set (args t) \\<union> set (args s).\n     \\<forall>taa\\<in>set (args u) \\<union> set (args t) \\<union>\n                      set (args s).\n        \\<forall>sa\\<in>set (args u) \\<union> set (args t) \\<union>\n                        set (args s).\n           uaa >\\<^sub>t taa \\<longrightarrow>\n           taa >\\<^sub>t sa \\<longrightarrow> uaa >\\<^sub>t sa\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "have \"\\<forall>f \\<in> ground_heads (head u). extf f (>\\<^sub>t) (args u) (args s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>local.ground_heads (head u).\n       extf f (>\\<^sub>t) (args u) (args s)", "by (clarify, rule extf_trans_from_irrefl[of ?S _ \"args t\", OF _ _ _ _ _ gt_trans_args])\n          (auto simp: gt_same_u_t(2,3) gt_same_t_s(3) wary_args wary_u wary_t wary_s gt_irrefl)"], ["proof (state)\nthis:\n  \\<forall>f\\<in>local.ground_heads (head u).\n     extf f (>\\<^sub>t) (args u) (args s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wt u \\<ge>\\<^sub>p wt t; head u = head t;\n     \\<forall>f\\<in>local.ground_heads (head u).\n        extf f (>\\<^sub>t) (args u) (args t)\\<rbrakk>\n    \\<Longrightarrow> u >\\<^sub>t s", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>local.ground_heads (head u).\n     extf f (>\\<^sub>t) (args u) (args s)\n\ngoal (1 subgoal):\n 1. u >\\<^sub>t s", "by (rule gt_same[OF wt_u_ge_s hd_u_s])"], ["proof (state)\nthis:\n  u >\\<^sub>t s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u >\\<^sub>t s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  u >\\<^sub>t s\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gt_antisym: \"wary s \\<Longrightarrow> wary t \\<Longrightarrow> t >\\<^sub>t s \\<Longrightarrow> \\<not> s >\\<^sub>t t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wary s; wary t; t >\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> \\<not> s >\\<^sub>t t", "using gt_irrefl gt_trans"], ["proof (prove)\nusing this:\n  wary ?s \\<Longrightarrow> \\<not> ?s >\\<^sub>t ?s\n  \\<lbrakk>wary ?u; wary ?t; wary ?s; ?u >\\<^sub>t ?t;\n   ?t >\\<^sub>t ?s\\<rbrakk>\n  \\<Longrightarrow> ?u >\\<^sub>t ?s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wary s; wary t; t >\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> \\<not> s >\\<^sub>t t", "by blast"], ["", "subsection \\<open>Subterm Property\\<close>"], ["", "lemma gt_sub_fun: \"App s t >\\<^sub>t s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. App s t >\\<^sub>t s", "proof (cases \"wt (App s t) >\\<^sub>p wt s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. wt (App s t) >\\<^sub>p wt s \\<Longrightarrow> App s t >\\<^sub>t s\n 2. \\<not> wt (App s t) >\\<^sub>p wt s \\<Longrightarrow> App s t >\\<^sub>t s", "case True"], ["proof (state)\nthis:\n  wt (App s t) >\\<^sub>p wt s\n\ngoal (2 subgoals):\n 1. wt (App s t) >\\<^sub>p wt s \\<Longrightarrow> App s t >\\<^sub>t s\n 2. \\<not> wt (App s t) >\\<^sub>p wt s \\<Longrightarrow> App s t >\\<^sub>t s", "thus ?thesis"], ["proof (prove)\nusing this:\n  wt (App s t) >\\<^sub>p wt s\n\ngoal (1 subgoal):\n 1. App s t >\\<^sub>t s", "using gt_wt"], ["proof (prove)\nusing this:\n  wt (App s t) >\\<^sub>p wt s\n  wt ?t >\\<^sub>p wt ?s \\<Longrightarrow> ?t >\\<^sub>t ?s\n\ngoal (1 subgoal):\n 1. App s t >\\<^sub>t s", "by simp"], ["proof (state)\nthis:\n  App s t >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. \\<not> wt (App s t) >\\<^sub>p wt s \\<Longrightarrow> App s t >\\<^sub>t s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> wt (App s t) >\\<^sub>p wt s \\<Longrightarrow> App s t >\\<^sub>t s", "case False"], ["proof (state)\nthis:\n  \\<not> wt (App s t) >\\<^sub>p wt s\n\ngoal (1 subgoal):\n 1. \\<not> wt (App s t) >\\<^sub>p wt s \\<Longrightarrow> App s t >\\<^sub>t s", "hence \\<delta>_eq_\\<epsilon>: \"\\<delta>\\<^sub>h = \\<epsilon>\\<^sub>h\""], ["proof (prove)\nusing this:\n  \\<not> wt (App s t) >\\<^sub>p wt s\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>h = \\<epsilon>\\<^sub>h", "using wt_App_ge_fun dual_order.order_iff_strict wt_App_arg_\\<delta>\\<^sub>h wt_\\<delta>\\<^sub>h_imp_\\<delta>\\<^sub>h_eq_\\<epsilon>\\<^sub>h"], ["proof (prove)\nusing this:\n  \\<not> wt (App s t) >\\<^sub>p wt s\n  wt (App ?s ?t) \\<ge>\\<^sub>p wt ?s\n  (?b \\<le> ?a) = (?b < ?a \\<or> ?a = ?b)\n  \\<lbrakk>legal_zpassign ?A;\n   eval_tpoly ?A (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App ?s ?t))) =\n   eval_tpoly ?A (map_tpoly (\\<lambda>x. x) zhmset_of (wt ?s))\\<rbrakk>\n  \\<Longrightarrow> eval_tpoly ?A\n                     (map_tpoly (\\<lambda>x. x) zhmset_of (wt ?t)) =\n                    zhmset_of \\<delta>\\<^sub>h\n  \\<lbrakk>legal_zpassign ?A;\n   eval_tpoly ?A (map_tpoly (\\<lambda>x. x) zhmset_of (wt ?s)) =\n   zhmset_of \\<delta>\\<^sub>h\\<rbrakk>\n  \\<Longrightarrow> \\<delta>\\<^sub>h = \\<epsilon>\\<^sub>h\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>h = \\<epsilon>\\<^sub>h", "unfolding gt_tpoly_def ge_tpoly_def"], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>A.\n             legal_zpassign A \\<longrightarrow>\n             eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s))\n             < eval_tpoly A\n                (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App s t))))\n  \\<forall>A.\n     legal_zpassign A \\<longrightarrow>\n     eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt ?s))\n     \\<le> eval_tpoly A\n            (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App ?s ?t)))\n  (?b \\<le> ?a) = (?b < ?a \\<or> ?a = ?b)\n  \\<lbrakk>legal_zpassign ?A;\n   eval_tpoly ?A (map_tpoly (\\<lambda>x. x) zhmset_of (wt (App ?s ?t))) =\n   eval_tpoly ?A (map_tpoly (\\<lambda>x. x) zhmset_of (wt ?s))\\<rbrakk>\n  \\<Longrightarrow> eval_tpoly ?A\n                     (map_tpoly (\\<lambda>x. x) zhmset_of (wt ?t)) =\n                    zhmset_of \\<delta>\\<^sub>h\n  \\<lbrakk>legal_zpassign ?A;\n   eval_tpoly ?A (map_tpoly (\\<lambda>x. x) zhmset_of (wt ?s)) =\n   zhmset_of \\<delta>\\<^sub>h\\<rbrakk>\n  \\<Longrightarrow> \\<delta>\\<^sub>h = \\<epsilon>\\<^sub>h\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>h = \\<epsilon>\\<^sub>h", "by fast"], ["proof (state)\nthis:\n  \\<delta>\\<^sub>h = \\<epsilon>\\<^sub>h\n\ngoal (1 subgoal):\n 1. \\<not> wt (App s t) >\\<^sub>p wt s \\<Longrightarrow> App s t >\\<^sub>t s", "have hd_st: \"head (App s t) = head s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. head (App s t) = head s", "by auto"], ["proof (state)\nthis:\n  head (App s t) = head s\n\ngoal (1 subgoal):\n 1. \\<not> wt (App s t) >\\<^sub>p wt s \\<Longrightarrow> App s t >\\<^sub>t s", "have extf: \"\\<forall>f \\<in> ground_heads (head (App s t)). extf f (>\\<^sub>t) (args (App s t)) (args s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>local.ground_heads (head (App s t)).\n       extf f (>\\<^sub>t) (args (App s t)) (args s)", "by (simp add: \\<delta>_eq_\\<epsilon> extf_snoc_if_\\<delta>\\<^sub>h_eq_\\<epsilon>\\<^sub>h)"], ["proof (state)\nthis:\n  \\<forall>f\\<in>local.ground_heads (head (App s t)).\n     extf f (>\\<^sub>t) (args (App s t)) (args s)\n\ngoal (1 subgoal):\n 1. \\<not> wt (App s t) >\\<^sub>p wt s \\<Longrightarrow> App s t >\\<^sub>t s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. App s t >\\<^sub>t s", "by (rule gt_same[OF wt_App_ge_fun hd_st extf])"], ["proof (state)\nthis:\n  App s t >\\<^sub>t s\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem gt_proper_sub: \"wary t \\<Longrightarrow> proper_sub s t \\<Longrightarrow> t >\\<^sub>t s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wary t; proper_sub s t\\<rbrakk> \\<Longrightarrow> t >\\<^sub>t s", "by (induct t) (auto intro: gt_sub_fun gt_sub_arg gt_trans sub.intros wary_sub)"], ["", "subsection \\<open>Compatibility with Functions\\<close>"], ["", "lemma gt_compat_fun:\n  assumes\n    wary_t: \"wary t\" and\n    t'_gt_t: \"t' >\\<^sub>t t\"\n  shows \"App s t' >\\<^sub>t App s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. App s t' >\\<^sub>t App s t", "proof (rule gt_same; clarify?)"], ["proof (state)\ngoal (3 subgoals):\n 1. wt (App s t') \\<ge>\\<^sub>p wt (App s t)\n 2. head (App s t') = head (App s t)\n 3. \\<And>f.\n       f \\<in> local.ground_heads (head (App s t')) \\<Longrightarrow>\n       extf f (>\\<^sub>t) (args (App s t')) (args (App s t))", "show \"wt (App s t') \\<ge>\\<^sub>p wt (App s t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wt (App s t') \\<ge>\\<^sub>p wt (App s t)", "using gt_imp_wt[OF t'_gt_t, unfolded ge_tpoly_def]"], ["proof (prove)\nusing this:\n  \\<forall>A.\n     legal_zpassign A \\<longrightarrow>\n     eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n     \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t'))\n\ngoal (1 subgoal):\n 1. wt (App s t') \\<ge>\\<^sub>p wt (App s t)", "by (cases s rule: tm_exhaust_apps,\n      auto simp del: apps_append simp: ge_tpoly_def App_apps eval_ztpoly_nonneg\n        intro: ordered_comm_semiring_class.comm_mult_left_mono)"], ["proof (state)\nthis:\n  wt (App s t') \\<ge>\\<^sub>p wt (App s t)\n\ngoal (2 subgoals):\n 1. head (App s t') = head (App s t)\n 2. \\<And>f.\n       f \\<in> local.ground_heads (head (App s t')) \\<Longrightarrow>\n       extf f (>\\<^sub>t) (args (App s t')) (args (App s t))", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. head (App s t') = head (App s t)\n 2. \\<And>f.\n       f \\<in> local.ground_heads (head (App s t')) \\<Longrightarrow>\n       extf f (>\\<^sub>t) (args (App s t')) (args (App s t))", "fix f"], ["proof (state)\ngoal (2 subgoals):\n 1. head (App s t') = head (App s t)\n 2. \\<And>f.\n       f \\<in> local.ground_heads (head (App s t')) \\<Longrightarrow>\n       extf f (>\\<^sub>t) (args (App s t')) (args (App s t))", "have \"extf f (>\\<^sub>t) (args s @ [t']) (args s @ [t])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extf f (>\\<^sub>t) (args s @ [t']) (args s @ [t])", "using t'_gt_t"], ["proof (prove)\nusing this:\n  t' >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. extf f (>\\<^sub>t) (args s @ [t']) (args s @ [t])", "by (metis extf_compat_list gt_irrefl[OF wary_t])"], ["proof (state)\nthis:\n  extf f (>\\<^sub>t) (args s @ [t']) (args s @ [t])\n\ngoal (2 subgoals):\n 1. head (App s t') = head (App s t)\n 2. \\<And>f.\n       f \\<in> local.ground_heads (head (App s t')) \\<Longrightarrow>\n       extf f (>\\<^sub>t) (args (App s t')) (args (App s t))", "thus \"extf f (>\\<^sub>t) (args (App s t')) (args (App s t))\""], ["proof (prove)\nusing this:\n  extf f (>\\<^sub>t) (args s @ [t']) (args s @ [t])\n\ngoal (1 subgoal):\n 1. extf f (>\\<^sub>t) (args (App s t')) (args (App s t))", "by simp"], ["proof (state)\nthis:\n  extf f (>\\<^sub>t) (args (App s t')) (args (App s t))\n\ngoal (1 subgoal):\n 1. head (App s t') = head (App s t)", "qed simp"], ["", "theorem gt_compat_fun_strong:\n  assumes\n    wary_t: \"wary t\" and\n    t'_gt_t: \"t' >\\<^sub>t t\"\n  shows \"apps s (t' # us) >\\<^sub>t apps s (t # us)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. apps s (t' # us) >\\<^sub>t apps s (t # us)", "proof (induct us rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. apps s [t'] >\\<^sub>t apps s [t]\n 2. \\<And>x xs.\n       apps s (t' # xs) >\\<^sub>t apps s (t # xs) \\<Longrightarrow>\n       apps s (t' # xs @ [x]) >\\<^sub>t apps s (t # xs @ [x])", "case Nil"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. apps s [t'] >\\<^sub>t apps s [t]\n 2. \\<And>x xs.\n       apps s (t' # xs) >\\<^sub>t apps s (t # xs) \\<Longrightarrow>\n       apps s (t' # xs @ [x]) >\\<^sub>t apps s (t # xs @ [x])", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. apps s [t'] >\\<^sub>t apps s [t]", "using t'_gt_t"], ["proof (prove)\nusing this:\n  t' >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. apps s [t'] >\\<^sub>t apps s [t]", "by (auto intro!: gt_compat_fun[OF wary_t])"], ["proof (state)\nthis:\n  apps s [t'] >\\<^sub>t apps s [t]\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       apps s (t' # xs) >\\<^sub>t apps s (t # xs) \\<Longrightarrow>\n       apps s (t' # xs @ [x]) >\\<^sub>t apps s (t # xs @ [x])", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       apps s (t' # xs) >\\<^sub>t apps s (t # xs) \\<Longrightarrow>\n       apps s (t' # xs @ [x]) >\\<^sub>t apps s (t # xs @ [x])", "case (snoc u us)"], ["proof (state)\nthis:\n  apps s (t' # us) >\\<^sub>t apps s (t # us)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       apps s (t' # xs) >\\<^sub>t apps s (t # xs) \\<Longrightarrow>\n       apps s (t' # xs @ [x]) >\\<^sub>t apps s (t # xs @ [x])", "note ih = snoc"], ["proof (state)\nthis:\n  apps s (t' # us) >\\<^sub>t apps s (t # us)\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       apps s (t' # xs) >\\<^sub>t apps s (t # xs) \\<Longrightarrow>\n       apps s (t' # xs @ [x]) >\\<^sub>t apps s (t # xs @ [x])", "let ?v' = \"apps s (t' # us @ [u])\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       apps s (t' # xs) >\\<^sub>t apps s (t # xs) \\<Longrightarrow>\n       apps s (t' # xs @ [x]) >\\<^sub>t apps s (t # xs @ [x])", "let ?v = \"apps s (t # us @ [u])\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       apps s (t' # xs) >\\<^sub>t apps s (t # xs) \\<Longrightarrow>\n       apps s (t' # xs @ [x]) >\\<^sub>t apps s (t # xs @ [x])", "have \"wt ?v' \\<ge>\\<^sub>p wt ?v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wt (apps s (t' # us @ [u])) \\<ge>\\<^sub>p wt (apps s (t # us @ [u]))", "using gt_imp_wt[OF ih]"], ["proof (prove)\nusing this:\n  wt (apps s (t' # us)) \\<ge>\\<^sub>p wt (apps s (t # us))\n\ngoal (1 subgoal):\n 1. wt (apps s (t' # us @ [u])) \\<ge>\\<^sub>p wt (apps s (t # us @ [u]))", "by (cases s rule: tm_exhaust_apps,\n      simp del: apps_append add: App_apps apps_append[symmetric] ge_tpoly_def,\n      subst (1 2) zip_eq_butlast_last, simp+)"], ["proof (state)\nthis:\n  wt (apps s (t' # us @ [u])) \\<ge>\\<^sub>p wt (apps s (t # us @ [u]))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       apps s (t' # xs) >\\<^sub>t apps s (t # xs) \\<Longrightarrow>\n       apps s (t' # xs @ [x]) >\\<^sub>t apps s (t # xs @ [x])", "moreover"], ["proof (state)\nthis:\n  wt (apps s (t' # us @ [u])) \\<ge>\\<^sub>p wt (apps s (t # us @ [u]))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       apps s (t' # xs) >\\<^sub>t apps s (t # xs) \\<Longrightarrow>\n       apps s (t' # xs @ [x]) >\\<^sub>t apps s (t # xs @ [x])", "have \"head ?v' = head ?v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. head (apps s (t' # us @ [u])) = head (apps s (t # us @ [u]))", "by simp"], ["proof (state)\nthis:\n  head (apps s (t' # us @ [u])) = head (apps s (t # us @ [u]))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       apps s (t' # xs) >\\<^sub>t apps s (t # xs) \\<Longrightarrow>\n       apps s (t' # xs @ [x]) >\\<^sub>t apps s (t # xs @ [x])", "moreover"], ["proof (state)\nthis:\n  head (apps s (t' # us @ [u])) = head (apps s (t # us @ [u]))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       apps s (t' # xs) >\\<^sub>t apps s (t # xs) \\<Longrightarrow>\n       apps s (t' # xs @ [x]) >\\<^sub>t apps s (t # xs @ [x])", "have \"\\<forall>f \\<in> ground_heads (head ?v'). extf f (>\\<^sub>t) (args ?v') (args ?v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>local.ground_heads (head (apps s (t' # us @ [u]))).\n       extf f (>\\<^sub>t) (args (apps s (t' # us @ [u])))\n        (args (apps s (t # us @ [u])))", "by (metis args_apps extf_compat_list gt_irrefl[OF wary_t] t'_gt_t)"], ["proof (state)\nthis:\n  \\<forall>f\\<in>local.ground_heads (head (apps s (t' # us @ [u]))).\n     extf f (>\\<^sub>t) (args (apps s (t' # us @ [u])))\n      (args (apps s (t # us @ [u])))\n\ngoal (1 subgoal):\n 1. \\<And>x xs.\n       apps s (t' # xs) >\\<^sub>t apps s (t # xs) \\<Longrightarrow>\n       apps s (t' # xs @ [x]) >\\<^sub>t apps s (t # xs @ [x])", "ultimately"], ["proof (chain)\npicking this:\n  wt (apps s (t' # us @ [u])) \\<ge>\\<^sub>p wt (apps s (t # us @ [u]))\n  head (apps s (t' # us @ [u])) = head (apps s (t # us @ [u]))\n  \\<forall>f\\<in>local.ground_heads (head (apps s (t' # us @ [u]))).\n     extf f (>\\<^sub>t) (args (apps s (t' # us @ [u])))\n      (args (apps s (t # us @ [u])))", "show ?case"], ["proof (prove)\nusing this:\n  wt (apps s (t' # us @ [u])) \\<ge>\\<^sub>p wt (apps s (t # us @ [u]))\n  head (apps s (t' # us @ [u])) = head (apps s (t # us @ [u]))\n  \\<forall>f\\<in>local.ground_heads (head (apps s (t' # us @ [u]))).\n     extf f (>\\<^sub>t) (args (apps s (t' # us @ [u])))\n      (args (apps s (t # us @ [u])))\n\ngoal (1 subgoal):\n 1. apps s (t' # us @ [u]) >\\<^sub>t apps s (t # us @ [u])", "by (rule gt_same)"], ["proof (state)\nthis:\n  apps s (t' # us @ [u]) >\\<^sub>t apps s (t # us @ [u])\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Compatibility with Arguments\\<close>"], ["", "theorem gt_compat_arg_weak:\n  assumes\n    wary_st: \"wary (App s t)\" and\n    wary_s't: \"wary (App s' t)\" and\n    coef_s'_0_ge_s: \"coef s' 0 \\<ge>\\<^sub>p coef s 0\" and\n    s'_gt_s: \"s' >\\<^sub>t s\"\n  shows \"App s' t >\\<^sub>t App s t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. App s' t >\\<^sub>t App s t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. App s' t >\\<^sub>t App s t", "obtain \\<zeta> ss where s: \"s = apps (Hd \\<zeta>) ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<zeta> ss.\n        s = apps (Hd \\<zeta>) ss \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis tm_exhaust_apps)"], ["proof (state)\nthis:\n  s = apps (Hd \\<zeta>) ss\n\ngoal (1 subgoal):\n 1. App s' t >\\<^sub>t App s t", "obtain \\<zeta>' ss' where s': \"s' = apps (Hd \\<zeta>') ss'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<zeta>' ss'.\n        s' = apps (Hd \\<zeta>') ss' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis tm_exhaust_apps)"], ["proof (state)\nthis:\n  s' = apps (Hd \\<zeta>') ss'\n\ngoal (1 subgoal):\n 1. App s' t >\\<^sub>t App s t", "have len_ss_lt: \"of_nat (length ss) < arity_sym\\<^sub>h (min_ground_head \\<zeta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (length ss) < arity_sym\\<^sub>h (min_ground_head \\<zeta>)", "using wary_st[unfolded s] ground_heads_arity\\<^sub>h less_le_trans min_ground_head_in_ground_heads"], ["proof (prove)\nusing this:\n  wary (App (apps (Hd \\<zeta>) ss) t)\n  ?f \\<in> local.ground_heads ?\\<zeta> \\<Longrightarrow>\n  arity_hd\\<^sub>h ?\\<zeta> \\<le> arity_sym\\<^sub>h ?f\n  \\<lbrakk>?x < ?y; ?y \\<le> ?z\\<rbrakk> \\<Longrightarrow> ?x < ?z\n  min_ground_head ?\\<zeta> \\<in> local.ground_heads ?\\<zeta>\n\ngoal (1 subgoal):\n 1. of_nat (length ss) < arity_sym\\<^sub>h (min_ground_head \\<zeta>)", "by (metis (no_types) tm_collapse_apps tm_inject_apps wary_AppE\\<^sub>h)"], ["proof (state)\nthis:\n  of_nat (length ss) < arity_sym\\<^sub>h (min_ground_head \\<zeta>)\n\ngoal (1 subgoal):\n 1. App s' t >\\<^sub>t App s t", "have \\<delta>_etc:\n    \"\\<delta>\\<^sub>h + \\<delta>\\<^sub>h * (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss) - 1) =\n     \\<delta>\\<^sub>h * (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss))\"\n    if wary: \"wary (App (apps (Hd \\<zeta>) ss) t)\" for \\<zeta> ss"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>h +\n    \\<delta>\\<^sub>h *\n    (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss) - 1) =\n    \\<delta>\\<^sub>h *\n    (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss))", "proof (cases \"\\<delta>\\<^sub>h > 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. 0 < \\<delta>\\<^sub>h \\<Longrightarrow>\n    \\<delta>\\<^sub>h +\n    \\<delta>\\<^sub>h *\n    (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss) - 1) =\n    \\<delta>\\<^sub>h *\n    (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss))\n 2. \\<not> 0 < \\<delta>\\<^sub>h \\<Longrightarrow>\n    \\<delta>\\<^sub>h +\n    \\<delta>\\<^sub>h *\n    (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss) - 1) =\n    \\<delta>\\<^sub>h *\n    (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss))", "case True"], ["proof (state)\nthis:\n  0 < \\<delta>\\<^sub>h\n\ngoal (2 subgoals):\n 1. 0 < \\<delta>\\<^sub>h \\<Longrightarrow>\n    \\<delta>\\<^sub>h +\n    \\<delta>\\<^sub>h *\n    (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss) - 1) =\n    \\<delta>\\<^sub>h *\n    (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss))\n 2. \\<not> 0 < \\<delta>\\<^sub>h \\<Longrightarrow>\n    \\<delta>\\<^sub>h +\n    \\<delta>\\<^sub>h *\n    (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss) - 1) =\n    \\<delta>\\<^sub>h *\n    (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss))", "then"], ["proof (chain)\npicking this:\n  0 < \\<delta>\\<^sub>h", "obtain n where n: \"of_nat n = arity_sym\\<^sub>h (min_ground_head \\<zeta>)\""], ["proof (prove)\nusing this:\n  0 < \\<delta>\\<^sub>h\n\ngoal (1 subgoal):\n 1. (\\<And>n.\n        of_nat n =\n        arity_sym\\<^sub>h (min_ground_head \\<zeta>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis arity_sym\\<^sub>h_if_\\<delta>\\<^sub>h_gt_0_E)"], ["proof (state)\nthis:\n  of_nat n = arity_sym\\<^sub>h (min_ground_head \\<zeta>)\n\ngoal (2 subgoals):\n 1. 0 < \\<delta>\\<^sub>h \\<Longrightarrow>\n    \\<delta>\\<^sub>h +\n    \\<delta>\\<^sub>h *\n    (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss) - 1) =\n    \\<delta>\\<^sub>h *\n    (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss))\n 2. \\<not> 0 < \\<delta>\\<^sub>h \\<Longrightarrow>\n    \\<delta>\\<^sub>h +\n    \\<delta>\\<^sub>h *\n    (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss) - 1) =\n    \\<delta>\\<^sub>h *\n    (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss))", "have \"of_nat (length ss) < arity_sym\\<^sub>h (min_ground_head \\<zeta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (length ss) < arity_sym\\<^sub>h (min_ground_head \\<zeta>)", "using wary"], ["proof (prove)\nusing this:\n  wary (App (apps (Hd \\<zeta>) ss) t)\n\ngoal (1 subgoal):\n 1. of_nat (length ss) < arity_sym\\<^sub>h (min_ground_head \\<zeta>)", "by (metis (no_types) wary_AppE\\<^sub>h ground_heads_arity\\<^sub>h le_less_trans\n        min_ground_head_in_ground_heads not_le tm_collapse_apps tm_inject_apps)"], ["proof (state)\nthis:\n  of_nat (length ss) < arity_sym\\<^sub>h (min_ground_head \\<zeta>)\n\ngoal (2 subgoals):\n 1. 0 < \\<delta>\\<^sub>h \\<Longrightarrow>\n    \\<delta>\\<^sub>h +\n    \\<delta>\\<^sub>h *\n    (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss) - 1) =\n    \\<delta>\\<^sub>h *\n    (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss))\n 2. \\<not> 0 < \\<delta>\\<^sub>h \\<Longrightarrow>\n    \\<delta>\\<^sub>h +\n    \\<delta>\\<^sub>h *\n    (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss) - 1) =\n    \\<delta>\\<^sub>h *\n    (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss))", "thus ?thesis"], ["proof (prove)\nusing this:\n  of_nat (length ss) < arity_sym\\<^sub>h (min_ground_head \\<zeta>)\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>h +\n    \\<delta>\\<^sub>h *\n    (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss) - 1) =\n    \\<delta>\\<^sub>h *\n    (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss))", "by (fold n, subst of_nat_1[symmetric], fold of_nat_minus_hmset, simp,\n        metis Suc_diff_Suc mult_Suc_right of_nat_add of_nat_mult)"], ["proof (state)\nthis:\n  \\<delta>\\<^sub>h +\n  \\<delta>\\<^sub>h *\n  (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss) - 1) =\n  \\<delta>\\<^sub>h *\n  (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss))\n\ngoal (1 subgoal):\n 1. \\<not> 0 < \\<delta>\\<^sub>h \\<Longrightarrow>\n    \\<delta>\\<^sub>h +\n    \\<delta>\\<^sub>h *\n    (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss) - 1) =\n    \\<delta>\\<^sub>h *\n    (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss))", "qed simp"], ["proof (state)\nthis:\n  wary (App (apps (Hd ?\\<zeta>) ?ss) t) \\<Longrightarrow>\n  \\<delta>\\<^sub>h +\n  \\<delta>\\<^sub>h *\n  (arity_sym\\<^sub>h (min_ground_head ?\\<zeta>) - of_nat (length ?ss) - 1) =\n  \\<delta>\\<^sub>h *\n  (arity_sym\\<^sub>h (min_ground_head ?\\<zeta>) - of_nat (length ?ss))\n\ngoal (1 subgoal):\n 1. App s' t >\\<^sub>t App s t", "have coef_\\<zeta>'_ge_\\<zeta>: \"coef_hd \\<zeta>' (length ss') \\<ge>\\<^sub>p coef_hd \\<zeta> (length ss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. coef_hd \\<zeta>' (length ss') \\<ge>\\<^sub>p coef_hd \\<zeta> (length ss)", "by (rule coef_s'_0_ge_s[unfolded s s', simplified])"], ["proof (state)\nthis:\n  coef_hd \\<zeta>' (length ss') \\<ge>\\<^sub>p coef_hd \\<zeta> (length ss)\n\ngoal (1 subgoal):\n 1. App s' t >\\<^sub>t App s t", "have wt_s'_ge_s: \"wt s' \\<ge>\\<^sub>p wt s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wt s' \\<ge>\\<^sub>p wt s", "by (rule gt_imp_wt[OF s'_gt_s])"], ["proof (state)\nthis:\n  wt s' \\<ge>\\<^sub>p wt s\n\ngoal (1 subgoal):\n 1. App s' t >\\<^sub>t App s t", "have \\<zeta>_tms_len_ss_tms_wt_t_le:\n    \"eval_ztpoly A (coef_hd \\<zeta> (length ss)) * eval_ztpoly A (wt t)\n     \\<le> eval_ztpoly A (coef_hd \\<zeta>' (length ss')) * eval_ztpoly A (wt t)\"\n    if legal: \"legal_zpassign A\" for A"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_tpoly A\n     (map_tpoly (\\<lambda>x. x) zhmset_of (coef_hd \\<zeta> (length ss))) *\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n    \\<le> eval_tpoly A\n           (map_tpoly (\\<lambda>x. x) zhmset_of\n             (coef_hd \\<zeta>' (length ss'))) *\n          eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))", "using legal coef_\\<zeta>'_ge_\\<zeta>[unfolded ge_tpoly_def]"], ["proof (prove)\nusing this:\n  legal_zpassign A\n  \\<forall>A.\n     legal_zpassign A \\<longrightarrow>\n     eval_tpoly A\n      (map_tpoly (\\<lambda>x. x) zhmset_of (coef_hd \\<zeta> (length ss)))\n     \\<le> eval_tpoly A\n            (map_tpoly (\\<lambda>x. x) zhmset_of\n              (coef_hd \\<zeta>' (length ss')))\n\ngoal (1 subgoal):\n 1. eval_tpoly A\n     (map_tpoly (\\<lambda>x. x) zhmset_of (coef_hd \\<zeta> (length ss))) *\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n    \\<le> eval_tpoly A\n           (map_tpoly (\\<lambda>x. x) zhmset_of\n             (coef_hd \\<zeta>' (length ss'))) *\n          eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))", "by (simp add: eval_ztpoly_nonneg mult_right_mono)"], ["proof (state)\nthis:\n  legal_zpassign ?A \\<Longrightarrow>\n  eval_tpoly ?A\n   (map_tpoly (\\<lambda>x. x) zhmset_of (coef_hd \\<zeta> (length ss))) *\n  eval_tpoly ?A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n  \\<le> eval_tpoly ?A\n         (map_tpoly (\\<lambda>x. x) zhmset_of\n           (coef_hd \\<zeta>' (length ss'))) *\n        eval_tpoly ?A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n\ngoal (1 subgoal):\n 1. App s' t >\\<^sub>t App s t", "have wt_s't_ge_st: \"wt (App s' t) \\<ge>\\<^sub>p wt (App s t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wt (App s' t) \\<ge>\\<^sub>p wt (App s t)", "unfolding s s'"], ["proof (prove)\ngoal (1 subgoal):\n 1. wt (App (apps (Hd \\<zeta>') ss') t) \\<ge>\\<^sub>p\n    wt (App (apps (Hd \\<zeta>) ss) t)", "by (clarsimp simp del: apps_append simp: App_apps ge_tpoly_def add_ac(1)[symmetric]\n          intro!: add_mono[OF _ \\<zeta>_tms_len_ss_tms_wt_t_le],\n      rule add_le_imp_le_left[of \"zhmset_of \\<delta>\\<^sub>h\"],\n      unfold add_ac(1)[symmetric] add.commute[of 1] diff_diff_add[symmetric],\n      subst (1 3) ac_simps(3)[unfolded add_ac(1)[symmetric]], subst (1 3) add_ac(1),\n      simp only: zhmset_of_plus[symmetric] \\<delta>_etc[OF wary_st[unfolded s]]\n        \\<delta>_etc[OF wary_s't[unfolded s']] add_ac(1)\n        wt_s'_ge_s[unfolded s s', unfolded ge_tpoly_def add_ac(1)[symmetric], simplified])"], ["proof (state)\nthis:\n  wt (App s' t) \\<ge>\\<^sub>p wt (App s t)\n\ngoal (1 subgoal):\n 1. App s' t >\\<^sub>t App s t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. App s' t >\\<^sub>t App s t", "using s'_gt_s"], ["proof (prove)\nusing this:\n  s' >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. App s' t >\\<^sub>t App s t", "proof cases"], ["proof (state)\ngoal (4 subgoals):\n 1. wt s' >\\<^sub>p wt s \\<Longrightarrow> App s' t >\\<^sub>t App s t\n 2. \\<lbrakk>wt s' \\<ge>\\<^sub>p wt s;\n     \\<not> head s' \\<le>\\<ge>\\<^sub>h\\<^sub>d head s; num_args s' = 1;\n     \\<exists>f\\<in>local.ground_heads (head s').\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg s' \\<ge>\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> App s' t >\\<^sub>t App s t\n 3. \\<lbrakk>wt s' \\<ge>\\<^sub>p wt s;\n     head s' >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n    \\<Longrightarrow> App s' t >\\<^sub>t App s t\n 4. \\<lbrakk>wt s' \\<ge>\\<^sub>p wt s; head s' = head s;\n     \\<forall>f\\<in>local.ground_heads (head s').\n        extf f (>\\<^sub>t) (args s') (args s)\\<rbrakk>\n    \\<Longrightarrow> App s' t >\\<^sub>t App s t", "case gt_wt_s'_s: gt_wt"], ["proof (state)\nthis:\n  wt s' >\\<^sub>p wt s\n\ngoal (4 subgoals):\n 1. wt s' >\\<^sub>p wt s \\<Longrightarrow> App s' t >\\<^sub>t App s t\n 2. \\<lbrakk>wt s' \\<ge>\\<^sub>p wt s;\n     \\<not> head s' \\<le>\\<ge>\\<^sub>h\\<^sub>d head s; num_args s' = 1;\n     \\<exists>f\\<in>local.ground_heads (head s').\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg s' \\<ge>\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> App s' t >\\<^sub>t App s t\n 3. \\<lbrakk>wt s' \\<ge>\\<^sub>p wt s;\n     head s' >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n    \\<Longrightarrow> App s' t >\\<^sub>t App s t\n 4. \\<lbrakk>wt s' \\<ge>\\<^sub>p wt s; head s' = head s;\n     \\<forall>f\\<in>local.ground_heads (head s').\n        extf f (>\\<^sub>t) (args s') (args s)\\<rbrakk>\n    \\<Longrightarrow> App s' t >\\<^sub>t App s t", "have \"wt (App s' t) >\\<^sub>p wt (App s t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wt (App s' t) >\\<^sub>p wt (App s t)", "unfolding s s'"], ["proof (prove)\ngoal (1 subgoal):\n 1. wt (App (apps (Hd \\<zeta>') ss') t) >\\<^sub>p\n    wt (App (apps (Hd \\<zeta>) ss) t)", "by (clarsimp simp del: apps_append simp: App_apps gt_tpoly_def add_ac(1)[symmetric]\n            intro!: add_less_le_mono[OF _ \\<zeta>_tms_len_ss_tms_wt_t_le],\n        rule add_less_imp_less_left[of \"zhmset_of \\<delta>\\<^sub>h\"],\n        unfold add_ac(1)[symmetric] add.commute[of 1] diff_diff_add[symmetric],\n        subst (1 3) ac_simps(3)[unfolded add_ac(1)[symmetric]],\n        subst (1 3) add_ac(1),\n        simp only: zhmset_of_plus[symmetric] \\<delta>_etc[OF wary_st[unfolded s]]\n          \\<delta>_etc[OF wary_s't[unfolded s']] add_ac(1)\n          gt_wt_s'_s[unfolded s s', unfolded gt_tpoly_def add_ac(1)[symmetric], simplified])"], ["proof (state)\nthis:\n  wt (App s' t) >\\<^sub>p wt (App s t)\n\ngoal (4 subgoals):\n 1. wt s' >\\<^sub>p wt s \\<Longrightarrow> App s' t >\\<^sub>t App s t\n 2. \\<lbrakk>wt s' \\<ge>\\<^sub>p wt s;\n     \\<not> head s' \\<le>\\<ge>\\<^sub>h\\<^sub>d head s; num_args s' = 1;\n     \\<exists>f\\<in>local.ground_heads (head s').\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg s' \\<ge>\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> App s' t >\\<^sub>t App s t\n 3. \\<lbrakk>wt s' \\<ge>\\<^sub>p wt s;\n     head s' >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n    \\<Longrightarrow> App s' t >\\<^sub>t App s t\n 4. \\<lbrakk>wt s' \\<ge>\\<^sub>p wt s; head s' = head s;\n     \\<forall>f\\<in>local.ground_heads (head s').\n        extf f (>\\<^sub>t) (args s') (args s)\\<rbrakk>\n    \\<Longrightarrow> App s' t >\\<^sub>t App s t", "thus ?thesis"], ["proof (prove)\nusing this:\n  wt (App s' t) >\\<^sub>p wt (App s t)\n\ngoal (1 subgoal):\n 1. App s' t >\\<^sub>t App s t", "by (rule gt_wt)"], ["proof (state)\nthis:\n  App s' t >\\<^sub>t App s t\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt s' \\<ge>\\<^sub>p wt s;\n     \\<not> head s' \\<le>\\<ge>\\<^sub>h\\<^sub>d head s; num_args s' = 1;\n     \\<exists>f\\<in>local.ground_heads (head s').\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg s' \\<ge>\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> App s' t >\\<^sub>t App s t\n 2. \\<lbrakk>wt s' \\<ge>\\<^sub>p wt s;\n     head s' >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n    \\<Longrightarrow> App s' t >\\<^sub>t App s t\n 3. \\<lbrakk>wt s' \\<ge>\\<^sub>p wt s; head s' = head s;\n     \\<forall>f\\<in>local.ground_heads (head s').\n        extf f (>\\<^sub>t) (args s') (args s)\\<rbrakk>\n    \\<Longrightarrow> App s' t >\\<^sub>t App s t", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>wt s' \\<ge>\\<^sub>p wt s;\n     \\<not> head s' \\<le>\\<ge>\\<^sub>h\\<^sub>d head s; num_args s' = 1;\n     \\<exists>f\\<in>local.ground_heads (head s').\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg s' \\<ge>\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> App s' t >\\<^sub>t App s t\n 2. \\<lbrakk>wt s' \\<ge>\\<^sub>p wt s;\n     head s' >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n    \\<Longrightarrow> App s' t >\\<^sub>t App s t\n 3. \\<lbrakk>wt s' \\<ge>\\<^sub>p wt s; head s' = head s;\n     \\<forall>f\\<in>local.ground_heads (head s').\n        extf f (>\\<^sub>t) (args s') (args s)\\<rbrakk>\n    \\<Longrightarrow> App s' t >\\<^sub>t App s t", "case gt_unary_s'_s: gt_unary"], ["proof (state)\nthis:\n  wt s' \\<ge>\\<^sub>p wt s\n  \\<not> head s' \\<le>\\<ge>\\<^sub>h\\<^sub>d head s\n  num_args s' = 1\n  \\<exists>f\\<in>local.ground_heads (head s').\n     arity_sym f = 1 \\<and> wt_sym f = 0\n  arg s' \\<ge>\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt s' \\<ge>\\<^sub>p wt s;\n     \\<not> head s' \\<le>\\<ge>\\<^sub>h\\<^sub>d head s; num_args s' = 1;\n     \\<exists>f\\<in>local.ground_heads (head s').\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg s' \\<ge>\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> App s' t >\\<^sub>t App s t\n 2. \\<lbrakk>wt s' \\<ge>\\<^sub>p wt s;\n     head s' >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n    \\<Longrightarrow> App s' t >\\<^sub>t App s t\n 3. \\<lbrakk>wt s' \\<ge>\\<^sub>p wt s; head s' = head s;\n     \\<forall>f\\<in>local.ground_heads (head s').\n        extf f (>\\<^sub>t) (args s') (args s)\\<rbrakk>\n    \\<Longrightarrow> App s' t >\\<^sub>t App s t", "have False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "by (metis ground_heads_arity\\<^sub>h gt_unary_s'_s(3) gt_unary_s'_s(4) hmset_of_enat_1 leD of_nat_1\n        wary_AppE\\<^sub>h wary_s't)"], ["proof (state)\nthis:\n  False\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt s' \\<ge>\\<^sub>p wt s;\n     \\<not> head s' \\<le>\\<ge>\\<^sub>h\\<^sub>d head s; num_args s' = 1;\n     \\<exists>f\\<in>local.ground_heads (head s').\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg s' \\<ge>\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> App s' t >\\<^sub>t App s t\n 2. \\<lbrakk>wt s' \\<ge>\\<^sub>p wt s;\n     head s' >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n    \\<Longrightarrow> App s' t >\\<^sub>t App s t\n 3. \\<lbrakk>wt s' \\<ge>\\<^sub>p wt s; head s' = head s;\n     \\<forall>f\\<in>local.ground_heads (head s').\n        extf f (>\\<^sub>t) (args s') (args s)\\<rbrakk>\n    \\<Longrightarrow> App s' t >\\<^sub>t App s t", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. App s' t >\\<^sub>t App s t", "by sat"], ["proof (state)\nthis:\n  App s' t >\\<^sub>t App s t\n\ngoal (2 subgoals):\n 1. \\<lbrakk>wt s' \\<ge>\\<^sub>p wt s;\n     head s' >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n    \\<Longrightarrow> App s' t >\\<^sub>t App s t\n 2. \\<lbrakk>wt s' \\<ge>\\<^sub>p wt s; head s' = head s;\n     \\<forall>f\\<in>local.ground_heads (head s').\n        extf f (>\\<^sub>t) (args s') (args s)\\<rbrakk>\n    \\<Longrightarrow> App s' t >\\<^sub>t App s t", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>wt s' \\<ge>\\<^sub>p wt s;\n     head s' >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n    \\<Longrightarrow> App s' t >\\<^sub>t App s t\n 2. \\<lbrakk>wt s' \\<ge>\\<^sub>p wt s; head s' = head s;\n     \\<forall>f\\<in>local.ground_heads (head s').\n        extf f (>\\<^sub>t) (args s') (args s)\\<rbrakk>\n    \\<Longrightarrow> App s' t >\\<^sub>t App s t", "case gt_diff_s'_s: gt_diff"], ["proof (state)\nthis:\n  wt s' \\<ge>\\<^sub>p wt s\n  head s' >\\<^sub>h\\<^sub>d head s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>wt s' \\<ge>\\<^sub>p wt s;\n     head s' >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n    \\<Longrightarrow> App s' t >\\<^sub>t App s t\n 2. \\<lbrakk>wt s' \\<ge>\\<^sub>p wt s; head s' = head s;\n     \\<forall>f\\<in>local.ground_heads (head s').\n        extf f (>\\<^sub>t) (args s') (args s)\\<rbrakk>\n    \\<Longrightarrow> App s' t >\\<^sub>t App s t", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. App s' t >\\<^sub>t App s t", "by (rule gt_diff[OF wt_s't_ge_st]) (simp add: gt_diff_s'_s(2))"], ["proof (state)\nthis:\n  App s' t >\\<^sub>t App s t\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wt s' \\<ge>\\<^sub>p wt s; head s' = head s;\n     \\<forall>f\\<in>local.ground_heads (head s').\n        extf f (>\\<^sub>t) (args s') (args s)\\<rbrakk>\n    \\<Longrightarrow> App s' t >\\<^sub>t App s t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>wt s' \\<ge>\\<^sub>p wt s; head s' = head s;\n     \\<forall>f\\<in>local.ground_heads (head s').\n        extf f (>\\<^sub>t) (args s') (args s)\\<rbrakk>\n    \\<Longrightarrow> App s' t >\\<^sub>t App s t", "case gt_same_s'_s: gt_same"], ["proof (state)\nthis:\n  wt s' \\<ge>\\<^sub>p wt s\n  head s' = head s\n  \\<forall>f\\<in>local.ground_heads (head s').\n     extf f (>\\<^sub>t) (args s') (args s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wt s' \\<ge>\\<^sub>p wt s; head s' = head s;\n     \\<forall>f\\<in>local.ground_heads (head s').\n        extf f (>\\<^sub>t) (args s') (args s)\\<rbrakk>\n    \\<Longrightarrow> App s' t >\\<^sub>t App s t", "have hd_s't: \"head (App s' t) = head (App s t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. head (App s' t) = head (App s t)", "by (simp add: gt_same_s'_s(2))"], ["proof (state)\nthis:\n  head (App s' t) = head (App s t)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wt s' \\<ge>\\<^sub>p wt s; head s' = head s;\n     \\<forall>f\\<in>local.ground_heads (head s').\n        extf f (>\\<^sub>t) (args s') (args s)\\<rbrakk>\n    \\<Longrightarrow> App s' t >\\<^sub>t App s t", "have \"\\<forall>f \\<in> ground_heads (head (App s' t)). extf f (>\\<^sub>t) (args (App s' t)) (args (App s t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>local.ground_heads (head (App s' t)).\n       extf f (>\\<^sub>t) (args (App s' t)) (args (App s t))", "using gt_same_s'_s(3)"], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>local.ground_heads (head s').\n     extf f (>\\<^sub>t) (args s') (args s)\n\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>local.ground_heads (head (App s' t)).\n       extf f (>\\<^sub>t) (args (App s' t)) (args (App s t))", "by (auto intro: extf_compat_append_right)"], ["proof (state)\nthis:\n  \\<forall>f\\<in>local.ground_heads (head (App s' t)).\n     extf f (>\\<^sub>t) (args (App s' t)) (args (App s t))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wt s' \\<ge>\\<^sub>p wt s; head s' = head s;\n     \\<forall>f\\<in>local.ground_heads (head s').\n        extf f (>\\<^sub>t) (args s') (args s)\\<rbrakk>\n    \\<Longrightarrow> App s' t >\\<^sub>t App s t", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>local.ground_heads (head (App s' t)).\n     extf f (>\\<^sub>t) (args (App s' t)) (args (App s t))\n\ngoal (1 subgoal):\n 1. App s' t >\\<^sub>t App s t", "by (rule gt_same[OF wt_s't_ge_st hd_s't])"], ["proof (state)\nthis:\n  App s' t >\\<^sub>t App s t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  App s' t >\\<^sub>t App s t\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Stability under Substitution\\<close>"], ["", "primrec\n  subst_zpassign :: \"('v \\<Rightarrow> ('s, 'v) tm) \\<Rightarrow> ('v pvar \\<Rightarrow> zhmultiset) \\<Rightarrow> 'v pvar \\<Rightarrow> zhmultiset\"\nwhere\n  \"subst_zpassign \\<rho> A (PWt x) =\n   eval_ztpoly A (wt (\\<rho> x)) - zhmset_of (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head (Var x)))\"\n| \"subst_zpassign \\<rho> A (PCoef x i) = eval_ztpoly A (coef (\\<rho> x) i)\""], ["", "lemma legal_subst_zpassign:\n  assumes\n    legal: \"legal_zpassign A\" and\n    wary_\\<rho>: \"wary_subst \\<rho>\"\n  shows \"legal_zpassign (subst_zpassign \\<rho> A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. legal_zpassign (subst_zpassign \\<rho> A)", "unfolding legal_zpassign_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x. zhmset_of (min_passign x) \\<le> subst_zpassign \\<rho> A x", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. zhmset_of (min_passign x) \\<le> subst_zpassign \\<rho> A x", "fix v"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. zhmset_of (min_passign x) \\<le> subst_zpassign \\<rho> A x", "show \"subst_zpassign \\<rho> A v \\<ge> min_zpassign v\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zhmset_of (min_passign v) \\<le> subst_zpassign \\<rho> A v", "proof (cases v)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       v = PWt x1 \\<Longrightarrow>\n       zhmset_of (min_passign v) \\<le> subst_zpassign \\<rho> A v\n 2. \\<And>x21 x22.\n       v = PCoef x21 x22 \\<Longrightarrow>\n       zhmset_of (min_passign v) \\<le> subst_zpassign \\<rho> A v", "case v: (PWt x)"], ["proof (state)\nthis:\n  v = PWt x\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       v = PWt x1 \\<Longrightarrow>\n       zhmset_of (min_passign v) \\<le> subst_zpassign \\<rho> A v\n 2. \\<And>x21 x22.\n       v = PCoef x21 x22 \\<Longrightarrow>\n       zhmset_of (min_passign v) \\<le> subst_zpassign \\<rho> A v", "obtain \\<zeta> ss where \\<rho>x: \"\\<rho> x = apps (Hd \\<zeta>) ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<zeta> ss.\n        \\<rho> x = apps (Hd \\<zeta>) ss \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule tm_exhaust_apps)"], ["proof (state)\nthis:\n  \\<rho> x = apps (Hd \\<zeta>) ss\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       v = PWt x1 \\<Longrightarrow>\n       zhmset_of (min_passign v) \\<le> subst_zpassign \\<rho> A v\n 2. \\<And>x21 x22.\n       v = PCoef x21 x22 \\<Longrightarrow>\n       zhmset_of (min_passign v) \\<le> subst_zpassign \\<rho> A v", "have ghd_\\<zeta>: \"ground_heads \\<zeta> \\<subseteq> ground_heads_var x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.ground_heads \\<zeta> \\<subseteq> ground_heads_var x", "using wary_\\<rho>[unfolded wary_subst_def, rule_format, of x, unfolded \\<rho>x]"], ["proof (prove)\nusing this:\n  wary (apps (Hd \\<zeta>) ss) \\<and>\n  arity_var x \\<le> arity (apps (Hd \\<zeta>) ss) \\<and>\n  local.ground_heads (head (apps (Hd \\<zeta>) ss))\n  \\<subseteq> ground_heads_var x\n\ngoal (1 subgoal):\n 1. local.ground_heads \\<zeta> \\<subseteq> ground_heads_var x", "by simp"], ["proof (state)\nthis:\n  local.ground_heads \\<zeta> \\<subseteq> ground_heads_var x\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       v = PWt x1 \\<Longrightarrow>\n       zhmset_of (min_passign v) \\<le> subst_zpassign \\<rho> A v\n 2. \\<And>x21 x22.\n       v = PCoef x21 x22 \\<Longrightarrow>\n       zhmset_of (min_passign v) \\<le> subst_zpassign \\<rho> A v", "have \"zhmset_of (wt_sym (min_ground_head (Var x)) + \\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head (Var x)))\n      \\<le> eval_ztpoly A (wt0 \\<zeta>) + zhmset_of (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zhmset_of\n     (wt_sym (min_ground_head (Var x)) +\n      \\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head (Var x)))\n    \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n          zhmset_of\n           (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. zhmset_of\n     (wt_sym (min_ground_head (Var x)) +\n      \\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head (Var x)))\n    \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n          zhmset_of\n           (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))", "have mgh_x_min:\n        \"zhmset_of (wt_sym (min_ground_head (Var x)) + \\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head (Var x)))\n         \\<le> zhmset_of (wt_sym (min_ground_head \\<zeta>) + \\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zhmset_of\n     (wt_sym (min_ground_head (Var x)) +\n      \\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head (Var x)))\n    \\<le> zhmset_of\n           (wt_sym (min_ground_head \\<zeta>) +\n            \\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))", "by (simp add: zmset_of_le zhmset_of_le ghd_\\<zeta> min_ground_head_antimono)"], ["proof (state)\nthis:\n  zhmset_of\n   (wt_sym (min_ground_head (Var x)) +\n    \\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head (Var x)))\n  \\<le> zhmset_of\n         (wt_sym (min_ground_head \\<zeta>) +\n          \\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))\n\ngoal (1 subgoal):\n 1. zhmset_of\n     (wt_sym (min_ground_head (Var x)) +\n      \\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head (Var x)))\n    \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n          zhmset_of\n           (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))", "have wt_mgh_le_wt0: \"zhmset_of (wt_sym (min_ground_head \\<zeta>)) \\<le> eval_ztpoly A (wt0 \\<zeta>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zhmset_of (wt_sym (min_ground_head \\<zeta>))\n    \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>))", "using wt0_ge_min_ground_head[OF legal]"], ["proof (prove)\nusing this:\n  zhmset_of (wt_sym (min_ground_head ?\\<zeta>))\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 ?\\<zeta>))\n\ngoal (1 subgoal):\n 1. zhmset_of (wt_sym (min_ground_head \\<zeta>))\n    \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>))", "by blast"], ["proof (state)\nthis:\n  zhmset_of (wt_sym (min_ground_head \\<zeta>))\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>))\n\ngoal (1 subgoal):\n 1. zhmset_of\n     (wt_sym (min_ground_head (Var x)) +\n      \\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head (Var x)))\n    \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n          zhmset_of\n           (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. zhmset_of\n     (wt_sym (min_ground_head (Var x)) +\n      \\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head (Var x)))\n    \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n          zhmset_of\n           (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))", "by (rule order_trans[OF mgh_x_min]) (simp add: zhmset_of_plus wt_mgh_le_wt0)"], ["proof (state)\nthis:\n  zhmset_of\n   (wt_sym (min_ground_head (Var x)) +\n    \\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head (Var x)))\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n        zhmset_of\n         (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  zhmset_of\n   (wt_sym (min_ground_head (Var x)) +\n    \\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head (Var x)))\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n        zhmset_of\n         (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       v = PWt x1 \\<Longrightarrow>\n       zhmset_of (min_passign v) \\<le> subst_zpassign \\<rho> A v\n 2. \\<And>x21 x22.\n       v = PCoef x21 x22 \\<Longrightarrow>\n       zhmset_of (min_passign v) \\<le> subst_zpassign \\<rho> A v", "also"], ["proof (state)\nthis:\n  zhmset_of\n   (wt_sym (min_ground_head (Var x)) +\n    \\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head (Var x)))\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n        zhmset_of\n         (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       v = PWt x1 \\<Longrightarrow>\n       zhmset_of (min_passign v) \\<le> subst_zpassign \\<rho> A v\n 2. \\<And>x21 x22.\n       v = PCoef x21 x22 \\<Longrightarrow>\n       zhmset_of (min_passign v) \\<le> subst_zpassign \\<rho> A v", "have \"\\<dots> \\<le> eval_ztpoly A (wt0 \\<zeta>)\n      + zhmset_of ((\\<delta>\\<^sub>h * (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss)))\n        + of_nat (length ss) * \\<delta>\\<^sub>h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n    zhmset_of\n     (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))\n    \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n          zhmset_of\n           (\\<delta>\\<^sub>h *\n            (arity_sym\\<^sub>h (min_ground_head \\<zeta>) -\n             of_nat (length ss)) +\n            of_nat (length ss) * \\<delta>\\<^sub>h)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n    zhmset_of\n     (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))\n    \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n          zhmset_of\n           (\\<delta>\\<^sub>h *\n            (arity_sym\\<^sub>h (min_ground_head \\<zeta>) -\n             of_nat (length ss)) +\n            of_nat (length ss) * \\<delta>\\<^sub>h)", "have \"zhmset_of (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))\n        \\<le> zhmset_of (\\<delta>\\<^sub>h * (of_nat (length ss)\n          + (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zhmset_of\n     (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))\n    \\<le> zhmset_of\n           (\\<delta>\\<^sub>h *\n            (of_nat (length ss) +\n             (arity_sym\\<^sub>h (min_ground_head \\<zeta>) -\n              of_nat (length ss))))", "by (metis add.commute le_minus_plus_same_hmset mult_le_mono2_hmset zhmset_of_le)"], ["proof (state)\nthis:\n  zhmset_of (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))\n  \\<le> zhmset_of\n         (\\<delta>\\<^sub>h *\n          (of_nat (length ss) +\n           (arity_sym\\<^sub>h (min_ground_head \\<zeta>) -\n            of_nat (length ss))))\n\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n    zhmset_of\n     (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))\n    \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n          zhmset_of\n           (\\<delta>\\<^sub>h *\n            (arity_sym\\<^sub>h (min_ground_head \\<zeta>) -\n             of_nat (length ss)) +\n            of_nat (length ss) * \\<delta>\\<^sub>h)", "thus ?thesis"], ["proof (prove)\nusing this:\n  zhmset_of (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))\n  \\<le> zhmset_of\n         (\\<delta>\\<^sub>h *\n          (of_nat (length ss) +\n           (arity_sym\\<^sub>h (min_ground_head \\<zeta>) -\n            of_nat (length ss))))\n\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n    zhmset_of\n     (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))\n    \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n          zhmset_of\n           (\\<delta>\\<^sub>h *\n            (arity_sym\\<^sub>h (min_ground_head \\<zeta>) -\n             of_nat (length ss)) +\n            of_nat (length ss) * \\<delta>\\<^sub>h)", "by (simp add: add.commute add.left_commute distrib_left mult.commute)"], ["proof (state)\nthis:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n  zhmset_of (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n        zhmset_of\n         (\\<delta>\\<^sub>h *\n          (arity_sym\\<^sub>h (min_ground_head \\<zeta>) -\n           of_nat (length ss)) +\n          of_nat (length ss) * \\<delta>\\<^sub>h)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n  zhmset_of (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n        zhmset_of\n         (\\<delta>\\<^sub>h *\n          (arity_sym\\<^sub>h (min_ground_head \\<zeta>) -\n           of_nat (length ss)) +\n          of_nat (length ss) * \\<delta>\\<^sub>h)\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       v = PWt x1 \\<Longrightarrow>\n       zhmset_of (min_passign v) \\<le> subst_zpassign \\<rho> A v\n 2. \\<And>x21 x22.\n       v = PCoef x21 x22 \\<Longrightarrow>\n       zhmset_of (min_passign v) \\<le> subst_zpassign \\<rho> A v", "also"], ["proof (state)\nthis:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n  zhmset_of (\\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head \\<zeta>))\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n        zhmset_of\n         (\\<delta>\\<^sub>h *\n          (arity_sym\\<^sub>h (min_ground_head \\<zeta>) -\n           of_nat (length ss)) +\n          of_nat (length ss) * \\<delta>\\<^sub>h)\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       v = PWt x1 \\<Longrightarrow>\n       zhmset_of (min_passign v) \\<le> subst_zpassign \\<rho> A v\n 2. \\<And>x21 x22.\n       v = PCoef x21 x22 \\<Longrightarrow>\n       zhmset_of (min_passign v) \\<le> subst_zpassign \\<rho> A v", "have \"\\<dots> \\<le> eval_ztpoly A (wt0 \\<zeta>)\n      + zhmset_of ((\\<delta>\\<^sub>h * (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss)))\n        + of_nat (length ss) * \\<epsilon>\\<^sub>h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n    zhmset_of\n     (\\<delta>\\<^sub>h *\n      (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss)) +\n      of_nat (length ss) * \\<delta>\\<^sub>h)\n    \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n          zhmset_of\n           (\\<delta>\\<^sub>h *\n            (arity_sym\\<^sub>h (min_ground_head \\<zeta>) -\n             of_nat (length ss)) +\n            of_nat (length ss) * \\<epsilon>\\<^sub>h)", "using \\<delta>\\<^sub>h_le_\\<epsilon>\\<^sub>h zhmset_of_le"], ["proof (prove)\nusing this:\n  \\<delta>\\<^sub>h \\<le> \\<epsilon>\\<^sub>h\n  (zhmset_of ?M \\<le> zhmset_of ?N) = (?M \\<le> ?N)\n\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n    zhmset_of\n     (\\<delta>\\<^sub>h *\n      (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss)) +\n      of_nat (length ss) * \\<delta>\\<^sub>h)\n    \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n          zhmset_of\n           (\\<delta>\\<^sub>h *\n            (arity_sym\\<^sub>h (min_ground_head \\<zeta>) -\n             of_nat (length ss)) +\n            of_nat (length ss) * \\<epsilon>\\<^sub>h)", "by auto"], ["proof (state)\nthis:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n  zhmset_of\n   (\\<delta>\\<^sub>h *\n    (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss)) +\n    of_nat (length ss) * \\<delta>\\<^sub>h)\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n        zhmset_of\n         (\\<delta>\\<^sub>h *\n          (arity_sym\\<^sub>h (min_ground_head \\<zeta>) -\n           of_nat (length ss)) +\n          of_nat (length ss) * \\<epsilon>\\<^sub>h)\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       v = PWt x1 \\<Longrightarrow>\n       zhmset_of (min_passign v) \\<le> subst_zpassign \\<rho> A v\n 2. \\<And>x21 x22.\n       v = PCoef x21 x22 \\<Longrightarrow>\n       zhmset_of (min_passign v) \\<le> subst_zpassign \\<rho> A v", "also"], ["proof (state)\nthis:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n  zhmset_of\n   (\\<delta>\\<^sub>h *\n    (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss)) +\n    of_nat (length ss) * \\<delta>\\<^sub>h)\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n        zhmset_of\n         (\\<delta>\\<^sub>h *\n          (arity_sym\\<^sub>h (min_ground_head \\<zeta>) -\n           of_nat (length ss)) +\n          of_nat (length ss) * \\<epsilon>\\<^sub>h)\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       v = PWt x1 \\<Longrightarrow>\n       zhmset_of (min_passign v) \\<le> subst_zpassign \\<rho> A v\n 2. \\<And>x21 x22.\n       v = PCoef x21 x22 \\<Longrightarrow>\n       zhmset_of (min_passign v) \\<le> subst_zpassign \\<rho> A v", "have \"\\<dots> \\<le> eval_ztpoly A (wt0 \\<zeta>)\n      + zhmset_of (\\<delta>\\<^sub>h * (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss))) + wt_args 0 A \\<zeta> ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n    zhmset_of\n     (\\<delta>\\<^sub>h *\n      (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss)) +\n      of_nat (length ss) * \\<epsilon>\\<^sub>h)\n    \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n          zhmset_of\n           (\\<delta>\\<^sub>h *\n            (arity_sym\\<^sub>h (min_ground_head \\<zeta>) -\n             of_nat (length ss))) +\n          wt_args 0 A \\<zeta> ss", "using wt_args_ge_length_times_\\<epsilon>\\<^sub>h[OF legal]"], ["proof (prove)\nusing this:\n  of_nat (length ?ss) * zhmset_of \\<epsilon>\\<^sub>h\n  \\<le> wt_args ?i A ?\\<zeta> ?ss\n\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n    zhmset_of\n     (\\<delta>\\<^sub>h *\n      (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss)) +\n      of_nat (length ss) * \\<epsilon>\\<^sub>h)\n    \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n          zhmset_of\n           (\\<delta>\\<^sub>h *\n            (arity_sym\\<^sub>h (min_ground_head \\<zeta>) -\n             of_nat (length ss))) +\n          wt_args 0 A \\<zeta> ss", "by (simp add: algebra_simps zhmset_of_plus zhmset_of_times of_nat_zhmset)"], ["proof (state)\nthis:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n  zhmset_of\n   (\\<delta>\\<^sub>h *\n    (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss)) +\n    of_nat (length ss) * \\<epsilon>\\<^sub>h)\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n        zhmset_of\n         (\\<delta>\\<^sub>h *\n          (arity_sym\\<^sub>h (min_ground_head \\<zeta>) -\n           of_nat (length ss))) +\n        wt_args 0 A \\<zeta> ss\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       v = PWt x1 \\<Longrightarrow>\n       zhmset_of (min_passign v) \\<le> subst_zpassign \\<rho> A v\n 2. \\<And>x21 x22.\n       v = PCoef x21 x22 \\<Longrightarrow>\n       zhmset_of (min_passign v) \\<le> subst_zpassign \\<rho> A v", "finally"], ["proof (chain)\npicking this:\n  zhmset_of\n   (wt_sym (min_ground_head (Var x)) +\n    \\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head (Var x)))\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n        zhmset_of\n         (\\<delta>\\<^sub>h *\n          (arity_sym\\<^sub>h (min_ground_head \\<zeta>) -\n           of_nat (length ss))) +\n        wt_args 0 A \\<zeta> ss", "have wt_x_le_\\<zeta>ssts:\n      \"zhmset_of (wt_sym (min_ground_head (Var x)) + \\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head (Var x)))\n       \\<le> eval_ztpoly A (wt0 \\<zeta>)\n         + zhmset_of (\\<delta>\\<^sub>h * (arity_sym\\<^sub>h (min_ground_head \\<zeta>) - of_nat (length ss)))\n         + wt_args 0 A \\<zeta> ss\""], ["proof (prove)\nusing this:\n  zhmset_of\n   (wt_sym (min_ground_head (Var x)) +\n    \\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head (Var x)))\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n        zhmset_of\n         (\\<delta>\\<^sub>h *\n          (arity_sym\\<^sub>h (min_ground_head \\<zeta>) -\n           of_nat (length ss))) +\n        wt_args 0 A \\<zeta> ss\n\ngoal (1 subgoal):\n 1. zhmset_of\n     (wt_sym (min_ground_head (Var x)) +\n      \\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head (Var x)))\n    \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n          zhmset_of\n           (\\<delta>\\<^sub>h *\n            (arity_sym\\<^sub>h (min_ground_head \\<zeta>) -\n             of_nat (length ss))) +\n          wt_args 0 A \\<zeta> ss", "by assumption"], ["proof (state)\nthis:\n  zhmset_of\n   (wt_sym (min_ground_head (Var x)) +\n    \\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head (Var x)))\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n        zhmset_of\n         (\\<delta>\\<^sub>h *\n          (arity_sym\\<^sub>h (min_ground_head \\<zeta>) -\n           of_nat (length ss))) +\n        wt_args 0 A \\<zeta> ss\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       v = PWt x1 \\<Longrightarrow>\n       zhmset_of (min_passign v) \\<le> subst_zpassign \\<rho> A v\n 2. \\<And>x21 x22.\n       v = PCoef x21 x22 \\<Longrightarrow>\n       zhmset_of (min_passign v) \\<le> subst_zpassign \\<rho> A v", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. zhmset_of (min_passign v) \\<le> subst_zpassign \\<rho> A v", "using wt_x_le_\\<zeta>ssts[unfolded wt_args_def]"], ["proof (prove)\nusing this:\n  zhmset_of\n   (wt_sym (min_ground_head (Var x)) +\n    \\<delta>\\<^sub>h * arity_sym\\<^sub>h (min_ground_head (Var x)))\n  \\<le> eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<zeta>)) +\n        zhmset_of\n         (\\<delta>\\<^sub>h *\n          (arity_sym\\<^sub>h (min_ground_head \\<zeta>) -\n           of_nat (length ss))) +\n        sum_list\n         (map ((\\<lambda>p.\n                   eval_tpoly A\n                    (map_tpoly (\\<lambda>x. x) zhmset_of p)) \\<circ>\n               (\\<lambda>(s, i). PMult [coef_hd \\<zeta> i, wt s]))\n           (zip ss [0..<0 + length ss]))\n\ngoal (1 subgoal):\n 1. zhmset_of (min_passign v) \\<le> subst_zpassign \\<rho> A v", "by (simp add: v \\<rho>x comp_def le_diff_eq add.assoc[symmetric] ZHMSet_plus[symmetric]\n        zmset_of_plus[symmetric] hmsetmset_plus[symmetric] zmset_of_le)"], ["proof (state)\nthis:\n  zhmset_of (min_passign v) \\<le> subst_zpassign \\<rho> A v\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       v = PCoef x21 x22 \\<Longrightarrow>\n       zhmset_of (min_passign v) \\<le> subst_zpassign \\<rho> A v", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       v = PCoef x21 x22 \\<Longrightarrow>\n       zhmset_of (min_passign v) \\<le> subst_zpassign \\<rho> A v", "case (PCoef x i)"], ["proof (state)\nthis:\n  v = PCoef x i\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       v = PCoef x21 x22 \\<Longrightarrow>\n       zhmset_of (min_passign v) \\<le> subst_zpassign \\<rho> A v", "thus ?thesis"], ["proof (prove)\nusing this:\n  v = PCoef x i\n\ngoal (1 subgoal):\n 1. zhmset_of (min_passign v) \\<le> subst_zpassign \\<rho> A v", "using coef_gt_0[OF legal, unfolded zero_less_iff_1_le_hmset]"], ["proof (prove)\nusing this:\n  v = PCoef x i\n  0 < eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (coef ?s ?i))\n\ngoal (1 subgoal):\n 1. zhmset_of (min_passign v) \\<le> subst_zpassign \\<rho> A v", "by (simp add: zhmset_of_1 zero_less_iff_1_le_zhmset)"], ["proof (state)\nthis:\n  zhmset_of (min_passign v) \\<le> subst_zpassign \\<rho> A v\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  zhmset_of (min_passign v) \\<le> subst_zpassign \\<rho> A v\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma wt_subst:\n  assumes\n    legal: \"legal_zpassign A\" and\n    wary_\\<rho>: \"wary_subst \\<rho>\"\n  shows \"wary s \\<Longrightarrow> eval_ztpoly A (wt (subst \\<rho> s)) = eval_ztpoly (subst_zpassign \\<rho> A) (wt s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wary s \\<Longrightarrow>\n    eval_tpoly A\n     (map_tpoly (\\<lambda>x. x) zhmset_of (wt (subst \\<rho> s))) =\n    eval_tpoly (subst_zpassign \\<rho> A)\n     (map_tpoly (\\<lambda>x. x) zhmset_of (wt s))", "proof (induct s rule: tm_induct_apps)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>s \\<in> set ss; wary s\\<rbrakk>\n                   \\<Longrightarrow> eval_tpoly A\n(map_tpoly (\\<lambda>x. x) zhmset_of (wt (subst \\<rho> s))) =\n                                     eval_tpoly (subst_zpassign \\<rho> A)\n(map_tpoly (\\<lambda>x. x) zhmset_of (wt s));\n        wary (apps (Hd \\<zeta>) ss)\\<rbrakk>\n       \\<Longrightarrow> eval_tpoly A\n                          (map_tpoly (\\<lambda>x. x) zhmset_of\n                            (wt (subst \\<rho> (apps (Hd \\<zeta>) ss)))) =\n                         eval_tpoly (subst_zpassign \\<rho> A)\n                          (map_tpoly (\\<lambda>x. x) zhmset_of\n                            (wt (apps (Hd \\<zeta>) ss)))", "case (apps \\<zeta> ss)"], ["proof (state)\nthis:\n  \\<lbrakk>?s \\<in> set ss; wary ?s\\<rbrakk>\n  \\<Longrightarrow> eval_tpoly A\n                     (map_tpoly (\\<lambda>x. x) zhmset_of\n                       (wt (subst \\<rho> ?s))) =\n                    eval_tpoly (subst_zpassign \\<rho> A)\n                     (map_tpoly (\\<lambda>x. x) zhmset_of (wt ?s))\n  wary (apps (Hd \\<zeta>) ss)\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>s \\<in> set ss; wary s\\<rbrakk>\n                   \\<Longrightarrow> eval_tpoly A\n(map_tpoly (\\<lambda>x. x) zhmset_of (wt (subst \\<rho> s))) =\n                                     eval_tpoly (subst_zpassign \\<rho> A)\n(map_tpoly (\\<lambda>x. x) zhmset_of (wt s));\n        wary (apps (Hd \\<zeta>) ss)\\<rbrakk>\n       \\<Longrightarrow> eval_tpoly A\n                          (map_tpoly (\\<lambda>x. x) zhmset_of\n                            (wt (subst \\<rho> (apps (Hd \\<zeta>) ss)))) =\n                         eval_tpoly (subst_zpassign \\<rho> A)\n                          (map_tpoly (\\<lambda>x. x) zhmset_of\n                            (wt (apps (Hd \\<zeta>) ss)))", "note ih = this(1) and wary_\\<zeta>ss = this(2)"], ["proof (state)\nthis:\n  \\<lbrakk>?s \\<in> set ss; wary ?s\\<rbrakk>\n  \\<Longrightarrow> eval_tpoly A\n                     (map_tpoly (\\<lambda>x. x) zhmset_of\n                       (wt (subst \\<rho> ?s))) =\n                    eval_tpoly (subst_zpassign \\<rho> A)\n                     (map_tpoly (\\<lambda>x. x) zhmset_of (wt ?s))\n  wary (apps (Hd \\<zeta>) ss)\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>s \\<in> set ss; wary s\\<rbrakk>\n                   \\<Longrightarrow> eval_tpoly A\n(map_tpoly (\\<lambda>x. x) zhmset_of (wt (subst \\<rho> s))) =\n                                     eval_tpoly (subst_zpassign \\<rho> A)\n(map_tpoly (\\<lambda>x. x) zhmset_of (wt s));\n        wary (apps (Hd \\<zeta>) ss)\\<rbrakk>\n       \\<Longrightarrow> eval_tpoly A\n                          (map_tpoly (\\<lambda>x. x) zhmset_of\n                            (wt (subst \\<rho> (apps (Hd \\<zeta>) ss)))) =\n                         eval_tpoly (subst_zpassign \\<rho> A)\n                          (map_tpoly (\\<lambda>x. x) zhmset_of\n                            (wt (apps (Hd \\<zeta>) ss)))", "have wary_nth_ss: \"\\<And>i. i < length ss \\<Longrightarrow> wary (ss ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i < length ss \\<Longrightarrow> wary (ss ! i)", "using wary_args[OF _ wary_\\<zeta>ss]"], ["proof (prove)\nusing this:\n  ?s \\<in> set (args (apps (Hd \\<zeta>) ss)) \\<Longrightarrow> wary ?s\n\ngoal (1 subgoal):\n 1. \\<And>i. i < length ss \\<Longrightarrow> wary (ss ! i)", "by force"], ["proof (state)\nthis:\n  ?i < length ss \\<Longrightarrow> wary (ss ! ?i)\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta> ss.\n       \\<lbrakk>\\<And>s.\n                   \\<lbrakk>s \\<in> set ss; wary s\\<rbrakk>\n                   \\<Longrightarrow> eval_tpoly A\n(map_tpoly (\\<lambda>x. x) zhmset_of (wt (subst \\<rho> s))) =\n                                     eval_tpoly (subst_zpassign \\<rho> A)\n(map_tpoly (\\<lambda>x. x) zhmset_of (wt s));\n        wary (apps (Hd \\<zeta>) ss)\\<rbrakk>\n       \\<Longrightarrow> eval_tpoly A\n                          (map_tpoly (\\<lambda>x. x) zhmset_of\n                            (wt (subst \\<rho> (apps (Hd \\<zeta>) ss)))) =\n                         eval_tpoly (subst_zpassign \\<rho> A)\n                          (map_tpoly (\\<lambda>x. x) zhmset_of\n                            (wt (apps (Hd \\<zeta>) ss)))", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_tpoly A\n     (map_tpoly (\\<lambda>x. x) zhmset_of\n       (wt (subst \\<rho> (apps (Hd \\<zeta>) ss)))) =\n    eval_tpoly (subst_zpassign \\<rho> A)\n     (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))", "proof (cases \\<zeta>)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<zeta> = Var x1 \\<Longrightarrow>\n       eval_tpoly A\n        (map_tpoly (\\<lambda>x. x) zhmset_of\n          (wt (subst \\<rho> (apps (Hd \\<zeta>) ss)))) =\n       eval_tpoly (subst_zpassign \\<rho> A)\n        (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))\n 2. \\<And>x2.\n       \\<zeta> = Sym x2 \\<Longrightarrow>\n       eval_tpoly A\n        (map_tpoly (\\<lambda>x. x) zhmset_of\n          (wt (subst \\<rho> (apps (Hd \\<zeta>) ss)))) =\n       eval_tpoly (subst_zpassign \\<rho> A)\n        (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))", "case \\<zeta>: (Var x)"], ["proof (state)\nthis:\n  \\<zeta> = Var x\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       \\<zeta> = Var x1 \\<Longrightarrow>\n       eval_tpoly A\n        (map_tpoly (\\<lambda>x. x) zhmset_of\n          (wt (subst \\<rho> (apps (Hd \\<zeta>) ss)))) =\n       eval_tpoly (subst_zpassign \\<rho> A)\n        (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))\n 2. \\<And>x2.\n       \\<zeta> = Sym x2 \\<Longrightarrow>\n       eval_tpoly A\n        (map_tpoly (\\<lambda>x. x) zhmset_of\n          (wt (subst \\<rho> (apps (Hd \\<zeta>) ss)))) =\n       eval_tpoly (subst_zpassign \\<rho> A)\n        (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_tpoly A\n     (map_tpoly (\\<lambda>x. x) zhmset_of\n       (wt (subst \\<rho> (apps (Hd \\<zeta>) ss)))) =\n    eval_tpoly (subst_zpassign \\<rho> A)\n     (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))", "proof (cases \"\\<rho> x\" rule: tm_exhaust_apps)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<zeta>' ssa.\n       \\<rho> x = apps (Hd \\<zeta>') ssa \\<Longrightarrow>\n       eval_tpoly A\n        (map_tpoly (\\<lambda>x. x) zhmset_of\n          (wt (subst \\<rho> (apps (Hd \\<zeta>) ss)))) =\n       eval_tpoly (subst_zpassign \\<rho> A)\n        (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))", "case \\<rho>x: (apps \\<xi> ts)"], ["proof (state)\nthis:\n  \\<rho> x = apps (Hd \\<xi>) ts\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta>' ssa.\n       \\<rho> x = apps (Hd \\<zeta>') ssa \\<Longrightarrow>\n       eval_tpoly A\n        (map_tpoly (\\<lambda>x. x) zhmset_of\n          (wt (subst \\<rho> (apps (Hd \\<zeta>) ss)))) =\n       eval_tpoly (subst_zpassign \\<rho> A)\n        (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))", "have wary_\\<rho>x: \"wary (\\<rho> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wary (\\<rho> x)", "using wary_\\<rho> wary_subst_def"], ["proof (prove)\nusing this:\n  wary_subst \\<rho>\n  wary_subst ?\\<rho> =\n  (\\<forall>x.\n      wary (?\\<rho> x) \\<and>\n      arity_var x \\<le> arity (?\\<rho> x) \\<and>\n      local.ground_heads (head (?\\<rho> x)) \\<subseteq> ground_heads_var x)\n\ngoal (1 subgoal):\n 1. wary (\\<rho> x)", "by blast"], ["proof (state)\nthis:\n  wary (\\<rho> x)\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta>' ssa.\n       \\<rho> x = apps (Hd \\<zeta>') ssa \\<Longrightarrow>\n       eval_tpoly A\n        (map_tpoly (\\<lambda>x. x) zhmset_of\n          (wt (subst \\<rho> (apps (Hd \\<zeta>) ss)))) =\n       eval_tpoly (subst_zpassign \\<rho> A)\n        (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))", "have coef_subst: \"\\<And>i. eval_tpoly A (zhmset_of_tpoly (coef_hd \\<xi> (i + length ts))) =\n        eval_tpoly (subst_zpassign \\<rho> A) (zhmset_of_tpoly (coef_hd (Var x) i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       eval_tpoly A\n        (map_tpoly (\\<lambda>x. x) zhmset_of\n          (coef_hd \\<xi> (i + length ts))) =\n       eval_tpoly (subst_zpassign \\<rho> A)\n        (map_tpoly (\\<lambda>x. x) zhmset_of (coef_hd (Var x) i))", "by (simp add: \\<rho>x)"], ["proof (state)\nthis:\n  eval_tpoly A\n   (map_tpoly (\\<lambda>x. x) zhmset_of (coef_hd \\<xi> (?i + length ts))) =\n  eval_tpoly (subst_zpassign \\<rho> A)\n   (map_tpoly (\\<lambda>x. x) zhmset_of (coef_hd (Var x) ?i))\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta>' ssa.\n       \\<rho> x = apps (Hd \\<zeta>') ssa \\<Longrightarrow>\n       eval_tpoly A\n        (map_tpoly (\\<lambda>x. x) zhmset_of\n          (wt (subst \\<rho> (apps (Hd \\<zeta>) ss)))) =\n       eval_tpoly (subst_zpassign \\<rho> A)\n        (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))", "have tedious_ary_arith:\n        \"arity_sym\\<^sub>h (min_ground_head (Var x))\n         + (arity_sym\\<^sub>h (min_ground_head \\<xi>) - (of_nat (length ss) + of_nat (length ts))) =\n         arity_sym\\<^sub>h (min_ground_head \\<xi>) - of_nat (length ts)\n         + (arity_sym\\<^sub>h (min_ground_head (Var x)) - of_nat (length ss))\"\n        if \\<delta>_gt_0: \"\\<delta>\\<^sub>h > 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arity_sym\\<^sub>h (min_ground_head (Var x)) +\n    (arity_sym\\<^sub>h (min_ground_head \\<xi>) -\n     (of_nat (length ss) + of_nat (length ts))) =\n    arity_sym\\<^sub>h (min_ground_head \\<xi>) - of_nat (length ts) +\n    (arity_sym\\<^sub>h (min_ground_head (Var x)) - of_nat (length ss))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. arity_sym\\<^sub>h (min_ground_head (Var x)) +\n    (arity_sym\\<^sub>h (min_ground_head \\<xi>) -\n     (of_nat (length ss) + of_nat (length ts))) =\n    arity_sym\\<^sub>h (min_ground_head \\<xi>) - of_nat (length ts) +\n    (arity_sym\\<^sub>h (min_ground_head (Var x)) - of_nat (length ss))", "obtain m where m: \"of_nat m = arity_sym\\<^sub>h (min_ground_head (Var x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>m.\n        of_nat m =\n        arity_sym\\<^sub>h (min_ground_head (Var x)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis arity_sym\\<^sub>h_if_\\<delta>\\<^sub>h_gt_0_E[OF \\<delta>_gt_0])"], ["proof (state)\nthis:\n  of_nat m = arity_sym\\<^sub>h (min_ground_head (Var x))\n\ngoal (1 subgoal):\n 1. arity_sym\\<^sub>h (min_ground_head (Var x)) +\n    (arity_sym\\<^sub>h (min_ground_head \\<xi>) -\n     (of_nat (length ss) + of_nat (length ts))) =\n    arity_sym\\<^sub>h (min_ground_head \\<xi>) - of_nat (length ts) +\n    (arity_sym\\<^sub>h (min_ground_head (Var x)) - of_nat (length ss))", "obtain n where n: \"of_nat n = arity_sym\\<^sub>h (min_ground_head \\<xi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>n.\n        of_nat n =\n        arity_sym\\<^sub>h (min_ground_head \\<xi>) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis arity_sym\\<^sub>h_if_\\<delta>\\<^sub>h_gt_0_E[OF \\<delta>_gt_0])"], ["proof (state)\nthis:\n  of_nat n = arity_sym\\<^sub>h (min_ground_head \\<xi>)\n\ngoal (1 subgoal):\n 1. arity_sym\\<^sub>h (min_ground_head (Var x)) +\n    (arity_sym\\<^sub>h (min_ground_head \\<xi>) -\n     (of_nat (length ss) + of_nat (length ts))) =\n    arity_sym\\<^sub>h (min_ground_head \\<xi>) - of_nat (length ts) +\n    (arity_sym\\<^sub>h (min_ground_head (Var x)) - of_nat (length ss))", "have \"m \\<ge> length ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ss \\<le> m", "unfolding of_nat_le_hmset[symmetric] m"], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (length ss) \\<le> arity_sym\\<^sub>h (min_ground_head (Var x))", "using wary_\\<zeta>ss[unfolded \\<zeta>]"], ["proof (prove)\nusing this:\n  wary (apps (Hd (Var x)) ss)\n\ngoal (1 subgoal):\n 1. of_nat (length ss) \\<le> arity_sym\\<^sub>h (min_ground_head (Var x))", "by (cases rule: wary_cases_apps\\<^sub>h, clarsimp,\n            metis arity_hd.simps(1) enat_ile enat_ord_simps(1) ground_heads_arity\n              hmset_of_enat_inject hmset_of_enat_of_nat le_trans m min_ground_head_in_ground_heads\n              of_nat_eq_enat of_nat_le_hmset_of_enat_iff)"], ["proof (state)\nthis:\n  length ss \\<le> m\n\ngoal (1 subgoal):\n 1. arity_sym\\<^sub>h (min_ground_head (Var x)) +\n    (arity_sym\\<^sub>h (min_ground_head \\<xi>) -\n     (of_nat (length ss) + of_nat (length ts))) =\n    arity_sym\\<^sub>h (min_ground_head \\<xi>) - of_nat (length ts) +\n    (arity_sym\\<^sub>h (min_ground_head (Var x)) - of_nat (length ss))", "moreover"], ["proof (state)\nthis:\n  length ss \\<le> m\n\ngoal (1 subgoal):\n 1. arity_sym\\<^sub>h (min_ground_head (Var x)) +\n    (arity_sym\\<^sub>h (min_ground_head \\<xi>) -\n     (of_nat (length ss) + of_nat (length ts))) =\n    arity_sym\\<^sub>h (min_ground_head \\<xi>) - of_nat (length ts) +\n    (arity_sym\\<^sub>h (min_ground_head (Var x)) - of_nat (length ss))", "have n_ge_len_ss_ts: \"n \\<ge> length ss + length ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ss + length ts \\<le> n", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length ss + length ts \\<le> n", "have \"of_nat (length ss) + of_nat (length ts) \\<le> arity_hd\\<^sub>h \\<zeta> + of_nat (length ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. of_nat (length ss) + of_nat (length ts)\n    \\<le> arity_hd\\<^sub>h \\<zeta> + of_nat (length ts)", "using wary_\\<zeta>ss wary_cases_apps\\<^sub>h"], ["proof (prove)\nusing this:\n  wary (apps (Hd \\<zeta>) ss)\n  \\<lbrakk>wary ?t;\n   \\<And>\\<zeta> ss.\n      \\<lbrakk>?t = apps (Hd \\<zeta>) ss;\n       \\<And>sa. sa \\<in> set ss \\<Longrightarrow> wary sa;\n       of_nat (length ss) \\<le> arity_hd\\<^sub>h \\<zeta>\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. of_nat (length ss) + of_nat (length ts)\n    \\<le> arity_hd\\<^sub>h \\<zeta> + of_nat (length ts)", "by fastforce"], ["proof (state)\nthis:\n  of_nat (length ss) + of_nat (length ts)\n  \\<le> arity_hd\\<^sub>h \\<zeta> + of_nat (length ts)\n\ngoal (1 subgoal):\n 1. length ss + length ts \\<le> n", "also"], ["proof (state)\nthis:\n  of_nat (length ss) + of_nat (length ts)\n  \\<le> arity_hd\\<^sub>h \\<zeta> + of_nat (length ts)\n\ngoal (1 subgoal):\n 1. length ss + length ts \\<le> n", "have \"\\<dots> = arity_var\\<^sub>h x + of_nat (length ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arity_hd\\<^sub>h \\<zeta> + of_nat (length ts) =\n    arity_var\\<^sub>h x + of_nat (length ts)", "by (simp add: \\<zeta>)"], ["proof (state)\nthis:\n  arity_hd\\<^sub>h \\<zeta> + of_nat (length ts) =\n  arity_var\\<^sub>h x + of_nat (length ts)\n\ngoal (1 subgoal):\n 1. length ss + length ts \\<le> n", "also"], ["proof (state)\nthis:\n  arity_hd\\<^sub>h \\<zeta> + of_nat (length ts) =\n  arity_var\\<^sub>h x + of_nat (length ts)\n\ngoal (1 subgoal):\n 1. length ss + length ts \\<le> n", "have \"\\<dots> \\<le> arity\\<^sub>h (\\<rho> x) + of_nat (length ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arity_var\\<^sub>h x + of_nat (length ts)\n    \\<le> arity\\<^sub>h (\\<rho> x) + of_nat (length ts)", "using wary_\\<rho> wary_subst_def"], ["proof (prove)\nusing this:\n  wary_subst \\<rho>\n  wary_subst ?\\<rho> =\n  (\\<forall>x.\n      wary (?\\<rho> x) \\<and>\n      arity_var x \\<le> arity (?\\<rho> x) \\<and>\n      local.ground_heads (head (?\\<rho> x)) \\<subseteq> ground_heads_var x)\n\ngoal (1 subgoal):\n 1. arity_var\\<^sub>h x + of_nat (length ts)\n    \\<le> arity\\<^sub>h (\\<rho> x) + of_nat (length ts)", "by auto"], ["proof (state)\nthis:\n  arity_var\\<^sub>h x + of_nat (length ts)\n  \\<le> arity\\<^sub>h (\\<rho> x) + of_nat (length ts)\n\ngoal (1 subgoal):\n 1. length ss + length ts \\<le> n", "also"], ["proof (state)\nthis:\n  arity_var\\<^sub>h x + of_nat (length ts)\n  \\<le> arity\\<^sub>h (\\<rho> x) + of_nat (length ts)\n\ngoal (1 subgoal):\n 1. length ss + length ts \\<le> n", "have \"\\<dots> = arity\\<^sub>h (apps (Hd \\<xi>) ts) + of_nat (length ts)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arity\\<^sub>h (\\<rho> x) + of_nat (length ts) =\n    arity\\<^sub>h (apps (Hd \\<xi>) ts) + of_nat (length ts)", "by (simp add: \\<rho>x)"], ["proof (state)\nthis:\n  arity\\<^sub>h (\\<rho> x) + of_nat (length ts) =\n  arity\\<^sub>h (apps (Hd \\<xi>) ts) + of_nat (length ts)\n\ngoal (1 subgoal):\n 1. length ss + length ts \\<le> n", "also"], ["proof (state)\nthis:\n  arity\\<^sub>h (\\<rho> x) + of_nat (length ts) =\n  arity\\<^sub>h (apps (Hd \\<xi>) ts) + of_nat (length ts)\n\ngoal (1 subgoal):\n 1. length ss + length ts \\<le> n", "have \"\\<dots> = arity_hd\\<^sub>h \\<xi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arity\\<^sub>h (apps (Hd \\<xi>) ts) + of_nat (length ts) =\n    arity_hd\\<^sub>h \\<xi>", "using wary_\\<rho>x[unfolded \\<rho>x]"], ["proof (prove)\nusing this:\n  wary (apps (Hd \\<xi>) ts)\n\ngoal (1 subgoal):\n 1. arity\\<^sub>h (apps (Hd \\<xi>) ts) + of_nat (length ts) =\n    arity_hd\\<^sub>h \\<xi>", "by (cases rule: wary_cases_apps\\<^sub>h, cases \"arity_hd \\<xi>\",\n              simp add: of_nat_add[symmetric] of_nat_minus_hmset[symmetric],\n              metis \\<delta>_gt_0 arity_hd_ne_infinity_if_\\<delta>_gt_0 of_nat_0 of_nat_less_hmset)"], ["proof (state)\nthis:\n  arity\\<^sub>h (apps (Hd \\<xi>) ts) + of_nat (length ts) =\n  arity_hd\\<^sub>h \\<xi>\n\ngoal (1 subgoal):\n 1. length ss + length ts \\<le> n", "also"], ["proof (state)\nthis:\n  arity\\<^sub>h (apps (Hd \\<xi>) ts) + of_nat (length ts) =\n  arity_hd\\<^sub>h \\<xi>\n\ngoal (1 subgoal):\n 1. length ss + length ts \\<le> n", "have \"\\<dots> \\<le> arity_sym\\<^sub>h (min_ground_head \\<xi>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arity_hd\\<^sub>h \\<xi> \\<le> arity_sym\\<^sub>h (min_ground_head \\<xi>)", "using ground_heads_arity\\<^sub>h min_ground_head_in_ground_heads"], ["proof (prove)\nusing this:\n  ?f \\<in> local.ground_heads ?\\<zeta> \\<Longrightarrow>\n  arity_hd\\<^sub>h ?\\<zeta> \\<le> arity_sym\\<^sub>h ?f\n  min_ground_head ?\\<zeta> \\<in> local.ground_heads ?\\<zeta>\n\ngoal (1 subgoal):\n 1. arity_hd\\<^sub>h \\<xi> \\<le> arity_sym\\<^sub>h (min_ground_head \\<xi>)", "by blast"], ["proof (state)\nthis:\n  arity_hd\\<^sub>h \\<xi> \\<le> arity_sym\\<^sub>h (min_ground_head \\<xi>)\n\ngoal (1 subgoal):\n 1. length ss + length ts \\<le> n", "finally"], ["proof (chain)\npicking this:\n  of_nat (length ss) + of_nat (length ts)\n  \\<le> arity_sym\\<^sub>h (min_ground_head \\<xi>)", "show ?thesis"], ["proof (prove)\nusing this:\n  of_nat (length ss) + of_nat (length ts)\n  \\<le> arity_sym\\<^sub>h (min_ground_head \\<xi>)\n\ngoal (1 subgoal):\n 1. length ss + length ts \\<le> n", "unfolding of_nat_le_hmset[symmetric] n"], ["proof (prove)\nusing this:\n  of_nat (length ss) + of_nat (length ts)\n  \\<le> arity_sym\\<^sub>h (min_ground_head \\<xi>)\n\ngoal (1 subgoal):\n 1. of_nat (length ss + length ts)\n    \\<le> arity_sym\\<^sub>h (min_ground_head \\<xi>)", "by simp"], ["proof (state)\nthis:\n  length ss + length ts \\<le> n\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length ss + length ts \\<le> n\n\ngoal (1 subgoal):\n 1. arity_sym\\<^sub>h (min_ground_head (Var x)) +\n    (arity_sym\\<^sub>h (min_ground_head \\<xi>) -\n     (of_nat (length ss) + of_nat (length ts))) =\n    arity_sym\\<^sub>h (min_ground_head \\<xi>) - of_nat (length ts) +\n    (arity_sym\\<^sub>h (min_ground_head (Var x)) - of_nat (length ss))", "moreover"], ["proof (state)\nthis:\n  length ss + length ts \\<le> n\n\ngoal (1 subgoal):\n 1. arity_sym\\<^sub>h (min_ground_head (Var x)) +\n    (arity_sym\\<^sub>h (min_ground_head \\<xi>) -\n     (of_nat (length ss) + of_nat (length ts))) =\n    arity_sym\\<^sub>h (min_ground_head \\<xi>) - of_nat (length ts) +\n    (arity_sym\\<^sub>h (min_ground_head (Var x)) - of_nat (length ss))", "have \"n \\<ge> length ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ts \\<le> n", "using n_ge_len_ss_ts"], ["proof (prove)\nusing this:\n  length ss + length ts \\<le> n\n\ngoal (1 subgoal):\n 1. length ts \\<le> n", "by simp"], ["proof (state)\nthis:\n  length ts \\<le> n\n\ngoal (1 subgoal):\n 1. arity_sym\\<^sub>h (min_ground_head (Var x)) +\n    (arity_sym\\<^sub>h (min_ground_head \\<xi>) -\n     (of_nat (length ss) + of_nat (length ts))) =\n    arity_sym\\<^sub>h (min_ground_head \\<xi>) - of_nat (length ts) +\n    (arity_sym\\<^sub>h (min_ground_head (Var x)) - of_nat (length ss))", "ultimately"], ["proof (chain)\npicking this:\n  length ss \\<le> m\n  length ss + length ts \\<le> n\n  length ts \\<le> n", "show ?thesis"], ["proof (prove)\nusing this:\n  length ss \\<le> m\n  length ss + length ts \\<le> n\n  length ts \\<le> n\n\ngoal (1 subgoal):\n 1. arity_sym\\<^sub>h (min_ground_head (Var x)) +\n    (arity_sym\\<^sub>h (min_ground_head \\<xi>) -\n     (of_nat (length ss) + of_nat (length ts))) =\n    arity_sym\\<^sub>h (min_ground_head \\<xi>) - of_nat (length ts) +\n    (arity_sym\\<^sub>h (min_ground_head (Var x)) - of_nat (length ss))", "by (fold m n of_nat_add of_nat_minus_hmset, unfold of_nat_inject_hmset, fastforce)"], ["proof (state)\nthis:\n  arity_sym\\<^sub>h (min_ground_head (Var x)) +\n  (arity_sym\\<^sub>h (min_ground_head \\<xi>) -\n   (of_nat (length ss) + of_nat (length ts))) =\n  arity_sym\\<^sub>h (min_ground_head \\<xi>) - of_nat (length ts) +\n  (arity_sym\\<^sub>h (min_ground_head (Var x)) - of_nat (length ss))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  0 < \\<delta>\\<^sub>h \\<Longrightarrow>\n  arity_sym\\<^sub>h (min_ground_head (Var x)) +\n  (arity_sym\\<^sub>h (min_ground_head \\<xi>) -\n   (of_nat (length ss) + of_nat (length ts))) =\n  arity_sym\\<^sub>h (min_ground_head \\<xi>) - of_nat (length ts) +\n  (arity_sym\\<^sub>h (min_ground_head (Var x)) - of_nat (length ss))\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta>' ssa.\n       \\<rho> x = apps (Hd \\<zeta>') ssa \\<Longrightarrow>\n       eval_tpoly A\n        (map_tpoly (\\<lambda>x. x) zhmset_of\n          (wt (subst \\<rho> (apps (Hd \\<zeta>) ss)))) =\n       eval_tpoly (subst_zpassign \\<rho> A)\n        (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))", "have \"eval_tpoly A (zhmset_of_tpoly (wt (subst \\<rho> (apps (Hd (Var x)) ss)))) =\n        eval_tpoly A (zhmset_of_tpoly (wt0 \\<xi>))\n        + zhmset_of (\\<delta>\\<^sub>h * (arity_sym\\<^sub>h (min_ground_head \\<xi>)\n          - (of_nat (length ts) + of_nat (length ss))))\n        + wt_args 0 A \\<xi> (ts @ map (subst \\<rho>) ss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_tpoly A\n     (map_tpoly (\\<lambda>x. x) zhmset_of\n       (wt (subst \\<rho> (apps (Hd (Var x)) ss)))) =\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<xi>)) +\n    zhmset_of\n     (\\<delta>\\<^sub>h *\n      (arity_sym\\<^sub>h (min_ground_head \\<xi>) -\n       (of_nat (length ts) + of_nat (length ss)))) +\n    wt_args 0 A \\<xi> (ts @ map (subst \\<rho>) ss)", "by (simp del: apps_append add: apps_append[symmetric] \\<rho>x wt_args_def comp_def)"], ["proof (state)\nthis:\n  eval_tpoly A\n   (map_tpoly (\\<lambda>x. x) zhmset_of\n     (wt (subst \\<rho> (apps (Hd (Var x)) ss)))) =\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<xi>)) +\n  zhmset_of\n   (\\<delta>\\<^sub>h *\n    (arity_sym\\<^sub>h (min_ground_head \\<xi>) -\n     (of_nat (length ts) + of_nat (length ss)))) +\n  wt_args 0 A \\<xi> (ts @ map (subst \\<rho>) ss)\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta>' ssa.\n       \\<rho> x = apps (Hd \\<zeta>') ssa \\<Longrightarrow>\n       eval_tpoly A\n        (map_tpoly (\\<lambda>x. x) zhmset_of\n          (wt (subst \\<rho> (apps (Hd \\<zeta>) ss)))) =\n       eval_tpoly (subst_zpassign \\<rho> A)\n        (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))", "also"], ["proof (state)\nthis:\n  eval_tpoly A\n   (map_tpoly (\\<lambda>x. x) zhmset_of\n     (wt (subst \\<rho> (apps (Hd (Var x)) ss)))) =\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<xi>)) +\n  zhmset_of\n   (\\<delta>\\<^sub>h *\n    (arity_sym\\<^sub>h (min_ground_head \\<xi>) -\n     (of_nat (length ts) + of_nat (length ss)))) +\n  wt_args 0 A \\<xi> (ts @ map (subst \\<rho>) ss)\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta>' ssa.\n       \\<rho> x = apps (Hd \\<zeta>') ssa \\<Longrightarrow>\n       eval_tpoly A\n        (map_tpoly (\\<lambda>x. x) zhmset_of\n          (wt (subst \\<rho> (apps (Hd \\<zeta>) ss)))) =\n       eval_tpoly (subst_zpassign \\<rho> A)\n        (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))", "have \"\\<dots> = eval_tpoly A (zhmset_of_tpoly (wt0 \\<xi>))\n        + zhmset_of (\\<delta>\\<^sub>h * (arity_sym\\<^sub>h (min_ground_head \\<xi>)\n          - (of_nat (length ts) + of_nat (length ss))))\n        + wt_args 0 A \\<xi> ts + wt_args (length ts) A \\<xi> (map (subst \\<rho>) ss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<xi>)) +\n    zhmset_of\n     (\\<delta>\\<^sub>h *\n      (arity_sym\\<^sub>h (min_ground_head \\<xi>) -\n       (of_nat (length ts) + of_nat (length ss)))) +\n    wt_args 0 A \\<xi> (ts @ map (subst \\<rho>) ss) =\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<xi>)) +\n    zhmset_of\n     (\\<delta>\\<^sub>h *\n      (arity_sym\\<^sub>h (min_ground_head \\<xi>) -\n       (of_nat (length ts) + of_nat (length ss)))) +\n    wt_args 0 A \\<xi> ts +\n    wt_args (length ts) A \\<xi> (map (subst \\<rho>) ss)", "by (simp add: wt_args_def zip_append_0_upt[of ts \"map (subst \\<rho>) ss\", simplified])"], ["proof (state)\nthis:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<xi>)) +\n  zhmset_of\n   (\\<delta>\\<^sub>h *\n    (arity_sym\\<^sub>h (min_ground_head \\<xi>) -\n     (of_nat (length ts) + of_nat (length ss)))) +\n  wt_args 0 A \\<xi> (ts @ map (subst \\<rho>) ss) =\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<xi>)) +\n  zhmset_of\n   (\\<delta>\\<^sub>h *\n    (arity_sym\\<^sub>h (min_ground_head \\<xi>) -\n     (of_nat (length ts) + of_nat (length ss)))) +\n  wt_args 0 A \\<xi> ts +\n  wt_args (length ts) A \\<xi> (map (subst \\<rho>) ss)\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta>' ssa.\n       \\<rho> x = apps (Hd \\<zeta>') ssa \\<Longrightarrow>\n       eval_tpoly A\n        (map_tpoly (\\<lambda>x. x) zhmset_of\n          (wt (subst \\<rho> (apps (Hd \\<zeta>) ss)))) =\n       eval_tpoly (subst_zpassign \\<rho> A)\n        (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))", "also"], ["proof (state)\nthis:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<xi>)) +\n  zhmset_of\n   (\\<delta>\\<^sub>h *\n    (arity_sym\\<^sub>h (min_ground_head \\<xi>) -\n     (of_nat (length ts) + of_nat (length ss)))) +\n  wt_args 0 A \\<xi> (ts @ map (subst \\<rho>) ss) =\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<xi>)) +\n  zhmset_of\n   (\\<delta>\\<^sub>h *\n    (arity_sym\\<^sub>h (min_ground_head \\<xi>) -\n     (of_nat (length ts) + of_nat (length ss)))) +\n  wt_args 0 A \\<xi> ts +\n  wt_args (length ts) A \\<xi> (map (subst \\<rho>) ss)\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta>' ssa.\n       \\<rho> x = apps (Hd \\<zeta>') ssa \\<Longrightarrow>\n       eval_tpoly A\n        (map_tpoly (\\<lambda>x. x) zhmset_of\n          (wt (subst \\<rho> (apps (Hd \\<zeta>) ss)))) =\n       eval_tpoly (subst_zpassign \\<rho> A)\n        (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))", "have \"\\<dots> = eval_tpoly A (zhmset_of_tpoly (wt0 \\<xi>))\n        + zhmset_of (\\<delta>\\<^sub>h * (arity_sym\\<^sub>h (min_ground_head \\<xi>)\n          - (of_nat (length ts) + of_nat (length ss))))\n        + wt_args 0 A \\<xi> ts + wt_args 0 (subst_zpassign \\<rho> A) (Var x) ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<xi>)) +\n    zhmset_of\n     (\\<delta>\\<^sub>h *\n      (arity_sym\\<^sub>h (min_ground_head \\<xi>) -\n       (of_nat (length ts) + of_nat (length ss)))) +\n    wt_args 0 A \\<xi> ts +\n    wt_args (length ts) A \\<xi> (map (subst \\<rho>) ss) =\n    eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<xi>)) +\n    zhmset_of\n     (\\<delta>\\<^sub>h *\n      (arity_sym\\<^sub>h (min_ground_head \\<xi>) -\n       (of_nat (length ts) + of_nat (length ss)))) +\n    wt_args 0 A \\<xi> ts +\n    wt_args 0 (subst_zpassign \\<rho> A) (Var x) ss", "by (auto intro!: arg_cong[of _ _ sum_list] nth_map_conv\n          simp: wt_args_def coef_subst add.commute zhmset_of_times ih[OF nth_mem wary_nth_ss])"], ["proof (state)\nthis:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<xi>)) +\n  zhmset_of\n   (\\<delta>\\<^sub>h *\n    (arity_sym\\<^sub>h (min_ground_head \\<xi>) -\n     (of_nat (length ts) + of_nat (length ss)))) +\n  wt_args 0 A \\<xi> ts +\n  wt_args (length ts) A \\<xi> (map (subst \\<rho>) ss) =\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<xi>)) +\n  zhmset_of\n   (\\<delta>\\<^sub>h *\n    (arity_sym\\<^sub>h (min_ground_head \\<xi>) -\n     (of_nat (length ts) + of_nat (length ss)))) +\n  wt_args 0 A \\<xi> ts +\n  wt_args 0 (subst_zpassign \\<rho> A) (Var x) ss\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta>' ssa.\n       \\<rho> x = apps (Hd \\<zeta>') ssa \\<Longrightarrow>\n       eval_tpoly A\n        (map_tpoly (\\<lambda>x. x) zhmset_of\n          (wt (subst \\<rho> (apps (Hd \\<zeta>) ss)))) =\n       eval_tpoly (subst_zpassign \\<rho> A)\n        (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))", "also"], ["proof (state)\nthis:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<xi>)) +\n  zhmset_of\n   (\\<delta>\\<^sub>h *\n    (arity_sym\\<^sub>h (min_ground_head \\<xi>) -\n     (of_nat (length ts) + of_nat (length ss)))) +\n  wt_args 0 A \\<xi> ts +\n  wt_args (length ts) A \\<xi> (map (subst \\<rho>) ss) =\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<xi>)) +\n  zhmset_of\n   (\\<delta>\\<^sub>h *\n    (arity_sym\\<^sub>h (min_ground_head \\<xi>) -\n     (of_nat (length ts) + of_nat (length ss)))) +\n  wt_args 0 A \\<xi> ts +\n  wt_args 0 (subst_zpassign \\<rho> A) (Var x) ss\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta>' ssa.\n       \\<rho> x = apps (Hd \\<zeta>') ssa \\<Longrightarrow>\n       eval_tpoly A\n        (map_tpoly (\\<lambda>x. x) zhmset_of\n          (wt (subst \\<rho> (apps (Hd \\<zeta>) ss)))) =\n       eval_tpoly (subst_zpassign \\<rho> A)\n        (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))", "have \"\\<dots> = eval_tpoly (subst_zpassign \\<rho> A) (zhmset_of_tpoly (wt0 (Var x)))\n        + zhmset_of (\\<delta>\\<^sub>h * (arity_sym\\<^sub>h (min_ground_head (Var x)) - of_nat (length ss)))\n        + wt_args 0 (subst_zpassign \\<rho> A) (Var x) ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<xi>)) +\n    zhmset_of\n     (\\<delta>\\<^sub>h *\n      (arity_sym\\<^sub>h (min_ground_head \\<xi>) -\n       (of_nat (length ts) + of_nat (length ss)))) +\n    wt_args 0 A \\<xi> ts +\n    wt_args 0 (subst_zpassign \\<rho> A) (Var x) ss =\n    eval_tpoly (subst_zpassign \\<rho> A)\n     (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 (Var x))) +\n    zhmset_of\n     (\\<delta>\\<^sub>h *\n      (arity_sym\\<^sub>h (min_ground_head (Var x)) - of_nat (length ss))) +\n    wt_args 0 (subst_zpassign \\<rho> A) (Var x) ss", "by (simp add: \\<rho>x wt_args_def comp_def algebra_simps ring_distribs(1)[symmetric]\n              zhmset_of_times zhmset_of_plus[symmetric] zhmset_of_0[symmetric])\n          (use tedious_ary_arith in fastforce)"], ["proof (state)\nthis:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<xi>)) +\n  zhmset_of\n   (\\<delta>\\<^sub>h *\n    (arity_sym\\<^sub>h (min_ground_head \\<xi>) -\n     (of_nat (length ts) + of_nat (length ss)))) +\n  wt_args 0 A \\<xi> ts +\n  wt_args 0 (subst_zpassign \\<rho> A) (Var x) ss =\n  eval_tpoly (subst_zpassign \\<rho> A)\n   (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 (Var x))) +\n  zhmset_of\n   (\\<delta>\\<^sub>h *\n    (arity_sym\\<^sub>h (min_ground_head (Var x)) - of_nat (length ss))) +\n  wt_args 0 (subst_zpassign \\<rho> A) (Var x) ss\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta>' ssa.\n       \\<rho> x = apps (Hd \\<zeta>') ssa \\<Longrightarrow>\n       eval_tpoly A\n        (map_tpoly (\\<lambda>x. x) zhmset_of\n          (wt (subst \\<rho> (apps (Hd \\<zeta>) ss)))) =\n       eval_tpoly (subst_zpassign \\<rho> A)\n        (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))", "also"], ["proof (state)\nthis:\n  eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 \\<xi>)) +\n  zhmset_of\n   (\\<delta>\\<^sub>h *\n    (arity_sym\\<^sub>h (min_ground_head \\<xi>) -\n     (of_nat (length ts) + of_nat (length ss)))) +\n  wt_args 0 A \\<xi> ts +\n  wt_args 0 (subst_zpassign \\<rho> A) (Var x) ss =\n  eval_tpoly (subst_zpassign \\<rho> A)\n   (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 (Var x))) +\n  zhmset_of\n   (\\<delta>\\<^sub>h *\n    (arity_sym\\<^sub>h (min_ground_head (Var x)) - of_nat (length ss))) +\n  wt_args 0 (subst_zpassign \\<rho> A) (Var x) ss\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta>' ssa.\n       \\<rho> x = apps (Hd \\<zeta>') ssa \\<Longrightarrow>\n       eval_tpoly A\n        (map_tpoly (\\<lambda>x. x) zhmset_of\n          (wt (subst \\<rho> (apps (Hd \\<zeta>) ss)))) =\n       eval_tpoly (subst_zpassign \\<rho> A)\n        (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))", "have \"\\<dots> = eval_tpoly (subst_zpassign \\<rho> A) (zhmset_of_tpoly (wt (apps (Hd (Var x)) ss)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_tpoly (subst_zpassign \\<rho> A)\n     (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 (Var x))) +\n    zhmset_of\n     (\\<delta>\\<^sub>h *\n      (arity_sym\\<^sub>h (min_ground_head (Var x)) - of_nat (length ss))) +\n    wt_args 0 (subst_zpassign \\<rho> A) (Var x) ss =\n    eval_tpoly (subst_zpassign \\<rho> A)\n     (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd (Var x)) ss)))", "by (simp add: wt_args_def comp_def)"], ["proof (state)\nthis:\n  eval_tpoly (subst_zpassign \\<rho> A)\n   (map_tpoly (\\<lambda>x. x) zhmset_of (wt0 (Var x))) +\n  zhmset_of\n   (\\<delta>\\<^sub>h *\n    (arity_sym\\<^sub>h (min_ground_head (Var x)) - of_nat (length ss))) +\n  wt_args 0 (subst_zpassign \\<rho> A) (Var x) ss =\n  eval_tpoly (subst_zpassign \\<rho> A)\n   (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd (Var x)) ss)))\n\ngoal (1 subgoal):\n 1. \\<And>\\<zeta>' ssa.\n       \\<rho> x = apps (Hd \\<zeta>') ssa \\<Longrightarrow>\n       eval_tpoly A\n        (map_tpoly (\\<lambda>x. x) zhmset_of\n          (wt (subst \\<rho> (apps (Hd \\<zeta>) ss)))) =\n       eval_tpoly (subst_zpassign \\<rho> A)\n        (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))", "finally"], ["proof (chain)\npicking this:\n  eval_tpoly A\n   (map_tpoly (\\<lambda>x. x) zhmset_of\n     (wt (subst \\<rho> (apps (Hd (Var x)) ss)))) =\n  eval_tpoly (subst_zpassign \\<rho> A)\n   (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd (Var x)) ss)))", "show ?thesis"], ["proof (prove)\nusing this:\n  eval_tpoly A\n   (map_tpoly (\\<lambda>x. x) zhmset_of\n     (wt (subst \\<rho> (apps (Hd (Var x)) ss)))) =\n  eval_tpoly (subst_zpassign \\<rho> A)\n   (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd (Var x)) ss)))\n\ngoal (1 subgoal):\n 1. eval_tpoly A\n     (map_tpoly (\\<lambda>x. x) zhmset_of\n       (wt (subst \\<rho> (apps (Hd \\<zeta>) ss)))) =\n    eval_tpoly (subst_zpassign \\<rho> A)\n     (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))", "unfolding \\<zeta>"], ["proof (prove)\nusing this:\n  eval_tpoly A\n   (map_tpoly (\\<lambda>x. x) zhmset_of\n     (wt (subst \\<rho> (apps (Hd (Var x)) ss)))) =\n  eval_tpoly (subst_zpassign \\<rho> A)\n   (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd (Var x)) ss)))\n\ngoal (1 subgoal):\n 1. eval_tpoly A\n     (map_tpoly (\\<lambda>x. x) zhmset_of\n       (wt (subst \\<rho> (apps (Hd (Var x)) ss)))) =\n    eval_tpoly (subst_zpassign \\<rho> A)\n     (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd (Var x)) ss)))", "by assumption"], ["proof (state)\nthis:\n  eval_tpoly A\n   (map_tpoly (\\<lambda>x. x) zhmset_of\n     (wt (subst \\<rho> (apps (Hd \\<zeta>) ss)))) =\n  eval_tpoly (subst_zpassign \\<rho> A)\n   (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval_tpoly A\n   (map_tpoly (\\<lambda>x. x) zhmset_of\n     (wt (subst \\<rho> (apps (Hd \\<zeta>) ss)))) =\n  eval_tpoly (subst_zpassign \\<rho> A)\n   (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<zeta> = Sym x2 \\<Longrightarrow>\n       eval_tpoly A\n        (map_tpoly (\\<lambda>x. x) zhmset_of\n          (wt (subst \\<rho> (apps (Hd \\<zeta>) ss)))) =\n       eval_tpoly (subst_zpassign \\<rho> A)\n        (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<zeta> = Sym x2 \\<Longrightarrow>\n       eval_tpoly A\n        (map_tpoly (\\<lambda>x. x) zhmset_of\n          (wt (subst \\<rho> (apps (Hd \\<zeta>) ss)))) =\n       eval_tpoly (subst_zpassign \\<rho> A)\n        (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))", "case \\<zeta>: (Sym f)"], ["proof (state)\nthis:\n  \\<zeta> = Sym f\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<zeta> = Sym x2 \\<Longrightarrow>\n       eval_tpoly A\n        (map_tpoly (\\<lambda>x. x) zhmset_of\n          (wt (subst \\<rho> (apps (Hd \\<zeta>) ss)))) =\n       eval_tpoly (subst_zpassign \\<rho> A)\n        (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))", "have \"eval_tpoly A (zhmset_of_tpoly (wt (subst \\<rho> (apps (Hd (Sym f)) ss)))) =\n      zhmset_of (wt_sym f) + zhmset_of (\\<delta>\\<^sub>h * (arity_sym\\<^sub>h f - of_nat (length ss)))\n      + wt_args 0 A (Sym f) (map (subst \\<rho>) ss)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eval_tpoly A\n     (map_tpoly (\\<lambda>x. x) zhmset_of\n       (wt (subst \\<rho> (apps (Hd (Sym f)) ss)))) =\n    zhmset_of (wt_sym f) +\n    zhmset_of\n     (\\<delta>\\<^sub>h * (arity_sym\\<^sub>h f - of_nat (length ss))) +\n    wt_args 0 A (Sym f) (map (subst \\<rho>) ss)", "by (simp add: wt_args_def comp_def)"], ["proof (state)\nthis:\n  eval_tpoly A\n   (map_tpoly (\\<lambda>x. x) zhmset_of\n     (wt (subst \\<rho> (apps (Hd (Sym f)) ss)))) =\n  zhmset_of (wt_sym f) +\n  zhmset_of\n   (\\<delta>\\<^sub>h * (arity_sym\\<^sub>h f - of_nat (length ss))) +\n  wt_args 0 A (Sym f) (map (subst \\<rho>) ss)\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<zeta> = Sym x2 \\<Longrightarrow>\n       eval_tpoly A\n        (map_tpoly (\\<lambda>x. x) zhmset_of\n          (wt (subst \\<rho> (apps (Hd \\<zeta>) ss)))) =\n       eval_tpoly (subst_zpassign \\<rho> A)\n        (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))", "also"], ["proof (state)\nthis:\n  eval_tpoly A\n   (map_tpoly (\\<lambda>x. x) zhmset_of\n     (wt (subst \\<rho> (apps (Hd (Sym f)) ss)))) =\n  zhmset_of (wt_sym f) +\n  zhmset_of\n   (\\<delta>\\<^sub>h * (arity_sym\\<^sub>h f - of_nat (length ss))) +\n  wt_args 0 A (Sym f) (map (subst \\<rho>) ss)\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<zeta> = Sym x2 \\<Longrightarrow>\n       eval_tpoly A\n        (map_tpoly (\\<lambda>x. x) zhmset_of\n          (wt (subst \\<rho> (apps (Hd \\<zeta>) ss)))) =\n       eval_tpoly (subst_zpassign \\<rho> A)\n        (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))", "have \"\\<dots> = zhmset_of (wt_sym f) + zhmset_of (\\<delta>\\<^sub>h * (arity_sym\\<^sub>h f - of_nat (length ss)))\n      + wt_args 0 (subst_zpassign \\<rho> A) (Sym f) ss\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zhmset_of (wt_sym f) +\n    zhmset_of\n     (\\<delta>\\<^sub>h * (arity_sym\\<^sub>h f - of_nat (length ss))) +\n    wt_args 0 A (Sym f) (map (subst \\<rho>) ss) =\n    zhmset_of (wt_sym f) +\n    zhmset_of\n     (\\<delta>\\<^sub>h * (arity_sym\\<^sub>h f - of_nat (length ss))) +\n    wt_args 0 (subst_zpassign \\<rho> A) (Sym f) ss", "by (auto simp: wt_args_def ih[OF _ wary_nth_ss] intro!: arg_cong[of _ _ sum_list]\n        nth_map_conv)"], ["proof (state)\nthis:\n  zhmset_of (wt_sym f) +\n  zhmset_of\n   (\\<delta>\\<^sub>h * (arity_sym\\<^sub>h f - of_nat (length ss))) +\n  wt_args 0 A (Sym f) (map (subst \\<rho>) ss) =\n  zhmset_of (wt_sym f) +\n  zhmset_of\n   (\\<delta>\\<^sub>h * (arity_sym\\<^sub>h f - of_nat (length ss))) +\n  wt_args 0 (subst_zpassign \\<rho> A) (Sym f) ss\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<zeta> = Sym x2 \\<Longrightarrow>\n       eval_tpoly A\n        (map_tpoly (\\<lambda>x. x) zhmset_of\n          (wt (subst \\<rho> (apps (Hd \\<zeta>) ss)))) =\n       eval_tpoly (subst_zpassign \\<rho> A)\n        (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))", "also"], ["proof (state)\nthis:\n  zhmset_of (wt_sym f) +\n  zhmset_of\n   (\\<delta>\\<^sub>h * (arity_sym\\<^sub>h f - of_nat (length ss))) +\n  wt_args 0 A (Sym f) (map (subst \\<rho>) ss) =\n  zhmset_of (wt_sym f) +\n  zhmset_of\n   (\\<delta>\\<^sub>h * (arity_sym\\<^sub>h f - of_nat (length ss))) +\n  wt_args 0 (subst_zpassign \\<rho> A) (Sym f) ss\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<zeta> = Sym x2 \\<Longrightarrow>\n       eval_tpoly A\n        (map_tpoly (\\<lambda>x. x) zhmset_of\n          (wt (subst \\<rho> (apps (Hd \\<zeta>) ss)))) =\n       eval_tpoly (subst_zpassign \\<rho> A)\n        (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))", "have \"\\<dots> = eval_tpoly (subst_zpassign \\<rho> A) (zhmset_of_tpoly (wt (apps (Hd (Sym f)) ss)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. zhmset_of (wt_sym f) +\n    zhmset_of\n     (\\<delta>\\<^sub>h * (arity_sym\\<^sub>h f - of_nat (length ss))) +\n    wt_args 0 (subst_zpassign \\<rho> A) (Sym f) ss =\n    eval_tpoly (subst_zpassign \\<rho> A)\n     (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd (Sym f)) ss)))", "by (simp add: wt_args_def comp_def)"], ["proof (state)\nthis:\n  zhmset_of (wt_sym f) +\n  zhmset_of\n   (\\<delta>\\<^sub>h * (arity_sym\\<^sub>h f - of_nat (length ss))) +\n  wt_args 0 (subst_zpassign \\<rho> A) (Sym f) ss =\n  eval_tpoly (subst_zpassign \\<rho> A)\n   (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd (Sym f)) ss)))\n\ngoal (1 subgoal):\n 1. \\<And>x2.\n       \\<zeta> = Sym x2 \\<Longrightarrow>\n       eval_tpoly A\n        (map_tpoly (\\<lambda>x. x) zhmset_of\n          (wt (subst \\<rho> (apps (Hd \\<zeta>) ss)))) =\n       eval_tpoly (subst_zpassign \\<rho> A)\n        (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))", "finally"], ["proof (chain)\npicking this:\n  eval_tpoly A\n   (map_tpoly (\\<lambda>x. x) zhmset_of\n     (wt (subst \\<rho> (apps (Hd (Sym f)) ss)))) =\n  eval_tpoly (subst_zpassign \\<rho> A)\n   (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd (Sym f)) ss)))", "show ?thesis"], ["proof (prove)\nusing this:\n  eval_tpoly A\n   (map_tpoly (\\<lambda>x. x) zhmset_of\n     (wt (subst \\<rho> (apps (Hd (Sym f)) ss)))) =\n  eval_tpoly (subst_zpassign \\<rho> A)\n   (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd (Sym f)) ss)))\n\ngoal (1 subgoal):\n 1. eval_tpoly A\n     (map_tpoly (\\<lambda>x. x) zhmset_of\n       (wt (subst \\<rho> (apps (Hd \\<zeta>) ss)))) =\n    eval_tpoly (subst_zpassign \\<rho> A)\n     (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))", "unfolding \\<zeta>"], ["proof (prove)\nusing this:\n  eval_tpoly A\n   (map_tpoly (\\<lambda>x. x) zhmset_of\n     (wt (subst \\<rho> (apps (Hd (Sym f)) ss)))) =\n  eval_tpoly (subst_zpassign \\<rho> A)\n   (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd (Sym f)) ss)))\n\ngoal (1 subgoal):\n 1. eval_tpoly A\n     (map_tpoly (\\<lambda>x. x) zhmset_of\n       (wt (subst \\<rho> (apps (Hd (Sym f)) ss)))) =\n    eval_tpoly (subst_zpassign \\<rho> A)\n     (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd (Sym f)) ss)))", "by assumption"], ["proof (state)\nthis:\n  eval_tpoly A\n   (map_tpoly (\\<lambda>x. x) zhmset_of\n     (wt (subst \\<rho> (apps (Hd \\<zeta>) ss)))) =\n  eval_tpoly (subst_zpassign \\<rho> A)\n   (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  eval_tpoly A\n   (map_tpoly (\\<lambda>x. x) zhmset_of\n     (wt (subst \\<rho> (apps (Hd \\<zeta>) ss)))) =\n  eval_tpoly (subst_zpassign \\<rho> A)\n   (map_tpoly (\\<lambda>x. x) zhmset_of (wt (apps (Hd \\<zeta>) ss)))\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem gt_subst:\n  assumes wary_\\<rho>: \"wary_subst \\<rho>\"\n  shows \"wary t \\<Longrightarrow> wary s \\<Longrightarrow> t >\\<^sub>t s \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>wary t; wary s; t >\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "proof (simp only: atomize_imp,\n    rule measure_induct_rule[of \"\\<lambda>(t, s). {#size t, size s#}\"\n        \"\\<lambda>(t, s). wary t \\<longrightarrow> wary s \\<longrightarrow> t >\\<^sub>t s \\<longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\" \"(t, s)\",\n      simplified prod.case],\n    simp only: split_paired_all prod.case atomize_imp[symmetric])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    wary aa; wary ba; aa >\\<^sub>t ba\\<rbrakk>\n                   \\<Longrightarrow> subst \\<rho> aa >\\<^sub>t\n                                     subst \\<rho> ba;\n        wary a; wary b; a >\\<^sub>t b\\<rbrakk>\n       \\<Longrightarrow> subst \\<rho> a >\\<^sub>t subst \\<rho> b", "fix t s"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    wary aa; wary ba; aa >\\<^sub>t ba\\<rbrakk>\n                   \\<Longrightarrow> subst \\<rho> aa >\\<^sub>t\n                                     subst \\<rho> ba;\n        wary a; wary b; a >\\<^sub>t b\\<rbrakk>\n       \\<Longrightarrow> subst \\<rho> a >\\<^sub>t subst \\<rho> b", "assume\n    ih: \"\\<And>ta sa. {#size ta, size sa#} < {#size t, size s#} \\<Longrightarrow> wary ta \\<Longrightarrow> wary sa \\<Longrightarrow> ta >\\<^sub>t sa \\<Longrightarrow>\n      subst \\<rho> ta >\\<^sub>t subst \\<rho> sa\" and\n    wary_t: \"wary t\" and wary_s: \"wary s\" and t_gt_s: \"t >\\<^sub>t s\""], ["proof (state)\nthis:\n  \\<lbrakk>{#size ?ta, size ?sa#} < {#size t, size s#}; wary ?ta; wary ?sa;\n   ?ta >\\<^sub>t ?sa\\<rbrakk>\n  \\<Longrightarrow> subst \\<rho> ?ta >\\<^sub>t subst \\<rho> ?sa\n  wary t\n  wary s\n  t >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    wary aa; wary ba; aa >\\<^sub>t ba\\<rbrakk>\n                   \\<Longrightarrow> subst \\<rho> aa >\\<^sub>t\n                                     subst \\<rho> ba;\n        wary a; wary b; a >\\<^sub>t b\\<rbrakk>\n       \\<Longrightarrow> subst \\<rho> a >\\<^sub>t subst \\<rho> b", "show \"subst \\<rho> t >\\<^sub>t subst \\<rho> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst \\<rho> t >\\<^sub>t subst \\<rho> s", "using t_gt_s"], ["proof (prove)\nusing this:\n  t >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. subst \\<rho> t >\\<^sub>t subst \\<rho> s", "proof cases"], ["proof (state)\ngoal (4 subgoals):\n 1. wt t >\\<^sub>p wt s \\<Longrightarrow>\n    subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 2. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     \\<not> head t \\<le>\\<ge>\\<^sub>h\\<^sub>d head s; num_args t = 1;\n     \\<exists>f\\<in>local.ground_heads (head t).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg t \\<ge>\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 3. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     head t >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 4. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "case gt_wt_t_s: gt_wt"], ["proof (state)\nthis:\n  wt t >\\<^sub>p wt s\n\ngoal (4 subgoals):\n 1. wt t >\\<^sub>p wt s \\<Longrightarrow>\n    subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 2. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     \\<not> head t \\<le>\\<ge>\\<^sub>h\\<^sub>d head s; num_args t = 1;\n     \\<exists>f\\<in>local.ground_heads (head t).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg t \\<ge>\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 3. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     head t >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 4. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "have \"wt (subst \\<rho> t) >\\<^sub>p wt (subst \\<rho> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wt (subst \\<rho> t) >\\<^sub>p wt (subst \\<rho> s)", "by (auto simp: gt_tpoly_def wary_s wary_t wt_subst[OF _ wary_\\<rho>]\n        intro: gt_wt_t_s[unfolded gt_tpoly_def, rule_format]\n        elim: legal_subst_zpassign[OF _ wary_\\<rho>])"], ["proof (state)\nthis:\n  wt (subst \\<rho> t) >\\<^sub>p wt (subst \\<rho> s)\n\ngoal (4 subgoals):\n 1. wt t >\\<^sub>p wt s \\<Longrightarrow>\n    subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 2. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     \\<not> head t \\<le>\\<ge>\\<^sub>h\\<^sub>d head s; num_args t = 1;\n     \\<exists>f\\<in>local.ground_heads (head t).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg t \\<ge>\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 3. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     head t >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 4. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "thus ?thesis"], ["proof (prove)\nusing this:\n  wt (subst \\<rho> t) >\\<^sub>p wt (subst \\<rho> s)\n\ngoal (1 subgoal):\n 1. subst \\<rho> t >\\<^sub>t subst \\<rho> s", "by (rule gt_wt)"], ["proof (state)\nthis:\n  subst \\<rho> t >\\<^sub>t subst \\<rho> s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     \\<not> head t \\<le>\\<ge>\\<^sub>h\\<^sub>d head s; num_args t = 1;\n     \\<exists>f\\<in>local.ground_heads (head t).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg t \\<ge>\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 2. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     head t >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 3. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     \\<not> head t \\<le>\\<ge>\\<^sub>h\\<^sub>d head s; num_args t = 1;\n     \\<exists>f\\<in>local.ground_heads (head t).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg t \\<ge>\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 2. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     head t >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 3. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "assume wt_t_ge_s: \"wt t \\<ge>\\<^sub>p wt s\""], ["proof (state)\nthis:\n  wt t \\<ge>\\<^sub>p wt s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     \\<not> head t \\<le>\\<ge>\\<^sub>h\\<^sub>d head s; num_args t = 1;\n     \\<exists>f\\<in>local.ground_heads (head t).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg t \\<ge>\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 2. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     head t >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 3. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "have wt_\\<rho>t_ge_\\<rho>s: \"wt (subst \\<rho> t) \\<ge>\\<^sub>p wt (subst \\<rho> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wt (subst \\<rho> t) \\<ge>\\<^sub>p wt (subst \\<rho> s)", "by (auto simp: ge_tpoly_def wary_s wary_t wt_subst[OF _ wary_\\<rho>]\n        intro: wt_t_ge_s[unfolded ge_tpoly_def, rule_format]\n        elim: legal_subst_zpassign[OF _ wary_\\<rho>])"], ["proof (state)\nthis:\n  wt (subst \\<rho> t) \\<ge>\\<^sub>p wt (subst \\<rho> s)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     \\<not> head t \\<le>\\<ge>\\<^sub>h\\<^sub>d head s; num_args t = 1;\n     \\<exists>f\\<in>local.ground_heads (head t).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg t \\<ge>\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 2. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     head t >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 3. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "{"], ["proof (state)\nthis:\n  wt (subst \\<rho> t) \\<ge>\\<^sub>p wt (subst \\<rho> s)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     \\<not> head t \\<le>\\<ge>\\<^sub>h\\<^sub>d head s; num_args t = 1;\n     \\<exists>f\\<in>local.ground_heads (head t).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg t \\<ge>\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 2. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     head t >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 3. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "case gt_unary"], ["proof (state)\nthis:\n  wt t \\<ge>\\<^sub>p wt s\n  \\<not> head t \\<le>\\<ge>\\<^sub>h\\<^sub>d head s\n  num_args t = 1\n  \\<exists>f\\<in>local.ground_heads (head t).\n     arity_sym f = 1 \\<and> wt_sym f = 0\n  arg t \\<ge>\\<^sub>t s\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     \\<not> head t \\<le>\\<ge>\\<^sub>h\\<^sub>d head s; num_args t = 1;\n     \\<exists>f\\<in>local.ground_heads (head t).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg t \\<ge>\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 2. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     head t >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 3. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "have wary_\\<rho>t: \"wary (subst \\<rho> t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wary (subst \\<rho> t)", "by (simp add: wary_subst_wary wary_t wary_\\<rho>)"], ["proof (state)\nthis:\n  wary (subst \\<rho> t)\n\ngoal (3 subgoals):\n 1. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     \\<not> head t \\<le>\\<ge>\\<^sub>h\\<^sub>d head s; num_args t = 1;\n     \\<exists>f\\<in>local.ground_heads (head t).\n        arity_sym f = 1 \\<and> wt_sym f = 0;\n     arg t \\<ge>\\<^sub>t s\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 2. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     head t >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 3. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst \\<rho> t >\\<^sub>t subst \\<rho> s", "proof (cases t)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x1.\n       t = Hd x1 \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 2. \\<And>x21 x22.\n       t = App x21 x22 \\<Longrightarrow>\n       subst \\<rho> t >\\<^sub>t subst \\<rho> s", "case Hd"], ["proof (state)\nthis:\n  t = Hd x1_\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       t = Hd x1 \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 2. \\<And>x21 x22.\n       t = App x21 x22 \\<Longrightarrow>\n       subst \\<rho> t >\\<^sub>t subst \\<rho> s", "hence False"], ["proof (prove)\nusing this:\n  t = Hd x1_\n\ngoal (1 subgoal):\n 1. False", "using gt_unary(3)"], ["proof (prove)\nusing this:\n  t = Hd x1_\n  num_args t = 1\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. \\<And>x1.\n       t = Hd x1 \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 2. \\<And>x21 x22.\n       t = App x21 x22 \\<Longrightarrow>\n       subst \\<rho> t >\\<^sub>t subst \\<rho> s", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. subst \\<rho> t >\\<^sub>t subst \\<rho> s", "by sat"], ["proof (state)\nthis:\n  subst \\<rho> t >\\<^sub>t subst \\<rho> s\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = App x21 x22 \\<Longrightarrow>\n       subst \\<rho> t >\\<^sub>t subst \\<rho> s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = App x21 x22 \\<Longrightarrow>\n       subst \\<rho> t >\\<^sub>t subst \\<rho> s", "case t: (App t1 t2)"], ["proof (state)\nthis:\n  t = App t1 t2\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = App x21 x22 \\<Longrightarrow>\n       subst \\<rho> t >\\<^sub>t subst \\<rho> s", "hence t2: \"t2 = arg t\""], ["proof (prove)\nusing this:\n  t = App t1 t2\n\ngoal (1 subgoal):\n 1. t2 = arg t", "by simp"], ["proof (state)\nthis:\n  t2 = arg t\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = App x21 x22 \\<Longrightarrow>\n       subst \\<rho> t >\\<^sub>t subst \\<rho> s", "hence wary_t2: \"wary t2\""], ["proof (prove)\nusing this:\n  t2 = arg t\n\ngoal (1 subgoal):\n 1. wary t2", "using wary_t"], ["proof (prove)\nusing this:\n  t2 = arg t\n  wary t\n\ngoal (1 subgoal):\n 1. wary t2", "by blast"], ["proof (state)\nthis:\n  wary t2\n\ngoal (1 subgoal):\n 1. \\<And>x21 x22.\n       t = App x21 x22 \\<Longrightarrow>\n       subst \\<rho> t >\\<^sub>t subst \\<rho> s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst \\<rho> t >\\<^sub>t subst \\<rho> s", "proof (cases \"t2 = s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. t2 = s \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 2. t2 \\<noteq> s \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "case True"], ["proof (state)\nthis:\n  t2 = s\n\ngoal (2 subgoals):\n 1. t2 = s \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 2. t2 \\<noteq> s \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "moreover"], ["proof (state)\nthis:\n  t2 = s\n\ngoal (2 subgoals):\n 1. t2 = s \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 2. t2 \\<noteq> s \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "have \"subst \\<rho> t >\\<^sub>t subst \\<rho> t2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst \\<rho> t >\\<^sub>t subst \\<rho> t2", "using gt_sub_arg wary_\\<rho>t"], ["proof (prove)\nusing this:\n  wary (App ?s ?t) \\<Longrightarrow> App ?s ?t >\\<^sub>t ?t\n  wary (subst \\<rho> t)\n\ngoal (1 subgoal):\n 1. subst \\<rho> t >\\<^sub>t subst \\<rho> t2", "unfolding t"], ["proof (prove)\nusing this:\n  wary (App ?s ?t) \\<Longrightarrow> App ?s ?t >\\<^sub>t ?t\n  wary (subst \\<rho> (App t1 t2))\n\ngoal (1 subgoal):\n 1. subst \\<rho> (App t1 t2) >\\<^sub>t subst \\<rho> t2", "by simp"], ["proof (state)\nthis:\n  subst \\<rho> t >\\<^sub>t subst \\<rho> t2\n\ngoal (2 subgoals):\n 1. t2 = s \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 2. t2 \\<noteq> s \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "ultimately"], ["proof (chain)\npicking this:\n  t2 = s\n  subst \\<rho> t >\\<^sub>t subst \\<rho> t2", "show ?thesis"], ["proof (prove)\nusing this:\n  t2 = s\n  subst \\<rho> t >\\<^sub>t subst \\<rho> t2\n\ngoal (1 subgoal):\n 1. subst \\<rho> t >\\<^sub>t subst \\<rho> s", "by simp"], ["proof (state)\nthis:\n  subst \\<rho> t >\\<^sub>t subst \\<rho> s\n\ngoal (1 subgoal):\n 1. t2 \\<noteq> s \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. t2 \\<noteq> s \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "case t2_ne_s: False"], ["proof (state)\nthis:\n  t2 \\<noteq> s\n\ngoal (1 subgoal):\n 1. t2 \\<noteq> s \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "hence t2_gt_s: \"t2 >\\<^sub>t s\""], ["proof (prove)\nusing this:\n  t2 \\<noteq> s\n\ngoal (1 subgoal):\n 1. t2 >\\<^sub>t s", "using gt_unary(5) t2"], ["proof (prove)\nusing this:\n  t2 \\<noteq> s\n  arg t \\<ge>\\<^sub>t s\n  t2 = arg t\n\ngoal (1 subgoal):\n 1. t2 >\\<^sub>t s", "by blast"], ["proof (state)\nthis:\n  t2 >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. t2 \\<noteq> s \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "have \"subst \\<rho> t2 >\\<^sub>t subst \\<rho> s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst \\<rho> t2 >\\<^sub>t subst \\<rho> s", "by (rule ih[OF _ wary_t2 wary_s t2_gt_s]) (simp add: t)"], ["proof (state)\nthis:\n  subst \\<rho> t2 >\\<^sub>t subst \\<rho> s\n\ngoal (1 subgoal):\n 1. t2 \\<noteq> s \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "thus ?thesis"], ["proof (prove)\nusing this:\n  subst \\<rho> t2 >\\<^sub>t subst \\<rho> s\n\ngoal (1 subgoal):\n 1. subst \\<rho> t >\\<^sub>t subst \\<rho> s", "by (metis gt_sub_arg gt_trans subst.simps(2) t wary_\\<rho> wary_\\<rho>t wary_s wary_subst_wary\n              wary_t2)"], ["proof (state)\nthis:\n  subst \\<rho> t >\\<^sub>t subst \\<rho> s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst \\<rho> t >\\<^sub>t subst \\<rho> s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst \\<rho> t >\\<^sub>t subst \\<rho> s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     head t >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 2. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "}"], ["proof (state)\nthis:\n  \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n   \\<not> head t \\<le>\\<ge>\\<^sub>h\\<^sub>d head s; num_args t = 1;\n   \\<exists>f\\<in>local.ground_heads (head t).\n      arity_sym f = 1 \\<and> wt_sym f = 0;\n   arg t \\<ge>\\<^sub>t s\\<rbrakk>\n  \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     head t >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 2. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "{"], ["proof (state)\nthis:\n  \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n   \\<not> head t \\<le>\\<ge>\\<^sub>h\\<^sub>d head s; num_args t = 1;\n   \\<exists>f\\<in>local.ground_heads (head t).\n      arity_sym f = 1 \\<and> wt_sym f = 0;\n   arg t \\<ge>\\<^sub>t s\\<rbrakk>\n  \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     head t >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 2. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "case _: gt_diff"], ["proof (state)\nthis:\n  wt t \\<ge>\\<^sub>p wt s\n  head t >\\<^sub>h\\<^sub>d head s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     head t >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 2. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "note hd_t_gt_hd_s = this(2)"], ["proof (state)\nthis:\n  head t >\\<^sub>h\\<^sub>d head s\n\ngoal (2 subgoals):\n 1. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     head t >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 2. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "have \"head (subst \\<rho> t) >\\<^sub>h\\<^sub>d head (subst \\<rho> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. head (subst \\<rho> t) >\\<^sub>h\\<^sub>d head (subst \\<rho> s)", "by (meson hd_t_gt_hd_s wary_subst_ground_heads gt_hd_def rev_subsetD wary_\\<rho>)"], ["proof (state)\nthis:\n  head (subst \\<rho> t) >\\<^sub>h\\<^sub>d head (subst \\<rho> s)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s;\n     head t >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n 2. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "thus ?thesis"], ["proof (prove)\nusing this:\n  head (subst \\<rho> t) >\\<^sub>h\\<^sub>d head (subst \\<rho> s)\n\ngoal (1 subgoal):\n 1. subst \\<rho> t >\\<^sub>t subst \\<rho> s", "by (rule gt_diff[OF wt_\\<rho>t_ge_\\<rho>s])"], ["proof (state)\nthis:\n  subst \\<rho> t >\\<^sub>t subst \\<rho> s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "}"], ["proof (state)\nthis:\n  \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n  \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "{"], ["proof (state)\nthis:\n  \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t >\\<^sub>h\\<^sub>d head s\\<rbrakk>\n  \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "case _: gt_same"], ["proof (state)\nthis:\n  wt t \\<ge>\\<^sub>p wt s\n  head t = head s\n  \\<forall>f\\<in>local.ground_heads (head t).\n     extf f (>\\<^sub>t) (args t) (args s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "note hd_s_eq_hd_t = this(2) and extf = this(3)"], ["proof (state)\nthis:\n  head t = head s\n  \\<forall>f\\<in>local.ground_heads (head t).\n     extf f (>\\<^sub>t) (args t) (args s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "have hd_\\<rho>t: \"head (subst \\<rho> t) = head (subst \\<rho> s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. head (subst \\<rho> t) = head (subst \\<rho> s)", "by (simp add: hd_s_eq_hd_t)"], ["proof (state)\nthis:\n  head (subst \\<rho> t) = head (subst \\<rho> s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "{"], ["proof (state)\nthis:\n  head (subst \\<rho> t) = head (subst \\<rho> s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "assume f_in_grs: \"f \\<in> ground_heads (head (subst \\<rho> t))\""], ["proof (state)\nthis:\n  f \\<in> local.ground_heads (head (subst \\<rho> t))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "let ?S = \"set (args t) \\<union> set (args s)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "have extf_args_s_t: \"extf f (>\\<^sub>t) (args t) (args s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extf f (>\\<^sub>t) (args t) (args s)", "using extf f_in_grs wary_subst_ground_heads wary_\\<rho>"], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>local.ground_heads (head t).\n     extf f (>\\<^sub>t) (args t) (args s)\n  f \\<in> local.ground_heads (head (subst \\<rho> t))\n  wary_subst ?\\<rho> \\<Longrightarrow>\n  local.ground_heads (head (subst ?\\<rho> ?s))\n  \\<subseteq> local.ground_heads (head ?s)\n  wary_subst \\<rho>\n\ngoal (1 subgoal):\n 1. extf f (>\\<^sub>t) (args t) (args s)", "by blast"], ["proof (state)\nthis:\n  extf f (>\\<^sub>t) (args t) (args s)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "have \"extf f (>\\<^sub>t) (map (subst \\<rho>) (args t)) (map (subst \\<rho>) (args s))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. extf f (>\\<^sub>t) (map (subst \\<rho>) (args t))\n     (map (subst \\<rho>) (args s))", "proof (rule extf_map[of ?S, OF _ _ _ _ _ _ extf_args_s_t])"], ["proof (state)\ngoal (6 subgoals):\n 1. finite (set (args t) \\<union> set (args s))\n 2. args t \\<in> lists (set (args t) \\<union> set (args s))\n 3. args s \\<in> lists (set (args t) \\<union> set (args s))\n 4. \\<forall>x\\<in>set (args t) \\<union> set (args s).\n       \\<not> subst \\<rho> x >\\<^sub>t subst \\<rho> x\n 5. \\<forall>z\\<in>set (args t) \\<union> set (args s).\n       \\<forall>y\\<in>set (args t) \\<union> set (args s).\n          \\<forall>x\\<in>set (args t) \\<union> set (args s).\n             subst \\<rho> z >\\<^sub>t subst \\<rho> y \\<longrightarrow>\n             subst \\<rho> y >\\<^sub>t subst \\<rho> x \\<longrightarrow>\n             subst \\<rho> z >\\<^sub>t subst \\<rho> x\n 6. \\<forall>y\\<in>set (args t) \\<union> set (args s).\n       \\<forall>x\\<in>set (args t) \\<union> set (args s).\n          y >\\<^sub>t x \\<longrightarrow>\n          subst \\<rho> y >\\<^sub>t subst \\<rho> x", "show \"\\<forall>x \\<in> ?S. \\<not> subst \\<rho> x >\\<^sub>t subst \\<rho> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (args t) \\<union> set (args s).\n       \\<not> subst \\<rho> x >\\<^sub>t subst \\<rho> x", "using gt_irrefl wary_t wary_s wary_args wary_\\<rho> wary_subst_wary"], ["proof (prove)\nusing this:\n  wary ?s \\<Longrightarrow> \\<not> ?s >\\<^sub>t ?s\n  wary t\n  wary s\n  \\<lbrakk>?s \\<in> set (args ?t); wary ?t\\<rbrakk>\n  \\<Longrightarrow> wary ?s\n  wary_subst \\<rho>\n  \\<lbrakk>wary_subst ?\\<rho>; wary ?s\\<rbrakk>\n  \\<Longrightarrow> wary (subst ?\\<rho> ?s)\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>set (args t) \\<union> set (args s).\n       \\<not> subst \\<rho> x >\\<^sub>t subst \\<rho> x", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>x\\<in>set (args t) \\<union> set (args s).\n     \\<not> subst \\<rho> x >\\<^sub>t subst \\<rho> x\n\ngoal (5 subgoals):\n 1. finite (set (args t) \\<union> set (args s))\n 2. args t \\<in> lists (set (args t) \\<union> set (args s))\n 3. args s \\<in> lists (set (args t) \\<union> set (args s))\n 4. \\<forall>z\\<in>set (args t) \\<union> set (args s).\n       \\<forall>y\\<in>set (args t) \\<union> set (args s).\n          \\<forall>x\\<in>set (args t) \\<union> set (args s).\n             subst \\<rho> z >\\<^sub>t subst \\<rho> y \\<longrightarrow>\n             subst \\<rho> y >\\<^sub>t subst \\<rho> x \\<longrightarrow>\n             subst \\<rho> z >\\<^sub>t subst \\<rho> x\n 5. \\<forall>y\\<in>set (args t) \\<union> set (args s).\n       \\<forall>x\\<in>set (args t) \\<union> set (args s).\n          y >\\<^sub>t x \\<longrightarrow>\n          subst \\<rho> y >\\<^sub>t subst \\<rho> x", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. finite (set (args t) \\<union> set (args s))\n 2. args t \\<in> lists (set (args t) \\<union> set (args s))\n 3. args s \\<in> lists (set (args t) \\<union> set (args s))\n 4. \\<forall>z\\<in>set (args t) \\<union> set (args s).\n       \\<forall>y\\<in>set (args t) \\<union> set (args s).\n          \\<forall>x\\<in>set (args t) \\<union> set (args s).\n             subst \\<rho> z >\\<^sub>t subst \\<rho> y \\<longrightarrow>\n             subst \\<rho> y >\\<^sub>t subst \\<rho> x \\<longrightarrow>\n             subst \\<rho> z >\\<^sub>t subst \\<rho> x\n 5. \\<forall>y\\<in>set (args t) \\<union> set (args s).\n       \\<forall>x\\<in>set (args t) \\<union> set (args s).\n          y >\\<^sub>t x \\<longrightarrow>\n          subst \\<rho> y >\\<^sub>t subst \\<rho> x", "show \"\\<forall>z \\<in> ?S. \\<forall>y \\<in> ?S. \\<forall>x \\<in> ?S. subst \\<rho> z >\\<^sub>t subst \\<rho> y \\<longrightarrow> subst \\<rho> y >\\<^sub>t subst \\<rho> x \\<longrightarrow>\n            subst \\<rho> z >\\<^sub>t subst \\<rho> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>z\\<in>set (args t) \\<union> set (args s).\n       \\<forall>y\\<in>set (args t) \\<union> set (args s).\n          \\<forall>x\\<in>set (args t) \\<union> set (args s).\n             subst \\<rho> z >\\<^sub>t subst \\<rho> y \\<longrightarrow>\n             subst \\<rho> y >\\<^sub>t subst \\<rho> x \\<longrightarrow>\n             subst \\<rho> z >\\<^sub>t subst \\<rho> x", "using gt_trans wary_t wary_s wary_args wary_\\<rho> wary_subst_wary"], ["proof (prove)\nusing this:\n  \\<lbrakk>wary ?u; wary ?t; wary ?s; ?u >\\<^sub>t ?t;\n   ?t >\\<^sub>t ?s\\<rbrakk>\n  \\<Longrightarrow> ?u >\\<^sub>t ?s\n  wary t\n  wary s\n  \\<lbrakk>?s \\<in> set (args ?t); wary ?t\\<rbrakk>\n  \\<Longrightarrow> wary ?s\n  wary_subst \\<rho>\n  \\<lbrakk>wary_subst ?\\<rho>; wary ?s\\<rbrakk>\n  \\<Longrightarrow> wary (subst ?\\<rho> ?s)\n\ngoal (1 subgoal):\n 1. \\<forall>z\\<in>set (args t) \\<union> set (args s).\n       \\<forall>y\\<in>set (args t) \\<union> set (args s).\n          \\<forall>x\\<in>set (args t) \\<union> set (args s).\n             subst \\<rho> z >\\<^sub>t subst \\<rho> y \\<longrightarrow>\n             subst \\<rho> y >\\<^sub>t subst \\<rho> x \\<longrightarrow>\n             subst \\<rho> z >\\<^sub>t subst \\<rho> x", "by (metis Un_iff)"], ["proof (state)\nthis:\n  \\<forall>z\\<in>set (args t) \\<union> set (args s).\n     \\<forall>y\\<in>set (args t) \\<union> set (args s).\n        \\<forall>x\\<in>set (args t) \\<union> set (args s).\n           subst \\<rho> z >\\<^sub>t subst \\<rho> y \\<longrightarrow>\n           subst \\<rho> y >\\<^sub>t subst \\<rho> x \\<longrightarrow>\n           subst \\<rho> z >\\<^sub>t subst \\<rho> x\n\ngoal (4 subgoals):\n 1. finite (set (args t) \\<union> set (args s))\n 2. args t \\<in> lists (set (args t) \\<union> set (args s))\n 3. args s \\<in> lists (set (args t) \\<union> set (args s))\n 4. \\<forall>y\\<in>set (args t) \\<union> set (args s).\n       \\<forall>x\\<in>set (args t) \\<union> set (args s).\n          y >\\<^sub>t x \\<longrightarrow>\n          subst \\<rho> y >\\<^sub>t subst \\<rho> x", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. finite (set (args t) \\<union> set (args s))\n 2. args t \\<in> lists (set (args t) \\<union> set (args s))\n 3. args s \\<in> lists (set (args t) \\<union> set (args s))\n 4. \\<forall>y\\<in>set (args t) \\<union> set (args s).\n       \\<forall>x\\<in>set (args t) \\<union> set (args s).\n          y >\\<^sub>t x \\<longrightarrow>\n          subst \\<rho> y >\\<^sub>t subst \\<rho> x", "have sz_a: \"\\<forall>ta \\<in> ?S. \\<forall>sa \\<in> ?S. {#size ta, size sa#} < {#size t, size s#}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>taa\\<in>set (args t) \\<union> set (args s).\n       \\<forall>saa\\<in>set (args t) \\<union> set (args s).\n          {#size taa, size saa#} < {#size t, size s#}", "by (fastforce intro: Max_lt_imp_lt_mset dest: size_in_args)"], ["proof (state)\nthis:\n  \\<forall>taa\\<in>set (args t) \\<union> set (args s).\n     \\<forall>saa\\<in>set (args t) \\<union> set (args s).\n        {#size taa, size saa#} < {#size t, size s#}\n\ngoal (4 subgoals):\n 1. finite (set (args t) \\<union> set (args s))\n 2. args t \\<in> lists (set (args t) \\<union> set (args s))\n 3. args s \\<in> lists (set (args t) \\<union> set (args s))\n 4. \\<forall>y\\<in>set (args t) \\<union> set (args s).\n       \\<forall>x\\<in>set (args t) \\<union> set (args s).\n          y >\\<^sub>t x \\<longrightarrow>\n          subst \\<rho> y >\\<^sub>t subst \\<rho> x", "show \"\\<forall>y \\<in> ?S. \\<forall>x \\<in> ?S. y >\\<^sub>t x \\<longrightarrow> subst \\<rho> y >\\<^sub>t subst \\<rho> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set (args t) \\<union> set (args s).\n       \\<forall>x\\<in>set (args t) \\<union> set (args s).\n          y >\\<^sub>t x \\<longrightarrow>\n          subst \\<rho> y >\\<^sub>t subst \\<rho> x", "using ih sz_a size_in_args wary_t wary_s wary_args wary_\\<rho> wary_subst_wary"], ["proof (prove)\nusing this:\n  \\<lbrakk>{#size ?ta, size ?sa#} < {#size t, size s#}; wary ?ta; wary ?sa;\n   ?ta >\\<^sub>t ?sa\\<rbrakk>\n  \\<Longrightarrow> subst \\<rho> ?ta >\\<^sub>t subst \\<rho> ?sa\n  \\<forall>taa\\<in>set (args t) \\<union> set (args s).\n     \\<forall>saa\\<in>set (args t) \\<union> set (args s).\n        {#size taa, size saa#} < {#size t, size s#}\n  ?s \\<in> set (args ?t) \\<Longrightarrow> size ?s < size ?t\n  wary t\n  wary s\n  \\<lbrakk>?s \\<in> set (args ?t); wary ?t\\<rbrakk>\n  \\<Longrightarrow> wary ?s\n  wary_subst \\<rho>\n  \\<lbrakk>wary_subst ?\\<rho>; wary ?s\\<rbrakk>\n  \\<Longrightarrow> wary (subst ?\\<rho> ?s)\n\ngoal (1 subgoal):\n 1. \\<forall>y\\<in>set (args t) \\<union> set (args s).\n       \\<forall>x\\<in>set (args t) \\<union> set (args s).\n          y >\\<^sub>t x \\<longrightarrow>\n          subst \\<rho> y >\\<^sub>t subst \\<rho> x", "by fastforce"], ["proof (state)\nthis:\n  \\<forall>y\\<in>set (args t) \\<union> set (args s).\n     \\<forall>x\\<in>set (args t) \\<union> set (args s).\n        y >\\<^sub>t x \\<longrightarrow>\n        subst \\<rho> y >\\<^sub>t subst \\<rho> x\n\ngoal (3 subgoals):\n 1. finite (set (args t) \\<union> set (args s))\n 2. args t \\<in> lists (set (args t) \\<union> set (args s))\n 3. args s \\<in> lists (set (args t) \\<union> set (args s))", "qed auto"], ["proof (state)\nthis:\n  extf f (>\\<^sub>t) (map (subst \\<rho>) (args t))\n   (map (subst \\<rho>) (args s))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "hence \"extf f (>\\<^sub>t) (args (subst \\<rho> t)) (args (subst \\<rho> s))\""], ["proof (prove)\nusing this:\n  extf f (>\\<^sub>t) (map (subst \\<rho>) (args t))\n   (map (subst \\<rho>) (args s))\n\ngoal (1 subgoal):\n 1. extf f (>\\<^sub>t) (args (subst \\<rho> t)) (args (subst \\<rho> s))", "by (auto simp: hd_s_eq_hd_t intro: extf_compat_append_left)"], ["proof (state)\nthis:\n  extf f (>\\<^sub>t) (args (subst \\<rho> t)) (args (subst \\<rho> s))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "}"], ["proof (state)\nthis:\n  ?f2 \\<in> local.ground_heads (head (subst \\<rho> t)) \\<Longrightarrow>\n  extf ?f2 (>\\<^sub>t) (args (subst \\<rho> t)) (args (subst \\<rho> s))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "hence \"\\<forall>f \\<in> ground_heads (head (subst \\<rho> t)).\n        extf f (>\\<^sub>t) (args (subst \\<rho> t)) (args (subst \\<rho> s))\""], ["proof (prove)\nusing this:\n  ?f2 \\<in> local.ground_heads (head (subst \\<rho> t)) \\<Longrightarrow>\n  extf ?f2 (>\\<^sub>t) (args (subst \\<rho> t)) (args (subst \\<rho> s))\n\ngoal (1 subgoal):\n 1. \\<forall>f\\<in>local.ground_heads (head (subst \\<rho> t)).\n       extf f (>\\<^sub>t) (args (subst \\<rho> t)) (args (subst \\<rho> s))", "by blast"], ["proof (state)\nthis:\n  \\<forall>f\\<in>local.ground_heads (head (subst \\<rho> t)).\n     extf f (>\\<^sub>t) (args (subst \\<rho> t)) (args (subst \\<rho> s))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n     \\<forall>f\\<in>local.ground_heads (head t).\n        extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n    \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<forall>f\\<in>local.ground_heads (head (subst \\<rho> t)).\n     extf f (>\\<^sub>t) (args (subst \\<rho> t)) (args (subst \\<rho> s))\n\ngoal (1 subgoal):\n 1. subst \\<rho> t >\\<^sub>t subst \\<rho> s", "by (rule gt_same[OF wt_\\<rho>t_ge_\\<rho>s hd_\\<rho>t])"], ["proof (state)\nthis:\n  subst \\<rho> t >\\<^sub>t subst \\<rho> s\n\ngoal:\nNo subgoals!", "}"], ["proof (state)\nthis:\n  \\<lbrakk>wt t \\<ge>\\<^sub>p wt s; head t = head s;\n   \\<forall>f\\<in>local.ground_heads (head t).\n      extf f (>\\<^sub>t) (args t) (args s)\\<rbrakk>\n  \\<Longrightarrow> subst \\<rho> t >\\<^sub>t subst \\<rho> s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst \\<rho> t >\\<^sub>t subst \\<rho> s\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Totality on Ground Terms\\<close>"], ["", "lemma wt_total_ground:\n  assumes\n    gr_t: \"ground t\" and\n    gr_s: \"ground s\"\n  shows \"wt t >\\<^sub>p wt s \\<or> wt s >\\<^sub>p wt t \\<or> wt t =\\<^sub>p wt s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wt t >\\<^sub>p wt s \\<or> wt s >\\<^sub>p wt t \\<or> wt t =\\<^sub>p wt s", "unfolding gt_tpoly_def eq_tpoly_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>A.\n        legal_zpassign A \\<longrightarrow>\n        eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s))\n        < eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))) \\<or>\n    (\\<forall>A.\n        legal_zpassign A \\<longrightarrow>\n        eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t))\n        < eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s))) \\<or>\n    (\\<forall>A.\n        legal_zpassign A \\<longrightarrow>\n        eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt t)) =\n        eval_tpoly A (map_tpoly (\\<lambda>x. x) zhmset_of (wt s)))", "by (subst (1 2 3) ground_eval_ztpoly_wt_eq[OF gr_t, of _ undefined],\n    subst (1 2 3) ground_eval_ztpoly_wt_eq[OF gr_s, of _ undefined], auto)"], ["", "theorem gt_total_ground:\n  assumes extf_total: \"\\<And>f. ext_total (extf f)\"\n  shows \"ground t \\<Longrightarrow> ground s \\<Longrightarrow> t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ground t; ground s\\<rbrakk>\n    \\<Longrightarrow> t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s", "proof (simp only: atomize_imp,\n    rule measure_induct_rule[of \"\\<lambda>(t, s). {# size t, size s #}\"\n      \"\\<lambda>(t, s). ground t \\<longrightarrow> ground s \\<longrightarrow> t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s\" \"(t, s)\", simplified prod.case],\n    simp only: split_paired_all prod.case atomize_imp[symmetric])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "fix t s :: \"('s, 'v) tm\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "assume\n    ih: \"\\<And>ta sa. {# size ta, size sa #} < {# size t, size s #} \\<Longrightarrow> ground ta \\<Longrightarrow> ground sa \\<Longrightarrow>\n      ta >\\<^sub>t sa \\<or> sa >\\<^sub>t ta \\<or> ta = sa\" and\n    gr_t: \"ground t\" and gr_s: \"ground s\""], ["proof (state)\nthis:\n  \\<lbrakk>{#size ?ta, size ?sa#} < {#size t, size s#}; ground ?ta;\n   ground ?sa\\<rbrakk>\n  \\<Longrightarrow> ?ta >\\<^sub>t ?sa \\<or>\n                    ?sa >\\<^sub>t ?ta \\<or> ?ta = ?sa\n  ground t\n  ground s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "let ?case = \"t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "assume \"wt t >\\<^sub>p wt s\""], ["proof (state)\nthis:\n  wt t >\\<^sub>p wt s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "hence \"t >\\<^sub>t s\""], ["proof (prove)\nusing this:\n  wt t >\\<^sub>p wt s\n\ngoal (1 subgoal):\n 1. t >\\<^sub>t s", "by (rule gt_wt)"], ["proof (state)\nthis:\n  t >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "}"], ["proof (state)\nthis:\n  wt t >\\<^sub>p wt s \\<Longrightarrow> t >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "moreover"], ["proof (state)\nthis:\n  wt t >\\<^sub>p wt s \\<Longrightarrow> t >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "{"], ["proof (state)\nthis:\n  wt t >\\<^sub>p wt s \\<Longrightarrow> t >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "assume \"wt s >\\<^sub>p wt t\""], ["proof (state)\nthis:\n  wt s >\\<^sub>p wt t\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "hence \"s >\\<^sub>t t\""], ["proof (prove)\nusing this:\n  wt s >\\<^sub>p wt t\n\ngoal (1 subgoal):\n 1. s >\\<^sub>t t", "by (rule gt_wt)"], ["proof (state)\nthis:\n  s >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "}"], ["proof (state)\nthis:\n  wt s >\\<^sub>p wt t \\<Longrightarrow> s >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "moreover"], ["proof (state)\nthis:\n  wt s >\\<^sub>p wt t \\<Longrightarrow> s >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "{"], ["proof (state)\nthis:\n  wt s >\\<^sub>p wt t \\<Longrightarrow> s >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "assume \"wt t =\\<^sub>p wt s\""], ["proof (state)\nthis:\n  wt t =\\<^sub>p wt s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "hence wt_t_ge_s: \"wt t \\<ge>\\<^sub>p wt s\" and wt_s_ge_t: \"wt s \\<ge>\\<^sub>p wt t\""], ["proof (prove)\nusing this:\n  wt t =\\<^sub>p wt s\n\ngoal (1 subgoal):\n 1. wt t \\<ge>\\<^sub>p wt s &&& wt s \\<ge>\\<^sub>p wt t", "by (simp add: eq_tpoly_def ge_tpoly_def)+"], ["proof (state)\nthis:\n  wt t \\<ge>\\<^sub>p wt s\n  wt s \\<ge>\\<^sub>p wt t\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "obtain g where \\<xi>: \"head t = Sym g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>g. head t = Sym g \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis ground_head[OF gr_t] hd.collapse(2))"], ["proof (state)\nthis:\n  head t = Sym g\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "obtain f where \\<zeta>: \"head s = Sym f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>f. head s = Sym f \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis ground_head[OF gr_s] hd.collapse(2))"], ["proof (state)\nthis:\n  head s = Sym f\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "{"], ["proof (state)\nthis:\n  head s = Sym f\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "assume g_gt_f: \"g >\\<^sub>s f\""], ["proof (state)\nthis:\n  g >\\<^sub>s f\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "have \"t >\\<^sub>t s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t >\\<^sub>t s", "by (rule gt_diff[OF wt_t_ge_s]) (simp add: \\<xi> \\<zeta> g_gt_f gt_hd_def)"], ["proof (state)\nthis:\n  t >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "}"], ["proof (state)\nthis:\n  g >\\<^sub>s f \\<Longrightarrow> t >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "moreover"], ["proof (state)\nthis:\n  g >\\<^sub>s f \\<Longrightarrow> t >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "{"], ["proof (state)\nthis:\n  g >\\<^sub>s f \\<Longrightarrow> t >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "assume f_gt_g: \"f >\\<^sub>s g\""], ["proof (state)\nthis:\n  f >\\<^sub>s g\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "have \"s >\\<^sub>t t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s >\\<^sub>t t", "by (rule gt_diff[OF wt_s_ge_t]) (simp add: \\<xi> \\<zeta> f_gt_g gt_hd_def)"], ["proof (state)\nthis:\n  s >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "}"], ["proof (state)\nthis:\n  f >\\<^sub>s g \\<Longrightarrow> s >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "moreover"], ["proof (state)\nthis:\n  f >\\<^sub>s g \\<Longrightarrow> s >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "{"], ["proof (state)\nthis:\n  f >\\<^sub>s g \\<Longrightarrow> s >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "assume g_eq_f: \"g = f\""], ["proof (state)\nthis:\n  g = f\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "hence hd_t: \"head t = head s\""], ["proof (prove)\nusing this:\n  g = f\n\ngoal (1 subgoal):\n 1. head t = head s", "using \\<xi> \\<zeta>"], ["proof (prove)\nusing this:\n  g = f\n  head t = Sym g\n  head s = Sym f\n\ngoal (1 subgoal):\n 1. head t = head s", "by force"], ["proof (state)\nthis:\n  head t = head s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "note hd_s = hd_t[symmetric]"], ["proof (state)\nthis:\n  head s = head t\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "let ?ts = \"args t\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "let ?ss = \"args s\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "have gr_ts: \"\\<forall>t \\<in> set ?ts. ground t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>set (args t). ground t", "using gr_t ground_args"], ["proof (prove)\nusing this:\n  ground t\n  \\<lbrakk>?t \\<in> set (args ?s); ground ?s\\<rbrakk>\n  \\<Longrightarrow> ground ?t\n\ngoal (1 subgoal):\n 1. \\<forall>t\\<in>set (args t). ground t", "by auto"], ["proof (state)\nthis:\n  \\<forall>t\\<in>set (args t). ground t\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "have gr_ss: \"\\<forall>s \\<in> set ?ss. ground s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>set (args s). ground s", "using gr_s ground_args"], ["proof (prove)\nusing this:\n  ground s\n  \\<lbrakk>?t \\<in> set (args ?s); ground ?s\\<rbrakk>\n  \\<Longrightarrow> ground ?t\n\ngoal (1 subgoal):\n 1. \\<forall>s\\<in>set (args s). ground s", "by auto"], ["proof (state)\nthis:\n  \\<forall>s\\<in>set (args s). ground s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "have ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s", "proof (cases \"?ts = ?ss\")"], ["proof (state)\ngoal (2 subgoals):\n 1. args t = args s \\<Longrightarrow>\n    t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s\n 2. args t \\<noteq> args s \\<Longrightarrow>\n    t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s", "case ts_eq_ss: True"], ["proof (state)\nthis:\n  args t = args s\n\ngoal (2 subgoals):\n 1. args t = args s \\<Longrightarrow>\n    t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s\n 2. args t \\<noteq> args s \\<Longrightarrow>\n    t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s", "using \\<xi> \\<zeta> g_eq_f ts_eq_ss"], ["proof (prove)\nusing this:\n  head t = Sym g\n  head s = Sym f\n  g = f\n  args t = args s\n\ngoal (1 subgoal):\n 1. t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s", "by (simp add: tm_expand_apps)"], ["proof (state)\nthis:\n  t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s\n\ngoal (1 subgoal):\n 1. args t \\<noteq> args s \\<Longrightarrow>\n    t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. args t \\<noteq> args s \\<Longrightarrow>\n    t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s", "case False"], ["proof (state)\nthis:\n  args t \\<noteq> args s\n\ngoal (1 subgoal):\n 1. args t \\<noteq> args s \\<Longrightarrow>\n    t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s", "hence \"extf g (>\\<^sub>t) ?ts ?ss \\<or> extf g (>\\<^sub>t) ?ss ?ts\""], ["proof (prove)\nusing this:\n  args t \\<noteq> args s\n\ngoal (1 subgoal):\n 1. extf g (>\\<^sub>t) (args t) (args s) \\<or>\n    extf g (>\\<^sub>t) (args s) (args t)", "using ih gr_ss gr_ts less_multiset_doubletons\n            ext_total.total[OF extf_total, rule_format, of \"set ?ts \\<union> set ?ss\" \"(>\\<^sub>t)\" ?ts ?ss g]"], ["proof (prove)\nusing this:\n  args t \\<noteq> args s\n  \\<lbrakk>{#size ?ta, size ?sa#} < {#size t, size s#}; ground ?ta;\n   ground ?sa\\<rbrakk>\n  \\<Longrightarrow> ?ta >\\<^sub>t ?sa \\<or>\n                    ?sa >\\<^sub>t ?ta \\<or> ?ta = ?sa\n  \\<forall>s\\<in>set (args s). ground s\n  \\<forall>t\\<in>set (args t). ground t\n  \\<lbrakk>?y < ?t \\<or> ?y < ?s; ?x < ?t \\<or> ?x < ?s\\<rbrakk>\n  \\<Longrightarrow> {#?y, ?x#} < {#?t, ?s#}\n  \\<lbrakk>\\<And>y x.\n              \\<lbrakk>y \\<in> set (args t) \\<union> set (args s);\n               x \\<in> set (args t) \\<union> set (args s)\\<rbrakk>\n              \\<Longrightarrow> y >\\<^sub>t x \\<or>\n                                x >\\<^sub>t y \\<or> y = x;\n   args t \\<in> lists (set (args t) \\<union> set (args s));\n   args s \\<in> lists (set (args t) \\<union> set (args s))\\<rbrakk>\n  \\<Longrightarrow> extf g (>\\<^sub>t) (args t) (args s) \\<or>\n                    extf g (>\\<^sub>t) (args s) (args t) \\<or>\n                    args t = args s\n\ngoal (1 subgoal):\n 1. extf g (>\\<^sub>t) (args t) (args s) \\<or>\n    extf g (>\\<^sub>t) (args s) (args t)", "by (metis Un_commute Un_iff in_lists_iff_set size_in_args sup_ge2)"], ["proof (state)\nthis:\n  extf g (>\\<^sub>t) (args t) (args s) \\<or>\n  extf g (>\\<^sub>t) (args s) (args t)\n\ngoal (1 subgoal):\n 1. args t \\<noteq> args s \\<Longrightarrow>\n    t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s", "moreover"], ["proof (state)\nthis:\n  extf g (>\\<^sub>t) (args t) (args s) \\<or>\n  extf g (>\\<^sub>t) (args s) (args t)\n\ngoal (1 subgoal):\n 1. args t \\<noteq> args s \\<Longrightarrow>\n    t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s", "{"], ["proof (state)\nthis:\n  extf g (>\\<^sub>t) (args t) (args s) \\<or>\n  extf g (>\\<^sub>t) (args s) (args t)\n\ngoal (1 subgoal):\n 1. args t \\<noteq> args s \\<Longrightarrow>\n    t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s", "assume extf: \"extf g (>\\<^sub>t) ?ts ?ss\""], ["proof (state)\nthis:\n  extf g (>\\<^sub>t) (args t) (args s)\n\ngoal (1 subgoal):\n 1. args t \\<noteq> args s \\<Longrightarrow>\n    t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s", "have \"t >\\<^sub>t s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t >\\<^sub>t s", "by (rule gt_same[OF wt_t_ge_s hd_t]) (simp add: extf \\<xi>)"], ["proof (state)\nthis:\n  t >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. args t \\<noteq> args s \\<Longrightarrow>\n    t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s", "}"], ["proof (state)\nthis:\n  extf g (>\\<^sub>t) (args t) (args s) \\<Longrightarrow> t >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. args t \\<noteq> args s \\<Longrightarrow>\n    t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s", "moreover"], ["proof (state)\nthis:\n  extf g (>\\<^sub>t) (args t) (args s) \\<Longrightarrow> t >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. args t \\<noteq> args s \\<Longrightarrow>\n    t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s", "{"], ["proof (state)\nthis:\n  extf g (>\\<^sub>t) (args t) (args s) \\<Longrightarrow> t >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. args t \\<noteq> args s \\<Longrightarrow>\n    t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s", "assume extf: \"extf g (>\\<^sub>t) ?ss ?ts\""], ["proof (state)\nthis:\n  extf g (>\\<^sub>t) (args s) (args t)\n\ngoal (1 subgoal):\n 1. args t \\<noteq> args s \\<Longrightarrow>\n    t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s", "have \"s >\\<^sub>t t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. s >\\<^sub>t t", "by (rule gt_same[OF wt_s_ge_t hd_s]) (simp add: extf[unfolded g_eq_f] \\<zeta>)"], ["proof (state)\nthis:\n  s >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. args t \\<noteq> args s \\<Longrightarrow>\n    t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s", "}"], ["proof (state)\nthis:\n  extf g (>\\<^sub>t) (args s) (args t) \\<Longrightarrow> s >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. args t \\<noteq> args s \\<Longrightarrow>\n    t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s", "ultimately"], ["proof (chain)\npicking this:\n  extf g (>\\<^sub>t) (args t) (args s) \\<or>\n  extf g (>\\<^sub>t) (args s) (args t)\n  extf g (>\\<^sub>t) (args t) (args s) \\<Longrightarrow> t >\\<^sub>t s\n  extf g (>\\<^sub>t) (args s) (args t) \\<Longrightarrow> s >\\<^sub>t t", "show ?thesis"], ["proof (prove)\nusing this:\n  extf g (>\\<^sub>t) (args t) (args s) \\<or>\n  extf g (>\\<^sub>t) (args s) (args t)\n  extf g (>\\<^sub>t) (args t) (args s) \\<Longrightarrow> t >\\<^sub>t s\n  extf g (>\\<^sub>t) (args s) (args t) \\<Longrightarrow> s >\\<^sub>t t\n\ngoal (1 subgoal):\n 1. t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s", "by sat"], ["proof (state)\nthis:\n  t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "}"], ["proof (state)\nthis:\n  g = f \\<Longrightarrow> t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "ultimately"], ["proof (chain)\npicking this:\n  g >\\<^sub>s f \\<Longrightarrow> t >\\<^sub>t s\n  f >\\<^sub>s g \\<Longrightarrow> s >\\<^sub>t t\n  g = f \\<Longrightarrow> t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s", "have ?case"], ["proof (prove)\nusing this:\n  g >\\<^sub>s f \\<Longrightarrow> t >\\<^sub>t s\n  f >\\<^sub>s g \\<Longrightarrow> s >\\<^sub>t t\n  g = f \\<Longrightarrow> t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s\n\ngoal (1 subgoal):\n 1. t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s", "using gt_sym_total"], ["proof (prove)\nusing this:\n  g >\\<^sub>s f \\<Longrightarrow> t >\\<^sub>t s\n  f >\\<^sub>s g \\<Longrightarrow> s >\\<^sub>t t\n  g = f \\<Longrightarrow> t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s\n  ?f >\\<^sub>s ?g \\<or> ?g >\\<^sub>s ?f \\<or> ?g = ?f\n\ngoal (1 subgoal):\n 1. t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s", "by blast"], ["proof (state)\nthis:\n  t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "}"], ["proof (state)\nthis:\n  wt t =\\<^sub>p wt s \\<Longrightarrow>\n  t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>aa ba.\n                   \\<lbrakk>{#size aa, size ba#} < {#size a, size b#};\n                    ground aa; ground ba\\<rbrakk>\n                   \\<Longrightarrow> aa >\\<^sub>t ba \\<or>\n                                     ba >\\<^sub>t aa \\<or> aa = ba;\n        ground a; ground b\\<rbrakk>\n       \\<Longrightarrow> a >\\<^sub>t b \\<or> b >\\<^sub>t a \\<or> a = b", "ultimately"], ["proof (chain)\npicking this:\n  wt t >\\<^sub>p wt s \\<Longrightarrow> t >\\<^sub>t s\n  wt s >\\<^sub>p wt t \\<Longrightarrow> s >\\<^sub>t t\n  wt t =\\<^sub>p wt s \\<Longrightarrow>\n  t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s", "show ?case"], ["proof (prove)\nusing this:\n  wt t >\\<^sub>p wt s \\<Longrightarrow> t >\\<^sub>t s\n  wt s >\\<^sub>p wt t \\<Longrightarrow> s >\\<^sub>t t\n  wt t =\\<^sub>p wt s \\<Longrightarrow>\n  t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s\n\ngoal (1 subgoal):\n 1. t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s", "using wt_total_ground[OF gr_t gr_s]"], ["proof (prove)\nusing this:\n  wt t >\\<^sub>p wt s \\<Longrightarrow> t >\\<^sub>t s\n  wt s >\\<^sub>p wt t \\<Longrightarrow> s >\\<^sub>t t\n  wt t =\\<^sub>p wt s \\<Longrightarrow>\n  t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s\n  wt t >\\<^sub>p wt s \\<or> wt s >\\<^sub>p wt t \\<or> wt t =\\<^sub>p wt s\n\ngoal (1 subgoal):\n 1. t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s", "by fast"], ["proof (state)\nthis:\n  t >\\<^sub>t s \\<or> s >\\<^sub>t t \\<or> t = s\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Well-foundedness\\<close>"], ["", "abbreviation gtw :: \"('s, 'v) tm \\<Rightarrow> ('s, 'v) tm \\<Rightarrow> bool\" (infix \">\\<^sub>t\\<^sub>w\" 50) where\n  \"(>\\<^sub>t\\<^sub>w) \\<equiv> \\<lambda>t s. wary t \\<and> wary s \\<and> t >\\<^sub>t s\""], ["", "abbreviation gtwg :: \"('s, 'v) tm \\<Rightarrow> ('s, 'v) tm \\<Rightarrow> bool\" (infix \">\\<^sub>t\\<^sub>w\\<^sub>g\" 50) where\n  \"(>\\<^sub>t\\<^sub>w\\<^sub>g) \\<equiv> \\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s\""], ["", "lemma ground_gt_unary:\n  assumes gr_t: \"ground t\"\n  shows \"\\<not> gt_unary t s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> gt_unary t s", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. gt_unary t s \\<Longrightarrow> False", "assume gt_unary_t_s: \"gt_unary t s\""], ["proof (state)\nthis:\n  gt_unary t s\n\ngoal (1 subgoal):\n 1. gt_unary t s \\<Longrightarrow> False", "hence \"t >\\<^sub>t s\""], ["proof (prove)\nusing this:\n  gt_unary t s\n\ngoal (1 subgoal):\n 1. t >\\<^sub>t s", "using gt_iff_wt_unary_diff_same"], ["proof (prove)\nusing this:\n  gt_unary t s\n  (?t >\\<^sub>t ?s) =\n  (gt_wt ?t ?s \\<or> gt_unary ?t ?s \\<or> gt_diff ?t ?s \\<or> gt_same ?t ?s)\n\ngoal (1 subgoal):\n 1. t >\\<^sub>t s", "by blast"], ["proof (state)\nthis:\n  t >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. gt_unary t s \\<Longrightarrow> False", "hence gr_s: \"ground s\""], ["proof (prove)\nusing this:\n  t >\\<^sub>t s\n\ngoal (1 subgoal):\n 1. ground s", "using gr_t gt_imp_vars"], ["proof (prove)\nusing this:\n  t >\\<^sub>t s\n  ground t\n  ?t >\\<^sub>t ?s \\<Longrightarrow> vars ?s \\<subseteq> vars ?t\n\ngoal (1 subgoal):\n 1. ground s", "by blast"], ["proof (state)\nthis:\n  ground s\n\ngoal (1 subgoal):\n 1. gt_unary t s \\<Longrightarrow> False", "have ngr_t_or_s: \"\\<not> ground t \\<or> \\<not> ground s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars t \\<noteq> {} \\<or> vars s \\<noteq> {}", "using gt_unary_t_s"], ["proof (prove)\nusing this:\n  gt_unary t s\n\ngoal (1 subgoal):\n 1. vars t \\<noteq> {} \\<or> vars s \\<noteq> {}", "by cases (blast dest: ground_head not_comp_hd_imp_Var)"], ["proof (state)\nthis:\n  vars t \\<noteq> {} \\<or> vars s \\<noteq> {}\n\ngoal (1 subgoal):\n 1. gt_unary t s \\<Longrightarrow> False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using gr_t gr_s ngr_t_or_s"], ["proof (prove)\nusing this:\n  ground t\n  ground s\n  vars t \\<noteq> {} \\<or> vars s \\<noteq> {}\n\ngoal (1 subgoal):\n 1. False", "by sat"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem gt_wf: \"wfP (\\<lambda>s t. t >\\<^sub>t\\<^sub>w s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfP (\\<lambda>s t. t >\\<^sub>t\\<^sub>w s)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. wfP (\\<lambda>s t. t >\\<^sub>t\\<^sub>w s)", "have ground_wfP: \"wfP (\\<lambda>s t. t >\\<^sub>t\\<^sub>w\\<^sub>g s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfP (\\<lambda>s t. ground t \\<and> t >\\<^sub>t\\<^sub>w s)", "unfolding wfP_iff_no_inf_chain"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> Ex (inf_chain\n                (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "assume \"\\<exists>f. inf_chain (>\\<^sub>t\\<^sub>w\\<^sub>g) f\""], ["proof (state)\nthis:\n  \\<exists>f.\n     inf_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s) f\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "then"], ["proof (chain)\npicking this:\n  \\<exists>f.\n     inf_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s) f", "obtain t where t_bad: \"bad (>\\<^sub>t\\<^sub>w\\<^sub>g) t\""], ["proof (prove)\nusing this:\n  \\<exists>f.\n     inf_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s) f\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        bad (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n         t \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding inf_chain_def bad_def"], ["proof (prove)\nusing this:\n  \\<exists>f.\n     \\<forall>i. ground (f i) \\<and> f i >\\<^sub>t\\<^sub>w f (Suc i)\n\ngoal (1 subgoal):\n 1. (\\<And>t.\n        \\<exists>f.\n           (\\<forall>i.\n               ground (f i) \\<and> f i >\\<^sub>t\\<^sub>w f (Suc i)) \\<and>\n           f 0 = t \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  bad (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s) t\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "let ?ff = \"worst_chain (>\\<^sub>t\\<^sub>w\\<^sub>g) (\\<lambda>t s. size t > size s)\""], ["proof (state)\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "let ?A = min_passign"], ["proof (state)\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "note wf_sz = wf_app[OF wellorder_class.wf, of size, simplified]"], ["proof (state)\nthis:\n  wf {(x, y). size x < size y}\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "have ffi_ground: \"\\<And>i. ground (?ff i)\" and ffi_wary: \"\\<And>i. wary (?ff i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i.\n        ground\n         (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n           (\\<lambda>t s. size s < size t) i)) &&&\n    (\\<And>i.\n        wary\n         (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n           (\\<lambda>t s. size s < size t) i))", "using worst_chain_bad[OF wf_sz t_bad, unfolded inf_chain_def]"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     ground\n      (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n        (\\<lambda>y x. size x < size y) i) \\<and>\n     worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n      (\\<lambda>y x. size x < size y) i >\\<^sub>t\\<^sub>w\n     worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n      (\\<lambda>y x. size x < size y) (Suc i)\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        ground\n         (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n           (\\<lambda>t s. size s < size t) i)) &&&\n    (\\<And>i.\n        wary\n         (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n           (\\<lambda>t s. size s < size t) i))", "by fast+"], ["proof (state)\nthis:\n  ground\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n     (\\<lambda>t s. size s < size t) ?i)\n  wary\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n     (\\<lambda>t s. size s < size t) ?i)\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "have \"inf_chain (>\\<^sub>t\\<^sub>w\\<^sub>g) ?ff\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inf_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t))", "by (rule worst_chain_bad[OF wf_sz t_bad])"], ["proof (state)\nthis:\n  inf_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n     (\\<lambda>t s. size s < size t))\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "hence bad_wt_diff_same:\n      \"inf_chain (\\<lambda>t s. ground t \\<and> (gt_wt t s \\<or> gt_diff t s \\<or> gt_same t s)) ?ff\""], ["proof (prove)\nusing this:\n  inf_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n     (\\<lambda>t s. size s < size t))\n\ngoal (1 subgoal):\n 1. inf_chain\n     (\\<lambda>t s.\n         ground t \\<and> (gt_wt t s \\<or> gt_diff t s \\<or> gt_same t s))\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t))", "unfolding inf_chain_def"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     ground\n      (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n        (\\<lambda>t s. size s < size t) i) \\<and>\n     worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n      (\\<lambda>t s. size s < size t) i >\\<^sub>t\\<^sub>w\n     worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n      (\\<lambda>t s. size s < size t) (Suc i)\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       ground\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n          (\\<lambda>t s. size s < size t) i) \\<and>\n       (gt_wt\n         (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n           (\\<lambda>t s. size s < size t) i)\n         (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n           (\\<lambda>t s. size s < size t) (Suc i)) \\<or>\n        gt_diff\n         (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n           (\\<lambda>t s. size s < size t) i)\n         (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n           (\\<lambda>t s. size s < size t) (Suc i)) \\<or>\n        gt_same\n         (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n           (\\<lambda>t s. size s < size t) i)\n         (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n           (\\<lambda>t s. size s < size t) (Suc i)))", "using gt_iff_wt_unary_diff_same ground_gt_unary"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     ground\n      (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n        (\\<lambda>t s. size s < size t) i) \\<and>\n     worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n      (\\<lambda>t s. size s < size t) i >\\<^sub>t\\<^sub>w\n     worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n      (\\<lambda>t s. size s < size t) (Suc i)\n  (?t >\\<^sub>t ?s) =\n  (gt_wt ?t ?s \\<or> gt_unary ?t ?s \\<or> gt_diff ?t ?s \\<or> gt_same ?t ?s)\n  ground ?t \\<Longrightarrow> \\<not> gt_unary ?t ?s\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       ground\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n          (\\<lambda>t s. size s < size t) i) \\<and>\n       (gt_wt\n         (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n           (\\<lambda>t s. size s < size t) i)\n         (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n           (\\<lambda>t s. size s < size t) (Suc i)) \\<or>\n        gt_diff\n         (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n           (\\<lambda>t s. size s < size t) i)\n         (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n           (\\<lambda>t s. size s < size t) (Suc i)) \\<or>\n        gt_same\n         (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n           (\\<lambda>t s. size s < size t) i)\n         (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n           (\\<lambda>t s. size s < size t) (Suc i)))", "by blast"], ["proof (state)\nthis:\n  inf_chain\n   (\\<lambda>t s.\n       ground t \\<and> (gt_wt t s \\<or> gt_diff t s \\<or> gt_same t s))\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n     (\\<lambda>t s. size s < size t))\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "have wf_wt: \"wf {(s, t). ground t \\<and> gt_wt t s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf {(s, t). ground t \\<and> gt_wt t s}", "by (rule wf_subset[OF wf_app[of _ \"eval_tpoly ?A \\<circ> wt\", OF wf_less_hmultiset]],\n        simp add: gt_wt.simps gt_tpoly_def, fold zhmset_of_less,\n        auto simp: legal_min_zpassign gt_wt.simps gt_tpoly_def)"], ["proof (state)\nthis:\n  wf {(s, t). ground t \\<and> gt_wt t s}\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "have wt_O_diff_same: \"{(s, t). ground t \\<and> gt_wt t s}\n        O {(s, t). ground t \\<and> wt t =\\<^sub>p wt s \\<and>  (gt_diff t s \\<or> gt_same t s)}\n      \\<subseteq> {(s, t). ground t \\<and> gt_wt t s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(s, t). ground t \\<and> gt_wt t s} O\n    {(s, t).\n     ground t \\<and>\n     wt t =\\<^sub>p wt s \\<and> (gt_diff t s \\<or> gt_same t s)}\n    \\<subseteq> {(s, t). ground t \\<and> gt_wt t s}", "unfolding gt_wt.simps gt_diff.simps gt_same.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(s, t).\n     ground t \\<and>\n     (\\<exists>ta sa. t = ta \\<and> s = sa \\<and> wt ta >\\<^sub>p wt sa)} O\n    {(s, t).\n     ground t \\<and>\n     wt t =\\<^sub>p wt s \\<and>\n     ((\\<exists>ta sa.\n          t = ta \\<and>\n          s = sa \\<and>\n          wt ta \\<ge>\\<^sub>p wt sa \\<and>\n          head ta >\\<^sub>h\\<^sub>d head sa) \\<or>\n      (\\<exists>ta sa.\n          t = ta \\<and>\n          s = sa \\<and>\n          wt ta \\<ge>\\<^sub>p wt sa \\<and>\n          head ta = head sa \\<and>\n          (\\<forall>f\\<in>local.ground_heads (head ta).\n              extf f (>\\<^sub>t) (args ta) (args sa))))}\n    \\<subseteq> {(s, t).\n                 ground t \\<and>\n                 (\\<exists>ta sa.\n                     t = ta \\<and> s = sa \\<and> wt ta >\\<^sub>p wt sa)}", "by (auto intro: ge_gt_tpoly_trans)"], ["proof (state)\nthis:\n  {(s, t). ground t \\<and> gt_wt t s} O\n  {(s, t).\n   ground t \\<and>\n   wt t =\\<^sub>p wt s \\<and> (gt_diff t s \\<or> gt_same t s)}\n  \\<subseteq> {(s, t). ground t \\<and> gt_wt t s}\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "have wt_diff_same_as_union:\n      \"{(s, t). ground t \\<and> (gt_wt t s \\<or> gt_diff t s \\<or> gt_same t s)} =\n       {(s, t). ground t \\<and> gt_wt t s}\n       \\<union> {(s, t). ground t \\<and> wt t =\\<^sub>p wt s \\<and> (gt_diff t s \\<or> gt_same t s)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(s, t).\n     ground t \\<and> (gt_wt t s \\<or> gt_diff t s \\<or> gt_same t s)} =\n    {(s, t). ground t \\<and> gt_wt t s} \\<union>\n    {(s, t).\n     ground t \\<and>\n     wt t =\\<^sub>p wt s \\<and> (gt_diff t s \\<or> gt_same t s)}", "using gt_ge_tpoly_trans gt_tpoly_irrefl wt_ge_vars wt_total_ground"], ["proof (prove)\nusing this:\n  \\<lbrakk>?r >\\<^sub>p ?q; ?q \\<ge>\\<^sub>p ?p\\<rbrakk>\n  \\<Longrightarrow> ?r >\\<^sub>p ?p\n  \\<not> ?p >\\<^sub>p ?p\n  wt ?t \\<ge>\\<^sub>p wt ?s \\<Longrightarrow> vars ?s \\<subseteq> vars ?t\n  \\<lbrakk>ground ?t; ground ?s\\<rbrakk>\n  \\<Longrightarrow> wt ?t >\\<^sub>p wt ?s \\<or>\n                    wt ?s >\\<^sub>p wt ?t \\<or> wt ?t =\\<^sub>p wt ?s\n\ngoal (1 subgoal):\n 1. {(s, t).\n     ground t \\<and> (gt_wt t s \\<or> gt_diff t s \\<or> gt_same t s)} =\n    {(s, t). ground t \\<and> gt_wt t s} \\<union>\n    {(s, t).\n     ground t \\<and>\n     wt t =\\<^sub>p wt s \\<and> (gt_diff t s \\<or> gt_same t s)}", "by (fastforce simp: gt_wt.simps gt_diff.simps gt_same.simps)"], ["proof (state)\nthis:\n  {(s, t).\n   ground t \\<and> (gt_wt t s \\<or> gt_diff t s \\<or> gt_same t s)} =\n  {(s, t). ground t \\<and> gt_wt t s} \\<union>\n  {(s, t).\n   ground t \\<and>\n   wt t =\\<^sub>p wt s \\<and> (gt_diff t s \\<or> gt_same t s)}\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "obtain k1 where bad_diff_same:\n      \"inf_chain (\\<lambda>t s. ground t \\<and> wt t =\\<^sub>p wt s \\<and> (gt_diff t s \\<or> gt_same t s)) (\\<lambda>i. ?ff (i + k1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k1.\n        inf_chain\n         (\\<lambda>t s.\n             ground t \\<and>\n             wt t =\\<^sub>p wt s \\<and> (gt_diff t s \\<or> gt_same t s))\n         (\\<lambda>i.\n             worst_chain\n              (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n              (\\<lambda>t s. size s < size t) (i + k1)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using wf_infinite_down_chain_compatible[OF wf_wt _ wt_O_diff_same, of ?ff] bad_wt_diff_same"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (Suc i),\n      worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) i)\n     \\<in> {(s, t). ground t \\<and> gt_wt t s} \\<union>\n           {(s, t).\n            ground t \\<and>\n            wt t =\\<^sub>p wt s \\<and>\n            (gt_diff t s \\<or> gt_same t s)} \\<Longrightarrow>\n  \\<exists>k.\n     \\<forall>i.\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n          (\\<lambda>t s. size s < size t) (Suc (i + k)),\n         worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n          (\\<lambda>t s. size s < size t) (i + k))\n        \\<in> {(s, t).\n               ground t \\<and>\n               wt t =\\<^sub>p wt s \\<and> (gt_diff t s \\<or> gt_same t s)}\n  inf_chain\n   (\\<lambda>t s.\n       ground t \\<and> (gt_wt t s \\<or> gt_diff t s \\<or> gt_same t s))\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n     (\\<lambda>t s. size s < size t))\n\ngoal (1 subgoal):\n 1. (\\<And>k1.\n        inf_chain\n         (\\<lambda>t s.\n             ground t \\<and>\n             wt t =\\<^sub>p wt s \\<and> (gt_diff t s \\<or> gt_same t s))\n         (\\<lambda>i.\n             worst_chain\n              (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n              (\\<lambda>t s. size s < size t) (i + k1)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding inf_chain_def wt_diff_same_as_union[symmetric]"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (Suc i),\n      worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) i)\n     \\<in> {(s, t).\n            ground t \\<and>\n            (gt_wt t s \\<or>\n             gt_diff t s \\<or> gt_same t s)} \\<Longrightarrow>\n  \\<exists>k.\n     \\<forall>i.\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n          (\\<lambda>t s. size s < size t) (Suc (i + k)),\n         worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n          (\\<lambda>t s. size s < size t) (i + k))\n        \\<in> {(s, t).\n               ground t \\<and>\n               wt t =\\<^sub>p wt s \\<and> (gt_diff t s \\<or> gt_same t s)}\n  \\<forall>i.\n     ground\n      (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n        (\\<lambda>t s. size s < size t) i) \\<and>\n     (gt_wt\n       (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n         (\\<lambda>t s. size s < size t) i)\n       (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n         (\\<lambda>t s. size s < size t) (Suc i)) \\<or>\n      gt_diff\n       (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n         (\\<lambda>t s. size s < size t) i)\n       (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n         (\\<lambda>t s. size s < size t) (Suc i)) \\<or>\n      gt_same\n       (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n         (\\<lambda>t s. size s < size t) i)\n       (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n         (\\<lambda>t s. size s < size t) (Suc i)))\n\ngoal (1 subgoal):\n 1. (\\<And>k1.\n        \\<forall>i.\n           ground\n            (worst_chain\n              (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n              (\\<lambda>t s. size s < size t) (i + k1)) \\<and>\n           wt (worst_chain\n                (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n                (\\<lambda>t s. size s < size t) (i + k1)) =\\<^sub>p\n           wt (worst_chain\n                (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n                (\\<lambda>t s. size s < size t) (Suc i + k1)) \\<and>\n           (gt_diff\n             (worst_chain\n               (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n               (\\<lambda>t s. size s < size t) (i + k1))\n             (worst_chain\n               (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n               (\\<lambda>t s. size s < size t) (Suc i + k1)) \\<or>\n            gt_same\n             (worst_chain\n               (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n               (\\<lambda>t s. size s < size t) (i + k1))\n             (worst_chain\n               (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n               (\\<lambda>t s. size s < size t)\n               (Suc i + k1))) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  inf_chain\n   (\\<lambda>t s.\n       ground t \\<and>\n       wt t =\\<^sub>p wt s \\<and> (gt_diff t s \\<or> gt_same t s))\n   (\\<lambda>i.\n       worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n        (\\<lambda>t s. size s < size t) (i + k1))\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "have \"wf {(s, t). ground s \\<and> ground t \\<and> wt t =\\<^sub>p wt s \\<and> sym (head t) >\\<^sub>s sym (head s)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf {(s, t).\n        ground s \\<and>\n        ground t \\<and>\n        wt t =\\<^sub>p wt s \\<and>\n        hd.sym (head t) >\\<^sub>s hd.sym (head s)}", "using gt_sym_wf"], ["proof (prove)\nusing this:\n  wfP (\\<lambda>f g. g >\\<^sub>s f)\n\ngoal (1 subgoal):\n 1. wf {(s, t).\n        ground s \\<and>\n        ground t \\<and>\n        wt t =\\<^sub>p wt s \\<and>\n        hd.sym (head t) >\\<^sub>s hd.sym (head s)}", "unfolding wfP_def wf_iff_no_infinite_down_chain"], ["proof (prove)\nusing this:\n  \\<nexists>f. \\<forall>i. (f (Suc i), f i) \\<in> {(f, g). g >\\<^sub>s f}\n\ngoal (1 subgoal):\n 1. \\<nexists>f.\n       \\<forall>i.\n          (f (Suc i), f i)\n          \\<in> {(s, t).\n                 ground s \\<and>\n                 ground t \\<and>\n                 wt t =\\<^sub>p wt s \\<and>\n                 hd.sym (head t) >\\<^sub>s hd.sym (head s)}", "by fast"], ["proof (state)\nthis:\n  wf {(s, t).\n      ground s \\<and>\n      ground t \\<and>\n      wt t =\\<^sub>p wt s \\<and> hd.sym (head t) >\\<^sub>s hd.sym (head s)}\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  wf {(s, t).\n      ground s \\<and>\n      ground t \\<and>\n      wt t =\\<^sub>p wt s \\<and> hd.sym (head t) >\\<^sub>s hd.sym (head s)}\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "have \"{(s, t). ground t \\<and> wt t =\\<^sub>p wt s \\<and> gt_diff t s}\n      \\<subseteq> {(s, t). ground s \\<and> ground t \\<and> wt t =\\<^sub>p wt s \\<and> sym (head t) >\\<^sub>s sym (head s)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(s, t). ground t \\<and> wt t =\\<^sub>p wt s \\<and> gt_diff t s}\n    \\<subseteq> {(s, t).\n                 ground s \\<and>\n                 ground t \\<and>\n                 wt t =\\<^sub>p wt s \\<and>\n                 hd.sym (head t) >\\<^sub>s hd.sym (head s)}", "proof (clarsimp, intro conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>ground b; wt b =\\<^sub>p wt a; gt_diff b a\\<rbrakk>\n       \\<Longrightarrow> ground a\n 2. \\<And>a b.\n       \\<lbrakk>ground b; wt b =\\<^sub>p wt a; gt_diff b a\\<rbrakk>\n       \\<Longrightarrow> hd.sym (head b) >\\<^sub>s hd.sym (head a)", "fix s t"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>ground b; wt b =\\<^sub>p wt a; gt_diff b a\\<rbrakk>\n       \\<Longrightarrow> ground a\n 2. \\<And>a b.\n       \\<lbrakk>ground b; wt b =\\<^sub>p wt a; gt_diff b a\\<rbrakk>\n       \\<Longrightarrow> hd.sym (head b) >\\<^sub>s hd.sym (head a)", "assume gr_t: \"ground t\" and gt_diff_t_s: \"gt_diff t s\""], ["proof (state)\nthis:\n  ground t\n  gt_diff t s\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>ground b; wt b =\\<^sub>p wt a; gt_diff b a\\<rbrakk>\n       \\<Longrightarrow> ground a\n 2. \\<And>a b.\n       \\<lbrakk>ground b; wt b =\\<^sub>p wt a; gt_diff b a\\<rbrakk>\n       \\<Longrightarrow> hd.sym (head b) >\\<^sub>s hd.sym (head a)", "thus gr_s: \"ground s\""], ["proof (prove)\nusing this:\n  ground t\n  gt_diff t s\n\ngoal (1 subgoal):\n 1. ground s", "using gt_iff_wt_unary_diff_same gt_imp_vars"], ["proof (prove)\nusing this:\n  ground t\n  gt_diff t s\n  (?t >\\<^sub>t ?s) =\n  (gt_wt ?t ?s \\<or> gt_unary ?t ?s \\<or> gt_diff ?t ?s \\<or> gt_same ?t ?s)\n  ?t >\\<^sub>t ?s \\<Longrightarrow> vars ?s \\<subseteq> vars ?t\n\ngoal (1 subgoal):\n 1. ground s", "by fastforce"], ["proof (state)\nthis:\n  ground s\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ground b; wt b =\\<^sub>p wt a; gt_diff b a\\<rbrakk>\n       \\<Longrightarrow> hd.sym (head b) >\\<^sub>s hd.sym (head a)", "show \"sym (head t) >\\<^sub>s sym (head s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hd.sym (head t) >\\<^sub>s hd.sym (head s)", "using gt_diff_t_s"], ["proof (prove)\nusing this:\n  gt_diff t s\n\ngoal (1 subgoal):\n 1. hd.sym (head t) >\\<^sub>s hd.sym (head s)", "by cases (simp add: gt_hd_def gr_s gr_t ground_hd_in_ground_heads)"], ["proof (state)\nthis:\n  hd.sym (head t) >\\<^sub>s hd.sym (head s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  {(s, t). ground t \\<and> wt t =\\<^sub>p wt s \\<and> gt_diff t s}\n  \\<subseteq> {(s, t).\n               ground s \\<and>\n               ground t \\<and>\n               wt t =\\<^sub>p wt s \\<and>\n               hd.sym (head t) >\\<^sub>s hd.sym (head s)}\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  wf {(s, t).\n      ground s \\<and>\n      ground t \\<and>\n      wt t =\\<^sub>p wt s \\<and> hd.sym (head t) >\\<^sub>s hd.sym (head s)}\n  {(s, t). ground t \\<and> wt t =\\<^sub>p wt s \\<and> gt_diff t s}\n  \\<subseteq> {(s, t).\n               ground s \\<and>\n               ground t \\<and>\n               wt t =\\<^sub>p wt s \\<and>\n               hd.sym (head t) >\\<^sub>s hd.sym (head s)}", "have wf_diff: \"wf {(s, t). ground t \\<and> wt t =\\<^sub>p wt s \\<and> gt_diff t s}\""], ["proof (prove)\nusing this:\n  wf {(s, t).\n      ground s \\<and>\n      ground t \\<and>\n      wt t =\\<^sub>p wt s \\<and> hd.sym (head t) >\\<^sub>s hd.sym (head s)}\n  {(s, t). ground t \\<and> wt t =\\<^sub>p wt s \\<and> gt_diff t s}\n  \\<subseteq> {(s, t).\n               ground s \\<and>\n               ground t \\<and>\n               wt t =\\<^sub>p wt s \\<and>\n               hd.sym (head t) >\\<^sub>s hd.sym (head s)}\n\ngoal (1 subgoal):\n 1. wf {(s, t). ground t \\<and> wt t =\\<^sub>p wt s \\<and> gt_diff t s}", "by (rule wf_subset)"], ["proof (state)\nthis:\n  wf {(s, t). ground t \\<and> wt t =\\<^sub>p wt s \\<and> gt_diff t s}\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "have diff_O_same:\n      \"{(s, t). ground t \\<and> wt t =\\<^sub>p wt s \\<and> gt_diff t s}\n         O {(s, t). ground t \\<and> wt t =\\<^sub>p wt s \\<and> gt_same t s}\n       \\<subseteq> {(s, t). ground t \\<and> wt t =\\<^sub>p wt s \\<and> gt_diff t s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(s, t). ground t \\<and> wt t =\\<^sub>p wt s \\<and> gt_diff t s} O\n    {(s, t). ground t \\<and> wt t =\\<^sub>p wt s \\<and> gt_same t s}\n    \\<subseteq> {(s, t).\n                 ground t \\<and> wt t =\\<^sub>p wt s \\<and> gt_diff t s}", "unfolding gt_diff.simps gt_same.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(s, t).\n     ground t \\<and>\n     wt t =\\<^sub>p wt s \\<and>\n     (\\<exists>ta sa.\n         t = ta \\<and>\n         s = sa \\<and>\n         wt ta \\<ge>\\<^sub>p wt sa \\<and>\n         head ta >\\<^sub>h\\<^sub>d head sa)} O\n    {(s, t).\n     ground t \\<and>\n     wt t =\\<^sub>p wt s \\<and>\n     (\\<exists>ta sa.\n         t = ta \\<and>\n         s = sa \\<and>\n         wt ta \\<ge>\\<^sub>p wt sa \\<and>\n         head ta = head sa \\<and>\n         (\\<forall>f\\<in>local.ground_heads (head ta).\n             extf f (>\\<^sub>t) (args ta) (args sa)))}\n    \\<subseteq> {(s, t).\n                 ground t \\<and>\n                 wt t =\\<^sub>p wt s \\<and>\n                 (\\<exists>ta sa.\n                     t = ta \\<and>\n                     s = sa \\<and>\n                     wt ta \\<ge>\\<^sub>p wt sa \\<and>\n                     head ta >\\<^sub>h\\<^sub>d head sa)}", "by (auto intro: ge_ge_tpoly_trans simp: eq_tpoly_def)"], ["proof (state)\nthis:\n  {(s, t). ground t \\<and> wt t =\\<^sub>p wt s \\<and> gt_diff t s} O\n  {(s, t). ground t \\<and> wt t =\\<^sub>p wt s \\<and> gt_same t s}\n  \\<subseteq> {(s, t).\n               ground t \\<and> wt t =\\<^sub>p wt s \\<and> gt_diff t s}\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "have diff_same_as_union:\n      \"{(s, t). ground t \\<and> wt t =\\<^sub>p wt s \\<and> (gt_diff t s \\<or> gt_same t s)} =\n       {(s, t). ground t \\<and> wt t =\\<^sub>p wt s \\<and> gt_diff t s}\n       \\<union> {(s, t). ground t \\<and> wt t =\\<^sub>p wt s \\<and> gt_same t s}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {(s, t).\n     ground t \\<and>\n     wt t =\\<^sub>p wt s \\<and> (gt_diff t s \\<or> gt_same t s)} =\n    {(s, t).\n     ground t \\<and> wt t =\\<^sub>p wt s \\<and> gt_diff t s} \\<union>\n    {(s, t). ground t \\<and> wt t =\\<^sub>p wt s \\<and> gt_same t s}", "by auto"], ["proof (state)\nthis:\n  {(s, t).\n   ground t \\<and>\n   wt t =\\<^sub>p wt s \\<and> (gt_diff t s \\<or> gt_same t s)} =\n  {(s, t). ground t \\<and> wt t =\\<^sub>p wt s \\<and> gt_diff t s} \\<union>\n  {(s, t). ground t \\<and> wt t =\\<^sub>p wt s \\<and> gt_same t s}\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "obtain k2 where\n      bad_same: \"inf_chain (\\<lambda>t s. ground t \\<and> wt t =\\<^sub>p wt s \\<and> gt_same t s) (\\<lambda>i. ?ff (i + k2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k2.\n        inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> wt t =\\<^sub>p wt s \\<and> gt_same t s)\n         (\\<lambda>i.\n             worst_chain\n              (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n              (\\<lambda>t s. size s < size t) (i + k2)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using wf_infinite_down_chain_compatible[OF wf_diff _ diff_O_same, of \"\\<lambda>i. ?ff (i + k1)\"]\n        bad_diff_same"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (Suc i + k1),\n      worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (i + k1))\n     \\<in> {(s, t).\n            ground t \\<and> wt t =\\<^sub>p wt s \\<and> gt_diff t s} \\<union>\n           {(s, t).\n            ground t \\<and>\n            wt t =\\<^sub>p wt s \\<and> gt_same t s} \\<Longrightarrow>\n  \\<exists>k.\n     \\<forall>i.\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n          (\\<lambda>t s. size s < size t) (Suc (i + k) + k1),\n         worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n          (\\<lambda>t s. size s < size t) (i + k + k1))\n        \\<in> {(s, t).\n               ground t \\<and> wt t =\\<^sub>p wt s \\<and> gt_same t s}\n  inf_chain\n   (\\<lambda>t s.\n       ground t \\<and>\n       wt t =\\<^sub>p wt s \\<and> (gt_diff t s \\<or> gt_same t s))\n   (\\<lambda>i.\n       worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n        (\\<lambda>t s. size s < size t) (i + k1))\n\ngoal (1 subgoal):\n 1. (\\<And>k2.\n        inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> wt t =\\<^sub>p wt s \\<and> gt_same t s)\n         (\\<lambda>i.\n             worst_chain\n              (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n              (\\<lambda>t s. size s < size t) (i + k2)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "unfolding inf_chain_def diff_same_as_union[symmetric]"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (Suc i + k1),\n      worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (i + k1))\n     \\<in> {(s, t).\n            ground t \\<and>\n            wt t =\\<^sub>p wt s \\<and>\n            (gt_diff t s \\<or> gt_same t s)} \\<Longrightarrow>\n  \\<exists>k.\n     \\<forall>i.\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n          (\\<lambda>t s. size s < size t) (Suc (i + k) + k1),\n         worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n          (\\<lambda>t s. size s < size t) (i + k + k1))\n        \\<in> {(s, t).\n               ground t \\<and> wt t =\\<^sub>p wt s \\<and> gt_same t s}\n  \\<forall>i.\n     ground\n      (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n        (\\<lambda>t s. size s < size t) (i + k1)) \\<and>\n     wt (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n          (\\<lambda>t s. size s < size t) (i + k1)) =\\<^sub>p\n     wt (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n          (\\<lambda>t s. size s < size t) (Suc i + k1)) \\<and>\n     (gt_diff\n       (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n         (\\<lambda>t s. size s < size t) (i + k1))\n       (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n         (\\<lambda>t s. size s < size t) (Suc i + k1)) \\<or>\n      gt_same\n       (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n         (\\<lambda>t s. size s < size t) (i + k1))\n       (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n         (\\<lambda>t s. size s < size t) (Suc i + k1)))\n\ngoal (1 subgoal):\n 1. (\\<And>k2.\n        \\<forall>i.\n           ground\n            (worst_chain\n              (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n              (\\<lambda>t s. size s < size t) (i + k2)) \\<and>\n           wt (worst_chain\n                (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n                (\\<lambda>t s. size s < size t) (i + k2)) =\\<^sub>p\n           wt (worst_chain\n                (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n                (\\<lambda>t s. size s < size t) (Suc i + k2)) \\<and>\n           gt_same\n            (worst_chain\n              (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n              (\\<lambda>t s. size s < size t) (i + k2))\n            (worst_chain\n              (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n              (\\<lambda>t s. size s < size t)\n              (Suc i + k2)) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto simp: add.assoc)"], ["proof (state)\nthis:\n  inf_chain\n   (\\<lambda>t s. ground t \\<and> wt t =\\<^sub>p wt s \\<and> gt_same t s)\n   (\\<lambda>i.\n       worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n        (\\<lambda>t s. size s < size t) (i + k2))\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "hence hd_sym: \"\\<And>i. is_Sym (head (?ff (i + k2)))\""], ["proof (prove)\nusing this:\n  inf_chain\n   (\\<lambda>t s. ground t \\<and> wt t =\\<^sub>p wt s \\<and> gt_same t s)\n   (\\<lambda>i.\n       worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n        (\\<lambda>t s. size s < size t) (i + k2))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       is_Sym\n        (head\n          (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n            (\\<lambda>t s. size s < size t) (i + k2)))", "unfolding inf_chain_def"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     ground\n      (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n        (\\<lambda>t s. size s < size t) (i + k2)) \\<and>\n     wt (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n          (\\<lambda>t s. size s < size t) (i + k2)) =\\<^sub>p\n     wt (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n          (\\<lambda>t s. size s < size t) (Suc i + k2)) \\<and>\n     gt_same\n      (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n        (\\<lambda>t s. size s < size t) (i + k2))\n      (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n        (\\<lambda>t s. size s < size t) (Suc i + k2))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       is_Sym\n        (head\n          (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n            (\\<lambda>t s. size s < size t) (i + k2)))", "by (simp add: ground_head)"], ["proof (state)\nthis:\n  is_Sym\n   (head\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (?i + k2)))\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "define f where \"f = sym (head (?ff k2))\""], ["proof (state)\nthis:\n  f =\n  hd.sym\n   (head\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) k2))\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "define w where \"w = eval_tpoly ?A (wt (?ff k2))\""], ["proof (state)\nthis:\n  w =\n  eval_tpoly min_passign\n   (wt (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n         (\\<lambda>t s. size s < size t) k2))\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "have \"head (?ff (i + k2)) = Sym f \\<and> eval_tpoly ?A (wt (?ff (i + k2))) = w\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. head\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (i + k2)) =\n    Sym f \\<and>\n    eval_tpoly min_passign\n     (wt (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n           (\\<lambda>t s. size s < size t) (i + k2))) =\n    w", "proof (induct i)"], ["proof (state)\ngoal (2 subgoals):\n 1. head\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (0 + k2)) =\n    Sym f \\<and>\n    eval_tpoly min_passign\n     (wt (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n           (\\<lambda>t s. size s < size t) (0 + k2))) =\n    w\n 2. \\<And>i.\n       head\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n          (\\<lambda>t s. size s < size t) (i + k2)) =\n       Sym f \\<and>\n       eval_tpoly min_passign\n        (wt (worst_chain\n              (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n              (\\<lambda>t s. size s < size t) (i + k2))) =\n       w \\<Longrightarrow>\n       head\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n          (\\<lambda>t s. size s < size t) (Suc i + k2)) =\n       Sym f \\<and>\n       eval_tpoly min_passign\n        (wt (worst_chain\n              (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n              (\\<lambda>t s. size s < size t) (Suc i + k2))) =\n       w", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. head\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (0 + k2)) =\n    Sym f \\<and>\n    eval_tpoly min_passign\n     (wt (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n           (\\<lambda>t s. size s < size t) (0 + k2))) =\n    w\n 2. \\<And>i.\n       head\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n          (\\<lambda>t s. size s < size t) (i + k2)) =\n       Sym f \\<and>\n       eval_tpoly min_passign\n        (wt (worst_chain\n              (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n              (\\<lambda>t s. size s < size t) (i + k2))) =\n       w \\<Longrightarrow>\n       head\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n          (\\<lambda>t s. size s < size t) (Suc i + k2)) =\n       Sym f \\<and>\n       eval_tpoly min_passign\n        (wt (worst_chain\n              (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n              (\\<lambda>t s. size s < size t) (Suc i + k2))) =\n       w", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. head\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (0 + k2)) =\n    Sym f \\<and>\n    eval_tpoly min_passign\n     (wt (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n           (\\<lambda>t s. size s < size t) (0 + k2))) =\n    w", "by (auto simp: f_def w_def hd.collapse(2)[OF hd_sym, of 0, simplified])"], ["proof (state)\nthis:\n  head\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n     (\\<lambda>t s. size s < size t) (0 + k2)) =\n  Sym f \\<and>\n  eval_tpoly min_passign\n   (wt (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n         (\\<lambda>t s. size s < size t) (0 + k2))) =\n  w\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       head\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n          (\\<lambda>t s. size s < size t) (i + k2)) =\n       Sym f \\<and>\n       eval_tpoly min_passign\n        (wt (worst_chain\n              (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n              (\\<lambda>t s. size s < size t) (i + k2))) =\n       w \\<Longrightarrow>\n       head\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n          (\\<lambda>t s. size s < size t) (Suc i + k2)) =\n       Sym f \\<and>\n       eval_tpoly min_passign\n        (wt (worst_chain\n              (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n              (\\<lambda>t s. size s < size t) (Suc i + k2))) =\n       w", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       head\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n          (\\<lambda>t s. size s < size t) (i + k2)) =\n       Sym f \\<and>\n       eval_tpoly min_passign\n        (wt (worst_chain\n              (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n              (\\<lambda>t s. size s < size t) (i + k2))) =\n       w \\<Longrightarrow>\n       head\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n          (\\<lambda>t s. size s < size t) (Suc i + k2)) =\n       Sym f \\<and>\n       eval_tpoly min_passign\n        (wt (worst_chain\n              (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n              (\\<lambda>t s. size s < size t) (Suc i + k2))) =\n       w", "case (Suc ia)"], ["proof (state)\nthis:\n  head\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n     (\\<lambda>t s. size s < size t) (ia + k2)) =\n  Sym f \\<and>\n  eval_tpoly min_passign\n   (wt (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n         (\\<lambda>t s. size s < size t) (ia + k2))) =\n  w\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       head\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n          (\\<lambda>t s. size s < size t) (i + k2)) =\n       Sym f \\<and>\n       eval_tpoly min_passign\n        (wt (worst_chain\n              (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n              (\\<lambda>t s. size s < size t) (i + k2))) =\n       w \\<Longrightarrow>\n       head\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n          (\\<lambda>t s. size s < size t) (Suc i + k2)) =\n       Sym f \\<and>\n       eval_tpoly min_passign\n        (wt (worst_chain\n              (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n              (\\<lambda>t s. size s < size t) (Suc i + k2))) =\n       w", "thus ?case"], ["proof (prove)\nusing this:\n  head\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n     (\\<lambda>t s. size s < size t) (ia + k2)) =\n  Sym f \\<and>\n  eval_tpoly min_passign\n   (wt (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n         (\\<lambda>t s. size s < size t) (ia + k2))) =\n  w\n\ngoal (1 subgoal):\n 1. head\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (Suc ia + k2)) =\n    Sym f \\<and>\n    eval_tpoly min_passign\n     (wt (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n           (\\<lambda>t s. size s < size t) (Suc ia + k2))) =\n    w", "using bad_same"], ["proof (prove)\nusing this:\n  head\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n     (\\<lambda>t s. size s < size t) (ia + k2)) =\n  Sym f \\<and>\n  eval_tpoly min_passign\n   (wt (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n         (\\<lambda>t s. size s < size t) (ia + k2))) =\n  w\n  inf_chain\n   (\\<lambda>t s. ground t \\<and> wt t =\\<^sub>p wt s \\<and> gt_same t s)\n   (\\<lambda>i.\n       worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n        (\\<lambda>t s. size s < size t) (i + k2))\n\ngoal (1 subgoal):\n 1. head\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (Suc ia + k2)) =\n    Sym f \\<and>\n    eval_tpoly min_passign\n     (wt (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n           (\\<lambda>t s. size s < size t) (Suc ia + k2))) =\n    w", "unfolding inf_chain_def gt_same.simps zhmset_of_inject[symmetric]"], ["proof (prove)\nusing this:\n  head\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n     (\\<lambda>t s. size s < size t) (ia + k2)) =\n  Sym f \\<and>\n  zhmset_of\n   (eval_tpoly min_passign\n     (wt (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n           (\\<lambda>t s. size s < size t) (ia + k2)))) =\n  zhmset_of w\n  \\<forall>i.\n     ground\n      (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n        (\\<lambda>t s. size s < size t) (i + k2)) \\<and>\n     wt (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n          (\\<lambda>t s. size s < size t) (i + k2)) =\\<^sub>p\n     wt (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n          (\\<lambda>t s. size s < size t) (Suc i + k2)) \\<and>\n     (\\<exists>t s.\n         worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n          (\\<lambda>t s. size s < size t) (i + k2) =\n         t \\<and>\n         worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n          (\\<lambda>t s. size s < size t) (Suc i + k2) =\n         s \\<and>\n         wt t \\<ge>\\<^sub>p wt s \\<and>\n         head t = head s \\<and>\n         (\\<forall>f\\<in>local.ground_heads (head t).\n             extf f (>\\<^sub>t) (args t) (args s)))\n\ngoal (1 subgoal):\n 1. head\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (Suc ia + k2)) =\n    Sym f \\<and>\n    zhmset_of\n     (eval_tpoly min_passign\n       (wt (worst_chain\n             (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n             (\\<lambda>t s. size s < size t) (Suc ia + k2)))) =\n    zhmset_of w", "by (simp add: eq_tpoly_def legal_min_zpassign)"], ["proof (state)\nthis:\n  head\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n     (\\<lambda>t s. size s < size t) (Suc ia + k2)) =\n  Sym f \\<and>\n  eval_tpoly min_passign\n   (wt (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n         (\\<lambda>t s. size s < size t) (Suc ia + k2))) =\n  w\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  head\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n     (\\<lambda>t s. size s < size t) (?i + k2)) =\n  Sym f \\<and>\n  eval_tpoly min_passign\n   (wt (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n         (\\<lambda>t s. size s < size t) (?i + k2))) =\n  w\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "note hd_eq_f = this[THEN conjunct1] and wt_eq_w = this[THEN conjunct2]"], ["proof (state)\nthis:\n  head\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n     (\\<lambda>t s. size s < size t) (?i1 + k2)) =\n  Sym f\n  eval_tpoly min_passign\n   (wt (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n         (\\<lambda>t s. size s < size t) (?i1 + k2))) =\n  w\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "define max_args where\n      \"max_args = (if \\<delta>\\<^sub>h = 0 then sum_coefs w else the_enat (arity_sym f))\""], ["proof (state)\nthis:\n  max_args =\n  (if \\<delta>\\<^sub>h = 0 then sum_coefs w else the_enat (arity_sym f))\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "have nargs_le_max_args: \"num_args (?ff (i + k2)) \\<le> max_args\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. num_args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (i + k2))\n    \\<le> max_args", "proof (cases \"\\<delta>\\<^sub>h = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<delta>\\<^sub>h = 0 \\<Longrightarrow>\n    num_args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (i + k2))\n    \\<le> max_args\n 2. \\<delta>\\<^sub>h \\<noteq> 0 \\<Longrightarrow>\n    num_args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (i + k2))\n    \\<le> max_args", "case \\<delta>_ne_0: False"], ["proof (state)\nthis:\n  \\<delta>\\<^sub>h \\<noteq> 0\n\ngoal (2 subgoals):\n 1. \\<delta>\\<^sub>h = 0 \\<Longrightarrow>\n    num_args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (i + k2))\n    \\<le> max_args\n 2. \\<delta>\\<^sub>h \\<noteq> 0 \\<Longrightarrow>\n    num_args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (i + k2))\n    \\<le> max_args", "hence ary_f_ne_inf: \"arity_sym f \\<noteq> \\<infinity>\""], ["proof (prove)\nusing this:\n  \\<delta>\\<^sub>h \\<noteq> 0\n\ngoal (1 subgoal):\n 1. arity_sym f \\<noteq> \\<infinity>", "using arity_sym_ne_infinity_if_\\<delta>_gt_0 of_nat_0"], ["proof (prove)\nusing this:\n  \\<delta>\\<^sub>h \\<noteq> 0\n  0 < \\<delta> \\<Longrightarrow> arity_sym ?f \\<noteq> \\<infinity>\n  of_nat 0 = (0::?'a)\n\ngoal (1 subgoal):\n 1. arity_sym f \\<noteq> \\<infinity>", "by blast"], ["proof (state)\nthis:\n  arity_sym f \\<noteq> \\<infinity>\n\ngoal (2 subgoals):\n 1. \\<delta>\\<^sub>h = 0 \\<Longrightarrow>\n    num_args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (i + k2))\n    \\<le> max_args\n 2. \\<delta>\\<^sub>h \\<noteq> 0 \\<Longrightarrow>\n    num_args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (i + k2))\n    \\<le> max_args", "have \"enat (num_args (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s) (\\<lambda>t s. size s < size t) (i + k2))) \\<le> arity_sym f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. enat\n     (num_args\n       (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n         (\\<lambda>t s. size s < size t) (i + k2)))\n    \\<le> arity_sym f", "using wary_num_args_le_arity_head[OF ffi_wary[of \"i + k2\"]]"], ["proof (prove)\nusing this:\n  enat\n   (num_args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (i + k2)))\n  \\<le> arity_hd\n         (head\n           (worst_chain\n             (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n             (\\<lambda>t s. size s < size t) (i + k2)))\n\ngoal (1 subgoal):\n 1. enat\n     (num_args\n       (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n         (\\<lambda>t s. size s < size t) (i + k2)))\n    \\<le> arity_sym f", "by (simp add: hd_eq_f)"], ["proof (state)\nthis:\n  enat\n   (num_args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (i + k2)))\n  \\<le> arity_sym f\n\ngoal (2 subgoals):\n 1. \\<delta>\\<^sub>h = 0 \\<Longrightarrow>\n    num_args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (i + k2))\n    \\<le> max_args\n 2. \\<delta>\\<^sub>h \\<noteq> 0 \\<Longrightarrow>\n    num_args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (i + k2))\n    \\<le> max_args", "with \\<delta>_ne_0"], ["proof (chain)\npicking this:\n  \\<delta>\\<^sub>h \\<noteq> 0\n  enat\n   (num_args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (i + k2)))\n  \\<le> arity_sym f", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<delta>\\<^sub>h \\<noteq> 0\n  enat\n   (num_args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (i + k2)))\n  \\<le> arity_sym f\n\ngoal (1 subgoal):\n 1. num_args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (i + k2))\n    \\<le> max_args", "by (simp del: enat_ord_simps add: max_args_def  enat_ord_simps(1)[symmetric] enat_the_enat_iden[OF ary_f_ne_inf])"], ["proof (state)\nthis:\n  num_args\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n     (\\<lambda>t s. size s < size t) (i + k2))\n  \\<le> max_args\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>h = 0 \\<Longrightarrow>\n    num_args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (i + k2))\n    \\<le> max_args", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>h = 0 \\<Longrightarrow>\n    num_args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (i + k2))\n    \\<le> max_args", "case \\<delta>_eq_0: True"], ["proof (state)\nthis:\n  \\<delta>\\<^sub>h = 0\n\ngoal (1 subgoal):\n 1. \\<delta>\\<^sub>h = 0 \\<Longrightarrow>\n    num_args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (i + k2))\n    \\<le> max_args", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. num_args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (i + k2))\n    \\<le> max_args", "using sum_coefs_ge_num_args_if_\\<delta>\\<^sub>h_eq_0[OF legal_min_passign \\<delta>_eq_0 ffi_wary[of \"i + k2\"]]"], ["proof (prove)\nusing this:\n  num_args\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n     (\\<lambda>t s. size s < size t) (i + k2))\n  \\<le> sum_coefs\n         (eval_tpoly min_passign\n           (wt (worst_chain\n                 (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n                 (\\<lambda>t s. size s < size t) (i + k2))))\n\ngoal (1 subgoal):\n 1. num_args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (i + k2))\n    \\<le> max_args", "by (simp add: max_args_def \\<delta>_eq_0 wt_eq_w)"], ["proof (state)\nthis:\n  num_args\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n     (\\<lambda>t s. size s < size t) (i + k2))\n  \\<le> max_args\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  num_args\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n     (\\<lambda>t s. size s < size t) (?i + k2))\n  \\<le> max_args\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "let ?U_of = \"\\<lambda>i. set (args (?ff (i + k2)))\""], ["proof (state)\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "define U where \"U = (\\<Union>i. ?U_of i)\""], ["proof (state)\nthis:\n  U =\n  (\\<Union>i.\n      set (args\n            (worst_chain\n              (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n              (\\<lambda>t s. size s < size t) (i + k2))))\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "have gr_u: \"\\<And>u. u \\<in> U \\<Longrightarrow> ground u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u. u \\<in> U \\<Longrightarrow> ground u", "unfolding U_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> (\\<Union>i.\n                   set (args\n                         (worst_chain\n                           (\\<lambda>t s.\n                               ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n                           (\\<lambda>t s. size s < size t)\n                           (i + k2)))) \\<Longrightarrow>\n       ground u", "by (blast dest: ground_args[OF _ ffi_ground])"], ["proof (state)\nthis:\n  ?u \\<in> U \\<Longrightarrow> ground ?u\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "have wary_u: \"\\<And>u. u \\<in> U \\<Longrightarrow> wary u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u. u \\<in> U \\<Longrightarrow> wary u", "unfolding U_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> (\\<Union>i.\n                   set (args\n                         (worst_chain\n                           (\\<lambda>t s.\n                               ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n                           (\\<lambda>t s. size s < size t)\n                           (i + k2)))) \\<Longrightarrow>\n       wary u", "by (blast dest: wary_args[OF _ ffi_wary])"], ["proof (state)\nthis:\n  ?u \\<in> U \\<Longrightarrow> wary ?u\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "have \"\\<not> bad (>\\<^sub>t\\<^sub>w\\<^sub>g) u\" if u_in: \"u \\<in> ?U_of i\" for u i"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> bad (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s) u", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. bad (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n     u \\<Longrightarrow>\n    False", "assume u_bad: \"bad (>\\<^sub>t\\<^sub>w\\<^sub>g) u\""], ["proof (state)\nthis:\n  bad (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s) u\n\ngoal (1 subgoal):\n 1. bad (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n     u \\<Longrightarrow>\n    False", "have sz_u: \"size u < size (?ff (i + k2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. size u\n    < size\n       (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n         (\\<lambda>t s. size s < size t) (i + k2))", "by (rule size_in_args[OF u_in])"], ["proof (state)\nthis:\n  size u\n  < size\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (i + k2))\n\ngoal (1 subgoal):\n 1. bad (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n     u \\<Longrightarrow>\n    False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof (cases \"i + k2\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i + k2 = 0 \\<Longrightarrow> False\n 2. \\<And>nat. i + k2 = Suc nat \\<Longrightarrow> False", "case 0"], ["proof (state)\nthis:\n  i + k2 = 0\n\ngoal (2 subgoals):\n 1. i + k2 = 0 \\<Longrightarrow> False\n 2. \\<And>nat. i + k2 = Suc nat \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  i + k2 = 0\n\ngoal (1 subgoal):\n 1. False", "using sz_u min_worst_chain_0[OF wf_sz u_bad]"], ["proof (prove)\nusing this:\n  i + k2 = 0\n  size u\n  < size\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (i + k2))\n  \\<not> size u\n         < size\n            (worst_chain\n              (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n              (\\<lambda>y x. size x < size y) 0)\n\ngoal (1 subgoal):\n 1. False", "by simp"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<And>nat. i + k2 = Suc nat \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>nat. i + k2 = Suc nat \\<Longrightarrow> False", "case Suc"], ["proof (state)\nthis:\n  i + k2 = Suc nat_\n\ngoal (1 subgoal):\n 1. \\<And>nat. i + k2 = Suc nat \\<Longrightarrow> False", "hence gt: \"?ff (i + k2 - 1) >\\<^sub>t\\<^sub>w ?ff (i + k2)\""], ["proof (prove)\nusing this:\n  i + k2 = Suc nat_\n\ngoal (1 subgoal):\n 1. worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n     (\\<lambda>t s. size s < size t) (i + k2 - 1) >\\<^sub>t\\<^sub>w\n    worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n     (\\<lambda>t s. size s < size t) (i + k2)", "using worst_chain_pred[OF wf_sz t_bad]"], ["proof (prove)\nusing this:\n  i + k2 = Suc nat_\n  ground\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n     (\\<lambda>y x. size x < size y) ?i) \\<and>\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n   (\\<lambda>y x. size x < size y) ?i >\\<^sub>t\\<^sub>w\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n   (\\<lambda>y x. size x < size y) (Suc ?i)\n\ngoal (1 subgoal):\n 1. worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n     (\\<lambda>t s. size s < size t) (i + k2 - 1) >\\<^sub>t\\<^sub>w\n    worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n     (\\<lambda>t s. size s < size t) (i + k2)", "by auto"], ["proof (state)\nthis:\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n   (\\<lambda>t s. size s < size t) (i + k2 - 1) >\\<^sub>t\\<^sub>w\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n   (\\<lambda>t s. size s < size t) (i + k2)\n\ngoal (1 subgoal):\n 1. \\<And>nat. i + k2 = Suc nat \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n   (\\<lambda>t s. size s < size t) (i + k2 - 1) >\\<^sub>t\\<^sub>w\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n   (\\<lambda>t s. size s < size t) (i + k2)\n\ngoal (1 subgoal):\n 1. \\<And>nat. i + k2 = Suc nat \\<Longrightarrow> False", "have \"?ff (i + k2) >\\<^sub>t\\<^sub>w u\""], ["proof (prove)\ngoal (1 subgoal):\n 1. worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n     (\\<lambda>t s. size s < size t) (i + k2) >\\<^sub>t\\<^sub>w\n    u", "using gt gt_proper_sub sub_args sz_u u_in wary_args"], ["proof (prove)\nusing this:\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n   (\\<lambda>t s. size s < size t) (i + k2 - 1) >\\<^sub>t\\<^sub>w\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n   (\\<lambda>t s. size s < size t) (i + k2)\n  \\<lbrakk>wary ?t; proper_sub ?s ?t\\<rbrakk>\n  \\<Longrightarrow> ?t >\\<^sub>t ?s\n  ?s \\<in> set (args ?t) \\<Longrightarrow> sub ?s ?t\n  size u\n  < size\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (i + k2))\n  u \\<in> set (args\n                (worst_chain\n                  (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n                  (\\<lambda>t s. size s < size t) (i + k2)))\n  \\<lbrakk>?s \\<in> set (args ?t); wary ?t\\<rbrakk>\n  \\<Longrightarrow> wary ?s\n\ngoal (1 subgoal):\n 1. worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n     (\\<lambda>t s. size s < size t) (i + k2) >\\<^sub>t\\<^sub>w\n    u", "by auto"], ["proof (state)\nthis:\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n   (\\<lambda>t s. size s < size t) (i + k2) >\\<^sub>t\\<^sub>w\n  u\n\ngoal (1 subgoal):\n 1. \\<And>nat. i + k2 = Suc nat \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n   (\\<lambda>t s. size s < size t) (i + k2 - 1) >\\<^sub>t\\<^sub>w\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n   (\\<lambda>t s. size s < size t) (i + k2)\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n   (\\<lambda>t s. size s < size t) (i + k2) >\\<^sub>t\\<^sub>w\n  u", "have \"?ff (i + k2 - 1) >\\<^sub>t\\<^sub>w u\""], ["proof (prove)\nusing this:\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n   (\\<lambda>t s. size s < size t) (i + k2 - 1) >\\<^sub>t\\<^sub>w\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n   (\\<lambda>t s. size s < size t) (i + k2)\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n   (\\<lambda>t s. size s < size t) (i + k2) >\\<^sub>t\\<^sub>w\n  u\n\ngoal (1 subgoal):\n 1. worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n     (\\<lambda>t s. size s < size t) (i + k2 - 1) >\\<^sub>t\\<^sub>w\n    u", "using gt_trans"], ["proof (prove)\nusing this:\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n   (\\<lambda>t s. size s < size t) (i + k2 - 1) >\\<^sub>t\\<^sub>w\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n   (\\<lambda>t s. size s < size t) (i + k2)\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n   (\\<lambda>t s. size s < size t) (i + k2) >\\<^sub>t\\<^sub>w\n  u\n  \\<lbrakk>wary ?u; wary ?t; wary ?s; ?u >\\<^sub>t ?t;\n   ?t >\\<^sub>t ?s\\<rbrakk>\n  \\<Longrightarrow> ?u >\\<^sub>t ?s\n\ngoal (1 subgoal):\n 1. worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n     (\\<lambda>t s. size s < size t) (i + k2 - 1) >\\<^sub>t\\<^sub>w\n    u", "by blast"], ["proof (state)\nthis:\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n   (\\<lambda>t s. size s < size t) (i + k2 - 1) >\\<^sub>t\\<^sub>w\n  u\n\ngoal (1 subgoal):\n 1. \\<And>nat. i + k2 = Suc nat \\<Longrightarrow> False", "thus False"], ["proof (prove)\nusing this:\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n   (\\<lambda>t s. size s < size t) (i + k2 - 1) >\\<^sub>t\\<^sub>w\n  u\n\ngoal (1 subgoal):\n 1. False", "using Suc sz_u min_worst_chain_Suc[OF wf_sz u_bad] ffi_ground"], ["proof (prove)\nusing this:\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n   (\\<lambda>t s. size s < size t) (i + k2 - 1) >\\<^sub>t\\<^sub>w\n  u\n  i + k2 = Suc nat_\n  size u\n  < size\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (i + k2))\n  ground\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n     (\\<lambda>y x. size x < size y) ?i) \\<and>\n  worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n   (\\<lambda>y x. size x < size y) ?i >\\<^sub>t\\<^sub>w\n  u \\<Longrightarrow>\n  \\<not> size u\n         < size\n            (worst_chain\n              (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n              (\\<lambda>y x. size x < size y) (Suc ?i))\n  ground\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n     (\\<lambda>t s. size s < size t) ?i)\n\ngoal (1 subgoal):\n 1. False", "by fastforce"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?u \\<in> set (args\n                 (worst_chain\n                   (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n                   (\\<lambda>t s. size s < size t)\n                   (?i + k2))) \\<Longrightarrow>\n  \\<not> bad (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s) ?u\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "hence u_good: \"\\<And>u. u \\<in> U \\<Longrightarrow> \\<not> bad (>\\<^sub>t\\<^sub>w\\<^sub>g) u\""], ["proof (prove)\nusing this:\n  ?u \\<in> set (args\n                 (worst_chain\n                   (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n                   (\\<lambda>t s. size s < size t)\n                   (?i + k2))) \\<Longrightarrow>\n  \\<not> bad (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s) ?u\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> U \\<Longrightarrow>\n       \\<not> bad (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s) u", "unfolding U_def"], ["proof (prove)\nusing this:\n  ?u \\<in> set (args\n                 (worst_chain\n                   (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n                   (\\<lambda>t s. size s < size t)\n                   (?i + k2))) \\<Longrightarrow>\n  \\<not> bad (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s) ?u\n\ngoal (1 subgoal):\n 1. \\<And>u.\n       u \\<in> (\\<Union>i.\n                   set (args\n                         (worst_chain\n                           (\\<lambda>t s.\n                               ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n                           (\\<lambda>t s. size s < size t)\n                           (i + k2)))) \\<Longrightarrow>\n       \\<not> bad (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s) u", "by blast"], ["proof (state)\nthis:\n  ?u \\<in> U \\<Longrightarrow>\n  \\<not> bad (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s) ?u\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "let ?gtwu = \"\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s\""], ["proof (state)\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "have gtwu_irrefl: \"\\<And>x. \\<not> ?gtwu x x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. \\<not> (x \\<in> U \\<and> x >\\<^sub>t\\<^sub>w x)", "using gt_irrefl"], ["proof (prove)\nusing this:\n  wary ?s \\<Longrightarrow> \\<not> ?s >\\<^sub>t ?s\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<not> (x \\<in> U \\<and> x >\\<^sub>t\\<^sub>w x)", "by auto"], ["proof (state)\nthis:\n  \\<not> (?x \\<in> U \\<and> ?x >\\<^sub>t\\<^sub>w ?x)\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "have \"\\<And>i j. \\<forall>t \\<in> set (args (?ff (i + k2))). \\<forall>s \\<in> set (args (?ff (j + k2))). t >\\<^sub>t s \\<longrightarrow>\n      t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<forall>t\\<in>set (args\n                            (worst_chain\n                              (\\<lambda>t s.\n                                  ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n                              (\\<lambda>t s. size s < size t) (i + k2))).\n          \\<forall>s\\<in>set (args\n                               (worst_chain\n                                 (\\<lambda>t s.\n                                     ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n                                 (\\<lambda>t s. size s < size t) (j + k2))).\n             t >\\<^sub>t s \\<longrightarrow>\n             t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s", "using wary_u"], ["proof (prove)\nusing this:\n  ?u \\<in> U \\<Longrightarrow> wary ?u\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<forall>t\\<in>set (args\n                            (worst_chain\n                              (\\<lambda>t s.\n                                  ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n                              (\\<lambda>t s. size s < size t) (i + k2))).\n          \\<forall>s\\<in>set (args\n                               (worst_chain\n                                 (\\<lambda>t s.\n                                     ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n                                 (\\<lambda>t s. size s < size t) (j + k2))).\n             t >\\<^sub>t s \\<longrightarrow>\n             t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s", "unfolding U_def"], ["proof (prove)\nusing this:\n  ?u \\<in> (\\<Union>i.\n               set (args\n                     (worst_chain\n                       (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n                       (\\<lambda>t s. size s < size t)\n                       (i + k2)))) \\<Longrightarrow>\n  wary ?u\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<forall>t\\<in>set (args\n                            (worst_chain\n                              (\\<lambda>t s.\n                                  ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n                              (\\<lambda>t s. size s < size t) (i + k2))).\n          \\<forall>s\\<in>set (args\n                               (worst_chain\n                                 (\\<lambda>t s.\n                                     ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n                                 (\\<lambda>t s. size s < size t) (j + k2))).\n             t >\\<^sub>t s \\<longrightarrow>\n             t \\<in> (\\<Union>i.\n                         set (args\n                               (worst_chain\n                                 (\\<lambda>t s.\n                                     ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n                                 (\\<lambda>t s. size s < size t)\n                                 (i + k2)))) \\<and>\n             t >\\<^sub>t\\<^sub>w s", "by blast"], ["proof (state)\nthis:\n  \\<forall>t\\<in>set (args\n                       (worst_chain\n                         (\\<lambda>t s.\n                             ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n                         (\\<lambda>t s. size s < size t) (?i + k2))).\n     \\<forall>s\\<in>set (args\n                          (worst_chain\n                            (\\<lambda>t s.\n                                ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n                            (\\<lambda>t s. size s < size t) (?j + k2))).\n        t >\\<^sub>t s \\<longrightarrow>\n        t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "moreover"], ["proof (state)\nthis:\n  \\<forall>t\\<in>set (args\n                       (worst_chain\n                         (\\<lambda>t s.\n                             ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n                         (\\<lambda>t s. size s < size t) (?i + k2))).\n     \\<forall>s\\<in>set (args\n                          (worst_chain\n                            (\\<lambda>t s.\n                                ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n                            (\\<lambda>t s. size s < size t) (?j + k2))).\n        t >\\<^sub>t s \\<longrightarrow>\n        t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "have \"\\<And>i. extf f (>\\<^sub>t) (args (?ff (i + k2))) (args (?ff (Suc i + k2)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       extf f (>\\<^sub>t)\n        (args\n          (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n            (\\<lambda>t s. size s < size t) (i + k2)))\n        (args\n          (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n            (\\<lambda>t s. size s < size t) (Suc i + k2)))", "using bad_same hd_eq_f"], ["proof (prove)\nusing this:\n  inf_chain\n   (\\<lambda>t s. ground t \\<and> wt t =\\<^sub>p wt s \\<and> gt_same t s)\n   (\\<lambda>i.\n       worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n        (\\<lambda>t s. size s < size t) (i + k2))\n  head\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n     (\\<lambda>t s. size s < size t) (?i1 + k2)) =\n  Sym f\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       extf f (>\\<^sub>t)\n        (args\n          (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n            (\\<lambda>t s. size s < size t) (i + k2)))\n        (args\n          (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n            (\\<lambda>t s. size s < size t) (Suc i + k2)))", "unfolding inf_chain_def gt_same.simps"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     ground\n      (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n        (\\<lambda>t s. size s < size t) (i + k2)) \\<and>\n     wt (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n          (\\<lambda>t s. size s < size t) (i + k2)) =\\<^sub>p\n     wt (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n          (\\<lambda>t s. size s < size t) (Suc i + k2)) \\<and>\n     (\\<exists>t s.\n         worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n          (\\<lambda>t s. size s < size t) (i + k2) =\n         t \\<and>\n         worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n          (\\<lambda>t s. size s < size t) (Suc i + k2) =\n         s \\<and>\n         wt t \\<ge>\\<^sub>p wt s \\<and>\n         head t = head s \\<and>\n         (\\<forall>f\\<in>local.ground_heads (head t).\n             extf f (>\\<^sub>t) (args t) (args s)))\n  head\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n     (\\<lambda>t s. size s < size t) (?i1 + k2)) =\n  Sym f\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       extf f (>\\<^sub>t)\n        (args\n          (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n            (\\<lambda>t s. size s < size t) (i + k2)))\n        (args\n          (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n            (\\<lambda>t s. size s < size t) (Suc i + k2)))", "by auto"], ["proof (state)\nthis:\n  extf f (>\\<^sub>t)\n   (args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (?i + k2)))\n   (args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (Suc ?i + k2)))\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "ultimately"], ["proof (chain)\npicking this:\n  \\<forall>t\\<in>set (args\n                       (worst_chain\n                         (\\<lambda>t s.\n                             ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n                         (\\<lambda>t s. size s < size t) (?i + k2))).\n     \\<forall>s\\<in>set (args\n                          (worst_chain\n                            (\\<lambda>t s.\n                                ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n                            (\\<lambda>t s. size s < size t) (?j + k2))).\n        t >\\<^sub>t s \\<longrightarrow>\n        t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s\n  extf f (>\\<^sub>t)\n   (args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (?i + k2)))\n   (args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (Suc ?i + k2)))", "have \"\\<And>i. extf f ?gtwu (args (?ff (i + k2))) (args (?ff (Suc i + k2)))\""], ["proof (prove)\nusing this:\n  \\<forall>t\\<in>set (args\n                       (worst_chain\n                         (\\<lambda>t s.\n                             ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n                         (\\<lambda>t s. size s < size t) (?i + k2))).\n     \\<forall>s\\<in>set (args\n                          (worst_chain\n                            (\\<lambda>t s.\n                                ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n                            (\\<lambda>t s. size s < size t) (?j + k2))).\n        t >\\<^sub>t s \\<longrightarrow>\n        t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s\n  extf f (>\\<^sub>t)\n   (args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (?i + k2)))\n   (args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (Suc ?i + k2)))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       extf f (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s)\n        (args\n          (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n            (\\<lambda>t s. size s < size t) (i + k2)))\n        (args\n          (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n            (\\<lambda>t s. size s < size t) (Suc i + k2)))", "by (rule extf_mono_strong)"], ["proof (state)\nthis:\n  extf f (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s)\n   (args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (?i + k2)))\n   (args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (Suc ?i + k2)))\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "hence \"inf_chain (extf f ?gtwu) (\\<lambda>i. args (?ff (i + k2)))\""], ["proof (prove)\nusing this:\n  extf f (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s)\n   (args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (?i + k2)))\n   (args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (Suc ?i + k2)))\n\ngoal (1 subgoal):\n 1. inf_chain\n     (extf f (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s))\n     (\\<lambda>i.\n         args\n          (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n            (\\<lambda>t s. size s < size t) (i + k2)))", "unfolding inf_chain_def"], ["proof (prove)\nusing this:\n  extf f (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s)\n   (args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (?i + k2)))\n   (args\n     (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n       (\\<lambda>t s. size s < size t) (Suc ?i + k2)))\n\ngoal (1 subgoal):\n 1. \\<forall>i.\n       extf f (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s)\n        (args\n          (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n            (\\<lambda>t s. size s < size t) (i + k2)))\n        (args\n          (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n            (\\<lambda>t s. size s < size t) (Suc i + k2)))", "by blast"], ["proof (state)\nthis:\n  inf_chain (extf f (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s))\n   (\\<lambda>i.\n       args\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n          (\\<lambda>t s. size s < size t) (i + k2)))\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "hence nwf_ext:\n      \"\\<not> wfP (\\<lambda>xs ys. length ys \\<le> max_args \\<and> length xs \\<le> max_args \\<and> extf f ?gtwu ys xs)\""], ["proof (prove)\nusing this:\n  inf_chain (extf f (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s))\n   (\\<lambda>i.\n       args\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n          (\\<lambda>t s. size s < size t) (i + k2)))\n\ngoal (1 subgoal):\n 1. \\<not> wfP (\\<lambda>xs ys.\n                   length ys \\<le> max_args \\<and>\n                   length xs \\<le> max_args \\<and>\n                   extf f\n                    (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s)\n                    ys xs)", "unfolding inf_chain_def wfP_def wf_iff_no_infinite_down_chain"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     extf f (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s)\n      (args\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n          (\\<lambda>t s. size s < size t) (i + k2)))\n      (args\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n          (\\<lambda>t s. size s < size t) (Suc i + k2)))\n\ngoal (1 subgoal):\n 1. \\<not> (\\<nexists>fa.\n               \\<forall>i.\n                  (fa (Suc i), fa i)\n                  \\<in> {(xs, ys).\n                         length ys \\<le> max_args \\<and>\n                         length xs \\<le> max_args \\<and>\n                         extf f\n                          (\\<lambda>t s.\n                              t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s)\n                          ys xs})", "using nargs_le_max_args"], ["proof (prove)\nusing this:\n  \\<forall>i.\n     extf f (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s)\n      (args\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n          (\\<lambda>t s. size s < size t) (i + k2)))\n      (args\n        (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n          (\\<lambda>t s. size s < size t) (Suc i + k2)))\n  num_args\n   (worst_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n     (\\<lambda>t s. size s < size t) (?i + k2))\n  \\<le> max_args\n\ngoal (1 subgoal):\n 1. \\<not> (\\<nexists>fa.\n               \\<forall>i.\n                  (fa (Suc i), fa i)\n                  \\<in> {(xs, ys).\n                         length ys \\<le> max_args \\<and>\n                         length xs \\<le> max_args \\<and>\n                         extf f\n                          (\\<lambda>t s.\n                              t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s)\n                          ys xs})", "by fast"], ["proof (state)\nthis:\n  \\<not> wfP (\\<lambda>xs ys.\n                 length ys \\<le> max_args \\<and>\n                 length xs \\<le> max_args \\<and>\n                 extf f\n                  (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s) ys\n                  xs)\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "have gtwu_le_gtwg: \"?gtwu \\<le> (>\\<^sub>t\\<^sub>w\\<^sub>g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s)\n    \\<le> (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)", "by (auto intro!: gr_u)"], ["proof (state)\nthis:\n  (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s)\n  \\<le> (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "have \"wfP (\\<lambda>s t. ?gtwu t s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfP (\\<lambda>s t. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s)", "unfolding wfP_iff_no_inf_chain"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> Ex (inf_chain\n                (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s))", "proof (intro notI, elim exE)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       inf_chain (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s)\n        x \\<Longrightarrow>\n       False", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       inf_chain (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s)\n        x \\<Longrightarrow>\n       False", "assume bad_f: \"inf_chain ?gtwu f\""], ["proof (state)\nthis:\n  inf_chain (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s) f\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       inf_chain (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s)\n        x \\<Longrightarrow>\n       False", "hence bad_f0: \"bad ?gtwu (f 0)\""], ["proof (prove)\nusing this:\n  inf_chain (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s) f\n\ngoal (1 subgoal):\n 1. bad (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s) (f 0)", "by (rule inf_chain_bad)"], ["proof (state)\nthis:\n  bad (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s) (f 0)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       inf_chain (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s)\n        x \\<Longrightarrow>\n       False", "hence \"f 0 \\<in> U\""], ["proof (prove)\nusing this:\n  bad (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s) (f 0)\n\ngoal (1 subgoal):\n 1. f 0 \\<in> U", "using bad_f"], ["proof (prove)\nusing this:\n  bad (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s) (f 0)\n  inf_chain (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s) f\n\ngoal (1 subgoal):\n 1. f 0 \\<in> U", "unfolding inf_chain_def"], ["proof (prove)\nusing this:\n  bad (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s) (f 0)\n  \\<forall>i. f i \\<in> U \\<and> f i >\\<^sub>t\\<^sub>w f (Suc i)\n\ngoal (1 subgoal):\n 1. f 0 \\<in> U", "by blast"], ["proof (state)\nthis:\n  f 0 \\<in> U\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       inf_chain (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s)\n        x \\<Longrightarrow>\n       False", "hence \"\\<not> bad (>\\<^sub>t\\<^sub>w\\<^sub>g) (f 0)\""], ["proof (prove)\nusing this:\n  f 0 \\<in> U\n\ngoal (1 subgoal):\n 1. \\<not> bad (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s) (f 0)", "using u_good"], ["proof (prove)\nusing this:\n  f 0 \\<in> U\n  ?u \\<in> U \\<Longrightarrow>\n  \\<not> bad (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s) ?u\n\ngoal (1 subgoal):\n 1. \\<not> bad (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s) (f 0)", "by blast"], ["proof (state)\nthis:\n  \\<not> bad (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s) (f 0)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       inf_chain (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s)\n        x \\<Longrightarrow>\n       False", "hence \"\\<not> bad ?gtwu (f 0)\""], ["proof (prove)\nusing this:\n  \\<not> bad (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s) (f 0)\n\ngoal (1 subgoal):\n 1. \\<not> bad (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s) (f 0)", "using bad_f inf_chain_bad inf_chain_subset[OF _ gtwu_le_gtwg]"], ["proof (prove)\nusing this:\n  \\<not> bad (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s) (f 0)\n  inf_chain (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s) f\n  inf_chain ?p ?f \\<Longrightarrow> bad ?p (?f ?i)\n  inf_chain (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s)\n   ?f \\<Longrightarrow>\n  inf_chain (\\<lambda>t s. ground t \\<and> t >\\<^sub>t\\<^sub>w s) ?f\n\ngoal (1 subgoal):\n 1. \\<not> bad (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s) (f 0)", "by blast"], ["proof (state)\nthis:\n  \\<not> bad (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s) (f 0)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       inf_chain (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s)\n        x \\<Longrightarrow>\n       False", "thus False"], ["proof (prove)\nusing this:\n  \\<not> bad (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s) (f 0)\n\ngoal (1 subgoal):\n 1. False", "using bad_f0"], ["proof (prove)\nusing this:\n  \\<not> bad (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s) (f 0)\n  bad (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s) (f 0)\n\ngoal (1 subgoal):\n 1. False", "by sat"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wfP (\\<lambda>s t. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s)\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "hence wf_ext: \"wfP (\\<lambda>xs ys. length ys \\<le> max_args \\<and> length xs \\<le> max_args \\<and> extf f ?gtwu ys xs)\""], ["proof (prove)\nusing this:\n  wfP (\\<lambda>s t. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s)\n\ngoal (1 subgoal):\n 1. wfP (\\<lambda>xs ys.\n            length ys \\<le> max_args \\<and>\n            length xs \\<le> max_args \\<and>\n            extf f (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s) ys\n             xs)", "using extf_wf_bounded[of ?gtwu] gtwu_irrefl"], ["proof (prove)\nusing this:\n  wfP (\\<lambda>s t. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s)\n  \\<lbrakk>\\<And>z. \\<not> (z \\<in> U \\<and> z >\\<^sub>t\\<^sub>w z);\n   wfP (\\<lambda>x y. y \\<in> U \\<and> y >\\<^sub>t\\<^sub>w x)\\<rbrakk>\n  \\<Longrightarrow> wfP (\\<lambda>xs ys.\n                            length ys \\<le> ?n \\<and>\n                            length xs \\<le> ?n \\<and>\n                            extf ?f\n                             (\\<lambda>t s.\n                                 t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s)\n                             ys xs)\n  \\<not> (?x \\<in> U \\<and> ?x >\\<^sub>t\\<^sub>w ?x)\n\ngoal (1 subgoal):\n 1. wfP (\\<lambda>xs ys.\n            length ys \\<le> max_args \\<and>\n            length xs \\<le> max_args \\<and>\n            extf f (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s) ys\n             xs)", "by blast"], ["proof (state)\nthis:\n  wfP (\\<lambda>xs ys.\n          length ys \\<le> max_args \\<and>\n          length xs \\<le> max_args \\<and>\n          extf f (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s) ys\n           xs)\n\ngoal (1 subgoal):\n 1. Ex (inf_chain\n         (\\<lambda>t s.\n             ground t \\<and> t >\\<^sub>t\\<^sub>w s)) \\<Longrightarrow>\n    False", "show False"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using nwf_ext wf_ext"], ["proof (prove)\nusing this:\n  \\<not> wfP (\\<lambda>xs ys.\n                 length ys \\<le> max_args \\<and>\n                 length xs \\<le> max_args \\<and>\n                 extf f\n                  (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s) ys\n                  xs)\n  wfP (\\<lambda>xs ys.\n          length ys \\<le> max_args \\<and>\n          length xs \\<le> max_args \\<and>\n          extf f (\\<lambda>t s. t \\<in> U \\<and> t >\\<^sub>t\\<^sub>w s) ys\n           xs)\n\ngoal (1 subgoal):\n 1. False", "by blast"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  wfP (\\<lambda>s t. ground t \\<and> t >\\<^sub>t\\<^sub>w s)\n\ngoal (1 subgoal):\n 1. wfP (\\<lambda>s t. t >\\<^sub>t\\<^sub>w s)", "let ?subst = \"subst grounding_\\<rho>\""], ["proof (state)\ngoal (1 subgoal):\n 1. wfP (\\<lambda>s t. t >\\<^sub>t\\<^sub>w s)", "have \"wfP (\\<lambda>s t. ?subst t >\\<^sub>t\\<^sub>w\\<^sub>g ?subst s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wfP (\\<lambda>s t.\n            ground (subst grounding_\\<rho> t) \\<and>\n            subst grounding_\\<rho> t >\\<^sub>t\\<^sub>w\n            subst grounding_\\<rho> s)", "by (rule wfP_app[OF ground_wfP])"], ["proof (state)\nthis:\n  wfP (\\<lambda>s t.\n          ground (subst grounding_\\<rho> t) \\<and>\n          subst grounding_\\<rho> t >\\<^sub>t\\<^sub>w\n          subst grounding_\\<rho> s)\n\ngoal (1 subgoal):\n 1. wfP (\\<lambda>s t. t >\\<^sub>t\\<^sub>w s)", "hence \"wfP (\\<lambda>s t. ?subst t >\\<^sub>t\\<^sub>w ?subst s)\""], ["proof (prove)\nusing this:\n  wfP (\\<lambda>s t.\n          ground (subst grounding_\\<rho> t) \\<and>\n          subst grounding_\\<rho> t >\\<^sub>t\\<^sub>w\n          subst grounding_\\<rho> s)\n\ngoal (1 subgoal):\n 1. wfP (\\<lambda>s t.\n            subst grounding_\\<rho> t >\\<^sub>t\\<^sub>w\n            subst grounding_\\<rho> s)", "by (simp add: ground_grounding_\\<rho>)"], ["proof (state)\nthis:\n  wfP (\\<lambda>s t.\n          subst grounding_\\<rho> t >\\<^sub>t\\<^sub>w\n          subst grounding_\\<rho> s)\n\ngoal (1 subgoal):\n 1. wfP (\\<lambda>s t. t >\\<^sub>t\\<^sub>w s)", "thus ?thesis"], ["proof (prove)\nusing this:\n  wfP (\\<lambda>s t.\n          subst grounding_\\<rho> t >\\<^sub>t\\<^sub>w\n          subst grounding_\\<rho> s)\n\ngoal (1 subgoal):\n 1. wfP (\\<lambda>s t. t >\\<^sub>t\\<^sub>w s)", "by (auto intro: wfP_subset wary_subst_wary[OF wary_grounding_\\<rho>] gt_subst[OF wary_grounding_\\<rho>])"], ["proof (state)\nthis:\n  wfP (\\<lambda>s t. t >\\<^sub>t\\<^sub>w s)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}