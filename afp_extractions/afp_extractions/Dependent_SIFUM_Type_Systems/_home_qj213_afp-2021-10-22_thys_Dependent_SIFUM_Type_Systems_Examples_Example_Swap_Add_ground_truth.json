{"file_name": "/home/qj213/afp-2021-10-22/thys/Dependent_SIFUM_Type_Systems/Examples/Example_Swap_Add.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Dependent_SIFUM_Type_Systems", "problem_names": ["lemma if_type'': \n  \"\\<lbrakk>type_bexpr \\<Gamma> e t; pred_entailment P t;\n    has_type  \\<Gamma> \\<S> (add_pred P \\<S> e) c\\<^sub>1 \\<Gamma>' \\<S>' P';\n    has_type \\<Gamma> \\<S> (add_pred P \\<S> (bexp_neg e)) c\\<^sub>2 \\<Gamma>' \\<S>' P'';\n    pred_entailment P' {e}; pred_entailment P'' {bexp_neg e};  \n    P''' = restrict_preds_to_vars (((Imp e) ` (P' - {e})) \\<union> ((Imp (bexp_neg e)) ` (P'' - {bexp_neg e}))) {v. stable \\<S>' v}\\<rbrakk>\n\\<Longrightarrow> has_type \\<Gamma> \\<S> P (Stmt.If e c\\<^sub>1 c\\<^sub>2) \\<Gamma>' \\<S>' P'''\"", "lemma \\<C>_simp[simp]:\n  \"\\<C> = {control_X, control_Y, control_Z}\"", "lemma type_aexpr_Load:\n  \"v \\<notin> dom \\<Gamma> \\<Longrightarrow> type_aexpr \\<Gamma> (Load v) (dma_type v)\"", "lemma type_aexpr_Load':\n  \"v \\<in> dom \\<Gamma> \\<Longrightarrow> t = (the (\\<Gamma> v)) \\<Longrightarrow> type_aexpr \\<Gamma> (Load v) t\"", "lemma type_aexpr_Add:\n  \"x \\<notin> dom \\<Gamma> \\<Longrightarrow> y \\<notin> dom \\<Gamma> \\<Longrightarrow> \n   type_aexpr \\<Gamma> (Add x y) (\\<Union> {dma_type x, dma_type y})\"", "lemma type_aexpr_Add':\n  \"x \\<notin> dom \\<Gamma> \\<Longrightarrow> y \\<in> dom \\<Gamma> \\<Longrightarrow> t = (the (\\<Gamma> y)) \\<Longrightarrow>\n   type_aexpr \\<Gamma> (Add x y) (\\<Union> {dma_type x, t})\"", "lemma type_aexpr_Add'':\n  \"x \\<in> dom \\<Gamma> \\<Longrightarrow> y \\<notin> dom \\<Gamma> \\<Longrightarrow> t = (the (\\<Gamma> x)) \\<Longrightarrow>\n   type_aexpr \\<Gamma> (Add x y) (\\<Union> {t, dma_type y})\"", "lemma type_aexpr_Add''':\n  \"x \\<in> dom \\<Gamma> \\<Longrightarrow> y \\<in> dom \\<Gamma> \\<Longrightarrow> t = (the (\\<Gamma> x)) \\<Longrightarrow> t' = (the (\\<Gamma> y)) \\<Longrightarrow>\n   type_aexpr \\<Gamma> (Add x y) (\\<Union> {t, t'})\"", "lemma type_aexpr_Const[simp]:\n  \"type_aexpr \\<Gamma> (Const c) {}\"", "lemma control_vars_cases:\n  \"control_X \\<in> \\<C>_vars v \\<Longrightarrow> v = X\"\n  \"control_Y \\<in> \\<C>_vars v \\<Longrightarrow> v = Y\"\n  \"control_Z \\<in> \\<C>_vars v \\<Longrightarrow> v = Z\"", "lemma mem_is_different[simp, intro]:\n  \"mem x = A \\<Longrightarrow> mem y \\<noteq> A \\<Longrightarrow> \\<not> ev\\<^sub>B  mem (Same y (Load x))\"\n  \"mem x = A \\<Longrightarrow> mem y \\<noteq> A \\<Longrightarrow> \\<not> ev\\<^sub>B  mem (Same x (Load y))\"", "lemma restrict_preds_to_vars_empty[simp]:\n  \"restrict_preds_to_vars {} V = {}\"", "lemma restrict_preds_to_vars_idemp[simp]:\n  \"restrict_preds_to_vars (restrict_preds_to_vars P V) V = \n   restrict_preds_to_vars P V\"", "lemma restrict_preds_to_vars_insert1[simp]:\n  \"(\\<forall>x\\<in>bexp_vars a. x \\<in> V) \\<Longrightarrow> restrict_preds_to_vars (insert a P) V = (insert a (restrict_preds_to_vars P V))\"", "lemma restrict_preds_to_vars_insert2[simp]:\n  \"(\\<exists>x\\<in>bexp_vars a. x \\<notin> V) \\<Longrightarrow> restrict_preds_to_vars (insert a P) V = ((restrict_preds_to_vars P V))\"", "lemma [simp]: \"pred_entailment P {}\"", "lemma [simp]: \"e \\<in> P \\<Longrightarrow> pred_entailment P {e}\"", "lemma [simp]: \"FF \\<in> P \\<Longrightarrow> pred_entailment P Q\"", "lemma swap_vars_typed:\n  \"\\<Gamma> = (\\<lambda>_. None) \\<Longrightarrow> \\<S> = ({},{}) \\<Longrightarrow> P = {} \\<Longrightarrow> \n  \\<exists>\\<Gamma>' \\<S>' P'. has_type \\<Gamma> \\<S> P swap_vars \\<Gamma>' \\<S>' P'\"", "lemma swap_vars_sifum_secure:\n  \"com_sifum_secure (swap_vars,(\\<lambda>_. {}))\"", "lemma pred_entailment_singleton_by_case_distinction:\n  \"Imp e f \\<in> P \\<Longrightarrow> Imp (bexp.Not e) f \\<in> P \\<Longrightarrow> pred_entailment P {f}\"", "lemma restrict_preds_to_vars_nest [simp]:\n  \"restrict_preds_to_vars (restrict_preds_to_vars P V) V' = restrict_preds_to_vars P (V \\<inter> V')\"", "lemma restrict_preds_to_vars_imp_image1 [simp]:\n  \"\\<not> bexp_vars e \\<subseteq> V \\<Longrightarrow> restrict_preds_to_vars (Imp e ` P) V = {}\"", "lemma restrict_preds_to_vars_imp_image2 [simp]:\n  \"bexp_vars e \\<subseteq> V \\<Longrightarrow> restrict_preds_to_vars (Imp e ` P) V = ((Imp e) ` (restrict_preds_to_vars P V))\"", "lemma insert_minus1 [simp]:\n  \"x = y \\<Longrightarrow> (insert x A) - {y} = (A - {y})\"", "lemma insert_minus2 [simp]:\n  \"x \\<noteq> y \\<Longrightarrow> (insert x A) - {y} = insert x (A - {y})\"", "lemma add_vars_typed:\n  \"\\<Gamma> = (\\<lambda>_. None) \\<Longrightarrow> \\<S> = ({},{}) \\<Longrightarrow> P = {} \\<Longrightarrow> \n  \\<exists>\\<Gamma>' \\<S>' P'. has_type \\<Gamma> \\<S> P add_vars \\<Gamma>' \\<S>' P'\"", "lemma swap_vars_typed':\n  \"\\<Gamma> = (\\<lambda>_. None) \\<Longrightarrow> \\<S> = ({},{}) \\<Longrightarrow> P = {} \\<Longrightarrow> \n  \\<exists>\\<Gamma>' \\<S>' P'. has_type \\<Gamma> \\<S> P swap_vars \\<Gamma>' \\<S>' P'\"", "lemma add_vars_typed':\n  \"\\<Gamma> = (\\<lambda>_. None) \\<Longrightarrow> \\<S> = ({},{}) \\<Longrightarrow> P = {} \\<Longrightarrow> \n  \\<exists>\\<Gamma>' \\<S>' P'. has_type \\<Gamma> \\<S> P add_vars \\<Gamma>' \\<S>' P'\""], "translations": [["", "lemma if_type'': \n  \"\\<lbrakk>type_bexpr \\<Gamma> e t; pred_entailment P t;\n    has_type  \\<Gamma> \\<S> (add_pred P \\<S> e) c\\<^sub>1 \\<Gamma>' \\<S>' P';\n    has_type \\<Gamma> \\<S> (add_pred P \\<S> (bexp_neg e)) c\\<^sub>2 \\<Gamma>' \\<S>' P'';\n    pred_entailment P' {e}; pred_entailment P'' {bexp_neg e};  \n    P''' = restrict_preds_to_vars (((Imp e) ` (P' - {e})) \\<union> ((Imp (bexp_neg e)) ` (P'' - {bexp_neg e}))) {v. stable \\<S>' v}\\<rbrakk>\n\\<Longrightarrow> has_type \\<Gamma> \\<S> P (Stmt.If e c\\<^sub>1 c\\<^sub>2) \\<Gamma>' \\<S>' P'''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>type_bexpr \\<Gamma> e t; pred_entailment P t;\n     has_type \\<Gamma> \\<S> (add_pred P \\<S> e) c\\<^sub>1 \\<Gamma>' \\<S>'\n      P';\n     has_type \\<Gamma> \\<S> (add_pred P \\<S> (bexp_neg e)) c\\<^sub>2\n      \\<Gamma>' \\<S>' P'';\n     pred_entailment P' {e}; pred_entailment P'' {bexp_neg e};\n     P''' =\n     restrict_preds_to_vars\n      (Imp e ` (P' - {e}) \\<union> Imp (bexp_neg e) ` (P'' - {bexp_neg e}))\n      {v. stable \\<S>' v}\\<rbrakk>\n    \\<Longrightarrow> has_type \\<Gamma> \\<S> P\n                       (Stmt.If e c\\<^sub>1 c\\<^sub>2) \\<Gamma>' \\<S>' P'''", "apply(erule (3) if_type,simp+)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>pred_entailment P t;\n     has_type \\<Gamma> \\<S> (add_pred P \\<S> e) c\\<^sub>1 \\<Gamma>' \\<S>'\n      P';\n     has_type \\<Gamma> \\<S> (add_pred P \\<S> (bexp.Not e)) c\\<^sub>2\n      \\<Gamma>' \\<S>' P'';\n     pred_entailment P' {e}; pred_entailment P'' {bexp.Not e};\n     P''' =\n     restrict_preds_to_vars\n      (Imp e ` (P' - {e}) \\<union> Imp (bexp.Not e) ` (P'' - {bexp.Not e}))\n      {v. stable \\<S>' v}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment P'\n                       (restrict_preds_to_vars\n                         (Imp e ` (P' - {e}) \\<union>\n                          Imp (bexp.Not e) ` (P'' - {bexp.Not e}))\n                         {v. stable \\<S>' v})\n 2. \\<lbrakk>pred_entailment P t;\n     has_type \\<Gamma> \\<S> (add_pred P \\<S> e) c\\<^sub>1 \\<Gamma>' \\<S>'\n      P';\n     has_type \\<Gamma> \\<S> (add_pred P \\<S> (bexp_neg e)) c\\<^sub>2\n      \\<Gamma>' \\<S>' P'';\n     pred_entailment P' {e}; pred_entailment P'' {bexp_neg e};\n     P''' =\n     restrict_preds_to_vars\n      (Imp e ` (P' - {e}) \\<union> Imp (bexp_neg e) ` (P'' - {bexp_neg e}))\n      {v. stable \\<S>' v}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment P'' P'''\n 3. \\<lbrakk>pred_entailment P t;\n     has_type \\<Gamma> \\<S> (add_pred P \\<S> e) c\\<^sub>1 \\<Gamma>' \\<S>'\n      P';\n     has_type \\<Gamma> \\<S> (add_pred P \\<S> (bexp_neg e)) c\\<^sub>2\n      \\<Gamma>' \\<S>' P'';\n     pred_entailment P' {e}; pred_entailment P'' {bexp_neg e};\n     P''' =\n     restrict_preds_to_vars\n      (Imp e ` (P' - {e}) \\<union> Imp (bexp_neg e) ` (P'' - {bexp_neg e}))\n      {v. stable \\<S>' v}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds \\<Gamma>' \\<S>'\n                          P' \\<longrightarrow>\n                         tyenv_wellformed mds \\<Gamma>' \\<S>' P'''\n 4. \\<lbrakk>pred_entailment P t;\n     has_type \\<Gamma> \\<S> (add_pred P \\<S> e) c\\<^sub>1 \\<Gamma>' \\<S>'\n      P';\n     has_type \\<Gamma> \\<S> (add_pred P \\<S> (bexp_neg e)) c\\<^sub>2\n      \\<Gamma>' \\<S>' P'';\n     pred_entailment P' {e}; pred_entailment P'' {bexp_neg e};\n     P''' =\n     restrict_preds_to_vars\n      (Imp e ` (P' - {e}) \\<union> Imp (bexp_neg e) ` (P'' - {bexp_neg e}))\n      {v. stable \\<S>' v}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds \\<Gamma>' \\<S>'\n                          P'' \\<longrightarrow>\n                         tyenv_wellformed mds \\<Gamma>' \\<S>' P'''", "apply(auto simp: pred_entailment_def pred_def image_def restrict_preds_to_vars_def)[1]"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>pred_entailment P t;\n     has_type \\<Gamma> \\<S> (add_pred P \\<S> e) c\\<^sub>1 \\<Gamma>' \\<S>'\n      P';\n     has_type \\<Gamma> \\<S> (add_pred P \\<S> (bexp_neg e)) c\\<^sub>2\n      \\<Gamma>' \\<S>' P'';\n     pred_entailment P' {e}; pred_entailment P'' {bexp_neg e};\n     P''' =\n     restrict_preds_to_vars\n      (Imp e ` (P' - {e}) \\<union> Imp (bexp_neg e) ` (P'' - {bexp_neg e}))\n      {v. stable \\<S>' v}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment P'' P'''\n 2. \\<lbrakk>pred_entailment P t;\n     has_type \\<Gamma> \\<S> (add_pred P \\<S> e) c\\<^sub>1 \\<Gamma>' \\<S>'\n      P';\n     has_type \\<Gamma> \\<S> (add_pred P \\<S> (bexp_neg e)) c\\<^sub>2\n      \\<Gamma>' \\<S>' P'';\n     pred_entailment P' {e}; pred_entailment P'' {bexp_neg e};\n     P''' =\n     restrict_preds_to_vars\n      (Imp e ` (P' - {e}) \\<union> Imp (bexp_neg e) ` (P'' - {bexp_neg e}))\n      {v. stable \\<S>' v}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds \\<Gamma>' \\<S>'\n                          P' \\<longrightarrow>\n                         tyenv_wellformed mds \\<Gamma>' \\<S>' P'''\n 3. \\<lbrakk>pred_entailment P t;\n     has_type \\<Gamma> \\<S> (add_pred P \\<S> e) c\\<^sub>1 \\<Gamma>' \\<S>'\n      P';\n     has_type \\<Gamma> \\<S> (add_pred P \\<S> (bexp_neg e)) c\\<^sub>2\n      \\<Gamma>' \\<S>' P'';\n     pred_entailment P' {e}; pred_entailment P'' {bexp_neg e};\n     P''' =\n     restrict_preds_to_vars\n      (Imp e ` (P' - {e}) \\<union> Imp (bexp_neg e) ` (P'' - {bexp_neg e}))\n      {v. stable \\<S>' v}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds \\<Gamma>' \\<S>'\n                          P'' \\<longrightarrow>\n                         tyenv_wellformed mds \\<Gamma>' \\<S>' P'''", "apply(auto simp: pred_entailment_def pred_def image_def restrict_preds_to_vars_def)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>pred_entailment P t;\n     has_type \\<Gamma> \\<S> (add_pred P \\<S> e) c\\<^sub>1 \\<Gamma>' \\<S>'\n      P';\n     has_type \\<Gamma> \\<S> (add_pred P \\<S> (bexp_neg e)) c\\<^sub>2\n      \\<Gamma>' \\<S>' P'';\n     pred_entailment P' {e}; pred_entailment P'' {bexp_neg e};\n     P''' =\n     restrict_preds_to_vars\n      (Imp e ` (P' - {e}) \\<union> Imp (bexp_neg e) ` (P'' - {bexp_neg e}))\n      {v. stable \\<S>' v}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds \\<Gamma>' \\<S>'\n                          P' \\<longrightarrow>\n                         tyenv_wellformed mds \\<Gamma>' \\<S>' P'''\n 2. \\<lbrakk>pred_entailment P t;\n     has_type \\<Gamma> \\<S> (add_pred P \\<S> e) c\\<^sub>1 \\<Gamma>' \\<S>'\n      P';\n     has_type \\<Gamma> \\<S> (add_pred P \\<S> (bexp_neg e)) c\\<^sub>2\n      \\<Gamma>' \\<S>' P'';\n     pred_entailment P' {e}; pred_entailment P'' {bexp_neg e};\n     P''' =\n     restrict_preds_to_vars\n      (Imp e ` (P' - {e}) \\<union> Imp (bexp_neg e) ` (P'' - {bexp_neg e}))\n      {v. stable \\<S>' v}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds \\<Gamma>' \\<S>'\n                          P'' \\<longrightarrow>\n                         tyenv_wellformed mds \\<Gamma>' \\<S>' P'''", "apply(clarsimp simp: tyenv_wellformed_def mds_consistent_def stable_def image_def restrict_preds_to_vars_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>mds p x.\n       \\<lbrakk>pred_entailment P t;\n        has_type \\<Gamma> \\<S> (add_pred P \\<S> e) c\\<^sub>1 \\<Gamma>'\n         (mds AsmNoWrite, mds AsmNoReadOrWrite) P';\n        has_type \\<Gamma> \\<S> (add_pred P \\<S> (bexp.Not e)) c\\<^sub>2\n         \\<Gamma>' (mds AsmNoWrite, mds AsmNoReadOrWrite) P'';\n        pred_entailment P' {e}; pred_entailment P'' {bexp.Not e};\n        P''' =\n        {ea.\n         ((\\<exists>x\\<in>P' - {e}. ea = Imp e x) \\<or>\n          (\\<exists>x\\<in>P'' - {bexp.Not e}.\n              ea = Imp (bexp.Not e) x)) \\<and>\n         bexp_vars ea\n         \\<subseteq> {v. v \\<in> mds AsmNoWrite \\<or>\n                         v \\<in> mds AsmNoReadOrWrite}};\n        \\<S>' = (mds AsmNoWrite, mds AsmNoReadOrWrite);\n        dom \\<Gamma>' =\n        {x. x \\<notin> \\<C> \\<and>\n            (x \\<in> mds AsmNoWrite \\<or> x \\<in> mds AsmNoReadOrWrite)};\n        \\<forall>p\\<in>P'.\n           \\<forall>x\\<in>bexp_vars p.\n              x \\<in> mds AsmNoWrite \\<or> x \\<in> mds AsmNoReadOrWrite;\n        types_wellformed \\<Gamma>';\n        types_stable \\<Gamma>' (mds AsmNoWrite, mds AsmNoReadOrWrite);\n        x \\<in> bexp_vars p;\n        (\\<exists>x\\<in>P' - {e}. p = Imp e x) \\<or>\n        (\\<exists>x\\<in>P'' - {bexp.Not e}. p = Imp (bexp.Not e) x);\n        bexp_vars p\n        \\<subseteq> {v. v \\<in> mds AsmNoWrite \\<or>\n                        v \\<in> mds AsmNoReadOrWrite};\n        x \\<notin> mds AsmNoReadOrWrite\\<rbrakk>\n       \\<Longrightarrow> x \\<in> mds AsmNoWrite\n 2. \\<lbrakk>pred_entailment P t;\n     has_type \\<Gamma> \\<S> (add_pred P \\<S> e) c\\<^sub>1 \\<Gamma>' \\<S>'\n      P';\n     has_type \\<Gamma> \\<S> (add_pred P \\<S> (bexp_neg e)) c\\<^sub>2\n      \\<Gamma>' \\<S>' P'';\n     pred_entailment P' {e}; pred_entailment P'' {bexp_neg e};\n     P''' =\n     restrict_preds_to_vars\n      (Imp e ` (P' - {e}) \\<union> Imp (bexp_neg e) ` (P'' - {bexp_neg e}))\n      {v. stable \\<S>' v}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds \\<Gamma>' \\<S>'\n                          P'' \\<longrightarrow>\n                         tyenv_wellformed mds \\<Gamma>' \\<S>' P'''", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>pred_entailment P t;\n     has_type \\<Gamma> \\<S> (add_pred P \\<S> e) c\\<^sub>1 \\<Gamma>' \\<S>'\n      P';\n     has_type \\<Gamma> \\<S> (add_pred P \\<S> (bexp_neg e)) c\\<^sub>2\n      \\<Gamma>' \\<S>' P'';\n     pred_entailment P' {e}; pred_entailment P'' {bexp_neg e};\n     P''' =\n     restrict_preds_to_vars\n      (Imp e ` (P' - {e}) \\<union> Imp (bexp_neg e) ` (P'' - {bexp_neg e}))\n      {v. stable \\<S>' v}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds \\<Gamma>' \\<S>'\n                          P'' \\<longrightarrow>\n                         tyenv_wellformed mds \\<Gamma>' \\<S>' P'''", "apply(clarsimp simp: tyenv_wellformed_def mds_consistent_def stable_def image_def restrict_preds_to_vars_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>mds p x.\n       \\<lbrakk>pred_entailment P t;\n        has_type \\<Gamma> \\<S> (add_pred P \\<S> e) c\\<^sub>1 \\<Gamma>'\n         (mds AsmNoWrite, mds AsmNoReadOrWrite) P';\n        has_type \\<Gamma> \\<S> (add_pred P \\<S> (bexp.Not e)) c\\<^sub>2\n         \\<Gamma>' (mds AsmNoWrite, mds AsmNoReadOrWrite) P'';\n        pred_entailment P' {e}; pred_entailment P'' {bexp.Not e};\n        P''' =\n        {ea.\n         ((\\<exists>x\\<in>P' - {e}. ea = Imp e x) \\<or>\n          (\\<exists>x\\<in>P'' - {bexp.Not e}.\n              ea = Imp (bexp.Not e) x)) \\<and>\n         bexp_vars ea\n         \\<subseteq> {v. v \\<in> mds AsmNoWrite \\<or>\n                         v \\<in> mds AsmNoReadOrWrite}};\n        \\<S>' = (mds AsmNoWrite, mds AsmNoReadOrWrite);\n        dom \\<Gamma>' =\n        {x. x \\<notin> \\<C> \\<and>\n            (x \\<in> mds AsmNoWrite \\<or> x \\<in> mds AsmNoReadOrWrite)};\n        \\<forall>p\\<in>P''.\n           \\<forall>x\\<in>bexp_vars p.\n              x \\<in> mds AsmNoWrite \\<or> x \\<in> mds AsmNoReadOrWrite;\n        types_wellformed \\<Gamma>';\n        types_stable \\<Gamma>' (mds AsmNoWrite, mds AsmNoReadOrWrite);\n        x \\<in> bexp_vars p;\n        (\\<exists>x\\<in>P' - {e}. p = Imp e x) \\<or>\n        (\\<exists>x\\<in>P'' - {bexp.Not e}. p = Imp (bexp.Not e) x);\n        bexp_vars p\n        \\<subseteq> {v. v \\<in> mds AsmNoWrite \\<or>\n                        v \\<in> mds AsmNoReadOrWrite};\n        x \\<notin> mds AsmNoReadOrWrite\\<rbrakk>\n       \\<Longrightarrow> x \\<in> mds AsmNoWrite", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition\n  swap_vars :: \"(addr, aexp, bexp) Stmt\"\nwhere\n  \"swap_vars \\<equiv> \n     ModeDecl Skip (Acq control_X AsmNoWrite) ;; \n     ModeDecl Skip (Acq control_Y AsmNoWrite) ;;\n     ModeDecl Skip (Acq control_Z AsmNoWrite) ;;\n     ModeDecl Skip (Acq X AsmNoReadOrWrite) ;; \n     ModeDecl Skip (Acq Y AsmNoReadOrWrite) ;;\n     ModeDecl Skip (Acq Z AsmNoReadOrWrite) ;;\n     Assign Z (Load X) ;;\n     Assign X (Load Y) ;;\n     Assign Y (Load Z) ;;\n     Assign control_Z (Load control_X) ;;\n     Assign control_X (Load control_Y) ;;\n     Assign control_Y (Load control_Z) ;;\n     ModeDecl Skip (Rel X AsmNoReadOrWrite) ;;\n     ModeDecl Skip (Rel Y AsmNoReadOrWrite) ;;\n     ModeDecl Skip (Rel Z AsmNoReadOrWrite) ;;\n     ModeDecl Skip (Rel control_X AsmNoWrite) ;; \n     ModeDecl Skip (Rel control_Y AsmNoWrite) ;;\n     ModeDecl Skip (Rel control_Z AsmNoWrite) ;;\n     Skip\""], ["", "lemma \\<C>_simp[simp]:\n  \"\\<C> = {control_X, control_Y, control_Z}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<C> = {control_X, control_Y, control_Z}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<C> = {control_X, control_Y, control_Z}", "have \"\\<C> = control_var_of ` {x. x = X \\<or> x = Y \\<or> x = Z}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<C> = control_var_of ` {x. x = X \\<or> x = Y \\<or> x = Z}", "by (simp add: \\<C>_def \\<C>_vars_def UNION_singleton_eq_range)"], ["proof (state)\nthis:\n  \\<C> = control_var_of ` {x. x = X \\<or> x = Y \\<or> x = Z}\n\ngoal (1 subgoal):\n 1. \\<C> = {control_X, control_Y, control_Z}", "also"], ["proof (state)\nthis:\n  \\<C> = control_var_of ` {x. x = X \\<or> x = Y \\<or> x = Z}\n\ngoal (1 subgoal):\n 1. \\<C> = {control_X, control_Y, control_Z}", "have \"{x. x = X \\<or> x = Y \\<or> x = Z} = {X, Y, Z}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. x = X \\<or> x = Y \\<or> x = Z} = {X, Y, Z}", "by auto"], ["proof (state)\nthis:\n  {x. x = X \\<or> x = Y \\<or> x = Z} = {X, Y, Z}\n\ngoal (1 subgoal):\n 1. \\<C> = {control_X, control_Y, control_Z}", "finally"], ["proof (chain)\npicking this:\n  \\<C> = control_var_of ` {X, Y, Z}", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<C> = control_var_of ` {X, Y, Z}\n\ngoal (1 subgoal):\n 1. \\<C> = {control_X, control_Y, control_Z}", "by simp"], ["proof (state)\nthis:\n  \\<C> = {control_X, control_Y, control_Z}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma type_aexpr_Load:\n  \"v \\<notin> dom \\<Gamma> \\<Longrightarrow> type_aexpr \\<Gamma> (Load v) (dma_type v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<notin> dom \\<Gamma> \\<Longrightarrow>\n    type_aexpr \\<Gamma> (Load v) (dma_type v)", "apply(insert type_aexpr[of \\<Gamma> \"Load v\", simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<notin> dom \\<Gamma>;\n     type_aexpr \\<Gamma> (Load v) (to_total \\<Gamma> v)\\<rbrakk>\n    \\<Longrightarrow> type_aexpr \\<Gamma> (Load v) (dma_type v)", "apply(simp add: to_total_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma type_aexpr_Load':\n  \"v \\<in> dom \\<Gamma> \\<Longrightarrow> t = (the (\\<Gamma> v)) \\<Longrightarrow> type_aexpr \\<Gamma> (Load v) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> dom \\<Gamma>; t = the (\\<Gamma> v)\\<rbrakk>\n    \\<Longrightarrow> type_aexpr \\<Gamma> (Load v) t", "apply(insert type_aexpr[of \\<Gamma> \"Load v\", simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> dom \\<Gamma>; t = the (\\<Gamma> v);\n     type_aexpr \\<Gamma> (Load v) (to_total \\<Gamma> v)\\<rbrakk>\n    \\<Longrightarrow> type_aexpr \\<Gamma> (Load v) t", "apply(simp add: to_total_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma type_aexpr_Add:\n  \"x \\<notin> dom \\<Gamma> \\<Longrightarrow> y \\<notin> dom \\<Gamma> \\<Longrightarrow> \n   type_aexpr \\<Gamma> (Add x y) (\\<Union> {dma_type x, dma_type y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> dom \\<Gamma>; y \\<notin> dom \\<Gamma>\\<rbrakk>\n    \\<Longrightarrow> type_aexpr \\<Gamma> (Add x y)\n                       (\\<Union> {dma_type x, dma_type y})", "apply(insert type_aexpr[of \\<Gamma> \"Add x y\", simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> dom \\<Gamma>; y \\<notin> dom \\<Gamma>;\n     type_aexpr \\<Gamma> (Add x y)\n      (to_total \\<Gamma> x \\<union> to_total \\<Gamma> y)\\<rbrakk>\n    \\<Longrightarrow> type_aexpr \\<Gamma> (Add x y)\n                       (\\<Union> {dma_type x, dma_type y})", "apply(simp add: to_total_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma type_aexpr_Add':\n  \"x \\<notin> dom \\<Gamma> \\<Longrightarrow> y \\<in> dom \\<Gamma> \\<Longrightarrow> t = (the (\\<Gamma> y)) \\<Longrightarrow>\n   type_aexpr \\<Gamma> (Add x y) (\\<Union> {dma_type x, t})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> dom \\<Gamma>; y \\<in> dom \\<Gamma>;\n     t = the (\\<Gamma> y)\\<rbrakk>\n    \\<Longrightarrow> type_aexpr \\<Gamma> (Add x y)\n                       (\\<Union> {dma_type x, t})", "apply(insert type_aexpr[of \\<Gamma> \"Add x y\", simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<notin> dom \\<Gamma>; y \\<in> dom \\<Gamma>;\n     t = the (\\<Gamma> y);\n     type_aexpr \\<Gamma> (Add x y)\n      (to_total \\<Gamma> x \\<union> to_total \\<Gamma> y)\\<rbrakk>\n    \\<Longrightarrow> type_aexpr \\<Gamma> (Add x y)\n                       (\\<Union> {dma_type x, t})", "apply(simp add: to_total_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma type_aexpr_Add'':\n  \"x \\<in> dom \\<Gamma> \\<Longrightarrow> y \\<notin> dom \\<Gamma> \\<Longrightarrow> t = (the (\\<Gamma> x)) \\<Longrightarrow>\n   type_aexpr \\<Gamma> (Add x y) (\\<Union> {t, dma_type y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> dom \\<Gamma>; y \\<notin> dom \\<Gamma>;\n     t = the (\\<Gamma> x)\\<rbrakk>\n    \\<Longrightarrow> type_aexpr \\<Gamma> (Add x y)\n                       (\\<Union> {t, dma_type y})", "apply(insert type_aexpr[of \\<Gamma> \"Add x y\", simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> dom \\<Gamma>; y \\<notin> dom \\<Gamma>;\n     t = the (\\<Gamma> x);\n     type_aexpr \\<Gamma> (Add x y)\n      (to_total \\<Gamma> x \\<union> to_total \\<Gamma> y)\\<rbrakk>\n    \\<Longrightarrow> type_aexpr \\<Gamma> (Add x y)\n                       (\\<Union> {t, dma_type y})", "apply(simp add: to_total_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma type_aexpr_Add''':\n  \"x \\<in> dom \\<Gamma> \\<Longrightarrow> y \\<in> dom \\<Gamma> \\<Longrightarrow> t = (the (\\<Gamma> x)) \\<Longrightarrow> t' = (the (\\<Gamma> y)) \\<Longrightarrow>\n   type_aexpr \\<Gamma> (Add x y) (\\<Union> {t, t'})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> dom \\<Gamma>; y \\<in> dom \\<Gamma>;\n     t = the (\\<Gamma> x); t' = the (\\<Gamma> y)\\<rbrakk>\n    \\<Longrightarrow> type_aexpr \\<Gamma> (Add x y) (\\<Union> {t, t'})", "apply(insert type_aexpr[of \\<Gamma> \"Add x y\", simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> dom \\<Gamma>; y \\<in> dom \\<Gamma>;\n     t = the (\\<Gamma> x); t' = the (\\<Gamma> y);\n     type_aexpr \\<Gamma> (Add x y)\n      (to_total \\<Gamma> x \\<union> to_total \\<Gamma> y)\\<rbrakk>\n    \\<Longrightarrow> type_aexpr \\<Gamma> (Add x y) (\\<Union> {t, t'})", "apply(simp add: to_total_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma type_aexpr_Const[simp]:\n  \"type_aexpr \\<Gamma> (Const c) {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. type_aexpr \\<Gamma> (Const c) {}", "apply(insert type_aexpr[of \\<Gamma> \"Const c\", simplified],simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare restrict_preds_to_vars_def [simp]"], ["", "declare add_pred_def [simp]"], ["", "declare stable_def [simp]"], ["", "declare to_total_def [simp]"], ["", "declare \\<C>_vars_def [simp]"], ["", "declare anno_type_stable_def [simp]"], ["", "declare anno_type_sec_def [simp]"], ["", "declare assign_post_def [simp]"], ["", "lemma control_vars_cases:\n  \"control_X \\<in> \\<C>_vars v \\<Longrightarrow> v = X\"\n  \"control_Y \\<in> \\<C>_vars v \\<Longrightarrow> v = Y\"\n  \"control_Z \\<in> \\<C>_vars v \\<Longrightarrow> v = Z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (control_X \\<in> \\<C>_vars v \\<Longrightarrow> v = X) &&&\n    (control_Y \\<in> \\<C>_vars v \\<Longrightarrow> v = Y) &&&\n    (control_Z \\<in> \\<C>_vars v \\<Longrightarrow> v = Z)", "by(case_tac v, auto)+"], ["", "lemma mem_is_different[simp, intro]:\n  \"mem x = A \\<Longrightarrow> mem y \\<noteq> A \\<Longrightarrow> \\<not> ev\\<^sub>B  mem (Same y (Load x))\"\n  \"mem x = A \\<Longrightarrow> mem y \\<noteq> A \\<Longrightarrow> \\<not> ev\\<^sub>B  mem (Same x (Load y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lbrakk>mem x = A; mem y \\<noteq> A\\<rbrakk>\n     \\<Longrightarrow> \\<not> ev\\<^sub>B mem (Same y (Load x))) &&&\n    (\\<lbrakk>mem x = A; mem y \\<noteq> A\\<rbrakk>\n     \\<Longrightarrow> \\<not> ev\\<^sub>B mem (Same x (Load y)))", "by fastforce+"], ["", "lemma restrict_preds_to_vars_empty[simp]:\n  \"restrict_preds_to_vars {} V = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict_preds_to_vars {} V = {}", "apply(simp add: restrict_preds_to_vars_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma restrict_preds_to_vars_idemp[simp]:\n  \"restrict_preds_to_vars (restrict_preds_to_vars P V) V = \n   restrict_preds_to_vars P V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict_preds_to_vars (restrict_preds_to_vars P V) V =\n    restrict_preds_to_vars P V", "apply(simp add: restrict_preds_to_vars_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma restrict_preds_to_vars_insert1[simp]:\n  \"(\\<forall>x\\<in>bexp_vars a. x \\<in> V) \\<Longrightarrow> restrict_preds_to_vars (insert a P) V = (insert a (restrict_preds_to_vars P V))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>bexp_vars a. x \\<in> V \\<Longrightarrow>\n    restrict_preds_to_vars (insert a P) V =\n    insert a (restrict_preds_to_vars P V)", "apply(simp add: restrict_preds_to_vars_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>bexp_vars a. x \\<in> V \\<Longrightarrow>\n    {e. (e = a \\<or> e \\<in> P) \\<and> bexp_vars e \\<subseteq> V} =\n    insert a {e \\<in> P. bexp_vars e \\<subseteq> V}", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma restrict_preds_to_vars_insert2[simp]:\n  \"(\\<exists>x\\<in>bexp_vars a. x \\<notin> V) \\<Longrightarrow> restrict_preds_to_vars (insert a P) V = ((restrict_preds_to_vars P V))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>bexp_vars a. x \\<notin> V \\<Longrightarrow>\n    restrict_preds_to_vars (insert a P) V = restrict_preds_to_vars P V", "apply(simp add: restrict_preds_to_vars_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>bexp_vars a. x \\<notin> V \\<Longrightarrow>\n    {e. (e = a \\<or> e \\<in> P) \\<and> bexp_vars e \\<subseteq> V} =\n    {e \\<in> P. bexp_vars e \\<subseteq> V}", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare restrict_preds_to_vars_def[simp del]"], ["", "lemma [simp]: \"pred_entailment P {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_entailment P {}", "by(simp add: pred_entailment_def pred_def)"], ["", "lemma [simp]: \"e \\<in> P \\<Longrightarrow> pred_entailment P {e}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<in> P \\<Longrightarrow> pred_entailment P {e}", "by(blast intro: subset_entailment)"], ["", "lemma [simp]: \"FF \\<in> P \\<Longrightarrow> pred_entailment P Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FF \\<in> P \\<Longrightarrow> pred_entailment P Q", "by(auto simp: pred_entailment_def pred_def)"], ["", "lemma swap_vars_typed:\n  \"\\<Gamma> = (\\<lambda>_. None) \\<Longrightarrow> \\<S> = ({},{}) \\<Longrightarrow> P = {} \\<Longrightarrow> \n  \\<exists>\\<Gamma>' \\<S>' P'. has_type \\<Gamma> \\<S> P swap_vars \\<Gamma>' \\<S>' P'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<Gamma>' \\<S>' P'.\n                         has_type \\<Gamma> \\<S> P swap_vars \\<Gamma>' \\<S>'\n                          P'", "apply(intro exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type \\<Gamma> \\<S> P swap_vars ?\\<Gamma>' ?\\<S>'1\n                       ?P'2", "apply(simp add: swap_vars_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({}, {}) {}\n                       ((Skip@[control_X +=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y +=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z +=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[X +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Z \\<leftarrow> Load X) ;;\n                        (X \\<leftarrow> Load Y) ;;\n                        (Y \\<leftarrow> Load Z) ;;\n                        (control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule seq_type)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({}, {}) {}\n                       (Skip@[control_X +=\\<^sub>m AsmNoWrite]) ?\\<Gamma>'3\n                       ?\\<S>'3 ?P'3\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'3 ?\\<S>'3 ?P'3\n                       ((Skip@[control_Y +=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z +=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[X +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Z \\<leftarrow> Load X) ;;\n                        (X \\<leftarrow> Load Y) ;;\n                        (Y \\<leftarrow> Load Z) ;;\n                        (control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule anno_type[OF HOL.refl HOL.refl HOL.refl])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno Map.empty ({}, {})\n                         (control_X +=\\<^sub>m AsmNoWrite))\n                       (add_anno_stable ({}, {})\n                         (control_X +=\\<^sub>m AsmNoWrite))\n                       (restrict_preds_to_vars {}\n                         {v. stable\n                              (add_anno_stable ({}, {})\n                                (control_X +=\\<^sub>m AsmNoWrite))\n                              v})\n                       Skip ?\\<Gamma>'3 ?\\<S>'3 ?P'3\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable ({}, {})\n                                   (control_X +=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty ({}, {})\n                              (control_X +=\\<^sub>m AsmNoWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty ({}, {})\n                       (control_X +=\\<^sub>m AsmNoWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({}, {}) {}\n                       (control_X +=\\<^sub>m AsmNoWrite)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'3 ?\\<S>'3 ?P'3\n                       ((Skip@[control_Y +=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z +=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[X +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Z \\<leftarrow> Load X) ;;\n                        (X \\<leftarrow> Load Y) ;;\n                        (Y \\<leftarrow> Load Z) ;;\n                        (control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply clarsimp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({control_X}, {}) {} Skip\n                       ?\\<Gamma>'3 ?\\<S>'3 ?P'3\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable ({}, {})\n                                   (control_X +=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty ({}, {})\n                              (control_X +=\\<^sub>m AsmNoWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty ({}, {})\n                       (control_X +=\\<^sub>m AsmNoWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({}, {}) {}\n                       (control_X +=\\<^sub>m AsmNoWrite)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'3 ?\\<S>'3 ?P'3\n                       ((Skip@[control_Y +=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z +=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[X +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Z \\<leftarrow> Load X) ;;\n                        (X \\<leftarrow> Load Y) ;;\n                        (Y \\<leftarrow> Load Z) ;;\n                        (control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule skip_type)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 2. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable ({}, {})\n                                   (control_X +=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty ({}, {})\n                              (control_X +=\\<^sub>m AsmNoWrite))\n                            x)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty ({}, {})\n                       (control_X +=\\<^sub>m AsmNoWrite)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({}, {}) {}\n                       (control_X +=\\<^sub>m AsmNoWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({control_X}, {}) {}\n                       ((Skip@[control_Y +=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z +=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[X +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Z \\<leftarrow> Load X) ;;\n                        (X \\<leftarrow> Load Y) ;;\n                        (Y \\<leftarrow> Load Z) ;;\n                        (control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(simp+)[4]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({control_X}, {}) {}\n                       ((Skip@[control_Y +=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z +=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[X +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Z \\<leftarrow> Load X) ;;\n                        (X \\<leftarrow> Load Y) ;;\n                        (Y \\<leftarrow> Load Z) ;;\n                        (control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule seq_type)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({control_X}, {}) {}\n                       (Skip@[control_Y +=\\<^sub>m AsmNoWrite]) ?\\<Gamma>'20\n                       ?\\<S>'20 ?P'20\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'20 ?\\<S>'20 ?P'20\n                       ((Skip@[control_Z +=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[X +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Z \\<leftarrow> Load X) ;;\n                        (X \\<leftarrow> Load Y) ;;\n                        (Y \\<leftarrow> Load Z) ;;\n                        (control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule anno_type[OF HOL.refl HOL.refl HOL.refl])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno Map.empty ({control_X}, {})\n                         (control_Y +=\\<^sub>m AsmNoWrite))\n                       (add_anno_stable ({control_X}, {})\n                         (control_Y +=\\<^sub>m AsmNoWrite))\n                       (restrict_preds_to_vars {}\n                         {v. stable\n                              (add_anno_stable ({control_X}, {})\n                                (control_Y +=\\<^sub>m AsmNoWrite))\n                              v})\n                       Skip ?\\<Gamma>'20 ?\\<S>'20 ?P'20\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable ({control_X}, {})\n                                   (control_Y +=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty ({control_X}, {})\n                              (control_Y +=\\<^sub>m AsmNoWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty ({control_X}, {})\n                       (control_Y +=\\<^sub>m AsmNoWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({control_X}, {}) {}\n                       (control_Y +=\\<^sub>m AsmNoWrite)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'20 ?\\<S>'20 ?P'20\n                       ((Skip@[control_Z +=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[X +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Z \\<leftarrow> Load X) ;;\n                        (X \\<leftarrow> Load Y) ;;\n                        (Y \\<leftarrow> Load Z) ;;\n                        (control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply clarsimp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({control_Y, control_X}, {}) {}\n                       Skip ?\\<Gamma>'20 ?\\<S>'20 ?P'20\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable ({control_X}, {})\n                                   (control_Y +=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty ({control_X}, {})\n                              (control_Y +=\\<^sub>m AsmNoWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty ({control_X}, {})\n                       (control_Y +=\\<^sub>m AsmNoWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({control_X}, {}) {}\n                       (control_Y +=\\<^sub>m AsmNoWrite)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'20 ?\\<S>'20 ?P'20\n                       ((Skip@[control_Z +=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[X +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Z \\<leftarrow> Load X) ;;\n                        (X \\<leftarrow> Load Y) ;;\n                        (Y \\<leftarrow> Load Z) ;;\n                        (control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule skip_type)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 2. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable ({control_X}, {})\n                                   (control_Y +=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty ({control_X}, {})\n                              (control_Y +=\\<^sub>m AsmNoWrite))\n                            x)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty ({control_X}, {})\n                       (control_Y +=\\<^sub>m AsmNoWrite)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({control_X}, {}) {}\n                       (control_Y +=\\<^sub>m AsmNoWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({control_Y, control_X}, {}) {}\n                       ((Skip@[control_Z +=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[X +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Z \\<leftarrow> Load X) ;;\n                        (X \\<leftarrow> Load Y) ;;\n                        (Y \\<leftarrow> Load Z) ;;\n                        (control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(simp+)[4]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({control_Y, control_X}, {}) {}\n                       ((Skip@[control_Z +=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[X +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Z \\<leftarrow> Load X) ;;\n                        (X \\<leftarrow> Load Y) ;;\n                        (Y \\<leftarrow> Load Z) ;;\n                        (control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule seq_type)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({control_Y, control_X}, {}) {}\n                       (Skip@[control_Z +=\\<^sub>m AsmNoWrite]) ?\\<Gamma>'37\n                       ?\\<S>'37 ?P'37\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'37 ?\\<S>'37 ?P'37\n                       ((Skip@[X +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Z \\<leftarrow> Load X) ;;\n                        (X \\<leftarrow> Load Y) ;;\n                        (Y \\<leftarrow> Load Z) ;;\n                        (control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule anno_type[OF HOL.refl HOL.refl HOL.refl])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno Map.empty ({control_Y, control_X}, {})\n                         (control_Z +=\\<^sub>m AsmNoWrite))\n                       (add_anno_stable ({control_Y, control_X}, {})\n                         (control_Z +=\\<^sub>m AsmNoWrite))\n                       (restrict_preds_to_vars {}\n                         {v. stable\n                              (add_anno_stable ({control_Y, control_X}, {})\n                                (control_Z +=\\<^sub>m AsmNoWrite))\n                              v})\n                       Skip ?\\<Gamma>'37 ?\\<S>'37 ?P'37\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable\n                                   ({control_Y, control_X}, {})\n                                   (control_Z +=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty ({control_Y, control_X}, {})\n                              (control_Z +=\\<^sub>m AsmNoWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty\n                       ({control_Y, control_X}, {})\n                       (control_Z +=\\<^sub>m AsmNoWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({control_Y, control_X}, {})\n                       {} (control_Z +=\\<^sub>m AsmNoWrite)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'37 ?\\<S>'37 ?P'37\n                       ((Skip@[X +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Z \\<leftarrow> Load X) ;;\n                        (X \\<leftarrow> Load Y) ;;\n                        (Y \\<leftarrow> Load Z) ;;\n                        (control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply clarsimp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty\n                       ({control_Z, control_Y, control_X}, {}) {} Skip\n                       ?\\<Gamma>'37 ?\\<S>'37 ?P'37\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable\n                                   ({control_Y, control_X}, {})\n                                   (control_Z +=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty ({control_Y, control_X}, {})\n                              (control_Z +=\\<^sub>m AsmNoWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty\n                       ({control_Y, control_X}, {})\n                       (control_Z +=\\<^sub>m AsmNoWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({control_Y, control_X}, {})\n                       {} (control_Z +=\\<^sub>m AsmNoWrite)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'37 ?\\<S>'37 ?P'37\n                       ((Skip@[X +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Z \\<leftarrow> Load X) ;;\n                        (X \\<leftarrow> Load Y) ;;\n                        (Y \\<leftarrow> Load Z) ;;\n                        (control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule skip_type)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 2. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable\n                                   ({control_Y, control_X}, {})\n                                   (control_Z +=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty ({control_Y, control_X}, {})\n                              (control_Z +=\\<^sub>m AsmNoWrite))\n                            x)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty\n                       ({control_Y, control_X}, {})\n                       (control_Z +=\\<^sub>m AsmNoWrite)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({control_Y, control_X}, {})\n                       {} (control_Z +=\\<^sub>m AsmNoWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty\n                       ({control_Z, control_Y, control_X}, {}) {}\n                       ((Skip@[X +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Z \\<leftarrow> Load X) ;;\n                        (X \\<leftarrow> Load Y) ;;\n                        (Y \\<leftarrow> Load Z) ;;\n                        (control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(simp+)[4]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty\n                       ({control_Z, control_Y, control_X}, {}) {}\n                       ((Skip@[X +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Z \\<leftarrow> Load X) ;;\n                        (X \\<leftarrow> Load Y) ;;\n                        (Y \\<leftarrow> Load Z) ;;\n                        (control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule seq_type)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty\n                       ({control_Z, control_Y, control_X}, {}) {}\n                       (Skip@[X +=\\<^sub>m AsmNoReadOrWrite]) ?\\<Gamma>'54\n                       ?\\<S>'54 ?P'54\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'54 ?\\<S>'54 ?P'54\n                       ((Skip@[Y +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Z \\<leftarrow> Load X) ;;\n                        (X \\<leftarrow> Load Y) ;;\n                        (Y \\<leftarrow> Load Z) ;;\n                        (control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule anno_type[OF HOL.refl HOL.refl HOL.refl])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno Map.empty\n                         ({control_Z, control_Y, control_X}, {})\n                         (X +=\\<^sub>m AsmNoReadOrWrite))\n                       (add_anno_stable\n                         ({control_Z, control_Y, control_X}, {})\n                         (X +=\\<^sub>m AsmNoReadOrWrite))\n                       (restrict_preds_to_vars {}\n                         {v. stable\n                              (add_anno_stable\n                                ({control_Z, control_Y, control_X}, {})\n                                (X +=\\<^sub>m AsmNoReadOrWrite))\n                              v})\n                       Skip ?\\<Gamma>'54 ?\\<S>'54 ?P'54\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable\n                                   ({control_Z, control_Y, control_X}, {})\n                                   (X +=\\<^sub>m AsmNoReadOrWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty\n                              ({control_Z, control_Y, control_X}, {})\n                              (X +=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty\n                       ({control_Z, control_Y, control_X}, {})\n                       (X +=\\<^sub>m AsmNoReadOrWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty\n                       ({control_Z, control_Y, control_X}, {}) {}\n                       (X +=\\<^sub>m AsmNoReadOrWrite)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'54 ?\\<S>'54 ?P'54\n                       ((Skip@[Y +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Z \\<leftarrow> Load X) ;;\n                        (X \\<leftarrow> Load Y) ;;\n                        (Y \\<leftarrow> Load Z) ;;\n                        (control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply clarsimp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [X \\<mapsto> {Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {X}) {} Skip\n                       ?\\<Gamma>'54 ?\\<S>'54 ?P'54\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable\n                                   ({control_Z, control_Y, control_X}, {})\n                                   (X +=\\<^sub>m AsmNoReadOrWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty\n                              ({control_Z, control_Y, control_X}, {})\n                              (X +=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty\n                       ({control_Z, control_Y, control_X}, {})\n                       (X +=\\<^sub>m AsmNoReadOrWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty\n                       ({control_Z, control_Y, control_X}, {}) {}\n                       (X +=\\<^sub>m AsmNoReadOrWrite)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'54 ?\\<S>'54 ?P'54\n                       ((Skip@[Y +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Z \\<leftarrow> Load X) ;;\n                        (X \\<leftarrow> Load Y) ;;\n                        (Y \\<leftarrow> Load Z) ;;\n                        (control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule skip_type)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 2. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable\n                                   ({control_Z, control_Y, control_X}, {})\n                                   (X +=\\<^sub>m AsmNoReadOrWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty\n                              ({control_Z, control_Y, control_X}, {})\n                              (X +=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty\n                       ({control_Z, control_Y, control_X}, {})\n                       (X +=\\<^sub>m AsmNoReadOrWrite)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty\n                       ({control_Z, control_Y, control_X}, {}) {}\n                       (X +=\\<^sub>m AsmNoReadOrWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [X \\<mapsto> {Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {X}) {}\n                       ((Skip@[Y +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Z \\<leftarrow> Load X) ;;\n                        (X \\<leftarrow> Load Y) ;;\n                        (Y \\<leftarrow> Load Z) ;;\n                        (control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(simp+)[4]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [X \\<mapsto> {Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {X}) {}\n                       ((Skip@[Y +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Z \\<leftarrow> Load X) ;;\n                        (X \\<leftarrow> Load Y) ;;\n                        (Y \\<leftarrow> Load Z) ;;\n                        (control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule seq_type)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [X \\<mapsto> {Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {X}) {}\n                       (Skip@[Y +=\\<^sub>m AsmNoReadOrWrite]) ?\\<Gamma>'75\n                       ?\\<S>'75 ?P'75\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'75 ?\\<S>'75 ?P'75\n                       ((Skip@[Z +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Z \\<leftarrow> Load X) ;;\n                        (X \\<leftarrow> Load Y) ;;\n                        (Y \\<leftarrow> Load Z) ;;\n                        (control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule anno_type[OF HOL.refl HOL.refl HOL.refl])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno [X \\<mapsto> {Eq control_X 0}]\n                         ({control_Z, control_Y, control_X}, {X})\n                         (Y +=\\<^sub>m AsmNoReadOrWrite))\n                       (add_anno_stable\n                         ({control_Z, control_Y, control_X}, {X})\n                         (Y +=\\<^sub>m AsmNoReadOrWrite))\n                       (restrict_preds_to_vars {}\n                         {v. stable\n                              (add_anno_stable\n                                ({control_Z, control_Y, control_X}, {X})\n                                (Y +=\\<^sub>m AsmNoReadOrWrite))\n                              v})\n                       Skip ?\\<Gamma>'75 ?\\<S>'75 ?P'75\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total [X \\<mapsto> {Eq control_X 0}] x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable\n                                   ({control_Z, control_Y, control_X}, {X})\n                                   (Y +=\\<^sub>m AsmNoReadOrWrite))\n                                 v})\n                          (to_total\n                            (add_anno [X \\<mapsto> {Eq control_X 0}]\n                              ({control_Z, control_Y, control_X}, {X})\n                              (Y +=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable [X \\<mapsto> {Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {X})\n                       (Y +=\\<^sub>m AsmNoReadOrWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec [X \\<mapsto> {Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {X}) {}\n                       (Y +=\\<^sub>m AsmNoReadOrWrite)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'75 ?\\<S>'75 ?P'75\n                       ((Skip@[Z +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Z \\<leftarrow> Load X) ;;\n                        (X \\<leftarrow> Load Y) ;;\n                        (Y \\<leftarrow> Load Z) ;;\n                        (control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply clarsimp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}]\n                       ({control_Z, control_Y, control_X}, {Y, X}) {} Skip\n                       ?\\<Gamma>'75 ?\\<S>'75 ?P'75\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total [X \\<mapsto> {Eq control_X 0}] x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable\n                                   ({control_Z, control_Y, control_X}, {X})\n                                   (Y +=\\<^sub>m AsmNoReadOrWrite))\n                                 v})\n                          (to_total\n                            (add_anno [X \\<mapsto> {Eq control_X 0}]\n                              ({control_Z, control_Y, control_X}, {X})\n                              (Y +=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable [X \\<mapsto> {Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {X})\n                       (Y +=\\<^sub>m AsmNoReadOrWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec [X \\<mapsto> {Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {X}) {}\n                       (Y +=\\<^sub>m AsmNoReadOrWrite)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'75 ?\\<S>'75 ?P'75\n                       ((Skip@[Z +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Z \\<leftarrow> Load X) ;;\n                        (X \\<leftarrow> Load Y) ;;\n                        (Y \\<leftarrow> Load Z) ;;\n                        (control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule skip_type)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 2. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total [X \\<mapsto> {Eq control_X 0}] x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable\n                                   ({control_Z, control_Y, control_X}, {X})\n                                   (Y +=\\<^sub>m AsmNoReadOrWrite))\n                                 v})\n                          (to_total\n                            (add_anno [X \\<mapsto> {Eq control_X 0}]\n                              ({control_Z, control_Y, control_X}, {X})\n                              (Y +=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable [X \\<mapsto> {Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {X})\n                       (Y +=\\<^sub>m AsmNoReadOrWrite)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec [X \\<mapsto> {Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {X}) {}\n                       (Y +=\\<^sub>m AsmNoReadOrWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}]\n                       ({control_Z, control_Y, control_X}, {Y, X}) {}\n                       ((Skip@[Z +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Z \\<leftarrow> Load X) ;;\n                        (X \\<leftarrow> Load Y) ;;\n                        (Y \\<leftarrow> Load Z) ;;\n                        (control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(simp+)[4]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}]\n                       ({control_Z, control_Y, control_X}, {Y, X}) {}\n                       ((Skip@[Z +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Z \\<leftarrow> Load X) ;;\n                        (X \\<leftarrow> Load Y) ;;\n                        (Y \\<leftarrow> Load Z) ;;\n                        (control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule seq_type)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}]\n                       ({control_Z, control_Y, control_X}, {Y, X}) {}\n                       (Skip@[Z +=\\<^sub>m AsmNoReadOrWrite]) ?\\<Gamma>'96\n                       ?\\<S>'96 ?P'96\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'96 ?\\<S>'96 ?P'96\n                       ((Z \\<leftarrow> Load X) ;;\n                        (X \\<leftarrow> Load Y) ;;\n                        (Y \\<leftarrow> Load Z) ;;\n                        (control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule anno_type[OF HOL.refl HOL.refl HOL.refl])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno\n                         [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                          {Eq control_Y 0}]\n                         ({control_Z, control_Y, control_X}, {Y, X})\n                         (Z +=\\<^sub>m AsmNoReadOrWrite))\n                       (add_anno_stable\n                         ({control_Z, control_Y, control_X}, {Y, X})\n                         (Z +=\\<^sub>m AsmNoReadOrWrite))\n                       (restrict_preds_to_vars {}\n                         {v. stable\n                              (add_anno_stable\n                                ({control_Z, control_Y, control_X}, {Y, X})\n                                (Z +=\\<^sub>m AsmNoReadOrWrite))\n                              v})\n                       Skip ?\\<Gamma>'96 ?\\<S>'96 ?P'96\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype\n                          (to_total\n                            [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                             {Eq control_Y 0}]\n                            x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable\n                                   ({control_Z, control_Y, control_X},\n                                    {Y, X})\n                                   (Z +=\\<^sub>m AsmNoReadOrWrite))\n                                 v})\n                          (to_total\n                            (add_anno\n                              [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                               {Eq control_Y 0}]\n                              ({control_Z, control_Y, control_X}, {Y, X})\n                              (Z +=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}]\n                       ({control_Z, control_Y, control_X}, {Y, X})\n                       (Z +=\\<^sub>m AsmNoReadOrWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}]\n                       ({control_Z, control_Y, control_X}, {Y, X}) {}\n                       (Z +=\\<^sub>m AsmNoReadOrWrite)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'96 ?\\<S>'96 ?P'96\n                       ((Z \\<leftarrow> Load X) ;;\n                        (X \\<leftarrow> Load Y) ;;\n                        (Y \\<leftarrow> Load Z) ;;\n                        (control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply clarsimp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X}) {}\n                       Skip ?\\<Gamma>'96 ?\\<S>'96 ?P'96\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype\n                          (to_total\n                            [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                             {Eq control_Y 0}]\n                            x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable\n                                   ({control_Z, control_Y, control_X},\n                                    {Y, X})\n                                   (Z +=\\<^sub>m AsmNoReadOrWrite))\n                                 v})\n                          (to_total\n                            (add_anno\n                              [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                               {Eq control_Y 0}]\n                              ({control_Z, control_Y, control_X}, {Y, X})\n                              (Z +=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}]\n                       ({control_Z, control_Y, control_X}, {Y, X})\n                       (Z +=\\<^sub>m AsmNoReadOrWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}]\n                       ({control_Z, control_Y, control_X}, {Y, X}) {}\n                       (Z +=\\<^sub>m AsmNoReadOrWrite)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'96 ?\\<S>'96 ?P'96\n                       ((Z \\<leftarrow> Load X) ;;\n                        (X \\<leftarrow> Load Y) ;;\n                        (Y \\<leftarrow> Load Z) ;;\n                        (control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule skip_type)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 2. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype\n                          (to_total\n                            [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                             {Eq control_Y 0}]\n                            x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable\n                                   ({control_Z, control_Y, control_X},\n                                    {Y, X})\n                                   (Z +=\\<^sub>m AsmNoReadOrWrite))\n                                 v})\n                          (to_total\n                            (add_anno\n                              [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                               {Eq control_Y 0}]\n                              ({control_Z, control_Y, control_X}, {Y, X})\n                              (Z +=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}]\n                       ({control_Z, control_Y, control_X}, {Y, X})\n                       (Z +=\\<^sub>m AsmNoReadOrWrite)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}]\n                       ({control_Z, control_Y, control_X}, {Y, X}) {}\n                       (Z +=\\<^sub>m AsmNoReadOrWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X}) {}\n                       ((Z \\<leftarrow> Load X) ;;\n                        (X \\<leftarrow> Load Y) ;;\n                        (Y \\<leftarrow> Load Z) ;;\n                        (control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(simp+)[4]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X}) {}\n                       ((Z \\<leftarrow> Load X) ;;\n                        (X \\<leftarrow> Load Y) ;;\n                        (Y \\<leftarrow> Load Z) ;;\n                        (control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule seq_type)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X}) {}\n                       (Z \\<leftarrow> Load X) ?\\<Gamma>'117 ?\\<S>'117\n                       ?P'117\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'117 ?\\<S>'117 ?P'117\n                       ((X \\<leftarrow> Load Y) ;;\n                        (Y \\<leftarrow> Load Z) ;;\n                        (control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule assign\\<^sub>2[OF _ _ _ HOL.refl])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Z \\<in> dom [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                                   {Eq control_Y 0}, Z \\<mapsto>\n                                   {Eq control_Z 0}]\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}]\n                       (Load X) ?t120\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable\n                       ({control_Z, control_Y, control_X}, {Z, Y, X}) ?t120\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Z \\<notin> snd ({control_Z, control_Y, control_X},\n{Z, Y, X}) \\<longrightarrow>\n                      subtype ?t120\n                       (restrict_preds_to_vars (assign_post {} Z (Load X))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       (dma_type Z)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}, Z \n                        \\<mapsto> ?t120]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (restrict_preds_to_vars (assign_post {} Z (Load X))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       ((X \\<leftarrow> Load Y) ;;\n                        (Y \\<leftarrow> Load Z) ;;\n                        (control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}]\n                       (Load X) ?t120\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable\n                       ({control_Z, control_Y, control_X}, {Z, Y, X}) ?t120\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Z \\<notin> snd ({control_Z, control_Y, control_X},\n{Z, Y, X}) \\<longrightarrow>\n                      subtype ?t120\n                       (restrict_preds_to_vars (assign_post {} Z (Load X))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       (dma_type Z)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}, Z \n                        \\<mapsto> ?t120]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (restrict_preds_to_vars (assign_post {} Z (Load X))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       ((X \\<leftarrow> Load Y) ;;\n                        (Y \\<leftarrow> Load Z) ;;\n                        (control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule type_aexpr_Load')"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> X \\<in> dom [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                                   {Eq control_Y 0}, Z \\<mapsto>\n                                   {Eq control_Z 0}]\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?t120 =\n                      the ([X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                            {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}]\n                            X)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable\n                       ({control_Z, control_Y, control_X}, {Z, Y, X}) ?t120\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Z \\<notin> snd ({control_Z, control_Y, control_X},\n{Z, Y, X}) \\<longrightarrow>\n                      subtype ?t120\n                       (restrict_preds_to_vars (assign_post {} Z (Load X))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       (dma_type Z)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}, Z \n                        \\<mapsto> ?t120]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (restrict_preds_to_vars (assign_post {} Z (Load X))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       ((X \\<leftarrow> Load Y) ;;\n                        (Y \\<leftarrow> Load Z) ;;\n                        (control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(simp+)[4]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}, Z \n                        \\<mapsto> {Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (restrict_preds_to_vars (assign_post {} Z (Load X))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       ((X \\<leftarrow> Load Y) ;;\n                        (Y \\<leftarrow> Load Z) ;;\n                        (control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule seq_type)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}, Z \n                        \\<mapsto> {Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (restrict_preds_to_vars (assign_post {} Z (Load X))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       (X \\<leftarrow> Load Y) ?\\<Gamma>'135 ?\\<S>'135\n                       ?P'135\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'135 ?\\<S>'135 ?P'135\n                       ((Y \\<leftarrow> Load Z) ;;\n                        (control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule assign\\<^sub>2[OF _ _ _ HOL.refl])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> X \\<in> dom [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                                   {Eq control_Y 0}, Z \\<mapsto>\n                                   {Eq control_Z 0}, Z \\<mapsto>\n                                   {Eq control_X 0}]\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}, Z \n                        \\<mapsto> {Eq control_X 0}]\n                       (Load Y) ?t138\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable\n                       ({control_Z, control_Y, control_X}, {Z, Y, X}) ?t138\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> X \\<notin> snd ({control_Z, control_Y, control_X},\n{Z, Y, X}) \\<longrightarrow>\n                      subtype ?t138\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (restrict_preds_to_vars\n                             (assign_post {} Z (Load X))\n                             {v. stable\n                                  ({control_Z, control_Y, control_X},\n                                   {Z, Y, X})\n                                  v})\n                           X (Load Y))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       (dma_type X)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}, Z \n                        \\<mapsto> {Eq control_X 0}, X \\<mapsto> ?t138]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (restrict_preds_to_vars\n                             (assign_post {} Z (Load X))\n                             {v. stable\n                                  ({control_Z, control_Y, control_X},\n                                   {Z, Y, X})\n                                  v})\n                           X (Load Y))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       ((Y \\<leftarrow> Load Z) ;;\n                        (control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}, Z \n                        \\<mapsto> {Eq control_X 0}]\n                       (Load Y) ?t138\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable\n                       ({control_Z, control_Y, control_X}, {Z, Y, X}) ?t138\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> X \\<notin> snd ({control_Z, control_Y, control_X},\n{Z, Y, X}) \\<longrightarrow>\n                      subtype ?t138\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (restrict_preds_to_vars\n                             (assign_post {} Z (Load X))\n                             {v. stable\n                                  ({control_Z, control_Y, control_X},\n                                   {Z, Y, X})\n                                  v})\n                           X (Load Y))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       (dma_type X)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}, Z \n                        \\<mapsto> {Eq control_X 0}, X \\<mapsto> ?t138]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (restrict_preds_to_vars\n                             (assign_post {} Z (Load X))\n                             {v. stable\n                                  ({control_Z, control_Y, control_X},\n                                   {Z, Y, X})\n                                  v})\n                           X (Load Y))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       ((Y \\<leftarrow> Load Z) ;;\n                        (control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule type_aexpr_Load')"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Y \\<in> dom [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                                   {Eq control_Y 0}, Z \\<mapsto>\n                                   {Eq control_Z 0}, Z \\<mapsto>\n                                   {Eq control_X 0}]\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?t138 =\n                      the ([X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                            {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0},\n                            Z \\<mapsto> {Eq control_X 0}]\n                            Y)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable\n                       ({control_Z, control_Y, control_X}, {Z, Y, X}) ?t138\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> X \\<notin> snd ({control_Z, control_Y, control_X},\n{Z, Y, X}) \\<longrightarrow>\n                      subtype ?t138\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (restrict_preds_to_vars\n                             (assign_post {} Z (Load X))\n                             {v. stable\n                                  ({control_Z, control_Y, control_X},\n                                   {Z, Y, X})\n                                  v})\n                           X (Load Y))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       (dma_type X)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}, Z \n                        \\<mapsto> {Eq control_X 0}, X \\<mapsto> ?t138]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (restrict_preds_to_vars\n                             (assign_post {} Z (Load X))\n                             {v. stable\n                                  ({control_Z, control_Y, control_X},\n                                   {Z, Y, X})\n                                  v})\n                           X (Load Y))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       ((Y \\<leftarrow> Load Z) ;;\n                        (control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(simp+)[4]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}, Z \n                        \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                        {Eq control_Y 0}]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (restrict_preds_to_vars\n                             (assign_post {} Z (Load X))\n                             {v. stable\n                                  ({control_Z, control_Y, control_X},\n                                   {Z, Y, X})\n                                  v})\n                           X (Load Y))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       ((Y \\<leftarrow> Load Z) ;;\n                        (control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule seq_type)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}, Z \n                        \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                        {Eq control_Y 0}]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (restrict_preds_to_vars\n                             (assign_post {} Z (Load X))\n                             {v. stable\n                                  ({control_Z, control_Y, control_X},\n                                   {Z, Y, X})\n                                  v})\n                           X (Load Y))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       (Y \\<leftarrow> Load Z) ?\\<Gamma>'153 ?\\<S>'153\n                       ?P'153\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'153 ?\\<S>'153 ?P'153\n                       ((control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule assign\\<^sub>2[OF _ _ _ HOL.refl])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Y \\<in> dom [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                                   {Eq control_Y 0}, Z \\<mapsto>\n                                   {Eq control_Z 0}, Z \\<mapsto>\n                                   {Eq control_X 0}, X \\<mapsto>\n                                   {Eq control_Y 0}]\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}, Z \n                        \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                        {Eq control_Y 0}]\n                       (Load Z) ?t156\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable\n                       ({control_Z, control_Y, control_X}, {Z, Y, X}) ?t156\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Y \\<notin> snd ({control_Z, control_Y, control_X},\n{Z, Y, X}) \\<longrightarrow>\n                      subtype ?t156\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (restrict_preds_to_vars\n                             (assign_post\n                               (restrict_preds_to_vars\n                                 (assign_post {} Z (Load X))\n                                 {v. stable\n({control_Z, control_Y, control_X}, {Z, Y, X}) v})\n                               X (Load Y))\n                             {v. stable\n                                  ({control_Z, control_Y, control_X},\n                                   {Z, Y, X})\n                                  v})\n                           Y (Load Z))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       (dma_type Y)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}, Z \n                        \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                        {Eq control_Y 0}, Y \\<mapsto> ?t156]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (restrict_preds_to_vars\n                             (assign_post\n                               (restrict_preds_to_vars\n                                 (assign_post {} Z (Load X))\n                                 {v. stable\n({control_Z, control_Y, control_X}, {Z, Y, X}) v})\n                               X (Load Y))\n                             {v. stable\n                                  ({control_Z, control_Y, control_X},\n                                   {Z, Y, X})\n                                  v})\n                           Y (Load Z))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       ((control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}, Z \n                        \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                        {Eq control_Y 0}]\n                       (Load Z) ?t156\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable\n                       ({control_Z, control_Y, control_X}, {Z, Y, X}) ?t156\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Y \\<notin> snd ({control_Z, control_Y, control_X},\n{Z, Y, X}) \\<longrightarrow>\n                      subtype ?t156\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (restrict_preds_to_vars\n                             (assign_post\n                               (restrict_preds_to_vars\n                                 (assign_post {} Z (Load X))\n                                 {v. stable\n({control_Z, control_Y, control_X}, {Z, Y, X}) v})\n                               X (Load Y))\n                             {v. stable\n                                  ({control_Z, control_Y, control_X},\n                                   {Z, Y, X})\n                                  v})\n                           Y (Load Z))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       (dma_type Y)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}, Z \n                        \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                        {Eq control_Y 0}, Y \\<mapsto> ?t156]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (restrict_preds_to_vars\n                             (assign_post\n                               (restrict_preds_to_vars\n                                 (assign_post {} Z (Load X))\n                                 {v. stable\n({control_Z, control_Y, control_X}, {Z, Y, X}) v})\n                               X (Load Y))\n                             {v. stable\n                                  ({control_Z, control_Y, control_X},\n                                   {Z, Y, X})\n                                  v})\n                           Y (Load Z))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       ((control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule type_aexpr_Load')"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Z \\<in> dom [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                                   {Eq control_Y 0}, Z \\<mapsto>\n                                   {Eq control_Z 0}, Z \\<mapsto>\n                                   {Eq control_X 0}, X \\<mapsto>\n                                   {Eq control_Y 0}]\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?t156 =\n                      the ([X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                            {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0},\n                            Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                            {Eq control_Y 0}]\n                            Z)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable\n                       ({control_Z, control_Y, control_X}, {Z, Y, X}) ?t156\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Y \\<notin> snd ({control_Z, control_Y, control_X},\n{Z, Y, X}) \\<longrightarrow>\n                      subtype ?t156\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (restrict_preds_to_vars\n                             (assign_post\n                               (restrict_preds_to_vars\n                                 (assign_post {} Z (Load X))\n                                 {v. stable\n({control_Z, control_Y, control_X}, {Z, Y, X}) v})\n                               X (Load Y))\n                             {v. stable\n                                  ({control_Z, control_Y, control_X},\n                                   {Z, Y, X})\n                                  v})\n                           Y (Load Z))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       (dma_type Y)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}, Z \n                        \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                        {Eq control_Y 0}, Y \\<mapsto> ?t156]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (restrict_preds_to_vars\n                             (assign_post\n                               (restrict_preds_to_vars\n                                 (assign_post {} Z (Load X))\n                                 {v. stable\n({control_Z, control_Y, control_X}, {Z, Y, X}) v})\n                               X (Load Y))\n                             {v. stable\n                                  ({control_Z, control_Y, control_X},\n                                   {Z, Y, X})\n                                  v})\n                           Y (Load Z))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       ((control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(simp+)[4]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}, Z \n                        \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                        {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (restrict_preds_to_vars\n                             (assign_post\n                               (restrict_preds_to_vars\n                                 (assign_post {} Z (Load X))\n                                 {v. stable\n({control_Z, control_Y, control_X}, {Z, Y, X}) v})\n                               X (Load Y))\n                             {v. stable\n                                  ({control_Z, control_Y, control_X},\n                                   {Z, Y, X})\n                                  v})\n                           Y (Load Z))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       ((control_Z \\<leftarrow> Load control_X) ;;\n                        (control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule seq_type)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}, Z \n                        \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                        {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (restrict_preds_to_vars\n                             (assign_post\n                               (restrict_preds_to_vars\n                                 (assign_post {} Z (Load X))\n                                 {v. stable\n({control_Z, control_Y, control_X}, {Z, Y, X}) v})\n                               X (Load Y))\n                             {v. stable\n                                  ({control_Z, control_Y, control_X},\n                                   {Z, Y, X})\n                                  v})\n                           Y (Load Z))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       (control_Z \\<leftarrow> Load control_X) ?\\<Gamma>'171\n                       ?\\<S>'171 ?P'171\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'171 ?\\<S>'171 ?P'171\n                       ((control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule assign\\<^sub>\\<C>[OF _ _ _ _ HOL.refl])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> control_Z \\<in> \\<C>\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}, Z \n                        \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                        {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0}]\n                       (Load control_X) ?t174\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (restrict_preds_to_vars\n                             (assign_post\n                               (restrict_preds_to_vars\n                                 (assign_post {} Z (Load X))\n                                 {v. stable\n({control_Z, control_Y, control_X}, {Z, Y, X}) v})\n                               X (Load Y))\n                             {v. stable\n                                  ({control_Z, control_Y, control_X},\n                                   {Z, Y, X})\n                                  v})\n                           Y (Load Z))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       ?t174\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom\n[X \\<mapsto> {Eq control_X 0}, Y \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n {Eq control_Z 0}, Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0}].\n                         control_Z\n                         \\<notin> vars_of_type\n                                   (the ([X \\<mapsto> {Eq control_X 0}, Y \n    \\<mapsto> {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n    {Eq control_X 0}, X \\<mapsto> {Eq control_Y 0}, Y \\<mapsto>\n    {Eq control_X 0}]\n    v))\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         control_Z \\<in> \\<C>_vars v \\<and>\n                         v \\<notin> snd ({control_Z, control_Y, control_X},\n   {Z, Y, X}) \\<longrightarrow>\n                         pred_entailment\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (restrict_preds_to_vars\n                                (assign_post\n                                  (restrict_preds_to_vars\n                                    (assign_post {} Z (Load X))\n                                    {v. stable\n   ({control_Z, control_Y, control_X}, {Z, Y, X}) v})\n                                  X (Load Y))\n                                {v. stable\n                                     ({control_Z, control_Y, control_X},\n{Z, Y, X})\n                                     v})\n                              Y (Load Z))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X},\n                                  {Z, Y, X})\n                                 v})\n                          (to_total\n                            [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                             {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0},\n                             Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                             {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0}]\n                            v) \\<and>\n                         subtype\n                          (to_total\n                            [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                             {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0},\n                             Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                             {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0}]\n                            v)\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (restrict_preds_to_vars\n                                (assign_post\n                                  (restrict_preds_to_vars\n                                    (assign_post\n(restrict_preds_to_vars (assign_post {} Z (Load X))\n  {v. stable ({control_Z, control_Y, control_X}, {Z, Y, X}) v})\nX (Load Y))\n                                    {v. stable\n   ({control_Z, control_Y, control_X}, {Z, Y, X}) v})\n                                  Y (Load Z))\n                                {v. stable\n                                     ({control_Z, control_Y, control_X},\n{Z, Y, X})\n                                     v})\n                              control_Z (Load control_X))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X},\n                                  {Z, Y, X})\n                                 v})\n                          (dma_type v)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}, Z \n                        \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                        {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (restrict_preds_to_vars\n                             (assign_post\n                               (restrict_preds_to_vars\n                                 (assign_post\n                                   (restrict_preds_to_vars\n                                     (assign_post {} Z (Load X))\n                                     {v.\nstable ({control_Z, control_Y, control_X}, {Z, Y, X}) v})\n                                   X (Load Y))\n                                 {v. stable\n({control_Z, control_Y, control_X}, {Z, Y, X}) v})\n                               Y (Load Z))\n                             {v. stable\n                                  ({control_Z, control_Y, control_X},\n                                   {Z, Y, X})\n                                  v})\n                           control_Z (Load control_X))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       ((control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}, Z \n                        \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                        {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0}]\n                       (Load control_X) ?t174\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (restrict_preds_to_vars\n                             (assign_post\n                               (restrict_preds_to_vars\n                                 (assign_post {} Z (Load X))\n                                 {v. stable\n({control_Z, control_Y, control_X}, {Z, Y, X}) v})\n                               X (Load Y))\n                             {v. stable\n                                  ({control_Z, control_Y, control_X},\n                                   {Z, Y, X})\n                                  v})\n                           Y (Load Z))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       ?t174\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom\n[X \\<mapsto> {Eq control_X 0}, Y \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n {Eq control_Z 0}, Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0}].\n                         control_Z\n                         \\<notin> vars_of_type\n                                   (the ([X \\<mapsto> {Eq control_X 0}, Y \n    \\<mapsto> {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n    {Eq control_X 0}, X \\<mapsto> {Eq control_Y 0}, Y \\<mapsto>\n    {Eq control_X 0}]\n    v))\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         control_Z \\<in> \\<C>_vars v \\<and>\n                         v \\<notin> snd ({control_Z, control_Y, control_X},\n   {Z, Y, X}) \\<longrightarrow>\n                         pred_entailment\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (restrict_preds_to_vars\n                                (assign_post\n                                  (restrict_preds_to_vars\n                                    (assign_post {} Z (Load X))\n                                    {v. stable\n   ({control_Z, control_Y, control_X}, {Z, Y, X}) v})\n                                  X (Load Y))\n                                {v. stable\n                                     ({control_Z, control_Y, control_X},\n{Z, Y, X})\n                                     v})\n                              Y (Load Z))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X},\n                                  {Z, Y, X})\n                                 v})\n                          (to_total\n                            [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                             {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0},\n                             Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                             {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0}]\n                            v) \\<and>\n                         subtype\n                          (to_total\n                            [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                             {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0},\n                             Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                             {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0}]\n                            v)\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (restrict_preds_to_vars\n                                (assign_post\n                                  (restrict_preds_to_vars\n                                    (assign_post\n(restrict_preds_to_vars (assign_post {} Z (Load X))\n  {v. stable ({control_Z, control_Y, control_X}, {Z, Y, X}) v})\nX (Load Y))\n                                    {v. stable\n   ({control_Z, control_Y, control_X}, {Z, Y, X}) v})\n                                  Y (Load Z))\n                                {v. stable\n                                     ({control_Z, control_Y, control_X},\n{Z, Y, X})\n                                     v})\n                              control_Z (Load control_X))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X},\n                                  {Z, Y, X})\n                                 v})\n                          (dma_type v)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}, Z \n                        \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                        {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (restrict_preds_to_vars\n                             (assign_post\n                               (restrict_preds_to_vars\n                                 (assign_post\n                                   (restrict_preds_to_vars\n                                     (assign_post {} Z (Load X))\n                                     {v.\nstable ({control_Z, control_Y, control_X}, {Z, Y, X}) v})\n                                   X (Load Y))\n                                 {v. stable\n({control_Z, control_Y, control_X}, {Z, Y, X}) v})\n                               Y (Load Z))\n                             {v. stable\n                                  ({control_Z, control_Y, control_X},\n                                   {Z, Y, X})\n                                  v})\n                           control_Z (Load control_X))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       ((control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule type_aexpr_Load)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> control_X\n                      \\<notin> dom [X \\<mapsto> {Eq control_X 0}, Y \n                                    \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                                    {Eq control_Z 0}, Z \\<mapsto>\n                                    {Eq control_X 0}, X \\<mapsto>\n                                    {Eq control_Y 0}, Y \\<mapsto>\n                                    {Eq control_X 0}]\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (restrict_preds_to_vars\n                             (assign_post\n                               (restrict_preds_to_vars\n                                 (assign_post {} Z (Load X))\n                                 {v. stable\n({control_Z, control_Y, control_X}, {Z, Y, X}) v})\n                               X (Load Y))\n                             {v. stable\n                                  ({control_Z, control_Y, control_X},\n                                   {Z, Y, X})\n                                  v})\n                           Y (Load Z))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       (dma_type control_X)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom\n[X \\<mapsto> {Eq control_X 0}, Y \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n {Eq control_Z 0}, Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0}].\n                         control_Z\n                         \\<notin> vars_of_type\n                                   (the ([X \\<mapsto> {Eq control_X 0}, Y \n    \\<mapsto> {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n    {Eq control_X 0}, X \\<mapsto> {Eq control_Y 0}, Y \\<mapsto>\n    {Eq control_X 0}]\n    v))\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         control_Z \\<in> \\<C>_vars v \\<and>\n                         v \\<notin> snd ({control_Z, control_Y, control_X},\n   {Z, Y, X}) \\<longrightarrow>\n                         pred_entailment\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (restrict_preds_to_vars\n                                (assign_post\n                                  (restrict_preds_to_vars\n                                    (assign_post {} Z (Load X))\n                                    {v. stable\n   ({control_Z, control_Y, control_X}, {Z, Y, X}) v})\n                                  X (Load Y))\n                                {v. stable\n                                     ({control_Z, control_Y, control_X},\n{Z, Y, X})\n                                     v})\n                              Y (Load Z))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X},\n                                  {Z, Y, X})\n                                 v})\n                          (to_total\n                            [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                             {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0},\n                             Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                             {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0}]\n                            v) \\<and>\n                         subtype\n                          (to_total\n                            [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                             {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0},\n                             Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                             {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0}]\n                            v)\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (restrict_preds_to_vars\n                                (assign_post\n                                  (restrict_preds_to_vars\n                                    (assign_post\n(restrict_preds_to_vars (assign_post {} Z (Load X))\n  {v. stable ({control_Z, control_Y, control_X}, {Z, Y, X}) v})\nX (Load Y))\n                                    {v. stable\n   ({control_Z, control_Y, control_X}, {Z, Y, X}) v})\n                                  Y (Load Z))\n                                {v. stable\n                                     ({control_Z, control_Y, control_X},\n{Z, Y, X})\n                                     v})\n                              control_Z (Load control_X))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X},\n                                  {Z, Y, X})\n                                 v})\n                          (dma_type v)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}, Z \n                        \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                        {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (restrict_preds_to_vars\n                             (assign_post\n                               (restrict_preds_to_vars\n                                 (assign_post\n                                   (restrict_preds_to_vars\n                                     (assign_post {} Z (Load X))\n                                     {v.\nstable ({control_Z, control_Y, control_X}, {Z, Y, X}) v})\n                                   X (Load Y))\n                                 {v. stable\n({control_Z, control_Y, control_X}, {Z, Y, X}) v})\n                               Y (Load Z))\n                             {v. stable\n                                  ({control_Z, control_Y, control_X},\n                                   {Z, Y, X})\n                                  v})\n                           control_Z (Load control_X))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       ((control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply (simp+)[4]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}, Z \n                        \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                        {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (restrict_preds_to_vars\n                             (assign_post\n                               (restrict_preds_to_vars\n                                 (assign_post\n                                   (restrict_preds_to_vars\n                                     (assign_post {} Z (Load X))\n                                     {v.\nstable ({control_Z, control_Y, control_X}, {Z, Y, X}) v})\n                                   X (Load Y))\n                                 {v. stable\n({control_Z, control_Y, control_X}, {Z, Y, X}) v})\n                               Y (Load Z))\n                             {v. stable\n                                  ({control_Z, control_Y, control_X},\n                                   {Z, Y, X})\n                                  v})\n                           control_Z (Load control_X))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       ((control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                        {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       {Same control_Z (Load control_X), Same Y (Load Z)}\n                       ((control_X \\<leftarrow> Load control_Y) ;;\n                        (control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule seq_type)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                        {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       {Same control_Z (Load control_X), Same Y (Load Z)}\n                       (control_X \\<leftarrow> Load control_Y) ?\\<Gamma>'196\n                       ?\\<S>'196 ?P'196\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'196 ?\\<S>'196 ?P'196\n                       ((control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule conc'[where x=\"Z\" and t=\"dma_type Z\", OF _ HOL.refl])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                        {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0}, Z \n                        \\<mapsto> dma_type Z]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       {Same control_Z (Load control_X), Same Y (Load Z)}\n                       (control_X \\<leftarrow> Load control_Y) ?\\<Gamma>'196\n                       ?\\<S>'196 ?P'196\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Z \\<in> dom [Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                                   {Eq control_Y 0}, Y \\<mapsto>\n                                   {Eq control_X 0}]\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_equiv\n                       (the ([Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                              {Eq control_Y 0}, Y \\<mapsto>\n                              {Eq control_X 0}]\n                              Z))\n                       {Same control_Z (Load control_X), Same Y (Load Z)}\n                       (dma_type Z)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_wellformed (dma_type Z)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (dma_type Z)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'196 ?\\<S>'196 ?P'196\n                       ((control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule conc'[where x=Y and t=\"dma_type Z\", OF _ HOL.refl])"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                        {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0}, Z \n                        \\<mapsto> dma_type Z, Y \\<mapsto> dma_type Z]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       {Same control_Z (Load control_X), Same Y (Load Z)}\n                       (control_X \\<leftarrow> Load control_Y) ?\\<Gamma>'196\n                       ?\\<S>'196 ?P'196\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Y \\<in> dom [Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                                   {Eq control_Y 0}, Y \\<mapsto>\n                                   {Eq control_X 0}, Z \\<mapsto> dma_type Z]\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_equiv\n                       (the ([Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                              {Eq control_Y 0}, Y \\<mapsto>\n                              {Eq control_X 0}, Z \\<mapsto> dma_type Z]\n                              Y))\n                       {Same control_Z (Load control_X), Same Y (Load Z)}\n                       (dma_type Z)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_wellformed (dma_type Z)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (dma_type Z)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Z \\<in> dom [Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                                   {Eq control_Y 0}, Y \\<mapsto>\n                                   {Eq control_X 0}]\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_equiv\n                       (the ([Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                              {Eq control_Y 0}, Y \\<mapsto>\n                              {Eq control_X 0}]\n                              Z))\n                       {Same control_Z (Load control_X), Same Y (Load Z)}\n                       (dma_type Z)\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_wellformed (dma_type Z)\n 9. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (dma_type Z)\n 10. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n     \\<Longrightarrow> has_type ?\\<Gamma>'196 ?\\<S>'196 ?P'196\n                        ((control_Y \\<leftarrow> Load control_Z) ;;\n                         (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                         (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                         (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                         (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                         (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                         (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                        ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule assign\\<^sub>\\<C>[OF _ _ _ _ HOL.refl])"], ["proof (prove)\ngoal (14 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> control_X \\<in> \\<C>\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr\n                       [Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                        {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0}, Z \n                        \\<mapsto> dma_type Z, Y \\<mapsto> dma_type Z]\n                       (Load control_Y) ?t215\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       {Same control_Z (Load control_X), Same Y (Load Z)}\n                       ?t215\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom\n[Z \\<mapsto> {Eq control_X 0}, X \\<mapsto> {Eq control_Y 0}, Y \\<mapsto>\n {Eq control_X 0}, Z \\<mapsto> dma_type Z, Y \\<mapsto> dma_type Z].\n                         control_X\n                         \\<notin> vars_of_type\n                                   (the ([Z \\<mapsto> {Eq control_X 0}, X \n    \\<mapsto> {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0}, Z \\<mapsto>\n    dma_type Z, Y \\<mapsto> dma_type Z]\n    v))\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         control_X \\<in> \\<C>_vars v \\<and>\n                         v \\<notin> snd ({control_Z, control_Y, control_X},\n   {Z, Y, X}) \\<longrightarrow>\n                         pred_entailment\n                          {Same control_Z (Load control_X), Same Y (Load Z)}\n                          (to_total\n                            [Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                             {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0},\n                             Z \\<mapsto> dma_type Z, Y \\<mapsto> dma_type Z]\n                            v) \\<and>\n                         subtype\n                          (to_total\n                            [Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                             {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0},\n                             Z \\<mapsto> dma_type Z, Y \\<mapsto> dma_type Z]\n                            v)\n                          (restrict_preds_to_vars\n                            (assign_post\n                              {Same control_Z (Load control_X),\n                               Same Y (Load Z)}\n                              control_X (Load control_Y))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X},\n                                  {Z, Y, X})\n                                 v})\n                          (dma_type v)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Y \\<in> dom [Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                                   {Eq control_Y 0}, Y \\<mapsto>\n                                   {Eq control_X 0}, Z \\<mapsto> dma_type Z]\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_equiv\n                       (the ([Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                              {Eq control_Y 0}, Y \\<mapsto>\n                              {Eq control_X 0}, Z \\<mapsto> dma_type Z]\n                              Y))\n                       {Same control_Z (Load control_X), Same Y (Load Z)}\n                       (dma_type Z)\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_wellformed (dma_type Z)\n 9. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (dma_type Z)\n 10. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n     \\<Longrightarrow> Z \\<in> dom [Z \\<mapsto> {Eq control_X 0}, X \n                                    \\<mapsto> {Eq control_Y 0}, Y \\<mapsto>\n                                    {Eq control_X 0}]\nA total of 14 subgoals...", "apply simp"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr\n                       [Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                        {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0}, Z \n                        \\<mapsto> dma_type Z, Y \\<mapsto> dma_type Z]\n                       (Load control_Y) ?t215\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       {Same control_Z (Load control_X), Same Y (Load Z)}\n                       ?t215\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom\n[Z \\<mapsto> {Eq control_X 0}, X \\<mapsto> {Eq control_Y 0}, Y \\<mapsto>\n {Eq control_X 0}, Z \\<mapsto> dma_type Z, Y \\<mapsto> dma_type Z].\n                         control_X\n                         \\<notin> vars_of_type\n                                   (the ([Z \\<mapsto> {Eq control_X 0}, X \n    \\<mapsto> {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0}, Z \\<mapsto>\n    dma_type Z, Y \\<mapsto> dma_type Z]\n    v))\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         control_X \\<in> \\<C>_vars v \\<and>\n                         v \\<notin> snd ({control_Z, control_Y, control_X},\n   {Z, Y, X}) \\<longrightarrow>\n                         pred_entailment\n                          {Same control_Z (Load control_X), Same Y (Load Z)}\n                          (to_total\n                            [Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                             {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0},\n                             Z \\<mapsto> dma_type Z, Y \\<mapsto> dma_type Z]\n                            v) \\<and>\n                         subtype\n                          (to_total\n                            [Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                             {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0},\n                             Z \\<mapsto> dma_type Z, Y \\<mapsto> dma_type Z]\n                            v)\n                          (restrict_preds_to_vars\n                            (assign_post\n                              {Same control_Z (Load control_X),\n                               Same Y (Load Z)}\n                              control_X (Load control_Y))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X},\n                                  {Z, Y, X})\n                                 v})\n                          (dma_type v)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Y \\<in> dom [Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                                   {Eq control_Y 0}, Y \\<mapsto>\n                                   {Eq control_X 0}, Z \\<mapsto> dma_type Z]\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_equiv\n                       (the ([Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                              {Eq control_Y 0}, Y \\<mapsto>\n                              {Eq control_X 0}, Z \\<mapsto> dma_type Z]\n                              Y))\n                       {Same control_Z (Load control_X), Same Y (Load Z)}\n                       (dma_type Z)\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_wellformed (dma_type Z)\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (dma_type Z)\n 9. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Z \\<in> dom [Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                                   {Eq control_Y 0}, Y \\<mapsto>\n                                   {Eq control_X 0}]\n 10. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n     \\<Longrightarrow> type_equiv\n                        (the ([Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                               {Eq control_Y 0}, Y \\<mapsto>\n                               {Eq control_X 0}]\n                               Z))\n                        {Same control_Z (Load control_X), Same Y (Load Z)}\n                        (dma_type Z)\nA total of 13 subgoals...", "apply(rule type_aexpr_Load)"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> control_Y\n                      \\<notin> dom [Z \\<mapsto> {Eq control_X 0}, X \n                                    \\<mapsto> {Eq control_Y 0}, Y \\<mapsto>\n                                    {Eq control_X 0}, Z \\<mapsto>\n                                    dma_type Z, Y \\<mapsto> dma_type Z]\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       {Same control_Z (Load control_X), Same Y (Load Z)}\n                       (dma_type control_Y)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom\n[Z \\<mapsto> {Eq control_X 0}, X \\<mapsto> {Eq control_Y 0}, Y \\<mapsto>\n {Eq control_X 0}, Z \\<mapsto> dma_type Z, Y \\<mapsto> dma_type Z].\n                         control_X\n                         \\<notin> vars_of_type\n                                   (the ([Z \\<mapsto> {Eq control_X 0}, X \n    \\<mapsto> {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0}, Z \\<mapsto>\n    dma_type Z, Y \\<mapsto> dma_type Z]\n    v))\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         control_X \\<in> \\<C>_vars v \\<and>\n                         v \\<notin> snd ({control_Z, control_Y, control_X},\n   {Z, Y, X}) \\<longrightarrow>\n                         pred_entailment\n                          {Same control_Z (Load control_X), Same Y (Load Z)}\n                          (to_total\n                            [Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                             {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0},\n                             Z \\<mapsto> dma_type Z, Y \\<mapsto> dma_type Z]\n                            v) \\<and>\n                         subtype\n                          (to_total\n                            [Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                             {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0},\n                             Z \\<mapsto> dma_type Z, Y \\<mapsto> dma_type Z]\n                            v)\n                          (restrict_preds_to_vars\n                            (assign_post\n                              {Same control_Z (Load control_X),\n                               Same Y (Load Z)}\n                              control_X (Load control_Y))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X},\n                                  {Z, Y, X})\n                                 v})\n                          (dma_type v)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Y \\<in> dom [Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                                   {Eq control_Y 0}, Y \\<mapsto>\n                                   {Eq control_X 0}, Z \\<mapsto> dma_type Z]\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_equiv\n                       (the ([Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                              {Eq control_Y 0}, Y \\<mapsto>\n                              {Eq control_X 0}, Z \\<mapsto> dma_type Z]\n                              Y))\n                       {Same control_Z (Load control_X), Same Y (Load Z)}\n                       (dma_type Z)\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_wellformed (dma_type Z)\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (dma_type Z)\n 9. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Z \\<in> dom [Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                                   {Eq control_Y 0}, Y \\<mapsto>\n                                   {Eq control_X 0}]\n 10. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n     \\<Longrightarrow> type_equiv\n                        (the ([Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                               {Eq control_Y 0}, Y \\<mapsto>\n                               {Eq control_X 0}]\n                               Z))\n                        {Same control_Z (Load control_X), Same Y (Load Z)}\n                        (dma_type Z)\nA total of 13 subgoals...", "apply simp+"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_equiv {Eq control_X 0}\n                       {Same control_Z (Load control_X), Same Y (Load Z)}\n                       {Eq control_Z 0}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_wellformed (dma_type Z)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (dma_type Z)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Z \\<in> dom [Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                                   {Eq control_Y 0}, Y \\<mapsto>\n                                   {Eq control_X 0}]\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_equiv\n                       (the ([Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                              {Eq control_Y 0}, Y \\<mapsto>\n                              {Eq control_X 0}]\n                              Z))\n                       {Same control_Z (Load control_X), Same Y (Load Z)}\n                       (dma_type Z)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_wellformed (dma_type Z)\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (dma_type Z)\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                        {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0}, Z \n                        \\<mapsto> dma_type Z, Y \\<mapsto> dma_type Z]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (restrict_preds_to_vars\n                         (assign_post\n                           {Same control_Z (Load control_X),\n                            Same Y (Load Z)}\n                           control_X (Load control_Y))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       ((control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(clarsimp simp: type_equiv_def subtype_def pred_entailment_def pred_def)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_wellformed (dma_type Z)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (dma_type Z)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Z \\<in> dom [Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                                   {Eq control_Y 0}, Y \\<mapsto>\n                                   {Eq control_X 0}]\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_equiv\n                       (the ([Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                              {Eq control_Y 0}, Y \\<mapsto>\n                              {Eq control_X 0}]\n                              Z))\n                       {Same control_Z (Load control_X), Same Y (Load Z)}\n                       (dma_type Z)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_wellformed (dma_type Z)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (dma_type Z)\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                        {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0}, Z \n                        \\<mapsto> dma_type Z, Y \\<mapsto> dma_type Z]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (restrict_preds_to_vars\n                         (assign_post\n                           {Same control_Z (Load control_X),\n                            Same Y (Load Z)}\n                           control_X (Load control_Y))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       ((control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(fastforce simp: type_wellformed_def)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (dma_type Z)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Z \\<in> dom [Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                                   {Eq control_Y 0}, Y \\<mapsto>\n                                   {Eq control_X 0}]\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_equiv\n                       (the ([Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                              {Eq control_Y 0}, Y \\<mapsto>\n                              {Eq control_X 0}]\n                              Z))\n                       {Same control_Z (Load control_X), Same Y (Load Z)}\n                       (dma_type Z)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_wellformed (dma_type Z)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (dma_type Z)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                        {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0}, Z \n                        \\<mapsto> dma_type Z, Y \\<mapsto> dma_type Z]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (restrict_preds_to_vars\n                         (assign_post\n                           {Same control_Z (Load control_X),\n                            Same Y (Load Z)}\n                           control_X (Load control_Y))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       ((control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Z \\<in> dom [Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                                   {Eq control_Y 0}, Y \\<mapsto>\n                                   {Eq control_X 0}]\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_equiv\n                       (the ([Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                              {Eq control_Y 0}, Y \\<mapsto>\n                              {Eq control_X 0}]\n                              Z))\n                       {Same control_Z (Load control_X), Same Y (Load Z)}\n                       (dma_type Z)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_wellformed (dma_type Z)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (dma_type Z)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                        {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0}, Z \n                        \\<mapsto> dma_type Z, Y \\<mapsto> dma_type Z]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (restrict_preds_to_vars\n                         (assign_post\n                           {Same control_Z (Load control_X),\n                            Same Y (Load Z)}\n                           control_X (Load control_Y))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       ((control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_equiv\n                       (the ([Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                              {Eq control_Y 0}, Y \\<mapsto>\n                              {Eq control_X 0}]\n                              Z))\n                       {Same control_Z (Load control_X), Same Y (Load Z)}\n                       (dma_type Z)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_wellformed (dma_type Z)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (dma_type Z)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                        {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0}, Z \n                        \\<mapsto> dma_type Z, Y \\<mapsto> dma_type Z]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (restrict_preds_to_vars\n                         (assign_post\n                           {Same control_Z (Load control_X),\n                            Same Y (Load Z)}\n                           control_X (Load control_Y))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       ((control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(clarsimp simp: type_equiv_def subtype_def pred_entailment_def pred_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_wellformed (dma_type Z)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (dma_type Z)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                        {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0}, Z \n                        \\<mapsto> dma_type Z, Y \\<mapsto> dma_type Z]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (restrict_preds_to_vars\n                         (assign_post\n                           {Same control_Z (Load control_X),\n                            Same Y (Load Z)}\n                           control_X (Load control_Y))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       ((control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(fastforce simp: type_wellformed_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (dma_type Z)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                        {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0}, Z \n                        \\<mapsto> dma_type Z, Y \\<mapsto> dma_type Z]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (restrict_preds_to_vars\n                         (assign_post\n                           {Same control_Z (Load control_X),\n                            Same Y (Load Z)}\n                           control_X (Load control_Y))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       ((control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                        {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0}, Z \n                        \\<mapsto> dma_type Z, Y \\<mapsto> dma_type Z]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (restrict_preds_to_vars\n                         (assign_post\n                           {Same control_Z (Load control_X),\n                            Same Y (Load Z)}\n                           control_X (Load control_Y))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       ((control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                        {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0}]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       {Same control_X (Load control_Y), Same Y (Load Z)}\n                       ((control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule seq_type)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                        {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0}]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       {Same control_X (Load control_Y), Same Y (Load Z)}\n                       (control_Y \\<leftarrow> Load control_Z) ?\\<Gamma>'239\n                       ?\\<S>'239 ?P'239\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'239 ?\\<S>'239 ?P'239\n                       ((Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule conc'[where x=X and t=\"dma_type X\" , OF _ HOL.refl])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                        {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0}, X \n                        \\<mapsto> dma_type X]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       {Same control_X (Load control_Y), Same Y (Load Z)}\n                       (control_Y \\<leftarrow> Load control_Z) ?\\<Gamma>'239\n                       ?\\<S>'239 ?P'239\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> X \\<in> dom [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                                   {Eq control_Z 0}, Y \\<mapsto>\n                                   {Eq control_Z 0}]\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_equiv\n                       (the ([X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                              {Eq control_Z 0}, Y \\<mapsto>\n                              {Eq control_Z 0}]\n                              X))\n                       {Same control_X (Load control_Y), Same Y (Load Z)}\n                       (dma_type X)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_wellformed (dma_type X)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (dma_type X)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'239 ?\\<S>'239 ?P'239\n                       ((Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule assign\\<^sub>\\<C>[OF _ _ _ _ HOL.refl])"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> control_Y \\<in> \\<C>\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr\n                       [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                        {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0}, X \n                        \\<mapsto> dma_type X]\n                       (Load control_Z) ?t250\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       {Same control_X (Load control_Y), Same Y (Load Z)}\n                       ?t250\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom\n[X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}, Y \\<mapsto>\n {Eq control_Z 0}, X \\<mapsto> dma_type X].\n                         control_Y\n                         \\<notin> vars_of_type\n                                   (the ([X \\<mapsto> {Eq control_Y 0}, Z \n    \\<mapsto> {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0}, X \\<mapsto>\n    dma_type X]\n    v))\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         control_Y \\<in> \\<C>_vars v \\<and>\n                         v \\<notin> snd ({control_Z, control_Y, control_X},\n   {Z, Y, X}) \\<longrightarrow>\n                         pred_entailment\n                          {Same control_X (Load control_Y), Same Y (Load Z)}\n                          (to_total\n                            [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                             {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0},\n                             X \\<mapsto> dma_type X]\n                            v) \\<and>\n                         subtype\n                          (to_total\n                            [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                             {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0},\n                             X \\<mapsto> dma_type X]\n                            v)\n                          (restrict_preds_to_vars\n                            (assign_post\n                              {Same control_X (Load control_Y),\n                               Same Y (Load Z)}\n                              control_Y (Load control_Z))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X},\n                                  {Z, Y, X})\n                                 v})\n                          (dma_type v)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> X \\<in> dom [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                                   {Eq control_Z 0}, Y \\<mapsto>\n                                   {Eq control_Z 0}]\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_equiv\n                       (the ([X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                              {Eq control_Z 0}, Y \\<mapsto>\n                              {Eq control_Z 0}]\n                              X))\n                       {Same control_X (Load control_Y), Same Y (Load Z)}\n                       (dma_type X)\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_wellformed (dma_type X)\n 9. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (dma_type X)\n 10. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n     \\<Longrightarrow> has_type\n                        [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                         {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0}, X \n                         \\<mapsto> dma_type X]\n                        ({control_Z, control_Y, control_X}, {Z, Y, X})\n                        (restrict_preds_to_vars\n                          (assign_post\n                            {Same control_X (Load control_Y),\n                             Same Y (Load Z)}\n                            control_Y (Load control_Z))\n                          {v. stable\n                               ({control_Z, control_Y, control_X},\n                                {Z, Y, X})\n                               v})\n                        ((Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                         (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                         (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                         (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                         (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                         (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                        ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr\n                       [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                        {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0}, X \n                        \\<mapsto> dma_type X]\n                       (Load control_Z) ?t250\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       {Same control_X (Load control_Y), Same Y (Load Z)}\n                       ?t250\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom\n[X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}, Y \\<mapsto>\n {Eq control_Z 0}, X \\<mapsto> dma_type X].\n                         control_Y\n                         \\<notin> vars_of_type\n                                   (the ([X \\<mapsto> {Eq control_Y 0}, Z \n    \\<mapsto> {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0}, X \\<mapsto>\n    dma_type X]\n    v))\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         control_Y \\<in> \\<C>_vars v \\<and>\n                         v \\<notin> snd ({control_Z, control_Y, control_X},\n   {Z, Y, X}) \\<longrightarrow>\n                         pred_entailment\n                          {Same control_X (Load control_Y), Same Y (Load Z)}\n                          (to_total\n                            [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                             {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0},\n                             X \\<mapsto> dma_type X]\n                            v) \\<and>\n                         subtype\n                          (to_total\n                            [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                             {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0},\n                             X \\<mapsto> dma_type X]\n                            v)\n                          (restrict_preds_to_vars\n                            (assign_post\n                              {Same control_X (Load control_Y),\n                               Same Y (Load Z)}\n                              control_Y (Load control_Z))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X},\n                                  {Z, Y, X})\n                                 v})\n                          (dma_type v)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> X \\<in> dom [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                                   {Eq control_Z 0}, Y \\<mapsto>\n                                   {Eq control_Z 0}]\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_equiv\n                       (the ([X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                              {Eq control_Z 0}, Y \\<mapsto>\n                              {Eq control_Z 0}]\n                              X))\n                       {Same control_X (Load control_Y), Same Y (Load Z)}\n                       (dma_type X)\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_wellformed (dma_type X)\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (dma_type X)\n 9. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                        {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0}, X \n                        \\<mapsto> dma_type X]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (restrict_preds_to_vars\n                         (assign_post\n                           {Same control_X (Load control_Y),\n                            Same Y (Load Z)}\n                           control_Y (Load control_Z))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       ((Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule type_aexpr_Load)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> control_Z\n                      \\<notin> dom [X \\<mapsto> {Eq control_Y 0}, Z \n                                    \\<mapsto> {Eq control_Z 0}, Y \\<mapsto>\n                                    {Eq control_Z 0}, X \\<mapsto>\n                                    dma_type X]\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       {Same control_X (Load control_Y), Same Y (Load Z)}\n                       (dma_type control_Z)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom\n[X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}, Y \\<mapsto>\n {Eq control_Z 0}, X \\<mapsto> dma_type X].\n                         control_Y\n                         \\<notin> vars_of_type\n                                   (the ([X \\<mapsto> {Eq control_Y 0}, Z \n    \\<mapsto> {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0}, X \\<mapsto>\n    dma_type X]\n    v))\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         control_Y \\<in> \\<C>_vars v \\<and>\n                         v \\<notin> snd ({control_Z, control_Y, control_X},\n   {Z, Y, X}) \\<longrightarrow>\n                         pred_entailment\n                          {Same control_X (Load control_Y), Same Y (Load Z)}\n                          (to_total\n                            [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                             {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0},\n                             X \\<mapsto> dma_type X]\n                            v) \\<and>\n                         subtype\n                          (to_total\n                            [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                             {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0},\n                             X \\<mapsto> dma_type X]\n                            v)\n                          (restrict_preds_to_vars\n                            (assign_post\n                              {Same control_X (Load control_Y),\n                               Same Y (Load Z)}\n                              control_Y (Load control_Z))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X},\n                                  {Z, Y, X})\n                                 v})\n                          (dma_type v)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> X \\<in> dom [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                                   {Eq control_Z 0}, Y \\<mapsto>\n                                   {Eq control_Z 0}]\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_equiv\n                       (the ([X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                              {Eq control_Z 0}, Y \\<mapsto>\n                              {Eq control_Z 0}]\n                              X))\n                       {Same control_X (Load control_Y), Same Y (Load Z)}\n                       (dma_type X)\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_wellformed (dma_type X)\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (dma_type X)\n 9. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                        {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0}, X \n                        \\<mapsto> dma_type X]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (restrict_preds_to_vars\n                         (assign_post\n                           {Same control_X (Load control_Y),\n                            Same Y (Load Z)}\n                           control_Y (Load control_Z))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       ((Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp+"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_equiv {Eq control_Y 0}\n                       {Same control_X (Load control_Y), Same Y (Load Z)}\n                       {Eq control_X 0}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_wellformed (dma_type X)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (dma_type X)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                        {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0}, X \n                        \\<mapsto> dma_type X]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (restrict_preds_to_vars\n                         (assign_post\n                           {Same control_X (Load control_Y),\n                            Same Y (Load Z)}\n                           control_Y (Load control_Z))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       ((Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(clarsimp simp: type_equiv_def subtype_def pred_entailment_def pred_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_wellformed (dma_type X)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (dma_type X)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                        {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0}, X \n                        \\<mapsto> dma_type X]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (restrict_preds_to_vars\n                         (assign_post\n                           {Same control_X (Load control_Y),\n                            Same Y (Load Z)}\n                           control_Y (Load control_Z))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       ((Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(clarsimp simp: type_wellformed_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (dma_type X)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                        {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0}, X \n                        \\<mapsto> dma_type X]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (restrict_preds_to_vars\n                         (assign_post\n                           {Same control_X (Load control_Y),\n                            Same Y (Load Z)}\n                           control_Y (Load control_Z))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       ((Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                        {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0}, X \n                        \\<mapsto> dma_type X]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (restrict_preds_to_vars\n                         (assign_post\n                           {Same control_X (Load control_Y),\n                            Same Y (Load Z)}\n                           control_Y (Load control_Z))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       ((Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule seq_type)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                        {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0}, X \n                        \\<mapsto> dma_type X]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (restrict_preds_to_vars\n                         (assign_post\n                           {Same control_X (Load control_Y),\n                            Same Y (Load Z)}\n                           control_Y (Load control_Z))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ?\\<Gamma>'270\n                       ?\\<S>'270 ?P'270\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'270 ?\\<S>'270 ?P'270\n                       ((Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule anno_type[OF HOL.refl HOL.refl HOL.refl])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno\n                         [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                          {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0}, X \n                          \\<mapsto> dma_type X]\n                         ({control_Z, control_Y, control_X}, {Z, Y, X})\n                         (X -=\\<^sub>m AsmNoReadOrWrite))\n                       (add_anno_stable\n                         ({control_Z, control_Y, control_X}, {Z, Y, X})\n                         (X -=\\<^sub>m AsmNoReadOrWrite))\n                       (restrict_preds_to_vars\n                         (restrict_preds_to_vars\n                           (assign_post\n                             {Same control_X (Load control_Y),\n                              Same Y (Load Z)}\n                             control_Y (Load control_Z))\n                           {v. stable\n                                ({control_Z, control_Y, control_X},\n                                 {Z, Y, X})\n                                v})\n                         {v. stable\n                              (add_anno_stable\n                                ({control_Z, control_Y, control_X},\n                                 {Z, Y, X})\n                                (X -=\\<^sub>m AsmNoReadOrWrite))\n                              v})\n                       Skip ?\\<Gamma>'270 ?\\<S>'270 ?P'270\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype\n                          (to_total\n                            [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                             {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0},\n                             X \\<mapsto> dma_type X]\n                            x)\n                          (restrict_preds_to_vars\n                            (restrict_preds_to_vars\n                              (assign_post\n                                {Same control_X (Load control_Y),\n                                 Same Y (Load Z)}\n                                control_Y (Load control_Z))\n                              {v. stable\n                                   ({control_Z, control_Y, control_X},\n                                    {Z, Y, X})\n                                   v})\n                            {v. stable\n                                 (add_anno_stable\n                                   ({control_Z, control_Y, control_X},\n                                    {Z, Y, X})\n                                   (X -=\\<^sub>m AsmNoReadOrWrite))\n                                 v})\n                          (to_total\n                            (add_anno\n                              [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                               {Eq control_Z 0}, Y \\<mapsto>\n                               {Eq control_Z 0}, X \\<mapsto> dma_type X]\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              (X -=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable\n                       [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                        {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0}, X \n                        \\<mapsto> dma_type X]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (X -=\\<^sub>m AsmNoReadOrWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec\n                       [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                        {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0}, X \n                        \\<mapsto> dma_type X]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (restrict_preds_to_vars\n                         (assign_post\n                           {Same control_X (Load control_Y),\n                            Same Y (Load Z)}\n                           control_Y (Load control_Z))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       (X -=\\<^sub>m AsmNoReadOrWrite)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'270 ?\\<S>'270 ?P'270\n                       ((Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule skip_type)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 2. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype\n                          (to_total\n                            [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                             {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0},\n                             X \\<mapsto> dma_type X]\n                            x)\n                          (restrict_preds_to_vars\n                            (restrict_preds_to_vars\n                              (assign_post\n                                {Same control_X (Load control_Y),\n                                 Same Y (Load Z)}\n                                control_Y (Load control_Z))\n                              {v. stable\n                                   ({control_Z, control_Y, control_X},\n                                    {Z, Y, X})\n                                   v})\n                            {v. stable\n                                 (add_anno_stable\n                                   ({control_Z, control_Y, control_X},\n                                    {Z, Y, X})\n                                   (X -=\\<^sub>m AsmNoReadOrWrite))\n                                 v})\n                          (to_total\n                            (add_anno\n                              [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                               {Eq control_Z 0}, Y \\<mapsto>\n                               {Eq control_Z 0}, X \\<mapsto> dma_type X]\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              (X -=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable\n                       [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                        {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0}, X \n                        \\<mapsto> dma_type X]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (X -=\\<^sub>m AsmNoReadOrWrite)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec\n                       [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                        {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0}, X \n                        \\<mapsto> dma_type X]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (restrict_preds_to_vars\n                         (assign_post\n                           {Same control_X (Load control_Y),\n                            Same Y (Load Z)}\n                           control_Y (Load control_Z))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       (X -=\\<^sub>m AsmNoReadOrWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno\n                         [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                          {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0}, X \n                          \\<mapsto> dma_type X]\n                         ({control_Z, control_Y, control_X}, {Z, Y, X})\n                         (X -=\\<^sub>m AsmNoReadOrWrite))\n                       (add_anno_stable\n                         ({control_Z, control_Y, control_X}, {Z, Y, X})\n                         (X -=\\<^sub>m AsmNoReadOrWrite))\n                       (restrict_preds_to_vars\n                         (restrict_preds_to_vars\n                           (assign_post\n                             {Same control_X (Load control_Y),\n                              Same Y (Load Z)}\n                             control_Y (Load control_Z))\n                           {v. stable\n                                ({control_Z, control_Y, control_X},\n                                 {Z, Y, X})\n                                v})\n                         {v. stable\n                              (add_anno_stable\n                                ({control_Z, control_Y, control_X},\n                                 {Z, Y, X})\n                                (X -=\\<^sub>m AsmNoReadOrWrite))\n                              v})\n                       ((Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype\n                          (to_total\n                            [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                             {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0},\n                             X \\<mapsto> dma_type X]\n                            x)\n                          (restrict_preds_to_vars\n                            (restrict_preds_to_vars\n                              (assign_post\n                                {Same control_X (Load control_Y),\n                                 Same Y (Load Z)}\n                                control_Y (Load control_Z))\n                              {v. stable\n                                   ({control_Z, control_Y, control_X},\n                                    {Z, Y, X})\n                                   v})\n                            {v. stable\n                                 (add_anno_stable\n                                   ({control_Z, control_Y, control_X},\n                                    {Z, Y, X})\n                                   (X -=\\<^sub>m AsmNoReadOrWrite))\n                                 v})\n                          (to_total\n                            (add_anno\n                              [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                               {Eq control_Z 0}, Y \\<mapsto>\n                               {Eq control_Z 0}, X \\<mapsto> dma_type X]\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              (X -=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable\n                       [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                        {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0}, X \n                        \\<mapsto> dma_type X]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (X -=\\<^sub>m AsmNoReadOrWrite)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec\n                       [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                        {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0}, X \n                        \\<mapsto> dma_type X]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (restrict_preds_to_vars\n                         (assign_post\n                           {Same control_X (Load control_Y),\n                            Same Y (Load Z)}\n                           control_Y (Load control_Z))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       (X -=\\<^sub>m AsmNoReadOrWrite)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno\n                         [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                          {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0}, X \n                          \\<mapsto> dma_type X]\n                         ({control_Z, control_Y, control_X}, {Z, Y, X})\n                         (X -=\\<^sub>m AsmNoReadOrWrite))\n                       (add_anno_stable\n                         ({control_Z, control_Y, control_X}, {Z, Y, X})\n                         (X -=\\<^sub>m AsmNoReadOrWrite))\n                       (restrict_preds_to_vars\n                         (restrict_preds_to_vars\n                           (assign_post\n                             {Same control_X (Load control_Y),\n                              Same Y (Load Z)}\n                             control_Y (Load control_Z))\n                           {v. stable\n                                ({control_Z, control_Y, control_X},\n                                 {Z, Y, X})\n                                v})\n                         {v. stable\n                              (add_anno_stable\n                                ({control_Z, control_Y, control_X},\n                                 {Z, Y, X})\n                                (X -=\\<^sub>m AsmNoReadOrWrite))\n                              v})\n                       ((Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(fastforce simp: add_anno_def subtype_def pred_entailment_def pred_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable\n                       [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                        {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0}, X \n                        \\<mapsto> dma_type X]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (X -=\\<^sub>m AsmNoReadOrWrite)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec\n                       [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                        {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0}, X \n                        \\<mapsto> dma_type X]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (restrict_preds_to_vars\n                         (assign_post\n                           {Same control_X (Load control_Y),\n                            Same Y (Load Z)}\n                           control_Y (Load control_Z))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       (X -=\\<^sub>m AsmNoReadOrWrite)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno\n                         [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                          {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0}, X \n                          \\<mapsto> dma_type X]\n                         ({control_Z, control_Y, control_X}, {Z, Y, X})\n                         (X -=\\<^sub>m AsmNoReadOrWrite))\n                       (add_anno_stable\n                         ({control_Z, control_Y, control_X}, {Z, Y, X})\n                         (X -=\\<^sub>m AsmNoReadOrWrite))\n                       (restrict_preds_to_vars\n                         (restrict_preds_to_vars\n                           (assign_post\n                             {Same control_X (Load control_Y),\n                              Same Y (Load Z)}\n                             control_Y (Load control_Z))\n                           {v. stable\n                                ({control_Z, control_Y, control_X},\n                                 {Z, Y, X})\n                                v})\n                         {v. stable\n                              (add_anno_stable\n                                ({control_Z, control_Y, control_X},\n                                 {Z, Y, X})\n                                (X -=\\<^sub>m AsmNoReadOrWrite))\n                              v})\n                       ((Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec\n                       [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                        {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0}, X \n                        \\<mapsto> dma_type X]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (restrict_preds_to_vars\n                         (assign_post\n                           {Same control_X (Load control_Y),\n                            Same Y (Load Z)}\n                           control_Y (Load control_Z))\n                         {v. stable\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              v})\n                       (X -=\\<^sub>m AsmNoReadOrWrite)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno\n                         [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                          {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0}, X \n                          \\<mapsto> dma_type X]\n                         ({control_Z, control_Y, control_X}, {Z, Y, X})\n                         (X -=\\<^sub>m AsmNoReadOrWrite))\n                       (add_anno_stable\n                         ({control_Z, control_Y, control_X}, {Z, Y, X})\n                         (X -=\\<^sub>m AsmNoReadOrWrite))\n                       (restrict_preds_to_vars\n                         (restrict_preds_to_vars\n                           (assign_post\n                             {Same control_X (Load control_Y),\n                              Same Y (Load Z)}\n                             control_Y (Load control_Z))\n                           {v. stable\n                                ({control_Z, control_Y, control_X},\n                                 {Z, Y, X})\n                                v})\n                         {v. stable\n                              (add_anno_stable\n                                ({control_Z, control_Y, control_X},\n                                 {Z, Y, X})\n                                (X -=\\<^sub>m AsmNoReadOrWrite))\n                              v})\n                       ((Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno\n                         [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                          {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0}, X \n                          \\<mapsto> dma_type X]\n                         ({control_Z, control_Y, control_X}, {Z, Y, X})\n                         (X -=\\<^sub>m AsmNoReadOrWrite))\n                       (add_anno_stable\n                         ({control_Z, control_Y, control_X}, {Z, Y, X})\n                         (X -=\\<^sub>m AsmNoReadOrWrite))\n                       (restrict_preds_to_vars\n                         (restrict_preds_to_vars\n                           (assign_post\n                             {Same control_X (Load control_Y),\n                              Same Y (Load Z)}\n                             control_Y (Load control_Z))\n                           {v. stable\n                                ({control_Z, control_Y, control_X},\n                                 {Z, Y, X})\n                                v})\n                         {v. stable\n                              (add_anno_stable\n                                ({control_Z, control_Y, control_X},\n                                 {Z, Y, X})\n                                (X -=\\<^sub>m AsmNoReadOrWrite))\n                              v})\n                       ((Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule seq_type)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno\n                         [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                          {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0}, X \n                          \\<mapsto> dma_type X]\n                         ({control_Z, control_Y, control_X}, {Z, Y, X})\n                         (X -=\\<^sub>m AsmNoReadOrWrite))\n                       (add_anno_stable\n                         ({control_Z, control_Y, control_X}, {Z, Y, X})\n                         (X -=\\<^sub>m AsmNoReadOrWrite))\n                       (restrict_preds_to_vars\n                         (restrict_preds_to_vars\n                           (assign_post\n                             {Same control_X (Load control_Y),\n                              Same Y (Load Z)}\n                             control_Y (Load control_Z))\n                           {v. stable\n                                ({control_Z, control_Y, control_X},\n                                 {Z, Y, X})\n                                v})\n                         {v. stable\n                              (add_anno_stable\n                                ({control_Z, control_Y, control_X},\n                                 {Z, Y, X})\n                                (X -=\\<^sub>m AsmNoReadOrWrite))\n                              v})\n                       (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ?\\<Gamma>'289\n                       ?\\<S>'289 ?P'289\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'289 ?\\<S>'289 ?P'289\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule anno_type[OF HOL.refl HOL.refl HOL.refl])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno\n                         (add_anno\n                           [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                            {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0},\n                            X \\<mapsto> dma_type X]\n                           ({control_Z, control_Y, control_X}, {Z, Y, X})\n                           (X -=\\<^sub>m AsmNoReadOrWrite))\n                         (add_anno_stable\n                           ({control_Z, control_Y, control_X}, {Z, Y, X})\n                           (X -=\\<^sub>m AsmNoReadOrWrite))\n                         (Y -=\\<^sub>m AsmNoReadOrWrite))\n                       (add_anno_stable\n                         (add_anno_stable\n                           ({control_Z, control_Y, control_X}, {Z, Y, X})\n                           (X -=\\<^sub>m AsmNoReadOrWrite))\n                         (Y -=\\<^sub>m AsmNoReadOrWrite))\n                       (restrict_preds_to_vars\n                         (restrict_preds_to_vars\n                           (restrict_preds_to_vars\n                             (assign_post\n                               {Same control_X (Load control_Y),\n                                Same Y (Load Z)}\n                               control_Y (Load control_Z))\n                             {v. stable\n                                  ({control_Z, control_Y, control_X},\n                                   {Z, Y, X})\n                                  v})\n                           {v. stable\n                                (add_anno_stable\n                                  ({control_Z, control_Y, control_X},\n                                   {Z, Y, X})\n                                  (X -=\\<^sub>m AsmNoReadOrWrite))\n                                v})\n                         {v. stable\n                              (add_anno_stable\n                                (add_anno_stable\n                                  ({control_Z, control_Y, control_X},\n                                   {Z, Y, X})\n                                  (X -=\\<^sub>m AsmNoReadOrWrite))\n                                (Y -=\\<^sub>m AsmNoReadOrWrite))\n                              v})\n                       Skip ?\\<Gamma>'289 ?\\<S>'289 ?P'289\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype\n                          (to_total\n                            (add_anno\n                              [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                               {Eq control_Z 0}, Y \\<mapsto>\n                               {Eq control_Z 0}, X \\<mapsto> dma_type X]\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              (X -=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n                          (restrict_preds_to_vars\n                            (restrict_preds_to_vars\n                              (restrict_preds_to_vars\n                                (assign_post\n                                  {Same control_X (Load control_Y),\n                                   Same Y (Load Z)}\n                                  control_Y (Load control_Z))\n                                {v. stable\n                                     ({control_Z, control_Y, control_X},\n{Z, Y, X})\n                                     v})\n                              {v. stable\n                                   (add_anno_stable\n                                     ({control_Z, control_Y, control_X},\n{Z, Y, X})\n                                     (X -=\\<^sub>m AsmNoReadOrWrite))\n                                   v})\n                            {v. stable\n                                 (add_anno_stable\n                                   (add_anno_stable\n                                     ({control_Z, control_Y, control_X},\n{Z, Y, X})\n                                     (X -=\\<^sub>m AsmNoReadOrWrite))\n                                   (Y -=\\<^sub>m AsmNoReadOrWrite))\n                                 v})\n                          (to_total\n                            (add_anno\n                              (add_anno\n                                [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                                 {Eq control_Z 0}, Y \\<mapsto>\n                                 {Eq control_Z 0}, X \\<mapsto> dma_type X]\n                                ({control_Z, control_Y, control_X},\n                                 {Z, Y, X})\n                                (X -=\\<^sub>m AsmNoReadOrWrite))\n                              (add_anno_stable\n                                ({control_Z, control_Y, control_X},\n                                 {Z, Y, X})\n                                (X -=\\<^sub>m AsmNoReadOrWrite))\n                              (Y -=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable\n                       (add_anno\n                         [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                          {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0}, X \n                          \\<mapsto> dma_type X]\n                         ({control_Z, control_Y, control_X}, {Z, Y, X})\n                         (X -=\\<^sub>m AsmNoReadOrWrite))\n                       (add_anno_stable\n                         ({control_Z, control_Y, control_X}, {Z, Y, X})\n                         (X -=\\<^sub>m AsmNoReadOrWrite))\n                       (Y -=\\<^sub>m AsmNoReadOrWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec\n                       (add_anno\n                         [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                          {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0}, X \n                          \\<mapsto> dma_type X]\n                         ({control_Z, control_Y, control_X}, {Z, Y, X})\n                         (X -=\\<^sub>m AsmNoReadOrWrite))\n                       (add_anno_stable\n                         ({control_Z, control_Y, control_X}, {Z, Y, X})\n                         (X -=\\<^sub>m AsmNoReadOrWrite))\n                       (restrict_preds_to_vars\n                         (restrict_preds_to_vars\n                           (assign_post\n                             {Same control_X (Load control_Y),\n                              Same Y (Load Z)}\n                             control_Y (Load control_Z))\n                           {v. stable\n                                ({control_Z, control_Y, control_X},\n                                 {Z, Y, X})\n                                v})\n                         {v. stable\n                              (add_anno_stable\n                                ({control_Z, control_Y, control_X},\n                                 {Z, Y, X})\n                                (X -=\\<^sub>m AsmNoReadOrWrite))\n                              v})\n                       (Y -=\\<^sub>m AsmNoReadOrWrite)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'289 ?\\<S>'289 ?P'289\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply clarsimp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [Z \\<mapsto> {Eq control_Z 0}]\n                       ({control_Z, control_Y, control_X},\n                        {Z, Y, X} - {X} - {Y})\n                       {Same control_Y (Load control_Z)} Skip ?\\<Gamma>'289\n                       ?\\<S>'289 ?P'289\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype\n                          (to_total\n                            (add_anno\n                              [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                               {Eq control_Z 0}, Y \\<mapsto>\n                               {Eq control_Z 0}, X \\<mapsto> dma_type X]\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              (X -=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n                          (restrict_preds_to_vars\n                            (restrict_preds_to_vars\n                              (restrict_preds_to_vars\n                                (assign_post\n                                  {Same control_X (Load control_Y),\n                                   Same Y (Load Z)}\n                                  control_Y (Load control_Z))\n                                {v. stable\n                                     ({control_Z, control_Y, control_X},\n{Z, Y, X})\n                                     v})\n                              {v. stable\n                                   (add_anno_stable\n                                     ({control_Z, control_Y, control_X},\n{Z, Y, X})\n                                     (X -=\\<^sub>m AsmNoReadOrWrite))\n                                   v})\n                            {v. stable\n                                 (add_anno_stable\n                                   (add_anno_stable\n                                     ({control_Z, control_Y, control_X},\n{Z, Y, X})\n                                     (X -=\\<^sub>m AsmNoReadOrWrite))\n                                   (Y -=\\<^sub>m AsmNoReadOrWrite))\n                                 v})\n                          (to_total\n                            (add_anno\n                              (add_anno\n                                [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                                 {Eq control_Z 0}, Y \\<mapsto>\n                                 {Eq control_Z 0}, X \\<mapsto> dma_type X]\n                                ({control_Z, control_Y, control_X},\n                                 {Z, Y, X})\n                                (X -=\\<^sub>m AsmNoReadOrWrite))\n                              (add_anno_stable\n                                ({control_Z, control_Y, control_X},\n                                 {Z, Y, X})\n                                (X -=\\<^sub>m AsmNoReadOrWrite))\n                              (Y -=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable\n                       (add_anno\n                         [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                          {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0}, X \n                          \\<mapsto> dma_type X]\n                         ({control_Z, control_Y, control_X}, {Z, Y, X})\n                         (X -=\\<^sub>m AsmNoReadOrWrite))\n                       (add_anno_stable\n                         ({control_Z, control_Y, control_X}, {Z, Y, X})\n                         (X -=\\<^sub>m AsmNoReadOrWrite))\n                       (Y -=\\<^sub>m AsmNoReadOrWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec\n                       (add_anno\n                         [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                          {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0}, X \n                          \\<mapsto> dma_type X]\n                         ({control_Z, control_Y, control_X}, {Z, Y, X})\n                         (X -=\\<^sub>m AsmNoReadOrWrite))\n                       (add_anno_stable\n                         ({control_Z, control_Y, control_X}, {Z, Y, X})\n                         (X -=\\<^sub>m AsmNoReadOrWrite))\n                       (restrict_preds_to_vars\n                         (restrict_preds_to_vars\n                           (assign_post\n                             {Same control_X (Load control_Y),\n                              Same Y (Load Z)}\n                             control_Y (Load control_Z))\n                           {v. stable\n                                ({control_Z, control_Y, control_X},\n                                 {Z, Y, X})\n                                v})\n                         {v. stable\n                              (add_anno_stable\n                                ({control_Z, control_Y, control_X},\n                                 {Z, Y, X})\n                                (X -=\\<^sub>m AsmNoReadOrWrite))\n                              v})\n                       (Y -=\\<^sub>m AsmNoReadOrWrite)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'289 ?\\<S>'289 ?P'289\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule skip_type)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 2. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype\n                          (to_total\n                            (add_anno\n                              [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                               {Eq control_Z 0}, Y \\<mapsto>\n                               {Eq control_Z 0}, X \\<mapsto> dma_type X]\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              (X -=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n                          (restrict_preds_to_vars\n                            (restrict_preds_to_vars\n                              (restrict_preds_to_vars\n                                (assign_post\n                                  {Same control_X (Load control_Y),\n                                   Same Y (Load Z)}\n                                  control_Y (Load control_Z))\n                                {v. stable\n                                     ({control_Z, control_Y, control_X},\n{Z, Y, X})\n                                     v})\n                              {v. stable\n                                   (add_anno_stable\n                                     ({control_Z, control_Y, control_X},\n{Z, Y, X})\n                                     (X -=\\<^sub>m AsmNoReadOrWrite))\n                                   v})\n                            {v. stable\n                                 (add_anno_stable\n                                   (add_anno_stable\n                                     ({control_Z, control_Y, control_X},\n{Z, Y, X})\n                                     (X -=\\<^sub>m AsmNoReadOrWrite))\n                                   (Y -=\\<^sub>m AsmNoReadOrWrite))\n                                 v})\n                          (to_total\n                            (add_anno\n                              (add_anno\n                                [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                                 {Eq control_Z 0}, Y \\<mapsto>\n                                 {Eq control_Z 0}, X \\<mapsto> dma_type X]\n                                ({control_Z, control_Y, control_X},\n                                 {Z, Y, X})\n                                (X -=\\<^sub>m AsmNoReadOrWrite))\n                              (add_anno_stable\n                                ({control_Z, control_Y, control_X},\n                                 {Z, Y, X})\n                                (X -=\\<^sub>m AsmNoReadOrWrite))\n                              (Y -=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable\n                       (add_anno\n                         [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                          {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0}, X \n                          \\<mapsto> dma_type X]\n                         ({control_Z, control_Y, control_X}, {Z, Y, X})\n                         (X -=\\<^sub>m AsmNoReadOrWrite))\n                       (add_anno_stable\n                         ({control_Z, control_Y, control_X}, {Z, Y, X})\n                         (X -=\\<^sub>m AsmNoReadOrWrite))\n                       (Y -=\\<^sub>m AsmNoReadOrWrite)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec\n                       (add_anno\n                         [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                          {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0}, X \n                          \\<mapsto> dma_type X]\n                         ({control_Z, control_Y, control_X}, {Z, Y, X})\n                         (X -=\\<^sub>m AsmNoReadOrWrite))\n                       (add_anno_stable\n                         ({control_Z, control_Y, control_X}, {Z, Y, X})\n                         (X -=\\<^sub>m AsmNoReadOrWrite))\n                       (restrict_preds_to_vars\n                         (restrict_preds_to_vars\n                           (assign_post\n                             {Same control_X (Load control_Y),\n                              Same Y (Load Z)}\n                             control_Y (Load control_Z))\n                           {v. stable\n                                ({control_Z, control_Y, control_X},\n                                 {Z, Y, X})\n                                v})\n                         {v. stable\n                              (add_anno_stable\n                                ({control_Z, control_Y, control_X},\n                                 {Z, Y, X})\n                                (X -=\\<^sub>m AsmNoReadOrWrite))\n                              v})\n                       (Y -=\\<^sub>m AsmNoReadOrWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [Z \\<mapsto> {Eq control_Z 0}]\n                       ({control_Z, control_Y, control_X},\n                        {Z, Y, X} - {X} - {Y})\n                       {Same control_Y (Load control_Z)}\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype\n                          (to_total\n                            (add_anno\n                              [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                               {Eq control_Z 0}, Y \\<mapsto>\n                               {Eq control_Z 0}, X \\<mapsto> dma_type X]\n                              ({control_Z, control_Y, control_X}, {Z, Y, X})\n                              (X -=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n                          (restrict_preds_to_vars\n                            (restrict_preds_to_vars\n                              (restrict_preds_to_vars\n                                (assign_post\n                                  {Same control_X (Load control_Y),\n                                   Same Y (Load Z)}\n                                  control_Y (Load control_Z))\n                                {v. stable\n                                     ({control_Z, control_Y, control_X},\n{Z, Y, X})\n                                     v})\n                              {v. stable\n                                   (add_anno_stable\n                                     ({control_Z, control_Y, control_X},\n{Z, Y, X})\n                                     (X -=\\<^sub>m AsmNoReadOrWrite))\n                                   v})\n                            {v. stable\n                                 (add_anno_stable\n                                   (add_anno_stable\n                                     ({control_Z, control_Y, control_X},\n{Z, Y, X})\n                                     (X -=\\<^sub>m AsmNoReadOrWrite))\n                                   (Y -=\\<^sub>m AsmNoReadOrWrite))\n                                 v})\n                          (to_total\n                            (add_anno\n                              (add_anno\n                                [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                                 {Eq control_Z 0}, Y \\<mapsto>\n                                 {Eq control_Z 0}, X \\<mapsto> dma_type X]\n                                ({control_Z, control_Y, control_X},\n                                 {Z, Y, X})\n                                (X -=\\<^sub>m AsmNoReadOrWrite))\n                              (add_anno_stable\n                                ({control_Z, control_Y, control_X},\n                                 {Z, Y, X})\n                                (X -=\\<^sub>m AsmNoReadOrWrite))\n                              (Y -=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable\n                       (add_anno\n                         [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                          {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0}, X \n                          \\<mapsto> dma_type X]\n                         ({control_Z, control_Y, control_X}, {Z, Y, X})\n                         (X -=\\<^sub>m AsmNoReadOrWrite))\n                       (add_anno_stable\n                         ({control_Z, control_Y, control_X}, {Z, Y, X})\n                         (X -=\\<^sub>m AsmNoReadOrWrite))\n                       (Y -=\\<^sub>m AsmNoReadOrWrite)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec\n                       (add_anno\n                         [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                          {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0}, X \n                          \\<mapsto> dma_type X]\n                         ({control_Z, control_Y, control_X}, {Z, Y, X})\n                         (X -=\\<^sub>m AsmNoReadOrWrite))\n                       (add_anno_stable\n                         ({control_Z, control_Y, control_X}, {Z, Y, X})\n                         (X -=\\<^sub>m AsmNoReadOrWrite))\n                       (restrict_preds_to_vars\n                         (restrict_preds_to_vars\n                           (assign_post\n                             {Same control_X (Load control_Y),\n                              Same Y (Load Z)}\n                             control_Y (Load control_Z))\n                           {v. stable\n                                ({control_Z, control_Y, control_X},\n                                 {Z, Y, X})\n                                v})\n                         {v. stable\n                              (add_anno_stable\n                                ({control_Z, control_Y, control_X},\n                                 {Z, Y, X})\n                                (X -=\\<^sub>m AsmNoReadOrWrite))\n                              v})\n                       (Y -=\\<^sub>m AsmNoReadOrWrite)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [Z \\<mapsto> {Eq control_Z 0}]\n                       ({control_Z, control_Y, control_X},\n                        {Z, Y, X} - {X} - {Y})\n                       {Same control_Y (Load control_Z)}\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(fastforce simp: add_anno_def subtype_def pred_entailment_def pred_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable\n                       (add_anno\n                         [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                          {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0}, X \n                          \\<mapsto> dma_type X]\n                         ({control_Z, control_Y, control_X}, {Z, Y, X})\n                         (X -=\\<^sub>m AsmNoReadOrWrite))\n                       (add_anno_stable\n                         ({control_Z, control_Y, control_X}, {Z, Y, X})\n                         (X -=\\<^sub>m AsmNoReadOrWrite))\n                       (Y -=\\<^sub>m AsmNoReadOrWrite)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec\n                       (add_anno\n                         [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                          {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0}, X \n                          \\<mapsto> dma_type X]\n                         ({control_Z, control_Y, control_X}, {Z, Y, X})\n                         (X -=\\<^sub>m AsmNoReadOrWrite))\n                       (add_anno_stable\n                         ({control_Z, control_Y, control_X}, {Z, Y, X})\n                         (X -=\\<^sub>m AsmNoReadOrWrite))\n                       (restrict_preds_to_vars\n                         (restrict_preds_to_vars\n                           (assign_post\n                             {Same control_X (Load control_Y),\n                              Same Y (Load Z)}\n                             control_Y (Load control_Z))\n                           {v. stable\n                                ({control_Z, control_Y, control_X},\n                                 {Z, Y, X})\n                                v})\n                         {v. stable\n                              (add_anno_stable\n                                ({control_Z, control_Y, control_X},\n                                 {Z, Y, X})\n                                (X -=\\<^sub>m AsmNoReadOrWrite))\n                              v})\n                       (Y -=\\<^sub>m AsmNoReadOrWrite)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [Z \\<mapsto> {Eq control_Z 0}]\n                       ({control_Z, control_Y, control_X},\n                        {Z, Y, X} - {X} - {Y})\n                       {Same control_Y (Load control_Z)}\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec\n                       (add_anno\n                         [X \\<mapsto> {Eq control_Y 0}, Z \\<mapsto>\n                          {Eq control_Z 0}, Y \\<mapsto> {Eq control_Z 0}, X \n                          \\<mapsto> dma_type X]\n                         ({control_Z, control_Y, control_X}, {Z, Y, X})\n                         (X -=\\<^sub>m AsmNoReadOrWrite))\n                       (add_anno_stable\n                         ({control_Z, control_Y, control_X}, {Z, Y, X})\n                         (X -=\\<^sub>m AsmNoReadOrWrite))\n                       (restrict_preds_to_vars\n                         (restrict_preds_to_vars\n                           (assign_post\n                             {Same control_X (Load control_Y),\n                              Same Y (Load Z)}\n                             control_Y (Load control_Z))\n                           {v. stable\n                                ({control_Z, control_Y, control_X},\n                                 {Z, Y, X})\n                                v})\n                         {v. stable\n                              (add_anno_stable\n                                ({control_Z, control_Y, control_X},\n                                 {Z, Y, X})\n                                (X -=\\<^sub>m AsmNoReadOrWrite))\n                              v})\n                       (Y -=\\<^sub>m AsmNoReadOrWrite)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [Z \\<mapsto> {Eq control_Z 0}]\n                       ({control_Z, control_Y, control_X},\n                        {Z, Y, X} - {X} - {Y})\n                       {Same control_Y (Load control_Z)}\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [Z \\<mapsto> {Eq control_Z 0}]\n                       ({control_Z, control_Y, control_X},\n                        {Z, Y, X} - {X} - {Y})\n                       {Same control_Y (Load control_Z)}\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule seq_type)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [Z \\<mapsto> {Eq control_Z 0}]\n                       ({control_Z, control_Y, control_X},\n                        {Z, Y, X} - {X} - {Y})\n                       {Same control_Y (Load control_Z)}\n                       (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ?\\<Gamma>'310\n                       ?\\<S>'310 ?P'310\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'310 ?\\<S>'310 ?P'310\n                       ((Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule anno_type[OF HOL.refl HOL.refl HOL.refl])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno [Z \\<mapsto> {Eq control_Z 0}]\n                         ({control_Z, control_Y, control_X},\n                          {Z, Y, X} - {X} - {Y})\n                         (Z -=\\<^sub>m AsmNoReadOrWrite))\n                       (add_anno_stable\n                         ({control_Z, control_Y, control_X},\n                          {Z, Y, X} - {X} - {Y})\n                         (Z -=\\<^sub>m AsmNoReadOrWrite))\n                       (restrict_preds_to_vars\n                         {Same control_Y (Load control_Z)}\n                         {v. stable\n                              (add_anno_stable\n                                ({control_Z, control_Y, control_X},\n                                 {Z, Y, X} - {X} - {Y})\n                                (Z -=\\<^sub>m AsmNoReadOrWrite))\n                              v})\n                       Skip ?\\<Gamma>'310 ?\\<S>'310 ?P'310\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total [Z \\<mapsto> {Eq control_Z 0}] x)\n                          (restrict_preds_to_vars\n                            {Same control_Y (Load control_Z)}\n                            {v. stable\n                                 (add_anno_stable\n                                   ({control_Z, control_Y, control_X},\n                                    {Z, Y, X} - {X} - {Y})\n                                   (Z -=\\<^sub>m AsmNoReadOrWrite))\n                                 v})\n                          (to_total\n                            (add_anno [Z \\<mapsto> {Eq control_Z 0}]\n                              ({control_Z, control_Y, control_X},\n                               {Z, Y, X} - {X} - {Y})\n                              (Z -=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable [Z \\<mapsto> {Eq control_Z 0}]\n                       ({control_Z, control_Y, control_X},\n                        {Z, Y, X} - {X} - {Y})\n                       (Z -=\\<^sub>m AsmNoReadOrWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec [Z \\<mapsto> {Eq control_Z 0}]\n                       ({control_Z, control_Y, control_X},\n                        {Z, Y, X} - {X} - {Y})\n                       {Same control_Y (Load control_Z)}\n                       (Z -=\\<^sub>m AsmNoReadOrWrite)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'310 ?\\<S>'310 ?P'310\n                       ((Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply clarsimp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty\n                       ({control_Z, control_Y, control_X},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {Same control_Y (Load control_Z)} Skip ?\\<Gamma>'310\n                       ?\\<S>'310 ?P'310\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total [Z \\<mapsto> {Eq control_Z 0}] x)\n                          (restrict_preds_to_vars\n                            {Same control_Y (Load control_Z)}\n                            {v. stable\n                                 (add_anno_stable\n                                   ({control_Z, control_Y, control_X},\n                                    {Z, Y, X} - {X} - {Y})\n                                   (Z -=\\<^sub>m AsmNoReadOrWrite))\n                                 v})\n                          (to_total\n                            (add_anno [Z \\<mapsto> {Eq control_Z 0}]\n                              ({control_Z, control_Y, control_X},\n                               {Z, Y, X} - {X} - {Y})\n                              (Z -=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable [Z \\<mapsto> {Eq control_Z 0}]\n                       ({control_Z, control_Y, control_X},\n                        {Z, Y, X} - {X} - {Y})\n                       (Z -=\\<^sub>m AsmNoReadOrWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec [Z \\<mapsto> {Eq control_Z 0}]\n                       ({control_Z, control_Y, control_X},\n                        {Z, Y, X} - {X} - {Y})\n                       {Same control_Y (Load control_Z)}\n                       (Z -=\\<^sub>m AsmNoReadOrWrite)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'310 ?\\<S>'310 ?P'310\n                       ((Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule skip_type)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 2. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total [Z \\<mapsto> {Eq control_Z 0}] x)\n                          (restrict_preds_to_vars\n                            {Same control_Y (Load control_Z)}\n                            {v. stable\n                                 (add_anno_stable\n                                   ({control_Z, control_Y, control_X},\n                                    {Z, Y, X} - {X} - {Y})\n                                   (Z -=\\<^sub>m AsmNoReadOrWrite))\n                                 v})\n                          (to_total\n                            (add_anno [Z \\<mapsto> {Eq control_Z 0}]\n                              ({control_Z, control_Y, control_X},\n                               {Z, Y, X} - {X} - {Y})\n                              (Z -=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable [Z \\<mapsto> {Eq control_Z 0}]\n                       ({control_Z, control_Y, control_X},\n                        {Z, Y, X} - {X} - {Y})\n                       (Z -=\\<^sub>m AsmNoReadOrWrite)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec [Z \\<mapsto> {Eq control_Z 0}]\n                       ({control_Z, control_Y, control_X},\n                        {Z, Y, X} - {X} - {Y})\n                       {Same control_Y (Load control_Z)}\n                       (Z -=\\<^sub>m AsmNoReadOrWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty\n                       ({control_Z, control_Y, control_X},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {Same control_Y (Load control_Z)}\n                       ((Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total [Z \\<mapsto> {Eq control_Z 0}] x)\n                          (restrict_preds_to_vars\n                            {Same control_Y (Load control_Z)}\n                            {v. stable\n                                 (add_anno_stable\n                                   ({control_Z, control_Y, control_X},\n                                    {Z, Y, X} - {X} - {Y})\n                                   (Z -=\\<^sub>m AsmNoReadOrWrite))\n                                 v})\n                          (to_total\n                            (add_anno [Z \\<mapsto> {Eq control_Z 0}]\n                              ({control_Z, control_Y, control_X},\n                               {Z, Y, X} - {X} - {Y})\n                              (Z -=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable [Z \\<mapsto> {Eq control_Z 0}]\n                       ({control_Z, control_Y, control_X},\n                        {Z, Y, X} - {X} - {Y})\n                       (Z -=\\<^sub>m AsmNoReadOrWrite)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec [Z \\<mapsto> {Eq control_Z 0}]\n                       ({control_Z, control_Y, control_X},\n                        {Z, Y, X} - {X} - {Y})\n                       {Same control_Y (Load control_Z)}\n                       (Z -=\\<^sub>m AsmNoReadOrWrite)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty\n                       ({control_Z, control_Y, control_X},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {Same control_Y (Load control_Z)}\n                       ((Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(fastforce simp: add_anno_def subtype_def pred_entailment_def pred_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable [Z \\<mapsto> {Eq control_Z 0}]\n                       ({control_Z, control_Y, control_X},\n                        {Z, Y, X} - {X} - {Y})\n                       (Z -=\\<^sub>m AsmNoReadOrWrite)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec [Z \\<mapsto> {Eq control_Z 0}]\n                       ({control_Z, control_Y, control_X},\n                        {Z, Y, X} - {X} - {Y})\n                       {Same control_Y (Load control_Z)}\n                       (Z -=\\<^sub>m AsmNoReadOrWrite)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty\n                       ({control_Z, control_Y, control_X},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {Same control_Y (Load control_Z)}\n                       ((Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec [Z \\<mapsto> {Eq control_Z 0}]\n                       ({control_Z, control_Y, control_X},\n                        {Z, Y, X} - {X} - {Y})\n                       {Same control_Y (Load control_Z)}\n                       (Z -=\\<^sub>m AsmNoReadOrWrite)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty\n                       ({control_Z, control_Y, control_X},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {Same control_Y (Load control_Z)}\n                       ((Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty\n                       ({control_Z, control_Y, control_X},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {Same control_Y (Load control_Z)}\n                       ((Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule seq_type)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty\n                       ({control_Z, control_Y, control_X},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {Same control_Y (Load control_Z)}\n                       (Skip@[control_X -=\\<^sub>m AsmNoWrite])\n                       ?\\<Gamma>'331 ?\\<S>'331 ?P'331\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'331 ?\\<S>'331 ?P'331\n                       ((Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule anno_type[OF HOL.refl HOL.refl HOL.refl])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno Map.empty\n                         ({control_Z, control_Y, control_X},\n                          {Z, Y, X} - {X} - {Y} - {Z})\n                         (control_X -=\\<^sub>m AsmNoWrite))\n                       (add_anno_stable\n                         ({control_Z, control_Y, control_X},\n                          {Z, Y, X} - {X} - {Y} - {Z})\n                         (control_X -=\\<^sub>m AsmNoWrite))\n                       (restrict_preds_to_vars\n                         {Same control_Y (Load control_Z)}\n                         {v. stable\n                              (add_anno_stable\n                                ({control_Z, control_Y, control_X},\n                                 {Z, Y, X} - {X} - {Y} - {Z})\n                                (control_X -=\\<^sub>m AsmNoWrite))\n                              v})\n                       Skip ?\\<Gamma>'331 ?\\<S>'331 ?P'331\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars\n                            {Same control_Y (Load control_Z)}\n                            {v. stable\n                                 (add_anno_stable\n                                   ({control_Z, control_Y, control_X},\n                                    {Z, Y, X} - {X} - {Y} - {Z})\n                                   (control_X -=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty\n                              ({control_Z, control_Y, control_X},\n                               {Z, Y, X} - {X} - {Y} - {Z})\n                              (control_X -=\\<^sub>m AsmNoWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty\n                       ({control_Z, control_Y, control_X},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       (control_X -=\\<^sub>m AsmNoWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty\n                       ({control_Z, control_Y, control_X},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {Same control_Y (Load control_Z)}\n                       (control_X -=\\<^sub>m AsmNoWrite)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'331 ?\\<S>'331 ?P'331\n                       ((Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply clarsimp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty\n                       ({control_Z, control_Y, control_X} - {control_X},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {Same control_Y (Load control_Z)} Skip ?\\<Gamma>'331\n                       ?\\<S>'331 ?P'331\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars\n                            {Same control_Y (Load control_Z)}\n                            {v. stable\n                                 (add_anno_stable\n                                   ({control_Z, control_Y, control_X},\n                                    {Z, Y, X} - {X} - {Y} - {Z})\n                                   (control_X -=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty\n                              ({control_Z, control_Y, control_X},\n                               {Z, Y, X} - {X} - {Y} - {Z})\n                              (control_X -=\\<^sub>m AsmNoWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty\n                       ({control_Z, control_Y, control_X},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       (control_X -=\\<^sub>m AsmNoWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty\n                       ({control_Z, control_Y, control_X},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {Same control_Y (Load control_Z)}\n                       (control_X -=\\<^sub>m AsmNoWrite)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'331 ?\\<S>'331 ?P'331\n                       ((Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule skip_type)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 2. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars\n                            {Same control_Y (Load control_Z)}\n                            {v. stable\n                                 (add_anno_stable\n                                   ({control_Z, control_Y, control_X},\n                                    {Z, Y, X} - {X} - {Y} - {Z})\n                                   (control_X -=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty\n                              ({control_Z, control_Y, control_X},\n                               {Z, Y, X} - {X} - {Y} - {Z})\n                              (control_X -=\\<^sub>m AsmNoWrite))\n                            x)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty\n                       ({control_Z, control_Y, control_X},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       (control_X -=\\<^sub>m AsmNoWrite)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty\n                       ({control_Z, control_Y, control_X},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {Same control_Y (Load control_Z)}\n                       (control_X -=\\<^sub>m AsmNoWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty\n                       ({control_Z, control_Y, control_X} - {control_X},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {Same control_Y (Load control_Z)}\n                       ((Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars\n                            {Same control_Y (Load control_Z)}\n                            {v. stable\n                                 (add_anno_stable\n                                   ({control_Z, control_Y, control_X},\n                                    {Z, Y, X} - {X} - {Y} - {Z})\n                                   (control_X -=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty\n                              ({control_Z, control_Y, control_X},\n                               {Z, Y, X} - {X} - {Y} - {Z})\n                              (control_X -=\\<^sub>m AsmNoWrite))\n                            x)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty\n                       ({control_Z, control_Y, control_X},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       (control_X -=\\<^sub>m AsmNoWrite)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty\n                       ({control_Z, control_Y, control_X},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {Same control_Y (Load control_Z)}\n                       (control_X -=\\<^sub>m AsmNoWrite)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty\n                       ({control_Z, control_Y, control_X} - {control_X},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {Same control_Y (Load control_Z)}\n                       ((Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(fastforce simp: add_anno_def subtype_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty\n                       ({control_Z, control_Y, control_X},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       (control_X -=\\<^sub>m AsmNoWrite)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty\n                       ({control_Z, control_Y, control_X},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {Same control_Y (Load control_Z)}\n                       (control_X -=\\<^sub>m AsmNoWrite)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty\n                       ({control_Z, control_Y, control_X} - {control_X},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {Same control_Y (Load control_Z)}\n                       ((Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply (simp add: add_anno_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty\n                       ({control_Z, control_Y, control_X},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {Same control_Y (Load control_Z)}\n                       (control_X -=\\<^sub>m AsmNoWrite)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty\n                       ({control_Z, control_Y, control_X} - {control_X},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {Same control_Y (Load control_Z)}\n                       ((Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty\n                       ({control_Z, control_Y, control_X} - {control_X},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {Same control_Y (Load control_Z)}\n                       ((Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule seq_type)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty\n                       ({control_Z, control_Y, control_X} - {control_X},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {Same control_Y (Load control_Z)}\n                       (Skip@[control_Y -=\\<^sub>m AsmNoWrite])\n                       ?\\<Gamma>'348 ?\\<S>'348 ?P'348\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'348 ?\\<S>'348 ?P'348\n                       ((Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule anno_type[OF HOL.refl HOL.refl HOL.refl])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno Map.empty\n                         ({control_Z, control_Y, control_X} - {control_X},\n                          {Z, Y, X} - {X} - {Y} - {Z})\n                         (control_Y -=\\<^sub>m AsmNoWrite))\n                       (add_anno_stable\n                         ({control_Z, control_Y, control_X} - {control_X},\n                          {Z, Y, X} - {X} - {Y} - {Z})\n                         (control_Y -=\\<^sub>m AsmNoWrite))\n                       (restrict_preds_to_vars\n                         {Same control_Y (Load control_Z)}\n                         {v. stable\n                              (add_anno_stable\n                                ({control_Z, control_Y, control_X} -\n                                 {control_X},\n                                 {Z, Y, X} - {X} - {Y} - {Z})\n                                (control_Y -=\\<^sub>m AsmNoWrite))\n                              v})\n                       Skip ?\\<Gamma>'348 ?\\<S>'348 ?P'348\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars\n                            {Same control_Y (Load control_Z)}\n                            {v. stable\n                                 (add_anno_stable\n                                   ({control_Z, control_Y, control_X} -\n                                    {control_X},\n                                    {Z, Y, X} - {X} - {Y} - {Z})\n                                   (control_Y -=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty\n                              ({control_Z, control_Y, control_X} -\n                               {control_X},\n                               {Z, Y, X} - {X} - {Y} - {Z})\n                              (control_Y -=\\<^sub>m AsmNoWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty\n                       ({control_Z, control_Y, control_X} - {control_X},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       (control_Y -=\\<^sub>m AsmNoWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty\n                       ({control_Z, control_Y, control_X} - {control_X},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {Same control_Y (Load control_Z)}\n                       (control_Y -=\\<^sub>m AsmNoWrite)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'348 ?\\<S>'348 ?P'348\n                       ((Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply clarsimp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty\n                       ({control_Z, control_Y, control_X} - {control_X} -\n                        {control_Y},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {} Skip ?\\<Gamma>'348 ?\\<S>'348 ?P'348\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars\n                            {Same control_Y (Load control_Z)}\n                            {v. stable\n                                 (add_anno_stable\n                                   ({control_Z, control_Y, control_X} -\n                                    {control_X},\n                                    {Z, Y, X} - {X} - {Y} - {Z})\n                                   (control_Y -=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty\n                              ({control_Z, control_Y, control_X} -\n                               {control_X},\n                               {Z, Y, X} - {X} - {Y} - {Z})\n                              (control_Y -=\\<^sub>m AsmNoWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty\n                       ({control_Z, control_Y, control_X} - {control_X},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       (control_Y -=\\<^sub>m AsmNoWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty\n                       ({control_Z, control_Y, control_X} - {control_X},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {Same control_Y (Load control_Z)}\n                       (control_Y -=\\<^sub>m AsmNoWrite)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'348 ?\\<S>'348 ?P'348\n                       ((Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule skip_type)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 2. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars\n                            {Same control_Y (Load control_Z)}\n                            {v. stable\n                                 (add_anno_stable\n                                   ({control_Z, control_Y, control_X} -\n                                    {control_X},\n                                    {Z, Y, X} - {X} - {Y} - {Z})\n                                   (control_Y -=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty\n                              ({control_Z, control_Y, control_X} -\n                               {control_X},\n                               {Z, Y, X} - {X} - {Y} - {Z})\n                              (control_Y -=\\<^sub>m AsmNoWrite))\n                            x)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty\n                       ({control_Z, control_Y, control_X} - {control_X},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       (control_Y -=\\<^sub>m AsmNoWrite)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty\n                       ({control_Z, control_Y, control_X} - {control_X},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {Same control_Y (Load control_Z)}\n                       (control_Y -=\\<^sub>m AsmNoWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty\n                       ({control_Z, control_Y, control_X} - {control_X} -\n                        {control_Y},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {} ((Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars\n                            {Same control_Y (Load control_Z)}\n                            {v. stable\n                                 (add_anno_stable\n                                   ({control_Z, control_Y, control_X} -\n                                    {control_X},\n                                    {Z, Y, X} - {X} - {Y} - {Z})\n                                   (control_Y -=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty\n                              ({control_Z, control_Y, control_X} -\n                               {control_X},\n                               {Z, Y, X} - {X} - {Y} - {Z})\n                              (control_Y -=\\<^sub>m AsmNoWrite))\n                            x)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty\n                       ({control_Z, control_Y, control_X} - {control_X},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       (control_Y -=\\<^sub>m AsmNoWrite)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty\n                       ({control_Z, control_Y, control_X} - {control_X},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {Same control_Y (Load control_Z)}\n                       (control_Y -=\\<^sub>m AsmNoWrite)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty\n                       ({control_Z, control_Y, control_X} - {control_X} -\n                        {control_Y},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {} ((Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(fastforce simp: add_anno_def subtype_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty\n                       ({control_Z, control_Y, control_X} - {control_X},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       (control_Y -=\\<^sub>m AsmNoWrite)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty\n                       ({control_Z, control_Y, control_X} - {control_X},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {Same control_Y (Load control_Z)}\n                       (control_Y -=\\<^sub>m AsmNoWrite)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty\n                       ({control_Z, control_Y, control_X} - {control_X} -\n                        {control_Y},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {} ((Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply (simp add: add_anno_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty\n                       ({control_Z, control_Y, control_X} - {control_X},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {Same control_Y (Load control_Z)}\n                       (control_Y -=\\<^sub>m AsmNoWrite)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty\n                       ({control_Z, control_Y, control_X} - {control_X} -\n                        {control_Y},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {} ((Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty\n                       ({control_Z, control_Y, control_X} - {control_X} -\n                        {control_Y},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {} ((Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule seq_type)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty\n                       ({control_Z, control_Y, control_X} - {control_X} -\n                        {control_Y},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {} (Skip@[control_Z -=\\<^sub>m AsmNoWrite])\n                       ?\\<Gamma>'365 ?\\<S>'365 ?P'365\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'365 ?\\<S>'365 ?P'365 Skip\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule anno_type[OF HOL.refl HOL.refl HOL.refl])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno Map.empty\n                         ({control_Z, control_Y, control_X} - {control_X} -\n                          {control_Y},\n                          {Z, Y, X} - {X} - {Y} - {Z})\n                         (control_Z -=\\<^sub>m AsmNoWrite))\n                       (add_anno_stable\n                         ({control_Z, control_Y, control_X} - {control_X} -\n                          {control_Y},\n                          {Z, Y, X} - {X} - {Y} - {Z})\n                         (control_Z -=\\<^sub>m AsmNoWrite))\n                       (restrict_preds_to_vars {}\n                         {v. stable\n                              (add_anno_stable\n                                ({control_Z, control_Y, control_X} -\n                                 {control_X} -\n                                 {control_Y},\n                                 {Z, Y, X} - {X} - {Y} - {Z})\n                                (control_Z -=\\<^sub>m AsmNoWrite))\n                              v})\n                       Skip ?\\<Gamma>'365 ?\\<S>'365 ?P'365\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable\n                                   ({control_Z, control_Y, control_X} -\n                                    {control_X} -\n                                    {control_Y},\n                                    {Z, Y, X} - {X} - {Y} - {Z})\n                                   (control_Z -=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty\n                              ({control_Z, control_Y, control_X} -\n                               {control_X} -\n                               {control_Y},\n                               {Z, Y, X} - {X} - {Y} - {Z})\n                              (control_Z -=\\<^sub>m AsmNoWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty\n                       ({control_Z, control_Y, control_X} - {control_X} -\n                        {control_Y},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       (control_Z -=\\<^sub>m AsmNoWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty\n                       ({control_Z, control_Y, control_X} - {control_X} -\n                        {control_Y},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {} (control_Z -=\\<^sub>m AsmNoWrite)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'365 ?\\<S>'365 ?P'365 Skip\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply clarsimp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty\n                       ({control_Z, control_Y, control_X} - {control_X} -\n                        {control_Y} -\n                        {control_Z},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {} Skip ?\\<Gamma>'365 ?\\<S>'365 ?P'365\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable\n                                   ({control_Z, control_Y, control_X} -\n                                    {control_X} -\n                                    {control_Y},\n                                    {Z, Y, X} - {X} - {Y} - {Z})\n                                   (control_Z -=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty\n                              ({control_Z, control_Y, control_X} -\n                               {control_X} -\n                               {control_Y},\n                               {Z, Y, X} - {X} - {Y} - {Z})\n                              (control_Z -=\\<^sub>m AsmNoWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty\n                       ({control_Z, control_Y, control_X} - {control_X} -\n                        {control_Y},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       (control_Z -=\\<^sub>m AsmNoWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty\n                       ({control_Z, control_Y, control_X} - {control_X} -\n                        {control_Y},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {} (control_Z -=\\<^sub>m AsmNoWrite)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'365 ?\\<S>'365 ?P'365 Skip\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule skip_type)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 2. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable\n                                   ({control_Z, control_Y, control_X} -\n                                    {control_X} -\n                                    {control_Y},\n                                    {Z, Y, X} - {X} - {Y} - {Z})\n                                   (control_Z -=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty\n                              ({control_Z, control_Y, control_X} -\n                               {control_X} -\n                               {control_Y},\n                               {Z, Y, X} - {X} - {Y} - {Z})\n                              (control_Z -=\\<^sub>m AsmNoWrite))\n                            x)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty\n                       ({control_Z, control_Y, control_X} - {control_X} -\n                        {control_Y},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       (control_Z -=\\<^sub>m AsmNoWrite)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty\n                       ({control_Z, control_Y, control_X} - {control_X} -\n                        {control_Y},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {} (control_Z -=\\<^sub>m AsmNoWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty\n                       ({control_Z, control_Y, control_X} - {control_X} -\n                        {control_Y} -\n                        {control_Z},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {} Skip ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable\n                                   ({control_Z, control_Y, control_X} -\n                                    {control_X} -\n                                    {control_Y},\n                                    {Z, Y, X} - {X} - {Y} - {Z})\n                                   (control_Z -=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty\n                              ({control_Z, control_Y, control_X} -\n                               {control_X} -\n                               {control_Y},\n                               {Z, Y, X} - {X} - {Y} - {Z})\n                              (control_Z -=\\<^sub>m AsmNoWrite))\n                            x)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty\n                       ({control_Z, control_Y, control_X} - {control_X} -\n                        {control_Y},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       (control_Z -=\\<^sub>m AsmNoWrite)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty\n                       ({control_Z, control_Y, control_X} - {control_X} -\n                        {control_Y},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {} (control_Z -=\\<^sub>m AsmNoWrite)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty\n                       ({control_Z, control_Y, control_X} - {control_X} -\n                        {control_Y} -\n                        {control_Z},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {} Skip ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(fastforce simp: add_anno_def subtype_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty\n                       ({control_Z, control_Y, control_X} - {control_X} -\n                        {control_Y},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       (control_Z -=\\<^sub>m AsmNoWrite)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty\n                       ({control_Z, control_Y, control_X} - {control_X} -\n                        {control_Y},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {} (control_Z -=\\<^sub>m AsmNoWrite)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty\n                       ({control_Z, control_Y, control_X} - {control_X} -\n                        {control_Y} -\n                        {control_Z},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {} Skip ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply (simp add: add_anno_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty\n                       ({control_Z, control_Y, control_X} - {control_X} -\n                        {control_Y},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {} (control_Z -=\\<^sub>m AsmNoWrite)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty\n                       ({control_Z, control_Y, control_X} - {control_X} -\n                        {control_Y} -\n                        {control_Z},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {} Skip ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty\n                       ({control_Z, control_Y, control_X} - {control_X} -\n                        {control_Y} -\n                        {control_Z},\n                        {Z, Y, X} - {X} - {Y} - {Z})\n                       {} Skip ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule skip_type)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma swap_vars_sifum_secure:\n  \"com_sifum_secure (swap_vars,(\\<lambda>_. {}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. com_sifum_secure (swap_vars, \\<lambda>_. {})", "apply(insert swap_vars_typed[OF HOL.refl HOL.refl HOL.refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma>' \\<S>' P'.\n       has_type Map.empty ({}, {}) {} swap_vars \\<Gamma>' \\<S>'\n        P' \\<Longrightarrow>\n    com_sifum_secure (swap_vars, \\<lambda>_. {})", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma>' a b x.\n       has_type Map.empty ({}, {}) {} swap_vars \\<Gamma>' (a, b)\n        x \\<Longrightarrow>\n       com_sifum_secure (swap_vars, \\<lambda>_. {})", "apply(rule typed_secure)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma>' a b x.\n       has_type Map.empty ({}, {}) {} swap_vars \\<Gamma>' (a, b)\n        x \\<Longrightarrow>\n       has_type (\\<Gamma>_of_mds (\\<lambda>_. {}))\n        (\\<S>_of_mds (\\<lambda>_. {})) {} swap_vars\n        (?\\<Gamma>'8 \\<Gamma>' a b x) (?\\<S>'8 \\<Gamma>' a b x)\n        (?P'8 \\<Gamma>' a b x)\n 2. \\<And>\\<Gamma>' a b x.\n       has_type Map.empty ({}, {}) {} swap_vars \\<Gamma>' (a, b)\n        x \\<Longrightarrow>\n       mds_yields_stable_types (\\<lambda>_. {})", "apply(fastforce simp: \\<Gamma>_of_mds_def \\<S>_of_mds_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma>' a b x.\n       has_type Map.empty ({}, {}) {} swap_vars \\<Gamma>' (a, b)\n        x \\<Longrightarrow>\n       mds_yields_stable_types (\\<lambda>_. {})", "apply(auto simp: mds_yields_stable_types_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition\n  add_vars :: \"(addr, aexp, bexp) Stmt\"\nwhere\n  \"add_vars \\<equiv> \n     ModeDecl Skip (Acq control_X AsmNoWrite) ;; \n     ModeDecl Skip (Acq control_Y AsmNoWrite) ;;\n     ModeDecl Skip (Acq control_Z AsmNoWrite) ;;\n     ModeDecl Skip (Acq Z AsmNoReadOrWrite) ;;\n     Assign Z (Add X Y) ;;\n     If (Eq control_X 0)\n        (If (Eq control_Y 0)\n            (Assign control_Z (Const 0))\n            (Assign control_Z (Const 1)))\n        (Assign control_Z (Const 1)) ;;\n     ModeDecl Skip (Rel Z AsmNoReadOrWrite) ;;\n     ModeDecl Skip (Rel control_X AsmNoWrite) ;; \n     ModeDecl Skip (Rel control_Y AsmNoWrite) ;;\n     ModeDecl Skip (Rel control_Z AsmNoWrite) ;;\n     Skip\""], ["", "lemma pred_entailment_singleton_by_case_distinction:\n  \"Imp e f \\<in> P \\<Longrightarrow> Imp (bexp.Not e) f \\<in> P \\<Longrightarrow> pred_entailment P {f}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Imp e f \\<in> P; Imp (bexp.Not e) f \\<in> P\\<rbrakk>\n    \\<Longrightarrow> pred_entailment P {f}", "apply(clarsimp simp: pred_entailment_def pred_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>mem.\n       \\<lbrakk>Imp e f \\<in> P; Imp (bexp.Not e) f \\<in> P;\n        \\<forall>x\\<in>P. ev\\<^sub>B mem x\\<rbrakk>\n       \\<Longrightarrow> ev\\<^sub>B mem f", "apply(case_tac \"ev\\<^sub>B mem e\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>mem.\n       \\<lbrakk>Imp e f \\<in> P; Imp (bexp.Not e) f \\<in> P;\n        \\<forall>x\\<in>P. ev\\<^sub>B mem x; ev\\<^sub>B mem e\\<rbrakk>\n       \\<Longrightarrow> ev\\<^sub>B mem f\n 2. \\<And>mem.\n       \\<lbrakk>Imp e f \\<in> P; Imp (bexp.Not e) f \\<in> P;\n        \\<forall>x\\<in>P. ev\\<^sub>B mem x; \\<not> ev\\<^sub>B mem e\\<rbrakk>\n       \\<Longrightarrow> ev\\<^sub>B mem f", "apply fastforce+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma restrict_preds_to_vars_nest [simp]:\n  \"restrict_preds_to_vars (restrict_preds_to_vars P V) V' = restrict_preds_to_vars P (V \\<inter> V')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict_preds_to_vars (restrict_preds_to_vars P V) V' =\n    restrict_preds_to_vars P (V \\<inter> V')", "apply(auto simp: restrict_preds_to_vars_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma restrict_preds_to_vars_imp_image1 [simp]:\n  \"\\<not> bexp_vars e \\<subseteq> V \\<Longrightarrow> restrict_preds_to_vars (Imp e ` P) V = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> bexp_vars e \\<subseteq> V \\<Longrightarrow>\n    restrict_preds_to_vars (Imp e ` P) V = {}", "apply(auto simp: restrict_preds_to_vars_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma restrict_preds_to_vars_imp_image2 [simp]:\n  \"bexp_vars e \\<subseteq> V \\<Longrightarrow> restrict_preds_to_vars (Imp e ` P) V = ((Imp e) ` (restrict_preds_to_vars P V))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bexp_vars e \\<subseteq> V \\<Longrightarrow>\n    restrict_preds_to_vars (Imp e ` P) V =\n    Imp e ` restrict_preds_to_vars P V", "apply(auto simp: restrict_preds_to_vars_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma insert_minus1 [simp]:\n  \"x = y \\<Longrightarrow> (insert x A) - {y} = (A - {y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y \\<Longrightarrow> insert x A - {y} = A - {y}", "by auto"], ["", "lemma insert_minus2 [simp]:\n  \"x \\<noteq> y \\<Longrightarrow> (insert x A) - {y} = insert x (A - {y})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> y \\<Longrightarrow> insert x A - {y} = insert x (A - {y})", "by auto"], ["", "lemma add_vars_typed:\n  \"\\<Gamma> = (\\<lambda>_. None) \\<Longrightarrow> \\<S> = ({},{}) \\<Longrightarrow> P = {} \\<Longrightarrow> \n  \\<exists>\\<Gamma>' \\<S>' P'. has_type \\<Gamma> \\<S> P add_vars \\<Gamma>' \\<S>' P'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<Gamma>' \\<S>' P'.\n                         has_type \\<Gamma> \\<S> P add_vars \\<Gamma>' \\<S>'\n                          P'", "apply(intro exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type \\<Gamma> \\<S> P add_vars ?\\<Gamma>' ?\\<S>'1\n                       ?P'2", "apply(simp add: add_vars_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({}, {}) {}\n                       ((Skip@[control_X +=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y +=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z +=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[Z +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Z \\<leftarrow> Add X Y) ;;\n                        Stmt.If (Eq control_X 0)\n                         (Stmt.If (Eq control_Y 0)\n                           (control_Z \\<leftarrow> Const 0)\n                           (control_Z \\<leftarrow> Const (Suc 0)))\n                         (control_Z \\<leftarrow> Const (Suc 0)) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule seq_type)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({}, {}) {}\n                       (Skip@[control_X +=\\<^sub>m AsmNoWrite]) ?\\<Gamma>'3\n                       ?\\<S>'3 ?P'3\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'3 ?\\<S>'3 ?P'3\n                       ((Skip@[control_Y +=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z +=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[Z +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Z \\<leftarrow> Add X Y) ;;\n                        Stmt.If (Eq control_X 0)\n                         (Stmt.If (Eq control_Y 0)\n                           (control_Z \\<leftarrow> Const 0)\n                           (control_Z \\<leftarrow> Const (Suc 0)))\n                         (control_Z \\<leftarrow> Const (Suc 0)) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule anno_type[OF HOL.refl HOL.refl HOL.refl])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno Map.empty ({}, {})\n                         (control_X +=\\<^sub>m AsmNoWrite))\n                       (add_anno_stable ({}, {})\n                         (control_X +=\\<^sub>m AsmNoWrite))\n                       (restrict_preds_to_vars {}\n                         {v. stable\n                              (add_anno_stable ({}, {})\n                                (control_X +=\\<^sub>m AsmNoWrite))\n                              v})\n                       Skip ?\\<Gamma>'3 ?\\<S>'3 ?P'3\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable ({}, {})\n                                   (control_X +=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty ({}, {})\n                              (control_X +=\\<^sub>m AsmNoWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty ({}, {})\n                       (control_X +=\\<^sub>m AsmNoWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({}, {}) {}\n                       (control_X +=\\<^sub>m AsmNoWrite)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'3 ?\\<S>'3 ?P'3\n                       ((Skip@[control_Y +=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z +=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[Z +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Z \\<leftarrow> Add X Y) ;;\n                        Stmt.If (Eq control_X 0)\n                         (Stmt.If (Eq control_Y 0)\n                           (control_Z \\<leftarrow> Const 0)\n                           (control_Z \\<leftarrow> Const (Suc 0)))\n                         (control_Z \\<leftarrow> Const (Suc 0)) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule skip_type)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 2. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable ({}, {})\n                                   (control_X +=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty ({}, {})\n                              (control_X +=\\<^sub>m AsmNoWrite))\n                            x)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty ({}, {})\n                       (control_X +=\\<^sub>m AsmNoWrite)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({}, {}) {}\n                       (control_X +=\\<^sub>m AsmNoWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno Map.empty ({}, {})\n                         (control_X +=\\<^sub>m AsmNoWrite))\n                       (add_anno_stable ({}, {})\n                         (control_X +=\\<^sub>m AsmNoWrite))\n                       (restrict_preds_to_vars {}\n                         {v. stable\n                              (add_anno_stable ({}, {})\n                                (control_X +=\\<^sub>m AsmNoWrite))\n                              v})\n                       ((Skip@[control_Y +=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z +=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[Z +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Z \\<leftarrow> Add X Y) ;;\n                        Stmt.If (Eq control_X 0)\n                         (Stmt.If (Eq control_Y 0)\n                           (control_Z \\<leftarrow> Const 0)\n                           (control_Z \\<leftarrow> Const (Suc 0)))\n                         (control_Z \\<leftarrow> Const (Suc 0)) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({control_X}, {}) {}\n                       ((Skip@[control_Y +=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z +=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[Z +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Z \\<leftarrow> Add X Y) ;;\n                        Stmt.If (Eq control_X 0)\n                         (Stmt.If (Eq control_Y 0)\n                           (control_Z \\<leftarrow> Const 0)\n                           (control_Z \\<leftarrow> Const (Suc 0)))\n                         (control_Z \\<leftarrow> Const (Suc 0)) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule seq_type)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({control_X}, {}) {}\n                       (Skip@[control_Y +=\\<^sub>m AsmNoWrite]) ?\\<Gamma>'16\n                       ?\\<S>'16 ?P'16\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'16 ?\\<S>'16 ?P'16\n                       ((Skip@[control_Z +=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[Z +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Z \\<leftarrow> Add X Y) ;;\n                        Stmt.If (Eq control_X 0)\n                         (Stmt.If (Eq control_Y 0)\n                           (control_Z \\<leftarrow> Const 0)\n                           (control_Z \\<leftarrow> Const (Suc 0)))\n                         (control_Z \\<leftarrow> Const (Suc 0)) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule anno_type[OF HOL.refl HOL.refl HOL.refl])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno Map.empty ({control_X}, {})\n                         (control_Y +=\\<^sub>m AsmNoWrite))\n                       (add_anno_stable ({control_X}, {})\n                         (control_Y +=\\<^sub>m AsmNoWrite))\n                       (restrict_preds_to_vars {}\n                         {v. stable\n                              (add_anno_stable ({control_X}, {})\n                                (control_Y +=\\<^sub>m AsmNoWrite))\n                              v})\n                       Skip ?\\<Gamma>'16 ?\\<S>'16 ?P'16\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable ({control_X}, {})\n                                   (control_Y +=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty ({control_X}, {})\n                              (control_Y +=\\<^sub>m AsmNoWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty ({control_X}, {})\n                       (control_Y +=\\<^sub>m AsmNoWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({control_X}, {}) {}\n                       (control_Y +=\\<^sub>m AsmNoWrite)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'16 ?\\<S>'16 ?P'16\n                       ((Skip@[control_Z +=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[Z +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Z \\<leftarrow> Add X Y) ;;\n                        Stmt.If (Eq control_X 0)\n                         (Stmt.If (Eq control_Y 0)\n                           (control_Z \\<leftarrow> Const 0)\n                           (control_Z \\<leftarrow> Const (Suc 0)))\n                         (control_Z \\<leftarrow> Const (Suc 0)) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule skip_type)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 2. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable ({control_X}, {})\n                                   (control_Y +=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty ({control_X}, {})\n                              (control_Y +=\\<^sub>m AsmNoWrite))\n                            x)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty ({control_X}, {})\n                       (control_Y +=\\<^sub>m AsmNoWrite)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({control_X}, {}) {}\n                       (control_Y +=\\<^sub>m AsmNoWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno Map.empty ({control_X}, {})\n                         (control_Y +=\\<^sub>m AsmNoWrite))\n                       (add_anno_stable ({control_X}, {})\n                         (control_Y +=\\<^sub>m AsmNoWrite))\n                       (restrict_preds_to_vars {}\n                         {v. stable\n                              (add_anno_stable ({control_X}, {})\n                                (control_Y +=\\<^sub>m AsmNoWrite))\n                              v})\n                       ((Skip@[control_Z +=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[Z +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Z \\<leftarrow> Add X Y) ;;\n                        Stmt.If (Eq control_X 0)\n                         (Stmt.If (Eq control_Y 0)\n                           (control_Z \\<leftarrow> Const 0)\n                           (control_Z \\<leftarrow> Const (Suc 0)))\n                         (control_Z \\<leftarrow> Const (Suc 0)) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({control_Y, control_X}, {}) {}\n                       ((Skip@[control_Z +=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[Z +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Z \\<leftarrow> Add X Y) ;;\n                        Stmt.If (Eq control_X 0)\n                         (Stmt.If (Eq control_Y 0)\n                           (control_Z \\<leftarrow> Const 0)\n                           (control_Z \\<leftarrow> Const (Suc 0)))\n                         (control_Z \\<leftarrow> Const (Suc 0)) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule seq_type)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({control_Y, control_X}, {}) {}\n                       (Skip@[control_Z +=\\<^sub>m AsmNoWrite]) ?\\<Gamma>'29\n                       ?\\<S>'29 ?P'29\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'29 ?\\<S>'29 ?P'29\n                       ((Skip@[Z +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Z \\<leftarrow> Add X Y) ;;\n                        Stmt.If (Eq control_X 0)\n                         (Stmt.If (Eq control_Y 0)\n                           (control_Z \\<leftarrow> Const 0)\n                           (control_Z \\<leftarrow> Const (Suc 0)))\n                         (control_Z \\<leftarrow> Const (Suc 0)) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule anno_type[OF HOL.refl HOL.refl HOL.refl])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno Map.empty ({control_Y, control_X}, {})\n                         (control_Z +=\\<^sub>m AsmNoWrite))\n                       (add_anno_stable ({control_Y, control_X}, {})\n                         (control_Z +=\\<^sub>m AsmNoWrite))\n                       (restrict_preds_to_vars {}\n                         {v. stable\n                              (add_anno_stable ({control_Y, control_X}, {})\n                                (control_Z +=\\<^sub>m AsmNoWrite))\n                              v})\n                       Skip ?\\<Gamma>'29 ?\\<S>'29 ?P'29\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable\n                                   ({control_Y, control_X}, {})\n                                   (control_Z +=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty ({control_Y, control_X}, {})\n                              (control_Z +=\\<^sub>m AsmNoWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty\n                       ({control_Y, control_X}, {})\n                       (control_Z +=\\<^sub>m AsmNoWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({control_Y, control_X}, {})\n                       {} (control_Z +=\\<^sub>m AsmNoWrite)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'29 ?\\<S>'29 ?P'29\n                       ((Skip@[Z +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Z \\<leftarrow> Add X Y) ;;\n                        Stmt.If (Eq control_X 0)\n                         (Stmt.If (Eq control_Y 0)\n                           (control_Z \\<leftarrow> Const 0)\n                           (control_Z \\<leftarrow> Const (Suc 0)))\n                         (control_Z \\<leftarrow> Const (Suc 0)) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule skip_type)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 2. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable\n                                   ({control_Y, control_X}, {})\n                                   (control_Z +=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty ({control_Y, control_X}, {})\n                              (control_Z +=\\<^sub>m AsmNoWrite))\n                            x)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty\n                       ({control_Y, control_X}, {})\n                       (control_Z +=\\<^sub>m AsmNoWrite)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({control_Y, control_X}, {})\n                       {} (control_Z +=\\<^sub>m AsmNoWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno Map.empty ({control_Y, control_X}, {})\n                         (control_Z +=\\<^sub>m AsmNoWrite))\n                       (add_anno_stable ({control_Y, control_X}, {})\n                         (control_Z +=\\<^sub>m AsmNoWrite))\n                       (restrict_preds_to_vars {}\n                         {v. stable\n                              (add_anno_stable ({control_Y, control_X}, {})\n                                (control_Z +=\\<^sub>m AsmNoWrite))\n                              v})\n                       ((Skip@[Z +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Z \\<leftarrow> Add X Y) ;;\n                        Stmt.If (Eq control_X 0)\n                         (Stmt.If (Eq control_Y 0)\n                           (control_Z \\<leftarrow> Const 0)\n                           (control_Z \\<leftarrow> Const (Suc 0)))\n                         (control_Z \\<leftarrow> Const (Suc 0)) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty\n                       ({control_Z, control_Y, control_X}, {}) {}\n                       ((Skip@[Z +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Z \\<leftarrow> Add X Y) ;;\n                        Stmt.If (Eq control_X 0)\n                         (Stmt.If (Eq control_Y 0)\n                           (control_Z \\<leftarrow> Const 0)\n                           (control_Z \\<leftarrow> Const (Suc 0)))\n                         (control_Z \\<leftarrow> Const (Suc 0)) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule seq_type)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty\n                       ({control_Z, control_Y, control_X}, {}) {}\n                       (Skip@[Z +=\\<^sub>m AsmNoReadOrWrite]) ?\\<Gamma>'42\n                       ?\\<S>'42 ?P'42\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'42 ?\\<S>'42 ?P'42\n                       ((Z \\<leftarrow> Add X Y) ;;\n                        Stmt.If (Eq control_X 0)\n                         (Stmt.If (Eq control_Y 0)\n                           (control_Z \\<leftarrow> Const 0)\n                           (control_Z \\<leftarrow> Const (Suc 0)))\n                         (control_Z \\<leftarrow> Const (Suc 0)) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule anno_type[OF HOL.refl HOL.refl HOL.refl])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno Map.empty\n                         ({control_Z, control_Y, control_X}, {})\n                         (Z +=\\<^sub>m AsmNoReadOrWrite))\n                       (add_anno_stable\n                         ({control_Z, control_Y, control_X}, {})\n                         (Z +=\\<^sub>m AsmNoReadOrWrite))\n                       (restrict_preds_to_vars {}\n                         {v. stable\n                              (add_anno_stable\n                                ({control_Z, control_Y, control_X}, {})\n                                (Z +=\\<^sub>m AsmNoReadOrWrite))\n                              v})\n                       Skip ?\\<Gamma>'42 ?\\<S>'42 ?P'42\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable\n                                   ({control_Z, control_Y, control_X}, {})\n                                   (Z +=\\<^sub>m AsmNoReadOrWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty\n                              ({control_Z, control_Y, control_X}, {})\n                              (Z +=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty\n                       ({control_Z, control_Y, control_X}, {})\n                       (Z +=\\<^sub>m AsmNoReadOrWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty\n                       ({control_Z, control_Y, control_X}, {}) {}\n                       (Z +=\\<^sub>m AsmNoReadOrWrite)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'42 ?\\<S>'42 ?P'42\n                       ((Z \\<leftarrow> Add X Y) ;;\n                        Stmt.If (Eq control_X 0)\n                         (Stmt.If (Eq control_Y 0)\n                           (control_Z \\<leftarrow> Const 0)\n                           (control_Z \\<leftarrow> Const (Suc 0)))\n                         (control_Z \\<leftarrow> Const (Suc 0)) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule skip_type)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 2. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable\n                                   ({control_Z, control_Y, control_X}, {})\n                                   (Z +=\\<^sub>m AsmNoReadOrWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty\n                              ({control_Z, control_Y, control_X}, {})\n                              (Z +=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty\n                       ({control_Z, control_Y, control_X}, {})\n                       (Z +=\\<^sub>m AsmNoReadOrWrite)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty\n                       ({control_Z, control_Y, control_X}, {}) {}\n                       (Z +=\\<^sub>m AsmNoReadOrWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno Map.empty\n                         ({control_Z, control_Y, control_X}, {})\n                         (Z +=\\<^sub>m AsmNoReadOrWrite))\n                       (add_anno_stable\n                         ({control_Z, control_Y, control_X}, {})\n                         (Z +=\\<^sub>m AsmNoReadOrWrite))\n                       (restrict_preds_to_vars {}\n                         {v. stable\n                              (add_anno_stable\n                                ({control_Z, control_Y, control_X}, {})\n                                (Z +=\\<^sub>m AsmNoReadOrWrite))\n                              v})\n                       ((Z \\<leftarrow> Add X Y) ;;\n                        Stmt.If (Eq control_X 0)\n                         (Stmt.If (Eq control_Y 0)\n                           (control_Z \\<leftarrow> Const 0)\n                           (control_Z \\<leftarrow> Const (Suc 0)))\n                         (control_Z \\<leftarrow> Const (Suc 0)) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [Z \\<mapsto> {Eq control_Z 0}]\n                       ({control_Z, control_Y, control_X}, {Z}) {}\n                       ((Z \\<leftarrow> Add X Y) ;;\n                        Stmt.If (Eq control_X 0)\n                         (Stmt.If (Eq control_Y 0)\n                           (control_Z \\<leftarrow> Const 0)\n                           (control_Z \\<leftarrow> Const (Suc 0)))\n                         (control_Z \\<leftarrow> Const (Suc 0)) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule seq_type)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [Z \\<mapsto> {Eq control_Z 0}]\n                       ({control_Z, control_Y, control_X}, {Z}) {}\n                       (Z \\<leftarrow> Add X Y) ?\\<Gamma>'59 ?\\<S>'59 ?P'59\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'59 ?\\<S>'59 ?P'59\n                       (Stmt.If (Eq control_X 0)\n                         (Stmt.If (Eq control_Y 0)\n                           (control_Z \\<leftarrow> Const 0)\n                           (control_Z \\<leftarrow> Const (Suc 0)))\n                         (control_Z \\<leftarrow> Const (Suc 0)) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule assign\\<^sub>2)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Z \\<in> dom [Z \\<mapsto> {Eq control_Z 0}]\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr [Z \\<mapsto> {Eq control_Z 0}] (Add X Y)\n                       ?t62\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable ({control_Z, control_Y, control_X}, {Z})\n                       ?t62\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'59 =\n                      restrict_preds_to_vars (assign_post {} Z (Add X Y))\n                       {v. stable ({control_Z, control_Y, control_X}, {Z})\n                            v}\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Z \\<notin> snd ({control_Z, control_Y, control_X},\n{Z}) \\<longrightarrow>\n                      subtype ?t62 ?P'59 (dma_type Z)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto> ?t62]\n                       ({control_Z, control_Y, control_X}, {Z}) ?P'59\n                       (Stmt.If (Eq control_X 0)\n                         (Stmt.If (Eq control_Y 0)\n                           (control_Z \\<leftarrow> Const 0)\n                           (control_Z \\<leftarrow> Const (Suc 0)))\n                         (control_Z \\<leftarrow> Const (Suc 0)) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr [Z \\<mapsto> {Eq control_Z 0}] (Add X Y)\n                       ?t62\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable ({control_Z, control_Y, control_X}, {Z})\n                       ?t62\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'59 =\n                      restrict_preds_to_vars (assign_post {} Z (Add X Y))\n                       {v. stable ({control_Z, control_Y, control_X}, {Z})\n                            v}\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Z \\<notin> snd ({control_Z, control_Y, control_X},\n{Z}) \\<longrightarrow>\n                      subtype ?t62 ?P'59 (dma_type Z)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto> ?t62]\n                       ({control_Z, control_Y, control_X}, {Z}) ?P'59\n                       (Stmt.If (Eq control_X 0)\n                         (Stmt.If (Eq control_Y 0)\n                           (control_Z \\<leftarrow> Const 0)\n                           (control_Z \\<leftarrow> Const (Suc 0)))\n                         (control_Z \\<leftarrow> Const (Suc 0)) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply (rule type_aexpr_Add type_aexpr_Add' type_aexpr_Add'' type_aexpr_Add'''; simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable ({control_Z, control_Y, control_X}, {Z})\n                       (\\<Union> {dma_type X, dma_type Y})\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'59 =\n                      restrict_preds_to_vars (assign_post {} Z (Add X Y))\n                       {v. stable ({control_Z, control_Y, control_X}, {Z})\n                            v}\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Z \\<notin> snd ({control_Z, control_Y, control_X},\n{Z}) \\<longrightarrow>\n                      subtype (\\<Union> {dma_type X, dma_type Y}) ?P'59\n                       (dma_type Z)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z}) ?P'59\n                       (Stmt.If (Eq control_X 0)\n                         (Stmt.If (Eq control_Y 0)\n                           (control_Z \\<leftarrow> Const 0)\n                           (control_Z \\<leftarrow> Const (Suc 0)))\n                         (control_Z \\<leftarrow> Const (Suc 0)) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'59 =\n                      restrict_preds_to_vars (assign_post {} Z (Add X Y))\n                       {v. stable ({control_Z, control_Y, control_X}, {Z})\n                            v}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Z \\<notin> snd ({control_Z, control_Y, control_X},\n{Z}) \\<longrightarrow>\n                      subtype (\\<Union> {dma_type X, dma_type Y}) ?P'59\n                       (dma_type Z)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z}) ?P'59\n                       (Stmt.If (Eq control_X 0)\n                         (Stmt.If (Eq control_Y 0)\n                           (control_Z \\<leftarrow> Const 0)\n                           (control_Z \\<leftarrow> Const (Suc 0)))\n                         (control_Z \\<leftarrow> Const (Suc 0)) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Z \\<notin> snd ({control_Z, control_Y, control_X},\n{Z}) \\<longrightarrow>\n                      subtype (\\<Union> {dma_type X, dma_type Y}) {}\n                       (dma_type Z)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z}) {}\n                       (Stmt.If (Eq control_X 0)\n                         (Stmt.If (Eq control_Y 0)\n                           (control_Z \\<leftarrow> Const 0)\n                           (control_Z \\<leftarrow> Const (Suc 0)))\n                         (control_Z \\<leftarrow> Const (Suc 0)) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z}) {}\n                       (Stmt.If (Eq control_X 0)\n                         (Stmt.If (Eq control_Y 0)\n                           (control_Z \\<leftarrow> Const 0)\n                           (control_Z \\<leftarrow> Const (Suc 0)))\n                         (control_Z \\<leftarrow> Const (Suc 0)) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z}) {}\n                       (Stmt.If (Eq control_X 0)\n                         (Stmt.If (Eq control_Y 0)\n                           (control_Z \\<leftarrow> Const 0)\n                           (control_Z \\<leftarrow> Const (Suc 0)))\n                         (control_Z \\<leftarrow> Const (Suc 0)) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule seq_type)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z}) {}\n                       (Stmt.If (Eq control_X 0)\n                         (Stmt.If (Eq control_Y 0)\n                           (control_Z \\<leftarrow> Const 0)\n                           (control_Z \\<leftarrow> Const (Suc 0)))\n                         (control_Z \\<leftarrow> Const (Suc 0)))\n                       ?\\<Gamma>'78 ?\\<S>'78 ?P'78\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'78 ?\\<S>'78 ?P'78\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule if_type''[OF _ _ _ _ _ _ HOL.refl])"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_bexpr\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       (Eq control_X 0) ?t81\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment {} ?t81\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (Eq control_X 0))\n                       (Stmt.If (Eq control_Y 0)\n                         (control_Z \\<leftarrow> Const 0)\n                         (control_Z \\<leftarrow> Const (Suc 0)))\n                       ?\\<Gamma>'78 ?\\<S>'78 ?P'81\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_X 0)))\n                       (control_Z \\<leftarrow> Const (Suc 0)) ?\\<Gamma>'78\n                       ?\\<S>'78 ?P''81\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P'81 {Eq control_X 0}\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''81 {bexp_neg (Eq control_X 0)}\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'78 ?\\<S>'78\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (?P'81 - {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          (?P''81 - {bexp_neg (Eq control_X 0)}))\n                         {v. stable ?\\<S>'78 v})\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule type_bexprI)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?t81 =\n                      \\<Union>\n                       (to_total\n                         [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}] `\n                        bexp_vars (Eq control_X 0))\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment {} ?t81\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (Eq control_X 0))\n                       (Stmt.If (Eq control_Y 0)\n                         (control_Z \\<leftarrow> Const 0)\n                         (control_Z \\<leftarrow> Const (Suc 0)))\n                       ?\\<Gamma>'78 ?\\<S>'78 ?P'81\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_X 0)))\n                       (control_Z \\<leftarrow> Const (Suc 0)) ?\\<Gamma>'78\n                       ?\\<S>'78 ?P''81\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P'81 {Eq control_X 0}\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''81 {bexp_neg (Eq control_X 0)}\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'78 ?\\<S>'78\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (?P'81 - {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          (?P''81 - {bexp_neg (Eq control_X 0)}))\n                         {v. stable ?\\<S>'78 v})\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(clarsimp)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?t81 = {}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment {} ?t81\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (Eq control_X 0))\n                       (Stmt.If (Eq control_Y 0)\n                         (control_Z \\<leftarrow> Const 0)\n                         (control_Z \\<leftarrow> Const (Suc 0)))\n                       ?\\<Gamma>'78 ?\\<S>'78 ?P'81\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_X 0)))\n                       (control_Z \\<leftarrow> Const (Suc 0)) ?\\<Gamma>'78\n                       ?\\<S>'78 ?P''81\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P'81 {Eq control_X 0}\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''81 {bexp_neg (Eq control_X 0)}\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'78 ?\\<S>'78\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (?P'81 - {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          (?P''81 - {bexp_neg (Eq control_X 0)}))\n                         {v. stable ?\\<S>'78 v})\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule HOL.refl)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment {} {}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (Eq control_X 0))\n                       (Stmt.If (Eq control_Y 0)\n                         (control_Z \\<leftarrow> Const 0)\n                         (control_Z \\<leftarrow> Const (Suc 0)))\n                       ?\\<Gamma>'78 ?\\<S>'78 ?P'81\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_X 0)))\n                       (control_Z \\<leftarrow> Const (Suc 0)) ?\\<Gamma>'78\n                       ?\\<S>'78 ?P''81\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P'81 {Eq control_X 0}\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''81 {bexp_neg (Eq control_X 0)}\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'78 ?\\<S>'78\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (?P'81 - {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          (?P''81 - {bexp_neg (Eq control_X 0)}))\n                         {v. stable ?\\<S>'78 v})\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (Eq control_X 0))\n                       (Stmt.If (Eq control_Y 0)\n                         (control_Z \\<leftarrow> Const 0)\n                         (control_Z \\<leftarrow> Const (Suc 0)))\n                       ?\\<Gamma>'78 ?\\<S>'78 ?P'81\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_X 0)))\n                       (control_Z \\<leftarrow> Const (Suc 0)) ?\\<Gamma>'78\n                       ?\\<S>'78 ?P''81\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P'81 {Eq control_X 0}\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''81 {bexp_neg (Eq control_X 0)}\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'78 ?\\<S>'78\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (?P'81 - {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          (?P''81 - {bexp_neg (Eq control_X 0)}))\n                         {v. stable ?\\<S>'78 v})\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule if_type''[OF _ _ _ _ _ _ HOL.refl])"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_bexpr\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       (Eq control_Y 0) ?t100\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (Eq control_X 0))\n                       ?t100\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred\n                         (add_pred {}\n                           ({control_Z, control_Y, control_X}, {Z})\n                           (Eq control_X 0))\n                         ({control_Z, control_Y, control_X}, {Z})\n                         (Eq control_Y 0))\n                       (control_Z \\<leftarrow> Const 0) ?\\<Gamma>'78\n                       ?\\<S>'78 ?P'100\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred\n                         (add_pred {}\n                           ({control_Z, control_Y, control_X}, {Z})\n                           (Eq control_X 0))\n                         ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_Y 0)))\n                       (control_Z \\<leftarrow> Const (Suc 0)) ?\\<Gamma>'78\n                       ?\\<S>'78 ?P''100\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P'100 {Eq control_Y 0}\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''100 {bexp_neg (Eq control_Y 0)}\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_X 0)))\n                       (control_Z \\<leftarrow> Const (Suc 0)) ?\\<Gamma>'78\n                       ?\\<S>'78 ?P''81\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_Y 0) `\n                          (?P'100 - {Eq control_Y 0}) \\<union>\n                          Imp (bexp_neg (Eq control_Y 0)) `\n                          (?P''100 - {bexp_neg (Eq control_Y 0)}))\n                         {v. stable ?\\<S>'78 v})\n                       {Eq control_X 0}\n 9. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''81 {bexp_neg (Eq control_X 0)}\n 10. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n     \\<Longrightarrow> has_type ?\\<Gamma>'78 ?\\<S>'78\n                        (restrict_preds_to_vars\n                          (Imp (Eq control_X 0) `\n                           (restrict_preds_to_vars\n                             (Imp (Eq control_Y 0) `\n                              (?P'100 - {Eq control_Y 0}) \\<union>\n                              Imp (bexp_neg (Eq control_Y 0)) `\n                              (?P''100 - {bexp_neg (Eq control_Y 0)}))\n                             {v. stable ?\\<S>'78 v} -\n                            {Eq control_X 0}) \\<union>\n                           Imp (bexp_neg (Eq control_X 0)) `\n                           (?P''81 - {bexp_neg (Eq control_X 0)}))\n                          {v. stable ?\\<S>'78 v})\n                        ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                         (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                         (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                         (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                        ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule type_bexprI)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?t100 =\n                      \\<Union>\n                       (to_total\n                         [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}] `\n                        bexp_vars (Eq control_Y 0))\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (Eq control_X 0))\n                       ?t100\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred\n                         (add_pred {}\n                           ({control_Z, control_Y, control_X}, {Z})\n                           (Eq control_X 0))\n                         ({control_Z, control_Y, control_X}, {Z})\n                         (Eq control_Y 0))\n                       (control_Z \\<leftarrow> Const 0) ?\\<Gamma>'78\n                       ?\\<S>'78 ?P'100\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred\n                         (add_pred {}\n                           ({control_Z, control_Y, control_X}, {Z})\n                           (Eq control_X 0))\n                         ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_Y 0)))\n                       (control_Z \\<leftarrow> Const (Suc 0)) ?\\<Gamma>'78\n                       ?\\<S>'78 ?P''100\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P'100 {Eq control_Y 0}\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''100 {bexp_neg (Eq control_Y 0)}\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_X 0)))\n                       (control_Z \\<leftarrow> Const (Suc 0)) ?\\<Gamma>'78\n                       ?\\<S>'78 ?P''81\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_Y 0) `\n                          (?P'100 - {Eq control_Y 0}) \\<union>\n                          Imp (bexp_neg (Eq control_Y 0)) `\n                          (?P''100 - {bexp_neg (Eq control_Y 0)}))\n                         {v. stable ?\\<S>'78 v})\n                       {Eq control_X 0}\n 9. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''81 {bexp_neg (Eq control_X 0)}\n 10. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n     \\<Longrightarrow> has_type ?\\<Gamma>'78 ?\\<S>'78\n                        (restrict_preds_to_vars\n                          (Imp (Eq control_X 0) `\n                           (restrict_preds_to_vars\n                             (Imp (Eq control_Y 0) `\n                              (?P'100 - {Eq control_Y 0}) \\<union>\n                              Imp (bexp_neg (Eq control_Y 0)) `\n                              (?P''100 - {bexp_neg (Eq control_Y 0)}))\n                             {v. stable ?\\<S>'78 v} -\n                            {Eq control_X 0}) \\<union>\n                           Imp (bexp_neg (Eq control_X 0)) `\n                           (?P''81 - {bexp_neg (Eq control_X 0)}))\n                          {v. stable ?\\<S>'78 v})\n                        ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                         (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                         (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                         (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                        ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(clarsimp simp: to_total_def)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?t100 = {}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (Eq control_X 0))\n                       ?t100\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred\n                         (add_pred {}\n                           ({control_Z, control_Y, control_X}, {Z})\n                           (Eq control_X 0))\n                         ({control_Z, control_Y, control_X}, {Z})\n                         (Eq control_Y 0))\n                       (control_Z \\<leftarrow> Const 0) ?\\<Gamma>'78\n                       ?\\<S>'78 ?P'100\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred\n                         (add_pred {}\n                           ({control_Z, control_Y, control_X}, {Z})\n                           (Eq control_X 0))\n                         ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_Y 0)))\n                       (control_Z \\<leftarrow> Const (Suc 0)) ?\\<Gamma>'78\n                       ?\\<S>'78 ?P''100\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P'100 {Eq control_Y 0}\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''100 {bexp_neg (Eq control_Y 0)}\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_X 0)))\n                       (control_Z \\<leftarrow> Const (Suc 0)) ?\\<Gamma>'78\n                       ?\\<S>'78 ?P''81\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_Y 0) `\n                          (?P'100 - {Eq control_Y 0}) \\<union>\n                          Imp (bexp_neg (Eq control_Y 0)) `\n                          (?P''100 - {bexp_neg (Eq control_Y 0)}))\n                         {v. stable ?\\<S>'78 v})\n                       {Eq control_X 0}\n 9. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''81 {bexp_neg (Eq control_X 0)}\n 10. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n     \\<Longrightarrow> has_type ?\\<Gamma>'78 ?\\<S>'78\n                        (restrict_preds_to_vars\n                          (Imp (Eq control_X 0) `\n                           (restrict_preds_to_vars\n                             (Imp (Eq control_Y 0) `\n                              (?P'100 - {Eq control_Y 0}) \\<union>\n                              Imp (bexp_neg (Eq control_Y 0)) `\n                              (?P''100 - {bexp_neg (Eq control_Y 0)}))\n                             {v. stable ?\\<S>'78 v} -\n                            {Eq control_X 0}) \\<union>\n                           Imp (bexp_neg (Eq control_X 0)) `\n                           (?P''81 - {bexp_neg (Eq control_X 0)}))\n                          {v. stable ?\\<S>'78 v})\n                        ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                         (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                         (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                         (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                        ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule HOL.refl)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (Eq control_X 0))\n                       {}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred\n                         (add_pred {}\n                           ({control_Z, control_Y, control_X}, {Z})\n                           (Eq control_X 0))\n                         ({control_Z, control_Y, control_X}, {Z})\n                         (Eq control_Y 0))\n                       (control_Z \\<leftarrow> Const 0) ?\\<Gamma>'78\n                       ?\\<S>'78 ?P'100\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred\n                         (add_pred {}\n                           ({control_Z, control_Y, control_X}, {Z})\n                           (Eq control_X 0))\n                         ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_Y 0)))\n                       (control_Z \\<leftarrow> Const (Suc 0)) ?\\<Gamma>'78\n                       ?\\<S>'78 ?P''100\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P'100 {Eq control_Y 0}\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''100 {bexp_neg (Eq control_Y 0)}\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_X 0)))\n                       (control_Z \\<leftarrow> Const (Suc 0)) ?\\<Gamma>'78\n                       ?\\<S>'78 ?P''81\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_Y 0) `\n                          (?P'100 - {Eq control_Y 0}) \\<union>\n                          Imp (bexp_neg (Eq control_Y 0)) `\n                          (?P''100 - {bexp_neg (Eq control_Y 0)}))\n                         {v. stable ?\\<S>'78 v})\n                       {Eq control_X 0}\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''81 {bexp_neg (Eq control_X 0)}\n 9. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'78 ?\\<S>'78\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (restrict_preds_to_vars\n                            (Imp (Eq control_Y 0) `\n                             (?P'100 - {Eq control_Y 0}) \\<union>\n                             Imp (bexp_neg (Eq control_Y 0)) `\n                             (?P''100 - {bexp_neg (Eq control_Y 0)}))\n                            {v. stable ?\\<S>'78 v} -\n                           {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          (?P''81 - {bexp_neg (Eq control_X 0)}))\n                         {v. stable ?\\<S>'78 v})\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred\n                         (add_pred {}\n                           ({control_Z, control_Y, control_X}, {Z})\n                           (Eq control_X 0))\n                         ({control_Z, control_Y, control_X}, {Z})\n                         (Eq control_Y 0))\n                       (control_Z \\<leftarrow> Const 0) ?\\<Gamma>'78\n                       ?\\<S>'78 ?P'100\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred\n                         (add_pred {}\n                           ({control_Z, control_Y, control_X}, {Z})\n                           (Eq control_X 0))\n                         ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_Y 0)))\n                       (control_Z \\<leftarrow> Const (Suc 0)) ?\\<Gamma>'78\n                       ?\\<S>'78 ?P''100\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P'100 {Eq control_Y 0}\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''100 {bexp_neg (Eq control_Y 0)}\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_X 0)))\n                       (control_Z \\<leftarrow> Const (Suc 0)) ?\\<Gamma>'78\n                       ?\\<S>'78 ?P''81\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_Y 0) `\n                          (?P'100 - {Eq control_Y 0}) \\<union>\n                          Imp (bexp_neg (Eq control_Y 0)) `\n                          (?P''100 - {bexp_neg (Eq control_Y 0)}))\n                         {v. stable ?\\<S>'78 v})\n                       {Eq control_X 0}\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''81 {bexp_neg (Eq control_X 0)}\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'78 ?\\<S>'78\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (restrict_preds_to_vars\n                            (Imp (Eq control_Y 0) `\n                             (?P'100 - {Eq control_Y 0}) \\<union>\n                             Imp (bexp_neg (Eq control_Y 0)) `\n                             (?P''100 - {bexp_neg (Eq control_Y 0)}))\n                            {v. stable ?\\<S>'78 v} -\n                           {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          (?P''81 - {bexp_neg (Eq control_X 0)}))\n                         {v. stable ?\\<S>'78 v})\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule assign\\<^sub>\\<C>)"], ["proof (prove)\ngoal (13 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> control_Z \\<in> \\<C>\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       (Const 0) ?t119\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (add_pred\n                         (add_pred {}\n                           ({control_Z, control_Y, control_X}, {Z})\n                           (Eq control_X 0))\n                         ({control_Z, control_Y, control_X}, {Z})\n                         (Eq control_Y 0))\n                       ?t119\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom\n[Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}].\n                         control_Z\n                         \\<notin> vars_of_type\n                                   (the ([Z \\<mapsto>\n    {Eq control_Y 0, Eq control_X 0}]\n    v))\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'100 =\n                      restrict_preds_to_vars\n                       (assign_post\n                         (add_pred\n                           (add_pred {}\n                             ({control_Z, control_Y, control_X}, {Z})\n                             (Eq control_X 0))\n                           ({control_Z, control_Y, control_X}, {Z})\n                           (Eq control_Y 0))\n                         control_Z (Const 0))\n                       {v. stable ({control_Z, control_Y, control_X}, {Z})\n                            v}\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         control_Z \\<in> \\<C>_vars v \\<and>\n                         v \\<notin> snd ({control_Z, control_Y, control_X},\n   {Z}) \\<longrightarrow>\n                         pred_entailment\n                          (add_pred\n                            (add_pred {}\n                              ({control_Z, control_Y, control_X}, {Z})\n                              (Eq control_X 0))\n                            ({control_Z, control_Y, control_X}, {Z})\n                            (Eq control_Y 0))\n                          (to_total\n                            [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                            v) \\<and>\n                         subtype\n                          (to_total\n                            [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                            v)\n                          ?P'100 (dma_type v)\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred\n                         (add_pred {}\n                           ({control_Z, control_Y, control_X}, {Z})\n                           (Eq control_X 0))\n                         ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_Y 0)))\n                       (control_Z \\<leftarrow> Const (Suc 0))\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z}) ?P''100\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P'100 {Eq control_Y 0}\n 9. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''100 {bexp_neg (Eq control_Y 0)}\n 10. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n     \\<Longrightarrow> has_type\n                        [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                        ({control_Z, control_Y, control_X}, {Z})\n                        (add_pred {}\n                          ({control_Z, control_Y, control_X}, {Z})\n                          (bexp_neg (Eq control_X 0)))\n                        (control_Z \\<leftarrow> Const (Suc 0))\n                        [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                        ({control_Z, control_Y, control_X}, {Z}) ?P''81\nA total of 13 subgoals...", "apply simp"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       (Const 0) ?t119\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (add_pred\n                         (add_pred {}\n                           ({control_Z, control_Y, control_X}, {Z})\n                           (Eq control_X 0))\n                         ({control_Z, control_Y, control_X}, {Z})\n                         (Eq control_Y 0))\n                       ?t119\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom\n[Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}].\n                         control_Z\n                         \\<notin> vars_of_type\n                                   (the ([Z \\<mapsto>\n    {Eq control_Y 0, Eq control_X 0}]\n    v))\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'100 =\n                      restrict_preds_to_vars\n                       (assign_post\n                         (add_pred\n                           (add_pred {}\n                             ({control_Z, control_Y, control_X}, {Z})\n                             (Eq control_X 0))\n                           ({control_Z, control_Y, control_X}, {Z})\n                           (Eq control_Y 0))\n                         control_Z (Const 0))\n                       {v. stable ({control_Z, control_Y, control_X}, {Z})\n                            v}\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         control_Z \\<in> \\<C>_vars v \\<and>\n                         v \\<notin> snd ({control_Z, control_Y, control_X},\n   {Z}) \\<longrightarrow>\n                         pred_entailment\n                          (add_pred\n                            (add_pred {}\n                              ({control_Z, control_Y, control_X}, {Z})\n                              (Eq control_X 0))\n                            ({control_Z, control_Y, control_X}, {Z})\n                            (Eq control_Y 0))\n                          (to_total\n                            [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                            v) \\<and>\n                         subtype\n                          (to_total\n                            [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                            v)\n                          ?P'100 (dma_type v)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred\n                         (add_pred {}\n                           ({control_Z, control_Y, control_X}, {Z})\n                           (Eq control_X 0))\n                         ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_Y 0)))\n                       (control_Z \\<leftarrow> Const (Suc 0))\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z}) ?P''100\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P'100 {Eq control_Y 0}\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''100 {bexp_neg (Eq control_Y 0)}\n 9. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_X 0)))\n                       (control_Z \\<leftarrow> Const (Suc 0))\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z}) ?P''81\n 10. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n     \\<Longrightarrow> pred_entailment\n                        (restrict_preds_to_vars\n                          (Imp (Eq control_Y 0) `\n                           (?P'100 - {Eq control_Y 0}) \\<union>\n                           Imp (bexp_neg (Eq control_Y 0)) `\n                           (?P''100 - {bexp_neg (Eq control_Y 0)}))\n                          {v. stable\n                               ({control_Z, control_Y, control_X}, {Z}) v})\n                        {Eq control_X 0}\nA total of 12 subgoals...", "apply(rule type_aexpr_Const)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (add_pred\n                         (add_pred {}\n                           ({control_Z, control_Y, control_X}, {Z})\n                           (Eq control_X 0))\n                         ({control_Z, control_Y, control_X}, {Z})\n                         (Eq control_Y 0))\n                       {}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom\n[Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}].\n                         control_Z\n                         \\<notin> vars_of_type\n                                   (the ([Z \\<mapsto>\n    {Eq control_Y 0, Eq control_X 0}]\n    v))\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'100 =\n                      restrict_preds_to_vars\n                       (assign_post\n                         (add_pred\n                           (add_pred {}\n                             ({control_Z, control_Y, control_X}, {Z})\n                             (Eq control_X 0))\n                           ({control_Z, control_Y, control_X}, {Z})\n                           (Eq control_Y 0))\n                         control_Z (Const 0))\n                       {v. stable ({control_Z, control_Y, control_X}, {Z})\n                            v}\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         control_Z \\<in> \\<C>_vars v \\<and>\n                         v \\<notin> snd ({control_Z, control_Y, control_X},\n   {Z}) \\<longrightarrow>\n                         pred_entailment\n                          (add_pred\n                            (add_pred {}\n                              ({control_Z, control_Y, control_X}, {Z})\n                              (Eq control_X 0))\n                            ({control_Z, control_Y, control_X}, {Z})\n                            (Eq control_Y 0))\n                          (to_total\n                            [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                            v) \\<and>\n                         subtype\n                          (to_total\n                            [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                            v)\n                          ?P'100 (dma_type v)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred\n                         (add_pred {}\n                           ({control_Z, control_Y, control_X}, {Z})\n                           (Eq control_X 0))\n                         ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_Y 0)))\n                       (control_Z \\<leftarrow> Const (Suc 0))\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z}) ?P''100\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P'100 {Eq control_Y 0}\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''100 {bexp_neg (Eq control_Y 0)}\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_X 0)))\n                       (control_Z \\<leftarrow> Const (Suc 0))\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z}) ?P''81\n 9. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_Y 0) `\n                          (?P'100 - {Eq control_Y 0}) \\<union>\n                          Imp (bexp_neg (Eq control_Y 0)) `\n                          (?P''100 - {bexp_neg (Eq control_Y 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       {Eq control_X 0}\n 10. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n     \\<Longrightarrow> pred_entailment ?P''81 {bexp_neg (Eq control_X 0)}\nA total of 11 subgoals...", "apply simp"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom\n[Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}].\n                         control_Z\n                         \\<notin> vars_of_type\n                                   (the ([Z \\<mapsto>\n    {Eq control_Y 0, Eq control_X 0}]\n    v))\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'100 =\n                      restrict_preds_to_vars\n                       (assign_post\n                         (add_pred\n                           (add_pred {}\n                             ({control_Z, control_Y, control_X}, {Z})\n                             (Eq control_X 0))\n                           ({control_Z, control_Y, control_X}, {Z})\n                           (Eq control_Y 0))\n                         control_Z (Const 0))\n                       {v. stable ({control_Z, control_Y, control_X}, {Z})\n                            v}\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         control_Z \\<in> \\<C>_vars v \\<and>\n                         v \\<notin> snd ({control_Z, control_Y, control_X},\n   {Z}) \\<longrightarrow>\n                         pred_entailment\n                          (add_pred\n                            (add_pred {}\n                              ({control_Z, control_Y, control_X}, {Z})\n                              (Eq control_X 0))\n                            ({control_Z, control_Y, control_X}, {Z})\n                            (Eq control_Y 0))\n                          (to_total\n                            [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                            v) \\<and>\n                         subtype\n                          (to_total\n                            [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                            v)\n                          ?P'100 (dma_type v)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred\n                         (add_pred {}\n                           ({control_Z, control_Y, control_X}, {Z})\n                           (Eq control_X 0))\n                         ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_Y 0)))\n                       (control_Z \\<leftarrow> Const (Suc 0))\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z}) ?P''100\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P'100 {Eq control_Y 0}\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''100 {bexp_neg (Eq control_Y 0)}\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_X 0)))\n                       (control_Z \\<leftarrow> Const (Suc 0))\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z}) ?P''81\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_Y 0) `\n                          (?P'100 - {Eq control_Y 0}) \\<union>\n                          Imp (bexp_neg (Eq control_Y 0)) `\n                          (?P''100 - {bexp_neg (Eq control_Y 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       {Eq control_X 0}\n 9. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''81 {bexp_neg (Eq control_X 0)}\n 10. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n     \\<Longrightarrow> has_type\n                        [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                        ({control_Z, control_Y, control_X}, {Z})\n                        (restrict_preds_to_vars\n                          (Imp (Eq control_X 0) `\n                           (restrict_preds_to_vars\n                             (Imp (Eq control_Y 0) `\n                              (?P'100 - {Eq control_Y 0}) \\<union>\n                              Imp (bexp_neg (Eq control_Y 0)) `\n                              (?P''100 - {bexp_neg (Eq control_Y 0)}))\n                             {v. stable\n                                  ({control_Z, control_Y, control_X}, {Z})\n                                  v} -\n                            {Eq control_X 0}) \\<union>\n                           Imp (bexp_neg (Eq control_X 0)) `\n                           (?P''81 - {bexp_neg (Eq control_X 0)}))\n                          {v. stable\n                               ({control_Z, control_Y, control_X}, {Z}) v})\n                        ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                         (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                         (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                         (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                        ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply (clarsimp, fast)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         control_Z \\<in> \\<C>_vars v \\<and>\n                         v \\<notin> snd ({control_Z, control_Y, control_X},\n   {Z}) \\<longrightarrow>\n                         pred_entailment\n                          (add_pred\n                            (add_pred {}\n                              ({control_Z, control_Y, control_X}, {Z})\n                              (Eq control_X 0))\n                            ({control_Z, control_Y, control_X}, {Z})\n                            (Eq control_Y 0))\n                          (to_total\n                            [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                            v) \\<and>\n                         subtype\n                          (to_total\n                            [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                            v)\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred\n                                (add_pred {}\n                                  ({control_Z, control_Y, control_X}, {Z})\n                                  (Eq control_X 0))\n                                ({control_Z, control_Y, control_X}, {Z})\n                                (Eq control_Y 0))\n                              control_Z (Const 0))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v})\n                          (dma_type v)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred\n                         (add_pred {}\n                           ({control_Z, control_Y, control_X}, {Z})\n                           (Eq control_X 0))\n                         ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_Y 0)))\n                       (control_Z \\<leftarrow> Const (Suc 0))\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z}) ?P''100\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred\n                             (add_pred {}\n                               ({control_Z, control_Y, control_X}, {Z})\n                               (Eq control_X 0))\n                             ({control_Z, control_Y, control_X}, {Z})\n                             (Eq control_Y 0))\n                           control_Z (Const 0))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       {Eq control_Y 0}\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''100 {bexp_neg (Eq control_Y 0)}\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_X 0)))\n                       (control_Z \\<leftarrow> Const (Suc 0))\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z}) ?P''81\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_Y 0) `\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred\n                                (add_pred {}\n                                  ({control_Z, control_Y, control_X}, {Z})\n                                  (Eq control_X 0))\n                                ({control_Z, control_Y, control_X}, {Z})\n                                (Eq control_Y 0))\n                              control_Z (Const 0))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_Y 0}) \\<union>\n                          Imp (bexp_neg (Eq control_Y 0)) `\n                          (?P''100 - {bexp_neg (Eq control_Y 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       {Eq control_X 0}\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''81 {bexp_neg (Eq control_X 0)}\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (restrict_preds_to_vars\n                            (Imp (Eq control_Y 0) `\n                             (restrict_preds_to_vars\n                               (assign_post\n                                 (add_pred\n                                   (add_pred {}\n                                     ({control_Z, control_Y, control_X},\n{Z})\n                                     (Eq control_X 0))\n                                   ({control_Z, control_Y, control_X}, {Z})\n                                   (Eq control_Y 0))\n                                 control_Z (Const 0))\n                               {v. stable\n                                    ({control_Z, control_Y, control_X}, {Z})\n                                    v} -\n                              {Eq control_Y 0}) \\<union>\n                             Imp (bexp_neg (Eq control_Y 0)) `\n                             (?P''100 - {bexp_neg (Eq control_Y 0)}))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          (?P''81 - {bexp_neg (Eq control_X 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(simp)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred\n                         (add_pred {}\n                           ({control_Z, control_Y, control_X}, {Z})\n                           (Eq control_X 0))\n                         ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_Y 0)))\n                       (control_Z \\<leftarrow> Const (Suc 0))\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z}) ?P''100\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred\n                             (add_pred {}\n                               ({control_Z, control_Y, control_X}, {Z})\n                               (Eq control_X 0))\n                             ({control_Z, control_Y, control_X}, {Z})\n                             (Eq control_Y 0))\n                           control_Z (Const 0))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       {Eq control_Y 0}\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''100 {bexp_neg (Eq control_Y 0)}\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_X 0)))\n                       (control_Z \\<leftarrow> Const (Suc 0))\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z}) ?P''81\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_Y 0) `\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred\n                                (add_pred {}\n                                  ({control_Z, control_Y, control_X}, {Z})\n                                  (Eq control_X 0))\n                                ({control_Z, control_Y, control_X}, {Z})\n                                (Eq control_Y 0))\n                              control_Z (Const 0))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_Y 0}) \\<union>\n                          Imp (bexp_neg (Eq control_Y 0)) `\n                          (?P''100 - {bexp_neg (Eq control_Y 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       {Eq control_X 0}\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''81 {bexp_neg (Eq control_X 0)}\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (restrict_preds_to_vars\n                            (Imp (Eq control_Y 0) `\n                             (restrict_preds_to_vars\n                               (assign_post\n                                 (add_pred\n                                   (add_pred {}\n                                     ({control_Z, control_Y, control_X},\n{Z})\n                                     (Eq control_X 0))\n                                   ({control_Z, control_Y, control_X}, {Z})\n                                   (Eq control_Y 0))\n                                 control_Z (Const 0))\n                               {v. stable\n                                    ({control_Z, control_Y, control_X}, {Z})\n                                    v} -\n                              {Eq control_Y 0}) \\<union>\n                             Imp (bexp_neg (Eq control_Y 0)) `\n                             (?P''100 - {bexp_neg (Eq control_Y 0)}))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          (?P''81 - {bexp_neg (Eq control_X 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       {bexp.Not (Eq control_Y 0), Eq control_X 0}\n                       (control_Z \\<leftarrow> Const (Suc 0))\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z}) ?P''100\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred\n                             (add_pred {}\n                               ({control_Z, control_Y, control_X}, {Z})\n                               (Eq control_X 0))\n                             ({control_Z, control_Y, control_X}, {Z})\n                             (Eq control_Y 0))\n                           control_Z (Const 0))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       {Eq control_Y 0}\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''100 {bexp_neg (Eq control_Y 0)}\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_X 0)))\n                       (control_Z \\<leftarrow> Const (Suc 0))\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z}) ?P''81\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_Y 0) `\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred\n                                (add_pred {}\n                                  ({control_Z, control_Y, control_X}, {Z})\n                                  (Eq control_X 0))\n                                ({control_Z, control_Y, control_X}, {Z})\n                                (Eq control_Y 0))\n                              control_Z (Const 0))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_Y 0}) \\<union>\n                          Imp (bexp_neg (Eq control_Y 0)) `\n                          (?P''100 - {bexp_neg (Eq control_Y 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       {Eq control_X 0}\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''81 {bexp_neg (Eq control_X 0)}\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (restrict_preds_to_vars\n                            (Imp (Eq control_Y 0) `\n                             (restrict_preds_to_vars\n                               (assign_post\n                                 (add_pred\n                                   (add_pred {}\n                                     ({control_Z, control_Y, control_X},\n{Z})\n                                     (Eq control_X 0))\n                                   ({control_Z, control_Y, control_X}, {Z})\n                                   (Eq control_Y 0))\n                                 control_Z (Const 0))\n                               {v. stable\n                                    ({control_Z, control_Y, control_X}, {Z})\n                                    v} -\n                              {Eq control_Y 0}) \\<union>\n                             Imp (bexp_neg (Eq control_Y 0)) `\n                             (?P''100 - {bexp_neg (Eq control_Y 0)}))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          (?P''81 - {bexp_neg (Eq control_X 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule assign\\<^sub>\\<C>)"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> control_Z \\<in> \\<C>\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       (Const (Suc 0)) ?t139\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       {bexp.Not (Eq control_Y 0), Eq control_X 0} ?t139\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom\n[Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}].\n                         control_Z\n                         \\<notin> vars_of_type\n                                   (the ([Z \\<mapsto>\n    {Eq control_Y 0, Eq control_X 0}]\n    v))\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P''100 =\n                      restrict_preds_to_vars\n                       (assign_post\n                         {bexp.Not (Eq control_Y 0), Eq control_X 0}\n                         control_Z (Const (Suc 0)))\n                       {v. stable ({control_Z, control_Y, control_X}, {Z})\n                            v}\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         control_Z \\<in> \\<C>_vars v \\<and>\n                         v \\<notin> snd ({control_Z, control_Y, control_X},\n   {Z}) \\<longrightarrow>\n                         pred_entailment\n                          {bexp.Not (Eq control_Y 0), Eq control_X 0}\n                          (to_total\n                            [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                            v) \\<and>\n                         subtype\n                          (to_total\n                            [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                            v)\n                          ?P''100 (dma_type v)\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred\n                             (add_pred {}\n                               ({control_Z, control_Y, control_X}, {Z})\n                               (Eq control_X 0))\n                             ({control_Z, control_Y, control_X}, {Z})\n                             (Eq control_Y 0))\n                           control_Z (Const 0))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       {Eq control_Y 0}\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''100 {bexp_neg (Eq control_Y 0)}\n 9. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_X 0)))\n                       (control_Z \\<leftarrow> Const (Suc 0))\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z}) ?P''81\n 10. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n     \\<Longrightarrow> pred_entailment\n                        (restrict_preds_to_vars\n                          (Imp (Eq control_Y 0) `\n                           (restrict_preds_to_vars\n                             (assign_post\n                               (add_pred\n                                 (add_pred {}\n                                   ({control_Z, control_Y, control_X}, {Z})\n                                   (Eq control_X 0))\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 (Eq control_Y 0))\n                               control_Z (Const 0))\n                             {v. stable\n                                  ({control_Z, control_Y, control_X}, {Z})\n                                  v} -\n                            {Eq control_Y 0}) \\<union>\n                           Imp (bexp_neg (Eq control_Y 0)) `\n                           (?P''100 - {bexp_neg (Eq control_Y 0)}))\n                          {v. stable\n                               ({control_Z, control_Y, control_X}, {Z}) v})\n                        {Eq control_X 0}\nA total of 12 subgoals...", "apply simp"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       (Const (Suc 0)) ?t139\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       {bexp.Not (Eq control_Y 0), Eq control_X 0} ?t139\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom\n[Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}].\n                         control_Z\n                         \\<notin> vars_of_type\n                                   (the ([Z \\<mapsto>\n    {Eq control_Y 0, Eq control_X 0}]\n    v))\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P''100 =\n                      restrict_preds_to_vars\n                       (assign_post\n                         {bexp.Not (Eq control_Y 0), Eq control_X 0}\n                         control_Z (Const (Suc 0)))\n                       {v. stable ({control_Z, control_Y, control_X}, {Z})\n                            v}\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         control_Z \\<in> \\<C>_vars v \\<and>\n                         v \\<notin> snd ({control_Z, control_Y, control_X},\n   {Z}) \\<longrightarrow>\n                         pred_entailment\n                          {bexp.Not (Eq control_Y 0), Eq control_X 0}\n                          (to_total\n                            [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                            v) \\<and>\n                         subtype\n                          (to_total\n                            [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                            v)\n                          ?P''100 (dma_type v)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred\n                             (add_pred {}\n                               ({control_Z, control_Y, control_X}, {Z})\n                               (Eq control_X 0))\n                             ({control_Z, control_Y, control_X}, {Z})\n                             (Eq control_Y 0))\n                           control_Z (Const 0))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       {Eq control_Y 0}\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''100 {bexp_neg (Eq control_Y 0)}\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_X 0)))\n                       (control_Z \\<leftarrow> Const (Suc 0))\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z}) ?P''81\n 9. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_Y 0) `\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred\n                                (add_pred {}\n                                  ({control_Z, control_Y, control_X}, {Z})\n                                  (Eq control_X 0))\n                                ({control_Z, control_Y, control_X}, {Z})\n                                (Eq control_Y 0))\n                              control_Z (Const 0))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_Y 0}) \\<union>\n                          Imp (bexp_neg (Eq control_Y 0)) `\n                          (?P''100 - {bexp_neg (Eq control_Y 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       {Eq control_X 0}\n 10. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n     \\<Longrightarrow> pred_entailment ?P''81 {bexp_neg (Eq control_X 0)}\nA total of 11 subgoals...", "apply(rule type_aexpr_Const)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       {bexp.Not (Eq control_Y 0), Eq control_X 0} {}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom\n[Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}].\n                         control_Z\n                         \\<notin> vars_of_type\n                                   (the ([Z \\<mapsto>\n    {Eq control_Y 0, Eq control_X 0}]\n    v))\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P''100 =\n                      restrict_preds_to_vars\n                       (assign_post\n                         {bexp.Not (Eq control_Y 0), Eq control_X 0}\n                         control_Z (Const (Suc 0)))\n                       {v. stable ({control_Z, control_Y, control_X}, {Z})\n                            v}\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         control_Z \\<in> \\<C>_vars v \\<and>\n                         v \\<notin> snd ({control_Z, control_Y, control_X},\n   {Z}) \\<longrightarrow>\n                         pred_entailment\n                          {bexp.Not (Eq control_Y 0), Eq control_X 0}\n                          (to_total\n                            [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                            v) \\<and>\n                         subtype\n                          (to_total\n                            [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                            v)\n                          ?P''100 (dma_type v)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred\n                             (add_pred {}\n                               ({control_Z, control_Y, control_X}, {Z})\n                               (Eq control_X 0))\n                             ({control_Z, control_Y, control_X}, {Z})\n                             (Eq control_Y 0))\n                           control_Z (Const 0))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       {Eq control_Y 0}\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''100 {bexp_neg (Eq control_Y 0)}\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_X 0)))\n                       (control_Z \\<leftarrow> Const (Suc 0))\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z}) ?P''81\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_Y 0) `\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred\n                                (add_pred {}\n                                  ({control_Z, control_Y, control_X}, {Z})\n                                  (Eq control_X 0))\n                                ({control_Z, control_Y, control_X}, {Z})\n                                (Eq control_Y 0))\n                              control_Z (Const 0))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_Y 0}) \\<union>\n                          Imp (bexp_neg (Eq control_Y 0)) `\n                          (?P''100 - {bexp_neg (Eq control_Y 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       {Eq control_X 0}\n 9. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''81 {bexp_neg (Eq control_X 0)}\n 10. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n     \\<Longrightarrow> has_type\n                        [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                        ({control_Z, control_Y, control_X}, {Z})\n                        (restrict_preds_to_vars\n                          (Imp (Eq control_X 0) `\n                           (restrict_preds_to_vars\n                             (Imp (Eq control_Y 0) `\n                              (restrict_preds_to_vars\n                                (assign_post\n                                  (add_pred\n                                    (add_pred {}\n({control_Z, control_Y, control_X}, {Z}) (Eq control_X 0))\n                                    ({control_Z, control_Y, control_X}, {Z})\n                                    (Eq control_Y 0))\n                                  control_Z (Const 0))\n                                {v. stable\n                                     ({control_Z, control_Y, control_X},\n{Z})\n                                     v} -\n                               {Eq control_Y 0}) \\<union>\n                              Imp (bexp_neg (Eq control_Y 0)) `\n                              (?P''100 - {bexp_neg (Eq control_Y 0)}))\n                             {v. stable\n                                  ({control_Z, control_Y, control_X}, {Z})\n                                  v} -\n                            {Eq control_X 0}) \\<union>\n                           Imp (bexp_neg (Eq control_X 0)) `\n                           (?P''81 - {bexp_neg (Eq control_X 0)}))\n                          {v. stable\n                               ({control_Z, control_Y, control_X}, {Z}) v})\n                        ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                         (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                         (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                         (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                        ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom\n[Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}].\n                         control_Z\n                         \\<notin> vars_of_type\n                                   (the ([Z \\<mapsto>\n    {Eq control_Y 0, Eq control_X 0}]\n    v))\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P''100 =\n                      restrict_preds_to_vars\n                       (assign_post\n                         {bexp.Not (Eq control_Y 0), Eq control_X 0}\n                         control_Z (Const (Suc 0)))\n                       {v. stable ({control_Z, control_Y, control_X}, {Z})\n                            v}\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         control_Z \\<in> \\<C>_vars v \\<and>\n                         v \\<notin> snd ({control_Z, control_Y, control_X},\n   {Z}) \\<longrightarrow>\n                         pred_entailment\n                          {bexp.Not (Eq control_Y 0), Eq control_X 0}\n                          (to_total\n                            [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                            v) \\<and>\n                         subtype\n                          (to_total\n                            [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                            v)\n                          ?P''100 (dma_type v)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred\n                             (add_pred {}\n                               ({control_Z, control_Y, control_X}, {Z})\n                               (Eq control_X 0))\n                             ({control_Z, control_Y, control_X}, {Z})\n                             (Eq control_Y 0))\n                           control_Z (Const 0))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       {Eq control_Y 0}\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''100 {bexp_neg (Eq control_Y 0)}\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_X 0)))\n                       (control_Z \\<leftarrow> Const (Suc 0))\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z}) ?P''81\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_Y 0) `\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred\n                                (add_pred {}\n                                  ({control_Z, control_Y, control_X}, {Z})\n                                  (Eq control_X 0))\n                                ({control_Z, control_Y, control_X}, {Z})\n                                (Eq control_Y 0))\n                              control_Z (Const 0))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_Y 0}) \\<union>\n                          Imp (bexp_neg (Eq control_Y 0)) `\n                          (?P''100 - {bexp_neg (Eq control_Y 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       {Eq control_X 0}\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''81 {bexp_neg (Eq control_X 0)}\n 9. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (restrict_preds_to_vars\n                            (Imp (Eq control_Y 0) `\n                             (restrict_preds_to_vars\n                               (assign_post\n                                 (add_pred\n                                   (add_pred {}\n                                     ({control_Z, control_Y, control_X},\n{Z})\n                                     (Eq control_X 0))\n                                   ({control_Z, control_Y, control_X}, {Z})\n                                   (Eq control_Y 0))\n                                 control_Z (Const 0))\n                               {v. stable\n                                    ({control_Z, control_Y, control_X}, {Z})\n                                    v} -\n                              {Eq control_Y 0}) \\<union>\n                             Imp (bexp_neg (Eq control_Y 0)) `\n                             (?P''100 - {bexp_neg (Eq control_Y 0)}))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          (?P''81 - {bexp_neg (Eq control_X 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply auto[1]"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P''100 =\n                      restrict_preds_to_vars\n                       (assign_post\n                         {bexp.Not (Eq control_Y 0), Eq control_X 0}\n                         control_Z (Const (Suc 0)))\n                       {v. stable ({control_Z, control_Y, control_X}, {Z})\n                            v}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         control_Z \\<in> \\<C>_vars v \\<and>\n                         v \\<notin> snd ({control_Z, control_Y, control_X},\n   {Z}) \\<longrightarrow>\n                         pred_entailment\n                          {bexp.Not (Eq control_Y 0), Eq control_X 0}\n                          (to_total\n                            [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                            v) \\<and>\n                         subtype\n                          (to_total\n                            [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                            v)\n                          ?P''100 (dma_type v)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred\n                             (add_pred {}\n                               ({control_Z, control_Y, control_X}, {Z})\n                               (Eq control_X 0))\n                             ({control_Z, control_Y, control_X}, {Z})\n                             (Eq control_Y 0))\n                           control_Z (Const 0))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       {Eq control_Y 0}\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''100 {bexp_neg (Eq control_Y 0)}\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_X 0)))\n                       (control_Z \\<leftarrow> Const (Suc 0))\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z}) ?P''81\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_Y 0) `\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred\n                                (add_pred {}\n                                  ({control_Z, control_Y, control_X}, {Z})\n                                  (Eq control_X 0))\n                                ({control_Z, control_Y, control_X}, {Z})\n                                (Eq control_Y 0))\n                              control_Z (Const 0))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_Y 0}) \\<union>\n                          Imp (bexp_neg (Eq control_Y 0)) `\n                          (?P''100 - {bexp_neg (Eq control_Y 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       {Eq control_X 0}\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''81 {bexp_neg (Eq control_X 0)}\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (restrict_preds_to_vars\n                            (Imp (Eq control_Y 0) `\n                             (restrict_preds_to_vars\n                               (assign_post\n                                 (add_pred\n                                   (add_pred {}\n                                     ({control_Z, control_Y, control_X},\n{Z})\n                                     (Eq control_X 0))\n                                   ({control_Z, control_Y, control_X}, {Z})\n                                   (Eq control_Y 0))\n                                 control_Z (Const 0))\n                               {v. stable\n                                    ({control_Z, control_Y, control_X}, {Z})\n                                    v} -\n                              {Eq control_Y 0}) \\<union>\n                             Imp (bexp_neg (Eq control_Y 0)) `\n                             (?P''100 - {bexp_neg (Eq control_Y 0)}))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          (?P''81 - {bexp_neg (Eq control_X 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(simp)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         control_Z \\<in> \\<C>_vars v \\<and>\n                         v \\<notin> snd ({control_Z, control_Y, control_X},\n   {Z}) \\<longrightarrow>\n                         pred_entailment\n                          {bexp.Not (Eq control_Y 0), Eq control_X 0}\n                          (to_total\n                            [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                            v) \\<and>\n                         subtype\n                          (to_total\n                            [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                            v)\n                          {Same control_Z (Const (Suc 0)),\n                           bexp.Not (Eq control_Y 0), Eq control_X 0}\n                          (dma_type v)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred\n                             (add_pred {}\n                               ({control_Z, control_Y, control_X}, {Z})\n                               (Eq control_X 0))\n                             ({control_Z, control_Y, control_X}, {Z})\n                             (Eq control_Y 0))\n                           control_Z (Const 0))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       {Eq control_Y 0}\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       {Same control_Z (Const (Suc 0)),\n                        bexp.Not (Eq control_Y 0), Eq control_X 0}\n                       {bexp_neg (Eq control_Y 0)}\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_X 0)))\n                       (control_Z \\<leftarrow> Const (Suc 0))\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z}) ?P''81\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_Y 0) `\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred\n                                (add_pred {}\n                                  ({control_Z, control_Y, control_X}, {Z})\n                                  (Eq control_X 0))\n                                ({control_Z, control_Y, control_X}, {Z})\n                                (Eq control_Y 0))\n                              control_Z (Const 0))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_Y 0}) \\<union>\n                          Imp (bexp_neg (Eq control_Y 0)) `\n                          ({Same control_Z (Const (Suc 0)),\n                            bexp.Not (Eq control_Y 0), Eq control_X 0} -\n                           {bexp_neg (Eq control_Y 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       {Eq control_X 0}\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''81 {bexp_neg (Eq control_X 0)}\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (restrict_preds_to_vars\n                            (Imp (Eq control_Y 0) `\n                             (restrict_preds_to_vars\n                               (assign_post\n                                 (add_pred\n                                   (add_pred {}\n                                     ({control_Z, control_Y, control_X},\n{Z})\n                                     (Eq control_X 0))\n                                   ({control_Z, control_Y, control_X}, {Z})\n                                   (Eq control_Y 0))\n                                 control_Z (Const 0))\n                               {v. stable\n                                    ({control_Z, control_Y, control_X}, {Z})\n                                    v} -\n                              {Eq control_Y 0}) \\<union>\n                             Imp (bexp_neg (Eq control_Y 0)) `\n                             ({Same control_Z (Const (Suc 0)),\n                               bexp.Not (Eq control_Y 0), Eq control_X 0} -\n                              {bexp_neg (Eq control_Y 0)}))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          (?P''81 - {bexp_neg (Eq control_X 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply clarsimp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred\n                             (add_pred {}\n                               ({control_Z, control_Y, control_X}, {Z})\n                               (Eq control_X 0))\n                             ({control_Z, control_Y, control_X}, {Z})\n                             (Eq control_Y 0))\n                           control_Z (Const 0))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       {Eq control_Y 0}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       {Same control_Z (Const (Suc 0)),\n                        bexp.Not (Eq control_Y 0), Eq control_X 0}\n                       {bexp_neg (Eq control_Y 0)}\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_X 0)))\n                       (control_Z \\<leftarrow> Const (Suc 0))\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z}) ?P''81\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_Y 0) `\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred\n                                (add_pred {}\n                                  ({control_Z, control_Y, control_X}, {Z})\n                                  (Eq control_X 0))\n                                ({control_Z, control_Y, control_X}, {Z})\n                                (Eq control_Y 0))\n                              control_Z (Const 0))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_Y 0}) \\<union>\n                          Imp (bexp_neg (Eq control_Y 0)) `\n                          ({Same control_Z (Const (Suc 0)),\n                            bexp.Not (Eq control_Y 0), Eq control_X 0} -\n                           {bexp_neg (Eq control_Y 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       {Eq control_X 0}\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''81 {bexp_neg (Eq control_X 0)}\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (restrict_preds_to_vars\n                            (Imp (Eq control_Y 0) `\n                             (restrict_preds_to_vars\n                               (assign_post\n                                 (add_pred\n                                   (add_pred {}\n                                     ({control_Z, control_Y, control_X},\n{Z})\n                                     (Eq control_X 0))\n                                   ({control_Z, control_Y, control_X}, {Z})\n                                   (Eq control_Y 0))\n                                 control_Z (Const 0))\n                               {v. stable\n                                    ({control_Z, control_Y, control_X}, {Z})\n                                    v} -\n                              {Eq control_Y 0}) \\<union>\n                             Imp (bexp_neg (Eq control_Y 0)) `\n                             ({Same control_Z (Const (Suc 0)),\n                               bexp.Not (Eq control_Y 0), Eq control_X 0} -\n                              {bexp_neg (Eq control_Y 0)}))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          (?P''81 - {bexp_neg (Eq control_X 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(clarsimp simp: subset_entailment)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       {Same control_Z (Const (Suc 0)),\n                        bexp.Not (Eq control_Y 0), Eq control_X 0}\n                       {bexp_neg (Eq control_Y 0)}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_X 0)))\n                       (control_Z \\<leftarrow> Const (Suc 0))\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z}) ?P''81\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_Y 0) `\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred\n                                (add_pred {}\n                                  ({control_Z, control_Y, control_X}, {Z})\n                                  (Eq control_X 0))\n                                ({control_Z, control_Y, control_X}, {Z})\n                                (Eq control_Y 0))\n                              control_Z (Const 0))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_Y 0}) \\<union>\n                          Imp (bexp_neg (Eq control_Y 0)) `\n                          ({Same control_Z (Const (Suc 0)),\n                            bexp.Not (Eq control_Y 0), Eq control_X 0} -\n                           {bexp_neg (Eq control_Y 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       {Eq control_X 0}\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''81 {bexp_neg (Eq control_X 0)}\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (restrict_preds_to_vars\n                            (Imp (Eq control_Y 0) `\n                             (restrict_preds_to_vars\n                               (assign_post\n                                 (add_pred\n                                   (add_pred {}\n                                     ({control_Z, control_Y, control_X},\n{Z})\n                                     (Eq control_X 0))\n                                   ({control_Z, control_Y, control_X}, {Z})\n                                   (Eq control_Y 0))\n                                 control_Z (Const 0))\n                               {v. stable\n                                    ({control_Z, control_Y, control_X}, {Z})\n                                    v} -\n                              {Eq control_Y 0}) \\<union>\n                             Imp (bexp_neg (Eq control_Y 0)) `\n                             ({Same control_Z (Const (Suc 0)),\n                               bexp.Not (Eq control_Y 0), Eq control_X 0} -\n                              {bexp_neg (Eq control_Y 0)}))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          (?P''81 - {bexp_neg (Eq control_X 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(clarsimp simp: subset_entailment)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_X 0)))\n                       (control_Z \\<leftarrow> Const (Suc 0))\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z}) ?P''81\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_Y 0) `\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred\n                                (add_pred {}\n                                  ({control_Z, control_Y, control_X}, {Z})\n                                  (Eq control_X 0))\n                                ({control_Z, control_Y, control_X}, {Z})\n                                (Eq control_Y 0))\n                              control_Z (Const 0))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_Y 0}) \\<union>\n                          Imp (bexp_neg (Eq control_Y 0)) `\n                          ({Same control_Z (Const (Suc 0)),\n                            bexp.Not (Eq control_Y 0), Eq control_X 0} -\n                           {bexp_neg (Eq control_Y 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       {Eq control_X 0}\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''81 {bexp_neg (Eq control_X 0)}\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (restrict_preds_to_vars\n                            (Imp (Eq control_Y 0) `\n                             (restrict_preds_to_vars\n                               (assign_post\n                                 (add_pred\n                                   (add_pred {}\n                                     ({control_Z, control_Y, control_X},\n{Z})\n                                     (Eq control_X 0))\n                                   ({control_Z, control_Y, control_X}, {Z})\n                                   (Eq control_Y 0))\n                                 control_Z (Const 0))\n                               {v. stable\n                                    ({control_Z, control_Y, control_X}, {Z})\n                                    v} -\n                              {Eq control_Y 0}) \\<union>\n                             Imp (bexp_neg (Eq control_Y 0)) `\n                             ({Same control_Z (Const (Suc 0)),\n                               bexp.Not (Eq control_Y 0), Eq control_X 0} -\n                              {bexp_neg (Eq control_Y 0)}))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          (?P''81 - {bexp_neg (Eq control_X 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule assign\\<^sub>\\<C>)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> control_Z \\<in> \\<C>\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       (Const (Suc 0)) ?t157\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_X 0)))\n                       ?t157\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom\n[Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}].\n                         control_Z\n                         \\<notin> vars_of_type\n                                   (the ([Z \\<mapsto>\n    {Eq control_Y 0, Eq control_X 0}]\n    v))\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P''81 =\n                      restrict_preds_to_vars\n                       (assign_post\n                         (add_pred {}\n                           ({control_Z, control_Y, control_X}, {Z})\n                           (bexp_neg (Eq control_X 0)))\n                         control_Z (Const (Suc 0)))\n                       {v. stable ({control_Z, control_Y, control_X}, {Z})\n                            v}\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         control_Z \\<in> \\<C>_vars v \\<and>\n                         v \\<notin> snd ({control_Z, control_Y, control_X},\n   {Z}) \\<longrightarrow>\n                         pred_entailment\n                          (add_pred {}\n                            ({control_Z, control_Y, control_X}, {Z})\n                            (bexp_neg (Eq control_X 0)))\n                          (to_total\n                            [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                            v) \\<and>\n                         subtype\n                          (to_total\n                            [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                            v)\n                          ?P''81 (dma_type v)\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_Y 0) `\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred\n                                (add_pred {}\n                                  ({control_Z, control_Y, control_X}, {Z})\n                                  (Eq control_X 0))\n                                ({control_Z, control_Y, control_X}, {Z})\n                                (Eq control_Y 0))\n                              control_Z (Const 0))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_Y 0}) \\<union>\n                          Imp (bexp_neg (Eq control_Y 0)) `\n                          ({Same control_Z (Const (Suc 0)),\n                            bexp.Not (Eq control_Y 0), Eq control_X 0} -\n                           {bexp_neg (Eq control_Y 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       {Eq control_X 0}\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''81 {bexp_neg (Eq control_X 0)}\n 9. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (restrict_preds_to_vars\n                            (Imp (Eq control_Y 0) `\n                             (restrict_preds_to_vars\n                               (assign_post\n                                 (add_pred\n                                   (add_pred {}\n                                     ({control_Z, control_Y, control_X},\n{Z})\n                                     (Eq control_X 0))\n                                   ({control_Z, control_Y, control_X}, {Z})\n                                   (Eq control_Y 0))\n                                 control_Z (Const 0))\n                               {v. stable\n                                    ({control_Z, control_Y, control_X}, {Z})\n                                    v} -\n                              {Eq control_Y 0}) \\<union>\n                             Imp (bexp_neg (Eq control_Y 0)) `\n                             ({Same control_Z (Const (Suc 0)),\n                               bexp.Not (Eq control_Y 0), Eq control_X 0} -\n                              {bexp_neg (Eq control_Y 0)}))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          (?P''81 - {bexp_neg (Eq control_X 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       (Const (Suc 0)) ?t157\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_X 0)))\n                       ?t157\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom\n[Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}].\n                         control_Z\n                         \\<notin> vars_of_type\n                                   (the ([Z \\<mapsto>\n    {Eq control_Y 0, Eq control_X 0}]\n    v))\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P''81 =\n                      restrict_preds_to_vars\n                       (assign_post\n                         (add_pred {}\n                           ({control_Z, control_Y, control_X}, {Z})\n                           (bexp_neg (Eq control_X 0)))\n                         control_Z (Const (Suc 0)))\n                       {v. stable ({control_Z, control_Y, control_X}, {Z})\n                            v}\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         control_Z \\<in> \\<C>_vars v \\<and>\n                         v \\<notin> snd ({control_Z, control_Y, control_X},\n   {Z}) \\<longrightarrow>\n                         pred_entailment\n                          (add_pred {}\n                            ({control_Z, control_Y, control_X}, {Z})\n                            (bexp_neg (Eq control_X 0)))\n                          (to_total\n                            [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                            v) \\<and>\n                         subtype\n                          (to_total\n                            [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                            v)\n                          ?P''81 (dma_type v)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_Y 0) `\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred\n                                (add_pred {}\n                                  ({control_Z, control_Y, control_X}, {Z})\n                                  (Eq control_X 0))\n                                ({control_Z, control_Y, control_X}, {Z})\n                                (Eq control_Y 0))\n                              control_Z (Const 0))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_Y 0}) \\<union>\n                          Imp (bexp_neg (Eq control_Y 0)) `\n                          ({Same control_Z (Const (Suc 0)),\n                            bexp.Not (Eq control_Y 0), Eq control_X 0} -\n                           {bexp_neg (Eq control_Y 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       {Eq control_X 0}\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''81 {bexp_neg (Eq control_X 0)}\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (restrict_preds_to_vars\n                            (Imp (Eq control_Y 0) `\n                             (restrict_preds_to_vars\n                               (assign_post\n                                 (add_pred\n                                   (add_pred {}\n                                     ({control_Z, control_Y, control_X},\n{Z})\n                                     (Eq control_X 0))\n                                   ({control_Z, control_Y, control_X}, {Z})\n                                   (Eq control_Y 0))\n                                 control_Z (Const 0))\n                               {v. stable\n                                    ({control_Z, control_Y, control_X}, {Z})\n                                    v} -\n                              {Eq control_Y 0}) \\<union>\n                             Imp (bexp_neg (Eq control_Y 0)) `\n                             ({Same control_Z (Const (Suc 0)),\n                               bexp.Not (Eq control_Y 0), Eq control_X 0} -\n                              {bexp_neg (Eq control_Y 0)}))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          (?P''81 - {bexp_neg (Eq control_X 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule type_aexpr_Const)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_X 0)))\n                       {}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom\n[Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}].\n                         control_Z\n                         \\<notin> vars_of_type\n                                   (the ([Z \\<mapsto>\n    {Eq control_Y 0, Eq control_X 0}]\n    v))\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P''81 =\n                      restrict_preds_to_vars\n                       (assign_post\n                         (add_pred {}\n                           ({control_Z, control_Y, control_X}, {Z})\n                           (bexp_neg (Eq control_X 0)))\n                         control_Z (Const (Suc 0)))\n                       {v. stable ({control_Z, control_Y, control_X}, {Z})\n                            v}\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         control_Z \\<in> \\<C>_vars v \\<and>\n                         v \\<notin> snd ({control_Z, control_Y, control_X},\n   {Z}) \\<longrightarrow>\n                         pred_entailment\n                          (add_pred {}\n                            ({control_Z, control_Y, control_X}, {Z})\n                            (bexp_neg (Eq control_X 0)))\n                          (to_total\n                            [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                            v) \\<and>\n                         subtype\n                          (to_total\n                            [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                            v)\n                          ?P''81 (dma_type v)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_Y 0) `\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred\n                                (add_pred {}\n                                  ({control_Z, control_Y, control_X}, {Z})\n                                  (Eq control_X 0))\n                                ({control_Z, control_Y, control_X}, {Z})\n                                (Eq control_Y 0))\n                              control_Z (Const 0))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_Y 0}) \\<union>\n                          Imp (bexp_neg (Eq control_Y 0)) `\n                          ({Same control_Z (Const (Suc 0)),\n                            bexp.Not (Eq control_Y 0), Eq control_X 0} -\n                           {bexp_neg (Eq control_Y 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       {Eq control_X 0}\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''81 {bexp_neg (Eq control_X 0)}\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (restrict_preds_to_vars\n                            (Imp (Eq control_Y 0) `\n                             (restrict_preds_to_vars\n                               (assign_post\n                                 (add_pred\n                                   (add_pred {}\n                                     ({control_Z, control_Y, control_X},\n{Z})\n                                     (Eq control_X 0))\n                                   ({control_Z, control_Y, control_X}, {Z})\n                                   (Eq control_Y 0))\n                                 control_Z (Const 0))\n                               {v. stable\n                                    ({control_Z, control_Y, control_X}, {Z})\n                                    v} -\n                              {Eq control_Y 0}) \\<union>\n                             Imp (bexp_neg (Eq control_Y 0)) `\n                             ({Same control_Z (Const (Suc 0)),\n                               bexp.Not (Eq control_Y 0), Eq control_X 0} -\n                              {bexp_neg (Eq control_Y 0)}))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          (?P''81 - {bexp_neg (Eq control_X 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v\\<in>dom\n[Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}].\n                         control_Z\n                         \\<notin> vars_of_type\n                                   (the ([Z \\<mapsto>\n    {Eq control_Y 0, Eq control_X 0}]\n    v))\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P''81 =\n                      restrict_preds_to_vars\n                       (assign_post\n                         (add_pred {}\n                           ({control_Z, control_Y, control_X}, {Z})\n                           (bexp_neg (Eq control_X 0)))\n                         control_Z (Const (Suc 0)))\n                       {v. stable ({control_Z, control_Y, control_X}, {Z})\n                            v}\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         control_Z \\<in> \\<C>_vars v \\<and>\n                         v \\<notin> snd ({control_Z, control_Y, control_X},\n   {Z}) \\<longrightarrow>\n                         pred_entailment\n                          (add_pred {}\n                            ({control_Z, control_Y, control_X}, {Z})\n                            (bexp_neg (Eq control_X 0)))\n                          (to_total\n                            [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                            v) \\<and>\n                         subtype\n                          (to_total\n                            [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                            v)\n                          ?P''81 (dma_type v)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_Y 0) `\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred\n                                (add_pred {}\n                                  ({control_Z, control_Y, control_X}, {Z})\n                                  (Eq control_X 0))\n                                ({control_Z, control_Y, control_X}, {Z})\n                                (Eq control_Y 0))\n                              control_Z (Const 0))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_Y 0}) \\<union>\n                          Imp (bexp_neg (Eq control_Y 0)) `\n                          ({Same control_Z (Const (Suc 0)),\n                            bexp.Not (Eq control_Y 0), Eq control_X 0} -\n                           {bexp_neg (Eq control_Y 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       {Eq control_X 0}\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''81 {bexp_neg (Eq control_X 0)}\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (restrict_preds_to_vars\n                            (Imp (Eq control_Y 0) `\n                             (restrict_preds_to_vars\n                               (assign_post\n                                 (add_pred\n                                   (add_pred {}\n                                     ({control_Z, control_Y, control_X},\n{Z})\n                                     (Eq control_X 0))\n                                   ({control_Z, control_Y, control_X}, {Z})\n                                   (Eq control_Y 0))\n                                 control_Z (Const 0))\n                               {v. stable\n                                    ({control_Z, control_Y, control_X}, {Z})\n                                    v} -\n                              {Eq control_Y 0}) \\<union>\n                             Imp (bexp_neg (Eq control_Y 0)) `\n                             ({Same control_Z (Const (Suc 0)),\n                               bexp.Not (Eq control_Y 0), Eq control_X 0} -\n                              {bexp_neg (Eq control_Y 0)}))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          (?P''81 - {bexp_neg (Eq control_X 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply clarsimp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P''81 =\n                      restrict_preds_to_vars\n                       (assign_post\n                         (add_pred {}\n                           ({control_Z, control_Y, control_X}, {Z})\n                           (bexp_neg (Eq control_X 0)))\n                         control_Z (Const (Suc 0)))\n                       {v. stable ({control_Z, control_Y, control_X}, {Z})\n                            v}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         control_Z \\<in> \\<C>_vars v \\<and>\n                         v \\<notin> snd ({control_Z, control_Y, control_X},\n   {Z}) \\<longrightarrow>\n                         pred_entailment\n                          (add_pred {}\n                            ({control_Z, control_Y, control_X}, {Z})\n                            (bexp_neg (Eq control_X 0)))\n                          (to_total\n                            [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                            v) \\<and>\n                         subtype\n                          (to_total\n                            [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                            v)\n                          ?P''81 (dma_type v)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_Y 0) `\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred\n                                (add_pred {}\n                                  ({control_Z, control_Y, control_X}, {Z})\n                                  (Eq control_X 0))\n                                ({control_Z, control_Y, control_X}, {Z})\n                                (Eq control_Y 0))\n                              control_Z (Const 0))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_Y 0}) \\<union>\n                          Imp (bexp_neg (Eq control_Y 0)) `\n                          ({Same control_Z (Const (Suc 0)),\n                            bexp.Not (Eq control_Y 0), Eq control_X 0} -\n                           {bexp_neg (Eq control_Y 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       {Eq control_X 0}\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''81 {bexp_neg (Eq control_X 0)}\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (restrict_preds_to_vars\n                            (Imp (Eq control_Y 0) `\n                             (restrict_preds_to_vars\n                               (assign_post\n                                 (add_pred\n                                   (add_pred {}\n                                     ({control_Z, control_Y, control_X},\n{Z})\n                                     (Eq control_X 0))\n                                   ({control_Z, control_Y, control_X}, {Z})\n                                   (Eq control_Y 0))\n                                 control_Z (Const 0))\n                               {v. stable\n                                    ({control_Z, control_Y, control_X}, {Z})\n                                    v} -\n                              {Eq control_Y 0}) \\<union>\n                             Imp (bexp_neg (Eq control_Y 0)) `\n                             ({Same control_Z (Const (Suc 0)),\n                               bexp.Not (Eq control_Y 0), Eq control_X 0} -\n                              {bexp_neg (Eq control_Y 0)}))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          (?P''81 - {bexp_neg (Eq control_X 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply fast"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>v.\n                         control_Z \\<in> \\<C>_vars v \\<and>\n                         v \\<notin> snd ({control_Z, control_Y, control_X},\n   {Z}) \\<longrightarrow>\n                         pred_entailment\n                          (add_pred {}\n                            ({control_Z, control_Y, control_X}, {Z})\n                            (bexp_neg (Eq control_X 0)))\n                          (to_total\n                            [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                            v) \\<and>\n                         subtype\n                          (to_total\n                            [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                            v)\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred {}\n                                ({control_Z, control_Y, control_X}, {Z})\n                                (bexp_neg (Eq control_X 0)))\n                              control_Z (Const (Suc 0)))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v})\n                          (dma_type v)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_Y 0) `\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred\n                                (add_pred {}\n                                  ({control_Z, control_Y, control_X}, {Z})\n                                  (Eq control_X 0))\n                                ({control_Z, control_Y, control_X}, {Z})\n                                (Eq control_Y 0))\n                              control_Z (Const 0))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_Y 0}) \\<union>\n                          Imp (bexp_neg (Eq control_Y 0)) `\n                          ({Same control_Z (Const (Suc 0)),\n                            bexp.Not (Eq control_Y 0), Eq control_X 0} -\n                           {bexp_neg (Eq control_Y 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       {Eq control_X 0}\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {}\n                             ({control_Z, control_Y, control_X}, {Z})\n                             (bexp_neg (Eq control_X 0)))\n                           control_Z (Const (Suc 0)))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       {bexp_neg (Eq control_X 0)}\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (restrict_preds_to_vars\n                            (Imp (Eq control_Y 0) `\n                             (restrict_preds_to_vars\n                               (assign_post\n                                 (add_pred\n                                   (add_pred {}\n                                     ({control_Z, control_Y, control_X},\n{Z})\n                                     (Eq control_X 0))\n                                   ({control_Z, control_Y, control_X}, {Z})\n                                   (Eq control_Y 0))\n                                 control_Z (Const 0))\n                               {v. stable\n                                    ({control_Z, control_Y, control_X}, {Z})\n                                    v} -\n                              {Eq control_Y 0}) \\<union>\n                             Imp (bexp_neg (Eq control_Y 0)) `\n                             ({Same control_Z (Const (Suc 0)),\n                               bexp.Not (Eq control_Y 0), Eq control_X 0} -\n                              {bexp_neg (Eq control_Y 0)}))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred {}\n                                ({control_Z, control_Y, control_X}, {Z})\n                                (bexp_neg (Eq control_X 0)))\n                              control_Z (Const (Suc 0)))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {bexp_neg (Eq control_X 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_Y 0) `\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred\n                                (add_pred {}\n                                  ({control_Z, control_Y, control_X}, {Z})\n                                  (Eq control_X 0))\n                                ({control_Z, control_Y, control_X}, {Z})\n                                (Eq control_Y 0))\n                              control_Z (Const 0))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_Y 0}) \\<union>\n                          Imp (bexp_neg (Eq control_Y 0)) `\n                          ({Same control_Z (Const (Suc 0)),\n                            bexp.Not (Eq control_Y 0), Eq control_X 0} -\n                           {bexp_neg (Eq control_Y 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       {Eq control_X 0}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {}\n                             ({control_Z, control_Y, control_X}, {Z})\n                             (bexp_neg (Eq control_X 0)))\n                           control_Z (Const (Suc 0)))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       {bexp_neg (Eq control_X 0)}\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (restrict_preds_to_vars\n                            (Imp (Eq control_Y 0) `\n                             (restrict_preds_to_vars\n                               (assign_post\n                                 (add_pred\n                                   (add_pred {}\n                                     ({control_Z, control_Y, control_X},\n{Z})\n                                     (Eq control_X 0))\n                                   ({control_Z, control_Y, control_X}, {Z})\n                                   (Eq control_Y 0))\n                                 control_Z (Const 0))\n                               {v. stable\n                                    ({control_Z, control_Y, control_X}, {Z})\n                                    v} -\n                              {Eq control_Y 0}) \\<union>\n                             Imp (bexp_neg (Eq control_Y 0)) `\n                             ({Same control_Z (Const (Suc 0)),\n                               bexp.Not (Eq control_Y 0), Eq control_X 0} -\n                              {bexp_neg (Eq control_Y 0)}))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred {}\n                                ({control_Z, control_Y, control_X}, {Z})\n                                (bexp_neg (Eq control_X 0)))\n                              control_Z (Const (Suc 0)))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {bexp_neg (Eq control_X 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       {Imp (bexp.Not (Eq control_Y 0))\n                         (Same control_Z (Const (Suc 0))),\n                        Imp (bexp.Not (Eq control_Y 0)) (Eq control_X 0),\n                        Imp (Eq control_Y 0) (Same control_Z (Const 0)),\n                        Imp (Eq control_Y 0) (Eq control_X 0)}\n                       {Eq control_X 0}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {}\n                             ({control_Z, control_Y, control_X}, {Z})\n                             (bexp_neg (Eq control_X 0)))\n                           control_Z (Const (Suc 0)))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       {bexp_neg (Eq control_X 0)}\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (restrict_preds_to_vars\n                            (Imp (Eq control_Y 0) `\n                             (restrict_preds_to_vars\n                               (assign_post\n                                 (add_pred\n                                   (add_pred {}\n                                     ({control_Z, control_Y, control_X},\n{Z})\n                                     (Eq control_X 0))\n                                   ({control_Z, control_Y, control_X}, {Z})\n                                   (Eq control_Y 0))\n                                 control_Z (Const 0))\n                               {v. stable\n                                    ({control_Z, control_Y, control_X}, {Z})\n                                    v} -\n                              {Eq control_Y 0}) \\<union>\n                             Imp (bexp_neg (Eq control_Y 0)) `\n                             ({Same control_Z (Const (Suc 0)),\n                               bexp.Not (Eq control_Y 0), Eq control_X 0} -\n                              {bexp_neg (Eq control_Y 0)}))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred {}\n                                ({control_Z, control_Y, control_X}, {Z})\n                                (bexp_neg (Eq control_X 0)))\n                              control_Z (Const (Suc 0)))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {bexp_neg (Eq control_X 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(fastforce intro: pred_entailment_singleton_by_case_distinction simp: image_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {}\n                             ({control_Z, control_Y, control_X}, {Z})\n                             (bexp_neg (Eq control_X 0)))\n                           control_Z (Const (Suc 0)))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       {bexp_neg (Eq control_X 0)}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (restrict_preds_to_vars\n                            (Imp (Eq control_Y 0) `\n                             (restrict_preds_to_vars\n                               (assign_post\n                                 (add_pred\n                                   (add_pred {}\n                                     ({control_Z, control_Y, control_X},\n{Z})\n                                     (Eq control_X 0))\n                                   ({control_Z, control_Y, control_X}, {Z})\n                                   (Eq control_Y 0))\n                                 control_Z (Const 0))\n                               {v. stable\n                                    ({control_Z, control_Y, control_X}, {Z})\n                                    v} -\n                              {Eq control_Y 0}) \\<union>\n                             Imp (bexp_neg (Eq control_Y 0)) `\n                             ({Same control_Z (Const (Suc 0)),\n                               bexp.Not (Eq control_Y 0), Eq control_X 0} -\n                              {bexp_neg (Eq control_Y 0)}))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred {}\n                                ({control_Z, control_Y, control_X}, {Z})\n                                (bexp_neg (Eq control_X 0)))\n                              control_Z (Const (Suc 0)))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {bexp_neg (Eq control_X 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(fastforce intro: subset_entailment)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (restrict_preds_to_vars\n                            (Imp (Eq control_Y 0) `\n                             (restrict_preds_to_vars\n                               (assign_post\n                                 (add_pred\n                                   (add_pred {}\n                                     ({control_Z, control_Y, control_X},\n{Z})\n                                     (Eq control_X 0))\n                                   ({control_Z, control_Y, control_X}, {Z})\n                                   (Eq control_Y 0))\n                                 control_Z (Const 0))\n                               {v. stable\n                                    ({control_Z, control_Y, control_X}, {Z})\n                                    v} -\n                              {Eq control_Y 0}) \\<union>\n                             Imp (bexp_neg (Eq control_Y 0)) `\n                             ({Same control_Z (Const (Suc 0)),\n                               bexp.Not (Eq control_Y 0), Eq control_X 0} -\n                              {bexp_neg (Eq control_Y 0)}))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred {}\n                                ({control_Z, control_Y, control_X}, {Z})\n                                (bexp_neg (Eq control_X 0)))\n                              control_Z (Const (Suc 0)))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {bexp_neg (Eq control_X 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule seq_type)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (restrict_preds_to_vars\n                            (Imp (Eq control_Y 0) `\n                             (restrict_preds_to_vars\n                               (assign_post\n                                 (add_pred\n                                   (add_pred {}\n                                     ({control_Z, control_Y, control_X},\n{Z})\n                                     (Eq control_X 0))\n                                   ({control_Z, control_Y, control_X}, {Z})\n                                   (Eq control_Y 0))\n                                 control_Z (Const 0))\n                               {v. stable\n                                    ({control_Z, control_Y, control_X}, {Z})\n                                    v} -\n                              {Eq control_Y 0}) \\<union>\n                             Imp (bexp_neg (Eq control_Y 0)) `\n                             ({Same control_Z (Const (Suc 0)),\n                               bexp.Not (Eq control_Y 0), Eq control_X 0} -\n                              {bexp_neg (Eq control_Y 0)}))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred {}\n                                ({control_Z, control_Y, control_X}, {Z})\n                                (bexp_neg (Eq control_X 0)))\n                              control_Z (Const (Suc 0)))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {bexp_neg (Eq control_X 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ?\\<Gamma>'268\n                       ?\\<S>'268 ?P'268\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'268 ?\\<S>'268 ?P'268\n                       ((Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule anno_type[OF HOL.refl HOL.refl HOL.refl])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno\n                         [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                         ({control_Z, control_Y, control_X}, {Z})\n                         (Z -=\\<^sub>m AsmNoReadOrWrite))\n                       (add_anno_stable\n                         ({control_Z, control_Y, control_X}, {Z})\n                         (Z -=\\<^sub>m AsmNoReadOrWrite))\n                       (restrict_preds_to_vars\n                         (restrict_preds_to_vars\n                           (Imp (Eq control_X 0) `\n                            (restrict_preds_to_vars\n                              (Imp (Eq control_Y 0) `\n                               (restrict_preds_to_vars\n                                 (assign_post\n                                   (add_pred\n                                     (add_pred {}\n ({control_Z, control_Y, control_X}, {Z}) (Eq control_X 0))\n                                     ({control_Z, control_Y, control_X},\n{Z})\n                                     (Eq control_Y 0))\n                                   control_Z (Const 0))\n                                 {v. stable\n({control_Z, control_Y, control_X}, {Z}) v} -\n                                {Eq control_Y 0}) \\<union>\n                               Imp (bexp_neg (Eq control_Y 0)) `\n                               ({Same control_Z (Const (Suc 0)),\n                                 bexp.Not (Eq control_Y 0),\n                                 Eq control_X 0} -\n                                {bexp_neg (Eq control_Y 0)}))\n                              {v. stable\n                                   ({control_Z, control_Y, control_X}, {Z})\n                                   v} -\n                             {Eq control_X 0}) \\<union>\n                            Imp (bexp_neg (Eq control_X 0)) `\n                            (restrict_preds_to_vars\n                              (assign_post\n                                (add_pred {}\n                                  ({control_Z, control_Y, control_X}, {Z})\n                                  (bexp_neg (Eq control_X 0)))\n                                control_Z (Const (Suc 0)))\n                              {v. stable\n                                   ({control_Z, control_Y, control_X}, {Z})\n                                   v} -\n                             {bexp_neg (Eq control_X 0)}))\n                           {v. stable\n                                ({control_Z, control_Y, control_X}, {Z}) v})\n                         {v. stable\n                              (add_anno_stable\n                                ({control_Z, control_Y, control_X}, {Z})\n                                (Z -=\\<^sub>m AsmNoReadOrWrite))\n                              v})\n                       Skip ?\\<Gamma>'268 ?\\<S>'268 ?P'268\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype\n                          (to_total\n                            [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                            x)\n                          (restrict_preds_to_vars\n                            (restrict_preds_to_vars\n                              (Imp (Eq control_X 0) `\n                               (restrict_preds_to_vars\n                                 (Imp (Eq control_Y 0) `\n                                  (restrict_preds_to_vars\n                                    (assign_post\n(add_pred\n  (add_pred {} ({control_Z, control_Y, control_X}, {Z}) (Eq control_X 0))\n  ({control_Z, control_Y, control_X}, {Z}) (Eq control_Y 0))\ncontrol_Z (Const 0))\n                                    {v. stable\n   ({control_Z, control_Y, control_X}, {Z}) v} -\n                                   {Eq control_Y 0}) \\<union>\n                                  Imp (bexp_neg (Eq control_Y 0)) `\n                                  ({Same control_Z (Const (Suc 0)),\n                                    bexp.Not (Eq control_Y 0),\n                                    Eq control_X 0} -\n                                   {bexp_neg (Eq control_Y 0)}))\n                                 {v. stable\n({control_Z, control_Y, control_X}, {Z}) v} -\n                                {Eq control_X 0}) \\<union>\n                               Imp (bexp_neg (Eq control_X 0)) `\n                               (restrict_preds_to_vars\n                                 (assign_post\n                                   (add_pred {}\n                                     ({control_Z, control_Y, control_X},\n{Z})\n                                     (bexp_neg (Eq control_X 0)))\n                                   control_Z (Const (Suc 0)))\n                                 {v. stable\n({control_Z, control_Y, control_X}, {Z}) v} -\n                                {bexp_neg (Eq control_X 0)}))\n                              {v. stable\n                                   ({control_Z, control_Y, control_X}, {Z})\n                                   v})\n                            {v. stable\n                                 (add_anno_stable\n                                   ({control_Z, control_Y, control_X}, {Z})\n                                   (Z -=\\<^sub>m AsmNoReadOrWrite))\n                                 v})\n                          (to_total\n                            (add_anno\n                              [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                              ({control_Z, control_Y, control_X}, {Z})\n                              (Z -=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (Z -=\\<^sub>m AsmNoReadOrWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (restrict_preds_to_vars\n                            (Imp (Eq control_Y 0) `\n                             (restrict_preds_to_vars\n                               (assign_post\n                                 (add_pred\n                                   (add_pred {}\n                                     ({control_Z, control_Y, control_X},\n{Z})\n                                     (Eq control_X 0))\n                                   ({control_Z, control_Y, control_X}, {Z})\n                                   (Eq control_Y 0))\n                                 control_Z (Const 0))\n                               {v. stable\n                                    ({control_Z, control_Y, control_X}, {Z})\n                                    v} -\n                              {Eq control_Y 0}) \\<union>\n                             Imp (bexp_neg (Eq control_Y 0)) `\n                             ({Same control_Z (Const (Suc 0)),\n                               bexp.Not (Eq control_Y 0), Eq control_X 0} -\n                              {bexp_neg (Eq control_Y 0)}))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred {}\n                                ({control_Z, control_Y, control_X}, {Z})\n                                (bexp_neg (Eq control_X 0)))\n                              control_Z (Const (Suc 0)))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {bexp_neg (Eq control_X 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       (Z -=\\<^sub>m AsmNoReadOrWrite)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'268 ?\\<S>'268 ?P'268\n                       ((Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule skip_type)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 2. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype\n                          (to_total\n                            [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                            x)\n                          (restrict_preds_to_vars\n                            (restrict_preds_to_vars\n                              (Imp (Eq control_X 0) `\n                               (restrict_preds_to_vars\n                                 (Imp (Eq control_Y 0) `\n                                  (restrict_preds_to_vars\n                                    (assign_post\n(add_pred\n  (add_pred {} ({control_Z, control_Y, control_X}, {Z}) (Eq control_X 0))\n  ({control_Z, control_Y, control_X}, {Z}) (Eq control_Y 0))\ncontrol_Z (Const 0))\n                                    {v. stable\n   ({control_Z, control_Y, control_X}, {Z}) v} -\n                                   {Eq control_Y 0}) \\<union>\n                                  Imp (bexp_neg (Eq control_Y 0)) `\n                                  ({Same control_Z (Const (Suc 0)),\n                                    bexp.Not (Eq control_Y 0),\n                                    Eq control_X 0} -\n                                   {bexp_neg (Eq control_Y 0)}))\n                                 {v. stable\n({control_Z, control_Y, control_X}, {Z}) v} -\n                                {Eq control_X 0}) \\<union>\n                               Imp (bexp_neg (Eq control_X 0)) `\n                               (restrict_preds_to_vars\n                                 (assign_post\n                                   (add_pred {}\n                                     ({control_Z, control_Y, control_X},\n{Z})\n                                     (bexp_neg (Eq control_X 0)))\n                                   control_Z (Const (Suc 0)))\n                                 {v. stable\n({control_Z, control_Y, control_X}, {Z}) v} -\n                                {bexp_neg (Eq control_X 0)}))\n                              {v. stable\n                                   ({control_Z, control_Y, control_X}, {Z})\n                                   v})\n                            {v. stable\n                                 (add_anno_stable\n                                   ({control_Z, control_Y, control_X}, {Z})\n                                   (Z -=\\<^sub>m AsmNoReadOrWrite))\n                                 v})\n                          (to_total\n                            (add_anno\n                              [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                              ({control_Z, control_Y, control_X}, {Z})\n                              (Z -=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (Z -=\\<^sub>m AsmNoReadOrWrite)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (restrict_preds_to_vars\n                            (Imp (Eq control_Y 0) `\n                             (restrict_preds_to_vars\n                               (assign_post\n                                 (add_pred\n                                   (add_pred {}\n                                     ({control_Z, control_Y, control_X},\n{Z})\n                                     (Eq control_X 0))\n                                   ({control_Z, control_Y, control_X}, {Z})\n                                   (Eq control_Y 0))\n                                 control_Z (Const 0))\n                               {v. stable\n                                    ({control_Z, control_Y, control_X}, {Z})\n                                    v} -\n                              {Eq control_Y 0}) \\<union>\n                             Imp (bexp_neg (Eq control_Y 0)) `\n                             ({Same control_Z (Const (Suc 0)),\n                               bexp.Not (Eq control_Y 0), Eq control_X 0} -\n                              {bexp_neg (Eq control_Y 0)}))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred {}\n                                ({control_Z, control_Y, control_X}, {Z})\n                                (bexp_neg (Eq control_X 0)))\n                              control_Z (Const (Suc 0)))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {bexp_neg (Eq control_X 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       (Z -=\\<^sub>m AsmNoReadOrWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno\n                         [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                         ({control_Z, control_Y, control_X}, {Z})\n                         (Z -=\\<^sub>m AsmNoReadOrWrite))\n                       (add_anno_stable\n                         ({control_Z, control_Y, control_X}, {Z})\n                         (Z -=\\<^sub>m AsmNoReadOrWrite))\n                       (restrict_preds_to_vars\n                         (restrict_preds_to_vars\n                           (Imp (Eq control_X 0) `\n                            (restrict_preds_to_vars\n                              (Imp (Eq control_Y 0) `\n                               (restrict_preds_to_vars\n                                 (assign_post\n                                   (add_pred\n                                     (add_pred {}\n ({control_Z, control_Y, control_X}, {Z}) (Eq control_X 0))\n                                     ({control_Z, control_Y, control_X},\n{Z})\n                                     (Eq control_Y 0))\n                                   control_Z (Const 0))\n                                 {v. stable\n({control_Z, control_Y, control_X}, {Z}) v} -\n                                {Eq control_Y 0}) \\<union>\n                               Imp (bexp_neg (Eq control_Y 0)) `\n                               ({Same control_Z (Const (Suc 0)),\n                                 bexp.Not (Eq control_Y 0),\n                                 Eq control_X 0} -\n                                {bexp_neg (Eq control_Y 0)}))\n                              {v. stable\n                                   ({control_Z, control_Y, control_X}, {Z})\n                                   v} -\n                             {Eq control_X 0}) \\<union>\n                            Imp (bexp_neg (Eq control_X 0)) `\n                            (restrict_preds_to_vars\n                              (assign_post\n                                (add_pred {}\n                                  ({control_Z, control_Y, control_X}, {Z})\n                                  (bexp_neg (Eq control_X 0)))\n                                control_Z (Const (Suc 0)))\n                              {v. stable\n                                   ({control_Z, control_Y, control_X}, {Z})\n                                   v} -\n                             {bexp_neg (Eq control_X 0)}))\n                           {v. stable\n                                ({control_Z, control_Y, control_X}, {Z}) v})\n                         {v. stable\n                              (add_anno_stable\n                                ({control_Z, control_Y, control_X}, {Z})\n                                (Z -=\\<^sub>m AsmNoReadOrWrite))\n                              v})\n                       ((Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype\n                          (to_total\n                            [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                            x)\n                          (restrict_preds_to_vars\n                            (restrict_preds_to_vars\n                              (Imp (Eq control_X 0) `\n                               (restrict_preds_to_vars\n                                 (Imp (Eq control_Y 0) `\n                                  (restrict_preds_to_vars\n                                    (assign_post\n(add_pred\n  (add_pred {} ({control_Z, control_Y, control_X}, {Z}) (Eq control_X 0))\n  ({control_Z, control_Y, control_X}, {Z}) (Eq control_Y 0))\ncontrol_Z (Const 0))\n                                    {v. stable\n   ({control_Z, control_Y, control_X}, {Z}) v} -\n                                   {Eq control_Y 0}) \\<union>\n                                  Imp (bexp_neg (Eq control_Y 0)) `\n                                  ({Same control_Z (Const (Suc 0)),\n                                    bexp.Not (Eq control_Y 0),\n                                    Eq control_X 0} -\n                                   {bexp_neg (Eq control_Y 0)}))\n                                 {v. stable\n({control_Z, control_Y, control_X}, {Z}) v} -\n                                {Eq control_X 0}) \\<union>\n                               Imp (bexp_neg (Eq control_X 0)) `\n                               (restrict_preds_to_vars\n                                 (assign_post\n                                   (add_pred {}\n                                     ({control_Z, control_Y, control_X},\n{Z})\n                                     (bexp_neg (Eq control_X 0)))\n                                   control_Z (Const (Suc 0)))\n                                 {v. stable\n({control_Z, control_Y, control_X}, {Z}) v} -\n                                {bexp_neg (Eq control_X 0)}))\n                              {v. stable\n                                   ({control_Z, control_Y, control_X}, {Z})\n                                   v})\n                            {v. stable\n                                 (add_anno_stable\n                                   ({control_Z, control_Y, control_X}, {Z})\n                                   (Z -=\\<^sub>m AsmNoReadOrWrite))\n                                 v})\n                          (to_total\n                            (add_anno\n                              [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                              ({control_Z, control_Y, control_X}, {Z})\n                              (Z -=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (Z -=\\<^sub>m AsmNoReadOrWrite)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (restrict_preds_to_vars\n                            (Imp (Eq control_Y 0) `\n                             (restrict_preds_to_vars\n                               (assign_post\n                                 (add_pred\n                                   (add_pred {}\n                                     ({control_Z, control_Y, control_X},\n{Z})\n                                     (Eq control_X 0))\n                                   ({control_Z, control_Y, control_X}, {Z})\n                                   (Eq control_Y 0))\n                                 control_Z (Const 0))\n                               {v. stable\n                                    ({control_Z, control_Y, control_X}, {Z})\n                                    v} -\n                              {Eq control_Y 0}) \\<union>\n                             Imp (bexp_neg (Eq control_Y 0)) `\n                             ({Same control_Z (Const (Suc 0)),\n                               bexp.Not (Eq control_Y 0), Eq control_X 0} -\n                              {bexp_neg (Eq control_Y 0)}))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred {}\n                                ({control_Z, control_Y, control_X}, {Z})\n                                (bexp_neg (Eq control_X 0)))\n                              control_Z (Const (Suc 0)))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {bexp_neg (Eq control_X 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       (Z -=\\<^sub>m AsmNoReadOrWrite)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno\n                         [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                         ({control_Z, control_Y, control_X}, {Z})\n                         (Z -=\\<^sub>m AsmNoReadOrWrite))\n                       (add_anno_stable\n                         ({control_Z, control_Y, control_X}, {Z})\n                         (Z -=\\<^sub>m AsmNoReadOrWrite))\n                       (restrict_preds_to_vars\n                         (restrict_preds_to_vars\n                           (Imp (Eq control_X 0) `\n                            (restrict_preds_to_vars\n                              (Imp (Eq control_Y 0) `\n                               (restrict_preds_to_vars\n                                 (assign_post\n                                   (add_pred\n                                     (add_pred {}\n ({control_Z, control_Y, control_X}, {Z}) (Eq control_X 0))\n                                     ({control_Z, control_Y, control_X},\n{Z})\n                                     (Eq control_Y 0))\n                                   control_Z (Const 0))\n                                 {v. stable\n({control_Z, control_Y, control_X}, {Z}) v} -\n                                {Eq control_Y 0}) \\<union>\n                               Imp (bexp_neg (Eq control_Y 0)) `\n                               ({Same control_Z (Const (Suc 0)),\n                                 bexp.Not (Eq control_Y 0),\n                                 Eq control_X 0} -\n                                {bexp_neg (Eq control_Y 0)}))\n                              {v. stable\n                                   ({control_Z, control_Y, control_X}, {Z})\n                                   v} -\n                             {Eq control_X 0}) \\<union>\n                            Imp (bexp_neg (Eq control_X 0)) `\n                            (restrict_preds_to_vars\n                              (assign_post\n                                (add_pred {}\n                                  ({control_Z, control_Y, control_X}, {Z})\n                                  (bexp_neg (Eq control_X 0)))\n                                control_Z (Const (Suc 0)))\n                              {v. stable\n                                   ({control_Z, control_Y, control_X}, {Z})\n                                   v} -\n                             {bexp_neg (Eq control_X 0)}))\n                           {v. stable\n                                ({control_Z, control_Y, control_X}, {Z}) v})\n                         {v. stable\n                              (add_anno_stable\n                                ({control_Z, control_Y, control_X}, {Z})\n                                (Z -=\\<^sub>m AsmNoReadOrWrite))\n                              v})\n                       ((Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(clarsimp simp: subtype_def pred_def add_anno_def pred_entailment_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (Z -=\\<^sub>m AsmNoReadOrWrite)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec\n                       [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (restrict_preds_to_vars\n                            (Imp (Eq control_Y 0) `\n                             (restrict_preds_to_vars\n                               (assign_post\n                                 (add_pred\n                                   (add_pred {}\n                                     ({control_Z, control_Y, control_X},\n{Z})\n                                     (Eq control_X 0))\n                                   ({control_Z, control_Y, control_X}, {Z})\n                                   (Eq control_Y 0))\n                                 control_Z (Const 0))\n                               {v. stable\n                                    ({control_Z, control_Y, control_X}, {Z})\n                                    v} -\n                              {Eq control_Y 0}) \\<union>\n                             Imp (bexp_neg (Eq control_Y 0)) `\n                             ({Same control_Z (Const (Suc 0)),\n                               bexp.Not (Eq control_Y 0), Eq control_X 0} -\n                              {bexp_neg (Eq control_Y 0)}))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred {}\n                                ({control_Z, control_Y, control_X}, {Z})\n                                (bexp_neg (Eq control_X 0)))\n                              control_Z (Const (Suc 0)))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {bexp_neg (Eq control_X 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       (Z -=\\<^sub>m AsmNoReadOrWrite)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno\n                         [Z \\<mapsto> {Eq control_Y 0, Eq control_X 0}]\n                         ({control_Z, control_Y, control_X}, {Z})\n                         (Z -=\\<^sub>m AsmNoReadOrWrite))\n                       (add_anno_stable\n                         ({control_Z, control_Y, control_X}, {Z})\n                         (Z -=\\<^sub>m AsmNoReadOrWrite))\n                       (restrict_preds_to_vars\n                         (restrict_preds_to_vars\n                           (Imp (Eq control_X 0) `\n                            (restrict_preds_to_vars\n                              (Imp (Eq control_Y 0) `\n                               (restrict_preds_to_vars\n                                 (assign_post\n                                   (add_pred\n                                     (add_pred {}\n ({control_Z, control_Y, control_X}, {Z}) (Eq control_X 0))\n                                     ({control_Z, control_Y, control_X},\n{Z})\n                                     (Eq control_Y 0))\n                                   control_Z (Const 0))\n                                 {v. stable\n({control_Z, control_Y, control_X}, {Z}) v} -\n                                {Eq control_Y 0}) \\<union>\n                               Imp (bexp_neg (Eq control_Y 0)) `\n                               ({Same control_Z (Const (Suc 0)),\n                                 bexp.Not (Eq control_Y 0),\n                                 Eq control_X 0} -\n                                {bexp_neg (Eq control_Y 0)}))\n                              {v. stable\n                                   ({control_Z, control_Y, control_X}, {Z})\n                                   v} -\n                             {Eq control_X 0}) \\<union>\n                            Imp (bexp_neg (Eq control_X 0)) `\n                            (restrict_preds_to_vars\n                              (assign_post\n                                (add_pred {}\n                                  ({control_Z, control_Y, control_X}, {Z})\n                                  (bexp_neg (Eq control_X 0)))\n                                control_Z (Const (Suc 0)))\n                              {v. stable\n                                   ({control_Z, control_Y, control_X}, {Z})\n                                   v} -\n                             {bexp_neg (Eq control_X 0)}))\n                           {v. stable\n                                ({control_Z, control_Y, control_X}, {Z}) v})\n                         {v. stable\n                              (add_anno_stable\n                                ({control_Z, control_Y, control_X}, {Z})\n                                (Z -=\\<^sub>m AsmNoReadOrWrite))\n                              v})\n                       ((Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty\n                       ({control_Z, control_Y, control_X}, {})\n                       {Imp (bexp.Not (Eq control_X 0))\n                         (Same control_Z (Const (Suc 0))),\n                        Imp (Eq control_X 0)\n                         (Imp (bexp.Not (Eq control_Y 0))\n                           (Same control_Z (Const (Suc 0)))),\n                        Imp (Eq control_X 0)\n                         (Imp (bexp.Not (Eq control_Y 0)) (Eq control_X 0)),\n                        Imp (Eq control_X 0)\n                         (Imp (Eq control_Y 0) (Same control_Z (Const 0))),\n                        Imp (Eq control_X 0)\n                         (Imp (Eq control_Y 0) (Eq control_X 0))}\n                       ((Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule seq_type)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty\n                       ({control_Z, control_Y, control_X}, {})\n                       {Imp (bexp.Not (Eq control_X 0))\n                         (Same control_Z (Const (Suc 0))),\n                        Imp (Eq control_X 0)\n                         (Imp (bexp.Not (Eq control_Y 0))\n                           (Same control_Z (Const (Suc 0)))),\n                        Imp (Eq control_X 0)\n                         (Imp (bexp.Not (Eq control_Y 0)) (Eq control_X 0)),\n                        Imp (Eq control_X 0)\n                         (Imp (Eq control_Y 0) (Same control_Z (Const 0))),\n                        Imp (Eq control_X 0)\n                         (Imp (Eq control_Y 0) (Eq control_X 0))}\n                       (Skip@[control_X -=\\<^sub>m AsmNoWrite])\n                       ?\\<Gamma>'294 ?\\<S>'294 ?P'294\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'294 ?\\<S>'294 ?P'294\n                       ((Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule anno_type[OF HOL.refl HOL.refl HOL.refl])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno Map.empty\n                         ({control_Z, control_Y, control_X}, {})\n                         (control_X -=\\<^sub>m AsmNoWrite))\n                       (add_anno_stable\n                         ({control_Z, control_Y, control_X}, {})\n                         (control_X -=\\<^sub>m AsmNoWrite))\n                       (restrict_preds_to_vars\n                         {Imp (bexp.Not (Eq control_X 0))\n                           (Same control_Z (Const (Suc 0))),\n                          Imp (Eq control_X 0)\n                           (Imp (bexp.Not (Eq control_Y 0))\n                             (Same control_Z (Const (Suc 0)))),\n                          Imp (Eq control_X 0)\n                           (Imp (bexp.Not (Eq control_Y 0))\n                             (Eq control_X 0)),\n                          Imp (Eq control_X 0)\n                           (Imp (Eq control_Y 0)\n                             (Same control_Z (Const 0))),\n                          Imp (Eq control_X 0)\n                           (Imp (Eq control_Y 0) (Eq control_X 0))}\n                         {v. stable\n                              (add_anno_stable\n                                ({control_Z, control_Y, control_X}, {})\n                                (control_X -=\\<^sub>m AsmNoWrite))\n                              v})\n                       Skip ?\\<Gamma>'294 ?\\<S>'294 ?P'294\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars\n                            {Imp (bexp.Not (Eq control_X 0))\n                              (Same control_Z (Const (Suc 0))),\n                             Imp (Eq control_X 0)\n                              (Imp (bexp.Not (Eq control_Y 0))\n                                (Same control_Z (Const (Suc 0)))),\n                             Imp (Eq control_X 0)\n                              (Imp (bexp.Not (Eq control_Y 0))\n                                (Eq control_X 0)),\n                             Imp (Eq control_X 0)\n                              (Imp (Eq control_Y 0)\n                                (Same control_Z (Const 0))),\n                             Imp (Eq control_X 0)\n                              (Imp (Eq control_Y 0) (Eq control_X 0))}\n                            {v. stable\n                                 (add_anno_stable\n                                   ({control_Z, control_Y, control_X}, {})\n                                   (control_X -=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty\n                              ({control_Z, control_Y, control_X}, {})\n                              (control_X -=\\<^sub>m AsmNoWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty\n                       ({control_Z, control_Y, control_X}, {})\n                       (control_X -=\\<^sub>m AsmNoWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty\n                       ({control_Z, control_Y, control_X}, {})\n                       {Imp (bexp.Not (Eq control_X 0))\n                         (Same control_Z (Const (Suc 0))),\n                        Imp (Eq control_X 0)\n                         (Imp (bexp.Not (Eq control_Y 0))\n                           (Same control_Z (Const (Suc 0)))),\n                        Imp (Eq control_X 0)\n                         (Imp (bexp.Not (Eq control_Y 0)) (Eq control_X 0)),\n                        Imp (Eq control_X 0)\n                         (Imp (Eq control_Y 0) (Same control_Z (Const 0))),\n                        Imp (Eq control_X 0)\n                         (Imp (Eq control_Y 0) (Eq control_X 0))}\n                       (control_X -=\\<^sub>m AsmNoWrite)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'294 ?\\<S>'294 ?P'294\n                       ((Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule skip_type)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 2. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars\n                            {Imp (bexp.Not (Eq control_X 0))\n                              (Same control_Z (Const (Suc 0))),\n                             Imp (Eq control_X 0)\n                              (Imp (bexp.Not (Eq control_Y 0))\n                                (Same control_Z (Const (Suc 0)))),\n                             Imp (Eq control_X 0)\n                              (Imp (bexp.Not (Eq control_Y 0))\n                                (Eq control_X 0)),\n                             Imp (Eq control_X 0)\n                              (Imp (Eq control_Y 0)\n                                (Same control_Z (Const 0))),\n                             Imp (Eq control_X 0)\n                              (Imp (Eq control_Y 0) (Eq control_X 0))}\n                            {v. stable\n                                 (add_anno_stable\n                                   ({control_Z, control_Y, control_X}, {})\n                                   (control_X -=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty\n                              ({control_Z, control_Y, control_X}, {})\n                              (control_X -=\\<^sub>m AsmNoWrite))\n                            x)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty\n                       ({control_Z, control_Y, control_X}, {})\n                       (control_X -=\\<^sub>m AsmNoWrite)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty\n                       ({control_Z, control_Y, control_X}, {})\n                       {Imp (bexp.Not (Eq control_X 0))\n                         (Same control_Z (Const (Suc 0))),\n                        Imp (Eq control_X 0)\n                         (Imp (bexp.Not (Eq control_Y 0))\n                           (Same control_Z (Const (Suc 0)))),\n                        Imp (Eq control_X 0)\n                         (Imp (bexp.Not (Eq control_Y 0)) (Eq control_X 0)),\n                        Imp (Eq control_X 0)\n                         (Imp (Eq control_Y 0) (Same control_Z (Const 0))),\n                        Imp (Eq control_X 0)\n                         (Imp (Eq control_Y 0) (Eq control_X 0))}\n                       (control_X -=\\<^sub>m AsmNoWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno Map.empty\n                         ({control_Z, control_Y, control_X}, {})\n                         (control_X -=\\<^sub>m AsmNoWrite))\n                       (add_anno_stable\n                         ({control_Z, control_Y, control_X}, {})\n                         (control_X -=\\<^sub>m AsmNoWrite))\n                       (restrict_preds_to_vars\n                         {Imp (bexp.Not (Eq control_X 0))\n                           (Same control_Z (Const (Suc 0))),\n                          Imp (Eq control_X 0)\n                           (Imp (bexp.Not (Eq control_Y 0))\n                             (Same control_Z (Const (Suc 0)))),\n                          Imp (Eq control_X 0)\n                           (Imp (bexp.Not (Eq control_Y 0))\n                             (Eq control_X 0)),\n                          Imp (Eq control_X 0)\n                           (Imp (Eq control_Y 0)\n                             (Same control_Z (Const 0))),\n                          Imp (Eq control_X 0)\n                           (Imp (Eq control_Y 0) (Eq control_X 0))}\n                         {v. stable\n                              (add_anno_stable\n                                ({control_Z, control_Y, control_X}, {})\n                                (control_X -=\\<^sub>m AsmNoWrite))\n                              v})\n                       ((Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars\n                            {Imp (bexp.Not (Eq control_X 0))\n                              (Same control_Z (Const (Suc 0))),\n                             Imp (Eq control_X 0)\n                              (Imp (bexp.Not (Eq control_Y 0))\n                                (Same control_Z (Const (Suc 0)))),\n                             Imp (Eq control_X 0)\n                              (Imp (bexp.Not (Eq control_Y 0))\n                                (Eq control_X 0)),\n                             Imp (Eq control_X 0)\n                              (Imp (Eq control_Y 0)\n                                (Same control_Z (Const 0))),\n                             Imp (Eq control_X 0)\n                              (Imp (Eq control_Y 0) (Eq control_X 0))}\n                            {v. stable\n                                 (add_anno_stable\n                                   ({control_Z, control_Y, control_X}, {})\n                                   (control_X -=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty\n                              ({control_Z, control_Y, control_X}, {})\n                              (control_X -=\\<^sub>m AsmNoWrite))\n                            x)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty\n                       ({control_Z, control_Y, control_X}, {})\n                       (control_X -=\\<^sub>m AsmNoWrite)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty\n                       ({control_Z, control_Y, control_X}, {})\n                       {Imp (bexp.Not (Eq control_X 0))\n                         (Same control_Z (Const (Suc 0))),\n                        Imp (Eq control_X 0)\n                         (Imp (bexp.Not (Eq control_Y 0))\n                           (Same control_Z (Const (Suc 0)))),\n                        Imp (Eq control_X 0)\n                         (Imp (bexp.Not (Eq control_Y 0)) (Eq control_X 0)),\n                        Imp (Eq control_X 0)\n                         (Imp (Eq control_Y 0) (Same control_Z (Const 0))),\n                        Imp (Eq control_X 0)\n                         (Imp (Eq control_Y 0) (Eq control_X 0))}\n                       (control_X -=\\<^sub>m AsmNoWrite)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno Map.empty\n                         ({control_Z, control_Y, control_X}, {})\n                         (control_X -=\\<^sub>m AsmNoWrite))\n                       (add_anno_stable\n                         ({control_Z, control_Y, control_X}, {})\n                         (control_X -=\\<^sub>m AsmNoWrite))\n                       (restrict_preds_to_vars\n                         {Imp (bexp.Not (Eq control_X 0))\n                           (Same control_Z (Const (Suc 0))),\n                          Imp (Eq control_X 0)\n                           (Imp (bexp.Not (Eq control_Y 0))\n                             (Same control_Z (Const (Suc 0)))),\n                          Imp (Eq control_X 0)\n                           (Imp (bexp.Not (Eq control_Y 0))\n                             (Eq control_X 0)),\n                          Imp (Eq control_X 0)\n                           (Imp (Eq control_Y 0)\n                             (Same control_Z (Const 0))),\n                          Imp (Eq control_X 0)\n                           (Imp (Eq control_Y 0) (Eq control_X 0))}\n                         {v. stable\n                              (add_anno_stable\n                                ({control_Z, control_Y, control_X}, {})\n                                (control_X -=\\<^sub>m AsmNoWrite))\n                              v})\n                       ((Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(clarsimp simp: subtype_def pred_def add_anno_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty\n                       ({control_Z, control_Y, control_X}, {})\n                       (control_X -=\\<^sub>m AsmNoWrite)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty\n                       ({control_Z, control_Y, control_X}, {})\n                       {Imp (bexp.Not (Eq control_X 0))\n                         (Same control_Z (Const (Suc 0))),\n                        Imp (Eq control_X 0)\n                         (Imp (bexp.Not (Eq control_Y 0))\n                           (Same control_Z (Const (Suc 0)))),\n                        Imp (Eq control_X 0)\n                         (Imp (bexp.Not (Eq control_Y 0)) (Eq control_X 0)),\n                        Imp (Eq control_X 0)\n                         (Imp (Eq control_Y 0) (Same control_Z (Const 0))),\n                        Imp (Eq control_X 0)\n                         (Imp (Eq control_Y 0) (Eq control_X 0))}\n                       (control_X -=\\<^sub>m AsmNoWrite)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno Map.empty\n                         ({control_Z, control_Y, control_X}, {})\n                         (control_X -=\\<^sub>m AsmNoWrite))\n                       (add_anno_stable\n                         ({control_Z, control_Y, control_X}, {})\n                         (control_X -=\\<^sub>m AsmNoWrite))\n                       (restrict_preds_to_vars\n                         {Imp (bexp.Not (Eq control_X 0))\n                           (Same control_Z (Const (Suc 0))),\n                          Imp (Eq control_X 0)\n                           (Imp (bexp.Not (Eq control_Y 0))\n                             (Same control_Z (Const (Suc 0)))),\n                          Imp (Eq control_X 0)\n                           (Imp (bexp.Not (Eq control_Y 0))\n                             (Eq control_X 0)),\n                          Imp (Eq control_X 0)\n                           (Imp (Eq control_Y 0)\n                             (Same control_Z (Const 0))),\n                          Imp (Eq control_X 0)\n                           (Imp (Eq control_Y 0) (Eq control_X 0))}\n                         {v. stable\n                              (add_anno_stable\n                                ({control_Z, control_Y, control_X}, {})\n                                (control_X -=\\<^sub>m AsmNoWrite))\n                              v})\n                       ((Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply (simp add: add_anno_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty\n                       ({control_Z, control_Y, control_X}, {})\n                       {Imp (bexp.Not (Eq control_X 0))\n                         (Same control_Z (Const (Suc 0))),\n                        Imp (Eq control_X 0)\n                         (Imp (bexp.Not (Eq control_Y 0))\n                           (Same control_Z (Const (Suc 0)))),\n                        Imp (Eq control_X 0)\n                         (Imp (bexp.Not (Eq control_Y 0)) (Eq control_X 0)),\n                        Imp (Eq control_X 0)\n                         (Imp (Eq control_Y 0) (Same control_Z (Const 0))),\n                        Imp (Eq control_X 0)\n                         (Imp (Eq control_Y 0) (Eq control_X 0))}\n                       (control_X -=\\<^sub>m AsmNoWrite)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno Map.empty\n                         ({control_Z, control_Y, control_X}, {})\n                         (control_X -=\\<^sub>m AsmNoWrite))\n                       (add_anno_stable\n                         ({control_Z, control_Y, control_X}, {})\n                         (control_X -=\\<^sub>m AsmNoWrite))\n                       (restrict_preds_to_vars\n                         {Imp (bexp.Not (Eq control_X 0))\n                           (Same control_Z (Const (Suc 0))),\n                          Imp (Eq control_X 0)\n                           (Imp (bexp.Not (Eq control_Y 0))\n                             (Same control_Z (Const (Suc 0)))),\n                          Imp (Eq control_X 0)\n                           (Imp (bexp.Not (Eq control_Y 0))\n                             (Eq control_X 0)),\n                          Imp (Eq control_X 0)\n                           (Imp (Eq control_Y 0)\n                             (Same control_Z (Const 0))),\n                          Imp (Eq control_X 0)\n                           (Imp (Eq control_Y 0) (Eq control_X 0))}\n                         {v. stable\n                              (add_anno_stable\n                                ({control_Z, control_Y, control_X}, {})\n                                (control_X -=\\<^sub>m AsmNoWrite))\n                              v})\n                       ((Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp+"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({control_Z, control_Y}, {}) {}\n                       ((Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule seq_type)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({control_Z, control_Y}, {}) {}\n                       (Skip@[control_Y -=\\<^sub>m AsmNoWrite])\n                       ?\\<Gamma>'307 ?\\<S>'307 ?P'307\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'307 ?\\<S>'307 ?P'307\n                       ((Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule anno_type[OF HOL.refl HOL.refl HOL.refl])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno Map.empty ({control_Z, control_Y}, {})\n                         (control_Y -=\\<^sub>m AsmNoWrite))\n                       (add_anno_stable ({control_Z, control_Y}, {})\n                         (control_Y -=\\<^sub>m AsmNoWrite))\n                       (restrict_preds_to_vars {}\n                         {v. stable\n                              (add_anno_stable ({control_Z, control_Y}, {})\n                                (control_Y -=\\<^sub>m AsmNoWrite))\n                              v})\n                       Skip ?\\<Gamma>'307 ?\\<S>'307 ?P'307\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable\n                                   ({control_Z, control_Y}, {})\n                                   (control_Y -=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty ({control_Z, control_Y}, {})\n                              (control_Y -=\\<^sub>m AsmNoWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty\n                       ({control_Z, control_Y}, {})\n                       (control_Y -=\\<^sub>m AsmNoWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({control_Z, control_Y}, {})\n                       {} (control_Y -=\\<^sub>m AsmNoWrite)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'307 ?\\<S>'307 ?P'307\n                       ((Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule skip_type)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 2. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable\n                                   ({control_Z, control_Y}, {})\n                                   (control_Y -=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty ({control_Z, control_Y}, {})\n                              (control_Y -=\\<^sub>m AsmNoWrite))\n                            x)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty\n                       ({control_Z, control_Y}, {})\n                       (control_Y -=\\<^sub>m AsmNoWrite)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({control_Z, control_Y}, {})\n                       {} (control_Y -=\\<^sub>m AsmNoWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno Map.empty ({control_Z, control_Y}, {})\n                         (control_Y -=\\<^sub>m AsmNoWrite))\n                       (add_anno_stable ({control_Z, control_Y}, {})\n                         (control_Y -=\\<^sub>m AsmNoWrite))\n                       (restrict_preds_to_vars {}\n                         {v. stable\n                              (add_anno_stable ({control_Z, control_Y}, {})\n                                (control_Y -=\\<^sub>m AsmNoWrite))\n                              v})\n                       ((Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply fastforce+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "method post_conc_tac \n  declares aexpr bexpr =\n  ( simp,\n   clarsimp simp: type_equiv_def subtype_def pred_entailment_def pred_def,\n   clarsimp simp: type_wellformed_def,\n   simp, \n   has_type_tac')"], ["", "method conc_tac for x :: addr and y :: addr  =\n  (rule conc'[where  x=\"x\" and t=\"dma_type y\", OF _ HOL.refl])"], ["", "lemma swap_vars_typed':\n  \"\\<Gamma> = (\\<lambda>_. None) \\<Longrightarrow> \\<S> = ({},{}) \\<Longrightarrow> P = {} \\<Longrightarrow> \n  \\<exists>\\<Gamma>' \\<S>' P'. has_type \\<Gamma> \\<S> P swap_vars \\<Gamma>' \\<S>' P'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<Gamma>' \\<S>' P'.\n                         has_type \\<Gamma> \\<S> P swap_vars \\<Gamma>' \\<S>'\n                          P'", "apply (has_type_tac prog: swap_vars_def aexpr: type_aexpr_Load' type_aexpr_Load bexpr:type_bexprI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}, Z \n                        \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                        {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0}]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       {Same control_Z (Load control_X), Same Y (Load Z)}\n                       (control_X \\<leftarrow> Load control_Y) ?\\<Gamma>'243\n                       ?\\<S>'243 ?P'243\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'243 ?\\<S>'243 ?P'243\n                       ((control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(conc_tac Z Z)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}, Z \n                        \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                        {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0}, Z \n                        \\<mapsto> dma_type Z]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       {Same control_Z (Load control_X), Same Y (Load Z)}\n                       (control_X \\<leftarrow> Load control_Y) ?\\<Gamma>'243\n                       ?\\<S>'243 ?P'243\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Z \\<in> dom [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                                   {Eq control_Y 0}, Z \\<mapsto>\n                                   {Eq control_Z 0}, Z \\<mapsto>\n                                   {Eq control_X 0}, X \\<mapsto>\n                                   {Eq control_Y 0}, Y \\<mapsto>\n                                   {Eq control_X 0}]\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_equiv\n                       (the ([X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                              {Eq control_Y 0}, Z \\<mapsto>\n                              {Eq control_Z 0}, Z \\<mapsto>\n                              {Eq control_X 0}, X \\<mapsto>\n                              {Eq control_Y 0}, Y \\<mapsto>\n                              {Eq control_X 0}]\n                              Z))\n                       {Same control_Z (Load control_X), Same Y (Load Z)}\n                       (dma_type Z)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_wellformed (dma_type Z)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (dma_type Z)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'243 ?\\<S>'243 ?P'243\n                       ((control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(conc_tac Y Z)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}, Z \n                        \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                        {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0}, Z \n                        \\<mapsto> dma_type Z, Y \\<mapsto> dma_type Z]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       {Same control_Z (Load control_X), Same Y (Load Z)}\n                       (control_X \\<leftarrow> Load control_Y) ?\\<Gamma>'243\n                       ?\\<S>'243 ?P'243\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Y \\<in> dom [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                                   {Eq control_Y 0}, Z \\<mapsto>\n                                   {Eq control_Z 0}, Z \\<mapsto>\n                                   {Eq control_X 0}, X \\<mapsto>\n                                   {Eq control_Y 0}, Y \\<mapsto>\n                                   {Eq control_X 0}, Z \\<mapsto> dma_type Z]\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_equiv\n                       (the ([X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                              {Eq control_Y 0}, Z \\<mapsto>\n                              {Eq control_Z 0}, Z \\<mapsto>\n                              {Eq control_X 0}, X \\<mapsto>\n                              {Eq control_Y 0}, Y \\<mapsto>\n                              {Eq control_X 0}, Z \\<mapsto> dma_type Z]\n                              Y))\n                       {Same control_Z (Load control_X), Same Y (Load Z)}\n                       (dma_type Z)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_wellformed (dma_type Z)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (dma_type Z)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Z \\<in> dom [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                                   {Eq control_Y 0}, Z \\<mapsto>\n                                   {Eq control_Z 0}, Z \\<mapsto>\n                                   {Eq control_X 0}, X \\<mapsto>\n                                   {Eq control_Y 0}, Y \\<mapsto>\n                                   {Eq control_X 0}]\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_equiv\n                       (the ([X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                              {Eq control_Y 0}, Z \\<mapsto>\n                              {Eq control_Z 0}, Z \\<mapsto>\n                              {Eq control_X 0}, X \\<mapsto>\n                              {Eq control_Y 0}, Y \\<mapsto>\n                              {Eq control_X 0}]\n                              Z))\n                       {Same control_Z (Load control_X), Same Y (Load Z)}\n                       (dma_type Z)\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_wellformed (dma_type Z)\n 9. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (dma_type Z)\n 10. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n     \\<Longrightarrow> has_type ?\\<Gamma>'243 ?\\<S>'243 ?P'243\n                        ((control_Y \\<leftarrow> Load control_Z) ;;\n                         (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                         (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                         (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                         (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                         (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                         (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                        ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply (has_type_tac' aexpr:type_aexpr_Load' type_aexpr_Load bexpr:type_bexprI)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Y \\<in> dom [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                                   {Eq control_Y 0}, Z \\<mapsto>\n                                   {Eq control_Z 0}, Z \\<mapsto>\n                                   {Eq control_X 0}, X \\<mapsto>\n                                   {Eq control_Y 0}, Y \\<mapsto>\n                                   {Eq control_X 0}, Z \\<mapsto> dma_type Z]\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_equiv\n                       (the ([X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                              {Eq control_Y 0}, Z \\<mapsto>\n                              {Eq control_Z 0}, Z \\<mapsto>\n                              {Eq control_X 0}, X \\<mapsto>\n                              {Eq control_Y 0}, Y \\<mapsto>\n                              {Eq control_X 0}, Z \\<mapsto> dma_type Z]\n                              Y))\n                       {Same control_Z (Load control_X), Same Y (Load Z)}\n                       (dma_type Z)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_wellformed (dma_type Z)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (dma_type Z)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Z \\<in> dom [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                                   {Eq control_Y 0}, Z \\<mapsto>\n                                   {Eq control_Z 0}, Z \\<mapsto>\n                                   {Eq control_X 0}, X \\<mapsto>\n                                   {Eq control_Y 0}, Y \\<mapsto>\n                                   {Eq control_X 0}]\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_equiv\n                       (the ([X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                              {Eq control_Y 0}, Z \\<mapsto>\n                              {Eq control_Z 0}, Z \\<mapsto>\n                              {Eq control_X 0}, X \\<mapsto>\n                              {Eq control_Y 0}, Y \\<mapsto>\n                              {Eq control_X 0}]\n                              Z))\n                       {Same control_Z (Load control_X), Same Y (Load Z)}\n                       (dma_type Z)\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_wellformed (dma_type Z)\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (dma_type Z)\n 9. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}, Z \n                        \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                        {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0}, Z \n                        \\<mapsto> dma_type Z, Y \\<mapsto> dma_type Z]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       {Same control_X (Load control_Y), Same Y (Load Z)}\n                       ((control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply post_conc_tac"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Z \\<in> dom [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                                   {Eq control_Y 0}, Z \\<mapsto>\n                                   {Eq control_Z 0}, Z \\<mapsto>\n                                   {Eq control_X 0}, X \\<mapsto>\n                                   {Eq control_Y 0}, Y \\<mapsto>\n                                   {Eq control_X 0}]\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_equiv\n                       (the ([X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                              {Eq control_Y 0}, Z \\<mapsto>\n                              {Eq control_Z 0}, Z \\<mapsto>\n                              {Eq control_X 0}, X \\<mapsto>\n                              {Eq control_Y 0}, Y \\<mapsto>\n                              {Eq control_X 0}]\n                              Z))\n                       {Same control_Z (Load control_X), Same Y (Load Z)}\n                       (dma_type Z)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_wellformed (dma_type Z)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (dma_type Z)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}, Z \n                        \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                        {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0}, Z \n                        \\<mapsto> dma_type Z, Y \\<mapsto> dma_type Z]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       {Same control_X (Load control_Y), Same Y (Load Z)}\n                       ((control_Y \\<leftarrow> Load control_Z) ;;\n                        (Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply post_conc_tac"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}, Z \n                        \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                        {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0}, Z \n                        \\<mapsto> dma_type Z, Y \\<mapsto> dma_type Z]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       {Same control_X (Load control_Y), Same Y (Load Z)}\n                       (control_Y \\<leftarrow> Load control_Z) ?\\<Gamma>'291\n                       ?\\<S>'291 ?P'291\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'291 ?\\<S>'291 ?P'291\n                       ((Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply (has_type_tac' aexpr:type_aexpr_Load' type_aexpr_Load bexpr:type_bexprI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}, Z \n                        \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                        {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0}, Z \n                        \\<mapsto> dma_type Z, Y \\<mapsto> dma_type Z]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       {Same control_X (Load control_Y), Same Y (Load Z)}\n                       (control_Y \\<leftarrow> Load control_Z) ?\\<Gamma>'291\n                       ?\\<S>'291 ?P'291\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'291 ?\\<S>'291 ?P'291\n                       ((Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(conc_tac X X)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}, Z \n                        \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                        {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0}, Z \n                        \\<mapsto> dma_type Z, Y \\<mapsto> dma_type Z, X \n                        \\<mapsto> dma_type X]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       {Same control_X (Load control_Y), Same Y (Load Z)}\n                       (control_Y \\<leftarrow> Load control_Z) ?\\<Gamma>'291\n                       ?\\<S>'291 ?P'291\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> X \\<in> dom [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                                   {Eq control_Y 0}, Z \\<mapsto>\n                                   {Eq control_Z 0}, Z \\<mapsto>\n                                   {Eq control_X 0}, X \\<mapsto>\n                                   {Eq control_Y 0}, Y \\<mapsto>\n                                   {Eq control_X 0}, Z \\<mapsto> dma_type Z,\n                                   Y \\<mapsto> dma_type Z]\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_equiv\n                       (the ([X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                              {Eq control_Y 0}, Z \\<mapsto>\n                              {Eq control_Z 0}, Z \\<mapsto>\n                              {Eq control_X 0}, X \\<mapsto>\n                              {Eq control_Y 0}, Y \\<mapsto>\n                              {Eq control_X 0}, Z \\<mapsto> dma_type Z, Y \n                              \\<mapsto> dma_type Z]\n                              X))\n                       {Same control_X (Load control_Y), Same Y (Load Z)}\n                       (dma_type X)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_wellformed (dma_type X)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (dma_type X)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'291 ?\\<S>'291 ?P'291\n                       ((Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply (has_type_tac' aexpr:type_aexpr_Load' type_aexpr_Load bexpr:type_bexprI)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> X \\<in> dom [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                                   {Eq control_Y 0}, Z \\<mapsto>\n                                   {Eq control_Z 0}, Z \\<mapsto>\n                                   {Eq control_X 0}, X \\<mapsto>\n                                   {Eq control_Y 0}, Y \\<mapsto>\n                                   {Eq control_X 0}, Z \\<mapsto> dma_type Z,\n                                   Y \\<mapsto> dma_type Z]\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_equiv\n                       (the ([X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                              {Eq control_Y 0}, Z \\<mapsto>\n                              {Eq control_Z 0}, Z \\<mapsto>\n                              {Eq control_X 0}, X \\<mapsto>\n                              {Eq control_Y 0}, Y \\<mapsto>\n                              {Eq control_X 0}, Z \\<mapsto> dma_type Z, Y \n                              \\<mapsto> dma_type Z]\n                              X))\n                       {Same control_X (Load control_Y), Same Y (Load Z)}\n                       (dma_type X)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_wellformed (dma_type X)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       (dma_type X)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [X \\<mapsto> {Eq control_X 0}, Y \\<mapsto>\n                        {Eq control_Y 0}, Z \\<mapsto> {Eq control_Z 0}, Z \n                        \\<mapsto> {Eq control_X 0}, X \\<mapsto>\n                        {Eq control_Y 0}, Y \\<mapsto> {Eq control_X 0}, Z \n                        \\<mapsto> dma_type Z, Y \\<mapsto> dma_type Z, X \n                        \\<mapsto> dma_type X]\n                       ({control_Z, control_Y, control_X}, {Z, Y, X})\n                       {Same control_Y (Load control_Z), Same Y (Load Z)}\n                       ((Skip@[X -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Y -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply  (post_conc_tac)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma add_vars_typed':\n  \"\\<Gamma> = (\\<lambda>_. None) \\<Longrightarrow> \\<S> = ({},{}) \\<Longrightarrow> P = {} \\<Longrightarrow> \n  \\<exists>\\<Gamma>' \\<S>' P'. has_type \\<Gamma> \\<S> P add_vars \\<Gamma>' \\<S>' P'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<Gamma>' \\<S>' P'.\n                         has_type \\<Gamma> \\<S> P add_vars \\<Gamma>' \\<S>'\n                          P'", "apply (has_type_no_if_tac\n          prog: add_vars_def\n          aexpr: type_aexpr_Load' type_aexpr_Load type_aexpr_Add \n           type_aexpr_Add' type_aexpr_Add''  type_aexpr_Const\n          bexpr:type_bexprI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z}) {}\n                       (Stmt.If (Eq control_X 0)\n                         (Stmt.If (Eq control_Y 0)\n                           (control_Z \\<leftarrow> Const 0)\n                           (control_Z \\<leftarrow> Const 1))\n                         (control_Z \\<leftarrow> Const 1))\n                       ?\\<Gamma>'107 ?\\<S>'107 ?P'107\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'107 ?\\<S>'107 ?P'107\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule if_type''[OF _ _ _ _ _ _ HOL.refl])"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_bexpr\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       (Eq control_X 0) ?t110\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment {} ?t110\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (Eq control_X 0))\n                       (Stmt.If (Eq control_Y 0)\n                         (control_Z \\<leftarrow> Const 0)\n                         (control_Z \\<leftarrow> Const 1))\n                       ?\\<Gamma>'107 ?\\<S>'107 ?P'110\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_X 0)))\n                       (control_Z \\<leftarrow> Const 1) ?\\<Gamma>'107\n                       ?\\<S>'107 ?P''110\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P'110 {Eq control_X 0}\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''110 {bexp_neg (Eq control_X 0)}\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'107 ?\\<S>'107\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (?P'110 - {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          (?P''110 - {bexp_neg (Eq control_X 0)}))\n                         {v. stable ?\\<S>'107 v})\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule type_bexprI)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?t110 =\n                      \\<Union>\n                       (to_total\n                         [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                          \\<Union> {dma_type X, dma_type Y}] `\n                        bexp_vars (Eq control_X 0))\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment {} ?t110\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (Eq control_X 0))\n                       (Stmt.If (Eq control_Y 0)\n                         (control_Z \\<leftarrow> Const 0)\n                         (control_Z \\<leftarrow> Const 1))\n                       ?\\<Gamma>'107 ?\\<S>'107 ?P'110\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_X 0)))\n                       (control_Z \\<leftarrow> Const 1) ?\\<Gamma>'107\n                       ?\\<S>'107 ?P''110\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P'110 {Eq control_X 0}\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''110 {bexp_neg (Eq control_X 0)}\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'107 ?\\<S>'107\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (?P'110 - {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          (?P''110 - {bexp_neg (Eq control_X 0)}))\n                         {v. stable ?\\<S>'107 v})\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(clarsimp)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?t110 = {}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment {} ?t110\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (Eq control_X 0))\n                       (Stmt.If (Eq control_Y 0)\n                         (control_Z \\<leftarrow> Const 0)\n                         (control_Z \\<leftarrow> Const 1))\n                       ?\\<Gamma>'107 ?\\<S>'107 ?P'110\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_X 0)))\n                       (control_Z \\<leftarrow> Const 1) ?\\<Gamma>'107\n                       ?\\<S>'107 ?P''110\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P'110 {Eq control_X 0}\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''110 {bexp_neg (Eq control_X 0)}\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'107 ?\\<S>'107\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (?P'110 - {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          (?P''110 - {bexp_neg (Eq control_X 0)}))\n                         {v. stable ?\\<S>'107 v})\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule HOL.refl)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment {} {}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (Eq control_X 0))\n                       (Stmt.If (Eq control_Y 0)\n                         (control_Z \\<leftarrow> Const 0)\n                         (control_Z \\<leftarrow> Const 1))\n                       ?\\<Gamma>'107 ?\\<S>'107 ?P'110\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_X 0)))\n                       (control_Z \\<leftarrow> Const 1) ?\\<Gamma>'107\n                       ?\\<S>'107 ?P''110\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P'110 {Eq control_X 0}\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''110 {bexp_neg (Eq control_X 0)}\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'107 ?\\<S>'107\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (?P'110 - {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          (?P''110 - {bexp_neg (Eq control_X 0)}))\n                         {v. stable ?\\<S>'107 v})\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (Eq control_X 0))\n                       (Stmt.If (Eq control_Y 0)\n                         (control_Z \\<leftarrow> Const 0)\n                         (control_Z \\<leftarrow> Const 1))\n                       ?\\<Gamma>'107 ?\\<S>'107 ?P'110\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_X 0)))\n                       (control_Z \\<leftarrow> Const 1) ?\\<Gamma>'107\n                       ?\\<S>'107 ?P''110\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P'110 {Eq control_X 0}\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''110 {bexp_neg (Eq control_X 0)}\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'107 ?\\<S>'107\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (?P'110 - {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          (?P''110 - {bexp_neg (Eq control_X 0)}))\n                         {v. stable ?\\<S>'107 v})\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule if_type''[OF _ _ _ _ _ _ HOL.refl])"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_bexpr\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       (Eq control_Y 0) ?t129\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (Eq control_X 0))\n                       ?t129\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred\n                         (add_pred {}\n                           ({control_Z, control_Y, control_X}, {Z})\n                           (Eq control_X 0))\n                         ({control_Z, control_Y, control_X}, {Z})\n                         (Eq control_Y 0))\n                       (control_Z \\<leftarrow> Const 0) ?\\<Gamma>'107\n                       ?\\<S>'107 ?P'129\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred\n                         (add_pred {}\n                           ({control_Z, control_Y, control_X}, {Z})\n                           (Eq control_X 0))\n                         ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_Y 0)))\n                       (control_Z \\<leftarrow> Const 1) ?\\<Gamma>'107\n                       ?\\<S>'107 ?P''129\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P'129 {Eq control_Y 0}\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''129 {bexp_neg (Eq control_Y 0)}\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_X 0)))\n                       (control_Z \\<leftarrow> Const 1) ?\\<Gamma>'107\n                       ?\\<S>'107 ?P''110\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_Y 0) `\n                          (?P'129 - {Eq control_Y 0}) \\<union>\n                          Imp (bexp_neg (Eq control_Y 0)) `\n                          (?P''129 - {bexp_neg (Eq control_Y 0)}))\n                         {v. stable ?\\<S>'107 v})\n                       {Eq control_X 0}\n 9. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''110 {bexp_neg (Eq control_X 0)}\n 10. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n     \\<Longrightarrow> has_type ?\\<Gamma>'107 ?\\<S>'107\n                        (restrict_preds_to_vars\n                          (Imp (Eq control_X 0) `\n                           (restrict_preds_to_vars\n                             (Imp (Eq control_Y 0) `\n                              (?P'129 - {Eq control_Y 0}) \\<union>\n                              Imp (bexp_neg (Eq control_Y 0)) `\n                              (?P''129 - {bexp_neg (Eq control_Y 0)}))\n                             {v. stable ?\\<S>'107 v} -\n                            {Eq control_X 0}) \\<union>\n                           Imp (bexp_neg (Eq control_X 0)) `\n                           (?P''110 - {bexp_neg (Eq control_X 0)}))\n                          {v. stable ?\\<S>'107 v})\n                        ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                         (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                         (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                         (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                        ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule type_bexprI)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?t129 =\n                      \\<Union>\n                       (to_total\n                         [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                          \\<Union> {dma_type X, dma_type Y}] `\n                        bexp_vars (Eq control_Y 0))\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (Eq control_X 0))\n                       ?t129\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred\n                         (add_pred {}\n                           ({control_Z, control_Y, control_X}, {Z})\n                           (Eq control_X 0))\n                         ({control_Z, control_Y, control_X}, {Z})\n                         (Eq control_Y 0))\n                       (control_Z \\<leftarrow> Const 0) ?\\<Gamma>'107\n                       ?\\<S>'107 ?P'129\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred\n                         (add_pred {}\n                           ({control_Z, control_Y, control_X}, {Z})\n                           (Eq control_X 0))\n                         ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_Y 0)))\n                       (control_Z \\<leftarrow> Const 1) ?\\<Gamma>'107\n                       ?\\<S>'107 ?P''129\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P'129 {Eq control_Y 0}\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''129 {bexp_neg (Eq control_Y 0)}\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_X 0)))\n                       (control_Z \\<leftarrow> Const 1) ?\\<Gamma>'107\n                       ?\\<S>'107 ?P''110\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_Y 0) `\n                          (?P'129 - {Eq control_Y 0}) \\<union>\n                          Imp (bexp_neg (Eq control_Y 0)) `\n                          (?P''129 - {bexp_neg (Eq control_Y 0)}))\n                         {v. stable ?\\<S>'107 v})\n                       {Eq control_X 0}\n 9. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''110 {bexp_neg (Eq control_X 0)}\n 10. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n     \\<Longrightarrow> has_type ?\\<Gamma>'107 ?\\<S>'107\n                        (restrict_preds_to_vars\n                          (Imp (Eq control_X 0) `\n                           (restrict_preds_to_vars\n                             (Imp (Eq control_Y 0) `\n                              (?P'129 - {Eq control_Y 0}) \\<union>\n                              Imp (bexp_neg (Eq control_Y 0)) `\n                              (?P''129 - {bexp_neg (Eq control_Y 0)}))\n                             {v. stable ?\\<S>'107 v} -\n                            {Eq control_X 0}) \\<union>\n                           Imp (bexp_neg (Eq control_X 0)) `\n                           (?P''110 - {bexp_neg (Eq control_X 0)}))\n                          {v. stable ?\\<S>'107 v})\n                        ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                         (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                         (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                         (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                        ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(clarsimp)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?t129 = {}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (Eq control_X 0))\n                       ?t129\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred\n                         (add_pred {}\n                           ({control_Z, control_Y, control_X}, {Z})\n                           (Eq control_X 0))\n                         ({control_Z, control_Y, control_X}, {Z})\n                         (Eq control_Y 0))\n                       (control_Z \\<leftarrow> Const 0) ?\\<Gamma>'107\n                       ?\\<S>'107 ?P'129\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred\n                         (add_pred {}\n                           ({control_Z, control_Y, control_X}, {Z})\n                           (Eq control_X 0))\n                         ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_Y 0)))\n                       (control_Z \\<leftarrow> Const 1) ?\\<Gamma>'107\n                       ?\\<S>'107 ?P''129\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P'129 {Eq control_Y 0}\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''129 {bexp_neg (Eq control_Y 0)}\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_X 0)))\n                       (control_Z \\<leftarrow> Const 1) ?\\<Gamma>'107\n                       ?\\<S>'107 ?P''110\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_Y 0) `\n                          (?P'129 - {Eq control_Y 0}) \\<union>\n                          Imp (bexp_neg (Eq control_Y 0)) `\n                          (?P''129 - {bexp_neg (Eq control_Y 0)}))\n                         {v. stable ?\\<S>'107 v})\n                       {Eq control_X 0}\n 9. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''110 {bexp_neg (Eq control_X 0)}\n 10. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n     \\<Longrightarrow> has_type ?\\<Gamma>'107 ?\\<S>'107\n                        (restrict_preds_to_vars\n                          (Imp (Eq control_X 0) `\n                           (restrict_preds_to_vars\n                             (Imp (Eq control_Y 0) `\n                              (?P'129 - {Eq control_Y 0}) \\<union>\n                              Imp (bexp_neg (Eq control_Y 0)) `\n                              (?P''129 - {bexp_neg (Eq control_Y 0)}))\n                             {v. stable ?\\<S>'107 v} -\n                            {Eq control_X 0}) \\<union>\n                           Imp (bexp_neg (Eq control_X 0)) `\n                           (?P''110 - {bexp_neg (Eq control_X 0)}))\n                          {v. stable ?\\<S>'107 v})\n                        ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                         (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                         (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                         (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                        ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule HOL.refl)"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (Eq control_X 0))\n                       {}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred\n                         (add_pred {}\n                           ({control_Z, control_Y, control_X}, {Z})\n                           (Eq control_X 0))\n                         ({control_Z, control_Y, control_X}, {Z})\n                         (Eq control_Y 0))\n                       (control_Z \\<leftarrow> Const 0) ?\\<Gamma>'107\n                       ?\\<S>'107 ?P'129\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred\n                         (add_pred {}\n                           ({control_Z, control_Y, control_X}, {Z})\n                           (Eq control_X 0))\n                         ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_Y 0)))\n                       (control_Z \\<leftarrow> Const 1) ?\\<Gamma>'107\n                       ?\\<S>'107 ?P''129\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P'129 {Eq control_Y 0}\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''129 {bexp_neg (Eq control_Y 0)}\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_X 0)))\n                       (control_Z \\<leftarrow> Const 1) ?\\<Gamma>'107\n                       ?\\<S>'107 ?P''110\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_Y 0) `\n                          (?P'129 - {Eq control_Y 0}) \\<union>\n                          Imp (bexp_neg (Eq control_Y 0)) `\n                          (?P''129 - {bexp_neg (Eq control_Y 0)}))\n                         {v. stable ?\\<S>'107 v})\n                       {Eq control_X 0}\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''110 {bexp_neg (Eq control_X 0)}\n 9. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'107 ?\\<S>'107\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (restrict_preds_to_vars\n                            (Imp (Eq control_Y 0) `\n                             (?P'129 - {Eq control_Y 0}) \\<union>\n                             Imp (bexp_neg (Eq control_Y 0)) `\n                             (?P''129 - {bexp_neg (Eq control_Y 0)}))\n                            {v. stable ?\\<S>'107 v} -\n                           {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          (?P''110 - {bexp_neg (Eq control_X 0)}))\n                         {v. stable ?\\<S>'107 v})\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred\n                         (add_pred {}\n                           ({control_Z, control_Y, control_X}, {Z})\n                           (Eq control_X 0))\n                         ({control_Z, control_Y, control_X}, {Z})\n                         (Eq control_Y 0))\n                       (control_Z \\<leftarrow> Const 0) ?\\<Gamma>'107\n                       ?\\<S>'107 ?P'129\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred\n                         (add_pred {}\n                           ({control_Z, control_Y, control_X}, {Z})\n                           (Eq control_X 0))\n                         ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_Y 0)))\n                       (control_Z \\<leftarrow> Const 1) ?\\<Gamma>'107\n                       ?\\<S>'107 ?P''129\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P'129 {Eq control_Y 0}\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''129 {bexp_neg (Eq control_Y 0)}\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_X 0)))\n                       (control_Z \\<leftarrow> Const 1) ?\\<Gamma>'107\n                       ?\\<S>'107 ?P''110\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_Y 0) `\n                          (?P'129 - {Eq control_Y 0}) \\<union>\n                          Imp (bexp_neg (Eq control_Y 0)) `\n                          (?P''129 - {bexp_neg (Eq control_Y 0)}))\n                         {v. stable ?\\<S>'107 v})\n                       {Eq control_X 0}\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''110 {bexp_neg (Eq control_X 0)}\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'107 ?\\<S>'107\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (restrict_preds_to_vars\n                            (Imp (Eq control_Y 0) `\n                             (?P'129 - {Eq control_Y 0}) \\<union>\n                             Imp (bexp_neg (Eq control_Y 0)) `\n                             (?P''129 - {bexp_neg (Eq control_Y 0)}))\n                            {v. stable ?\\<S>'107 v} -\n                           {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          (?P''110 - {bexp_neg (Eq control_X 0)}))\n                         {v. stable ?\\<S>'107 v})\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply (has_type_tac' aexpr: type_aexpr_Const)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred\n                         (add_pred {}\n                           ({control_Z, control_Y, control_X}, {Z})\n                           (Eq control_X 0))\n                         ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_Y 0)))\n                       (control_Z \\<leftarrow> Const 1)\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z}) ?P''129\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       {Same control_Z (Const 0), Eq control_Y 0,\n                        Eq control_X 0}\n                       {Eq control_Y 0}\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''129 {bexp_neg (Eq control_Y 0)}\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_X 0)))\n                       (control_Z \\<leftarrow> Const 1)\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z}) ?P''110\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_Y 0) `\n                          ({Same control_Z (Const 0), Eq control_Y 0,\n                            Eq control_X 0} -\n                           {Eq control_Y 0}) \\<union>\n                          Imp (bexp_neg (Eq control_Y 0)) `\n                          (?P''129 - {bexp_neg (Eq control_Y 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       {Eq control_X 0}\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''110 {bexp_neg (Eq control_X 0)}\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (restrict_preds_to_vars\n                            (Imp (Eq control_Y 0) `\n                             ({Same control_Z (Const 0), Eq control_Y 0,\n                               Eq control_X 0} -\n                              {Eq control_Y 0}) \\<union>\n                             Imp (bexp_neg (Eq control_Y 0)) `\n                             (?P''129 - {bexp_neg (Eq control_Y 0)}))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          (?P''110 - {bexp_neg (Eq control_X 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply (has_type_tac' aexpr: type_aexpr_Const)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       {Same control_Z (Const 0), Eq control_Y 0,\n                        Eq control_X 0}\n                       {Eq control_Y 0}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       {Same control_Z (Const (Suc 0)),\n                        bexp.Not (Eq control_Y 0), Eq control_X 0}\n                       {bexp_neg (Eq control_Y 0)}\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_X 0)))\n                       (control_Z \\<leftarrow> Const 1)\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z}) ?P''110\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_Y 0) `\n                          ({Same control_Z (Const 0), Eq control_Y 0,\n                            Eq control_X 0} -\n                           {Eq control_Y 0}) \\<union>\n                          Imp (bexp_neg (Eq control_Y 0)) `\n                          ({Same control_Z (Const (Suc 0)),\n                            bexp.Not (Eq control_Y 0), Eq control_X 0} -\n                           {bexp_neg (Eq control_Y 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       {Eq control_X 0}\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''110 {bexp_neg (Eq control_X 0)}\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (restrict_preds_to_vars\n                            (Imp (Eq control_Y 0) `\n                             ({Same control_Z (Const 0), Eq control_Y 0,\n                               Eq control_X 0} -\n                              {Eq control_Y 0}) \\<union>\n                             Imp (bexp_neg (Eq control_Y 0)) `\n                             ({Same control_Z (Const (Suc 0)),\n                               bexp.Not (Eq control_Y 0), Eq control_X 0} -\n                              {bexp_neg (Eq control_Y 0)}))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          (?P''110 - {bexp_neg (Eq control_X 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(clarsimp simp: subset_entailment)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       {Same control_Z (Const (Suc 0)),\n                        bexp.Not (Eq control_Y 0), Eq control_X 0}\n                       {bexp_neg (Eq control_Y 0)}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_X 0)))\n                       (control_Z \\<leftarrow> Const 1)\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z}) ?P''110\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_Y 0) `\n                          ({Same control_Z (Const 0), Eq control_Y 0,\n                            Eq control_X 0} -\n                           {Eq control_Y 0}) \\<union>\n                          Imp (bexp_neg (Eq control_Y 0)) `\n                          ({Same control_Z (Const (Suc 0)),\n                            bexp.Not (Eq control_Y 0), Eq control_X 0} -\n                           {bexp_neg (Eq control_Y 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       {Eq control_X 0}\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''110 {bexp_neg (Eq control_X 0)}\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (restrict_preds_to_vars\n                            (Imp (Eq control_Y 0) `\n                             ({Same control_Z (Const 0), Eq control_Y 0,\n                               Eq control_X 0} -\n                              {Eq control_Y 0}) \\<union>\n                             Imp (bexp_neg (Eq control_Y 0)) `\n                             ({Same control_Z (Const (Suc 0)),\n                               bexp.Not (Eq control_Y 0), Eq control_X 0} -\n                              {bexp_neg (Eq control_Y 0)}))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          (?P''110 - {bexp_neg (Eq control_X 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(clarsimp simp: subset_entailment)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (add_pred {} ({control_Z, control_Y, control_X}, {Z})\n                         (bexp_neg (Eq control_X 0)))\n                       (control_Z \\<leftarrow> Const 1)\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z}) ?P''110\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_Y 0) `\n                          ({Same control_Z (Const 0), Eq control_Y 0,\n                            Eq control_X 0} -\n                           {Eq control_Y 0}) \\<union>\n                          Imp (bexp_neg (Eq control_Y 0)) `\n                          ({Same control_Z (Const (Suc 0)),\n                            bexp.Not (Eq control_Y 0), Eq control_X 0} -\n                           {bexp_neg (Eq control_Y 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       {Eq control_X 0}\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''110 {bexp_neg (Eq control_X 0)}\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (restrict_preds_to_vars\n                            (Imp (Eq control_Y 0) `\n                             ({Same control_Z (Const 0), Eq control_Y 0,\n                               Eq control_X 0} -\n                              {Eq control_Y 0}) \\<union>\n                             Imp (bexp_neg (Eq control_Y 0)) `\n                             ({Same control_Z (Const (Suc 0)),\n                               bexp.Not (Eq control_Y 0), Eq control_X 0} -\n                              {bexp_neg (Eq control_Y 0)}))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          (?P''110 - {bexp_neg (Eq control_X 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply (has_type_tac' aexpr: type_aexpr_Const)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_Y 0) `\n                          ({Same control_Z (Const 0), Eq control_Y 0,\n                            Eq control_X 0} -\n                           {Eq control_Y 0}) \\<union>\n                          Imp (bexp_neg (Eq control_Y 0)) `\n                          ({Same control_Z (Const (Suc 0)),\n                            bexp.Not (Eq control_Y 0), Eq control_X 0} -\n                           {bexp_neg (Eq control_Y 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       {Eq control_X 0}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       {Same control_Z (Const (Suc 0)),\n                        bexp.Not (Eq control_X 0)}\n                       {bexp_neg (Eq control_X 0)}\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (restrict_preds_to_vars\n                            (Imp (Eq control_Y 0) `\n                             ({Same control_Z (Const 0), Eq control_Y 0,\n                               Eq control_X 0} -\n                              {Eq control_Y 0}) \\<union>\n                             Imp (bexp_neg (Eq control_Y 0)) `\n                             ({Same control_Z (Const (Suc 0)),\n                               bexp.Not (Eq control_Y 0), Eq control_X 0} -\n                              {bexp_neg (Eq control_Y 0)}))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          ({Same control_Z (Const (Suc 0)),\n                            bexp.Not (Eq control_X 0)} -\n                           {bexp_neg (Eq control_X 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       {Imp (bexp.Not (Eq control_Y 0))\n                         (Same control_Z (Const (Suc 0))),\n                        Imp (bexp.Not (Eq control_Y 0)) (Eq control_X 0),\n                        Imp (Eq control_Y 0) (Same control_Z (Const 0)),\n                        Imp (Eq control_Y 0) (Eq control_X 0)}\n                       {Eq control_X 0}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       {Same control_Z (Const (Suc 0)),\n                        bexp.Not (Eq control_X 0)}\n                       {bexp_neg (Eq control_X 0)}\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (restrict_preds_to_vars\n                            (Imp (Eq control_Y 0) `\n                             ({Same control_Z (Const 0), Eq control_Y 0,\n                               Eq control_X 0} -\n                              {Eq control_Y 0}) \\<union>\n                             Imp (bexp_neg (Eq control_Y 0)) `\n                             ({Same control_Z (Const (Suc 0)),\n                               bexp.Not (Eq control_Y 0), Eq control_X 0} -\n                              {bexp_neg (Eq control_Y 0)}))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          ({Same control_Z (Const (Suc 0)),\n                            bexp.Not (Eq control_X 0)} -\n                           {bexp_neg (Eq control_X 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(fastforce intro: pred_entailment_singleton_by_case_distinction simp: image_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       {Same control_Z (Const (Suc 0)),\n                        bexp.Not (Eq control_X 0)}\n                       {bexp_neg (Eq control_X 0)}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (restrict_preds_to_vars\n                            (Imp (Eq control_Y 0) `\n                             ({Same control_Z (Const 0), Eq control_Y 0,\n                               Eq control_X 0} -\n                              {Eq control_Y 0}) \\<union>\n                             Imp (bexp_neg (Eq control_Y 0)) `\n                             ({Same control_Z (Const (Suc 0)),\n                               bexp.Not (Eq control_Y 0), Eq control_X 0} -\n                              {bexp_neg (Eq control_Y 0)}))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          ({Same control_Z (Const (Suc 0)),\n                            bexp.Not (Eq control_X 0)} -\n                           {bexp_neg (Eq control_X 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(fastforce intro: subset_entailment)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [Z \\<mapsto> {Eq control_Z 0}, Z \\<mapsto>\n                        \\<Union> {dma_type X, dma_type Y}]\n                       ({control_Z, control_Y, control_X}, {Z})\n                       (restrict_preds_to_vars\n                         (Imp (Eq control_X 0) `\n                          (restrict_preds_to_vars\n                            (Imp (Eq control_Y 0) `\n                             ({Same control_Z (Const 0), Eq control_Y 0,\n                               Eq control_X 0} -\n                              {Eq control_Y 0}) \\<union>\n                             Imp (bexp_neg (Eq control_Y 0)) `\n                             ({Same control_Z (Const (Suc 0)),\n                               bexp.Not (Eq control_Y 0), Eq control_X 0} -\n                              {bexp_neg (Eq control_Y 0)}))\n                            {v. stable\n                                 ({control_Z, control_Y, control_X}, {Z})\n                                 v} -\n                           {Eq control_X 0}) \\<union>\n                          Imp (bexp_neg (Eq control_X 0)) `\n                          ({Same control_Z (Const (Suc 0)),\n                            bexp.Not (Eq control_X 0)} -\n                           {bexp_neg (Eq control_X 0)}))\n                         {v. stable ({control_Z, control_Y, control_X}, {Z})\n                              v})\n                       ((Skip@[Z -=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (Skip@[control_X -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Y -=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[control_Z -=\\<^sub>m AsmNoWrite]) ;; Skip)\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply (has_type_tac')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "end"]]}