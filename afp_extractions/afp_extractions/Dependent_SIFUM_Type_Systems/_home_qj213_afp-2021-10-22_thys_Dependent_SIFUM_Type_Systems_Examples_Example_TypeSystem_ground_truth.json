{"file_name": "/home/qj213/afp-2021-10-22/thys/Dependent_SIFUM_Type_Systems/Examples/Example_TypeSystem.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Dependent_SIFUM_Type_Systems", "problem_names": ["lemma \\<C>_simp[simp]:\n  \"\\<C> = {control_var}\"", "lemma type_aexpr_Load:\n  \"v \\<notin> dom \\<Gamma> \\<Longrightarrow> type_aexpr \\<Gamma> (Load v) (dma_type v)\"", "lemma type_aexpr_Load':\n  \"v \\<in> dom \\<Gamma> \\<Longrightarrow> t = (the (\\<Gamma> v)) \\<Longrightarrow> type_aexpr \\<Gamma> (Load v) t\"", "lemma [simp]: \"pred_entailment P {}\"", "lemma [simp]: \"e \\<in> P \\<Longrightarrow> pred_entailment P {e}\"", "lemma [simp]: \"FF \\<in> P \\<Longrightarrow> pred_entailment P Q\"", "lemma read_buffer_typed:\n  \"\\<Gamma> = (\\<lambda>_. None) \\<Longrightarrow> \\<S> = ({},{}) \\<Longrightarrow> P = {} \\<Longrightarrow> \n  \\<exists>\\<Gamma>' \\<S>' P'. has_type \\<Gamma> \\<S> P read_buffer \\<Gamma>' \\<S>' P'\"", "lemma read_buffer_com_sifum_secure:\n  \"com_sifum_secure (read_buffer,(\\<lambda>_. {}))\"", "lemma restrict_preds_to_vars_empty[simp]:\n  \"restrict_preds_to_vars {} V = {}\"", "lemma restrict_preds_to_vars_idemp[simp]:\n  \"restrict_preds_to_vars (restrict_preds_to_vars P V) V = \n   restrict_preds_to_vars P V\"", "lemma restrict_preds_to_vars_insert1[simp]:\n  \"(\\<forall>x\\<in>bexp_vars a. x \\<in> V) \\<Longrightarrow> restrict_preds_to_vars (insert a P) V = (insert a (restrict_preds_to_vars P V))\"", "lemma restrict_preds_to_vars_insert2[simp]:\n  \"(\\<exists>x\\<in>bexp_vars a. x \\<notin> V) \\<Longrightarrow> restrict_preds_to_vars (insert a P) V = ((restrict_preds_to_vars P V))\"", "lemma [simp]:\n  \"Eq a b \\<in> P \\<Longrightarrow> Neq a b \\<in> P \\<Longrightarrow> pred_entailment P Q\"", "lemma write_buffer_typed:\n  \"\\<Gamma> = (\\<lambda>_. None) \\<Longrightarrow> \\<S> = ({},{}) \\<Longrightarrow> P = {} \\<Longrightarrow> \n  \\<exists>\\<Gamma>' \\<S>' P'. has_type \\<Gamma> \\<S> P write_buffer \\<Gamma>' \\<S>' P'\"", "lemma read_buffer_typed':\n  \"\\<Gamma> = (\\<lambda>_. None) \\<Longrightarrow> \\<S> = ({},{}) \\<Longrightarrow> P = {} \\<Longrightarrow> \n  \\<exists>\\<Gamma>' \\<S>' P'. has_type \\<Gamma> \\<S> P read_buffer \\<Gamma>' \\<S>' P'\"", "lemma write_buffer_typed':\n  \"\\<Gamma> = (\\<lambda>_. None) \\<Longrightarrow> \\<S> = ({},{}) \\<Longrightarrow> P = {} \\<Longrightarrow> \n  \\<exists>\\<Gamma>' \\<S>' P'. has_type \\<Gamma> \\<S> P write_buffer \\<Gamma>' \\<S>' P'\""], "translations": [["", "lemma \\<C>_simp[simp]:\n  \"\\<C> = {control_var}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<C> = {control_var}", "by(auto simp: \\<C>_def \\<C>_vars_def split: if_splits)"], ["", "lemma type_aexpr_Load:\n  \"v \\<notin> dom \\<Gamma> \\<Longrightarrow> type_aexpr \\<Gamma> (Load v) (dma_type v)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. v \\<notin> dom \\<Gamma> \\<Longrightarrow>\n    type_aexpr \\<Gamma> (Load v) (dma_type v)", "apply(insert type_aexpr[of \\<Gamma> \"Load v\", simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<notin> dom \\<Gamma>;\n     type_aexpr \\<Gamma> (Load v) (to_total \\<Gamma> v)\\<rbrakk>\n    \\<Longrightarrow> type_aexpr \\<Gamma> (Load v) (dma_type v)", "apply(simp add: to_total_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma type_aexpr_Load':\n  \"v \\<in> dom \\<Gamma> \\<Longrightarrow> t = (the (\\<Gamma> v)) \\<Longrightarrow> type_aexpr \\<Gamma> (Load v) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> dom \\<Gamma>; t = the (\\<Gamma> v)\\<rbrakk>\n    \\<Longrightarrow> type_aexpr \\<Gamma> (Load v) t", "apply(insert type_aexpr[of \\<Gamma> \"Load v\", simplified])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>v \\<in> dom \\<Gamma>; t = the (\\<Gamma> v);\n     type_aexpr \\<Gamma> (Load v) (to_total \\<Gamma> v)\\<rbrakk>\n    \\<Longrightarrow> type_aexpr \\<Gamma> (Load v) t", "apply(simp add: to_total_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare restrict_preds_to_vars_def [simp]"], ["", "declare add_pred_def [simp]"], ["", "declare stable_def [simp]"], ["", "declare to_total_def [simp]"], ["", "declare \\<C>_vars_def [simp]"], ["", "declare anno_type_stable_def [simp]"], ["", "declare anno_type_sec_def [simp]"], ["", "declare assign_post_def [simp]"], ["", "lemma [simp]: \"pred_entailment P {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pred_entailment P {}", "by(simp add: pred_entailment_def pred_def)"], ["", "lemma [simp]: \"e \\<in> P \\<Longrightarrow> pred_entailment P {e}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e \\<in> P \\<Longrightarrow> pred_entailment P {e}", "by(blast intro: subset_entailment)"], ["", "lemma [simp]: \"FF \\<in> P \\<Longrightarrow> pred_entailment P Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. FF \\<in> P \\<Longrightarrow> pred_entailment P Q", "by(auto simp: pred_entailment_def pred_def)"], ["", "lemma read_buffer_typed:\n  \"\\<Gamma> = (\\<lambda>_. None) \\<Longrightarrow> \\<S> = ({},{}) \\<Longrightarrow> P = {} \\<Longrightarrow> \n  \\<exists>\\<Gamma>' \\<S>' P'. has_type \\<Gamma> \\<S> P read_buffer \\<Gamma>' \\<S>' P'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<Gamma>' \\<S>' P'.\n                         has_type \\<Gamma> \\<S> P read_buffer \\<Gamma>'\n                          \\<S>' P'", "apply(intro exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type \\<Gamma> \\<S> P read_buffer ?\\<Gamma>'\n                       ?\\<S>'1 ?P'2", "apply(simp add: read_buffer_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({}, {}) {}\n                       ((Skip@[control_var +=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[temp +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (temp \\<leftarrow> Load buffer) ;;\n                        Stmt.If (Eq control_var 0)\n                         (low_var \\<leftarrow> Load temp)\n                         (high_var \\<leftarrow> Load temp))\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule seq_type)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({}, {}) {}\n                       (Skip@[control_var +=\\<^sub>m AsmNoWrite])\n                       ?\\<Gamma>'3 ?\\<S>'3 ?P'3\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'3 ?\\<S>'3 ?P'3\n                       ((Skip@[temp +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (temp \\<leftarrow> Load buffer) ;;\n                        Stmt.If (Eq control_var 0)\n                         (low_var \\<leftarrow> Load temp)\n                         (high_var \\<leftarrow> Load temp))\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule anno_type[OF HOL.refl HOL.refl HOL.refl])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno Map.empty ({}, {})\n                         (control_var +=\\<^sub>m AsmNoWrite))\n                       (add_anno_stable ({}, {})\n                         (control_var +=\\<^sub>m AsmNoWrite))\n                       (restrict_preds_to_vars {}\n                         {v. stable\n                              (add_anno_stable ({}, {})\n                                (control_var +=\\<^sub>m AsmNoWrite))\n                              v})\n                       Skip ?\\<Gamma>'3 ?\\<S>'3 ?P'3\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable ({}, {})\n                                   (control_var +=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty ({}, {})\n                              (control_var +=\\<^sub>m AsmNoWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty ({}, {})\n                       (control_var +=\\<^sub>m AsmNoWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({}, {}) {}\n                       (control_var +=\\<^sub>m AsmNoWrite)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'3 ?\\<S>'3 ?P'3\n                       ((Skip@[temp +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (temp \\<leftarrow> Load buffer) ;;\n                        Stmt.If (Eq control_var 0)\n                         (low_var \\<leftarrow> Load temp)\n                         (high_var \\<leftarrow> Load temp))\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply clarsimp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({control_var}, {}) {} Skip\n                       ?\\<Gamma>'3 ?\\<S>'3 ?P'3\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable ({}, {})\n                                   (control_var +=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty ({}, {})\n                              (control_var +=\\<^sub>m AsmNoWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty ({}, {})\n                       (control_var +=\\<^sub>m AsmNoWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({}, {}) {}\n                       (control_var +=\\<^sub>m AsmNoWrite)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'3 ?\\<S>'3 ?P'3\n                       ((Skip@[temp +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (temp \\<leftarrow> Load buffer) ;;\n                        Stmt.If (Eq control_var 0)\n                         (low_var \\<leftarrow> Load temp)\n                         (high_var \\<leftarrow> Load temp))\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule skip_type)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 2. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable ({}, {})\n                                   (control_var +=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty ({}, {})\n                              (control_var +=\\<^sub>m AsmNoWrite))\n                            x)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty ({}, {})\n                       (control_var +=\\<^sub>m AsmNoWrite)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({}, {}) {}\n                       (control_var +=\\<^sub>m AsmNoWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({control_var}, {}) {}\n                       ((Skip@[temp +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (temp \\<leftarrow> Load buffer) ;;\n                        Stmt.If (Eq control_var 0)\n                         (low_var \\<leftarrow> Load temp)\n                         (high_var \\<leftarrow> Load temp))\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable ({}, {})\n                                   (control_var +=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty ({}, {})\n                              (control_var +=\\<^sub>m AsmNoWrite))\n                            x)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty ({}, {})\n                       (control_var +=\\<^sub>m AsmNoWrite)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({}, {}) {}\n                       (control_var +=\\<^sub>m AsmNoWrite)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({control_var}, {}) {}\n                       ((Skip@[temp +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (temp \\<leftarrow> Load buffer) ;;\n                        Stmt.If (Eq control_var 0)\n                         (low_var \\<leftarrow> Load temp)\n                         (high_var \\<leftarrow> Load temp))\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty ({}, {})\n                       (control_var +=\\<^sub>m AsmNoWrite)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({}, {}) {}\n                       (control_var +=\\<^sub>m AsmNoWrite)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({control_var}, {}) {}\n                       ((Skip@[temp +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (temp \\<leftarrow> Load buffer) ;;\n                        Stmt.If (Eq control_var 0)\n                         (low_var \\<leftarrow> Load temp)\n                         (high_var \\<leftarrow> Load temp))\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({}, {}) {}\n                       (control_var +=\\<^sub>m AsmNoWrite)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({control_var}, {}) {}\n                       ((Skip@[temp +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (temp \\<leftarrow> Load buffer) ;;\n                        Stmt.If (Eq control_var 0)\n                         (low_var \\<leftarrow> Load temp)\n                         (high_var \\<leftarrow> Load temp))\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({control_var}, {}) {}\n                       ((Skip@[temp +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        (temp \\<leftarrow> Load buffer) ;;\n                        Stmt.If (Eq control_var 0)\n                         (low_var \\<leftarrow> Load temp)\n                         (high_var \\<leftarrow> Load temp))\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule seq_type)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({control_var}, {}) {}\n                       (Skip@[temp +=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>'18 ?\\<S>'18 ?P'18\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'18 ?\\<S>'18 ?P'18\n                       ((temp \\<leftarrow> Load buffer) ;;\n                        Stmt.If (Eq control_var 0)\n                         (low_var \\<leftarrow> Load temp)\n                         (high_var \\<leftarrow> Load temp))\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule anno_type[OF HOL.refl HOL.refl HOL.refl])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno Map.empty ({control_var}, {})\n                         (temp +=\\<^sub>m AsmNoReadOrWrite))\n                       (add_anno_stable ({control_var}, {})\n                         (temp +=\\<^sub>m AsmNoReadOrWrite))\n                       (restrict_preds_to_vars {}\n                         {v. stable\n                              (add_anno_stable ({control_var}, {})\n                                (temp +=\\<^sub>m AsmNoReadOrWrite))\n                              v})\n                       Skip ?\\<Gamma>'18 ?\\<S>'18 ?P'18\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable ({control_var}, {})\n                                   (temp +=\\<^sub>m AsmNoReadOrWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty ({control_var}, {})\n                              (temp +=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty ({control_var}, {})\n                       (temp +=\\<^sub>m AsmNoReadOrWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({control_var}, {}) {}\n                       (temp +=\\<^sub>m AsmNoReadOrWrite)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'18 ?\\<S>'18 ?P'18\n                       ((temp \\<leftarrow> Load buffer) ;;\n                        Stmt.If (Eq control_var 0)\n                         (low_var \\<leftarrow> Load temp)\n                         (high_var \\<leftarrow> Load temp))\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply clarsimp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {}] ({control_var}, {temp})\n                       {} Skip ?\\<Gamma>'18 ?\\<S>'18 ?P'18\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable ({control_var}, {})\n                                   (temp +=\\<^sub>m AsmNoReadOrWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty ({control_var}, {})\n                              (temp +=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty ({control_var}, {})\n                       (temp +=\\<^sub>m AsmNoReadOrWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({control_var}, {}) {}\n                       (temp +=\\<^sub>m AsmNoReadOrWrite)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'18 ?\\<S>'18 ?P'18\n                       ((temp \\<leftarrow> Load buffer) ;;\n                        Stmt.If (Eq control_var 0)\n                         (low_var \\<leftarrow> Load temp)\n                         (high_var \\<leftarrow> Load temp))\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule skip_type)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 2. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable ({control_var}, {})\n                                   (temp +=\\<^sub>m AsmNoReadOrWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty ({control_var}, {})\n                              (temp +=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty ({control_var}, {})\n                       (temp +=\\<^sub>m AsmNoReadOrWrite)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({control_var}, {}) {}\n                       (temp +=\\<^sub>m AsmNoReadOrWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {}] ({control_var}, {temp})\n                       {} ((temp \\<leftarrow> Load buffer) ;;\n                           Stmt.If (Eq control_var 0)\n                            (low_var \\<leftarrow> Load temp)\n                            (high_var \\<leftarrow> Load temp))\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable ({control_var}, {})\n                                   (temp +=\\<^sub>m AsmNoReadOrWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty ({control_var}, {})\n                              (temp +=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty ({control_var}, {})\n                       (temp +=\\<^sub>m AsmNoReadOrWrite)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({control_var}, {}) {}\n                       (temp +=\\<^sub>m AsmNoReadOrWrite)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {}] ({control_var}, {temp})\n                       {} ((temp \\<leftarrow> Load buffer) ;;\n                           Stmt.If (Eq control_var 0)\n                            (low_var \\<leftarrow> Load temp)\n                            (high_var \\<leftarrow> Load temp))\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty ({control_var}, {})\n                       (temp +=\\<^sub>m AsmNoReadOrWrite)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({control_var}, {}) {}\n                       (temp +=\\<^sub>m AsmNoReadOrWrite)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {}] ({control_var}, {temp})\n                       {} ((temp \\<leftarrow> Load buffer) ;;\n                           Stmt.If (Eq control_var 0)\n                            (low_var \\<leftarrow> Load temp)\n                            (high_var \\<leftarrow> Load temp))\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({control_var}, {}) {}\n                       (temp +=\\<^sub>m AsmNoReadOrWrite)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {}] ({control_var}, {temp})\n                       {} ((temp \\<leftarrow> Load buffer) ;;\n                           Stmt.If (Eq control_var 0)\n                            (low_var \\<leftarrow> Load temp)\n                            (high_var \\<leftarrow> Load temp))\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {}] ({control_var}, {temp})\n                       {} ((temp \\<leftarrow> Load buffer) ;;\n                           Stmt.If (Eq control_var 0)\n                            (low_var \\<leftarrow> Load temp)\n                            (high_var \\<leftarrow> Load temp))\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule seq_type)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {}] ({control_var}, {temp})\n                       {} (temp \\<leftarrow> Load buffer) ?\\<Gamma>'37\n                       ?\\<S>'37 ?P'37\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'37 ?\\<S>'37 ?P'37\n                       (Stmt.If (Eq control_var 0)\n                         (low_var \\<leftarrow> Load temp)\n                         (high_var \\<leftarrow> Load temp))\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule assign\\<^sub>2[OF _ _ _ HOL.refl])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> temp \\<in> dom [temp \\<mapsto> {}]\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr [temp \\<mapsto> {}] (Load buffer) ?t40\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable ({control_var}, {temp}) ?t40\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> temp\n                      \\<notin> snd ({control_var}, {temp}) \\<longrightarrow>\n                      subtype ?t40\n                       (restrict_preds_to_vars\n                         (assign_post {} temp (Load buffer))\n                         {v. stable ({control_var}, {temp}) v})\n                       (dma_type temp)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {}, temp \\<mapsto> ?t40]\n                       ({control_var}, {temp})\n                       (restrict_preds_to_vars\n                         (assign_post {} temp (Load buffer))\n                         {v. stable ({control_var}, {temp}) v})\n                       (Stmt.If (Eq control_var 0)\n                         (low_var \\<leftarrow> Load temp)\n                         (high_var \\<leftarrow> Load temp))\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr [temp \\<mapsto> {}] (Load buffer) ?t40\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable ({control_var}, {temp}) ?t40\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> temp\n                      \\<notin> snd ({control_var}, {temp}) \\<longrightarrow>\n                      subtype ?t40\n                       (restrict_preds_to_vars\n                         (assign_post {} temp (Load buffer))\n                         {v. stable ({control_var}, {temp}) v})\n                       (dma_type temp)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {}, temp \\<mapsto> ?t40]\n                       ({control_var}, {temp})\n                       (restrict_preds_to_vars\n                         (assign_post {} temp (Load buffer))\n                         {v. stable ({control_var}, {temp}) v})\n                       (Stmt.If (Eq control_var 0)\n                         (low_var \\<leftarrow> Load temp)\n                         (high_var \\<leftarrow> Load temp))\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule type_aexpr_Load)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> buffer \\<notin> dom [temp \\<mapsto> {}]\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable ({control_var}, {temp}) (dma_type buffer)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> temp\n                      \\<notin> snd ({control_var}, {temp}) \\<longrightarrow>\n                      subtype (dma_type buffer)\n                       (restrict_preds_to_vars\n                         (assign_post {} temp (Load buffer))\n                         {v. stable ({control_var}, {temp}) v})\n                       (dma_type temp)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp})\n                       (restrict_preds_to_vars\n                         (assign_post {} temp (Load buffer))\n                         {v. stable ({control_var}, {temp}) v})\n                       (Stmt.If (Eq control_var 0)\n                         (low_var \\<leftarrow> Load temp)\n                         (high_var \\<leftarrow> Load temp))\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable ({control_var}, {temp}) (dma_type buffer)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> temp\n                      \\<notin> snd ({control_var}, {temp}) \\<longrightarrow>\n                      subtype (dma_type buffer)\n                       (restrict_preds_to_vars\n                         (assign_post {} temp (Load buffer))\n                         {v. stable ({control_var}, {temp}) v})\n                       (dma_type temp)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp})\n                       (restrict_preds_to_vars\n                         (assign_post {} temp (Load buffer))\n                         {v. stable ({control_var}, {temp}) v})\n                       (Stmt.If (Eq control_var 0)\n                         (low_var \\<leftarrow> Load temp)\n                         (high_var \\<leftarrow> Load temp))\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> temp\n                      \\<notin> snd ({control_var}, {temp}) \\<longrightarrow>\n                      subtype (dma_type buffer)\n                       (restrict_preds_to_vars\n                         (assign_post {} temp (Load buffer))\n                         {v. stable ({control_var}, {temp}) v})\n                       (dma_type temp)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp})\n                       (restrict_preds_to_vars\n                         (assign_post {} temp (Load buffer))\n                         {v. stable ({control_var}, {temp}) v})\n                       (Stmt.If (Eq control_var 0)\n                         (low_var \\<leftarrow> Load temp)\n                         (high_var \\<leftarrow> Load temp))\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp})\n                       (restrict_preds_to_vars\n                         (assign_post {} temp (Load buffer))\n                         {v. stable ({control_var}, {temp}) v})\n                       (Stmt.If (Eq control_var 0)\n                         (low_var \\<leftarrow> Load temp)\n                         (high_var \\<leftarrow> Load temp))\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule if_type')"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_bexpr\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type buffer]\n                       (Eq control_var 0) ?t51\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (assign_post {} temp (Load buffer))\n                         {v. stable ({control_var}, {temp}) v})\n                       ?t51\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp})\n                       (add_pred\n                         (restrict_preds_to_vars\n                           (assign_post {} temp (Load buffer))\n                           {v. stable ({control_var}, {temp}) v})\n                         ({control_var}, {temp}) (Eq control_var 0))\n                       (low_var \\<leftarrow> Load temp) ?\\<Gamma>' ?\\<S>'1\n                       ?P'51\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp})\n                       (add_pred\n                         (restrict_preds_to_vars\n                           (assign_post {} temp (Load buffer))\n                           {v. stable ({control_var}, {temp}) v})\n                         ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (high_var \\<leftarrow> Load temp) ?\\<Gamma>' ?\\<S>'1\n                       ?P''51\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'2 \\<subseteq> ?P'51 \\<inter> ?P''51", "apply(rule type_bexprI)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?t51 =\n                      \\<Union>\n                       (to_total\n                         [temp \\<mapsto> {}, temp \\<mapsto>\n                          dma_type buffer] `\n                        bexp_vars (Eq control_var 0))\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (assign_post {} temp (Load buffer))\n                         {v. stable ({control_var}, {temp}) v})\n                       ?t51\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp})\n                       (add_pred\n                         (restrict_preds_to_vars\n                           (assign_post {} temp (Load buffer))\n                           {v. stable ({control_var}, {temp}) v})\n                         ({control_var}, {temp}) (Eq control_var 0))\n                       (low_var \\<leftarrow> Load temp) ?\\<Gamma>' ?\\<S>'1\n                       ?P'51\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp})\n                       (add_pred\n                         (restrict_preds_to_vars\n                           (assign_post {} temp (Load buffer))\n                           {v. stable ({control_var}, {temp}) v})\n                         ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (high_var \\<leftarrow> Load temp) ?\\<Gamma>' ?\\<S>'1\n                       ?P''51\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'2 \\<subseteq> ?P'51 \\<inter> ?P''51", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (assign_post {} temp (Load buffer))\n                         {v. stable ({control_var}, {temp}) v})\n                       {}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp})\n                       (add_pred\n                         (restrict_preds_to_vars\n                           (assign_post {} temp (Load buffer))\n                           {v. stable ({control_var}, {temp}) v})\n                         ({control_var}, {temp}) (Eq control_var 0))\n                       (low_var \\<leftarrow> Load temp) ?\\<Gamma>' ?\\<S>'1\n                       ?P'51\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp})\n                       (add_pred\n                         (restrict_preds_to_vars\n                           (assign_post {} temp (Load buffer))\n                           {v. stable ({control_var}, {temp}) v})\n                         ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (high_var \\<leftarrow> Load temp) ?\\<Gamma>' ?\\<S>'1\n                       ?P''51\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'2 \\<subseteq> ?P'51 \\<inter> ?P''51", "apply(clarsimp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp})\n                       (add_pred\n                         (restrict_preds_to_vars\n                           (assign_post {} temp (Load buffer))\n                           {v. stable ({control_var}, {temp}) v})\n                         ({control_var}, {temp}) (Eq control_var 0))\n                       (low_var \\<leftarrow> Load temp) ?\\<Gamma>' ?\\<S>'1\n                       ?P'51\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp})\n                       (add_pred\n                         (restrict_preds_to_vars\n                           (assign_post {} temp (Load buffer))\n                           {v. stable ({control_var}, {temp}) v})\n                         ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (high_var \\<leftarrow> Load temp) ?\\<Gamma>' ?\\<S>'1\n                       ?P''51\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'2 \\<subseteq> ?P'51 \\<inter> ?P''51", "apply(rule assign\\<^sub>1)"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> low_var\n                      \\<notin> dom [temp \\<mapsto> {}, temp \\<mapsto>\n                                    dma_type buffer]\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> low_var \\<notin> \\<C>\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type buffer]\n                       (Load temp) ?t63\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> subtype ?t63\n                       (add_pred\n                         (restrict_preds_to_vars\n                           (assign_post {} temp (Load buffer))\n                           {v. stable ({control_var}, {temp}) v})\n                         ({control_var}, {temp}) (Eq control_var 0))\n                       (dma_type low_var)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'51 =\n                      restrict_preds_to_vars\n                       (assign_post\n                         (add_pred\n                           (restrict_preds_to_vars\n                             (assign_post {} temp (Load buffer))\n                             {v. stable ({control_var}, {temp}) v})\n                           ({control_var}, {temp}) (Eq control_var 0))\n                         low_var (Load temp))\n                       {v. stable ({control_var}, {temp}) v}\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp})\n                       (add_pred\n                         (restrict_preds_to_vars\n                           (assign_post {} temp (Load buffer))\n                           {v. stable ({control_var}, {temp}) v})\n                         ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (high_var \\<leftarrow> Load temp)\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp}) ?P''51\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'2 \\<subseteq> ?P'51 \\<inter> ?P''51", "apply simp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> low_var \\<notin> \\<C>\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type buffer]\n                       (Load temp) ?t63\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> subtype ?t63\n                       (add_pred\n                         (restrict_preds_to_vars\n                           (assign_post {} temp (Load buffer))\n                           {v. stable ({control_var}, {temp}) v})\n                         ({control_var}, {temp}) (Eq control_var 0))\n                       (dma_type low_var)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'51 =\n                      restrict_preds_to_vars\n                       (assign_post\n                         (add_pred\n                           (restrict_preds_to_vars\n                             (assign_post {} temp (Load buffer))\n                             {v. stable ({control_var}, {temp}) v})\n                           ({control_var}, {temp}) (Eq control_var 0))\n                         low_var (Load temp))\n                       {v. stable ({control_var}, {temp}) v}\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp})\n                       (add_pred\n                         (restrict_preds_to_vars\n                           (assign_post {} temp (Load buffer))\n                           {v. stable ({control_var}, {temp}) v})\n                         ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (high_var \\<leftarrow> Load temp)\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp}) ?P''51\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'2 \\<subseteq> ?P'51 \\<inter> ?P''51", "apply(simp)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type buffer]\n                       (Load temp) ?t63\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> subtype ?t63\n                       (add_pred\n                         (restrict_preds_to_vars\n                           (assign_post {} temp (Load buffer))\n                           {v. stable ({control_var}, {temp}) v})\n                         ({control_var}, {temp}) (Eq control_var 0))\n                       (dma_type low_var)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'51 =\n                      restrict_preds_to_vars\n                       (assign_post\n                         (add_pred\n                           (restrict_preds_to_vars\n                             (assign_post {} temp (Load buffer))\n                             {v. stable ({control_var}, {temp}) v})\n                           ({control_var}, {temp}) (Eq control_var 0))\n                         low_var (Load temp))\n                       {v. stable ({control_var}, {temp}) v}\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp})\n                       (add_pred\n                         (restrict_preds_to_vars\n                           (assign_post {} temp (Load buffer))\n                           {v. stable ({control_var}, {temp}) v})\n                         ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (high_var \\<leftarrow> Load temp)\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp}) ?P''51\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'2 \\<subseteq> ?P'51 \\<inter> ?P''51", "apply(rule type_aexpr_Load')"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> temp\n                      \\<in> dom [temp \\<mapsto> {}, temp \\<mapsto>\n                                 dma_type buffer]\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?t63 =\n                      the ([temp \\<mapsto> {}, temp \\<mapsto>\n                            dma_type buffer]\n                            temp)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> subtype ?t63\n                       (add_pred\n                         (restrict_preds_to_vars\n                           (assign_post {} temp (Load buffer))\n                           {v. stable ({control_var}, {temp}) v})\n                         ({control_var}, {temp}) (Eq control_var 0))\n                       (dma_type low_var)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'51 =\n                      restrict_preds_to_vars\n                       (assign_post\n                         (add_pred\n                           (restrict_preds_to_vars\n                             (assign_post {} temp (Load buffer))\n                             {v. stable ({control_var}, {temp}) v})\n                           ({control_var}, {temp}) (Eq control_var 0))\n                         low_var (Load temp))\n                       {v. stable ({control_var}, {temp}) v}\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp})\n                       (add_pred\n                         (restrict_preds_to_vars\n                           (assign_post {} temp (Load buffer))\n                           {v. stable ({control_var}, {temp}) v})\n                         ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (high_var \\<leftarrow> Load temp)\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp}) ?P''51\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'2 \\<subseteq> ?P'51 \\<inter> ?P''51", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?t63 =\n                      the ([temp \\<mapsto> {}, temp \\<mapsto>\n                            dma_type buffer]\n                            temp)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> subtype ?t63\n                       (add_pred\n                         (restrict_preds_to_vars\n                           (assign_post {} temp (Load buffer))\n                           {v. stable ({control_var}, {temp}) v})\n                         ({control_var}, {temp}) (Eq control_var 0))\n                       (dma_type low_var)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'51 =\n                      restrict_preds_to_vars\n                       (assign_post\n                         (add_pred\n                           (restrict_preds_to_vars\n                             (assign_post {} temp (Load buffer))\n                             {v. stable ({control_var}, {temp}) v})\n                           ({control_var}, {temp}) (Eq control_var 0))\n                         low_var (Load temp))\n                       {v. stable ({control_var}, {temp}) v}\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp})\n                       (add_pred\n                         (restrict_preds_to_vars\n                           (assign_post {} temp (Load buffer))\n                           {v. stable ({control_var}, {temp}) v})\n                         ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (high_var \\<leftarrow> Load temp)\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp}) ?P''51\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'2 \\<subseteq> ?P'51 \\<inter> ?P''51", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> subtype {Eq control_var 0}\n                       (add_pred\n                         (restrict_preds_to_vars\n                           (assign_post {} temp (Load buffer))\n                           {v. stable ({control_var}, {temp}) v})\n                         ({control_var}, {temp}) (Eq control_var 0))\n                       (dma_type low_var)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'51 =\n                      restrict_preds_to_vars\n                       (assign_post\n                         (add_pred\n                           (restrict_preds_to_vars\n                             (assign_post {} temp (Load buffer))\n                             {v. stable ({control_var}, {temp}) v})\n                           ({control_var}, {temp}) (Eq control_var 0))\n                         low_var (Load temp))\n                       {v. stable ({control_var}, {temp}) v}\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp})\n                       (add_pred\n                         (restrict_preds_to_vars\n                           (assign_post {} temp (Load buffer))\n                           {v. stable ({control_var}, {temp}) v})\n                         ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (high_var \\<leftarrow> Load temp)\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp}) ?P''51\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'2 \\<subseteq> ?P'51 \\<inter> ?P''51", "apply(simp add: subtype_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'51 =\n                      restrict_preds_to_vars\n                       (assign_post\n                         (add_pred\n                           (restrict_preds_to_vars\n                             (assign_post {} temp (Load buffer))\n                             {v. stable ({control_var}, {temp}) v})\n                           ({control_var}, {temp}) (Eq control_var 0))\n                         low_var (Load temp))\n                       {v. stable ({control_var}, {temp}) v}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp})\n                       (add_pred\n                         (restrict_preds_to_vars\n                           (assign_post {} temp (Load buffer))\n                           {v. stable ({control_var}, {temp}) v})\n                         ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (high_var \\<leftarrow> Load temp)\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp}) ?P''51\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'2 \\<subseteq> ?P'51 \\<inter> ?P''51", "apply(simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp})\n                       (add_pred\n                         (restrict_preds_to_vars\n                           (assign_post {} temp (Load buffer))\n                           {v. stable ({control_var}, {temp}) v})\n                         ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (high_var \\<leftarrow> Load temp)\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp}) ?P''51\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'2\n                      \\<subseteq> {e. (e = Same low_var temp \\<or>\n (e = Eq control_var 0 \\<or>\n  e = Same temp buffer \\<and>\n  bexp_vars e \\<subseteq> {v. v = temp \\<or> v = control_var}) \\<and>\n low_var \\<notin> bexp_vars e) \\<and>\nbexp_vars e \\<subseteq> {v. v = temp \\<or> v = control_var}} \\<inter>\n                                  ?P''51", "apply(rule assign\\<^sub>1)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> high_var\n                      \\<notin> dom [temp \\<mapsto> {}, temp \\<mapsto>\n                                    dma_type buffer]\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> high_var \\<notin> \\<C>\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type buffer]\n                       (Load temp) ?t74\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> subtype ?t74\n                       (add_pred\n                         (restrict_preds_to_vars\n                           (assign_post {} temp (Load buffer))\n                           {v. stable ({control_var}, {temp}) v})\n                         ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (dma_type high_var)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P''51 =\n                      restrict_preds_to_vars\n                       (assign_post\n                         (add_pred\n                           (restrict_preds_to_vars\n                             (assign_post {} temp (Load buffer))\n                             {v. stable ({control_var}, {temp}) v})\n                           ({control_var}, {temp})\n                           (bexp_neg (Eq control_var 0)))\n                         high_var (Load temp))\n                       {v. stable ({control_var}, {temp}) v}\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'2\n                      \\<subseteq> {e. (e = Same low_var temp \\<or>\n (e = Eq control_var 0 \\<or>\n  e = Same temp buffer \\<and>\n  bexp_vars e \\<subseteq> {v. v = temp \\<or> v = control_var}) \\<and>\n low_var \\<notin> bexp_vars e) \\<and>\nbexp_vars e \\<subseteq> {v. v = temp \\<or> v = control_var}} \\<inter>\n                                  ?P''51", "apply simp"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> high_var \\<notin> \\<C>\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type buffer]\n                       (Load temp) ?t74\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> subtype ?t74\n                       (add_pred\n                         (restrict_preds_to_vars\n                           (assign_post {} temp (Load buffer))\n                           {v. stable ({control_var}, {temp}) v})\n                         ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (dma_type high_var)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P''51 =\n                      restrict_preds_to_vars\n                       (assign_post\n                         (add_pred\n                           (restrict_preds_to_vars\n                             (assign_post {} temp (Load buffer))\n                             {v. stable ({control_var}, {temp}) v})\n                           ({control_var}, {temp})\n                           (bexp_neg (Eq control_var 0)))\n                         high_var (Load temp))\n                       {v. stable ({control_var}, {temp}) v}\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'2\n                      \\<subseteq> {e. (e = Same low_var temp \\<or>\n (e = Eq control_var 0 \\<or>\n  e = Same temp buffer \\<and>\n  bexp_vars e \\<subseteq> {v. v = temp \\<or> v = control_var}) \\<and>\n low_var \\<notin> bexp_vars e) \\<and>\nbexp_vars e \\<subseteq> {v. v = temp \\<or> v = control_var}} \\<inter>\n                                  ?P''51", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type buffer]\n                       (Load temp) ?t74\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> subtype ?t74\n                       (add_pred\n                         (restrict_preds_to_vars\n                           (assign_post {} temp (Load buffer))\n                           {v. stable ({control_var}, {temp}) v})\n                         ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (dma_type high_var)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P''51 =\n                      restrict_preds_to_vars\n                       (assign_post\n                         (add_pred\n                           (restrict_preds_to_vars\n                             (assign_post {} temp (Load buffer))\n                             {v. stable ({control_var}, {temp}) v})\n                           ({control_var}, {temp})\n                           (bexp_neg (Eq control_var 0)))\n                         high_var (Load temp))\n                       {v. stable ({control_var}, {temp}) v}\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'2\n                      \\<subseteq> {e. (e = Same low_var temp \\<or>\n (e = Eq control_var 0 \\<or>\n  e = Same temp buffer \\<and>\n  bexp_vars e \\<subseteq> {v. v = temp \\<or> v = control_var}) \\<and>\n low_var \\<notin> bexp_vars e) \\<and>\nbexp_vars e \\<subseteq> {v. v = temp \\<or> v = control_var}} \\<inter>\n                                  ?P''51", "apply(rule type_aexpr_Load')"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> temp\n                      \\<in> dom [temp \\<mapsto> {}, temp \\<mapsto>\n                                 dma_type buffer]\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?t74 =\n                      the ([temp \\<mapsto> {}, temp \\<mapsto>\n                            dma_type buffer]\n                            temp)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> subtype ?t74\n                       (add_pred\n                         (restrict_preds_to_vars\n                           (assign_post {} temp (Load buffer))\n                           {v. stable ({control_var}, {temp}) v})\n                         ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (dma_type high_var)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P''51 =\n                      restrict_preds_to_vars\n                       (assign_post\n                         (add_pred\n                           (restrict_preds_to_vars\n                             (assign_post {} temp (Load buffer))\n                             {v. stable ({control_var}, {temp}) v})\n                           ({control_var}, {temp})\n                           (bexp_neg (Eq control_var 0)))\n                         high_var (Load temp))\n                       {v. stable ({control_var}, {temp}) v}\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'2\n                      \\<subseteq> {e. (e = Same low_var temp \\<or>\n (e = Eq control_var 0 \\<or>\n  e = Same temp buffer \\<and>\n  bexp_vars e \\<subseteq> {v. v = temp \\<or> v = control_var}) \\<and>\n low_var \\<notin> bexp_vars e) \\<and>\nbexp_vars e \\<subseteq> {v. v = temp \\<or> v = control_var}} \\<inter>\n                                  ?P''51", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?t74 =\n                      the ([temp \\<mapsto> {}, temp \\<mapsto>\n                            dma_type buffer]\n                            temp)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> subtype ?t74\n                       (add_pred\n                         (restrict_preds_to_vars\n                           (assign_post {} temp (Load buffer))\n                           {v. stable ({control_var}, {temp}) v})\n                         ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (dma_type high_var)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P''51 =\n                      restrict_preds_to_vars\n                       (assign_post\n                         (add_pred\n                           (restrict_preds_to_vars\n                             (assign_post {} temp (Load buffer))\n                             {v. stable ({control_var}, {temp}) v})\n                           ({control_var}, {temp})\n                           (bexp_neg (Eq control_var 0)))\n                         high_var (Load temp))\n                       {v. stable ({control_var}, {temp}) v}\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'2\n                      \\<subseteq> {e. (e = Same low_var temp \\<or>\n (e = Eq control_var 0 \\<or>\n  e = Same temp buffer \\<and>\n  bexp_vars e \\<subseteq> {v. v = temp \\<or> v = control_var}) \\<and>\n low_var \\<notin> bexp_vars e) \\<and>\nbexp_vars e \\<subseteq> {v. v = temp \\<or> v = control_var}} \\<inter>\n                                  ?P''51", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> subtype {Eq control_var 0}\n                       (add_pred\n                         (restrict_preds_to_vars\n                           (assign_post {} temp (Load buffer))\n                           {v. stable ({control_var}, {temp}) v})\n                         ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (dma_type high_var)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P''51 =\n                      restrict_preds_to_vars\n                       (assign_post\n                         (add_pred\n                           (restrict_preds_to_vars\n                             (assign_post {} temp (Load buffer))\n                             {v. stable ({control_var}, {temp}) v})\n                           ({control_var}, {temp})\n                           (bexp_neg (Eq control_var 0)))\n                         high_var (Load temp))\n                       {v. stable ({control_var}, {temp}) v}\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'2\n                      \\<subseteq> {e. (e = Same low_var temp \\<or>\n (e = Eq control_var 0 \\<or>\n  e = Same temp buffer \\<and>\n  bexp_vars e \\<subseteq> {v. v = temp \\<or> v = control_var}) \\<and>\n low_var \\<notin> bexp_vars e) \\<and>\nbexp_vars e \\<subseteq> {v. v = temp \\<or> v = control_var}} \\<inter>\n                                  ?P''51", "apply(simp add: subtype_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P''51 =\n                      restrict_preds_to_vars\n                       (assign_post\n                         (add_pred\n                           (restrict_preds_to_vars\n                             (assign_post {} temp (Load buffer))\n                             {v. stable ({control_var}, {temp}) v})\n                           ({control_var}, {temp})\n                           (bexp_neg (Eq control_var 0)))\n                         high_var (Load temp))\n                       {v. stable ({control_var}, {temp}) v}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'2\n                      \\<subseteq> {e. (e = Same low_var temp \\<or>\n (e = Eq control_var 0 \\<or>\n  e = Same temp buffer \\<and>\n  bexp_vars e \\<subseteq> {v. v = temp \\<or> v = control_var}) \\<and>\n low_var \\<notin> bexp_vars e) \\<and>\nbexp_vars e \\<subseteq> {v. v = temp \\<or> v = control_var}} \\<inter>\n                                  ?P''51", "apply(simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'2\n                      \\<subseteq> {e. (e = Same low_var temp \\<or>\n (e = Eq control_var 0 \\<or>\n  e = Same temp buffer \\<and>\n  bexp_vars e \\<subseteq> {v. v = temp \\<or> v = control_var}) \\<and>\n low_var \\<notin> bexp_vars e) \\<and>\nbexp_vars e \\<subseteq> {v. v = temp \\<or> v = control_var}} \\<inter>\n                                  {e. (e = Same high_var temp \\<or>\n (e = Neq control_var 0 \\<or>\n  e = Same temp buffer \\<and>\n  bexp_vars e \\<subseteq> {v. v = temp \\<or> v = control_var}) \\<and>\n high_var \\<notin> bexp_vars e) \\<and>\nbexp_vars e \\<subseteq> {v. v = temp \\<or> v = control_var}}", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'2\n                      \\<subseteq> {e. (e = Same low_var temp \\<or>\n (e = Eq control_var 0 \\<or>\n  e = Same temp buffer \\<and>\n  bexp_vars e \\<subseteq> {v. v = temp \\<or> v = control_var}) \\<and>\n low_var \\<notin> bexp_vars e) \\<and>\nbexp_vars e \\<subseteq> {v. v = temp \\<or> v = control_var}} \\<and>\n                      ?P'2\n                      \\<subseteq> {e. (e = Same high_var temp \\<or>\n (e = Neq control_var 0 \\<or>\n  e = Same temp buffer \\<and>\n  bexp_vars e \\<subseteq> {v. v = temp \\<or> v = control_var}) \\<and>\n high_var \\<notin> bexp_vars e) \\<and>\nbexp_vars e \\<subseteq> {v. v = temp \\<or> v = control_var}}", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma read_buffer_com_sifum_secure:\n  \"com_sifum_secure (read_buffer,(\\<lambda>_. {}))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. com_sifum_secure (read_buffer, \\<lambda>_. {})", "apply(insert read_buffer_typed[OF HOL.refl HOL.refl HOL.refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<Gamma>' \\<S>' P'.\n       has_type Map.empty ({}, {}) {} read_buffer \\<Gamma>' \\<S>'\n        P' \\<Longrightarrow>\n    com_sifum_secure (read_buffer, \\<lambda>_. {})", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma>' a b x.\n       has_type Map.empty ({}, {}) {} read_buffer \\<Gamma>' (a, b)\n        x \\<Longrightarrow>\n       com_sifum_secure (read_buffer, \\<lambda>_. {})", "apply(rule typed_secure)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<Gamma>' a b x.\n       has_type Map.empty ({}, {}) {} read_buffer \\<Gamma>' (a, b)\n        x \\<Longrightarrow>\n       has_type (\\<Gamma>_of_mds (\\<lambda>_. {}))\n        (\\<S>_of_mds (\\<lambda>_. {})) {} read_buffer\n        (?\\<Gamma>'8 \\<Gamma>' a b x) (?\\<S>'8 \\<Gamma>' a b x)\n        (?P'8 \\<Gamma>' a b x)\n 2. \\<And>\\<Gamma>' a b x.\n       has_type Map.empty ({}, {}) {} read_buffer \\<Gamma>' (a, b)\n        x \\<Longrightarrow>\n       mds_yields_stable_types (\\<lambda>_. {})", "apply(fastforce simp: \\<Gamma>_of_mds_def \\<S>_of_mds_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<Gamma>' a b x.\n       has_type Map.empty ({}, {}) {} read_buffer \\<Gamma>' (a, b)\n        x \\<Longrightarrow>\n       mds_yields_stable_types (\\<lambda>_. {})", "apply(auto simp: mds_yields_stable_types_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "definition\n  write_buffer :: \"(addr, aexp, bexp) Stmt\"\nwhere\n  \"write_buffer \\<equiv> \n     ModeDecl Skip (Acq control_var AsmNoWrite) ;; \n     ModeDecl Skip (Acq temp AsmNoReadOrWrite) ;;\n     If (Eq control_var 0) (Assign temp (Load low_var)) (Assign temp (Load high_var)) ;;\n     Assign buffer (Load temp)\""], ["", "lemma restrict_preds_to_vars_empty[simp]:\n  \"restrict_preds_to_vars {} V = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict_preds_to_vars {} V = {}", "apply(simp add: restrict_preds_to_vars_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma restrict_preds_to_vars_idemp[simp]:\n  \"restrict_preds_to_vars (restrict_preds_to_vars P V) V = \n   restrict_preds_to_vars P V\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict_preds_to_vars (restrict_preds_to_vars P V) V =\n    restrict_preds_to_vars P V", "apply(simp add: restrict_preds_to_vars_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma restrict_preds_to_vars_insert1[simp]:\n  \"(\\<forall>x\\<in>bexp_vars a. x \\<in> V) \\<Longrightarrow> restrict_preds_to_vars (insert a P) V = (insert a (restrict_preds_to_vars P V))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>bexp_vars a. x \\<in> V \\<Longrightarrow>\n    restrict_preds_to_vars (insert a P) V =\n    insert a (restrict_preds_to_vars P V)", "apply(simp add: restrict_preds_to_vars_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>bexp_vars a. x \\<in> V \\<Longrightarrow>\n    {e. (e = a \\<or> e \\<in> P) \\<and> bexp_vars e \\<subseteq> V} =\n    insert a {e \\<in> P. bexp_vars e \\<subseteq> V}", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma restrict_preds_to_vars_insert2[simp]:\n  \"(\\<exists>x\\<in>bexp_vars a. x \\<notin> V) \\<Longrightarrow> restrict_preds_to_vars (insert a P) V = ((restrict_preds_to_vars P V))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>bexp_vars a. x \\<notin> V \\<Longrightarrow>\n    restrict_preds_to_vars (insert a P) V = restrict_preds_to_vars P V", "apply(simp add: restrict_preds_to_vars_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>bexp_vars a. x \\<notin> V \\<Longrightarrow>\n    {e. (e = a \\<or> e \\<in> P) \\<and> bexp_vars e \\<subseteq> V} =\n    {e \\<in> P. bexp_vars e \\<subseteq> V}", "apply fastforce"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [simp]:\n  \"Eq a b \\<in> P \\<Longrightarrow> Neq a b \\<in> P \\<Longrightarrow> pred_entailment P Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>Eq a b \\<in> P; Neq a b \\<in> P\\<rbrakk>\n    \\<Longrightarrow> pred_entailment P Q", "apply(clarsimp simp: pred_entailment_def pred_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>mem x.\n       \\<lbrakk>Eq a b \\<in> P; Neq a b \\<in> P;\n        \\<forall>x\\<in>P. ev\\<^sub>B mem x; x \\<in> Q\\<rbrakk>\n       \\<Longrightarrow> ev\\<^sub>B mem x", "apply(frule bspec, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>mem x.\n       \\<lbrakk>Eq a b \\<in> P; Neq a b \\<in> P;\n        \\<forall>x\\<in>P. ev\\<^sub>B mem x; x \\<in> Q;\n        ev\\<^sub>B mem (Eq a b)\\<rbrakk>\n       \\<Longrightarrow> ev\\<^sub>B mem x", "apply(drule bspec, assumption, fastforce)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "declare restrict_preds_to_vars_def[simp del]"], ["", "lemma write_buffer_typed:\n  \"\\<Gamma> = (\\<lambda>_. None) \\<Longrightarrow> \\<S> = ({},{}) \\<Longrightarrow> P = {} \\<Longrightarrow> \n  \\<exists>\\<Gamma>' \\<S>' P'. has_type \\<Gamma> \\<S> P write_buffer \\<Gamma>' \\<S>' P'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<Gamma>' \\<S>' P'.\n                         has_type \\<Gamma> \\<S> P write_buffer \\<Gamma>'\n                          \\<S>' P'", "apply(intro exI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type \\<Gamma> \\<S> P write_buffer ?\\<Gamma>'\n                       ?\\<S>'1 ?P'2", "apply(simp add: write_buffer_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({}, {}) {}\n                       ((Skip@[control_var +=\\<^sub>m AsmNoWrite]) ;;\n                        (Skip@[temp +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        Stmt.If (Eq control_var 0)\n                         (temp \\<leftarrow> Load low_var)\n                         (temp \\<leftarrow> Load high_var) ;;\n                        (buffer \\<leftarrow> Load temp))\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule seq_type)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({}, {}) {}\n                       (Skip@[control_var +=\\<^sub>m AsmNoWrite])\n                       ?\\<Gamma>'3 ?\\<S>'3 ?P'3\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'3 ?\\<S>'3 ?P'3\n                       ((Skip@[temp +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        Stmt.If (Eq control_var 0)\n                         (temp \\<leftarrow> Load low_var)\n                         (temp \\<leftarrow> Load high_var) ;;\n                        (buffer \\<leftarrow> Load temp))\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule anno_type[OF HOL.refl HOL.refl HOL.refl])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno Map.empty ({}, {})\n                         (control_var +=\\<^sub>m AsmNoWrite))\n                       (add_anno_stable ({}, {})\n                         (control_var +=\\<^sub>m AsmNoWrite))\n                       (restrict_preds_to_vars {}\n                         {v. stable\n                              (add_anno_stable ({}, {})\n                                (control_var +=\\<^sub>m AsmNoWrite))\n                              v})\n                       Skip ?\\<Gamma>'3 ?\\<S>'3 ?P'3\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable ({}, {})\n                                   (control_var +=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty ({}, {})\n                              (control_var +=\\<^sub>m AsmNoWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty ({}, {})\n                       (control_var +=\\<^sub>m AsmNoWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({}, {}) {}\n                       (control_var +=\\<^sub>m AsmNoWrite)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'3 ?\\<S>'3 ?P'3\n                       ((Skip@[temp +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        Stmt.If (Eq control_var 0)\n                         (temp \\<leftarrow> Load low_var)\n                         (temp \\<leftarrow> Load high_var) ;;\n                        (buffer \\<leftarrow> Load temp))\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply clarsimp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({control_var}, {}) {} Skip\n                       ?\\<Gamma>'3 ?\\<S>'3 ?P'3\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable ({}, {})\n                                   (control_var +=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty ({}, {})\n                              (control_var +=\\<^sub>m AsmNoWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty ({}, {})\n                       (control_var +=\\<^sub>m AsmNoWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({}, {}) {}\n                       (control_var +=\\<^sub>m AsmNoWrite)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'3 ?\\<S>'3 ?P'3\n                       ((Skip@[temp +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        Stmt.If (Eq control_var 0)\n                         (temp \\<leftarrow> Load low_var)\n                         (temp \\<leftarrow> Load high_var) ;;\n                        (buffer \\<leftarrow> Load temp))\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule skip_type)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 2. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable ({}, {})\n                                   (control_var +=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty ({}, {})\n                              (control_var +=\\<^sub>m AsmNoWrite))\n                            x)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty ({}, {})\n                       (control_var +=\\<^sub>m AsmNoWrite)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({}, {}) {}\n                       (control_var +=\\<^sub>m AsmNoWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({control_var}, {}) {}\n                       ((Skip@[temp +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        Stmt.If (Eq control_var 0)\n                         (temp \\<leftarrow> Load low_var)\n                         (temp \\<leftarrow> Load high_var) ;;\n                        (buffer \\<leftarrow> Load temp))\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable ({}, {})\n                                   (control_var +=\\<^sub>m AsmNoWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty ({}, {})\n                              (control_var +=\\<^sub>m AsmNoWrite))\n                            x)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty ({}, {})\n                       (control_var +=\\<^sub>m AsmNoWrite)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({}, {}) {}\n                       (control_var +=\\<^sub>m AsmNoWrite)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({control_var}, {}) {}\n                       ((Skip@[temp +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        Stmt.If (Eq control_var 0)\n                         (temp \\<leftarrow> Load low_var)\n                         (temp \\<leftarrow> Load high_var) ;;\n                        (buffer \\<leftarrow> Load temp))\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty ({}, {})\n                       (control_var +=\\<^sub>m AsmNoWrite)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({}, {}) {}\n                       (control_var +=\\<^sub>m AsmNoWrite)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({control_var}, {}) {}\n                       ((Skip@[temp +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        Stmt.If (Eq control_var 0)\n                         (temp \\<leftarrow> Load low_var)\n                         (temp \\<leftarrow> Load high_var) ;;\n                        (buffer \\<leftarrow> Load temp))\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({}, {}) {}\n                       (control_var +=\\<^sub>m AsmNoWrite)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({control_var}, {}) {}\n                       ((Skip@[temp +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        Stmt.If (Eq control_var 0)\n                         (temp \\<leftarrow> Load low_var)\n                         (temp \\<leftarrow> Load high_var) ;;\n                        (buffer \\<leftarrow> Load temp))\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({control_var}, {}) {}\n                       ((Skip@[temp +=\\<^sub>m AsmNoReadOrWrite]) ;;\n                        Stmt.If (Eq control_var 0)\n                         (temp \\<leftarrow> Load low_var)\n                         (temp \\<leftarrow> Load high_var) ;;\n                        (buffer \\<leftarrow> Load temp))\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule seq_type)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type Map.empty ({control_var}, {}) {}\n                       (Skip@[temp +=\\<^sub>m AsmNoReadOrWrite])\n                       ?\\<Gamma>'18 ?\\<S>'18 ?P'18\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'18 ?\\<S>'18 ?P'18\n                       (Stmt.If (Eq control_var 0)\n                         (temp \\<leftarrow> Load low_var)\n                         (temp \\<leftarrow> Load high_var) ;;\n                        (buffer \\<leftarrow> Load temp))\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule anno_type[OF HOL.refl HOL.refl HOL.refl])"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type\n                       (add_anno Map.empty ({control_var}, {})\n                         (temp +=\\<^sub>m AsmNoReadOrWrite))\n                       (add_anno_stable ({control_var}, {})\n                         (temp +=\\<^sub>m AsmNoReadOrWrite))\n                       (restrict_preds_to_vars {}\n                         {v. stable\n                              (add_anno_stable ({control_var}, {})\n                                (temp +=\\<^sub>m AsmNoReadOrWrite))\n                              v})\n                       Skip ?\\<Gamma>'18 ?\\<S>'18 ?P'18\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable ({control_var}, {})\n                                   (temp +=\\<^sub>m AsmNoReadOrWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty ({control_var}, {})\n                              (temp +=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty ({control_var}, {})\n                       (temp +=\\<^sub>m AsmNoReadOrWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({control_var}, {}) {}\n                       (temp +=\\<^sub>m AsmNoReadOrWrite)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'18 ?\\<S>'18 ?P'18\n                       (Stmt.If (Eq control_var 0)\n                         (temp \\<leftarrow> Load low_var)\n                         (temp \\<leftarrow> Load high_var) ;;\n                        (buffer \\<leftarrow> Load temp))\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply clarsimp"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {}] ({control_var}, {temp})\n                       {} Skip ?\\<Gamma>'18 ?\\<S>'18 ?P'18\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 3. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable ({control_var}, {})\n                                   (temp +=\\<^sub>m AsmNoReadOrWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty ({control_var}, {})\n                              (temp +=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty ({control_var}, {})\n                       (temp +=\\<^sub>m AsmNoReadOrWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({control_var}, {}) {}\n                       (temp +=\\<^sub>m AsmNoReadOrWrite)\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'18 ?\\<S>'18 ?P'18\n                       (Stmt.If (Eq control_var 0)\n                         (temp \\<leftarrow> Load low_var)\n                         (temp \\<leftarrow> Load high_var) ;;\n                        (buffer \\<leftarrow> Load temp))\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule skip_type)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> Skip \\<noteq> Stop\n 2. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable ({control_var}, {})\n                                   (temp +=\\<^sub>m AsmNoReadOrWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty ({control_var}, {})\n                              (temp +=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty ({control_var}, {})\n                       (temp +=\\<^sub>m AsmNoReadOrWrite)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({control_var}, {}) {}\n                       (temp +=\\<^sub>m AsmNoReadOrWrite)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {}] ({control_var}, {temp})\n                       {} (Stmt.If (Eq control_var 0)\n                            (temp \\<leftarrow> Load low_var)\n                            (temp \\<leftarrow> Load high_var) ;;\n                           (buffer \\<leftarrow> Load temp))\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n       \\<Longrightarrow> subtype (to_total Map.empty x)\n                          (restrict_preds_to_vars {}\n                            {v. stable\n                                 (add_anno_stable ({control_var}, {})\n                                   (temp +=\\<^sub>m AsmNoReadOrWrite))\n                                 v})\n                          (to_total\n                            (add_anno Map.empty ({control_var}, {})\n                              (temp +=\\<^sub>m AsmNoReadOrWrite))\n                            x)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty ({control_var}, {})\n                       (temp +=\\<^sub>m AsmNoReadOrWrite)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({control_var}, {}) {}\n                       (temp +=\\<^sub>m AsmNoReadOrWrite)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {}] ({control_var}, {temp})\n                       {} (Stmt.If (Eq control_var 0)\n                            (temp \\<leftarrow> Load low_var)\n                            (temp \\<leftarrow> Load high_var) ;;\n                           (buffer \\<leftarrow> Load temp))\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_stable Map.empty ({control_var}, {})\n                       (temp +=\\<^sub>m AsmNoReadOrWrite)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({control_var}, {}) {}\n                       (temp +=\\<^sub>m AsmNoReadOrWrite)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {}] ({control_var}, {temp})\n                       {} (Stmt.If (Eq control_var 0)\n                            (temp \\<leftarrow> Load low_var)\n                            (temp \\<leftarrow> Load high_var) ;;\n                           (buffer \\<leftarrow> Load temp))\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> anno_type_sec Map.empty ({control_var}, {}) {}\n                       (temp +=\\<^sub>m AsmNoReadOrWrite)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {}] ({control_var}, {temp})\n                       {} (Stmt.If (Eq control_var 0)\n                            (temp \\<leftarrow> Load low_var)\n                            (temp \\<leftarrow> Load high_var) ;;\n                           (buffer \\<leftarrow> Load temp))\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {}] ({control_var}, {temp})\n                       {} (Stmt.If (Eq control_var 0)\n                            (temp \\<leftarrow> Load low_var)\n                            (temp \\<leftarrow> Load high_var) ;;\n                           (buffer \\<leftarrow> Load temp))\n                       ?\\<Gamma>' ?\\<S>'1 ?P'2", "apply(rule seq_type)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {}] ({control_var}, {temp})\n                       {} (Stmt.If (Eq control_var 0)\n                            (temp \\<leftarrow> Load low_var)\n                            (temp \\<leftarrow> Load high_var))\n                       ?\\<Gamma>'37 ?\\<S>'37 ?P'37\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'37 ?\\<S>'37 ?P'37\n                       (buffer \\<leftarrow> Load temp) ?\\<Gamma>' ?\\<S>'1\n                       ?P'2", "apply(rule if_type[where \\<Gamma>'''=\"[temp \\<mapsto> dma_type buffer]\" and P'''=\"{}\"])"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_bexpr [temp \\<mapsto> {}] (Eq control_var 0) ?t40\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment {} ?t40\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {}] ({control_var}, {temp})\n                       (add_pred {} ({control_var}, {temp})\n                         (Eq control_var 0))\n                       (temp \\<leftarrow> Load low_var) ?\\<Gamma>'40\n                       ?\\<S>'37 ?P'40\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {}] ({control_var}, {temp})\n                       (add_pred {} ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (temp \\<leftarrow> Load high_var) ?\\<Gamma>''40\n                       ?\\<S>'37 ?P''40\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> context_equiv ?\\<Gamma>'40 ?P'40\n                       [temp \\<mapsto> dma_type buffer]\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> context_equiv ?\\<Gamma>''40 ?P''40\n                       [temp \\<mapsto> dma_type buffer]\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P'40 {}\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''40 {}\n 9. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds ?\\<Gamma>'40 ?\\<S>'37\n                          ?P'40 \\<longrightarrow>\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> dma_type buffer] ?\\<S>'37 {}\n 10. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n     \\<Longrightarrow> \\<forall>mds.\n                          tyenv_wellformed mds ?\\<Gamma>''40 ?\\<S>'37\n                           ?P''40 \\<longrightarrow>\n                          tyenv_wellformed mds\n                           [temp \\<mapsto> dma_type buffer] ?\\<S>'37 {}\nA total of 11 subgoals...", "apply(rule type_bexprI)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?t40 =\n                      \\<Union>\n                       (to_total [temp \\<mapsto> {}] `\n                        bexp_vars (Eq control_var 0))\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment {} ?t40\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {}] ({control_var}, {temp})\n                       (add_pred {} ({control_var}, {temp})\n                         (Eq control_var 0))\n                       (temp \\<leftarrow> Load low_var) ?\\<Gamma>'40\n                       ?\\<S>'37 ?P'40\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {}] ({control_var}, {temp})\n                       (add_pred {} ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (temp \\<leftarrow> Load high_var) ?\\<Gamma>''40\n                       ?\\<S>'37 ?P''40\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> context_equiv ?\\<Gamma>'40 ?P'40\n                       [temp \\<mapsto> dma_type buffer]\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> context_equiv ?\\<Gamma>''40 ?P''40\n                       [temp \\<mapsto> dma_type buffer]\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P'40 {}\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''40 {}\n 9. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds ?\\<Gamma>'40 ?\\<S>'37\n                          ?P'40 \\<longrightarrow>\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> dma_type buffer] ?\\<S>'37 {}\n 10. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n     \\<Longrightarrow> \\<forall>mds.\n                          tyenv_wellformed mds ?\\<Gamma>''40 ?\\<S>'37\n                           ?P''40 \\<longrightarrow>\n                          tyenv_wellformed mds\n                           [temp \\<mapsto> dma_type buffer] ?\\<S>'37 {}\nA total of 11 subgoals...", "apply simp"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment {} {}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {}] ({control_var}, {temp})\n                       (add_pred {} ({control_var}, {temp})\n                         (Eq control_var 0))\n                       (temp \\<leftarrow> Load low_var) ?\\<Gamma>'40\n                       ?\\<S>'37 ?P'40\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {}] ({control_var}, {temp})\n                       (add_pred {} ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (temp \\<leftarrow> Load high_var) ?\\<Gamma>''40\n                       ?\\<S>'37 ?P''40\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> context_equiv ?\\<Gamma>'40 ?P'40\n                       [temp \\<mapsto> dma_type buffer]\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> context_equiv ?\\<Gamma>''40 ?P''40\n                       [temp \\<mapsto> dma_type buffer]\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P'40 {}\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''40 {}\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds ?\\<Gamma>'40 ?\\<S>'37\n                          ?P'40 \\<longrightarrow>\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> dma_type buffer] ?\\<S>'37 {}\n 9. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds ?\\<Gamma>''40 ?\\<S>'37\n                          ?P''40 \\<longrightarrow>\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> dma_type buffer] ?\\<S>'37 {}\n 10. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n     \\<Longrightarrow> has_type [temp \\<mapsto> dma_type buffer] ?\\<S>'37 {}\n                        (buffer \\<leftarrow> Load temp) ?\\<Gamma>' ?\\<S>'1\n                        ?P'2", "apply simp"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {}] ({control_var}, {temp})\n                       (add_pred {} ({control_var}, {temp})\n                         (Eq control_var 0))\n                       (temp \\<leftarrow> Load low_var) ?\\<Gamma>'40\n                       ?\\<S>'37 ?P'40\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {}] ({control_var}, {temp})\n                       (add_pred {} ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (temp \\<leftarrow> Load high_var) ?\\<Gamma>''40\n                       ?\\<S>'37 ?P''40\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> context_equiv ?\\<Gamma>'40 ?P'40\n                       [temp \\<mapsto> dma_type buffer]\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> context_equiv ?\\<Gamma>''40 ?P''40\n                       [temp \\<mapsto> dma_type buffer]\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P'40 {}\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''40 {}\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds ?\\<Gamma>'40 ?\\<S>'37\n                          ?P'40 \\<longrightarrow>\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> dma_type buffer] ?\\<S>'37 {}\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds ?\\<Gamma>''40 ?\\<S>'37\n                          ?P''40 \\<longrightarrow>\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> dma_type buffer] ?\\<S>'37 {}\n 9. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> dma_type buffer] ?\\<S>'37 {}\n                       (buffer \\<leftarrow> Load temp) ?\\<Gamma>' ?\\<S>'1\n                       ?P'2", "apply(rule assign\\<^sub>2[OF _ _ _ HOL.refl])"], ["proof (prove)\ngoal (12 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> temp \\<in> dom [temp \\<mapsto> {}]\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr [temp \\<mapsto> {}] (Load low_var) ?t54\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable ({control_var}, {temp}) ?t54\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> temp\n                      \\<notin> snd ({control_var}, {temp}) \\<longrightarrow>\n                      subtype ?t54\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (Eq control_var 0))\n                           temp (Load low_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       (dma_type temp)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {}] ({control_var}, {temp})\n                       (add_pred {} ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (temp \\<leftarrow> Load high_var) ?\\<Gamma>''40\n                       ({control_var}, {temp}) ?P''40\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> context_equiv [temp \\<mapsto> {}, temp \\<mapsto> ?t54]\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (Eq control_var 0))\n                           temp (Load low_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       [temp \\<mapsto> dma_type buffer]\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> context_equiv ?\\<Gamma>''40 ?P''40\n                       [temp \\<mapsto> dma_type buffer]\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (Eq control_var 0))\n                           temp (Load low_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       {}\n 9. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''40 {}\n 10. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n     \\<Longrightarrow> \\<forall>mds.\n                          tyenv_wellformed mds\n                           [temp \\<mapsto> {}, temp \\<mapsto> ?t54]\n                           ({control_var}, {temp})\n                           (restrict_preds_to_vars\n                             (assign_post\n                               (add_pred {} ({control_var}, {temp})\n                                 (Eq control_var 0))\n                               temp (Load low_var))\n                             {v. stable ({control_var}, {temp})\n                                  v}) \\<longrightarrow>\n                          tyenv_wellformed mds\n                           [temp \\<mapsto> dma_type buffer]\n                           ({control_var}, {temp}) {}\nA total of 12 subgoals...", "apply simp"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr [temp \\<mapsto> {}] (Load low_var) ?t54\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable ({control_var}, {temp}) ?t54\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> temp\n                      \\<notin> snd ({control_var}, {temp}) \\<longrightarrow>\n                      subtype ?t54\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (Eq control_var 0))\n                           temp (Load low_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       (dma_type temp)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {}] ({control_var}, {temp})\n                       (add_pred {} ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (temp \\<leftarrow> Load high_var) ?\\<Gamma>''40\n                       ({control_var}, {temp}) ?P''40\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> context_equiv [temp \\<mapsto> {}, temp \\<mapsto> ?t54]\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (Eq control_var 0))\n                           temp (Load low_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       [temp \\<mapsto> dma_type buffer]\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> context_equiv ?\\<Gamma>''40 ?P''40\n                       [temp \\<mapsto> dma_type buffer]\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (Eq control_var 0))\n                           temp (Load low_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       {}\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''40 {}\n 9. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> {}, temp \\<mapsto> ?t54]\n                          ({control_var}, {temp})\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred {} ({control_var}, {temp})\n                                (Eq control_var 0))\n                              temp (Load low_var))\n                            {v. stable ({control_var}, {temp})\n                                 v}) \\<longrightarrow>\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> dma_type buffer]\n                          ({control_var}, {temp}) {}\n 10. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n     \\<Longrightarrow> \\<forall>mds.\n                          tyenv_wellformed mds ?\\<Gamma>''40\n                           ({control_var}, {temp}) ?P''40 \\<longrightarrow>\n                          tyenv_wellformed mds\n                           [temp \\<mapsto> dma_type buffer]\n                           ({control_var}, {temp}) {}\nA total of 11 subgoals...", "apply(rule type_aexpr_Load)"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> low_var \\<notin> dom [temp \\<mapsto> {}]\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable ({control_var}, {temp}) (dma_type low_var)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> temp\n                      \\<notin> snd ({control_var}, {temp}) \\<longrightarrow>\n                      subtype (dma_type low_var)\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (Eq control_var 0))\n                           temp (Load low_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       (dma_type temp)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {}] ({control_var}, {temp})\n                       (add_pred {} ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (temp \\<leftarrow> Load high_var) ?\\<Gamma>''40\n                       ({control_var}, {temp}) ?P''40\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> context_equiv\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type low_var]\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (Eq control_var 0))\n                           temp (Load low_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       [temp \\<mapsto> dma_type buffer]\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> context_equiv ?\\<Gamma>''40 ?P''40\n                       [temp \\<mapsto> dma_type buffer]\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (Eq control_var 0))\n                           temp (Load low_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       {}\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''40 {}\n 9. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> {}, temp \\<mapsto>\n                           dma_type low_var]\n                          ({control_var}, {temp})\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred {} ({control_var}, {temp})\n                                (Eq control_var 0))\n                              temp (Load low_var))\n                            {v. stable ({control_var}, {temp})\n                                 v}) \\<longrightarrow>\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> dma_type buffer]\n                          ({control_var}, {temp}) {}\n 10. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n     \\<Longrightarrow> \\<forall>mds.\n                          tyenv_wellformed mds ?\\<Gamma>''40\n                           ({control_var}, {temp}) ?P''40 \\<longrightarrow>\n                          tyenv_wellformed mds\n                           [temp \\<mapsto> dma_type buffer]\n                           ({control_var}, {temp}) {}\nA total of 11 subgoals...", "apply simp"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable ({control_var}, {temp}) (dma_type low_var)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> temp\n                      \\<notin> snd ({control_var}, {temp}) \\<longrightarrow>\n                      subtype (dma_type low_var)\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (Eq control_var 0))\n                           temp (Load low_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       (dma_type temp)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {}] ({control_var}, {temp})\n                       (add_pred {} ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (temp \\<leftarrow> Load high_var) ?\\<Gamma>''40\n                       ({control_var}, {temp}) ?P''40\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> context_equiv\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type low_var]\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (Eq control_var 0))\n                           temp (Load low_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       [temp \\<mapsto> dma_type buffer]\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> context_equiv ?\\<Gamma>''40 ?P''40\n                       [temp \\<mapsto> dma_type buffer]\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (Eq control_var 0))\n                           temp (Load low_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       {}\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''40 {}\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> {}, temp \\<mapsto>\n                           dma_type low_var]\n                          ({control_var}, {temp})\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred {} ({control_var}, {temp})\n                                (Eq control_var 0))\n                              temp (Load low_var))\n                            {v. stable ({control_var}, {temp})\n                                 v}) \\<longrightarrow>\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> dma_type buffer]\n                          ({control_var}, {temp}) {}\n 9. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds ?\\<Gamma>''40\n                          ({control_var}, {temp}) ?P''40 \\<longrightarrow>\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> dma_type buffer]\n                          ({control_var}, {temp}) {}\n 10. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n     \\<Longrightarrow> has_type [temp \\<mapsto> dma_type buffer]\n                        ({control_var}, {temp}) {}\n                        (buffer \\<leftarrow> Load temp) ?\\<Gamma>' ?\\<S>'1\n                        ?P'2", "apply simp"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> temp\n                      \\<notin> snd ({control_var}, {temp}) \\<longrightarrow>\n                      subtype (dma_type low_var)\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (Eq control_var 0))\n                           temp (Load low_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       (dma_type temp)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {}] ({control_var}, {temp})\n                       (add_pred {} ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (temp \\<leftarrow> Load high_var) ?\\<Gamma>''40\n                       ({control_var}, {temp}) ?P''40\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> context_equiv\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type low_var]\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (Eq control_var 0))\n                           temp (Load low_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       [temp \\<mapsto> dma_type buffer]\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> context_equiv ?\\<Gamma>''40 ?P''40\n                       [temp \\<mapsto> dma_type buffer]\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (Eq control_var 0))\n                           temp (Load low_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       {}\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''40 {}\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> {}, temp \\<mapsto>\n                           dma_type low_var]\n                          ({control_var}, {temp})\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred {} ({control_var}, {temp})\n                                (Eq control_var 0))\n                              temp (Load low_var))\n                            {v. stable ({control_var}, {temp})\n                                 v}) \\<longrightarrow>\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> dma_type buffer]\n                          ({control_var}, {temp}) {}\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds ?\\<Gamma>''40\n                          ({control_var}, {temp}) ?P''40 \\<longrightarrow>\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> dma_type buffer]\n                          ({control_var}, {temp}) {}\n 9. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp}) {}\n                       (buffer \\<leftarrow> Load temp) ?\\<Gamma>' ?\\<S>'1\n                       ?P'2", "apply simp"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {}] ({control_var}, {temp})\n                       (add_pred {} ({control_var}, {temp})\n                         (bexp_neg (Eq control_var 0)))\n                       (temp \\<leftarrow> Load high_var) ?\\<Gamma>''40\n                       ({control_var}, {temp}) ?P''40\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> context_equiv\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type low_var]\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (Eq control_var 0))\n                           temp (Load low_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       [temp \\<mapsto> dma_type buffer]\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> context_equiv ?\\<Gamma>''40 ?P''40\n                       [temp \\<mapsto> dma_type buffer]\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (Eq control_var 0))\n                           temp (Load low_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       {}\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment ?P''40 {}\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> {}, temp \\<mapsto>\n                           dma_type low_var]\n                          ({control_var}, {temp})\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred {} ({control_var}, {temp})\n                                (Eq control_var 0))\n                              temp (Load low_var))\n                            {v. stable ({control_var}, {temp})\n                                 v}) \\<longrightarrow>\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> dma_type buffer]\n                          ({control_var}, {temp}) {}\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds ?\\<Gamma>''40\n                          ({control_var}, {temp}) ?P''40 \\<longrightarrow>\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> dma_type buffer]\n                          ({control_var}, {temp}) {}\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp}) {}\n                       (buffer \\<leftarrow> Load temp) ?\\<Gamma>' ?\\<S>'1\n                       ?P'2", "apply(rule assign\\<^sub>2[OF _ _ _ HOL.refl])"], ["proof (prove)\ngoal (11 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> temp \\<in> dom [temp \\<mapsto> {}]\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr [temp \\<mapsto> {}] (Load high_var) ?t65\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable ({control_var}, {temp}) ?t65\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> temp\n                      \\<notin> snd ({control_var}, {temp}) \\<longrightarrow>\n                      subtype ?t65\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (bexp_neg (Eq control_var 0)))\n                           temp (Load high_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       (dma_type temp)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> context_equiv\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type low_var]\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (Eq control_var 0))\n                           temp (Load low_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       [temp \\<mapsto> dma_type buffer]\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> context_equiv [temp \\<mapsto> {}, temp \\<mapsto> ?t65]\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (bexp_neg (Eq control_var 0)))\n                           temp (Load high_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       [temp \\<mapsto> dma_type buffer]\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (Eq control_var 0))\n                           temp (Load low_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       {}\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (bexp_neg (Eq control_var 0)))\n                           temp (Load high_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       {}\n 9. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> {}, temp \\<mapsto>\n                           dma_type low_var]\n                          ({control_var}, {temp})\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred {} ({control_var}, {temp})\n                                (Eq control_var 0))\n                              temp (Load low_var))\n                            {v. stable ({control_var}, {temp})\n                                 v}) \\<longrightarrow>\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> dma_type buffer]\n                          ({control_var}, {temp}) {}\n 10. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n     \\<Longrightarrow> \\<forall>mds.\n                          tyenv_wellformed mds\n                           [temp \\<mapsto> {}, temp \\<mapsto> ?t65]\n                           ({control_var}, {temp})\n                           (restrict_preds_to_vars\n                             (assign_post\n                               (add_pred {} ({control_var}, {temp})\n                                 (bexp_neg (Eq control_var 0)))\n                               temp (Load high_var))\n                             {v. stable ({control_var}, {temp})\n                                  v}) \\<longrightarrow>\n                          tyenv_wellformed mds\n                           [temp \\<mapsto> dma_type buffer]\n                           ({control_var}, {temp}) {}\nA total of 11 subgoals...", "apply simp"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr [temp \\<mapsto> {}] (Load high_var) ?t65\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable ({control_var}, {temp}) ?t65\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> temp\n                      \\<notin> snd ({control_var}, {temp}) \\<longrightarrow>\n                      subtype ?t65\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (bexp_neg (Eq control_var 0)))\n                           temp (Load high_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       (dma_type temp)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> context_equiv\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type low_var]\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (Eq control_var 0))\n                           temp (Load low_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       [temp \\<mapsto> dma_type buffer]\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> context_equiv [temp \\<mapsto> {}, temp \\<mapsto> ?t65]\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (bexp_neg (Eq control_var 0)))\n                           temp (Load high_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       [temp \\<mapsto> dma_type buffer]\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (Eq control_var 0))\n                           temp (Load low_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       {}\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (bexp_neg (Eq control_var 0)))\n                           temp (Load high_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       {}\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> {}, temp \\<mapsto>\n                           dma_type low_var]\n                          ({control_var}, {temp})\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred {} ({control_var}, {temp})\n                                (Eq control_var 0))\n                              temp (Load low_var))\n                            {v. stable ({control_var}, {temp})\n                                 v}) \\<longrightarrow>\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> dma_type buffer]\n                          ({control_var}, {temp}) {}\n 9. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> {}, temp \\<mapsto> ?t65]\n                          ({control_var}, {temp})\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred {} ({control_var}, {temp})\n                                (bexp_neg (Eq control_var 0)))\n                              temp (Load high_var))\n                            {v. stable ({control_var}, {temp})\n                                 v}) \\<longrightarrow>\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> dma_type buffer]\n                          ({control_var}, {temp}) {}\n 10. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n     \\<Longrightarrow> has_type [temp \\<mapsto> dma_type buffer]\n                        ({control_var}, {temp}) {}\n                        (buffer \\<leftarrow> Load temp) ?\\<Gamma>' ?\\<S>'1\n                        ?P'2", "apply(rule type_aexpr_Load)"], ["proof (prove)\ngoal (10 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> high_var \\<notin> dom [temp \\<mapsto> {}]\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable ({control_var}, {temp})\n                       (dma_type high_var)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> temp\n                      \\<notin> snd ({control_var}, {temp}) \\<longrightarrow>\n                      subtype (dma_type high_var)\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (bexp_neg (Eq control_var 0)))\n                           temp (Load high_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       (dma_type temp)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> context_equiv\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type low_var]\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (Eq control_var 0))\n                           temp (Load low_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       [temp \\<mapsto> dma_type buffer]\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> context_equiv\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type high_var]\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (bexp_neg (Eq control_var 0)))\n                           temp (Load high_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       [temp \\<mapsto> dma_type buffer]\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (Eq control_var 0))\n                           temp (Load low_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       {}\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (bexp_neg (Eq control_var 0)))\n                           temp (Load high_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       {}\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> {}, temp \\<mapsto>\n                           dma_type low_var]\n                          ({control_var}, {temp})\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred {} ({control_var}, {temp})\n                                (Eq control_var 0))\n                              temp (Load low_var))\n                            {v. stable ({control_var}, {temp})\n                                 v}) \\<longrightarrow>\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> dma_type buffer]\n                          ({control_var}, {temp}) {}\n 9. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> {}, temp \\<mapsto>\n                           dma_type high_var]\n                          ({control_var}, {temp})\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred {} ({control_var}, {temp})\n                                (bexp_neg (Eq control_var 0)))\n                              temp (Load high_var))\n                            {v. stable ({control_var}, {temp})\n                                 v}) \\<longrightarrow>\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> dma_type buffer]\n                          ({control_var}, {temp}) {}\n 10. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n     \\<Longrightarrow> has_type [temp \\<mapsto> dma_type buffer]\n                        ({control_var}, {temp}) {}\n                        (buffer \\<leftarrow> Load temp) ?\\<Gamma>' ?\\<S>'1\n                        ?P'2", "apply simp"], ["proof (prove)\ngoal (9 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_stable ({control_var}, {temp})\n                       (dma_type high_var)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> temp\n                      \\<notin> snd ({control_var}, {temp}) \\<longrightarrow>\n                      subtype (dma_type high_var)\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (bexp_neg (Eq control_var 0)))\n                           temp (Load high_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       (dma_type temp)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> context_equiv\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type low_var]\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (Eq control_var 0))\n                           temp (Load low_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       [temp \\<mapsto> dma_type buffer]\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> context_equiv\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type high_var]\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (bexp_neg (Eq control_var 0)))\n                           temp (Load high_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       [temp \\<mapsto> dma_type buffer]\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (Eq control_var 0))\n                           temp (Load low_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       {}\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (bexp_neg (Eq control_var 0)))\n                           temp (Load high_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       {}\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> {}, temp \\<mapsto>\n                           dma_type low_var]\n                          ({control_var}, {temp})\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred {} ({control_var}, {temp})\n                                (Eq control_var 0))\n                              temp (Load low_var))\n                            {v. stable ({control_var}, {temp})\n                                 v}) \\<longrightarrow>\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> dma_type buffer]\n                          ({control_var}, {temp}) {}\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> {}, temp \\<mapsto>\n                           dma_type high_var]\n                          ({control_var}, {temp})\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred {} ({control_var}, {temp})\n                                (bexp_neg (Eq control_var 0)))\n                              temp (Load high_var))\n                            {v. stable ({control_var}, {temp})\n                                 v}) \\<longrightarrow>\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> dma_type buffer]\n                          ({control_var}, {temp}) {}\n 9. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp}) {}\n                       (buffer \\<leftarrow> Load temp) ?\\<Gamma>' ?\\<S>'1\n                       ?P'2", "apply(simp)"], ["proof (prove)\ngoal (8 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> temp\n                      \\<notin> snd ({control_var}, {temp}) \\<longrightarrow>\n                      subtype (dma_type high_var)\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (bexp_neg (Eq control_var 0)))\n                           temp (Load high_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       (dma_type temp)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> context_equiv\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type low_var]\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (Eq control_var 0))\n                           temp (Load low_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       [temp \\<mapsto> dma_type buffer]\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> context_equiv\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type high_var]\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (bexp_neg (Eq control_var 0)))\n                           temp (Load high_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       [temp \\<mapsto> dma_type buffer]\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (Eq control_var 0))\n                           temp (Load low_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       {}\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (bexp_neg (Eq control_var 0)))\n                           temp (Load high_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       {}\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> {}, temp \\<mapsto>\n                           dma_type low_var]\n                          ({control_var}, {temp})\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred {} ({control_var}, {temp})\n                                (Eq control_var 0))\n                              temp (Load low_var))\n                            {v. stable ({control_var}, {temp})\n                                 v}) \\<longrightarrow>\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> dma_type buffer]\n                          ({control_var}, {temp}) {}\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> {}, temp \\<mapsto>\n                           dma_type high_var]\n                          ({control_var}, {temp})\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred {} ({control_var}, {temp})\n                                (bexp_neg (Eq control_var 0)))\n                              temp (Load high_var))\n                            {v. stable ({control_var}, {temp})\n                                 v}) \\<longrightarrow>\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> dma_type buffer]\n                          ({control_var}, {temp}) {}\n 8. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp}) {}\n                       (buffer \\<leftarrow> Load temp) ?\\<Gamma>' ?\\<S>'1\n                       ?P'2", "apply simp"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> context_equiv\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type low_var]\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (Eq control_var 0))\n                           temp (Load low_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       [temp \\<mapsto> dma_type buffer]\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> context_equiv\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type high_var]\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (bexp_neg (Eq control_var 0)))\n                           temp (Load high_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       [temp \\<mapsto> dma_type buffer]\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (Eq control_var 0))\n                           temp (Load low_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       {}\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (bexp_neg (Eq control_var 0)))\n                           temp (Load high_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       {}\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> {}, temp \\<mapsto>\n                           dma_type low_var]\n                          ({control_var}, {temp})\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred {} ({control_var}, {temp})\n                                (Eq control_var 0))\n                              temp (Load low_var))\n                            {v. stable ({control_var}, {temp})\n                                 v}) \\<longrightarrow>\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> dma_type buffer]\n                          ({control_var}, {temp}) {}\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> {}, temp \\<mapsto>\n                           dma_type high_var]\n                          ({control_var}, {temp})\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred {} ({control_var}, {temp})\n                                (bexp_neg (Eq control_var 0)))\n                              temp (Load high_var))\n                            {v. stable ({control_var}, {temp})\n                                 v}) \\<longrightarrow>\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> dma_type buffer]\n                          ({control_var}, {temp}) {}\n 7. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp}) {}\n                       (buffer \\<leftarrow> Load temp) ?\\<Gamma>' ?\\<S>'1\n                       ?P'2", "apply(clarsimp simp: context_equiv_def  type_equiv_def subtype_def)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> context_equiv\n                       [temp \\<mapsto> {}, temp \\<mapsto> dma_type high_var]\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (bexp_neg (Eq control_var 0)))\n                           temp (Load high_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       [temp \\<mapsto> dma_type buffer]\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (Eq control_var 0))\n                           temp (Load low_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       {}\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (bexp_neg (Eq control_var 0)))\n                           temp (Load high_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       {}\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> {}, temp \\<mapsto>\n                           dma_type low_var]\n                          ({control_var}, {temp})\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred {} ({control_var}, {temp})\n                                (Eq control_var 0))\n                              temp (Load low_var))\n                            {v. stable ({control_var}, {temp})\n                                 v}) \\<longrightarrow>\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> dma_type buffer]\n                          ({control_var}, {temp}) {}\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> {}, temp \\<mapsto>\n                           dma_type high_var]\n                          ({control_var}, {temp})\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred {} ({control_var}, {temp})\n                                (bexp_neg (Eq control_var 0)))\n                              temp (Load high_var))\n                            {v. stable ({control_var}, {temp})\n                                 v}) \\<longrightarrow>\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> dma_type buffer]\n                          ({control_var}, {temp}) {}\n 6. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp}) {}\n                       (buffer \\<leftarrow> Load temp) ?\\<Gamma>' ?\\<S>'1\n                       ?P'2", "apply(clarsimp simp: context_equiv_def type_equiv_def subtype_def)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (Eq control_var 0))\n                           temp (Load low_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       {}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (bexp_neg (Eq control_var 0)))\n                           temp (Load high_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       {}\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> {}, temp \\<mapsto>\n                           dma_type low_var]\n                          ({control_var}, {temp})\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred {} ({control_var}, {temp})\n                                (Eq control_var 0))\n                              temp (Load low_var))\n                            {v. stable ({control_var}, {temp})\n                                 v}) \\<longrightarrow>\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> dma_type buffer]\n                          ({control_var}, {temp}) {}\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> {}, temp \\<mapsto>\n                           dma_type high_var]\n                          ({control_var}, {temp})\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred {} ({control_var}, {temp})\n                                (bexp_neg (Eq control_var 0)))\n                              temp (Load high_var))\n                            {v. stable ({control_var}, {temp})\n                                 v}) \\<longrightarrow>\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> dma_type buffer]\n                          ({control_var}, {temp}) {}\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp}) {}\n                       (buffer \\<leftarrow> Load temp) ?\\<Gamma>' ?\\<S>'1\n                       ?P'2", "apply(blast intro: subset_entailment)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> pred_entailment\n                       (restrict_preds_to_vars\n                         (assign_post\n                           (add_pred {} ({control_var}, {temp})\n                             (bexp_neg (Eq control_var 0)))\n                           temp (Load high_var))\n                         {v. stable ({control_var}, {temp}) v})\n                       {}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> {}, temp \\<mapsto>\n                           dma_type low_var]\n                          ({control_var}, {temp})\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred {} ({control_var}, {temp})\n                                (Eq control_var 0))\n                              temp (Load low_var))\n                            {v. stable ({control_var}, {temp})\n                                 v}) \\<longrightarrow>\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> dma_type buffer]\n                          ({control_var}, {temp}) {}\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> {}, temp \\<mapsto>\n                           dma_type high_var]\n                          ({control_var}, {temp})\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred {} ({control_var}, {temp})\n                                (bexp_neg (Eq control_var 0)))\n                              temp (Load high_var))\n                            {v. stable ({control_var}, {temp})\n                                 v}) \\<longrightarrow>\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> dma_type buffer]\n                          ({control_var}, {temp}) {}\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp}) {}\n                       (buffer \\<leftarrow> Load temp) ?\\<Gamma>' ?\\<S>'1\n                       ?P'2", "apply(blast intro: subset_entailment)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> {}, temp \\<mapsto>\n                           dma_type low_var]\n                          ({control_var}, {temp})\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred {} ({control_var}, {temp})\n                                (Eq control_var 0))\n                              temp (Load low_var))\n                            {v. stable ({control_var}, {temp})\n                                 v}) \\<longrightarrow>\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> dma_type buffer]\n                          ({control_var}, {temp}) {}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> {}, temp \\<mapsto>\n                           dma_type high_var]\n                          ({control_var}, {temp})\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred {} ({control_var}, {temp})\n                                (bexp_neg (Eq control_var 0)))\n                              temp (Load high_var))\n                            {v. stable ({control_var}, {temp})\n                                 v}) \\<longrightarrow>\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> dma_type buffer]\n                          ({control_var}, {temp}) {}\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp}) {}\n                       (buffer \\<leftarrow> Load temp) ?\\<Gamma>' ?\\<S>'1\n                       ?P'2", "(* need to be careful how we unfold here as otherwise the tactics get overwhelmed *)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> {}, temp \\<mapsto>\n                           dma_type low_var]\n                          ({control_var}, {temp})\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred {} ({control_var}, {temp})\n                                (Eq control_var 0))\n                              temp (Load low_var))\n                            {v. stable ({control_var}, {temp})\n                                 v}) \\<longrightarrow>\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> dma_type buffer]\n                          ({control_var}, {temp}) {}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> {}, temp \\<mapsto>\n                           dma_type high_var]\n                          ({control_var}, {temp})\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred {} ({control_var}, {temp})\n                                (bexp_neg (Eq control_var 0)))\n                              temp (Load high_var))\n                            {v. stable ({control_var}, {temp})\n                                 v}) \\<longrightarrow>\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> dma_type buffer]\n                          ({control_var}, {temp}) {}\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp}) {}\n                       (buffer \\<leftarrow> Load temp) ?\\<Gamma>' ?\\<S>'1\n                       ?P'2", "apply clarsimp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>mds.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {};\n        tyenv_wellformed mds [temp \\<mapsto> {}] ({control_var}, {temp})\n         {Eq control_var 0}\\<rbrakk>\n       \\<Longrightarrow> tyenv_wellformed mds\n                          [temp \\<mapsto> {Eq control_var 0}]\n                          ({control_var}, {temp}) {}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> {}, temp \\<mapsto>\n                           dma_type high_var]\n                          ({control_var}, {temp})\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred {} ({control_var}, {temp})\n                                (bexp_neg (Eq control_var 0)))\n                              temp (Load high_var))\n                            {v. stable ({control_var}, {temp})\n                                 v}) \\<longrightarrow>\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> dma_type buffer]\n                          ({control_var}, {temp}) {}\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp}) {}\n                       (buffer \\<leftarrow> Load temp) ?\\<Gamma>' ?\\<S>'1\n                       ?P'2", "apply(subst tyenv_wellformed_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>mds.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {};\n        tyenv_wellformed mds [temp \\<mapsto> {}] ({control_var}, {temp})\n         {Eq control_var 0}\\<rbrakk>\n       \\<Longrightarrow> mds_consistent mds\n                          [temp \\<mapsto> {Eq control_var 0}]\n                          ({control_var}, {temp}) {} \\<and>\n                         types_wellformed\n                          [temp \\<mapsto> {Eq control_var 0}] \\<and>\n                         types_stable [temp \\<mapsto> {Eq control_var 0}]\n                          ({control_var}, {temp})\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> {}, temp \\<mapsto>\n                           dma_type high_var]\n                          ({control_var}, {temp})\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred {} ({control_var}, {temp})\n                                (bexp_neg (Eq control_var 0)))\n                              temp (Load high_var))\n                            {v. stable ({control_var}, {temp})\n                                 v}) \\<longrightarrow>\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> dma_type buffer]\n                          ({control_var}, {temp}) {}\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp}) {}\n                       (buffer \\<leftarrow> Load temp) ?\\<Gamma>' ?\\<S>'1\n                       ?P'2", "apply(clarsimp simp: mds_consistent_def types_wellformed_def type_wellformed_def types_stable_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>mds.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {};\n        tyenv_wellformed mds [temp \\<mapsto> {}] ({control_var}, {temp})\n         {Eq control_var 0}\\<rbrakk>\n       \\<Longrightarrow> {control_var} = mds AsmNoWrite \\<and>\n                         {temp} = mds AsmNoReadOrWrite \\<and>\n                         {temp} =\n                         {x. x \\<noteq> control_var \\<and>\n                             (x = temp \\<or> x = control_var)}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> {}, temp \\<mapsto>\n                           dma_type high_var]\n                          ({control_var}, {temp})\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred {} ({control_var}, {temp})\n                                (bexp_neg (Eq control_var 0)))\n                              temp (Load high_var))\n                            {v. stable ({control_var}, {temp})\n                                 v}) \\<longrightarrow>\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> dma_type buffer]\n                          ({control_var}, {temp}) {}\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp}) {}\n                       (buffer \\<leftarrow> Load temp) ?\\<Gamma>' ?\\<S>'1\n                       ?P'2", "apply(simp add: tyenv_wellformed_def mds_consistent_def)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>mds.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {};\n        {control_var} = mds AsmNoWrite \\<and>\n        {temp} = mds AsmNoReadOrWrite \\<and>\n        {temp} =\n        {x. x \\<noteq> control_var \\<and>\n            (x = temp \\<or> x = control_var)} \\<and>\n        types_wellformed [temp \\<mapsto> {}] \\<and>\n        types_stable [temp \\<mapsto> {}] ({control_var}, {temp})\\<rbrakk>\n       \\<Longrightarrow> mds AsmNoReadOrWrite =\n                         {x. x \\<noteq> control_var \\<and>\n                             (x = temp \\<or> x = control_var)}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> {}, temp \\<mapsto>\n                           dma_type high_var]\n                          ({control_var}, {temp})\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred {} ({control_var}, {temp})\n                                (bexp_neg (Eq control_var 0)))\n                              temp (Load high_var))\n                            {v. stable ({control_var}, {temp})\n                                 v}) \\<longrightarrow>\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> dma_type buffer]\n                          ({control_var}, {temp}) {}\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp}) {}\n                       (buffer \\<leftarrow> Load temp) ?\\<Gamma>' ?\\<S>'1\n                       ?P'2", "apply blast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<forall>mds.\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> {}, temp \\<mapsto>\n                           dma_type high_var]\n                          ({control_var}, {temp})\n                          (restrict_preds_to_vars\n                            (assign_post\n                              (add_pred {} ({control_var}, {temp})\n                                (bexp_neg (Eq control_var 0)))\n                              temp (Load high_var))\n                            {v. stable ({control_var}, {temp})\n                                 v}) \\<longrightarrow>\n                         tyenv_wellformed mds\n                          [temp \\<mapsto> dma_type buffer]\n                          ({control_var}, {temp}) {}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp}) {}\n                       (buffer \\<leftarrow> Load temp) ?\\<Gamma>' ?\\<S>'1\n                       ?P'2", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>mds.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {};\n        tyenv_wellformed mds [temp \\<mapsto> {FF}] ({control_var}, {temp})\n         {Neq control_var 0}\\<rbrakk>\n       \\<Longrightarrow> tyenv_wellformed mds\n                          [temp \\<mapsto> {Eq control_var 0}]\n                          ({control_var}, {temp}) {}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp}) {}\n                       (buffer \\<leftarrow> Load temp) ?\\<Gamma>' ?\\<S>'1\n                       ?P'2", "apply(subst tyenv_wellformed_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>mds.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {};\n        tyenv_wellformed mds [temp \\<mapsto> {FF}] ({control_var}, {temp})\n         {Neq control_var 0}\\<rbrakk>\n       \\<Longrightarrow> mds_consistent mds\n                          [temp \\<mapsto> {Eq control_var 0}]\n                          ({control_var}, {temp}) {} \\<and>\n                         types_wellformed\n                          [temp \\<mapsto> {Eq control_var 0}] \\<and>\n                         types_stable [temp \\<mapsto> {Eq control_var 0}]\n                          ({control_var}, {temp})\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp}) {}\n                       (buffer \\<leftarrow> Load temp) ?\\<Gamma>' ?\\<S>'1\n                       ?P'2", "apply(clarsimp simp: mds_consistent_def types_wellformed_def type_wellformed_def types_stable_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>mds.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {};\n        tyenv_wellformed mds [temp \\<mapsto> {FF}] ({control_var}, {temp})\n         {Neq control_var 0}\\<rbrakk>\n       \\<Longrightarrow> {control_var} = mds AsmNoWrite \\<and>\n                         {temp} = mds AsmNoReadOrWrite \\<and>\n                         {temp} =\n                         {x. x \\<noteq> control_var \\<and>\n                             (x = temp \\<or> x = control_var)}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp}) {}\n                       (buffer \\<leftarrow> Load temp) ?\\<Gamma>' ?\\<S>'1\n                       ?P'2", "apply(simp add: tyenv_wellformed_def mds_consistent_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>mds.\n       \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {};\n        {control_var} = mds AsmNoWrite \\<and>\n        {temp} = mds AsmNoReadOrWrite \\<and>\n        {temp} =\n        {x. x \\<noteq> control_var \\<and>\n            (x = temp \\<or> x = control_var)} \\<and>\n        types_wellformed [temp \\<mapsto> {FF}] \\<and>\n        types_stable [temp \\<mapsto> {FF}] ({control_var}, {temp})\\<rbrakk>\n       \\<Longrightarrow> mds AsmNoReadOrWrite =\n                         {x. x \\<noteq> control_var \\<and>\n                             (x = temp \\<or> x = control_var)}\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp}) {}\n                       (buffer \\<leftarrow> Load temp) ?\\<Gamma>' ?\\<S>'1\n                       ?P'2", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp}) {}\n                       (buffer \\<leftarrow> Load temp) ?\\<Gamma>' ?\\<S>'1\n                       ?P'2", "apply(rule assign\\<^sub>1)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> buffer \\<notin> dom [temp \\<mapsto> dma_type buffer]\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> buffer \\<notin> \\<C>\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr [temp \\<mapsto> dma_type buffer]\n                       (Load temp) ?t502\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> subtype ?t502 {} (dma_type buffer)\n 5. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'2 =\n                      restrict_preds_to_vars\n                       (assign_post {} buffer (Load temp))\n                       {v. stable ({control_var}, {temp}) v}", "apply simp+"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> type_aexpr [temp \\<mapsto> {Eq control_var 0}]\n                       (Load temp) ?t502\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> subtype ?t502 {} (dma_type buffer)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'2 =\n                      restrict_preds_to_vars\n                       (assign_post {} buffer (Load temp))\n                       {v. stable ({control_var}, {temp}) v}", "apply(rule type_aexpr_Load')"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> temp \\<in> dom [temp \\<mapsto> {Eq control_var 0}]\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?t502 = the ([temp \\<mapsto> {Eq control_var 0}] temp)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> subtype ?t502 {} (dma_type buffer)\n 4. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'2 =\n                      restrict_preds_to_vars\n                       (assign_post {} buffer (Load temp))\n                       {v. stable ({control_var}, {temp}) v}", "apply simp"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?t502 = the ([temp \\<mapsto> {Eq control_var 0}] temp)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> subtype ?t502 {} (dma_type buffer)\n 3. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'2 =\n                      restrict_preds_to_vars\n                       (assign_post {} buffer (Load temp))\n                       {v. stable ({control_var}, {temp}) v}", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> subtype {Eq control_var 0} {} (dma_type buffer)\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'2 =\n                      restrict_preds_to_vars\n                       (assign_post {} buffer (Load temp))\n                       {v. stable ({control_var}, {temp}) v}", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> ?P'2 =\n                      restrict_preds_to_vars\n                       (assign_post {} buffer (Load temp))\n                       {v. stable ({control_var}, {temp}) v}", "apply blast"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma read_buffer_typed':\n  \"\\<Gamma> = (\\<lambda>_. None) \\<Longrightarrow> \\<S> = ({},{}) \\<Longrightarrow> P = {} \\<Longrightarrow> \n  \\<exists>\\<Gamma>' \\<S>' P'. has_type \\<Gamma> \\<S> P read_buffer \\<Gamma>' \\<S>' P'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<Gamma>' \\<S>' P'.\n                         has_type \\<Gamma> \\<S> P read_buffer \\<Gamma>'\n                          \\<S>' P'", "by (has_type_tac prog: read_buffer_def \n       aexpr:type_aexpr_Load' type_aexpr_Load \n       bexpr:type_bexprI)"], ["", "lemma write_buffer_typed':\n  \"\\<Gamma> = (\\<lambda>_. None) \\<Longrightarrow> \\<S> = ({},{}) \\<Longrightarrow> P = {} \\<Longrightarrow> \n  \\<exists>\\<Gamma>' \\<S>' P'. has_type \\<Gamma> \\<S> P write_buffer \\<Gamma>' \\<S>' P'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> \\<exists>\\<Gamma>' \\<S>' P'.\n                         has_type \\<Gamma> \\<S> P write_buffer \\<Gamma>'\n                          \\<S>' P'", "apply (has_type_tac prog: write_buffer_def aexpr:type_aexpr_Load' type_aexpr_Load bexpr:type_bexprI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> {}] ({control_var}, {temp})\n                       {} (Stmt.If (Eq control_var 0)\n                            (temp \\<leftarrow> Load low_var)\n                            (temp \\<leftarrow> Load high_var))\n                       ?\\<Gamma>'43 ?\\<S>'43 ?P'43\n 2. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type ?\\<Gamma>'43 ?\\<S>'43 ?P'43\n                       (buffer \\<leftarrow> Load temp) ?\\<Gamma>' ?\\<S>'1\n                       ?P'2", "apply (if_type_tac bexpr: type_bexprI\n          custom_if: if_type[where \\<Gamma>'''=\"[temp \\<mapsto> dma_type buffer]\" and P'''=\"{}\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<Gamma> = Map.empty; \\<S> = ({}, {}); P = {}\\<rbrakk>\n    \\<Longrightarrow> has_type [temp \\<mapsto> dma_type buffer]\n                       ({control_var}, {temp}) {}\n                       (buffer \\<leftarrow> Load temp) ?\\<Gamma>' ?\\<S>'1\n                       ?P'2", "apply (has_type_tac' aexpr:type_aexpr_Load' type_aexpr_Load bexpr:type_bexprI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"], ["", "end"]]}