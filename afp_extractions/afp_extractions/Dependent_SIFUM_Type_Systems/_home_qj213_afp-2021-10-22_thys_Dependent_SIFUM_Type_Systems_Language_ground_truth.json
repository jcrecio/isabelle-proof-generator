{"file_name": "/home/qj213/afp-2021-10-22/thys/Dependent_SIFUM_Type_Systems/Language.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Dependent_SIFUM_Type_Systems", "problem_names": ["lemma cond:\n  \"((If b t e, mem), (if eval\\<^sub>B mem b then t else e, mem)) \\<in> eval\\<^sub>w_simple\"", "lemma rtrancl_mono_proof[mono]:\n  \"(\\<And>a b. x a b \\<longrightarrow> y a b) \\<Longrightarrow> rtranclp x a b \\<longrightarrow> rtranclp y a b\"", "lemma trancl_mono_proof[mono]:\n  \"(\\<And>a b. x a b \\<longrightarrow> y a b) \\<Longrightarrow> tranclp x a b \\<longrightarrow> tranclp y a b\"", "lemma cxt_inv:\n  \"\\<lbrakk> cxt_to_stmt E c = c' ; \\<And> p q. c' \\<noteq> Seq p q \\<rbrakk> \\<Longrightarrow> E = [] \\<and> c' = c\"", "lemma cxt_inv_assign:\n  \"\\<lbrakk> cxt_to_stmt E c = x \\<leftarrow> e \\<rbrakk> \\<Longrightarrow> c = x \\<leftarrow> e \\<and> E = []\"", "lemma cxt_inv_skip:\n  \"\\<lbrakk> cxt_to_stmt E c = Skip \\<rbrakk> \\<Longrightarrow> c = Skip \\<and> E = []\"", "lemma cxt_inv_stop:\n  \"cxt_to_stmt E c = Stop \\<Longrightarrow> c = Stop \\<and> E = []\"", "lemma cxt_inv_if:\n  \"cxt_to_stmt E c = If e p q \\<Longrightarrow> c = If e p q \\<and> E = []\"", "lemma ctx_inv_anno:\n  \"cxt_to_stmt E c = c'@[mu] \\<Longrightarrow> c = c'@[mu] \\<and> E = []\"", "lemma cxt_inv_await:\n  \"cxt_to_stmt E c = Await e p \\<Longrightarrow> c = Await e p  \\<and> E = []\"", "lemma cxt_inv_while:\n  \"cxt_to_stmt E c = While e p \\<Longrightarrow> c = While e p \\<and> E = []\"", "lemma skip_elim [elim]:\n  \"\\<langle>Skip, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow> c' = Stop \\<and> mds = mds' \\<and> mem = mem'\"", "lemma assign_elim [elim]:\n  \"\\<langle>x \\<leftarrow> e, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow> c' = Stop \\<and> mds = mds' \\<and> mem' = mem (x := eval\\<^sub>A mem e)\"", "lemma if_elim [elim]:\n  \"\\<And> P.\n    \\<lbrakk> \\<langle>If b p q, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c', mds', mem'\\<rangle>\\<^sub>w ;\n     \\<lbrakk> c' = p; mem' = mem ; mds' = mds ; eval\\<^sub>B mem b \\<rbrakk> \\<Longrightarrow> P ;\n     \\<lbrakk> c' = q; mem' = mem ; mds' = mds ; \\<not> eval\\<^sub>B mem b \\<rbrakk> \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\"", "lemma while_elim [elim]:\n  \"\\<lbrakk> \\<langle>While e c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<rbrakk> \\<Longrightarrow> c' = If e (c ;; While e c) Stop \\<and> mds' = mds \\<and> mem' = mem\"", "lemma upd_elim [elim]:\n  \"\\<langle>c@[upd], mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow> \\<langle>c, update_modes upd mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\"", "lemma cxt_seq_elim [elim]:\n  \"c\\<^sub>1 ;; c\\<^sub>2 = cxt_to_stmt E c \\<Longrightarrow> (E = [] \\<and> c = c\\<^sub>1 ;; c\\<^sub>2) \\<or> (\\<exists> c' cs. E = c' # cs \\<and> c = c\\<^sub>1 \\<and> c\\<^sub>2 = cxt_to_stmt cs c')\"", "lemma stop_no_eval: \"\\<not> (\\<langle>Stop, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c', mds', mem'\\<rangle>\\<^sub>w)\"", "lemma seq_stop_elim [elim]:\n  \"\\<langle>Stop ;; c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow> c' = c \\<and> mds' = mds \\<and> mem' = mem\"", "lemma cxt_stmt_seq:\n  \"c ;; cxt_to_stmt E c' = cxt_to_stmt (c' # E) c\"", "lemma seq_elim [elim]:\n  \"\\<lbrakk> \\<langle>c\\<^sub>1 ;; c\\<^sub>2, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c', mds', mem'\\<rangle>\\<^sub>w ; c\\<^sub>1 \\<noteq> Stop \\<rbrakk> \\<Longrightarrow>\n  (\\<exists> c\\<^sub>1'. \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and> c' = c\\<^sub>1' ;; c\\<^sub>2)\"", "lemma stop_cxt: \"Stop = cxt_to_stmt E c \\<Longrightarrow> c = Stop\"", "lemmas decl_eval\\<^sub>w = decl[OF unannotated, OF skip, where E=\"[]\", simplified, where E1=\"[]\", simplified]", "lemmas seq_stop_eval\\<^sub>w = unannotated[OF seq_stop, where E=\"[]\", simplified]", "lemmas assign_eval\\<^sub>w = unannotated[OF assign, where E=\"[]\", simplified]", "lemmas if_eval\\<^sub>w = unannotated[OF cond, where E=\"[]\", simplified]", "lemmas if_false_eval\\<^sub>w = unannotated[OF if_false, where E=\"[]\", simplified]", "lemmas skip_eval\\<^sub>w = unannotated[OF skip, where E=\"[]\", simplified]", "lemmas while_eval\\<^sub>w = unannotated[OF while, where E=\"[]\", simplified]", "lemma decl_eval\\<^sub>w':\n  assumes mem_unchanged: \"mem' = mem\"\n  assumes upd: \"mds' = update_modes upd mds\"\n  shows \"(\\<langle>Skip@[upd], mds, mem\\<rangle>\\<^sub>w, \\<langle>Stop, mds', mem'\\<rangle>\\<^sub>w) \\<in> eval\\<^sub>w\"", "lemma assign_eval\\<^sub>w':\n  \"\\<lbrakk>mds = mds'; mem' = mem(x := eval\\<^sub>A mem e)\\<rbrakk> \\<Longrightarrow>\n  \\<langle>x \\<leftarrow> e, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>Stop, mds', mem'\\<rangle>\\<^sub>w\"", "lemma seq_decl_elim:\n  \"\\<langle>(Skip@[upd]) ;; c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n   c' = Stop ;; c \\<and> mem' = mem \\<and> mds' = update_modes upd mds\"", "lemma seq_assign_elim:\n  \"\\<langle>(x \\<leftarrow> e) ;; c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n   c' = Stop ;; c \\<and> mds' = mds \\<and> mem' = mem(x := eval\\<^sub>A mem e)\"", "lemma no_await_trans: \n  \"\\<lbrakk> no_await c; \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<rbrakk> \\<Longrightarrow> no_await c'\"", "lemma no_await_no_await[elim]: \"\\<lbrakk> no_await c \\<rbrakk> \\<Longrightarrow> c \\<noteq> Await b c'\"", "lemma no_await_trancl_impl: \n  \"\\<lbrakk>ctx \\<leadsto>\\<^sub>w\\<^sup>+ ctx'\\<rbrakk> \\<Longrightarrow> no_await (fst (fst ctx)) \\<longrightarrow> no_await (fst (fst ctx'))\"", "lemma no_await_trancl: \n  \"\\<lbrakk>ctx \\<leadsto>\\<^sub>w\\<^sup>+ ctx'; no_await (fst (fst ctx))\\<rbrakk> \\<Longrightarrow> no_await (fst (fst ctx'))\"", "lemma await_elim: \n  \"\\<lbrakk>\\<langle>Await b c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c\\<^sub>2, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk> \\<Longrightarrow> \n    eval\\<^sub>B mem b \\<and> no_await c\\<^sub>1 \\<and> is_final c\\<^sub>2  \\<and>\n    \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>c\\<^sub>2, mds', mem'\\<rangle>\\<^sub>w\""], "translations": [["", "lemma cond:\n  \"((If b t e, mem), (if eval\\<^sub>B mem b then t else e, mem)) \\<in> eval\\<^sub>w_simple\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Stmt.If b t e, mem) \\<leadsto>\\<^sub>s\n    (if eval\\<^sub>B mem b then t else e, mem)", "apply(case_tac \"eval\\<^sub>B mem b\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. eval\\<^sub>B mem b \\<Longrightarrow>\n    (Stmt.If b t e, mem) \\<leadsto>\\<^sub>s\n    (if eval\\<^sub>B mem b then t else e, mem)\n 2. \\<not> eval\\<^sub>B mem b \\<Longrightarrow>\n    (Stmt.If b t e, mem) \\<leadsto>\\<^sub>s\n    (if eval\\<^sub>B mem b then t else e, mem)", "apply(auto intro: eval\\<^sub>w_simple.intros)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "primrec cxt_to_stmt :: \"('Var, 'AExp, 'BExp) EvalCxt \\<Rightarrow> ('Var, 'AExp, 'BExp) Stmt\n  \\<Rightarrow> ('Var, 'AExp, 'BExp) Stmt\"\n  where\n  \"cxt_to_stmt [] c = c\" |\n  \"cxt_to_stmt (c # cs) c' = Seq c' (cxt_to_stmt cs c)\""], ["", "(* Design decision: Add \"normal\" rule for sequential statements here as well.\n  Otherwise, one would have to take care of adding some sort of normalization\n  later, so that one doesn't get stuck on expressions of the form (c ;; c') ;; c''.\n*)\n(* Normalization turned out to be more difficult, as it made the proofs of several\n  helpful lemmas below quite difficult. *)"], ["", "lemma rtrancl_mono_proof[mono]:\n  \"(\\<And>a b. x a b \\<longrightarrow> y a b) \\<Longrightarrow> rtranclp x a b \\<longrightarrow> rtranclp y a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b. x a b \\<longrightarrow> y a b) \\<Longrightarrow>\n    x\\<^sup>*\\<^sup>* a b \\<longrightarrow> y\\<^sup>*\\<^sup>* a b", "apply (rule impI, rotate_tac, induct rule: rtranclp.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a.\n       (\\<And>a b. x a b \\<longrightarrow> y a b) \\<Longrightarrow>\n       y\\<^sup>*\\<^sup>* a a\n 2. \\<And>a b c.\n       \\<lbrakk>x\\<^sup>*\\<^sup>* a b;\n        (\\<And>a b. x a b \\<longrightarrow> y a b) \\<Longrightarrow>\n        y\\<^sup>*\\<^sup>* a b;\n        x b c; \\<And>a b. x a b \\<longrightarrow> y a b\\<rbrakk>\n       \\<Longrightarrow> y\\<^sup>*\\<^sup>* a c", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>x\\<^sup>*\\<^sup>* a b; y\\<^sup>*\\<^sup>* a b; x b c;\n        \\<And>a b. x a b \\<longrightarrow> y a b\\<rbrakk>\n       \\<Longrightarrow> y\\<^sup>*\\<^sup>* a c", "apply (metis rtranclp.intros)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma trancl_mono_proof[mono]:\n  \"(\\<And>a b. x a b \\<longrightarrow> y a b) \\<Longrightarrow> tranclp x a b \\<longrightarrow> tranclp y a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a b. x a b \\<longrightarrow> y a b) \\<Longrightarrow>\n    x\\<^sup>+\\<^sup>+ a b \\<longrightarrow> y\\<^sup>+\\<^sup>+ a b", "apply (rule impI, rotate_tac, induct rule: tranclp.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>x a b; \\<And>a b. x a b \\<longrightarrow> y a b\\<rbrakk>\n       \\<Longrightarrow> y\\<^sup>+\\<^sup>+ a b\n 2. \\<And>a b c.\n       \\<lbrakk>x\\<^sup>+\\<^sup>+ a b;\n        (\\<And>a b. x a b \\<longrightarrow> y a b) \\<Longrightarrow>\n        y\\<^sup>+\\<^sup>+ a b;\n        x b c; \\<And>a b. x a b \\<longrightarrow> y a b\\<rbrakk>\n       \\<Longrightarrow> y\\<^sup>+\\<^sup>+ a c", "apply simp_all"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>x a b; \\<And>a b. x a b \\<longrightarrow> y a b\\<rbrakk>\n       \\<Longrightarrow> y\\<^sup>+\\<^sup>+ a b\n 2. \\<And>a b c.\n       \\<lbrakk>x\\<^sup>+\\<^sup>+ a b; y\\<^sup>+\\<^sup>+ a b; x b c;\n        \\<And>a b. x a b \\<longrightarrow> y a b\\<rbrakk>\n       \\<Longrightarrow> y\\<^sup>+\\<^sup>+ a c", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>x\\<^sup>+\\<^sup>+ a b; y\\<^sup>+\\<^sup>+ a b; x b c;\n        \\<And>a b. x a b \\<longrightarrow> y a b\\<rbrakk>\n       \\<Longrightarrow> y\\<^sup>+\\<^sup>+ a c", "by fastforce"], ["", "inductive no_await :: \"('Var, 'AExp, 'BExp) Stmt \\<Rightarrow> bool\" where\n  \"no_await (x \\<leftarrow> e)\" |\n  \"no_await c1 \\<Longrightarrow> no_await c2 \\<Longrightarrow> no_await (c1 ;; c2)\" |\n  \"no_await c1 \\<Longrightarrow> no_await c2 \\<Longrightarrow> no_await (If b c1 c2)\" |\n  \"no_await c \\<Longrightarrow> no_await (While b c)\" |\n  \"no_await Skip\" |\n  \"no_await Stop\" |\n  \"no_await c \\<Longrightarrow> no_await (c@[m])\""], ["", "inductive is_final :: \"('Var, 'AExp, 'BExp) Stmt \\<Rightarrow> bool\" where\n  \"is_final Stop\" |\n  \"is_final c \\<Longrightarrow> is_final (c@[m])\""], ["", "inductive_set eval\\<^sub>w :: \"(('Var, 'AExp, 'BExp) Stmt, 'Var, 'Val) LocalConf rel\"\nand eval\\<^sub>w_abv :: \"(('Var, 'AExp, 'BExp) Stmt, 'Var, 'Val) LocalConf \\<Rightarrow>\n                  (('Var, 'AExp, 'BExp) Stmt, 'Var, 'Val) LocalConf \\<Rightarrow> bool\"\n  (infixr \"\\<leadsto>\\<^sub>w\" 60)\nwhere\n  \"c \\<leadsto>\\<^sub>w c' \\<equiv> (c, c') \\<in> eval\\<^sub>w\" |\n  unannotated: \"\\<lbrakk> (c, mem) \\<leadsto>\\<^sub>s (c', mem') \\<rbrakk>\n    \\<Longrightarrow> (\\<langle>cxt_to_stmt E c, mds, mem\\<rangle>\\<^sub>w, \\<langle>cxt_to_stmt E c', mds, mem'\\<rangle>\\<^sub>w) \\<in> eval\\<^sub>w\" |\n  seq: \"\\<lbrakk> \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<rbrakk> \\<Longrightarrow> (\\<langle>(c\\<^sub>1 ;; c\\<^sub>2), mds, mem\\<rangle>\\<^sub>w, \\<langle>(c\\<^sub>1' ;; c\\<^sub>2), mds', mem'\\<rangle>\\<^sub>w) \\<in> eval\\<^sub>w\" |\n  decl: \"\\<lbrakk> \\<langle>c, update_modes mu mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<rbrakk> \\<Longrightarrow>\n         (\\<langle>cxt_to_stmt E (ModeDecl c mu), mds, mem\\<rangle>\\<^sub>w, \\<langle>cxt_to_stmt E c', mds', mem'\\<rangle>\\<^sub>w) \\<in> eval\\<^sub>w\" |\n(* This is added instead of defining eval\\<^sub>p -- see next comment*)\n  await: \"\\<lbrakk>eval\\<^sub>B mem b; no_await c\\<^sub>1;\n         (\\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w, \\<langle>c\\<^sub>2, mds', mem'\\<rangle>\\<^sub>w) \\<in> eval\\<^sub>w\\<^sup>+;\n         is_final c\\<^sub>2\\<rbrakk> \\<Longrightarrow>\n         (\\<langle>Await b c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w, \\<langle>c\\<^sub>2, mds', mem'\\<rangle>\\<^sub>w) \\<in> eval\\<^sub>w\""], ["", "abbreviation eval\\<^sub>w_plus :: \"\n  (('Var, 'AExp, 'BExp) Stmt, 'Var, 'Val) LocalConf \\<Rightarrow>\n                  (('Var, 'AExp, 'BExp) Stmt, 'Var, 'Val) LocalConf \\<Rightarrow> bool\" (\"_ \\<leadsto>\\<^sub>w\\<^sup>+ _\") where\n\"ctx \\<leadsto>\\<^sub>w\\<^sup>+ ctx' \\<equiv> (ctx, ctx') \\<in> eval\\<^sub>w\\<^sup>+\""], ["", "subsection \\<open>Semantic Properties\\<close>"], ["", "text \\<open>The following lemmas simplify working with evaluation contexts\n  in the soundness proofs for the type system(s).\\<close>"], ["", "inductive_cases eval_elim: \"(((c, mds), mem), ((c', mds'), mem')) \\<in> eval\\<^sub>w\""], ["", "inductive_cases stop_no_eval' [elim]: \"((Stop, mem), (c', mem')) \\<in> eval\\<^sub>w_simple\""], ["", "inductive_cases assign_elim' [elim]: \"((x \\<leftarrow> e, mem), (c', mem')) \\<in> eval\\<^sub>w_simple\""], ["", "inductive_cases skip_elim' [elim]: \"(Skip, mem) \\<leadsto>\\<^sub>s (c', mem')\""], ["", "lemma cxt_inv:\n  \"\\<lbrakk> cxt_to_stmt E c = c' ; \\<And> p q. c' \\<noteq> Seq p q \\<rbrakk> \\<Longrightarrow> E = [] \\<and> c' = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>cxt_to_stmt E c = c'; \\<And>p q. c' \\<noteq> p ;; q\\<rbrakk>\n    \\<Longrightarrow> E = [] \\<and> c' = c", "by (metis cxt_to_stmt.simps(1) cxt_to_stmt.simps(2) neq_Nil_conv)"], ["", "lemma cxt_inv_assign:\n  \"\\<lbrakk> cxt_to_stmt E c = x \\<leftarrow> e \\<rbrakk> \\<Longrightarrow> c = x \\<leftarrow> e \\<and> E = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cxt_to_stmt E c = x \\<leftarrow> e \\<Longrightarrow>\n    c = x \\<leftarrow> e \\<and> E = []", "by (metis Stmt.simps(11) cxt_inv)"], ["", "lemma cxt_inv_skip:\n  \"\\<lbrakk> cxt_to_stmt E c = Skip \\<rbrakk> \\<Longrightarrow> c = Skip \\<and> E = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cxt_to_stmt E c = Skip \\<Longrightarrow> c = Skip \\<and> E = []", "by (metis Stmt.simps(23) cxt_inv)"], ["", "lemma cxt_inv_stop:\n  \"cxt_to_stmt E c = Stop \\<Longrightarrow> c = Stop \\<and> E = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cxt_to_stmt E c = Stop \\<Longrightarrow> c = Stop \\<and> E = []", "by (metis Stmt.simps(49) cxt_inv)"], ["", "lemma cxt_inv_if:\n  \"cxt_to_stmt E c = If e p q \\<Longrightarrow> c = If e p q \\<and> E = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cxt_to_stmt E c = Stmt.If e p q \\<Longrightarrow>\n    c = Stmt.If e p q \\<and> E = []", "by (metis Stmt.simps(43) cxt_inv)"], ["", "lemma ctx_inv_anno:\n  \"cxt_to_stmt E c = c'@[mu] \\<Longrightarrow> c = c'@[mu] \\<and> E = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cxt_to_stmt E c = c'@[mu] \\<Longrightarrow> c = c'@[mu] \\<and> E = []", "using cxt_inv"], ["proof (prove)\nusing this:\n  \\<lbrakk>cxt_to_stmt ?E ?c = ?c'; \\<And>p q. ?c' \\<noteq> p ;; q\\<rbrakk>\n  \\<Longrightarrow> ?E = [] \\<and> ?c' = ?c\n\ngoal (1 subgoal):\n 1. cxt_to_stmt E c = c'@[mu] \\<Longrightarrow> c = c'@[mu] \\<and> E = []", "by blast"], ["", "lemma cxt_inv_await:\n  \"cxt_to_stmt E c = Await e p \\<Longrightarrow> c = Await e p  \\<and> E = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cxt_to_stmt E c = Await e p \\<Longrightarrow>\n    c = Await e p \\<and> E = []", "by (metis Stmt.simps(47) cxt_inv)"], ["", "lemma cxt_inv_while:\n  \"cxt_to_stmt E c = While e p \\<Longrightarrow> c = While e p \\<and> E = []\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cxt_to_stmt E c = While e p \\<Longrightarrow>\n    c = While e p \\<and> E = []", "by (metis Stmt.simps(45) cxt_inv)"], ["", "lemma skip_elim [elim]:\n  \"\\<langle>Skip, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow> c' = Stop \\<and> mds = mds' \\<and> mem = mem'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Skip, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n    \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n    c' = Stop \\<and> mds = mds' \\<and> mem = mem'", "apply (erule eval_elim)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>c c'a E.\n       \\<lbrakk>Skip = cxt_to_stmt E c;\n        (c, mem) \\<leadsto>\\<^sub>s (c'a, mem'); c' = cxt_to_stmt E c'a;\n        mds' = mds\\<rbrakk>\n       \\<Longrightarrow> c' = Stop \\<and> mds = mds' \\<and> mem = mem'\n 2. \\<And>c\\<^sub>1 c\\<^sub>1' c\\<^sub>2.\n       \\<lbrakk>Skip = c\\<^sub>1 ;; c\\<^sub>2; c' = c\\<^sub>1' ;; c\\<^sub>2;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = Stop \\<and> mds = mds' \\<and> mem = mem'\n 3. \\<And>c mu c'a E.\n       \\<lbrakk>Skip = cxt_to_stmt E (c@[mu]); c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = Stop \\<and> mds = mds' \\<and> mem = mem'\n 4. \\<And>b c\\<^sub>1.\n       \\<lbrakk>Skip = Await b c\\<^sub>1; eval\\<^sub>B mem b;\n        no_await c\\<^sub>1;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>c', mds', mem'\\<rangle>\\<^sub>w;\n        is_final c'\\<rbrakk>\n       \\<Longrightarrow> c' = Stop \\<and> mds = mds' \\<and> mem = mem'", "apply (metis (lifting) cxt_inv_skip cxt_to_stmt.simps(1) skip_elim')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>c\\<^sub>1 c\\<^sub>1' c\\<^sub>2.\n       \\<lbrakk>Skip = c\\<^sub>1 ;; c\\<^sub>2; c' = c\\<^sub>1' ;; c\\<^sub>2;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = Stop \\<and> mds = mds' \\<and> mem = mem'\n 2. \\<And>c mu c'a E.\n       \\<lbrakk>Skip = cxt_to_stmt E (c@[mu]); c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = Stop \\<and> mds = mds' \\<and> mem = mem'\n 3. \\<And>b c\\<^sub>1.\n       \\<lbrakk>Skip = Await b c\\<^sub>1; eval\\<^sub>B mem b;\n        no_await c\\<^sub>1;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>c', mds', mem'\\<rangle>\\<^sub>w;\n        is_final c'\\<rbrakk>\n       \\<Longrightarrow> c' = Stop \\<and> mds = mds' \\<and> mem = mem'", "apply (metis Stmt.simps(24))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c mu c'a E.\n       \\<lbrakk>Skip = cxt_to_stmt E (c@[mu]); c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = Stop \\<and> mds = mds' \\<and> mem = mem'\n 2. \\<And>b c\\<^sub>1.\n       \\<lbrakk>Skip = Await b c\\<^sub>1; eval\\<^sub>B mem b;\n        no_await c\\<^sub>1;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>c', mds', mem'\\<rangle>\\<^sub>w;\n        is_final c'\\<rbrakk>\n       \\<Longrightarrow> c' = Stop \\<and> mds = mds' \\<and> mem = mem'", "apply (metis Stmt.simps(21) cxt_inv_skip)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b c\\<^sub>1.\n       \\<lbrakk>Skip = Await b c\\<^sub>1; eval\\<^sub>B mem b;\n        no_await c\\<^sub>1;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>c', mds', mem'\\<rangle>\\<^sub>w;\n        is_final c'\\<rbrakk>\n       \\<Longrightarrow> c' = Stop \\<and> mds = mds' \\<and> mem = mem'", "by simp"], ["", "lemma assign_elim [elim]:\n  \"\\<langle>x \\<leftarrow> e, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow> c' = Stop \\<and> mds = mds' \\<and> mem' = mem (x := eval\\<^sub>A mem e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>x \\<leftarrow> e, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n    \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n    c' = Stop \\<and> mds = mds' \\<and> mem' = mem(x := eval\\<^sub>A mem e)", "apply (erule eval_elim)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>c c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E c;\n        (c, mem) \\<leadsto>\\<^sub>s (c'a, mem'); c' = cxt_to_stmt E c'a;\n        mds' = mds\\<rbrakk>\n       \\<Longrightarrow> c' = Stop \\<and>\n                         mds = mds' \\<and>\n                         mem' = mem(x := eval\\<^sub>A mem e)\n 2. \\<And>c\\<^sub>1 c\\<^sub>1' c\\<^sub>2.\n       \\<lbrakk>x \\<leftarrow> e = c\\<^sub>1 ;; c\\<^sub>2;\n        c' = c\\<^sub>1' ;; c\\<^sub>2;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = Stop \\<and>\n                         mds = mds' \\<and>\n                         mem' = mem(x := eval\\<^sub>A mem e)\n 3. \\<And>c mu c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = Stop \\<and>\n                         mds = mds' \\<and>\n                         mem' = mem(x := eval\\<^sub>A mem e)\n 4. \\<And>b c\\<^sub>1.\n       \\<lbrakk>x \\<leftarrow> e = Await b c\\<^sub>1; eval\\<^sub>B mem b;\n        no_await c\\<^sub>1;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>c', mds', mem'\\<rangle>\\<^sub>w;\n        is_final c'\\<rbrakk>\n       \\<Longrightarrow> c' = Stop \\<and>\n                         mds = mds' \\<and>\n                         mem' = mem(x := eval\\<^sub>A mem e)", "apply (rename_tac c c'a E)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>c c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E c;\n        (c, mem) \\<leadsto>\\<^sub>s (c'a, mem'); c' = cxt_to_stmt E c'a;\n        mds' = mds\\<rbrakk>\n       \\<Longrightarrow> c' = Stop \\<and>\n                         mds = mds' \\<and>\n                         mem' = mem(x := eval\\<^sub>A mem e)\n 2. \\<And>c\\<^sub>1 c\\<^sub>1' c\\<^sub>2.\n       \\<lbrakk>x \\<leftarrow> e = c\\<^sub>1 ;; c\\<^sub>2;\n        c' = c\\<^sub>1' ;; c\\<^sub>2;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = Stop \\<and>\n                         mds = mds' \\<and>\n                         mem' = mem(x := eval\\<^sub>A mem e)\n 3. \\<And>c mu c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = Stop \\<and>\n                         mds = mds' \\<and>\n                         mem' = mem(x := eval\\<^sub>A mem e)\n 4. \\<And>b c\\<^sub>1.\n       \\<lbrakk>x \\<leftarrow> e = Await b c\\<^sub>1; eval\\<^sub>B mem b;\n        no_await c\\<^sub>1;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>c', mds', mem'\\<rangle>\\<^sub>w;\n        is_final c'\\<rbrakk>\n       \\<Longrightarrow> c' = Stop \\<and>\n                         mds = mds' \\<and>\n                         mem' = mem(x := eval\\<^sub>A mem e)", "apply (subgoal_tac \"c = x \\<leftarrow> e \\<and> E = []\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>c c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E c;\n        (c, mem) \\<leadsto>\\<^sub>s (c'a, mem'); c' = cxt_to_stmt E c'a;\n        mds' = mds; c = x \\<leftarrow> e \\<and> E = []\\<rbrakk>\n       \\<Longrightarrow> c' = Stop \\<and>\n                         mds = mds' \\<and>\n                         mem' = mem(x := eval\\<^sub>A mem e)\n 2. \\<And>c c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E c;\n        (c, mem) \\<leadsto>\\<^sub>s (c'a, mem'); c' = cxt_to_stmt E c'a;\n        mds' = mds\\<rbrakk>\n       \\<Longrightarrow> c = x \\<leftarrow> e \\<and> E = []\n 3. \\<And>c\\<^sub>1 c\\<^sub>1' c\\<^sub>2.\n       \\<lbrakk>x \\<leftarrow> e = c\\<^sub>1 ;; c\\<^sub>2;\n        c' = c\\<^sub>1' ;; c\\<^sub>2;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = Stop \\<and>\n                         mds = mds' \\<and>\n                         mem' = mem(x := eval\\<^sub>A mem e)\n 4. \\<And>c mu c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = Stop \\<and>\n                         mds = mds' \\<and>\n                         mem' = mem(x := eval\\<^sub>A mem e)\n 5. \\<And>b c\\<^sub>1.\n       \\<lbrakk>x \\<leftarrow> e = Await b c\\<^sub>1; eval\\<^sub>B mem b;\n        no_await c\\<^sub>1;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>c', mds', mem'\\<rangle>\\<^sub>w;\n        is_final c'\\<rbrakk>\n       \\<Longrightarrow> c' = Stop \\<and>\n                         mds = mds' \\<and>\n                         mem' = mem(x := eval\\<^sub>A mem e)", "apply force"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>c c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E c;\n        (c, mem) \\<leadsto>\\<^sub>s (c'a, mem'); c' = cxt_to_stmt E c'a;\n        mds' = mds\\<rbrakk>\n       \\<Longrightarrow> c = x \\<leftarrow> e \\<and> E = []\n 2. \\<And>c\\<^sub>1 c\\<^sub>1' c\\<^sub>2.\n       \\<lbrakk>x \\<leftarrow> e = c\\<^sub>1 ;; c\\<^sub>2;\n        c' = c\\<^sub>1' ;; c\\<^sub>2;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = Stop \\<and>\n                         mds = mds' \\<and>\n                         mem' = mem(x := eval\\<^sub>A mem e)\n 3. \\<And>c mu c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = Stop \\<and>\n                         mds = mds' \\<and>\n                         mem' = mem(x := eval\\<^sub>A mem e)\n 4. \\<And>b c\\<^sub>1.\n       \\<lbrakk>x \\<leftarrow> e = Await b c\\<^sub>1; eval\\<^sub>B mem b;\n        no_await c\\<^sub>1;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>c', mds', mem'\\<rangle>\\<^sub>w;\n        is_final c'\\<rbrakk>\n       \\<Longrightarrow> c' = Stop \\<and>\n                         mds = mds' \\<and>\n                         mem' = mem(x := eval\\<^sub>A mem e)", "apply auto"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>c c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E c;\n        (c, mem) \\<leadsto>\\<^sub>s (c'a, mem'); c' = cxt_to_stmt E c'a;\n        mds' = mds\\<rbrakk>\n       \\<Longrightarrow> c = cxt_to_stmt E c\n 2. \\<And>c c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E c;\n        (c, mem) \\<leadsto>\\<^sub>s (c'a, mem'); c' = cxt_to_stmt E c'a;\n        mds' = mds\\<rbrakk>\n       \\<Longrightarrow> E = []\n 3. \\<And>c mu c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> cxt_to_stmt E c'a = Stop\n 4. \\<And>c mu c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> mds = mds'\n 5. \\<And>c mu c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> mem' = mem(x := eval\\<^sub>A mem e)", "apply (metis cxt_inv_assign)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>c c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E c;\n        (c, mem) \\<leadsto>\\<^sub>s (c'a, mem'); c' = cxt_to_stmt E c'a;\n        mds' = mds\\<rbrakk>\n       \\<Longrightarrow> E = []\n 2. \\<And>c mu c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> cxt_to_stmt E c'a = Stop\n 3. \\<And>c mu c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> mds = mds'\n 4. \\<And>c mu c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> mem' = mem(x := eval\\<^sub>A mem e)", "apply (metis cxt_inv_assign)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>c mu c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> cxt_to_stmt E c'a = Stop\n 2. \\<And>c mu c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> mds = mds'\n 3. \\<And>c mu c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> mem' = mem(x := eval\\<^sub>A mem e)", "apply (metis Stmt.simps(9) cxt_inv_assign)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c mu c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> mds = mds'\n 2. \\<And>c mu c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> mem' = mem(x := eval\\<^sub>A mem e)", "apply (metis Stmt.simps(9) cxt_inv_assign)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c mu c'a E.\n       \\<lbrakk>x \\<leftarrow> e = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> mem' = mem(x := eval\\<^sub>A mem e)", "by (metis Stmt.simps(9) cxt_inv_assign)"], ["", "inductive_cases if_elim' [elim!]: \"(If b p q, mem) \\<leadsto>\\<^sub>s (c', mem')\""], ["", "lemma if_elim [elim]:\n  \"\\<And> P.\n    \\<lbrakk> \\<langle>If b p q, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c', mds', mem'\\<rangle>\\<^sub>w ;\n     \\<lbrakk> c' = p; mem' = mem ; mds' = mds ; eval\\<^sub>B mem b \\<rbrakk> \\<Longrightarrow> P ;\n     \\<lbrakk> c' = q; mem' = mem ; mds' = mds ; \\<not> eval\\<^sub>B mem b \\<rbrakk> \\<Longrightarrow> P \\<rbrakk> \\<Longrightarrow> P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P.\n       \\<lbrakk>\\<langle>Stmt.If b p\n                          q, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                \\<langle>c', mds', mem'\\<rangle>\\<^sub>w;\n        \\<lbrakk>c' = p; mem' = mem; mds' = mds; eval\\<^sub>B mem b\\<rbrakk>\n        \\<Longrightarrow> P;\n        \\<lbrakk>c' = q; mem' = mem; mds' = mds;\n         \\<not> eval\\<^sub>B mem b\\<rbrakk>\n        \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P", "apply (erule eval_elim)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P c c'a E.\n       \\<lbrakk>\\<lbrakk>c' = p; mem' = mem; mds' = mds;\n                 eval\\<^sub>B mem b\\<rbrakk>\n                \\<Longrightarrow> P;\n        \\<lbrakk>c' = q; mem' = mem; mds' = mds;\n         \\<not> eval\\<^sub>B mem b\\<rbrakk>\n        \\<Longrightarrow> P;\n        Stmt.If b p q = cxt_to_stmt E c;\n        (c, mem) \\<leadsto>\\<^sub>s (c'a, mem'); c' = cxt_to_stmt E c'a;\n        mds' = mds\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>P c\\<^sub>1 c\\<^sub>1' c\\<^sub>2.\n       \\<lbrakk>\\<lbrakk>c' = p; mem' = mem; mds' = mds;\n                 eval\\<^sub>B mem b\\<rbrakk>\n                \\<Longrightarrow> P;\n        \\<lbrakk>c' = q; mem' = mem; mds' = mds;\n         \\<not> eval\\<^sub>B mem b\\<rbrakk>\n        \\<Longrightarrow> P;\n        Stmt.If b p q = c\\<^sub>1 ;; c\\<^sub>2;\n        c' = c\\<^sub>1' ;; c\\<^sub>2;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> P\n 3. \\<And>P c mu c'a E.\n       \\<lbrakk>\\<lbrakk>c' = p; mem' = mem; mds' = mds;\n                 eval\\<^sub>B mem b\\<rbrakk>\n                \\<Longrightarrow> P;\n        \\<lbrakk>c' = q; mem' = mem; mds' = mds;\n         \\<not> eval\\<^sub>B mem b\\<rbrakk>\n        \\<Longrightarrow> P;\n        Stmt.If b p q = cxt_to_stmt E (c@[mu]); c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> P\n 4. \\<And>P ba c\\<^sub>1.\n       \\<lbrakk>\\<lbrakk>c' = p; mem' = mem; mds' = mds;\n                 eval\\<^sub>B mem b\\<rbrakk>\n                \\<Longrightarrow> P;\n        \\<lbrakk>c' = q; mem' = mem; mds' = mds;\n         \\<not> eval\\<^sub>B mem b\\<rbrakk>\n        \\<Longrightarrow> P;\n        Stmt.If b p q = Await ba c\\<^sub>1; eval\\<^sub>B mem ba;\n        no_await c\\<^sub>1;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>c', mds', mem'\\<rangle>\\<^sub>w;\n        is_final c'\\<rbrakk>\n       \\<Longrightarrow> P", "apply (metis (no_types) cxt_inv_if cxt_to_stmt.simps(1) if_elim')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>P c\\<^sub>1 c\\<^sub>1' c\\<^sub>2.\n       \\<lbrakk>\\<lbrakk>c' = p; mem' = mem; mds' = mds;\n                 eval\\<^sub>B mem b\\<rbrakk>\n                \\<Longrightarrow> P;\n        \\<lbrakk>c' = q; mem' = mem; mds' = mds;\n         \\<not> eval\\<^sub>B mem b\\<rbrakk>\n        \\<Longrightarrow> P;\n        Stmt.If b p q = c\\<^sub>1 ;; c\\<^sub>2;\n        c' = c\\<^sub>1' ;; c\\<^sub>2;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>P c mu c'a E.\n       \\<lbrakk>\\<lbrakk>c' = p; mem' = mem; mds' = mds;\n                 eval\\<^sub>B mem b\\<rbrakk>\n                \\<Longrightarrow> P;\n        \\<lbrakk>c' = q; mem' = mem; mds' = mds;\n         \\<not> eval\\<^sub>B mem b\\<rbrakk>\n        \\<Longrightarrow> P;\n        Stmt.If b p q = cxt_to_stmt E (c@[mu]); c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> P\n 3. \\<And>P ba c\\<^sub>1.\n       \\<lbrakk>\\<lbrakk>c' = p; mem' = mem; mds' = mds;\n                 eval\\<^sub>B mem b\\<rbrakk>\n                \\<Longrightarrow> P;\n        \\<lbrakk>c' = q; mem' = mem; mds' = mds;\n         \\<not> eval\\<^sub>B mem b\\<rbrakk>\n        \\<Longrightarrow> P;\n        Stmt.If b p q = Await ba c\\<^sub>1; eval\\<^sub>B mem ba;\n        no_await c\\<^sub>1;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>c', mds', mem'\\<rangle>\\<^sub>w;\n        is_final c'\\<rbrakk>\n       \\<Longrightarrow> P", "apply (metis Stmt.simps(43))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P c mu c'a E.\n       \\<lbrakk>\\<lbrakk>c' = p; mem' = mem; mds' = mds;\n                 eval\\<^sub>B mem b\\<rbrakk>\n                \\<Longrightarrow> P;\n        \\<lbrakk>c' = q; mem' = mem; mds' = mds;\n         \\<not> eval\\<^sub>B mem b\\<rbrakk>\n        \\<Longrightarrow> P;\n        Stmt.If b p q = cxt_to_stmt E (c@[mu]); c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> P\n 2. \\<And>P ba c\\<^sub>1.\n       \\<lbrakk>\\<lbrakk>c' = p; mem' = mem; mds' = mds;\n                 eval\\<^sub>B mem b\\<rbrakk>\n                \\<Longrightarrow> P;\n        \\<lbrakk>c' = q; mem' = mem; mds' = mds;\n         \\<not> eval\\<^sub>B mem b\\<rbrakk>\n        \\<Longrightarrow> P;\n        Stmt.If b p q = Await ba c\\<^sub>1; eval\\<^sub>B mem ba;\n        no_await c\\<^sub>1;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>c', mds', mem'\\<rangle>\\<^sub>w;\n        is_final c'\\<rbrakk>\n       \\<Longrightarrow> P", "apply (metis Stmt.simps(35) cxt_inv_if)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P ba c\\<^sub>1.\n       \\<lbrakk>\\<lbrakk>c' = p; mem' = mem; mds' = mds;\n                 eval\\<^sub>B mem b\\<rbrakk>\n                \\<Longrightarrow> P;\n        \\<lbrakk>c' = q; mem' = mem; mds' = mds;\n         \\<not> eval\\<^sub>B mem b\\<rbrakk>\n        \\<Longrightarrow> P;\n        Stmt.If b p q = Await ba c\\<^sub>1; eval\\<^sub>B mem ba;\n        no_await c\\<^sub>1;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>c', mds', mem'\\<rangle>\\<^sub>w;\n        is_final c'\\<rbrakk>\n       \\<Longrightarrow> P", "by simp"], ["", "inductive_cases await_elim' [elim!]: \"\\<langle>Await b p, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c',mds', mem'\\<rangle>\\<^sub>w\""], ["", "inductive_cases while_elim' [elim!]: \"(While e c, mem) \\<leadsto>\\<^sub>s (c', mem')\""], ["", "lemma while_elim [elim]:\n  \"\\<lbrakk> \\<langle>While e c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<rbrakk> \\<Longrightarrow> c' = If e (c ;; While e c) Stop \\<and> mds' = mds \\<and> mem' = mem\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>While e c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n    \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n    c' = Stmt.If e (c ;; While e c) Stop \\<and> mds' = mds \\<and> mem' = mem", "apply (erule eval_elim)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>ca c'a E.\n       \\<lbrakk>While e c = cxt_to_stmt E ca;\n        (ca, mem) \\<leadsto>\\<^sub>s (c'a, mem'); c' = cxt_to_stmt E c'a;\n        mds' = mds\\<rbrakk>\n       \\<Longrightarrow> c' = Stmt.If e (c ;; While e c) Stop \\<and>\n                         mds' = mds \\<and> mem' = mem\n 2. \\<And>c\\<^sub>1 c\\<^sub>1' c\\<^sub>2.\n       \\<lbrakk>While e c = c\\<^sub>1 ;; c\\<^sub>2;\n        c' = c\\<^sub>1' ;; c\\<^sub>2;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = Stmt.If e (c ;; While e c) Stop \\<and>\n                         mds' = mds \\<and> mem' = mem\n 3. \\<And>ca mu c'a E.\n       \\<lbrakk>While e c = cxt_to_stmt E (ca@[mu]); c' = cxt_to_stmt E c'a;\n        \\<langle>ca, update_modes mu\n                      mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = Stmt.If e (c ;; While e c) Stop \\<and>\n                         mds' = mds \\<and> mem' = mem\n 4. \\<And>b c\\<^sub>1.\n       \\<lbrakk>While e c = Await b c\\<^sub>1; eval\\<^sub>B mem b;\n        no_await c\\<^sub>1;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>c', mds', mem'\\<rangle>\\<^sub>w;\n        is_final c'\\<rbrakk>\n       \\<Longrightarrow> c' = Stmt.If e (c ;; While e c) Stop \\<and>\n                         mds' = mds \\<and> mem' = mem", "apply (metis (no_types) cxt_inv_while cxt_to_stmt.simps(1) while_elim')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>c\\<^sub>1 c\\<^sub>1' c\\<^sub>2.\n       \\<lbrakk>While e c = c\\<^sub>1 ;; c\\<^sub>2;\n        c' = c\\<^sub>1' ;; c\\<^sub>2;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = Stmt.If e (c ;; While e c) Stop \\<and>\n                         mds' = mds \\<and> mem' = mem\n 2. \\<And>ca mu c'a E.\n       \\<lbrakk>While e c = cxt_to_stmt E (ca@[mu]); c' = cxt_to_stmt E c'a;\n        \\<langle>ca, update_modes mu\n                      mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = Stmt.If e (c ;; While e c) Stop \\<and>\n                         mds' = mds \\<and> mem' = mem\n 3. \\<And>b c\\<^sub>1.\n       \\<lbrakk>While e c = Await b c\\<^sub>1; eval\\<^sub>B mem b;\n        no_await c\\<^sub>1;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>c', mds', mem'\\<rangle>\\<^sub>w;\n        is_final c'\\<rbrakk>\n       \\<Longrightarrow> c' = Stmt.If e (c ;; While e c) Stop \\<and>\n                         mds' = mds \\<and> mem' = mem", "apply (metis Stmt.simps(45))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ca mu c'a E.\n       \\<lbrakk>While e c = cxt_to_stmt E (ca@[mu]); c' = cxt_to_stmt E c'a;\n        \\<langle>ca, update_modes mu\n                      mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = Stmt.If e (c ;; While e c) Stop \\<and>\n                         mds' = mds \\<and> mem' = mem\n 2. \\<And>b c\\<^sub>1.\n       \\<lbrakk>While e c = Await b c\\<^sub>1; eval\\<^sub>B mem b;\n        no_await c\\<^sub>1;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>c', mds', mem'\\<rangle>\\<^sub>w;\n        is_final c'\\<rbrakk>\n       \\<Longrightarrow> c' = Stmt.If e (c ;; While e c) Stop \\<and>\n                         mds' = mds \\<and> mem' = mem", "apply (metis (lifting) Stmt.simps(37) cxt_inv_while)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b c\\<^sub>1.\n       \\<lbrakk>While e c = Await b c\\<^sub>1; eval\\<^sub>B mem b;\n        no_await c\\<^sub>1;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>c', mds', mem'\\<rangle>\\<^sub>w;\n        is_final c'\\<rbrakk>\n       \\<Longrightarrow> c' = Stmt.If e (c ;; While e c) Stop \\<and>\n                         mds' = mds \\<and> mem' = mem", "by simp"], ["", "inductive_cases upd_elim' [elim]: \"(c@[upd], mem) \\<leadsto>\\<^sub>s (c', mem')\""], ["", "lemma upd_elim [elim]:\n  \"\\<langle>c@[upd], mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow> \\<langle>c, update_modes upd mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>c@[upd], mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n    \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n    \\<langle>c, update_modes upd\n                 mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n    \\<langle>c', mds', mem'\\<rangle>\\<^sub>w", "apply (erule eval_elim)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>ca c'a E.\n       \\<lbrakk>c@[upd] = cxt_to_stmt E ca;\n        (ca, mem) \\<leadsto>\\<^sub>s (c'a, mem'); c' = cxt_to_stmt E c'a;\n        mds' = mds\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c, update_modes upd\nmds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                         \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\n 2. \\<And>c\\<^sub>1 c\\<^sub>1' c\\<^sub>2.\n       \\<lbrakk>c@[upd] = c\\<^sub>1 ;; c\\<^sub>2;\n        c' = c\\<^sub>1' ;; c\\<^sub>2;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c, update_modes upd\nmds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                         \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\n 3. \\<And>ca mu c'a E.\n       \\<lbrakk>c@[upd] = cxt_to_stmt E (ca@[mu]); c' = cxt_to_stmt E c'a;\n        \\<langle>ca, update_modes mu\n                      mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c, update_modes upd\nmds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                         \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\n 4. \\<And>b c\\<^sub>1.\n       \\<lbrakk>c@[upd] = Await b c\\<^sub>1; eval\\<^sub>B mem b;\n        no_await c\\<^sub>1;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>c', mds', mem'\\<rangle>\\<^sub>w;\n        is_final c'\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c, update_modes upd\nmds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                         \\<langle>c', mds', mem'\\<rangle>\\<^sub>w", "apply (metis (lifting) Stmt.simps(33) cxt_inv upd_elim')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>c\\<^sub>1 c\\<^sub>1' c\\<^sub>2.\n       \\<lbrakk>c@[upd] = c\\<^sub>1 ;; c\\<^sub>2;\n        c' = c\\<^sub>1' ;; c\\<^sub>2;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c, update_modes upd\nmds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                         \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\n 2. \\<And>ca mu c'a E.\n       \\<lbrakk>c@[upd] = cxt_to_stmt E (ca@[mu]); c' = cxt_to_stmt E c'a;\n        \\<langle>ca, update_modes mu\n                      mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c, update_modes upd\nmds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                         \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\n 3. \\<And>b c\\<^sub>1.\n       \\<lbrakk>c@[upd] = Await b c\\<^sub>1; eval\\<^sub>B mem b;\n        no_await c\\<^sub>1;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>c', mds', mem'\\<rangle>\\<^sub>w;\n        is_final c'\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c, update_modes upd\nmds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                         \\<langle>c', mds', mem'\\<rangle>\\<^sub>w", "apply (metis Stmt.simps(34))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ca mu c'a E.\n       \\<lbrakk>c@[upd] = cxt_to_stmt E (ca@[mu]); c' = cxt_to_stmt E c'a;\n        \\<langle>ca, update_modes mu\n                      mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c, update_modes upd\nmds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                         \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\n 2. \\<And>b c\\<^sub>1.\n       \\<lbrakk>c@[upd] = Await b c\\<^sub>1; eval\\<^sub>B mem b;\n        no_await c\\<^sub>1;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>c', mds', mem'\\<rangle>\\<^sub>w;\n        is_final c'\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c, update_modes upd\nmds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                         \\<langle>c', mds', mem'\\<rangle>\\<^sub>w", "apply (metis (lifting) Stmt.simps(2) Stmt.simps(33) cxt_inv cxt_to_stmt.simps(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b c\\<^sub>1.\n       \\<lbrakk>c@[upd] = Await b c\\<^sub>1; eval\\<^sub>B mem b;\n        no_await c\\<^sub>1;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>c', mds', mem'\\<rangle>\\<^sub>w;\n        is_final c'\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c, update_modes upd\nmds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                         \\<langle>c', mds', mem'\\<rangle>\\<^sub>w", "by simp"], ["", "lemma cxt_seq_elim [elim]:\n  \"c\\<^sub>1 ;; c\\<^sub>2 = cxt_to_stmt E c \\<Longrightarrow> (E = [] \\<and> c = c\\<^sub>1 ;; c\\<^sub>2) \\<or> (\\<exists> c' cs. E = c' # cs \\<and> c = c\\<^sub>1 \\<and> c\\<^sub>2 = cxt_to_stmt cs c')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c\\<^sub>1 ;; c\\<^sub>2 = cxt_to_stmt E c \\<Longrightarrow>\n    E = [] \\<and> c = c\\<^sub>1 ;; c\\<^sub>2 \\<or>\n    (\\<exists>c' cs.\n        E = c' # cs \\<and>\n        c = c\\<^sub>1 \\<and> c\\<^sub>2 = cxt_to_stmt cs c')", "apply (cases E)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>c\\<^sub>1 ;; c\\<^sub>2 = cxt_to_stmt E c; E = []\\<rbrakk>\n    \\<Longrightarrow> E = [] \\<and> c = c\\<^sub>1 ;; c\\<^sub>2 \\<or>\n                      (\\<exists>c' cs.\n                          E = c' # cs \\<and>\n                          c = c\\<^sub>1 \\<and>\n                          c\\<^sub>2 = cxt_to_stmt cs c')\n 2. \\<And>a list.\n       \\<lbrakk>c\\<^sub>1 ;; c\\<^sub>2 = cxt_to_stmt E c;\n        E = a # list\\<rbrakk>\n       \\<Longrightarrow> E = [] \\<and> c = c\\<^sub>1 ;; c\\<^sub>2 \\<or>\n                         (\\<exists>c' cs.\n                             E = c' # cs \\<and>\n                             c = c\\<^sub>1 \\<and>\n                             c\\<^sub>2 = cxt_to_stmt cs c')", "apply (metis cxt_to_stmt.simps(1))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       \\<lbrakk>c\\<^sub>1 ;; c\\<^sub>2 = cxt_to_stmt E c;\n        E = a # list\\<rbrakk>\n       \\<Longrightarrow> E = [] \\<and> c = c\\<^sub>1 ;; c\\<^sub>2 \\<or>\n                         (\\<exists>c' cs.\n                             E = c' # cs \\<and>\n                             c = c\\<^sub>1 \\<and>\n                             c\\<^sub>2 = cxt_to_stmt cs c')", "by (metis Stmt.simps(3) cxt_to_stmt.simps(2))"], ["", "inductive_cases seq_elim' [elim]: \"(c\\<^sub>1 ;; c\\<^sub>2, mem) \\<leadsto>\\<^sub>s (c', mem')\""], ["", "lemma stop_no_eval: \"\\<not> (\\<langle>Stop, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c', mds', mem'\\<rangle>\\<^sub>w)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<langle>Stop, mds, mem\\<rangle>\\<^sub>w,\n     \\<langle>c', mds', mem'\\<rangle>\\<^sub>w)\n    \\<notin> eval\\<^sub>w", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Stop, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n    \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n    False", "apply (erule eval_elim)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>c c'a E.\n       \\<lbrakk>Stop = cxt_to_stmt E c;\n        (c, mem) \\<leadsto>\\<^sub>s (c'a, mem'); c' = cxt_to_stmt E c'a;\n        mds' = mds\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c\\<^sub>1 c\\<^sub>1' c\\<^sub>2.\n       \\<lbrakk>Stop = c\\<^sub>1 ;; c\\<^sub>2; c' = c\\<^sub>1' ;; c\\<^sub>2;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>c mu c'a E.\n       \\<lbrakk>Stop = cxt_to_stmt E (c@[mu]); c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> False\n 4. \\<And>b c\\<^sub>1.\n       \\<lbrakk>Stop = Await b c\\<^sub>1; eval\\<^sub>B mem b;\n        no_await c\\<^sub>1;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>c', mds', mem'\\<rangle>\\<^sub>w;\n        is_final c'\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis cxt_inv_stop stop_no_eval')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>c\\<^sub>1 c\\<^sub>1' c\\<^sub>2.\n       \\<lbrakk>Stop = c\\<^sub>1 ;; c\\<^sub>2; c' = c\\<^sub>1' ;; c\\<^sub>2;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>c mu c'a E.\n       \\<lbrakk>Stop = cxt_to_stmt E (c@[mu]); c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> False\n 3. \\<And>b c\\<^sub>1.\n       \\<lbrakk>Stop = Await b c\\<^sub>1; eval\\<^sub>B mem b;\n        no_await c\\<^sub>1;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>c', mds', mem'\\<rangle>\\<^sub>w;\n        is_final c'\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis Stmt.simps(49))"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c mu c'a E.\n       \\<lbrakk>Stop = cxt_to_stmt E (c@[mu]); c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> False\n 2. \\<And>b c\\<^sub>1.\n       \\<lbrakk>Stop = Await b c\\<^sub>1; eval\\<^sub>B mem b;\n        no_await c\\<^sub>1;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>c', mds', mem'\\<rangle>\\<^sub>w;\n        is_final c'\\<rbrakk>\n       \\<Longrightarrow> False", "apply (metis Stmt.simps(41) cxt_inv_stop)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b c\\<^sub>1.\n       \\<lbrakk>Stop = Await b c\\<^sub>1; eval\\<^sub>B mem b;\n        no_await c\\<^sub>1;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>c', mds', mem'\\<rangle>\\<^sub>w;\n        is_final c'\\<rbrakk>\n       \\<Longrightarrow> False", "by simp"], ["", "lemma seq_stop_elim [elim]:\n  \"\\<langle>Stop ;; c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow> c' = c \\<and> mds' = mds \\<and> mem' = mem\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Stop ;; c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n    \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n    c' = c \\<and> mds' = mds \\<and> mem' = mem", "apply (erule eval_elim)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>ca c'a E.\n       \\<lbrakk>Stop ;; c = cxt_to_stmt E ca;\n        (ca, mem) \\<leadsto>\\<^sub>s (c'a, mem'); c' = cxt_to_stmt E c'a;\n        mds' = mds\\<rbrakk>\n       \\<Longrightarrow> c' = c \\<and> mds' = mds \\<and> mem' = mem\n 2. \\<And>c\\<^sub>1 c\\<^sub>1' c\\<^sub>2.\n       \\<lbrakk>Stop ;; c = c\\<^sub>1 ;; c\\<^sub>2;\n        c' = c\\<^sub>1' ;; c\\<^sub>2;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = c \\<and> mds' = mds \\<and> mem' = mem\n 3. \\<And>ca mu c'a E.\n       \\<lbrakk>Stop ;; c = cxt_to_stmt E (ca@[mu]); c' = cxt_to_stmt E c'a;\n        \\<langle>ca, update_modes mu\n                      mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = c \\<and> mds' = mds \\<and> mem' = mem\n 4. \\<And>b c\\<^sub>1.\n       \\<lbrakk>Stop ;; c = Await b c\\<^sub>1; eval\\<^sub>B mem b;\n        no_await c\\<^sub>1;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>c', mds', mem'\\<rangle>\\<^sub>w;\n        is_final c'\\<rbrakk>\n       \\<Longrightarrow> c' = c \\<and> mds' = mds \\<and> mem' = mem", "apply clarify"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>ca c'a E.\n       \\<lbrakk>Stop ;; c = cxt_to_stmt E ca;\n        (ca, mem) \\<leadsto>\\<^sub>s (c'a, mem'); mds' = mds;\n        c' = cxt_to_stmt E c'a\\<rbrakk>\n       \\<Longrightarrow> cxt_to_stmt E c'a = c \\<and>\n                         mds = mds \\<and> mem' = mem\n 2. \\<And>c\\<^sub>1 c\\<^sub>1' c\\<^sub>2.\n       \\<lbrakk>Stop ;; c = c\\<^sub>1 ;; c\\<^sub>2;\n        c' = c\\<^sub>1' ;; c\\<^sub>2;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = c \\<and> mds' = mds \\<and> mem' = mem\n 3. \\<And>ca mu c'a E.\n       \\<lbrakk>Stop ;; c = cxt_to_stmt E (ca@[mu]); c' = cxt_to_stmt E c'a;\n        \\<langle>ca, update_modes mu\n                      mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = c \\<and> mds' = mds \\<and> mem' = mem\n 4. \\<And>b c\\<^sub>1.\n       \\<lbrakk>Stop ;; c = Await b c\\<^sub>1; eval\\<^sub>B mem b;\n        no_await c\\<^sub>1;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>c', mds', mem'\\<rangle>\\<^sub>w;\n        is_final c'\\<rbrakk>\n       \\<Longrightarrow> c' = c \\<and> mds' = mds \\<and> mem' = mem", "apply (metis (no_types) cxt_seq_elim cxt_to_stmt.simps(1) seq_elim' stop_no_eval')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>c\\<^sub>1 c\\<^sub>1' c\\<^sub>2.\n       \\<lbrakk>Stop ;; c = c\\<^sub>1 ;; c\\<^sub>2;\n        c' = c\\<^sub>1' ;; c\\<^sub>2;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = c \\<and> mds' = mds \\<and> mem' = mem\n 2. \\<And>ca mu c'a E.\n       \\<lbrakk>Stop ;; c = cxt_to_stmt E (ca@[mu]); c' = cxt_to_stmt E c'a;\n        \\<langle>ca, update_modes mu\n                      mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = c \\<and> mds' = mds \\<and> mem' = mem\n 3. \\<And>b c\\<^sub>1.\n       \\<lbrakk>Stop ;; c = Await b c\\<^sub>1; eval\\<^sub>B mem b;\n        no_await c\\<^sub>1;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>c', mds', mem'\\<rangle>\\<^sub>w;\n        is_final c'\\<rbrakk>\n       \\<Longrightarrow> c' = c \\<and> mds' = mds \\<and> mem' = mem", "apply (metis Stmt.inject(3) stop_no_eval)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ca mu c'a E.\n       \\<lbrakk>Stop ;; c = cxt_to_stmt E (ca@[mu]); c' = cxt_to_stmt E c'a;\n        \\<langle>ca, update_modes mu\n                      mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c' = c \\<and> mds' = mds \\<and> mem' = mem\n 2. \\<And>b c\\<^sub>1.\n       \\<lbrakk>Stop ;; c = Await b c\\<^sub>1; eval\\<^sub>B mem b;\n        no_await c\\<^sub>1;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>c', mds', mem'\\<rangle>\\<^sub>w;\n        is_final c'\\<rbrakk>\n       \\<Longrightarrow> c' = c \\<and> mds' = mds \\<and> mem' = mem", "apply (metis Stmt.distinct(28) Stmt.distinct(36) cxt_seq_elim)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b c\\<^sub>1.\n       \\<lbrakk>Stop ;; c = Await b c\\<^sub>1; eval\\<^sub>B mem b;\n        no_await c\\<^sub>1;\n        \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>c', mds', mem'\\<rangle>\\<^sub>w;\n        is_final c'\\<rbrakk>\n       \\<Longrightarrow> c' = c \\<and> mds' = mds \\<and> mem' = mem", "by simp"], ["", "lemma cxt_stmt_seq:\n  \"c ;; cxt_to_stmt E c' = cxt_to_stmt (c' # E) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c ;; cxt_to_stmt E c' = cxt_to_stmt (c' # E) c", "by (metis cxt_to_stmt.simps(2))"], ["", "lemma seq_elim [elim]:\n  \"\\<lbrakk> \\<langle>c\\<^sub>1 ;; c\\<^sub>2, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c', mds', mem'\\<rangle>\\<^sub>w ; c\\<^sub>1 \\<noteq> Stop \\<rbrakk> \\<Longrightarrow>\n  (\\<exists> c\\<^sub>1'. \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and> c' = c\\<^sub>1' ;; c\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<langle>c\\<^sub>1 ;;\n                      c\\<^sub>2, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n             \\<langle>c', mds', mem'\\<rangle>\\<^sub>w;\n     c\\<^sub>1 \\<noteq> Stop\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                         \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                         \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and>\n                         c' = c\\<^sub>1' ;; c\\<^sub>2", "apply (erule eval_elim)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>c c'a E.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = cxt_to_stmt E c;\n        (c, mem) \\<leadsto>\\<^sub>s (c'a, mem'); c' = cxt_to_stmt E c'a;\n        mds' = mds\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and>\n                            c' = c\\<^sub>1' ;; c\\<^sub>2\n 2. \\<And>c\\<^sub>1' c\\<^sub>1'' c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = c\\<^sub>1' ;; c\\<^sub>2';\n        c' = c\\<^sub>1'' ;; c\\<^sub>2';\n        \\<langle>c\\<^sub>1', mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1'', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and>\n                            c' = c\\<^sub>1' ;; c\\<^sub>2\n 3. \\<And>c mu c'a E.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and>\n                            c' = c\\<^sub>1' ;; c\\<^sub>2\n 4. \\<And>b c\\<^sub>1'.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = Await b c\\<^sub>1'; eval\\<^sub>B mem b;\n        no_await c\\<^sub>1';\n        \\<langle>c\\<^sub>1', mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>c', mds', mem'\\<rangle>\\<^sub>w;\n        is_final c'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and>\n                            c' = c\\<^sub>1' ;; c\\<^sub>2", "apply clarify"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>c c'a E.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = cxt_to_stmt E c;\n        (c, mem) \\<leadsto>\\<^sub>s (c'a, mem'); mds' = mds;\n        c' = cxt_to_stmt E c'a\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds, mem'\\<rangle>\\<^sub>w \\<and>\n                            cxt_to_stmt E c'a = c\\<^sub>1' ;; c\\<^sub>2\n 2. \\<And>c\\<^sub>1' c\\<^sub>1'' c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = c\\<^sub>1' ;; c\\<^sub>2';\n        c' = c\\<^sub>1'' ;; c\\<^sub>2';\n        \\<langle>c\\<^sub>1', mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1'', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and>\n                            c' = c\\<^sub>1' ;; c\\<^sub>2\n 3. \\<And>c mu c'a E.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and>\n                            c' = c\\<^sub>1' ;; c\\<^sub>2\n 4. \\<And>b c\\<^sub>1'.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = Await b c\\<^sub>1'; eval\\<^sub>B mem b;\n        no_await c\\<^sub>1';\n        \\<langle>c\\<^sub>1', mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>c', mds', mem'\\<rangle>\\<^sub>w;\n        is_final c'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and>\n                            c' = c\\<^sub>1' ;; c\\<^sub>2", "apply (drule cxt_seq_elim)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>c c'a E.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        (c, mem) \\<leadsto>\\<^sub>s (c'a, mem'); mds' = mds;\n        c' = cxt_to_stmt E c'a;\n        E = [] \\<and> c = c\\<^sub>1 ;; c\\<^sub>2 \\<or>\n        (\\<exists>c' cs.\n            E = c' # cs \\<and>\n            c = c\\<^sub>1 \\<and> c\\<^sub>2 = cxt_to_stmt cs c')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds, mem'\\<rangle>\\<^sub>w \\<and>\n                            cxt_to_stmt E c'a = c\\<^sub>1' ;; c\\<^sub>2\n 2. \\<And>c\\<^sub>1' c\\<^sub>1'' c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = c\\<^sub>1' ;; c\\<^sub>2';\n        c' = c\\<^sub>1'' ;; c\\<^sub>2';\n        \\<langle>c\\<^sub>1', mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1'', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and>\n                            c' = c\\<^sub>1' ;; c\\<^sub>2\n 3. \\<And>c mu c'a E.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and>\n                            c' = c\\<^sub>1' ;; c\\<^sub>2\n 4. \\<And>b c\\<^sub>1'.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = Await b c\\<^sub>1'; eval\\<^sub>B mem b;\n        no_await c\\<^sub>1';\n        \\<langle>c\\<^sub>1', mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>c', mds', mem'\\<rangle>\\<^sub>w;\n        is_final c'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and>\n                            c' = c\\<^sub>1' ;; c\\<^sub>2", "apply (erule disjE)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>c c'a E.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        (c, mem) \\<leadsto>\\<^sub>s (c'a, mem'); mds' = mds;\n        c' = cxt_to_stmt E c'a;\n        E = [] \\<and> c = c\\<^sub>1 ;; c\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds, mem'\\<rangle>\\<^sub>w \\<and>\n                            cxt_to_stmt E c'a = c\\<^sub>1' ;; c\\<^sub>2\n 2. \\<And>c c'a E.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        (c, mem) \\<leadsto>\\<^sub>s (c'a, mem'); mds' = mds;\n        c' = cxt_to_stmt E c'a;\n        \\<exists>c' cs.\n           E = c' # cs \\<and>\n           c = c\\<^sub>1 \\<and> c\\<^sub>2 = cxt_to_stmt cs c'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds, mem'\\<rangle>\\<^sub>w \\<and>\n                            cxt_to_stmt E c'a = c\\<^sub>1' ;; c\\<^sub>2\n 3. \\<And>c\\<^sub>1' c\\<^sub>1'' c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = c\\<^sub>1' ;; c\\<^sub>2';\n        c' = c\\<^sub>1'' ;; c\\<^sub>2';\n        \\<langle>c\\<^sub>1', mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1'', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and>\n                            c' = c\\<^sub>1' ;; c\\<^sub>2\n 4. \\<And>c mu c'a E.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and>\n                            c' = c\\<^sub>1' ;; c\\<^sub>2\n 5. \\<And>b c\\<^sub>1'.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = Await b c\\<^sub>1'; eval\\<^sub>B mem b;\n        no_await c\\<^sub>1';\n        \\<langle>c\\<^sub>1', mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>c', mds', mem'\\<rangle>\\<^sub>w;\n        is_final c'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and>\n                            c' = c\\<^sub>1' ;; c\\<^sub>2", "apply blast"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>c c'a E.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        (c, mem) \\<leadsto>\\<^sub>s (c'a, mem'); mds' = mds;\n        c' = cxt_to_stmt E c'a;\n        \\<exists>c' cs.\n           E = c' # cs \\<and>\n           c = c\\<^sub>1 \\<and> c\\<^sub>2 = cxt_to_stmt cs c'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds, mem'\\<rangle>\\<^sub>w \\<and>\n                            cxt_to_stmt E c'a = c\\<^sub>1' ;; c\\<^sub>2\n 2. \\<And>c\\<^sub>1' c\\<^sub>1'' c\\<^sub>2'.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = c\\<^sub>1' ;; c\\<^sub>2';\n        c' = c\\<^sub>1'' ;; c\\<^sub>2';\n        \\<langle>c\\<^sub>1', mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1'', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and>\n                            c' = c\\<^sub>1' ;; c\\<^sub>2\n 3. \\<And>c mu c'a E.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and>\n                            c' = c\\<^sub>1' ;; c\\<^sub>2\n 4. \\<And>b c\\<^sub>1'.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = Await b c\\<^sub>1'; eval\\<^sub>B mem b;\n        no_await c\\<^sub>1';\n        \\<langle>c\\<^sub>1', mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>c', mds', mem'\\<rangle>\\<^sub>w;\n        is_final c'\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and>\n                            c' = c\\<^sub>1' ;; c\\<^sub>2", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c'a c'aa cs.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        (c\\<^sub>1, mem) \\<leadsto>\\<^sub>s (c'a, mem'); mds' = mds;\n        c' = c'a ;; cxt_to_stmt cs c'aa;\n        c\\<^sub>2 = cxt_to_stmt cs c'aa\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                         \\<langle>c'a, mds, mem'\\<rangle>\\<^sub>w\n 2. \\<And>c mu c'a E.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and>\n                            cxt_to_stmt E c'a = c\\<^sub>1' ;; c\\<^sub>2", "apply (metis cxt_to_stmt.simps(1) eval\\<^sub>w.unannotated)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c mu c'a E.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and>\n                            cxt_to_stmt E c'a = c\\<^sub>1' ;; c\\<^sub>2", "apply (subgoal_tac \"c\\<^sub>1 = c@[mu]\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c mu c'a E.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w;\n        c\\<^sub>1 = c@[mu]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and>\n                            cxt_to_stmt E c'a = c\\<^sub>1' ;; c\\<^sub>2\n 2. \\<And>c mu c'a E.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 = c@[mu]", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c mu c'a E.\n       \\<lbrakk>(c@[mu]) ;; c\\<^sub>2 = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w;\n        c\\<^sub>1 = c@[mu]\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c@[mu], mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and>\n                            cxt_to_stmt E c'a = c\\<^sub>1' ;; c\\<^sub>2\n 2. \\<And>c mu c'a E.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 = c@[mu]", "apply (drule cxt_seq_elim)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c mu c'a E.\n       \\<lbrakk>c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w;\n        c\\<^sub>1 = c@[mu];\n        E = [] \\<and> c@[mu] = (c@[mu]) ;; c\\<^sub>2 \\<or>\n        (\\<exists>c' cs.\n            E = c' # cs \\<and>\n            c@[mu] = c@[mu] \\<and> c\\<^sub>2 = cxt_to_stmt cs c')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                            \\<langle>c@[mu], mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                            \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and>\n                            cxt_to_stmt E c'a = c\\<^sub>1' ;; c\\<^sub>2\n 2. \\<And>c mu c'a E.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 = c@[mu]", "apply (metis Stmt.distinct(27) cxt_stmt_seq cxt_to_stmt.simps(1) eval\\<^sub>w.decl)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c mu c'a E.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 = c@[mu]", "using cxt_seq_elim"], ["proof (prove)\nusing this:\n  ?c\\<^sub>1 ;; ?c\\<^sub>2 = cxt_to_stmt ?E ?c \\<Longrightarrow>\n  ?E = [] \\<and> ?c = ?c\\<^sub>1 ;; ?c\\<^sub>2 \\<or>\n  (\\<exists>c' cs.\n      ?E = c' # cs \\<and>\n      ?c = ?c\\<^sub>1 \\<and> ?c\\<^sub>2 = cxt_to_stmt cs c')\n\ngoal (1 subgoal):\n 1. \\<And>c mu c'a E.\n       \\<lbrakk>c\\<^sub>1 \\<noteq> Stop;\n        c\\<^sub>1 ;; c\\<^sub>2 = cxt_to_stmt E (c@[mu]);\n        c' = cxt_to_stmt E c'a;\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c'a, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1 = c@[mu]", "by blast"], ["", "lemma stop_cxt: \"Stop = cxt_to_stmt E c \\<Longrightarrow> c = Stop\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Stop = cxt_to_stmt E c \\<Longrightarrow> c = Stop", "by (metis Stmt.simps(50) cxt_to_stmt.simps(1) cxt_to_stmt.simps(2) neq_Nil_conv)"], ["", "(* Additional helper lemmas added by TobyM and RobS *)"], ["", "lemmas decl_eval\\<^sub>w = decl[OF unannotated, OF skip, where E=\"[]\", simplified, where E1=\"[]\", simplified]"], ["", "lemmas seq_stop_eval\\<^sub>w = unannotated[OF seq_stop, where E=\"[]\", simplified]"], ["", "lemmas assign_eval\\<^sub>w = unannotated[OF assign, where E=\"[]\", simplified]"], ["", "lemmas if_eval\\<^sub>w = unannotated[OF cond, where E=\"[]\", simplified]"], ["", "lemmas if_false_eval\\<^sub>w = unannotated[OF if_false, where E=\"[]\", simplified]"], ["", "lemmas skip_eval\\<^sub>w = unannotated[OF skip, where E=\"[]\", simplified]"], ["", "lemmas while_eval\\<^sub>w = unannotated[OF while, where E=\"[]\", simplified]"], ["", "lemma decl_eval\\<^sub>w':\n  assumes mem_unchanged: \"mem' = mem\"\n  assumes upd: \"mds' = update_modes upd mds\"\n  shows \"(\\<langle>Skip@[upd], mds, mem\\<rangle>\\<^sub>w, \\<langle>Stop, mds', mem'\\<rangle>\\<^sub>w) \\<in> eval\\<^sub>w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Skip@[upd], mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n    \\<langle>Stop, mds', mem'\\<rangle>\\<^sub>w", "using assms decl_eval\\<^sub>w"], ["proof (prove)\nusing this:\n  mem' = mem\n  mds' = update_modes upd mds\n  \\<langle>Skip@[?mu], ?mds, ?mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n  \\<langle>Stop, update_modes ?mu ?mds, ?mem\\<rangle>\\<^sub>w\n\ngoal (1 subgoal):\n 1. \\<langle>Skip@[upd], mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n    \\<langle>Stop, mds', mem'\\<rangle>\\<^sub>w", "by auto"], ["", "lemma assign_eval\\<^sub>w':\n  \"\\<lbrakk>mds = mds'; mem' = mem(x := eval\\<^sub>A mem e)\\<rbrakk> \\<Longrightarrow>\n  \\<langle>x \\<leftarrow> e, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>Stop, mds', mem'\\<rangle>\\<^sub>w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mds = mds'; mem' = mem(x := eval\\<^sub>A mem e)\\<rbrakk>\n    \\<Longrightarrow> \\<langle>x \\<leftarrow>\n                               e, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                      \\<langle>Stop, mds', mem'\\<rangle>\\<^sub>w", "using assign_eval\\<^sub>w"], ["proof (prove)\nusing this:\n  \\<langle>?x \\<leftarrow>\n           ?e, ?mds, ?mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n  \\<langle>Stop, ?mds, ?mem(?x := eval\\<^sub>A ?mem ?e)\\<rangle>\\<^sub>w\n\ngoal (1 subgoal):\n 1. \\<lbrakk>mds = mds'; mem' = mem(x := eval\\<^sub>A mem e)\\<rbrakk>\n    \\<Longrightarrow> \\<langle>x \\<leftarrow>\n                               e, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                      \\<langle>Stop, mds', mem'\\<rangle>\\<^sub>w", "by simp"], ["", "(* Following the naming convention, but we actually apply these as dest, not elim rules... *)"], ["", "lemma seq_decl_elim:\n  \"\\<langle>(Skip@[upd]) ;; c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n   c' = Stop ;; c \\<and> mem' = mem \\<and> mds' = update_modes upd mds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>(Skip@[upd]) ;; c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n    \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n    c' = Stop ;; c \\<and> mem' = mem \\<and> mds' = update_modes upd mds", "apply(drule seq_elim, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c\\<^sub>1'.\n       \\<langle>Skip@[upd], mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and>\n       c' = c\\<^sub>1' ;; c \\<Longrightarrow>\n    c' = Stop ;; c \\<and> mem' = mem \\<and> mds' = update_modes upd mds", "apply(erule exE, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c\\<^sub>1'.\n       \\<lbrakk>\\<langle>Skip@[upd], mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w;\n        c' = c\\<^sub>1' ;; c\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1' = Stop \\<and>\n                         mem' = mem \\<and> mds' = update_modes upd mds", "apply(drule upd_elim)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c\\<^sub>1'.\n       \\<lbrakk>c' = c\\<^sub>1' ;; c;\n        \\<langle>Skip, update_modes upd\n                        mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1' = Stop \\<and>\n                         mem' = mem \\<and> mds' = update_modes upd mds", "apply(drule skip_elim, clarsimp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma seq_assign_elim:\n  \"\\<langle>(x \\<leftarrow> e) ;; c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n   c' = Stop ;; c \\<and> mds' = mds \\<and> mem' = mem(x := eval\\<^sub>A mem e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>(x \\<leftarrow> e) ;;\n             c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n    \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n    c' = Stop ;; c \\<and>\n    mds' = mds \\<and> mem' = mem(x := eval\\<^sub>A mem e)", "apply(drule seq_elim, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c\\<^sub>1'.\n       \\<langle>x \\<leftarrow>\n                e, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w \\<and>\n       c' = c\\<^sub>1' ;; c \\<Longrightarrow>\n    c' = Stop ;; c \\<and>\n    mds' = mds \\<and> mem' = mem(x := eval\\<^sub>A mem e)", "apply(erule exE, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c\\<^sub>1'.\n       \\<lbrakk>\\<langle>x \\<leftarrow>\n                         e, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                \\<langle>c\\<^sub>1', mds', mem'\\<rangle>\\<^sub>w;\n        c' = c\\<^sub>1' ;; c\\<rbrakk>\n       \\<Longrightarrow> c\\<^sub>1' = Stop \\<and>\n                         mds' = mds \\<and>\n                         mem' = mem(x := eval\\<^sub>A mem e)", "apply(drule assign_elim, clarsimp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma no_await_trans: \n  \"\\<lbrakk> no_await c; \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<rbrakk> \\<Longrightarrow> no_await c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>no_await c;\n     \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n     \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n    \\<Longrightarrow> no_await c'", "apply (induct arbitrary: c' mds rule: \"no_await.induct\")"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>x e c' mds.\n       \\<langle>x \\<leftarrow>\n                e, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 2. \\<And>c1 c2 c' mds.\n       \\<lbrakk>no_await c1;\n        \\<And>c' mds.\n           \\<langle>c1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        no_await c2;\n        \\<And>c' mds.\n           \\<langle>c2, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>c1 ;; c2, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'\n 3. \\<And>c1 c2 b c' mds.\n       \\<lbrakk>no_await c1;\n        \\<And>c' mds.\n           \\<langle>c1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        no_await c2;\n        \\<And>c' mds.\n           \\<langle>c2, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>Stmt.If b c1\n                  c2, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'\n 4. \\<And>c b c' mds.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>While b c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'\n 5. \\<And>c' mds.\n       \\<langle>Skip, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 6. \\<And>c' mds.\n       \\<langle>Stop, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 7. \\<And>c m c' mds.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>c@[m], mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'", "using assign_elim \"no_await.simps\""], ["proof (prove)\nusing this:\n  \\<langle>?x \\<leftarrow>\n           ?e, ?mds, ?mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n  \\<langle>?c', ?mds', ?mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n  ?c' = Stop \\<and>\n  ?mds = ?mds' \\<and> ?mem' = ?mem(?x := eval\\<^sub>A ?mem ?e)\n  no_await ?a =\n  ((\\<exists>x e. ?a = x \\<leftarrow> e) \\<or>\n   (\\<exists>c1 c2.\n       ?a = c1 ;; c2 \\<and> no_await c1 \\<and> no_await c2) \\<or>\n   (\\<exists>c1 c2 b.\n       ?a = Stmt.If b c1 c2 \\<and> no_await c1 \\<and> no_await c2) \\<or>\n   (\\<exists>c b. ?a = While b c \\<and> no_await c) \\<or>\n   ?a = Skip \\<or>\n   ?a = Stop \\<or> (\\<exists>c m. ?a = c@[m] \\<and> no_await c))\n\ngoal (7 subgoals):\n 1. \\<And>x e c' mds.\n       \\<langle>x \\<leftarrow>\n                e, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 2. \\<And>c1 c2 c' mds.\n       \\<lbrakk>no_await c1;\n        \\<And>c' mds.\n           \\<langle>c1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        no_await c2;\n        \\<And>c' mds.\n           \\<langle>c2, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>c1 ;; c2, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'\n 3. \\<And>c1 c2 b c' mds.\n       \\<lbrakk>no_await c1;\n        \\<And>c' mds.\n           \\<langle>c1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        no_await c2;\n        \\<And>c' mds.\n           \\<langle>c2, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>Stmt.If b c1\n                  c2, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'\n 4. \\<And>c b c' mds.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>While b c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'\n 5. \\<And>c' mds.\n       \\<langle>Skip, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 6. \\<And>c' mds.\n       \\<langle>Stop, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 7. \\<And>c m c' mds.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>c@[m], mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'", "apply blast"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>c1 c2 c' mds.\n       \\<lbrakk>no_await c1;\n        \\<And>c' mds.\n           \\<langle>c1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        no_await c2;\n        \\<And>c' mds.\n           \\<langle>c2, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>c1 ;; c2, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'\n 2. \\<And>c1 c2 b c' mds.\n       \\<lbrakk>no_await c1;\n        \\<And>c' mds.\n           \\<langle>c1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        no_await c2;\n        \\<And>c' mds.\n           \\<langle>c2, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>Stmt.If b c1\n                  c2, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'\n 3. \\<And>c b c' mds.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>While b c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'\n 4. \\<And>c' mds.\n       \\<langle>Skip, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 5. \\<And>c' mds.\n       \\<langle>Stop, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 6. \\<And>c m c' mds.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>c@[m], mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'", "apply (rename_tac c1 c2 c3 mds)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>c1 c2 c3 mds.\n       \\<lbrakk>no_await c1;\n        \\<And>c' mds.\n           \\<langle>c1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        no_await c2;\n        \\<And>c' mds.\n           \\<langle>c2, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>c1 ;; c2, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c3, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c3\n 2. \\<And>c1 c2 b c' mds.\n       \\<lbrakk>no_await c1;\n        \\<And>c' mds.\n           \\<langle>c1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        no_await c2;\n        \\<And>c' mds.\n           \\<langle>c2, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>Stmt.If b c1\n                  c2, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'\n 3. \\<And>c b c' mds.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>While b c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'\n 4. \\<And>c' mds.\n       \\<langle>Skip, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 5. \\<And>c' mds.\n       \\<langle>Stop, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 6. \\<And>c m c' mds.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>c@[m], mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'", "apply (case_tac \"c1 = Stop\")"], ["proof (prove)\ngoal (7 subgoals):\n 1. \\<And>c1 c2 c3 mds.\n       \\<lbrakk>no_await c1;\n        \\<And>c' mds.\n           \\<langle>c1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        no_await c2;\n        \\<And>c' mds.\n           \\<langle>c2, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>c1 ;; c2, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c3, mds', mem'\\<rangle>\\<^sub>w;\n        c1 = Stop\\<rbrakk>\n       \\<Longrightarrow> no_await c3\n 2. \\<And>c1 c2 c3 mds.\n       \\<lbrakk>no_await c1;\n        \\<And>c' mds.\n           \\<langle>c1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        no_await c2;\n        \\<And>c' mds.\n           \\<langle>c2, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>c1 ;; c2, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c3, mds', mem'\\<rangle>\\<^sub>w;\n        c1 \\<noteq> Stop\\<rbrakk>\n       \\<Longrightarrow> no_await c3\n 3. \\<And>c1 c2 b c' mds.\n       \\<lbrakk>no_await c1;\n        \\<And>c' mds.\n           \\<langle>c1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        no_await c2;\n        \\<And>c' mds.\n           \\<langle>c2, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>Stmt.If b c1\n                  c2, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'\n 4. \\<And>c b c' mds.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>While b c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'\n 5. \\<And>c' mds.\n       \\<langle>Skip, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 6. \\<And>c' mds.\n       \\<langle>Stop, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 7. \\<And>c m c' mds.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>c@[m], mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'", "apply (simp, frule seq_stop_elim, clarsimp)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>c1 c2 c3 mds.\n       \\<lbrakk>no_await c1;\n        \\<And>c' mds.\n           \\<langle>c1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        no_await c2;\n        \\<And>c' mds.\n           \\<langle>c2, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>c1 ;; c2, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c3, mds', mem'\\<rangle>\\<^sub>w;\n        c1 \\<noteq> Stop\\<rbrakk>\n       \\<Longrightarrow> no_await c3\n 2. \\<And>c1 c2 b c' mds.\n       \\<lbrakk>no_await c1;\n        \\<And>c' mds.\n           \\<langle>c1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        no_await c2;\n        \\<And>c' mds.\n           \\<langle>c2, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>Stmt.If b c1\n                  c2, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'\n 3. \\<And>c b c' mds.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>While b c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'\n 4. \\<And>c' mds.\n       \\<langle>Skip, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 5. \\<And>c' mds.\n       \\<langle>Stop, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 6. \\<And>c m c' mds.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>c@[m], mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'", "using seq_elim no_await.intros"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<langle>?c\\<^sub>1 ;;\n                    ?c\\<^sub>2, ?mds, ?mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>?c', ?mds', ?mem'\\<rangle>\\<^sub>w;\n   ?c\\<^sub>1 \\<noteq> Stop\\<rbrakk>\n  \\<Longrightarrow> \\<exists>c\\<^sub>1'.\n                       \\<langle>?c\\<^sub>1, ?mds, ?mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                       \\<langle>c\\<^sub>1', ?mds', ?mem'\\<rangle>\\<^sub>w \\<and>\n                       ?c' = c\\<^sub>1' ;; ?c\\<^sub>2\n  no_await (?x \\<leftarrow> ?e)\n  \\<lbrakk>no_await ?c1.0; no_await ?c2.0\\<rbrakk>\n  \\<Longrightarrow> no_await (?c1.0 ;; ?c2.0)\n  \\<lbrakk>no_await ?c1.0; no_await ?c2.0\\<rbrakk>\n  \\<Longrightarrow> no_await (Stmt.If ?b ?c1.0 ?c2.0)\n  no_await ?c \\<Longrightarrow> no_await (While ?b ?c)\n  no_await Skip\n  no_await Stop\n  no_await ?c \\<Longrightarrow> no_await (?c@[?m])\n\ngoal (6 subgoals):\n 1. \\<And>c1 c2 c3 mds.\n       \\<lbrakk>no_await c1;\n        \\<And>c' mds.\n           \\<langle>c1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        no_await c2;\n        \\<And>c' mds.\n           \\<langle>c2, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>c1 ;; c2, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c3, mds', mem'\\<rangle>\\<^sub>w;\n        c1 \\<noteq> Stop\\<rbrakk>\n       \\<Longrightarrow> no_await c3\n 2. \\<And>c1 c2 b c' mds.\n       \\<lbrakk>no_await c1;\n        \\<And>c' mds.\n           \\<langle>c1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        no_await c2;\n        \\<And>c' mds.\n           \\<langle>c2, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>Stmt.If b c1\n                  c2, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'\n 3. \\<And>c b c' mds.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>While b c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'\n 4. \\<And>c' mds.\n       \\<langle>Skip, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 5. \\<And>c' mds.\n       \\<langle>Stop, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 6. \\<And>c m c' mds.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>c@[m], mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'", "apply metis"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>c1 c2 b c' mds.\n       \\<lbrakk>no_await c1;\n        \\<And>c' mds.\n           \\<langle>c1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        no_await c2;\n        \\<And>c' mds.\n           \\<langle>c2, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>Stmt.If b c1\n                  c2, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'\n 2. \\<And>c b c' mds.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>While b c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'\n 3. \\<And>c' mds.\n       \\<langle>Skip, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 4. \\<And>c' mds.\n       \\<langle>Stop, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 5. \\<And>c m c' mds.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>c@[m], mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'", "using if_elim no_await.intros"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<langle>Stmt.If ?b ?p\n                     ?q, ?mds, ?mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>?c', ?mds', ?mem'\\<rangle>\\<^sub>w;\n   \\<lbrakk>?c' = ?p; ?mem' = ?mem; ?mds' = ?mds;\n    eval\\<^sub>B ?mem ?b\\<rbrakk>\n   \\<Longrightarrow> ?P;\n   \\<lbrakk>?c' = ?q; ?mem' = ?mem; ?mds' = ?mds;\n    \\<not> eval\\<^sub>B ?mem ?b\\<rbrakk>\n   \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  no_await (?x \\<leftarrow> ?e)\n  \\<lbrakk>no_await ?c1.0; no_await ?c2.0\\<rbrakk>\n  \\<Longrightarrow> no_await (?c1.0 ;; ?c2.0)\n  \\<lbrakk>no_await ?c1.0; no_await ?c2.0\\<rbrakk>\n  \\<Longrightarrow> no_await (Stmt.If ?b ?c1.0 ?c2.0)\n  no_await ?c \\<Longrightarrow> no_await (While ?b ?c)\n  no_await Skip\n  no_await Stop\n  no_await ?c \\<Longrightarrow> no_await (?c@[?m])\n\ngoal (5 subgoals):\n 1. \\<And>c1 c2 b c' mds.\n       \\<lbrakk>no_await c1;\n        \\<And>c' mds.\n           \\<langle>c1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        no_await c2;\n        \\<And>c' mds.\n           \\<langle>c2, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>Stmt.If b c1\n                  c2, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'\n 2. \\<And>c b c' mds.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>While b c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'\n 3. \\<And>c' mds.\n       \\<langle>Skip, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 4. \\<And>c' mds.\n       \\<langle>Stop, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 5. \\<And>c m c' mds.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>c@[m], mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'", "apply blast"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>c b c' mds.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>While b c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'\n 2. \\<And>c' mds.\n       \\<langle>Skip, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 3. \\<And>c' mds.\n       \\<langle>Stop, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 4. \\<And>c m c' mds.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>c@[m], mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'", "apply (frule while_elim, clarsimp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>c b.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>While b c, mds', mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>Stmt.If b (c ;; While b c)\n                  Stop, mds', mem\\<rangle>\\<^sub>w;\n        mem' = mem\\<rbrakk>\n       \\<Longrightarrow> no_await (Stmt.If b (c ;; While b c) Stop)\n 2. \\<And>c' mds.\n       \\<langle>Skip, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 3. \\<And>c' mds.\n       \\<langle>Stop, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 4. \\<And>c m c' mds.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>c@[m], mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'", "apply (rename_tac c b)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>c b.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>While b c, mds', mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>Stmt.If b (c ;; While b c)\n                  Stop, mds', mem\\<rangle>\\<^sub>w;\n        mem' = mem\\<rbrakk>\n       \\<Longrightarrow> no_await (Stmt.If b (c ;; While b c) Stop)\n 2. \\<And>c' mds.\n       \\<langle>Skip, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 3. \\<And>c' mds.\n       \\<langle>Stop, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 4. \\<And>c m c' mds.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>c@[m], mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'", "apply (subgoal_tac \"no_await (While b c)\")"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>c b.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>While b c, mds', mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>Stmt.If b (c ;; While b c)\n                  Stop, mds', mem\\<rangle>\\<^sub>w;\n        mem' = mem; no_await (While b c)\\<rbrakk>\n       \\<Longrightarrow> no_await (Stmt.If b (c ;; While b c) Stop)\n 2. \\<And>c b.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>While b c, mds', mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>Stmt.If b (c ;; While b c)\n                  Stop, mds', mem\\<rangle>\\<^sub>w;\n        mem' = mem\\<rbrakk>\n       \\<Longrightarrow> no_await (While b c)\n 3. \\<And>c' mds.\n       \\<langle>Skip, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 4. \\<And>c' mds.\n       \\<langle>Stop, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 5. \\<And>c m c' mds.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>c@[m], mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'", "apply (subgoal_tac \"no_await (c ;; While b c)\")"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>c b.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>While b c, mds', mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>Stmt.If b (c ;; While b c)\n                  Stop, mds', mem\\<rangle>\\<^sub>w;\n        mem' = mem; no_await (While b c); no_await (c ;; While b c)\\<rbrakk>\n       \\<Longrightarrow> no_await (Stmt.If b (c ;; While b c) Stop)\n 2. \\<And>c b.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>While b c, mds', mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>Stmt.If b (c ;; While b c)\n                  Stop, mds', mem\\<rangle>\\<^sub>w;\n        mem' = mem; no_await (While b c)\\<rbrakk>\n       \\<Longrightarrow> no_await (c ;; While b c)\n 3. \\<And>c b.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>While b c, mds', mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>Stmt.If b (c ;; While b c)\n                  Stop, mds', mem\\<rangle>\\<^sub>w;\n        mem' = mem\\<rbrakk>\n       \\<Longrightarrow> no_await (While b c)\n 4. \\<And>c' mds.\n       \\<langle>Skip, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 5. \\<And>c' mds.\n       \\<langle>Stop, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 6. \\<And>c m c' mds.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>c@[m], mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'", "using no_await.intros"], ["proof (prove)\nusing this:\n  no_await (?x \\<leftarrow> ?e)\n  \\<lbrakk>no_await ?c1.0; no_await ?c2.0\\<rbrakk>\n  \\<Longrightarrow> no_await (?c1.0 ;; ?c2.0)\n  \\<lbrakk>no_await ?c1.0; no_await ?c2.0\\<rbrakk>\n  \\<Longrightarrow> no_await (Stmt.If ?b ?c1.0 ?c2.0)\n  no_await ?c \\<Longrightarrow> no_await (While ?b ?c)\n  no_await Skip\n  no_await Stop\n  no_await ?c \\<Longrightarrow> no_await (?c@[?m])\n\ngoal (6 subgoals):\n 1. \\<And>c b.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>While b c, mds', mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>Stmt.If b (c ;; While b c)\n                  Stop, mds', mem\\<rangle>\\<^sub>w;\n        mem' = mem; no_await (While b c); no_await (c ;; While b c)\\<rbrakk>\n       \\<Longrightarrow> no_await (Stmt.If b (c ;; While b c) Stop)\n 2. \\<And>c b.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>While b c, mds', mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>Stmt.If b (c ;; While b c)\n                  Stop, mds', mem\\<rangle>\\<^sub>w;\n        mem' = mem; no_await (While b c)\\<rbrakk>\n       \\<Longrightarrow> no_await (c ;; While b c)\n 3. \\<And>c b.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>While b c, mds', mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>Stmt.If b (c ;; While b c)\n                  Stop, mds', mem\\<rangle>\\<^sub>w;\n        mem' = mem\\<rbrakk>\n       \\<Longrightarrow> no_await (While b c)\n 4. \\<And>c' mds.\n       \\<langle>Skip, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 5. \\<And>c' mds.\n       \\<langle>Stop, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 6. \\<And>c m c' mds.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>c@[m], mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'", "apply blast"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>c b.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>While b c, mds', mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>Stmt.If b (c ;; While b c)\n                  Stop, mds', mem\\<rangle>\\<^sub>w;\n        mem' = mem; no_await (While b c)\\<rbrakk>\n       \\<Longrightarrow> no_await (c ;; While b c)\n 2. \\<And>c b.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>While b c, mds', mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>Stmt.If b (c ;; While b c)\n                  Stop, mds', mem\\<rangle>\\<^sub>w;\n        mem' = mem\\<rbrakk>\n       \\<Longrightarrow> no_await (While b c)\n 3. \\<And>c' mds.\n       \\<langle>Skip, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 4. \\<And>c' mds.\n       \\<langle>Stop, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 5. \\<And>c m c' mds.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>c@[m], mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'", "using no_await.intros"], ["proof (prove)\nusing this:\n  no_await (?x \\<leftarrow> ?e)\n  \\<lbrakk>no_await ?c1.0; no_await ?c2.0\\<rbrakk>\n  \\<Longrightarrow> no_await (?c1.0 ;; ?c2.0)\n  \\<lbrakk>no_await ?c1.0; no_await ?c2.0\\<rbrakk>\n  \\<Longrightarrow> no_await (Stmt.If ?b ?c1.0 ?c2.0)\n  no_await ?c \\<Longrightarrow> no_await (While ?b ?c)\n  no_await Skip\n  no_await Stop\n  no_await ?c \\<Longrightarrow> no_await (?c@[?m])\n\ngoal (5 subgoals):\n 1. \\<And>c b.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>While b c, mds', mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>Stmt.If b (c ;; While b c)\n                  Stop, mds', mem\\<rangle>\\<^sub>w;\n        mem' = mem; no_await (While b c)\\<rbrakk>\n       \\<Longrightarrow> no_await (c ;; While b c)\n 2. \\<And>c b.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>While b c, mds', mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>Stmt.If b (c ;; While b c)\n                  Stop, mds', mem\\<rangle>\\<^sub>w;\n        mem' = mem\\<rbrakk>\n       \\<Longrightarrow> no_await (While b c)\n 3. \\<And>c' mds.\n       \\<langle>Skip, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 4. \\<And>c' mds.\n       \\<langle>Stop, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 5. \\<And>c m c' mds.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>c@[m], mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'", "apply blast"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>c b.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>While b c, mds', mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>Stmt.If b (c ;; While b c)\n                  Stop, mds', mem\\<rangle>\\<^sub>w;\n        mem' = mem\\<rbrakk>\n       \\<Longrightarrow> no_await (While b c)\n 2. \\<And>c' mds.\n       \\<langle>Skip, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 3. \\<And>c' mds.\n       \\<langle>Stop, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 4. \\<And>c m c' mds.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>c@[m], mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'", "using no_await.intros"], ["proof (prove)\nusing this:\n  no_await (?x \\<leftarrow> ?e)\n  \\<lbrakk>no_await ?c1.0; no_await ?c2.0\\<rbrakk>\n  \\<Longrightarrow> no_await (?c1.0 ;; ?c2.0)\n  \\<lbrakk>no_await ?c1.0; no_await ?c2.0\\<rbrakk>\n  \\<Longrightarrow> no_await (Stmt.If ?b ?c1.0 ?c2.0)\n  no_await ?c \\<Longrightarrow> no_await (While ?b ?c)\n  no_await Skip\n  no_await Stop\n  no_await ?c \\<Longrightarrow> no_await (?c@[?m])\n\ngoal (4 subgoals):\n 1. \\<And>c b.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>While b c, mds', mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>Stmt.If b (c ;; While b c)\n                  Stop, mds', mem\\<rangle>\\<^sub>w;\n        mem' = mem\\<rbrakk>\n       \\<Longrightarrow> no_await (While b c)\n 2. \\<And>c' mds.\n       \\<langle>Skip, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 3. \\<And>c' mds.\n       \\<langle>Stop, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 4. \\<And>c m c' mds.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>c@[m], mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'", "apply blast"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>c' mds.\n       \\<langle>Skip, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 2. \\<And>c' mds.\n       \\<langle>Stop, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 3. \\<And>c m c' mds.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>c@[m], mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'", "using no_await.intros skip_elim"], ["proof (prove)\nusing this:\n  no_await (?x \\<leftarrow> ?e)\n  \\<lbrakk>no_await ?c1.0; no_await ?c2.0\\<rbrakk>\n  \\<Longrightarrow> no_await (?c1.0 ;; ?c2.0)\n  \\<lbrakk>no_await ?c1.0; no_await ?c2.0\\<rbrakk>\n  \\<Longrightarrow> no_await (Stmt.If ?b ?c1.0 ?c2.0)\n  no_await ?c \\<Longrightarrow> no_await (While ?b ?c)\n  no_await Skip\n  no_await Stop\n  no_await ?c \\<Longrightarrow> no_await (?c@[?m])\n  \\<langle>Skip, ?mds, ?mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n  \\<langle>?c', ?mds', ?mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n  ?c' = Stop \\<and> ?mds = ?mds' \\<and> ?mem = ?mem'\n\ngoal (3 subgoals):\n 1. \\<And>c' mds.\n       \\<langle>Skip, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 2. \\<And>c' mds.\n       \\<langle>Stop, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 3. \\<And>c m c' mds.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>c@[m], mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'", "apply fast"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c' mds.\n       \\<langle>Stop, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 2. \\<And>c m c' mds.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>c@[m], mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'", "using no_await.intros stop_no_eval"], ["proof (prove)\nusing this:\n  no_await (?x \\<leftarrow> ?e)\n  \\<lbrakk>no_await ?c1.0; no_await ?c2.0\\<rbrakk>\n  \\<Longrightarrow> no_await (?c1.0 ;; ?c2.0)\n  \\<lbrakk>no_await ?c1.0; no_await ?c2.0\\<rbrakk>\n  \\<Longrightarrow> no_await (Stmt.If ?b ?c1.0 ?c2.0)\n  no_await ?c \\<Longrightarrow> no_await (While ?b ?c)\n  no_await Skip\n  no_await Stop\n  no_await ?c \\<Longrightarrow> no_await (?c@[?m])\n  (\\<langle>Stop, ?mds, ?mem\\<rangle>\\<^sub>w,\n   \\<langle>?c', ?mds', ?mem'\\<rangle>\\<^sub>w)\n  \\<notin> eval\\<^sub>w\n\ngoal (2 subgoals):\n 1. \\<And>c' mds.\n       \\<langle>Stop, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n       \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n       no_await c'\n 2. \\<And>c m c' mds.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>c@[m], mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'", "apply fast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c m c' mds.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>c@[m], mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'", "using no_await.intros upd_elim"], ["proof (prove)\nusing this:\n  no_await (?x \\<leftarrow> ?e)\n  \\<lbrakk>no_await ?c1.0; no_await ?c2.0\\<rbrakk>\n  \\<Longrightarrow> no_await (?c1.0 ;; ?c2.0)\n  \\<lbrakk>no_await ?c1.0; no_await ?c2.0\\<rbrakk>\n  \\<Longrightarrow> no_await (Stmt.If ?b ?c1.0 ?c2.0)\n  no_await ?c \\<Longrightarrow> no_await (While ?b ?c)\n  no_await Skip\n  no_await Stop\n  no_await ?c \\<Longrightarrow> no_await (?c@[?m])\n  \\<langle>?c@[?upd], ?mds, ?mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n  \\<langle>?c', ?mds', ?mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n  \\<langle>?c, update_modes ?upd\n                ?mds, ?mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n  \\<langle>?c', ?mds', ?mem'\\<rangle>\\<^sub>w\n\ngoal (1 subgoal):\n 1. \\<And>c m c' mds.\n       \\<lbrakk>no_await c;\n        \\<And>c' mds.\n           \\<langle>c, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n           \\<langle>c', mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n           no_await c';\n        \\<langle>c@[m], mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> no_await c'", "by fast"], ["", "lemma no_await_no_await[elim]: \"\\<lbrakk> no_await c \\<rbrakk> \\<Longrightarrow> c \\<noteq> Await b c'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. no_await c \\<Longrightarrow> c \\<noteq> Await b c'", "using no_await.cases Stmt.distinct"], ["proof (prove)\nusing this:\n  \\<lbrakk>no_await ?a;\n   \\<And>x e. ?a = x \\<leftarrow> e \\<Longrightarrow> ?P;\n   \\<And>c1 c2.\n      \\<lbrakk>?a = c1 ;; c2; no_await c1; no_await c2\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>c1 c2 b.\n      \\<lbrakk>?a = Stmt.If b c1 c2; no_await c1; no_await c2\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>c b.\n      \\<lbrakk>?a = While b c; no_await c\\<rbrakk> \\<Longrightarrow> ?P;\n   ?a = Skip \\<Longrightarrow> ?P; ?a = Stop \\<Longrightarrow> ?P;\n   \\<And>c m.\n      \\<lbrakk>?a = c@[m]; no_await c\\<rbrakk> \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  ?x11.0 \\<leftarrow> ?x12.0 \\<noteq> Skip\n  Skip \\<noteq> ?x11.0 \\<leftarrow> ?x12.0\n  ?x11.0 \\<leftarrow> ?x12.0 \\<noteq> ?x31.0@[?x32.0]\n  ?x31.0@[?x32.0] \\<noteq> ?x11.0 \\<leftarrow> ?x12.0\n  ?x11.0 \\<leftarrow> ?x12.0 \\<noteq> ?x41.0 ;; ?x42.0\n  ?x41.0 ;; ?x42.0 \\<noteq> ?x11.0 \\<leftarrow> ?x12.0\n  ?x11.0 \\<leftarrow> ?x12.0 \\<noteq> Stmt.If ?x51.0 ?x52.0 ?x53.0\n  Stmt.If ?x51.0 ?x52.0 ?x53.0 \\<noteq> ?x11.0 \\<leftarrow> ?x12.0\n  ?x11.0 \\<leftarrow> ?x12.0 \\<noteq> While ?x61.0 ?x62.0\n  While ?x61.0 ?x62.0 \\<noteq> ?x11.0 \\<leftarrow> ?x12.0\n  ?x11.0 \\<leftarrow> ?x12.0 \\<noteq> Await ?x71.0 ?x72.0\n  Await ?x71.0 ?x72.0 \\<noteq> ?x11.0 \\<leftarrow> ?x12.0\n  ?x11.0 \\<leftarrow> ?x12.0 \\<noteq> Stop\n  Stop \\<noteq> ?x11.0 \\<leftarrow> ?x12.0\n  Skip \\<noteq> ?x31.0@[?x32.0]\n  ?x31.0@[?x32.0] \\<noteq> Skip\n  Skip \\<noteq> ?x41.0 ;; ?x42.0\n  ?x41.0 ;; ?x42.0 \\<noteq> Skip\n  Skip \\<noteq> Stmt.If ?x51.0 ?x52.0 ?x53.0\n  Stmt.If ?x51.0 ?x52.0 ?x53.0 \\<noteq> Skip\n  Skip \\<noteq> While ?x61.0 ?x62.0\n  While ?x61.0 ?x62.0 \\<noteq> Skip\n  Skip \\<noteq> Await ?x71.0 ?x72.0\n  Await ?x71.0 ?x72.0 \\<noteq> Skip\n  Skip \\<noteq> Stop\n  Stop \\<noteq> Skip\n  ?x31.0@[?x32.0] \\<noteq> ?x41.0 ;; ?x42.0\n  ?x41.0 ;; ?x42.0 \\<noteq> ?x31.0@[?x32.0]\n  ?x31.0@[?x32.0] \\<noteq> Stmt.If ?x51.0 ?x52.0 ?x53.0\n  Stmt.If ?x51.0 ?x52.0 ?x53.0 \\<noteq> ?x31.0@[?x32.0]\n  ?x31.0@[?x32.0] \\<noteq> While ?x61.0 ?x62.0\n  While ?x61.0 ?x62.0 \\<noteq> ?x31.0@[?x32.0]\n  ?x31.0@[?x32.0] \\<noteq> Await ?x71.0 ?x72.0\n  Await ?x71.0 ?x72.0 \\<noteq> ?x31.0@[?x32.0]\n  ?x31.0@[?x32.0] \\<noteq> Stop\n  Stop \\<noteq> ?x31.0@[?x32.0]\n  ?x41.0 ;; ?x42.0 \\<noteq> Stmt.If ?x51.0 ?x52.0 ?x53.0\n  Stmt.If ?x51.0 ?x52.0 ?x53.0 \\<noteq> ?x41.0 ;; ?x42.0\n  ?x41.0 ;; ?x42.0 \\<noteq> While ?x61.0 ?x62.0\n  While ?x61.0 ?x62.0 \\<noteq> ?x41.0 ;; ?x42.0\n  ?x41.0 ;; ?x42.0 \\<noteq> Await ?x71.0 ?x72.0\n  Await ?x71.0 ?x72.0 \\<noteq> ?x41.0 ;; ?x42.0\n  ?x41.0 ;; ?x42.0 \\<noteq> Stop\n  Stop \\<noteq> ?x41.0 ;; ?x42.0\n  Stmt.If ?x51.0 ?x52.0 ?x53.0 \\<noteq> While ?x61.0 ?x62.0\n  While ?x61.0 ?x62.0 \\<noteq> Stmt.If ?x51.0 ?x52.0 ?x53.0\n  Stmt.If ?x51.0 ?x52.0 ?x53.0 \\<noteq> Await ?x71.0 ?x72.0\n  Await ?x71.0 ?x72.0 \\<noteq> Stmt.If ?x51.0 ?x52.0 ?x53.0\n  Stmt.If ?x51.0 ?x52.0 ?x53.0 \\<noteq> Stop\n  Stop \\<noteq> Stmt.If ?x51.0 ?x52.0 ?x53.0\n  While ?x61.0 ?x62.0 \\<noteq> Await ?x71.0 ?x72.0\n  Await ?x71.0 ?x72.0 \\<noteq> While ?x61.0 ?x62.0\n  While ?x61.0 ?x62.0 \\<noteq> Stop\n  Stop \\<noteq> While ?x61.0 ?x62.0\n  Await ?x71.0 ?x72.0 \\<noteq> Stop\n  Stop \\<noteq> Await ?x71.0 ?x72.0\n\ngoal (1 subgoal):\n 1. no_await c \\<Longrightarrow> c \\<noteq> Await b c'", "by fast"], ["", "lemma no_await_trancl_impl: \n  \"\\<lbrakk>ctx \\<leadsto>\\<^sub>w\\<^sup>+ ctx'\\<rbrakk> \\<Longrightarrow> no_await (fst (fst ctx)) \\<longrightarrow> no_await (fst (fst ctx'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ctx \\<leadsto>\\<^sub>w\\<^sup>+ ctx' \\<Longrightarrow>\n    no_await (fst (fst ctx)) \\<longrightarrow> no_await (fst (fst ctx'))", "apply (erule trancl.induct, clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b ba aa bb bc.\n       \\<lbrakk>\\<langle>a, b, ba\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                \\<langle>aa, bb, bc\\<rangle>\\<^sub>w;\n        no_await a\\<rbrakk>\n       \\<Longrightarrow> no_await aa\n 2. \\<And>a b c.\n       \\<lbrakk>a \\<leadsto>\\<^sub>w\\<^sup>+ b;\n        no_await (fst (fst a)) \\<longrightarrow> no_await (fst (fst b));\n        b \\<leadsto>\\<^sub>w c\\<rbrakk>\n       \\<Longrightarrow> no_await (fst (fst a)) \\<longrightarrow>\n                         no_await (fst (fst c))", "using no_await_trans"], ["proof (prove)\nusing this:\n  \\<lbrakk>no_await ?c;\n   \\<langle>?c, ?mds, ?mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n   \\<langle>?c', ?mds', ?mem'\\<rangle>\\<^sub>w\\<rbrakk>\n  \\<Longrightarrow> no_await ?c'\n\ngoal (2 subgoals):\n 1. \\<And>a b ba aa bb bc.\n       \\<lbrakk>\\<langle>a, b, ba\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n                \\<langle>aa, bb, bc\\<rangle>\\<^sub>w;\n        no_await a\\<rbrakk>\n       \\<Longrightarrow> no_await aa\n 2. \\<And>a b c.\n       \\<lbrakk>a \\<leadsto>\\<^sub>w\\<^sup>+ b;\n        no_await (fst (fst a)) \\<longrightarrow> no_await (fst (fst b));\n        b \\<leadsto>\\<^sub>w c\\<rbrakk>\n       \\<Longrightarrow> no_await (fst (fst a)) \\<longrightarrow>\n                         no_await (fst (fst c))", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b c.\n       \\<lbrakk>a \\<leadsto>\\<^sub>w\\<^sup>+ b;\n        no_await (fst (fst a)) \\<longrightarrow> no_await (fst (fst b));\n        b \\<leadsto>\\<^sub>w c\\<rbrakk>\n       \\<Longrightarrow> no_await (fst (fst a)) \\<longrightarrow>\n                         no_await (fst (fst c))", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b ba aa bb bc ab bd be.\n       \\<lbrakk>\\<langle>a, b, ba\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>aa, bb, bc\\<rangle>\\<^sub>w;\n        \\<langle>aa, bb, bc\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>ab, bd, be\\<rangle>\\<^sub>w;\n        no_await a; no_await aa\\<rbrakk>\n       \\<Longrightarrow> no_await ab", "using no_await_trans"], ["proof (prove)\nusing this:\n  \\<lbrakk>no_await ?c;\n   \\<langle>?c, ?mds, ?mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n   \\<langle>?c', ?mds', ?mem'\\<rangle>\\<^sub>w\\<rbrakk>\n  \\<Longrightarrow> no_await ?c'\n\ngoal (1 subgoal):\n 1. \\<And>a b ba aa bb bc ab bd be.\n       \\<lbrakk>\\<langle>a, b, ba\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>aa, bb, bc\\<rangle>\\<^sub>w;\n        \\<langle>aa, bb, bc\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>ab, bd, be\\<rangle>\\<^sub>w;\n        no_await a; no_await aa\\<rbrakk>\n       \\<Longrightarrow> no_await ab", "by blast"], ["", "lemma no_await_trancl: \n  \"\\<lbrakk>ctx \\<leadsto>\\<^sub>w\\<^sup>+ ctx'; no_await (fst (fst ctx))\\<rbrakk> \\<Longrightarrow> no_await (fst (fst ctx'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>ctx \\<leadsto>\\<^sub>w\\<^sup>+ ctx';\n     no_await (fst (fst ctx))\\<rbrakk>\n    \\<Longrightarrow> no_await (fst (fst ctx'))", "using no_await_trancl_impl"], ["proof (prove)\nusing this:\n  ?ctx \\<leadsto>\\<^sub>w\\<^sup>+ ?ctx' \\<Longrightarrow>\n  no_await (fst (fst ?ctx)) \\<longrightarrow> no_await (fst (fst ?ctx'))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>ctx \\<leadsto>\\<^sub>w\\<^sup>+ ctx';\n     no_await (fst (fst ctx))\\<rbrakk>\n    \\<Longrightarrow> no_await (fst (fst ctx'))", "by blast"], ["", "lemma await_elim: \n  \"\\<lbrakk>\\<langle>Await b c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w \\<langle>c\\<^sub>2, mds', mem'\\<rangle>\\<^sub>w\\<rbrakk> \\<Longrightarrow> \n    eval\\<^sub>B mem b \\<and> no_await c\\<^sub>1 \\<and> is_final c\\<^sub>2  \\<and>\n    \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>c\\<^sub>2, mds', mem'\\<rangle>\\<^sub>w\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Await b c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n    \\<langle>c\\<^sub>2, mds', mem'\\<rangle>\\<^sub>w \\<Longrightarrow>\n    eval\\<^sub>B mem b \\<and>\n    no_await c\\<^sub>1 \\<and>\n    is_final c\\<^sub>2 \\<and>\n    \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>c\\<^sub>2, mds', mem'\\<rangle>\\<^sub>w", "apply (erule \"eval\\<^sub>w.cases\"; clarsimp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c c' E.\n       \\<lbrakk>Await b c\\<^sub>1 = cxt_to_stmt E c;\n        (c, mem) \\<leadsto>\\<^sub>s (c', mem');\n        c\\<^sub>2 = cxt_to_stmt E c'; mds' = mds\\<rbrakk>\n       \\<Longrightarrow> eval\\<^sub>B mem b \\<and>\n                         no_await c\\<^sub>1 \\<and>\n                         is_final (cxt_to_stmt E c') \\<and>\n                         \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>cxt_to_stmt\n                                E c', mds, mem'\\<rangle>\\<^sub>w\n 2. \\<And>c mu c' E.\n       \\<lbrakk>Await b c\\<^sub>1 = cxt_to_stmt E (c@[mu]);\n        c\\<^sub>2 = cxt_to_stmt E c';\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> eval\\<^sub>B mem b \\<and>\n                         no_await c\\<^sub>1 \\<and>\n                         is_final (cxt_to_stmt E c') \\<and>\n                         \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>cxt_to_stmt\n                                E c', mds', mem'\\<rangle>\\<^sub>w", "apply (subgoal_tac \"cxt_to_stmt E c = Await b c\\<^sub>1\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>c c' E.\n       \\<lbrakk>Await b c\\<^sub>1 = cxt_to_stmt E c;\n        (c, mem) \\<leadsto>\\<^sub>s (c', mem');\n        c\\<^sub>2 = cxt_to_stmt E c'; mds' = mds;\n        cxt_to_stmt E c = Await b c\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> eval\\<^sub>B mem b \\<and>\n                         no_await c\\<^sub>1 \\<and>\n                         is_final (cxt_to_stmt E c') \\<and>\n                         \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>cxt_to_stmt\n                                E c', mds, mem'\\<rangle>\\<^sub>w\n 2. \\<And>c c' E.\n       \\<lbrakk>Await b c\\<^sub>1 = cxt_to_stmt E c;\n        (c, mem) \\<leadsto>\\<^sub>s (c', mem');\n        c\\<^sub>2 = cxt_to_stmt E c'; mds' = mds\\<rbrakk>\n       \\<Longrightarrow> cxt_to_stmt E c = Await b c\\<^sub>1\n 3. \\<And>c mu c' E.\n       \\<lbrakk>Await b c\\<^sub>1 = cxt_to_stmt E (c@[mu]);\n        c\\<^sub>2 = cxt_to_stmt E c';\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> eval\\<^sub>B mem b \\<and>\n                         no_await c\\<^sub>1 \\<and>\n                         is_final (cxt_to_stmt E c') \\<and>\n                         \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>cxt_to_stmt\n                                E c', mds', mem'\\<rangle>\\<^sub>w", "apply (drule cxt_inv_await)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>c c' E.\n       \\<lbrakk>Await b c\\<^sub>1 = cxt_to_stmt E c;\n        (c, mem) \\<leadsto>\\<^sub>s (c', mem');\n        c\\<^sub>2 = cxt_to_stmt E c'; mds' = mds;\n        c = Await b c\\<^sub>1 \\<and> E = []\\<rbrakk>\n       \\<Longrightarrow> eval\\<^sub>B mem b \\<and>\n                         no_await c\\<^sub>1 \\<and>\n                         is_final (cxt_to_stmt E c') \\<and>\n                         \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>cxt_to_stmt\n                                E c', mds, mem'\\<rangle>\\<^sub>w\n 2. \\<And>c c' E.\n       \\<lbrakk>Await b c\\<^sub>1 = cxt_to_stmt E c;\n        (c, mem) \\<leadsto>\\<^sub>s (c', mem');\n        c\\<^sub>2 = cxt_to_stmt E c'; mds' = mds\\<rbrakk>\n       \\<Longrightarrow> cxt_to_stmt E c = Await b c\\<^sub>1\n 3. \\<And>c mu c' E.\n       \\<lbrakk>Await b c\\<^sub>1 = cxt_to_stmt E (c@[mu]);\n        c\\<^sub>2 = cxt_to_stmt E c';\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> eval\\<^sub>B mem b \\<and>\n                         no_await c\\<^sub>1 \\<and>\n                         is_final (cxt_to_stmt E c') \\<and>\n                         \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>cxt_to_stmt\n                                E c', mds', mem'\\<rangle>\\<^sub>w", "using \"eval\\<^sub>w_simple.cases\""], ["proof (prove)\nusing this:\n  \\<lbrakk>(?a1.0, ?a2.0) \\<leadsto>\\<^sub>s (?a3.0, ?a4.0);\n   \\<And>x e mem.\n      \\<lbrakk>?a1.0 = x \\<leftarrow> e; ?a2.0 = mem; ?a3.0 = Stop;\n       ?a4.0 = mem(x := eval\\<^sub>A mem e)\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>mem.\n      \\<lbrakk>?a1.0 = Skip; ?a2.0 = mem; ?a3.0 = Stop; ?a4.0 = mem\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>c mem.\n      \\<lbrakk>?a1.0 = Stop ;; c; ?a2.0 = mem; ?a3.0 = c;\n       ?a4.0 = mem\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>mem b t e.\n      \\<lbrakk>?a1.0 = Stmt.If b t e; ?a2.0 = mem; ?a3.0 = t; ?a4.0 = mem;\n       eval\\<^sub>B mem b\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>mem b t e.\n      \\<lbrakk>?a1.0 = Stmt.If b t e; ?a2.0 = mem; ?a3.0 = e; ?a4.0 = mem;\n       \\<not> eval\\<^sub>B mem b\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>b c mem.\n      \\<lbrakk>?a1.0 = While b c; ?a2.0 = mem;\n       ?a3.0 = Stmt.If b (c ;; While b c) Stop; ?a4.0 = mem\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (3 subgoals):\n 1. \\<And>c c' E.\n       \\<lbrakk>Await b c\\<^sub>1 = cxt_to_stmt E c;\n        (c, mem) \\<leadsto>\\<^sub>s (c', mem');\n        c\\<^sub>2 = cxt_to_stmt E c'; mds' = mds;\n        c = Await b c\\<^sub>1 \\<and> E = []\\<rbrakk>\n       \\<Longrightarrow> eval\\<^sub>B mem b \\<and>\n                         no_await c\\<^sub>1 \\<and>\n                         is_final (cxt_to_stmt E c') \\<and>\n                         \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>cxt_to_stmt\n                                E c', mds, mem'\\<rangle>\\<^sub>w\n 2. \\<And>c c' E.\n       \\<lbrakk>Await b c\\<^sub>1 = cxt_to_stmt E c;\n        (c, mem) \\<leadsto>\\<^sub>s (c', mem');\n        c\\<^sub>2 = cxt_to_stmt E c'; mds' = mds\\<rbrakk>\n       \\<Longrightarrow> cxt_to_stmt E c = Await b c\\<^sub>1\n 3. \\<And>c mu c' E.\n       \\<lbrakk>Await b c\\<^sub>1 = cxt_to_stmt E (c@[mu]);\n        c\\<^sub>2 = cxt_to_stmt E c';\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> eval\\<^sub>B mem b \\<and>\n                         no_await c\\<^sub>1 \\<and>\n                         is_final (cxt_to_stmt E c') \\<and>\n                         \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>cxt_to_stmt\n                                E c', mds', mem'\\<rangle>\\<^sub>w", "apply force"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c c' E.\n       \\<lbrakk>Await b c\\<^sub>1 = cxt_to_stmt E c;\n        (c, mem) \\<leadsto>\\<^sub>s (c', mem');\n        c\\<^sub>2 = cxt_to_stmt E c'; mds' = mds\\<rbrakk>\n       \\<Longrightarrow> cxt_to_stmt E c = Await b c\\<^sub>1\n 2. \\<And>c mu c' E.\n       \\<lbrakk>Await b c\\<^sub>1 = cxt_to_stmt E (c@[mu]);\n        c\\<^sub>2 = cxt_to_stmt E c';\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> eval\\<^sub>B mem b \\<and>\n                         no_await c\\<^sub>1 \\<and>\n                         is_final (cxt_to_stmt E c') \\<and>\n                         \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>cxt_to_stmt\n                                E c', mds', mem'\\<rangle>\\<^sub>w", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c mu c' E.\n       \\<lbrakk>Await b c\\<^sub>1 = cxt_to_stmt E (c@[mu]);\n        c\\<^sub>2 = cxt_to_stmt E c';\n        \\<langle>c, update_modes mu\n                     mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\n        \\<langle>c', mds', mem'\\<rangle>\\<^sub>w\\<rbrakk>\n       \\<Longrightarrow> eval\\<^sub>B mem b \\<and>\n                         no_await c\\<^sub>1 \\<and>\n                         is_final (cxt_to_stmt E c') \\<and>\n                         \\<langle>c\\<^sub>1, mds, mem\\<rangle>\\<^sub>w \\<leadsto>\\<^sub>w\\<^sup>+ \\<langle>cxt_to_stmt\n                                E c', mds', mem'\\<rangle>\\<^sub>w", "by (metis Stmt.distinct(33) cxt_inv_await)"], ["", "end"], ["", "end"]]}