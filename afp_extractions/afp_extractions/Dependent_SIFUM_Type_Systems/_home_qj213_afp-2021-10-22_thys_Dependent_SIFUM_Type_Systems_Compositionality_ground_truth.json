{"file_name": "/home/qj213/afp-2021-10-22/thys/Dependent_SIFUM_Type_Systems/Compositionality.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Dependent_SIFUM_Type_Systems", "problem_names": ["lemma differing_finite: \"finite (differing_vars mem\\<^sub>1 mem\\<^sub>2)\"", "lemma differing_lists_finite: \"finite (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i)\"", "lemma makes_compatible_intro [intro]:\n  \"\\<lbrakk> length cms\\<^sub>1 = length cms\\<^sub>2 \\<and> length cms\\<^sub>1 = length mems;\n     (\\<And> i \\<sigma>. \\<lbrakk> i < length cms\\<^sub>1; dom \\<sigma> = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i \\<rbrakk> \\<Longrightarrow>\n          (cms\\<^sub>1 ! i, (fst (mems ! i)) [\\<mapsto> \\<sigma>]) \\<approx> (cms\\<^sub>2 ! i, (snd (mems ! i)) [\\<mapsto> \\<sigma>]));\n     (\\<And> i x. \\<lbrakk> i < length cms\\<^sub>1; mem\\<^sub>1 x = mem\\<^sub>2 x \\<or> dma mem\\<^sub>1 x = High \\<or> x \\<in> \\<C> \\<rbrakk> \\<Longrightarrow> \n          x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i);\n     (length cms\\<^sub>1 = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2) \\<or>\n     (\\<forall> x. \\<exists> i. i < length cms\\<^sub>1 \\<and> x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i) \\<rbrakk> \\<Longrightarrow>\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2) mems\"", "lemma compat_low:\n  \"\\<lbrakk> makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2) mems;\n     i < length cms\\<^sub>1;\n     x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i \\<rbrakk> \\<Longrightarrow> dma mem\\<^sub>1 x = Low\"", "lemma compat_different:\n  \"\\<lbrakk> makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2) mems;\n     i < length cms\\<^sub>1;\n     x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i \\<rbrakk> \\<Longrightarrow> mem\\<^sub>1 x \\<noteq> mem\\<^sub>2 x \\<and> dma mem\\<^sub>1 x = Low \\<and> x \\<notin> \\<C>\"", "lemma sound_modes_no_read :\n  \"\\<lbrakk> sound_mode_use (cms, mem); x \\<in> (map snd cms ! i) GuarNoReadOrWrite; i < length cms \\<rbrakk> \\<Longrightarrow>\n  doesnt_read_or_modify (fst (cms ! i)) x\"", "lemma differing_vars_neg: \"x \\<notin> differing_vars_lists mem1 mem2 mems i \\<Longrightarrow>\n  (fst (mems ! i) x = mem1 x \\<and> snd (mems ! i) x = mem2 x)\"", "lemma differing_vars_neg_intro:\n  \"\\<lbrakk> mem\\<^sub>1 x = fst (mems ! i) x;\n  mem\\<^sub>2 x = snd (mems ! i) x \\<rbrakk> \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\"", "lemma differing_vars_elim [elim]:\n  \"x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i \\<Longrightarrow>\n  (fst (mems ! i) x \\<noteq> mem\\<^sub>1 x) \\<or> (snd (mems ! i) x \\<noteq> mem\\<^sub>2 x)\"", "lemma makes_compatible_dma_eq:\n  assumes compat: \"makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2) mems\"\n  assumes ile: \"i < length cms\\<^sub>1\"\n  assumes dom\\<sigma>: \"dom \\<sigma> = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\"\n  shows \"dma ((fst (mems ! i)) [\\<mapsto> \\<sigma>]) = dma mem\\<^sub>1\"", "lemma compat_different_vars:\n  \"\\<lbrakk> fst (mems ! i) x = snd (mems ! i) x;\n     x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i \\<rbrakk> \\<Longrightarrow>\n    mem\\<^sub>1 x = mem\\<^sub>2 x\"", "lemma differing_vars_subst [rule_format]:\n  assumes dom\\<sigma>: \"dom \\<sigma> \\<supseteq> differing_vars mem\\<^sub>1 mem\\<^sub>2\"\n  shows \"mem\\<^sub>1 [\\<mapsto> \\<sigma>] = mem\\<^sub>2 [\\<mapsto> \\<sigma>]\"", "lemma mm_equiv_low_eq:\n  \"\\<lbrakk> \\<langle> c\\<^sub>1, mds, mem\\<^sub>1 \\<rangle> \\<approx> \\<langle> c\\<^sub>2, mds, mem\\<^sub>2 \\<rangle> \\<rbrakk> \\<Longrightarrow> mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2\"", "lemma globally_sound_modes_compatible:\n  \"\\<lbrakk> globally_sound_mode_use (cms, mem) \\<rbrakk> \\<Longrightarrow> compatible_modes (map snd cms)\"", "lemma compatible_different_no_read :\n  assumes sound_modes: \"sound_mode_use (cms\\<^sub>1, mem\\<^sub>1)\"\n                       \"sound_mode_use (cms\\<^sub>2, mem\\<^sub>2)\"\n  assumes compat: \"makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2) mems\"\n  assumes modes_eq: \"map snd cms\\<^sub>1 = map snd cms\\<^sub>2\"\n  assumes ile: \"i < length cms\\<^sub>1\"\n  assumes x: \"x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\"\n  shows \"doesnt_read_or_modify (fst (cms\\<^sub>1 ! i)) x \\<and> doesnt_read_or_modify (fst (cms\\<^sub>2 ! i)) x\"", "lemma subst_overrides: \"dom \\<sigma> = dom \\<tau> \\<Longrightarrow> mem [\\<mapsto> \\<tau>] [\\<mapsto> \\<sigma>] = mem [\\<mapsto> \\<sigma>]\"", "lemma dom_restrict_total: \"dom (to_partial f |` X) = X\"", "lemma change_respecting_doesnt_modify':\n  assumes eval: \"(cms, mem) \\<leadsto> (cms', mem')\"\n  assumes cr: \"\\<forall> f. dom f = Y \\<longrightarrow> (cms, mem [\\<mapsto> f]) \\<leadsto> (cms', mem' [\\<mapsto> f])\"\n  assumes x_in_dom: \"x \\<in> Y\"\n  shows \"mem x = mem' x\"", "lemma change_respecting_subset':\n  assumes step: \"(cms, mem) \\<leadsto> (cms', mem')\"\n  assumes noread: \"(\\<forall> \\<sigma>. dom \\<sigma> = X \\<longrightarrow> (cms, mem [\\<mapsto> \\<sigma>]) \\<leadsto> (cms', mem' [\\<mapsto> \\<sigma>]))\"\n  assumes dom_subset: \"dom \\<sigma> \\<subseteq> X\"\n  shows \"(cms, mem [\\<mapsto> \\<sigma>]) \\<leadsto> (cms', mem' [\\<mapsto> \\<sigma>])\"", "lemma change_respecting_subst:\n  \"change_respecting (cms, mem) (cms', mem') X \\<Longrightarrow>\n       (\\<forall> \\<sigma>. dom \\<sigma> = X \\<longrightarrow> (cms, mem [\\<mapsto> \\<sigma>]) \\<leadsto> (cms', mem' [\\<mapsto> \\<sigma>]))\"", "lemma change_respecting_intro [iff]:\n  \"\\<lbrakk> \\<langle> c, mds, mem \\<rangle> \\<leadsto> \\<langle> c', mds', mem' \\<rangle>;\n     \\<And> f. dom f = vars_and_\\<C> X \\<Longrightarrow>\n           (\\<langle> c, mds, mem [\\<mapsto> f] \\<rangle> \\<leadsto> \\<langle> c', mds', mem' [\\<mapsto> f] \\<rangle>) \\<rbrakk>\n  \\<Longrightarrow> change_respecting \\<langle>c, mds, mem\\<rangle> \\<langle>c', mds', mem'\\<rangle> X\"", "lemma vars_\\<C>_mono:\n  \"X \\<subseteq> Y \\<Longrightarrow> vars_\\<C> X \\<subseteq> vars_\\<C> Y\"", "lemma vars_\\<C>_Un:\n  \"vars_\\<C> (X \\<union> Y) = (vars_\\<C> X \\<union> vars_\\<C> Y)\"", "lemma vars_\\<C>_insert:\n  \"vars_\\<C> (insert x Y) = (vars_\\<C> {x}) \\<union> (vars_\\<C> Y)\"", "lemma vars_\\<C>_empty[simp]:\n  \"vars_\\<C> {} = {}\"", "lemma \\<C>_vars_of_\\<C>_vars_empty:\n  \"x \\<in> \\<C>_vars y \\<Longrightarrow> \\<C>_vars x = {}\"", "lemma vars_and_\\<C>_mono:\n  \"X \\<subseteq> X' \\<Longrightarrow> vars_and_\\<C> X \\<subseteq> vars_and_\\<C> X'\"", "lemma \\<C>_vars_finite[simp]:\n  \"finite (\\<C>_vars x)\"", "lemma finite_dom:\n  \"finite (dom (\\<sigma>::'Var \\<Rightarrow> 'Val option))\"", "lemma doesnt_read_or_modify_subst: \n  assumes noread: \"doesnt_read_or_modify c x\"\n  assumes step: \"\\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\"\n  assumes subset: \"X \\<subseteq> {x} \\<union> \\<C>_vars x\"\n  shows \"\\<And> \\<sigma>. dom \\<sigma> = X \\<Longrightarrow> \\<langle>c, mds, mem[\\<mapsto> \\<sigma>]\\<rangle> \\<leadsto> \\<langle>c', mds', mem'[\\<mapsto> \\<sigma>]\\<rangle>\"", "lemma subst_restrict_twice:\n  \"dom \\<sigma> = A \\<union> B \\<Longrightarrow>\n   mem [\\<mapsto> (\\<sigma> |` A)] [\\<mapsto> (\\<sigma> |` B)] = mem [\\<mapsto> \\<sigma>]\"", "lemma noread_exists_change_respecting:\n  assumes fin: \"finite (X :: 'Var set)\"\n  assumes eval: \"\\<langle> c, mds, mem \\<rangle> \\<leadsto> \\<langle> c', mds', mem' \\<rangle>\"\n  assumes noread: \"\\<forall> x \\<in> X. doesnt_read_or_modify c x\"\n  shows \"change_respecting \\<langle>c, mds, mem\\<rangle> \\<langle>c', mds', mem'\\<rangle> X\"", "lemma update_nth_eq:\n  \"\\<lbrakk> xs = ys; n < length xs \\<rbrakk> \\<Longrightarrow> xs = ys [n := xs ! n]\"", "lemma mm_equiv_step:\n  assumes bisim: \"(cms\\<^sub>1, mem\\<^sub>1) \\<approx> (cms\\<^sub>2, mem\\<^sub>2)\"\n  assumes modes_eq: \"snd cms\\<^sub>1 = snd cms\\<^sub>2\"\n  assumes step: \"(cms\\<^sub>1, mem\\<^sub>1) \\<leadsto> (cms\\<^sub>1', mem\\<^sub>1')\"\n  shows \"\\<exists> c\\<^sub>2' mem\\<^sub>2'. (cms\\<^sub>2, mem\\<^sub>2) \\<leadsto> \\<langle> c\\<^sub>2', snd cms\\<^sub>1', mem\\<^sub>2' \\<rangle> \\<and>\n  (cms\\<^sub>1', mem\\<^sub>1') \\<approx> \\<langle> c\\<^sub>2', snd cms\\<^sub>1', mem\\<^sub>2' \\<rangle>\"", "lemma change_respecting_doesnt_modify:\n  assumes cr: \"change_respecting (cms, mem) (cms', mem') X\"\n  assumes eval: \"(cms, mem) \\<leadsto> (cms', mem')\"\n  assumes x_in_dom: \"x \\<in> X \\<union> vars_\\<C> X\"\n  shows \"mem x = mem' x\"", "lemma change_respecting_doesnt_modify_dma:\n  assumes cr: \"change_respecting (cms, mem) (cms', mem') X\"\n  assumes eval: \"(cms, mem) \\<leadsto> (cms', mem')\"\n  assumes x_in_dom: \"x \\<in> X\"\n  shows \"dma mem x = dma mem' x\"", "lemma differing_empty_eq:\n  \"\\<lbrakk> differing_vars mem mem' = {} \\<rbrakk> \\<Longrightarrow> mem = mem'\"", "lemma adaptation_finite:\n  \"finite (dom (A::('Var,'Val) adaptation))\"", "lemma globally_consistent_adapt_bisim:\n  assumes bisim: \"\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx> \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>\"\n  assumes globally_consistent: \"globally_consistent A mds mem\\<^sub>1 mem\\<^sub>2\"\n  shows \"\\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx> \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>\"", "lemma mm_equiv_\\<C>_eq: \n  \"(a,b) \\<approx> (a',b') \\<Longrightarrow> snd a = snd a' \\<Longrightarrow>\n    \\<forall>x\\<in>\\<C>. b x = b' x\"", "lemma apply_adaptation_not_in_dom: \n  \"x \\<notin> dom A \\<Longrightarrow> apply_adaptation b blah A x = blah x\"", "lemma makes_compatible_invariant:\n  assumes sound_modes: \"sound_mode_use (cms\\<^sub>1, mem\\<^sub>1)\"\n                      \"sound_mode_use (cms\\<^sub>2, mem\\<^sub>2)\"\n  assumes compat: \"makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2) mems\"\n  assumes modes_eq: \"map snd cms\\<^sub>1 = map snd cms\\<^sub>2\"\n  assumes eval: \"(cms\\<^sub>1, mem\\<^sub>1) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\"\n  obtains cms\\<^sub>2' mem\\<^sub>2' mems' where\n      \"map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n       (cms\\<^sub>2, mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n       makes_compatible (cms\\<^sub>1', mem\\<^sub>1') (cms\\<^sub>2', mem\\<^sub>2') mems'\"", "lemma compat_low_eq:\n  assumes compat: \"makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2) mems\"\n  assumes modes_eq: \"map snd cms\\<^sub>1 = map snd cms\\<^sub>2\"\n  assumes x_low: \"dma mem\\<^sub>1 x = Low\"\n  assumes x_readable: \"x \\<in> \\<C> \\<or> (\\<forall> i < length cms\\<^sub>1. x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite)\"\n  shows \"mem\\<^sub>1 x = mem\\<^sub>2 x\"", "lemma loc_reach_subset:\n  assumes eval: \"\\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\"\n  shows \"loc_reach \\<langle>c', mds', mem'\\<rangle> \\<subseteq> loc_reach \\<langle>c, mds, mem\\<rangle>\"", "lemma locally_sound_modes_invariant:\n  assumes sound_modes: \"locally_sound_mode_use \\<langle>c, mds, mem\\<rangle>\"\n  assumes eval: \"\\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\"\n  shows \"locally_sound_mode_use \\<langle>c', mds', mem'\\<rangle>\"", "lemma meval_sched_one:\n  \"(cms, mem) \\<leadsto>\\<^bsub>k\\<^esub> (cms', mem') \\<Longrightarrow>\n        (cms, mem) \\<rightarrow>\\<^bsub>[k]\\<^esub> (cms', mem')\"", "lemma meval_sched_ConsI: \n  \"(cms, mem) \\<leadsto>\\<^bsub>k\\<^esub> (cms', mem') \\<Longrightarrow>\n   (cms', mem') \\<rightarrow>\\<^bsub>sched\\<^esub> (cms'', mem'') \\<Longrightarrow>\n   (cms, mem) \\<rightarrow>\\<^bsub>(k#sched)\\<^esub> (cms'', mem'')\"", "lemma reachable_modes_subset:\n  assumes eval: \"(cms, mem) \\<leadsto>\\<^bsub>k\\<^esub> (cms', mem')\"\n  shows \"reachable_mode_states (cms', mem') \\<subseteq> reachable_mode_states (cms, mem)\"", "lemma globally_sound_modes_invariant:\n  assumes globally_sound: \"globally_sound_mode_use (cms, mem)\"\n  assumes eval: \"(cms, mem) \\<leadsto>\\<^bsub>k\\<^esub> (cms', mem')\"\n  shows \"globally_sound_mode_use (cms', mem')\"", "lemma loc_reach_mem_diff_subset:\n  assumes mem_diff: \"\\<forall> x. var_asm_not_written mds x \\<longrightarrow> mem\\<^sub>1 x = mem\\<^sub>2 x \\<and> dma mem\\<^sub>1 x = dma mem\\<^sub>2 x\"\n  shows \"\\<langle>c', mds', mem'\\<rangle> \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle> \\<Longrightarrow> \\<langle>c', mds', mem'\\<rangle> \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>\"", "lemma loc_reach_mem_diff_eq:\n  assumes mem_diff: \"\\<forall> x. var_asm_not_written mds x \\<longrightarrow> mem' x = mem x \\<and> dma mem' x = dma mem x\"\n  shows \"loc_reach \\<langle>c, mds, mem\\<rangle> = loc_reach \\<langle>c, mds, mem'\\<rangle>\"", "lemma sound_modes_invariant:\n  assumes sound_modes: \"sound_mode_use (cms, mem)\"\n  assumes eval: \"(cms, mem) \\<leadsto>\\<^bsub>k\\<^esub> (cms', mem')\"\n  shows \"sound_mode_use (cms', mem')\"", "lemma app_Cons_rewrite:\n  \"ns @ (a # ms) = ((ns @ [a]) @ ms)\"", "lemma meval_sched_app_iff:\n  \"(cms\\<^sub>1, mem\\<^sub>1) \\<rightarrow>\\<^bsub>ns@ms\\<^esub> (cms\\<^sub>1', mem\\<^sub>1') =\n   (\\<exists>cms\\<^sub>1'' mem\\<^sub>1''. (cms\\<^sub>1, mem\\<^sub>1) \\<rightarrow>\\<^bsub>ns\\<^esub> (cms\\<^sub>1'', mem\\<^sub>1'') \\<and> (cms\\<^sub>1'', mem\\<^sub>1'') \\<rightarrow>\\<^bsub>ms\\<^esub> (cms\\<^sub>1', mem\\<^sub>1'))\"", "lemmas meval_sched_appD = meval_sched_app_iff[THEN iffD1]", "lemmas meval_sched_appI = meval_sched_app_iff[THEN iffD2, OF exI, OF exI]", "lemma meval_sched_snocD:\n  \"(cms\\<^sub>1, mem\\<^sub>1) \\<rightarrow>\\<^bsub>ns@[n]\\<^esub> (cms\\<^sub>1', mem\\<^sub>1') \\<Longrightarrow>\n   \\<exists>cms\\<^sub>1'' mem\\<^sub>1''. (cms\\<^sub>1, mem\\<^sub>1) \\<rightarrow>\\<^bsub>ns\\<^esub> (cms\\<^sub>1'', mem\\<^sub>1'') \\<and> (cms\\<^sub>1'', mem\\<^sub>1'') \\<leadsto>\\<^bsub>n\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\"", "lemma meval_sched_snocI:\n  \"(cms\\<^sub>1, mem\\<^sub>1) \\<rightarrow>\\<^bsub>ns\\<^esub> (cms\\<^sub>1'', mem\\<^sub>1'') \\<and> (cms\\<^sub>1'', mem\\<^sub>1'') \\<leadsto>\\<^bsub>n\\<^esub> (cms\\<^sub>1', mem\\<^sub>1') \\<Longrightarrow>\n  (cms\\<^sub>1, mem\\<^sub>1) \\<rightarrow>\\<^bsub>ns@[n]\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\"", "lemma makes_compatible_eval_sched:\n  assumes compat: \"makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2) mems\"\n  assumes modes_eq: \"map snd cms\\<^sub>1 = map snd cms\\<^sub>2\"\n  assumes sound_modes: \"sound_mode_use (cms\\<^sub>1, mem\\<^sub>1)\" \"sound_mode_use (cms\\<^sub>2, mem\\<^sub>2)\"\n  assumes eval: \"(cms\\<^sub>1, mem\\<^sub>1) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\"\n  shows \"\\<exists> cms\\<^sub>2' mem\\<^sub>2' mems'. sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                              sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                              map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n                              (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                              makes_compatible (cms\\<^sub>1', mem\\<^sub>1') (cms\\<^sub>2', mem\\<^sub>2') mems'\"", "lemma differing_vars_initially_empty:\n  \"i < n \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 (zip (replicate n mem\\<^sub>1) (replicate n mem\\<^sub>2)) i\"", "lemma compatible_refl:\n  assumes coms_secure: \"list_all com_sifum_secure cmds\"\n  assumes low_eq: \"mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2\"\n  shows \"makes_compatible (cmds, mem\\<^sub>1)\n                          (cmds, mem\\<^sub>2)\n                          (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\"", "theorem sifum_compositionality_cont:\n  assumes com_secure: \"list_all com_sifum_secure cmds\"\n  assumes sound_modes: \"\\<forall> mem. INIT mem \\<longrightarrow> sound_mode_use (cmds, mem)\"\n  shows \"prog_sifum_secure_cont cmds\""], "translations": [["", "lemma differing_finite: \"finite (differing_vars mem\\<^sub>1 mem\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (differing_vars mem\\<^sub>1 mem\\<^sub>2)", "by (metis UNIV_def Un_UNIV_left finite_Un finite_memory)"], ["", "lemma differing_lists_finite: \"finite (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i)", "by (simp add: differing_finite differing_vars_lists_def)"], ["", "fun makes_compatible ::\n  \"('Com, 'Var, 'Val) GlobalConf \\<Rightarrow>\n   ('Com, 'Var, 'Val) GlobalConf \\<Rightarrow>\n   ((_, _) Mem \\<times> (_, _) Mem) list \\<Rightarrow>\n  bool\"\nwhere\n  \"makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2) mems =\n  (length cms\\<^sub>1 = length cms\\<^sub>2 \\<and> length cms\\<^sub>1 = length mems \\<and>\n   (\\<forall> i. i < length cms\\<^sub>1 \\<longrightarrow>\n       (\\<forall> \\<sigma>. dom \\<sigma> = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i \\<longrightarrow>\n         (cms\\<^sub>1 ! i, (fst (mems ! i)) [\\<mapsto> \\<sigma>]) \\<approx> (cms\\<^sub>2 ! i, (snd (mems ! i)) [\\<mapsto> \\<sigma>])) \\<and>\n       (\\<forall> x. (mem\\<^sub>1 x = mem\\<^sub>2 x \\<or> dma mem\\<^sub>1 x = High \\<or> x \\<in> \\<C>) \\<longrightarrow>\n             x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i)) \\<and>\n    ((length cms\\<^sub>1 = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2) \\<or> (\\<forall> x. \\<exists> i. i < length cms\\<^sub>1 \\<and>\n                                          x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i)))\""], ["", "(* This just restates the previous definition using meta-quantification. This allows\n  more readable proof blocks that prove each part separately. *)"], ["", "lemma makes_compatible_intro [intro]:\n  \"\\<lbrakk> length cms\\<^sub>1 = length cms\\<^sub>2 \\<and> length cms\\<^sub>1 = length mems;\n     (\\<And> i \\<sigma>. \\<lbrakk> i < length cms\\<^sub>1; dom \\<sigma> = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i \\<rbrakk> \\<Longrightarrow>\n          (cms\\<^sub>1 ! i, (fst (mems ! i)) [\\<mapsto> \\<sigma>]) \\<approx> (cms\\<^sub>2 ! i, (snd (mems ! i)) [\\<mapsto> \\<sigma>]));\n     (\\<And> i x. \\<lbrakk> i < length cms\\<^sub>1; mem\\<^sub>1 x = mem\\<^sub>2 x \\<or> dma mem\\<^sub>1 x = High \\<or> x \\<in> \\<C> \\<rbrakk> \\<Longrightarrow> \n          x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i);\n     (length cms\\<^sub>1 = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2) \\<or>\n     (\\<forall> x. \\<exists> i. i < length cms\\<^sub>1 \\<and> x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i) \\<rbrakk> \\<Longrightarrow>\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2) mems\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length cms\\<^sub>1 = length cms\\<^sub>2 \\<and>\n             length cms\\<^sub>1 = length mems;\n     \\<And>i \\<sigma>.\n        \\<lbrakk>i < length cms\\<^sub>1;\n         dom \\<sigma> =\n         differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\\<rbrakk>\n        \\<Longrightarrow> (cms\\<^sub>1 ! i,\n                           subst \\<sigma> (fst (mems ! i))) \\<approx>\n                          (cms\\<^sub>2 ! i,\n                           subst \\<sigma> (snd (mems ! i)));\n     \\<And>i x.\n        \\<lbrakk>i < length cms\\<^sub>1;\n         mem\\<^sub>1 x = mem\\<^sub>2 x \\<or>\n         dma mem\\<^sub>1 x = High \\<or> x \\<in> \\<C>\\<rbrakk>\n        \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1\nmem\\<^sub>2 mems i;\n     length cms\\<^sub>1 = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n     (\\<forall>x.\n         \\<exists>i<length cms\\<^sub>1.\n            x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                        i)\\<rbrakk>\n    \\<Longrightarrow> makes_compatible (cms\\<^sub>1, mem\\<^sub>1)\n                       (cms\\<^sub>2, mem\\<^sub>2) mems", "by auto"], ["", "(* First, some auxiliary lemmas about makes_compatible: *)"], ["", "lemma compat_low:\n  \"\\<lbrakk> makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2) mems;\n     i < length cms\\<^sub>1;\n     x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i \\<rbrakk> \\<Longrightarrow> dma mem\\<^sub>1 x = Low\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>makes_compatible (cms\\<^sub>1, mem\\<^sub>1)\n              (cms\\<^sub>2, mem\\<^sub>2) mems;\n     i < length cms\\<^sub>1;\n     x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\\<rbrakk>\n    \\<Longrightarrow> dma mem\\<^sub>1 x = Low", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>makes_compatible (cms\\<^sub>1, mem\\<^sub>1)\n              (cms\\<^sub>2, mem\\<^sub>2) mems;\n     i < length cms\\<^sub>1;\n     x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\\<rbrakk>\n    \\<Longrightarrow> dma mem\\<^sub>1 x = Low", "assume \"i < length cms\\<^sub>1\" and *: \"x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\" and\n    \"makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2) mems\""], ["proof (state)\nthis:\n  i < length cms\\<^sub>1\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n\ngoal (1 subgoal):\n 1. \\<lbrakk>makes_compatible (cms\\<^sub>1, mem\\<^sub>1)\n              (cms\\<^sub>2, mem\\<^sub>2) mems;\n     i < length cms\\<^sub>1;\n     x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\\<rbrakk>\n    \\<Longrightarrow> dma mem\\<^sub>1 x = Low", "then"], ["proof (chain)\npicking this:\n  i < length cms\\<^sub>1\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems", "have\n    \"(mem\\<^sub>1 x = mem\\<^sub>2 x \\<or> dma mem\\<^sub>1 x = High \\<or> x \\<in> \\<C>) \\<longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\""], ["proof (prove)\nusing this:\n  i < length cms\\<^sub>1\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n\ngoal (1 subgoal):\n 1. mem\\<^sub>1 x = mem\\<^sub>2 x \\<or>\n    dma mem\\<^sub>1 x = High \\<or> x \\<in> \\<C> \\<longrightarrow>\n    x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i", "by (simp add: Let_def, blast)"], ["proof (state)\nthis:\n  mem\\<^sub>1 x = mem\\<^sub>2 x \\<or>\n  dma mem\\<^sub>1 x = High \\<or> x \\<in> \\<C> \\<longrightarrow>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>makes_compatible (cms\\<^sub>1, mem\\<^sub>1)\n              (cms\\<^sub>2, mem\\<^sub>2) mems;\n     i < length cms\\<^sub>1;\n     x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\\<rbrakk>\n    \\<Longrightarrow> dma mem\\<^sub>1 x = Low", "with *"], ["proof (chain)\npicking this:\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n  mem\\<^sub>1 x = mem\\<^sub>2 x \\<or>\n  dma mem\\<^sub>1 x = High \\<or> x \\<in> \\<C> \\<longrightarrow>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i", "show \"dma mem\\<^sub>1 x = Low\""], ["proof (prove)\nusing this:\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n  mem\\<^sub>1 x = mem\\<^sub>2 x \\<or>\n  dma mem\\<^sub>1 x = High \\<or> x \\<in> \\<C> \\<longrightarrow>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n\ngoal (1 subgoal):\n 1. dma mem\\<^sub>1 x = Low", "by (cases \"dma mem\\<^sub>1 x\", blast)"], ["proof (state)\nthis:\n  dma mem\\<^sub>1 x = Low\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma compat_different:\n  \"\\<lbrakk> makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2) mems;\n     i < length cms\\<^sub>1;\n     x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i \\<rbrakk> \\<Longrightarrow> mem\\<^sub>1 x \\<noteq> mem\\<^sub>2 x \\<and> dma mem\\<^sub>1 x = Low \\<and> x \\<notin> \\<C>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>makes_compatible (cms\\<^sub>1, mem\\<^sub>1)\n              (cms\\<^sub>2, mem\\<^sub>2) mems;\n     i < length cms\\<^sub>1;\n     x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\\<rbrakk>\n    \\<Longrightarrow> mem\\<^sub>1 x \\<noteq> mem\\<^sub>2 x \\<and>\n                      dma mem\\<^sub>1 x = Low \\<and> x \\<notin> \\<C>", "by (cases \"dma mem\\<^sub>1 x\", auto)"], ["", "lemma sound_modes_no_read :\n  \"\\<lbrakk> sound_mode_use (cms, mem); x \\<in> (map snd cms ! i) GuarNoReadOrWrite; i < length cms \\<rbrakk> \\<Longrightarrow>\n  doesnt_read_or_modify (fst (cms ! i)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>sound_mode_use (cms, mem);\n     x \\<in> (map snd cms ! i) GuarNoReadOrWrite; i < length cms\\<rbrakk>\n    \\<Longrightarrow> doesnt_read_or_modify (fst (cms ! i)) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>sound_mode_use (cms, mem);\n     x \\<in> (map snd cms ! i) GuarNoReadOrWrite; i < length cms\\<rbrakk>\n    \\<Longrightarrow> doesnt_read_or_modify (fst (cms ! i)) x", "fix cms mem x i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>sound_mode_use (cms, mem);\n     x \\<in> (map snd cms ! i) GuarNoReadOrWrite; i < length cms\\<rbrakk>\n    \\<Longrightarrow> doesnt_read_or_modify (fst (cms ! i)) x", "assume sound_modes: \"sound_mode_use (cms, mem)\" and \"i < length cms\""], ["proof (state)\nthis:\n  sound_mode_use (cms, mem)\n  i < length cms\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sound_mode_use (cms, mem);\n     x \\<in> (map snd cms ! i) GuarNoReadOrWrite; i < length cms\\<rbrakk>\n    \\<Longrightarrow> doesnt_read_or_modify (fst (cms ! i)) x", "hence \"locally_sound_mode_use (cms ! i, mem)\""], ["proof (prove)\nusing this:\n  sound_mode_use (cms, mem)\n  i < length cms\n\ngoal (1 subgoal):\n 1. locally_sound_mode_use (cms ! i, mem)", "by (auto simp: sound_mode_use_def list_all_length)"], ["proof (state)\nthis:\n  locally_sound_mode_use (cms ! i, mem)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sound_mode_use (cms, mem);\n     x \\<in> (map snd cms ! i) GuarNoReadOrWrite; i < length cms\\<rbrakk>\n    \\<Longrightarrow> doesnt_read_or_modify (fst (cms ! i)) x", "moreover"], ["proof (state)\nthis:\n  locally_sound_mode_use (cms ! i, mem)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sound_mode_use (cms, mem);\n     x \\<in> (map snd cms ! i) GuarNoReadOrWrite; i < length cms\\<rbrakk>\n    \\<Longrightarrow> doesnt_read_or_modify (fst (cms ! i)) x", "assume \"x \\<in> (map snd cms ! i) GuarNoReadOrWrite\""], ["proof (state)\nthis:\n  x \\<in> (map snd cms ! i) GuarNoReadOrWrite\n\ngoal (1 subgoal):\n 1. \\<lbrakk>sound_mode_use (cms, mem);\n     x \\<in> (map snd cms ! i) GuarNoReadOrWrite; i < length cms\\<rbrakk>\n    \\<Longrightarrow> doesnt_read_or_modify (fst (cms ! i)) x", "ultimately"], ["proof (chain)\npicking this:\n  locally_sound_mode_use (cms ! i, mem)\n  x \\<in> (map snd cms ! i) GuarNoReadOrWrite", "show \"doesnt_read_or_modify (fst (cms !i)) x\""], ["proof (prove)\nusing this:\n  locally_sound_mode_use (cms ! i, mem)\n  x \\<in> (map snd cms ! i) GuarNoReadOrWrite\n\ngoal (1 subgoal):\n 1. doesnt_read_or_modify (fst (cms ! i)) x", "apply (simp add: locally_sound_mode_use_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>c' mds'.\n                (\\<exists>mem'.\n                    \\<langle>c', mds', mem'\\<rangle>\n                    \\<in> loc_reach (cms ! i, mem)) \\<longrightarrow>\n                (\\<forall>x.\n                    (x \\<in> mds' GuarNoReadOrWrite \\<longrightarrow>\n                     doesnt_read_or_modify c' x) \\<and>\n                    (x \\<in> mds' GuarNoWrite \\<longrightarrow>\n                     doesnt_modify c' x));\n     x \\<in> (map snd cms ! i) GuarNoReadOrWrite\\<rbrakk>\n    \\<Longrightarrow> doesnt_read_or_modify (fst (cms ! i)) x", "using \\<open>i < length cms\\<close> \\<open>locally_sound_mode_use (cms ! i, mem)\\<close> locally_sound_respects_guarantees respects_own_guarantees_def"], ["proof (prove)\nusing this:\n  i < length cms\n  locally_sound_mode_use (cms ! i, mem)\n  locally_sound_mode_use (?cm, ?mem) \\<Longrightarrow>\n  respects_own_guarantees ?cm\n  respects_own_guarantees ?cm \\<equiv>\n  \\<forall>x.\n     (x \\<in> snd ?cm GuarNoReadOrWrite \\<longrightarrow>\n      doesnt_read_or_modify (fst ?cm) x) \\<and>\n     (x \\<in> snd ?cm GuarNoWrite \\<longrightarrow>\n      doesnt_modify (fst ?cm) x)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>c' mds'.\n                (\\<exists>mem'.\n                    \\<langle>c', mds', mem'\\<rangle>\n                    \\<in> loc_reach (cms ! i, mem)) \\<longrightarrow>\n                (\\<forall>x.\n                    (x \\<in> mds' GuarNoReadOrWrite \\<longrightarrow>\n                     doesnt_read_or_modify c' x) \\<and>\n                    (x \\<in> mds' GuarNoWrite \\<longrightarrow>\n                     doesnt_modify c' x));\n     x \\<in> (map snd cms ! i) GuarNoReadOrWrite\\<rbrakk>\n    \\<Longrightarrow> doesnt_read_or_modify (fst (cms ! i)) x", "by auto"], ["proof (state)\nthis:\n  doesnt_read_or_modify (fst (cms ! i)) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma differing_vars_neg: \"x \\<notin> differing_vars_lists mem1 mem2 mems i \\<Longrightarrow>\n  (fst (mems ! i) x = mem1 x \\<and> snd (mems ! i) x = mem2 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem1 mem2 mems i \\<Longrightarrow>\n    fst (mems ! i) x = mem1 x \\<and> snd (mems ! i) x = mem2 x", "by (simp add: differing_vars_lists_def differing_vars_def)"], ["", "lemma differing_vars_neg_intro:\n  \"\\<lbrakk> mem\\<^sub>1 x = fst (mems ! i) x;\n  mem\\<^sub>2 x = snd (mems ! i) x \\<rbrakk> \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mem\\<^sub>1 x = fst (mems ! i) x;\n     mem\\<^sub>2 x = snd (mems ! i) x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1\n                                  mem\\<^sub>2 mems i", "by (auto simp: differing_vars_lists_def differing_vars_def)"], ["", "lemma differing_vars_elim [elim]:\n  \"x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i \\<Longrightarrow>\n  (fst (mems ! i) x \\<noteq> mem\\<^sub>1 x) \\<or> (snd (mems ! i) x \\<noteq> mem\\<^sub>2 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n             i \\<Longrightarrow>\n    fst (mems ! i) x \\<noteq> mem\\<^sub>1 x \\<or>\n    snd (mems ! i) x \\<noteq> mem\\<^sub>2 x", "by (auto simp: differing_vars_lists_def differing_vars_def)"], ["", "lemma makes_compatible_dma_eq:\n  assumes compat: \"makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2) mems\"\n  assumes ile: \"i < length cms\\<^sub>1\"\n  assumes dom\\<sigma>: \"dom \\<sigma> = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\"\n  shows \"dma ((fst (mems ! i)) [\\<mapsto> \\<sigma>]) = dma mem\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dma (subst \\<sigma> (fst (mems ! i))) = dma mem\\<^sub>1", "proof(rule dma_\\<C>, clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<C> \\<Longrightarrow>\n       subst \\<sigma> (fst (mems ! i)) x = mem\\<^sub>1 x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<C> \\<Longrightarrow>\n       subst \\<sigma> (fst (mems ! i)) x = mem\\<^sub>1 x", "assume \"x \\<in> \\<C>\""], ["proof (state)\nthis:\n  x \\<in> \\<C>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<C> \\<Longrightarrow>\n       subst \\<sigma> (fst (mems ! i)) x = mem\\<^sub>1 x", "with compat ile"], ["proof (chain)\npicking this:\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  i < length cms\\<^sub>1\n  x \\<in> \\<C>", "have notin_diff: \"x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\""], ["proof (prove)\nusing this:\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  i < length cms\\<^sub>1\n  x \\<in> \\<C>\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i", "by simp"], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<C> \\<Longrightarrow>\n       subst \\<sigma> (fst (mems ! i)) x = mem\\<^sub>1 x", "hence \"x \\<notin> dom \\<sigma>\""], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n\ngoal (1 subgoal):\n 1. x \\<notin> dom \\<sigma>", "by(metis dom\\<sigma>)"], ["proof (state)\nthis:\n  x \\<notin> dom \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<C> \\<Longrightarrow>\n       subst \\<sigma> (fst (mems ! i)) x = mem\\<^sub>1 x", "hence \"(fst (mems ! i) [\\<mapsto> \\<sigma>]) x = (fst (mems ! i)) x\""], ["proof (prove)\nusing this:\n  x \\<notin> dom \\<sigma>\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (fst (mems ! i)) x = fst (mems ! i) x", "by(metis subst_not_in_dom)"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems ! i)) x = fst (mems ! i) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<C> \\<Longrightarrow>\n       subst \\<sigma> (fst (mems ! i)) x = mem\\<^sub>1 x", "moreover"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems ! i)) x = fst (mems ! i) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<C> \\<Longrightarrow>\n       subst \\<sigma> (fst (mems ! i)) x = mem\\<^sub>1 x", "have \"(fst (mems ! i)) x = mem\\<^sub>1 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (mems ! i) x = mem\\<^sub>1 x", "using notin_diff differing_vars_neg"], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n  ?x \\<notin> differing_vars_lists ?mem1.0 ?mem2.0 ?mems\n               ?i \\<Longrightarrow>\n  fst (?mems ! ?i) ?x = ?mem1.0 ?x \\<and> snd (?mems ! ?i) ?x = ?mem2.0 ?x\n\ngoal (1 subgoal):\n 1. fst (mems ! i) x = mem\\<^sub>1 x", "by metis"], ["proof (state)\nthis:\n  fst (mems ! i) x = mem\\<^sub>1 x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<C> \\<Longrightarrow>\n       subst \\<sigma> (fst (mems ! i)) x = mem\\<^sub>1 x", "ultimately"], ["proof (chain)\npicking this:\n  subst \\<sigma> (fst (mems ! i)) x = fst (mems ! i) x\n  fst (mems ! i) x = mem\\<^sub>1 x", "show \"(fst (mems ! i) [\\<mapsto> \\<sigma>]) x = mem\\<^sub>1 x\""], ["proof (prove)\nusing this:\n  subst \\<sigma> (fst (mems ! i)) x = fst (mems ! i) x\n  fst (mems ! i) x = mem\\<^sub>1 x\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (fst (mems ! i)) x = mem\\<^sub>1 x", "by simp"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems ! i)) x = mem\\<^sub>1 x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma compat_different_vars:\n  \"\\<lbrakk> fst (mems ! i) x = snd (mems ! i) x;\n     x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i \\<rbrakk> \\<Longrightarrow>\n    mem\\<^sub>1 x = mem\\<^sub>2 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>fst (mems ! i) x = snd (mems ! i) x;\n     x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\\<rbrakk>\n    \\<Longrightarrow> mem\\<^sub>1 x = mem\\<^sub>2 x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>fst (mems ! i) x = snd (mems ! i) x;\n     x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\\<rbrakk>\n    \\<Longrightarrow> mem\\<^sub>1 x = mem\\<^sub>2 x", "assume \"x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\""], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fst (mems ! i) x = snd (mems ! i) x;\n     x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\\<rbrakk>\n    \\<Longrightarrow> mem\\<^sub>1 x = mem\\<^sub>2 x", "hence \"fst (mems ! i) x = mem\\<^sub>1 x \\<and> snd (mems ! i) x = mem\\<^sub>2 x\""], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n\ngoal (1 subgoal):\n 1. fst (mems ! i) x = mem\\<^sub>1 x \\<and> snd (mems ! i) x = mem\\<^sub>2 x", "by (simp add: differing_vars_lists_def differing_vars_def)"], ["proof (state)\nthis:\n  fst (mems ! i) x = mem\\<^sub>1 x \\<and> snd (mems ! i) x = mem\\<^sub>2 x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fst (mems ! i) x = snd (mems ! i) x;\n     x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\\<rbrakk>\n    \\<Longrightarrow> mem\\<^sub>1 x = mem\\<^sub>2 x", "moreover"], ["proof (state)\nthis:\n  fst (mems ! i) x = mem\\<^sub>1 x \\<and> snd (mems ! i) x = mem\\<^sub>2 x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fst (mems ! i) x = snd (mems ! i) x;\n     x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\\<rbrakk>\n    \\<Longrightarrow> mem\\<^sub>1 x = mem\\<^sub>2 x", "assume \"fst (mems ! i) x = snd (mems ! i) x\""], ["proof (state)\nthis:\n  fst (mems ! i) x = snd (mems ! i) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>fst (mems ! i) x = snd (mems ! i) x;\n     x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\\<rbrakk>\n    \\<Longrightarrow> mem\\<^sub>1 x = mem\\<^sub>2 x", "ultimately"], ["proof (chain)\npicking this:\n  fst (mems ! i) x = mem\\<^sub>1 x \\<and> snd (mems ! i) x = mem\\<^sub>2 x\n  fst (mems ! i) x = snd (mems ! i) x", "show \"mem\\<^sub>1 x = mem\\<^sub>2 x\""], ["proof (prove)\nusing this:\n  fst (mems ! i) x = mem\\<^sub>1 x \\<and> snd (mems ! i) x = mem\\<^sub>2 x\n  fst (mems ! i) x = snd (mems ! i) x\n\ngoal (1 subgoal):\n 1. mem\\<^sub>1 x = mem\\<^sub>2 x", "by auto"], ["proof (state)\nthis:\n  mem\\<^sub>1 x = mem\\<^sub>2 x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma differing_vars_subst [rule_format]:\n  assumes dom\\<sigma>: \"dom \\<sigma> \\<supseteq> differing_vars mem\\<^sub>1 mem\\<^sub>2\"\n  shows \"mem\\<^sub>1 [\\<mapsto> \\<sigma>] = mem\\<^sub>2 [\\<mapsto> \\<sigma>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst \\<sigma> mem\\<^sub>1 = subst \\<sigma> mem\\<^sub>2", "proof (rule ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. subst \\<sigma> mem\\<^sub>1 x = subst \\<sigma> mem\\<^sub>2 x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. subst \\<sigma> mem\\<^sub>1 x = subst \\<sigma> mem\\<^sub>2 x", "from dom\\<sigma>"], ["proof (chain)\npicking this:\n  differing_vars mem\\<^sub>1 mem\\<^sub>2 \\<subseteq> dom \\<sigma>", "show \"mem\\<^sub>1 [\\<mapsto> \\<sigma>] x = mem\\<^sub>2 [\\<mapsto> \\<sigma>] x\""], ["proof (prove)\nusing this:\n  differing_vars mem\\<^sub>1 mem\\<^sub>2 \\<subseteq> dom \\<sigma>\n\ngoal (1 subgoal):\n 1. subst \\<sigma> mem\\<^sub>1 x = subst \\<sigma> mem\\<^sub>2 x", "unfolding subst_def differing_vars_def"], ["proof (prove)\nusing this:\n  {x. mem\\<^sub>1 x \\<noteq> mem\\<^sub>2 x} \\<subseteq> dom \\<sigma>\n\ngoal (1 subgoal):\n 1. (case \\<sigma> x of None \\<Rightarrow> mem\\<^sub>1 x\n     | Some v \\<Rightarrow> v) =\n    (case \\<sigma> x of None \\<Rightarrow> mem\\<^sub>2 x\n     | Some v \\<Rightarrow> v)", "by (cases \"\\<sigma> x\", auto)"], ["proof (state)\nthis:\n  subst \\<sigma> mem\\<^sub>1 x = subst \\<sigma> mem\\<^sub>2 x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mm_equiv_low_eq:\n  \"\\<lbrakk> \\<langle> c\\<^sub>1, mds, mem\\<^sub>1 \\<rangle> \\<approx> \\<langle> c\\<^sub>2, mds, mem\\<^sub>2 \\<rangle> \\<rbrakk> \\<Longrightarrow> mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<Longrightarrow>\n    mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2", "unfolding mm_equiv.simps strong_low_bisim_mm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<R> lc\\<^sub>1 lc\\<^sub>2.\n       \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> = lc\\<^sub>1 \\<and>\n       \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> = lc\\<^sub>2 \\<and>\n       (sym \\<R> \\<and>\n        closed_glob_consistent \\<R> \\<and>\n        (\\<forall>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2.\n            (\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle>,\n             \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>)\n            \\<in> \\<R> \\<longrightarrow>\n            mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2 \\<and>\n            (\\<forall>c\\<^sub>1' mds' mem\\<^sub>1'.\n                \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n                \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<longrightarrow>\n                (\\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n                    \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n                    (\\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle>,\n                     \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>)\n                    \\<in> \\<R>)))) \\<and>\n       (lc\\<^sub>1, lc\\<^sub>2) \\<in> \\<R> \\<Longrightarrow>\n    mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2", "by fast"], ["", "lemma globally_sound_modes_compatible:\n  \"\\<lbrakk> globally_sound_mode_use (cms, mem) \\<rbrakk> \\<Longrightarrow> compatible_modes (map snd cms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. globally_sound_mode_use (cms, mem) \\<Longrightarrow>\n    compatible_modes (map snd cms)", "apply (simp add: globally_sound_mode_use_def reachable_mode_states_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>mdss.\n       (\\<exists>cms'.\n           (\\<exists>mem' sched.\n               (cms,\n                mem) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms', mem')) \\<and>\n           map snd cms' = mdss) \\<longrightarrow>\n       compatible_modes mdss \\<Longrightarrow>\n    compatible_modes (map snd cms)", "using meval_sched.simps(1)"], ["proof (prove)\nusing this:\n  ?c \\<rightarrow>\\<^bsub>[]\\<^esub> ?c' = (?c = ?c')\n\ngoal (1 subgoal):\n 1. \\<forall>mdss.\n       (\\<exists>cms'.\n           (\\<exists>mem' sched.\n               (cms,\n                mem) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms', mem')) \\<and>\n           map snd cms' = mdss) \\<longrightarrow>\n       compatible_modes mdss \\<Longrightarrow>\n    compatible_modes (map snd cms)", "by blast"], ["", "(* map snd cms1 = map snd cms2 states that both global configurations use the same modes *)"], ["", "lemma compatible_different_no_read :\n  assumes sound_modes: \"sound_mode_use (cms\\<^sub>1, mem\\<^sub>1)\"\n                       \"sound_mode_use (cms\\<^sub>2, mem\\<^sub>2)\"\n  assumes compat: \"makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2) mems\"\n  assumes modes_eq: \"map snd cms\\<^sub>1 = map snd cms\\<^sub>2\"\n  assumes ile: \"i < length cms\\<^sub>1\"\n  assumes x: \"x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\"\n  shows \"doesnt_read_or_modify (fst (cms\\<^sub>1 ! i)) x \\<and> doesnt_read_or_modify (fst (cms\\<^sub>2 ! i)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. doesnt_read_or_modify (fst (cms\\<^sub>1 ! i)) x \\<and>\n    doesnt_read_or_modify (fst (cms\\<^sub>2 ! i)) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. doesnt_read_or_modify (fst (cms\\<^sub>1 ! i)) x \\<and>\n    doesnt_read_or_modify (fst (cms\\<^sub>2 ! i)) x", "from compat"], ["proof (chain)\npicking this:\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems", "have len: \"length cms\\<^sub>1 = length cms\\<^sub>2\""], ["proof (prove)\nusing this:\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n\ngoal (1 subgoal):\n 1. length cms\\<^sub>1 = length cms\\<^sub>2", "by simp"], ["proof (state)\nthis:\n  length cms\\<^sub>1 = length cms\\<^sub>2\n\ngoal (1 subgoal):\n 1. doesnt_read_or_modify (fst (cms\\<^sub>1 ! i)) x \\<and>\n    doesnt_read_or_modify (fst (cms\\<^sub>2 ! i)) x", "let ?X\\<^sub>i = \"differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\""], ["proof (state)\ngoal (1 subgoal):\n 1. doesnt_read_or_modify (fst (cms\\<^sub>1 ! i)) x \\<and>\n    doesnt_read_or_modify (fst (cms\\<^sub>2 ! i)) x", "from compat ile x"], ["proof (chain)\npicking this:\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  i < length cms\\<^sub>1\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i", "have a: \"dma mem\\<^sub>1 x = Low\""], ["proof (prove)\nusing this:\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  i < length cms\\<^sub>1\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n\ngoal (1 subgoal):\n 1. dma mem\\<^sub>1 x = Low", "by (metis compat_low)"], ["proof (state)\nthis:\n  dma mem\\<^sub>1 x = Low\n\ngoal (1 subgoal):\n 1. doesnt_read_or_modify (fst (cms\\<^sub>1 ! i)) x \\<and>\n    doesnt_read_or_modify (fst (cms\\<^sub>2 ! i)) x", "from compat ile x"], ["proof (chain)\npicking this:\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  i < length cms\\<^sub>1\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i", "have b: \"mem\\<^sub>1 x \\<noteq> mem\\<^sub>2 x\""], ["proof (prove)\nusing this:\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  i < length cms\\<^sub>1\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n\ngoal (1 subgoal):\n 1. mem\\<^sub>1 x \\<noteq> mem\\<^sub>2 x", "by (metis compat_different)"], ["proof (state)\nthis:\n  mem\\<^sub>1 x \\<noteq> mem\\<^sub>2 x\n\ngoal (1 subgoal):\n 1. doesnt_read_or_modify (fst (cms\\<^sub>1 ! i)) x \\<and>\n    doesnt_read_or_modify (fst (cms\\<^sub>2 ! i)) x", "from compat ile x"], ["proof (chain)\npicking this:\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  i < length cms\\<^sub>1\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i", "have not_in_\\<C>: \"x \\<notin> \\<C>\""], ["proof (prove)\nusing this:\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  i < length cms\\<^sub>1\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n\ngoal (1 subgoal):\n 1. x \\<notin> \\<C>", "by (metis compat_different)"], ["proof (state)\nthis:\n  x \\<notin> \\<C>\n\ngoal (1 subgoal):\n 1. doesnt_read_or_modify (fst (cms\\<^sub>1 ! i)) x \\<and>\n    doesnt_read_or_modify (fst (cms\\<^sub>2 ! i)) x", "with a and compat ile x"], ["proof (chain)\npicking this:\n  dma mem\\<^sub>1 x = Low\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  i < length cms\\<^sub>1\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n  x \\<notin> \\<C>", "obtain j where\n    jprop: \"j < length cms\\<^sub>1 \\<and> x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\""], ["proof (prove)\nusing this:\n  dma mem\\<^sub>1 x = Low\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  i < length cms\\<^sub>1\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n  x \\<notin> \\<C>\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        j < length cms\\<^sub>1 \\<and>\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                    j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  j < length cms\\<^sub>1 \\<and>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n\ngoal (1 subgoal):\n 1. doesnt_read_or_modify (fst (cms\\<^sub>1 ! i)) x \\<and>\n    doesnt_read_or_modify (fst (cms\\<^sub>2 ! i)) x", "let ?X\\<^sub>j = \"differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\""], ["proof (state)\ngoal (1 subgoal):\n 1. doesnt_read_or_modify (fst (cms\\<^sub>1 ! i)) x \\<and>\n    doesnt_read_or_modify (fst (cms\\<^sub>2 ! i)) x", "obtain \\<sigma> :: \"'Var \\<rightharpoonup> 'Val\" where dom\\<sigma>: \"dom \\<sigma> = ?X\\<^sub>j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>.\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n         j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>.\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n         j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    dom ?\\<sigma>12 = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j", "let ?\\<sigma> = \"\\<lambda> x. if (x \\<in> ?X\\<^sub>j) then Some some_val else None\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>.\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n         j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    dom ?\\<sigma>12 = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j", "show \"dom ?\\<sigma> = ?X\\<^sub>j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (\\<lambda>x.\n            if x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n            then Some some_val else None) =\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j", "unfolding dom_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {a. (if a \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n         then Some some_val else None) \\<noteq>\n        None} =\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j", "by auto"], ["proof (state)\nthis:\n  dom (\\<lambda>x.\n          if x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n          then Some some_val else None) =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dom \\<sigma> = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n\ngoal (1 subgoal):\n 1. doesnt_read_or_modify (fst (cms\\<^sub>1 ! i)) x \\<and>\n    doesnt_read_or_modify (fst (cms\\<^sub>2 ! i)) x", "let ?mdss = \"map snd cms\\<^sub>1\" and\n      ?mems\\<^sub>1j = \"fst (mems ! j)\" and\n      ?mems\\<^sub>2j = \"snd (mems ! j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. doesnt_read_or_modify (fst (cms\\<^sub>1 ! i)) x \\<and>\n    doesnt_read_or_modify (fst (cms\\<^sub>2 ! i)) x", "from jprop dom\\<sigma>"], ["proof (chain)\npicking this:\n  j < length cms\\<^sub>1 \\<and>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n  dom \\<sigma> = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j", "have subst_eq:\n  \"?mems\\<^sub>1j [\\<mapsto> \\<sigma>] x = ?mems\\<^sub>1j x \\<and> ?mems\\<^sub>2j [\\<mapsto> \\<sigma>] x = ?mems\\<^sub>2j x\""], ["proof (prove)\nusing this:\n  j < length cms\\<^sub>1 \\<and>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n  dom \\<sigma> = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (fst (mems ! j)) x = fst (mems ! j) x \\<and>\n    subst \\<sigma> (snd (mems ! j)) x = snd (mems ! j) x", "by (metis subst_not_in_dom)"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems ! j)) x = fst (mems ! j) x \\<and>\n  subst \\<sigma> (snd (mems ! j)) x = snd (mems ! j) x\n\ngoal (1 subgoal):\n 1. doesnt_read_or_modify (fst (cms\\<^sub>1 ! i)) x \\<and>\n    doesnt_read_or_modify (fst (cms\\<^sub>2 ! i)) x", "from compat jprop dom\\<sigma>"], ["proof (chain)\npicking this:\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  j < length cms\\<^sub>1 \\<and>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n  dom \\<sigma> = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j", "have \"(cms\\<^sub>1 ! j, ?mems\\<^sub>1j [\\<mapsto> \\<sigma>]) \\<approx> (cms\\<^sub>2 ! j, ?mems\\<^sub>2j [\\<mapsto> \\<sigma>])\""], ["proof (prove)\nusing this:\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  j < length cms\\<^sub>1 \\<and>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n  dom \\<sigma> = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n\ngoal (1 subgoal):\n 1. (cms\\<^sub>1 ! j, subst \\<sigma> (fst (mems ! j))) \\<approx>\n    (cms\\<^sub>2 ! j, subst \\<sigma> (snd (mems ! j)))", "by (auto simp: Let_def)"], ["proof (state)\nthis:\n  (cms\\<^sub>1 ! j, subst \\<sigma> (fst (mems ! j))) \\<approx>\n  (cms\\<^sub>2 ! j, subst \\<sigma> (snd (mems ! j)))\n\ngoal (1 subgoal):\n 1. doesnt_read_or_modify (fst (cms\\<^sub>1 ! i)) x \\<and>\n    doesnt_read_or_modify (fst (cms\\<^sub>2 ! i)) x", "hence low_eq: \"?mems\\<^sub>1j [\\<mapsto> \\<sigma>] =\\<^bsub>?mdss ! j\\<^esub>\\<^sup>l ?mems\\<^sub>2j [\\<mapsto> \\<sigma>]\""], ["proof (prove)\nusing this:\n  (cms\\<^sub>1 ! j, subst \\<sigma> (fst (mems ! j))) \\<approx>\n  (cms\\<^sub>2 ! j, subst \\<sigma> (snd (mems ! j)))\n\ngoal (1 subgoal):\n 1. subst \\<sigma>\n     (fst (mems !\n           j)) =\\<^bsub>map snd cms\\<^sub>1 ! j\\<^esub>\\<^sup>l subst\n                           \\<sigma> (snd (mems ! j))", "using modes_eq"], ["proof (prove)\nusing this:\n  (cms\\<^sub>1 ! j, subst \\<sigma> (fst (mems ! j))) \\<approx>\n  (cms\\<^sub>2 ! j, subst \\<sigma> (snd (mems ! j)))\n  map snd cms\\<^sub>1 = map snd cms\\<^sub>2\n\ngoal (1 subgoal):\n 1. subst \\<sigma>\n     (fst (mems !\n           j)) =\\<^bsub>map snd cms\\<^sub>1 ! j\\<^esub>\\<^sup>l subst\n                           \\<sigma> (snd (mems ! j))", "by (metis (no_types) jprop len mm_equiv_low_eq nth_map surjective_pairing)"], ["proof (state)\nthis:\n  subst \\<sigma>\n   (fst (mems !\n         j)) =\\<^bsub>map snd cms\\<^sub>1 ! j\\<^esub>\\<^sup>l subst \\<sigma>\n                         (snd (mems ! j))\n\ngoal (1 subgoal):\n 1. doesnt_read_or_modify (fst (cms\\<^sub>1 ! i)) x \\<and>\n    doesnt_read_or_modify (fst (cms\\<^sub>2 ! i)) x", "with jprop and b"], ["proof (chain)\npicking this:\n  j < length cms\\<^sub>1 \\<and>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n  mem\\<^sub>1 x \\<noteq> mem\\<^sub>2 x\n  subst \\<sigma>\n   (fst (mems !\n         j)) =\\<^bsub>map snd cms\\<^sub>1 ! j\\<^esub>\\<^sup>l subst \\<sigma>\n                         (snd (mems ! j))", "have \"x \\<in> (?mdss ! j) AsmNoReadOrWrite\""], ["proof (prove)\nusing this:\n  j < length cms\\<^sub>1 \\<and>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n  mem\\<^sub>1 x \\<noteq> mem\\<^sub>2 x\n  subst \\<sigma>\n   (fst (mems !\n         j)) =\\<^bsub>map snd cms\\<^sub>1 ! j\\<^esub>\\<^sup>l subst \\<sigma>\n                         (snd (mems ! j))\n\ngoal (1 subgoal):\n 1. x \\<in> (map snd cms\\<^sub>1 ! j) AsmNoReadOrWrite", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>j < length cms\\<^sub>1 \\<and>\n             x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j;\n     mem\\<^sub>1 x \\<noteq> mem\\<^sub>2 x;\n     subst \\<sigma>\n      (fst (mems !\n            j)) =\\<^bsub>map snd cms\\<^sub>1 ! j\\<^esub>\\<^sup>l subst\n                            \\<sigma> (snd (mems ! j))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> (map snd cms\\<^sub>1 ! j) AsmNoReadOrWrite", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>j < length cms\\<^sub>1 \\<and>\n             x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j;\n     mem\\<^sub>1 x \\<noteq> mem\\<^sub>2 x;\n     subst \\<sigma>\n      (fst (mems !\n            j)) =\\<^bsub>map snd cms\\<^sub>1 ! j\\<^esub>\\<^sup>l subst\n                            \\<sigma> (snd (mems ! j))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> (map snd cms\\<^sub>1 ! j) AsmNoReadOrWrite", "assume \"x \\<notin> (?mdss ! j) AsmNoReadOrWrite\""], ["proof (state)\nthis:\n  x \\<notin> (map snd cms\\<^sub>1 ! j) AsmNoReadOrWrite\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j < length cms\\<^sub>1 \\<and>\n             x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j;\n     mem\\<^sub>1 x \\<noteq> mem\\<^sub>2 x;\n     subst \\<sigma>\n      (fst (mems !\n            j)) =\\<^bsub>map snd cms\\<^sub>1 ! j\\<^esub>\\<^sup>l subst\n                            \\<sigma> (snd (mems ! j))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> (map snd cms\\<^sub>1 ! j) AsmNoReadOrWrite", "then"], ["proof (chain)\npicking this:\n  x \\<notin> (map snd cms\\<^sub>1 ! j) AsmNoReadOrWrite", "have mems_eq: \"?mems\\<^sub>1j x = ?mems\\<^sub>2j x\""], ["proof (prove)\nusing this:\n  x \\<notin> (map snd cms\\<^sub>1 ! j) AsmNoReadOrWrite\n\ngoal (1 subgoal):\n 1. fst (mems ! j) x = snd (mems ! j) x", "using \\<open>dma mem\\<^sub>1 x = Low\\<close> low_eq subst_eq\n        makes_compatible_dma_eq[OF compat jprop[THEN conjunct1] dom\\<sigma>]\n        low_mds_eq_def"], ["proof (prove)\nusing this:\n  x \\<notin> (map snd cms\\<^sub>1 ! j) AsmNoReadOrWrite\n  dma mem\\<^sub>1 x = Low\n  subst \\<sigma>\n   (fst (mems !\n         j)) =\\<^bsub>map snd cms\\<^sub>1 ! j\\<^esub>\\<^sup>l subst \\<sigma>\n                         (snd (mems ! j))\n  subst \\<sigma> (fst (mems ! j)) x = fst (mems ! j) x \\<and>\n  subst \\<sigma> (snd (mems ! j)) x = snd (mems ! j) x\n  dma (subst \\<sigma> (fst (mems ! j))) = dma mem\\<^sub>1\n  ?mem\\<^sub>1 =\\<^bsub>?mds\\<^esub>\\<^sup>l ?mem\\<^sub>2 \\<equiv>\n  \\<forall>x.\n     dma ?mem\\<^sub>1 x = Low \\<and>\n     (x \\<in> \\<C> \\<or> x \\<notin> ?mds AsmNoReadOrWrite) \\<longrightarrow>\n     ?mem\\<^sub>1 x = ?mem\\<^sub>2 x\n\ngoal (1 subgoal):\n 1. fst (mems ! j) x = snd (mems ! j) x", "by (metis (poly_guards_query))"], ["proof (state)\nthis:\n  fst (mems ! j) x = snd (mems ! j) x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j < length cms\\<^sub>1 \\<and>\n             x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j;\n     mem\\<^sub>1 x \\<noteq> mem\\<^sub>2 x;\n     subst \\<sigma>\n      (fst (mems !\n            j)) =\\<^bsub>map snd cms\\<^sub>1 ! j\\<^esub>\\<^sup>l subst\n                            \\<sigma> (snd (mems ! j))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> (map snd cms\\<^sub>1 ! j) AsmNoReadOrWrite", "hence \"mem\\<^sub>1 x = mem\\<^sub>2 x\""], ["proof (prove)\nusing this:\n  fst (mems ! j) x = snd (mems ! j) x\n\ngoal (1 subgoal):\n 1. mem\\<^sub>1 x = mem\\<^sub>2 x", "by (metis compat_different_vars jprop)"], ["proof (state)\nthis:\n  mem\\<^sub>1 x = mem\\<^sub>2 x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j < length cms\\<^sub>1 \\<and>\n             x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j;\n     mem\\<^sub>1 x \\<noteq> mem\\<^sub>2 x;\n     subst \\<sigma>\n      (fst (mems !\n            j)) =\\<^bsub>map snd cms\\<^sub>1 ! j\\<^esub>\\<^sup>l subst\n                            \\<sigma> (snd (mems ! j))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> (map snd cms\\<^sub>1 ! j) AsmNoReadOrWrite", "hence False"], ["proof (prove)\nusing this:\n  mem\\<^sub>1 x = mem\\<^sub>2 x\n\ngoal (1 subgoal):\n 1. False", "by (metis b)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j < length cms\\<^sub>1 \\<and>\n             x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j;\n     mem\\<^sub>1 x \\<noteq> mem\\<^sub>2 x;\n     subst \\<sigma>\n      (fst (mems !\n            j)) =\\<^bsub>map snd cms\\<^sub>1 ! j\\<^esub>\\<^sup>l subst\n                            \\<sigma> (snd (mems ! j))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> (map snd cms\\<^sub>1 ! j) AsmNoReadOrWrite", "}"], ["proof (state)\nthis:\n  x \\<notin> (map snd cms\\<^sub>1 ! j) AsmNoReadOrWrite \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. \\<lbrakk>j < length cms\\<^sub>1 \\<and>\n             x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j;\n     mem\\<^sub>1 x \\<noteq> mem\\<^sub>2 x;\n     subst \\<sigma>\n      (fst (mems !\n            j)) =\\<^bsub>map snd cms\\<^sub>1 ! j\\<^esub>\\<^sup>l subst\n                            \\<sigma> (snd (mems ! j))\\<rbrakk>\n    \\<Longrightarrow> x \\<in> (map snd cms\\<^sub>1 ! j) AsmNoReadOrWrite", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<notin> (map snd cms\\<^sub>1 ! j) AsmNoReadOrWrite \\<Longrightarrow>\n  False\n\ngoal (1 subgoal):\n 1. x \\<in> (map snd cms\\<^sub>1 ! j) AsmNoReadOrWrite", "by metis"], ["proof (state)\nthis:\n  x \\<in> (map snd cms\\<^sub>1 ! j) AsmNoReadOrWrite\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> (map snd cms\\<^sub>1 ! j) AsmNoReadOrWrite\n\ngoal (1 subgoal):\n 1. doesnt_read_or_modify (fst (cms\\<^sub>1 ! i)) x \\<and>\n    doesnt_read_or_modify (fst (cms\\<^sub>2 ! i)) x", "hence \"x \\<in> (?mdss ! i) GuarNoReadOrWrite\""], ["proof (prove)\nusing this:\n  x \\<in> (map snd cms\\<^sub>1 ! j) AsmNoReadOrWrite\n\ngoal (1 subgoal):\n 1. x \\<in> (map snd cms\\<^sub>1 ! i) GuarNoReadOrWrite", "using sound_modes jprop"], ["proof (prove)\nusing this:\n  x \\<in> (map snd cms\\<^sub>1 ! j) AsmNoReadOrWrite\n  sound_mode_use (cms\\<^sub>1, mem\\<^sub>1)\n  sound_mode_use (cms\\<^sub>2, mem\\<^sub>2)\n  j < length cms\\<^sub>1 \\<and>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n\ngoal (1 subgoal):\n 1. x \\<in> (map snd cms\\<^sub>1 ! i) GuarNoReadOrWrite", "by (metis compatible_modes_def globally_sound_modes_compatible\n      length_map sound_mode_use.simps x ile)"], ["proof (state)\nthis:\n  x \\<in> (map snd cms\\<^sub>1 ! i) GuarNoReadOrWrite\n\ngoal (1 subgoal):\n 1. doesnt_read_or_modify (fst (cms\\<^sub>1 ! i)) x \\<and>\n    doesnt_read_or_modify (fst (cms\\<^sub>2 ! i)) x", "thus \"doesnt_read_or_modify (fst (cms\\<^sub>1 ! i)) x \\<and> doesnt_read_or_modify (fst (cms\\<^sub>2 ! i)) x\""], ["proof (prove)\nusing this:\n  x \\<in> (map snd cms\\<^sub>1 ! i) GuarNoReadOrWrite\n\ngoal (1 subgoal):\n 1. doesnt_read_or_modify (fst (cms\\<^sub>1 ! i)) x \\<and>\n    doesnt_read_or_modify (fst (cms\\<^sub>2 ! i)) x", "using sound_modes ile"], ["proof (prove)\nusing this:\n  x \\<in> (map snd cms\\<^sub>1 ! i) GuarNoReadOrWrite\n  sound_mode_use (cms\\<^sub>1, mem\\<^sub>1)\n  sound_mode_use (cms\\<^sub>2, mem\\<^sub>2)\n  i < length cms\\<^sub>1\n\ngoal (1 subgoal):\n 1. doesnt_read_or_modify (fst (cms\\<^sub>1 ! i)) x \\<and>\n    doesnt_read_or_modify (fst (cms\\<^sub>2 ! i)) x", "by (metis len modes_eq sound_modes_no_read)"], ["proof (state)\nthis:\n  doesnt_read_or_modify (fst (cms\\<^sub>1 ! i)) x \\<and>\n  doesnt_read_or_modify (fst (cms\\<^sub>2 ! i)) x\n\ngoal:\nNo subgoals!", "qed"], ["", "definition\n  vars_and_\\<C> :: \"'Var set \\<Rightarrow> 'Var set\"\nwhere\n  \"vars_and_\\<C> X \\<equiv> X \\<union> vars_\\<C> X\""], ["", "(* Toby: most of the complexity drops out as doesnt_read_or_modify now implies doesnt_modify *)"], ["", "fun change_respecting ::\n  \"('Com, 'Var, 'Val) LocalConf \\<Rightarrow>\n   ('Com, 'Var, 'Val) LocalConf \\<Rightarrow>\n   'Var set \\<Rightarrow> bool\"\n  where \"change_respecting (cms, mem) (cms', mem') X =\n      ((cms, mem) \\<leadsto> (cms', mem') \\<and>\n       (\\<forall> \\<sigma>. dom \\<sigma> = vars_and_\\<C> X \\<longrightarrow> (cms, mem [\\<mapsto> \\<sigma>]) \\<leadsto> (cms', mem' [\\<mapsto> \\<sigma>])))\""], ["", "lemma subst_overrides: \"dom \\<sigma> = dom \\<tau> \\<Longrightarrow> mem [\\<mapsto> \\<tau>] [\\<mapsto> \\<sigma>] = mem [\\<mapsto> \\<sigma>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom \\<sigma> = dom \\<tau> \\<Longrightarrow>\n    subst \\<sigma> (subst \\<tau> mem) = subst \\<sigma> mem", "unfolding subst_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dom \\<sigma> = dom \\<tau> \\<Longrightarrow>\n    (\\<lambda>x.\n        case \\<sigma> x of\n        None \\<Rightarrow>\n          case \\<tau> x of None \\<Rightarrow> mem x | Some v \\<Rightarrow> v\n        | Some v \\<Rightarrow> v) =\n    (\\<lambda>x.\n        case \\<sigma> x of None \\<Rightarrow> mem x\n        | Some v \\<Rightarrow> v)", "by (metis domIff option.exhaust option.simps(4) option.simps(5))"], ["", "definition to_partial :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> ('a \\<rightharpoonup> 'b)\"\n  where \"to_partial f = (\\<lambda> x. Some (f x))\""], ["", "lemma dom_restrict_total: \"dom (to_partial f |` X) = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (to_partial f |` X) = X", "unfolding to_partial_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dom ((\\<lambda>x. Some (f x)) |` X) = X", "by (metis Int_UNIV_left dom_const dom_restrict)"], ["", "lemma change_respecting_doesnt_modify':\n  assumes eval: \"(cms, mem) \\<leadsto> (cms', mem')\"\n  assumes cr: \"\\<forall> f. dom f = Y \\<longrightarrow> (cms, mem [\\<mapsto> f]) \\<leadsto> (cms', mem' [\\<mapsto> f])\"\n  assumes x_in_dom: \"x \\<in> Y\"\n  shows \"mem x = mem' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mem x = mem' x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mem x = mem' x", "let ?f' = \"to_partial mem |` Y\""], ["proof (state)\ngoal (1 subgoal):\n 1. mem x = mem' x", "have domf': \"dom ?f' = Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (to_partial mem |` Y) = Y", "by (metis dom_restrict_total)"], ["proof (state)\nthis:\n  dom (to_partial mem |` Y) = Y\n\ngoal (1 subgoal):\n 1. mem x = mem' x", "from this cr"], ["proof (chain)\npicking this:\n  dom (to_partial mem |` Y) = Y\n  \\<forall>f.\n     dom f = Y \\<longrightarrow>\n     (cms, subst f mem) \\<leadsto> (cms', subst f mem')", "have eval': \"(cms, mem [\\<mapsto> ?f']) \\<leadsto> (cms', mem' [\\<mapsto> ?f'])\""], ["proof (prove)\nusing this:\n  dom (to_partial mem |` Y) = Y\n  \\<forall>f.\n     dom f = Y \\<longrightarrow>\n     (cms, subst f mem) \\<leadsto> (cms', subst f mem')\n\ngoal (1 subgoal):\n 1. (cms, subst (to_partial mem |` Y) mem) \\<leadsto>\n    (cms', subst (to_partial mem |` Y) mem')", "by (metis)"], ["proof (state)\nthis:\n  (cms, subst (to_partial mem |` Y) mem) \\<leadsto>\n  (cms', subst (to_partial mem |` Y) mem')\n\ngoal (1 subgoal):\n 1. mem x = mem' x", "have mem_eq: \"mem [\\<mapsto> ?f'] = mem\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (to_partial mem |` Y) mem = mem", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. subst (to_partial mem |` Y) mem x = mem x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. subst (to_partial mem |` Y) mem x = mem x", "show \"mem [\\<mapsto> ?f'] x = mem x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst (to_partial mem |` Y) mem x = mem x", "unfolding subst_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (case (to_partial mem |` Y) x of None \\<Rightarrow> mem x\n     | Some v \\<Rightarrow> v) =\n    mem x", "apply (cases \"x \\<in> Y\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. x \\<in> Y \\<Longrightarrow>\n    (case (to_partial mem |` Y) x of None \\<Rightarrow> mem x\n     | Some v \\<Rightarrow> v) =\n    mem x\n 2. x \\<notin> Y \\<Longrightarrow>\n    (case (to_partial mem |` Y) x of None \\<Rightarrow> mem x\n     | Some v \\<Rightarrow> v) =\n    mem x", "apply (metis option.simps(5) restrict_in to_partial_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> Y \\<Longrightarrow>\n    (case (to_partial mem |` Y) x of None \\<Rightarrow> mem x\n     | Some v \\<Rightarrow> v) =\n    mem x", "by (metis domf' subst_def subst_not_in_dom)"], ["proof (state)\nthis:\n  subst (to_partial mem |` Y) mem x = mem x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst (to_partial mem |` Y) mem = mem\n\ngoal (1 subgoal):\n 1. mem x = mem' x", "then"], ["proof (chain)\npicking this:\n  subst (to_partial mem |` Y) mem = mem", "have mem'_eq: \"mem' [\\<mapsto> ?f'] = mem'\""], ["proof (prove)\nusing this:\n  subst (to_partial mem |` Y) mem = mem\n\ngoal (1 subgoal):\n 1. subst (to_partial mem |` Y) mem' = mem'", "using eval eval' deterministic"], ["proof (prove)\nusing this:\n  subst (to_partial mem |` Y) mem = mem\n  (cms, mem) \\<leadsto> (cms', mem')\n  (cms, subst (to_partial mem |` Y) mem) \\<leadsto>\n  (cms', subst (to_partial mem |` Y) mem')\n  \\<lbrakk>?lc \\<leadsto> ?lc'; ?lc \\<leadsto> ?lc''\\<rbrakk>\n  \\<Longrightarrow> ?lc' = ?lc''\n\ngoal (1 subgoal):\n 1. subst (to_partial mem |` Y) mem' = mem'", "by (metis Pair_inject)"], ["proof (state)\nthis:\n  subst (to_partial mem |` Y) mem' = mem'\n\ngoal (1 subgoal):\n 1. mem x = mem' x", "moreover"], ["proof (state)\nthis:\n  subst (to_partial mem |` Y) mem' = mem'\n\ngoal (1 subgoal):\n 1. mem x = mem' x", "have x_in_dom': \"x \\<in> dom ?f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> dom (to_partial mem |` Y)", "by (metis x_in_dom dom_restrict_total)"], ["proof (state)\nthis:\n  x \\<in> dom (to_partial mem |` Y)\n\ngoal (1 subgoal):\n 1. mem x = mem' x", "hence \"?f' x = Some (mem x)\""], ["proof (prove)\nusing this:\n  x \\<in> dom (to_partial mem |` Y)\n\ngoal (1 subgoal):\n 1. (to_partial mem |` Y) x = Some (mem x)", "by (metis restrict_in to_partial_def x_in_dom)"], ["proof (state)\nthis:\n  (to_partial mem |` Y) x = Some (mem x)\n\ngoal (1 subgoal):\n 1. mem x = mem' x", "hence \"mem' [\\<mapsto> ?f'] x = mem x\""], ["proof (prove)\nusing this:\n  (to_partial mem |` Y) x = Some (mem x)\n\ngoal (1 subgoal):\n 1. subst (to_partial mem |` Y) mem' x = mem x", "using subst_def x_in_dom'"], ["proof (prove)\nusing this:\n  (to_partial mem |` Y) x = Some (mem x)\n  subst ?f ?mem =\n  (\\<lambda>x.\n      case ?f x of None \\<Rightarrow> ?mem x | Some v \\<Rightarrow> v)\n  x \\<in> dom (to_partial mem |` Y)\n\ngoal (1 subgoal):\n 1. subst (to_partial mem |` Y) mem' x = mem x", "by (metis option.simps(5))"], ["proof (state)\nthis:\n  subst (to_partial mem |` Y) mem' x = mem x\n\ngoal (1 subgoal):\n 1. mem x = mem' x", "thus \"mem x = mem' x\""], ["proof (prove)\nusing this:\n  subst (to_partial mem |` Y) mem' x = mem x\n\ngoal (1 subgoal):\n 1. mem x = mem' x", "by (metis mem'_eq)"], ["proof (state)\nthis:\n  mem x = mem' x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma change_respecting_subset':\n  assumes step: \"(cms, mem) \\<leadsto> (cms', mem')\"\n  assumes noread: \"(\\<forall> \\<sigma>. dom \\<sigma> = X \\<longrightarrow> (cms, mem [\\<mapsto> \\<sigma>]) \\<leadsto> (cms', mem' [\\<mapsto> \\<sigma>]))\"\n  assumes dom_subset: \"dom \\<sigma> \\<subseteq> X\"\n  shows \"(cms, mem [\\<mapsto> \\<sigma>]) \\<leadsto> (cms', mem' [\\<mapsto> \\<sigma>])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cms, subst \\<sigma> mem) \\<leadsto> (cms', subst \\<sigma> mem')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (cms, subst \\<sigma> mem) \\<leadsto> (cms', subst \\<sigma> mem')", "define \\<sigma>\\<^sub>X where \"\\<sigma>\\<^sub>X x = (if x \\<in> X then if x \\<in> dom \\<sigma> then \\<sigma> x else Some (mem x) else None)\" for x"], ["proof (state)\nthis:\n  \\<sigma>\\<^sub>X ?x =\n  (if ?x \\<in> X\n   then if ?x \\<in> dom \\<sigma> then \\<sigma> ?x else Some (mem ?x)\n   else None)\n\ngoal (1 subgoal):\n 1. (cms, subst \\<sigma> mem) \\<leadsto> (cms', subst \\<sigma> mem')", "have \"dom \\<sigma>\\<^sub>X = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom \\<sigma>\\<^sub>X = X", "using dom_subset"], ["proof (prove)\nusing this:\n  dom \\<sigma> \\<subseteq> X\n\ngoal (1 subgoal):\n 1. dom \\<sigma>\\<^sub>X = X", "by(auto simp: \\<sigma>\\<^sub>X_def)"], ["proof (state)\nthis:\n  dom \\<sigma>\\<^sub>X = X\n\ngoal (1 subgoal):\n 1. (cms, subst \\<sigma> mem) \\<leadsto> (cms', subst \\<sigma> mem')", "have \"mem [\\<mapsto> \\<sigma>] = mem [\\<mapsto> \\<sigma>\\<^sub>X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst \\<sigma> mem = subst \\<sigma>\\<^sub>X mem", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. subst \\<sigma> mem x = subst \\<sigma>\\<^sub>X mem x", "using dom_subset"], ["proof (prove)\nusing this:\n  dom \\<sigma> \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<And>x. subst \\<sigma> mem x = subst \\<sigma>\\<^sub>X mem x", "apply(auto simp: subst_def \\<sigma>\\<^sub>X_def split: option.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  subst \\<sigma> mem = subst \\<sigma>\\<^sub>X mem\n\ngoal (1 subgoal):\n 1. (cms, subst \\<sigma> mem) \\<leadsto> (cms', subst \\<sigma> mem')", "moreover"], ["proof (state)\nthis:\n  subst \\<sigma> mem = subst \\<sigma>\\<^sub>X mem\n\ngoal (1 subgoal):\n 1. (cms, subst \\<sigma> mem) \\<leadsto> (cms', subst \\<sigma> mem')", "have \"mem' [\\<mapsto> \\<sigma>] = mem' [\\<mapsto> \\<sigma>\\<^sub>X]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst \\<sigma> mem' = subst \\<sigma>\\<^sub>X mem'", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. subst \\<sigma> mem' x = subst \\<sigma>\\<^sub>X mem' x", "using dom_subset"], ["proof (prove)\nusing this:\n  dom \\<sigma> \\<subseteq> X\n\ngoal (1 subgoal):\n 1. \\<And>x. subst \\<sigma> mem' x = subst \\<sigma>\\<^sub>X mem' x", "apply(auto simp: subst_def \\<sigma>\\<^sub>X_def split: option.splits simp: change_respecting_doesnt_modify'[OF step noread])"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  subst \\<sigma> mem' = subst \\<sigma>\\<^sub>X mem'\n\ngoal (1 subgoal):\n 1. (cms, subst \\<sigma> mem) \\<leadsto> (cms', subst \\<sigma> mem')", "moreover"], ["proof (state)\nthis:\n  subst \\<sigma> mem' = subst \\<sigma>\\<^sub>X mem'\n\ngoal (1 subgoal):\n 1. (cms, subst \\<sigma> mem) \\<leadsto> (cms', subst \\<sigma> mem')", "from noread \\<open>dom \\<sigma>\\<^sub>X = X\\<close>"], ["proof (chain)\npicking this:\n  \\<forall>\\<sigma>.\n     dom \\<sigma> = X \\<longrightarrow>\n     (cms, subst \\<sigma> mem) \\<leadsto> (cms', subst \\<sigma> mem')\n  dom \\<sigma>\\<^sub>X = X", "have \"(cms, mem [\\<mapsto> \\<sigma>\\<^sub>X]) \\<leadsto> (cms', mem' [\\<mapsto> \\<sigma>\\<^sub>X])\""], ["proof (prove)\nusing this:\n  \\<forall>\\<sigma>.\n     dom \\<sigma> = X \\<longrightarrow>\n     (cms, subst \\<sigma> mem) \\<leadsto> (cms', subst \\<sigma> mem')\n  dom \\<sigma>\\<^sub>X = X\n\ngoal (1 subgoal):\n 1. (cms, subst \\<sigma>\\<^sub>X mem) \\<leadsto>\n    (cms', subst \\<sigma>\\<^sub>X mem')", "by metis"], ["proof (state)\nthis:\n  (cms, subst \\<sigma>\\<^sub>X mem) \\<leadsto>\n  (cms', subst \\<sigma>\\<^sub>X mem')\n\ngoal (1 subgoal):\n 1. (cms, subst \\<sigma> mem) \\<leadsto> (cms', subst \\<sigma> mem')", "ultimately"], ["proof (chain)\npicking this:\n  subst \\<sigma> mem = subst \\<sigma>\\<^sub>X mem\n  subst \\<sigma> mem' = subst \\<sigma>\\<^sub>X mem'\n  (cms, subst \\<sigma>\\<^sub>X mem) \\<leadsto>\n  (cms', subst \\<sigma>\\<^sub>X mem')", "show ?thesis"], ["proof (prove)\nusing this:\n  subst \\<sigma> mem = subst \\<sigma>\\<^sub>X mem\n  subst \\<sigma> mem' = subst \\<sigma>\\<^sub>X mem'\n  (cms, subst \\<sigma>\\<^sub>X mem) \\<leadsto>\n  (cms', subst \\<sigma>\\<^sub>X mem')\n\ngoal (1 subgoal):\n 1. (cms, subst \\<sigma> mem) \\<leadsto> (cms', subst \\<sigma> mem')", "by simp"], ["proof (state)\nthis:\n  (cms, subst \\<sigma> mem) \\<leadsto> (cms', subst \\<sigma> mem')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma change_respecting_subst:\n  \"change_respecting (cms, mem) (cms', mem') X \\<Longrightarrow>\n       (\\<forall> \\<sigma>. dom \\<sigma> = X \\<longrightarrow> (cms, mem [\\<mapsto> \\<sigma>]) \\<leadsto> (cms', mem' [\\<mapsto> \\<sigma>]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. change_respecting (cms, mem) (cms', mem') X \\<Longrightarrow>\n    \\<forall>\\<sigma>.\n       dom \\<sigma> = X \\<longrightarrow>\n       (cms, subst \\<sigma> mem) \\<leadsto> (cms', subst \\<sigma> mem')", "unfolding change_respecting.simps vars_and_\\<C>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cms, mem) \\<leadsto> (cms', mem') \\<and>\n    (\\<forall>\\<sigma>.\n        dom \\<sigma> = X \\<union> vars_\\<C> X \\<longrightarrow>\n        (cms, subst \\<sigma> mem) \\<leadsto>\n        (cms', subst \\<sigma> mem')) \\<Longrightarrow>\n    \\<forall>\\<sigma>.\n       dom \\<sigma> = X \\<longrightarrow>\n       (cms, subst \\<sigma> mem) \\<leadsto> (cms', subst \\<sigma> mem')", "using change_respecting_subset'"], ["proof (prove)\nusing this:\n  \\<lbrakk>(?cms, ?mem) \\<leadsto> (?cms', ?mem');\n   \\<forall>\\<sigma>.\n      dom \\<sigma> = ?X \\<longrightarrow>\n      (?cms, subst \\<sigma> ?mem) \\<leadsto> (?cms', subst \\<sigma> ?mem');\n   dom ?\\<sigma> \\<subseteq> ?X\\<rbrakk>\n  \\<Longrightarrow> (?cms, subst ?\\<sigma> ?mem) \\<leadsto>\n                    (?cms', subst ?\\<sigma> ?mem')\n\ngoal (1 subgoal):\n 1. (cms, mem) \\<leadsto> (cms', mem') \\<and>\n    (\\<forall>\\<sigma>.\n        dom \\<sigma> = X \\<union> vars_\\<C> X \\<longrightarrow>\n        (cms, subst \\<sigma> mem) \\<leadsto>\n        (cms', subst \\<sigma> mem')) \\<Longrightarrow>\n    \\<forall>\\<sigma>.\n       dom \\<sigma> = X \\<longrightarrow>\n       (cms, subst \\<sigma> mem) \\<leadsto> (cms', subst \\<sigma> mem')", "by blast"], ["", "lemma change_respecting_intro [iff]:\n  \"\\<lbrakk> \\<langle> c, mds, mem \\<rangle> \\<leadsto> \\<langle> c', mds', mem' \\<rangle>;\n     \\<And> f. dom f = vars_and_\\<C> X \\<Longrightarrow>\n           (\\<langle> c, mds, mem [\\<mapsto> f] \\<rangle> \\<leadsto> \\<langle> c', mds', mem' [\\<mapsto> f] \\<rangle>) \\<rbrakk>\n  \\<Longrightarrow> change_respecting \\<langle>c, mds, mem\\<rangle> \\<langle>c', mds', mem'\\<rangle> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<langle>c, mds, mem\\<rangle> \\<leadsto>\n             \\<langle>c', mds', mem'\\<rangle>;\n     \\<And>f.\n        dom f = vars_and_\\<C> X \\<Longrightarrow>\n        \\<langle>c, mds, subst f mem\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst f mem'\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> change_respecting \\<langle>c, mds, mem\\<rangle>\n                       \\<langle>c', mds', mem'\\<rangle> X", "unfolding change_respecting.simps"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<langle>c, mds, mem\\<rangle> \\<leadsto>\n             \\<langle>c', mds', mem'\\<rangle>;\n     \\<And>f.\n        dom f = vars_and_\\<C> X \\<Longrightarrow>\n        \\<langle>c, mds, subst f mem\\<rangle> \\<leadsto>\n        \\<langle>c', mds', subst f mem'\\<rangle>\\<rbrakk>\n    \\<Longrightarrow> \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n                      \\<langle>c', mds', mem'\\<rangle> \\<and>\n                      (\\<forall>\\<sigma>.\n                          dom \\<sigma> = vars_and_\\<C> X \\<longrightarrow>\n                          \\<langle>c, mds, subst \\<sigma>\n      mem\\<rangle> \\<leadsto>\n                          \\<langle>c', mds', subst \\<sigma> mem'\\<rangle>)", "by blast"], ["", "lemma vars_\\<C>_mono:\n  \"X \\<subseteq> Y \\<Longrightarrow> vars_\\<C> X \\<subseteq> vars_\\<C> Y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<subseteq> Y \\<Longrightarrow> vars_\\<C> X \\<subseteq> vars_\\<C> Y", "by(auto simp: vars_\\<C>_def)"], ["", "lemma vars_\\<C>_Un:\n  \"vars_\\<C> (X \\<union> Y) = (vars_\\<C> X \\<union> vars_\\<C> Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars_\\<C> (X \\<union> Y) = vars_\\<C> X \\<union> vars_\\<C> Y", "by(simp add: vars_\\<C>_def)"], ["", "lemma vars_\\<C>_insert:\n  \"vars_\\<C> (insert x Y) = (vars_\\<C> {x}) \\<union> (vars_\\<C> Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars_\\<C> (insert x Y) = vars_\\<C> {x} \\<union> vars_\\<C> Y", "apply(subst insert_is_Un)"], ["proof (prove)\ngoal (1 subgoal):\n 1. vars_\\<C> ({x} \\<union> Y) = vars_\\<C> {x} \\<union> vars_\\<C> Y", "apply(rule vars_\\<C>_Un)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma vars_\\<C>_empty[simp]:\n  \"vars_\\<C> {} = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars_\\<C> {} = {}", "by(simp add: vars_\\<C>_def)"], ["", "lemma \\<C>_vars_of_\\<C>_vars_empty:\n  \"x \\<in> \\<C>_vars y \\<Longrightarrow> \\<C>_vars x = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> \\<C>_vars y \\<Longrightarrow> \\<C>_vars x = {}", "apply(drule subsetD[OF \\<C>_vars_subset_\\<C>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> \\<C> \\<Longrightarrow> \\<C>_vars x = {}", "apply(erule \\<C>_vars_\\<C>)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma vars_and_\\<C>_mono:\n  \"X \\<subseteq> X' \\<Longrightarrow> vars_and_\\<C> X \\<subseteq> vars_and_\\<C> X'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<subseteq> X' \\<Longrightarrow>\n    vars_and_\\<C> X \\<subseteq> vars_and_\\<C> X'", "apply(unfold vars_and_\\<C>_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. X \\<subseteq> X' \\<Longrightarrow>\n    X \\<union> vars_\\<C> X \\<subseteq> X' \\<union> vars_\\<C> X'", "apply(metis Un_mono vars_\\<C>_mono)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma \\<C>_vars_finite[simp]:\n  \"finite (\\<C>_vars x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (\\<C>_vars x)", "apply(rule finite_subset[OF _ finite_memory])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<C>_vars x \\<subseteq> {x. True}", "by blast"], ["", "lemma finite_dom:\n  \"finite (dom (\\<sigma>::'Var \\<Rightarrow> 'Val option))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (dom \\<sigma>)", "by(blast intro: finite_subset[OF _ finite_memory])"], ["", "lemma doesnt_read_or_modify_subst: \n  assumes noread: \"doesnt_read_or_modify c x\"\n  assumes step: \"\\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\"\n  assumes subset: \"X \\<subseteq> {x} \\<union> \\<C>_vars x\"\n  shows \"\\<And> \\<sigma>. dom \\<sigma> = X \\<Longrightarrow> \\<langle>c, mds, mem[\\<mapsto> \\<sigma>]\\<rangle> \\<leadsto> \\<langle>c', mds', mem'[\\<mapsto> \\<sigma>]\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       dom \\<sigma> = X \\<Longrightarrow>\n       \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst \\<sigma> mem'\\<rangle>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       dom \\<sigma> = X \\<Longrightarrow>\n       \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst \\<sigma> mem'\\<rangle>", "have \"finite X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite X", "using subset"], ["proof (prove)\nusing this:\n  X \\<subseteq> {x} \\<union> \\<C>_vars x\n\ngoal (1 subgoal):\n 1. finite X", "apply(rule finite_subset)"], ["proof (prove)\ngoal (1 subgoal):\n 1. finite ({x} \\<union> \\<C>_vars x)", "by simp"], ["proof (state)\nthis:\n  finite X\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       dom \\<sigma> = X \\<Longrightarrow>\n       \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst \\<sigma> mem'\\<rangle>", "show \"\\<And> \\<sigma>. dom \\<sigma> = X \\<Longrightarrow> \\<langle>c, mds, mem[\\<mapsto> \\<sigma>]\\<rangle> \\<leadsto> \\<langle>c', mds', mem'[\\<mapsto> \\<sigma>]\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       dom \\<sigma> = X \\<Longrightarrow>\n       \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst \\<sigma> mem'\\<rangle>", "using \\<open>finite X\\<close> subset"], ["proof (prove)\nusing this:\n  finite X\n  X \\<subseteq> {x} \\<union> \\<C>_vars x\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       dom \\<sigma> = X \\<Longrightarrow>\n       \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst \\<sigma> mem'\\<rangle>", "proof(induct \"X\" rule: finite_subset_induct[where A=\"{x} \\<union> \\<C>_vars x\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       dom \\<sigma> = {} \\<Longrightarrow>\n       \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst \\<sigma> mem'\\<rangle>\n 2. \\<And>a F \\<sigma>.\n       \\<lbrakk>finite F; a \\<in> {x} \\<union> \\<C>_vars x; a \\<notin> F;\n        \\<And>\\<sigma>.\n           dom \\<sigma> = F \\<Longrightarrow>\n           \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n           \\<langle>c', mds', subst \\<sigma> mem'\\<rangle>;\n        dom \\<sigma> = insert a F\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c, mds, subst \\<sigma>\n     mem\\<rangle> \\<leadsto>\n                         \\<langle>c', mds', subst \\<sigma> mem'\\<rangle>", "case empty"], ["proof (state)\nthis:\n  dom \\<sigma> = {}\n\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       dom \\<sigma> = {} \\<Longrightarrow>\n       \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst \\<sigma> mem'\\<rangle>\n 2. \\<And>a F \\<sigma>.\n       \\<lbrakk>finite F; a \\<in> {x} \\<union> \\<C>_vars x; a \\<notin> F;\n        \\<And>\\<sigma>.\n           dom \\<sigma> = F \\<Longrightarrow>\n           \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n           \\<langle>c', mds', subst \\<sigma> mem'\\<rangle>;\n        dom \\<sigma> = insert a F\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c, mds, subst \\<sigma>\n     mem\\<rangle> \\<leadsto>\n                         \\<langle>c', mds', subst \\<sigma> mem'\\<rangle>", "thus \"\\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto> \\<langle>c', mds', subst \\<sigma> mem'\\<rangle>\""], ["proof (prove)\nusing this:\n  dom \\<sigma> = {}\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst \\<sigma> mem'\\<rangle>", "using step"], ["proof (prove)\nusing this:\n  dom \\<sigma> = {}\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst \\<sigma> mem'\\<rangle>", "by(simp add: subst_def)"], ["proof (state)\nthis:\n  \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst \\<sigma> mem'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>a F \\<sigma>.\n       \\<lbrakk>finite F; a \\<in> {x} \\<union> \\<C>_vars x; a \\<notin> F;\n        \\<And>\\<sigma>.\n           dom \\<sigma> = F \\<Longrightarrow>\n           \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n           \\<langle>c', mds', subst \\<sigma> mem'\\<rangle>;\n        dom \\<sigma> = insert a F\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c, mds, subst \\<sigma>\n     mem\\<rangle> \\<leadsto>\n                         \\<langle>c', mds', subst \\<sigma> mem'\\<rangle>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a F \\<sigma>.\n       \\<lbrakk>finite F; a \\<in> {x} \\<union> \\<C>_vars x; a \\<notin> F;\n        \\<And>\\<sigma>.\n           dom \\<sigma> = F \\<Longrightarrow>\n           \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n           \\<langle>c', mds', subst \\<sigma> mem'\\<rangle>;\n        dom \\<sigma> = insert a F\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c, mds, subst \\<sigma>\n     mem\\<rangle> \\<leadsto>\n                         \\<langle>c', mds', subst \\<sigma> mem'\\<rangle>", "case (insert a X)"], ["proof (state)\nthis:\n  finite X\n  a \\<in> {x} \\<union> \\<C>_vars x\n  a \\<notin> X\n  dom ?\\<sigma>5 = X \\<Longrightarrow>\n  \\<langle>c, mds, subst ?\\<sigma>5 mem\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst ?\\<sigma>5 mem'\\<rangle>\n  dom \\<sigma> = insert a X\n\ngoal (1 subgoal):\n 1. \\<And>a F \\<sigma>.\n       \\<lbrakk>finite F; a \\<in> {x} \\<union> \\<C>_vars x; a \\<notin> F;\n        \\<And>\\<sigma>.\n           dom \\<sigma> = F \\<Longrightarrow>\n           \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n           \\<langle>c', mds', subst \\<sigma> mem'\\<rangle>;\n        dom \\<sigma> = insert a F\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c, mds, subst \\<sigma>\n     mem\\<rangle> \\<leadsto>\n                         \\<langle>c', mds', subst \\<sigma> mem'\\<rangle>", "show \"\\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto> \\<langle>c', mds', subst \\<sigma> mem'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst \\<sigma> mem'\\<rangle>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst \\<sigma> mem'\\<rangle>", "let ?\\<sigma>\\<^sub>X = \"(\\<sigma> |` X)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst \\<sigma> mem'\\<rangle>", "have IH\\<^sub>X: \"\\<langle>c, mds, subst ?\\<sigma>\\<^sub>X mem\\<rangle> \\<leadsto> \\<langle>c', mds', subst ?\\<sigma>\\<^sub>X mem'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst (\\<sigma> |` X) mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (\\<sigma> |` X) mem'\\<rangle>", "apply(rule insert(4))"], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (\\<sigma> |` X) = X", "using insert"], ["proof (prove)\nusing this:\n  finite X\n  a \\<in> {x} \\<union> \\<C>_vars x\n  a \\<notin> X\n  dom ?\\<sigma>5 = X \\<Longrightarrow>\n  \\<langle>c, mds, subst ?\\<sigma>5 mem\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst ?\\<sigma>5 mem'\\<rangle>\n  dom \\<sigma> = insert a X\n\ngoal (1 subgoal):\n 1. dom (\\<sigma> |` X) = X", "by (metis dom_restrict inf.absorb2 subset_insertI)"], ["proof (state)\nthis:\n  \\<langle>c, mds, subst (\\<sigma> |` X) mem\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (\\<sigma> |` X) mem'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst \\<sigma> mem'\\<rangle>", "from insert"], ["proof (chain)\npicking this:\n  finite X\n  a \\<in> {x} \\<union> \\<C>_vars x\n  a \\<notin> X\n  dom ?\\<sigma>5 = X \\<Longrightarrow>\n  \\<langle>c, mds, subst ?\\<sigma>5 mem\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst ?\\<sigma>5 mem'\\<rangle>\n  dom \\<sigma> = insert a X", "obtain v where \\<sigma>a: \"\\<sigma> a = Some v\""], ["proof (prove)\nusing this:\n  finite X\n  a \\<in> {x} \\<union> \\<C>_vars x\n  a \\<notin> X\n  dom ?\\<sigma>5 = X \\<Longrightarrow>\n  \\<langle>c, mds, subst ?\\<sigma>5 mem\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst ?\\<sigma>5 mem'\\<rangle>\n  dom \\<sigma> = insert a X\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<sigma> a = Some v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<sigma> a = Some v\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst \\<sigma> mem'\\<rangle>", "have r: \"\\<And>mem. (subst ?\\<sigma>\\<^sub>X mem)(a := v) = subst \\<sigma> mem\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>mem. (subst (\\<sigma> |` X) mem)(a := v) = subst \\<sigma> mem", "apply(rule ext, rename_tac y)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>mem y.\n       ((subst (\\<sigma> |` X) mem)(a := v)) y = subst \\<sigma> mem y", "apply(simp, safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>mem y. v = subst \\<sigma> mem a\n 2. \\<And>mem y.\n       y \\<noteq> a \\<Longrightarrow>\n       subst (\\<sigma> |` X) mem y = subst \\<sigma> mem y", "apply(simp add: subst_def \\<sigma>a)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>mem y.\n       y \\<noteq> a \\<Longrightarrow>\n       subst (\\<sigma> |` X) mem y = subst \\<sigma> mem y", "using \\<open>a \\<notin> X\\<close> insert"], ["proof (prove)\nusing this:\n  a \\<notin> X\n  finite X\n  a \\<in> {x} \\<union> \\<C>_vars x\n  a \\<notin> X\n  dom ?\\<sigma>5 = X \\<Longrightarrow>\n  \\<langle>c, mds, subst ?\\<sigma>5 mem\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst ?\\<sigma>5 mem'\\<rangle>\n  dom \\<sigma> = insert a X\n\ngoal (1 subgoal):\n 1. \\<And>mem y.\n       y \\<noteq> a \\<Longrightarrow>\n       subst (\\<sigma> |` X) mem y = subst \\<sigma> mem y", "apply(auto simp: subst_def split: option.splits simp: restrict_map_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (subst (\\<sigma> |` X) ?mem5)(a := v) = subst \\<sigma> ?mem5\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst \\<sigma> mem'\\<rangle>", "have \"\\<langle>c, mds, (subst ?\\<sigma>\\<^sub>X mem)(a := v)\\<rangle> \\<leadsto> \\<langle>c', mds', (subst ?\\<sigma>\\<^sub>X mem')(a := v)\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>c, mds, (subst (\\<sigma> |` X) mem)(a := v)\\<rangle> \\<leadsto>\n    \\<langle>c', mds', (subst (\\<sigma> |` X) mem')(a := v)\\<rangle>", "using noread \\<open>a \\<in> {x} \\<union> \\<C>_vars x\\<close> IH\\<^sub>X"], ["proof (prove)\nusing this:\n  doesnt_read_or_modify c x\n  a \\<in> {x} \\<union> \\<C>_vars x\n  \\<langle>c, mds, subst (\\<sigma> |` X) mem\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (\\<sigma> |` X) mem'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, (subst (\\<sigma> |` X) mem)(a := v)\\<rangle> \\<leadsto>\n    \\<langle>c', mds', (subst (\\<sigma> |` X) mem')(a := v)\\<rangle>", "unfolding doesnt_read_or_modify_def doesnt_read_or_modify_vars_def"], ["proof (prove)\nusing this:\n  \\<forall>mds mem c' mds' mem'.\n     \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n     \\<langle>c', mds', mem'\\<rangle> \\<longrightarrow>\n     (\\<forall>x\\<in>{x} \\<union> \\<C>_vars x.\n         \\<forall>v.\n            \\<langle>c, mds, mem(x := v)\\<rangle> \\<leadsto>\n            \\<langle>c', mds', mem'(x := v)\\<rangle>)\n  a \\<in> {x} \\<union> \\<C>_vars x\n  \\<langle>c, mds, subst (\\<sigma> |` X) mem\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (\\<sigma> |` X) mem'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, (subst (\\<sigma> |` X) mem)(a := v)\\<rangle> \\<leadsto>\n    \\<langle>c', mds', (subst (\\<sigma> |` X) mem')(a := v)\\<rangle>", "by metis"], ["proof (state)\nthis:\n  \\<langle>c, mds, (subst (\\<sigma> |` X) mem)(a := v)\\<rangle> \\<leadsto>\n  \\<langle>c', mds', (subst (\\<sigma> |` X) mem')(a := v)\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst \\<sigma> mem'\\<rangle>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<langle>c, mds, (subst (\\<sigma> |` X) mem)(a := v)\\<rangle> \\<leadsto>\n  \\<langle>c', mds', (subst (\\<sigma> |` X) mem')(a := v)\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst \\<sigma> mem'\\<rangle>", "by(simp add: r)"], ["proof (state)\nthis:\n  \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst \\<sigma> mem'\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst \\<sigma> mem'\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dom ?\\<sigma>5 = X \\<Longrightarrow>\n  \\<langle>c, mds, subst ?\\<sigma>5 mem\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst ?\\<sigma>5 mem'\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma subst_restrict_twice:\n  \"dom \\<sigma> = A \\<union> B \\<Longrightarrow>\n   mem [\\<mapsto> (\\<sigma> |` A)] [\\<mapsto> (\\<sigma> |` B)] = mem [\\<mapsto> \\<sigma>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom \\<sigma> = A \\<union> B \\<Longrightarrow>\n    subst (\\<sigma> |` B) (subst (\\<sigma> |` A) mem) = subst \\<sigma> mem", "by(fastforce simp: subst_def split: option.splits intro!: ext simp: restrict_map_def)"], ["", "(* Toby: this proof is now far simpler because change_respecting is *)"], ["", "lemma noread_exists_change_respecting:\n  assumes fin: \"finite (X :: 'Var set)\"\n  assumes eval: \"\\<langle> c, mds, mem \\<rangle> \\<leadsto> \\<langle> c', mds', mem' \\<rangle>\"\n  assumes noread: \"\\<forall> x \\<in> X. doesnt_read_or_modify c x\"\n  shows \"change_respecting \\<langle>c, mds, mem\\<rangle> \\<langle>c', mds', mem'\\<rangle> X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. change_respecting \\<langle>c, mds, mem\\<rangle>\n     \\<langle>c', mds', mem'\\<rangle> X", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. change_respecting \\<langle>c, mds, mem\\<rangle>\n     \\<langle>c', mds', mem'\\<rangle> X", "let ?lc = \"\\<langle>c, mds, mem\\<rangle>\" and ?lc' = \"\\<langle>c', mds', mem'\\<rangle>\""], ["proof (state)\ngoal (1 subgoal):\n 1. change_respecting \\<langle>c, mds, mem\\<rangle>\n     \\<langle>c', mds', mem'\\<rangle> X", "from fin eval noread"], ["proof (chain)\npicking this:\n  finite X\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\n  \\<forall>x\\<in>X. doesnt_read_or_modify c x", "show \"change_respecting \\<langle>c, mds, mem\\<rangle> \\<langle>c', mds', mem'\\<rangle> X\""], ["proof (prove)\nusing this:\n  finite X\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\n  \\<forall>x\\<in>X. doesnt_read_or_modify c x\n\ngoal (1 subgoal):\n 1. change_respecting \\<langle>c, mds, mem\\<rangle>\n     \\<langle>c', mds', mem'\\<rangle> X", "proof (induct \"X\" arbitrary: mem mem' rule: finite_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>mem mem'.\n       \\<lbrakk>\\<langle>c, mds, mem\\<rangle> \\<leadsto>\n                \\<langle>c', mds', mem'\\<rangle>;\n        Ball {} (doesnt_read_or_modify c)\\<rbrakk>\n       \\<Longrightarrow> change_respecting \\<langle>c, mds, mem\\<rangle>\n                          \\<langle>c', mds', mem'\\<rangle> {}\n 2. \\<And>x F mem mem'.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>mem mem'.\n           \\<lbrakk>\\<langle>c, mds, mem\\<rangle> \\<leadsto>\n                    \\<langle>c', mds', mem'\\<rangle>;\n            Ball F (doesnt_read_or_modify c)\\<rbrakk>\n           \\<Longrightarrow> change_respecting \\<langle>c, mds, mem\\<rangle>\n                              \\<langle>c', mds', mem'\\<rangle> F;\n        \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n        \\<langle>c', mds', mem'\\<rangle>;\n        Ball (insert x F) (doesnt_read_or_modify c)\\<rbrakk>\n       \\<Longrightarrow> change_respecting \\<langle>c, mds, mem\\<rangle>\n                          \\<langle>c', mds', mem'\\<rangle> (insert x F)", "case empty"], ["proof (state)\nthis:\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\n  \\<forall>a\\<in>{}. doesnt_read_or_modify c a\n\ngoal (2 subgoals):\n 1. \\<And>mem mem'.\n       \\<lbrakk>\\<langle>c, mds, mem\\<rangle> \\<leadsto>\n                \\<langle>c', mds', mem'\\<rangle>;\n        Ball {} (doesnt_read_or_modify c)\\<rbrakk>\n       \\<Longrightarrow> change_respecting \\<langle>c, mds, mem\\<rangle>\n                          \\<langle>c', mds', mem'\\<rangle> {}\n 2. \\<And>x F mem mem'.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>mem mem'.\n           \\<lbrakk>\\<langle>c, mds, mem\\<rangle> \\<leadsto>\n                    \\<langle>c', mds', mem'\\<rangle>;\n            Ball F (doesnt_read_or_modify c)\\<rbrakk>\n           \\<Longrightarrow> change_respecting \\<langle>c, mds, mem\\<rangle>\n                              \\<langle>c', mds', mem'\\<rangle> F;\n        \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n        \\<langle>c', mds', mem'\\<rangle>;\n        Ball (insert x F) (doesnt_read_or_modify c)\\<rbrakk>\n       \\<Longrightarrow> change_respecting \\<langle>c, mds, mem\\<rangle>\n                          \\<langle>c', mds', mem'\\<rangle> (insert x F)", "have \"mem [\\<mapsto> Map.empty] = mem\" \"mem' [\\<mapsto> Map.empty] = mem'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst Map.empty mem = mem &&& subst Map.empty mem' = mem'", "unfolding subst_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        case None of None \\<Rightarrow> mem x | Some v \\<Rightarrow> v) =\n    mem &&&\n    (\\<lambda>x.\n        case None of None \\<Rightarrow> mem' x | Some v \\<Rightarrow> v) =\n    mem'", "by auto"], ["proof (state)\nthis:\n  subst Map.empty mem = mem\n  subst Map.empty mem' = mem'\n\ngoal (2 subgoals):\n 1. \\<And>mem mem'.\n       \\<lbrakk>\\<langle>c, mds, mem\\<rangle> \\<leadsto>\n                \\<langle>c', mds', mem'\\<rangle>;\n        Ball {} (doesnt_read_or_modify c)\\<rbrakk>\n       \\<Longrightarrow> change_respecting \\<langle>c, mds, mem\\<rangle>\n                          \\<langle>c', mds', mem'\\<rangle> {}\n 2. \\<And>x F mem mem'.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>mem mem'.\n           \\<lbrakk>\\<langle>c, mds, mem\\<rangle> \\<leadsto>\n                    \\<langle>c', mds', mem'\\<rangle>;\n            Ball F (doesnt_read_or_modify c)\\<rbrakk>\n           \\<Longrightarrow> change_respecting \\<langle>c, mds, mem\\<rangle>\n                              \\<langle>c', mds', mem'\\<rangle> F;\n        \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n        \\<langle>c', mds', mem'\\<rangle>;\n        Ball (insert x F) (doesnt_read_or_modify c)\\<rbrakk>\n       \\<Longrightarrow> change_respecting \\<langle>c, mds, mem\\<rangle>\n                          \\<langle>c', mds', mem'\\<rangle> (insert x F)", "hence \"change_respecting \\<langle>c, mds, mem\\<rangle> \\<langle>c', mds', mem'\\<rangle> {}\""], ["proof (prove)\nusing this:\n  subst Map.empty mem = mem\n  subst Map.empty mem' = mem'\n\ngoal (1 subgoal):\n 1. change_respecting \\<langle>c, mds, mem\\<rangle>\n     \\<langle>c', mds', mem'\\<rangle> {}", "using empty"], ["proof (prove)\nusing this:\n  subst Map.empty mem = mem\n  subst Map.empty mem' = mem'\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\n  \\<forall>a\\<in>{}. doesnt_read_or_modify c a\n\ngoal (1 subgoal):\n 1. change_respecting \\<langle>c, mds, mem\\<rangle>\n     \\<langle>c', mds', mem'\\<rangle> {}", "unfolding change_respecting.simps subst_def vars_\\<C>_def vars_and_\\<C>_def"], ["proof (prove)\nusing this:\n  (\\<lambda>x.\n      case None of None \\<Rightarrow> mem x | Some v \\<Rightarrow> v) =\n  mem\n  (\\<lambda>x.\n      case None of None \\<Rightarrow> mem' x | Some v \\<Rightarrow> v) =\n  mem'\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\n  \\<forall>a\\<in>{}. doesnt_read_or_modify c a\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', mem'\\<rangle> \\<and>\n    (\\<forall>\\<sigma>.\n        dom \\<sigma> =\n        {} \\<union> \\<Union> (\\<C>_vars ` {}) \\<longrightarrow>\n        \\<langle>c, mds, \\<lambda>x.\n                            case \\<sigma> x of None \\<Rightarrow> mem x\n                            | Some v \\<Rightarrow> v\\<rangle> \\<leadsto>\n        \\<langle>c', mds', \\<lambda>x.\n                              case \\<sigma> x of None \\<Rightarrow> mem' x\n                              | Some v \\<Rightarrow> v\\<rangle>)", "by auto"], ["proof (state)\nthis:\n  change_respecting \\<langle>c, mds, mem\\<rangle>\n   \\<langle>c', mds', mem'\\<rangle> {}\n\ngoal (2 subgoals):\n 1. \\<And>mem mem'.\n       \\<lbrakk>\\<langle>c, mds, mem\\<rangle> \\<leadsto>\n                \\<langle>c', mds', mem'\\<rangle>;\n        Ball {} (doesnt_read_or_modify c)\\<rbrakk>\n       \\<Longrightarrow> change_respecting \\<langle>c, mds, mem\\<rangle>\n                          \\<langle>c', mds', mem'\\<rangle> {}\n 2. \\<And>x F mem mem'.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>mem mem'.\n           \\<lbrakk>\\<langle>c, mds, mem\\<rangle> \\<leadsto>\n                    \\<langle>c', mds', mem'\\<rangle>;\n            Ball F (doesnt_read_or_modify c)\\<rbrakk>\n           \\<Longrightarrow> change_respecting \\<langle>c, mds, mem\\<rangle>\n                              \\<langle>c', mds', mem'\\<rangle> F;\n        \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n        \\<langle>c', mds', mem'\\<rangle>;\n        Ball (insert x F) (doesnt_read_or_modify c)\\<rbrakk>\n       \\<Longrightarrow> change_respecting \\<langle>c, mds, mem\\<rangle>\n                          \\<langle>c', mds', mem'\\<rangle> (insert x F)", "thus ?case"], ["proof (prove)\nusing this:\n  change_respecting \\<langle>c, mds, mem\\<rangle>\n   \\<langle>c', mds', mem'\\<rangle> {}\n\ngoal (1 subgoal):\n 1. change_respecting \\<langle>c, mds, mem\\<rangle>\n     \\<langle>c', mds', mem'\\<rangle> {}", "by blast"], ["proof (state)\nthis:\n  change_respecting \\<langle>c, mds, mem\\<rangle>\n   \\<langle>c', mds', mem'\\<rangle> {}\n\ngoal (1 subgoal):\n 1. \\<And>x F mem mem'.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>mem mem'.\n           \\<lbrakk>\\<langle>c, mds, mem\\<rangle> \\<leadsto>\n                    \\<langle>c', mds', mem'\\<rangle>;\n            Ball F (doesnt_read_or_modify c)\\<rbrakk>\n           \\<Longrightarrow> change_respecting \\<langle>c, mds, mem\\<rangle>\n                              \\<langle>c', mds', mem'\\<rangle> F;\n        \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n        \\<langle>c', mds', mem'\\<rangle>;\n        Ball (insert x F) (doesnt_read_or_modify c)\\<rbrakk>\n       \\<Longrightarrow> change_respecting \\<langle>c, mds, mem\\<rangle>\n                          \\<langle>c', mds', mem'\\<rangle> (insert x F)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x F mem mem'.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>mem mem'.\n           \\<lbrakk>\\<langle>c, mds, mem\\<rangle> \\<leadsto>\n                    \\<langle>c', mds', mem'\\<rangle>;\n            Ball F (doesnt_read_or_modify c)\\<rbrakk>\n           \\<Longrightarrow> change_respecting \\<langle>c, mds, mem\\<rangle>\n                              \\<langle>c', mds', mem'\\<rangle> F;\n        \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n        \\<langle>c', mds', mem'\\<rangle>;\n        Ball (insert x F) (doesnt_read_or_modify c)\\<rbrakk>\n       \\<Longrightarrow> change_respecting \\<langle>c, mds, mem\\<rangle>\n                          \\<langle>c', mds', mem'\\<rangle> (insert x F)", "case (insert x X)"], ["proof (state)\nthis:\n  finite X\n  x \\<notin> X\n  \\<lbrakk>\\<langle>c, mds, ?mem5\\<rangle> \\<leadsto>\n           \\<langle>c', mds', ?mem'5\\<rangle>;\n   \\<forall>a\\<in>X. doesnt_read_or_modify c a\\<rbrakk>\n  \\<Longrightarrow> change_respecting \\<langle>c, mds, ?mem5\\<rangle>\n                     \\<langle>c', mds', ?mem'5\\<rangle> X\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\n  \\<forall>a\\<in>insert x X. doesnt_read_or_modify c a\n\ngoal (1 subgoal):\n 1. \\<And>x F mem mem'.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>mem mem'.\n           \\<lbrakk>\\<langle>c, mds, mem\\<rangle> \\<leadsto>\n                    \\<langle>c', mds', mem'\\<rangle>;\n            Ball F (doesnt_read_or_modify c)\\<rbrakk>\n           \\<Longrightarrow> change_respecting \\<langle>c, mds, mem\\<rangle>\n                              \\<langle>c', mds', mem'\\<rangle> F;\n        \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n        \\<langle>c', mds', mem'\\<rangle>;\n        Ball (insert x F) (doesnt_read_or_modify c)\\<rbrakk>\n       \\<Longrightarrow> change_respecting \\<langle>c, mds, mem\\<rangle>\n                          \\<langle>c', mds', mem'\\<rangle> (insert x F)", "then"], ["proof (chain)\npicking this:\n  finite X\n  x \\<notin> X\n  \\<lbrakk>\\<langle>c, mds, ?mem5\\<rangle> \\<leadsto>\n           \\<langle>c', mds', ?mem'5\\<rangle>;\n   \\<forall>a\\<in>X. doesnt_read_or_modify c a\\<rbrakk>\n  \\<Longrightarrow> change_respecting \\<langle>c, mds, ?mem5\\<rangle>\n                     \\<langle>c', mds', ?mem'5\\<rangle> X\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\n  \\<forall>a\\<in>insert x X. doesnt_read_or_modify c a", "have IH: \"change_respecting \\<langle>c, mds, mem\\<rangle> \\<langle>c', mds', mem'\\<rangle> X\""], ["proof (prove)\nusing this:\n  finite X\n  x \\<notin> X\n  \\<lbrakk>\\<langle>c, mds, ?mem5\\<rangle> \\<leadsto>\n           \\<langle>c', mds', ?mem'5\\<rangle>;\n   \\<forall>a\\<in>X. doesnt_read_or_modify c a\\<rbrakk>\n  \\<Longrightarrow> change_respecting \\<langle>c, mds, ?mem5\\<rangle>\n                     \\<langle>c', mds', ?mem'5\\<rangle> X\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\n  \\<forall>a\\<in>insert x X. doesnt_read_or_modify c a\n\ngoal (1 subgoal):\n 1. change_respecting \\<langle>c, mds, mem\\<rangle>\n     \\<langle>c', mds', mem'\\<rangle> X", "by (metis (poly_guards_query) insertCI insert_disjoint(1))"], ["proof (state)\nthis:\n  change_respecting \\<langle>c, mds, mem\\<rangle>\n   \\<langle>c', mds', mem'\\<rangle> X\n\ngoal (1 subgoal):\n 1. \\<And>x F mem mem'.\n       \\<lbrakk>finite F; x \\<notin> F;\n        \\<And>mem mem'.\n           \\<lbrakk>\\<langle>c, mds, mem\\<rangle> \\<leadsto>\n                    \\<langle>c', mds', mem'\\<rangle>;\n            Ball F (doesnt_read_or_modify c)\\<rbrakk>\n           \\<Longrightarrow> change_respecting \\<langle>c, mds, mem\\<rangle>\n                              \\<langle>c', mds', mem'\\<rangle> F;\n        \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n        \\<langle>c', mds', mem'\\<rangle>;\n        Ball (insert x F) (doesnt_read_or_modify c)\\<rbrakk>\n       \\<Longrightarrow> change_respecting \\<langle>c, mds, mem\\<rangle>\n                          \\<langle>c', mds', mem'\\<rangle> (insert x F)", "show \"change_respecting \\<langle>c, mds, mem\\<rangle> \\<langle>c', mds', mem'\\<rangle> (insert x X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. change_respecting \\<langle>c, mds, mem\\<rangle>\n     \\<langle>c', mds', mem'\\<rangle> (insert x X)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', mem'\\<rangle>\n 2. \\<And>f.\n       dom f = vars_and_\\<C> (insert x X) \\<Longrightarrow>\n       \\<langle>c, mds, subst f mem\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst f mem'\\<rangle>", "show \"\\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', mem'\\<rangle>", "using insert"], ["proof (prove)\nusing this:\n  finite X\n  x \\<notin> X\n  \\<lbrakk>\\<langle>c, mds, ?mem5\\<rangle> \\<leadsto>\n           \\<langle>c', mds', ?mem'5\\<rangle>;\n   \\<forall>a\\<in>X. doesnt_read_or_modify c a\\<rbrakk>\n  \\<Longrightarrow> change_respecting \\<langle>c, mds, ?mem5\\<rangle>\n                     \\<langle>c', mds', ?mem'5\\<rangle> X\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\n  \\<forall>a\\<in>insert x X. doesnt_read_or_modify c a\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', mem'\\<rangle>", "by auto"], ["proof (state)\nthis:\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       dom f = vars_and_\\<C> (insert x X) \\<Longrightarrow>\n       \\<langle>c, mds, subst f mem\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst f mem'\\<rangle>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       dom f = vars_and_\\<C> (insert x X) \\<Longrightarrow>\n       \\<langle>c, mds, subst f mem\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst f mem'\\<rangle>", "fix \\<sigma> :: \"'Var \\<rightharpoonup> 'Val\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       dom f = vars_and_\\<C> (insert x X) \\<Longrightarrow>\n       \\<langle>c, mds, subst f mem\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst f mem'\\<rangle>", "let ?\\<sigma>\\<^sub>X = \"\\<sigma> |` vars_and_\\<C> X\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       dom f = vars_and_\\<C> (insert x X) \\<Longrightarrow>\n       \\<langle>c, mds, subst f mem\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst f mem'\\<rangle>", "let ?\\<sigma>\\<^sub>x = \"\\<sigma> |` ({x} \\<union> \\<C>_vars x)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       dom f = vars_and_\\<C> (insert x X) \\<Longrightarrow>\n       \\<langle>c, mds, subst f mem\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst f mem'\\<rangle>", "assume dom\\<sigma>: \"dom \\<sigma> = vars_and_\\<C> (insert x X)\""], ["proof (state)\nthis:\n  dom \\<sigma> = vars_and_\\<C> (insert x X)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       dom f = vars_and_\\<C> (insert x X) \\<Longrightarrow>\n       \\<langle>c, mds, subst f mem\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst f mem'\\<rangle>", "hence \"dom ?\\<sigma>\\<^sub>X = vars_and_\\<C> X\""], ["proof (prove)\nusing this:\n  dom \\<sigma> = vars_and_\\<C> (insert x X)\n\ngoal (1 subgoal):\n 1. dom (\\<sigma> |` vars_and_\\<C> X) = vars_and_\\<C> X", "by (metis dom_restrict inf_absorb2 subset_insertI vars_and_\\<C>_mono)"], ["proof (state)\nthis:\n  dom (\\<sigma> |` vars_and_\\<C> X) = vars_and_\\<C> X\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       dom f = vars_and_\\<C> (insert x X) \\<Longrightarrow>\n       \\<langle>c, mds, subst f mem\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst f mem'\\<rangle>", "from dom\\<sigma>"], ["proof (chain)\npicking this:\n  dom \\<sigma> = vars_and_\\<C> (insert x X)", "have dom\\<sigma>\\<^sub>x: \"dom ?\\<sigma>\\<^sub>x = {x} \\<union> \\<C>_vars x\""], ["proof (prove)\nusing this:\n  dom \\<sigma> = vars_and_\\<C> (insert x X)\n\ngoal (1 subgoal):\n 1. dom (\\<sigma> |` ({x} \\<union> \\<C>_vars x)) = {x} \\<union> \\<C>_vars x", "by(simp add: dom\\<sigma> vars_and_\\<C>_def vars_\\<C>_def, blast)"], ["proof (state)\nthis:\n  dom (\\<sigma> |` ({x} \\<union> \\<C>_vars x)) = {x} \\<union> \\<C>_vars x\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       dom f = vars_and_\\<C> (insert x X) \\<Longrightarrow>\n       \\<langle>c, mds, subst f mem\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst f mem'\\<rangle>", "have \"dom \\<sigma> = vars_and_\\<C> X \\<union> ({x} \\<union> \\<C>_vars x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom \\<sigma> = vars_and_\\<C> X \\<union> ({x} \\<union> \\<C>_vars x)", "by(simp add: dom\\<sigma> vars_and_\\<C>_def vars_\\<C>_def, blast)"], ["proof (state)\nthis:\n  dom \\<sigma> = vars_and_\\<C> X \\<union> ({x} \\<union> \\<C>_vars x)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       dom f = vars_and_\\<C> (insert x X) \\<Longrightarrow>\n       \\<langle>c, mds, subst f mem\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst f mem'\\<rangle>", "hence subst\\<sigma>: \"\\<And> mem. mem [\\<mapsto> ?\\<sigma>\\<^sub>X] [\\<mapsto> ?\\<sigma>\\<^sub>x] = mem [\\<mapsto> \\<sigma>]\""], ["proof (prove)\nusing this:\n  dom \\<sigma> = vars_and_\\<C> X \\<union> ({x} \\<union> \\<C>_vars x)\n\ngoal (1 subgoal):\n 1. \\<And>mem.\n       subst (\\<sigma> |` ({x} \\<union> \\<C>_vars x))\n        (subst (\\<sigma> |` vars_and_\\<C> X) mem) =\n       subst \\<sigma> mem", "by(rule subst_restrict_twice)"], ["proof (state)\nthis:\n  subst (\\<sigma> |` ({x} \\<union> \\<C>_vars x))\n   (subst (\\<sigma> |` vars_and_\\<C> X) ?mem5) =\n  subst \\<sigma> ?mem5\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       dom f = vars_and_\\<C> (insert x X) \\<Longrightarrow>\n       \\<langle>c, mds, subst f mem\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst f mem'\\<rangle>", "from insert"], ["proof (chain)\npicking this:\n  finite X\n  x \\<notin> X\n  \\<lbrakk>\\<langle>c, mds, ?mem5\\<rangle> \\<leadsto>\n           \\<langle>c', mds', ?mem'5\\<rangle>;\n   \\<forall>a\\<in>X. doesnt_read_or_modify c a\\<rbrakk>\n  \\<Longrightarrow> change_respecting \\<langle>c, mds, ?mem5\\<rangle>\n                     \\<langle>c', mds', ?mem'5\\<rangle> X\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\n  \\<forall>a\\<in>insert x X. doesnt_read_or_modify c a", "have \"doesnt_read_or_modify c x\""], ["proof (prove)\nusing this:\n  finite X\n  x \\<notin> X\n  \\<lbrakk>\\<langle>c, mds, ?mem5\\<rangle> \\<leadsto>\n           \\<langle>c', mds', ?mem'5\\<rangle>;\n   \\<forall>a\\<in>X. doesnt_read_or_modify c a\\<rbrakk>\n  \\<Longrightarrow> change_respecting \\<langle>c, mds, ?mem5\\<rangle>\n                     \\<langle>c', mds', ?mem'5\\<rangle> X\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\n  \\<forall>a\\<in>insert x X. doesnt_read_or_modify c a\n\ngoal (1 subgoal):\n 1. doesnt_read_or_modify c x", "by auto"], ["proof (state)\nthis:\n  doesnt_read_or_modify c x\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       dom f = vars_and_\\<C> (insert x X) \\<Longrightarrow>\n       \\<langle>c, mds, subst f mem\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst f mem'\\<rangle>", "moreover"], ["proof (state)\nthis:\n  doesnt_read_or_modify c x\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       dom f = vars_and_\\<C> (insert x X) \\<Longrightarrow>\n       \\<langle>c, mds, subst f mem\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst f mem'\\<rangle>", "from IH"], ["proof (chain)\npicking this:\n  change_respecting \\<langle>c, mds, mem\\<rangle>\n   \\<langle>c', mds', mem'\\<rangle> X", "have eval\\<^sub>X: \"\\<langle>c, mds, mem [\\<mapsto> ?\\<sigma>\\<^sub>X]\\<rangle> \\<leadsto> \\<langle>c', mds', mem' [\\<mapsto> ?\\<sigma>\\<^sub>X]\\<rangle>\""], ["proof (prove)\nusing this:\n  change_respecting \\<langle>c, mds, mem\\<rangle>\n   \\<langle>c', mds', mem'\\<rangle> X\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst (\\<sigma> |` vars_and_\\<C> X)\n                      mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (\\<sigma> |` vars_and_\\<C> X) mem'\\<rangle>", "using \\<open>dom ?\\<sigma>\\<^sub>X = vars_and_\\<C> X\\<close>"], ["proof (prove)\nusing this:\n  change_respecting \\<langle>c, mds, mem\\<rangle>\n   \\<langle>c', mds', mem'\\<rangle> X\n  dom (\\<sigma> |` vars_and_\\<C> X) = vars_and_\\<C> X\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst (\\<sigma> |` vars_and_\\<C> X)\n                      mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (\\<sigma> |` vars_and_\\<C> X) mem'\\<rangle>", "unfolding change_respecting.simps"], ["proof (prove)\nusing this:\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto>\n  \\<langle>c', mds', mem'\\<rangle> \\<and>\n  (\\<forall>\\<sigma>.\n      dom \\<sigma> = vars_and_\\<C> X \\<longrightarrow>\n      \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n      \\<langle>c', mds', subst \\<sigma> mem'\\<rangle>)\n  dom (\\<sigma> |` vars_and_\\<C> X) = vars_and_\\<C> X\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst (\\<sigma> |` vars_and_\\<C> X)\n                      mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (\\<sigma> |` vars_and_\\<C> X) mem'\\<rangle>", "by auto"], ["proof (state)\nthis:\n  \\<langle>c, mds, subst (\\<sigma> |` vars_and_\\<C> X)\n                    mem\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (\\<sigma> |` vars_and_\\<C> X) mem'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       dom f = vars_and_\\<C> (insert x X) \\<Longrightarrow>\n       \\<langle>c, mds, subst f mem\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst f mem'\\<rangle>", "ultimately"], ["proof (chain)\npicking this:\n  doesnt_read_or_modify c x\n  \\<langle>c, mds, subst (\\<sigma> |` vars_and_\\<C> X)\n                    mem\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (\\<sigma> |` vars_and_\\<C> X) mem'\\<rangle>", "have \"\\<langle>c, mds, mem [\\<mapsto> ?\\<sigma>\\<^sub>X] [\\<mapsto> ?\\<sigma>\\<^sub>x]\\<rangle> \\<leadsto> \\<langle>c', mds', mem' [\\<mapsto> ?\\<sigma>\\<^sub>X] [\\<mapsto> ?\\<sigma>\\<^sub>x]\\<rangle>\""], ["proof (prove)\nusing this:\n  doesnt_read_or_modify c x\n  \\<langle>c, mds, subst (\\<sigma> |` vars_and_\\<C> X)\n                    mem\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (\\<sigma> |` vars_and_\\<C> X) mem'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst (\\<sigma> |` ({x} \\<union> \\<C>_vars x))\n                      (subst (\\<sigma> |` vars_and_\\<C> X)\n                        mem)\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (\\<sigma> |` ({x} \\<union> \\<C>_vars x))\n                        (subst (\\<sigma> |` vars_and_\\<C> X) mem')\\<rangle>", "using subset_refl dom\\<sigma>\\<^sub>x doesnt_read_or_modify_subst"], ["proof (prove)\nusing this:\n  doesnt_read_or_modify c x\n  \\<langle>c, mds, subst (\\<sigma> |` vars_and_\\<C> X)\n                    mem\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (\\<sigma> |` vars_and_\\<C> X) mem'\\<rangle>\n  ?A \\<subseteq> ?A\n  dom (\\<sigma> |` ({x} \\<union> \\<C>_vars x)) = {x} \\<union> \\<C>_vars x\n  \\<lbrakk>doesnt_read_or_modify ?c ?x;\n   \\<langle>?c, ?mds, ?mem\\<rangle> \\<leadsto>\n   \\<langle>?c', ?mds', ?mem'\\<rangle>;\n   ?X \\<subseteq> {?x} \\<union> \\<C>_vars ?x; dom ?\\<sigma> = ?X\\<rbrakk>\n  \\<Longrightarrow> \\<langle>?c, ?mds, subst ?\\<sigma>\n  ?mem\\<rangle> \\<leadsto>\n                    \\<langle>?c', ?mds', subst ?\\<sigma> ?mem'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst (\\<sigma> |` ({x} \\<union> \\<C>_vars x))\n                      (subst (\\<sigma> |` vars_and_\\<C> X)\n                        mem)\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst (\\<sigma> |` ({x} \\<union> \\<C>_vars x))\n                        (subst (\\<sigma> |` vars_and_\\<C> X) mem')\\<rangle>", "by metis"], ["proof (state)\nthis:\n  \\<langle>c, mds, subst (\\<sigma> |` ({x} \\<union> \\<C>_vars x))\n                    (subst (\\<sigma> |` vars_and_\\<C> X)\n                      mem)\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (\\<sigma> |` ({x} \\<union> \\<C>_vars x))\n                      (subst (\\<sigma> |` vars_and_\\<C> X) mem')\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       dom f = vars_and_\\<C> (insert x X) \\<Longrightarrow>\n       \\<langle>c, mds, subst f mem\\<rangle> \\<leadsto>\n       \\<langle>c', mds', subst f mem'\\<rangle>", "thus \"\\<langle>c, mds, mem [\\<mapsto> \\<sigma>]\\<rangle> \\<leadsto> \\<langle>c', mds', mem' [\\<mapsto> \\<sigma>]\\<rangle>\""], ["proof (prove)\nusing this:\n  \\<langle>c, mds, subst (\\<sigma> |` ({x} \\<union> \\<C>_vars x))\n                    (subst (\\<sigma> |` vars_and_\\<C> X)\n                      mem)\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (\\<sigma> |` ({x} \\<union> \\<C>_vars x))\n                      (subst (\\<sigma> |` vars_and_\\<C> X) mem')\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst \\<sigma> mem'\\<rangle>", "using subst\\<sigma>"], ["proof (prove)\nusing this:\n  \\<langle>c, mds, subst (\\<sigma> |` ({x} \\<union> \\<C>_vars x))\n                    (subst (\\<sigma> |` vars_and_\\<C> X)\n                      mem)\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst (\\<sigma> |` ({x} \\<union> \\<C>_vars x))\n                      (subst (\\<sigma> |` vars_and_\\<C> X) mem')\\<rangle>\n  subst (\\<sigma> |` ({x} \\<union> \\<C>_vars x))\n   (subst (\\<sigma> |` vars_and_\\<C> X) ?mem5) =\n  subst \\<sigma> ?mem5\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n    \\<langle>c', mds', subst \\<sigma> mem'\\<rangle>", "by metis"], ["proof (state)\nthis:\n  \\<langle>c, mds, subst \\<sigma> mem\\<rangle> \\<leadsto>\n  \\<langle>c', mds', subst \\<sigma> mem'\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  change_respecting \\<langle>c, mds, mem\\<rangle>\n   \\<langle>c', mds', mem'\\<rangle> (insert x X)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  change_respecting \\<langle>c, mds, mem\\<rangle>\n   \\<langle>c', mds', mem'\\<rangle> X\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma update_nth_eq:\n  \"\\<lbrakk> xs = ys; n < length xs \\<rbrakk> \\<Longrightarrow> xs = ys [n := xs ! n]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs = ys; n < length xs\\<rbrakk>\n    \\<Longrightarrow> xs = ys[n := xs ! n]", "by (metis list_update_id)"], ["", "text \\<open>This property is obvious,\n  so an unreadable apply-style proof is acceptable here:\\<close>"], ["", "lemma mm_equiv_step:\n  assumes bisim: \"(cms\\<^sub>1, mem\\<^sub>1) \\<approx> (cms\\<^sub>2, mem\\<^sub>2)\"\n  assumes modes_eq: \"snd cms\\<^sub>1 = snd cms\\<^sub>2\"\n  assumes step: \"(cms\\<^sub>1, mem\\<^sub>1) \\<leadsto> (cms\\<^sub>1', mem\\<^sub>1')\"\n  shows \"\\<exists> c\\<^sub>2' mem\\<^sub>2'. (cms\\<^sub>2, mem\\<^sub>2) \\<leadsto> \\<langle> c\\<^sub>2', snd cms\\<^sub>1', mem\\<^sub>2' \\<rangle> \\<and>\n  (cms\\<^sub>1', mem\\<^sub>1') \\<approx> \\<langle> c\\<^sub>2', snd cms\\<^sub>1', mem\\<^sub>2' \\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n       (cms\\<^sub>2, mem\\<^sub>2) \\<leadsto>\n       \\<langle>c\\<^sub>2', snd cms\\<^sub>1', mem\\<^sub>2'\\<rangle> \\<and>\n       (cms\\<^sub>1', mem\\<^sub>1') \\<approx>\n       \\<langle>c\\<^sub>2', snd cms\\<^sub>1', mem\\<^sub>2'\\<rangle>", "using assms mm_equiv_strong_low_bisim"], ["proof (prove)\nusing this:\n  (cms\\<^sub>1, mem\\<^sub>1) \\<approx> (cms\\<^sub>2, mem\\<^sub>2)\n  snd cms\\<^sub>1 = snd cms\\<^sub>2\n  (cms\\<^sub>1, mem\\<^sub>1) \\<leadsto> (cms\\<^sub>1', mem\\<^sub>1')\n  strong_low_bisim_mm mm_equiv\n\ngoal (1 subgoal):\n 1. \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n       (cms\\<^sub>2, mem\\<^sub>2) \\<leadsto>\n       \\<langle>c\\<^sub>2', snd cms\\<^sub>1', mem\\<^sub>2'\\<rangle> \\<and>\n       (cms\\<^sub>1', mem\\<^sub>1') \\<approx>\n       \\<langle>c\\<^sub>2', snd cms\\<^sub>1', mem\\<^sub>2'\\<rangle>", "unfolding strong_low_bisim_mm_def"], ["proof (prove)\nusing this:\n  (cms\\<^sub>1, mem\\<^sub>1) \\<approx> (cms\\<^sub>2, mem\\<^sub>2)\n  snd cms\\<^sub>1 = snd cms\\<^sub>2\n  (cms\\<^sub>1, mem\\<^sub>1) \\<leadsto> (cms\\<^sub>1', mem\\<^sub>1')\n  sym mm_equiv \\<and>\n  closed_glob_consistent mm_equiv \\<and>\n  (\\<forall>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2.\n      \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n      \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<longrightarrow>\n      mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2 \\<and>\n      (\\<forall>c\\<^sub>1' mds' mem\\<^sub>1'.\n          \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n          \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<longrightarrow>\n          (\\<exists>c\\<^sub>2' mem\\<^sub>2'.\n              \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n              \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n              \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n              \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>)))\n\ngoal (1 subgoal):\n 1. \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n       (cms\\<^sub>2, mem\\<^sub>2) \\<leadsto>\n       \\<langle>c\\<^sub>2', snd cms\\<^sub>1', mem\\<^sub>2'\\<rangle> \\<and>\n       (cms\\<^sub>1', mem\\<^sub>1') \\<approx>\n       \\<langle>c\\<^sub>2', snd cms\\<^sub>1', mem\\<^sub>2'\\<rangle>", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(cms\\<^sub>1, mem\\<^sub>1) \\<approx>\n             (cms\\<^sub>2, mem\\<^sub>2);\n     snd cms\\<^sub>1 = snd cms\\<^sub>2;\n     (cms\\<^sub>1, mem\\<^sub>1) \\<leadsto> (cms\\<^sub>1', mem\\<^sub>1');\n     sym mm_equiv; closed_glob_consistent mm_equiv;\n     \\<forall>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2.\n        \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n        \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<longrightarrow>\n        mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2 \\<and>\n        (\\<forall>c\\<^sub>1' mds' mem\\<^sub>1'.\n            \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n            \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<longrightarrow>\n            (\\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n                \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n                \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n                \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                         (cms\\<^sub>2, mem\\<^sub>2) \\<leadsto>\n                         \\<langle>c\\<^sub>2', snd\n         cms\\<^sub>1', mem\\<^sub>2'\\<rangle> \\<and>\n                         (cms\\<^sub>1', mem\\<^sub>1') \\<approx>\n                         \\<langle>c\\<^sub>2', snd\n         cms\\<^sub>1', mem\\<^sub>2'\\<rangle>", "apply (erule_tac x = \"fst cms\\<^sub>1\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(cms\\<^sub>1, mem\\<^sub>1) \\<approx>\n             (cms\\<^sub>2, mem\\<^sub>2);\n     snd cms\\<^sub>1 = snd cms\\<^sub>2;\n     (cms\\<^sub>1, mem\\<^sub>1) \\<leadsto> (cms\\<^sub>1', mem\\<^sub>1');\n     sym mm_equiv; closed_glob_consistent mm_equiv;\n     \\<forall>mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2.\n        \\<langle>fst cms\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n        \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<longrightarrow>\n        mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2 \\<and>\n        (\\<forall>c\\<^sub>1' mds' mem\\<^sub>1'.\n            \\<langle>fst cms\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n            \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<longrightarrow>\n            (\\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n                \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n                \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n                \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                         (cms\\<^sub>2, mem\\<^sub>2) \\<leadsto>\n                         \\<langle>c\\<^sub>2', snd\n         cms\\<^sub>1', mem\\<^sub>2'\\<rangle> \\<and>\n                         (cms\\<^sub>1', mem\\<^sub>1') \\<approx>\n                         \\<langle>c\\<^sub>2', snd\n         cms\\<^sub>1', mem\\<^sub>2'\\<rangle>", "apply (erule_tac x = \"snd cms\\<^sub>1\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(cms\\<^sub>1, mem\\<^sub>1) \\<approx>\n             (cms\\<^sub>2, mem\\<^sub>2);\n     snd cms\\<^sub>1 = snd cms\\<^sub>2;\n     (cms\\<^sub>1, mem\\<^sub>1) \\<leadsto> (cms\\<^sub>1', mem\\<^sub>1');\n     sym mm_equiv; closed_glob_consistent mm_equiv;\n     \\<forall>mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2.\n        \\<langle>fst cms\\<^sub>1, snd cms\\<^sub>1, mem\\<^sub>1\\<rangle> \\<approx>\n        \\<langle>c\\<^sub>2, snd cms\\<^sub>1, mem\\<^sub>2\\<rangle> \\<longrightarrow>\n        mem\\<^sub>1 =\\<^bsub>snd cms\\<^sub>1\\<^esub>\\<^sup>l mem\\<^sub>2 \\<and>\n        (\\<forall>c\\<^sub>1' mds' mem\\<^sub>1'.\n            \\<langle>fst cms\\<^sub>1, snd\n cms\\<^sub>1, mem\\<^sub>1\\<rangle> \\<leadsto>\n            \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<longrightarrow>\n            (\\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                \\<langle>c\\<^sub>2, snd cms\\<^sub>1, mem\\<^sub>2\\<rangle> \\<leadsto>\n                \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n                \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n                \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>))\\<rbrakk>\n    \\<Longrightarrow> \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                         (cms\\<^sub>2, mem\\<^sub>2) \\<leadsto>\n                         \\<langle>c\\<^sub>2', snd\n         cms\\<^sub>1', mem\\<^sub>2'\\<rangle> \\<and>\n                         (cms\\<^sub>1', mem\\<^sub>1') \\<approx>\n                         \\<langle>c\\<^sub>2', snd\n         cms\\<^sub>1', mem\\<^sub>2'\\<rangle>", "by (metis surjective_pairing)"], ["", "lemma change_respecting_doesnt_modify:\n  assumes cr: \"change_respecting (cms, mem) (cms', mem') X\"\n  assumes eval: \"(cms, mem) \\<leadsto> (cms', mem')\"\n  assumes x_in_dom: \"x \\<in> X \\<union> vars_\\<C> X\"\n  shows \"mem x = mem' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mem x = mem' x", "using change_respecting_doesnt_modify'[where Y=\"X \\<union> vars_\\<C> X\", OF eval] cr     \n        change_respecting.simps vars_and_\\<C>_def x_in_dom"], ["proof (prove)\nusing this:\n  \\<lbrakk>\\<forall>f.\n              dom f = X \\<union> vars_\\<C> X \\<longrightarrow>\n              (cms, subst f mem) \\<leadsto> (cms', subst f mem');\n   ?x \\<in> X \\<union> vars_\\<C> X\\<rbrakk>\n  \\<Longrightarrow> mem ?x = mem' ?x\n  change_respecting (cms, mem) (cms', mem') X\n  change_respecting (?cms, ?mem) (?cms', ?mem') ?X =\n  ((?cms, ?mem) \\<leadsto> (?cms', ?mem') \\<and>\n   (\\<forall>\\<sigma>.\n       dom \\<sigma> = vars_and_\\<C> ?X \\<longrightarrow>\n       (?cms, subst \\<sigma> ?mem) \\<leadsto>\n       (?cms', subst \\<sigma> ?mem')))\n  vars_and_\\<C> ?X \\<equiv> ?X \\<union> vars_\\<C> ?X\n  x \\<in> X \\<union> vars_\\<C> X\n\ngoal (1 subgoal):\n 1. mem x = mem' x", "by metis"], ["", "lemma change_respecting_doesnt_modify_dma:\n  assumes cr: \"change_respecting (cms, mem) (cms', mem') X\"\n  assumes eval: \"(cms, mem) \\<leadsto> (cms', mem')\"\n  assumes x_in_dom: \"x \\<in> X\"\n  shows \"dma mem x = dma mem' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dma mem x = dma mem' x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. dma mem x = dma mem' x", "have \"\\<And>y. y \\<in> \\<C>_vars x \\<Longrightarrow> mem y = mem' y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> \\<C>_vars x \\<Longrightarrow> mem y = mem' y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> \\<C>_vars x \\<Longrightarrow> mem y = mem' y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> \\<C>_vars x \\<Longrightarrow> mem y = mem' y", "assume \"y \\<in> \\<C>_vars x\""], ["proof (state)\nthis:\n  y \\<in> \\<C>_vars x\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> \\<C>_vars x \\<Longrightarrow> mem y = mem' y", "hence \"y \\<in> vars_\\<C> X\""], ["proof (prove)\nusing this:\n  y \\<in> \\<C>_vars x\n\ngoal (1 subgoal):\n 1. y \\<in> vars_\\<C> X", "using x_in_dom"], ["proof (prove)\nusing this:\n  y \\<in> \\<C>_vars x\n  x \\<in> X\n\ngoal (1 subgoal):\n 1. y \\<in> vars_\\<C> X", "by(auto simp: vars_\\<C>_def)"], ["proof (state)\nthis:\n  y \\<in> vars_\\<C> X\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> \\<C>_vars x \\<Longrightarrow> mem y = mem' y", "thus \"mem y = mem' y\""], ["proof (prove)\nusing this:\n  y \\<in> vars_\\<C> X\n\ngoal (1 subgoal):\n 1. mem y = mem' y", "using cr eval change_respecting_doesnt_modify"], ["proof (prove)\nusing this:\n  y \\<in> vars_\\<C> X\n  change_respecting (cms, mem) (cms', mem') X\n  (cms, mem) \\<leadsto> (cms', mem')\n  \\<lbrakk>change_respecting (?cms, ?mem) (?cms', ?mem') ?X;\n   (?cms, ?mem) \\<leadsto> (?cms', ?mem');\n   ?x \\<in> ?X \\<union> vars_\\<C> ?X\\<rbrakk>\n  \\<Longrightarrow> ?mem ?x = ?mem' ?x\n\ngoal (1 subgoal):\n 1. mem y = mem' y", "by blast"], ["proof (state)\nthis:\n  mem y = mem' y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?y5 \\<in> \\<C>_vars x \\<Longrightarrow> mem ?y5 = mem' ?y5\n\ngoal (1 subgoal):\n 1. dma mem x = dma mem' x", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?y5 \\<in> \\<C>_vars x \\<Longrightarrow> mem ?y5 = mem' ?y5\n\ngoal (1 subgoal):\n 1. dma mem x = dma mem' x", "by(metis dma_\\<C>_vars)"], ["proof (state)\nthis:\n  dma mem x = dma mem' x\n\ngoal:\nNo subgoals!", "qed"], ["", "definition restrict_total :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> 'a set \\<Rightarrow> 'a \\<rightharpoonup> 'b\" (*infix \"|'\" 60*)\n  where \"restrict_total f A = to_partial f |` A\""], ["", "lemma differing_empty_eq:\n  \"\\<lbrakk> differing_vars mem mem' = {} \\<rbrakk> \\<Longrightarrow> mem = mem'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. differing_vars mem mem' = {} \\<Longrightarrow> mem = mem'", "unfolding differing_vars_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. mem x \\<noteq> mem' x} = {} \\<Longrightarrow> mem = mem'", "by auto"], ["", "lemma adaptation_finite:\n  \"finite (dom (A::('Var,'Val) adaptation))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (dom A)", "apply(rule finite_subset[OF _ finite_memory])"], ["proof (prove)\ngoal (1 subgoal):\n 1. dom A \\<subseteq> {x. True}", "by blast"], ["", "definition \n  globally_consistent  :: \"('Var, 'Val) adaptation \\<Rightarrow> 'Var Mds \\<Rightarrow> ('Var,'Val) Mem \\<Rightarrow> ('Var,'Val) Mem \\<Rightarrow> bool\"\nwhere \"globally_consistent A mds mem\\<^sub>1 mem\\<^sub>2 \\<equiv> \n  (\\<forall>x.  case A x of Some (v,v') \\<Rightarrow> (mem\\<^sub>1 x \\<noteq> v \\<or> mem\\<^sub>2 x \\<noteq> v') \\<longrightarrow> \\<not> var_asm_not_written mds x | _ \\<Rightarrow> True) \\<and>\n        (\\<forall>x. dma mem\\<^sub>1 [\\<parallel>\\<^sub>1 A] x \\<noteq> dma mem\\<^sub>1 x \\<longrightarrow> \\<not> var_asm_not_written mds x) \\<and>\n          (\\<forall>x. dma (mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]) x = Low \\<and> (x \\<notin> mds AsmNoReadOrWrite \\<or> x \\<in> \\<C>) \\<longrightarrow> (mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]) x = (mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]) x)\""], ["", "lemma globally_consistent_adapt_bisim:\n  assumes bisim: \"\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx> \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>\"\n  assumes globally_consistent: \"globally_consistent A mds mem\\<^sub>1 mem\\<^sub>2\"\n  shows \"\\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx> \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>", "apply(rule mm_equiv_glob_consistent[simplified closed_glob_consistent_def, rule_format])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>\n 2. (\\<forall>x.\n        case A x of None \\<Rightarrow> True\n        | Some (v, v') \\<Rightarrow>\n            mem\\<^sub>1 x \\<noteq> v \\<or>\n            mem\\<^sub>2 x \\<noteq> v' \\<longrightarrow>\n            \\<not> var_asm_not_written mds x) \\<and>\n    (\\<forall>x.\n        dma mem\\<^sub>1 [\\<parallel>\\<^sub>1 A] x \\<noteq>\n        dma mem\\<^sub>1 x \\<longrightarrow>\n        \\<not> var_asm_not_written mds x) \\<and>\n    (\\<forall>x.\n        dma mem\\<^sub>1 [\\<parallel>\\<^sub>1 A] x = Low \\<and>\n        (x \\<notin> mds AsmNoReadOrWrite \\<or>\n         x \\<in> \\<C>) \\<longrightarrow>\n        mem\\<^sub>1 [\\<parallel>\\<^sub>1 A] x =\n        mem\\<^sub>2 [\\<parallel>\\<^sub>2 A] x)", "apply(rule bisim)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x.\n        case A x of None \\<Rightarrow> True\n        | Some (v, v') \\<Rightarrow>\n            mem\\<^sub>1 x \\<noteq> v \\<or>\n            mem\\<^sub>2 x \\<noteq> v' \\<longrightarrow>\n            \\<not> var_asm_not_written mds x) \\<and>\n    (\\<forall>x.\n        dma mem\\<^sub>1 [\\<parallel>\\<^sub>1 A] x \\<noteq>\n        dma mem\\<^sub>1 x \\<longrightarrow>\n        \\<not> var_asm_not_written mds x) \\<and>\n    (\\<forall>x.\n        dma mem\\<^sub>1 [\\<parallel>\\<^sub>1 A] x = Low \\<and>\n        (x \\<notin> mds AsmNoReadOrWrite \\<or>\n         x \\<in> \\<C>) \\<longrightarrow>\n        mem\\<^sub>1 [\\<parallel>\\<^sub>1 A] x =\n        mem\\<^sub>2 [\\<parallel>\\<^sub>2 A] x)", "apply(fold globally_consistent_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. globally_consistent A mds mem\\<^sub>1 mem\\<^sub>2", "by(rule globally_consistent)"], ["", "lemma mm_equiv_\\<C>_eq: \n  \"(a,b) \\<approx> (a',b') \\<Longrightarrow> snd a = snd a' \\<Longrightarrow>\n    \\<forall>x\\<in>\\<C>. b x = b' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(a, b) \\<approx> (a', b'); snd a = snd a'\\<rbrakk>\n    \\<Longrightarrow> \\<forall>x\\<in>\\<C>. b x = b' x", "apply(case_tac a, case_tac a')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>aa ba aaa baa.\n       \\<lbrakk>(a, b) \\<approx> (a', b'); snd a = snd a'; a = (aa, ba);\n        a' = (aaa, baa)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>\\<C>. b x = b' x", "using mm_equiv_strong_low_bisim[simplified strong_low_bisim_mm_def, rule_format]"], ["proof (prove)\nusing this:\n  sym mm_equiv \\<and>\n  closed_glob_consistent mm_equiv \\<and>\n  (\\<forall>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2.\n      \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n      \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<longrightarrow>\n      mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2 \\<and>\n      (\\<forall>c\\<^sub>1' mds' mem\\<^sub>1'.\n          \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n          \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<longrightarrow>\n          (\\<exists>c\\<^sub>2' mem\\<^sub>2'.\n              \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n              \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n              \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n              \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>)))\n\ngoal (1 subgoal):\n 1. \\<And>aa ba aaa baa.\n       \\<lbrakk>(a, b) \\<approx> (a', b'); snd a = snd a'; a = (aa, ba);\n        a' = (aaa, baa)\\<rbrakk>\n       \\<Longrightarrow> \\<forall>x\\<in>\\<C>. b x = b' x", "by(auto simp: low_mds_eq_def \\<C>_Low)"], ["", "lemma apply_adaptation_not_in_dom: \n  \"x \\<notin> dom A \\<Longrightarrow> apply_adaptation b blah A x = blah x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> dom A \\<Longrightarrow> apply_adaptation b blah A x = blah x", "apply(simp add: apply_adaptation_def domIff split: option.splits)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* This is the central lemma. Unfortunately, I didn't find\n   a nice partitioning into several easier lemmas: *)"], ["", "lemma makes_compatible_invariant:\n  assumes sound_modes: \"sound_mode_use (cms\\<^sub>1, mem\\<^sub>1)\"\n                      \"sound_mode_use (cms\\<^sub>2, mem\\<^sub>2)\"\n  assumes compat: \"makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2) mems\"\n  assumes modes_eq: \"map snd cms\\<^sub>1 = map snd cms\\<^sub>2\"\n  assumes eval: \"(cms\\<^sub>1, mem\\<^sub>1) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\"\n  obtains cms\\<^sub>2' mem\\<^sub>2' mems' where\n      \"map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n       (cms\\<^sub>2, mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n       makes_compatible (cms\\<^sub>1', mem\\<^sub>1') (cms\\<^sub>2', mem\\<^sub>2') mems'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2,\n         mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2,\n         mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "let ?X = \"\\<lambda> i. differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2,\n         mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "from sound_modes compat modes_eq"], ["proof (chain)\npicking this:\n  sound_mode_use (cms\\<^sub>1, mem\\<^sub>1)\n  sound_mode_use (cms\\<^sub>2, mem\\<^sub>2)\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  map snd cms\\<^sub>1 = map snd cms\\<^sub>2", "have\n    a: \"\\<forall> i < length cms\\<^sub>1. \\<forall> x \\<in> (?X i). doesnt_read_or_modify (fst (cms\\<^sub>1 ! i)) x \\<and>\n                                          doesnt_read_or_modify (fst (cms\\<^sub>2 ! i)) x\""], ["proof (prove)\nusing this:\n  sound_mode_use (cms\\<^sub>1, mem\\<^sub>1)\n  sound_mode_use (cms\\<^sub>2, mem\\<^sub>2)\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  map snd cms\\<^sub>1 = map snd cms\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<forall>i<length cms\\<^sub>1.\n       \\<forall>x\\<in>differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i.\n          doesnt_read_or_modify (fst (cms\\<^sub>1 ! i)) x \\<and>\n          doesnt_read_or_modify (fst (cms\\<^sub>2 ! i)) x", "by (metis compatible_different_no_read)"], ["proof (state)\nthis:\n  \\<forall>i<length cms\\<^sub>1.\n     \\<forall>x\\<in>differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i.\n        doesnt_read_or_modify (fst (cms\\<^sub>1 ! i)) x \\<and>\n        doesnt_read_or_modify (fst (cms\\<^sub>2 ! i)) x\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2,\n         mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "from eval"], ["proof (chain)\npicking this:\n  (cms\\<^sub>1,\n   mem\\<^sub>1) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')", "have\n    b: \"k < length cms\\<^sub>1 \\<and> (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto> (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n        cms\\<^sub>1' = cms\\<^sub>1 [k := cms\\<^sub>1' ! k]\""], ["proof (prove)\nusing this:\n  (cms\\<^sub>1,\n   mem\\<^sub>1) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\n\ngoal (1 subgoal):\n 1. k < length cms\\<^sub>1 \\<and>\n    (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto>\n    (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n    cms\\<^sub>1' = cms\\<^sub>1[k := cms\\<^sub>1' ! k]", "by (metis meval_elim nth_list_update_eq)"], ["proof (state)\nthis:\n  k < length cms\\<^sub>1 \\<and>\n  (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto>\n  (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n  cms\\<^sub>1' = cms\\<^sub>1[k := cms\\<^sub>1' ! k]\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2,\n         mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "from modes_eq"], ["proof (chain)\npicking this:\n  map snd cms\\<^sub>1 = map snd cms\\<^sub>2", "have equal_size: \"length cms\\<^sub>1 = length cms\\<^sub>2\""], ["proof (prove)\nusing this:\n  map snd cms\\<^sub>1 = map snd cms\\<^sub>2\n\ngoal (1 subgoal):\n 1. length cms\\<^sub>1 = length cms\\<^sub>2", "by (metis length_map)"], ["proof (state)\nthis:\n  length cms\\<^sub>1 = length cms\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2,\n         mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "let ?mds\\<^sub>k = \"snd (cms\\<^sub>1 ! k)\" and\n      ?mds\\<^sub>k' = \"snd (cms\\<^sub>1' ! k)\" and\n      ?mems\\<^sub>1k = \"fst (mems ! k)\" and\n      ?mems\\<^sub>2k = \"snd (mems ! k)\" and\n      ?n = \"length cms\\<^sub>1\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2,\n         mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have \"finite (?X k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)", "by (metis differing_lists_finite)"], ["proof (state)\nthis:\n  finite (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2,\n         mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "(* Obtaining cms' and mem\\<^sub>2' is not in a proof block, since we\n     need some of the following statements later: *)"], ["proof (state)\nthis:\n  finite (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2,\n         mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  finite (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)", "have\n    c: \"change_respecting (cms\\<^sub>1 ! k, mem\\<^sub>1) (cms\\<^sub>1' ! k, mem\\<^sub>1') (?X k)\""], ["proof (prove)\nusing this:\n  finite (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n\ngoal (1 subgoal):\n 1. change_respecting (cms\\<^sub>1 ! k, mem\\<^sub>1)\n     (cms\\<^sub>1' ! k, mem\\<^sub>1')\n     (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)", "using noread_exists_change_respecting b a"], ["proof (prove)\nusing this:\n  finite (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n  \\<lbrakk>finite ?X;\n   \\<langle>?c, ?mds, ?mem\\<rangle> \\<leadsto>\n   \\<langle>?c', ?mds', ?mem'\\<rangle>;\n   \\<forall>x\\<in>?X. doesnt_read_or_modify ?c x\\<rbrakk>\n  \\<Longrightarrow> change_respecting \\<langle>?c, ?mds, ?mem\\<rangle>\n                     \\<langle>?c', ?mds', ?mem'\\<rangle> ?X\n  k < length cms\\<^sub>1 \\<and>\n  (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto>\n  (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n  cms\\<^sub>1' = cms\\<^sub>1[k := cms\\<^sub>1' ! k]\n  \\<forall>i<length cms\\<^sub>1.\n     \\<forall>x\\<in>differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i.\n        doesnt_read_or_modify (fst (cms\\<^sub>1 ! i)) x \\<and>\n        doesnt_read_or_modify (fst (cms\\<^sub>2 ! i)) x\n\ngoal (1 subgoal):\n 1. change_respecting (cms\\<^sub>1 ! k, mem\\<^sub>1)\n     (cms\\<^sub>1' ! k, mem\\<^sub>1')\n     (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)", "by (metis surjective_pairing)"], ["proof (state)\nthis:\n  change_respecting (cms\\<^sub>1 ! k, mem\\<^sub>1)\n   (cms\\<^sub>1' ! k, mem\\<^sub>1')\n   (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2,\n         mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "from compat"], ["proof (chain)\npicking this:\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems", "have \"\\<And> \\<sigma>. dom \\<sigma> = ?X k \\<Longrightarrow> ?mems\\<^sub>1k [\\<mapsto> \\<sigma>] = mem\\<^sub>1 [\\<mapsto> \\<sigma>]\""], ["proof (prove)\nusing this:\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       dom \\<sigma> =\n       differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n       subst \\<sigma> (fst (mems ! k)) = subst \\<sigma> mem\\<^sub>1", "using differing_vars_subst differing_vars_lists_def"], ["proof (prove)\nusing this:\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  differing_vars ?mem\\<^sub>1 ?mem\\<^sub>2\n  \\<subseteq> dom ?\\<sigma> \\<Longrightarrow>\n  subst ?\\<sigma> ?mem\\<^sub>1 = subst ?\\<sigma> ?mem\\<^sub>2\n  differing_vars_lists ?mem\\<^sub>1 ?mem\\<^sub>2 ?mems ?i \\<equiv>\n  differing_vars ?mem\\<^sub>1 (fst (?mems ! ?i)) \\<union>\n  differing_vars ?mem\\<^sub>2 (snd (?mems ! ?i))\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       dom \\<sigma> =\n       differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n       subst \\<sigma> (fst (mems ! k)) = subst \\<sigma> mem\\<^sub>1", "by (metis Un_upper1 Un_subset_iff)"], ["proof (state)\nthis:\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  subst ?\\<sigma>5 (fst (mems ! k)) = subst ?\\<sigma>5 mem\\<^sub>1\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2,\n         mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "hence\n    eval\\<^sub>\\<sigma>: \"\\<And> \\<sigma>. dom \\<sigma> = ?X k \\<Longrightarrow> (cms\\<^sub>1 ! k, ?mems\\<^sub>1k [\\<mapsto> \\<sigma>]) \\<leadsto> (cms\\<^sub>1' ! k, mem\\<^sub>1' [\\<mapsto> \\<sigma>])\""], ["proof (prove)\nusing this:\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  subst ?\\<sigma>5 (fst (mems ! k)) = subst ?\\<sigma>5 mem\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       dom \\<sigma> =\n       differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n       (cms\\<^sub>1 ! k, subst \\<sigma> (fst (mems ! k))) \\<leadsto>\n       (cms\\<^sub>1' ! k, subst \\<sigma> mem\\<^sub>1')", "by(metis change_respecting_subst[rule_format, where X=\"?X k\"] c)"], ["proof (state)\nthis:\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  (cms\\<^sub>1 ! k, subst ?\\<sigma>5 (fst (mems ! k))) \\<leadsto>\n  (cms\\<^sub>1' ! k, subst ?\\<sigma>5 mem\\<^sub>1')\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2,\n         mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  (cms\\<^sub>1 ! k, subst ?\\<sigma>5 (fst (mems ! k))) \\<leadsto>\n  (cms\\<^sub>1' ! k, subst ?\\<sigma>5 mem\\<^sub>1')\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2,\n         mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "with b and compat"], ["proof (chain)\npicking this:\n  k < length cms\\<^sub>1 \\<and>\n  (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto>\n  (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n  cms\\<^sub>1' = cms\\<^sub>1[k := cms\\<^sub>1' ! k]\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  (cms\\<^sub>1 ! k, subst ?\\<sigma>5 (fst (mems ! k))) \\<leadsto>\n  (cms\\<^sub>1' ! k, subst ?\\<sigma>5 mem\\<^sub>1')", "have\n    bisim\\<^sub>\\<sigma>: \"\\<And> \\<sigma>. dom \\<sigma> = ?X k \\<Longrightarrow> (cms\\<^sub>1 ! k, ?mems\\<^sub>1k [\\<mapsto> \\<sigma>]) \\<approx> (cms\\<^sub>2 ! k, ?mems\\<^sub>2k [\\<mapsto> \\<sigma>])\""], ["proof (prove)\nusing this:\n  k < length cms\\<^sub>1 \\<and>\n  (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto>\n  (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n  cms\\<^sub>1' = cms\\<^sub>1[k := cms\\<^sub>1' ! k]\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  (cms\\<^sub>1 ! k, subst ?\\<sigma>5 (fst (mems ! k))) \\<leadsto>\n  (cms\\<^sub>1' ! k, subst ?\\<sigma>5 mem\\<^sub>1')\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       dom \\<sigma> =\n       differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n       (cms\\<^sub>1 ! k, subst \\<sigma> (fst (mems ! k))) \\<approx>\n       (cms\\<^sub>2 ! k, subst \\<sigma> (snd (mems ! k)))", "by auto"], ["proof (state)\nthis:\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  (cms\\<^sub>1 ! k, subst ?\\<sigma>5 (fst (mems ! k))) \\<approx>\n  (cms\\<^sub>2 ! k, subst ?\\<sigma>5 (snd (mems ! k)))\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2,\n         mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  (cms\\<^sub>1 ! k, subst ?\\<sigma>5 (fst (mems ! k))) \\<approx>\n  (cms\\<^sub>2 ! k, subst ?\\<sigma>5 (snd (mems ! k)))\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2,\n         mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have \"snd (cms\\<^sub>1 ! k) = snd (cms\\<^sub>2 ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (cms\\<^sub>1 ! k) = snd (cms\\<^sub>2 ! k)", "by (metis b equal_size modes_eq nth_map)"], ["proof (state)\nthis:\n  snd (cms\\<^sub>1 ! k) = snd (cms\\<^sub>2 ! k)\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2,\n         mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  (cms\\<^sub>1 ! k, subst ?\\<sigma>5 (fst (mems ! k))) \\<leadsto>\n  (cms\\<^sub>1' ! k, subst ?\\<sigma>5 mem\\<^sub>1')\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  (cms\\<^sub>1 ! k, subst ?\\<sigma>5 (fst (mems ! k))) \\<approx>\n  (cms\\<^sub>2 ! k, subst ?\\<sigma>5 (snd (mems ! k)))\n  snd (cms\\<^sub>1 ! k) = snd (cms\\<^sub>2 ! k)", "have d: \"\\<And> \\<sigma>. dom \\<sigma> = ?X k \\<Longrightarrow> \\<exists> c\\<^sub>f' mem\\<^sub>f'.\n    (cms\\<^sub>2 ! k, ?mems\\<^sub>2k [\\<mapsto> \\<sigma>]) \\<leadsto> \\<langle> c\\<^sub>f', ?mds\\<^sub>k', mem\\<^sub>f' \\<rangle> \\<and>\n    (cms\\<^sub>1' ! k, mem\\<^sub>1' [\\<mapsto> \\<sigma>]) \\<approx> \\<langle> c\\<^sub>f', ?mds\\<^sub>k', mem\\<^sub>f' \\<rangle>\""], ["proof (prove)\nusing this:\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  (cms\\<^sub>1 ! k, subst ?\\<sigma>5 (fst (mems ! k))) \\<leadsto>\n  (cms\\<^sub>1' ! k, subst ?\\<sigma>5 mem\\<^sub>1')\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  (cms\\<^sub>1 ! k, subst ?\\<sigma>5 (fst (mems ! k))) \\<approx>\n  (cms\\<^sub>2 ! k, subst ?\\<sigma>5 (snd (mems ! k)))\n  snd (cms\\<^sub>1 ! k) = snd (cms\\<^sub>2 ! k)\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       dom \\<sigma> =\n       differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n       \\<exists>c\\<^sub>f' mem\\<^sub>f'.\n          (cms\\<^sub>2 ! k, subst \\<sigma> (snd (mems ! k))) \\<leadsto>\n          \\<langle>c\\<^sub>f', snd (cms\\<^sub>1' !\n                                    k), mem\\<^sub>f'\\<rangle> \\<and>\n          (cms\\<^sub>1' ! k, subst \\<sigma> mem\\<^sub>1') \\<approx>\n          \\<langle>c\\<^sub>f', snd (cms\\<^sub>1' ! k), mem\\<^sub>f'\\<rangle>", "by (metis mm_equiv_step)"], ["proof (state)\nthis:\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  \\<exists>c\\<^sub>f' mem\\<^sub>f'.\n     (cms\\<^sub>2 ! k, subst ?\\<sigma>5 (snd (mems ! k))) \\<leadsto>\n     \\<langle>c\\<^sub>f', snd (cms\\<^sub>1' !\n                               k), mem\\<^sub>f'\\<rangle> \\<and>\n     (cms\\<^sub>1' ! k, subst ?\\<sigma>5 mem\\<^sub>1') \\<approx>\n     \\<langle>c\\<^sub>f', snd (cms\\<^sub>1' ! k), mem\\<^sub>f'\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2,\n         mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "obtain h :: \"'Var \\<rightharpoonup> 'Val\" where domh: \"dom h = ?X k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>h.\n        dom h =\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n         k \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis dom_restrict_total)"], ["proof (state)\nthis:\n  dom h = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2,\n         mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  dom h = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k", "obtain c\\<^sub>h mem\\<^sub>h where h_prop:\n    \"(cms\\<^sub>2 ! k, ?mems\\<^sub>2k [\\<mapsto> h]) \\<leadsto> \\<langle> c\\<^sub>h, ?mds\\<^sub>k', mem\\<^sub>h \\<rangle> \\<and>\n    (cms\\<^sub>1' ! k, mem\\<^sub>1' [\\<mapsto> h]) \\<approx> \\<langle> c\\<^sub>h, ?mds\\<^sub>k', mem\\<^sub>h \\<rangle>\""], ["proof (prove)\nusing this:\n  dom h = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. (\\<And>c\\<^sub>h mem\\<^sub>h.\n        (cms\\<^sub>2 ! k, subst h (snd (mems ! k))) \\<leadsto>\n        \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                                 k), mem\\<^sub>h\\<rangle> \\<and>\n        (cms\\<^sub>1' ! k, subst h mem\\<^sub>1') \\<approx>\n        \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                                 k), mem\\<^sub>h\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using d"], ["proof (prove)\nusing this:\n  dom h = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  \\<exists>c\\<^sub>f' mem\\<^sub>f'.\n     (cms\\<^sub>2 ! k, subst ?\\<sigma>5 (snd (mems ! k))) \\<leadsto>\n     \\<langle>c\\<^sub>f', snd (cms\\<^sub>1' !\n                               k), mem\\<^sub>f'\\<rangle> \\<and>\n     (cms\\<^sub>1' ! k, subst ?\\<sigma>5 mem\\<^sub>1') \\<approx>\n     \\<langle>c\\<^sub>f', snd (cms\\<^sub>1' ! k), mem\\<^sub>f'\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>c\\<^sub>h mem\\<^sub>h.\n        (cms\\<^sub>2 ! k, subst h (snd (mems ! k))) \\<leadsto>\n        \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                                 k), mem\\<^sub>h\\<rangle> \\<and>\n        (cms\\<^sub>1' ! k, subst h mem\\<^sub>1') \\<approx>\n        \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                                 k), mem\\<^sub>h\\<rangle> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  (cms\\<^sub>2 ! k, subst h (snd (mems ! k))) \\<leadsto>\n  \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle> \\<and>\n  (cms\\<^sub>1' ! k, subst h mem\\<^sub>1') \\<approx>\n  \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2,\n         mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "then"], ["proof (chain)\npicking this:\n  (cms\\<^sub>2 ! k, subst h (snd (mems ! k))) \\<leadsto>\n  \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle> \\<and>\n  (cms\\<^sub>1' ! k, subst h mem\\<^sub>1') \\<approx>\n  \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle>", "have\n    \"change_respecting (cms\\<^sub>2 ! k, ?mems\\<^sub>2k [\\<mapsto> h]) \\<langle> c\\<^sub>h, ?mds\\<^sub>k', mem\\<^sub>h \\<rangle> (?X k)\""], ["proof (prove)\nusing this:\n  (cms\\<^sub>2 ! k, subst h (snd (mems ! k))) \\<leadsto>\n  \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle> \\<and>\n  (cms\\<^sub>1' ! k, subst h mem\\<^sub>1') \\<approx>\n  \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle>\n\ngoal (1 subgoal):\n 1. change_respecting (cms\\<^sub>2 ! k, subst h (snd (mems ! k)))\n     \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle>\n     (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)", "using a b noread_exists_change_respecting"], ["proof (prove)\nusing this:\n  (cms\\<^sub>2 ! k, subst h (snd (mems ! k))) \\<leadsto>\n  \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle> \\<and>\n  (cms\\<^sub>1' ! k, subst h mem\\<^sub>1') \\<approx>\n  \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle>\n  \\<forall>i<length cms\\<^sub>1.\n     \\<forall>x\\<in>differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i.\n        doesnt_read_or_modify (fst (cms\\<^sub>1 ! i)) x \\<and>\n        doesnt_read_or_modify (fst (cms\\<^sub>2 ! i)) x\n  k < length cms\\<^sub>1 \\<and>\n  (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto>\n  (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n  cms\\<^sub>1' = cms\\<^sub>1[k := cms\\<^sub>1' ! k]\n  \\<lbrakk>finite ?X;\n   \\<langle>?c, ?mds, ?mem\\<rangle> \\<leadsto>\n   \\<langle>?c', ?mds', ?mem'\\<rangle>;\n   \\<forall>x\\<in>?X. doesnt_read_or_modify ?c x\\<rbrakk>\n  \\<Longrightarrow> change_respecting \\<langle>?c, ?mds, ?mem\\<rangle>\n                     \\<langle>?c', ?mds', ?mem'\\<rangle> ?X\n\ngoal (1 subgoal):\n 1. change_respecting (cms\\<^sub>2 ! k, subst h (snd (mems ! k)))\n     \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle>\n     (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)", "by (metis differing_lists_finite surjective_pairing)\n\n  \\<comment> \\<open>The following statements are universally quantified\n      since they are reused later:\\<close>"], ["proof (state)\nthis:\n  change_respecting (cms\\<^sub>2 ! k, subst h (snd (mems ! k)))\n   \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle>\n   (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2,\n         mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "with h_prop"], ["proof (chain)\npicking this:\n  (cms\\<^sub>2 ! k, subst h (snd (mems ! k))) \\<leadsto>\n  \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle> \\<and>\n  (cms\\<^sub>1' ! k, subst h mem\\<^sub>1') \\<approx>\n  \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle>\n  change_respecting (cms\\<^sub>2 ! k, subst h (snd (mems ! k)))\n   \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle>\n   (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)", "have\n    \"\\<forall> \\<sigma>. dom \\<sigma> = ?X k \\<longrightarrow>\n      (cms\\<^sub>2 ! k, ?mems\\<^sub>2k [\\<mapsto> h] [\\<mapsto> \\<sigma>]) \\<leadsto> \\<langle> c\\<^sub>h, ?mds\\<^sub>k', mem\\<^sub>h [\\<mapsto> \\<sigma>] \\<rangle>\""], ["proof (prove)\nusing this:\n  (cms\\<^sub>2 ! k, subst h (snd (mems ! k))) \\<leadsto>\n  \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle> \\<and>\n  (cms\\<^sub>1' ! k, subst h mem\\<^sub>1') \\<approx>\n  \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle>\n  change_respecting (cms\\<^sub>2 ! k, subst h (snd (mems ! k)))\n   \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle>\n   (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       dom \\<sigma> =\n       differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<longrightarrow>\n       (cms\\<^sub>2 ! k,\n        subst \\<sigma> (subst h (snd (mems ! k)))) \\<leadsto>\n       \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                                k), subst \\<sigma> mem\\<^sub>h\\<rangle>", "by (metis change_respecting_subst)"], ["proof (state)\nthis:\n  \\<forall>\\<sigma>.\n     dom \\<sigma> =\n     differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<longrightarrow>\n     (cms\\<^sub>2 ! k, subst \\<sigma> (subst h (snd (mems ! k)))) \\<leadsto>\n     \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                              k), subst \\<sigma> mem\\<^sub>h\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2,\n         mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "with domh"], ["proof (chain)\npicking this:\n  dom h = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n  \\<forall>\\<sigma>.\n     dom \\<sigma> =\n     differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<longrightarrow>\n     (cms\\<^sub>2 ! k, subst \\<sigma> (subst h (snd (mems ! k)))) \\<leadsto>\n     \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                              k), subst \\<sigma> mem\\<^sub>h\\<rangle>", "have f:\n    \"\\<forall> \\<sigma>. dom \\<sigma> = ?X k \\<longrightarrow>\n      (cms\\<^sub>2 ! k, ?mems\\<^sub>2k [\\<mapsto> \\<sigma>]) \\<leadsto> \\<langle> c\\<^sub>h, ?mds\\<^sub>k', mem\\<^sub>h [\\<mapsto> \\<sigma>] \\<rangle>\""], ["proof (prove)\nusing this:\n  dom h = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n  \\<forall>\\<sigma>.\n     dom \\<sigma> =\n     differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<longrightarrow>\n     (cms\\<^sub>2 ! k, subst \\<sigma> (subst h (snd (mems ! k)))) \\<leadsto>\n     \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                              k), subst \\<sigma> mem\\<^sub>h\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       dom \\<sigma> =\n       differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<longrightarrow>\n       (cms\\<^sub>2 ! k, subst \\<sigma> (snd (mems ! k))) \\<leadsto>\n       \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                                k), subst \\<sigma> mem\\<^sub>h\\<rangle>", "by (auto simp: subst_overrides)"], ["proof (state)\nthis:\n  \\<forall>\\<sigma>.\n     dom \\<sigma> =\n     differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<longrightarrow>\n     (cms\\<^sub>2 ! k, subst \\<sigma> (snd (mems ! k))) \\<leadsto>\n     \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                              k), subst \\<sigma> mem\\<^sub>h\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2,\n         mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "from d and f"], ["proof (chain)\npicking this:\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  \\<exists>c\\<^sub>f' mem\\<^sub>f'.\n     (cms\\<^sub>2 ! k, subst ?\\<sigma>5 (snd (mems ! k))) \\<leadsto>\n     \\<langle>c\\<^sub>f', snd (cms\\<^sub>1' !\n                               k), mem\\<^sub>f'\\<rangle> \\<and>\n     (cms\\<^sub>1' ! k, subst ?\\<sigma>5 mem\\<^sub>1') \\<approx>\n     \\<langle>c\\<^sub>f', snd (cms\\<^sub>1' ! k), mem\\<^sub>f'\\<rangle>\n  \\<forall>\\<sigma>.\n     dom \\<sigma> =\n     differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<longrightarrow>\n     (cms\\<^sub>2 ! k, subst \\<sigma> (snd (mems ! k))) \\<leadsto>\n     \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                              k), subst \\<sigma> mem\\<^sub>h\\<rangle>", "have g: \"\\<And> \\<sigma>. dom \\<sigma> = ?X k \\<Longrightarrow>\n    (cms\\<^sub>2 ! k, ?mems\\<^sub>2k [\\<mapsto> \\<sigma>]) \\<leadsto> \\<langle> c\\<^sub>h, ?mds\\<^sub>k', mem\\<^sub>h [\\<mapsto> \\<sigma>] \\<rangle> \\<and>\n    (cms\\<^sub>1' ! k, mem\\<^sub>1' [\\<mapsto> \\<sigma>]) \\<approx> \\<langle> c\\<^sub>h, ?mds\\<^sub>k', mem\\<^sub>h [\\<mapsto> \\<sigma>] \\<rangle>\""], ["proof (prove)\nusing this:\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  \\<exists>c\\<^sub>f' mem\\<^sub>f'.\n     (cms\\<^sub>2 ! k, subst ?\\<sigma>5 (snd (mems ! k))) \\<leadsto>\n     \\<langle>c\\<^sub>f', snd (cms\\<^sub>1' !\n                               k), mem\\<^sub>f'\\<rangle> \\<and>\n     (cms\\<^sub>1' ! k, subst ?\\<sigma>5 mem\\<^sub>1') \\<approx>\n     \\<langle>c\\<^sub>f', snd (cms\\<^sub>1' ! k), mem\\<^sub>f'\\<rangle>\n  \\<forall>\\<sigma>.\n     dom \\<sigma> =\n     differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<longrightarrow>\n     (cms\\<^sub>2 ! k, subst \\<sigma> (snd (mems ! k))) \\<leadsto>\n     \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                              k), subst \\<sigma> mem\\<^sub>h\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       dom \\<sigma> =\n       differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n       (cms\\<^sub>2 ! k, subst \\<sigma> (snd (mems ! k))) \\<leadsto>\n       \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                                k), subst \\<sigma>\n                                     mem\\<^sub>h\\<rangle> \\<and>\n       (cms\\<^sub>1' ! k, subst \\<sigma> mem\\<^sub>1') \\<approx>\n       \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                                k), subst \\<sigma> mem\\<^sub>h\\<rangle>", "using h_prop"], ["proof (prove)\nusing this:\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  \\<exists>c\\<^sub>f' mem\\<^sub>f'.\n     (cms\\<^sub>2 ! k, subst ?\\<sigma>5 (snd (mems ! k))) \\<leadsto>\n     \\<langle>c\\<^sub>f', snd (cms\\<^sub>1' !\n                               k), mem\\<^sub>f'\\<rangle> \\<and>\n     (cms\\<^sub>1' ! k, subst ?\\<sigma>5 mem\\<^sub>1') \\<approx>\n     \\<langle>c\\<^sub>f', snd (cms\\<^sub>1' ! k), mem\\<^sub>f'\\<rangle>\n  \\<forall>\\<sigma>.\n     dom \\<sigma> =\n     differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<longrightarrow>\n     (cms\\<^sub>2 ! k, subst \\<sigma> (snd (mems ! k))) \\<leadsto>\n     \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                              k), subst \\<sigma> mem\\<^sub>h\\<rangle>\n  (cms\\<^sub>2 ! k, subst h (snd (mems ! k))) \\<leadsto>\n  \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle> \\<and>\n  (cms\\<^sub>1' ! k, subst h mem\\<^sub>1') \\<approx>\n  \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>h\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       dom \\<sigma> =\n       differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n       (cms\\<^sub>2 ! k, subst \\<sigma> (snd (mems ! k))) \\<leadsto>\n       \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                                k), subst \\<sigma>\n                                     mem\\<^sub>h\\<rangle> \\<and>\n       (cms\\<^sub>1' ! k, subst \\<sigma> mem\\<^sub>1') \\<approx>\n       \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                                k), subst \\<sigma> mem\\<^sub>h\\<rangle>", "by (metis deterministic)"], ["proof (state)\nthis:\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  (cms\\<^sub>2 ! k, subst ?\\<sigma>5 (snd (mems ! k))) \\<leadsto>\n  \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                           k), subst ?\\<sigma>5 mem\\<^sub>h\\<rangle> \\<and>\n  (cms\\<^sub>1' ! k, subst ?\\<sigma>5 mem\\<^sub>1') \\<approx>\n  \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                           k), subst ?\\<sigma>5 mem\\<^sub>h\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2,\n         mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "let ?\\<sigma>_mem\\<^sub>2 = \"to_partial mem\\<^sub>2 |` ?X k\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2,\n         mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "define mem\\<^sub>2' where \"mem\\<^sub>2' = mem\\<^sub>h [\\<mapsto> ?\\<sigma>_mem\\<^sub>2]\""], ["proof (state)\nthis:\n  mem\\<^sub>2' =\n  subst\n   (to_partial mem\\<^sub>2 |`\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n   mem\\<^sub>h\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2,\n         mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "define c\\<^sub>2' where \"c\\<^sub>2' = c\\<^sub>h\""], ["proof (state)\nthis:\n  c\\<^sub>2' = c\\<^sub>h\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2,\n         mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have dom\\<sigma>_mem\\<^sub>2: \"dom ?\\<sigma>_mem\\<^sub>2 = ?X k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (to_partial mem\\<^sub>2 |`\n         differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) =\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k", "by (metis dom_restrict_total)"], ["proof (state)\nthis:\n  dom (to_partial mem\\<^sub>2 |`\n       differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2,\n         mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "have \"mem\\<^sub>2 = ?mems\\<^sub>2k [\\<mapsto> ?\\<sigma>_mem\\<^sub>2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mem\\<^sub>2 =\n    subst\n     (to_partial mem\\<^sub>2 |`\n      differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n     (snd (mems ! k))", "proof (rule ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       mem\\<^sub>2 x =\n       subst\n        (to_partial mem\\<^sub>2 |`\n         differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n        (snd (mems ! k)) x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       mem\\<^sub>2 x =\n       subst\n        (to_partial mem\\<^sub>2 |`\n         differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n        (snd (mems ! k)) x", "show \"mem\\<^sub>2 x = ?mems\\<^sub>2k [\\<mapsto> ?\\<sigma>_mem\\<^sub>2] x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mem\\<^sub>2 x =\n    subst\n     (to_partial mem\\<^sub>2 |`\n      differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n     (snd (mems ! k)) x", "using dom\\<sigma>_mem\\<^sub>2"], ["proof (prove)\nusing this:\n  dom (to_partial mem\\<^sub>2 |`\n       differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. mem\\<^sub>2 x =\n    subst\n     (to_partial mem\\<^sub>2 |`\n      differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n     (snd (mems ! k)) x", "unfolding to_partial_def subst_def"], ["proof (prove)\nusing this:\n  dom ((\\<lambda>x. Some (mem\\<^sub>2 x)) |`\n       differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. mem\\<^sub>2 x =\n    (case ((\\<lambda>x. Some (mem\\<^sub>2 x)) |`\n           differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n           x of\n     None \\<Rightarrow> snd (mems ! k) x | Some v \\<Rightarrow> v)", "apply (cases \"x \\<in> ?X k\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>dom ((\\<lambda>x. Some (mem\\<^sub>2 x)) |`\n                  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) =\n             differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n     x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\\<rbrakk>\n    \\<Longrightarrow> mem\\<^sub>2 x =\n                      (case ((\\<lambda>x. Some (mem\\<^sub>2 x)) |`\n                             differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                              mems k)\n                             x of\n                       None \\<Rightarrow> snd (mems ! k) x\n                       | Some v \\<Rightarrow> v)\n 2. \\<lbrakk>dom ((\\<lambda>x. Some (mem\\<^sub>2 x)) |`\n                  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) =\n             differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n     x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\\<rbrakk>\n    \\<Longrightarrow> mem\\<^sub>2 x =\n                      (case ((\\<lambda>x. Some (mem\\<^sub>2 x)) |`\n                             differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                              mems k)\n                             x of\n                       None \\<Rightarrow> snd (mems ! k) x\n                       | Some v \\<Rightarrow> v)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n    mem\\<^sub>2 x = snd (mems ! k) x", "by (metis differing_vars_neg)"], ["proof (state)\nthis:\n  mem\\<^sub>2 x =\n  subst\n   (to_partial mem\\<^sub>2 |`\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n   (snd (mems ! k)) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mem\\<^sub>2 =\n  subst\n   (to_partial mem\\<^sub>2 |`\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n   (snd (mems ! k))\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2,\n         mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "with f dom\\<sigma>_mem\\<^sub>2"], ["proof (chain)\npicking this:\n  \\<forall>\\<sigma>.\n     dom \\<sigma> =\n     differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<longrightarrow>\n     (cms\\<^sub>2 ! k, subst \\<sigma> (snd (mems ! k))) \\<leadsto>\n     \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                              k), subst \\<sigma> mem\\<^sub>h\\<rangle>\n  dom (to_partial mem\\<^sub>2 |`\n       differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n  mem\\<^sub>2 =\n  subst\n   (to_partial mem\\<^sub>2 |`\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n   (snd (mems ! k))", "have i: \"(cms\\<^sub>2 ! k, mem\\<^sub>2) \\<leadsto> \\<langle> c\\<^sub>2', ?mds\\<^sub>k', mem\\<^sub>2' \\<rangle>\""], ["proof (prove)\nusing this:\n  \\<forall>\\<sigma>.\n     dom \\<sigma> =\n     differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<longrightarrow>\n     (cms\\<^sub>2 ! k, subst \\<sigma> (snd (mems ! k))) \\<leadsto>\n     \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                              k), subst \\<sigma> mem\\<^sub>h\\<rangle>\n  dom (to_partial mem\\<^sub>2 |`\n       differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n  mem\\<^sub>2 =\n  subst\n   (to_partial mem\\<^sub>2 |`\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n   (snd (mems ! k))\n\ngoal (1 subgoal):\n 1. (cms\\<^sub>2 ! k, mem\\<^sub>2) \\<leadsto>\n    \\<langle>c\\<^sub>2', snd (cms\\<^sub>1' ! k), mem\\<^sub>2'\\<rangle>", "unfolding mem\\<^sub>2'_def c\\<^sub>2'_def"], ["proof (prove)\nusing this:\n  \\<forall>\\<sigma>.\n     dom \\<sigma> =\n     differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<longrightarrow>\n     (cms\\<^sub>2 ! k, subst \\<sigma> (snd (mems ! k))) \\<leadsto>\n     \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                              k), subst \\<sigma> mem\\<^sub>h\\<rangle>\n  dom (to_partial mem\\<^sub>2 |`\n       differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n  mem\\<^sub>2 =\n  subst\n   (to_partial mem\\<^sub>2 |`\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n   (snd (mems ! k))\n\ngoal (1 subgoal):\n 1. (cms\\<^sub>2 ! k, mem\\<^sub>2) \\<leadsto>\n    \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                             k), subst\n                                  (to_partial mem\\<^sub>2 |`\n                                   differing_vars_lists mem\\<^sub>1\n                                    mem\\<^sub>2 mems k)\n                                  mem\\<^sub>h\\<rangle>", "by metis"], ["proof (state)\nthis:\n  (cms\\<^sub>2 ! k, mem\\<^sub>2) \\<leadsto>\n  \\<langle>c\\<^sub>2', snd (cms\\<^sub>1' ! k), mem\\<^sub>2'\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2,\n         mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "define cms\\<^sub>2' where \"cms\\<^sub>2' = cms\\<^sub>2 [k := (c\\<^sub>2', ?mds\\<^sub>k')]\""], ["proof (state)\nthis:\n  cms\\<^sub>2' = cms\\<^sub>2[k := (c\\<^sub>2', snd (cms\\<^sub>1' ! k))]\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2,\n         mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "with i b equal_size"], ["proof (chain)\npicking this:\n  (cms\\<^sub>2 ! k, mem\\<^sub>2) \\<leadsto>\n  \\<langle>c\\<^sub>2', snd (cms\\<^sub>1' ! k), mem\\<^sub>2'\\<rangle>\n  k < length cms\\<^sub>1 \\<and>\n  (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto>\n  (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n  cms\\<^sub>1' = cms\\<^sub>1[k := cms\\<^sub>1' ! k]\n  length cms\\<^sub>1 = length cms\\<^sub>2\n  cms\\<^sub>2' = cms\\<^sub>2[k := (c\\<^sub>2', snd (cms\\<^sub>1' ! k))]", "have \"(cms\\<^sub>2, mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2', mem\\<^sub>2')\""], ["proof (prove)\nusing this:\n  (cms\\<^sub>2 ! k, mem\\<^sub>2) \\<leadsto>\n  \\<langle>c\\<^sub>2', snd (cms\\<^sub>1' ! k), mem\\<^sub>2'\\<rangle>\n  k < length cms\\<^sub>1 \\<and>\n  (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto>\n  (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n  cms\\<^sub>1' = cms\\<^sub>1[k := cms\\<^sub>1' ! k]\n  length cms\\<^sub>1 = length cms\\<^sub>2\n  cms\\<^sub>2' = cms\\<^sub>2[k := (c\\<^sub>2', snd (cms\\<^sub>1' ! k))]\n\ngoal (1 subgoal):\n 1. (cms\\<^sub>2,\n     mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2', mem\\<^sub>2')", "by (metis meval_intro)"], ["proof (state)\nthis:\n  (cms\\<^sub>2,\n   mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2', mem\\<^sub>2')\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2,\n         mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "moreover"], ["proof (state)\nthis:\n  (cms\\<^sub>2,\n   mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2', mem\\<^sub>2')\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2,\n         mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "from equal_size"], ["proof (chain)\npicking this:\n  length cms\\<^sub>1 = length cms\\<^sub>2", "have new_length: \"length cms\\<^sub>1' = length cms\\<^sub>2'\""], ["proof (prove)\nusing this:\n  length cms\\<^sub>1 = length cms\\<^sub>2\n\ngoal (1 subgoal):\n 1. length cms\\<^sub>1' = length cms\\<^sub>2'", "unfolding cms\\<^sub>2'_def"], ["proof (prove)\nusing this:\n  length cms\\<^sub>1 = length cms\\<^sub>2\n\ngoal (1 subgoal):\n 1. length cms\\<^sub>1' =\n    length (cms\\<^sub>2[k := (c\\<^sub>2', snd (cms\\<^sub>1' ! k))])", "by (metis eval length_list_update meval_elim)"], ["proof (state)\nthis:\n  length cms\\<^sub>1' = length cms\\<^sub>2'\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2,\n         mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "with modes_eq"], ["proof (chain)\npicking this:\n  map snd cms\\<^sub>1 = map snd cms\\<^sub>2\n  length cms\\<^sub>1' = length cms\\<^sub>2'", "have \"map snd cms\\<^sub>1' = map snd cms\\<^sub>2'\""], ["proof (prove)\nusing this:\n  map snd cms\\<^sub>1 = map snd cms\\<^sub>2\n  length cms\\<^sub>1' = length cms\\<^sub>2'\n\ngoal (1 subgoal):\n 1. map snd cms\\<^sub>1' = map snd cms\\<^sub>2'", "unfolding cms\\<^sub>2'_def"], ["proof (prove)\nusing this:\n  map snd cms\\<^sub>1 = map snd cms\\<^sub>2\n  length cms\\<^sub>1' =\n  length (cms\\<^sub>2[k := (c\\<^sub>2', snd (cms\\<^sub>1' ! k))])\n\ngoal (1 subgoal):\n 1. map snd cms\\<^sub>1' =\n    map snd (cms\\<^sub>2[k := (c\\<^sub>2', snd (cms\\<^sub>1' ! k))])", "by (metis b map_update snd_conv)"], ["proof (state)\nthis:\n  map snd cms\\<^sub>1' = map snd cms\\<^sub>2'\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2,\n         mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "moreover\n\n  \\<comment> \\<open>This is the complicated part of the proof.\\<close>"], ["proof (state)\nthis:\n  map snd cms\\<^sub>1' = map snd cms\\<^sub>2'\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2,\n         mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "obtain mems' where \"makes_compatible (cms\\<^sub>1', mem\\<^sub>1') (cms\\<^sub>2', mem\\<^sub>2') mems'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "proof\n    \\<comment> \\<open>This is used in two of the following cases, so we prove it beforehand:\\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "have x_unchanged: \"\\<And> x. \\<lbrakk> x \\<in> ?X k \\<rbrakk> \\<Longrightarrow>\n      mem\\<^sub>1 x = mem\\<^sub>1' x \\<and> mem\\<^sub>2 x = mem\\<^sub>2' x \\<and> dma mem\\<^sub>1 x = dma mem\\<^sub>1' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n       mem\\<^sub>1 x = mem\\<^sub>1' x \\<and>\n       mem\\<^sub>2 x = mem\\<^sub>2' x \\<and>\n       dma mem\\<^sub>1 x = dma mem\\<^sub>1' x", "proof(intro conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n       mem\\<^sub>1 x = mem\\<^sub>1' x\n 2. \\<And>x.\n       x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n       mem\\<^sub>2 x = mem\\<^sub>2' x\n 3. \\<And>x.\n       x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n       dma mem\\<^sub>1 x = dma mem\\<^sub>1' x", "fix x"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n       mem\\<^sub>1 x = mem\\<^sub>1' x\n 2. \\<And>x.\n       x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n       mem\\<^sub>2 x = mem\\<^sub>2' x\n 3. \\<And>x.\n       x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n       dma mem\\<^sub>1 x = dma mem\\<^sub>1' x", "assume \"x \\<in> ?X k\""], ["proof (state)\nthis:\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (3 subgoals):\n 1. \\<And>x.\n       x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n       mem\\<^sub>1 x = mem\\<^sub>1' x\n 2. \\<And>x.\n       x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n       mem\\<^sub>2 x = mem\\<^sub>2' x\n 3. \\<And>x.\n       x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n       dma mem\\<^sub>1 x = dma mem\\<^sub>1' x", "thus \"mem\\<^sub>1 x = mem\\<^sub>1' x\""], ["proof (prove)\nusing this:\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. mem\\<^sub>1 x = mem\\<^sub>1' x", "using a b c change_respecting_doesnt_modify domh"], ["proof (prove)\nusing this:\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n  \\<forall>i<length cms\\<^sub>1.\n     \\<forall>x\\<in>differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i.\n        doesnt_read_or_modify (fst (cms\\<^sub>1 ! i)) x \\<and>\n        doesnt_read_or_modify (fst (cms\\<^sub>2 ! i)) x\n  k < length cms\\<^sub>1 \\<and>\n  (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto>\n  (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n  cms\\<^sub>1' = cms\\<^sub>1[k := cms\\<^sub>1' ! k]\n  change_respecting (cms\\<^sub>1 ! k, mem\\<^sub>1)\n   (cms\\<^sub>1' ! k, mem\\<^sub>1')\n   (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n  \\<lbrakk>change_respecting (?cms, ?mem) (?cms', ?mem') ?X;\n   (?cms, ?mem) \\<leadsto> (?cms', ?mem');\n   ?x \\<in> ?X \\<union> vars_\\<C> ?X\\<rbrakk>\n  \\<Longrightarrow> ?mem ?x = ?mem' ?x\n  dom h = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. mem\\<^sub>1 x = mem\\<^sub>1' x", "by (metis (erased, hide_lams) Un_upper1 contra_subsetD)"], ["proof (state)\nthis:\n  mem\\<^sub>1 x = mem\\<^sub>1' x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n       mem\\<^sub>2 x = mem\\<^sub>2' x\n 2. \\<And>x.\n       x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n       dma mem\\<^sub>1 x = dma mem\\<^sub>1' x", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n       mem\\<^sub>2 x = mem\\<^sub>2' x\n 2. \\<And>x.\n       x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n       dma mem\\<^sub>1 x = dma mem\\<^sub>1' x", "fix x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n       mem\\<^sub>2 x = mem\\<^sub>2' x\n 2. \\<And>x.\n       x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n       dma mem\\<^sub>1 x = dma mem\\<^sub>1' x", "assume \"x \\<in> ?X k\""], ["proof (state)\nthis:\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n       mem\\<^sub>2 x = mem\\<^sub>2' x\n 2. \\<And>x.\n       x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n       dma mem\\<^sub>1 x = dma mem\\<^sub>1' x", "hence eq_mem\\<^sub>2: \"?\\<sigma>_mem\\<^sub>2 x = Some (mem\\<^sub>2 x)\""], ["proof (prove)\nusing this:\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. (to_partial mem\\<^sub>2 |`\n     differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n     x =\n    Some (mem\\<^sub>2 x)", "by (metis restrict_in to_partial_def)"], ["proof (state)\nthis:\n  (to_partial mem\\<^sub>2 |`\n   differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n   x =\n  Some (mem\\<^sub>2 x)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n       mem\\<^sub>2 x = mem\\<^sub>2' x\n 2. \\<And>x.\n       x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n       dma mem\\<^sub>1 x = dma mem\\<^sub>1' x", "hence \"?mems\\<^sub>2k [\\<mapsto> h] [\\<mapsto> ?\\<sigma>_mem\\<^sub>2] x = mem\\<^sub>2 x\""], ["proof (prove)\nusing this:\n  (to_partial mem\\<^sub>2 |`\n   differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n   x =\n  Some (mem\\<^sub>2 x)\n\ngoal (1 subgoal):\n 1. subst\n     (to_partial mem\\<^sub>2 |`\n      differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n     (subst h (snd (mems ! k))) x =\n    mem\\<^sub>2 x", "by (auto simp: subst_def)"], ["proof (state)\nthis:\n  subst\n   (to_partial mem\\<^sub>2 |`\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n   (subst h (snd (mems ! k))) x =\n  mem\\<^sub>2 x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n       mem\\<^sub>2 x = mem\\<^sub>2' x\n 2. \\<And>x.\n       x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n       dma mem\\<^sub>1 x = dma mem\\<^sub>1' x", "moreover"], ["proof (state)\nthis:\n  subst\n   (to_partial mem\\<^sub>2 |`\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n   (subst h (snd (mems ! k))) x =\n  mem\\<^sub>2 x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n       mem\\<^sub>2 x = mem\\<^sub>2' x\n 2. \\<And>x.\n       x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n       dma mem\\<^sub>1 x = dma mem\\<^sub>1' x", "have \"mem\\<^sub>h [\\<mapsto> ?\\<sigma>_mem\\<^sub>2] x = mem\\<^sub>2 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst\n     (to_partial mem\\<^sub>2 |`\n      differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n     mem\\<^sub>h x =\n    mem\\<^sub>2 x", "by (auto simp: subst_def \\<open>x \\<in> ?X k\\<close> eq_mem\\<^sub>2)"], ["proof (state)\nthis:\n  subst\n   (to_partial mem\\<^sub>2 |`\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n   mem\\<^sub>h x =\n  mem\\<^sub>2 x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n       mem\\<^sub>2 x = mem\\<^sub>2' x\n 2. \\<And>x.\n       x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n       dma mem\\<^sub>1 x = dma mem\\<^sub>1' x", "ultimately"], ["proof (chain)\npicking this:\n  subst\n   (to_partial mem\\<^sub>2 |`\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n   (subst h (snd (mems ! k))) x =\n  mem\\<^sub>2 x\n  subst\n   (to_partial mem\\<^sub>2 |`\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n   mem\\<^sub>h x =\n  mem\\<^sub>2 x", "have \"?mems\\<^sub>2k [\\<mapsto> h] [\\<mapsto> ?\\<sigma>_mem\\<^sub>2] x = mem\\<^sub>h [\\<mapsto> ?\\<sigma>_mem\\<^sub>2] x\""], ["proof (prove)\nusing this:\n  subst\n   (to_partial mem\\<^sub>2 |`\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n   (subst h (snd (mems ! k))) x =\n  mem\\<^sub>2 x\n  subst\n   (to_partial mem\\<^sub>2 |`\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n   mem\\<^sub>h x =\n  mem\\<^sub>2 x\n\ngoal (1 subgoal):\n 1. subst\n     (to_partial mem\\<^sub>2 |`\n      differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n     (subst h (snd (mems ! k))) x =\n    subst\n     (to_partial mem\\<^sub>2 |`\n      differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n     mem\\<^sub>h x", "by auto"], ["proof (state)\nthis:\n  subst\n   (to_partial mem\\<^sub>2 |`\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n   (subst h (snd (mems ! k))) x =\n  subst\n   (to_partial mem\\<^sub>2 |`\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n   mem\\<^sub>h x\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n       mem\\<^sub>2 x = mem\\<^sub>2' x\n 2. \\<And>x.\n       x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n       dma mem\\<^sub>1 x = dma mem\\<^sub>1' x", "thus \"mem\\<^sub>2 x = mem\\<^sub>2' x\""], ["proof (prove)\nusing this:\n  subst\n   (to_partial mem\\<^sub>2 |`\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n   (subst h (snd (mems ! k))) x =\n  subst\n   (to_partial mem\\<^sub>2 |`\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n   mem\\<^sub>h x\n\ngoal (1 subgoal):\n 1. mem\\<^sub>2 x = mem\\<^sub>2' x", "by (metis \\<open>mem\\<^sub>2 = ?mems\\<^sub>2k [\\<mapsto> ?\\<sigma>_mem\\<^sub>2]\\<close> dom\\<sigma>_mem\\<^sub>2 domh mem\\<^sub>2'_def subst_overrides)"], ["proof (state)\nthis:\n  mem\\<^sub>2 x = mem\\<^sub>2' x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n       dma mem\\<^sub>1 x = dma mem\\<^sub>1' x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n       dma mem\\<^sub>1 x = dma mem\\<^sub>1' x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n       dma mem\\<^sub>1 x = dma mem\\<^sub>1' x", "assume \"x \\<in> ?X k\""], ["proof (state)\nthis:\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n       dma mem\\<^sub>1 x = dma mem\\<^sub>1' x", "thus \"dma mem\\<^sub>1 x = dma mem\\<^sub>1' x\""], ["proof (prove)\nusing this:\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. dma mem\\<^sub>1 x = dma mem\\<^sub>1' x", "using a b c change_respecting_doesnt_modify_dma domh"], ["proof (prove)\nusing this:\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n  \\<forall>i<length cms\\<^sub>1.\n     \\<forall>x\\<in>differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i.\n        doesnt_read_or_modify (fst (cms\\<^sub>1 ! i)) x \\<and>\n        doesnt_read_or_modify (fst (cms\\<^sub>2 ! i)) x\n  k < length cms\\<^sub>1 \\<and>\n  (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto>\n  (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n  cms\\<^sub>1' = cms\\<^sub>1[k := cms\\<^sub>1' ! k]\n  change_respecting (cms\\<^sub>1 ! k, mem\\<^sub>1)\n   (cms\\<^sub>1' ! k, mem\\<^sub>1')\n   (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n  \\<lbrakk>change_respecting (?cms, ?mem) (?cms', ?mem') ?X;\n   (?cms, ?mem) \\<leadsto> (?cms', ?mem'); ?x \\<in> ?X\\<rbrakk>\n  \\<Longrightarrow> dma ?mem ?x = dma ?mem' ?x\n  dom h = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. dma mem\\<^sub>1 x = dma mem\\<^sub>1' x", "by (metis (erased, hide_lams))"], ["proof (state)\nthis:\n  dma mem\\<^sub>1 x = dma mem\\<^sub>1' x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x5\n  \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n         k \\<Longrightarrow>\n  mem\\<^sub>1 ?x5 = mem\\<^sub>1' ?x5 \\<and>\n  mem\\<^sub>2 ?x5 = mem\\<^sub>2' ?x5 \\<and>\n  dma mem\\<^sub>1 ?x5 = dma mem\\<^sub>1' ?x5\n\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "define mems'_k where \"mems'_k x =\n      (if x \\<notin> ?X k\n       then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n       else (?mems\\<^sub>1k x, ?mems\\<^sub>2k x))\" for x"], ["proof (state)\nthis:\n  mems'_k ?x =\n  (if ?x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n   then (mem\\<^sub>1' ?x, mem\\<^sub>2' ?x)\n   else (fst (mems ! k) ?x, snd (mems ! k) ?x))\n\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "(* FIXME: see if we can reduce the number of cases *)"], ["proof (state)\nthis:\n  mems'_k ?x =\n  (if ?x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n   then (mem\\<^sub>1' ?x, mem\\<^sub>2' ?x)\n   else (fst (mems ! k) ?x, snd (mems ! k) ?x))\n\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "define mems'_i where \"mems'_i i x =\n      (if ((mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or> mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n          (mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma mem\\<^sub>1' x = High))\n         then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n         else if ((mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or> mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n                  (mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma mem\\<^sub>1' x = Low))\n              then (some_val, some_val)\n              else if dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low then (mem\\<^sub>1 x, mem\\<^sub>1 x)\n              else if dma mem\\<^sub>1' x = dma mem\\<^sub>1 x then (fst (mems ! i) x, snd (mems ! i) x)\n              else (mem\\<^sub>1' x, mem\\<^sub>2' x))\" for i x"], ["proof (state)\nthis:\n  mems'_i ?i ?x =\n  (if (mem\\<^sub>1 ?x \\<noteq> mem\\<^sub>1' ?x \\<or>\n       mem\\<^sub>2 ?x \\<noteq> mem\\<^sub>2' ?x) \\<and>\n      (mem\\<^sub>1' ?x = mem\\<^sub>2' ?x \\<or> dma mem\\<^sub>1' ?x = High)\n   then (mem\\<^sub>1' ?x, mem\\<^sub>2' ?x)\n   else if (mem\\<^sub>1 ?x \\<noteq> mem\\<^sub>1' ?x \\<or>\n            mem\\<^sub>2 ?x \\<noteq> mem\\<^sub>2' ?x) \\<and>\n           mem\\<^sub>1' ?x \\<noteq> mem\\<^sub>2' ?x \\<and>\n           dma mem\\<^sub>1' ?x = Low\n        then (some_val, some_val)\n        else if dma mem\\<^sub>1 ?x = High \\<and> dma mem\\<^sub>1' ?x = Low\n             then (mem\\<^sub>1 ?x, mem\\<^sub>1 ?x)\n             else if dma mem\\<^sub>1' ?x = dma mem\\<^sub>1 ?x\n                  then (fst (mems ! ?i) ?x, snd (mems ! ?i) ?x)\n                  else (mem\\<^sub>1' ?x, mem\\<^sub>2' ?x))\n\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "define mems'\n      where \"mems' =\n        map (\\<lambda> i.\n            if i = k\n            then (fst \\<circ> mems'_k, snd \\<circ> mems'_k)\n            else (fst \\<circ> mems'_i i, snd \\<circ> mems'_i i))\n      [0..< length cms\\<^sub>1]\""], ["proof (state)\nthis:\n  mems' =\n  map (\\<lambda>i.\n          if i = k then (fst \\<circ> mems'_k, snd \\<circ> mems'_k)\n          else (fst \\<circ> mems'_i i, snd \\<circ> mems'_i i))\n   [0..<length cms\\<^sub>1]\n\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "from b"], ["proof (chain)\npicking this:\n  k < length cms\\<^sub>1 \\<and>\n  (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto>\n  (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n  cms\\<^sub>1' = cms\\<^sub>1[k := cms\\<^sub>1' ! k]", "have mems'_k_simp: \"mems' ! k = (fst \\<circ> mems'_k, snd \\<circ> mems'_k)\""], ["proof (prove)\nusing this:\n  k < length cms\\<^sub>1 \\<and>\n  (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto>\n  (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n  cms\\<^sub>1' = cms\\<^sub>1[k := cms\\<^sub>1' ! k]\n\ngoal (1 subgoal):\n 1. mems' ! k = (fst \\<circ> mems'_k, snd \\<circ> mems'_k)", "unfolding mems'_def"], ["proof (prove)\nusing this:\n  k < length cms\\<^sub>1 \\<and>\n  (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto>\n  (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n  cms\\<^sub>1' = cms\\<^sub>1[k := cms\\<^sub>1' ! k]\n\ngoal (1 subgoal):\n 1. map (\\<lambda>i.\n            if i = k then (fst \\<circ> mems'_k, snd \\<circ> mems'_k)\n            else (fst \\<circ> mems'_i i, snd \\<circ> mems'_i i))\n     [0..<length cms\\<^sub>1] !\n    k =\n    (fst \\<circ> mems'_k, snd \\<circ> mems'_k)", "by auto"], ["proof (state)\nthis:\n  mems' ! k = (fst \\<circ> mems'_k, snd \\<circ> mems'_k)\n\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "have mems'_simp2: \"\\<And>i. \\<lbrakk> i \\<noteq> k; i < length cms\\<^sub>1 \\<rbrakk> \\<Longrightarrow>\n      mems' ! i = (fst \\<circ> mems'_i i, snd \\<circ> mems'_i i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<noteq> k; i < length cms\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> mems' ! i =\n                         (fst \\<circ> mems'_i i, snd \\<circ> mems'_i i)", "unfolding mems'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i \\<noteq> k; i < length cms\\<^sub>1\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>i.\n                                 if i = k\n                                 then (fst \\<circ> mems'_k,\n snd \\<circ> mems'_k)\n                                 else (fst \\<circ> mems'_i i,\n snd \\<circ> mems'_i i))\n                          [0..<length cms\\<^sub>1] !\n                         i =\n                         (fst \\<circ> mems'_i i, snd \\<circ> mems'_i i)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?i5 \\<noteq> k; ?i5 < length cms\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> mems' ! ?i5 =\n                    (fst \\<circ> mems'_i ?i5, snd \\<circ> mems'_i ?i5)\n\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "(* Some auxiliary statements to allow reasoning about these definitions as if they were given\n       by cases instead of nested if clauses. *)"], ["proof (state)\nthis:\n  \\<lbrakk>?i5 \\<noteq> k; ?i5 < length cms\\<^sub>1\\<rbrakk>\n  \\<Longrightarrow> mems' ! ?i5 =\n                    (fst \\<circ> mems'_i ?i5, snd \\<circ> mems'_i ?i5)\n\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "have mems'_k_1 [simp]: \"\\<And> x. \\<lbrakk> x \\<notin> ?X k \\<rbrakk> \\<Longrightarrow>\n      fst (mems' ! k) x = mem\\<^sub>1' x \\<and> snd (mems' ! k) x = mem\\<^sub>2' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                   k \\<Longrightarrow>\n       fst (mems' ! k) x = mem\\<^sub>1' x \\<and>\n       snd (mems' ! k) x = mem\\<^sub>2' x", "unfolding mems'_k_simp mems'_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                   k \\<Longrightarrow>\n       fst (fst \\<circ>\n            (\\<lambda>x.\n                if x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                               mems k\n                then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                else (fst (mems ! k) x, snd (mems ! k) x)),\n            snd \\<circ>\n            (\\<lambda>x.\n                if x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                               mems k\n                then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                else (fst (mems ! k) x, snd (mems ! k) x)))\n        x =\n       mem\\<^sub>1' x \\<and>\n       snd (fst \\<circ>\n            (\\<lambda>x.\n                if x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                               mems k\n                then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                else (fst (mems ! k) x, snd (mems ! k) x)),\n            snd \\<circ>\n            (\\<lambda>x.\n                if x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                               mems k\n                then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                else (fst (mems ! k) x, snd (mems ! k) x)))\n        x =\n       mem\\<^sub>2' x", "by auto"], ["proof (state)\nthis:\n  ?x5\n  \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n            k \\<Longrightarrow>\n  fst (mems' ! k) ?x5 = mem\\<^sub>1' ?x5 \\<and>\n  snd (mems' ! k) ?x5 = mem\\<^sub>2' ?x5\n\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "have mems'_k_2 [simp]: \"\\<And> x. \\<lbrakk> x \\<in> ?X k \\<rbrakk> \\<Longrightarrow>\n      fst (mems' ! k) x = fst (mems ! k) x \\<and> snd (mems' ! k) x = snd (mems ! k) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n       fst (mems' ! k) x = fst (mems ! k) x \\<and>\n       snd (mems' ! k) x = snd (mems ! k) x", "unfolding mems'_k_simp mems'_k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n       fst (fst \\<circ>\n            (\\<lambda>x.\n                if x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                               mems k\n                then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                else (fst (mems ! k) x, snd (mems ! k) x)),\n            snd \\<circ>\n            (\\<lambda>x.\n                if x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                               mems k\n                then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                else (fst (mems ! k) x, snd (mems ! k) x)))\n        x =\n       fst (mems ! k) x \\<and>\n       snd (fst \\<circ>\n            (\\<lambda>x.\n                if x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                               mems k\n                then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                else (fst (mems ! k) x, snd (mems ! k) x)),\n            snd \\<circ>\n            (\\<lambda>x.\n                if x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                               mems k\n                then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                else (fst (mems ! k) x, snd (mems ! k) x)))\n        x =\n       snd (mems ! k) x", "by auto"], ["proof (state)\nthis:\n  ?x5\n  \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n         k \\<Longrightarrow>\n  fst (mems' ! k) ?x5 = fst (mems ! k) ?x5 \\<and>\n  snd (mems' ! k) ?x5 = snd (mems ! k) ?x5\n\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "have mems'_k_cases:\n      \"\\<And> P x.\n        \\<lbrakk>\n         \\<lbrakk> x \\<notin> ?X k;\n           fst (mems' ! k) x = mem\\<^sub>1' x;\n           snd (mems' ! k) x = mem\\<^sub>2' x \\<rbrakk> \\<Longrightarrow> P x;\n         \\<lbrakk> x \\<in> ?X k; \n           fst (mems' ! k) x = fst (mems ! k) x;\n           snd (mems' ! k) x = snd (mems ! k) x \\<rbrakk> \\<Longrightarrow> P x \\<rbrakk> \\<Longrightarrow> P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P x.\n       \\<lbrakk>\\<lbrakk>x \\<notin> differing_vars_lists mem\\<^sub>1\n                                     mem\\<^sub>2 mems k;\n                 fst (mems' ! k) x = mem\\<^sub>1' x;\n                 snd (mems' ! k) x = mem\\<^sub>2' x\\<rbrakk>\n                \\<Longrightarrow> P x;\n        \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                          k;\n         fst (mems' ! k) x = fst (mems ! k) x;\n         snd (mems' ! k) x = snd (mems ! k) x\\<rbrakk>\n        \\<Longrightarrow> P x\\<rbrakk>\n       \\<Longrightarrow> P x", "apply(case_tac \"x \\<notin> ?X k\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>\\<lbrakk>x \\<notin> differing_vars_lists mem\\<^sub>1\n                                     mem\\<^sub>2 mems k;\n                 fst (mems' ! k) x = mem\\<^sub>1' x;\n                 snd (mems' ! k) x = mem\\<^sub>2' x\\<rbrakk>\n                \\<Longrightarrow> P x;\n        \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                          k;\n         fst (mems' ! k) x = fst (mems ! k) x;\n         snd (mems' ! k) x = snd (mems ! k) x\\<rbrakk>\n        \\<Longrightarrow> P x;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                    k\\<rbrakk>\n       \\<Longrightarrow> P x\n 2. \\<And>P x.\n       \\<lbrakk>\\<lbrakk>x \\<notin> differing_vars_lists mem\\<^sub>1\n                                     mem\\<^sub>2 mems k;\n                 fst (mems' ! k) x = mem\\<^sub>1' x;\n                 snd (mems' ! k) x = mem\\<^sub>2' x\\<rbrakk>\n                \\<Longrightarrow> P x;\n        \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                          k;\n         fst (mems' ! k) x = fst (mems ! k) x;\n         snd (mems' ! k) x = snd (mems ! k) x\\<rbrakk>\n        \\<Longrightarrow> P x;\n        \\<not> x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                           k\\<rbrakk>\n       \\<Longrightarrow> P x", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P x.\n       \\<lbrakk>\\<lbrakk>x \\<notin> differing_vars_lists mem\\<^sub>1\n                                     mem\\<^sub>2 mems k;\n                 fst (mems' ! k) x = mem\\<^sub>1' x;\n                 snd (mems' ! k) x = mem\\<^sub>2' x\\<rbrakk>\n                \\<Longrightarrow> P x;\n        \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                          k;\n         fst (mems' ! k) x = fst (mems ! k) x;\n         snd (mems' ! k) x = snd (mems ! k) x\\<rbrakk>\n        \\<Longrightarrow> P x;\n        \\<not> x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                           k\\<rbrakk>\n       \\<Longrightarrow> P x", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<lbrakk>\\<lbrakk>?x5\n                    \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                              mems k;\n            fst (mems' ! k) ?x5 = mem\\<^sub>1' ?x5;\n            snd (mems' ! k) ?x5 = mem\\<^sub>2' ?x5\\<rbrakk>\n           \\<Longrightarrow> ?P5 ?x5;\n   \\<lbrakk>?x5 \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n    fst (mems' ! k) ?x5 = fst (mems ! k) ?x5;\n    snd (mems' ! k) ?x5 = snd (mems ! k) ?x5\\<rbrakk>\n   \\<Longrightarrow> ?P5 ?x5\\<rbrakk>\n  \\<Longrightarrow> ?P5 ?x5\n\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "have mems'_i_simp:\n      \"\\<And> i. \\<lbrakk> i < length cms\\<^sub>1; i \\<noteq> k \\<rbrakk> \\<Longrightarrow> mems' ! i = (fst \\<circ> mems'_i i, snd \\<circ> mems'_i i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length cms\\<^sub>1; i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> mems' ! i =\n                         (fst \\<circ> mems'_i i, snd \\<circ> mems'_i i)", "unfolding mems'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       \\<lbrakk>i < length cms\\<^sub>1; i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> map (\\<lambda>i.\n                                 if i = k\n                                 then (fst \\<circ> mems'_k,\n snd \\<circ> mems'_k)\n                                 else (fst \\<circ> mems'_i i,\n snd \\<circ> mems'_i i))\n                          [0..<length cms\\<^sub>1] !\n                         i =\n                         (fst \\<circ> mems'_i i, snd \\<circ> mems'_i i)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?i5 < length cms\\<^sub>1; ?i5 \\<noteq> k\\<rbrakk>\n  \\<Longrightarrow> mems' ! ?i5 =\n                    (fst \\<circ> mems'_i ?i5, snd \\<circ> mems'_i ?i5)\n\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "have mems'_i_1 [simp]:\n      \"\\<And> i x. \\<lbrakk> i \\<noteq> k; i < length cms\\<^sub>1;\n                 mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or> mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n                 mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma mem\\<^sub>1' x = High \\<rbrakk> \\<Longrightarrow>\n               fst (mems' ! i) x = mem\\<^sub>1' x \\<and> snd (mems' ! i) x = mem\\<^sub>2' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i \\<noteq> k; i < length cms\\<^sub>1;\n        mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n        mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n        mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\n        dma mem\\<^sub>1' x = High\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n                         snd (mems' ! i) x = mem\\<^sub>2' x", "unfolding mems'_i_def mems'_i_simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i \\<noteq> k; i < length cms\\<^sub>1;\n        mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n        mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n        mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\n        dma mem\\<^sub>1' x = High\\<rbrakk>\n       \\<Longrightarrow> fst (fst \\<circ>\n                              (\\<lambda>x.\n                                  if (mem\\<^sub>1 x \\<noteq>\nmem\\<^sub>1' x \\<or>\nmem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n                                     (mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\ndma mem\\<^sub>1' x = High)\n                                  then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                                  else if (mem\\<^sub>1 x \\<noteq>\n     mem\\<^sub>1' x \\<or>\n     mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma mem\\<^sub>1' x = Low\n then (some_val, some_val)\n else if dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low\n      then (mem\\<^sub>1 x, mem\\<^sub>1 x)\n      else if dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\n           then (fst (mems ! i) x, snd (mems ! i) x)\n           else (mem\\<^sub>1' x, mem\\<^sub>2' x)),\n                              snd \\<circ>\n                              (\\<lambda>x.\n                                  if (mem\\<^sub>1 x \\<noteq>\nmem\\<^sub>1' x \\<or>\nmem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n                                     (mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\ndma mem\\<^sub>1' x = High)\n                                  then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                                  else if (mem\\<^sub>1 x \\<noteq>\n     mem\\<^sub>1' x \\<or>\n     mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma mem\\<^sub>1' x = Low\n then (some_val, some_val)\n else if dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low\n      then (mem\\<^sub>1 x, mem\\<^sub>1 x)\n      else if dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\n           then (fst (mems ! i) x, snd (mems ! i) x)\n           else (mem\\<^sub>1' x, mem\\<^sub>2' x)))\n                          x =\n                         mem\\<^sub>1' x \\<and>\n                         snd (fst \\<circ>\n                              (\\<lambda>x.\n                                  if (mem\\<^sub>1 x \\<noteq>\nmem\\<^sub>1' x \\<or>\nmem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n                                     (mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\ndma mem\\<^sub>1' x = High)\n                                  then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                                  else if (mem\\<^sub>1 x \\<noteq>\n     mem\\<^sub>1' x \\<or>\n     mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma mem\\<^sub>1' x = Low\n then (some_val, some_val)\n else if dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low\n      then (mem\\<^sub>1 x, mem\\<^sub>1 x)\n      else if dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\n           then (fst (mems ! i) x, snd (mems ! i) x)\n           else (mem\\<^sub>1' x, mem\\<^sub>2' x)),\n                              snd \\<circ>\n                              (\\<lambda>x.\n                                  if (mem\\<^sub>1 x \\<noteq>\nmem\\<^sub>1' x \\<or>\nmem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n                                     (mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\ndma mem\\<^sub>1' x = High)\n                                  then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                                  else if (mem\\<^sub>1 x \\<noteq>\n     mem\\<^sub>1' x \\<or>\n     mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma mem\\<^sub>1' x = Low\n then (some_val, some_val)\n else if dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low\n      then (mem\\<^sub>1 x, mem\\<^sub>1 x)\n      else if dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\n           then (fst (mems ! i) x, snd (mems ! i) x)\n           else (mem\\<^sub>1' x, mem\\<^sub>2' x)))\n                          x =\n                         mem\\<^sub>2' x", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?i5 \\<noteq> k; ?i5 < length cms\\<^sub>1;\n   mem\\<^sub>1 ?x5 \\<noteq> mem\\<^sub>1' ?x5 \\<or>\n   mem\\<^sub>2 ?x5 \\<noteq> mem\\<^sub>2' ?x5;\n   mem\\<^sub>1' ?x5 = mem\\<^sub>2' ?x5 \\<or>\n   dma mem\\<^sub>1' ?x5 = High\\<rbrakk>\n  \\<Longrightarrow> fst (mems' ! ?i5) ?x5 = mem\\<^sub>1' ?x5 \\<and>\n                    snd (mems' ! ?i5) ?x5 = mem\\<^sub>2' ?x5\n\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "have mems'_i_2 [simp]:\n      \"\\<And> i x. \\<lbrakk> i \\<noteq> k; i < length cms\\<^sub>1;\n                 mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or> mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n                 mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x; dma mem\\<^sub>1' x = Low \\<rbrakk> \\<Longrightarrow>\n              fst (mems' ! i) x = some_val \\<and> snd (mems' ! i) x = some_val\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i \\<noteq> k; i < length cms\\<^sub>1;\n        mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n        mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n        mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x;\n        dma mem\\<^sub>1' x = Low\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = some_val \\<and>\n                         snd (mems' ! i) x = some_val", "unfolding mems'_i_def mems'_i_simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i \\<noteq> k; i < length cms\\<^sub>1;\n        mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n        mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n        mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x;\n        dma mem\\<^sub>1' x = Low\\<rbrakk>\n       \\<Longrightarrow> fst (fst \\<circ>\n                              (\\<lambda>x.\n                                  if (mem\\<^sub>1 x \\<noteq>\nmem\\<^sub>1' x \\<or>\nmem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n                                     (mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\ndma mem\\<^sub>1' x = High)\n                                  then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                                  else if (mem\\<^sub>1 x \\<noteq>\n     mem\\<^sub>1' x \\<or>\n     mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma mem\\<^sub>1' x = Low\n then (some_val, some_val)\n else if dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low\n      then (mem\\<^sub>1 x, mem\\<^sub>1 x)\n      else if dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\n           then (fst (mems ! i) x, snd (mems ! i) x)\n           else (mem\\<^sub>1' x, mem\\<^sub>2' x)),\n                              snd \\<circ>\n                              (\\<lambda>x.\n                                  if (mem\\<^sub>1 x \\<noteq>\nmem\\<^sub>1' x \\<or>\nmem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n                                     (mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\ndma mem\\<^sub>1' x = High)\n                                  then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                                  else if (mem\\<^sub>1 x \\<noteq>\n     mem\\<^sub>1' x \\<or>\n     mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma mem\\<^sub>1' x = Low\n then (some_val, some_val)\n else if dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low\n      then (mem\\<^sub>1 x, mem\\<^sub>1 x)\n      else if dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\n           then (fst (mems ! i) x, snd (mems ! i) x)\n           else (mem\\<^sub>1' x, mem\\<^sub>2' x)))\n                          x =\n                         some_val \\<and>\n                         snd (fst \\<circ>\n                              (\\<lambda>x.\n                                  if (mem\\<^sub>1 x \\<noteq>\nmem\\<^sub>1' x \\<or>\nmem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n                                     (mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\ndma mem\\<^sub>1' x = High)\n                                  then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                                  else if (mem\\<^sub>1 x \\<noteq>\n     mem\\<^sub>1' x \\<or>\n     mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma mem\\<^sub>1' x = Low\n then (some_val, some_val)\n else if dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low\n      then (mem\\<^sub>1 x, mem\\<^sub>1 x)\n      else if dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\n           then (fst (mems ! i) x, snd (mems ! i) x)\n           else (mem\\<^sub>1' x, mem\\<^sub>2' x)),\n                              snd \\<circ>\n                              (\\<lambda>x.\n                                  if (mem\\<^sub>1 x \\<noteq>\nmem\\<^sub>1' x \\<or>\nmem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n                                     (mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\ndma mem\\<^sub>1' x = High)\n                                  then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                                  else if (mem\\<^sub>1 x \\<noteq>\n     mem\\<^sub>1' x \\<or>\n     mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma mem\\<^sub>1' x = Low\n then (some_val, some_val)\n else if dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low\n      then (mem\\<^sub>1 x, mem\\<^sub>1 x)\n      else if dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\n           then (fst (mems ! i) x, snd (mems ! i) x)\n           else (mem\\<^sub>1' x, mem\\<^sub>2' x)))\n                          x =\n                         some_val", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?i5 \\<noteq> k; ?i5 < length cms\\<^sub>1;\n   mem\\<^sub>1 ?x5 \\<noteq> mem\\<^sub>1' ?x5 \\<or>\n   mem\\<^sub>2 ?x5 \\<noteq> mem\\<^sub>2' ?x5;\n   mem\\<^sub>1' ?x5 \\<noteq> mem\\<^sub>2' ?x5;\n   dma mem\\<^sub>1' ?x5 = Low\\<rbrakk>\n  \\<Longrightarrow> fst (mems' ! ?i5) ?x5 = some_val \\<and>\n                    snd (mems' ! ?i5) ?x5 = some_val\n\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "have mems'_i_3 [simp]:\n      \"\\<And> i x. \\<lbrakk> i \\<noteq> k; i < length cms\\<^sub>1;\n                 mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n                 dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low \\<rbrakk> \\<Longrightarrow>\n              fst (mems' ! i) x = mem\\<^sub>1 x \\<and> snd (mems' ! i) x = mem\\<^sub>1 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i \\<noteq> k; i < length cms\\<^sub>1;\n        mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n        dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = mem\\<^sub>1 x \\<and>\n                         snd (mems' ! i) x = mem\\<^sub>1 x", "unfolding mems'_i_def mems'_i_simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i \\<noteq> k; i < length cms\\<^sub>1;\n        mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n        dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low\\<rbrakk>\n       \\<Longrightarrow> fst (fst \\<circ>\n                              (\\<lambda>x.\n                                  if (mem\\<^sub>1 x \\<noteq>\nmem\\<^sub>1' x \\<or>\nmem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n                                     (mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\ndma mem\\<^sub>1' x = High)\n                                  then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                                  else if (mem\\<^sub>1 x \\<noteq>\n     mem\\<^sub>1' x \\<or>\n     mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma mem\\<^sub>1' x = Low\n then (some_val, some_val)\n else if dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low\n      then (mem\\<^sub>1 x, mem\\<^sub>1 x)\n      else if dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\n           then (fst (mems ! i) x, snd (mems ! i) x)\n           else (mem\\<^sub>1' x, mem\\<^sub>2' x)),\n                              snd \\<circ>\n                              (\\<lambda>x.\n                                  if (mem\\<^sub>1 x \\<noteq>\nmem\\<^sub>1' x \\<or>\nmem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n                                     (mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\ndma mem\\<^sub>1' x = High)\n                                  then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                                  else if (mem\\<^sub>1 x \\<noteq>\n     mem\\<^sub>1' x \\<or>\n     mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma mem\\<^sub>1' x = Low\n then (some_val, some_val)\n else if dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low\n      then (mem\\<^sub>1 x, mem\\<^sub>1 x)\n      else if dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\n           then (fst (mems ! i) x, snd (mems ! i) x)\n           else (mem\\<^sub>1' x, mem\\<^sub>2' x)))\n                          x =\n                         mem\\<^sub>1 x \\<and>\n                         snd (fst \\<circ>\n                              (\\<lambda>x.\n                                  if (mem\\<^sub>1 x \\<noteq>\nmem\\<^sub>1' x \\<or>\nmem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n                                     (mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\ndma mem\\<^sub>1' x = High)\n                                  then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                                  else if (mem\\<^sub>1 x \\<noteq>\n     mem\\<^sub>1' x \\<or>\n     mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma mem\\<^sub>1' x = Low\n then (some_val, some_val)\n else if dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low\n      then (mem\\<^sub>1 x, mem\\<^sub>1 x)\n      else if dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\n           then (fst (mems ! i) x, snd (mems ! i) x)\n           else (mem\\<^sub>1' x, mem\\<^sub>2' x)),\n                              snd \\<circ>\n                              (\\<lambda>x.\n                                  if (mem\\<^sub>1 x \\<noteq>\nmem\\<^sub>1' x \\<or>\nmem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n                                     (mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\ndma mem\\<^sub>1' x = High)\n                                  then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                                  else if (mem\\<^sub>1 x \\<noteq>\n     mem\\<^sub>1' x \\<or>\n     mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma mem\\<^sub>1' x = Low\n then (some_val, some_val)\n else if dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low\n      then (mem\\<^sub>1 x, mem\\<^sub>1 x)\n      else if dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\n           then (fst (mems ! i) x, snd (mems ! i) x)\n           else (mem\\<^sub>1' x, mem\\<^sub>2' x)))\n                          x =\n                         mem\\<^sub>1 x", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?i5 \\<noteq> k; ?i5 < length cms\\<^sub>1;\n   mem\\<^sub>1 ?x5 = mem\\<^sub>1' ?x5; mem\\<^sub>2 ?x5 = mem\\<^sub>2' ?x5;\n   dma mem\\<^sub>1 ?x5 = High \\<and> dma mem\\<^sub>1' ?x5 = Low\\<rbrakk>\n  \\<Longrightarrow> fst (mems' ! ?i5) ?x5 = mem\\<^sub>1 ?x5 \\<and>\n                    snd (mems' ! ?i5) ?x5 = mem\\<^sub>1 ?x5\n\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "have mems'_i_4 [simp]:\n      \"\\<And> i x. \\<lbrakk> i \\<noteq> k; i < length cms\\<^sub>1;\n                 mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n                 dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High;\n                 dma mem\\<^sub>1' x = dma mem\\<^sub>1 x \\<rbrakk> \\<Longrightarrow>\n              fst (mems' ! i) x = fst (mems ! i) x \\<and> snd (mems' ! i) x = snd (mems ! i) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i \\<noteq> k; i < length cms\\<^sub>1;\n        mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n        dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High;\n        dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = fst (mems ! i) x \\<and>\n                         snd (mems' ! i) x = snd (mems ! i) x", "unfolding mems'_i_def mems'_i_simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i \\<noteq> k; i < length cms\\<^sub>1;\n        mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n        dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High;\n        dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\\<rbrakk>\n       \\<Longrightarrow> fst (fst \\<circ>\n                              (\\<lambda>x.\n                                  if (mem\\<^sub>1 x \\<noteq>\nmem\\<^sub>1' x \\<or>\nmem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n                                     (mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\ndma mem\\<^sub>1' x = High)\n                                  then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                                  else if (mem\\<^sub>1 x \\<noteq>\n     mem\\<^sub>1' x \\<or>\n     mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma mem\\<^sub>1' x = Low\n then (some_val, some_val)\n else if dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low\n      then (mem\\<^sub>1 x, mem\\<^sub>1 x)\n      else if dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\n           then (fst (mems ! i) x, snd (mems ! i) x)\n           else (mem\\<^sub>1' x, mem\\<^sub>2' x)),\n                              snd \\<circ>\n                              (\\<lambda>x.\n                                  if (mem\\<^sub>1 x \\<noteq>\nmem\\<^sub>1' x \\<or>\nmem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n                                     (mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\ndma mem\\<^sub>1' x = High)\n                                  then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                                  else if (mem\\<^sub>1 x \\<noteq>\n     mem\\<^sub>1' x \\<or>\n     mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma mem\\<^sub>1' x = Low\n then (some_val, some_val)\n else if dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low\n      then (mem\\<^sub>1 x, mem\\<^sub>1 x)\n      else if dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\n           then (fst (mems ! i) x, snd (mems ! i) x)\n           else (mem\\<^sub>1' x, mem\\<^sub>2' x)))\n                          x =\n                         fst (mems ! i) x \\<and>\n                         snd (fst \\<circ>\n                              (\\<lambda>x.\n                                  if (mem\\<^sub>1 x \\<noteq>\nmem\\<^sub>1' x \\<or>\nmem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n                                     (mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\ndma mem\\<^sub>1' x = High)\n                                  then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                                  else if (mem\\<^sub>1 x \\<noteq>\n     mem\\<^sub>1' x \\<or>\n     mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma mem\\<^sub>1' x = Low\n then (some_val, some_val)\n else if dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low\n      then (mem\\<^sub>1 x, mem\\<^sub>1 x)\n      else if dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\n           then (fst (mems ! i) x, snd (mems ! i) x)\n           else (mem\\<^sub>1' x, mem\\<^sub>2' x)),\n                              snd \\<circ>\n                              (\\<lambda>x.\n                                  if (mem\\<^sub>1 x \\<noteq>\nmem\\<^sub>1' x \\<or>\nmem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n                                     (mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\ndma mem\\<^sub>1' x = High)\n                                  then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                                  else if (mem\\<^sub>1 x \\<noteq>\n     mem\\<^sub>1' x \\<or>\n     mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma mem\\<^sub>1' x = Low\n then (some_val, some_val)\n else if dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low\n      then (mem\\<^sub>1 x, mem\\<^sub>1 x)\n      else if dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\n           then (fst (mems ! i) x, snd (mems ! i) x)\n           else (mem\\<^sub>1' x, mem\\<^sub>2' x)))\n                          x =\n                         snd (mems ! i) x", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?i5 \\<noteq> k; ?i5 < length cms\\<^sub>1;\n   mem\\<^sub>1 ?x5 = mem\\<^sub>1' ?x5; mem\\<^sub>2 ?x5 = mem\\<^sub>2' ?x5;\n   dma mem\\<^sub>1 ?x5 = Low \\<or> dma mem\\<^sub>1' ?x5 = High;\n   dma mem\\<^sub>1' ?x5 = dma mem\\<^sub>1 ?x5\\<rbrakk>\n  \\<Longrightarrow> fst (mems' ! ?i5) ?x5 = fst (mems ! ?i5) ?x5 \\<and>\n                    snd (mems' ! ?i5) ?x5 = snd (mems ! ?i5) ?x5\n\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "have mems'_i_5 [simp]:\n      \"\\<And> i x. \\<lbrakk> i \\<noteq> k; i < length cms\\<^sub>1;\n                 mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n                 dma mem\\<^sub>1 x = Low \\<and> dma mem\\<^sub>1' x = High;\n                 dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x \\<rbrakk> \\<Longrightarrow>\n              fst (mems' ! i) x = mem\\<^sub>1' x \\<and> snd (mems' ! i) x = mem\\<^sub>2' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i \\<noteq> k; i < length cms\\<^sub>1;\n        mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n        dma mem\\<^sub>1 x = Low \\<and> dma mem\\<^sub>1' x = High;\n        dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n                         snd (mems' ! i) x = mem\\<^sub>2' x", "unfolding mems'_i_def mems'_i_simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i x.\n       \\<lbrakk>i \\<noteq> k; i < length cms\\<^sub>1;\n        mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n        dma mem\\<^sub>1 x = Low \\<and> dma mem\\<^sub>1' x = High;\n        dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x\\<rbrakk>\n       \\<Longrightarrow> fst (fst \\<circ>\n                              (\\<lambda>x.\n                                  if (mem\\<^sub>1 x \\<noteq>\nmem\\<^sub>1' x \\<or>\nmem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n                                     (mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\ndma mem\\<^sub>1' x = High)\n                                  then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                                  else if (mem\\<^sub>1 x \\<noteq>\n     mem\\<^sub>1' x \\<or>\n     mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma mem\\<^sub>1' x = Low\n then (some_val, some_val)\n else if dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low\n      then (mem\\<^sub>1 x, mem\\<^sub>1 x)\n      else if dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\n           then (fst (mems ! i) x, snd (mems ! i) x)\n           else (mem\\<^sub>1' x, mem\\<^sub>2' x)),\n                              snd \\<circ>\n                              (\\<lambda>x.\n                                  if (mem\\<^sub>1 x \\<noteq>\nmem\\<^sub>1' x \\<or>\nmem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n                                     (mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\ndma mem\\<^sub>1' x = High)\n                                  then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                                  else if (mem\\<^sub>1 x \\<noteq>\n     mem\\<^sub>1' x \\<or>\n     mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma mem\\<^sub>1' x = Low\n then (some_val, some_val)\n else if dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low\n      then (mem\\<^sub>1 x, mem\\<^sub>1 x)\n      else if dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\n           then (fst (mems ! i) x, snd (mems ! i) x)\n           else (mem\\<^sub>1' x, mem\\<^sub>2' x)))\n                          x =\n                         mem\\<^sub>1' x \\<and>\n                         snd (fst \\<circ>\n                              (\\<lambda>x.\n                                  if (mem\\<^sub>1 x \\<noteq>\nmem\\<^sub>1' x \\<or>\nmem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n                                     (mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\ndma mem\\<^sub>1' x = High)\n                                  then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                                  else if (mem\\<^sub>1 x \\<noteq>\n     mem\\<^sub>1' x \\<or>\n     mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma mem\\<^sub>1' x = Low\n then (some_val, some_val)\n else if dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low\n      then (mem\\<^sub>1 x, mem\\<^sub>1 x)\n      else if dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\n           then (fst (mems ! i) x, snd (mems ! i) x)\n           else (mem\\<^sub>1' x, mem\\<^sub>2' x)),\n                              snd \\<circ>\n                              (\\<lambda>x.\n                                  if (mem\\<^sub>1 x \\<noteq>\nmem\\<^sub>1' x \\<or>\nmem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n                                     (mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\ndma mem\\<^sub>1' x = High)\n                                  then (mem\\<^sub>1' x, mem\\<^sub>2' x)\n                                  else if (mem\\<^sub>1 x \\<noteq>\n     mem\\<^sub>1' x \\<or>\n     mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x) \\<and>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma mem\\<^sub>1' x = Low\n then (some_val, some_val)\n else if dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low\n      then (mem\\<^sub>1 x, mem\\<^sub>1 x)\n      else if dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\n           then (fst (mems ! i) x, snd (mems ! i) x)\n           else (mem\\<^sub>1' x, mem\\<^sub>2' x)))\n                          x =\n                         mem\\<^sub>2' x", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>?i5 \\<noteq> k; ?i5 < length cms\\<^sub>1;\n   mem\\<^sub>1 ?x5 = mem\\<^sub>1' ?x5; mem\\<^sub>2 ?x5 = mem\\<^sub>2' ?x5;\n   dma mem\\<^sub>1 ?x5 = Low \\<and> dma mem\\<^sub>1' ?x5 = High;\n   dma mem\\<^sub>1' ?x5 \\<noteq> dma mem\\<^sub>1 ?x5\\<rbrakk>\n  \\<Longrightarrow> fst (mems' ! ?i5) ?x5 = mem\\<^sub>1' ?x5 \\<and>\n                    snd (mems' ! ?i5) ?x5 = mem\\<^sub>2' ?x5\n\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "(* This may look complicated, but is actually a rather\n       mechanical definition, as it merely spells out the cases\n       of the definition: *)"], ["proof (state)\nthis:\n  \\<lbrakk>?i5 \\<noteq> k; ?i5 < length cms\\<^sub>1;\n   mem\\<^sub>1 ?x5 = mem\\<^sub>1' ?x5; mem\\<^sub>2 ?x5 = mem\\<^sub>2' ?x5;\n   dma mem\\<^sub>1 ?x5 = Low \\<and> dma mem\\<^sub>1' ?x5 = High;\n   dma mem\\<^sub>1' ?x5 \\<noteq> dma mem\\<^sub>1 ?x5\\<rbrakk>\n  \\<Longrightarrow> fst (mems' ! ?i5) ?x5 = mem\\<^sub>1' ?x5 \\<and>\n                    snd (mems' ! ?i5) ?x5 = mem\\<^sub>2' ?x5\n\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "have mems'_i_cases:\n      \"\\<And> P i x.\n         \\<lbrakk> i \\<noteq> k; i < length cms\\<^sub>1;\n           \\<lbrakk> mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or> mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n             mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma mem\\<^sub>1' x = High;\n             fst (mems' ! i) x = mem\\<^sub>1' x; snd (mems' ! i) x = mem\\<^sub>2' x \\<rbrakk> \\<Longrightarrow> P x;\n      \\<lbrakk> mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or> mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n        mem\\<^sub>1' x \\<noteq>  mem\\<^sub>2' x; dma mem\\<^sub>1' x = Low;\n        fst (mems' ! i) x = some_val; snd (mems' ! i) x = some_val \\<rbrakk> \\<Longrightarrow> P x;\n      \\<lbrakk> mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x; dma mem\\<^sub>1 x = High; \n        dma mem\\<^sub>1' x = Low;\n        fst (mems' ! i) x = mem\\<^sub>1 x; snd (mems' ! i) x = mem\\<^sub>1 x \\<rbrakk> \\<Longrightarrow> P x;\n      \\<lbrakk> mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x; dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High;\n        dma mem\\<^sub>1' x = dma mem\\<^sub>1 x;\n        fst (mems' ! i) x = fst (mems ! i) x; snd (mems' ! i) x = snd (mems ! i) x \\<rbrakk> \\<Longrightarrow> P x;\n      \\<lbrakk> mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x; dma mem\\<^sub>1 x = Low; dma mem\\<^sub>1' x = High;\n        fst (mems' ! i) x = mem\\<^sub>1' x; snd (mems' ! i) x = mem\\<^sub>2' x \\<rbrakk> \\<Longrightarrow> P x       \\<rbrakk>\n      \\<Longrightarrow> P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>P i x.\n       \\<lbrakk>i \\<noteq> k; i < length cms\\<^sub>1;\n        \\<lbrakk>mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n                 mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n         mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma mem\\<^sub>1' x = High;\n         fst (mems' ! i) x = mem\\<^sub>1' x;\n         snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n        \\<Longrightarrow> P x;\n        \\<lbrakk>mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n                 mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n         mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x; dma mem\\<^sub>1' x = Low;\n         fst (mems' ! i) x = some_val; snd (mems' ! i) x = some_val\\<rbrakk>\n        \\<Longrightarrow> P x;\n        \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x;\n         mem\\<^sub>2 x = mem\\<^sub>2' x; dma mem\\<^sub>1 x = High;\n         dma mem\\<^sub>1' x = Low; fst (mems' ! i) x = mem\\<^sub>1 x;\n         snd (mems' ! i) x = mem\\<^sub>1 x\\<rbrakk>\n        \\<Longrightarrow> P x;\n        \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x;\n         mem\\<^sub>2 x = mem\\<^sub>2' x;\n         dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High;\n         dma mem\\<^sub>1' x = dma mem\\<^sub>1 x;\n         fst (mems' ! i) x = fst (mems ! i) x;\n         snd (mems' ! i) x = snd (mems ! i) x\\<rbrakk>\n        \\<Longrightarrow> P x;\n        \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x;\n         mem\\<^sub>2 x = mem\\<^sub>2' x; dma mem\\<^sub>1 x = Low;\n         dma mem\\<^sub>1' x = High; fst (mems' ! i) x = mem\\<^sub>1' x;\n         snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n        \\<Longrightarrow> P x\\<rbrakk>\n       \\<Longrightarrow> P x", "using mems'_i_1 mems'_i_2 mems'_i_3 mems'_i_4 mems'_i_5"], ["proof (prove)\nusing this:\n  \\<lbrakk>?i5 \\<noteq> k; ?i5 < length cms\\<^sub>1;\n   mem\\<^sub>1 ?x5 \\<noteq> mem\\<^sub>1' ?x5 \\<or>\n   mem\\<^sub>2 ?x5 \\<noteq> mem\\<^sub>2' ?x5;\n   mem\\<^sub>1' ?x5 = mem\\<^sub>2' ?x5 \\<or>\n   dma mem\\<^sub>1' ?x5 = High\\<rbrakk>\n  \\<Longrightarrow> fst (mems' ! ?i5) ?x5 = mem\\<^sub>1' ?x5 \\<and>\n                    snd (mems' ! ?i5) ?x5 = mem\\<^sub>2' ?x5\n  \\<lbrakk>?i5 \\<noteq> k; ?i5 < length cms\\<^sub>1;\n   mem\\<^sub>1 ?x5 \\<noteq> mem\\<^sub>1' ?x5 \\<or>\n   mem\\<^sub>2 ?x5 \\<noteq> mem\\<^sub>2' ?x5;\n   mem\\<^sub>1' ?x5 \\<noteq> mem\\<^sub>2' ?x5;\n   dma mem\\<^sub>1' ?x5 = Low\\<rbrakk>\n  \\<Longrightarrow> fst (mems' ! ?i5) ?x5 = some_val \\<and>\n                    snd (mems' ! ?i5) ?x5 = some_val\n  \\<lbrakk>?i5 \\<noteq> k; ?i5 < length cms\\<^sub>1;\n   mem\\<^sub>1 ?x5 = mem\\<^sub>1' ?x5; mem\\<^sub>2 ?x5 = mem\\<^sub>2' ?x5;\n   dma mem\\<^sub>1 ?x5 = High \\<and> dma mem\\<^sub>1' ?x5 = Low\\<rbrakk>\n  \\<Longrightarrow> fst (mems' ! ?i5) ?x5 = mem\\<^sub>1 ?x5 \\<and>\n                    snd (mems' ! ?i5) ?x5 = mem\\<^sub>1 ?x5\n  \\<lbrakk>?i5 \\<noteq> k; ?i5 < length cms\\<^sub>1;\n   mem\\<^sub>1 ?x5 = mem\\<^sub>1' ?x5; mem\\<^sub>2 ?x5 = mem\\<^sub>2' ?x5;\n   dma mem\\<^sub>1 ?x5 = Low \\<or> dma mem\\<^sub>1' ?x5 = High;\n   dma mem\\<^sub>1' ?x5 = dma mem\\<^sub>1 ?x5\\<rbrakk>\n  \\<Longrightarrow> fst (mems' ! ?i5) ?x5 = fst (mems ! ?i5) ?x5 \\<and>\n                    snd (mems' ! ?i5) ?x5 = snd (mems ! ?i5) ?x5\n  \\<lbrakk>?i5 \\<noteq> k; ?i5 < length cms\\<^sub>1;\n   mem\\<^sub>1 ?x5 = mem\\<^sub>1' ?x5; mem\\<^sub>2 ?x5 = mem\\<^sub>2' ?x5;\n   dma mem\\<^sub>1 ?x5 = Low \\<and> dma mem\\<^sub>1' ?x5 = High;\n   dma mem\\<^sub>1' ?x5 \\<noteq> dma mem\\<^sub>1 ?x5\\<rbrakk>\n  \\<Longrightarrow> fst (mems' ! ?i5) ?x5 = mem\\<^sub>1' ?x5 \\<and>\n                    snd (mems' ! ?i5) ?x5 = mem\\<^sub>2' ?x5\n\ngoal (1 subgoal):\n 1. \\<And>P i x.\n       \\<lbrakk>i \\<noteq> k; i < length cms\\<^sub>1;\n        \\<lbrakk>mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n                 mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n         mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma mem\\<^sub>1' x = High;\n         fst (mems' ! i) x = mem\\<^sub>1' x;\n         snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n        \\<Longrightarrow> P x;\n        \\<lbrakk>mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n                 mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n         mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x; dma mem\\<^sub>1' x = Low;\n         fst (mems' ! i) x = some_val; snd (mems' ! i) x = some_val\\<rbrakk>\n        \\<Longrightarrow> P x;\n        \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x;\n         mem\\<^sub>2 x = mem\\<^sub>2' x; dma mem\\<^sub>1 x = High;\n         dma mem\\<^sub>1' x = Low; fst (mems' ! i) x = mem\\<^sub>1 x;\n         snd (mems' ! i) x = mem\\<^sub>1 x\\<rbrakk>\n        \\<Longrightarrow> P x;\n        \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x;\n         mem\\<^sub>2 x = mem\\<^sub>2' x;\n         dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High;\n         dma mem\\<^sub>1' x = dma mem\\<^sub>1 x;\n         fst (mems' ! i) x = fst (mems ! i) x;\n         snd (mems' ! i) x = snd (mems ! i) x\\<rbrakk>\n        \\<Longrightarrow> P x;\n        \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x;\n         mem\\<^sub>2 x = mem\\<^sub>2' x; dma mem\\<^sub>1 x = Low;\n         dma mem\\<^sub>1' x = High; fst (mems' ! i) x = mem\\<^sub>1' x;\n         snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n        \\<Longrightarrow> P x\\<rbrakk>\n       \\<Longrightarrow> P x", "by (metis (full_types) Sec.exhaust)"], ["proof (state)\nthis:\n  \\<lbrakk>?i5 \\<noteq> k; ?i5 < length cms\\<^sub>1;\n   \\<lbrakk>mem\\<^sub>1 ?x5 \\<noteq> mem\\<^sub>1' ?x5 \\<or>\n            mem\\<^sub>2 ?x5 \\<noteq> mem\\<^sub>2' ?x5;\n    mem\\<^sub>1' ?x5 = mem\\<^sub>2' ?x5 \\<or> dma mem\\<^sub>1' ?x5 = High;\n    fst (mems' ! ?i5) ?x5 = mem\\<^sub>1' ?x5;\n    snd (mems' ! ?i5) ?x5 = mem\\<^sub>2' ?x5\\<rbrakk>\n   \\<Longrightarrow> ?P5 ?x5;\n   \\<lbrakk>mem\\<^sub>1 ?x5 \\<noteq> mem\\<^sub>1' ?x5 \\<or>\n            mem\\<^sub>2 ?x5 \\<noteq> mem\\<^sub>2' ?x5;\n    mem\\<^sub>1' ?x5 \\<noteq> mem\\<^sub>2' ?x5; dma mem\\<^sub>1' ?x5 = Low;\n    fst (mems' ! ?i5) ?x5 = some_val;\n    snd (mems' ! ?i5) ?x5 = some_val\\<rbrakk>\n   \\<Longrightarrow> ?P5 ?x5;\n   \\<lbrakk>mem\\<^sub>1 ?x5 = mem\\<^sub>1' ?x5;\n    mem\\<^sub>2 ?x5 = mem\\<^sub>2' ?x5; dma mem\\<^sub>1 ?x5 = High;\n    dma mem\\<^sub>1' ?x5 = Low; fst (mems' ! ?i5) ?x5 = mem\\<^sub>1 ?x5;\n    snd (mems' ! ?i5) ?x5 = mem\\<^sub>1 ?x5\\<rbrakk>\n   \\<Longrightarrow> ?P5 ?x5;\n   \\<lbrakk>mem\\<^sub>1 ?x5 = mem\\<^sub>1' ?x5;\n    mem\\<^sub>2 ?x5 = mem\\<^sub>2' ?x5;\n    dma mem\\<^sub>1 ?x5 = Low \\<or> dma mem\\<^sub>1' ?x5 = High;\n    dma mem\\<^sub>1' ?x5 = dma mem\\<^sub>1 ?x5;\n    fst (mems' ! ?i5) ?x5 = fst (mems ! ?i5) ?x5;\n    snd (mems' ! ?i5) ?x5 = snd (mems ! ?i5) ?x5\\<rbrakk>\n   \\<Longrightarrow> ?P5 ?x5;\n   \\<lbrakk>mem\\<^sub>1 ?x5 = mem\\<^sub>1' ?x5;\n    mem\\<^sub>2 ?x5 = mem\\<^sub>2' ?x5; dma mem\\<^sub>1 ?x5 = Low;\n    dma mem\\<^sub>1' ?x5 = High; fst (mems' ! ?i5) ?x5 = mem\\<^sub>1' ?x5;\n    snd (mems' ! ?i5) ?x5 = mem\\<^sub>2' ?x5\\<rbrakk>\n   \\<Longrightarrow> ?P5 ?x5\\<rbrakk>\n  \\<Longrightarrow> ?P5 ?x5\n\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "let ?X' = \"\\<lambda> i. differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\""], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "have len_unchanged: \"length cms\\<^sub>1' = length cms\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length cms\\<^sub>1' = length cms\\<^sub>1", "by (metis cms\\<^sub>2'_def equal_size length_list_update new_length)"], ["proof (state)\nthis:\n  length cms\\<^sub>1' = length cms\\<^sub>1\n\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "have mm_equiv': \"(cms\\<^sub>1' ! k, subst (?\\<sigma>_mem\\<^sub>2) mem\\<^sub>1') \\<approx> \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>2'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cms\\<^sub>1' ! k,\n     subst\n      (to_partial mem\\<^sub>2 |`\n       differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n      mem\\<^sub>1') \\<approx>\n    \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>2'\\<rangle>", "apply(simp add: mem\\<^sub>2'_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (cms\\<^sub>1' ! k,\n     subst\n      (to_partial mem\\<^sub>2 |`\n       differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n      mem\\<^sub>1') \\<approx>\n    \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                             k), subst\n                                  (to_partial mem\\<^sub>2 |`\n                                   differing_vars_lists mem\\<^sub>1\n                                    mem\\<^sub>2 mems k)\n                                  mem\\<^sub>h\\<rangle>", "apply(rule g[THEN conjunct2])"], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (to_partial mem\\<^sub>2 |`\n         differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k) =\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k", "apply(rule dom_restrict_total)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  (cms\\<^sub>1' ! k,\n   subst\n    (to_partial mem\\<^sub>2 |`\n     differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n    mem\\<^sub>1') \\<approx>\n  \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>2'\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "hence \\<C>_subst_eq: \"\\<forall>x\\<in>\\<C>. (subst (?\\<sigma>_mem\\<^sub>2) mem\\<^sub>1') x = mem\\<^sub>2' x\""], ["proof (prove)\nusing this:\n  (cms\\<^sub>1' ! k,\n   subst\n    (to_partial mem\\<^sub>2 |`\n     differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n    mem\\<^sub>1') \\<approx>\n  \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' ! k), mem\\<^sub>2'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>\\<C>.\n       subst\n        (to_partial mem\\<^sub>2 |`\n         differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n        mem\\<^sub>1' x =\n       mem\\<^sub>2' x", "apply(rule mm_equiv_\\<C>_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (cms\\<^sub>1' ! k) = snd (c\\<^sub>h, snd (cms\\<^sub>1' ! k))", "by simp"], ["proof (state)\nthis:\n  \\<forall>x\\<in>\\<C>.\n     subst\n      (to_partial mem\\<^sub>2 |`\n       differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n      mem\\<^sub>1' x =\n     mem\\<^sub>2' x\n\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "have low_mds_eq': \"(subst (?\\<sigma>_mem\\<^sub>2) mem\\<^sub>1') =\\<^bsub>snd (cms\\<^sub>1' ! k)\\<^esub>\\<^sup>l mem\\<^sub>2'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst\n     (to_partial mem\\<^sub>2 |`\n      differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n     mem\\<^sub>1' =\\<^bsub>snd (cms\\<^sub>1' ! k)\\<^esub>\\<^sup>l mem\\<^sub>2'", "apply(rule mm_equiv_low_eq[where c\\<^sub>1=\"fst (cms\\<^sub>1' ! k)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>fst (cms\\<^sub>1' !\n                  k), snd (cms\\<^sub>1' !\n                           k), subst\n                                (to_partial mem\\<^sub>2 |`\n                                 differing_vars_lists mem\\<^sub>1\n                                  mem\\<^sub>2 mems k)\n                                mem\\<^sub>1'\\<rangle> \\<approx>\n    \\<langle>?c\\<^sub>2, snd (cms\\<^sub>1' ! k), mem\\<^sub>2'\\<rangle>", "apply(force intro: mm_equiv')"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  subst\n   (to_partial mem\\<^sub>2 |`\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n   mem\\<^sub>1' =\\<^bsub>snd (cms\\<^sub>1' ! k)\\<^esub>\\<^sup>l mem\\<^sub>2'\n\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "have \\<C>_subst_eq_idemp: \"\\<And>x. x \\<in> \\<C> \\<Longrightarrow> (subst (?\\<sigma>_mem\\<^sub>2) mem\\<^sub>1') x = mem\\<^sub>1' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<C> \\<Longrightarrow>\n       subst\n        (to_partial mem\\<^sub>2 |`\n         differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n        mem\\<^sub>1' x =\n       mem\\<^sub>1' x", "apply(rule subst_not_in_dom)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<C> \\<Longrightarrow>\n       x \\<notin> dom (to_partial mem\\<^sub>2 |`\n                       differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)", "apply(rule notI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> \\<C>;\n        x \\<in> dom (to_partial mem\\<^sub>2 |`\n                     differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                      k)\\<rbrakk>\n       \\<Longrightarrow> False", "apply(simp add: dom_restrict_total)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> \\<C>;\n        x \\<in> dom (to_partial mem\\<^sub>2) \\<and>\n        x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\\<rbrakk>\n       \\<Longrightarrow> False", "using compat b"], ["proof (prove)\nusing this:\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  k < length cms\\<^sub>1 \\<and>\n  (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto>\n  (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n  cms\\<^sub>1' = cms\\<^sub>1[k := cms\\<^sub>1' ! k]\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> \\<C>;\n        x \\<in> dom (to_partial mem\\<^sub>2) \\<and>\n        x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\\<rbrakk>\n       \\<Longrightarrow> False", "by force"], ["proof (state)\nthis:\n  ?x5 \\<in> \\<C> \\<Longrightarrow>\n  subst\n   (to_partial mem\\<^sub>2 |`\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n   mem\\<^sub>1' ?x5 =\n  mem\\<^sub>1' ?x5\n\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "from \\<C>_subst_eq \\<C>_subst_eq_idemp"], ["proof (chain)\npicking this:\n  \\<forall>x\\<in>\\<C>.\n     subst\n      (to_partial mem\\<^sub>2 |`\n       differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n      mem\\<^sub>1' x =\n     mem\\<^sub>2' x\n  ?x5 \\<in> \\<C> \\<Longrightarrow>\n  subst\n   (to_partial mem\\<^sub>2 |`\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n   mem\\<^sub>1' ?x5 =\n  mem\\<^sub>1' ?x5", "have \\<C>_eq: \"\\<And>x. x \\<in> \\<C> \\<Longrightarrow> mem\\<^sub>1' x = mem\\<^sub>2' x\""], ["proof (prove)\nusing this:\n  \\<forall>x\\<in>\\<C>.\n     subst\n      (to_partial mem\\<^sub>2 |`\n       differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n      mem\\<^sub>1' x =\n     mem\\<^sub>2' x\n  ?x5 \\<in> \\<C> \\<Longrightarrow>\n  subst\n   (to_partial mem\\<^sub>2 |`\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n   mem\\<^sub>1' ?x5 =\n  mem\\<^sub>1' ?x5\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> \\<C> \\<Longrightarrow> mem\\<^sub>1' x = mem\\<^sub>2' x", "by simp"], ["proof (state)\nthis:\n  ?x5 \\<in> \\<C> \\<Longrightarrow> mem\\<^sub>1' ?x5 = mem\\<^sub>2' ?x5\n\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "have not_control: \"\\<And>x i. i < length cms\\<^sub>1' \\<Longrightarrow> x \\<in> ?X' i \\<Longrightarrow> x \\<notin> \\<C>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>i < length cms\\<^sub>1';\n        x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                 i\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> \\<C>", "proof(rule ccontr, clarsimp)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>i < length cms\\<^sub>1';\n        x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i;\n        x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> False", "fix x i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>i < length cms\\<^sub>1';\n        x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i;\n        x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> False", "let ?mems\\<^sub>1i = \"fst (mems ! i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>i < length cms\\<^sub>1';\n        x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i;\n        x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> False", "let ?mems\\<^sub>2i = \"snd (mems ! i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>i < length cms\\<^sub>1';\n        x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i;\n        x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> False", "let ?mems\\<^sub>1'i = \"fst (mems' ! i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>i < length cms\\<^sub>1';\n        x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i;\n        x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> False", "let ?mems\\<^sub>2'i = \"snd (mems' ! i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>i < length cms\\<^sub>1';\n        x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i;\n        x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"i < length cms\\<^sub>1'\""], ["proof (state)\nthis:\n  i < length cms\\<^sub>1'\n\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>i < length cms\\<^sub>1';\n        x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i;\n        x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> False", "have \"i < length cms\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length cms\\<^sub>1", "by (metis len_unchanged \\<open>i < length cms\\<^sub>1'\\<close>)"], ["proof (state)\nthis:\n  i < length cms\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>i < length cms\\<^sub>1';\n        x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i;\n        x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"x \\<in> ?X' i\""], ["proof (state)\nthis:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>i < length cms\\<^sub>1';\n        x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i;\n        x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"x \\<in> \\<C>\""], ["proof (state)\nthis:\n  x \\<in> \\<C>\n\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>i < length cms\\<^sub>1';\n        x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i;\n        x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> False", "have \"x \\<notin> ?X i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i", "using compat \\<open>i < length cms\\<^sub>1'\\<close> len_unchanged new_length"], ["proof (prove)\nusing this:\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  i < length cms\\<^sub>1'\n  length cms\\<^sub>1' = length cms\\<^sub>1\n  length cms\\<^sub>1' = length cms\\<^sub>2'\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i", "by (metis \\<open>x \\<in> \\<C>\\<close> compat_different)"], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>i < length cms\\<^sub>1';\n        x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i;\n        x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> False", "from \\<open>x \\<in> \\<C>\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> \\<C>", "have  \"mem\\<^sub>1' x = mem\\<^sub>2' x\""], ["proof (prove)\nusing this:\n  x \\<in> \\<C>\n\ngoal (1 subgoal):\n 1. mem\\<^sub>1' x = mem\\<^sub>2' x", "by(rule \\<C>_eq)"], ["proof (state)\nthis:\n  mem\\<^sub>1' x = mem\\<^sub>2' x\n\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>i < length cms\\<^sub>1';\n        x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i;\n        x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> False", "from \\<open>x \\<in> \\<C>\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> \\<C>", "have \"dma mem\\<^sub>1' x = Low\""], ["proof (prove)\nusing this:\n  x \\<in> \\<C>\n\ngoal (1 subgoal):\n 1. dma mem\\<^sub>1' x = Low", "by(simp add: \\<C>_Low)"], ["proof (state)\nthis:\n  dma mem\\<^sub>1' x = Low\n\ngoal (1 subgoal):\n 1. \\<And>x i.\n       \\<lbrakk>i < length cms\\<^sub>1';\n        x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i;\n        x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> False", "show \"False\""], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "proof(cases \"i = k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow> False\n 2. i \\<noteq> k \\<Longrightarrow> False", "assume eq[simp]: \"i = k\""], ["proof (state)\nthis:\n  i = k\n\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow> False\n 2. i \\<noteq> k \\<Longrightarrow> False", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. False", "using \\<open>x \\<notin> ?X i\\<close> \\<open>x \\<in> ?X' i\\<close>"], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. False", "by(force simp: differing_vars_lists_def differing_vars_def)"], ["proof (state)\nthis:\n  False\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow> False", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow> False", "assume neq: \"i \\<noteq> k\""], ["proof (state)\nthis:\n  i \\<noteq> k\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow> False", "thus ?thesis"], ["proof (prove)\nusing this:\n  i \\<noteq> k\n\ngoal (1 subgoal):\n 1. False", "using \\<open>x \\<in> ?X' i\\<close> \\<open>x \\<notin> ?X i\\<close> \\<open>x \\<in> \\<C>\\<close> \\<C>_Low \\<open>mem\\<^sub>1' x = mem\\<^sub>2' x\\<close>"], ["proof (prove)\nusing this:\n  i \\<noteq> k\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n  x \\<in> \\<C>\n  \\<forall>x\\<in>\\<C>. dma ?mem x = Low\n  mem\\<^sub>1' x = mem\\<^sub>2' x\n\ngoal (1 subgoal):\n 1. False", "by(force elim: mems'_i_cases[of \"i\" \"x\" \"\\<lambda>x. False\", OF _ \\<open>i < length cms\\<^sub>1\\<close>]\n                 simp: differing_vars_lists_def differing_vars_def)"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?i5 < length cms\\<^sub>1';\n   ?x5\n   \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' ?i5\\<rbrakk>\n  \\<Longrightarrow> ?x5 \\<notin> \\<C>\n\ngoal (1 subgoal):\n 1. (\\<And>mems'.\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') ?mems'12", "show \"makes_compatible (cms\\<^sub>1', mem\\<^sub>1') (cms\\<^sub>2', mem\\<^sub>2') mems'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n     (cms\\<^sub>2', mem\\<^sub>2') mems'", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. length cms\\<^sub>1' = length cms\\<^sub>2' \\<and>\n    length cms\\<^sub>1' = length mems'\n 2. \\<And>i \\<sigma>.\n       \\<lbrakk>i < length cms\\<^sub>1';\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\\<rbrakk>\n       \\<Longrightarrow> (cms\\<^sub>1' ! i,\n                          subst \\<sigma> (fst (mems' ! i))) \\<approx>\n                         (cms\\<^sub>2' ! i,\n                          subst \\<sigma> (snd (mems' ! i)))\n 3. \\<And>i x.\n       \\<lbrakk>i < length cms\\<^sub>1';\n        mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\n        dma mem\\<^sub>1' x = High \\<or> x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                     mem\\<^sub>2' mems' i\n 4. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "have \"length cms\\<^sub>1' = length cms\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length cms\\<^sub>1' = length cms\\<^sub>1", "by (metis cms\\<^sub>2'_def equal_size length_list_update new_length)"], ["proof (state)\nthis:\n  length cms\\<^sub>1' = length cms\\<^sub>1\n\ngoal (4 subgoals):\n 1. length cms\\<^sub>1' = length cms\\<^sub>2' \\<and>\n    length cms\\<^sub>1' = length mems'\n 2. \\<And>i \\<sigma>.\n       \\<lbrakk>i < length cms\\<^sub>1';\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\\<rbrakk>\n       \\<Longrightarrow> (cms\\<^sub>1' ! i,\n                          subst \\<sigma> (fst (mems' ! i))) \\<approx>\n                         (cms\\<^sub>2' ! i,\n                          subst \\<sigma> (snd (mems' ! i)))\n 3. \\<And>i x.\n       \\<lbrakk>i < length cms\\<^sub>1';\n        mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\n        dma mem\\<^sub>1' x = High \\<or> x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                     mem\\<^sub>2' mems' i\n 4. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "then"], ["proof (chain)\npicking this:\n  length cms\\<^sub>1' = length cms\\<^sub>1", "show \"length cms\\<^sub>1' = length cms\\<^sub>2' \\<and> length cms\\<^sub>1' = length mems'\""], ["proof (prove)\nusing this:\n  length cms\\<^sub>1' = length cms\\<^sub>1\n\ngoal (1 subgoal):\n 1. length cms\\<^sub>1' = length cms\\<^sub>2' \\<and>\n    length cms\\<^sub>1' = length mems'", "using compat new_length"], ["proof (prove)\nusing this:\n  length cms\\<^sub>1' = length cms\\<^sub>1\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  length cms\\<^sub>1' = length cms\\<^sub>2'\n\ngoal (1 subgoal):\n 1. length cms\\<^sub>1' = length cms\\<^sub>2' \\<and>\n    length cms\\<^sub>1' = length mems'", "unfolding mems'_def"], ["proof (prove)\nusing this:\n  length cms\\<^sub>1' = length cms\\<^sub>1\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  length cms\\<^sub>1' = length cms\\<^sub>2'\n\ngoal (1 subgoal):\n 1. length cms\\<^sub>1' = length cms\\<^sub>2' \\<and>\n    length cms\\<^sub>1' =\n    length\n     (map (\\<lambda>i.\n              if i = k then (fst \\<circ> mems'_k, snd \\<circ> mems'_k)\n              else (fst \\<circ> mems'_i i, snd \\<circ> mems'_i i))\n       [0..<length cms\\<^sub>1])", "by auto"], ["proof (state)\nthis:\n  length cms\\<^sub>1' = length cms\\<^sub>2' \\<and>\n  length cms\\<^sub>1' = length mems'\n\ngoal (3 subgoals):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>i < length cms\\<^sub>1';\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\\<rbrakk>\n       \\<Longrightarrow> (cms\\<^sub>1' ! i,\n                          subst \\<sigma> (fst (mems' ! i))) \\<approx>\n                         (cms\\<^sub>2' ! i,\n                          subst \\<sigma> (snd (mems' ! i)))\n 2. \\<And>i x.\n       \\<lbrakk>i < length cms\\<^sub>1';\n        mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\n        dma mem\\<^sub>1' x = High \\<or> x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                     mem\\<^sub>2' mems' i\n 3. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>i < length cms\\<^sub>1';\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\\<rbrakk>\n       \\<Longrightarrow> (cms\\<^sub>1' ! i,\n                          subst \\<sigma> (fst (mems' ! i))) \\<approx>\n                         (cms\\<^sub>2' ! i,\n                          subst \\<sigma> (snd (mems' ! i)))\n 2. \\<And>i x.\n       \\<lbrakk>i < length cms\\<^sub>1';\n        mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\n        dma mem\\<^sub>1' x = High \\<or> x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                     mem\\<^sub>2' mems' i\n 3. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "fix i"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>i < length cms\\<^sub>1';\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\\<rbrakk>\n       \\<Longrightarrow> (cms\\<^sub>1' ! i,\n                          subst \\<sigma> (fst (mems' ! i))) \\<approx>\n                         (cms\\<^sub>2' ! i,\n                          subst \\<sigma> (snd (mems' ! i)))\n 2. \\<And>i x.\n       \\<lbrakk>i < length cms\\<^sub>1';\n        mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\n        dma mem\\<^sub>1' x = High \\<or> x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                     mem\\<^sub>2' mems' i\n 3. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "fix \\<sigma> :: \"'Var \\<rightharpoonup> 'Val\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>i < length cms\\<^sub>1';\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\\<rbrakk>\n       \\<Longrightarrow> (cms\\<^sub>1' ! i,\n                          subst \\<sigma> (fst (mems' ! i))) \\<approx>\n                         (cms\\<^sub>2' ! i,\n                          subst \\<sigma> (snd (mems' ! i)))\n 2. \\<And>i x.\n       \\<lbrakk>i < length cms\\<^sub>1';\n        mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\n        dma mem\\<^sub>1' x = High \\<or> x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                     mem\\<^sub>2' mems' i\n 3. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "let ?mems\\<^sub>1'i = \"fst (mems' ! i)\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>i < length cms\\<^sub>1';\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\\<rbrakk>\n       \\<Longrightarrow> (cms\\<^sub>1' ! i,\n                          subst \\<sigma> (fst (mems' ! i))) \\<approx>\n                         (cms\\<^sub>2' ! i,\n                          subst \\<sigma> (snd (mems' ! i)))\n 2. \\<And>i x.\n       \\<lbrakk>i < length cms\\<^sub>1';\n        mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\n        dma mem\\<^sub>1' x = High \\<or> x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                     mem\\<^sub>2' mems' i\n 3. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "let ?mems\\<^sub>2'i = \"snd (mems' ! i)\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>i < length cms\\<^sub>1';\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\\<rbrakk>\n       \\<Longrightarrow> (cms\\<^sub>1' ! i,\n                          subst \\<sigma> (fst (mems' ! i))) \\<approx>\n                         (cms\\<^sub>2' ! i,\n                          subst \\<sigma> (snd (mems' ! i)))\n 2. \\<And>i x.\n       \\<lbrakk>i < length cms\\<^sub>1';\n        mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\n        dma mem\\<^sub>1' x = High \\<or> x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                     mem\\<^sub>2' mems' i\n 3. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "assume i_le: \"i < length cms\\<^sub>1'\""], ["proof (state)\nthis:\n  i < length cms\\<^sub>1'\n\ngoal (3 subgoals):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>i < length cms\\<^sub>1';\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\\<rbrakk>\n       \\<Longrightarrow> (cms\\<^sub>1' ! i,\n                          subst \\<sigma> (fst (mems' ! i))) \\<approx>\n                         (cms\\<^sub>2' ! i,\n                          subst \\<sigma> (snd (mems' ! i)))\n 2. \\<And>i x.\n       \\<lbrakk>i < length cms\\<^sub>1';\n        mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\n        dma mem\\<^sub>1' x = High \\<or> x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                     mem\\<^sub>2' mems' i\n 3. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "assume dom\\<sigma>: \"dom \\<sigma> = ?X' i\""], ["proof (state)\nthis:\n  dom \\<sigma> = differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (3 subgoals):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>i < length cms\\<^sub>1';\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\\<rbrakk>\n       \\<Longrightarrow> (cms\\<^sub>1' ! i,\n                          subst \\<sigma> (fst (mems' ! i))) \\<approx>\n                         (cms\\<^sub>2' ! i,\n                          subst \\<sigma> (snd (mems' ! i)))\n 2. \\<And>i x.\n       \\<lbrakk>i < length cms\\<^sub>1';\n        mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\n        dma mem\\<^sub>1' x = High \\<or> x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                     mem\\<^sub>2' mems' i\n 3. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "show \"(cms\\<^sub>1' ! i, (fst (mems' ! i)) [\\<mapsto> \\<sigma>]) \\<approx> (cms\\<^sub>2' ! i, (snd (mems' ! i)) [\\<mapsto> \\<sigma>])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "proof (cases \"i = k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))\n 2. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "assume [simp]: \"i = k\"\n        \\<comment> \\<open>We define another  function from this and reuse the universally quantified statements\n          from the first part of the proof.\\<close>"], ["proof (state)\nthis:\n  i = k\n\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))\n 2. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "define \\<sigma>' where \"\\<sigma>' x =\n           (if x \\<in> ?X k\n            then if x \\<in> ?X' k\n                 then \\<sigma> x\n                 else Some (mem\\<^sub>1' x)\n            else None)\" for x"], ["proof (state)\nthis:\n  \\<sigma>' ?x =\n  (if ?x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n   then if ?x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n        then \\<sigma> ?x else Some (mem\\<^sub>1' ?x)\n   else None)\n\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))\n 2. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "have dom\\<sigma>': \"dom \\<sigma>' = ?X k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom \\<sigma>' = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k", "using \\<sigma>'_def [abs_def]"], ["proof (prove)\nusing this:\n  \\<sigma>' \\<equiv>\n  \\<lambda>x.\n     if x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n     then if x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n          then \\<sigma> x else Some (mem\\<^sub>1' x)\n     else None\n\ngoal (1 subgoal):\n 1. dom \\<sigma>' = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k", "apply (clarsimp, safe)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>\\<sigma>' \\<equiv>\n                \\<lambda>x.\n                   if x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                               mems k\n                   then if x \\<in> differing_vars_lists mem\\<^sub>1'\n                                    mem\\<^sub>2' mems' k\n                        then \\<sigma> x else Some (mem\\<^sub>1' x)\n                   else None;\n        \\<sigma>' \\<equiv>\n        \\<lambda>x.\n           if x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n           then if x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2'\n                            mems' k\n                then \\<sigma> x else Some (mem\\<^sub>1' x)\n           else None;\n        (if x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n         then if x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2'\n                          mems' k\n              then \\<sigma> x else Some (mem\\<^sub>1' x)\n         else None) =\n        Some y\\<rbrakk>\n       \\<Longrightarrow> x \\<in> differing_vars_lists mem\\<^sub>1\n                                  mem\\<^sub>2 mems k\n 2. \\<And>x.\n       \\<lbrakk>\\<sigma>' \\<equiv>\n                \\<lambda>x.\n                   if x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                               mems k\n                   then if x \\<in> differing_vars_lists mem\\<^sub>1'\n                                    mem\\<^sub>2' mems' k\n                        then \\<sigma> x else Some (mem\\<^sub>1' x)\n                   else None;\n        \\<sigma>' \\<equiv>\n        \\<lambda>x.\n           if x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n           then if x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2'\n                            mems' k\n                then \\<sigma> x else Some (mem\\<^sub>1' x)\n           else None;\n        x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y.\n                            (if x \\<in> differing_vars_lists mem\\<^sub>1\n   mem\\<^sub>2 mems k\n                             then if x \\<in> differing_vars_lists\n        mem\\<^sub>1' mem\\<^sub>2' mems' k\n                                  then \\<sigma> x else Some (mem\\<^sub>1' x)\n                             else None) =\n                            Some y", "by( metis domI domIff, metis \\<open>i = k\\<close> domD dom\\<sigma> )"], ["proof (state)\nthis:\n  dom \\<sigma>' = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))\n 2. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "have diff_vars_impl [simp]: \"\\<And>x. x \\<in> ?X' k \\<Longrightarrow> x \\<in> ?X k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n       x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k", "proof (rule ccontr)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                         k;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                    k\\<rbrakk>\n       \\<Longrightarrow> False", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                         k;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                    k\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"x \\<notin> ?X k\""], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                         k;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                    k\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"mem\\<^sub>1 x = ?mems\\<^sub>1k x \\<and> mem\\<^sub>2 x = ?mems\\<^sub>2k x\""], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. mem\\<^sub>1 x = fst (mems ! k) x \\<and> mem\\<^sub>2 x = snd (mems ! k) x", "by (metis differing_vars_neg)"], ["proof (state)\nthis:\n  mem\\<^sub>1 x = fst (mems ! k) x \\<and> mem\\<^sub>2 x = snd (mems ! k) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                         k;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                    k\\<rbrakk>\n       \\<Longrightarrow> False", "from \\<open>x \\<notin> ?X k\\<close>"], ["proof (chain)\npicking this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k", "have \"?mems\\<^sub>1'i x = mem\\<^sub>1' x \\<and> ?mems\\<^sub>2'i x = mem\\<^sub>2' x\""], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n    snd (mems' ! i) x = mem\\<^sub>2' x", "by auto"], ["proof (state)\nthis:\n  fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n  snd (mems' ! i) x = mem\\<^sub>2' x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                         k;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                    k\\<rbrakk>\n       \\<Longrightarrow> False", "moreover"], ["proof (state)\nthis:\n  fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n  snd (mems' ! i) x = mem\\<^sub>2' x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                         k;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                    k\\<rbrakk>\n       \\<Longrightarrow> False", "assume \"x \\<in> ?X' k\""], ["proof (state)\nthis:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                         k;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                    k\\<rbrakk>\n       \\<Longrightarrow> False", "hence \"mem\\<^sub>1' x \\<noteq> ?mems\\<^sub>1'i x \\<or> mem\\<^sub>2' x \\<noteq> ?mems\\<^sub>2'i x\""], ["proof (prove)\nusing this:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n\ngoal (1 subgoal):\n 1. mem\\<^sub>1' x \\<noteq> fst (mems' ! i) x \\<or>\n    mem\\<^sub>2' x \\<noteq> snd (mems' ! i) x", "by (metis \\<open>i = k\\<close> differing_vars_elim)"], ["proof (state)\nthis:\n  mem\\<^sub>1' x \\<noteq> fst (mems' ! i) x \\<or>\n  mem\\<^sub>2' x \\<noteq> snd (mems' ! i) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                         k;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                    k\\<rbrakk>\n       \\<Longrightarrow> False", "ultimately"], ["proof (chain)\npicking this:\n  fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n  snd (mems' ! i) x = mem\\<^sub>2' x\n  mem\\<^sub>1' x \\<noteq> fst (mems' ! i) x \\<or>\n  mem\\<^sub>2' x \\<noteq> snd (mems' ! i) x", "show False"], ["proof (prove)\nusing this:\n  fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n  snd (mems' ! i) x = mem\\<^sub>2' x\n  mem\\<^sub>1' x \\<noteq> fst (mems' ! i) x \\<or>\n  mem\\<^sub>2' x \\<noteq> snd (mems' ! i) x\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x5\n  \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n         k \\<Longrightarrow>\n  ?x5 \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))\n 2. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "(* We now show that we can reuse the earlier statements\n           by showing the following equality: *)"], ["proof (state)\nthis:\n  ?x5\n  \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n         k \\<Longrightarrow>\n  ?x5 \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))\n 2. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "have \"?mems\\<^sub>1'i [\\<mapsto> \\<sigma>] = mem\\<^sub>1' [\\<mapsto> \\<sigma>']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst \\<sigma> (fst (mems' ! i)) = subst \\<sigma>' mem\\<^sub>1'", "proof (rule ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x", "show \"?mems\\<^sub>1'i [\\<mapsto> \\<sigma>] x = mem\\<^sub>1' [\\<mapsto> \\<sigma>'] x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x", "proof (cases \"x \\<in> ?X' k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x", "assume x_in_X'k: \"x \\<in> ?X' k\""], ["proof (state)\nthis:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x", "then"], ["proof (chain)\npicking this:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k", "obtain v where \"\\<sigma> x = Some v\""], ["proof (prove)\nusing this:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<sigma> x = Some v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis dom\\<sigma> domD \\<open>i = k\\<close>)"], ["proof (state)\nthis:\n  \\<sigma> x = Some v\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x", "hence \"?mems\\<^sub>1'i [\\<mapsto> \\<sigma>] x = v\""], ["proof (prove)\nusing this:\n  \\<sigma> x = Some v\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (fst (mems' ! i)) x = v", "using \\<open>x \\<in> ?X' k\\<close> dom\\<sigma>"], ["proof (prove)\nusing this:\n  \\<sigma> x = Some v\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n  dom \\<sigma> = differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (fst (mems' ! i)) x = v", "by (auto simp: subst_def)"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) x = v\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x", "moreover"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) x = v\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x", "from dom\\<sigma>' and \\<open>x \\<in> ?X' k\\<close>"], ["proof (chain)\npicking this:\n  dom \\<sigma>' = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k", "have \"x \\<in> dom \\<sigma>'\""], ["proof (prove)\nusing this:\n  dom \\<sigma>' = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n\ngoal (1 subgoal):\n 1. x \\<in> dom \\<sigma>'", "by simp"], ["proof (state)\nthis:\n  x \\<in> dom \\<sigma>'\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x", "hence \"mem\\<^sub>1' [\\<mapsto> \\<sigma>'] x = v\""], ["proof (prove)\nusing this:\n  x \\<in> dom \\<sigma>'\n\ngoal (1 subgoal):\n 1. subst \\<sigma>' mem\\<^sub>1' x = v", "using dom\\<sigma>'"], ["proof (prove)\nusing this:\n  x \\<in> dom \\<sigma>'\n  dom \\<sigma>' = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. subst \\<sigma>' mem\\<^sub>1' x = v", "unfolding subst_def"], ["proof (prove)\nusing this:\n  x \\<in> dom \\<sigma>'\n  dom \\<sigma>' = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. (case \\<sigma>' x of None \\<Rightarrow> mem\\<^sub>1' x\n     | Some v \\<Rightarrow> v) =\n    v", "by (metis \\<sigma>'_def \\<open>\\<sigma> x = Some v\\<close> diff_vars_impl option.simps(5) x_in_X'k)"], ["proof (state)\nthis:\n  subst \\<sigma>' mem\\<^sub>1' x = v\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x", "ultimately"], ["proof (chain)\npicking this:\n  subst \\<sigma> (fst (mems' ! i)) x = v\n  subst \\<sigma>' mem\\<^sub>1' x = v", "show \"?mems\\<^sub>1'i [\\<mapsto> \\<sigma>] x = mem\\<^sub>1' [\\<mapsto> \\<sigma>'] x\""], ["proof (prove)\nusing this:\n  subst \\<sigma> (fst (mems' ! i)) x = v\n  subst \\<sigma>' mem\\<^sub>1' x = v\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x", ".."], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x", "assume \"x \\<notin> ?X' k\""], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x", "hence \"?mems\\<^sub>1'i [\\<mapsto> \\<sigma>] x = ?mems\\<^sub>1'i x\""], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (fst (mems' ! i)) x = fst (mems' ! i) x", "using dom\\<sigma>"], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n  dom \\<sigma> = differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (fst (mems' ! i)) x = fst (mems' ! i) x", "by (metis \\<open>i = k\\<close> subst_not_in_dom)"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) x = fst (mems' ! i) x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x", "proof(case_tac \"x \\<in> ?X k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n             k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x", "assume \"x \\<in> ?X k\""], ["proof (state)\nthis:\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n             k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x", "from \\<open>x \\<notin> ?X' k\\<close>"], ["proof (chain)\npicking this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k", "have \"mem\\<^sub>1' x = ?mems\\<^sub>1'i x\""], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n\ngoal (1 subgoal):\n 1. mem\\<^sub>1' x = fst (mems' ! i) x", "by(metis differing_vars_neg \\<open>i = k\\<close>)"], ["proof (state)\nthis:\n  mem\\<^sub>1' x = fst (mems' ! i) x\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n             k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x", "then"], ["proof (chain)\npicking this:\n  mem\\<^sub>1' x = fst (mems' ! i) x", "have \"\\<sigma>' x = Some (?mems\\<^sub>1'i x)\""], ["proof (prove)\nusing this:\n  mem\\<^sub>1' x = fst (mems' ! i) x\n\ngoal (1 subgoal):\n 1. \\<sigma>' x = Some (fst (mems' ! i) x)", "unfolding \\<sigma>'_def"], ["proof (prove)\nusing this:\n  mem\\<^sub>1' x = fst (mems' ! i) x\n\ngoal (1 subgoal):\n 1. (if x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n     then if x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n          then \\<sigma> x else Some (mem\\<^sub>1' x)\n     else None) =\n    Some (fst (mems' ! i) x)", "using dom\\<sigma>' domh"], ["proof (prove)\nusing this:\n  mem\\<^sub>1' x = fst (mems' ! i) x\n  dom \\<sigma>' = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n  dom h = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. (if x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n     then if x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n          then \\<sigma> x else Some (mem\\<^sub>1' x)\n     else None) =\n    Some (fst (mems' ! i) x)", "by(simp add: \\<open>x \\<in> ?X k\\<close> \\<open>x \\<notin> ?X' k\\<close>)"], ["proof (state)\nthis:\n  \\<sigma>' x = Some (fst (mems' ! i) x)\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n             k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x", "hence \"mem\\<^sub>1' [\\<mapsto> \\<sigma>'] x = ?mems\\<^sub>1'i x\""], ["proof (prove)\nusing this:\n  \\<sigma>' x = Some (fst (mems' ! i) x)\n\ngoal (1 subgoal):\n 1. subst \\<sigma>' mem\\<^sub>1' x = fst (mems' ! i) x", "unfolding subst_def"], ["proof (prove)\nusing this:\n  \\<sigma>' x = Some (fst (mems' ! i) x)\n\ngoal (1 subgoal):\n 1. (case \\<sigma>' x of None \\<Rightarrow> mem\\<^sub>1' x\n     | Some v \\<Rightarrow> v) =\n    fst (mems' ! i) x", "by (metis option.simps(5))"], ["proof (state)\nthis:\n  subst \\<sigma>' mem\\<^sub>1' x = fst (mems' ! i) x\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n             k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x", "thus ?thesis"], ["proof (prove)\nusing this:\n  subst \\<sigma>' mem\\<^sub>1' x = fst (mems' ! i) x\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x", "by (metis \\<open>?mems\\<^sub>1'i [\\<mapsto>\\<sigma>] x = ?mems\\<^sub>1'i x\\<close>)"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x", "assume \"x \\<notin> ?X k\""], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x", "then"], ["proof (chain)\npicking this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k", "have \"mem\\<^sub>1' [\\<mapsto> \\<sigma>'] x = mem\\<^sub>1' x\""], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. subst \\<sigma>' mem\\<^sub>1' x = mem\\<^sub>1' x", "by (metis dom\\<sigma>' subst_not_in_dom)"], ["proof (state)\nthis:\n  subst \\<sigma>' mem\\<^sub>1' x = mem\\<^sub>1' x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x", "moreover"], ["proof (state)\nthis:\n  subst \\<sigma>' mem\\<^sub>1' x = mem\\<^sub>1' x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x", "have \"?mems\\<^sub>1'i x = mem\\<^sub>1' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (mems' ! i) x = mem\\<^sub>1' x", "by (metis \\<open>i = k\\<close> \\<open>x \\<notin> ?X' k\\<close> differing_vars_neg)"], ["proof (state)\nthis:\n  fst (mems' ! i) x = mem\\<^sub>1' x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x", "ultimately"], ["proof (chain)\npicking this:\n  subst \\<sigma>' mem\\<^sub>1' x = mem\\<^sub>1' x\n  fst (mems' ! i) x = mem\\<^sub>1' x", "show ?thesis"], ["proof (prove)\nusing this:\n  subst \\<sigma>' mem\\<^sub>1' x = mem\\<^sub>1' x\n  fst (mems' ! i) x = mem\\<^sub>1' x\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x", "by (metis \\<open>?mems\\<^sub>1'i [\\<mapsto>\\<sigma>] x = ?mems\\<^sub>1'i x\\<close>)"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>1' x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) = subst \\<sigma>' mem\\<^sub>1'\n\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))\n 2. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "(* And the same for the second memories: *)"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) = subst \\<sigma>' mem\\<^sub>1'\n\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))\n 2. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "moreover"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) = subst \\<sigma>' mem\\<^sub>1'\n\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))\n 2. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "have \"?mems\\<^sub>2'i [\\<mapsto> \\<sigma>] = mem\\<^sub>h [\\<mapsto> \\<sigma>']\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst \\<sigma> (snd (mems' ! i)) = subst \\<sigma>' mem\\<^sub>h", "proof (rule ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x", "show \"?mems\\<^sub>2'i [\\<mapsto> \\<sigma>] x = mem\\<^sub>h [\\<mapsto> \\<sigma>'] x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x", "proof (cases \"x \\<in> ?X' k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x", "assume \"x \\<in> ?X' k\""], ["proof (state)\nthis:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x", "then"], ["proof (chain)\npicking this:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k", "obtain v where \"\\<sigma> x = Some v\""], ["proof (prove)\nusing this:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<sigma> x = Some v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using dom\\<sigma>"], ["proof (prove)\nusing this:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n  dom \\<sigma> = differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<sigma> x = Some v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis domD \\<open>i = k\\<close>)"], ["proof (state)\nthis:\n  \\<sigma> x = Some v\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x", "hence \"?mems\\<^sub>2'i [\\<mapsto> \\<sigma>] x = v\""], ["proof (prove)\nusing this:\n  \\<sigma> x = Some v\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (snd (mems' ! i)) x = v", "using \\<open>x \\<in> ?X' k\\<close> dom\\<sigma>"], ["proof (prove)\nusing this:\n  \\<sigma> x = Some v\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n  dom \\<sigma> = differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (snd (mems' ! i)) x = v", "unfolding subst_def"], ["proof (prove)\nusing this:\n  \\<sigma> x = Some v\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n  dom \\<sigma> = differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. (case \\<sigma> x of None \\<Rightarrow> snd (mems' ! i) x\n     | Some v \\<Rightarrow> v) =\n    v", "by (metis option.simps(5))"], ["proof (state)\nthis:\n  subst \\<sigma> (snd (mems' ! i)) x = v\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x", "moreover"], ["proof (state)\nthis:\n  subst \\<sigma> (snd (mems' ! i)) x = v\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x", "from \\<open>x \\<in> ?X' k\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k", "have \"x \\<in> ?X k\""], ["proof (prove)\nusing this:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n\ngoal (1 subgoal):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k", "by auto"], ["proof (state)\nthis:\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x", "hence \"x \\<in> dom (\\<sigma>')\""], ["proof (prove)\nusing this:\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. x \\<in> dom \\<sigma>'", "by (metis dom\\<sigma>'  \\<open>x \\<in> ?X' k\\<close>)"], ["proof (state)\nthis:\n  x \\<in> dom \\<sigma>'\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x", "hence \"mem\\<^sub>2' [\\<mapsto> \\<sigma>'] x = v\""], ["proof (prove)\nusing this:\n  x \\<in> dom \\<sigma>'\n\ngoal (1 subgoal):\n 1. subst \\<sigma>' mem\\<^sub>2' x = v", "using dom\\<sigma>' c"], ["proof (prove)\nusing this:\n  x \\<in> dom \\<sigma>'\n  dom \\<sigma>' = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n  change_respecting (cms\\<^sub>1 ! k, mem\\<^sub>1)\n   (cms\\<^sub>1' ! k, mem\\<^sub>1')\n   (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n\ngoal (1 subgoal):\n 1. subst \\<sigma>' mem\\<^sub>2' x = v", "unfolding subst_def"], ["proof (prove)\nusing this:\n  x \\<in> dom \\<sigma>'\n  dom \\<sigma>' = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n  change_respecting (cms\\<^sub>1 ! k, mem\\<^sub>1)\n   (cms\\<^sub>1' ! k, mem\\<^sub>1')\n   (differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n\ngoal (1 subgoal):\n 1. (case \\<sigma>' x of None \\<Rightarrow> mem\\<^sub>2' x\n     | Some v \\<Rightarrow> v) =\n    v", "by (metis \\<sigma>'_def \\<open>\\<sigma> x = Some v\\<close> diff_vars_impl option.simps(5) \\<open>x \\<in> ?X' k\\<close>)"], ["proof (state)\nthis:\n  subst \\<sigma>' mem\\<^sub>2' x = v\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x", "ultimately"], ["proof (chain)\npicking this:\n  subst \\<sigma> (snd (mems' ! i)) x = v\n  subst \\<sigma>' mem\\<^sub>2' x = v", "show ?thesis"], ["proof (prove)\nusing this:\n  subst \\<sigma> (snd (mems' ! i)) x = v\n  subst \\<sigma>' mem\\<^sub>2' x = v\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x", "by (metis dom\\<sigma>' dom_restrict_total mem\\<^sub>2'_def subst_overrides)"], ["proof (state)\nthis:\n  subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x", "assume \"x \\<notin> ?X' k\""], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x", "hence \"?mems\\<^sub>2'i [\\<mapsto> \\<sigma>] x = ?mems\\<^sub>2'i x\""], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (snd (mems' ! i)) x = snd (mems' ! i) x", "using dom\\<sigma>"], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n  dom \\<sigma> = differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (snd (mems' ! i)) x = snd (mems' ! i) x", "by (metis \\<open>i = k\\<close> subst_not_in_dom)"], ["proof (state)\nthis:\n  subst \\<sigma> (snd (mems' ! i)) x = snd (mems' ! i) x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x", "proof(case_tac \"x \\<in> ?X k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n             k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x", "assume \"x \\<in> ?X k\""], ["proof (state)\nthis:\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n             k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x", "(* This case can't happen so derive a contradiction *)"], ["proof (state)\nthis:\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n             k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x", "hence \"mem\\<^sub>1 x = mem\\<^sub>1' x \\<and> mem\\<^sub>2 x = mem\\<^sub>2' x\""], ["proof (prove)\nusing this:\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. mem\\<^sub>1 x = mem\\<^sub>1' x \\<and> mem\\<^sub>2 x = mem\\<^sub>2' x", "by (metis x_unchanged)"], ["proof (state)\nthis:\n  mem\\<^sub>1 x = mem\\<^sub>1' x \\<and> mem\\<^sub>2 x = mem\\<^sub>2' x\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n             k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x", "moreover"], ["proof (state)\nthis:\n  mem\\<^sub>1 x = mem\\<^sub>1' x \\<and> mem\\<^sub>2 x = mem\\<^sub>2' x\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n             k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x", "from \\<open>x \\<notin> ?X' k\\<close> \\<open>i = k\\<close>"], ["proof (chain)\npicking this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n  i = k", "have \"?mems\\<^sub>1'i x = mem\\<^sub>1' x \\<and> ?mems\\<^sub>2'i x = mem\\<^sub>2' x\""], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n  i = k\n\ngoal (1 subgoal):\n 1. fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n    snd (mems' ! i) x = mem\\<^sub>2' x", "by(metis differing_vars_neg)"], ["proof (state)\nthis:\n  fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n  snd (mems' ! i) x = mem\\<^sub>2' x\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n             k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x", "moreover"], ["proof (state)\nthis:\n  fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n  snd (mems' ! i) x = mem\\<^sub>2' x\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n             k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x", "from \\<open>x \\<in> ?X k\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k", "have \"fst (mems ! i) x \\<noteq> mem\\<^sub>1 x \\<or> snd (mems ! i) x \\<noteq> mem\\<^sub>2 x\""], ["proof (prove)\nusing this:\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. fst (mems ! i) x \\<noteq> mem\\<^sub>1 x \\<or>\n    snd (mems ! i) x \\<noteq> mem\\<^sub>2 x", "by(metis differing_vars_elim \\<open>i = k\\<close>)"], ["proof (state)\nthis:\n  fst (mems ! i) x \\<noteq> mem\\<^sub>1 x \\<or>\n  snd (mems ! i) x \\<noteq> mem\\<^sub>2 x\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n             k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x", "moreover"], ["proof (state)\nthis:\n  fst (mems ! i) x \\<noteq> mem\\<^sub>1 x \\<or>\n  snd (mems ! i) x \\<noteq> mem\\<^sub>2 x\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n             k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x", "from \\<open>x \\<in> ?X k\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k", "have \"fst (mems' ! i) x = fst (mems ! i) x \\<and>\n                                             snd (mems' ! i) x = snd (mems ! i) x\""], ["proof (prove)\nusing this:\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. fst (mems' ! i) x = fst (mems ! i) x \\<and>\n    snd (mems' ! i) x = snd (mems ! i) x", "by(metis mems'_k_2 \\<open>i = k\\<close>)"], ["proof (state)\nthis:\n  fst (mems' ! i) x = fst (mems ! i) x \\<and>\n  snd (mems' ! i) x = snd (mems ! i) x\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n             k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x", "ultimately"], ["proof (chain)\npicking this:\n  mem\\<^sub>1 x = mem\\<^sub>1' x \\<and> mem\\<^sub>2 x = mem\\<^sub>2' x\n  fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n  snd (mems' ! i) x = mem\\<^sub>2' x\n  fst (mems ! i) x \\<noteq> mem\\<^sub>1 x \\<or>\n  snd (mems ! i) x \\<noteq> mem\\<^sub>2 x\n  fst (mems' ! i) x = fst (mems ! i) x \\<and>\n  snd (mems' ! i) x = snd (mems ! i) x", "have \"False\""], ["proof (prove)\nusing this:\n  mem\\<^sub>1 x = mem\\<^sub>1' x \\<and> mem\\<^sub>2 x = mem\\<^sub>2' x\n  fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n  snd (mems' ! i) x = mem\\<^sub>2' x\n  fst (mems ! i) x \\<noteq> mem\\<^sub>1 x \\<or>\n  snd (mems ! i) x \\<noteq> mem\\<^sub>2 x\n  fst (mems' ! i) x = fst (mems ! i) x \\<and>\n  snd (mems' ! i) x = snd (mems ! i) x\n\ngoal (1 subgoal):\n 1. False", "by auto"], ["proof (state)\nthis:\n  False\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n             k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x", "thus ?thesis"], ["proof (prove)\nusing this:\n  False\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x", "by blast"], ["proof (state)\nthis:\n  subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x", "assume \"x \\<notin> ?X k\""], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x", "hence \"x \\<notin> dom \\<sigma>'\""], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. x \\<notin> dom \\<sigma>'", "by (simp add: dom\\<sigma>')"], ["proof (state)\nthis:\n  x \\<notin> dom \\<sigma>'\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x", "then"], ["proof (chain)\npicking this:\n  x \\<notin> dom \\<sigma>'", "have \"mem\\<^sub>h [\\<mapsto> \\<sigma>'] x = mem\\<^sub>h x\""], ["proof (prove)\nusing this:\n  x \\<notin> dom \\<sigma>'\n\ngoal (1 subgoal):\n 1. subst \\<sigma>' mem\\<^sub>h x = mem\\<^sub>h x", "by (metis subst_not_in_dom)"], ["proof (state)\nthis:\n  subst \\<sigma>' mem\\<^sub>h x = mem\\<^sub>h x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x", "moreover"], ["proof (state)\nthis:\n  subst \\<sigma>' mem\\<^sub>h x = mem\\<^sub>h x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x", "have \"?mems\\<^sub>2'i x = mem\\<^sub>2' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (mems' ! i) x = mem\\<^sub>2' x", "by (metis \\<open>i = k\\<close>  mems'_k_1 \\<open>x \\<notin> ?X k\\<close>)"], ["proof (state)\nthis:\n  snd (mems' ! i) x = mem\\<^sub>2' x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x", "hence \"?mems\\<^sub>2'i x = mem\\<^sub>h x\""], ["proof (prove)\nusing this:\n  snd (mems' ! i) x = mem\\<^sub>2' x\n\ngoal (1 subgoal):\n 1. snd (mems' ! i) x = mem\\<^sub>h x", "unfolding mem\\<^sub>2'_def"], ["proof (prove)\nusing this:\n  snd (mems' ! i) x =\n  subst\n   (to_partial mem\\<^sub>2 |`\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n   mem\\<^sub>h x\n\ngoal (1 subgoal):\n 1. snd (mems' ! i) x = mem\\<^sub>h x", "by (metis dom\\<sigma>_mem\\<^sub>2 subst_not_in_dom \\<open>x \\<notin> ?X k\\<close>)"], ["proof (state)\nthis:\n  snd (mems' ! i) x = mem\\<^sub>h x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                k \\<Longrightarrow>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x", "ultimately"], ["proof (chain)\npicking this:\n  subst \\<sigma>' mem\\<^sub>h x = mem\\<^sub>h x\n  snd (mems' ! i) x = mem\\<^sub>h x", "show ?thesis"], ["proof (prove)\nusing this:\n  subst \\<sigma>' mem\\<^sub>h x = mem\\<^sub>h x\n  snd (mems' ! i) x = mem\\<^sub>h x\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x", "by (metis \\<open>?mems\\<^sub>2'i [\\<mapsto>\\<sigma>] x = ?mems\\<^sub>2'i x\\<close>)"], ["proof (state)\nthis:\n  subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' mem\\<^sub>h x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst \\<sigma> (snd (mems' ! i)) = subst \\<sigma>' mem\\<^sub>h\n\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))\n 2. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "ultimately"], ["proof (chain)\npicking this:\n  subst \\<sigma> (fst (mems' ! i)) = subst \\<sigma>' mem\\<^sub>1'\n  subst \\<sigma> (snd (mems' ! i)) = subst \\<sigma>' mem\\<^sub>h", "show\n          \"(cms\\<^sub>1' ! i, (fst (mems' ! i)) [\\<mapsto> \\<sigma>]) \\<approx> (cms\\<^sub>2' ! i, (snd (mems' ! i)) [\\<mapsto> \\<sigma>])\""], ["proof (prove)\nusing this:\n  subst \\<sigma> (fst (mems' ! i)) = subst \\<sigma>' mem\\<^sub>1'\n  subst \\<sigma> (snd (mems' ! i)) = subst \\<sigma>' mem\\<^sub>h\n\ngoal (1 subgoal):\n 1. (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "using dom\\<sigma> dom\\<sigma>' g b \\<open>i = k\\<close>"], ["proof (prove)\nusing this:\n  subst \\<sigma> (fst (mems' ! i)) = subst \\<sigma>' mem\\<^sub>1'\n  subst \\<sigma> (snd (mems' ! i)) = subst \\<sigma>' mem\\<^sub>h\n  dom \\<sigma> = differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n  dom \\<sigma>' = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n  dom ?\\<sigma>5 =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k \\<Longrightarrow>\n  (cms\\<^sub>2 ! k, subst ?\\<sigma>5 (snd (mems ! k))) \\<leadsto>\n  \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                           k), subst ?\\<sigma>5 mem\\<^sub>h\\<rangle> \\<and>\n  (cms\\<^sub>1' ! k, subst ?\\<sigma>5 mem\\<^sub>1') \\<approx>\n  \\<langle>c\\<^sub>h, snd (cms\\<^sub>1' !\n                           k), subst ?\\<sigma>5 mem\\<^sub>h\\<rangle>\n  k < length cms\\<^sub>1 \\<and>\n  (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto>\n  (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n  cms\\<^sub>1' = cms\\<^sub>1[k := cms\\<^sub>1' ! k]\n  i = k\n\ngoal (1 subgoal):\n 1. (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "by (metis c\\<^sub>2'_def cms\\<^sub>2'_def equal_size nth_list_update_eq)"], ["proof (state)\nthis:\n  (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n  (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "assume \"i \\<noteq> k\""], ["proof (state)\nthis:\n  i \\<noteq> k\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "define \\<sigma>' where \"\\<sigma>' x =\n            (if x \\<in> ?X i\n             then if x \\<in> ?X' i\n                  then \\<sigma> x\n                  else Some (mem\\<^sub>1' x)\n             else None)\" for x"], ["proof (state)\nthis:\n  \\<sigma>' ?x =\n  (if ?x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n   then if ?x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n        then \\<sigma> ?x else Some (mem\\<^sub>1' ?x)\n   else None)\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "let ?mems\\<^sub>1i = \"fst (mems ! i)\" and\n            ?mems\\<^sub>2i = \"snd (mems ! i)\""], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "have \"dom \\<sigma>' = ?X i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom \\<sigma>' = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i", "unfolding \\<sigma>'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (\\<lambda>x.\n            if x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n            then if x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2'\n                             mems' i\n                 then \\<sigma> x else Some (mem\\<^sub>1' x)\n            else None) =\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       (if x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n        then if x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                         i\n             then \\<sigma> x else Some (mem\\<^sub>1' x)\n        else None) =\n       Some y \\<Longrightarrow>\n       x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i;\n        x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                 i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. \\<sigma> x = Some y", "apply (metis option.simps(2))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i;\n        x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                 i\\<rbrakk>\n       \\<Longrightarrow> \\<exists>y. \\<sigma> x = Some y", "by (metis domD dom\\<sigma>)"], ["proof (state)\nthis:\n  dom \\<sigma>' = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "have o: \"\\<And> x.\n                 ((?mems\\<^sub>1'i [\\<mapsto> \\<sigma>] x \\<noteq> ?mems\\<^sub>1i [\\<mapsto> \\<sigma>'] x \\<or>\n                  ?mems\\<^sub>2'i [\\<mapsto> \\<sigma>] x \\<noteq> ?mems\\<^sub>2i [\\<mapsto> \\<sigma>'] x) \\<and>\n                 (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n                 (dma mem\\<^sub>1' x = dma mem\\<^sub>1 x))\n                 \\<longrightarrow> (mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or> mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (fst (mems ! i)) x \\<or>\n        subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (snd (mems ! i)) x) \\<and>\n       (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n       dma mem\\<^sub>1' x = dma mem\\<^sub>1 x \\<longrightarrow>\n       mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n       mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (fst (mems ! i)) x \\<or>\n        subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (snd (mems ! i)) x) \\<and>\n       (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n       dma mem\\<^sub>1' x = dma mem\\<^sub>1 x \\<longrightarrow>\n       mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n       mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (fst (mems ! i)) x \\<or>\n        subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (snd (mems ! i)) x) \\<and>\n       (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n       dma mem\\<^sub>1' x = dma mem\\<^sub>1 x \\<longrightarrow>\n       mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n       mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (fst (mems ! i)) x \\<or>\n        subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (snd (mems ! i)) x) \\<and>\n       (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n       dma mem\\<^sub>1' x = dma mem\\<^sub>1 x \\<longrightarrow>\n       mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n       mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x", "assume eq_mem: \"mem\\<^sub>1' x = mem\\<^sub>1 x \\<and> mem\\<^sub>2' x = mem\\<^sub>2 x\"\n               and clas: \"dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High\"\n               and clas_eq: \"dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\""], ["proof (state)\nthis:\n  mem\\<^sub>1' x = mem\\<^sub>1 x \\<and> mem\\<^sub>2' x = mem\\<^sub>2 x\n  dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High\n  dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (fst (mems ! i)) x \\<or>\n        subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (snd (mems ! i)) x) \\<and>\n       (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n       dma mem\\<^sub>1' x = dma mem\\<^sub>1 x \\<longrightarrow>\n       mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n       mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x", "hence mems'_simp: \"?mems\\<^sub>1'i x = ?mems\\<^sub>1i x \\<and> ?mems\\<^sub>2'i x = ?mems\\<^sub>2i x\""], ["proof (prove)\nusing this:\n  mem\\<^sub>1' x = mem\\<^sub>1 x \\<and> mem\\<^sub>2' x = mem\\<^sub>2 x\n  dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High\n  dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\n\ngoal (1 subgoal):\n 1. fst (mems' ! i) x = fst (mems ! i) x \\<and>\n    snd (mems' ! i) x = snd (mems ! i) x", "using mems'_i_4"], ["proof (prove)\nusing this:\n  mem\\<^sub>1' x = mem\\<^sub>1 x \\<and> mem\\<^sub>2' x = mem\\<^sub>2 x\n  dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High\n  dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\n  \\<lbrakk>?i5 \\<noteq> k; ?i5 < length cms\\<^sub>1;\n   mem\\<^sub>1 ?x5 = mem\\<^sub>1' ?x5; mem\\<^sub>2 ?x5 = mem\\<^sub>2' ?x5;\n   dma mem\\<^sub>1 ?x5 = Low \\<or> dma mem\\<^sub>1' ?x5 = High;\n   dma mem\\<^sub>1' ?x5 = dma mem\\<^sub>1 ?x5\\<rbrakk>\n  \\<Longrightarrow> fst (mems' ! ?i5) ?x5 = fst (mems ! ?i5) ?x5 \\<and>\n                    snd (mems' ! ?i5) ?x5 = snd (mems ! ?i5) ?x5\n\ngoal (1 subgoal):\n 1. fst (mems' ! i) x = fst (mems ! i) x \\<and>\n    snd (mems' ! i) x = snd (mems ! i) x", "by (metis \\<open>i \\<noteq> k\\<close> b i_le length_list_update)"], ["proof (state)\nthis:\n  fst (mems' ! i) x = fst (mems ! i) x \\<and>\n  snd (mems' ! i) x = snd (mems ! i) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (fst (mems ! i)) x \\<or>\n        subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (snd (mems ! i)) x) \\<and>\n       (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n       dma mem\\<^sub>1' x = dma mem\\<^sub>1 x \\<longrightarrow>\n       mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n       mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x", "have\n              \"?mems\\<^sub>1'i [\\<mapsto> \\<sigma>] x = ?mems\\<^sub>1i [\\<mapsto> \\<sigma>'] x \\<and> ?mems\\<^sub>2'i [\\<mapsto> \\<sigma>] x = ?mems\\<^sub>2i [\\<mapsto> \\<sigma>'] x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x", "proof (cases \"x \\<in> ?X' i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             i \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x", "assume \"x \\<in> ?X' i\""], ["proof (state)\nthis:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             i \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x", "hence \"?mems\\<^sub>1'i x \\<noteq> mem\\<^sub>1' x \\<or> ?mems\\<^sub>2'i x \\<noteq> mem\\<^sub>2' x\""], ["proof (prove)\nusing this:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. fst (mems' ! i) x \\<noteq> mem\\<^sub>1' x \\<or>\n    snd (mems' ! i) x \\<noteq> mem\\<^sub>2' x", "by (metis differing_vars_neg_intro)"], ["proof (state)\nthis:\n  fst (mems' ! i) x \\<noteq> mem\\<^sub>1' x \\<or>\n  snd (mems' ! i) x \\<noteq> mem\\<^sub>2' x\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             i \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x", "hence \"x \\<in> ?X i\""], ["proof (prove)\nusing this:\n  fst (mems' ! i) x \\<noteq> mem\\<^sub>1' x \\<or>\n  snd (mems' ! i) x \\<noteq> mem\\<^sub>2' x\n\ngoal (1 subgoal):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i", "using eq_mem mems'_simp"], ["proof (prove)\nusing this:\n  fst (mems' ! i) x \\<noteq> mem\\<^sub>1' x \\<or>\n  snd (mems' ! i) x \\<noteq> mem\\<^sub>2' x\n  mem\\<^sub>1' x = mem\\<^sub>1 x \\<and> mem\\<^sub>2' x = mem\\<^sub>2 x\n  fst (mems' ! i) x = fst (mems ! i) x \\<and>\n  snd (mems' ! i) x = snd (mems ! i) x\n\ngoal (1 subgoal):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i", "by (metis differing_vars_neg)"], ["proof (state)\nthis:\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             i \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x", "hence \"\\<sigma>' x = \\<sigma> x\""], ["proof (prove)\nusing this:\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n\ngoal (1 subgoal):\n 1. \\<sigma>' x = \\<sigma> x", "by (metis \\<sigma>'_def \\<open>x \\<in> ?X' i\\<close>)"], ["proof (state)\nthis:\n  \\<sigma>' x = \\<sigma> x\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             i \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<sigma>' x = \\<sigma> x\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x", "by (clarsimp simp: subst_def mems'_simp split: option.splits)"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) x =\n  subst \\<sigma>' (fst (mems ! i)) x \\<and>\n  subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x", "assume \"x \\<notin> ?X' i\""], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x", "hence \"?mems\\<^sub>1'i x = mem\\<^sub>1' x \\<and> ?mems\\<^sub>2'i x = mem\\<^sub>2' x\""], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n    snd (mems' ! i) x = mem\\<^sub>2' x", "by (metis differing_vars_neg)"], ["proof (state)\nthis:\n  fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n  snd (mems' ! i) x = mem\\<^sub>2' x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x", "hence \"x \\<notin> ?X i\""], ["proof (prove)\nusing this:\n  fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n  snd (mems' ! i) x = mem\\<^sub>2' x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i", "using eq_mem mems'_simp"], ["proof (prove)\nusing this:\n  fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n  snd (mems' ! i) x = mem\\<^sub>2' x\n  mem\\<^sub>1' x = mem\\<^sub>1 x \\<and> mem\\<^sub>2' x = mem\\<^sub>2 x\n  fst (mems' ! i) x = fst (mems ! i) x \\<and>\n  snd (mems' ! i) x = snd (mems ! i) x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i", "by (auto simp: differing_vars_neg_intro)"], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x", "by (metis \\<open>dom \\<sigma>' = ?X i\\<close> \\<open>x \\<notin> ?X' i\\<close> dom\\<sigma> mems'_simp subst_not_in_dom)"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) x =\n  subst \\<sigma>' (fst (mems ! i)) x \\<and>\n  subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) x =\n  subst \\<sigma>' (fst (mems ! i)) x \\<and>\n  subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (fst (mems ! i)) x \\<or>\n        subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (snd (mems ! i)) x) \\<and>\n       (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n       dma mem\\<^sub>1' x = dma mem\\<^sub>1 x \\<longrightarrow>\n       mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n       mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x", "}"], ["proof (state)\nthis:\n  \\<lbrakk>mem\\<^sub>1' x = mem\\<^sub>1 x \\<and>\n           mem\\<^sub>2' x = mem\\<^sub>2 x;\n   dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High;\n   dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\\<rbrakk>\n  \\<Longrightarrow> subst \\<sigma> (fst (mems' ! i)) x =\n                    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n                    subst \\<sigma> (snd (mems' ! i)) x =\n                    subst \\<sigma>' (snd (mems ! i)) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (fst (mems ! i)) x \\<or>\n        subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (snd (mems ! i)) x) \\<and>\n       (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n       dma mem\\<^sub>1' x = dma mem\\<^sub>1 x \\<longrightarrow>\n       mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n       mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x", "thus \"?thesis x\""], ["proof (prove)\nusing this:\n  \\<lbrakk>mem\\<^sub>1' x = mem\\<^sub>1 x \\<and>\n           mem\\<^sub>2' x = mem\\<^sub>2 x;\n   dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High;\n   dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\\<rbrakk>\n  \\<Longrightarrow> subst \\<sigma> (fst (mems' ! i)) x =\n                    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n                    subst \\<sigma> (snd (mems' ! i)) x =\n                    subst \\<sigma>' (snd (mems ! i)) x\n\ngoal (1 subgoal):\n 1. (subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n     subst \\<sigma>' (fst (mems ! i)) x \\<or>\n     subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n     subst \\<sigma>' (snd (mems ! i)) x) \\<and>\n    (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n    dma mem\\<^sub>1' x = dma mem\\<^sub>1 x \\<longrightarrow>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n    mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x", "by blast"], ["proof (state)\nthis:\n  (subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n   subst \\<sigma>' (fst (mems ! i)) x \\<or>\n   subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n   subst \\<sigma>' (snd (mems ! i)) x) \\<and>\n  (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n  dma mem\\<^sub>1' x = dma mem\\<^sub>1 x \\<longrightarrow>\n  mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n  mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (subst \\<sigma> (fst (mems' ! i)) ?x5 \\<noteq>\n   subst \\<sigma>' (fst (mems ! i)) ?x5 \\<or>\n   subst \\<sigma> (snd (mems' ! i)) ?x5 \\<noteq>\n   subst \\<sigma>' (snd (mems ! i)) ?x5) \\<and>\n  (dma mem\\<^sub>1 ?x5 = Low \\<or> dma mem\\<^sub>1' ?x5 = High) \\<and>\n  dma mem\\<^sub>1' ?x5 = dma mem\\<^sub>1 ?x5 \\<longrightarrow>\n  mem\\<^sub>1' ?x5 \\<noteq> mem\\<^sub>1 ?x5 \\<or>\n  mem\\<^sub>2' ?x5 \\<noteq> mem\\<^sub>2 ?x5\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "(* FIXME: clean this up once we optimise the definition of mems'_i *)\n        (* Toby: try to establish something similar to o for the downgrading case *)"], ["proof (state)\nthis:\n  (subst \\<sigma> (fst (mems' ! i)) ?x5 \\<noteq>\n   subst \\<sigma>' (fst (mems ! i)) ?x5 \\<or>\n   subst \\<sigma> (snd (mems' ! i)) ?x5 \\<noteq>\n   subst \\<sigma>' (snd (mems ! i)) ?x5) \\<and>\n  (dma mem\\<^sub>1 ?x5 = Low \\<or> dma mem\\<^sub>1' ?x5 = High) \\<and>\n  dma mem\\<^sub>1' ?x5 = dma mem\\<^sub>1 ?x5 \\<longrightarrow>\n  mem\\<^sub>1' ?x5 \\<noteq> mem\\<^sub>1 ?x5 \\<or>\n  mem\\<^sub>2' ?x5 \\<noteq> mem\\<^sub>2 ?x5\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "have o_downgrade: \"\\<And>x. x \\<notin> ?X' i \\<and> (subst \\<sigma> (fst (mems' ! i)) x \\<noteq> subst \\<sigma>' (fst (mems ! i)) x \\<or>\n                    subst \\<sigma> (snd (mems' ! i)) x \\<noteq> subst \\<sigma>' (snd (mems ! i)) x) \\<and>\n                   (dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low) \\<longrightarrow>\n                    mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or> mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                   i \\<and>\n       (subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (fst (mems ! i)) x \\<or>\n        subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (snd (mems ! i)) x) \\<and>\n       dma mem\\<^sub>1 x = High \\<and>\n       dma mem\\<^sub>1' x = Low \\<longrightarrow>\n       mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n       mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                   i \\<and>\n       (subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (fst (mems ! i)) x \\<or>\n        subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (snd (mems ! i)) x) \\<and>\n       dma mem\\<^sub>1 x = High \\<and>\n       dma mem\\<^sub>1' x = Low \\<longrightarrow>\n       mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n       mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                   i \\<and>\n       (subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (fst (mems ! i)) x \\<or>\n        subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (snd (mems ! i)) x) \\<and>\n       dma mem\\<^sub>1 x = High \\<and>\n       dma mem\\<^sub>1' x = Low \\<longrightarrow>\n       mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n       mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                   i \\<and>\n       (subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (fst (mems ! i)) x \\<or>\n        subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (snd (mems ! i)) x) \\<and>\n       dma mem\\<^sub>1 x = High \\<and>\n       dma mem\\<^sub>1' x = Low \\<longrightarrow>\n       mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n       mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x", "assume mem_eq: \"mem\\<^sub>1' x = mem\\<^sub>1 x \\<and> mem\\<^sub>2' x = mem\\<^sub>2 x\"\n               and clas: \"(dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low)\"\n               and notin: \"x \\<notin> ?X' i\""], ["proof (state)\nthis:\n  mem\\<^sub>1' x = mem\\<^sub>1 x \\<and> mem\\<^sub>2' x = mem\\<^sub>2 x\n  dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                   i \\<and>\n       (subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (fst (mems ! i)) x \\<or>\n        subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (snd (mems ! i)) x) \\<and>\n       dma mem\\<^sub>1 x = High \\<and>\n       dma mem\\<^sub>1' x = Low \\<longrightarrow>\n       mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n       mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x", "hence mems'_simp [simp]: \"?mems\\<^sub>1'i x = mem\\<^sub>1 x \\<and> ?mems\\<^sub>2'i x = mem\\<^sub>1 x\""], ["proof (prove)\nusing this:\n  mem\\<^sub>1' x = mem\\<^sub>1 x \\<and> mem\\<^sub>2' x = mem\\<^sub>2 x\n  dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. fst (mems' ! i) x = mem\\<^sub>1 x \\<and>\n    snd (mems' ! i) x = mem\\<^sub>1 x", "using mems'_i_3"], ["proof (prove)\nusing this:\n  mem\\<^sub>1' x = mem\\<^sub>1 x \\<and> mem\\<^sub>2' x = mem\\<^sub>2 x\n  dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n  \\<lbrakk>?i5 \\<noteq> k; ?i5 < length cms\\<^sub>1;\n   mem\\<^sub>1 ?x5 = mem\\<^sub>1' ?x5; mem\\<^sub>2 ?x5 = mem\\<^sub>2' ?x5;\n   dma mem\\<^sub>1 ?x5 = High \\<and> dma mem\\<^sub>1' ?x5 = Low\\<rbrakk>\n  \\<Longrightarrow> fst (mems' ! ?i5) ?x5 = mem\\<^sub>1 ?x5 \\<and>\n                    snd (mems' ! ?i5) ?x5 = mem\\<^sub>1 ?x5\n\ngoal (1 subgoal):\n 1. fst (mems' ! i) x = mem\\<^sub>1 x \\<and>\n    snd (mems' ! i) x = mem\\<^sub>1 x", "by (metis \\<open>i \\<noteq> k\\<close> b i_le length_list_update)"], ["proof (state)\nthis:\n  fst (mems' ! i) x = mem\\<^sub>1 x \\<and> snd (mems' ! i) x = mem\\<^sub>1 x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                   i \\<and>\n       (subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (fst (mems ! i)) x \\<or>\n        subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (snd (mems ! i)) x) \\<and>\n       dma mem\\<^sub>1 x = High \\<and>\n       dma mem\\<^sub>1' x = Low \\<longrightarrow>\n       mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n       mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x", "have\n              \"?mems\\<^sub>1'i [\\<mapsto> \\<sigma>] x = ?mems\\<^sub>1i [\\<mapsto> \\<sigma>'] x \\<and> ?mems\\<^sub>2'i [\\<mapsto> \\<sigma>] x = ?mems\\<^sub>2i [\\<mapsto> \\<sigma>'] x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x", "proof (cases \"x \\<in> ?X' i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             i \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x", "assume \"x \\<in> ?X' i\""], ["proof (state)\nthis:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             i \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x", "using notin"], ["proof (prove)\nusing this:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x", "by blast"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) x =\n  subst \\<sigma>' (fst (mems ! i)) x \\<and>\n  subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x", "assume \"x \\<notin> ?X' i\""], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x", "hence \"?mems\\<^sub>1'i x = mem\\<^sub>1' x \\<and> ?mems\\<^sub>2'i x = mem\\<^sub>2' x\""], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n    snd (mems' ! i) x = mem\\<^sub>2' x", "by (metis differing_vars_neg)"], ["proof (state)\nthis:\n  fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n  snd (mems' ! i) x = mem\\<^sub>2' x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x", "moreover"], ["proof (state)\nthis:\n  fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n  snd (mems' ! i) x = mem\\<^sub>2' x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x", "have \"x \\<notin> ?X i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i", "using clas compat i_le len_unchanged"], ["proof (prove)\nusing this:\n  dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  i < length cms\\<^sub>1'\n  length cms\\<^sub>1' = length cms\\<^sub>1\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i", "by (force)"], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x", "ultimately"], ["proof (chain)\npicking this:\n  fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n  snd (mems' ! i) x = mem\\<^sub>2' x\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i", "show ?thesis"], ["proof (prove)\nusing this:\n  fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n  snd (mems' ! i) x = mem\\<^sub>2' x\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x", "using dom\\<sigma> \\<open>dom \\<sigma>' = ?X i\\<close> \\<open>x \\<notin> ?X' i\\<close>"], ["proof (prove)\nusing this:\n  fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n  snd (mems' ! i) x = mem\\<^sub>2' x\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n  dom \\<sigma> = differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n  dom \\<sigma>' = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (fst (mems' ! i)) x =\n    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x", "apply(simp add: subst_not_in_dom)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x \\<and>\n             mem\\<^sub>1 x = mem\\<^sub>2' x;\n     x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i;\n     dom \\<sigma> = differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i;\n     dom \\<sigma>' = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i;\n     x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                 i\\<rbrakk>\n    \\<Longrightarrow> mem\\<^sub>1' x = fst (mems ! i) x \\<and>\n                      mem\\<^sub>1' x = snd (mems ! i) x", "apply(simp add: mem_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>2 x;\n     x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i;\n     dom \\<sigma> = differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i;\n     dom \\<sigma>' = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i;\n     x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                 i\\<rbrakk>\n    \\<Longrightarrow> mem\\<^sub>2 x = fst (mems ! i) x \\<and>\n                      mem\\<^sub>2 x = snd (mems ! i) x", "apply(force simp: differing_vars_def differing_vars_lists_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) x =\n  subst \\<sigma>' (fst (mems ! i)) x \\<and>\n  subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) x =\n  subst \\<sigma>' (fst (mems ! i)) x \\<and>\n  subst \\<sigma> (snd (mems' ! i)) x = subst \\<sigma>' (snd (mems ! i)) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                   i \\<and>\n       (subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (fst (mems ! i)) x \\<or>\n        subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (snd (mems ! i)) x) \\<and>\n       dma mem\\<^sub>1 x = High \\<and>\n       dma mem\\<^sub>1' x = Low \\<longrightarrow>\n       mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n       mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x", "}"], ["proof (state)\nthis:\n  \\<lbrakk>mem\\<^sub>1' x = mem\\<^sub>1 x \\<and>\n           mem\\<^sub>2' x = mem\\<^sub>2 x;\n   dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low;\n   x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n               i\\<rbrakk>\n  \\<Longrightarrow> subst \\<sigma> (fst (mems' ! i)) x =\n                    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n                    subst \\<sigma> (snd (mems' ! i)) x =\n                    subst \\<sigma>' (snd (mems ! i)) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                   i \\<and>\n       (subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (fst (mems ! i)) x \\<or>\n        subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (snd (mems ! i)) x) \\<and>\n       dma mem\\<^sub>1 x = High \\<and>\n       dma mem\\<^sub>1' x = Low \\<longrightarrow>\n       mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n       mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x", "thus \"?thesis x\""], ["proof (prove)\nusing this:\n  \\<lbrakk>mem\\<^sub>1' x = mem\\<^sub>1 x \\<and>\n           mem\\<^sub>2' x = mem\\<^sub>2 x;\n   dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low;\n   x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n               i\\<rbrakk>\n  \\<Longrightarrow> subst \\<sigma> (fst (mems' ! i)) x =\n                    subst \\<sigma>' (fst (mems ! i)) x \\<and>\n                    subst \\<sigma> (snd (mems' ! i)) x =\n                    subst \\<sigma>' (snd (mems ! i)) x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i \\<and>\n    (subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n     subst \\<sigma>' (fst (mems ! i)) x \\<or>\n     subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n     subst \\<sigma>' (snd (mems ! i)) x) \\<and>\n    dma mem\\<^sub>1 x = High \\<and>\n    dma mem\\<^sub>1' x = Low \\<longrightarrow>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n    mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x", "by blast"], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i \\<and>\n  (subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n   subst \\<sigma>' (fst (mems ! i)) x \\<or>\n   subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n   subst \\<sigma>' (snd (mems ! i)) x) \\<and>\n  dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low \\<longrightarrow>\n  mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n  mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x5 \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i \\<and>\n  (subst \\<sigma> (fst (mems' ! i)) ?x5 \\<noteq>\n   subst \\<sigma>' (fst (mems ! i)) ?x5 \\<or>\n   subst \\<sigma> (snd (mems' ! i)) ?x5 \\<noteq>\n   subst \\<sigma>' (snd (mems ! i)) ?x5) \\<and>\n  dma mem\\<^sub>1 ?x5 = High \\<and>\n  dma mem\\<^sub>1' ?x5 = Low \\<longrightarrow>\n  mem\\<^sub>1' ?x5 \\<noteq> mem\\<^sub>1 ?x5 \\<or>\n  mem\\<^sub>2' ?x5 \\<noteq> mem\\<^sub>2 ?x5\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "have modifies_no_var_asm_not_written:\n             \"\\<And>x. mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or> mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or>\n                   dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x \\<or> dma mem\\<^sub>2' x \\<noteq> dma mem\\<^sub>2 x \\<Longrightarrow>\n              \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n       mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or>\n       dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x \\<or>\n       dma mem\\<^sub>2' x \\<noteq> dma mem\\<^sub>2 x \\<Longrightarrow>\n       \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n       mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or>\n       dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x \\<or>\n       dma mem\\<^sub>2' x \\<noteq> dma mem\\<^sub>2 x \\<Longrightarrow>\n       \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n       mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or>\n       dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x \\<or>\n       dma mem\\<^sub>2' x \\<noteq> dma mem\\<^sub>2 x \\<Longrightarrow>\n       \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x", "assume \"mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or> mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or> dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x \\<or> dma mem\\<^sub>2' x \\<noteq> dma mem\\<^sub>2 x\""], ["proof (state)\nthis:\n  mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n  mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or>\n  dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x \\<or>\n  dma mem\\<^sub>2' x \\<noteq> dma mem\\<^sub>2 x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n       mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or>\n       dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x \\<or>\n       dma mem\\<^sub>2' x \\<noteq> dma mem\\<^sub>2 x \\<Longrightarrow>\n       \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x", "hence modified: \" \\<not> (doesnt_modify (fst (cms\\<^sub>1 ! k)) x) \\<or> \\<not> (doesnt_modify (fst (cms\\<^sub>2 ! k)) x)\""], ["proof (prove)\nusing this:\n  mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n  mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or>\n  dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x \\<or>\n  dma mem\\<^sub>2' x \\<noteq> dma mem\\<^sub>2 x\n\ngoal (1 subgoal):\n 1. \\<not> doesnt_modify (fst (cms\\<^sub>1 ! k)) x \\<or>\n    \\<not> doesnt_modify (fst (cms\\<^sub>2 ! k)) x", "using b i"], ["proof (prove)\nusing this:\n  mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n  mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or>\n  dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x \\<or>\n  dma mem\\<^sub>2' x \\<noteq> dma mem\\<^sub>2 x\n  k < length cms\\<^sub>1 \\<and>\n  (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto>\n  (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n  cms\\<^sub>1' = cms\\<^sub>1[k := cms\\<^sub>1' ! k]\n  (cms\\<^sub>2 ! k, mem\\<^sub>2) \\<leadsto>\n  \\<langle>c\\<^sub>2', snd (cms\\<^sub>1' ! k), mem\\<^sub>2'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> doesnt_modify (fst (cms\\<^sub>1 ! k)) x \\<or>\n    \\<not> doesnt_modify (fst (cms\\<^sub>2 ! k)) x", "unfolding doesnt_modify_def"], ["proof (prove)\nusing this:\n  mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n  mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or>\n  dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x \\<or>\n  dma mem\\<^sub>2' x \\<noteq> dma mem\\<^sub>2 x\n  k < length cms\\<^sub>1 \\<and>\n  (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto>\n  (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n  cms\\<^sub>1' = cms\\<^sub>1[k := cms\\<^sub>1' ! k]\n  (cms\\<^sub>2 ! k, mem\\<^sub>2) \\<leadsto>\n  \\<langle>c\\<^sub>2', snd (cms\\<^sub>1' ! k), mem\\<^sub>2'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>mds mem c' mds' mem'.\n               \\<langle>fst (cms\\<^sub>1 ! k), mds, mem\\<rangle> \\<leadsto>\n               \\<langle>c', mds', mem'\\<rangle> \\<longrightarrow>\n               mem x = mem' x \\<and> dma mem x = dma mem' x) \\<or>\n    \\<not> (\\<forall>mds mem c' mds' mem'.\n               \\<langle>fst (cms\\<^sub>2 ! k), mds, mem\\<rangle> \\<leadsto>\n               \\<langle>c', mds', mem'\\<rangle> \\<longrightarrow>\n               mem x = mem' x \\<and> dma mem x = dma mem' x)", "by (metis surjective_pairing)"], ["proof (state)\nthis:\n  \\<not> doesnt_modify (fst (cms\\<^sub>1 ! k)) x \\<or>\n  \\<not> doesnt_modify (fst (cms\\<^sub>2 ! k)) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n       mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or>\n       dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x \\<or>\n       dma mem\\<^sub>2' x \\<noteq> dma mem\\<^sub>2 x \\<Longrightarrow>\n       \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x", "hence modified_r: \" \\<not> (doesnt_read_or_modify (fst (cms\\<^sub>1 ! k)) x) \\<or> \\<not> (doesnt_read_or_modify (fst (cms\\<^sub>2 ! k)) x)\""], ["proof (prove)\nusing this:\n  \\<not> doesnt_modify (fst (cms\\<^sub>1 ! k)) x \\<or>\n  \\<not> doesnt_modify (fst (cms\\<^sub>2 ! k)) x\n\ngoal (1 subgoal):\n 1. \\<not> doesnt_read_or_modify (fst (cms\\<^sub>1 ! k)) x \\<or>\n    \\<not> doesnt_read_or_modify (fst (cms\\<^sub>2 ! k)) x", "using doesnt_read_or_modify_doesnt_modify"], ["proof (prove)\nusing this:\n  \\<not> doesnt_modify (fst (cms\\<^sub>1 ! k)) x \\<or>\n  \\<not> doesnt_modify (fst (cms\\<^sub>2 ! k)) x\n  doesnt_read_or_modify ?c ?x \\<Longrightarrow> doesnt_modify ?c ?x\n\ngoal (1 subgoal):\n 1. \\<not> doesnt_read_or_modify (fst (cms\\<^sub>1 ! k)) x \\<or>\n    \\<not> doesnt_read_or_modify (fst (cms\\<^sub>2 ! k)) x", "by fastforce"], ["proof (state)\nthis:\n  \\<not> doesnt_read_or_modify (fst (cms\\<^sub>1 ! k)) x \\<or>\n  \\<not> doesnt_read_or_modify (fst (cms\\<^sub>2 ! k)) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n       mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or>\n       dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x \\<or>\n       dma mem\\<^sub>2' x \\<noteq> dma mem\\<^sub>2 x \\<Longrightarrow>\n       \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x", "from sound_modes"], ["proof (chain)\npicking this:\n  sound_mode_use (cms\\<^sub>1, mem\\<^sub>1)\n  sound_mode_use (cms\\<^sub>2, mem\\<^sub>2)", "have loc_modes:\n            \"locally_sound_mode_use (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<and>\n             locally_sound_mode_use (cms\\<^sub>2 ! k, mem\\<^sub>2)\""], ["proof (prove)\nusing this:\n  sound_mode_use (cms\\<^sub>1, mem\\<^sub>1)\n  sound_mode_use (cms\\<^sub>2, mem\\<^sub>2)\n\ngoal (1 subgoal):\n 1. locally_sound_mode_use (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<and>\n    locally_sound_mode_use (cms\\<^sub>2 ! k, mem\\<^sub>2)", "unfolding sound_mode_use.simps"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>cm. locally_sound_mode_use (cm, mem\\<^sub>1))\n   cms\\<^sub>1 \\<and>\n  globally_sound_mode_use (cms\\<^sub>1, mem\\<^sub>1)\n  list_all (\\<lambda>cm. locally_sound_mode_use (cm, mem\\<^sub>2))\n   cms\\<^sub>2 \\<and>\n  globally_sound_mode_use (cms\\<^sub>2, mem\\<^sub>2)\n\ngoal (1 subgoal):\n 1. locally_sound_mode_use (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<and>\n    locally_sound_mode_use (cms\\<^sub>2 ! k, mem\\<^sub>2)", "by (metis b equal_size list_all_length)"], ["proof (state)\nthis:\n  locally_sound_mode_use (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<and>\n  locally_sound_mode_use (cms\\<^sub>2 ! k, mem\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n       mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or>\n       dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x \\<or>\n       dma mem\\<^sub>2' x \\<noteq> dma mem\\<^sub>2 x \\<Longrightarrow>\n       \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x", "moreover"], ["proof (state)\nthis:\n  locally_sound_mode_use (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<and>\n  locally_sound_mode_use (cms\\<^sub>2 ! k, mem\\<^sub>2)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n       mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or>\n       dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x \\<or>\n       dma mem\\<^sub>2' x \\<noteq> dma mem\\<^sub>2 x \\<Longrightarrow>\n       \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x", "have \"snd (cms\\<^sub>1 ! k) = snd (cms\\<^sub>2 ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (cms\\<^sub>1 ! k) = snd (cms\\<^sub>2 ! k)", "by (metis b equal_size modes_eq nth_map)"], ["proof (state)\nthis:\n  snd (cms\\<^sub>1 ! k) = snd (cms\\<^sub>2 ! k)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n       mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or>\n       dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x \\<or>\n       dma mem\\<^sub>2' x \\<noteq> dma mem\\<^sub>2 x \\<Longrightarrow>\n       \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x", "have \"(cms\\<^sub>1 ! k, mem\\<^sub>1) \\<in> loc_reach (cms\\<^sub>1 ! k, mem\\<^sub>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cms\\<^sub>1 ! k, mem\\<^sub>1)\n    \\<in> loc_reach (cms\\<^sub>1 ! k, mem\\<^sub>1)", "using loc_reach.refl"], ["proof (prove)\nusing this:\n  \\<langle>fst (fst ?lc), snd (fst ?lc), snd ?lc\\<rangle>\n  \\<in> loc_reach ?lc\n\ngoal (1 subgoal):\n 1. (cms\\<^sub>1 ! k, mem\\<^sub>1)\n    \\<in> loc_reach (cms\\<^sub>1 ! k, mem\\<^sub>1)", "by auto"], ["proof (state)\nthis:\n  (cms\\<^sub>1 ! k, mem\\<^sub>1)\n  \\<in> loc_reach (cms\\<^sub>1 ! k, mem\\<^sub>1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n       mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or>\n       dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x \\<or>\n       dma mem\\<^sub>2' x \\<noteq> dma mem\\<^sub>2 x \\<Longrightarrow>\n       \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x", "hence guars:\n                \"x \\<in> snd (cms\\<^sub>1 ! k) GuarNoWrite \\<longrightarrow> doesnt_modify (fst (cms\\<^sub>1 ! k)) x \\<and>\n                 x \\<in> snd (cms\\<^sub>2 ! k) GuarNoWrite \\<longrightarrow> doesnt_modify (fst (cms\\<^sub>1 ! k)) x \\<and>\n                 x \\<in> snd (cms\\<^sub>1 ! k) GuarNoReadOrWrite \\<longrightarrow> doesnt_read_or_modify (fst (cms\\<^sub>1 ! k)) x \\<and>\n                 x \\<in> snd (cms\\<^sub>2 ! k) GuarNoReadOrWrite \\<longrightarrow> doesnt_read_or_modify (fst (cms\\<^sub>1 ! k)) x\""], ["proof (prove)\nusing this:\n  (cms\\<^sub>1 ! k, mem\\<^sub>1)\n  \\<in> loc_reach (cms\\<^sub>1 ! k, mem\\<^sub>1)\n\ngoal (1 subgoal):\n 1. x \\<in> snd (cms\\<^sub>1 ! k) GuarNoWrite \\<longrightarrow>\n    doesnt_modify (fst (cms\\<^sub>1 ! k)) x \\<and>\n    x \\<in> snd (cms\\<^sub>2 ! k) GuarNoWrite \\<longrightarrow>\n    doesnt_modify (fst (cms\\<^sub>1 ! k)) x \\<and>\n    x \\<in> snd (cms\\<^sub>1 ! k) GuarNoReadOrWrite \\<longrightarrow>\n    doesnt_read_or_modify (fst (cms\\<^sub>1 ! k)) x \\<and>\n    x \\<in> snd (cms\\<^sub>2 ! k) GuarNoReadOrWrite \\<longrightarrow>\n    doesnt_read_or_modify (fst (cms\\<^sub>1 ! k)) x", "using loc_modes"], ["proof (prove)\nusing this:\n  (cms\\<^sub>1 ! k, mem\\<^sub>1)\n  \\<in> loc_reach (cms\\<^sub>1 ! k, mem\\<^sub>1)\n  locally_sound_mode_use (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<and>\n  locally_sound_mode_use (cms\\<^sub>2 ! k, mem\\<^sub>2)\n\ngoal (1 subgoal):\n 1. x \\<in> snd (cms\\<^sub>1 ! k) GuarNoWrite \\<longrightarrow>\n    doesnt_modify (fst (cms\\<^sub>1 ! k)) x \\<and>\n    x \\<in> snd (cms\\<^sub>2 ! k) GuarNoWrite \\<longrightarrow>\n    doesnt_modify (fst (cms\\<^sub>1 ! k)) x \\<and>\n    x \\<in> snd (cms\\<^sub>1 ! k) GuarNoReadOrWrite \\<longrightarrow>\n    doesnt_read_or_modify (fst (cms\\<^sub>1 ! k)) x \\<and>\n    x \\<in> snd (cms\\<^sub>2 ! k) GuarNoReadOrWrite \\<longrightarrow>\n    doesnt_read_or_modify (fst (cms\\<^sub>1 ! k)) x", "unfolding locally_sound_mode_use_def \\<open>snd (cms\\<^sub>1 ! k) = snd (cms\\<^sub>2 ! k)\\<close>"], ["proof (prove)\nusing this:\n  (cms\\<^sub>1 ! k, mem\\<^sub>1)\n  \\<in> loc_reach (cms\\<^sub>1 ! k, mem\\<^sub>1)\n  (\\<forall>c' mds' mem'.\n      \\<langle>c', mds', mem'\\<rangle>\n      \\<in> loc_reach (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<longrightarrow>\n      (\\<forall>x.\n          (x \\<in> mds' GuarNoReadOrWrite \\<longrightarrow>\n           doesnt_read_or_modify c' x) \\<and>\n          (x \\<in> mds' GuarNoWrite \\<longrightarrow>\n           doesnt_modify c' x))) \\<and>\n  (\\<forall>c' mds' mem'.\n      \\<langle>c', mds', mem'\\<rangle>\n      \\<in> loc_reach (cms\\<^sub>2 ! k, mem\\<^sub>2) \\<longrightarrow>\n      (\\<forall>x.\n          (x \\<in> mds' GuarNoReadOrWrite \\<longrightarrow>\n           doesnt_read_or_modify c' x) \\<and>\n          (x \\<in> mds' GuarNoWrite \\<longrightarrow> doesnt_modify c' x)))\n\ngoal (1 subgoal):\n 1. x \\<in> snd (cms\\<^sub>2 ! k) GuarNoWrite \\<longrightarrow>\n    doesnt_modify (fst (cms\\<^sub>1 ! k)) x \\<and>\n    x \\<in> snd (cms\\<^sub>2 ! k) GuarNoWrite \\<longrightarrow>\n    doesnt_modify (fst (cms\\<^sub>1 ! k)) x \\<and>\n    x \\<in> snd (cms\\<^sub>2 ! k) GuarNoReadOrWrite \\<longrightarrow>\n    doesnt_read_or_modify (fst (cms\\<^sub>1 ! k)) x \\<and>\n    x \\<in> snd (cms\\<^sub>2 ! k) GuarNoReadOrWrite \\<longrightarrow>\n    doesnt_read_or_modify (fst (cms\\<^sub>1 ! k)) x", "by (metis loc_reach.refl surjective_pairing)"], ["proof (state)\nthis:\n  x \\<in> snd (cms\\<^sub>1 ! k) GuarNoWrite \\<longrightarrow>\n  doesnt_modify (fst (cms\\<^sub>1 ! k)) x \\<and>\n  x \\<in> snd (cms\\<^sub>2 ! k) GuarNoWrite \\<longrightarrow>\n  doesnt_modify (fst (cms\\<^sub>1 ! k)) x \\<and>\n  x \\<in> snd (cms\\<^sub>1 ! k) GuarNoReadOrWrite \\<longrightarrow>\n  doesnt_read_or_modify (fst (cms\\<^sub>1 ! k)) x \\<and>\n  x \\<in> snd (cms\\<^sub>2 ! k) GuarNoReadOrWrite \\<longrightarrow>\n  doesnt_read_or_modify (fst (cms\\<^sub>1 ! k)) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n       mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or>\n       dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x \\<or>\n       dma mem\\<^sub>2' x \\<noteq> dma mem\\<^sub>2 x \\<Longrightarrow>\n       \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x", "hence \"x \\<notin> snd (cms\\<^sub>1 ! k) GuarNoWrite \\<and> x \\<notin> snd (cms\\<^sub>1 ! k) GuarNoReadOrWrite\""], ["proof (prove)\nusing this:\n  x \\<in> snd (cms\\<^sub>1 ! k) GuarNoWrite \\<longrightarrow>\n  doesnt_modify (fst (cms\\<^sub>1 ! k)) x \\<and>\n  x \\<in> snd (cms\\<^sub>2 ! k) GuarNoWrite \\<longrightarrow>\n  doesnt_modify (fst (cms\\<^sub>1 ! k)) x \\<and>\n  x \\<in> snd (cms\\<^sub>1 ! k) GuarNoReadOrWrite \\<longrightarrow>\n  doesnt_read_or_modify (fst (cms\\<^sub>1 ! k)) x \\<and>\n  x \\<in> snd (cms\\<^sub>2 ! k) GuarNoReadOrWrite \\<longrightarrow>\n  doesnt_read_or_modify (fst (cms\\<^sub>1 ! k)) x\n\ngoal (1 subgoal):\n 1. x \\<notin> snd (cms\\<^sub>1 ! k) GuarNoWrite \\<and>\n    x \\<notin> snd (cms\\<^sub>1 ! k) GuarNoReadOrWrite", "using modified modified_r loc_modes locally_sound_mode_use_def"], ["proof (prove)\nusing this:\n  x \\<in> snd (cms\\<^sub>1 ! k) GuarNoWrite \\<longrightarrow>\n  doesnt_modify (fst (cms\\<^sub>1 ! k)) x \\<and>\n  x \\<in> snd (cms\\<^sub>2 ! k) GuarNoWrite \\<longrightarrow>\n  doesnt_modify (fst (cms\\<^sub>1 ! k)) x \\<and>\n  x \\<in> snd (cms\\<^sub>1 ! k) GuarNoReadOrWrite \\<longrightarrow>\n  doesnt_read_or_modify (fst (cms\\<^sub>1 ! k)) x \\<and>\n  x \\<in> snd (cms\\<^sub>2 ! k) GuarNoReadOrWrite \\<longrightarrow>\n  doesnt_read_or_modify (fst (cms\\<^sub>1 ! k)) x\n  \\<not> doesnt_modify (fst (cms\\<^sub>1 ! k)) x \\<or>\n  \\<not> doesnt_modify (fst (cms\\<^sub>2 ! k)) x\n  \\<not> doesnt_read_or_modify (fst (cms\\<^sub>1 ! k)) x \\<or>\n  \\<not> doesnt_read_or_modify (fst (cms\\<^sub>2 ! k)) x\n  locally_sound_mode_use (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<and>\n  locally_sound_mode_use (cms\\<^sub>2 ! k, mem\\<^sub>2)\n  locally_sound_mode_use ?lc =\n  (\\<forall>c' mds' mem'.\n      \\<langle>c', mds', mem'\\<rangle> \\<in> loc_reach ?lc \\<longrightarrow>\n      (\\<forall>x.\n          (x \\<in> mds' GuarNoReadOrWrite \\<longrightarrow>\n           doesnt_read_or_modify c' x) \\<and>\n          (x \\<in> mds' GuarNoWrite \\<longrightarrow> doesnt_modify c' x)))\n\ngoal (1 subgoal):\n 1. x \\<notin> snd (cms\\<^sub>1 ! k) GuarNoWrite \\<and>\n    x \\<notin> snd (cms\\<^sub>1 ! k) GuarNoReadOrWrite", "by (metis (no_types, lifting) \\<open>(cms\\<^sub>2, mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2', mem\\<^sub>2')\\<close> b locally_sound_respects_guarantees modes_eq nth_map meval_elim respects_own_guarantees_def sifum_security_init_axioms)"], ["proof (state)\nthis:\n  x \\<notin> snd (cms\\<^sub>1 ! k) GuarNoWrite \\<and>\n  x \\<notin> snd (cms\\<^sub>1 ! k) GuarNoReadOrWrite\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n       mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or>\n       dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x \\<or>\n       dma mem\\<^sub>2' x \\<noteq> dma mem\\<^sub>2 x \\<Longrightarrow>\n       \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x", "moreover"], ["proof (state)\nthis:\n  x \\<notin> snd (cms\\<^sub>1 ! k) GuarNoWrite \\<and>\n  x \\<notin> snd (cms\\<^sub>1 ! k) GuarNoReadOrWrite\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n       mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or>\n       dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x \\<or>\n       dma mem\\<^sub>2' x \\<noteq> dma mem\\<^sub>2 x \\<Longrightarrow>\n       \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x", "from sound_modes"], ["proof (chain)\npicking this:\n  sound_mode_use (cms\\<^sub>1, mem\\<^sub>1)\n  sound_mode_use (cms\\<^sub>2, mem\\<^sub>2)", "have \"compatible_modes (map snd cms\\<^sub>1)\""], ["proof (prove)\nusing this:\n  sound_mode_use (cms\\<^sub>1, mem\\<^sub>1)\n  sound_mode_use (cms\\<^sub>2, mem\\<^sub>2)\n\ngoal (1 subgoal):\n 1. compatible_modes (map snd cms\\<^sub>1)", "by (metis globally_sound_modes_compatible sound_mode_use.simps)"], ["proof (state)\nthis:\n  compatible_modes (map snd cms\\<^sub>1)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n       mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or>\n       dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x \\<or>\n       dma mem\\<^sub>2' x \\<noteq> dma mem\\<^sub>2 x \\<Longrightarrow>\n       \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x", "ultimately"], ["proof (chain)\npicking this:\n  locally_sound_mode_use (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<and>\n  locally_sound_mode_use (cms\\<^sub>2 ! k, mem\\<^sub>2)\n  x \\<notin> snd (cms\\<^sub>1 ! k) GuarNoWrite \\<and>\n  x \\<notin> snd (cms\\<^sub>1 ! k) GuarNoReadOrWrite\n  compatible_modes (map snd cms\\<^sub>1)", "show \"(?thesis x)\""], ["proof (prove)\nusing this:\n  locally_sound_mode_use (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<and>\n  locally_sound_mode_use (cms\\<^sub>2 ! k, mem\\<^sub>2)\n  x \\<notin> snd (cms\\<^sub>1 ! k) GuarNoWrite \\<and>\n  x \\<notin> snd (cms\\<^sub>1 ! k) GuarNoReadOrWrite\n  compatible_modes (map snd cms\\<^sub>1)\n\ngoal (1 subgoal):\n 1. \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x", "unfolding compatible_modes_def var_asm_not_written_def"], ["proof (prove)\nusing this:\n  locally_sound_mode_use (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<and>\n  locally_sound_mode_use (cms\\<^sub>2 ! k, mem\\<^sub>2)\n  x \\<notin> snd (cms\\<^sub>1 ! k) GuarNoWrite \\<and>\n  x \\<notin> snd (cms\\<^sub>1 ! k) GuarNoReadOrWrite\n  \\<forall>i x.\n     i < length (map snd cms\\<^sub>1) \\<longrightarrow>\n     (x \\<in> (map snd cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n      (\\<forall>j<length (map snd cms\\<^sub>1).\n          j \\<noteq> i \\<longrightarrow>\n          x \\<in> (map snd cms\\<^sub>1 ! j) GuarNoReadOrWrite)) \\<and>\n     (x \\<in> (map snd cms\\<^sub>1 ! i) AsmNoWrite \\<longrightarrow>\n      (\\<forall>j<length (map snd cms\\<^sub>1).\n          j \\<noteq> i \\<longrightarrow>\n          x \\<in> (map snd cms\\<^sub>1 ! j) GuarNoWrite))\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<in> snd (cms\\<^sub>1 ! i) AsmNoWrite \\<or>\n            x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite)", "using \\<open>i \\<noteq> k\\<close> i_le"], ["proof (prove)\nusing this:\n  locally_sound_mode_use (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<and>\n  locally_sound_mode_use (cms\\<^sub>2 ! k, mem\\<^sub>2)\n  x \\<notin> snd (cms\\<^sub>1 ! k) GuarNoWrite \\<and>\n  x \\<notin> snd (cms\\<^sub>1 ! k) GuarNoReadOrWrite\n  \\<forall>i x.\n     i < length (map snd cms\\<^sub>1) \\<longrightarrow>\n     (x \\<in> (map snd cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n      (\\<forall>j<length (map snd cms\\<^sub>1).\n          j \\<noteq> i \\<longrightarrow>\n          x \\<in> (map snd cms\\<^sub>1 ! j) GuarNoReadOrWrite)) \\<and>\n     (x \\<in> (map snd cms\\<^sub>1 ! i) AsmNoWrite \\<longrightarrow>\n      (\\<forall>j<length (map snd cms\\<^sub>1).\n          j \\<noteq> i \\<longrightarrow>\n          x \\<in> (map snd cms\\<^sub>1 ! j) GuarNoWrite))\n  i \\<noteq> k\n  i < length cms\\<^sub>1'\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<in> snd (cms\\<^sub>1 ! i) AsmNoWrite \\<or>\n            x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite)", "by (metis (no_types) b length_list_update length_map nth_map)"], ["proof (state)\nthis:\n  \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mem\\<^sub>1' ?x5 \\<noteq> mem\\<^sub>1 ?x5 \\<or>\n  mem\\<^sub>2' ?x5 \\<noteq> mem\\<^sub>2 ?x5 \\<or>\n  dma mem\\<^sub>1' ?x5 \\<noteq> dma mem\\<^sub>1 ?x5 \\<or>\n  dma mem\\<^sub>2' ?x5 \\<noteq> dma mem\\<^sub>2 ?x5 \\<Longrightarrow>\n  \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) ?x5\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "from o o_downgrade"], ["proof (chain)\npicking this:\n  (subst \\<sigma> (fst (mems' ! i)) ?x5 \\<noteq>\n   subst \\<sigma>' (fst (mems ! i)) ?x5 \\<or>\n   subst \\<sigma> (snd (mems' ! i)) ?x5 \\<noteq>\n   subst \\<sigma>' (snd (mems ! i)) ?x5) \\<and>\n  (dma mem\\<^sub>1 ?x5 = Low \\<or> dma mem\\<^sub>1' ?x5 = High) \\<and>\n  dma mem\\<^sub>1' ?x5 = dma mem\\<^sub>1 ?x5 \\<longrightarrow>\n  mem\\<^sub>1' ?x5 \\<noteq> mem\\<^sub>1 ?x5 \\<or>\n  mem\\<^sub>2' ?x5 \\<noteq> mem\\<^sub>2 ?x5\n  ?x5 \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i \\<and>\n  (subst \\<sigma> (fst (mems' ! i)) ?x5 \\<noteq>\n   subst \\<sigma>' (fst (mems ! i)) ?x5 \\<or>\n   subst \\<sigma> (snd (mems' ! i)) ?x5 \\<noteq>\n   subst \\<sigma>' (snd (mems ! i)) ?x5) \\<and>\n  dma mem\\<^sub>1 ?x5 = High \\<and>\n  dma mem\\<^sub>1' ?x5 = Low \\<longrightarrow>\n  mem\\<^sub>1' ?x5 \\<noteq> mem\\<^sub>1 ?x5 \\<or>\n  mem\\<^sub>2' ?x5 \\<noteq> mem\\<^sub>2 ?x5", "have\n          p: \"\\<And> x. \\<lbrakk> ?mems\\<^sub>1'i [\\<mapsto> \\<sigma>] x \\<noteq> ?mems\\<^sub>1i [\\<mapsto> \\<sigma>'] x \\<or>\n                      ?mems\\<^sub>2'i [\\<mapsto> \\<sigma>] x \\<noteq> ?mems\\<^sub>2i [\\<mapsto> \\<sigma>'] x;\n                     x \\<notin> ?X' i \\<or> ((dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n                                   (dma mem\\<^sub>1' x = dma mem\\<^sub>1 x)) \\<rbrakk> \\<Longrightarrow>\n          \\<not> var_asm_not_written  (snd (cms\\<^sub>1 ! i)) x\""], ["proof (prove)\nusing this:\n  (subst \\<sigma> (fst (mems' ! i)) ?x5 \\<noteq>\n   subst \\<sigma>' (fst (mems ! i)) ?x5 \\<or>\n   subst \\<sigma> (snd (mems' ! i)) ?x5 \\<noteq>\n   subst \\<sigma>' (snd (mems ! i)) ?x5) \\<and>\n  (dma mem\\<^sub>1 ?x5 = Low \\<or> dma mem\\<^sub>1' ?x5 = High) \\<and>\n  dma mem\\<^sub>1' ?x5 = dma mem\\<^sub>1 ?x5 \\<longrightarrow>\n  mem\\<^sub>1' ?x5 \\<noteq> mem\\<^sub>1 ?x5 \\<or>\n  mem\\<^sub>2' ?x5 \\<noteq> mem\\<^sub>2 ?x5\n  ?x5 \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i \\<and>\n  (subst \\<sigma> (fst (mems' ! i)) ?x5 \\<noteq>\n   subst \\<sigma>' (fst (mems ! i)) ?x5 \\<or>\n   subst \\<sigma> (snd (mems' ! i)) ?x5 \\<noteq>\n   subst \\<sigma>' (snd (mems ! i)) ?x5) \\<and>\n  dma mem\\<^sub>1 ?x5 = High \\<and>\n  dma mem\\<^sub>1' ?x5 = Low \\<longrightarrow>\n  mem\\<^sub>1' ?x5 \\<noteq> mem\\<^sub>1 ?x5 \\<or>\n  mem\\<^sub>2' ?x5 \\<noteq> mem\\<^sub>2 ?x5\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (fst (mems ! i)) x \\<or>\n                subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (snd (mems ! i)) x;\n        x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                    i \\<or>\n        (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n        dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\\<rbrakk>\n       \\<Longrightarrow> \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i))\n                                 x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (fst (mems ! i)) x \\<or>\n                subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (snd (mems ! i)) x;\n        x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                    i \\<or>\n        (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n        dma mem\\<^sub>1' x = dma mem\\<^sub>1 x;\n        \\<And>x.\n           (subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n            subst \\<sigma>' (fst (mems ! i)) x \\<or>\n            subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n            subst \\<sigma>' (snd (mems ! i)) x) \\<and>\n           (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n           dma mem\\<^sub>1' x = dma mem\\<^sub>1 x \\<longrightarrow>\n           mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n           mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x;\n        \\<And>x.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i \\<and>\n           (subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n            subst \\<sigma>' (fst (mems ! i)) x \\<or>\n            subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n            subst \\<sigma>' (snd (mems ! i)) x) \\<and>\n           dma mem\\<^sub>1 x = High \\<and>\n           dma mem\\<^sub>1' x = Low \\<longrightarrow>\n           mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n           mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x\\<rbrakk>\n       \\<Longrightarrow> \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i))\n                                 x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (fst (mems ! i)) x \\<or>\n                subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (snd (mems ! i)) x;\n        x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                    i \\<or>\n        (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n        dma mem\\<^sub>1' x = dma mem\\<^sub>1 x;\n        \\<And>x.\n           (subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n            subst \\<sigma>' (fst (mems ! i)) x \\<or>\n            subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n            subst \\<sigma>' (snd (mems ! i)) x) \\<and>\n           (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n           dma mem\\<^sub>1' x = dma mem\\<^sub>1 x \\<longrightarrow>\n           mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n           mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x;\n        \\<And>x.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i \\<and>\n           (subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n            subst \\<sigma>' (fst (mems ! i)) x \\<or>\n            subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n            subst \\<sigma>' (snd (mems ! i)) x) \\<and>\n           dma mem\\<^sub>1 x = High \\<and>\n           dma mem\\<^sub>1' x = Low \\<longrightarrow>\n           mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n           mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x\\<rbrakk>\n       \\<Longrightarrow> \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i))\n                                 x", "assume mems_neq:\n            \"?mems\\<^sub>1'i [\\<mapsto> \\<sigma>] x \\<noteq> ?mems\\<^sub>1i [\\<mapsto> \\<sigma>'] x \\<or> ?mems\\<^sub>2'i [\\<mapsto> \\<sigma>] x \\<noteq> ?mems\\<^sub>2i [\\<mapsto> \\<sigma>'] x\"\n             and nin:\n            \"x \\<notin> ?X' i \\<or> ((dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n                           (dma mem\\<^sub>1' x = dma mem\\<^sub>1 x))\""], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n  subst \\<sigma>' (fst (mems ! i)) x \\<or>\n  subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n  subst \\<sigma>' (snd (mems ! i)) x\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i \\<or>\n  (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n  dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (fst (mems ! i)) x \\<or>\n                subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (snd (mems ! i)) x;\n        x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                    i \\<or>\n        (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n        dma mem\\<^sub>1' x = dma mem\\<^sub>1 x;\n        \\<And>x.\n           (subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n            subst \\<sigma>' (fst (mems ! i)) x \\<or>\n            subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n            subst \\<sigma>' (snd (mems ! i)) x) \\<and>\n           (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n           dma mem\\<^sub>1' x = dma mem\\<^sub>1 x \\<longrightarrow>\n           mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n           mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x;\n        \\<And>x.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i \\<and>\n           (subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n            subst \\<sigma>' (fst (mems ! i)) x \\<or>\n            subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n            subst \\<sigma>' (snd (mems ! i)) x) \\<and>\n           dma mem\\<^sub>1 x = High \\<and>\n           dma mem\\<^sub>1' x = Low \\<longrightarrow>\n           mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n           mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x\\<rbrakk>\n       \\<Longrightarrow> \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i))\n                                 x", "hence \"mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or> mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or> dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x\""], ["proof (prove)\nusing this:\n  subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n  subst \\<sigma>' (fst (mems ! i)) x \\<or>\n  subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n  subst \\<sigma>' (snd (mems ! i)) x\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i \\<or>\n  (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n  dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\n\ngoal (1 subgoal):\n 1. mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n    mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or>\n    dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x", "(* FIXME: clean this up *)"], ["proof (prove)\nusing this:\n  subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n  subst \\<sigma>' (fst (mems ! i)) x \\<or>\n  subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n  subst \\<sigma>' (snd (mems ! i)) x\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i \\<or>\n  (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n  dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\n\ngoal (1 subgoal):\n 1. mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n    mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or>\n    dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n             subst \\<sigma>' (fst (mems ! i)) x \\<or>\n             subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n             subst \\<sigma>' (snd (mems ! i)) x;\n     x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i \\<or>\n     (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n     dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\\<rbrakk>\n    \\<Longrightarrow> mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n                      mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or>\n                      dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x", "apply(erule disjE[where P=\"x \\<notin> ?X' i\"])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n             subst \\<sigma>' (fst (mems ! i)) x \\<or>\n             subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n             subst \\<sigma>' (snd (mems ! i)) x;\n     x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                 i\\<rbrakk>\n    \\<Longrightarrow> mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n                      mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or>\n                      dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x\n 2. \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n             subst \\<sigma>' (fst (mems ! i)) x \\<or>\n             subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n             subst \\<sigma>' (snd (mems ! i)) x;\n     (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n     dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\\<rbrakk>\n    \\<Longrightarrow> mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n                      mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or>\n                      dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x", "apply(case_tac \"(dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low)\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n             subst \\<sigma>' (fst (mems ! i)) x \\<or>\n             subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n             subst \\<sigma>' (snd (mems ! i)) x;\n     x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i;\n     dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low\\<rbrakk>\n    \\<Longrightarrow> mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n                      mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or>\n                      dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x\n 2. \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n             subst \\<sigma>' (fst (mems ! i)) x \\<or>\n             subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n             subst \\<sigma>' (snd (mems ! i)) x;\n     x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i;\n     \\<not> (dma mem\\<^sub>1 x = High \\<and>\n             dma mem\\<^sub>1' x = Low)\\<rbrakk>\n    \\<Longrightarrow> mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n                      mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or>\n                      dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x\n 3. \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n             subst \\<sigma>' (fst (mems ! i)) x \\<or>\n             subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n             subst \\<sigma>' (snd (mems ! i)) x;\n     (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n     dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\\<rbrakk>\n    \\<Longrightarrow> mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n                      mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or>\n                      dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x", "apply(metis o_downgrade[rule_format])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n             subst \\<sigma>' (fst (mems ! i)) x \\<or>\n             subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n             subst \\<sigma>' (snd (mems ! i)) x;\n     x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i;\n     \\<not> (dma mem\\<^sub>1 x = High \\<and>\n             dma mem\\<^sub>1' x = Low)\\<rbrakk>\n    \\<Longrightarrow> mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n                      mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or>\n                      dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x\n 2. \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n             subst \\<sigma>' (fst (mems ! i)) x \\<or>\n             subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n             subst \\<sigma>' (snd (mems ! i)) x;\n     (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n     dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\\<rbrakk>\n    \\<Longrightarrow> mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n                      mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or>\n                      dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x", "apply(case_tac \"dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n             subst \\<sigma>' (fst (mems ! i)) x \\<or>\n             subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n             subst \\<sigma>' (snd (mems ! i)) x;\n     x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i;\n     \\<not> (dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low);\n     dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\\<rbrakk>\n    \\<Longrightarrow> mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n                      mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or>\n                      dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x\n 2. \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n             subst \\<sigma>' (fst (mems ! i)) x \\<or>\n             subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n             subst \\<sigma>' (snd (mems ! i)) x;\n     x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i;\n     \\<not> (dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low);\n     dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x\\<rbrakk>\n    \\<Longrightarrow> mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n                      mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or>\n                      dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x\n 3. \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n             subst \\<sigma>' (fst (mems ! i)) x \\<or>\n             subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n             subst \\<sigma>' (snd (mems ! i)) x;\n     (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n     dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\\<rbrakk>\n    \\<Longrightarrow> mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n                      mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or>\n                      dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x", "(* use o *)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n             subst \\<sigma>' (fst (mems ! i)) x \\<or>\n             subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n             subst \\<sigma>' (snd (mems ! i)) x;\n     x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i;\n     \\<not> (dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low);\n     dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\\<rbrakk>\n    \\<Longrightarrow> mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n                      mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or>\n                      dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x\n 2. \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n             subst \\<sigma>' (fst (mems ! i)) x \\<or>\n             subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n             subst \\<sigma>' (snd (mems ! i)) x;\n     x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i;\n     \\<not> (dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low);\n     dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x\\<rbrakk>\n    \\<Longrightarrow> mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n                      mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or>\n                      dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x\n 3. \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n             subst \\<sigma>' (fst (mems ! i)) x \\<or>\n             subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n             subst \\<sigma>' (snd (mems ! i)) x;\n     (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n     dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\\<rbrakk>\n    \\<Longrightarrow> mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n                      mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or>\n                      dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x", "apply(metis (poly_guards_query) o Sec.exhaust)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n             subst \\<sigma>' (fst (mems ! i)) x \\<or>\n             subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n             subst \\<sigma>' (snd (mems ! i)) x;\n     x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i;\n     \\<not> (dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low);\n     dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x\\<rbrakk>\n    \\<Longrightarrow> mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n                      mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or>\n                      dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x\n 2. \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n             subst \\<sigma>' (fst (mems ! i)) x \\<or>\n             subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n             subst \\<sigma>' (snd (mems ! i)) x;\n     (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n     dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\\<rbrakk>\n    \\<Longrightarrow> mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n                      mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or>\n                      dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x", "(* should follow trivially *)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n             subst \\<sigma>' (fst (mems ! i)) x \\<or>\n             subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n             subst \\<sigma>' (snd (mems ! i)) x;\n     x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i;\n     \\<not> (dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low);\n     dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x\\<rbrakk>\n    \\<Longrightarrow> mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n                      mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or>\n                      dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x\n 2. \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n             subst \\<sigma>' (fst (mems ! i)) x \\<or>\n             subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n             subst \\<sigma>' (snd (mems ! i)) x;\n     (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n     dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\\<rbrakk>\n    \\<Longrightarrow> mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n                      mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or>\n                      dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n             subst \\<sigma>' (fst (mems ! i)) x \\<or>\n             subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n             subst \\<sigma>' (snd (mems ! i)) x;\n     (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n     dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\\<rbrakk>\n    \\<Longrightarrow> mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n                      mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or>\n                      dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x", "apply(metis (poly_guards_query) o Sec.exhaust)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n  mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or>\n  dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (fst (mems ! i)) x \\<or>\n                subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n                subst \\<sigma>' (snd (mems ! i)) x;\n        x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                    i \\<or>\n        (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n        dma mem\\<^sub>1' x = dma mem\\<^sub>1 x;\n        \\<And>x.\n           (subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n            subst \\<sigma>' (fst (mems ! i)) x \\<or>\n            subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n            subst \\<sigma>' (snd (mems ! i)) x) \\<and>\n           (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n           dma mem\\<^sub>1' x = dma mem\\<^sub>1 x \\<longrightarrow>\n           mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n           mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x;\n        \\<And>x.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i \\<and>\n           (subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n            subst \\<sigma>' (fst (mems ! i)) x \\<or>\n            subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n            subst \\<sigma>' (snd (mems ! i)) x) \\<and>\n           dma mem\\<^sub>1 x = High \\<and>\n           dma mem\\<^sub>1' x = Low \\<longrightarrow>\n           mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n           mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x\\<rbrakk>\n       \\<Longrightarrow> \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i))\n                                 x", "thus \"?thesis x\""], ["proof (prove)\nusing this:\n  mem\\<^sub>1' x \\<noteq> mem\\<^sub>1 x \\<or>\n  mem\\<^sub>2' x \\<noteq> mem\\<^sub>2 x \\<or>\n  dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x\n\ngoal (1 subgoal):\n 1. \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x", "by(force simp: modifies_no_var_asm_not_written)"], ["proof (state)\nthis:\n  \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) ?x5 \\<noteq>\n           subst \\<sigma>' (fst (mems ! i)) ?x5 \\<or>\n           subst \\<sigma> (snd (mems' ! i)) ?x5 \\<noteq>\n           subst \\<sigma>' (snd (mems ! i)) ?x5;\n   ?x5 \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i \\<or>\n   (dma mem\\<^sub>1 ?x5 = Low \\<or> dma mem\\<^sub>1' ?x5 = High) \\<and>\n   dma mem\\<^sub>1' ?x5 = dma mem\\<^sub>1 ?x5\\<rbrakk>\n  \\<Longrightarrow> \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) ?x5\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "have q':\n          \"\\<And> x. \\<lbrakk> dma mem\\<^sub>1 x = Low; dma mem\\<^sub>1' x = Low;\n                   ?mems\\<^sub>1'i [\\<mapsto> \\<sigma>] x \\<noteq> ?mems\\<^sub>1i [\\<mapsto> \\<sigma>'] x \\<or>\n                   ?mems\\<^sub>2'i [\\<mapsto> \\<sigma>] x \\<noteq> ?mems\\<^sub>2i [\\<mapsto> \\<sigma>'] x;\n                   x \\<notin> ?X' i \\<rbrakk> \\<Longrightarrow>\n                 mem\\<^sub>1' x = mem\\<^sub>2' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1 x = Low; dma mem\\<^sub>1' x = Low;\n        subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (fst (mems ! i)) x \\<or>\n        subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (snd (mems ! i)) x;\n        x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                    i\\<rbrakk>\n       \\<Longrightarrow> mem\\<^sub>1' x = mem\\<^sub>2' x", "by (metis \\<open>i \\<noteq> k\\<close> b compat_different_vars i_le length_list_update mems'_i_2 o)"], ["proof (state)\nthis:\n  \\<lbrakk>dma mem\\<^sub>1 ?x5 = Low; dma mem\\<^sub>1' ?x5 = Low;\n   subst \\<sigma> (fst (mems' ! i)) ?x5 \\<noteq>\n   subst \\<sigma>' (fst (mems ! i)) ?x5 \\<or>\n   subst \\<sigma> (snd (mems' ! i)) ?x5 \\<noteq>\n   subst \\<sigma>' (snd (mems ! i)) ?x5;\n   ?x5\n   \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\\<rbrakk>\n  \\<Longrightarrow> mem\\<^sub>1' ?x5 = mem\\<^sub>2' ?x5\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "have \"i < length cms\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < length cms\\<^sub>1", "by (metis cms\\<^sub>2'_def equal_size i_le length_list_update new_length)"], ["proof (state)\nthis:\n  i < length cms\\<^sub>1\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "with compat and \\<open>dom \\<sigma>' = ?X i\\<close>"], ["proof (chain)\npicking this:\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  dom \\<sigma>' = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n  i < length cms\\<^sub>1", "have\n          bisim: \"(cms\\<^sub>1 ! i, ?mems\\<^sub>1i [\\<mapsto> \\<sigma>']) \\<approx> (cms\\<^sub>2 ! i, ?mems\\<^sub>2i [\\<mapsto> \\<sigma>'])\""], ["proof (prove)\nusing this:\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  dom \\<sigma>' = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n  i < length cms\\<^sub>1\n\ngoal (1 subgoal):\n 1. (cms\\<^sub>1 ! i, subst \\<sigma>' (fst (mems ! i))) \\<approx>\n    (cms\\<^sub>2 ! i, subst \\<sigma>' (snd (mems ! i)))", "by auto"], ["proof (state)\nthis:\n  (cms\\<^sub>1 ! i, subst \\<sigma>' (fst (mems ! i))) \\<approx>\n  (cms\\<^sub>2 ! i, subst \\<sigma>' (snd (mems ! i)))\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "define \\<sigma>'\\<^sub>k where \"\\<sigma>'\\<^sub>k x = (if x \\<in> ?X k then Some (undefined::'Val) else None)\" for x"], ["proof (state)\nthis:\n  \\<sigma>'\\<^sub>k ?x =\n  (if ?x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n   then Some undefined else None)\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "have \"dom \\<sigma>'\\<^sub>k = ?X k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom \\<sigma>'\\<^sub>k =\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k", "unfolding \\<sigma>'\\<^sub>k_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. dom (\\<lambda>x.\n            if x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n            then Some undefined else None) =\n    differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k", "by (simp add: dom_def)"], ["proof (state)\nthis:\n  dom \\<sigma>'\\<^sub>k =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "with compat and \\<open>dom \\<sigma>'\\<^sub>k = ?X k\\<close> and b"], ["proof (chain)\npicking this:\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  dom \\<sigma>'\\<^sub>k =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n  k < length cms\\<^sub>1 \\<and>\n  (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto>\n  (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n  cms\\<^sub>1' = cms\\<^sub>1[k := cms\\<^sub>1' ! k]\n  dom \\<sigma>'\\<^sub>k =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k", "have\n          bisim\\<^sub>k: \"(cms\\<^sub>1 ! k, ?mems\\<^sub>1k [\\<mapsto> \\<sigma>'\\<^sub>k]) \\<approx> (cms\\<^sub>2 ! k, ?mems\\<^sub>2k [\\<mapsto> \\<sigma>'\\<^sub>k])\""], ["proof (prove)\nusing this:\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  dom \\<sigma>'\\<^sub>k =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n  k < length cms\\<^sub>1 \\<and>\n  (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto>\n  (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n  cms\\<^sub>1' = cms\\<^sub>1[k := cms\\<^sub>1' ! k]\n  dom \\<sigma>'\\<^sub>k =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\n\ngoal (1 subgoal):\n 1. (cms\\<^sub>1 ! k, subst \\<sigma>'\\<^sub>k (fst (mems ! k))) \\<approx>\n    (cms\\<^sub>2 ! k, subst \\<sigma>'\\<^sub>k (snd (mems ! k)))", "by auto"], ["proof (state)\nthis:\n  (cms\\<^sub>1 ! k, subst \\<sigma>'\\<^sub>k (fst (mems ! k))) \\<approx>\n  (cms\\<^sub>2 ! k, subst \\<sigma>'\\<^sub>k (snd (mems ! k)))\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "have q_downgrade:\n          \"\\<And> x. \\<lbrakk> dma mem\\<^sub>1 x = High; dma mem\\<^sub>1' x = Low;\n                   ?mems\\<^sub>1'i [\\<mapsto> \\<sigma>] x \\<noteq> ?mems\\<^sub>1i [\\<mapsto> \\<sigma>'] x \\<or>\n                   ?mems\\<^sub>2'i [\\<mapsto> \\<sigma>] x \\<noteq> ?mems\\<^sub>2i [\\<mapsto> \\<sigma>'] x;\n                   x \\<notin> ?X' i \\<rbrakk> \\<Longrightarrow>\n                 mem\\<^sub>1' x = mem\\<^sub>2' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1 x = High; dma mem\\<^sub>1' x = Low;\n        subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (fst (mems ! i)) x \\<or>\n        subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (snd (mems ! i)) x;\n        x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                    i\\<rbrakk>\n       \\<Longrightarrow> mem\\<^sub>1' x = mem\\<^sub>2' x", "by (metis (erased, hide_lams) \\<open>i \\<noteq> k\\<close> compat_different_vars i_le len_unchanged mems'_i_2 o_downgrade)"], ["proof (state)\nthis:\n  \\<lbrakk>dma mem\\<^sub>1 ?x5 = High; dma mem\\<^sub>1' ?x5 = Low;\n   subst \\<sigma> (fst (mems' ! i)) ?x5 \\<noteq>\n   subst \\<sigma>' (fst (mems ! i)) ?x5 \\<or>\n   subst \\<sigma> (snd (mems' ! i)) ?x5 \\<noteq>\n   subst \\<sigma>' (snd (mems ! i)) ?x5;\n   ?x5\n   \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\\<rbrakk>\n  \\<Longrightarrow> mem\\<^sub>1' ?x5 = mem\\<^sub>2' ?x5\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "have q: \"\\<And> x. \\<lbrakk> dma mem\\<^sub>1' x = Low;\n                   ?mems\\<^sub>1'i [\\<mapsto> \\<sigma>] x \\<noteq> ?mems\\<^sub>1i [\\<mapsto> \\<sigma>'] x \\<or>\n                   ?mems\\<^sub>2'i [\\<mapsto> \\<sigma>] x \\<noteq> ?mems\\<^sub>2i [\\<mapsto> \\<sigma>'] x;\n                   x \\<notin> ?X' i \\<rbrakk> \\<Longrightarrow>\n                 mem\\<^sub>1' x = mem\\<^sub>2' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (fst (mems ! i)) x \\<or>\n        subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (snd (mems ! i)) x;\n        x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                    i\\<rbrakk>\n       \\<Longrightarrow> mem\\<^sub>1' x = mem\\<^sub>2' x", "apply(case_tac \"dma mem\\<^sub>1 x\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (fst (mems ! i)) x \\<or>\n        subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (snd (mems ! i)) x;\n        x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i;\n        dma mem\\<^sub>1 x = High\\<rbrakk>\n       \\<Longrightarrow> mem\\<^sub>1' x = mem\\<^sub>2' x\n 2. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (fst (mems ! i)) x \\<or>\n        subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (snd (mems ! i)) x;\n        x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i;\n        dma mem\\<^sub>1 x = Low\\<rbrakk>\n       \\<Longrightarrow> mem\\<^sub>1' x = mem\\<^sub>2' x", "apply(blast intro: q_downgrade)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (fst (mems ! i)) x \\<or>\n        subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n        subst \\<sigma>' (snd (mems ! i)) x;\n        x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i;\n        dma mem\\<^sub>1 x = Low\\<rbrakk>\n       \\<Longrightarrow> mem\\<^sub>1' x = mem\\<^sub>2' x", "by(blast intro: q')"], ["proof (state)\nthis:\n  \\<lbrakk>dma mem\\<^sub>1' ?x5 = Low;\n   subst \\<sigma> (fst (mems' ! i)) ?x5 \\<noteq>\n   subst \\<sigma>' (fst (mems ! i)) ?x5 \\<or>\n   subst \\<sigma> (snd (mems' ! i)) ?x5 \\<noteq>\n   subst \\<sigma>' (snd (mems ! i)) ?x5;\n   ?x5\n   \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\\<rbrakk>\n  \\<Longrightarrow> mem\\<^sub>1' ?x5 = mem\\<^sub>2' ?x5\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "let ?\\<Delta> = \"differing_vars (?mems\\<^sub>1i [\\<mapsto> \\<sigma>']) (?mems\\<^sub>1'i [\\<mapsto> \\<sigma>]) \\<union>\n                  differing_vars (?mems\\<^sub>2i [\\<mapsto> \\<sigma>']) (?mems\\<^sub>2'i [\\<mapsto> \\<sigma>])\""], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "have \\<Delta>_finite: \"finite ?\\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite\n     (differing_vars (subst \\<sigma>' (fst (mems ! i)))\n       (subst \\<sigma> (fst (mems' ! i))) \\<union>\n      differing_vars (subst \\<sigma>' (snd (mems ! i)))\n       (subst \\<sigma> (snd (mems' ! i))))", "by (metis (no_types) differing_finite finite_UnI)\n        \\<comment> \\<open>We first define the adaptation, then prove that it does the right thing.\\<close>"], ["proof (state)\nthis:\n  finite\n   (differing_vars (subst \\<sigma>' (fst (mems ! i)))\n     (subst \\<sigma> (fst (mems' ! i))) \\<union>\n    differing_vars (subst \\<sigma>' (snd (mems ! i)))\n     (subst \\<sigma> (snd (mems' ! i))))\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "define A where \"A x =\n             (if x \\<in> ?\\<Delta>\n              then if dma (?mems\\<^sub>1'i [\\<mapsto> \\<sigma>]) x = High\n                   then Some (?mems\\<^sub>1'i [\\<mapsto> \\<sigma>] x, ?mems\\<^sub>2'i [\\<mapsto> \\<sigma>] x)\n                   else if x \\<in> ?X' i\n                        then (case \\<sigma> x of\n                                Some v \\<Rightarrow> Some (v, v)\n                              | None \\<Rightarrow> None)\n                        else Some (mem\\<^sub>1' x, mem\\<^sub>1' x)\n              else None)\" for x"], ["proof (state)\nthis:\n  A ?x =\n  (if ?x \\<in> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                (subst \\<sigma> (fst (mems' ! i))) \\<union>\n               differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                (subst \\<sigma> (snd (mems' ! i)))\n   then if dma (subst \\<sigma> (fst (mems' ! i))) ?x = High\n        then Some\n              (subst \\<sigma> (fst (mems' ! i)) ?x,\n               subst \\<sigma> (snd (mems' ! i)) ?x)\n        else if ?x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2'\n                          mems' i\n             then case \\<sigma> ?x of None \\<Rightarrow> None\n                  | Some v \\<Rightarrow> Some (v, v)\n             else Some (mem\\<^sub>1' ?x, mem\\<^sub>1' ?x)\n   else None)\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "have domA: \"dom A = ?\\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom A =\n    differing_vars (subst \\<sigma>' (fst (mems ! i)))\n     (subst \\<sigma> (fst (mems' ! i))) \\<union>\n    differing_vars (subst \\<sigma>' (snd (mems ! i)))\n     (subst \\<sigma> (snd (mems' ! i)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. dom A\n    \\<subseteq> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                 (subst \\<sigma> (fst (mems' ! i))) \\<union>\n                differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                 (subst \\<sigma> (snd (mems' ! i)))\n 2. differing_vars (subst \\<sigma>' (fst (mems ! i)))\n     (subst \\<sigma> (fst (mems' ! i))) \\<union>\n    differing_vars (subst \\<sigma>' (snd (mems ! i)))\n     (subst \\<sigma> (snd (mems' ! i)))\n    \\<subseteq> dom A", "show \"dom A \\<subseteq> ?\\<Delta>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dom A\n    \\<subseteq> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                 (subst \\<sigma> (fst (mems' ! i))) \\<union>\n                differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                 (subst \\<sigma> (snd (mems' ! i)))", "using A_def"], ["proof (prove)\nusing this:\n  A ?x =\n  (if ?x \\<in> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                (subst \\<sigma> (fst (mems' ! i))) \\<union>\n               differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                (subst \\<sigma> (snd (mems' ! i)))\n   then if dma (subst \\<sigma> (fst (mems' ! i))) ?x = High\n        then Some\n              (subst \\<sigma> (fst (mems' ! i)) ?x,\n               subst \\<sigma> (snd (mems' ! i)) ?x)\n        else if ?x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2'\n                          mems' i\n             then case \\<sigma> ?x of None \\<Rightarrow> None\n                  | Some v \\<Rightarrow> Some (v, v)\n             else Some (mem\\<^sub>1' ?x, mem\\<^sub>1' ?x)\n   else None)\n\ngoal (1 subgoal):\n 1. dom A\n    \\<subseteq> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                 (subst \\<sigma> (fst (mems' ! i))) \\<union>\n                differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                 (subst \\<sigma> (snd (mems' ! i)))", "apply (auto simp: domD)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x a b.\n       \\<lbrakk>\\<And>x.\n                   A x =\n                   (if x \\<in> differing_vars\n                                (subst \\<sigma>' (fst (mems ! i)))\n                                (subst \\<sigma> (fst (mems' ! i))) \\<or>\n                       x \\<in> differing_vars\n                                (subst \\<sigma>' (snd (mems ! i)))\n                                (subst \\<sigma> (snd (mems' ! i)))\n                    then if dma (subst \\<sigma> (fst (mems' ! i))) x = High\n                         then Some\n                               (subst \\<sigma> (fst (mems' ! i)) x,\n                                subst \\<sigma> (snd (mems' ! i)) x)\n                         else if x \\<in> differing_vars_lists mem\\<^sub>1'\n    mem\\<^sub>2' mems' i\n                              then case \\<sigma> x of\n                                   None \\<Rightarrow> None\n                                   | Some v \\<Rightarrow> Some (v, v)\n                              else Some (mem\\<^sub>1' x, mem\\<^sub>1' x)\n                    else None);\n        x \\<notin> differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                    (subst \\<sigma> (snd (mems' ! i)));\n        (if x \\<in> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                     (subst \\<sigma> (fst (mems' ! i)))\n         then if dma (subst \\<sigma> (fst (mems' ! i))) x = High\n              then Some\n                    (subst \\<sigma> (fst (mems' ! i)) x,\n                     subst \\<sigma> (snd (mems' ! i)) x)\n              else if x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2'\n                               mems' i\n                   then case \\<sigma> x of None \\<Rightarrow> None\n                        | Some v \\<Rightarrow> Some (v, v)\n                   else Some (mem\\<^sub>1' x, mem\\<^sub>1' x)\n         else None) =\n        Some (a, b)\\<rbrakk>\n       \\<Longrightarrow> x \\<in> differing_vars\n                                  (subst \\<sigma>' (fst (mems ! i)))\n                                  (subst \\<sigma> (fst (mems' ! i)))", "by (metis option.simps(2))"], ["proof (state)\nthis:\n  dom A\n  \\<subseteq> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n               (subst \\<sigma> (fst (mems' ! i))) \\<union>\n              differing_vars (subst \\<sigma>' (snd (mems ! i)))\n               (subst \\<sigma> (snd (mems' ! i)))\n\ngoal (1 subgoal):\n 1. differing_vars (subst \\<sigma>' (fst (mems ! i)))\n     (subst \\<sigma> (fst (mems' ! i))) \\<union>\n    differing_vars (subst \\<sigma>' (snd (mems ! i)))\n     (subst \\<sigma> (snd (mems' ! i)))\n    \\<subseteq> dom A", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. differing_vars (subst \\<sigma>' (fst (mems ! i)))\n     (subst \\<sigma> (fst (mems' ! i))) \\<union>\n    differing_vars (subst \\<sigma>' (snd (mems ! i)))\n     (subst \\<sigma> (snd (mems' ! i)))\n    \\<subseteq> dom A", "show \"?\\<Delta> \\<subseteq> dom A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. differing_vars (subst \\<sigma>' (fst (mems ! i)))\n     (subst \\<sigma> (fst (mems' ! i))) \\<union>\n    differing_vars (subst \\<sigma>' (snd (mems ! i)))\n     (subst \\<sigma> (snd (mems' ! i)))\n    \\<subseteq> dom A", "unfolding A_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. differing_vars (subst \\<sigma>' (fst (mems ! i)))\n     (subst \\<sigma> (fst (mems' ! i))) \\<union>\n    differing_vars (subst \\<sigma>' (snd (mems ! i)))\n     (subst \\<sigma> (snd (mems' ! i)))\n    \\<subseteq> dom (\\<lambda>x.\n                        if x \\<in> differing_vars\n                                    (subst \\<sigma>' (fst (mems ! i)))\n                                    (subst \\<sigma>\n(fst (mems' ! i))) \\<union>\n                                   differing_vars\n                                    (subst \\<sigma>' (snd (mems ! i)))\n                                    (subst \\<sigma> (snd (mems' ! i)))\n                        then if dma (subst \\<sigma> (fst (mems' ! i))) x =\n                                High\n                             then Some\n                                   (subst \\<sigma> (fst (mems' ! i)) x,\n                                    subst \\<sigma> (snd (mems' ! i)) x)\n                             else if x \\<in> differing_vars_lists\n        mem\\<^sub>1' mem\\<^sub>2' mems' i\n                                  then case \\<sigma> x of\n None \\<Rightarrow> None | Some v \\<Rightarrow> Some (v, v)\n                                  else Some (mem\\<^sub>1' x, mem\\<^sub>1' x)\n                        else None)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                         (subst \\<sigma> (fst (mems' ! i)));\n        x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i;\n        dma (subst \\<sigma> (fst (mems' ! i))) x \\<noteq> High\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b.\n                            (case \\<sigma> x of None \\<Rightarrow> None\n                             | Some v \\<Rightarrow> Some (v, v)) =\n                            Some (a, b)\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                         (subst \\<sigma> (snd (mems' ! i)));\n        x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i;\n        dma (subst \\<sigma> (fst (mems' ! i))) x \\<noteq> High\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b.\n                            (case \\<sigma> x of None \\<Rightarrow> None\n                             | Some v \\<Rightarrow> Some (v, v)) =\n                            Some (a, b)", "apply (metis (no_types) domIff dom\\<sigma> option.exhaust option.simps(5))"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                         (subst \\<sigma> (snd (mems' ! i)));\n        x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i;\n        dma (subst \\<sigma> (fst (mems' ! i))) x \\<noteq> High\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b.\n                            (case \\<sigma> x of None \\<Rightarrow> None\n                             | Some v \\<Rightarrow> Some (v, v)) =\n                            Some (a, b)", "by (metis (no_types) domIff dom\\<sigma> option.exhaust option.simps(5))"], ["proof (state)\nthis:\n  differing_vars (subst \\<sigma>' (fst (mems ! i)))\n   (subst \\<sigma> (fst (mems' ! i))) \\<union>\n  differing_vars (subst \\<sigma>' (snd (mems ! i)))\n   (subst \\<sigma> (snd (mems' ! i)))\n  \\<subseteq> dom A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  dom A =\n  differing_vars (subst \\<sigma>' (fst (mems ! i)))\n   (subst \\<sigma> (fst (mems' ! i))) \\<union>\n  differing_vars (subst \\<sigma>' (snd (mems ! i)))\n   (subst \\<sigma> (snd (mems' ! i)))\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "(* FIXME: clean up *)"], ["proof (state)\nthis:\n  dom A =\n  differing_vars (subst \\<sigma>' (fst (mems ! i)))\n   (subst \\<sigma> (fst (mems' ! i))) \\<union>\n  differing_vars (subst \\<sigma>' (snd (mems ! i)))\n   (subst \\<sigma> (snd (mems' ! i)))\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "have dma_eq: \"dma (?mems\\<^sub>1'i [\\<mapsto> \\<sigma>]) = dma mem\\<^sub>1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dma (subst \\<sigma> (fst (mems' ! i))) = dma mem\\<^sub>1'", "apply(rule dma_\\<C>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>\\<C>. subst \\<sigma> (fst (mems' ! i)) x = mem\\<^sub>1' x", "apply(rule ballI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<C> \\<Longrightarrow>\n       subst \\<sigma> (fst (mems' ! i)) x = mem\\<^sub>1' x", "apply(case_tac \"x \\<in> ?X' i\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> \\<C>;\n        x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                 i\\<rbrakk>\n       \\<Longrightarrow> subst \\<sigma> (fst (mems' ! i)) x = mem\\<^sub>1' x\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> \\<C>;\n        x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                    i\\<rbrakk>\n       \\<Longrightarrow> subst \\<sigma> (fst (mems' ! i)) x = mem\\<^sub>1' x", "apply(drule not_control[rotated])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. x \\<in> \\<C> \\<Longrightarrow> i < length cms\\<^sub>1'\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> \\<C>; x \\<notin> \\<C>\\<rbrakk>\n       \\<Longrightarrow> subst \\<sigma> (fst (mems' ! i)) x = mem\\<^sub>1' x\n 3. \\<And>x.\n       \\<lbrakk>x \\<in> \\<C>;\n        x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                    i\\<rbrakk>\n       \\<Longrightarrow> subst \\<sigma> (fst (mems' ! i)) x = mem\\<^sub>1' x", "apply (metis i_le)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> \\<C>; x \\<notin> \\<C>\\<rbrakk>\n       \\<Longrightarrow> subst \\<sigma> (fst (mems' ! i)) x = mem\\<^sub>1' x\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> \\<C>;\n        x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                    i\\<rbrakk>\n       \\<Longrightarrow> subst \\<sigma> (fst (mems' ! i)) x = mem\\<^sub>1' x", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> \\<C>;\n        x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                    i\\<rbrakk>\n       \\<Longrightarrow> subst \\<sigma> (fst (mems' ! i)) x = mem\\<^sub>1' x", "apply(subst subst_not_in_dom)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> \\<C>;\n        x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                    i\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> dom \\<sigma>\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> \\<C>;\n        x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                    i\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = mem\\<^sub>1' x", "apply(simp add: dom\\<sigma>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> \\<C>;\n        x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                    i\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = mem\\<^sub>1' x", "apply(simp add: differing_vars_lists_def differing_vars_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  dma (subst \\<sigma> (fst (mems' ! i))) = dma mem\\<^sub>1'\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "(* FIXME: clean up *)"], ["proof (state)\nthis:\n  dma (subst \\<sigma> (fst (mems' ! i))) = dma mem\\<^sub>1'\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "have dma_eq'': \"dma (?mems\\<^sub>1i [\\<mapsto> \\<sigma>']) = dma mem\\<^sub>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dma (subst \\<sigma>' (fst (mems ! i))) = dma mem\\<^sub>1", "apply(rule dma_\\<C>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x\\<in>\\<C>. subst \\<sigma>' (fst (mems ! i)) x = mem\\<^sub>1 x", "apply(rule ballI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<C> \\<Longrightarrow>\n       subst \\<sigma>' (fst (mems ! i)) x = mem\\<^sub>1 x", "apply(case_tac \"x \\<in> ?X i\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> \\<C>;\n        x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\\<rbrakk>\n       \\<Longrightarrow> subst \\<sigma>' (fst (mems ! i)) x = mem\\<^sub>1 x\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> \\<C>;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                    i\\<rbrakk>\n       \\<Longrightarrow> subst \\<sigma>' (fst (mems ! i)) x = mem\\<^sub>1 x", "using compat compat i_le len_unchanged"], ["proof (prove)\nusing this:\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  i < length cms\\<^sub>1'\n  length cms\\<^sub>1' = length cms\\<^sub>1\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> \\<C>;\n        x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\\<rbrakk>\n       \\<Longrightarrow> subst \\<sigma>' (fst (mems ! i)) x = mem\\<^sub>1 x\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> \\<C>;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                    i\\<rbrakk>\n       \\<Longrightarrow> subst \\<sigma>' (fst (mems ! i)) x = mem\\<^sub>1 x", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> \\<C>;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                    i\\<rbrakk>\n       \\<Longrightarrow> subst \\<sigma>' (fst (mems ! i)) x = mem\\<^sub>1 x", "apply(subst subst_not_in_dom)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> \\<C>;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                    i\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> dom \\<sigma>'\n 2. \\<And>x.\n       \\<lbrakk>x \\<in> \\<C>;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                    i\\<rbrakk>\n       \\<Longrightarrow> fst (mems ! i) x = mem\\<^sub>1 x", "apply(simp add: \\<open>dom \\<sigma>' = ?X i\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>x \\<in> \\<C>;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                    i\\<rbrakk>\n       \\<Longrightarrow> fst (mems ! i) x = mem\\<^sub>1 x", "apply(simp add: differing_vars_lists_def differing_vars_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  dma (subst \\<sigma>' (fst (mems ! i))) = dma mem\\<^sub>1\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "have dma_eq': \"dma (subst ((to_partial mem\\<^sub>2 |` differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)) mem\\<^sub>1') = dma mem\\<^sub>1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dma (subst\n          (to_partial mem\\<^sub>2 |`\n           differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n          mem\\<^sub>1') =\n    dma mem\\<^sub>1'", "using compat b"], ["proof (prove)\nusing this:\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  k < length cms\\<^sub>1 \\<and>\n  (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto>\n  (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n  cms\\<^sub>1' = cms\\<^sub>1[k := cms\\<^sub>1' ! k]\n\ngoal (1 subgoal):\n 1. dma (subst\n          (to_partial mem\\<^sub>2 |`\n           differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n          mem\\<^sub>1') =\n    dma mem\\<^sub>1'", "by(force intro!: dma_\\<C> subst_not_in_dom)"], ["proof (state)\nthis:\n  dma (subst\n        (to_partial mem\\<^sub>2 |`\n         differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k)\n        mem\\<^sub>1') =\n  dma mem\\<^sub>1'\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "have A_correct:\n              \"\\<And> x.\n               ?mems\\<^sub>1i [\\<mapsto> \\<sigma>'] [\\<parallel>\\<^sub>1 A] x = ?mems\\<^sub>1'i [\\<mapsto> \\<sigma>] x \\<and>\n               ?mems\\<^sub>2i [\\<mapsto> \\<sigma>'] [\\<parallel>\\<^sub>2 A] x = ?mems\\<^sub>2'i [\\<mapsto> \\<sigma>] x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n       subst \\<sigma> (fst (mems' ! i)) x \\<and>\n       subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n       subst \\<sigma> (snd (mems' ! i)) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n       subst \\<sigma> (fst (mems' ! i)) x \\<and>\n       subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n       subst \\<sigma> (snd (mems' ! i)) x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n       subst \\<sigma> (fst (mems' ! i)) x \\<and>\n       subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n       subst \\<sigma> (snd (mems' ! i)) x", "show \"?thesis x\"\n            (is \"?Eq\\<^sub>1 \\<and> ?Eq\\<^sub>2\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "proof (cases \"x \\<in> ?\\<Delta>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n             (subst \\<sigma> (fst (mems' ! i))) \\<union>\n            differing_vars (subst \\<sigma>' (snd (mems ! i)))\n             (subst \\<sigma> (snd (mems' ! i))) \\<Longrightarrow>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x\n 2. x \\<notin> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                (subst \\<sigma> (fst (mems' ! i))) \\<union>\n               differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                (subst \\<sigma> (snd (mems' ! i))) \\<Longrightarrow>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "assume \"x \\<in> ?\\<Delta>\""], ["proof (state)\nthis:\n  x \\<in> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n           (subst \\<sigma> (fst (mems' ! i))) \\<union>\n          differing_vars (subst \\<sigma>' (snd (mems ! i)))\n           (subst \\<sigma> (snd (mems' ! i)))\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n             (subst \\<sigma> (fst (mems' ! i))) \\<union>\n            differing_vars (subst \\<sigma>' (snd (mems ! i)))\n             (subst \\<sigma> (snd (mems' ! i))) \\<Longrightarrow>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x\n 2. x \\<notin> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                (subst \\<sigma> (fst (mems' ! i))) \\<union>\n               differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                (subst \\<sigma> (snd (mems' ! i))) \\<Longrightarrow>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "hence diff:\n              \"?mems\\<^sub>1'i [\\<mapsto> \\<sigma>] x \\<noteq> ?mems\\<^sub>1i [\\<mapsto> \\<sigma>'] x \\<or> ?mems\\<^sub>2'i [\\<mapsto> \\<sigma>] x \\<noteq> ?mems\\<^sub>2i [\\<mapsto> \\<sigma>'] x\""], ["proof (prove)\nusing this:\n  x \\<in> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n           (subst \\<sigma> (fst (mems' ! i))) \\<union>\n          differing_vars (subst \\<sigma>' (snd (mems ! i)))\n           (subst \\<sigma> (snd (mems' ! i)))\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n    subst \\<sigma>' (fst (mems ! i)) x \\<or>\n    subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n    subst \\<sigma>' (snd (mems ! i)) x", "by (auto simp: differing_vars_def)"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n  subst \\<sigma>' (fst (mems ! i)) x \\<or>\n  subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n  subst \\<sigma>' (snd (mems ! i)) x\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n             (subst \\<sigma> (fst (mems' ! i))) \\<union>\n            differing_vars (subst \\<sigma>' (snd (mems ! i)))\n             (subst \\<sigma> (snd (mems' ! i))) \\<Longrightarrow>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x\n 2. x \\<notin> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                (subst \\<sigma> (fst (mems' ! i))) \\<union>\n               differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                (subst \\<sigma> (snd (mems' ! i))) \\<Longrightarrow>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "proof (cases \"dma (?mems\\<^sub>1'i [\\<mapsto> \\<sigma>]) x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. dma (subst \\<sigma> (fst (mems' ! i))) x = High \\<Longrightarrow>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x\n 2. dma (subst \\<sigma> (fst (mems' ! i))) x = Low \\<Longrightarrow>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "assume \"dma (?mems\\<^sub>1'i [\\<mapsto> \\<sigma>]) x = High\""], ["proof (state)\nthis:\n  dma (subst \\<sigma> (fst (mems' ! i))) x = High\n\ngoal (2 subgoals):\n 1. dma (subst \\<sigma> (fst (mems' ! i))) x = High \\<Longrightarrow>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x\n 2. dma (subst \\<sigma> (fst (mems' ! i))) x = Low \\<Longrightarrow>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "from \\<open>dma (?mems\\<^sub>1'i [\\<mapsto> \\<sigma>]) x = High\\<close>"], ["proof (chain)\npicking this:\n  dma (subst \\<sigma> (fst (mems' ! i))) x = High", "have A_simp [simp]:\n                \"A x = Some (?mems\\<^sub>1'i [\\<mapsto> \\<sigma>] x, ?mems\\<^sub>2'i [\\<mapsto> \\<sigma>] x)\""], ["proof (prove)\nusing this:\n  dma (subst \\<sigma> (fst (mems' ! i))) x = High\n\ngoal (1 subgoal):\n 1. A x =\n    Some\n     (subst \\<sigma> (fst (mems' ! i)) x,\n      subst \\<sigma> (snd (mems' ! i)) x)", "unfolding A_def"], ["proof (prove)\nusing this:\n  dma (subst \\<sigma> (fst (mems' ! i))) x = High\n\ngoal (1 subgoal):\n 1. (if x \\<in> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                 (subst \\<sigma> (fst (mems' ! i))) \\<union>\n                differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                 (subst \\<sigma> (snd (mems' ! i)))\n     then if dma (subst \\<sigma> (fst (mems' ! i))) x = High\n          then Some\n                (subst \\<sigma> (fst (mems' ! i)) x,\n                 subst \\<sigma> (snd (mems' ! i)) x)\n          else if x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2'\n                           mems' i\n               then case \\<sigma> x of None \\<Rightarrow> None\n                    | Some v \\<Rightarrow> Some (v, v)\n               else Some (mem\\<^sub>1' x, mem\\<^sub>1' x)\n     else None) =\n    Some\n     (subst \\<sigma> (fst (mems' ! i)) x,\n      subst \\<sigma> (snd (mems' ! i)) x)", "by (metis \\<open>x \\<in> ?\\<Delta>\\<close>)"], ["proof (state)\nthis:\n  A x =\n  Some\n   (subst \\<sigma> (fst (mems' ! i)) x, subst \\<sigma> (snd (mems' ! i)) x)\n\ngoal (2 subgoals):\n 1. dma (subst \\<sigma> (fst (mems' ! i))) x = High \\<Longrightarrow>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x\n 2. dma (subst \\<sigma> (fst (mems' ! i))) x = Low \\<Longrightarrow>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "from A_simp"], ["proof (chain)\npicking this:\n  A x =\n  Some\n   (subst \\<sigma> (fst (mems' ! i)) x, subst \\<sigma> (snd (mems' ! i)) x)", "have ?Eq\\<^sub>1 ?Eq\\<^sub>2"], ["proof (prove)\nusing this:\n  A x =\n  Some\n   (subst \\<sigma> (fst (mems' ! i)) x, subst \\<sigma> (snd (mems' ! i)) x)\n\ngoal (1 subgoal):\n 1. subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x &&&\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "unfolding A_def apply_adaptation_def"], ["proof (prove)\nusing this:\n  (if x \\<in> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n               (subst \\<sigma> (fst (mems' ! i))) \\<union>\n              differing_vars (subst \\<sigma>' (snd (mems ! i)))\n               (subst \\<sigma> (snd (mems' ! i)))\n   then if dma (subst \\<sigma> (fst (mems' ! i))) x = High\n        then Some\n              (subst \\<sigma> (fst (mems' ! i)) x,\n               subst \\<sigma> (snd (mems' ! i)) x)\n        else if x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                         i\n             then case \\<sigma> x of None \\<Rightarrow> None\n                  | Some v \\<Rightarrow> Some (v, v)\n             else Some (mem\\<^sub>1' x, mem\\<^sub>1' x)\n   else None) =\n  Some\n   (subst \\<sigma> (fst (mems' ! i)) x, subst \\<sigma> (snd (mems' ! i)) x)\n\ngoal (1 subgoal):\n 1. (case if x \\<in> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                      (subst \\<sigma> (fst (mems' ! i))) \\<union>\n                     differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                      (subst \\<sigma> (snd (mems' ! i)))\n          then if dma (subst \\<sigma> (fst (mems' ! i))) x = High\n               then Some\n                     (subst \\<sigma> (fst (mems' ! i)) x,\n                      subst \\<sigma> (snd (mems' ! i)) x)\n               else if x \\<in> differing_vars_lists mem\\<^sub>1'\n                                mem\\<^sub>2' mems' i\n                    then case \\<sigma> x of None \\<Rightarrow> None\n                         | Some v \\<Rightarrow> Some (v, v)\n                    else Some (mem\\<^sub>1' x, mem\\<^sub>1' x)\n          else None of\n     None \\<Rightarrow> subst \\<sigma>' (fst (mems ! i)) x\n     | Some (xa, xb) \\<Rightarrow> if True then xa else xb) =\n    subst \\<sigma> (fst (mems' ! i)) x &&&\n    (case if x \\<in> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                      (subst \\<sigma> (fst (mems' ! i))) \\<union>\n                     differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                      (subst \\<sigma> (snd (mems' ! i)))\n          then if dma (subst \\<sigma> (fst (mems' ! i))) x = High\n               then Some\n                     (subst \\<sigma> (fst (mems' ! i)) x,\n                      subst \\<sigma> (snd (mems' ! i)) x)\n               else if x \\<in> differing_vars_lists mem\\<^sub>1'\n                                mem\\<^sub>2' mems' i\n                    then case \\<sigma> x of None \\<Rightarrow> None\n                         | Some v \\<Rightarrow> Some (v, v)\n                    else Some (mem\\<^sub>1' x, mem\\<^sub>1' x)\n          else None of\n     None \\<Rightarrow> subst \\<sigma>' (snd (mems ! i)) x\n     | Some (xa, xb) \\<Rightarrow> if False then xa else xb) =\n    subst \\<sigma> (snd (mems' ! i)) x", "by auto"], ["proof (state)\nthis:\n  subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n  subst \\<sigma> (fst (mems' ! i)) x\n  subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n  subst \\<sigma> (snd (mems' ! i)) x\n\ngoal (2 subgoals):\n 1. dma (subst \\<sigma> (fst (mems' ! i))) x = High \\<Longrightarrow>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x\n 2. dma (subst \\<sigma> (fst (mems' ! i))) x = Low \\<Longrightarrow>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n  subst \\<sigma> (fst (mems' ! i)) x\n  subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n  subst \\<sigma> (snd (mems' ! i)) x\n\ngoal (1 subgoal):\n 1. subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "by auto"], ["proof (state)\nthis:\n  subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n  subst \\<sigma> (fst (mems' ! i)) x \\<and>\n  subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n  subst \\<sigma> (snd (mems' ! i)) x\n\ngoal (1 subgoal):\n 1. dma (subst \\<sigma> (fst (mems' ! i))) x = Low \\<Longrightarrow>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. dma (subst \\<sigma> (fst (mems' ! i))) x = Low \\<Longrightarrow>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "assume \"dma (?mems\\<^sub>1'i [\\<mapsto> \\<sigma>]) x = Low\""], ["proof (state)\nthis:\n  dma (subst \\<sigma> (fst (mems' ! i))) x = Low\n\ngoal (1 subgoal):\n 1. dma (subst \\<sigma> (fst (mems' ! i))) x = Low \\<Longrightarrow>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "proof (cases \"x \\<in> ?X' i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             i \\<Longrightarrow>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "assume \"x \\<in> ?X' i\""], ["proof (state)\nthis:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             i \\<Longrightarrow>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "then"], ["proof (chain)\npicking this:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "obtain v where \"\\<sigma> x = Some v\""], ["proof (prove)\nusing this:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. (\\<And>v.\n        \\<sigma> x = Some v \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis domD dom\\<sigma>)"], ["proof (state)\nthis:\n  \\<sigma> x = Some v\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             i \\<Longrightarrow>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "hence eq: \"?mems\\<^sub>1'i [\\<mapsto> \\<sigma>] x = v \\<and> ?mems\\<^sub>2'i [\\<mapsto> \\<sigma>] x = v\""], ["proof (prove)\nusing this:\n  \\<sigma> x = Some v\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (fst (mems' ! i)) x = v \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = v", "unfolding subst_def"], ["proof (prove)\nusing this:\n  \\<sigma> x = Some v\n\ngoal (1 subgoal):\n 1. (case \\<sigma> x of None \\<Rightarrow> fst (mems' ! i) x\n     | Some v \\<Rightarrow> v) =\n    v \\<and>\n    (case \\<sigma> x of None \\<Rightarrow> snd (mems' ! i) x\n     | Some v \\<Rightarrow> v) =\n    v", "by auto"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) x = v \\<and>\n  subst \\<sigma> (snd (mems' ! i)) x = v\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             i \\<Longrightarrow>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "moreover"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) x = v \\<and>\n  subst \\<sigma> (snd (mems' ! i)) x = v\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             i \\<Longrightarrow>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "from \\<open>x \\<in> ?X' i\\<close> and \\<open>dma (?mems\\<^sub>1'i [\\<mapsto> \\<sigma>]) x = Low\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n  dma (subst \\<sigma> (fst (mems' ! i))) x = Low", "have A_simp [simp]:\n                  \"A x = (case \\<sigma> x of\n                            Some v \\<Rightarrow> Some (v, v)\n                          | None \\<Rightarrow> None)\""], ["proof (prove)\nusing this:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n  dma (subst \\<sigma> (fst (mems' ! i))) x = Low\n\ngoal (1 subgoal):\n 1. A x =\n    (case \\<sigma> x of None \\<Rightarrow> None\n     | Some v \\<Rightarrow> Some (v, v))", "unfolding A_def"], ["proof (prove)\nusing this:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n  dma (subst \\<sigma> (fst (mems' ! i))) x = Low\n\ngoal (1 subgoal):\n 1. (if x \\<in> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                 (subst \\<sigma> (fst (mems' ! i))) \\<union>\n                differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                 (subst \\<sigma> (snd (mems' ! i)))\n     then if dma (subst \\<sigma> (fst (mems' ! i))) x = High\n          then Some\n                (subst \\<sigma> (fst (mems' ! i)) x,\n                 subst \\<sigma> (snd (mems' ! i)) x)\n          else if x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2'\n                           mems' i\n               then case \\<sigma> x of None \\<Rightarrow> None\n                    | Some v \\<Rightarrow> Some (v, v)\n               else Some (mem\\<^sub>1' x, mem\\<^sub>1' x)\n     else None) =\n    (case \\<sigma> x of None \\<Rightarrow> None\n     | Some v \\<Rightarrow> Some (v, v))", "by (metis Sec.simps(1) \\<open>x \\<in> ?\\<Delta>\\<close>)"], ["proof (state)\nthis:\n  A x =\n  (case \\<sigma> x of None \\<Rightarrow> None\n   | Some v \\<Rightarrow> Some (v, v))\n\ngoal (2 subgoals):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             i \\<Longrightarrow>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x\n 2. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "ultimately"], ["proof (chain)\npicking this:\n  subst \\<sigma> (fst (mems' ! i)) x = v \\<and>\n  subst \\<sigma> (snd (mems' ! i)) x = v\n  A x =\n  (case \\<sigma> x of None \\<Rightarrow> None\n   | Some v \\<Rightarrow> Some (v, v))", "show ?thesis"], ["proof (prove)\nusing this:\n  subst \\<sigma> (fst (mems' ! i)) x = v \\<and>\n  subst \\<sigma> (snd (mems' ! i)) x = v\n  A x =\n  (case \\<sigma> x of None \\<Rightarrow> None\n   | Some v \\<Rightarrow> Some (v, v))\n\ngoal (1 subgoal):\n 1. subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "using domA \\<open>x \\<in> ?\\<Delta>\\<close> \\<open>\\<sigma> x = Some v\\<close>"], ["proof (prove)\nusing this:\n  subst \\<sigma> (fst (mems' ! i)) x = v \\<and>\n  subst \\<sigma> (snd (mems' ! i)) x = v\n  A x =\n  (case \\<sigma> x of None \\<Rightarrow> None\n   | Some v \\<Rightarrow> Some (v, v))\n  dom A =\n  differing_vars (subst \\<sigma>' (fst (mems ! i)))\n   (subst \\<sigma> (fst (mems' ! i))) \\<union>\n  differing_vars (subst \\<sigma>' (snd (mems ! i)))\n   (subst \\<sigma> (snd (mems' ! i)))\n  x \\<in> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n           (subst \\<sigma> (fst (mems' ! i))) \\<union>\n          differing_vars (subst \\<sigma>' (snd (mems ! i)))\n           (subst \\<sigma> (snd (mems' ! i)))\n  \\<sigma> x = Some v\n\ngoal (1 subgoal):\n 1. subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "by (auto simp: apply_adaptation_def)"], ["proof (state)\nthis:\n  subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n  subst \\<sigma> (fst (mems' ! i)) x \\<and>\n  subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n  subst \\<sigma> (snd (mems' ! i)) x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "assume \"x \\<notin> ?X' i\""], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "hence A_simp [simp]: \"A x = Some (mem\\<^sub>1' x, mem\\<^sub>1' x)\""], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. A x = Some (mem\\<^sub>1' x, mem\\<^sub>1' x)", "unfolding A_def"], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. (if x \\<in> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                 (subst \\<sigma> (fst (mems' ! i))) \\<union>\n                differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                 (subst \\<sigma> (snd (mems' ! i)))\n     then if dma (subst \\<sigma> (fst (mems' ! i))) x = High\n          then Some\n                (subst \\<sigma> (fst (mems' ! i)) x,\n                 subst \\<sigma> (snd (mems' ! i)) x)\n          else if x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2'\n                           mems' i\n               then case \\<sigma> x of None \\<Rightarrow> None\n                    | Some v \\<Rightarrow> Some (v, v)\n               else Some (mem\\<^sub>1' x, mem\\<^sub>1' x)\n     else None) =\n    Some (mem\\<^sub>1' x, mem\\<^sub>1' x)", "using \\<open>x \\<in> ?\\<Delta>\\<close> \\<open>x \\<notin> ?X' i\\<close> \\<open>dma (?mems\\<^sub>1'i [\\<mapsto> \\<sigma>]) x = Low\\<close>"], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n  x \\<in> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n           (subst \\<sigma> (fst (mems' ! i))) \\<union>\n          differing_vars (subst \\<sigma>' (snd (mems ! i)))\n           (subst \\<sigma> (snd (mems' ! i)))\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n  dma (subst \\<sigma> (fst (mems' ! i))) x = Low\n\ngoal (1 subgoal):\n 1. (if x \\<in> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                 (subst \\<sigma> (fst (mems' ! i))) \\<union>\n                differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                 (subst \\<sigma> (snd (mems' ! i)))\n     then if dma (subst \\<sigma> (fst (mems' ! i))) x = High\n          then Some\n                (subst \\<sigma> (fst (mems' ! i)) x,\n                 subst \\<sigma> (snd (mems' ! i)) x)\n          else if x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2'\n                           mems' i\n               then case \\<sigma> x of None \\<Rightarrow> None\n                    | Some v \\<Rightarrow> Some (v, v)\n               else Some (mem\\<^sub>1' x, mem\\<^sub>1' x)\n     else None) =\n    Some (mem\\<^sub>1' x, mem\\<^sub>1' x)", "by auto"], ["proof (state)\nthis:\n  A x = Some (mem\\<^sub>1' x, mem\\<^sub>1' x)\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "from q"], ["proof (chain)\npicking this:\n  \\<lbrakk>dma mem\\<^sub>1' ?x5 = Low;\n   subst \\<sigma> (fst (mems' ! i)) ?x5 \\<noteq>\n   subst \\<sigma>' (fst (mems ! i)) ?x5 \\<or>\n   subst \\<sigma> (snd (mems' ! i)) ?x5 \\<noteq>\n   subst \\<sigma>' (snd (mems ! i)) ?x5;\n   ?x5\n   \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\\<rbrakk>\n  \\<Longrightarrow> mem\\<^sub>1' ?x5 = mem\\<^sub>2' ?x5", "have \"mem\\<^sub>1' x = mem\\<^sub>2' x\""], ["proof (prove)\nusing this:\n  \\<lbrakk>dma mem\\<^sub>1' ?x5 = Low;\n   subst \\<sigma> (fst (mems' ! i)) ?x5 \\<noteq>\n   subst \\<sigma>' (fst (mems ! i)) ?x5 \\<or>\n   subst \\<sigma> (snd (mems' ! i)) ?x5 \\<noteq>\n   subst \\<sigma>' (snd (mems ! i)) ?x5;\n   ?x5\n   \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\\<rbrakk>\n  \\<Longrightarrow> mem\\<^sub>1' ?x5 = mem\\<^sub>2' ?x5\n\ngoal (1 subgoal):\n 1. mem\\<^sub>1' x = mem\\<^sub>2' x", "by (metis \\<open>dma (?mems\\<^sub>1'i [\\<mapsto> \\<sigma>]) x = Low\\<close> diff \\<open>x \\<notin> ?X' i\\<close> dma_eq dma_eq'')"], ["proof (state)\nthis:\n  mem\\<^sub>1' x = mem\\<^sub>2' x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "from \\<open>x \\<notin> ?X' i\\<close>"], ["proof (chain)\npicking this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "have\n                  \"?mems\\<^sub>1'i [\\<mapsto> \\<sigma>] x = ?mems\\<^sub>1'i x \\<and> ?mems\\<^sub>2'i [\\<mapsto> \\<sigma>] x = ?mems\\<^sub>2'i x\""], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (fst (mems' ! i)) x = fst (mems' ! i) x \\<and>\n    subst \\<sigma> (snd (mems' ! i)) x = snd (mems' ! i) x", "by (metis dom\\<sigma> subst_not_in_dom)"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) x = fst (mems' ! i) x \\<and>\n  subst \\<sigma> (snd (mems' ! i)) x = snd (mems' ! i) x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "moreover"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) x = fst (mems' ! i) x \\<and>\n  subst \\<sigma> (snd (mems' ! i)) x = snd (mems' ! i) x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "from \\<open>x \\<notin> ?X' i\\<close>"], ["proof (chain)\npicking this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "have \"?mems\\<^sub>1'i x = mem\\<^sub>1' x \\<and> ?mems\\<^sub>2'i x = mem\\<^sub>2' x\""], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n    snd (mems' ! i) x = mem\\<^sub>2' x", "by (metis differing_vars_neg)"], ["proof (state)\nthis:\n  fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n  snd (mems' ! i) x = mem\\<^sub>2' x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                i \\<Longrightarrow>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "ultimately"], ["proof (chain)\npicking this:\n  subst \\<sigma> (fst (mems' ! i)) x = fst (mems' ! i) x \\<and>\n  subst \\<sigma> (snd (mems' ! i)) x = snd (mems' ! i) x\n  fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n  snd (mems' ! i) x = mem\\<^sub>2' x", "show ?thesis"], ["proof (prove)\nusing this:\n  subst \\<sigma> (fst (mems' ! i)) x = fst (mems' ! i) x \\<and>\n  subst \\<sigma> (snd (mems' ! i)) x = snd (mems' ! i) x\n  fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n  snd (mems' ! i) x = mem\\<^sub>2' x\n\ngoal (1 subgoal):\n 1. subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "using \\<open>mem\\<^sub>1' x = mem\\<^sub>2' x\\<close>"], ["proof (prove)\nusing this:\n  subst \\<sigma> (fst (mems' ! i)) x = fst (mems' ! i) x \\<and>\n  subst \\<sigma> (snd (mems' ! i)) x = snd (mems' ! i) x\n  fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n  snd (mems' ! i) x = mem\\<^sub>2' x\n  mem\\<^sub>1' x = mem\\<^sub>2' x\n\ngoal (1 subgoal):\n 1. subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "by (auto simp: apply_adaptation_def)"], ["proof (state)\nthis:\n  subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n  subst \\<sigma> (fst (mems' ! i)) x \\<and>\n  subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n  subst \\<sigma> (snd (mems' ! i)) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n  subst \\<sigma> (fst (mems' ! i)) x \\<and>\n  subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n  subst \\<sigma> (snd (mems' ! i)) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n  subst \\<sigma> (fst (mems' ! i)) x \\<and>\n  subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n  subst \\<sigma> (snd (mems' ! i)) x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                (subst \\<sigma> (fst (mems' ! i))) \\<union>\n               differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                (subst \\<sigma> (snd (mems' ! i))) \\<Longrightarrow>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                (subst \\<sigma> (fst (mems' ! i))) \\<union>\n               differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                (subst \\<sigma> (snd (mems' ! i))) \\<Longrightarrow>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "assume \"x \\<notin> ?\\<Delta>\""], ["proof (state)\nthis:\n  x \\<notin> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n              (subst \\<sigma> (fst (mems' ! i))) \\<union>\n             differing_vars (subst \\<sigma>' (snd (mems ! i)))\n              (subst \\<sigma> (snd (mems' ! i)))\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                (subst \\<sigma> (fst (mems' ! i))) \\<union>\n               differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                (subst \\<sigma> (snd (mems' ! i))) \\<Longrightarrow>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "hence \"A x = None\""], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n              (subst \\<sigma> (fst (mems' ! i))) \\<union>\n             differing_vars (subst \\<sigma>' (snd (mems ! i)))\n              (subst \\<sigma> (snd (mems' ! i)))\n\ngoal (1 subgoal):\n 1. A x = None", "by (metis domA domIff)"], ["proof (state)\nthis:\n  A x = None\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                (subst \\<sigma> (fst (mems' ! i))) \\<union>\n               differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                (subst \\<sigma> (snd (mems' ! i))) \\<Longrightarrow>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "from \\<open>A x = None\\<close>"], ["proof (chain)\npicking this:\n  A x = None", "have \"x \\<notin> dom A\""], ["proof (prove)\nusing this:\n  A x = None\n\ngoal (1 subgoal):\n 1. x \\<notin> dom A", "by (metis domIff)"], ["proof (state)\nthis:\n  x \\<notin> dom A\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                (subst \\<sigma> (fst (mems' ! i))) \\<union>\n               differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                (subst \\<sigma> (snd (mems' ! i))) \\<Longrightarrow>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "from \\<open>x \\<notin> ?\\<Delta>\\<close>"], ["proof (chain)\npicking this:\n  x \\<notin> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n              (subst \\<sigma> (fst (mems' ! i))) \\<union>\n             differing_vars (subst \\<sigma>' (snd (mems ! i)))\n              (subst \\<sigma> (snd (mems' ! i)))", "have \"?mems\\<^sub>1i [\\<mapsto> \\<sigma>'] [\\<parallel>\\<^sub>1 A] x = ?mems\\<^sub>1'i [\\<mapsto> \\<sigma>] x \\<and>\n                                 ?mems\\<^sub>2i [\\<mapsto> \\<sigma>'] [\\<parallel>\\<^sub>2 A] x = ?mems\\<^sub>2'i [\\<mapsto> \\<sigma>] x\""], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n              (subst \\<sigma> (fst (mems' ! i))) \\<union>\n             differing_vars (subst \\<sigma>' (snd (mems ! i)))\n              (subst \\<sigma> (snd (mems' ! i)))\n\ngoal (1 subgoal):\n 1. subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "using \\<open>A x = None\\<close>"], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n              (subst \\<sigma> (fst (mems' ! i))) \\<union>\n             differing_vars (subst \\<sigma>' (snd (mems ! i)))\n              (subst \\<sigma> (snd (mems' ! i)))\n  A x = None\n\ngoal (1 subgoal):\n 1. subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "unfolding differing_vars_def apply_adaptation_def"], ["proof (prove)\nusing this:\n  x \\<notin> {x. subst \\<sigma>' (fst (mems ! i)) x \\<noteq>\n                 subst \\<sigma> (fst (mems' ! i)) x} \\<union>\n             {x. subst \\<sigma>' (snd (mems ! i)) x \\<noteq>\n                 subst \\<sigma> (snd (mems' ! i)) x}\n  A x = None\n\ngoal (1 subgoal):\n 1. (case A x of None \\<Rightarrow> subst \\<sigma>' (fst (mems ! i)) x\n     | Some (xa, xb) \\<Rightarrow> if True then xa else xb) =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    (case A x of None \\<Rightarrow> subst \\<sigma>' (snd (mems ! i)) x\n     | Some (xa, xb) \\<Rightarrow> if False then xa else xb) =\n    subst \\<sigma> (snd (mems' ! i)) x", "by auto"], ["proof (state)\nthis:\n  subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n  subst \\<sigma> (fst (mems' ! i)) x \\<and>\n  subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n  subst \\<sigma> (snd (mems' ! i)) x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars (subst \\<sigma>' (fst (mems ! i)))\n                (subst \\<sigma> (fst (mems' ! i))) \\<union>\n               differing_vars (subst \\<sigma>' (snd (mems ! i)))\n                (subst \\<sigma> (snd (mems' ! i))) \\<Longrightarrow>\n    subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n  subst \\<sigma> (fst (mems' ! i)) x \\<and>\n  subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n  subst \\<sigma> (snd (mems' ! i)) x\n\ngoal (1 subgoal):\n 1. subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n    subst \\<sigma> (fst (mems' ! i)) x \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n    subst \\<sigma> (snd (mems' ! i)) x", "by auto"], ["proof (state)\nthis:\n  subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n  subst \\<sigma> (fst (mems' ! i)) x \\<and>\n  subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n  subst \\<sigma> (snd (mems' ! i)) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n  subst \\<sigma> (fst (mems' ! i)) x \\<and>\n  subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x =\n  subst \\<sigma> (snd (mems' ! i)) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] ?x5 =\n  subst \\<sigma> (fst (mems' ! i)) ?x5 \\<and>\n  subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] ?x5 =\n  subst \\<sigma> (snd (mems' ! i)) ?x5\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "hence adapt_eq: \n              \"?mems\\<^sub>1i [\\<mapsto> \\<sigma>'] [\\<parallel>\\<^sub>1 A] = ?mems\\<^sub>1'i [\\<mapsto> \\<sigma>] \\<and>\n               ?mems\\<^sub>2i [\\<mapsto> \\<sigma>'] [\\<parallel>\\<^sub>2 A] = ?mems\\<^sub>2'i [\\<mapsto> \\<sigma>]\""], ["proof (prove)\nusing this:\n  subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] ?x5 =\n  subst \\<sigma> (fst (mems' ! i)) ?x5 \\<and>\n  subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] ?x5 =\n  subst \\<sigma> (snd (mems' ! i)) ?x5\n\ngoal (1 subgoal):\n 1. subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] =\n    subst \\<sigma> (fst (mems' ! i)) \\<and>\n    subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] =\n    subst \\<sigma> (snd (mems' ! i))", "by auto"], ["proof (state)\nthis:\n  subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] =\n  subst \\<sigma> (fst (mems' ! i)) \\<and>\n  subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] =\n  subst \\<sigma> (snd (mems' ! i))\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "have \"cms\\<^sub>1' ! i = cms\\<^sub>1 ! i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cms\\<^sub>1' ! i = cms\\<^sub>1 ! i", "by (metis \\<open>i \\<noteq> k\\<close> b nth_list_update_neq)"], ["proof (state)\nthis:\n  cms\\<^sub>1' ! i = cms\\<^sub>1 ! i\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "have A_correct': \"globally_consistent A (snd (cms\\<^sub>1 ! i)) (?mems\\<^sub>1i [\\<mapsto> \\<sigma>']) (?mems\\<^sub>2i [\\<mapsto> \\<sigma>'])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. globally_consistent A (snd (cms\\<^sub>1 ! i))\n     (subst \\<sigma>' (fst (mems ! i))) (subst \\<sigma>' (snd (mems ! i)))", "(* FIXME: clean up *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. globally_consistent A (snd (cms\\<^sub>1 ! i))\n     (subst \\<sigma>' (fst (mems ! i))) (subst \\<sigma>' (snd (mems ! i)))", "apply(clarsimp simp: globally_consistent_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>x.\n        case A x of None \\<Rightarrow> True\n        | Some (v, v') \\<Rightarrow>\n            subst \\<sigma>' (fst (mems ! i)) x \\<noteq> v \\<or>\n            subst \\<sigma>' (snd (mems ! i)) x \\<noteq> v' \\<longrightarrow>\n            \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x) \\<and>\n    (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A]\n         x \\<noteq>\n        dma (subst \\<sigma>' (fst (mems ! i))) x \\<longrightarrow>\n        \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x) \\<and>\n    (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        Low \\<and>\n        (x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n         x \\<in> \\<C>) \\<longrightarrow>\n        subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x)", "apply(rule conjI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>x.\n       case A x of None \\<Rightarrow> True\n       | Some (v, v') \\<Rightarrow>\n           subst \\<sigma>' (fst (mems ! i)) x \\<noteq> v \\<or>\n           subst \\<sigma>' (snd (mems ! i)) x \\<noteq> v' \\<longrightarrow>\n           \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x\n 2. (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A]\n         x \\<noteq>\n        dma (subst \\<sigma>' (fst (mems ! i))) x \\<longrightarrow>\n        \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x) \\<and>\n    (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        Low \\<and>\n        (x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n         x \\<in> \\<C>) \\<longrightarrow>\n        subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x)", "apply(split option.split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>x.\n       (A x = None \\<longrightarrow> True) \\<and>\n       (\\<forall>x2.\n           A x = Some x2 \\<longrightarrow>\n           (case x2 of\n            (v, v') \\<Rightarrow>\n              subst \\<sigma>' (fst (mems ! i)) x \\<noteq> v \\<or>\n              subst \\<sigma>' (snd (mems ! i)) x \\<noteq>\n              v' \\<longrightarrow>\n              \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x))\n 2. (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A]\n         x \\<noteq>\n        dma (subst \\<sigma>' (fst (mems ! i))) x \\<longrightarrow>\n        \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x) \\<and>\n    (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        Low \\<and>\n        (x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n         x \\<in> \\<C>) \\<longrightarrow>\n        subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x)", "apply(intro allI conjI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x. A x = None \\<longrightarrow> True\n 2. \\<And>x x2.\n       A x = Some x2 \\<longrightarrow>\n       (case x2 of\n        (v, v') \\<Rightarrow>\n          subst \\<sigma>' (fst (mems ! i)) x \\<noteq> v \\<or>\n          subst \\<sigma>' (snd (mems ! i)) x \\<noteq> v' \\<longrightarrow>\n          \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x)\n 3. (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A]\n         x \\<noteq>\n        dma (subst \\<sigma>' (fst (mems ! i))) x \\<longrightarrow>\n        \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x) \\<and>\n    (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        Low \\<and>\n        (x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n         x \\<in> \\<C>) \\<longrightarrow>\n        subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x)", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x2.\n       A x = Some x2 \\<longrightarrow>\n       (case x2 of\n        (v, v') \\<Rightarrow>\n          subst \\<sigma>' (fst (mems ! i)) x \\<noteq> v \\<or>\n          subst \\<sigma>' (snd (mems ! i)) x \\<noteq> v' \\<longrightarrow>\n          \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x)\n 2. (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A]\n         x \\<noteq>\n        dma (subst \\<sigma>' (fst (mems ! i))) x \\<longrightarrow>\n        \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x) \\<and>\n    (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        Low \\<and>\n        (x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n         x \\<in> \\<C>) \\<longrightarrow>\n        subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x)", "apply(intro allI impI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x2.\n       A x = Some x2 \\<Longrightarrow>\n       case x2 of\n       (v, v') \\<Rightarrow>\n         subst \\<sigma>' (fst (mems ! i)) x \\<noteq> v \\<or>\n         subst \\<sigma>' (snd (mems ! i)) x \\<noteq> v' \\<longrightarrow>\n         \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x\n 2. (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A]\n         x \\<noteq>\n        dma (subst \\<sigma>' (fst (mems ! i))) x \\<longrightarrow>\n        \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x) \\<and>\n    (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        Low \\<and>\n        (x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n         x \\<in> \\<C>) \\<longrightarrow>\n        subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x)", "apply(split prod.split)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x2.\n       A x = Some x2 \\<Longrightarrow>\n       \\<forall>x1 x2a.\n          x2 = (x1, x2a) \\<longrightarrow>\n          subst \\<sigma>' (fst (mems ! i)) x \\<noteq> x1 \\<or>\n          subst \\<sigma>' (snd (mems ! i)) x \\<noteq> x2a \\<longrightarrow>\n          \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x\n 2. (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A]\n         x \\<noteq>\n        dma (subst \\<sigma>' (fst (mems ! i))) x \\<longrightarrow>\n        \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x) \\<and>\n    (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        Low \\<and>\n        (x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n         x \\<in> \\<C>) \\<longrightarrow>\n        subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x)", "apply(intro allI impI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x2 x1 x2a.\n       \\<lbrakk>A x = Some x2; x2 = (x1, x2a);\n        subst \\<sigma>' (fst (mems ! i)) x \\<noteq> x1 \\<or>\n        subst \\<sigma>' (snd (mems ! i)) x \\<noteq> x2a\\<rbrakk>\n       \\<Longrightarrow> \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i))\n                                 x\n 2. (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A]\n         x \\<noteq>\n        dma (subst \\<sigma>' (fst (mems ! i))) x \\<longrightarrow>\n        \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x) \\<and>\n    (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        Low \\<and>\n        (x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n         x \\<in> \\<C>) \\<longrightarrow>\n        subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x)", "apply(simp only:)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x x2 x1 x2a.\n       \\<lbrakk>A x = Some (x1, x2a); x2 = (x1, x2a);\n        subst \\<sigma>' (fst (mems ! i)) x \\<noteq> x1 \\<or>\n        subst \\<sigma>' (snd (mems ! i)) x \\<noteq> x2a\\<rbrakk>\n       \\<Longrightarrow> \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i))\n                                 x\n 2. (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A]\n         x \\<noteq>\n        dma (subst \\<sigma>' (fst (mems ! i))) x \\<longrightarrow>\n        \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x) \\<and>\n    (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        Low \\<and>\n        (x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n         x \\<in> \\<C>) \\<longrightarrow>\n        subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x x2 x1 x2a.\n       \\<lbrakk>A x = Some (x1, x2a); x2 = (x1, x2a);\n        subst \\<sigma>' (fst (mems ! i)) x \\<noteq> x1 \\<or>\n        subst \\<sigma>' (snd (mems ! i)) x \\<noteq> x2a\\<rbrakk>\n       \\<Longrightarrow> \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i))\n                                 x\n 2. (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A]\n         x \\<noteq>\n        dma (subst \\<sigma>' (fst (mems ! i))) x \\<longrightarrow>\n        \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x) \\<and>\n    (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        Low \\<and>\n        (x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n         x \\<in> \\<C>) \\<longrightarrow>\n        subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x)", "fix x v v'"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x x2 x1 x2a.\n       \\<lbrakk>A x = Some (x1, x2a); x2 = (x1, x2a);\n        subst \\<sigma>' (fst (mems ! i)) x \\<noteq> x1 \\<or>\n        subst \\<sigma>' (snd (mems ! i)) x \\<noteq> x2a\\<rbrakk>\n       \\<Longrightarrow> \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i))\n                                 x\n 2. (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A]\n         x \\<noteq>\n        dma (subst \\<sigma>' (fst (mems ! i))) x \\<longrightarrow>\n        \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x) \\<and>\n    (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        Low \\<and>\n        (x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n         x \\<in> \\<C>) \\<longrightarrow>\n        subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x)", "assume A_updates_x\\<^sub>1: \"A x = Some (v, v')\"\n                and A_updates_x\\<^sub>2:\"subst \\<sigma>' (fst (mems ! i)) x \\<noteq> v \\<or> subst \\<sigma>' (snd (mems ! i)) x \\<noteq> v'\""], ["proof (state)\nthis:\n  A x = Some (v, v')\n  subst \\<sigma>' (fst (mems ! i)) x \\<noteq> v \\<or>\n  subst \\<sigma>' (snd (mems ! i)) x \\<noteq> v'\n\ngoal (2 subgoals):\n 1. \\<And>x x2 x1 x2a.\n       \\<lbrakk>A x = Some (x1, x2a); x2 = (x1, x2a);\n        subst \\<sigma>' (fst (mems ! i)) x \\<noteq> x1 \\<or>\n        subst \\<sigma>' (snd (mems ! i)) x \\<noteq> x2a\\<rbrakk>\n       \\<Longrightarrow> \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i))\n                                 x\n 2. (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A]\n         x \\<noteq>\n        dma (subst \\<sigma>' (fst (mems ! i))) x \\<longrightarrow>\n        \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x) \\<and>\n    (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        Low \\<and>\n        (x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n         x \\<in> \\<C>) \\<longrightarrow>\n        subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x)", "hence \"x \\<in> dom A\""], ["proof (prove)\nusing this:\n  A x = Some (v, v')\n  subst \\<sigma>' (fst (mems ! i)) x \\<noteq> v \\<or>\n  subst \\<sigma>' (snd (mems ! i)) x \\<noteq> v'\n\ngoal (1 subgoal):\n 1. x \\<in> dom A", "by(blast)"], ["proof (state)\nthis:\n  x \\<in> dom A\n\ngoal (2 subgoals):\n 1. \\<And>x x2 x1 x2a.\n       \\<lbrakk>A x = Some (x1, x2a); x2 = (x1, x2a);\n        subst \\<sigma>' (fst (mems ! i)) x \\<noteq> x1 \\<or>\n        subst \\<sigma>' (snd (mems ! i)) x \\<noteq> x2a\\<rbrakk>\n       \\<Longrightarrow> \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i))\n                                 x\n 2. (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A]\n         x \\<noteq>\n        dma (subst \\<sigma>' (fst (mems ! i))) x \\<longrightarrow>\n        \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x) \\<and>\n    (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        Low \\<and>\n        (x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n         x \\<in> \\<C>) \\<longrightarrow>\n        subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x)", "hence diff:\n               \"?mems\\<^sub>1'i [\\<mapsto> \\<sigma>] x \\<noteq> ?mems\\<^sub>1i [\\<mapsto> \\<sigma>'] x \\<or> ?mems\\<^sub>2'i [\\<mapsto> \\<sigma>] x \\<noteq> ?mems\\<^sub>2i [\\<mapsto> \\<sigma>'] x\""], ["proof (prove)\nusing this:\n  x \\<in> dom A\n\ngoal (1 subgoal):\n 1. subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n    subst \\<sigma>' (fst (mems ! i)) x \\<or>\n    subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n    subst \\<sigma>' (snd (mems ! i)) x", "by (auto simp: differing_vars_def domA)"], ["proof (state)\nthis:\n  subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n  subst \\<sigma>' (fst (mems ! i)) x \\<or>\n  subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n  subst \\<sigma>' (snd (mems ! i)) x\n\ngoal (2 subgoals):\n 1. \\<And>x x2 x1 x2a.\n       \\<lbrakk>A x = Some (x1, x2a); x2 = (x1, x2a);\n        subst \\<sigma>' (fst (mems ! i)) x \\<noteq> x1 \\<or>\n        subst \\<sigma>' (snd (mems ! i)) x \\<noteq> x2a\\<rbrakk>\n       \\<Longrightarrow> \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i))\n                                 x\n 2. (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A]\n         x \\<noteq>\n        dma (subst \\<sigma>' (fst (mems ! i))) x \\<longrightarrow>\n        \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x) \\<and>\n    (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        Low \\<and>\n        (x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n         x \\<in> \\<C>) \\<longrightarrow>\n        subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x)", "show \"\\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x", "proof (cases \"x \\<notin> ?X' i \\<or> ((dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and> dma mem\\<^sub>1' x = dma mem\\<^sub>1 x)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i \\<or>\n    (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n    dma mem\\<^sub>1' x = dma mem\\<^sub>1 x \\<Longrightarrow>\n    \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x\n 2. \\<not> (x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                        i \\<or>\n            (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n            dma mem\\<^sub>1' x = dma mem\\<^sub>1 x) \\<Longrightarrow>\n    \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x", "assume \"x \\<notin> ?X' i \\<or> ((dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and> (dma mem\\<^sub>1' x = dma mem\\<^sub>1 x))\""], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i \\<or>\n  (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n  dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\n\ngoal (2 subgoals):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i \\<or>\n    (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n    dma mem\\<^sub>1' x = dma mem\\<^sub>1 x \\<Longrightarrow>\n    \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x\n 2. \\<not> (x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                        i \\<or>\n            (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n            dma mem\\<^sub>1' x = dma mem\\<^sub>1 x) \\<Longrightarrow>\n    \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x", "from this p and diff"], ["proof (chain)\npicking this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i \\<or>\n  (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n  dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\n  \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) ?x5 \\<noteq>\n           subst \\<sigma>' (fst (mems ! i)) ?x5 \\<or>\n           subst \\<sigma> (snd (mems' ! i)) ?x5 \\<noteq>\n           subst \\<sigma>' (snd (mems ! i)) ?x5;\n   ?x5 \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i \\<or>\n   (dma mem\\<^sub>1 ?x5 = Low \\<or> dma mem\\<^sub>1' ?x5 = High) \\<and>\n   dma mem\\<^sub>1' ?x5 = dma mem\\<^sub>1 ?x5\\<rbrakk>\n  \\<Longrightarrow> \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) ?x5\n  subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n  subst \\<sigma>' (fst (mems ! i)) x \\<or>\n  subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n  subst \\<sigma>' (snd (mems ! i)) x", "show writable: \"\\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x\""], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i \\<or>\n  (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n  dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\n  \\<lbrakk>subst \\<sigma> (fst (mems' ! i)) ?x5 \\<noteq>\n           subst \\<sigma>' (fst (mems ! i)) ?x5 \\<or>\n           subst \\<sigma> (snd (mems' ! i)) ?x5 \\<noteq>\n           subst \\<sigma>' (snd (mems ! i)) ?x5;\n   ?x5 \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i \\<or>\n   (dma mem\\<^sub>1 ?x5 = Low \\<or> dma mem\\<^sub>1' ?x5 = High) \\<and>\n   dma mem\\<^sub>1' ?x5 = dma mem\\<^sub>1 ?x5\\<rbrakk>\n  \\<Longrightarrow> \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) ?x5\n  subst \\<sigma> (fst (mems' ! i)) x \\<noteq>\n  subst \\<sigma>' (fst (mems ! i)) x \\<or>\n  subst \\<sigma> (snd (mems' ! i)) x \\<noteq>\n  subst \\<sigma>' (snd (mems ! i)) x\n\ngoal (1 subgoal):\n 1. \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x", "by auto"], ["proof (state)\nthis:\n  \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                        i \\<or>\n            (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n            dma mem\\<^sub>1' x = dma mem\\<^sub>1 x) \\<Longrightarrow>\n    \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                        i \\<or>\n            (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n            dma mem\\<^sub>1' x = dma mem\\<^sub>1 x) \\<Longrightarrow>\n    \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x", "assume \"\\<not> (x \\<notin> ?X' i \\<or> ((dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and> (dma mem\\<^sub>1' x = dma mem\\<^sub>1 x)))\""], ["proof (state)\nthis:\n  \\<not> (x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                      i \\<or>\n          (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n          dma mem\\<^sub>1' x = dma mem\\<^sub>1 x)\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                        i \\<or>\n            (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n            dma mem\\<^sub>1' x = dma mem\\<^sub>1 x) \\<Longrightarrow>\n    \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x", "hence \"x \\<in> ?X' i\" \"((dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low) \\<or> (dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x))\""], ["proof (prove)\nusing this:\n  \\<not> (x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                      i \\<or>\n          (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n          dma mem\\<^sub>1' x = dma mem\\<^sub>1 x)\n\ngoal (1 subgoal):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i &&&\n    dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low \\<or>\n    dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x", "by (metis Sec.exhaust)+"], ["proof (state)\nthis:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n  dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low \\<or>\n  dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x\n\ngoal (1 subgoal):\n 1. \\<not> (x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                        i \\<or>\n            (dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High) \\<and>\n            dma mem\\<^sub>1' x = dma mem\\<^sub>1 x) \\<Longrightarrow>\n    \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n  dma mem\\<^sub>1 x = High \\<and> dma mem\\<^sub>1' x = Low \\<or>\n  dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x\n\ngoal (1 subgoal):\n 1. \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x", "by(fastforce simp add: modifies_no_var_asm_not_written)"], ["proof (state)\nthis:\n  \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x\n\ngoal (1 subgoal):\n 1. (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A]\n         x \\<noteq>\n        dma (subst \\<sigma>' (fst (mems ! i))) x \\<longrightarrow>\n        \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x) \\<and>\n    (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        Low \\<and>\n        (x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n         x \\<in> \\<C>) \\<longrightarrow>\n        subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A]\n         x \\<noteq>\n        dma (subst \\<sigma>' (fst (mems ! i))) x \\<longrightarrow>\n        \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x) \\<and>\n    (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        Low \\<and>\n        (x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n         x \\<in> \\<C>) \\<longrightarrow>\n        subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x)", "have reclas: \"(\\<forall>x. dma ((subst \\<sigma>' (fst (mems ! i))) [\\<parallel>\\<^sub>1 A]) x \\<noteq> dma (subst \\<sigma>' (fst (mems ! i))) x \\<longrightarrow>\n         \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A]\n        x \\<noteq>\n       dma (subst \\<sigma>' (fst (mems ! i))) x \\<longrightarrow>\n       \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x", "apply(simp add: adapt_eq dma_eq dma_eq'')"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x \\<longrightarrow>\n       \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x", "apply(simp add: modifies_no_var_asm_not_written)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>x.\n     dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x \\<noteq>\n     dma (subst \\<sigma>' (fst (mems ! i))) x \\<longrightarrow>\n     \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x\n\ngoal (1 subgoal):\n 1. (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A]\n         x \\<noteq>\n        dma (subst \\<sigma>' (fst (mems ! i))) x \\<longrightarrow>\n        \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x) \\<and>\n    (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        Low \\<and>\n        (x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n         x \\<in> \\<C>) \\<longrightarrow>\n        subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x)", "have \"snd (cms\\<^sub>2 ! i) = snd (cms\\<^sub>1 ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (cms\\<^sub>2 ! i) = snd (cms\\<^sub>1 ! i)", "by (metis \\<open>i < length cms\\<^sub>1\\<close> equal_size modes_eq nth_map)"], ["proof (state)\nthis:\n  snd (cms\\<^sub>2 ! i) = snd (cms\\<^sub>1 ! i)\n\ngoal (1 subgoal):\n 1. (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A]\n         x \\<noteq>\n        dma (subst \\<sigma>' (fst (mems ! i))) x \\<longrightarrow>\n        \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x) \\<and>\n    (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        Low \\<and>\n        (x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n         x \\<in> \\<C>) \\<longrightarrow>\n        subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x)", "hence low_mds_eq: \"(subst \\<sigma>' (fst (mems ! i))) =\\<^bsub>snd (cms\\<^sub>1 ! i)\\<^esub>\\<^sup>l (subst \\<sigma>' (snd (mems ! i)))\""], ["proof (prove)\nusing this:\n  snd (cms\\<^sub>2 ! i) = snd (cms\\<^sub>1 ! i)\n\ngoal (1 subgoal):\n 1. subst \\<sigma>'\n     (fst (mems !\n           i)) =\\<^bsub>snd (cms\\<^sub>1 ! i)\\<^esub>\\<^sup>l subst\n                         \\<sigma>' (snd (mems ! i))", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (cms\\<^sub>2 ! i) = snd (cms\\<^sub>1 ! i) \\<Longrightarrow>\n    subst \\<sigma>'\n     (fst (mems !\n           i)) =\\<^bsub>snd (cms\\<^sub>1 ! i)\\<^esub>\\<^sup>l subst\n                         \\<sigma>' (snd (mems ! i))", "apply(rule mm_equiv_low_eq[where c\\<^sub>1=\"fst (cms\\<^sub>1 ! i)\" and c\\<^sub>2=\"fst (cms\\<^sub>2 ! i)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (cms\\<^sub>2 ! i) = snd (cms\\<^sub>1 ! i) \\<Longrightarrow>\n    \\<langle>fst (cms\\<^sub>1 !\n                  i), snd (cms\\<^sub>1 !\n                           i), subst \\<sigma>'\n                                (fst (mems ! i))\\<rangle> \\<approx>\n    \\<langle>fst (cms\\<^sub>2 !\n                  i), snd (cms\\<^sub>1 !\n                           i), subst \\<sigma>' (snd (mems ! i))\\<rangle>", "using bisim"], ["proof (prove)\nusing this:\n  (cms\\<^sub>1 ! i, subst \\<sigma>' (fst (mems ! i))) \\<approx>\n  (cms\\<^sub>2 ! i, subst \\<sigma>' (snd (mems ! i)))\n\ngoal (1 subgoal):\n 1. snd (cms\\<^sub>2 ! i) = snd (cms\\<^sub>1 ! i) \\<Longrightarrow>\n    \\<langle>fst (cms\\<^sub>1 !\n                  i), snd (cms\\<^sub>1 !\n                           i), subst \\<sigma>'\n                                (fst (mems ! i))\\<rangle> \\<approx>\n    \\<langle>fst (cms\\<^sub>2 !\n                  i), snd (cms\\<^sub>1 !\n                           i), subst \\<sigma>' (snd (mems ! i))\\<rangle>", "by (metis prod.collapse)"], ["proof (state)\nthis:\n  subst \\<sigma>'\n   (fst (mems !\n         i)) =\\<^bsub>snd (cms\\<^sub>1 ! i)\\<^esub>\\<^sup>l subst \\<sigma>'\n                       (snd (mems ! i))\n\ngoal (1 subgoal):\n 1. (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A]\n         x \\<noteq>\n        dma (subst \\<sigma>' (fst (mems ! i))) x \\<longrightarrow>\n        \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x) \\<and>\n    (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        Low \\<and>\n        (x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n         x \\<in> \\<C>) \\<longrightarrow>\n        subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x)", "have \"snd (cms\\<^sub>2 ! k) = snd (cms\\<^sub>1 ! k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (cms\\<^sub>2 ! k) = snd (cms\\<^sub>1 ! k)", "by (metis b equal_size modes_eq nth_map)"], ["proof (state)\nthis:\n  snd (cms\\<^sub>2 ! k) = snd (cms\\<^sub>1 ! k)\n\ngoal (1 subgoal):\n 1. (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A]\n         x \\<noteq>\n        dma (subst \\<sigma>' (fst (mems ! i))) x \\<longrightarrow>\n        \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x) \\<and>\n    (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        Low \\<and>\n        (x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n         x \\<in> \\<C>) \\<longrightarrow>\n        subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x)", "hence low_mds_eq\\<^sub>k: \"(subst \\<sigma>'\\<^sub>k (fst (mems ! k))) =\\<^bsub>snd (cms\\<^sub>1 ! k)\\<^esub>\\<^sup>l (subst \\<sigma>'\\<^sub>k (snd (mems ! k)))\""], ["proof (prove)\nusing this:\n  snd (cms\\<^sub>2 ! k) = snd (cms\\<^sub>1 ! k)\n\ngoal (1 subgoal):\n 1. subst \\<sigma>'\\<^sub>k\n     (fst (mems !\n           k)) =\\<^bsub>snd (cms\\<^sub>1 ! k)\\<^esub>\\<^sup>l subst\n                         \\<sigma>'\\<^sub>k (snd (mems ! k))", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (cms\\<^sub>2 ! k) = snd (cms\\<^sub>1 ! k) \\<Longrightarrow>\n    subst \\<sigma>'\\<^sub>k\n     (fst (mems !\n           k)) =\\<^bsub>snd (cms\\<^sub>1 ! k)\\<^esub>\\<^sup>l subst\n                         \\<sigma>'\\<^sub>k (snd (mems ! k))", "apply(rule mm_equiv_low_eq[where c\\<^sub>1=\"fst (cms\\<^sub>1 ! k)\" and c\\<^sub>2=\"fst (cms\\<^sub>2 ! k)\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (cms\\<^sub>2 ! k) = snd (cms\\<^sub>1 ! k) \\<Longrightarrow>\n    \\<langle>fst (cms\\<^sub>1 !\n                  k), snd (cms\\<^sub>1 !\n                           k), subst \\<sigma>'\\<^sub>k\n                                (fst (mems ! k))\\<rangle> \\<approx>\n    \\<langle>fst (cms\\<^sub>2 !\n                  k), snd (cms\\<^sub>1 !\n                           k), subst \\<sigma>'\\<^sub>k\n                                (snd (mems ! k))\\<rangle>", "using bisim\\<^sub>k"], ["proof (prove)\nusing this:\n  (cms\\<^sub>1 ! k, subst \\<sigma>'\\<^sub>k (fst (mems ! k))) \\<approx>\n  (cms\\<^sub>2 ! k, subst \\<sigma>'\\<^sub>k (snd (mems ! k)))\n\ngoal (1 subgoal):\n 1. snd (cms\\<^sub>2 ! k) = snd (cms\\<^sub>1 ! k) \\<Longrightarrow>\n    \\<langle>fst (cms\\<^sub>1 !\n                  k), snd (cms\\<^sub>1 !\n                           k), subst \\<sigma>'\\<^sub>k\n                                (fst (mems ! k))\\<rangle> \\<approx>\n    \\<langle>fst (cms\\<^sub>2 !\n                  k), snd (cms\\<^sub>1 !\n                           k), subst \\<sigma>'\\<^sub>k\n                                (snd (mems ! k))\\<rangle>", "by (metis prod.collapse)"], ["proof (state)\nthis:\n  subst \\<sigma>'\\<^sub>k\n   (fst (mems !\n         k)) =\\<^bsub>snd (cms\\<^sub>1 ! k)\\<^esub>\\<^sup>l subst\n                       \\<sigma>'\\<^sub>k (snd (mems ! k))\n\ngoal (1 subgoal):\n 1. (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A]\n         x \\<noteq>\n        dma (subst \\<sigma>' (fst (mems ! i))) x \\<longrightarrow>\n        \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x) \\<and>\n    (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        Low \\<and>\n        (x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n         x \\<in> \\<C>) \\<longrightarrow>\n        subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x)", "have eq: \"\\<forall>x. dma ((subst \\<sigma>' (fst (mems ! i))) [\\<parallel>\\<^sub>1 A]) x = Low \\<and> (x \\<in> (snd (cms\\<^sub>1 ! i)) AsmNoReadOrWrite \\<longrightarrow> x \\<in> \\<C>) \\<longrightarrow>\n        (subst \\<sigma>' (fst (mems ! i))) [\\<parallel>\\<^sub>1 A] x = (subst \\<sigma>' (snd (mems ! i))) [\\<parallel>\\<^sub>2 A] x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n       Low \\<and>\n       (x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>) \\<longrightarrow>\n       subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n       subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x", "(* FIXME: clean up *)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n       Low \\<and>\n       (x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>) \\<longrightarrow>\n       subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n       subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x", "apply(clarsimp simp: adapt_eq dma_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> subst \\<sigma> (fst (mems' ! i)) x =\n                         subst \\<sigma> (snd (mems' ! i)) x", "apply(case_tac \"x \\<in> dom \\<sigma>\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        x \\<in> dom \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> subst \\<sigma> (fst (mems' ! i)) x =\n                         subst \\<sigma> (snd (mems' ! i)) x\n 2. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        x \\<notin> dom \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> subst \\<sigma> (fst (mems' ! i)) x =\n                         subst \\<sigma> (snd (mems' ! i)) x", "apply(force simp: subst_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        x \\<notin> dom \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> subst \\<sigma> (fst (mems' ! i)) x =\n                         subst \\<sigma> (snd (mems' ! i)) x", "apply(simp add: subst_not_in_dom)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        x \\<notin> dom \\<sigma>\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = snd (mems' ! i) x", "apply(simp add: dom\\<sigma>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                    i\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = snd (mems' ! i) x", "apply(clarsimp simp: differing_vars_lists_def differing_vars_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems' ! i) x;\n        mem\\<^sub>2' x = snd (mems' ! i) x\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = snd (mems' ! i) x", "apply(case_tac \"i = k\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems' ! i) x;\n        mem\\<^sub>2' x = snd (mems' ! i) x; i = k\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = snd (mems' ! i) x\n 2. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems' ! i) x;\n        mem\\<^sub>2' x = snd (mems' ! i) x; i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = snd (mems' ! i) x", "apply(simp add: \\<open>i \\<noteq> k\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems' ! i) x;\n        mem\\<^sub>2' x = snd (mems' ! i) x; i \\<noteq> k\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = snd (mems' ! i) x", "apply(erule mems'_i_cases)"], ["proof (prove)\ngoal (6 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems' ! i) x;\n        mem\\<^sub>2' x = snd (mems' ! i) x\\<rbrakk>\n       \\<Longrightarrow> i < length cms\\<^sub>1\n 2. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems' ! i) x;\n        mem\\<^sub>2' x = snd (mems' ! i) x;\n        mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n        mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n        mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma mem\\<^sub>1' x = High;\n        fst (mems' ! i) x = mem\\<^sub>1' x;\n        snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = snd (mems' ! i) x\n 3. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems' ! i) x;\n        mem\\<^sub>2' x = snd (mems' ! i) x;\n        mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n        mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n        mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x; dma mem\\<^sub>1' x = Low;\n        fst (mems' ! i) x = some_val; snd (mems' ! i) x = some_val\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = snd (mems' ! i) x\n 4. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems' ! i) x;\n        mem\\<^sub>2' x = snd (mems' ! i) x; mem\\<^sub>1 x = mem\\<^sub>1' x;\n        mem\\<^sub>2 x = mem\\<^sub>2' x; dma mem\\<^sub>1 x = High;\n        dma mem\\<^sub>1' x = Low; fst (mems' ! i) x = mem\\<^sub>1 x;\n        snd (mems' ! i) x = mem\\<^sub>1 x\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = snd (mems' ! i) x\n 5. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems' ! i) x;\n        mem\\<^sub>2' x = snd (mems' ! i) x; mem\\<^sub>1 x = mem\\<^sub>1' x;\n        mem\\<^sub>2 x = mem\\<^sub>2' x;\n        dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High;\n        dma mem\\<^sub>1' x = dma mem\\<^sub>1 x;\n        fst (mems' ! i) x = fst (mems ! i) x;\n        snd (mems' ! i) x = snd (mems ! i) x\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = snd (mems' ! i) x\n 6. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems' ! i) x;\n        mem\\<^sub>2' x = snd (mems' ! i) x; mem\\<^sub>1 x = mem\\<^sub>1' x;\n        mem\\<^sub>2 x = mem\\<^sub>2' x; dma mem\\<^sub>1 x = Low;\n        dma mem\\<^sub>1' x = High; fst (mems' ! i) x = mem\\<^sub>1' x;\n        snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = snd (mems' ! i) x", "apply(rule \\<open>i < length cms\\<^sub>1'\\<close>[simplified len_unchanged])"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems' ! i) x;\n        mem\\<^sub>2' x = snd (mems' ! i) x;\n        mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n        mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n        mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma mem\\<^sub>1' x = High;\n        fst (mems' ! i) x = mem\\<^sub>1' x;\n        snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = snd (mems' ! i) x\n 2. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems' ! i) x;\n        mem\\<^sub>2' x = snd (mems' ! i) x;\n        mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n        mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n        mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x; dma mem\\<^sub>1' x = Low;\n        fst (mems' ! i) x = some_val; snd (mems' ! i) x = some_val\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = snd (mems' ! i) x\n 3. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems' ! i) x;\n        mem\\<^sub>2' x = snd (mems' ! i) x; mem\\<^sub>1 x = mem\\<^sub>1' x;\n        mem\\<^sub>2 x = mem\\<^sub>2' x; dma mem\\<^sub>1 x = High;\n        dma mem\\<^sub>1' x = Low; fst (mems' ! i) x = mem\\<^sub>1 x;\n        snd (mems' ! i) x = mem\\<^sub>1 x\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = snd (mems' ! i) x\n 4. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems' ! i) x;\n        mem\\<^sub>2' x = snd (mems' ! i) x; mem\\<^sub>1 x = mem\\<^sub>1' x;\n        mem\\<^sub>2 x = mem\\<^sub>2' x;\n        dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High;\n        dma mem\\<^sub>1' x = dma mem\\<^sub>1 x;\n        fst (mems' ! i) x = fst (mems ! i) x;\n        snd (mems' ! i) x = snd (mems ! i) x\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = snd (mems' ! i) x\n 5. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems' ! i) x;\n        mem\\<^sub>2' x = snd (mems' ! i) x; mem\\<^sub>1 x = mem\\<^sub>1' x;\n        mem\\<^sub>2 x = mem\\<^sub>2' x; dma mem\\<^sub>1 x = Low;\n        dma mem\\<^sub>1' x = High; fst (mems' ! i) x = mem\\<^sub>1' x;\n        snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = snd (mems' ! i) x", "apply force"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems' ! i) x;\n        mem\\<^sub>2' x = snd (mems' ! i) x;\n        mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n        mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n        mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x; dma mem\\<^sub>1' x = Low;\n        fst (mems' ! i) x = some_val; snd (mems' ! i) x = some_val\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = snd (mems' ! i) x\n 2. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems' ! i) x;\n        mem\\<^sub>2' x = snd (mems' ! i) x; mem\\<^sub>1 x = mem\\<^sub>1' x;\n        mem\\<^sub>2 x = mem\\<^sub>2' x; dma mem\\<^sub>1 x = High;\n        dma mem\\<^sub>1' x = Low; fst (mems' ! i) x = mem\\<^sub>1 x;\n        snd (mems' ! i) x = mem\\<^sub>1 x\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = snd (mems' ! i) x\n 3. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems' ! i) x;\n        mem\\<^sub>2' x = snd (mems' ! i) x; mem\\<^sub>1 x = mem\\<^sub>1' x;\n        mem\\<^sub>2 x = mem\\<^sub>2' x;\n        dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High;\n        dma mem\\<^sub>1' x = dma mem\\<^sub>1 x;\n        fst (mems' ! i) x = fst (mems ! i) x;\n        snd (mems' ! i) x = snd (mems ! i) x\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = snd (mems' ! i) x\n 4. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems' ! i) x;\n        mem\\<^sub>2' x = snd (mems' ! i) x; mem\\<^sub>1 x = mem\\<^sub>1' x;\n        mem\\<^sub>2 x = mem\\<^sub>2' x; dma mem\\<^sub>1 x = Low;\n        dma mem\\<^sub>1' x = High; fst (mems' ! i) x = mem\\<^sub>1' x;\n        snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = snd (mems' ! i) x", "apply fastforce"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems' ! i) x;\n        mem\\<^sub>2' x = snd (mems' ! i) x; mem\\<^sub>1 x = mem\\<^sub>1' x;\n        mem\\<^sub>2 x = mem\\<^sub>2' x; dma mem\\<^sub>1 x = High;\n        dma mem\\<^sub>1' x = Low; fst (mems' ! i) x = mem\\<^sub>1 x;\n        snd (mems' ! i) x = mem\\<^sub>1 x\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = snd (mems' ! i) x\n 2. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems' ! i) x;\n        mem\\<^sub>2' x = snd (mems' ! i) x; mem\\<^sub>1 x = mem\\<^sub>1' x;\n        mem\\<^sub>2 x = mem\\<^sub>2' x;\n        dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High;\n        dma mem\\<^sub>1' x = dma mem\\<^sub>1 x;\n        fst (mems' ! i) x = fst (mems ! i) x;\n        snd (mems' ! i) x = snd (mems ! i) x\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = snd (mems' ! i) x\n 3. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems' ! i) x;\n        mem\\<^sub>2' x = snd (mems' ! i) x; mem\\<^sub>1 x = mem\\<^sub>1' x;\n        mem\\<^sub>2 x = mem\\<^sub>2' x; dma mem\\<^sub>1 x = Low;\n        dma mem\\<^sub>1' x = High; fst (mems' ! i) x = mem\\<^sub>1' x;\n        snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = snd (mems' ! i) x", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems' ! i) x;\n        mem\\<^sub>2' x = snd (mems' ! i) x; mem\\<^sub>1 x = mem\\<^sub>1' x;\n        mem\\<^sub>2 x = mem\\<^sub>2' x;\n        dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High;\n        dma mem\\<^sub>1' x = dma mem\\<^sub>1 x;\n        fst (mems' ! i) x = fst (mems ! i) x;\n        snd (mems' ! i) x = snd (mems ! i) x\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = snd (mems' ! i) x\n 2. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems' ! i) x;\n        mem\\<^sub>2' x = snd (mems' ! i) x; mem\\<^sub>1 x = mem\\<^sub>1' x;\n        mem\\<^sub>2 x = mem\\<^sub>2' x; dma mem\\<^sub>1 x = Low;\n        dma mem\\<^sub>1' x = High; fst (mems' ! i) x = mem\\<^sub>1' x;\n        snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = snd (mems' ! i) x", "apply clarsimp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1 x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems ! i) x;\n        mem\\<^sub>2' x = snd (mems ! i) x; mem\\<^sub>1 x = fst (mems ! i) x;\n        mem\\<^sub>2 x = snd (mems ! i) x; dma mem\\<^sub>1' x = Low;\n        fst (mems' ! i) x = fst (mems ! i) x;\n        snd (mems' ! i) x = snd (mems ! i) x\\<rbrakk>\n       \\<Longrightarrow> fst (mems ! i) x = snd (mems ! i) x\n 2. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems' ! i) x;\n        mem\\<^sub>2' x = snd (mems' ! i) x; mem\\<^sub>1 x = mem\\<^sub>1' x;\n        mem\\<^sub>2 x = mem\\<^sub>2' x; dma mem\\<^sub>1 x = Low;\n        dma mem\\<^sub>1' x = High; fst (mems' ! i) x = mem\\<^sub>1' x;\n        snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = snd (mems' ! i) x", "apply(case_tac \"x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1 x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems ! i) x;\n        mem\\<^sub>2' x = snd (mems ! i) x; mem\\<^sub>1 x = fst (mems ! i) x;\n        mem\\<^sub>2 x = snd (mems ! i) x; dma mem\\<^sub>1' x = Low;\n        fst (mems' ! i) x = fst (mems ! i) x;\n        snd (mems' ! i) x = snd (mems ! i) x;\n        x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\\<rbrakk>\n       \\<Longrightarrow> fst (mems ! i) x = snd (mems ! i) x\n 2. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1 x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems ! i) x;\n        mem\\<^sub>2' x = snd (mems ! i) x; mem\\<^sub>1 x = fst (mems ! i) x;\n        mem\\<^sub>2 x = snd (mems ! i) x; dma mem\\<^sub>1' x = Low;\n        fst (mems' ! i) x = fst (mems ! i) x;\n        snd (mems' ! i) x = snd (mems ! i) x;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                    i\\<rbrakk>\n       \\<Longrightarrow> fst (mems ! i) x = snd (mems ! i) x\n 3. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems' ! i) x;\n        mem\\<^sub>2' x = snd (mems' ! i) x; mem\\<^sub>1 x = mem\\<^sub>1' x;\n        mem\\<^sub>2 x = mem\\<^sub>2' x; dma mem\\<^sub>1 x = Low;\n        dma mem\\<^sub>1' x = High; fst (mems' ! i) x = mem\\<^sub>1' x;\n        snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = snd (mems' ! i) x", "apply(force simp: differing_vars_lists_def differing_vars_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1 x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems ! i) x;\n        mem\\<^sub>2' x = snd (mems ! i) x; mem\\<^sub>1 x = fst (mems ! i) x;\n        mem\\<^sub>2 x = snd (mems ! i) x; dma mem\\<^sub>1' x = Low;\n        fst (mems' ! i) x = fst (mems ! i) x;\n        snd (mems' ! i) x = snd (mems ! i) x;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                    i\\<rbrakk>\n       \\<Longrightarrow> fst (mems ! i) x = snd (mems ! i) x\n 2. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems' ! i) x;\n        mem\\<^sub>2' x = snd (mems' ! i) x; mem\\<^sub>1 x = mem\\<^sub>1' x;\n        mem\\<^sub>2 x = mem\\<^sub>2' x; dma mem\\<^sub>1 x = Low;\n        dma mem\\<^sub>1' x = High; fst (mems' ! i) x = mem\\<^sub>1' x;\n        snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = snd (mems' ! i) x", "apply(insert low_mds_eq)[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1 x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems ! i) x;\n        mem\\<^sub>2' x = snd (mems ! i) x; mem\\<^sub>1 x = fst (mems ! i) x;\n        mem\\<^sub>2 x = snd (mems ! i) x; dma mem\\<^sub>1' x = Low;\n        fst (mems' ! i) x = fst (mems ! i) x;\n        snd (mems' ! i) x = snd (mems ! i) x;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i;\n        subst \\<sigma>'\n         (fst (mems !\n               i)) =\\<^bsub>snd (cms\\<^sub>1 ! i)\\<^esub>\\<^sup>l subst\n                             \\<sigma>' (snd (mems ! i))\\<rbrakk>\n       \\<Longrightarrow> fst (mems ! i) x = snd (mems ! i) x\n 2. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems' ! i) x;\n        mem\\<^sub>2' x = snd (mems' ! i) x; mem\\<^sub>1 x = mem\\<^sub>1' x;\n        mem\\<^sub>2 x = mem\\<^sub>2' x; dma mem\\<^sub>1 x = Low;\n        dma mem\\<^sub>1' x = High; fst (mems' ! i) x = mem\\<^sub>1' x;\n        snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = snd (mems' ! i) x", "apply(simp add: low_mds_eq_def)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1 x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems ! i) x;\n        mem\\<^sub>2' x = snd (mems ! i) x; mem\\<^sub>1 x = fst (mems ! i) x;\n        mem\\<^sub>2 x = snd (mems ! i) x; dma mem\\<^sub>1' x = Low;\n        fst (mems' ! i) x = fst (mems ! i) x;\n        snd (mems' ! i) x = snd (mems ! i) x;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i;\n        \\<forall>x.\n           dma (subst \\<sigma>' (fst (mems ! i))) x = Low \\<and>\n           (x \\<in> \\<C> \\<or>\n            x \\<notin> snd (cms\\<^sub>1 ! i)\n                        AsmNoReadOrWrite) \\<longrightarrow>\n           subst \\<sigma>' (fst (mems ! i)) x =\n           subst \\<sigma>' (snd (mems ! i)) x\\<rbrakk>\n       \\<Longrightarrow> fst (mems ! i) x = snd (mems ! i) x\n 2. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems' ! i) x;\n        mem\\<^sub>2' x = snd (mems' ! i) x; mem\\<^sub>1 x = mem\\<^sub>1' x;\n        mem\\<^sub>2 x = mem\\<^sub>2' x; dma mem\\<^sub>1 x = Low;\n        dma mem\\<^sub>1' x = High; fst (mems' ! i) x = mem\\<^sub>1' x;\n        snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = snd (mems' ! i) x", "apply(drule_tac x=x in spec)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1 x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems ! i) x;\n        mem\\<^sub>2' x = snd (mems ! i) x; mem\\<^sub>1 x = fst (mems ! i) x;\n        mem\\<^sub>2 x = snd (mems ! i) x; dma mem\\<^sub>1' x = Low;\n        fst (mems' ! i) x = fst (mems ! i) x;\n        snd (mems' ! i) x = snd (mems ! i) x;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i;\n        dma (subst \\<sigma>' (fst (mems ! i))) x = Low \\<and>\n        (x \\<in> \\<C> \\<or>\n         x \\<notin> snd (cms\\<^sub>1 ! i)\n                     AsmNoReadOrWrite) \\<longrightarrow>\n        subst \\<sigma>' (fst (mems ! i)) x =\n        subst \\<sigma>' (snd (mems ! i)) x\\<rbrakk>\n       \\<Longrightarrow> fst (mems ! i) x = snd (mems ! i) x\n 2. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems' ! i) x;\n        mem\\<^sub>2' x = snd (mems' ! i) x; mem\\<^sub>1 x = mem\\<^sub>1' x;\n        mem\\<^sub>2 x = mem\\<^sub>2' x; dma mem\\<^sub>1 x = Low;\n        dma mem\\<^sub>1' x = High; fst (mems' ! i) x = mem\\<^sub>1' x;\n        snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = snd (mems' ! i) x", "apply(subst (asm) makes_compatible_dma_eq)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1 x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems ! i) x;\n        mem\\<^sub>2' x = snd (mems ! i) x; mem\\<^sub>1 x = fst (mems ! i) x;\n        mem\\<^sub>2 x = snd (mems ! i) x; dma mem\\<^sub>1' x = Low;\n        fst (mems' ! i) x = fst (mems ! i) x;\n        snd (mems' ! i) x = snd (mems ! i) x;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                    i\\<rbrakk>\n       \\<Longrightarrow> makes_compatible\n                          (?cms\\<^sub>149 x, ?mem\\<^sub>149 x)\n                          (?cms\\<^sub>249 x, ?mem\\<^sub>249 x) mems\n 2. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1 x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems ! i) x;\n        mem\\<^sub>2' x = snd (mems ! i) x; mem\\<^sub>1 x = fst (mems ! i) x;\n        mem\\<^sub>2 x = snd (mems ! i) x; dma mem\\<^sub>1' x = Low;\n        fst (mems' ! i) x = fst (mems ! i) x;\n        snd (mems' ! i) x = snd (mems ! i) x;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                    i\\<rbrakk>\n       \\<Longrightarrow> i < length (?cms\\<^sub>149 x)\n 3. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1 x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems ! i) x;\n        mem\\<^sub>2' x = snd (mems ! i) x; mem\\<^sub>1 x = fst (mems ! i) x;\n        mem\\<^sub>2 x = snd (mems ! i) x; dma mem\\<^sub>1' x = Low;\n        fst (mems' ! i) x = fst (mems ! i) x;\n        snd (mems' ! i) x = snd (mems ! i) x;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                    i\\<rbrakk>\n       \\<Longrightarrow> dom \\<sigma>' =\n                         differing_vars_lists (?mem\\<^sub>149 x)\n                          (?mem\\<^sub>249 x) mems i\n 4. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1 x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems ! i) x;\n        mem\\<^sub>2' x = snd (mems ! i) x; mem\\<^sub>1 x = fst (mems ! i) x;\n        mem\\<^sub>2 x = snd (mems ! i) x; dma mem\\<^sub>1' x = Low;\n        fst (mems' ! i) x = fst (mems ! i) x;\n        snd (mems' ! i) x = snd (mems ! i) x;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i;\n        dma (?mem\\<^sub>149 x) x = Low \\<and>\n        (x \\<in> \\<C> \\<or>\n         x \\<notin> snd (cms\\<^sub>1 ! i)\n                     AsmNoReadOrWrite) \\<longrightarrow>\n        subst \\<sigma>' (fst (mems ! i)) x =\n        subst \\<sigma>' (snd (mems ! i)) x\\<rbrakk>\n       \\<Longrightarrow> fst (mems ! i) x = snd (mems ! i) x\n 5. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems' ! i) x;\n        mem\\<^sub>2' x = snd (mems' ! i) x; mem\\<^sub>1 x = mem\\<^sub>1' x;\n        mem\\<^sub>2 x = mem\\<^sub>2' x; dma mem\\<^sub>1 x = Low;\n        dma mem\\<^sub>1' x = High; fst (mems' ! i) x = mem\\<^sub>1' x;\n        snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = snd (mems' ! i) x", "apply(rule compat)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1 x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems ! i) x;\n        mem\\<^sub>2' x = snd (mems ! i) x; mem\\<^sub>1 x = fst (mems ! i) x;\n        mem\\<^sub>2 x = snd (mems ! i) x; dma mem\\<^sub>1' x = Low;\n        fst (mems' ! i) x = fst (mems ! i) x;\n        snd (mems' ! i) x = snd (mems ! i) x;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                    i\\<rbrakk>\n       \\<Longrightarrow> i < length cms\\<^sub>1\n 2. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1 x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems ! i) x;\n        mem\\<^sub>2' x = snd (mems ! i) x; mem\\<^sub>1 x = fst (mems ! i) x;\n        mem\\<^sub>2 x = snd (mems ! i) x; dma mem\\<^sub>1' x = Low;\n        fst (mems' ! i) x = fst (mems ! i) x;\n        snd (mems' ! i) x = snd (mems ! i) x;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                    i\\<rbrakk>\n       \\<Longrightarrow> dom \\<sigma>' =\n                         differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n 3. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1 x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems ! i) x;\n        mem\\<^sub>2' x = snd (mems ! i) x; mem\\<^sub>1 x = fst (mems ! i) x;\n        mem\\<^sub>2 x = snd (mems ! i) x; dma mem\\<^sub>1' x = Low;\n        fst (mems' ! i) x = fst (mems ! i) x;\n        snd (mems' ! i) x = snd (mems ! i) x;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i;\n        dma mem\\<^sub>1 x = Low \\<and>\n        (x \\<in> \\<C> \\<or>\n         x \\<notin> snd (cms\\<^sub>1 ! i)\n                     AsmNoReadOrWrite) \\<longrightarrow>\n        subst \\<sigma>' (fst (mems ! i)) x =\n        subst \\<sigma>' (snd (mems ! i)) x\\<rbrakk>\n       \\<Longrightarrow> fst (mems ! i) x = snd (mems ! i) x\n 4. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems' ! i) x;\n        mem\\<^sub>2' x = snd (mems' ! i) x; mem\\<^sub>1 x = mem\\<^sub>1' x;\n        mem\\<^sub>2 x = mem\\<^sub>2' x; dma mem\\<^sub>1 x = Low;\n        dma mem\\<^sub>1' x = High; fst (mems' ! i) x = mem\\<^sub>1' x;\n        snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = snd (mems' ! i) x", "apply(rule \\<open>i < length cms\\<^sub>1\\<close>)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1 x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems ! i) x;\n        mem\\<^sub>2' x = snd (mems ! i) x; mem\\<^sub>1 x = fst (mems ! i) x;\n        mem\\<^sub>2 x = snd (mems ! i) x; dma mem\\<^sub>1' x = Low;\n        fst (mems' ! i) x = fst (mems ! i) x;\n        snd (mems' ! i) x = snd (mems ! i) x;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                    i\\<rbrakk>\n       \\<Longrightarrow> dom \\<sigma>' =\n                         differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n 2. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1 x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems ! i) x;\n        mem\\<^sub>2' x = snd (mems ! i) x; mem\\<^sub>1 x = fst (mems ! i) x;\n        mem\\<^sub>2 x = snd (mems ! i) x; dma mem\\<^sub>1' x = Low;\n        fst (mems' ! i) x = fst (mems ! i) x;\n        snd (mems' ! i) x = snd (mems ! i) x;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i;\n        dma mem\\<^sub>1 x = Low \\<and>\n        (x \\<in> \\<C> \\<or>\n         x \\<notin> snd (cms\\<^sub>1 ! i)\n                     AsmNoReadOrWrite) \\<longrightarrow>\n        subst \\<sigma>' (fst (mems ! i)) x =\n        subst \\<sigma>' (snd (mems ! i)) x\\<rbrakk>\n       \\<Longrightarrow> fst (mems ! i) x = snd (mems ! i) x\n 3. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems' ! i) x;\n        mem\\<^sub>2' x = snd (mems' ! i) x; mem\\<^sub>1 x = mem\\<^sub>1' x;\n        mem\\<^sub>2 x = mem\\<^sub>2' x; dma mem\\<^sub>1 x = Low;\n        dma mem\\<^sub>1' x = High; fst (mems' ! i) x = mem\\<^sub>1' x;\n        snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = snd (mems' ! i) x", "apply(rule \\<open>dom \\<sigma>' = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\\<close>)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1 x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems ! i) x;\n        mem\\<^sub>2' x = snd (mems ! i) x; mem\\<^sub>1 x = fst (mems ! i) x;\n        mem\\<^sub>2 x = snd (mems ! i) x; dma mem\\<^sub>1' x = Low;\n        fst (mems' ! i) x = fst (mems ! i) x;\n        snd (mems' ! i) x = snd (mems ! i) x;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i;\n        dma mem\\<^sub>1 x = Low \\<and>\n        (x \\<in> \\<C> \\<or>\n         x \\<notin> snd (cms\\<^sub>1 ! i)\n                     AsmNoReadOrWrite) \\<longrightarrow>\n        subst \\<sigma>' (fst (mems ! i)) x =\n        subst \\<sigma>' (snd (mems ! i)) x\\<rbrakk>\n       \\<Longrightarrow> fst (mems ! i) x = snd (mems ! i) x\n 2. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems' ! i) x;\n        mem\\<^sub>2' x = snd (mems' ! i) x; mem\\<^sub>1 x = mem\\<^sub>1' x;\n        mem\\<^sub>2 x = mem\\<^sub>2' x; dma mem\\<^sub>1 x = Low;\n        dma mem\\<^sub>1' x = High; fst (mems' ! i) x = mem\\<^sub>1' x;\n        snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = snd (mems' ! i) x", "apply simp"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1 x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems ! i) x;\n        mem\\<^sub>2' x = snd (mems ! i) x; mem\\<^sub>1 x = fst (mems ! i) x;\n        mem\\<^sub>2 x = snd (mems ! i) x; dma mem\\<^sub>1' x = Low;\n        fst (mems' ! i) x = fst (mems ! i) x;\n        snd (mems' ! i) x = snd (mems ! i) x;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i;\n        (x \\<in> \\<C> \\<longrightarrow>\n         subst \\<sigma>' (fst (mems ! i)) x =\n         subst \\<sigma>' (snd (mems ! i)) x) \\<and>\n        (x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n         subst \\<sigma>' (fst (mems ! i)) x =\n         subst \\<sigma>' (snd (mems ! i)) x)\\<rbrakk>\n       \\<Longrightarrow> fst (mems ! i) x = snd (mems ! i) x\n 2. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems' ! i) x;\n        mem\\<^sub>2' x = snd (mems' ! i) x; mem\\<^sub>1 x = mem\\<^sub>1' x;\n        mem\\<^sub>2 x = mem\\<^sub>2' x; dma mem\\<^sub>1 x = Low;\n        dma mem\\<^sub>1' x = High; fst (mems' ! i) x = mem\\<^sub>1' x;\n        snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = snd (mems' ! i) x", "apply(subgoal_tac \"x \\<notin> dom \\<sigma>'\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1 x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems ! i) x;\n        mem\\<^sub>2' x = snd (mems ! i) x; mem\\<^sub>1 x = fst (mems ! i) x;\n        mem\\<^sub>2 x = snd (mems ! i) x; dma mem\\<^sub>1' x = Low;\n        fst (mems' ! i) x = fst (mems ! i) x;\n        snd (mems' ! i) x = snd (mems ! i) x;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i;\n        (x \\<in> \\<C> \\<longrightarrow>\n         subst \\<sigma>' (fst (mems ! i)) x =\n         subst \\<sigma>' (snd (mems ! i)) x) \\<and>\n        (x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n         subst \\<sigma>' (fst (mems ! i)) x =\n         subst \\<sigma>' (snd (mems ! i)) x);\n        x \\<notin> dom \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> fst (mems ! i) x = snd (mems ! i) x\n 2. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1 x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems ! i) x;\n        mem\\<^sub>2' x = snd (mems ! i) x; mem\\<^sub>1 x = fst (mems ! i) x;\n        mem\\<^sub>2 x = snd (mems ! i) x; dma mem\\<^sub>1' x = Low;\n        fst (mems' ! i) x = fst (mems ! i) x;\n        snd (mems' ! i) x = snd (mems ! i) x;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i;\n        (x \\<in> \\<C> \\<longrightarrow>\n         subst \\<sigma>' (fst (mems ! i)) x =\n         subst \\<sigma>' (snd (mems ! i)) x) \\<and>\n        (x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n         subst \\<sigma>' (fst (mems ! i)) x =\n         subst \\<sigma>' (snd (mems ! i)) x)\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> dom \\<sigma>'\n 3. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems' ! i) x;\n        mem\\<^sub>2' x = snd (mems' ! i) x; mem\\<^sub>1 x = mem\\<^sub>1' x;\n        mem\\<^sub>2 x = mem\\<^sub>2' x; dma mem\\<^sub>1 x = Low;\n        dma mem\\<^sub>1' x = High; fst (mems' ! i) x = mem\\<^sub>1' x;\n        snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = snd (mems' ! i) x", "apply(simp add: subst_not_in_dom)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1 x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems ! i) x;\n        mem\\<^sub>2' x = snd (mems ! i) x; mem\\<^sub>1 x = fst (mems ! i) x;\n        mem\\<^sub>2 x = snd (mems ! i) x; dma mem\\<^sub>1' x = Low;\n        fst (mems' ! i) x = fst (mems ! i) x;\n        snd (mems' ! i) x = snd (mems ! i) x;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i;\n        (x \\<in> \\<C> \\<longrightarrow>\n         fst (mems ! i) x = snd (mems ! i) x) \\<and>\n        (x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n         fst (mems ! i) x = snd (mems ! i) x);\n        x \\<notin> dom \\<sigma>'\\<rbrakk>\n       \\<Longrightarrow> fst (mems ! i) x = snd (mems ! i) x\n 2. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1 x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems ! i) x;\n        mem\\<^sub>2' x = snd (mems ! i) x; mem\\<^sub>1 x = fst (mems ! i) x;\n        mem\\<^sub>2 x = snd (mems ! i) x; dma mem\\<^sub>1' x = Low;\n        fst (mems' ! i) x = fst (mems ! i) x;\n        snd (mems' ! i) x = snd (mems ! i) x;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i;\n        (x \\<in> \\<C> \\<longrightarrow>\n         subst \\<sigma>' (fst (mems ! i)) x =\n         subst \\<sigma>' (snd (mems ! i)) x) \\<and>\n        (x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n         subst \\<sigma>' (fst (mems ! i)) x =\n         subst \\<sigma>' (snd (mems ! i)) x)\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> dom \\<sigma>'\n 3. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems' ! i) x;\n        mem\\<^sub>2' x = snd (mems' ! i) x; mem\\<^sub>1 x = mem\\<^sub>1' x;\n        mem\\<^sub>2 x = mem\\<^sub>2' x; dma mem\\<^sub>1 x = Low;\n        dma mem\\<^sub>1' x = High; fst (mems' ! i) x = mem\\<^sub>1' x;\n        snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = snd (mems' ! i) x", "apply force"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1 x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems ! i) x;\n        mem\\<^sub>2' x = snd (mems ! i) x; mem\\<^sub>1 x = fst (mems ! i) x;\n        mem\\<^sub>2 x = snd (mems ! i) x; dma mem\\<^sub>1' x = Low;\n        fst (mems' ! i) x = fst (mems ! i) x;\n        snd (mems' ! i) x = snd (mems ! i) x;\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i;\n        (x \\<in> \\<C> \\<longrightarrow>\n         subst \\<sigma>' (fst (mems ! i)) x =\n         subst \\<sigma>' (snd (mems ! i)) x) \\<and>\n        (x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n         subst \\<sigma>' (fst (mems ! i)) x =\n         subst \\<sigma>' (snd (mems ! i)) x)\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> dom \\<sigma>'\n 2. \\<And>x.\n       \\<lbrakk>dma mem\\<^sub>1' x = Low;\n        x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n        x \\<in> \\<C>;\n        mem\\<^sub>1' x = fst (mems' ! i) x;\n        mem\\<^sub>2' x = snd (mems' ! i) x; mem\\<^sub>1 x = mem\\<^sub>1' x;\n        mem\\<^sub>2 x = mem\\<^sub>2' x; dma mem\\<^sub>1 x = Low;\n        dma mem\\<^sub>1' x = High; fst (mems' ! i) x = mem\\<^sub>1' x;\n        snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n       \\<Longrightarrow> fst (mems' ! i) x = snd (mems' ! i) x", "apply(simp add: \\<open>dom \\<sigma>' = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\\<close>)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  \\<forall>x.\n     dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n     Low \\<and>\n     (x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n      x \\<in> \\<C>) \\<longrightarrow>\n     subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n     subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x\n\ngoal (1 subgoal):\n 1. (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A]\n         x \\<noteq>\n        dma (subst \\<sigma>' (fst (mems ! i))) x \\<longrightarrow>\n        \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x) \\<and>\n    (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        Low \\<and>\n        (x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n         x \\<in> \\<C>) \\<longrightarrow>\n        subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x)", "from reclas eq"], ["proof (chain)\npicking this:\n  \\<forall>x.\n     dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x \\<noteq>\n     dma (subst \\<sigma>' (fst (mems ! i))) x \\<longrightarrow>\n     \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x\n  \\<forall>x.\n     dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n     Low \\<and>\n     (x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n      x \\<in> \\<C>) \\<longrightarrow>\n     subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n     subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x", "show \" (\\<forall>x. dma ((subst \\<sigma>' (fst (mems ! i))) [\\<parallel>\\<^sub>1 A]) x \\<noteq> dma (subst \\<sigma>' (fst (mems ! i))) x \\<longrightarrow>\n         \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x) \\<and>\n    (\\<forall>x. dma ((subst \\<sigma>' (fst (mems ! i))) [\\<parallel>\\<^sub>1 A]) x = Low \\<and> (x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow> x \\<in> \\<C>) \\<longrightarrow>\n         (subst \\<sigma>' (fst (mems ! i))) [\\<parallel>\\<^sub>1 A] x = (subst \\<sigma>' (snd (mems ! i))) [\\<parallel>\\<^sub>2 A] x)\""], ["proof (prove)\nusing this:\n  \\<forall>x.\n     dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x \\<noteq>\n     dma (subst \\<sigma>' (fst (mems ! i))) x \\<longrightarrow>\n     \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x\n  \\<forall>x.\n     dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n     Low \\<and>\n     (x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n      x \\<in> \\<C>) \\<longrightarrow>\n     subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n     subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x\n\ngoal (1 subgoal):\n 1. (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A]\n         x \\<noteq>\n        dma (subst \\<sigma>' (fst (mems ! i))) x \\<longrightarrow>\n        \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x) \\<and>\n    (\\<forall>x.\n        dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        Low \\<and>\n        (x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n         x \\<in> \\<C>) \\<longrightarrow>\n        subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n        subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x)", "by blast"], ["proof (state)\nthis:\n  (\\<forall>x.\n      dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A]\n       x \\<noteq>\n      dma (subst \\<sigma>' (fst (mems ! i))) x \\<longrightarrow>\n      \\<not> var_asm_not_written (snd (cms\\<^sub>1 ! i)) x) \\<and>\n  (\\<forall>x.\n      dma subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n      Low \\<and>\n      (x \\<in> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite \\<longrightarrow>\n       x \\<in> \\<C>) \\<longrightarrow>\n      subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] x =\n      subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  globally_consistent A (snd (cms\\<^sub>1 ! i))\n   (subst \\<sigma>' (fst (mems ! i))) (subst \\<sigma>' (snd (mems ! i)))\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "have \"snd (cms\\<^sub>1 ! i) = snd (cms\\<^sub>2 ! i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (cms\\<^sub>1 ! i) = snd (cms\\<^sub>2 ! i)", "by (metis \\<open>i < length cms\\<^sub>1\\<close> equal_size modes_eq nth_map)"], ["proof (state)\nthis:\n  snd (cms\\<^sub>1 ! i) = snd (cms\\<^sub>2 ! i)\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "with bisim"], ["proof (chain)\npicking this:\n  (cms\\<^sub>1 ! i, subst \\<sigma>' (fst (mems ! i))) \\<approx>\n  (cms\\<^sub>2 ! i, subst \\<sigma>' (snd (mems ! i)))\n  snd (cms\\<^sub>1 ! i) = snd (cms\\<^sub>2 ! i)", "have \"(cms\\<^sub>1 ! i, ?mems\\<^sub>1i [\\<mapsto> \\<sigma>'] [\\<parallel>\\<^sub>1 A]) \\<approx> (cms\\<^sub>2 ! i, ?mems\\<^sub>2i [\\<mapsto> \\<sigma>'] [\\<parallel>\\<^sub>2 A])\""], ["proof (prove)\nusing this:\n  (cms\\<^sub>1 ! i, subst \\<sigma>' (fst (mems ! i))) \\<approx>\n  (cms\\<^sub>2 ! i, subst \\<sigma>' (snd (mems ! i)))\n  snd (cms\\<^sub>1 ! i) = snd (cms\\<^sub>2 ! i)\n\ngoal (1 subgoal):\n 1. (cms\\<^sub>1 ! i,\n     subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A]) \\<approx>\n    (cms\\<^sub>2 ! i,\n     subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A])", "using A_correct'"], ["proof (prove)\nusing this:\n  (cms\\<^sub>1 ! i, subst \\<sigma>' (fst (mems ! i))) \\<approx>\n  (cms\\<^sub>2 ! i, subst \\<sigma>' (snd (mems ! i)))\n  snd (cms\\<^sub>1 ! i) = snd (cms\\<^sub>2 ! i)\n  globally_consistent A (snd (cms\\<^sub>1 ! i))\n   (subst \\<sigma>' (fst (mems ! i))) (subst \\<sigma>' (snd (mems ! i)))\n\ngoal (1 subgoal):\n 1. (cms\\<^sub>1 ! i,\n     subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A]) \\<approx>\n    (cms\\<^sub>2 ! i,\n     subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A])", "apply (subst surjective_pairing[of \"cms\\<^sub>1 ! i\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(cms\\<^sub>1 ! i, subst \\<sigma>' (fst (mems ! i))) \\<approx>\n             (cms\\<^sub>2 ! i, subst \\<sigma>' (snd (mems ! i)));\n     snd (cms\\<^sub>1 ! i) = snd (cms\\<^sub>2 ! i);\n     globally_consistent A (snd (cms\\<^sub>1 ! i))\n      (subst \\<sigma>' (fst (mems ! i)))\n      (subst \\<sigma>' (snd (mems ! i)))\\<rbrakk>\n    \\<Longrightarrow> \\<langle>fst (cms\\<^sub>1 !\n                                    i), snd\n   (cms\\<^sub>1 !\n    i), subst \\<sigma>'\n         (fst (mems ! i)) [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                      (cms\\<^sub>2 ! i,\n                       subst \\<sigma>'\n                        (snd (mems ! i)) [\\<parallel>\\<^sub>2 A])", "apply (subst surjective_pairing[of \"cms\\<^sub>2 ! i\"])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(cms\\<^sub>1 ! i, subst \\<sigma>' (fst (mems ! i))) \\<approx>\n             (cms\\<^sub>2 ! i, subst \\<sigma>' (snd (mems ! i)));\n     snd (cms\\<^sub>1 ! i) = snd (cms\\<^sub>2 ! i);\n     globally_consistent A (snd (cms\\<^sub>1 ! i))\n      (subst \\<sigma>' (fst (mems ! i)))\n      (subst \\<sigma>' (snd (mems ! i)))\\<rbrakk>\n    \\<Longrightarrow> \\<langle>fst (cms\\<^sub>1 !\n                                    i), snd\n   (cms\\<^sub>1 !\n    i), subst \\<sigma>'\n         (fst (mems ! i)) [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                      \\<langle>fst (cms\\<^sub>2 !\n                                    i), snd\n   (cms\\<^sub>2 !\n    i), subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A]\\<rangle>", "by (metis surjective_pairing globally_consistent_adapt_bisim)"], ["proof (state)\nthis:\n  (cms\\<^sub>1 ! i,\n   subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A]) \\<approx>\n  (cms\\<^sub>2 ! i,\n   subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A])\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (cms\\<^sub>1 ! i,\n   subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A]) \\<approx>\n  (cms\\<^sub>2 ! i,\n   subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A])\n\ngoal (1 subgoal):\n 1. (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "using adapt_eq"], ["proof (prove)\nusing this:\n  (cms\\<^sub>1 ! i,\n   subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A]) \\<approx>\n  (cms\\<^sub>2 ! i,\n   subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A])\n  subst \\<sigma>' (fst (mems ! i)) [\\<parallel>\\<^sub>1 A] =\n  subst \\<sigma> (fst (mems' ! i)) \\<and>\n  subst \\<sigma>' (snd (mems ! i)) [\\<parallel>\\<^sub>2 A] =\n  subst \\<sigma> (snd (mems' ! i))\n\ngoal (1 subgoal):\n 1. (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n    (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))", "by (metis \\<open>i \\<noteq> k\\<close> b cms\\<^sub>2'_def nth_list_update_neq)"], ["proof (state)\nthis:\n  (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n  (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (cms\\<^sub>1' ! i, subst \\<sigma> (fst (mems' ! i))) \\<approx>\n  (cms\\<^sub>2' ! i, subst \\<sigma> (snd (mems' ! i)))\n\ngoal (2 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>i < length cms\\<^sub>1';\n        mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\n        dma mem\\<^sub>1' x = High \\<or> x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                     mem\\<^sub>2' mems' i\n 2. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>i < length cms\\<^sub>1';\n        mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\n        dma mem\\<^sub>1' x = High \\<or> x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                     mem\\<^sub>2' mems' i\n 2. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "fix i x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>i < length cms\\<^sub>1';\n        mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\n        dma mem\\<^sub>1' x = High \\<or> x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                     mem\\<^sub>2' mems' i\n 2. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "let ?mems\\<^sub>1'i = \"fst (mems' ! i)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>i < length cms\\<^sub>1';\n        mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\n        dma mem\\<^sub>1' x = High \\<or> x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                     mem\\<^sub>2' mems' i\n 2. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "let ?mems\\<^sub>2'i = \"snd (mems' ! i)\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>i < length cms\\<^sub>1';\n        mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\n        dma mem\\<^sub>1' x = High \\<or> x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                     mem\\<^sub>2' mems' i\n 2. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "assume i_le: \"i < length cms\\<^sub>1'\""], ["proof (state)\nthis:\n  i < length cms\\<^sub>1'\n\ngoal (2 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>i < length cms\\<^sub>1';\n        mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\n        dma mem\\<^sub>1' x = High \\<or> x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                     mem\\<^sub>2' mems' i\n 2. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "assume mem_eq': \"mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma mem\\<^sub>1' x = High \\<or> x \\<in> \\<C>\""], ["proof (state)\nthis:\n  mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\n  dma mem\\<^sub>1' x = High \\<or> x \\<in> \\<C>\n\ngoal (2 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>i < length cms\\<^sub>1';\n        mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\n        dma mem\\<^sub>1' x = High \\<or> x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                     mem\\<^sub>2' mems' i\n 2. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "show \"x \\<notin> ?X' i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "proof (cases \"x \\<in> \\<C>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> \\<C> \\<Longrightarrow>\n    x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n 2. x \\<notin> \\<C> \\<Longrightarrow>\n    x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "assume \"x \\<in> \\<C>\""], ["proof (state)\nthis:\n  x \\<in> \\<C>\n\ngoal (2 subgoals):\n 1. x \\<in> \\<C> \\<Longrightarrow>\n    x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n 2. x \\<notin> \\<C> \\<Longrightarrow>\n    x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> \\<C>\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "by(metis not_control i_le)"], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. x \\<notin> \\<C> \\<Longrightarrow>\n    x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> \\<C> \\<Longrightarrow>\n    x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "assume \"x \\<notin> \\<C>\""], ["proof (state)\nthis:\n  x \\<notin> \\<C>\n\ngoal (1 subgoal):\n 1. x \\<notin> \\<C> \\<Longrightarrow>\n    x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "hence mem_eq: \"mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma mem\\<^sub>1' x = High\""], ["proof (prove)\nusing this:\n  x \\<notin> \\<C>\n\ngoal (1 subgoal):\n 1. mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma mem\\<^sub>1' x = High", "by(metis mem_eq')"], ["proof (state)\nthis:\n  mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma mem\\<^sub>1' x = High\n\ngoal (1 subgoal):\n 1. x \\<notin> \\<C> \\<Longrightarrow>\n    x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "thus ?thesis"], ["proof (prove)\nusing this:\n  mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma mem\\<^sub>1' x = High\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "proof (cases \"i = k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\n             dma mem\\<^sub>1' x = High;\n     i = k\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 2. \\<lbrakk>mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\n             dma mem\\<^sub>1' x = High;\n     i \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "assume \"i = k\""], ["proof (state)\nthis:\n  i = k\n\ngoal (2 subgoals):\n 1. \\<lbrakk>mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\n             dma mem\\<^sub>1' x = High;\n     i = k\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 2. \\<lbrakk>mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\n             dma mem\\<^sub>1' x = High;\n     i \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "thus \"x \\<notin> ?X' i\""], ["proof (prove)\nusing this:\n  i = k\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "apply (cases \"x \\<notin> ?X k\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>i = k;\n     x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 2. \\<lbrakk>i = k;\n     \\<not> x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                        k\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "apply (metis differing_vars_neg_intro mems'_k_1 mems'_k_2)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i = k;\n     \\<not> x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                        k\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "by(metis compat_different[OF compat] b mem_eq Sec.distinct(1) x_unchanged)"], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\n             dma mem\\<^sub>1' x = High;\n     i \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\n             dma mem\\<^sub>1' x = High;\n     i \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "assume \"i \\<noteq> k\""], ["proof (state)\nthis:\n  i \\<noteq> k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>mem\\<^sub>1' x = mem\\<^sub>2' x \\<or>\n             dma mem\\<^sub>1' x = High;\n     i \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "thus \"x \\<notin> ?X' i\""], ["proof (prove)\nusing this:\n  i \\<noteq> k\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "proof (rule mems'_i_cases)"], ["proof (state)\ngoal (6 subgoals):\n 1. i < length cms\\<^sub>1\n 2. \\<lbrakk>mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n             mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n     mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma mem\\<^sub>1' x = High;\n     fst (mems' ! i) x = mem\\<^sub>1' x;\n     snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 3. \\<lbrakk>mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n             mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n     mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x; dma mem\\<^sub>1' x = Low;\n     fst (mems' ! i) x = some_val; snd (mems' ! i) x = some_val\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 4. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = High; dma mem\\<^sub>1' x = Low;\n     fst (mems' ! i) x = mem\\<^sub>1 x;\n     snd (mems' ! i) x = mem\\<^sub>1 x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 5. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High;\n     dma mem\\<^sub>1' x = dma mem\\<^sub>1 x;\n     fst (mems' ! i) x = fst (mems ! i) x;\n     snd (mems' ! i) x = snd (mems ! i) x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 6. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = Low; dma mem\\<^sub>1' x = High;\n     fst (mems' ! i) x = mem\\<^sub>1' x;\n     snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "from b i_le"], ["proof (chain)\npicking this:\n  k < length cms\\<^sub>1 \\<and>\n  (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto>\n  (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n  cms\\<^sub>1' = cms\\<^sub>1[k := cms\\<^sub>1' ! k]\n  i < length cms\\<^sub>1'", "show \"i < length cms\\<^sub>1\""], ["proof (prove)\nusing this:\n  k < length cms\\<^sub>1 \\<and>\n  (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto>\n  (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n  cms\\<^sub>1' = cms\\<^sub>1[k := cms\\<^sub>1' ! k]\n  i < length cms\\<^sub>1'\n\ngoal (1 subgoal):\n 1. i < length cms\\<^sub>1", "by (metis length_list_update)"], ["proof (state)\nthis:\n  i < length cms\\<^sub>1\n\ngoal (5 subgoals):\n 1. \\<lbrakk>mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n             mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n     mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma mem\\<^sub>1' x = High;\n     fst (mems' ! i) x = mem\\<^sub>1' x;\n     snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 2. \\<lbrakk>mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n             mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n     mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x; dma mem\\<^sub>1' x = Low;\n     fst (mems' ! i) x = some_val; snd (mems' ! i) x = some_val\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 3. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = High; dma mem\\<^sub>1' x = Low;\n     fst (mems' ! i) x = mem\\<^sub>1 x;\n     snd (mems' ! i) x = mem\\<^sub>1 x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 4. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High;\n     dma mem\\<^sub>1' x = dma mem\\<^sub>1 x;\n     fst (mems' ! i) x = fst (mems ! i) x;\n     snd (mems' ! i) x = snd (mems ! i) x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 5. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = Low; dma mem\\<^sub>1' x = High;\n     fst (mems' ! i) x = mem\\<^sub>1' x;\n     snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<lbrakk>mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n             mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n     mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma mem\\<^sub>1' x = High;\n     fst (mems' ! i) x = mem\\<^sub>1' x;\n     snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 2. \\<lbrakk>mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n             mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n     mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x; dma mem\\<^sub>1' x = Low;\n     fst (mems' ! i) x = some_val; snd (mems' ! i) x = some_val\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 3. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = High; dma mem\\<^sub>1' x = Low;\n     fst (mems' ! i) x = mem\\<^sub>1 x;\n     snd (mems' ! i) x = mem\\<^sub>1 x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 4. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High;\n     dma mem\\<^sub>1' x = dma mem\\<^sub>1 x;\n     fst (mems' ! i) x = fst (mems ! i) x;\n     snd (mems' ! i) x = snd (mems ! i) x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 5. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = Low; dma mem\\<^sub>1' x = High;\n     fst (mems' ! i) x = mem\\<^sub>1' x;\n     snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "assume \"fst (mems' ! i) x = mem\\<^sub>1' x\"\n              \"snd (mems' ! i) x = mem\\<^sub>2' x\""], ["proof (state)\nthis:\n  fst (mems' ! i) x = mem\\<^sub>1' x\n  snd (mems' ! i) x = mem\\<^sub>2' x\n\ngoal (5 subgoals):\n 1. \\<lbrakk>mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n             mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n     mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma mem\\<^sub>1' x = High;\n     fst (mems' ! i) x = mem\\<^sub>1' x;\n     snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 2. \\<lbrakk>mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n             mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n     mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x; dma mem\\<^sub>1' x = Low;\n     fst (mems' ! i) x = some_val; snd (mems' ! i) x = some_val\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 3. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = High; dma mem\\<^sub>1' x = Low;\n     fst (mems' ! i) x = mem\\<^sub>1 x;\n     snd (mems' ! i) x = mem\\<^sub>1 x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 4. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High;\n     dma mem\\<^sub>1' x = dma mem\\<^sub>1 x;\n     fst (mems' ! i) x = fst (mems ! i) x;\n     snd (mems' ! i) x = snd (mems ! i) x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 5. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = Low; dma mem\\<^sub>1' x = High;\n     fst (mems' ! i) x = mem\\<^sub>1' x;\n     snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "thus \"x \\<notin> ?X' i\""], ["proof (prove)\nusing this:\n  fst (mems' ! i) x = mem\\<^sub>1' x\n  snd (mems' ! i) x = mem\\<^sub>2' x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "by (metis differing_vars_neg_intro)"], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (4 subgoals):\n 1. \\<lbrakk>mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n             mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n     mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x; dma mem\\<^sub>1' x = Low;\n     fst (mems' ! i) x = some_val; snd (mems' ! i) x = some_val\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 2. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = High; dma mem\\<^sub>1' x = Low;\n     fst (mems' ! i) x = mem\\<^sub>1 x;\n     snd (mems' ! i) x = mem\\<^sub>1 x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 3. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High;\n     dma mem\\<^sub>1' x = dma mem\\<^sub>1 x;\n     fst (mems' ! i) x = fst (mems ! i) x;\n     snd (mems' ! i) x = snd (mems ! i) x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 4. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = Low; dma mem\\<^sub>1' x = High;\n     fst (mems' ! i) x = mem\\<^sub>1' x;\n     snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n             mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n     mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x; dma mem\\<^sub>1' x = Low;\n     fst (mems' ! i) x = some_val; snd (mems' ! i) x = some_val\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 2. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = High; dma mem\\<^sub>1' x = Low;\n     fst (mems' ! i) x = mem\\<^sub>1 x;\n     snd (mems' ! i) x = mem\\<^sub>1 x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 3. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High;\n     dma mem\\<^sub>1' x = dma mem\\<^sub>1 x;\n     fst (mems' ! i) x = fst (mems ! i) x;\n     snd (mems' ! i) x = snd (mems ! i) x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 4. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = Low; dma mem\\<^sub>1' x = High;\n     fst (mems' ! i) x = mem\\<^sub>1' x;\n     snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "assume \"mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or> mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x\"\n              \"mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x\" and \"dma mem\\<^sub>1' x = Low\"\n            \\<comment> \\<open>In this case, for example, the values of (mems' ! i) are not needed.\\<close>"], ["proof (state)\nthis:\n  mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n  mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x\n  mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x\n  dma mem\\<^sub>1' x = Low\n\ngoal (4 subgoals):\n 1. \\<lbrakk>mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n             mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n     mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x; dma mem\\<^sub>1' x = Low;\n     fst (mems' ! i) x = some_val; snd (mems' ! i) x = some_val\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 2. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = High; dma mem\\<^sub>1' x = Low;\n     fst (mems' ! i) x = mem\\<^sub>1 x;\n     snd (mems' ! i) x = mem\\<^sub>1 x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 3. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High;\n     dma mem\\<^sub>1' x = dma mem\\<^sub>1 x;\n     fst (mems' ! i) x = fst (mems ! i) x;\n     snd (mems' ! i) x = snd (mems ! i) x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 4. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = Low; dma mem\\<^sub>1' x = High;\n     fst (mems' ! i) x = mem\\<^sub>1' x;\n     snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "thus \"x \\<notin> ?X' i\""], ["proof (prove)\nusing this:\n  mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n  mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x\n  mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x\n  dma mem\\<^sub>1' x = Low\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "by (metis Sec.simps(2) mem_eq)"], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (3 subgoals):\n 1. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = High; dma mem\\<^sub>1' x = Low;\n     fst (mems' ! i) x = mem\\<^sub>1 x;\n     snd (mems' ! i) x = mem\\<^sub>1 x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 2. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High;\n     dma mem\\<^sub>1' x = dma mem\\<^sub>1 x;\n     fst (mems' ! i) x = fst (mems ! i) x;\n     snd (mems' ! i) x = snd (mems ! i) x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 3. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = Low; dma mem\\<^sub>1' x = High;\n     fst (mems' ! i) x = mem\\<^sub>1' x;\n     snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = High; dma mem\\<^sub>1' x = Low;\n     fst (mems' ! i) x = mem\\<^sub>1 x;\n     snd (mems' ! i) x = mem\\<^sub>1 x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 2. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High;\n     dma mem\\<^sub>1' x = dma mem\\<^sub>1 x;\n     fst (mems' ! i) x = fst (mems ! i) x;\n     snd (mems' ! i) x = snd (mems ! i) x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 3. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = Low; dma mem\\<^sub>1' x = High;\n     fst (mems' ! i) x = mem\\<^sub>1' x;\n     snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "(* FIXME: clean this up -- there is surely a more direct route.\n                      Same must be true of mems'_i definition and o, o_downgrade,\n                      p etc. lemmas above that are proved with surely lots of\n                      overlapping cases *)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = High; dma mem\\<^sub>1' x = Low;\n     fst (mems' ! i) x = mem\\<^sub>1 x;\n     snd (mems' ! i) x = mem\\<^sub>1 x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 2. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High;\n     dma mem\\<^sub>1' x = dma mem\\<^sub>1 x;\n     fst (mems' ! i) x = fst (mems ! i) x;\n     snd (mems' ! i) x = snd (mems ! i) x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 3. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = Low; dma mem\\<^sub>1' x = High;\n     fst (mems' ! i) x = mem\\<^sub>1' x;\n     snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "assume case3: \"mem\\<^sub>1 x = mem\\<^sub>1' x\" \"mem\\<^sub>2 x = mem\\<^sub>2' x\" \n              \"dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High\"\n              \"fst (mems' ! i) x = fst (mems ! i) x\"\n              \"snd (mems' ! i) x = snd (mems ! i) x\""], ["proof (state)\nthis:\n  mem\\<^sub>1 x = mem\\<^sub>1' x\n  mem\\<^sub>2 x = mem\\<^sub>2' x\n  dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High\n  fst (mems' ! i) x = fst (mems ! i) x\n  snd (mems' ! i) x = snd (mems ! i) x\n\ngoal (3 subgoals):\n 1. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = High; dma mem\\<^sub>1' x = Low;\n     fst (mems' ! i) x = mem\\<^sub>1 x;\n     snd (mems' ! i) x = mem\\<^sub>1 x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 2. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High;\n     dma mem\\<^sub>1' x = dma mem\\<^sub>1 x;\n     fst (mems' ! i) x = fst (mems ! i) x;\n     snd (mems' ! i) x = snd (mems ! i) x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 3. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = Low; dma mem\\<^sub>1' x = High;\n     fst (mems' ! i) x = mem\\<^sub>1' x;\n     snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "have \"x \\<in> ?X' i \\<Longrightarrow> mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma mem\\<^sub>1' x = Low\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             i \\<Longrightarrow>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma mem\\<^sub>1' x = Low", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             i \\<Longrightarrow>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma mem\\<^sub>1' x = Low", "assume \"x \\<in> ?X' i\""], ["proof (state)\nthis:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             i \\<Longrightarrow>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma mem\\<^sub>1' x = Low", "from case3 and \\<open>x \\<in> ?X' i\\<close>"], ["proof (chain)\npicking this:\n  mem\\<^sub>1 x = mem\\<^sub>1' x\n  mem\\<^sub>2 x = mem\\<^sub>2' x\n  dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High\n  fst (mems' ! i) x = fst (mems ! i) x\n  snd (mems' ! i) x = snd (mems ! i) x\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "have \"x \\<in> ?X i\""], ["proof (prove)\nusing this:\n  mem\\<^sub>1 x = mem\\<^sub>1' x\n  mem\\<^sub>2 x = mem\\<^sub>2' x\n  dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High\n  fst (mems' ! i) x = fst (mems ! i) x\n  snd (mems' ! i) x = snd (mems ! i) x\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i", "by (metis differing_vars_neg differing_vars_elim)"], ["proof (state)\nthis:\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n\ngoal (1 subgoal):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             i \\<Longrightarrow>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma mem\\<^sub>1' x = Low", "with case3"], ["proof (chain)\npicking this:\n  mem\\<^sub>1 x = mem\\<^sub>1' x\n  mem\\<^sub>2 x = mem\\<^sub>2' x\n  dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High\n  fst (mems' ! i) x = fst (mems ! i) x\n  snd (mems' ! i) x = snd (mems ! i) x\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i", "have \"mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma mem\\<^sub>1 x = Low\""], ["proof (prove)\nusing this:\n  mem\\<^sub>1 x = mem\\<^sub>1' x\n  mem\\<^sub>2 x = mem\\<^sub>2' x\n  dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High\n  fst (mems' ! i) x = fst (mems ! i) x\n  snd (mems' ! i) x = snd (mems ! i) x\n  x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n\ngoal (1 subgoal):\n 1. mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma mem\\<^sub>1 x = Low", "by (metis b compat compat_different i_le length_list_update)"], ["proof (state)\nthis:\n  mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma mem\\<^sub>1 x = Low\n\ngoal (1 subgoal):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             i \\<Longrightarrow>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma mem\\<^sub>1' x = Low", "with mem_eq"], ["proof (chain)\npicking this:\n  mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma mem\\<^sub>1' x = High\n  mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma mem\\<^sub>1 x = Low", "have clases: \"dma mem\\<^sub>1 x = Low \\<and> dma mem\\<^sub>1' x = High\""], ["proof (prove)\nusing this:\n  mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma mem\\<^sub>1' x = High\n  mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma mem\\<^sub>1 x = Low\n\ngoal (1 subgoal):\n 1. dma mem\\<^sub>1 x = Low \\<and> dma mem\\<^sub>1' x = High", "by auto"], ["proof (state)\nthis:\n  dma mem\\<^sub>1 x = Low \\<and> dma mem\\<^sub>1' x = High\n\ngoal (1 subgoal):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             i \\<Longrightarrow>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma mem\\<^sub>1' x = Low", "have \"fst (mems' ! i) x = mem\\<^sub>1' x \\<and> snd (mems' ! i) x = mem\\<^sub>2' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n    snd (mems' ! i) x = mem\\<^sub>2' x", "apply(rule mems'_i_5)"], ["proof (prove)\ngoal (6 subgoals):\n 1. i \\<noteq> k\n 2. i < length cms\\<^sub>1\n 3. mem\\<^sub>1 x = mem\\<^sub>1' x\n 4. mem\\<^sub>2 x = mem\\<^sub>2' x\n 5. dma mem\\<^sub>1 x = Low \\<and> dma mem\\<^sub>1' x = High\n 6. dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x", "apply(rule \\<open>i \\<noteq> k\\<close>)"], ["proof (prove)\ngoal (5 subgoals):\n 1. i < length cms\\<^sub>1\n 2. mem\\<^sub>1 x = mem\\<^sub>1' x\n 3. mem\\<^sub>2 x = mem\\<^sub>2' x\n 4. dma mem\\<^sub>1 x = Low \\<and> dma mem\\<^sub>1' x = High\n 5. dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x", "using i_le len_unchanged"], ["proof (prove)\nusing this:\n  i < length cms\\<^sub>1'\n  length cms\\<^sub>1' = length cms\\<^sub>1\n\ngoal (5 subgoals):\n 1. i < length cms\\<^sub>1\n 2. mem\\<^sub>1 x = mem\\<^sub>1' x\n 3. mem\\<^sub>2 x = mem\\<^sub>2' x\n 4. dma mem\\<^sub>1 x = Low \\<and> dma mem\\<^sub>1' x = High\n 5. dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x", "apply(simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. mem\\<^sub>1 x = mem\\<^sub>1' x\n 2. mem\\<^sub>2 x = mem\\<^sub>2' x\n 3. dma mem\\<^sub>1 x = Low \\<and> dma mem\\<^sub>1' x = High\n 4. dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x", "apply(simp add: case3)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. dma mem\\<^sub>1 x = Low \\<and> dma mem\\<^sub>1' x = High\n 2. dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x", "apply(simp add: clases)+"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n  snd (mems' ! i) x = mem\\<^sub>2' x\n\ngoal (1 subgoal):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             i \\<Longrightarrow>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma mem\\<^sub>1' x = Low", "hence \"x \\<notin> ?X' i\""], ["proof (prove)\nusing this:\n  fst (mems' ! i) x = mem\\<^sub>1' x \\<and>\n  snd (mems' ! i) x = mem\\<^sub>2' x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "by (metis differing_vars_neg_intro)"], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n             i \\<Longrightarrow>\n    mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma mem\\<^sub>1' x = Low", "with \\<open>x \\<in> ?X' i\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma mem\\<^sub>1' x = Low", "by blast"], ["proof (state)\nthis:\n  mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma mem\\<^sub>1' x = Low\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n           i \\<Longrightarrow>\n  mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma mem\\<^sub>1' x = Low\n\ngoal (3 subgoals):\n 1. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = High; dma mem\\<^sub>1' x = Low;\n     fst (mems' ! i) x = mem\\<^sub>1 x;\n     snd (mems' ! i) x = mem\\<^sub>1 x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 2. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High;\n     dma mem\\<^sub>1' x = dma mem\\<^sub>1 x;\n     fst (mems' ! i) x = fst (mems ! i) x;\n     snd (mems' ! i) x = snd (mems ! i) x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 3. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = Low; dma mem\\<^sub>1' x = High;\n     fst (mems' ! i) x = mem\\<^sub>1' x;\n     snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "with \\<open>mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma mem\\<^sub>1' x = High\\<close>"], ["proof (chain)\npicking this:\n  mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma mem\\<^sub>1' x = High\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n           i \\<Longrightarrow>\n  mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma mem\\<^sub>1' x = Low", "show \"x \\<notin> ?X' i\""], ["proof (prove)\nusing this:\n  mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma mem\\<^sub>1' x = High\n  x \\<in> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n           i \\<Longrightarrow>\n  mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x \\<and> dma mem\\<^sub>1' x = Low\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "by auto"], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (2 subgoals):\n 1. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = High; dma mem\\<^sub>1' x = Low;\n     fst (mems' ! i) x = mem\\<^sub>1 x;\n     snd (mems' ! i) x = mem\\<^sub>1 x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 2. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = Low; dma mem\\<^sub>1' x = High;\n     fst (mems' ! i) x = mem\\<^sub>1' x;\n     snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = High; dma mem\\<^sub>1' x = Low;\n     fst (mems' ! i) x = mem\\<^sub>1 x;\n     snd (mems' ! i) x = mem\\<^sub>1 x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 2. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = Low; dma mem\\<^sub>1' x = High;\n     fst (mems' ! i) x = mem\\<^sub>1' x;\n     snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "assume case4: \"mem\\<^sub>1 x = mem\\<^sub>1' x\" \"mem\\<^sub>2 x = mem\\<^sub>2' x\"\n                   \"dma mem\\<^sub>1 x = High\" \"dma mem\\<^sub>1' x = Low\"\n                   \"fst (mems' ! i) x = mem\\<^sub>1 x\" \"snd (mems' ! i) x = mem\\<^sub>1 x\""], ["proof (state)\nthis:\n  mem\\<^sub>1 x = mem\\<^sub>1' x\n  mem\\<^sub>2 x = mem\\<^sub>2' x\n  dma mem\\<^sub>1 x = High\n  dma mem\\<^sub>1' x = Low\n  fst (mems' ! i) x = mem\\<^sub>1 x\n  snd (mems' ! i) x = mem\\<^sub>1 x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = High; dma mem\\<^sub>1' x = Low;\n     fst (mems' ! i) x = mem\\<^sub>1 x;\n     snd (mems' ! i) x = mem\\<^sub>1 x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 2. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = Low; dma mem\\<^sub>1' x = High;\n     fst (mems' ! i) x = mem\\<^sub>1' x;\n     snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "with mem_eq"], ["proof (chain)\npicking this:\n  mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma mem\\<^sub>1' x = High\n  mem\\<^sub>1 x = mem\\<^sub>1' x\n  mem\\<^sub>2 x = mem\\<^sub>2' x\n  dma mem\\<^sub>1 x = High\n  dma mem\\<^sub>1' x = Low\n  fst (mems' ! i) x = mem\\<^sub>1 x\n  snd (mems' ! i) x = mem\\<^sub>1 x", "have \"mem\\<^sub>1' x = mem\\<^sub>2' x\""], ["proof (prove)\nusing this:\n  mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma mem\\<^sub>1' x = High\n  mem\\<^sub>1 x = mem\\<^sub>1' x\n  mem\\<^sub>2 x = mem\\<^sub>2' x\n  dma mem\\<^sub>1 x = High\n  dma mem\\<^sub>1' x = Low\n  fst (mems' ! i) x = mem\\<^sub>1 x\n  snd (mems' ! i) x = mem\\<^sub>1 x\n\ngoal (1 subgoal):\n 1. mem\\<^sub>1' x = mem\\<^sub>2' x", "by auto"], ["proof (state)\nthis:\n  mem\\<^sub>1' x = mem\\<^sub>2' x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = High; dma mem\\<^sub>1' x = Low;\n     fst (mems' ! i) x = mem\\<^sub>1 x;\n     snd (mems' ! i) x = mem\\<^sub>1 x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 2. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = Low; dma mem\\<^sub>1' x = High;\n     fst (mems' ! i) x = mem\\<^sub>1' x;\n     snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "with case4"], ["proof (chain)\npicking this:\n  mem\\<^sub>1 x = mem\\<^sub>1' x\n  mem\\<^sub>2 x = mem\\<^sub>2' x\n  dma mem\\<^sub>1 x = High\n  dma mem\\<^sub>1' x = Low\n  fst (mems' ! i) x = mem\\<^sub>1 x\n  snd (mems' ! i) x = mem\\<^sub>1 x\n  mem\\<^sub>1' x = mem\\<^sub>2' x", "show ?thesis"], ["proof (prove)\nusing this:\n  mem\\<^sub>1 x = mem\\<^sub>1' x\n  mem\\<^sub>2 x = mem\\<^sub>2' x\n  dma mem\\<^sub>1 x = High\n  dma mem\\<^sub>1' x = Low\n  fst (mems' ! i) x = mem\\<^sub>1 x\n  snd (mems' ! i) x = mem\\<^sub>1 x\n  mem\\<^sub>1' x = mem\\<^sub>2' x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "by(auto simp: differing_vars_def differing_vars_lists_def)"], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = Low; dma mem\\<^sub>1' x = High;\n     fst (mems' ! i) x = mem\\<^sub>1' x;\n     snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = Low; dma mem\\<^sub>1' x = High;\n     fst (mems' ! i) x = mem\\<^sub>1' x;\n     snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "assume \"fst (mems' ! i) x = mem\\<^sub>1' x\"\n                   \"snd (mems' ! i) x = mem\\<^sub>2' x\""], ["proof (state)\nthis:\n  fst (mems' ! i) x = mem\\<^sub>1' x\n  snd (mems' ! i) x = mem\\<^sub>2' x\n\ngoal (1 subgoal):\n 1. \\<lbrakk>mem\\<^sub>1 x = mem\\<^sub>1' x; mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = Low; dma mem\\<^sub>1' x = High;\n     fst (mems' ! i) x = mem\\<^sub>1' x;\n     snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "thus ?thesis"], ["proof (prove)\nusing this:\n  fst (mems' ! i) x = mem\\<^sub>1' x\n  snd (mems' ! i) x = mem\\<^sub>2' x\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "by(metis differing_vars_neg_intro)"], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "have \"\\<exists> i < length cms\\<^sub>1. x \\<notin> ?X' i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "proof (cases \"mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or> mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x \\<or> dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x\")"], ["proof (state)\ngoal (2 subgoals):\n 1. mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n    mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x \\<or>\n    dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n 2. \\<not> (mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n            mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x \\<or>\n            dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x) \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "assume var_changed: \"mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or> mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x \\<or> dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x\""], ["proof (state)\nthis:\n  mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n  mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x \\<or>\n  dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x\n\ngoal (2 subgoals):\n 1. mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n    mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x \\<or>\n    dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n 2. \\<not> (mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n            mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x \\<or>\n            dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x) \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "have \"x \\<notin> ?X' k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k", "apply (rule mems'_k_cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n     fst (mems' ! k) x = mem\\<^sub>1' x;\n     snd (mems' ! k) x = mem\\<^sub>2' x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' k\n 2. \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n     fst (mems' ! k) x = fst (mems ! k) x;\n     snd (mems' ! k) x = snd (mems ! k) x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' k", "apply (metis differing_vars_neg_intro)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n     fst (mems' ! k) x = fst (mems ! k) x;\n     snd (mems' ! k) x = snd (mems ! k) x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' k", "by (metis var_changed x_unchanged)"], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n\ngoal (2 subgoals):\n 1. mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n    mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x \\<or>\n    dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n 2. \\<not> (mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n            mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x \\<or>\n            dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x) \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n\ngoal (1 subgoal):\n 1. \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "by (metis b)"], ["proof (state)\nthis:\n  \\<exists>i<length cms\\<^sub>1.\n     x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. \\<not> (mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n            mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x \\<or>\n            dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x) \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n            mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x \\<or>\n            dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x) \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "assume \"\\<not> (mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or> mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x \\<or> dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x)\""], ["proof (state)\nthis:\n  \\<not> (mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n          mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x \\<or>\n          dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x)\n\ngoal (1 subgoal):\n 1. \\<not> (mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n            mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x \\<or>\n            dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x) \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "hence assms: \"mem\\<^sub>1 x = mem\\<^sub>1' x\" \"mem\\<^sub>2 x = mem\\<^sub>2' x\" \"dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\""], ["proof (prove)\nusing this:\n  \\<not> (mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n          mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x \\<or>\n          dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x)\n\ngoal (1 subgoal):\n 1. mem\\<^sub>1 x = mem\\<^sub>1' x &&&\n    mem\\<^sub>2 x = mem\\<^sub>2' x &&&\n    dma mem\\<^sub>1' x = dma mem\\<^sub>1 x", "by auto"], ["proof (state)\nthis:\n  mem\\<^sub>1 x = mem\\<^sub>1' x\n  mem\\<^sub>2 x = mem\\<^sub>2' x\n  dma mem\\<^sub>1' x = dma mem\\<^sub>1 x\n\ngoal (1 subgoal):\n 1. \\<not> (mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n            mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x \\<or>\n            dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x) \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "have \"length cms\\<^sub>1 \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length cms\\<^sub>1 \\<noteq> 0", "using b"], ["proof (prove)\nusing this:\n  k < length cms\\<^sub>1 \\<and>\n  (cms\\<^sub>1 ! k, mem\\<^sub>1) \\<leadsto>\n  (cms\\<^sub>1' ! k, mem\\<^sub>1') \\<and>\n  cms\\<^sub>1' = cms\\<^sub>1[k := cms\\<^sub>1' ! k]\n\ngoal (1 subgoal):\n 1. length cms\\<^sub>1 \\<noteq> 0", "by (metis less_zeroE)"], ["proof (state)\nthis:\n  length cms\\<^sub>1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<not> (mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n            mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x \\<or>\n            dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x) \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "then"], ["proof (chain)\npicking this:\n  length cms\\<^sub>1 \\<noteq> 0", "obtain i where i_prop: \"i < length cms\\<^sub>1 \\<and> x \\<notin> ?X i\""], ["proof (prove)\nusing this:\n  length cms\\<^sub>1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        i < length cms\\<^sub>1 \\<and>\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                    i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using compat"], ["proof (prove)\nusing this:\n  length cms\\<^sub>1 \\<noteq> 0\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n\ngoal (1 subgoal):\n 1. (\\<And>i.\n        i < length cms\\<^sub>1 \\<and>\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                    i \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (auto, blast)"], ["proof (state)\nthis:\n  i < length cms\\<^sub>1 \\<and>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n\ngoal (1 subgoal):\n 1. \\<not> (mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n            mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x \\<or>\n            dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x) \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "proof (cases \"i = k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n 2. i \\<noteq> k \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "assume \"i = k\""], ["proof (state)\nthis:\n  i = k\n\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n 2. i \\<noteq> k \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "have \"x \\<notin> ?X' k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k", "apply (rule mems'_k_cases)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n     fst (mems' ! k) x = mem\\<^sub>1' x;\n     snd (mems' ! k) x = mem\\<^sub>2' x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' k\n 2. \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n     fst (mems' ! k) x = fst (mems ! k) x;\n     snd (mems' ! k) x = snd (mems ! k) x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' k", "apply (metis differing_vars_neg_intro)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems k;\n     fst (mems' ! k) x = fst (mems ! k) x;\n     snd (mems' ! k) x = snd (mems ! k) x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' k", "by (metis i_prop \\<open>i = k\\<close>)"], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n\ngoal (2 subgoals):\n 1. i = k \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n 2. i \\<noteq> k \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' k\n\ngoal (1 subgoal):\n 1. \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "by (metis b)"], ["proof (state)\nthis:\n  \\<exists>i<length cms\\<^sub>1.\n     x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "from i_prop"], ["proof (chain)\npicking this:\n  i < length cms\\<^sub>1 \\<and>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i", "have \"x \\<notin> ?X i\""], ["proof (prove)\nusing this:\n  i < length cms\\<^sub>1 \\<and>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i", "by simp"], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "assume \"i \\<noteq> k\""], ["proof (state)\nthis:\n  i \\<noteq> k\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "hence \"x \\<notin> ?X' i\""], ["proof (prove)\nusing this:\n  i \\<noteq> k\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "(* FIXME: clean up *)"], ["proof (prove)\nusing this:\n  i \\<noteq> k\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "apply(rule mems'_i_cases)"], ["proof (prove)\ngoal (7 subgoals):\n 1. i \\<noteq> k \\<Longrightarrow> ?i6 \\<noteq> k\n 2. i \\<noteq> k \\<Longrightarrow> ?i6 < length cms\\<^sub>1\n 3. \\<lbrakk>i \\<noteq> k;\n     mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n     mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n     mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma mem\\<^sub>1' x = High;\n     fst (mems' ! ?i6) x = mem\\<^sub>1' x;\n     snd (mems' ! ?i6) x = mem\\<^sub>2' x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 4. \\<lbrakk>i \\<noteq> k;\n     mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n     mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n     mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x; dma mem\\<^sub>1' x = Low;\n     fst (mems' ! ?i6) x = some_val; snd (mems' ! ?i6) x = some_val\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 5. \\<lbrakk>i \\<noteq> k; mem\\<^sub>1 x = mem\\<^sub>1' x;\n     mem\\<^sub>2 x = mem\\<^sub>2' x; dma mem\\<^sub>1 x = High;\n     dma mem\\<^sub>1' x = Low; fst (mems' ! ?i6) x = mem\\<^sub>1 x;\n     snd (mems' ! ?i6) x = mem\\<^sub>1 x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 6. \\<lbrakk>i \\<noteq> k; mem\\<^sub>1 x = mem\\<^sub>1' x;\n     mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High;\n     dma mem\\<^sub>1' x = dma mem\\<^sub>1 x;\n     fst (mems' ! ?i6) x = fst (mems ! ?i6) x;\n     snd (mems' ! ?i6) x = snd (mems ! ?i6) x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 7. \\<lbrakk>i \\<noteq> k; mem\\<^sub>1 x = mem\\<^sub>1' x;\n     mem\\<^sub>2 x = mem\\<^sub>2' x; dma mem\\<^sub>1 x = Low;\n     dma mem\\<^sub>1' x = High; fst (mems' ! ?i6) x = mem\\<^sub>1' x;\n     snd (mems' ! ?i6) x = mem\\<^sub>2' x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "apply assumption"], ["proof (prove)\ngoal (6 subgoals):\n 1. i \\<noteq> k \\<Longrightarrow> i < length cms\\<^sub>1\n 2. \\<lbrakk>i \\<noteq> k;\n     mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n     mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n     mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma mem\\<^sub>1' x = High;\n     fst (mems' ! i) x = mem\\<^sub>1' x;\n     snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 3. \\<lbrakk>i \\<noteq> k;\n     mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n     mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n     mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x; dma mem\\<^sub>1' x = Low;\n     fst (mems' ! i) x = some_val; snd (mems' ! i) x = some_val\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 4. \\<lbrakk>i \\<noteq> k; mem\\<^sub>1 x = mem\\<^sub>1' x;\n     mem\\<^sub>2 x = mem\\<^sub>2' x; dma mem\\<^sub>1 x = High;\n     dma mem\\<^sub>1' x = Low; fst (mems' ! i) x = mem\\<^sub>1 x;\n     snd (mems' ! i) x = mem\\<^sub>1 x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 5. \\<lbrakk>i \\<noteq> k; mem\\<^sub>1 x = mem\\<^sub>1' x;\n     mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High;\n     dma mem\\<^sub>1' x = dma mem\\<^sub>1 x;\n     fst (mems' ! i) x = fst (mems ! i) x;\n     snd (mems' ! i) x = snd (mems ! i) x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 6. \\<lbrakk>i \\<noteq> k; mem\\<^sub>1 x = mem\\<^sub>1' x;\n     mem\\<^sub>2 x = mem\\<^sub>2' x; dma mem\\<^sub>1 x = Low;\n     dma mem\\<^sub>1' x = High; fst (mems' ! i) x = mem\\<^sub>1' x;\n     snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "apply(simp add: i_prop)"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<lbrakk>i \\<noteq> k;\n     mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n     mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n     mem\\<^sub>1' x = mem\\<^sub>2' x \\<or> dma mem\\<^sub>1' x = High;\n     fst (mems' ! i) x = mem\\<^sub>1' x;\n     snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 2. \\<lbrakk>i \\<noteq> k;\n     mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n     mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x;\n     mem\\<^sub>1' x \\<noteq> mem\\<^sub>2' x; dma mem\\<^sub>1' x = Low;\n     fst (mems' ! i) x = some_val; snd (mems' ! i) x = some_val\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 3. \\<lbrakk>i \\<noteq> k; mem\\<^sub>1 x = mem\\<^sub>1' x;\n     mem\\<^sub>2 x = mem\\<^sub>2' x; dma mem\\<^sub>1 x = High;\n     dma mem\\<^sub>1' x = Low; fst (mems' ! i) x = mem\\<^sub>1 x;\n     snd (mems' ! i) x = mem\\<^sub>1 x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 4. \\<lbrakk>i \\<noteq> k; mem\\<^sub>1 x = mem\\<^sub>1' x;\n     mem\\<^sub>2 x = mem\\<^sub>2' x;\n     dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1' x = High;\n     dma mem\\<^sub>1' x = dma mem\\<^sub>1 x;\n     fst (mems' ! i) x = fst (mems ! i) x;\n     snd (mems' ! i) x = snd (mems ! i) x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 5. \\<lbrakk>i \\<noteq> k; mem\\<^sub>1 x = mem\\<^sub>1' x;\n     mem\\<^sub>2 x = mem\\<^sub>2' x; dma mem\\<^sub>1 x = Low;\n     dma mem\\<^sub>1' x = High; fst (mems' ! i) x = mem\\<^sub>1' x;\n     snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "apply(simp add: assms)+"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<noteq> k;\n     dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1 x = High;\n     fst (mems' ! i) x = fst (mems ! i) x;\n     snd (mems' ! i) x = snd (mems ! i) x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 2. \\<lbrakk>i \\<noteq> k; mem\\<^sub>1 x = mem\\<^sub>1' x;\n     mem\\<^sub>2 x = mem\\<^sub>2' x; dma mem\\<^sub>1 x = Low;\n     dma mem\\<^sub>1' x = High; fst (mems' ! i) x = mem\\<^sub>1' x;\n     snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "using \\<open>x \\<notin> ?X i\\<close> differing_vars_neg"], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n  ?x \\<notin> differing_vars_lists ?mem1.0 ?mem2.0 ?mems\n               ?i \\<Longrightarrow>\n  fst (?mems ! ?i) ?x = ?mem1.0 ?x \\<and> snd (?mems ! ?i) ?x = ?mem2.0 ?x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<noteq> k;\n     dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1 x = High;\n     fst (mems' ! i) x = fst (mems ! i) x;\n     snd (mems' ! i) x = snd (mems ! i) x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 2. \\<lbrakk>i \\<noteq> k; mem\\<^sub>1 x = mem\\<^sub>1' x;\n     mem\\<^sub>2 x = mem\\<^sub>2' x; dma mem\\<^sub>1 x = Low;\n     dma mem\\<^sub>1' x = High; fst (mems' ! i) x = mem\\<^sub>1' x;\n     snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "using \\<open>\\<not> (mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or> mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x \\<or> dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x)\\<close> differing_vars_elim"], ["proof (prove)\nusing this:\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n  ?x \\<notin> differing_vars_lists ?mem1.0 ?mem2.0 ?mems\n               ?i \\<Longrightarrow>\n  fst (?mems ! ?i) ?x = ?mem1.0 ?x \\<and> snd (?mems ! ?i) ?x = ?mem2.0 ?x\n  \\<not> (mem\\<^sub>1 x \\<noteq> mem\\<^sub>1' x \\<or>\n          mem\\<^sub>2 x \\<noteq> mem\\<^sub>2' x \\<or>\n          dma mem\\<^sub>1' x \\<noteq> dma mem\\<^sub>1 x)\n  ?x \\<in> differing_vars_lists ?mem\\<^sub>1 ?mem\\<^sub>2 ?mems\n            ?i \\<Longrightarrow>\n  fst (?mems ! ?i) ?x \\<noteq> ?mem\\<^sub>1 ?x \\<or>\n  snd (?mems ! ?i) ?x \\<noteq> ?mem\\<^sub>2 ?x\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i \\<noteq> k;\n     dma mem\\<^sub>1 x = Low \\<or> dma mem\\<^sub>1 x = High;\n     fst (mems' ! i) x = fst (mems ! i) x;\n     snd (mems' ! i) x = snd (mems ! i) x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i\n 2. \\<lbrakk>i \\<noteq> k; mem\\<^sub>1 x = mem\\<^sub>1' x;\n     mem\\<^sub>2 x = mem\\<^sub>2' x; dma mem\\<^sub>1 x = Low;\n     dma mem\\<^sub>1' x = High; fst (mems' ! i) x = mem\\<^sub>1' x;\n     snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> k; mem\\<^sub>1 x = mem\\<^sub>1' x;\n     mem\\<^sub>2 x = mem\\<^sub>2' x; dma mem\\<^sub>1 x = Low;\n     dma mem\\<^sub>1' x = High; fst (mems' ! i) x = mem\\<^sub>1' x;\n     snd (mems' ! i) x = mem\\<^sub>2' x\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1'\n                                  mem\\<^sub>2' mems' i", "by(metis differing_vars_neg_intro)"], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. i \\<noteq> k \\<Longrightarrow>\n    \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "with i_prop"], ["proof (chain)\npicking this:\n  i < length cms\\<^sub>1 \\<and>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "show ?thesis"], ["proof (prove)\nusing this:\n  i < length cms\\<^sub>1 \\<and>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\n  x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. \\<exists>i<length cms\\<^sub>1.\n       x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i", "by auto"], ["proof (state)\nthis:\n  \\<exists>i<length cms\\<^sub>1.\n     x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>i<length cms\\<^sub>1.\n     x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>i<length cms\\<^sub>1.\n     x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "}"], ["proof (state)\nthis:\n  \\<exists>i<length cms\\<^sub>1.\n     ?x7 \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "thus \"(length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2') \\<or> (\\<forall> x. \\<exists> i < length cms\\<^sub>1'. x \\<notin> ?X' i)\""], ["proof (prove)\nusing this:\n  \\<exists>i<length cms\\<^sub>1.\n     ?x7 \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i\n\ngoal (1 subgoal):\n 1. length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cms\\<^sub>1'.\n           x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems'\n                       i)", "by (metis cms\\<^sub>2'_def equal_size length_list_update new_length)"], ["proof (state)\nthis:\n  length cms\\<^sub>1' = 0 \\<and> mem\\<^sub>1' =\\<^sup>l mem\\<^sub>2' \\<or>\n  (\\<forall>x.\n      \\<exists>i<length cms\\<^sub>1'.\n         x \\<notin> differing_vars_lists mem\\<^sub>1' mem\\<^sub>2' mems' i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  makes_compatible (cms\\<^sub>1', mem\\<^sub>1') (cms\\<^sub>2', mem\\<^sub>2')\n   mems'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  makes_compatible (cms\\<^sub>1', mem\\<^sub>1') (cms\\<^sub>2', mem\\<^sub>2')\n   mems'\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2,\n         mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "ultimately"], ["proof (chain)\npicking this:\n  (cms\\<^sub>2,\n   mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2', mem\\<^sub>2')\n  map snd cms\\<^sub>1' = map snd cms\\<^sub>2'\n  makes_compatible (cms\\<^sub>1', mem\\<^sub>1') (cms\\<^sub>2', mem\\<^sub>2')\n   mems'", "show ?thesis"], ["proof (prove)\nusing this:\n  (cms\\<^sub>2,\n   mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2', mem\\<^sub>2')\n  map snd cms\\<^sub>1' = map snd cms\\<^sub>2'\n  makes_compatible (cms\\<^sub>1', mem\\<^sub>1') (cms\\<^sub>2', mem\\<^sub>2')\n   mems'\n\ngoal (1 subgoal):\n 1. thesis", "using that"], ["proof (prove)\nusing this:\n  (cms\\<^sub>2,\n   mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (cms\\<^sub>2', mem\\<^sub>2')\n  map snd cms\\<^sub>1' = map snd cms\\<^sub>2'\n  makes_compatible (cms\\<^sub>1', mem\\<^sub>1') (cms\\<^sub>2', mem\\<^sub>2')\n   mems'\n  map snd cms\\<^sub>1' = map snd ?cms\\<^sub>2'5 \\<and>\n  (cms\\<^sub>2,\n   mem\\<^sub>2) \\<leadsto>\\<^bsub>k\\<^esub> (?cms\\<^sub>2'5,\n       ?mem\\<^sub>2'5) \\<and>\n  makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n   (?cms\\<^sub>2'5, ?mem\\<^sub>2'5) ?mems'5 \\<Longrightarrow>\n  thesis\n\ngoal (1 subgoal):\n 1. thesis", "by blast"], ["proof (state)\nthis:\n  thesis\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The Isar proof language provides a readable\nway of specifying assumptions while also giving them names for subsequent\nusage.\\<close>"], ["", "lemma compat_low_eq:\n  assumes compat: \"makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2) mems\"\n  assumes modes_eq: \"map snd cms\\<^sub>1 = map snd cms\\<^sub>2\"\n  assumes x_low: \"dma mem\\<^sub>1 x = Low\"\n  assumes x_readable: \"x \\<in> \\<C> \\<or> (\\<forall> i < length cms\\<^sub>1. x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite)\"\n  shows \"mem\\<^sub>1 x = mem\\<^sub>2 x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mem\\<^sub>1 x = mem\\<^sub>2 x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mem\\<^sub>1 x = mem\\<^sub>2 x", "let ?X = \"\\<lambda> i. differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems i\""], ["proof (state)\ngoal (1 subgoal):\n 1. mem\\<^sub>1 x = mem\\<^sub>2 x", "from compat"], ["proof (chain)\npicking this:\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems", "have \"(length cms\\<^sub>1 = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2) \\<or>\n                    (\\<forall> x. \\<exists> j. j < length cms\\<^sub>1 \\<and> x \\<notin> ?X j)\""], ["proof (prove)\nusing this:\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n\ngoal (1 subgoal):\n 1. length cms\\<^sub>1 = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>j<length cms\\<^sub>1.\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j)", "by auto"], ["proof (state)\nthis:\n  length cms\\<^sub>1 = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n  (\\<forall>x.\n      \\<exists>j<length cms\\<^sub>1.\n         x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j)\n\ngoal (1 subgoal):\n 1. mem\\<^sub>1 x = mem\\<^sub>2 x", "thus \"mem\\<^sub>1 x = mem\\<^sub>2 x\""], ["proof (prove)\nusing this:\n  length cms\\<^sub>1 = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n  (\\<forall>x.\n      \\<exists>j<length cms\\<^sub>1.\n         x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j)\n\ngoal (1 subgoal):\n 1. mem\\<^sub>1 x = mem\\<^sub>2 x", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. length cms\\<^sub>1 = 0 \\<and>\n    mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<Longrightarrow>\n    mem\\<^sub>1 x = mem\\<^sub>2 x\n 2. \\<forall>x.\n       \\<exists>j<length cms\\<^sub>1.\n          x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                      j \\<Longrightarrow>\n    mem\\<^sub>1 x = mem\\<^sub>2 x", "assume \"length cms\\<^sub>1 = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2\""], ["proof (state)\nthis:\n  length cms\\<^sub>1 = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2\n\ngoal (2 subgoals):\n 1. length cms\\<^sub>1 = 0 \\<and>\n    mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<Longrightarrow>\n    mem\\<^sub>1 x = mem\\<^sub>2 x\n 2. \\<forall>x.\n       \\<exists>j<length cms\\<^sub>1.\n          x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                      j \\<Longrightarrow>\n    mem\\<^sub>1 x = mem\\<^sub>2 x", "with x_low"], ["proof (chain)\npicking this:\n  dma mem\\<^sub>1 x = Low\n  length cms\\<^sub>1 = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2", "show ?thesis"], ["proof (prove)\nusing this:\n  dma mem\\<^sub>1 x = Low\n  length cms\\<^sub>1 = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2\n\ngoal (1 subgoal):\n 1. mem\\<^sub>1 x = mem\\<^sub>2 x", "by (simp add: low_eq_def)"], ["proof (state)\nthis:\n  mem\\<^sub>1 x = mem\\<^sub>2 x\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<exists>j<length cms\\<^sub>1.\n          x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                      j \\<Longrightarrow>\n    mem\\<^sub>1 x = mem\\<^sub>2 x", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<exists>j<length cms\\<^sub>1.\n          x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                      j \\<Longrightarrow>\n    mem\\<^sub>1 x = mem\\<^sub>2 x", "assume \"\\<forall> x. \\<exists> j. j < length cms\\<^sub>1 \\<and> x \\<notin> ?X j\""], ["proof (state)\nthis:\n  \\<forall>x.\n     \\<exists>j<length cms\\<^sub>1.\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<exists>j<length cms\\<^sub>1.\n          x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                      j \\<Longrightarrow>\n    mem\\<^sub>1 x = mem\\<^sub>2 x", "then"], ["proof (chain)\npicking this:\n  \\<forall>x.\n     \\<exists>j<length cms\\<^sub>1.\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j", "obtain j where j_prop: \"j < length cms\\<^sub>1 \\<and> x \\<notin> ?X j\""], ["proof (prove)\nusing this:\n  \\<forall>x.\n     \\<exists>j<length cms\\<^sub>1.\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n\ngoal (1 subgoal):\n 1. (\\<And>j.\n        j < length cms\\<^sub>1 \\<and>\n        x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                    j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  j < length cms\\<^sub>1 \\<and>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<exists>j<length cms\\<^sub>1.\n          x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                      j \\<Longrightarrow>\n    mem\\<^sub>1 x = mem\\<^sub>2 x", "let ?mems\\<^sub>1j = \"fst (mems ! j)\" and\n        ?mems\\<^sub>2j = \"snd (mems ! j)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<exists>j<length cms\\<^sub>1.\n          x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                      j \\<Longrightarrow>\n    mem\\<^sub>1 x = mem\\<^sub>2 x", "obtain \\<sigma> :: \"'Var \\<rightharpoonup> 'Val\" where dom\\<sigma>: \"dom \\<sigma> = ?X j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<sigma>.\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n         j \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis dom_restrict_total)"], ["proof (state)\nthis:\n  dom \\<sigma> = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<exists>j<length cms\\<^sub>1.\n          x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                      j \\<Longrightarrow>\n    mem\\<^sub>1 x = mem\\<^sub>2 x", "from compat x_low makes_compatible_dma_eq j_prop \\<open>dom \\<sigma> = ?X j\\<close>"], ["proof (chain)\npicking this:\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  dma mem\\<^sub>1 x = Low\n  \\<lbrakk>makes_compatible (?cms\\<^sub>1, ?mem\\<^sub>1)\n            (?cms\\<^sub>2, ?mem\\<^sub>2) ?mems;\n   ?i < length ?cms\\<^sub>1;\n   dom ?\\<sigma> =\n   differing_vars_lists ?mem\\<^sub>1 ?mem\\<^sub>2 ?mems ?i\\<rbrakk>\n  \\<Longrightarrow> dma (subst ?\\<sigma> (fst (?mems ! ?i))) =\n                    dma ?mem\\<^sub>1\n  j < length cms\\<^sub>1 \\<and>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n  dom \\<sigma> = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j", "have x_low: \"dma (?mems\\<^sub>1j [\\<mapsto> \\<sigma>]) x = Low\""], ["proof (prove)\nusing this:\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  dma mem\\<^sub>1 x = Low\n  \\<lbrakk>makes_compatible (?cms\\<^sub>1, ?mem\\<^sub>1)\n            (?cms\\<^sub>2, ?mem\\<^sub>2) ?mems;\n   ?i < length ?cms\\<^sub>1;\n   dom ?\\<sigma> =\n   differing_vars_lists ?mem\\<^sub>1 ?mem\\<^sub>2 ?mems ?i\\<rbrakk>\n  \\<Longrightarrow> dma (subst ?\\<sigma> (fst (?mems ! ?i))) =\n                    dma ?mem\\<^sub>1\n  j < length cms\\<^sub>1 \\<and>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n  dom \\<sigma> = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n\ngoal (1 subgoal):\n 1. dma (subst \\<sigma> (fst (mems ! j))) x = Low", "by metis"], ["proof (state)\nthis:\n  dma (subst \\<sigma> (fst (mems ! j))) x = Low\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<exists>j<length cms\\<^sub>1.\n          x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                      j \\<Longrightarrow>\n    mem\\<^sub>1 x = mem\\<^sub>2 x", "from dom\\<sigma> compat and j_prop"], ["proof (chain)\npicking this:\n  dom \\<sigma> = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  j < length cms\\<^sub>1 \\<and>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j", "have \"(cms\\<^sub>1 ! j, ?mems\\<^sub>1j [\\<mapsto> \\<sigma>]) \\<approx> (cms\\<^sub>2 ! j, ?mems\\<^sub>2j [\\<mapsto> \\<sigma>])\""], ["proof (prove)\nusing this:\n  dom \\<sigma> = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n  makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2)\n   mems\n  j < length cms\\<^sub>1 \\<and>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n\ngoal (1 subgoal):\n 1. (cms\\<^sub>1 ! j, subst \\<sigma> (fst (mems ! j))) \\<approx>\n    (cms\\<^sub>2 ! j, subst \\<sigma> (snd (mems ! j)))", "by auto"], ["proof (state)\nthis:\n  (cms\\<^sub>1 ! j, subst \\<sigma> (fst (mems ! j))) \\<approx>\n  (cms\\<^sub>2 ! j, subst \\<sigma> (snd (mems ! j)))\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<exists>j<length cms\\<^sub>1.\n          x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                      j \\<Longrightarrow>\n    mem\\<^sub>1 x = mem\\<^sub>2 x", "moreover"], ["proof (state)\nthis:\n  (cms\\<^sub>1 ! j, subst \\<sigma> (fst (mems ! j))) \\<approx>\n  (cms\\<^sub>2 ! j, subst \\<sigma> (snd (mems ! j)))\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<exists>j<length cms\\<^sub>1.\n          x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                      j \\<Longrightarrow>\n    mem\\<^sub>1 x = mem\\<^sub>2 x", "have \"snd (cms\\<^sub>1 ! j) = snd (cms\\<^sub>2 ! j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snd (cms\\<^sub>1 ! j) = snd (cms\\<^sub>2 ! j)", "using modes_eq"], ["proof (prove)\nusing this:\n  map snd cms\\<^sub>1 = map snd cms\\<^sub>2\n\ngoal (1 subgoal):\n 1. snd (cms\\<^sub>1 ! j) = snd (cms\\<^sub>2 ! j)", "by (metis j_prop length_map nth_map)"], ["proof (state)\nthis:\n  snd (cms\\<^sub>1 ! j) = snd (cms\\<^sub>2 ! j)\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<exists>j<length cms\\<^sub>1.\n          x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                      j \\<Longrightarrow>\n    mem\\<^sub>1 x = mem\\<^sub>2 x", "ultimately"], ["proof (chain)\npicking this:\n  (cms\\<^sub>1 ! j, subst \\<sigma> (fst (mems ! j))) \\<approx>\n  (cms\\<^sub>2 ! j, subst \\<sigma> (snd (mems ! j)))\n  snd (cms\\<^sub>1 ! j) = snd (cms\\<^sub>2 ! j)", "have \"?mems\\<^sub>1j [\\<mapsto> \\<sigma>] =\\<^bsub>snd (cms\\<^sub>1 ! j)\\<^esub>\\<^sup>l ?mems\\<^sub>2j [\\<mapsto> \\<sigma>]\""], ["proof (prove)\nusing this:\n  (cms\\<^sub>1 ! j, subst \\<sigma> (fst (mems ! j))) \\<approx>\n  (cms\\<^sub>2 ! j, subst \\<sigma> (snd (mems ! j)))\n  snd (cms\\<^sub>1 ! j) = snd (cms\\<^sub>2 ! j)\n\ngoal (1 subgoal):\n 1. subst \\<sigma>\n     (fst (mems !\n           j)) =\\<^bsub>snd (cms\\<^sub>1 ! j)\\<^esub>\\<^sup>l subst \\<sigma>\n                         (snd (mems ! j))", "using modes_eq j_prop"], ["proof (prove)\nusing this:\n  (cms\\<^sub>1 ! j, subst \\<sigma> (fst (mems ! j))) \\<approx>\n  (cms\\<^sub>2 ! j, subst \\<sigma> (snd (mems ! j)))\n  snd (cms\\<^sub>1 ! j) = snd (cms\\<^sub>2 ! j)\n  map snd cms\\<^sub>1 = map snd cms\\<^sub>2\n  j < length cms\\<^sub>1 \\<and>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n\ngoal (1 subgoal):\n 1. subst \\<sigma>\n     (fst (mems !\n           j)) =\\<^bsub>snd (cms\\<^sub>1 ! j)\\<^esub>\\<^sup>l subst \\<sigma>\n                         (snd (mems ! j))", "by (metis mm_equiv_low_eq prod.collapse)"], ["proof (state)\nthis:\n  subst \\<sigma>\n   (fst (mems !\n         j)) =\\<^bsub>snd (cms\\<^sub>1 ! j)\\<^esub>\\<^sup>l subst \\<sigma>\n                       (snd (mems ! j))\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<exists>j<length cms\\<^sub>1.\n          x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                      j \\<Longrightarrow>\n    mem\\<^sub>1 x = mem\\<^sub>2 x", "hence \"?mems\\<^sub>1j x = ?mems\\<^sub>2j x\""], ["proof (prove)\nusing this:\n  subst \\<sigma>\n   (fst (mems !\n         j)) =\\<^bsub>snd (cms\\<^sub>1 ! j)\\<^esub>\\<^sup>l subst \\<sigma>\n                       (snd (mems ! j))\n\ngoal (1 subgoal):\n 1. fst (mems ! j) x = snd (mems ! j) x", "using x_low x_readable j_prop \\<open>dom \\<sigma> = ?X j\\<close>"], ["proof (prove)\nusing this:\n  subst \\<sigma>\n   (fst (mems !\n         j)) =\\<^bsub>snd (cms\\<^sub>1 ! j)\\<^esub>\\<^sup>l subst \\<sigma>\n                       (snd (mems ! j))\n  dma (subst \\<sigma> (fst (mems ! j))) x = Low\n  x \\<in> \\<C> \\<or>\n  (\\<forall>i<length cms\\<^sub>1.\n      x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite)\n  j < length cms\\<^sub>1 \\<and>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n  dom \\<sigma> = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n\ngoal (1 subgoal):\n 1. fst (mems ! j) x = snd (mems ! j) x", "unfolding low_mds_eq_def"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     dma (subst \\<sigma> (fst (mems ! j))) x = Low \\<and>\n     (x \\<in> \\<C> \\<or>\n      x \\<notin> snd (cms\\<^sub>1 ! j) AsmNoReadOrWrite) \\<longrightarrow>\n     subst \\<sigma> (fst (mems ! j)) x = subst \\<sigma> (snd (mems ! j)) x\n  dma (subst \\<sigma> (fst (mems ! j))) x = Low\n  x \\<in> \\<C> \\<or>\n  (\\<forall>i<length cms\\<^sub>1.\n      x \\<notin> snd (cms\\<^sub>1 ! i) AsmNoReadOrWrite)\n  j < length cms\\<^sub>1 \\<and>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n  dom \\<sigma> = differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n\ngoal (1 subgoal):\n 1. fst (mems ! j) x = snd (mems ! j) x", "by (metis subst_not_in_dom)"], ["proof (state)\nthis:\n  fst (mems ! j) x = snd (mems ! j) x\n\ngoal (1 subgoal):\n 1. \\<forall>x.\n       \\<exists>j<length cms\\<^sub>1.\n          x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems\n                      j \\<Longrightarrow>\n    mem\\<^sub>1 x = mem\\<^sub>2 x", "thus ?thesis"], ["proof (prove)\nusing this:\n  fst (mems ! j) x = snd (mems ! j) x\n\ngoal (1 subgoal):\n 1. mem\\<^sub>1 x = mem\\<^sub>2 x", "using j_prop"], ["proof (prove)\nusing this:\n  fst (mems ! j) x = snd (mems ! j) x\n  j < length cms\\<^sub>1 \\<and>\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 mems j\n\ngoal (1 subgoal):\n 1. mem\\<^sub>1 x = mem\\<^sub>2 x", "by (metis compat_different_vars)"], ["proof (state)\nthis:\n  mem\\<^sub>1 x = mem\\<^sub>2 x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mem\\<^sub>1 x = mem\\<^sub>2 x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma loc_reach_subset:\n  assumes eval: \"\\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\"\n  shows \"loc_reach \\<langle>c', mds', mem'\\<rangle> \\<subseteq> loc_reach \\<langle>c, mds, mem\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. loc_reach \\<langle>c', mds', mem'\\<rangle>\n    \\<subseteq> loc_reach \\<langle>c, mds, mem\\<rangle>", "proof (clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<langle>a, b, ba\\<rangle>\n       \\<in> loc_reach \\<langle>c', mds', mem'\\<rangle> \\<Longrightarrow>\n       \\<langle>a, b, ba\\<rangle>\n       \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>", "fix c'' mds'' mem''"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<langle>a, b, ba\\<rangle>\n       \\<in> loc_reach \\<langle>c', mds', mem'\\<rangle> \\<Longrightarrow>\n       \\<langle>a, b, ba\\<rangle>\n       \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>", "from eval"], ["proof (chain)\npicking this:\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>", "have \"\\<langle>c', mds', mem'\\<rangle> \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>\""], ["proof (prove)\nusing this:\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>c', mds', mem'\\<rangle>\n    \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>", "by (metis loc_reach.refl loc_reach.step surjective_pairing)"], ["proof (state)\nthis:\n  \\<langle>c', mds', mem'\\<rangle>\n  \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<langle>a, b, ba\\<rangle>\n       \\<in> loc_reach \\<langle>c', mds', mem'\\<rangle> \\<Longrightarrow>\n       \\<langle>a, b, ba\\<rangle>\n       \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>", "assume \"\\<langle>c'', mds'', mem''\\<rangle> \\<in> loc_reach \\<langle>c', mds', mem'\\<rangle>\""], ["proof (state)\nthis:\n  \\<langle>c'', mds'', mem''\\<rangle>\n  \\<in> loc_reach \\<langle>c', mds', mem'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>a b ba.\n       \\<langle>a, b, ba\\<rangle>\n       \\<in> loc_reach \\<langle>c', mds', mem'\\<rangle> \\<Longrightarrow>\n       \\<langle>a, b, ba\\<rangle>\n       \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>", "thus \"\\<langle>c'', mds'', mem''\\<rangle> \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>\""], ["proof (prove)\nusing this:\n  \\<langle>c'', mds'', mem''\\<rangle>\n  \\<in> loc_reach \\<langle>c', mds', mem'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>c'', mds'', mem''\\<rangle>\n    \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>", "apply induct"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<langle>fst (fst \\<langle>c', mds', mem'\\<rangle>), snd\n                    (fst \\<langle>c', mds', mem'\\<rangle>), snd\n                       \\<langle>c', mds', mem'\\<rangle>\\<rangle>\n    \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>\n 2. \\<And>c'a mds'a mem'a c'' mds'' mem''.\n       \\<lbrakk>\\<langle>c'a, mds'a, mem'a\\<rangle>\n                \\<in> loc_reach \\<langle>c', mds', mem'\\<rangle>;\n        \\<langle>c'a, mds'a, mem'a\\<rangle>\n        \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>;\n        \\<langle>c'a, mds'a, mem'a\\<rangle> \\<leadsto>\n        \\<langle>c'', mds'', mem''\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c'', mds'', mem''\\<rangle>\n                         \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>\n 3. \\<And>c'a mds'a mem'a mem''.\n       \\<lbrakk>\\<langle>c'a, mds'a, mem'a\\<rangle>\n                \\<in> loc_reach \\<langle>c', mds', mem'\\<rangle>;\n        \\<langle>c'a, mds'a, mem'a\\<rangle>\n        \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>;\n        \\<forall>x.\n           var_asm_not_written mds'a x \\<longrightarrow>\n           mem'a x = mem'' x \\<and> dma mem'a x = dma mem'' x\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c'a, mds'a, mem''\\<rangle>\n                         \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>", "apply (metis \\<open>\\<langle>c', mds', mem'\\<rangle> \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>\\<close> surjective_pairing)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c'a mds'a mem'a c'' mds'' mem''.\n       \\<lbrakk>\\<langle>c'a, mds'a, mem'a\\<rangle>\n                \\<in> loc_reach \\<langle>c', mds', mem'\\<rangle>;\n        \\<langle>c'a, mds'a, mem'a\\<rangle>\n        \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>;\n        \\<langle>c'a, mds'a, mem'a\\<rangle> \\<leadsto>\n        \\<langle>c'', mds'', mem''\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c'', mds'', mem''\\<rangle>\n                         \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>\n 2. \\<And>c'a mds'a mem'a mem''.\n       \\<lbrakk>\\<langle>c'a, mds'a, mem'a\\<rangle>\n                \\<in> loc_reach \\<langle>c', mds', mem'\\<rangle>;\n        \\<langle>c'a, mds'a, mem'a\\<rangle>\n        \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>;\n        \\<forall>x.\n           var_asm_not_written mds'a x \\<longrightarrow>\n           mem'a x = mem'' x \\<and> dma mem'a x = dma mem'' x\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c'a, mds'a, mem''\\<rangle>\n                         \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>", "apply (metis loc_reach.step)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c'a mds'a mem'a mem''.\n       \\<lbrakk>\\<langle>c'a, mds'a, mem'a\\<rangle>\n                \\<in> loc_reach \\<langle>c', mds', mem'\\<rangle>;\n        \\<langle>c'a, mds'a, mem'a\\<rangle>\n        \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>;\n        \\<forall>x.\n           var_asm_not_written mds'a x \\<longrightarrow>\n           mem'a x = mem'' x \\<and> dma mem'a x = dma mem'' x\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c'a, mds'a, mem''\\<rangle>\n                         \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>", "by (metis loc_reach.mem_diff)"], ["proof (state)\nthis:\n  \\<langle>c'', mds'', mem''\\<rangle>\n  \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma locally_sound_modes_invariant:\n  assumes sound_modes: \"locally_sound_mode_use \\<langle>c, mds, mem\\<rangle>\"\n  assumes eval: \"\\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\"\n  shows \"locally_sound_mode_use \\<langle>c', mds', mem'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. locally_sound_mode_use \\<langle>c', mds', mem'\\<rangle>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. locally_sound_mode_use \\<langle>c', mds', mem'\\<rangle>", "from eval"], ["proof (chain)\npicking this:\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>", "have \"\\<langle>c', mds', mem'\\<rangle> \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>\""], ["proof (prove)\nusing this:\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>c', mds', mem'\\<rangle>\n    \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>", "by (metis fst_conv loc_reach.refl loc_reach.step snd_conv)"], ["proof (state)\nthis:\n  \\<langle>c', mds', mem'\\<rangle>\n  \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>\n\ngoal (1 subgoal):\n 1. locally_sound_mode_use \\<langle>c', mds', mem'\\<rangle>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<langle>c', mds', mem'\\<rangle>\n  \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>\n\ngoal (1 subgoal):\n 1. locally_sound_mode_use \\<langle>c', mds', mem'\\<rangle>", "using sound_modes"], ["proof (prove)\nusing this:\n  \\<langle>c', mds', mem'\\<rangle>\n  \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>\n  locally_sound_mode_use \\<langle>c, mds, mem\\<rangle>\n\ngoal (1 subgoal):\n 1. locally_sound_mode_use \\<langle>c', mds', mem'\\<rangle>", "unfolding locally_sound_mode_use_def"], ["proof (prove)\nusing this:\n  \\<langle>c', mds', mem'\\<rangle>\n  \\<in> loc_reach \\<langle>c, mds, mem\\<rangle>\n  \\<forall>c' mds' mem'.\n     \\<langle>c', mds', mem'\\<rangle>\n     \\<in> loc_reach \\<langle>c, mds, mem\\<rangle> \\<longrightarrow>\n     (\\<forall>x.\n         (x \\<in> mds' GuarNoReadOrWrite \\<longrightarrow>\n          doesnt_read_or_modify c' x) \\<and>\n         (x \\<in> mds' GuarNoWrite \\<longrightarrow> doesnt_modify c' x))\n\ngoal (1 subgoal):\n 1. \\<forall>c'a mds'a mem'a.\n       \\<langle>c'a, mds'a, mem'a\\<rangle>\n       \\<in> loc_reach \\<langle>c', mds', mem'\\<rangle> \\<longrightarrow>\n       (\\<forall>x.\n           (x \\<in> mds'a GuarNoReadOrWrite \\<longrightarrow>\n            doesnt_read_or_modify c'a x) \\<and>\n           (x \\<in> mds'a GuarNoWrite \\<longrightarrow>\n            doesnt_modify c'a x))", "by (metis (no_types) Collect_empty_eq eval loc_reach_subset subsetD)"], ["proof (state)\nthis:\n  locally_sound_mode_use \\<langle>c', mds', mem'\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma meval_sched_one:\n  \"(cms, mem) \\<leadsto>\\<^bsub>k\\<^esub> (cms', mem') \\<Longrightarrow>\n        (cms, mem) \\<rightarrow>\\<^bsub>[k]\\<^esub> (cms', mem')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cms, mem) \\<leadsto>\\<^bsub>k\\<^esub> (cms', mem') \\<Longrightarrow>\n    (cms, mem) \\<rightarrow>\\<^bsub>[k]\\<^esub> (cms', mem')", "apply(simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma meval_sched_ConsI: \n  \"(cms, mem) \\<leadsto>\\<^bsub>k\\<^esub> (cms', mem') \\<Longrightarrow>\n   (cms', mem') \\<rightarrow>\\<^bsub>sched\\<^esub> (cms'', mem'') \\<Longrightarrow>\n   (cms, mem) \\<rightarrow>\\<^bsub>(k#sched)\\<^esub> (cms'', mem'')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(cms, mem) \\<leadsto>\\<^bsub>k\\<^esub> (cms', mem');\n     (cms', mem') \\<rightarrow>\\<^bsub>sched\\<^esub> (cms'', mem'')\\<rbrakk>\n    \\<Longrightarrow> (cms,\n                       mem) \\<rightarrow>\\<^bsub>k #\n           sched\\<^esub> (cms'', mem'')", "by fastforce"], ["", "lemma reachable_modes_subset:\n  assumes eval: \"(cms, mem) \\<leadsto>\\<^bsub>k\\<^esub> (cms', mem')\"\n  shows \"reachable_mode_states (cms', mem') \\<subseteq> reachable_mode_states (cms, mem)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. reachable_mode_states (cms', mem')\n    \\<subseteq> reachable_mode_states (cms, mem)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> reachable_mode_states (cms', mem') \\<Longrightarrow>\n       x \\<in> reachable_mode_states (cms, mem)", "fix mdss"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> reachable_mode_states (cms', mem') \\<Longrightarrow>\n       x \\<in> reachable_mode_states (cms, mem)", "assume \"mdss \\<in> reachable_mode_states (cms', mem')\""], ["proof (state)\nthis:\n  mdss \\<in> reachable_mode_states (cms', mem')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> reachable_mode_states (cms', mem') \\<Longrightarrow>\n       x \\<in> reachable_mode_states (cms, mem)", "thus \"mdss \\<in> reachable_mode_states (cms, mem)\""], ["proof (prove)\nusing this:\n  mdss \\<in> reachable_mode_states (cms', mem')\n\ngoal (1 subgoal):\n 1. mdss \\<in> reachable_mode_states (cms, mem)", "using assms"], ["proof (prove)\nusing this:\n  mdss \\<in> reachable_mode_states (cms', mem')\n  (cms, mem) \\<leadsto>\\<^bsub>k\\<^esub> (cms', mem')\n\ngoal (1 subgoal):\n 1. mdss \\<in> reachable_mode_states (cms, mem)", "unfolding reachable_mode_states_def"], ["proof (prove)\nusing this:\n  mdss\n  \\<in> {mdss.\n         \\<exists>cms'a mem'a sched.\n            (cms',\n             mem') \\<rightarrow>\\<^bsub>sched\\<^esub> (cms'a, mem'a) \\<and>\n            map snd cms'a = mdss}\n  (cms, mem) \\<leadsto>\\<^bsub>k\\<^esub> (cms', mem')\n\ngoal (1 subgoal):\n 1. mdss\n    \\<in> {mdss.\n           \\<exists>cms' mem' sched.\n              (cms,\n               mem) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms', mem') \\<and>\n              map snd cms' = mdss}", "by (blast intro: meval_sched_ConsI)"], ["proof (state)\nthis:\n  mdss \\<in> reachable_mode_states (cms, mem)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma globally_sound_modes_invariant:\n  assumes globally_sound: \"globally_sound_mode_use (cms, mem)\"\n  assumes eval: \"(cms, mem) \\<leadsto>\\<^bsub>k\\<^esub> (cms', mem')\"\n  shows \"globally_sound_mode_use (cms', mem')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. globally_sound_mode_use (cms', mem')", "using assms reachable_modes_subset"], ["proof (prove)\nusing this:\n  globally_sound_mode_use (cms, mem)\n  (cms, mem) \\<leadsto>\\<^bsub>k\\<^esub> (cms', mem')\n  (?cms, ?mem) \\<leadsto>\\<^bsub>?k\\<^esub> (?cms', ?mem') \\<Longrightarrow>\n  reachable_mode_states (?cms', ?mem')\n  \\<subseteq> reachable_mode_states (?cms, ?mem)\n\ngoal (1 subgoal):\n 1. globally_sound_mode_use (cms', mem')", "unfolding globally_sound_mode_use_def"], ["proof (prove)\nusing this:\n  \\<forall>mdss.\n     mdss \\<in> reachable_mode_states (cms, mem) \\<longrightarrow>\n     compatible_modes mdss\n  (cms, mem) \\<leadsto>\\<^bsub>k\\<^esub> (cms', mem')\n  (?cms, ?mem) \\<leadsto>\\<^bsub>?k\\<^esub> (?cms', ?mem') \\<Longrightarrow>\n  reachable_mode_states (?cms', ?mem')\n  \\<subseteq> reachable_mode_states (?cms, ?mem)\n\ngoal (1 subgoal):\n 1. \\<forall>mdss.\n       mdss \\<in> reachable_mode_states (cms', mem') \\<longrightarrow>\n       compatible_modes mdss", "by (metis (no_types) subsetD)"], ["", "lemma loc_reach_mem_diff_subset:\n  assumes mem_diff: \"\\<forall> x. var_asm_not_written mds x \\<longrightarrow> mem\\<^sub>1 x = mem\\<^sub>2 x \\<and> dma mem\\<^sub>1 x = dma mem\\<^sub>2 x\"\n  shows \"\\<langle>c', mds', mem'\\<rangle> \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle> \\<Longrightarrow> \\<langle>c', mds', mem'\\<rangle> \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>c', mds', mem'\\<rangle>\n    \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle> \\<Longrightarrow>\n    \\<langle>c', mds', mem'\\<rangle>\n    \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<langle>c', mds', mem'\\<rangle>\n    \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle> \\<Longrightarrow>\n    \\<langle>c', mds', mem'\\<rangle>\n    \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>", "let ?lc = \"\\<langle>c', mds', mem'\\<rangle>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<langle>c', mds', mem'\\<rangle>\n    \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle> \\<Longrightarrow>\n    \\<langle>c', mds', mem'\\<rangle>\n    \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>", "assume \"?lc \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle>\""], ["proof (state)\nthis:\n  \\<langle>c', mds', mem'\\<rangle>\n  \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>c', mds', mem'\\<rangle>\n    \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle> \\<Longrightarrow>\n    \\<langle>c', mds', mem'\\<rangle>\n    \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<langle>c', mds', mem'\\<rangle>\n  \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>c', mds', mem'\\<rangle>\n    \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>", "proof (induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<langle>fst (fst \\<langle>c, mds, mem\\<^sub>1\\<rangle>), snd\n                         (fst \\<langle>c, mds, mem\\<^sub>1\\<rangle>), snd\n                                 \\<langle>c, mds, mem\\<^sub>1\\<rangle>\\<rangle>\n    \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>\n 2. \\<And>c' mds' mem' c'' mds'' mem''.\n       \\<lbrakk>\\<langle>c', mds', mem'\\<rangle>\n                \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle>;\n        \\<langle>c', mds', mem'\\<rangle>\n        \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>;\n        \\<langle>c', mds', mem'\\<rangle> \\<leadsto>\n        \\<langle>c'', mds'', mem''\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c'', mds'', mem''\\<rangle>\n                         \\<in> loc_reach\n                                \\<langle>c, mds, mem\\<^sub>2\\<rangle>\n 3. \\<And>c' mds' mem' mem''.\n       \\<lbrakk>\\<langle>c', mds', mem'\\<rangle>\n                \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle>;\n        \\<langle>c', mds', mem'\\<rangle>\n        \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>;\n        \\<forall>x.\n           var_asm_not_written mds' x \\<longrightarrow>\n           mem' x = mem'' x \\<and> dma mem' x = dma mem'' x\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c', mds', mem''\\<rangle>\n                         \\<in> loc_reach\n                                \\<langle>c, mds, mem\\<^sub>2\\<rangle>", "case refl"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<langle>fst (fst \\<langle>c, mds, mem\\<^sub>1\\<rangle>), snd\n                         (fst \\<langle>c, mds, mem\\<^sub>1\\<rangle>), snd\n                                 \\<langle>c, mds, mem\\<^sub>1\\<rangle>\\<rangle>\n    \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>\n 2. \\<And>c' mds' mem' c'' mds'' mem''.\n       \\<lbrakk>\\<langle>c', mds', mem'\\<rangle>\n                \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle>;\n        \\<langle>c', mds', mem'\\<rangle>\n        \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>;\n        \\<langle>c', mds', mem'\\<rangle> \\<leadsto>\n        \\<langle>c'', mds'', mem''\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c'', mds'', mem''\\<rangle>\n                         \\<in> loc_reach\n                                \\<langle>c, mds, mem\\<^sub>2\\<rangle>\n 3. \\<And>c' mds' mem' mem''.\n       \\<lbrakk>\\<langle>c', mds', mem'\\<rangle>\n                \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle>;\n        \\<langle>c', mds', mem'\\<rangle>\n        \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>;\n        \\<forall>x.\n           var_asm_not_written mds' x \\<longrightarrow>\n           mem' x = mem'' x \\<and> dma mem' x = dma mem'' x\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c', mds', mem''\\<rangle>\n                         \\<in> loc_reach\n                                \\<langle>c, mds, mem\\<^sub>2\\<rangle>", "thus ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>fst (fst \\<langle>c, mds, mem\\<^sub>1\\<rangle>), snd\n                         (fst \\<langle>c, mds, mem\\<^sub>1\\<rangle>), snd\n                                 \\<langle>c, mds, mem\\<^sub>1\\<rangle>\\<rangle>\n    \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>", "by (metis fst_conv loc_reach.mem_diff loc_reach.refl mem_diff snd_conv)"], ["proof (state)\nthis:\n  \\<langle>fst (fst \\<langle>c, mds, mem\\<^sub>1\\<rangle>), snd\n                       (fst \\<langle>c, mds, mem\\<^sub>1\\<rangle>), snd\n                               \\<langle>c, mds, mem\\<^sub>1\\<rangle>\\<rangle>\n  \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<And>c' mds' mem' c'' mds'' mem''.\n       \\<lbrakk>\\<langle>c', mds', mem'\\<rangle>\n                \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle>;\n        \\<langle>c', mds', mem'\\<rangle>\n        \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>;\n        \\<langle>c', mds', mem'\\<rangle> \\<leadsto>\n        \\<langle>c'', mds'', mem''\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c'', mds'', mem''\\<rangle>\n                         \\<in> loc_reach\n                                \\<langle>c, mds, mem\\<^sub>2\\<rangle>\n 2. \\<And>c' mds' mem' mem''.\n       \\<lbrakk>\\<langle>c', mds', mem'\\<rangle>\n                \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle>;\n        \\<langle>c', mds', mem'\\<rangle>\n        \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>;\n        \\<forall>x.\n           var_asm_not_written mds' x \\<longrightarrow>\n           mem' x = mem'' x \\<and> dma mem' x = dma mem'' x\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c', mds', mem''\\<rangle>\n                         \\<in> loc_reach\n                                \\<langle>c, mds, mem\\<^sub>2\\<rangle>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>c' mds' mem' c'' mds'' mem''.\n       \\<lbrakk>\\<langle>c', mds', mem'\\<rangle>\n                \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle>;\n        \\<langle>c', mds', mem'\\<rangle>\n        \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>;\n        \\<langle>c', mds', mem'\\<rangle> \\<leadsto>\n        \\<langle>c'', mds'', mem''\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c'', mds'', mem''\\<rangle>\n                         \\<in> loc_reach\n                                \\<langle>c, mds, mem\\<^sub>2\\<rangle>\n 2. \\<And>c' mds' mem' mem''.\n       \\<lbrakk>\\<langle>c', mds', mem'\\<rangle>\n                \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle>;\n        \\<langle>c', mds', mem'\\<rangle>\n        \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>;\n        \\<forall>x.\n           var_asm_not_written mds' x \\<longrightarrow>\n           mem' x = mem'' x \\<and> dma mem' x = dma mem'' x\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c', mds', mem''\\<rangle>\n                         \\<in> loc_reach\n                                \\<langle>c, mds, mem\\<^sub>2\\<rangle>", "case step"], ["proof (state)\nthis:\n  \\<langle>c'_, mds'_, mem'_\\<rangle>\n  \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle>\n  \\<langle>c'_, mds'_, mem'_\\<rangle>\n  \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>\n  \\<langle>c'_, mds'_, mem'_\\<rangle> \\<leadsto>\n  \\<langle>c''_, mds''_, mem''_\\<rangle>\n\ngoal (2 subgoals):\n 1. \\<And>c' mds' mem' c'' mds'' mem''.\n       \\<lbrakk>\\<langle>c', mds', mem'\\<rangle>\n                \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle>;\n        \\<langle>c', mds', mem'\\<rangle>\n        \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>;\n        \\<langle>c', mds', mem'\\<rangle> \\<leadsto>\n        \\<langle>c'', mds'', mem''\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c'', mds'', mem''\\<rangle>\n                         \\<in> loc_reach\n                                \\<langle>c, mds, mem\\<^sub>2\\<rangle>\n 2. \\<And>c' mds' mem' mem''.\n       \\<lbrakk>\\<langle>c', mds', mem'\\<rangle>\n                \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle>;\n        \\<langle>c', mds', mem'\\<rangle>\n        \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>;\n        \\<forall>x.\n           var_asm_not_written mds' x \\<longrightarrow>\n           mem' x = mem'' x \\<and> dma mem' x = dma mem'' x\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c', mds', mem''\\<rangle>\n                         \\<in> loc_reach\n                                \\<langle>c, mds, mem\\<^sub>2\\<rangle>", "thus ?case"], ["proof (prove)\nusing this:\n  \\<langle>c'_, mds'_, mem'_\\<rangle>\n  \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle>\n  \\<langle>c'_, mds'_, mem'_\\<rangle>\n  \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>\n  \\<langle>c'_, mds'_, mem'_\\<rangle> \\<leadsto>\n  \\<langle>c''_, mds''_, mem''_\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>c''_, mds''_, mem''_\\<rangle>\n    \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>", "by (metis loc_reach.step)"], ["proof (state)\nthis:\n  \\<langle>c''_, mds''_, mem''_\\<rangle>\n  \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>c' mds' mem' mem''.\n       \\<lbrakk>\\<langle>c', mds', mem'\\<rangle>\n                \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle>;\n        \\<langle>c', mds', mem'\\<rangle>\n        \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>;\n        \\<forall>x.\n           var_asm_not_written mds' x \\<longrightarrow>\n           mem' x = mem'' x \\<and> dma mem' x = dma mem'' x\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c', mds', mem''\\<rangle>\n                         \\<in> loc_reach\n                                \\<langle>c, mds, mem\\<^sub>2\\<rangle>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c' mds' mem' mem''.\n       \\<lbrakk>\\<langle>c', mds', mem'\\<rangle>\n                \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle>;\n        \\<langle>c', mds', mem'\\<rangle>\n        \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>;\n        \\<forall>x.\n           var_asm_not_written mds' x \\<longrightarrow>\n           mem' x = mem'' x \\<and> dma mem' x = dma mem'' x\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c', mds', mem''\\<rangle>\n                         \\<in> loc_reach\n                                \\<langle>c, mds, mem\\<^sub>2\\<rangle>", "case mem_diff"], ["proof (state)\nthis:\n  \\<langle>c'_, mds'_, mem'_\\<rangle>\n  \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle>\n  \\<langle>c'_, mds'_, mem'_\\<rangle>\n  \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>\n  \\<forall>x.\n     var_asm_not_written mds'_ x \\<longrightarrow>\n     mem'_ x = mem''_ x \\<and> dma mem'_ x = dma mem''_ x\n\ngoal (1 subgoal):\n 1. \\<And>c' mds' mem' mem''.\n       \\<lbrakk>\\<langle>c', mds', mem'\\<rangle>\n                \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle>;\n        \\<langle>c', mds', mem'\\<rangle>\n        \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>;\n        \\<forall>x.\n           var_asm_not_written mds' x \\<longrightarrow>\n           mem' x = mem'' x \\<and> dma mem' x = dma mem'' x\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c', mds', mem''\\<rangle>\n                         \\<in> loc_reach\n                                \\<langle>c, mds, mem\\<^sub>2\\<rangle>", "thus ?case"], ["proof (prove)\nusing this:\n  \\<langle>c'_, mds'_, mem'_\\<rangle>\n  \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>1\\<rangle>\n  \\<langle>c'_, mds'_, mem'_\\<rangle>\n  \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>\n  \\<forall>x.\n     var_asm_not_written mds'_ x \\<longrightarrow>\n     mem'_ x = mem''_ x \\<and> dma mem'_ x = dma mem''_ x\n\ngoal (1 subgoal):\n 1. \\<langle>c'_, mds'_, mem''_\\<rangle>\n    \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>", "by (metis loc_reach.mem_diff)"], ["proof (state)\nthis:\n  \\<langle>c'_, mds'_, mem''_\\<rangle>\n  \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<langle>c', mds', mem'\\<rangle>\n  \\<in> loc_reach \\<langle>c, mds, mem\\<^sub>2\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma loc_reach_mem_diff_eq:\n  assumes mem_diff: \"\\<forall> x. var_asm_not_written mds x \\<longrightarrow> mem' x = mem x \\<and> dma mem' x = dma mem x\"\n  shows \"loc_reach \\<langle>c, mds, mem\\<rangle> = loc_reach \\<langle>c, mds, mem'\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. loc_reach \\<langle>c, mds, mem\\<rangle> =\n    loc_reach \\<langle>c, mds, mem'\\<rangle>", "using assms loc_reach_mem_diff_subset"], ["proof (prove)\nusing this:\n  \\<forall>x.\n     var_asm_not_written mds x \\<longrightarrow>\n     mem' x = mem x \\<and> dma mem' x = dma mem x\n  \\<lbrakk>\\<forall>x.\n              var_asm_not_written ?mds x \\<longrightarrow>\n              ?mem\\<^sub>1 x = ?mem\\<^sub>2 x \\<and>\n              dma ?mem\\<^sub>1 x = dma ?mem\\<^sub>2 x;\n   \\<langle>?c', ?mds', ?mem'\\<rangle>\n   \\<in> loc_reach \\<langle>?c, ?mds, ?mem\\<^sub>1\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> \\<langle>?c', ?mds', ?mem'\\<rangle>\n                    \\<in> loc_reach \\<langle>?c, ?mds, ?mem\\<^sub>2\\<rangle>\n\ngoal (1 subgoal):\n 1. loc_reach \\<langle>c, mds, mem\\<rangle> =\n    loc_reach \\<langle>c, mds, mem'\\<rangle>", "by (auto, metis)"], ["", "lemma sound_modes_invariant:\n  assumes sound_modes: \"sound_mode_use (cms, mem)\"\n  assumes eval: \"(cms, mem) \\<leadsto>\\<^bsub>k\\<^esub> (cms', mem')\"\n  shows \"sound_mode_use (cms', mem')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sound_mode_use (cms', mem')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. sound_mode_use (cms', mem')", "from sound_modes and eval"], ["proof (chain)\npicking this:\n  sound_mode_use (cms, mem)\n  (cms, mem) \\<leadsto>\\<^bsub>k\\<^esub> (cms', mem')", "have \"globally_sound_mode_use (cms', mem')\""], ["proof (prove)\nusing this:\n  sound_mode_use (cms, mem)\n  (cms, mem) \\<leadsto>\\<^bsub>k\\<^esub> (cms', mem')\n\ngoal (1 subgoal):\n 1. globally_sound_mode_use (cms', mem')", "by (metis globally_sound_modes_invariant sound_mode_use.simps)"], ["proof (state)\nthis:\n  globally_sound_mode_use (cms', mem')\n\ngoal (1 subgoal):\n 1. sound_mode_use (cms', mem')", "moreover"], ["proof (state)\nthis:\n  globally_sound_mode_use (cms', mem')\n\ngoal (1 subgoal):\n 1. sound_mode_use (cms', mem')", "from sound_modes"], ["proof (chain)\npicking this:\n  sound_mode_use (cms, mem)", "have loc_sound: \"\\<forall> i < length cms. locally_sound_mode_use (cms ! i, mem)\""], ["proof (prove)\nusing this:\n  sound_mode_use (cms, mem)\n\ngoal (1 subgoal):\n 1. \\<forall>i<length cms. locally_sound_mode_use (cms ! i, mem)", "unfolding sound_mode_use_def"], ["proof (prove)\nusing this:\n  case (cms, mem) of\n  (cms, mem) \\<Rightarrow>\n    list_all (\\<lambda>cm. locally_sound_mode_use (cm, mem)) cms \\<and>\n    globally_sound_mode_use (cms, mem)\n\ngoal (1 subgoal):\n 1. \\<forall>i<length cms. locally_sound_mode_use (cms ! i, mem)", "by simp (metis list_all_length)"], ["proof (state)\nthis:\n  \\<forall>i<length cms. locally_sound_mode_use (cms ! i, mem)\n\ngoal (1 subgoal):\n 1. sound_mode_use (cms', mem')", "from eval"], ["proof (chain)\npicking this:\n  (cms, mem) \\<leadsto>\\<^bsub>k\\<^esub> (cms', mem')", "obtain k cms\\<^sub>k' where\n    ev: \"(cms ! k, mem) \\<leadsto> (cms\\<^sub>k', mem') \\<and> k < length cms \\<and> cms' = cms [k := cms\\<^sub>k']\""], ["proof (prove)\nusing this:\n  (cms, mem) \\<leadsto>\\<^bsub>k\\<^esub> (cms', mem')\n\ngoal (1 subgoal):\n 1. (\\<And>k cms\\<^sub>k'.\n        (cms ! k, mem) \\<leadsto> (cms\\<^sub>k', mem') \\<and>\n        k < length cms \\<and>\n        cms' = cms[k := cms\\<^sub>k'] \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis meval_elim)"], ["proof (state)\nthis:\n  (cms ! k, mem) \\<leadsto> (cms\\<^sub>k', mem') \\<and>\n  k < length cms \\<and> cms' = cms[k := cms\\<^sub>k']\n\ngoal (1 subgoal):\n 1. sound_mode_use (cms', mem')", "hence \"length cms = length cms'\""], ["proof (prove)\nusing this:\n  (cms ! k, mem) \\<leadsto> (cms\\<^sub>k', mem') \\<and>\n  k < length cms \\<and> cms' = cms[k := cms\\<^sub>k']\n\ngoal (1 subgoal):\n 1. length cms = length cms'", "by auto"], ["proof (state)\nthis:\n  length cms = length cms'\n\ngoal (1 subgoal):\n 1. sound_mode_use (cms', mem')", "have \"\\<And> i. i < length cms' \\<Longrightarrow> locally_sound_mode_use (cms' ! i, mem')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length cms' \\<Longrightarrow>\n       locally_sound_mode_use (cms' ! i, mem')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length cms' \\<Longrightarrow>\n       locally_sound_mode_use (cms' ! i, mem')", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length cms' \\<Longrightarrow>\n       locally_sound_mode_use (cms' ! i, mem')", "assume i_le: \"i < length cms'\""], ["proof (state)\nthis:\n  i < length cms'\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i < length cms' \\<Longrightarrow>\n       locally_sound_mode_use (cms' ! i, mem')", "thus \"?thesis i\""], ["proof (prove)\nusing this:\n  i < length cms'\n\ngoal (1 subgoal):\n 1. locally_sound_mode_use (cms' ! i, mem')", "proof (cases \"i = k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>i < length cms'; i = k\\<rbrakk>\n    \\<Longrightarrow> locally_sound_mode_use (cms' ! i, mem')\n 2. \\<lbrakk>i < length cms'; i \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> locally_sound_mode_use (cms' ! i, mem')", "assume \"i = k\""], ["proof (state)\nthis:\n  i = k\n\ngoal (2 subgoals):\n 1. \\<lbrakk>i < length cms'; i = k\\<rbrakk>\n    \\<Longrightarrow> locally_sound_mode_use (cms' ! i, mem')\n 2. \\<lbrakk>i < length cms'; i \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> locally_sound_mode_use (cms' ! i, mem')", "thus ?thesis"], ["proof (prove)\nusing this:\n  i = k\n\ngoal (1 subgoal):\n 1. locally_sound_mode_use (cms' ! i, mem')", "using i_le ev loc_sound"], ["proof (prove)\nusing this:\n  i = k\n  i < length cms'\n  (cms ! k, mem) \\<leadsto> (cms\\<^sub>k', mem') \\<and>\n  k < length cms \\<and> cms' = cms[k := cms\\<^sub>k']\n  \\<forall>i<length cms. locally_sound_mode_use (cms ! i, mem)\n\ngoal (1 subgoal):\n 1. locally_sound_mode_use (cms' ! i, mem')", "by (metis (hide_lams, no_types) locally_sound_modes_invariant nth_list_update surj_pair)"], ["proof (state)\nthis:\n  locally_sound_mode_use (cms' ! i, mem')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length cms'; i \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> locally_sound_mode_use (cms' ! i, mem')", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length cms'; i \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> locally_sound_mode_use (cms' ! i, mem')", "assume \"i \\<noteq> k\""], ["proof (state)\nthis:\n  i \\<noteq> k\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length cms'; i \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> locally_sound_mode_use (cms' ! i, mem')", "hence \"cms' ! i = cms ! i\""], ["proof (prove)\nusing this:\n  i \\<noteq> k\n\ngoal (1 subgoal):\n 1. cms' ! i = cms ! i", "by (metis ev nth_list_update_neq)"], ["proof (state)\nthis:\n  cms' ! i = cms ! i\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length cms'; i \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> locally_sound_mode_use (cms' ! i, mem')", "from sound_modes"], ["proof (chain)\npicking this:\n  sound_mode_use (cms, mem)", "have \"compatible_modes (map snd cms)\""], ["proof (prove)\nusing this:\n  sound_mode_use (cms, mem)\n\ngoal (1 subgoal):\n 1. compatible_modes (map snd cms)", "unfolding sound_mode_use.simps"], ["proof (prove)\nusing this:\n  list_all (\\<lambda>cm. locally_sound_mode_use (cm, mem)) cms \\<and>\n  globally_sound_mode_use (cms, mem)\n\ngoal (1 subgoal):\n 1. compatible_modes (map snd cms)", "by (metis globally_sound_modes_compatible)"], ["proof (state)\nthis:\n  compatible_modes (map snd cms)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length cms'; i \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> locally_sound_mode_use (cms' ! i, mem')", "hence \"\\<And> x. var_asm_not_written (snd (cms ! i)) x \\<Longrightarrow> x \\<in> snd (cms ! k) GuarNoWrite \\<or> x \\<in> snd (cms ! k) GuarNoReadOrWrite\""], ["proof (prove)\nusing this:\n  compatible_modes (map snd cms)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       var_asm_not_written (snd (cms ! i)) x \\<Longrightarrow>\n       x \\<in> snd (cms ! k) GuarNoWrite \\<or>\n       x \\<in> snd (cms ! k) GuarNoReadOrWrite", "unfolding compatible_modes_def"], ["proof (prove)\nusing this:\n  \\<forall>i x.\n     i < length (map snd cms) \\<longrightarrow>\n     (x \\<in> (map snd cms ! i) AsmNoReadOrWrite \\<longrightarrow>\n      (\\<forall>j<length (map snd cms).\n          j \\<noteq> i \\<longrightarrow>\n          x \\<in> (map snd cms ! j) GuarNoReadOrWrite)) \\<and>\n     (x \\<in> (map snd cms ! i) AsmNoWrite \\<longrightarrow>\n      (\\<forall>j<length (map snd cms).\n          j \\<noteq> i \\<longrightarrow>\n          x \\<in> (map snd cms ! j) GuarNoWrite))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       var_asm_not_written (snd (cms ! i)) x \\<Longrightarrow>\n       x \\<in> snd (cms ! k) GuarNoWrite \\<or>\n       x \\<in> snd (cms ! k) GuarNoReadOrWrite", "by (metis (no_types) \\<open>i \\<noteq> k\\<close> \\<open>length cms = length cms'\\<close> ev i_le length_map nth_map var_asm_not_written_def)"], ["proof (state)\nthis:\n  var_asm_not_written (snd (cms ! i)) ?x5 \\<Longrightarrow>\n  ?x5 \\<in> snd (cms ! k) GuarNoWrite \\<or>\n  ?x5 \\<in> snd (cms ! k) GuarNoReadOrWrite\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length cms'; i \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> locally_sound_mode_use (cms' ! i, mem')", "hence \"\\<And> x. var_asm_not_written (snd (cms ! i)) x \\<longrightarrow> doesnt_modify (fst (cms ! k)) x\""], ["proof (prove)\nusing this:\n  var_asm_not_written (snd (cms ! i)) ?x5 \\<Longrightarrow>\n  ?x5 \\<in> snd (cms ! k) GuarNoWrite \\<or>\n  ?x5 \\<in> snd (cms ! k) GuarNoReadOrWrite\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       var_asm_not_written (snd (cms ! i)) x \\<longrightarrow>\n       doesnt_modify (fst (cms ! k)) x", "using ev loc_sound"], ["proof (prove)\nusing this:\n  var_asm_not_written (snd (cms ! i)) ?x5 \\<Longrightarrow>\n  ?x5 \\<in> snd (cms ! k) GuarNoWrite \\<or>\n  ?x5 \\<in> snd (cms ! k) GuarNoReadOrWrite\n  (cms ! k, mem) \\<leadsto> (cms\\<^sub>k', mem') \\<and>\n  k < length cms \\<and> cms' = cms[k := cms\\<^sub>k']\n  \\<forall>i<length cms. locally_sound_mode_use (cms ! i, mem)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       var_asm_not_written (snd (cms ! i)) x \\<longrightarrow>\n       doesnt_modify (fst (cms ! k)) x", "unfolding locally_sound_mode_use_def"], ["proof (prove)\nusing this:\n  var_asm_not_written (snd (cms ! i)) ?x5 \\<Longrightarrow>\n  ?x5 \\<in> snd (cms ! k) GuarNoWrite \\<or>\n  ?x5 \\<in> snd (cms ! k) GuarNoReadOrWrite\n  (cms ! k, mem) \\<leadsto> (cms\\<^sub>k', mem') \\<and>\n  k < length cms \\<and> cms' = cms[k := cms\\<^sub>k']\n  \\<forall>i<length cms.\n     \\<forall>c' mds' mem'.\n        \\<langle>c', mds', mem'\\<rangle>\n        \\<in> loc_reach (cms ! i, mem) \\<longrightarrow>\n        (\\<forall>x.\n            (x \\<in> mds' GuarNoReadOrWrite \\<longrightarrow>\n             doesnt_read_or_modify c' x) \\<and>\n            (x \\<in> mds' GuarNoWrite \\<longrightarrow> doesnt_modify c' x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       var_asm_not_written (snd (cms ! i)) x \\<longrightarrow>\n       doesnt_modify (fst (cms ! k)) x", "by (metis loc_reach.refl surjective_pairing doesnt_read_or_modify_doesnt_modify)"], ["proof (state)\nthis:\n  var_asm_not_written (snd (cms ! i)) ?x5 \\<longrightarrow>\n  doesnt_modify (fst (cms ! k)) ?x5\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length cms'; i \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> locally_sound_mode_use (cms' ! i, mem')", "with ev"], ["proof (chain)\npicking this:\n  (cms ! k, mem) \\<leadsto> (cms\\<^sub>k', mem') \\<and>\n  k < length cms \\<and> cms' = cms[k := cms\\<^sub>k']\n  var_asm_not_written (snd (cms ! i)) ?x5 \\<longrightarrow>\n  doesnt_modify (fst (cms ! k)) ?x5", "have \"\\<And> x. var_asm_not_written (snd (cms ! i)) x \\<Longrightarrow> mem x = mem' x \\<and> dma mem x = dma mem' x\""], ["proof (prove)\nusing this:\n  (cms ! k, mem) \\<leadsto> (cms\\<^sub>k', mem') \\<and>\n  k < length cms \\<and> cms' = cms[k := cms\\<^sub>k']\n  var_asm_not_written (snd (cms ! i)) ?x5 \\<longrightarrow>\n  doesnt_modify (fst (cms ! k)) ?x5\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       var_asm_not_written (snd (cms ! i)) x \\<Longrightarrow>\n       mem x = mem' x \\<and> dma mem x = dma mem' x", "unfolding doesnt_modify_def"], ["proof (prove)\nusing this:\n  (cms ! k, mem) \\<leadsto> (cms\\<^sub>k', mem') \\<and>\n  k < length cms \\<and> cms' = cms[k := cms\\<^sub>k']\n  var_asm_not_written (snd (cms ! i)) ?x5 \\<longrightarrow>\n  (\\<forall>mds mem c' mds' mem'.\n      \\<langle>fst (cms ! k), mds, mem\\<rangle> \\<leadsto>\n      \\<langle>c', mds', mem'\\<rangle> \\<longrightarrow>\n      mem ?x5 = mem' ?x5 \\<and> dma mem ?x5 = dma mem' ?x5)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       var_asm_not_written (snd (cms ! i)) x \\<Longrightarrow>\n       mem x = mem' x \\<and> dma mem x = dma mem' x", "by (metis prod.collapse)"], ["proof (state)\nthis:\n  var_asm_not_written (snd (cms ! i)) ?x5 \\<Longrightarrow>\n  mem ?x5 = mem' ?x5 \\<and> dma mem ?x5 = dma mem' ?x5\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length cms'; i \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> locally_sound_mode_use (cms' ! i, mem')", "with loc_reach_mem_diff_eq"], ["proof (chain)\npicking this:\n  \\<forall>x.\n     var_asm_not_written ?mds x \\<longrightarrow>\n     ?mem' x = ?mem x \\<and> dma ?mem' x = dma ?mem x \\<Longrightarrow>\n  loc_reach \\<langle>?c, ?mds, ?mem\\<rangle> =\n  loc_reach \\<langle>?c, ?mds, ?mem'\\<rangle>\n  var_asm_not_written (snd (cms ! i)) ?x5 \\<Longrightarrow>\n  mem ?x5 = mem' ?x5 \\<and> dma mem ?x5 = dma mem' ?x5", "have \"loc_reach (cms ! i, mem') = loc_reach (cms ! i, mem)\""], ["proof (prove)\nusing this:\n  \\<forall>x.\n     var_asm_not_written ?mds x \\<longrightarrow>\n     ?mem' x = ?mem x \\<and> dma ?mem' x = dma ?mem x \\<Longrightarrow>\n  loc_reach \\<langle>?c, ?mds, ?mem\\<rangle> =\n  loc_reach \\<langle>?c, ?mds, ?mem'\\<rangle>\n  var_asm_not_written (snd (cms ! i)) ?x5 \\<Longrightarrow>\n  mem ?x5 = mem' ?x5 \\<and> dma mem ?x5 = dma mem' ?x5\n\ngoal (1 subgoal):\n 1. loc_reach (cms ! i, mem') = loc_reach (cms ! i, mem)", "apply -"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<And>mds mem' mem c.\n                \\<forall>x.\n                   var_asm_not_written mds x \\<longrightarrow>\n                   mem' x = mem x \\<and>\n                   dma mem' x = dma mem x \\<Longrightarrow>\n                loc_reach \\<langle>c, mds, mem\\<rangle> =\n                loc_reach \\<langle>c, mds, mem'\\<rangle>;\n     \\<And>x.\n        var_asm_not_written (snd (cms ! i)) x \\<Longrightarrow>\n        mem x = mem' x \\<and> dma mem x = dma mem' x\\<rbrakk>\n    \\<Longrightarrow> loc_reach (cms ! i, mem') = loc_reach (cms ! i, mem)", "by(case_tac \"cms ! i\", simp)"], ["proof (state)\nthis:\n  loc_reach (cms ! i, mem') = loc_reach (cms ! i, mem)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>i < length cms'; i \\<noteq> k\\<rbrakk>\n    \\<Longrightarrow> locally_sound_mode_use (cms' ! i, mem')", "thus ?thesis"], ["proof (prove)\nusing this:\n  loc_reach (cms ! i, mem') = loc_reach (cms ! i, mem)\n\ngoal (1 subgoal):\n 1. locally_sound_mode_use (cms' ! i, mem')", "using loc_sound i_le \\<open>length cms = length cms'\\<close>"], ["proof (prove)\nusing this:\n  loc_reach (cms ! i, mem') = loc_reach (cms ! i, mem)\n  \\<forall>i<length cms. locally_sound_mode_use (cms ! i, mem)\n  i < length cms'\n  length cms = length cms'\n\ngoal (1 subgoal):\n 1. locally_sound_mode_use (cms' ! i, mem')", "unfolding locally_sound_mode_use_def"], ["proof (prove)\nusing this:\n  loc_reach (cms ! i, mem') = loc_reach (cms ! i, mem)\n  \\<forall>i<length cms.\n     \\<forall>c' mds' mem'.\n        \\<langle>c', mds', mem'\\<rangle>\n        \\<in> loc_reach (cms ! i, mem) \\<longrightarrow>\n        (\\<forall>x.\n            (x \\<in> mds' GuarNoReadOrWrite \\<longrightarrow>\n             doesnt_read_or_modify c' x) \\<and>\n            (x \\<in> mds' GuarNoWrite \\<longrightarrow> doesnt_modify c' x))\n  i < length cms'\n  length cms = length cms'\n\ngoal (1 subgoal):\n 1. \\<forall>c' mds' mem'a.\n       \\<langle>c', mds', mem'a\\<rangle>\n       \\<in> loc_reach (cms' ! i, mem') \\<longrightarrow>\n       (\\<forall>x.\n           (x \\<in> mds' GuarNoReadOrWrite \\<longrightarrow>\n            doesnt_read_or_modify c' x) \\<and>\n           (x \\<in> mds' GuarNoWrite \\<longrightarrow> doesnt_modify c' x))", "by (metis \\<open>cms' ! i = cms ! i\\<close>)"], ["proof (state)\nthis:\n  locally_sound_mode_use (cms' ! i, mem')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  locally_sound_mode_use (cms' ! i, mem')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i5 < length cms' \\<Longrightarrow>\n  locally_sound_mode_use (cms' ! ?i5, mem')\n\ngoal (1 subgoal):\n 1. sound_mode_use (cms', mem')", "ultimately"], ["proof (chain)\npicking this:\n  globally_sound_mode_use (cms', mem')\n  ?i5 < length cms' \\<Longrightarrow>\n  locally_sound_mode_use (cms' ! ?i5, mem')", "show ?thesis"], ["proof (prove)\nusing this:\n  globally_sound_mode_use (cms', mem')\n  ?i5 < length cms' \\<Longrightarrow>\n  locally_sound_mode_use (cms' ! ?i5, mem')\n\ngoal (1 subgoal):\n 1. sound_mode_use (cms', mem')", "unfolding sound_mode_use.simps"], ["proof (prove)\nusing this:\n  globally_sound_mode_use (cms', mem')\n  ?i5 < length cms' \\<Longrightarrow>\n  locally_sound_mode_use (cms' ! ?i5, mem')\n\ngoal (1 subgoal):\n 1. list_all (\\<lambda>cm. locally_sound_mode_use (cm, mem')) cms' \\<and>\n    globally_sound_mode_use (cms', mem')", "by (metis (no_types) list_all_length)"], ["proof (state)\nthis:\n  sound_mode_use (cms', mem')\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma app_Cons_rewrite:\n  \"ns @ (a # ms) = ((ns @ [a]) @ ms)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ns @ a # ms = (ns @ [a]) @ ms", "apply simp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma meval_sched_app_iff:\n  \"(cms\\<^sub>1, mem\\<^sub>1) \\<rightarrow>\\<^bsub>ns@ms\\<^esub> (cms\\<^sub>1', mem\\<^sub>1') =\n   (\\<exists>cms\\<^sub>1'' mem\\<^sub>1''. (cms\\<^sub>1, mem\\<^sub>1) \\<rightarrow>\\<^bsub>ns\\<^esub> (cms\\<^sub>1'', mem\\<^sub>1'') \\<and> (cms\\<^sub>1'', mem\\<^sub>1'') \\<rightarrow>\\<^bsub>ms\\<^esub> (cms\\<^sub>1', mem\\<^sub>1'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cms\\<^sub>1,\n     mem\\<^sub>1) \\<rightarrow>\\<^bsub>ns @\n ms\\<^esub> (cms\\<^sub>1', mem\\<^sub>1') =\n    (\\<exists>cms\\<^sub>1'' mem\\<^sub>1''.\n        (cms\\<^sub>1,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>ns\\<^esub> (cms\\<^sub>1'',\n                 mem\\<^sub>1'') \\<and>\n        (cms\\<^sub>1'',\n         mem\\<^sub>1'') \\<rightarrow>\\<^bsub>ms\\<^esub> (cms\\<^sub>1',\n                   mem\\<^sub>1'))", "apply(induct ns arbitrary: ms cms\\<^sub>1 mem\\<^sub>1)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>ms cms\\<^sub>1 mem\\<^sub>1.\n       (cms\\<^sub>1,\n        mem\\<^sub>1) \\<rightarrow>\\<^bsub>[] @\n    ms\\<^esub> (cms\\<^sub>1', mem\\<^sub>1') =\n       (\\<exists>cms\\<^sub>1'' mem\\<^sub>1''.\n           (cms\\<^sub>1,\n            mem\\<^sub>1) \\<rightarrow>\\<^bsub>[]\\<^esub> (cms\\<^sub>1'',\n                    mem\\<^sub>1'') \\<and>\n           (cms\\<^sub>1'',\n            mem\\<^sub>1'') \\<rightarrow>\\<^bsub>ms\\<^esub> (cms\\<^sub>1',\n                      mem\\<^sub>1'))\n 2. \\<And>a ns ms cms\\<^sub>1 mem\\<^sub>1.\n       (\\<And>ms cms\\<^sub>1 mem\\<^sub>1.\n           (cms\\<^sub>1,\n            mem\\<^sub>1) \\<rightarrow>\\<^bsub>ns @\n        ms\\<^esub> (cms\\<^sub>1', mem\\<^sub>1') =\n           (\\<exists>cms\\<^sub>1'' mem\\<^sub>1''.\n               (cms\\<^sub>1,\n                mem\\<^sub>1) \\<rightarrow>\\<^bsub>ns\\<^esub> (cms\\<^sub>1'',\n                        mem\\<^sub>1'') \\<and>\n               (cms\\<^sub>1'',\n                mem\\<^sub>1'') \\<rightarrow>\\<^bsub>ms\\<^esub> (cms\\<^sub>1',\n                          mem\\<^sub>1'))) \\<Longrightarrow>\n       (cms\\<^sub>1,\n        mem\\<^sub>1) \\<rightarrow>\\<^bsub>(a # ns) @\n    ms\\<^esub> (cms\\<^sub>1', mem\\<^sub>1') =\n       (\\<exists>cms\\<^sub>1'' mem\\<^sub>1''.\n           (cms\\<^sub>1,\n            mem\\<^sub>1) \\<rightarrow>\\<^bsub>a #\n        ns\\<^esub> (cms\\<^sub>1'', mem\\<^sub>1'') \\<and>\n           (cms\\<^sub>1'',\n            mem\\<^sub>1'') \\<rightarrow>\\<^bsub>ms\\<^esub> (cms\\<^sub>1',\n                      mem\\<^sub>1'))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a ns ms cms\\<^sub>1 mem\\<^sub>1.\n       (\\<And>ms cms\\<^sub>1 mem\\<^sub>1.\n           (cms\\<^sub>1,\n            mem\\<^sub>1) \\<rightarrow>\\<^bsub>ns @\n        ms\\<^esub> (cms\\<^sub>1', mem\\<^sub>1') =\n           (\\<exists>cms\\<^sub>1'' mem\\<^sub>1''.\n               (cms\\<^sub>1,\n                mem\\<^sub>1) \\<rightarrow>\\<^bsub>ns\\<^esub> (cms\\<^sub>1'',\n                        mem\\<^sub>1'') \\<and>\n               (cms\\<^sub>1'',\n                mem\\<^sub>1'') \\<rightarrow>\\<^bsub>ms\\<^esub> (cms\\<^sub>1',\n                          mem\\<^sub>1'))) \\<Longrightarrow>\n       (cms\\<^sub>1,\n        mem\\<^sub>1) \\<rightarrow>\\<^bsub>(a # ns) @\n    ms\\<^esub> (cms\\<^sub>1', mem\\<^sub>1') =\n       (\\<exists>cms\\<^sub>1'' mem\\<^sub>1''.\n           (cms\\<^sub>1,\n            mem\\<^sub>1) \\<rightarrow>\\<^bsub>a #\n        ns\\<^esub> (cms\\<^sub>1'', mem\\<^sub>1'') \\<and>\n           (cms\\<^sub>1'',\n            mem\\<^sub>1'') \\<rightarrow>\\<^bsub>ms\\<^esub> (cms\\<^sub>1',\n                      mem\\<^sub>1'))", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemmas meval_sched_appD = meval_sched_app_iff[THEN iffD1]"], ["", "lemmas meval_sched_appI = meval_sched_app_iff[THEN iffD2, OF exI, OF exI]"], ["", "lemma meval_sched_snocD:\n  \"(cms\\<^sub>1, mem\\<^sub>1) \\<rightarrow>\\<^bsub>ns@[n]\\<^esub> (cms\\<^sub>1', mem\\<^sub>1') \\<Longrightarrow>\n   \\<exists>cms\\<^sub>1'' mem\\<^sub>1''. (cms\\<^sub>1, mem\\<^sub>1) \\<rightarrow>\\<^bsub>ns\\<^esub> (cms\\<^sub>1'', mem\\<^sub>1'') \\<and> (cms\\<^sub>1'', mem\\<^sub>1'') \\<leadsto>\\<^bsub>n\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cms\\<^sub>1,\n     mem\\<^sub>1) \\<rightarrow>\\<^bsub>ns @\n [n]\\<^esub> (cms\\<^sub>1', mem\\<^sub>1') \\<Longrightarrow>\n    \\<exists>cms\\<^sub>1'' mem\\<^sub>1''.\n       (cms\\<^sub>1,\n        mem\\<^sub>1) \\<rightarrow>\\<^bsub>ns\\<^esub> (cms\\<^sub>1'',\n                mem\\<^sub>1'') \\<and>\n       (cms\\<^sub>1'',\n        mem\\<^sub>1'') \\<leadsto>\\<^bsub>n\\<^esub> (cms\\<^sub>1',\n              mem\\<^sub>1')", "apply(fastforce dest: meval_sched_appD)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma meval_sched_snocI:\n  \"(cms\\<^sub>1, mem\\<^sub>1) \\<rightarrow>\\<^bsub>ns\\<^esub> (cms\\<^sub>1'', mem\\<^sub>1'') \\<and> (cms\\<^sub>1'', mem\\<^sub>1'') \\<leadsto>\\<^bsub>n\\<^esub> (cms\\<^sub>1', mem\\<^sub>1') \\<Longrightarrow>\n  (cms\\<^sub>1, mem\\<^sub>1) \\<rightarrow>\\<^bsub>ns@[n]\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (cms\\<^sub>1,\n     mem\\<^sub>1) \\<rightarrow>\\<^bsub>ns\\<^esub> (cms\\<^sub>1'',\n             mem\\<^sub>1'') \\<and>\n    (cms\\<^sub>1'',\n     mem\\<^sub>1'') \\<leadsto>\\<^bsub>n\\<^esub> (cms\\<^sub>1',\n           mem\\<^sub>1') \\<Longrightarrow>\n    (cms\\<^sub>1,\n     mem\\<^sub>1) \\<rightarrow>\\<^bsub>ns @\n [n]\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')", "apply(fastforce intro: meval_sched_appI)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma makes_compatible_eval_sched:\n  assumes compat: \"makes_compatible (cms\\<^sub>1, mem\\<^sub>1) (cms\\<^sub>2, mem\\<^sub>2) mems\"\n  assumes modes_eq: \"map snd cms\\<^sub>1 = map snd cms\\<^sub>2\"\n  assumes sound_modes: \"sound_mode_use (cms\\<^sub>1, mem\\<^sub>1)\" \"sound_mode_use (cms\\<^sub>2, mem\\<^sub>2)\"\n  assumes eval: \"(cms\\<^sub>1, mem\\<^sub>1) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\"\n  shows \"\\<exists> cms\\<^sub>2' mem\\<^sub>2' mems'. sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                              sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                              map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n                              (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                              makes_compatible (cms\\<^sub>1', mem\\<^sub>1') (cms\\<^sub>2', mem\\<^sub>2') mems'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n       sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n       sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n       map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n       (cms\\<^sub>2,\n        mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2',\n                   mem\\<^sub>2') \\<and>\n       makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n        (cms\\<^sub>2', mem\\<^sub>2') mems'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n       sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n       sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n       map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n       (cms\\<^sub>2,\n        mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2',\n                   mem\\<^sub>2') \\<and>\n       makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n        (cms\\<^sub>2', mem\\<^sub>2') mems'", "(* cms\\<^sub>1' and mem\\<^sub>1' need to be arbitrary so\n     that the induction hypothesis is sufficiently general. *)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n       sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n       sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n       map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n       (cms\\<^sub>2,\n        mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2',\n                   mem\\<^sub>2') \\<and>\n       makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n        (cms\\<^sub>2', mem\\<^sub>2') mems'", "from eval"], ["proof (chain)\npicking this:\n  (cms\\<^sub>1,\n   mem\\<^sub>1) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>1',\n              mem\\<^sub>1')", "show ?thesis"], ["proof (prove)\nusing this:\n  (cms\\<^sub>1,\n   mem\\<^sub>1) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>1',\n              mem\\<^sub>1')\n\ngoal (1 subgoal):\n 1. \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n       sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n       sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n       map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n       (cms\\<^sub>2,\n        mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2',\n                   mem\\<^sub>2') \\<and>\n       makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n        (cms\\<^sub>2', mem\\<^sub>2') mems'", "proof (induct \"sched\" arbitrary: cms\\<^sub>1' mem\\<^sub>1' rule: rev_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>cms\\<^sub>1' mem\\<^sub>1'.\n       (cms\\<^sub>1,\n        mem\\<^sub>1) \\<rightarrow>\\<^bsub>[]\\<^esub> (cms\\<^sub>1',\n                mem\\<^sub>1') \\<Longrightarrow>\n       \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n          sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n          sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n          map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n          (cms\\<^sub>2,\n           mem\\<^sub>2) \\<rightarrow>\\<^bsub>[]\\<^esub> (cms\\<^sub>2',\n                   mem\\<^sub>2') \\<and>\n          makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n           (cms\\<^sub>2', mem\\<^sub>2') mems'\n 2. \\<And>x xs cms\\<^sub>1' mem\\<^sub>1'.\n       \\<lbrakk>\\<And>cms\\<^sub>1' mem\\<^sub>1'.\n                   (cms\\<^sub>1,\n                    mem\\<^sub>1) \\<rightarrow>\\<^bsub>xs\\<^esub> (cms\\<^sub>1',\n                            mem\\<^sub>1') \\<Longrightarrow>\n                   \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                      sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                      sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                      map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n                      (cms\\<^sub>2,\n                       mem\\<^sub>2) \\<rightarrow>\\<^bsub>xs\\<^esub> (cms\\<^sub>2',\n                               mem\\<^sub>2') \\<and>\n                      makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                       (cms\\<^sub>2', mem\\<^sub>2') mems';\n        (cms\\<^sub>1,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>xs @\n     [x]\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                            sound_mode_use\n                             (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                            sound_mode_use\n                             (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                            map snd cms\\<^sub>1' =\n                            map snd cms\\<^sub>2' \\<and>\n                            (cms\\<^sub>2,\n                             mem\\<^sub>2) \\<rightarrow>\\<^bsub>xs @\n                         [x]\\<^esub> (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                            makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                             (cms\\<^sub>2', mem\\<^sub>2') mems'", "case Nil"], ["proof (state)\nthis:\n  (cms\\<^sub>1,\n   mem\\<^sub>1) \\<rightarrow>\\<^bsub>[]\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\n\ngoal (2 subgoals):\n 1. \\<And>cms\\<^sub>1' mem\\<^sub>1'.\n       (cms\\<^sub>1,\n        mem\\<^sub>1) \\<rightarrow>\\<^bsub>[]\\<^esub> (cms\\<^sub>1',\n                mem\\<^sub>1') \\<Longrightarrow>\n       \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n          sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n          sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n          map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n          (cms\\<^sub>2,\n           mem\\<^sub>2) \\<rightarrow>\\<^bsub>[]\\<^esub> (cms\\<^sub>2',\n                   mem\\<^sub>2') \\<and>\n          makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n           (cms\\<^sub>2', mem\\<^sub>2') mems'\n 2. \\<And>x xs cms\\<^sub>1' mem\\<^sub>1'.\n       \\<lbrakk>\\<And>cms\\<^sub>1' mem\\<^sub>1'.\n                   (cms\\<^sub>1,\n                    mem\\<^sub>1) \\<rightarrow>\\<^bsub>xs\\<^esub> (cms\\<^sub>1',\n                            mem\\<^sub>1') \\<Longrightarrow>\n                   \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                      sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                      sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                      map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n                      (cms\\<^sub>2,\n                       mem\\<^sub>2) \\<rightarrow>\\<^bsub>xs\\<^esub> (cms\\<^sub>2',\n                               mem\\<^sub>2') \\<and>\n                      makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                       (cms\\<^sub>2', mem\\<^sub>2') mems';\n        (cms\\<^sub>1,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>xs @\n     [x]\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                            sound_mode_use\n                             (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                            sound_mode_use\n                             (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                            map snd cms\\<^sub>1' =\n                            map snd cms\\<^sub>2' \\<and>\n                            (cms\\<^sub>2,\n                             mem\\<^sub>2) \\<rightarrow>\\<^bsub>xs @\n                         [x]\\<^esub> (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                            makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                             (cms\\<^sub>2', mem\\<^sub>2') mems'", "hence \"cms\\<^sub>1' = cms\\<^sub>1 \\<and> mem\\<^sub>1' = mem\\<^sub>1\""], ["proof (prove)\nusing this:\n  (cms\\<^sub>1,\n   mem\\<^sub>1) \\<rightarrow>\\<^bsub>[]\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\n\ngoal (1 subgoal):\n 1. cms\\<^sub>1' = cms\\<^sub>1 \\<and> mem\\<^sub>1' = mem\\<^sub>1", "by (simp add: Pair_inject meval_sched.simps(1))"], ["proof (state)\nthis:\n  cms\\<^sub>1' = cms\\<^sub>1 \\<and> mem\\<^sub>1' = mem\\<^sub>1\n\ngoal (2 subgoals):\n 1. \\<And>cms\\<^sub>1' mem\\<^sub>1'.\n       (cms\\<^sub>1,\n        mem\\<^sub>1) \\<rightarrow>\\<^bsub>[]\\<^esub> (cms\\<^sub>1',\n                mem\\<^sub>1') \\<Longrightarrow>\n       \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n          sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n          sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n          map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n          (cms\\<^sub>2,\n           mem\\<^sub>2) \\<rightarrow>\\<^bsub>[]\\<^esub> (cms\\<^sub>2',\n                   mem\\<^sub>2') \\<and>\n          makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n           (cms\\<^sub>2', mem\\<^sub>2') mems'\n 2. \\<And>x xs cms\\<^sub>1' mem\\<^sub>1'.\n       \\<lbrakk>\\<And>cms\\<^sub>1' mem\\<^sub>1'.\n                   (cms\\<^sub>1,\n                    mem\\<^sub>1) \\<rightarrow>\\<^bsub>xs\\<^esub> (cms\\<^sub>1',\n                            mem\\<^sub>1') \\<Longrightarrow>\n                   \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                      sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                      sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                      map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n                      (cms\\<^sub>2,\n                       mem\\<^sub>2) \\<rightarrow>\\<^bsub>xs\\<^esub> (cms\\<^sub>2',\n                               mem\\<^sub>2') \\<and>\n                      makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                       (cms\\<^sub>2', mem\\<^sub>2') mems';\n        (cms\\<^sub>1,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>xs @\n     [x]\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                            sound_mode_use\n                             (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                            sound_mode_use\n                             (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                            map snd cms\\<^sub>1' =\n                            map snd cms\\<^sub>2' \\<and>\n                            (cms\\<^sub>2,\n                             mem\\<^sub>2) \\<rightarrow>\\<^bsub>xs @\n                         [x]\\<^esub> (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                            makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                             (cms\\<^sub>2', mem\\<^sub>2') mems'", "thus ?case"], ["proof (prove)\nusing this:\n  cms\\<^sub>1' = cms\\<^sub>1 \\<and> mem\\<^sub>1' = mem\\<^sub>1\n\ngoal (1 subgoal):\n 1. \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n       sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n       sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n       map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n       (cms\\<^sub>2,\n        mem\\<^sub>2) \\<rightarrow>\\<^bsub>[]\\<^esub> (cms\\<^sub>2',\n                mem\\<^sub>2') \\<and>\n       makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n        (cms\\<^sub>2', mem\\<^sub>2') mems'", "by (metis compat meval_sched.simps(1) modes_eq sound_modes)"], ["proof (state)\nthis:\n  \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n     sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n     sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n     map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n     (cms\\<^sub>2,\n      mem\\<^sub>2) \\<rightarrow>\\<^bsub>[]\\<^esub> (cms\\<^sub>2',\n              mem\\<^sub>2') \\<and>\n     makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n      (cms\\<^sub>2', mem\\<^sub>2') mems'\n\ngoal (1 subgoal):\n 1. \\<And>x xs cms\\<^sub>1' mem\\<^sub>1'.\n       \\<lbrakk>\\<And>cms\\<^sub>1' mem\\<^sub>1'.\n                   (cms\\<^sub>1,\n                    mem\\<^sub>1) \\<rightarrow>\\<^bsub>xs\\<^esub> (cms\\<^sub>1',\n                            mem\\<^sub>1') \\<Longrightarrow>\n                   \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                      sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                      sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                      map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n                      (cms\\<^sub>2,\n                       mem\\<^sub>2) \\<rightarrow>\\<^bsub>xs\\<^esub> (cms\\<^sub>2',\n                               mem\\<^sub>2') \\<and>\n                      makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                       (cms\\<^sub>2', mem\\<^sub>2') mems';\n        (cms\\<^sub>1,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>xs @\n     [x]\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                            sound_mode_use\n                             (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                            sound_mode_use\n                             (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                            map snd cms\\<^sub>1' =\n                            map snd cms\\<^sub>2' \\<and>\n                            (cms\\<^sub>2,\n                             mem\\<^sub>2) \\<rightarrow>\\<^bsub>xs @\n                         [x]\\<^esub> (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                            makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                             (cms\\<^sub>2', mem\\<^sub>2') mems'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xs cms\\<^sub>1' mem\\<^sub>1'.\n       \\<lbrakk>\\<And>cms\\<^sub>1' mem\\<^sub>1'.\n                   (cms\\<^sub>1,\n                    mem\\<^sub>1) \\<rightarrow>\\<^bsub>xs\\<^esub> (cms\\<^sub>1',\n                            mem\\<^sub>1') \\<Longrightarrow>\n                   \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                      sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                      sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                      map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n                      (cms\\<^sub>2,\n                       mem\\<^sub>2) \\<rightarrow>\\<^bsub>xs\\<^esub> (cms\\<^sub>2',\n                               mem\\<^sub>2') \\<and>\n                      makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                       (cms\\<^sub>2', mem\\<^sub>2') mems';\n        (cms\\<^sub>1,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>xs @\n     [x]\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                            sound_mode_use\n                             (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                            sound_mode_use\n                             (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                            map snd cms\\<^sub>1' =\n                            map snd cms\\<^sub>2' \\<and>\n                            (cms\\<^sub>2,\n                             mem\\<^sub>2) \\<rightarrow>\\<^bsub>xs @\n                         [x]\\<^esub> (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                            makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                             (cms\\<^sub>2', mem\\<^sub>2') mems'", "case (snoc n ns)"], ["proof (state)\nthis:\n  (cms\\<^sub>1,\n   mem\\<^sub>1) \\<rightarrow>\\<^bsub>ns\\<^esub> (?cms\\<^sub>1'5,\n           ?mem\\<^sub>1'5) \\<Longrightarrow>\n  \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n     sound_mode_use (?cms\\<^sub>1'5, ?mem\\<^sub>1'5) \\<and>\n     sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n     map snd ?cms\\<^sub>1'5 = map snd cms\\<^sub>2' \\<and>\n     (cms\\<^sub>2,\n      mem\\<^sub>2) \\<rightarrow>\\<^bsub>ns\\<^esub> (cms\\<^sub>2',\n              mem\\<^sub>2') \\<and>\n     makes_compatible (?cms\\<^sub>1'5, ?mem\\<^sub>1'5)\n      (cms\\<^sub>2', mem\\<^sub>2') mems'\n  (cms\\<^sub>1,\n   mem\\<^sub>1) \\<rightarrow>\\<^bsub>ns @\n                                     [n]\\<^esub> (cms\\<^sub>1',\n            mem\\<^sub>1')\n\ngoal (1 subgoal):\n 1. \\<And>x xs cms\\<^sub>1' mem\\<^sub>1'.\n       \\<lbrakk>\\<And>cms\\<^sub>1' mem\\<^sub>1'.\n                   (cms\\<^sub>1,\n                    mem\\<^sub>1) \\<rightarrow>\\<^bsub>xs\\<^esub> (cms\\<^sub>1',\n                            mem\\<^sub>1') \\<Longrightarrow>\n                   \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                      sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                      sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                      map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n                      (cms\\<^sub>2,\n                       mem\\<^sub>2) \\<rightarrow>\\<^bsub>xs\\<^esub> (cms\\<^sub>2',\n                               mem\\<^sub>2') \\<and>\n                      makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                       (cms\\<^sub>2', mem\\<^sub>2') mems';\n        (cms\\<^sub>1,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>xs @\n     [x]\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                            sound_mode_use\n                             (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                            sound_mode_use\n                             (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                            map snd cms\\<^sub>1' =\n                            map snd cms\\<^sub>2' \\<and>\n                            (cms\\<^sub>2,\n                             mem\\<^sub>2) \\<rightarrow>\\<^bsub>xs @\n                         [x]\\<^esub> (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                            makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                             (cms\\<^sub>2', mem\\<^sub>2') mems'", "then"], ["proof (chain)\npicking this:\n  (cms\\<^sub>1,\n   mem\\<^sub>1) \\<rightarrow>\\<^bsub>ns\\<^esub> (?cms\\<^sub>1'5,\n           ?mem\\<^sub>1'5) \\<Longrightarrow>\n  \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n     sound_mode_use (?cms\\<^sub>1'5, ?mem\\<^sub>1'5) \\<and>\n     sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n     map snd ?cms\\<^sub>1'5 = map snd cms\\<^sub>2' \\<and>\n     (cms\\<^sub>2,\n      mem\\<^sub>2) \\<rightarrow>\\<^bsub>ns\\<^esub> (cms\\<^sub>2',\n              mem\\<^sub>2') \\<and>\n     makes_compatible (?cms\\<^sub>1'5, ?mem\\<^sub>1'5)\n      (cms\\<^sub>2', mem\\<^sub>2') mems'\n  (cms\\<^sub>1,\n   mem\\<^sub>1) \\<rightarrow>\\<^bsub>ns @\n                                     [n]\\<^esub> (cms\\<^sub>1',\n            mem\\<^sub>1')", "obtain cms\\<^sub>1'' mem\\<^sub>1'' where eval'':\n      \"(cms\\<^sub>1, mem\\<^sub>1) \\<rightarrow>\\<^bsub>ns\\<^esub> (cms\\<^sub>1'', mem\\<^sub>1'') \\<and> (cms\\<^sub>1'', mem\\<^sub>1'') \\<leadsto>\\<^bsub>n\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\""], ["proof (prove)\nusing this:\n  (cms\\<^sub>1,\n   mem\\<^sub>1) \\<rightarrow>\\<^bsub>ns\\<^esub> (?cms\\<^sub>1'5,\n           ?mem\\<^sub>1'5) \\<Longrightarrow>\n  \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n     sound_mode_use (?cms\\<^sub>1'5, ?mem\\<^sub>1'5) \\<and>\n     sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n     map snd ?cms\\<^sub>1'5 = map snd cms\\<^sub>2' \\<and>\n     (cms\\<^sub>2,\n      mem\\<^sub>2) \\<rightarrow>\\<^bsub>ns\\<^esub> (cms\\<^sub>2',\n              mem\\<^sub>2') \\<and>\n     makes_compatible (?cms\\<^sub>1'5, ?mem\\<^sub>1'5)\n      (cms\\<^sub>2', mem\\<^sub>2') mems'\n  (cms\\<^sub>1,\n   mem\\<^sub>1) \\<rightarrow>\\<^bsub>ns @\n                                     [n]\\<^esub> (cms\\<^sub>1',\n            mem\\<^sub>1')\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>1''' mem\\<^sub>1'''.\n        (cms\\<^sub>1,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>ns\\<^esub> (cms\\<^sub>1''',\n                 mem\\<^sub>1''') \\<and>\n        (cms\\<^sub>1''',\n         mem\\<^sub>1''') \\<leadsto>\\<^bsub>n\\<^esub> (cms\\<^sub>1',\n                mem\\<^sub>1') \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis meval_sched_snocD prod_cases3 snd_conv)"], ["proof (state)\nthis:\n  (cms\\<^sub>1,\n   mem\\<^sub>1) \\<rightarrow>\\<^bsub>ns\\<^esub> (cms\\<^sub>1'',\n           mem\\<^sub>1'') \\<and>\n  (cms\\<^sub>1'',\n   mem\\<^sub>1'') \\<leadsto>\\<^bsub>n\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\n\ngoal (1 subgoal):\n 1. \\<And>x xs cms\\<^sub>1' mem\\<^sub>1'.\n       \\<lbrakk>\\<And>cms\\<^sub>1' mem\\<^sub>1'.\n                   (cms\\<^sub>1,\n                    mem\\<^sub>1) \\<rightarrow>\\<^bsub>xs\\<^esub> (cms\\<^sub>1',\n                            mem\\<^sub>1') \\<Longrightarrow>\n                   \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                      sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                      sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                      map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n                      (cms\\<^sub>2,\n                       mem\\<^sub>2) \\<rightarrow>\\<^bsub>xs\\<^esub> (cms\\<^sub>2',\n                               mem\\<^sub>2') \\<and>\n                      makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                       (cms\\<^sub>2', mem\\<^sub>2') mems';\n        (cms\\<^sub>1,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>xs @\n     [x]\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                            sound_mode_use\n                             (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                            sound_mode_use\n                             (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                            map snd cms\\<^sub>1' =\n                            map snd cms\\<^sub>2' \\<and>\n                            (cms\\<^sub>2,\n                             mem\\<^sub>2) \\<rightarrow>\\<^bsub>xs @\n                         [x]\\<^esub> (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                            makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                             (cms\\<^sub>2', mem\\<^sub>2') mems'", "hence \"(cms\\<^sub>1'', mem\\<^sub>1'') \\<leadsto>\\<^bsub>n\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\""], ["proof (prove)\nusing this:\n  (cms\\<^sub>1,\n   mem\\<^sub>1) \\<rightarrow>\\<^bsub>ns\\<^esub> (cms\\<^sub>1'',\n           mem\\<^sub>1'') \\<and>\n  (cms\\<^sub>1'',\n   mem\\<^sub>1'') \\<leadsto>\\<^bsub>n\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\n\ngoal (1 subgoal):\n 1. (cms\\<^sub>1'',\n     mem\\<^sub>1'') \\<leadsto>\\<^bsub>n\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')", ".."], ["proof (state)\nthis:\n  (cms\\<^sub>1'',\n   mem\\<^sub>1'') \\<leadsto>\\<^bsub>n\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\n\ngoal (1 subgoal):\n 1. \\<And>x xs cms\\<^sub>1' mem\\<^sub>1'.\n       \\<lbrakk>\\<And>cms\\<^sub>1' mem\\<^sub>1'.\n                   (cms\\<^sub>1,\n                    mem\\<^sub>1) \\<rightarrow>\\<^bsub>xs\\<^esub> (cms\\<^sub>1',\n                            mem\\<^sub>1') \\<Longrightarrow>\n                   \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                      sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                      sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                      map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n                      (cms\\<^sub>2,\n                       mem\\<^sub>2) \\<rightarrow>\\<^bsub>xs\\<^esub> (cms\\<^sub>2',\n                               mem\\<^sub>2') \\<and>\n                      makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                       (cms\\<^sub>2', mem\\<^sub>2') mems';\n        (cms\\<^sub>1,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>xs @\n     [x]\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                            sound_mode_use\n                             (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                            sound_mode_use\n                             (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                            map snd cms\\<^sub>1' =\n                            map snd cms\\<^sub>2' \\<and>\n                            (cms\\<^sub>2,\n                             mem\\<^sub>2) \\<rightarrow>\\<^bsub>xs @\n                         [x]\\<^esub> (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                            makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                             (cms\\<^sub>2', mem\\<^sub>2') mems'", "moreover"], ["proof (state)\nthis:\n  (cms\\<^sub>1'',\n   mem\\<^sub>1'') \\<leadsto>\\<^bsub>n\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\n\ngoal (1 subgoal):\n 1. \\<And>x xs cms\\<^sub>1' mem\\<^sub>1'.\n       \\<lbrakk>\\<And>cms\\<^sub>1' mem\\<^sub>1'.\n                   (cms\\<^sub>1,\n                    mem\\<^sub>1) \\<rightarrow>\\<^bsub>xs\\<^esub> (cms\\<^sub>1',\n                            mem\\<^sub>1') \\<Longrightarrow>\n                   \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                      sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                      sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                      map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n                      (cms\\<^sub>2,\n                       mem\\<^sub>2) \\<rightarrow>\\<^bsub>xs\\<^esub> (cms\\<^sub>2',\n                               mem\\<^sub>2') \\<and>\n                      makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                       (cms\\<^sub>2', mem\\<^sub>2') mems';\n        (cms\\<^sub>1,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>xs @\n     [x]\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                            sound_mode_use\n                             (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                            sound_mode_use\n                             (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                            map snd cms\\<^sub>1' =\n                            map snd cms\\<^sub>2' \\<and>\n                            (cms\\<^sub>2,\n                             mem\\<^sub>2) \\<rightarrow>\\<^bsub>xs @\n                         [x]\\<^esub> (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                            makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                             (cms\\<^sub>2', mem\\<^sub>2') mems'", "from eval''"], ["proof (chain)\npicking this:\n  (cms\\<^sub>1,\n   mem\\<^sub>1) \\<rightarrow>\\<^bsub>ns\\<^esub> (cms\\<^sub>1'',\n           mem\\<^sub>1'') \\<and>\n  (cms\\<^sub>1'',\n   mem\\<^sub>1'') \\<leadsto>\\<^bsub>n\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')", "obtain cms\\<^sub>2'' mem\\<^sub>2'' mems'' where IH:\n      \"sound_mode_use (cms\\<^sub>1'', mem\\<^sub>1'') \\<and>\n       sound_mode_use (cms\\<^sub>2'', mem\\<^sub>2'') \\<and>\n       map snd cms\\<^sub>1'' = map snd cms\\<^sub>2'' \\<and>\n       (cms\\<^sub>2, mem\\<^sub>2) \\<rightarrow>\\<^bsub>ns\\<^esub> (cms\\<^sub>2'', mem\\<^sub>2'') \\<and>\n       makes_compatible (cms\\<^sub>1'', mem\\<^sub>1'') (cms\\<^sub>2'', mem\\<^sub>2'') mems''\""], ["proof (prove)\nusing this:\n  (cms\\<^sub>1,\n   mem\\<^sub>1) \\<rightarrow>\\<^bsub>ns\\<^esub> (cms\\<^sub>1'',\n           mem\\<^sub>1'') \\<and>\n  (cms\\<^sub>1'',\n   mem\\<^sub>1'') \\<leadsto>\\<^bsub>n\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2'' mem\\<^sub>2'' mems''.\n        sound_mode_use (cms\\<^sub>1'', mem\\<^sub>1'') \\<and>\n        sound_mode_use (cms\\<^sub>2'', mem\\<^sub>2'') \\<and>\n        map snd cms\\<^sub>1'' = map snd cms\\<^sub>2'' \\<and>\n        (cms\\<^sub>2,\n         mem\\<^sub>2) \\<rightarrow>\\<^bsub>ns\\<^esub> (cms\\<^sub>2'',\n                 mem\\<^sub>2'') \\<and>\n        makes_compatible (cms\\<^sub>1'', mem\\<^sub>1'')\n         (cms\\<^sub>2'', mem\\<^sub>2'') mems'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using snoc"], ["proof (prove)\nusing this:\n  (cms\\<^sub>1,\n   mem\\<^sub>1) \\<rightarrow>\\<^bsub>ns\\<^esub> (cms\\<^sub>1'',\n           mem\\<^sub>1'') \\<and>\n  (cms\\<^sub>1'',\n   mem\\<^sub>1'') \\<leadsto>\\<^bsub>n\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\n  (cms\\<^sub>1,\n   mem\\<^sub>1) \\<rightarrow>\\<^bsub>ns\\<^esub> (?cms\\<^sub>1'5,\n           ?mem\\<^sub>1'5) \\<Longrightarrow>\n  \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n     sound_mode_use (?cms\\<^sub>1'5, ?mem\\<^sub>1'5) \\<and>\n     sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n     map snd ?cms\\<^sub>1'5 = map snd cms\\<^sub>2' \\<and>\n     (cms\\<^sub>2,\n      mem\\<^sub>2) \\<rightarrow>\\<^bsub>ns\\<^esub> (cms\\<^sub>2',\n              mem\\<^sub>2') \\<and>\n     makes_compatible (?cms\\<^sub>1'5, ?mem\\<^sub>1'5)\n      (cms\\<^sub>2', mem\\<^sub>2') mems'\n  (cms\\<^sub>1,\n   mem\\<^sub>1) \\<rightarrow>\\<^bsub>ns @\n                                     [n]\\<^esub> (cms\\<^sub>1',\n            mem\\<^sub>1')\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2'' mem\\<^sub>2'' mems''.\n        sound_mode_use (cms\\<^sub>1'', mem\\<^sub>1'') \\<and>\n        sound_mode_use (cms\\<^sub>2'', mem\\<^sub>2'') \\<and>\n        map snd cms\\<^sub>1'' = map snd cms\\<^sub>2'' \\<and>\n        (cms\\<^sub>2,\n         mem\\<^sub>2) \\<rightarrow>\\<^bsub>ns\\<^esub> (cms\\<^sub>2'',\n                 mem\\<^sub>2'') \\<and>\n        makes_compatible (cms\\<^sub>1'', mem\\<^sub>1'')\n         (cms\\<^sub>2'', mem\\<^sub>2'') mems'' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  sound_mode_use (cms\\<^sub>1'', mem\\<^sub>1'') \\<and>\n  sound_mode_use (cms\\<^sub>2'', mem\\<^sub>2'') \\<and>\n  map snd cms\\<^sub>1'' = map snd cms\\<^sub>2'' \\<and>\n  (cms\\<^sub>2,\n   mem\\<^sub>2) \\<rightarrow>\\<^bsub>ns\\<^esub> (cms\\<^sub>2'',\n           mem\\<^sub>2'') \\<and>\n  makes_compatible (cms\\<^sub>1'', mem\\<^sub>1'')\n   (cms\\<^sub>2'', mem\\<^sub>2'') mems''\n\ngoal (1 subgoal):\n 1. \\<And>x xs cms\\<^sub>1' mem\\<^sub>1'.\n       \\<lbrakk>\\<And>cms\\<^sub>1' mem\\<^sub>1'.\n                   (cms\\<^sub>1,\n                    mem\\<^sub>1) \\<rightarrow>\\<^bsub>xs\\<^esub> (cms\\<^sub>1',\n                            mem\\<^sub>1') \\<Longrightarrow>\n                   \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                      sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                      sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                      map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n                      (cms\\<^sub>2,\n                       mem\\<^sub>2) \\<rightarrow>\\<^bsub>xs\\<^esub> (cms\\<^sub>2',\n                               mem\\<^sub>2') \\<and>\n                      makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                       (cms\\<^sub>2', mem\\<^sub>2') mems';\n        (cms\\<^sub>1,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>xs @\n     [x]\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                            sound_mode_use\n                             (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                            sound_mode_use\n                             (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                            map snd cms\\<^sub>1' =\n                            map snd cms\\<^sub>2' \\<and>\n                            (cms\\<^sub>2,\n                             mem\\<^sub>2) \\<rightarrow>\\<^bsub>xs @\n                         [x]\\<^esub> (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                            makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                             (cms\\<^sub>2', mem\\<^sub>2') mems'", "ultimately"], ["proof (chain)\npicking this:\n  (cms\\<^sub>1'',\n   mem\\<^sub>1'') \\<leadsto>\\<^bsub>n\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\n  sound_mode_use (cms\\<^sub>1'', mem\\<^sub>1'') \\<and>\n  sound_mode_use (cms\\<^sub>2'', mem\\<^sub>2'') \\<and>\n  map snd cms\\<^sub>1'' = map snd cms\\<^sub>2'' \\<and>\n  (cms\\<^sub>2,\n   mem\\<^sub>2) \\<rightarrow>\\<^bsub>ns\\<^esub> (cms\\<^sub>2'',\n           mem\\<^sub>2'') \\<and>\n  makes_compatible (cms\\<^sub>1'', mem\\<^sub>1'')\n   (cms\\<^sub>2'', mem\\<^sub>2'') mems''", "obtain cms\\<^sub>2' mem\\<^sub>2' mems' where\n      \"map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n       (cms\\<^sub>2'', mem\\<^sub>2'') \\<leadsto>\\<^bsub>n\\<^esub> (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n       makes_compatible (cms\\<^sub>1', mem\\<^sub>1') (cms\\<^sub>2', mem\\<^sub>2') mems'\""], ["proof (prove)\nusing this:\n  (cms\\<^sub>1'',\n   mem\\<^sub>1'') \\<leadsto>\\<^bsub>n\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\n  sound_mode_use (cms\\<^sub>1'', mem\\<^sub>1'') \\<and>\n  sound_mode_use (cms\\<^sub>2'', mem\\<^sub>2'') \\<and>\n  map snd cms\\<^sub>1'' = map snd cms\\<^sub>2'' \\<and>\n  (cms\\<^sub>2,\n   mem\\<^sub>2) \\<rightarrow>\\<^bsub>ns\\<^esub> (cms\\<^sub>2'',\n           mem\\<^sub>2'') \\<and>\n  makes_compatible (cms\\<^sub>1'', mem\\<^sub>1'')\n   (cms\\<^sub>2'', mem\\<^sub>2'') mems''\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2'',\n         mem\\<^sub>2'') \\<leadsto>\\<^bsub>n\\<^esub> (cms\\<^sub>2',\n               mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using makes_compatible_invariant"], ["proof (prove)\nusing this:\n  (cms\\<^sub>1'',\n   mem\\<^sub>1'') \\<leadsto>\\<^bsub>n\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\n  sound_mode_use (cms\\<^sub>1'', mem\\<^sub>1'') \\<and>\n  sound_mode_use (cms\\<^sub>2'', mem\\<^sub>2'') \\<and>\n  map snd cms\\<^sub>1'' = map snd cms\\<^sub>2'' \\<and>\n  (cms\\<^sub>2,\n   mem\\<^sub>2) \\<rightarrow>\\<^bsub>ns\\<^esub> (cms\\<^sub>2'',\n           mem\\<^sub>2'') \\<and>\n  makes_compatible (cms\\<^sub>1'', mem\\<^sub>1'')\n   (cms\\<^sub>2'', mem\\<^sub>2'') mems''\n  \\<lbrakk>sound_mode_use (?cms\\<^sub>1, ?mem\\<^sub>1);\n   sound_mode_use (?cms\\<^sub>2, ?mem\\<^sub>2);\n   makes_compatible (?cms\\<^sub>1, ?mem\\<^sub>1)\n    (?cms\\<^sub>2, ?mem\\<^sub>2) ?mems;\n   map snd ?cms\\<^sub>1 = map snd ?cms\\<^sub>2;\n   (?cms\\<^sub>1,\n    ?mem\\<^sub>1) \\<leadsto>\\<^bsub>?k\\<^esub> (?cms\\<^sub>1',\n          ?mem\\<^sub>1');\n   \\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n      map snd ?cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n      (?cms\\<^sub>2,\n       ?mem\\<^sub>2) \\<leadsto>\\<^bsub>?k\\<^esub> (cms\\<^sub>2',\n             mem\\<^sub>2') \\<and>\n      makes_compatible (?cms\\<^sub>1', ?mem\\<^sub>1')\n       (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n      ?thesis\\<rbrakk>\n  \\<Longrightarrow> ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cms\\<^sub>2'',\n         mem\\<^sub>2'') \\<leadsto>\\<^bsub>n\\<^esub> (cms\\<^sub>2',\n               mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n  (cms\\<^sub>2'',\n   mem\\<^sub>2'') \\<leadsto>\\<^bsub>n\\<^esub> (cms\\<^sub>2',\n         mem\\<^sub>2') \\<and>\n  makes_compatible (cms\\<^sub>1', mem\\<^sub>1') (cms\\<^sub>2', mem\\<^sub>2')\n   mems'\n\ngoal (1 subgoal):\n 1. \\<And>x xs cms\\<^sub>1' mem\\<^sub>1'.\n       \\<lbrakk>\\<And>cms\\<^sub>1' mem\\<^sub>1'.\n                   (cms\\<^sub>1,\n                    mem\\<^sub>1) \\<rightarrow>\\<^bsub>xs\\<^esub> (cms\\<^sub>1',\n                            mem\\<^sub>1') \\<Longrightarrow>\n                   \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                      sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                      sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                      map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n                      (cms\\<^sub>2,\n                       mem\\<^sub>2) \\<rightarrow>\\<^bsub>xs\\<^esub> (cms\\<^sub>2',\n                               mem\\<^sub>2') \\<and>\n                      makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                       (cms\\<^sub>2', mem\\<^sub>2') mems';\n        (cms\\<^sub>1,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>xs @\n     [x]\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                            sound_mode_use\n                             (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n                            sound_mode_use\n                             (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                            map snd cms\\<^sub>1' =\n                            map snd cms\\<^sub>2' \\<and>\n                            (cms\\<^sub>2,\n                             mem\\<^sub>2) \\<rightarrow>\\<^bsub>xs @\n                         [x]\\<^esub> (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                            makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n                             (cms\\<^sub>2', mem\\<^sub>2') mems'", "thus ?case"], ["proof (prove)\nusing this:\n  map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n  (cms\\<^sub>2'',\n   mem\\<^sub>2'') \\<leadsto>\\<^bsub>n\\<^esub> (cms\\<^sub>2',\n         mem\\<^sub>2') \\<and>\n  makes_compatible (cms\\<^sub>1', mem\\<^sub>1') (cms\\<^sub>2', mem\\<^sub>2')\n   mems'\n\ngoal (1 subgoal):\n 1. \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n       sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n       sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n       map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n       (cms\\<^sub>2,\n        mem\\<^sub>2) \\<rightarrow>\\<^bsub>ns @\n    [n]\\<^esub> (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n       makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n        (cms\\<^sub>2', mem\\<^sub>2') mems'", "using IH eval'' meval_sched_snocI sound_modes_invariant"], ["proof (prove)\nusing this:\n  map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n  (cms\\<^sub>2'',\n   mem\\<^sub>2'') \\<leadsto>\\<^bsub>n\\<^esub> (cms\\<^sub>2',\n         mem\\<^sub>2') \\<and>\n  makes_compatible (cms\\<^sub>1', mem\\<^sub>1') (cms\\<^sub>2', mem\\<^sub>2')\n   mems'\n  sound_mode_use (cms\\<^sub>1'', mem\\<^sub>1'') \\<and>\n  sound_mode_use (cms\\<^sub>2'', mem\\<^sub>2'') \\<and>\n  map snd cms\\<^sub>1'' = map snd cms\\<^sub>2'' \\<and>\n  (cms\\<^sub>2,\n   mem\\<^sub>2) \\<rightarrow>\\<^bsub>ns\\<^esub> (cms\\<^sub>2'',\n           mem\\<^sub>2'') \\<and>\n  makes_compatible (cms\\<^sub>1'', mem\\<^sub>1'')\n   (cms\\<^sub>2'', mem\\<^sub>2'') mems''\n  (cms\\<^sub>1,\n   mem\\<^sub>1) \\<rightarrow>\\<^bsub>ns\\<^esub> (cms\\<^sub>1'',\n           mem\\<^sub>1'') \\<and>\n  (cms\\<^sub>1'',\n   mem\\<^sub>1'') \\<leadsto>\\<^bsub>n\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\n  (?cms\\<^sub>1,\n   ?mem\\<^sub>1) \\<rightarrow>\\<^bsub>?ns\\<^esub> (?cms\\<^sub>1'',\n             ?mem\\<^sub>1'') \\<and>\n  (?cms\\<^sub>1'',\n   ?mem\\<^sub>1'') \\<leadsto>\\<^bsub>?n\\<^esub> (?cms\\<^sub>1',\n           ?mem\\<^sub>1') \\<Longrightarrow>\n  (?cms\\<^sub>1,\n   ?mem\\<^sub>1) \\<rightarrow>\\<^bsub>?ns @\n[?n]\\<^esub> (?cms\\<^sub>1', ?mem\\<^sub>1')\n  \\<lbrakk>sound_mode_use (?cms, ?mem);\n   (?cms, ?mem) \\<leadsto>\\<^bsub>?k\\<^esub> (?cms', ?mem')\\<rbrakk>\n  \\<Longrightarrow> sound_mode_use (?cms', ?mem')\n\ngoal (1 subgoal):\n 1. \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n       sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n       sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n       map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n       (cms\\<^sub>2,\n        mem\\<^sub>2) \\<rightarrow>\\<^bsub>ns @\n    [n]\\<^esub> (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n       makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n        (cms\\<^sub>2', mem\\<^sub>2') mems'", "by metis"], ["proof (state)\nthis:\n  \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n     sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n     sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n     map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n     (cms\\<^sub>2,\n      mem\\<^sub>2) \\<rightarrow>\\<^bsub>ns @\n  [n]\\<^esub> (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n     makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n      (cms\\<^sub>2', mem\\<^sub>2') mems'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n     sound_mode_use (cms\\<^sub>1', mem\\<^sub>1') \\<and>\n     sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n     map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n     (cms\\<^sub>2,\n      mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2',\n                 mem\\<^sub>2') \\<and>\n     makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n      (cms\\<^sub>2', mem\\<^sub>2') mems'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma differing_vars_initially_empty:\n  \"i < n \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 (zip (replicate n mem\\<^sub>1) (replicate n mem\\<^sub>2)) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i < n \\<Longrightarrow>\n    x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                (zip (replicate n mem\\<^sub>1) (replicate n mem\\<^sub>2)) i", "unfolding differing_vars_lists_def differing_vars_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. i < n \\<Longrightarrow>\n    x \\<notin> {x. mem\\<^sub>1 x \\<noteq>\n                   fst (zip (replicate n mem\\<^sub>1)\n                         (replicate n mem\\<^sub>2) !\n                        i)\n                    x} \\<union>\n               {x. mem\\<^sub>2 x \\<noteq>\n                   snd (zip (replicate n mem\\<^sub>1)\n                         (replicate n mem\\<^sub>2) !\n                        i)\n                    x}", "by auto"], ["", "lemma compatible_refl:\n  assumes coms_secure: \"list_all com_sifum_secure cmds\"\n  assumes low_eq: \"mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2\"\n  shows \"makes_compatible (cmds, mem\\<^sub>1)\n                          (cmds, mem\\<^sub>2)\n                          (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. makes_compatible (cmds, mem\\<^sub>1) (cmds, mem\\<^sub>2)\n     (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. makes_compatible (cmds, mem\\<^sub>1) (cmds, mem\\<^sub>2)\n     (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))", "let ?n = \"length cmds\""], ["proof (state)\ngoal (1 subgoal):\n 1. makes_compatible (cmds, mem\\<^sub>1) (cmds, mem\\<^sub>2)\n     (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))", "let ?mems = \"replicate ?n (mem\\<^sub>1, mem\\<^sub>2)\" and\n      ?mdss = \"map snd cmds\""], ["proof (state)\ngoal (1 subgoal):\n 1. makes_compatible (cmds, mem\\<^sub>1) (cmds, mem\\<^sub>2)\n     (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))", "let ?X = \"differing_vars_lists mem\\<^sub>1 mem\\<^sub>2 ?mems\""], ["proof (state)\ngoal (1 subgoal):\n 1. makes_compatible (cmds, mem\\<^sub>1) (cmds, mem\\<^sub>2)\n     (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))", "have diff_empty: \"\\<forall> i < ?n. ?X i = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length cmds.\n       differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n        (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i =\n       {}", "by (metis differing_vars_initially_empty ex_in_conv min.idem zip_replicate)"], ["proof (state)\nthis:\n  \\<forall>i<length cmds.\n     differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n      (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i =\n     {}\n\ngoal (1 subgoal):\n 1. makes_compatible (cmds, mem\\<^sub>1) (cmds, mem\\<^sub>2)\n     (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. makes_compatible (cmds, mem\\<^sub>1) (cmds, mem\\<^sub>2)\n     (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. length cmds = length cmds \\<and>\n    length cmds =\n    length (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n 2. \\<And>i \\<sigma>.\n       \\<lbrakk>i < length cmds;\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n         (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i\\<rbrakk>\n       \\<Longrightarrow> (cmds ! i,\n                          subst \\<sigma>\n                           (fst (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i))) \\<approx>\n                         (cmds ! i,\n                          subst \\<sigma>\n                           (snd (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i)))\n 3. \\<And>i x.\n       \\<lbrakk>i < length cmds;\n        mem\\<^sub>1 x = mem\\<^sub>2 x \\<or>\n        dma mem\\<^sub>1 x = High \\<or> x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1\n                                     mem\\<^sub>2\n                                     (replicate (length cmds)\n (mem\\<^sub>1, mem\\<^sub>2))\n                                     i\n 4. length cmds = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cmds.\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "show \"length cmds = length cmds \\<and> length cmds = length ?mems\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length cmds = length cmds \\<and>\n    length cmds =\n    length (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))", "by auto"], ["proof (state)\nthis:\n  length cmds = length cmds \\<and>\n  length cmds = length (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n\ngoal (3 subgoals):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>i < length cmds;\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n         (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i\\<rbrakk>\n       \\<Longrightarrow> (cmds ! i,\n                          subst \\<sigma>\n                           (fst (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i))) \\<approx>\n                         (cmds ! i,\n                          subst \\<sigma>\n                           (snd (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i)))\n 2. \\<And>i x.\n       \\<lbrakk>i < length cmds;\n        mem\\<^sub>1 x = mem\\<^sub>2 x \\<or>\n        dma mem\\<^sub>1 x = High \\<or> x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1\n                                     mem\\<^sub>2\n                                     (replicate (length cmds)\n (mem\\<^sub>1, mem\\<^sub>2))\n                                     i\n 3. length cmds = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cmds.\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>i < length cmds;\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n         (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i\\<rbrakk>\n       \\<Longrightarrow> (cmds ! i,\n                          subst \\<sigma>\n                           (fst (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i))) \\<approx>\n                         (cmds ! i,\n                          subst \\<sigma>\n                           (snd (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i)))\n 2. \\<And>i x.\n       \\<lbrakk>i < length cmds;\n        mem\\<^sub>1 x = mem\\<^sub>2 x \\<or>\n        dma mem\\<^sub>1 x = High \\<or> x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1\n                                     mem\\<^sub>2\n                                     (replicate (length cmds)\n (mem\\<^sub>1, mem\\<^sub>2))\n                                     i\n 3. length cmds = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cmds.\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "fix i and \\<sigma> :: \"'Var \\<Rightarrow> 'Val option\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>i < length cmds;\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n         (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i\\<rbrakk>\n       \\<Longrightarrow> (cmds ! i,\n                          subst \\<sigma>\n                           (fst (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i))) \\<approx>\n                         (cmds ! i,\n                          subst \\<sigma>\n                           (snd (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i)))\n 2. \\<And>i x.\n       \\<lbrakk>i < length cmds;\n        mem\\<^sub>1 x = mem\\<^sub>2 x \\<or>\n        dma mem\\<^sub>1 x = High \\<or> x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1\n                                     mem\\<^sub>2\n                                     (replicate (length cmds)\n (mem\\<^sub>1, mem\\<^sub>2))\n                                     i\n 3. length cmds = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cmds.\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "let ?mems\\<^sub>1i = \"fst (?mems ! i)\" and ?mems\\<^sub>2i = \"snd (?mems ! i)\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>i < length cmds;\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n         (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i\\<rbrakk>\n       \\<Longrightarrow> (cmds ! i,\n                          subst \\<sigma>\n                           (fst (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i))) \\<approx>\n                         (cmds ! i,\n                          subst \\<sigma>\n                           (snd (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i)))\n 2. \\<And>i x.\n       \\<lbrakk>i < length cmds;\n        mem\\<^sub>1 x = mem\\<^sub>2 x \\<or>\n        dma mem\\<^sub>1 x = High \\<or> x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1\n                                     mem\\<^sub>2\n                                     (replicate (length cmds)\n (mem\\<^sub>1, mem\\<^sub>2))\n                                     i\n 3. length cmds = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cmds.\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "let ?mdss\\<^sub>i = \"?mdss ! i\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>i < length cmds;\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n         (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i\\<rbrakk>\n       \\<Longrightarrow> (cmds ! i,\n                          subst \\<sigma>\n                           (fst (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i))) \\<approx>\n                         (cmds ! i,\n                          subst \\<sigma>\n                           (snd (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i)))\n 2. \\<And>i x.\n       \\<lbrakk>i < length cmds;\n        mem\\<^sub>1 x = mem\\<^sub>2 x \\<or>\n        dma mem\\<^sub>1 x = High \\<or> x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1\n                                     mem\\<^sub>2\n                                     (replicate (length cmds)\n (mem\\<^sub>1, mem\\<^sub>2))\n                                     i\n 3. length cmds = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cmds.\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "assume i: \"i < length cmds\""], ["proof (state)\nthis:\n  i < length cmds\n\ngoal (3 subgoals):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>i < length cmds;\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n         (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i\\<rbrakk>\n       \\<Longrightarrow> (cmds ! i,\n                          subst \\<sigma>\n                           (fst (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i))) \\<approx>\n                         (cmds ! i,\n                          subst \\<sigma>\n                           (snd (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i)))\n 2. \\<And>i x.\n       \\<lbrakk>i < length cmds;\n        mem\\<^sub>1 x = mem\\<^sub>2 x \\<or>\n        dma mem\\<^sub>1 x = High \\<or> x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1\n                                     mem\\<^sub>2\n                                     (replicate (length cmds)\n (mem\\<^sub>1, mem\\<^sub>2))\n                                     i\n 3. length cmds = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cmds.\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "assume dom\\<sigma>: \"dom \\<sigma> =\n                  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                                      (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i\""], ["proof (state)\nthis:\n  dom \\<sigma> =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n   (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i\n\ngoal (3 subgoals):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>i < length cmds;\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n         (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i\\<rbrakk>\n       \\<Longrightarrow> (cmds ! i,\n                          subst \\<sigma>\n                           (fst (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i))) \\<approx>\n                         (cmds ! i,\n                          subst \\<sigma>\n                           (snd (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i)))\n 2. \\<And>i x.\n       \\<lbrakk>i < length cmds;\n        mem\\<^sub>1 x = mem\\<^sub>2 x \\<or>\n        dma mem\\<^sub>1 x = High \\<or> x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1\n                                     mem\\<^sub>2\n                                     (replicate (length cmds)\n (mem\\<^sub>1, mem\\<^sub>2))\n                                     i\n 3. length cmds = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cmds.\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "from i"], ["proof (chain)\npicking this:\n  i < length cmds", "have \"?mems\\<^sub>1i = mem\\<^sub>1\" \"?mems\\<^sub>2i = mem\\<^sub>2\""], ["proof (prove)\nusing this:\n  i < length cmds\n\ngoal (1 subgoal):\n 1. fst (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) ! i) =\n    mem\\<^sub>1 &&&\n    snd (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) ! i) =\n    mem\\<^sub>2", "by auto"], ["proof (state)\nthis:\n  fst (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) ! i) = mem\\<^sub>1\n  snd (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) ! i) = mem\\<^sub>2\n\ngoal (3 subgoals):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>i < length cmds;\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n         (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i\\<rbrakk>\n       \\<Longrightarrow> (cmds ! i,\n                          subst \\<sigma>\n                           (fst (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i))) \\<approx>\n                         (cmds ! i,\n                          subst \\<sigma>\n                           (snd (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i)))\n 2. \\<And>i x.\n       \\<lbrakk>i < length cmds;\n        mem\\<^sub>1 x = mem\\<^sub>2 x \\<or>\n        dma mem\\<^sub>1 x = High \\<or> x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1\n                                     mem\\<^sub>2\n                                     (replicate (length cmds)\n (mem\\<^sub>1, mem\\<^sub>2))\n                                     i\n 3. length cmds = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cmds.\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "with dom\\<sigma>"], ["proof (chain)\npicking this:\n  dom \\<sigma> =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n   (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i\n  fst (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) ! i) = mem\\<^sub>1\n  snd (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) ! i) = mem\\<^sub>2", "have [simp]: \"dom \\<sigma> = {}\""], ["proof (prove)\nusing this:\n  dom \\<sigma> =\n  differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n   (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i\n  fst (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) ! i) = mem\\<^sub>1\n  snd (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) ! i) = mem\\<^sub>2\n\ngoal (1 subgoal):\n 1. dom \\<sigma> = {}", "by(auto simp: differing_vars_lists_def differing_vars_def i)"], ["proof (state)\nthis:\n  dom \\<sigma> = {}\n\ngoal (3 subgoals):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>i < length cmds;\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n         (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i\\<rbrakk>\n       \\<Longrightarrow> (cmds ! i,\n                          subst \\<sigma>\n                           (fst (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i))) \\<approx>\n                         (cmds ! i,\n                          subst \\<sigma>\n                           (snd (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i)))\n 2. \\<And>i x.\n       \\<lbrakk>i < length cmds;\n        mem\\<^sub>1 x = mem\\<^sub>2 x \\<or>\n        dma mem\\<^sub>1 x = High \\<or> x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1\n                                     mem\\<^sub>2\n                                     (replicate (length cmds)\n (mem\\<^sub>1, mem\\<^sub>2))\n                                     i\n 3. length cmds = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cmds.\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "from i coms_secure"], ["proof (chain)\npicking this:\n  i < length cmds\n  list_all com_sifum_secure cmds", "have \"com_sifum_secure (cmds ! i)\""], ["proof (prove)\nusing this:\n  i < length cmds\n  list_all com_sifum_secure cmds\n\ngoal (1 subgoal):\n 1. com_sifum_secure (cmds ! i)", "using coms_secure"], ["proof (prove)\nusing this:\n  i < length cmds\n  list_all com_sifum_secure cmds\n  list_all com_sifum_secure cmds\n\ngoal (1 subgoal):\n 1. com_sifum_secure (cmds ! i)", "by (metis length_map length_replicate list_all_length map_snd_zip)"], ["proof (state)\nthis:\n  com_sifum_secure (cmds ! i)\n\ngoal (3 subgoals):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>i < length cmds;\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n         (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i\\<rbrakk>\n       \\<Longrightarrow> (cmds ! i,\n                          subst \\<sigma>\n                           (fst (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i))) \\<approx>\n                         (cmds ! i,\n                          subst \\<sigma>\n                           (snd (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i)))\n 2. \\<And>i x.\n       \\<lbrakk>i < length cmds;\n        mem\\<^sub>1 x = mem\\<^sub>2 x \\<or>\n        dma mem\\<^sub>1 x = High \\<or> x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1\n                                     mem\\<^sub>2\n                                     (replicate (length cmds)\n (mem\\<^sub>1, mem\\<^sub>2))\n                                     i\n 3. length cmds = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cmds.\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "with i"], ["proof (chain)\npicking this:\n  i < length cmds\n  com_sifum_secure (cmds ! i)", "have \"\\<And> mem\\<^sub>1 mem\\<^sub>2. mem\\<^sub>1 =\\<^bsub>?mdss\\<^sub>i\\<^esub>\\<^sup>l mem\\<^sub>2 \\<Longrightarrow>\n      (cmds ! i, mem\\<^sub>1) \\<approx> (cmds ! i, mem\\<^sub>2)\""], ["proof (prove)\nusing this:\n  i < length cmds\n  com_sifum_secure (cmds ! i)\n\ngoal (1 subgoal):\n 1. \\<And>mem\\<^sub>1 mem\\<^sub>2.\n       mem\\<^sub>1 =\\<^bsub>map snd cmds ! i\\<^esub>\\<^sup>l mem\\<^sub>2 \\<Longrightarrow>\n       (cmds ! i, mem\\<^sub>1) \\<approx> (cmds ! i, mem\\<^sub>2)", "using com_sifum_secure_def low_indistinguishable_def"], ["proof (prove)\nusing this:\n  i < length cmds\n  com_sifum_secure (cmds ! i)\n  com_sifum_secure ?cmd \\<equiv>\n  case ?cmd of\n  (c, mds\\<^sub>s) \\<Rightarrow> c \\<sim>\\<^bsub>mds\\<^sub>s\\<^esub> c\n  ?c\\<^sub>1 \\<sim>\\<^bsub>?mds\\<^esub> ?c\\<^sub>2 =\n  (\\<forall>mem\\<^sub>1 mem\\<^sub>2.\n      mem\\<^sub>1 =\\<^bsub>?mds\\<^esub>\\<^sup>l mem\\<^sub>2 \\<longrightarrow>\n      \\<langle>?c\\<^sub>1, ?mds, mem\\<^sub>1\\<rangle> \\<approx>\n      \\<langle>?c\\<^sub>2, ?mds, mem\\<^sub>2\\<rangle>)\n\ngoal (1 subgoal):\n 1. \\<And>mem\\<^sub>1 mem\\<^sub>2.\n       mem\\<^sub>1 =\\<^bsub>map snd cmds ! i\\<^esub>\\<^sup>l mem\\<^sub>2 \\<Longrightarrow>\n       (cmds ! i, mem\\<^sub>1) \\<approx> (cmds ! i, mem\\<^sub>2)", "by auto"], ["proof (state)\nthis:\n  ?mem\\<^sub>15 =\\<^bsub>map snd cmds ! i\\<^esub>\\<^sup>l ?mem\\<^sub>25 \\<Longrightarrow>\n  (cmds ! i, ?mem\\<^sub>15) \\<approx> (cmds ! i, ?mem\\<^sub>25)\n\ngoal (3 subgoals):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>i < length cmds;\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n         (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i\\<rbrakk>\n       \\<Longrightarrow> (cmds ! i,\n                          subst \\<sigma>\n                           (fst (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i))) \\<approx>\n                         (cmds ! i,\n                          subst \\<sigma>\n                           (snd (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i)))\n 2. \\<And>i x.\n       \\<lbrakk>i < length cmds;\n        mem\\<^sub>1 x = mem\\<^sub>2 x \\<or>\n        dma mem\\<^sub>1 x = High \\<or> x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1\n                                     mem\\<^sub>2\n                                     (replicate (length cmds)\n (mem\\<^sub>1, mem\\<^sub>2))\n                                     i\n 3. length cmds = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cmds.\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "moreover"], ["proof (state)\nthis:\n  ?mem\\<^sub>15 =\\<^bsub>map snd cmds ! i\\<^esub>\\<^sup>l ?mem\\<^sub>25 \\<Longrightarrow>\n  (cmds ! i, ?mem\\<^sub>15) \\<approx> (cmds ! i, ?mem\\<^sub>25)\n\ngoal (3 subgoals):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>i < length cmds;\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n         (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i\\<rbrakk>\n       \\<Longrightarrow> (cmds ! i,\n                          subst \\<sigma>\n                           (fst (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i))) \\<approx>\n                         (cmds ! i,\n                          subst \\<sigma>\n                           (snd (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i)))\n 2. \\<And>i x.\n       \\<lbrakk>i < length cmds;\n        mem\\<^sub>1 x = mem\\<^sub>2 x \\<or>\n        dma mem\\<^sub>1 x = High \\<or> x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1\n                                     mem\\<^sub>2\n                                     (replicate (length cmds)\n (mem\\<^sub>1, mem\\<^sub>2))\n                                     i\n 3. length cmds = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cmds.\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "have \"\\<And>x. \\<sigma> x = None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. \\<sigma> x = None", "using \\<open>dom \\<sigma> = {}\\<close>"], ["proof (prove)\nusing this:\n  dom \\<sigma> = {}\n\ngoal (1 subgoal):\n 1. \\<And>x. \\<sigma> x = None", "by (metis domIff empty_iff)"], ["proof (state)\nthis:\n  \\<sigma> ?x5 = None\n\ngoal (3 subgoals):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>i < length cmds;\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n         (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i\\<rbrakk>\n       \\<Longrightarrow> (cmds ! i,\n                          subst \\<sigma>\n                           (fst (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i))) \\<approx>\n                         (cmds ! i,\n                          subst \\<sigma>\n                           (snd (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i)))\n 2. \\<And>i x.\n       \\<lbrakk>i < length cmds;\n        mem\\<^sub>1 x = mem\\<^sub>2 x \\<or>\n        dma mem\\<^sub>1 x = High \\<or> x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1\n                                     mem\\<^sub>2\n                                     (replicate (length cmds)\n (mem\\<^sub>1, mem\\<^sub>2))\n                                     i\n 3. length cmds = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cmds.\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "hence [simp]: \"\\<And> mem. mem [\\<mapsto> \\<sigma>] = mem\""], ["proof (prove)\nusing this:\n  \\<sigma> ?x5 = None\n\ngoal (1 subgoal):\n 1. \\<And>mem. subst \\<sigma> mem = mem", "by(simp add: subst_def)"], ["proof (state)\nthis:\n  subst \\<sigma> ?mem5 = ?mem5\n\ngoal (3 subgoals):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>i < length cmds;\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n         (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i\\<rbrakk>\n       \\<Longrightarrow> (cmds ! i,\n                          subst \\<sigma>\n                           (fst (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i))) \\<approx>\n                         (cmds ! i,\n                          subst \\<sigma>\n                           (snd (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i)))\n 2. \\<And>i x.\n       \\<lbrakk>i < length cmds;\n        mem\\<^sub>1 x = mem\\<^sub>2 x \\<or>\n        dma mem\\<^sub>1 x = High \\<or> x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1\n                                     mem\\<^sub>2\n                                     (replicate (length cmds)\n (mem\\<^sub>1, mem\\<^sub>2))\n                                     i\n 3. length cmds = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cmds.\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "from i"], ["proof (chain)\npicking this:\n  i < length cmds", "have \"?mems\\<^sub>1i = mem\\<^sub>1\" \"?mems\\<^sub>2i = mem\\<^sub>2\""], ["proof (prove)\nusing this:\n  i < length cmds\n\ngoal (1 subgoal):\n 1. fst (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) ! i) =\n    mem\\<^sub>1 &&&\n    snd (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) ! i) =\n    mem\\<^sub>2", "by auto"], ["proof (state)\nthis:\n  fst (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) ! i) = mem\\<^sub>1\n  snd (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) ! i) = mem\\<^sub>2\n\ngoal (3 subgoals):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>i < length cmds;\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n         (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i\\<rbrakk>\n       \\<Longrightarrow> (cmds ! i,\n                          subst \\<sigma>\n                           (fst (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i))) \\<approx>\n                         (cmds ! i,\n                          subst \\<sigma>\n                           (snd (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i)))\n 2. \\<And>i x.\n       \\<lbrakk>i < length cmds;\n        mem\\<^sub>1 x = mem\\<^sub>2 x \\<or>\n        dma mem\\<^sub>1 x = High \\<or> x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1\n                                     mem\\<^sub>2\n                                     (replicate (length cmds)\n (mem\\<^sub>1, mem\\<^sub>2))\n                                     i\n 3. length cmds = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cmds.\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "with low_eq"], ["proof (chain)\npicking this:\n  mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2\n  fst (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) ! i) = mem\\<^sub>1\n  snd (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) ! i) = mem\\<^sub>2", "have \"?mems\\<^sub>1i [\\<mapsto> \\<sigma>] =\\<^bsub>?mdss\\<^sub>i\\<^esub>\\<^sup>l ?mems\\<^sub>2i [\\<mapsto> \\<sigma>]\""], ["proof (prove)\nusing this:\n  mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2\n  fst (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) ! i) = mem\\<^sub>1\n  snd (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) ! i) = mem\\<^sub>2\n\ngoal (1 subgoal):\n 1. subst \\<sigma>\n     (fst (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) !\n           i)) =\\<^bsub>map snd cmds ! i\\<^esub>\\<^sup>l subst \\<sigma>\n                    (snd (replicate (length cmds)\n                           (mem\\<^sub>1, mem\\<^sub>2) !\n                          i))", "by (auto simp: low_mds_eq_def low_eq_def)"], ["proof (state)\nthis:\n  subst \\<sigma>\n   (fst (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) !\n         i)) =\\<^bsub>map snd cmds ! i\\<^esub>\\<^sup>l subst \\<sigma>\n                  (snd (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) !\n                        i))\n\ngoal (3 subgoals):\n 1. \\<And>i \\<sigma>.\n       \\<lbrakk>i < length cmds;\n        dom \\<sigma> =\n        differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n         (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i\\<rbrakk>\n       \\<Longrightarrow> (cmds ! i,\n                          subst \\<sigma>\n                           (fst (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i))) \\<approx>\n                         (cmds ! i,\n                          subst \\<sigma>\n                           (snd (replicate (length cmds)\n                                  (mem\\<^sub>1, mem\\<^sub>2) !\n                                 i)))\n 2. \\<And>i x.\n       \\<lbrakk>i < length cmds;\n        mem\\<^sub>1 x = mem\\<^sub>2 x \\<or>\n        dma mem\\<^sub>1 x = High \\<or> x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1\n                                     mem\\<^sub>2\n                                     (replicate (length cmds)\n (mem\\<^sub>1, mem\\<^sub>2))\n                                     i\n 3. length cmds = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cmds.\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "ultimately"], ["proof (chain)\npicking this:\n  ?mem\\<^sub>15 =\\<^bsub>map snd cmds ! i\\<^esub>\\<^sup>l ?mem\\<^sub>25 \\<Longrightarrow>\n  (cmds ! i, ?mem\\<^sub>15) \\<approx> (cmds ! i, ?mem\\<^sub>25)\n  subst \\<sigma>\n   (fst (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) !\n         i)) =\\<^bsub>map snd cmds ! i\\<^esub>\\<^sup>l subst \\<sigma>\n                  (snd (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) !\n                        i))", "show \"(cmds ! i, ?mems\\<^sub>1i [\\<mapsto> \\<sigma>]) \\<approx> (cmds ! i, ?mems\\<^sub>2i [\\<mapsto> \\<sigma>])\""], ["proof (prove)\nusing this:\n  ?mem\\<^sub>15 =\\<^bsub>map snd cmds ! i\\<^esub>\\<^sup>l ?mem\\<^sub>25 \\<Longrightarrow>\n  (cmds ! i, ?mem\\<^sub>15) \\<approx> (cmds ! i, ?mem\\<^sub>25)\n  subst \\<sigma>\n   (fst (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) !\n         i)) =\\<^bsub>map snd cmds ! i\\<^esub>\\<^sup>l subst \\<sigma>\n                  (snd (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) !\n                        i))\n\ngoal (1 subgoal):\n 1. (cmds ! i,\n     subst \\<sigma>\n      (fst (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) !\n            i))) \\<approx>\n    (cmds ! i,\n     subst \\<sigma>\n      (snd (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) ! i)))", "by simp"], ["proof (state)\nthis:\n  (cmds ! i,\n   subst \\<sigma>\n    (fst (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) !\n          i))) \\<approx>\n  (cmds ! i,\n   subst \\<sigma>\n    (snd (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2) ! i)))\n\ngoal (2 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>i < length cmds;\n        mem\\<^sub>1 x = mem\\<^sub>2 x \\<or>\n        dma mem\\<^sub>1 x = High \\<or> x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1\n                                     mem\\<^sub>2\n                                     (replicate (length cmds)\n (mem\\<^sub>1, mem\\<^sub>2))\n                                     i\n 2. length cmds = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cmds.\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>i < length cmds;\n        mem\\<^sub>1 x = mem\\<^sub>2 x \\<or>\n        dma mem\\<^sub>1 x = High \\<or> x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1\n                                     mem\\<^sub>2\n                                     (replicate (length cmds)\n (mem\\<^sub>1, mem\\<^sub>2))\n                                     i\n 2. length cmds = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cmds.\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "fix i x"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>i < length cmds;\n        mem\\<^sub>1 x = mem\\<^sub>2 x \\<or>\n        dma mem\\<^sub>1 x = High \\<or> x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1\n                                     mem\\<^sub>2\n                                     (replicate (length cmds)\n (mem\\<^sub>1, mem\\<^sub>2))\n                                     i\n 2. length cmds = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cmds.\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "assume \"i < length cmds\""], ["proof (state)\nthis:\n  i < length cmds\n\ngoal (2 subgoals):\n 1. \\<And>i x.\n       \\<lbrakk>i < length cmds;\n        mem\\<^sub>1 x = mem\\<^sub>2 x \\<or>\n        dma mem\\<^sub>1 x = High \\<or> x \\<in> \\<C>\\<rbrakk>\n       \\<Longrightarrow> x \\<notin> differing_vars_lists mem\\<^sub>1\n                                     mem\\<^sub>2\n                                     (replicate (length cmds)\n (mem\\<^sub>1, mem\\<^sub>2))\n                                     i\n 2. length cmds = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cmds.\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "with diff_empty"], ["proof (chain)\npicking this:\n  \\<forall>i<length cmds.\n     differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n      (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i =\n     {}\n  i < length cmds", "show \"x \\<notin> ?X i\""], ["proof (prove)\nusing this:\n  \\<forall>i<length cmds.\n     differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n      (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i =\n     {}\n  i < length cmds\n\ngoal (1 subgoal):\n 1. x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i", "by auto"], ["proof (state)\nthis:\n  x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n              (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i\n\ngoal (1 subgoal):\n 1. length cmds = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cmds.\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. length cmds = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cmds.\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "show \"(length cmds = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2) \\<or> (\\<forall> x. \\<exists> i < length cmds. x \\<notin> ?X i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length cmds = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cmds.\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "using diff_empty"], ["proof (prove)\nusing this:\n  \\<forall>i<length cmds.\n     differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n      (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i =\n     {}\n\ngoal (1 subgoal):\n 1. length cmds = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n    (\\<forall>x.\n        \\<exists>i<length cmds.\n           x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                       (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n                       i)", "by (metis bot_less bot_nat_def empty_iff length_zip low_eq min_0L)"], ["proof (state)\nthis:\n  length cmds = 0 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<or>\n  (\\<forall>x.\n      \\<exists>i<length cmds.\n         x \\<notin> differing_vars_lists mem\\<^sub>1 mem\\<^sub>2\n                     (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2)) i)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  makes_compatible (cmds, mem\\<^sub>1) (cmds, mem\\<^sub>2)\n   (replicate (length cmds) (mem\\<^sub>1, mem\\<^sub>2))\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem sifum_compositionality_cont:\n  assumes com_secure: \"list_all com_sifum_secure cmds\"\n  assumes sound_modes: \"\\<forall> mem. INIT mem \\<longrightarrow> sound_mode_use (cmds, mem)\"\n  shows \"prog_sifum_secure_cont cmds\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prog_sifum_secure_cont cmds", "unfolding prog_sifum_secure_cont_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>mem\\<^sub>1 mem\\<^sub>2.\n       INIT mem\\<^sub>1 \\<and>\n       INIT mem\\<^sub>2 \\<and>\n       mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<longrightarrow>\n       (\\<forall>sched cms\\<^sub>1' mem\\<^sub>1'.\n           (cmds,\n            mem\\<^sub>1) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>1',\n                       mem\\<^sub>1') \\<longrightarrow>\n           (\\<exists>cms\\<^sub>2' mem\\<^sub>2'.\n               (cmds,\n                mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2',\n                           mem\\<^sub>2') \\<and>\n               map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n               length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n               (\\<forall>x.\n                   dma mem\\<^sub>1' x = Low \\<and>\n                   (x \\<in> \\<C> \\<or>\n                    (\\<forall>i<length cms\\<^sub>1'.\n                        x \\<notin> snd (cms\\<^sub>1' ! i)\n                                    AsmNoReadOrWrite)) \\<longrightarrow>\n                   mem\\<^sub>1' x = mem\\<^sub>2' x)))", "using assms"], ["proof (prove)\nusing this:\n  list_all com_sifum_secure cmds\n  \\<forall>mem. INIT mem \\<longrightarrow> sound_mode_use (cmds, mem)\n\ngoal (1 subgoal):\n 1. \\<forall>mem\\<^sub>1 mem\\<^sub>2.\n       INIT mem\\<^sub>1 \\<and>\n       INIT mem\\<^sub>2 \\<and>\n       mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<longrightarrow>\n       (\\<forall>sched cms\\<^sub>1' mem\\<^sub>1'.\n           (cmds,\n            mem\\<^sub>1) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>1',\n                       mem\\<^sub>1') \\<longrightarrow>\n           (\\<exists>cms\\<^sub>2' mem\\<^sub>2'.\n               (cmds,\n                mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2',\n                           mem\\<^sub>2') \\<and>\n               map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n               length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n               (\\<forall>x.\n                   dma mem\\<^sub>1' x = Low \\<and>\n                   (x \\<in> \\<C> \\<or>\n                    (\\<forall>i<length cms\\<^sub>1'.\n                        x \\<notin> snd (cms\\<^sub>1' ! i)\n                                    AsmNoReadOrWrite)) \\<longrightarrow>\n                   mem\\<^sub>1' x = mem\\<^sub>2' x)))", "proof (clarify)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>mem\\<^sub>1 mem\\<^sub>2 sched cms\\<^sub>1' mem\\<^sub>1'.\n       \\<lbrakk>list_all com_sifum_secure cmds;\n        \\<forall>mem. INIT mem \\<longrightarrow> sound_mode_use (cmds, mem);\n        INIT mem\\<^sub>1; INIT mem\\<^sub>2;\n        mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2;\n        (cmds,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>1',\n                    mem\\<^sub>1')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2'.\n                            (cmds,\n                             mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2',\n  mem\\<^sub>2') \\<and>\n                            map snd cms\\<^sub>1' =\n                            map snd cms\\<^sub>2' \\<and>\n                            length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n                            (\\<forall>x.\n                                dma mem\\<^sub>1' x = Low \\<and>\n                                (x \\<in> \\<C> \\<or>\n                                 (\\<forall>i<length cms\\<^sub>1'.\n                                     x \\<notin> snd (cms\\<^sub>1' ! i)\n           AsmNoReadOrWrite)) \\<longrightarrow>\n                                mem\\<^sub>1' x = mem\\<^sub>2' x)", "fix mem\\<^sub>1 mem\\<^sub>2 :: \"'Var \\<Rightarrow> 'Val\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>mem\\<^sub>1 mem\\<^sub>2 sched cms\\<^sub>1' mem\\<^sub>1'.\n       \\<lbrakk>list_all com_sifum_secure cmds;\n        \\<forall>mem. INIT mem \\<longrightarrow> sound_mode_use (cmds, mem);\n        INIT mem\\<^sub>1; INIT mem\\<^sub>2;\n        mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2;\n        (cmds,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>1',\n                    mem\\<^sub>1')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2'.\n                            (cmds,\n                             mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2',\n  mem\\<^sub>2') \\<and>\n                            map snd cms\\<^sub>1' =\n                            map snd cms\\<^sub>2' \\<and>\n                            length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n                            (\\<forall>x.\n                                dma mem\\<^sub>1' x = Low \\<and>\n                                (x \\<in> \\<C> \\<or>\n                                 (\\<forall>i<length cms\\<^sub>1'.\n                                     x \\<notin> snd (cms\\<^sub>1' ! i)\n           AsmNoReadOrWrite)) \\<longrightarrow>\n                                mem\\<^sub>1' x = mem\\<^sub>2' x)", "fix sched cms\\<^sub>1' mem\\<^sub>1'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>mem\\<^sub>1 mem\\<^sub>2 sched cms\\<^sub>1' mem\\<^sub>1'.\n       \\<lbrakk>list_all com_sifum_secure cmds;\n        \\<forall>mem. INIT mem \\<longrightarrow> sound_mode_use (cmds, mem);\n        INIT mem\\<^sub>1; INIT mem\\<^sub>2;\n        mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2;\n        (cmds,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>1',\n                    mem\\<^sub>1')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2'.\n                            (cmds,\n                             mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2',\n  mem\\<^sub>2') \\<and>\n                            map snd cms\\<^sub>1' =\n                            map snd cms\\<^sub>2' \\<and>\n                            length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n                            (\\<forall>x.\n                                dma mem\\<^sub>1' x = Low \\<and>\n                                (x \\<in> \\<C> \\<or>\n                                 (\\<forall>i<length cms\\<^sub>1'.\n                                     x \\<notin> snd (cms\\<^sub>1' ! i)\n           AsmNoReadOrWrite)) \\<longrightarrow>\n                                mem\\<^sub>1' x = mem\\<^sub>2' x)", "let ?n = \"length cmds\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>mem\\<^sub>1 mem\\<^sub>2 sched cms\\<^sub>1' mem\\<^sub>1'.\n       \\<lbrakk>list_all com_sifum_secure cmds;\n        \\<forall>mem. INIT mem \\<longrightarrow> sound_mode_use (cmds, mem);\n        INIT mem\\<^sub>1; INIT mem\\<^sub>2;\n        mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2;\n        (cmds,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>1',\n                    mem\\<^sub>1')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2'.\n                            (cmds,\n                             mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2',\n  mem\\<^sub>2') \\<and>\n                            map snd cms\\<^sub>1' =\n                            map snd cms\\<^sub>2' \\<and>\n                            length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n                            (\\<forall>x.\n                                dma mem\\<^sub>1' x = Low \\<and>\n                                (x \\<in> \\<C> \\<or>\n                                 (\\<forall>i<length cms\\<^sub>1'.\n                                     x \\<notin> snd (cms\\<^sub>1' ! i)\n           AsmNoReadOrWrite)) \\<longrightarrow>\n                                mem\\<^sub>1' x = mem\\<^sub>2' x)", "let ?mems = \"zip (replicate ?n mem\\<^sub>1) (replicate ?n mem\\<^sub>2)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>mem\\<^sub>1 mem\\<^sub>2 sched cms\\<^sub>1' mem\\<^sub>1'.\n       \\<lbrakk>list_all com_sifum_secure cmds;\n        \\<forall>mem. INIT mem \\<longrightarrow> sound_mode_use (cmds, mem);\n        INIT mem\\<^sub>1; INIT mem\\<^sub>2;\n        mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2;\n        (cmds,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>1',\n                    mem\\<^sub>1')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2'.\n                            (cmds,\n                             mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2',\n  mem\\<^sub>2') \\<and>\n                            map snd cms\\<^sub>1' =\n                            map snd cms\\<^sub>2' \\<and>\n                            length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n                            (\\<forall>x.\n                                dma mem\\<^sub>1' x = Low \\<and>\n                                (x \\<in> \\<C> \\<or>\n                                 (\\<forall>i<length cms\\<^sub>1'.\n                                     x \\<notin> snd (cms\\<^sub>1' ! i)\n           AsmNoReadOrWrite)) \\<longrightarrow>\n                                mem\\<^sub>1' x = mem\\<^sub>2' x)", "assume INIT\\<^sub>1: \"INIT mem\\<^sub>1\" and INIT\\<^sub>2: \"INIT mem\\<^sub>2\""], ["proof (state)\nthis:\n  INIT mem\\<^sub>1\n  INIT mem\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>mem\\<^sub>1 mem\\<^sub>2 sched cms\\<^sub>1' mem\\<^sub>1'.\n       \\<lbrakk>list_all com_sifum_secure cmds;\n        \\<forall>mem. INIT mem \\<longrightarrow> sound_mode_use (cmds, mem);\n        INIT mem\\<^sub>1; INIT mem\\<^sub>2;\n        mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2;\n        (cmds,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>1',\n                    mem\\<^sub>1')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2'.\n                            (cmds,\n                             mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2',\n  mem\\<^sub>2') \\<and>\n                            map snd cms\\<^sub>1' =\n                            map snd cms\\<^sub>2' \\<and>\n                            length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n                            (\\<forall>x.\n                                dma mem\\<^sub>1' x = Low \\<and>\n                                (x \\<in> \\<C> \\<or>\n                                 (\\<forall>i<length cms\\<^sub>1'.\n                                     x \\<notin> snd (cms\\<^sub>1' ! i)\n           AsmNoReadOrWrite)) \\<longrightarrow>\n                                mem\\<^sub>1' x = mem\\<^sub>2' x)", "assume low_eq: \"mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2\""], ["proof (state)\nthis:\n  mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2\n\ngoal (1 subgoal):\n 1. \\<And>mem\\<^sub>1 mem\\<^sub>2 sched cms\\<^sub>1' mem\\<^sub>1'.\n       \\<lbrakk>list_all com_sifum_secure cmds;\n        \\<forall>mem. INIT mem \\<longrightarrow> sound_mode_use (cmds, mem);\n        INIT mem\\<^sub>1; INIT mem\\<^sub>2;\n        mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2;\n        (cmds,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>1',\n                    mem\\<^sub>1')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2'.\n                            (cmds,\n                             mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2',\n  mem\\<^sub>2') \\<and>\n                            map snd cms\\<^sub>1' =\n                            map snd cms\\<^sub>2' \\<and>\n                            length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n                            (\\<forall>x.\n                                dma mem\\<^sub>1' x = Low \\<and>\n                                (x \\<in> \\<C> \\<or>\n                                 (\\<forall>i<length cms\\<^sub>1'.\n                                     x \\<notin> snd (cms\\<^sub>1' ! i)\n           AsmNoReadOrWrite)) \\<longrightarrow>\n                                mem\\<^sub>1' x = mem\\<^sub>2' x)", "with com_secure"], ["proof (chain)\npicking this:\n  list_all com_sifum_secure cmds\n  mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2", "have compat:\n    \"makes_compatible (cmds, mem\\<^sub>1) (cmds, mem\\<^sub>2) ?mems\""], ["proof (prove)\nusing this:\n  list_all com_sifum_secure cmds\n  mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2\n\ngoal (1 subgoal):\n 1. makes_compatible (cmds, mem\\<^sub>1) (cmds, mem\\<^sub>2)\n     (zip (replicate (length cmds) mem\\<^sub>1)\n       (replicate (length cmds) mem\\<^sub>2))", "by (metis compatible_refl fst_conv length_replicate map_replicate snd_conv zip_eq_conv INIT\\<^sub>1 INIT\\<^sub>2)"], ["proof (state)\nthis:\n  makes_compatible (cmds, mem\\<^sub>1) (cmds, mem\\<^sub>2)\n   (zip (replicate (length cmds) mem\\<^sub>1)\n     (replicate (length cmds) mem\\<^sub>2))\n\ngoal (1 subgoal):\n 1. \\<And>mem\\<^sub>1 mem\\<^sub>2 sched cms\\<^sub>1' mem\\<^sub>1'.\n       \\<lbrakk>list_all com_sifum_secure cmds;\n        \\<forall>mem. INIT mem \\<longrightarrow> sound_mode_use (cmds, mem);\n        INIT mem\\<^sub>1; INIT mem\\<^sub>2;\n        mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2;\n        (cmds,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>1',\n                    mem\\<^sub>1')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2'.\n                            (cmds,\n                             mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2',\n  mem\\<^sub>2') \\<and>\n                            map snd cms\\<^sub>1' =\n                            map snd cms\\<^sub>2' \\<and>\n                            length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n                            (\\<forall>x.\n                                dma mem\\<^sub>1' x = Low \\<and>\n                                (x \\<in> \\<C> \\<or>\n                                 (\\<forall>i<length cms\\<^sub>1'.\n                                     x \\<notin> snd (cms\\<^sub>1' ! i)\n           AsmNoReadOrWrite)) \\<longrightarrow>\n                                mem\\<^sub>1' x = mem\\<^sub>2' x)", "also"], ["proof (state)\nthis:\n  makes_compatible (cmds, mem\\<^sub>1) (cmds, mem\\<^sub>2)\n   (zip (replicate (length cmds) mem\\<^sub>1)\n     (replicate (length cmds) mem\\<^sub>2))\n\ngoal (1 subgoal):\n 1. \\<And>mem\\<^sub>1 mem\\<^sub>2 sched cms\\<^sub>1' mem\\<^sub>1'.\n       \\<lbrakk>list_all com_sifum_secure cmds;\n        \\<forall>mem. INIT mem \\<longrightarrow> sound_mode_use (cmds, mem);\n        INIT mem\\<^sub>1; INIT mem\\<^sub>2;\n        mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2;\n        (cmds,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>1',\n                    mem\\<^sub>1')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2'.\n                            (cmds,\n                             mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2',\n  mem\\<^sub>2') \\<and>\n                            map snd cms\\<^sub>1' =\n                            map snd cms\\<^sub>2' \\<and>\n                            length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n                            (\\<forall>x.\n                                dma mem\\<^sub>1' x = Low \\<and>\n                                (x \\<in> \\<C> \\<or>\n                                 (\\<forall>i<length cms\\<^sub>1'.\n                                     x \\<notin> snd (cms\\<^sub>1' ! i)\n           AsmNoReadOrWrite)) \\<longrightarrow>\n                                mem\\<^sub>1' x = mem\\<^sub>2' x)", "assume eval: \"(cmds, mem\\<^sub>1) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>1', mem\\<^sub>1')\""], ["proof (state)\nthis:\n  (cmds,\n   mem\\<^sub>1) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>1',\n              mem\\<^sub>1')\n\ngoal (1 subgoal):\n 1. \\<And>mem\\<^sub>1 mem\\<^sub>2 sched cms\\<^sub>1' mem\\<^sub>1'.\n       \\<lbrakk>list_all com_sifum_secure cmds;\n        \\<forall>mem. INIT mem \\<longrightarrow> sound_mode_use (cmds, mem);\n        INIT mem\\<^sub>1; INIT mem\\<^sub>2;\n        mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2;\n        (cmds,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>1',\n                    mem\\<^sub>1')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2'.\n                            (cmds,\n                             mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2',\n  mem\\<^sub>2') \\<and>\n                            map snd cms\\<^sub>1' =\n                            map snd cms\\<^sub>2' \\<and>\n                            length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n                            (\\<forall>x.\n                                dma mem\\<^sub>1' x = Low \\<and>\n                                (x \\<in> \\<C> \\<or>\n                                 (\\<forall>i<length cms\\<^sub>1'.\n                                     x \\<notin> snd (cms\\<^sub>1' ! i)\n           AsmNoReadOrWrite)) \\<longrightarrow>\n                                mem\\<^sub>1' x = mem\\<^sub>2' x)", "ultimately"], ["proof (chain)\npicking this:\n  makes_compatible (cmds, mem\\<^sub>1) (cmds, mem\\<^sub>2)\n   (zip (replicate (length cmds) mem\\<^sub>1)\n     (replicate (length cmds) mem\\<^sub>2))\n  (cmds,\n   mem\\<^sub>1) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>1',\n              mem\\<^sub>1')", "obtain cms\\<^sub>2' mem\\<^sub>2' mems'\n    where p: \"map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n             (cmds, mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n             makes_compatible (cms\\<^sub>1', mem\\<^sub>1') (cms\\<^sub>2', mem\\<^sub>2') mems'\""], ["proof (prove)\nusing this:\n  makes_compatible (cmds, mem\\<^sub>1) (cmds, mem\\<^sub>2)\n   (zip (replicate (length cmds) mem\\<^sub>1)\n     (replicate (length cmds) mem\\<^sub>2))\n  (cmds,\n   mem\\<^sub>1) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>1',\n              mem\\<^sub>1')\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cmds,\n         mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2',\n                    mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using sound_modes makes_compatible_eval_sched INIT\\<^sub>1 INIT\\<^sub>2"], ["proof (prove)\nusing this:\n  makes_compatible (cmds, mem\\<^sub>1) (cmds, mem\\<^sub>2)\n   (zip (replicate (length cmds) mem\\<^sub>1)\n     (replicate (length cmds) mem\\<^sub>2))\n  (cmds,\n   mem\\<^sub>1) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>1',\n              mem\\<^sub>1')\n  \\<forall>mem. INIT mem \\<longrightarrow> sound_mode_use (cmds, mem)\n  \\<lbrakk>makes_compatible (?cms\\<^sub>1, ?mem\\<^sub>1)\n            (?cms\\<^sub>2, ?mem\\<^sub>2) ?mems;\n   map snd ?cms\\<^sub>1 = map snd ?cms\\<^sub>2;\n   sound_mode_use (?cms\\<^sub>1, ?mem\\<^sub>1);\n   sound_mode_use (?cms\\<^sub>2, ?mem\\<^sub>2);\n   (?cms\\<^sub>1,\n    ?mem\\<^sub>1) \\<rightarrow>\\<^bsub>?sched\\<^esub> (?cms\\<^sub>1',\n                 ?mem\\<^sub>1')\\<rbrakk>\n  \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2' mems'.\n                       sound_mode_use (?cms\\<^sub>1', ?mem\\<^sub>1') \\<and>\n                       sound_mode_use (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                       map snd ?cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n                       (?cms\\<^sub>2,\n                        ?mem\\<^sub>2) \\<rightarrow>\\<^bsub>?sched\\<^esub> (cms\\<^sub>2',\n                                     mem\\<^sub>2') \\<and>\n                       makes_compatible (?cms\\<^sub>1', ?mem\\<^sub>1')\n                        (cms\\<^sub>2', mem\\<^sub>2') mems'\n  INIT mem\\<^sub>1\n  INIT mem\\<^sub>2\n\ngoal (1 subgoal):\n 1. (\\<And>cms\\<^sub>2' mem\\<^sub>2' mems'.\n        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n        (cmds,\n         mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2',\n                    mem\\<^sub>2') \\<and>\n        makes_compatible (cms\\<^sub>1', mem\\<^sub>1')\n         (cms\\<^sub>2', mem\\<^sub>2') mems' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n  (cmds,\n   mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2',\n              mem\\<^sub>2') \\<and>\n  makes_compatible (cms\\<^sub>1', mem\\<^sub>1') (cms\\<^sub>2', mem\\<^sub>2')\n   mems'\n\ngoal (1 subgoal):\n 1. \\<And>mem\\<^sub>1 mem\\<^sub>2 sched cms\\<^sub>1' mem\\<^sub>1'.\n       \\<lbrakk>list_all com_sifum_secure cmds;\n        \\<forall>mem. INIT mem \\<longrightarrow> sound_mode_use (cmds, mem);\n        INIT mem\\<^sub>1; INIT mem\\<^sub>2;\n        mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2;\n        (cmds,\n         mem\\<^sub>1) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>1',\n                    mem\\<^sub>1')\\<rbrakk>\n       \\<Longrightarrow> \\<exists>cms\\<^sub>2' mem\\<^sub>2'.\n                            (cmds,\n                             mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2',\n  mem\\<^sub>2') \\<and>\n                            map snd cms\\<^sub>1' =\n                            map snd cms\\<^sub>2' \\<and>\n                            length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n                            (\\<forall>x.\n                                dma mem\\<^sub>1' x = Low \\<and>\n                                (x \\<in> \\<C> \\<or>\n                                 (\\<forall>i<length cms\\<^sub>1'.\n                                     x \\<notin> snd (cms\\<^sub>1' ! i)\n           AsmNoReadOrWrite)) \\<longrightarrow>\n                                mem\\<^sub>1' x = mem\\<^sub>2' x)", "thus \"\\<exists> cms\\<^sub>2' mem\\<^sub>2'. (cmds, mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                        map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n                        length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n                        (\\<forall> x. dma mem\\<^sub>1' x = Low \\<and> (x \\<in> \\<C> \\<or> (\\<forall> i < length cms\\<^sub>1'. x \\<notin> snd (cms\\<^sub>1' ! i) AsmNoReadOrWrite))\n          \\<longrightarrow> mem\\<^sub>1' x = mem\\<^sub>2' x)\""], ["proof (prove)\nusing this:\n  map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n  (cmds,\n   mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2',\n              mem\\<^sub>2') \\<and>\n  makes_compatible (cms\\<^sub>1', mem\\<^sub>1') (cms\\<^sub>2', mem\\<^sub>2')\n   mems'\n\ngoal (1 subgoal):\n 1. \\<exists>cms\\<^sub>2' mem\\<^sub>2'.\n       (cmds,\n        mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2',\n                   mem\\<^sub>2') \\<and>\n       map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n       length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n       (\\<forall>x.\n           dma mem\\<^sub>1' x = Low \\<and>\n           (x \\<in> \\<C> \\<or>\n            (\\<forall>i<length cms\\<^sub>1'.\n                x \\<notin> snd (cms\\<^sub>1' ! i)\n                            AsmNoReadOrWrite)) \\<longrightarrow>\n           mem\\<^sub>1' x = mem\\<^sub>2' x)", "using p compat_low_eq"], ["proof (prove)\nusing this:\n  map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n  (cmds,\n   mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2',\n              mem\\<^sub>2') \\<and>\n  makes_compatible (cms\\<^sub>1', mem\\<^sub>1') (cms\\<^sub>2', mem\\<^sub>2')\n   mems'\n  map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n  (cmds,\n   mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2',\n              mem\\<^sub>2') \\<and>\n  makes_compatible (cms\\<^sub>1', mem\\<^sub>1') (cms\\<^sub>2', mem\\<^sub>2')\n   mems'\n  \\<lbrakk>makes_compatible (?cms\\<^sub>1, ?mem\\<^sub>1)\n            (?cms\\<^sub>2, ?mem\\<^sub>2) ?mems;\n   map snd ?cms\\<^sub>1 = map snd ?cms\\<^sub>2; dma ?mem\\<^sub>1 ?x = Low;\n   ?x \\<in> \\<C> \\<or>\n   (\\<forall>i<length ?cms\\<^sub>1.\n       ?x \\<notin> snd (?cms\\<^sub>1 ! i) AsmNoReadOrWrite)\\<rbrakk>\n  \\<Longrightarrow> ?mem\\<^sub>1 ?x = ?mem\\<^sub>2 ?x\n\ngoal (1 subgoal):\n 1. \\<exists>cms\\<^sub>2' mem\\<^sub>2'.\n       (cmds,\n        mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2',\n                   mem\\<^sub>2') \\<and>\n       map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n       length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n       (\\<forall>x.\n           dma mem\\<^sub>1' x = Low \\<and>\n           (x \\<in> \\<C> \\<or>\n            (\\<forall>i<length cms\\<^sub>1'.\n                x \\<notin> snd (cms\\<^sub>1' ! i)\n                            AsmNoReadOrWrite)) \\<longrightarrow>\n           mem\\<^sub>1' x = mem\\<^sub>2' x)", "by (metis length_map)"], ["proof (state)\nthis:\n  \\<exists>cms\\<^sub>2' mem\\<^sub>2'.\n     (cmds,\n      mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2',\n                 mem\\<^sub>2') \\<and>\n     map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n     length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n     (\\<forall>x.\n         dma mem\\<^sub>1' x = Low \\<and>\n         (x \\<in> \\<C> \\<or>\n          (\\<forall>i<length cms\\<^sub>1'.\n              x \\<notin> snd (cms\\<^sub>1' ! i)\n                          AsmNoReadOrWrite)) \\<longrightarrow>\n         mem\\<^sub>1' x = mem\\<^sub>2' x)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}