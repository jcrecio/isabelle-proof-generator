{"file_name": "/home/qj213/afp-2021-10-22/thys/Dependent_SIFUM_Type_Systems/Security.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Dependent_SIFUM_Type_Systems", "problem_names": ["lemma neval_det:\n  \"x \\<leadsto>\\<^bsup>n\\<^esup> y \\<Longrightarrow> x \\<leadsto>\\<^bsup>n\\<^esup> y' \\<Longrightarrow> y = y'\"", "lemma neval_Suc_simp [simp]:\n  \"neval x (Suc 0) y = x \\<leadsto> y\"", "lemma meval_sched_det:\n  \"meval_sched ns c c' \\<Longrightarrow> meval_sched ns c c'' \\<Longrightarrow> c' = c''\"", "lemma low_eq_low_mds_eq:\n  \"(mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2) = (mem\\<^sub>1 =\\<^bsub>(\\<lambda>m. {})\\<^esub>\\<^sup>l mem\\<^sub>2)\"", "lemma low_mds_eq_dma:\n  \"(mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2) \\<Longrightarrow> dma mem\\<^sub>1 = dma mem\\<^sub>2\"", "lemma low_mds_eq_sym:\n  \"(mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2) \\<Longrightarrow> (mem\\<^sub>2 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>1)\"", "lemma low_eq_sym:\n  \"(mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2) \\<Longrightarrow> (mem\\<^sub>2 =\\<^sup>l mem\\<^sub>1)\"", "lemma [simp]: \"mem =\\<^sup>l mem' \\<Longrightarrow> mem =\\<^bsub>mds\\<^esub>\\<^sup>l mem'\"", "lemma [simp]: \"(\\<forall> mds. mem =\\<^bsub>mds\\<^esub>\\<^sup>l mem') \\<Longrightarrow> mem =\\<^sup>l mem'\"", "lemma High_not_in_\\<C> [simp]:\n  \"dma mem\\<^sub>1 x = High \\<Longrightarrow> x \\<notin> \\<C>\"", "lemma prog_sifum_secure_cont_def2:\n  \"prog_sifum_secure_cont cmds \\<equiv>\n   (\\<forall> mem\\<^sub>1 mem\\<^sub>2. INIT mem\\<^sub>1 \\<and> INIT mem\\<^sub>2 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<longrightarrow>\n    (\\<forall> sched cms\\<^sub>1' mem\\<^sub>1'.\n     (cmds, mem\\<^sub>1) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>1', mem\\<^sub>1') \\<longrightarrow>\n      (\\<exists> cms\\<^sub>2' mem\\<^sub>2'. (cmds, mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2', mem\\<^sub>2')) \\<and>\n      (\\<forall> cms\\<^sub>2' mem\\<^sub>2'. (cmds, mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2', mem\\<^sub>2') \\<longrightarrow>\n                      map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n                      length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n                      (\\<forall> x. dma mem\\<^sub>1' x = Low \\<and> (x \\<in> \\<C> \\<or> (\\<forall> i < length cms\\<^sub>1'.\n                        x \\<notin> snd (cms\\<^sub>1' ! i) AsmNoReadOrWrite)) \\<longrightarrow> mem\\<^sub>1' x = mem\\<^sub>2' x))))\"", "lemma subst_not_in_dom : \"\\<lbrakk> x \\<notin> dom \\<sigma> \\<rbrakk> \\<Longrightarrow> mem [\\<mapsto> \\<sigma>] x = mem x\"", "lemma vars_\\<C>_subset_\\<C>:\n  \"vars_\\<C> X \\<subseteq> \\<C>\"", "lemma noread_nowrite:\n  assumes step: \"\\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\"\n  assumes noread: \"(\\<And>v. \\<langle>c, mds, mem(x := v)\\<rangle> \\<leadsto> \\<langle>c', mds', mem'(x := v)\\<rangle>)\"\n  shows \"mem x = mem' x\"", "lemma doesnt_read_or_modify_doesnt_modify:\n  \"doesnt_read_or_modify c x \\<Longrightarrow> doesnt_modify c x\"", "lemma neval_loc_reach:\n  \"neval lc' n lc'' \\<Longrightarrow> lc' \\<in> loc_reach lc \\<Longrightarrow> lc'' \\<in> loc_reach lc\"", "lemma locally_sound_mode_use_def2:\n  \"locally_sound_mode_use lc \\<equiv> \\<forall>lc' \\<in> loc_reach lc. respects_own_guarantees (fst lc')\"", "lemma locally_sound_respects_guarantees:\n  \"locally_sound_mode_use (cm, mem) \\<Longrightarrow> respects_own_guarantees cm\"", "lemma mm_equiv_sym:\n  assumes equivalent: \"\\<langle>c\\<^sub>1, mds\\<^sub>1, mem\\<^sub>1\\<rangle> \\<approx> \\<langle>c\\<^sub>2, mds\\<^sub>2, mem\\<^sub>2\\<rangle>\"\n  shows \"\\<langle>c\\<^sub>2, mds\\<^sub>2, mem\\<^sub>2\\<rangle> \\<approx> \\<langle>c\\<^sub>1, mds\\<^sub>1, mem\\<^sub>1\\<rangle>\"", "lemma low_indistinguishable_sym: \"lc \\<sim>\\<^bsub>mds\\<^esub> lc' \\<Longrightarrow> lc' \\<sim>\\<^bsub>mds\\<^esub> lc\"", "lemma mm_equiv_glob_consistent: \"closed_glob_consistent mm_equiv\"", "lemma mm_equiv_strong_low_bisim: \"strong_low_bisim_mm mm_equiv\""], "translations": [["", "lemma neval_det:\n  \"x \\<leadsto>\\<^bsup>n\\<^esup> y \\<Longrightarrow> x \\<leadsto>\\<^bsup>n\\<^esup> y' \\<Longrightarrow> y = y'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<leadsto>\\<^bsup>n\\<^esup> y;\n     x \\<leadsto>\\<^bsup>n\\<^esup> y'\\<rbrakk>\n    \\<Longrightarrow> y = y'", "apply(induct arbitrary: y' rule: neval.induct)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x y y'.\n       \\<lbrakk>x = y; x \\<leadsto>\\<^bsup>0\\<^esup> y'\\<rbrakk>\n       \\<Longrightarrow> y = y'\n 2. \\<And>x y n z y'.\n       \\<lbrakk>x \\<leadsto> y; y \\<leadsto>\\<^bsup>n\\<^esup> z;\n        \\<And>y'. y \\<leadsto>\\<^bsup>n\\<^esup> y' \\<Longrightarrow> z = y';\n        x \\<leadsto>\\<^bsup>Suc n\\<^esup> y'\\<rbrakk>\n       \\<Longrightarrow> z = y'", "apply(blast elim: neval_ZeroE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y n z y'.\n       \\<lbrakk>x \\<leadsto> y; y \\<leadsto>\\<^bsup>n\\<^esup> z;\n        \\<And>y'. y \\<leadsto>\\<^bsup>n\\<^esup> y' \\<Longrightarrow> z = y';\n        x \\<leadsto>\\<^bsup>Suc n\\<^esup> y'\\<rbrakk>\n       \\<Longrightarrow> z = y'", "apply(blast elim: neval_SucE dest: deterministic)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma neval_Suc_simp [simp]:\n  \"neval x (Suc 0) y = x \\<leadsto> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<leadsto>\\<^bsup>Suc 0\\<^esup> y = x \\<leadsto> y", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<leadsto>\\<^bsup>Suc 0\\<^esup> y \\<Longrightarrow> x \\<leadsto> y\n 2. x \\<leadsto> y \\<Longrightarrow> x \\<leadsto>\\<^bsup>Suc 0\\<^esup> y", "assume a: \"neval x (Suc 0) y\""], ["proof (state)\nthis:\n  x \\<leadsto>\\<^bsup>Suc 0\\<^esup> y\n\ngoal (2 subgoals):\n 1. x \\<leadsto>\\<^bsup>Suc 0\\<^esup> y \\<Longrightarrow> x \\<leadsto> y\n 2. x \\<leadsto> y \\<Longrightarrow> x \\<leadsto>\\<^bsup>Suc 0\\<^esup> y", "have \"\\<And>n. neval x n y \\<Longrightarrow> n = Suc 0 \\<Longrightarrow> x \\<leadsto> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>x \\<leadsto>\\<^bsup>n\\<^esup> y; n = Suc 0\\<rbrakk>\n       \\<Longrightarrow> x \\<leadsto> y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>x \\<leadsto>\\<^bsup>n\\<^esup> y; n = Suc 0\\<rbrakk>\n       \\<Longrightarrow> x \\<leadsto> y", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>x \\<leadsto>\\<^bsup>n\\<^esup> y; n = Suc 0\\<rbrakk>\n       \\<Longrightarrow> x \\<leadsto> y", "assume \"neval x n y\"\n       and \"n = Suc 0\""], ["proof (state)\nthis:\n  x \\<leadsto>\\<^bsup>n\\<^esup> y\n  n = Suc 0\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>x \\<leadsto>\\<^bsup>n\\<^esup> y; n = Suc 0\\<rbrakk>\n       \\<Longrightarrow> x \\<leadsto> y", "thus \"x \\<leadsto> y\""], ["proof (prove)\nusing this:\n  x \\<leadsto>\\<^bsup>n\\<^esup> y\n  n = Suc 0\n\ngoal (1 subgoal):\n 1. x \\<leadsto> y", "by(induct rule: neval.induct, auto elim: neval_ZeroE)"], ["proof (state)\nthis:\n  x \\<leadsto> y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>x \\<leadsto>\\<^bsup>?n\\<^esup> y; ?n = Suc 0\\<rbrakk>\n  \\<Longrightarrow> x \\<leadsto> y\n\ngoal (2 subgoals):\n 1. x \\<leadsto>\\<^bsup>Suc 0\\<^esup> y \\<Longrightarrow> x \\<leadsto> y\n 2. x \\<leadsto> y \\<Longrightarrow> x \\<leadsto>\\<^bsup>Suc 0\\<^esup> y", "with a"], ["proof (chain)\npicking this:\n  x \\<leadsto>\\<^bsup>Suc 0\\<^esup> y\n  \\<lbrakk>x \\<leadsto>\\<^bsup>?n\\<^esup> y; ?n = Suc 0\\<rbrakk>\n  \\<Longrightarrow> x \\<leadsto> y", "show \"x \\<leadsto> y\""], ["proof (prove)\nusing this:\n  x \\<leadsto>\\<^bsup>Suc 0\\<^esup> y\n  \\<lbrakk>x \\<leadsto>\\<^bsup>?n\\<^esup> y; ?n = Suc 0\\<rbrakk>\n  \\<Longrightarrow> x \\<leadsto> y\n\ngoal (1 subgoal):\n 1. x \\<leadsto> y", "by simp"], ["proof (state)\nthis:\n  x \\<leadsto> y\n\ngoal (1 subgoal):\n 1. x \\<leadsto> y \\<Longrightarrow> x \\<leadsto>\\<^bsup>Suc 0\\<^esup> y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<leadsto> y \\<Longrightarrow> x \\<leadsto>\\<^bsup>Suc 0\\<^esup> y", "assume \"x \\<leadsto> y\""], ["proof (state)\nthis:\n  x \\<leadsto> y\n\ngoal (1 subgoal):\n 1. x \\<leadsto> y \\<Longrightarrow> x \\<leadsto>\\<^bsup>Suc 0\\<^esup> y", "thus \"neval x (Suc 0) y\""], ["proof (prove)\nusing this:\n  x \\<leadsto> y\n\ngoal (1 subgoal):\n 1. x \\<leadsto>\\<^bsup>Suc 0\\<^esup> y", "by(force intro: neval.intros)"], ["proof (state)\nthis:\n  x \\<leadsto>\\<^bsup>Suc 0\\<^esup> y\n\ngoal:\nNo subgoals!", "qed"], ["", "fun \n  lc_set_var :: \"(_, _, _) LocalConf \\<Rightarrow> 'Var \\<Rightarrow> 'Val \\<Rightarrow> (_, _, _) LocalConf\"\nwhere\n  \"lc_set_var (c, mem) x v = (c, mem (x := v))\""], ["", "fun \n  meval_sched :: \"nat list \\<Rightarrow> ('Com, 'Var, 'Val) GlobalConf \\<Rightarrow> (_, _, _) GlobalConf \\<Rightarrow> bool\"\nwhere\n  \"meval_sched [] c c' = (c = c')\" |\n  \"meval_sched (n#ns) c c' = (\\<exists> c''.  c \\<leadsto>\\<^bsub>n\\<^esub> c'' \\<and> meval_sched ns c'' c')\""], ["", "abbreviation\n  meval_sched_abv :: \"(_,_,_) GlobalConf \\<Rightarrow> nat list \\<Rightarrow> (_,_,_) GlobalConf \\<Rightarrow> bool\" (\"_ \\<rightarrow>\\<^bsub>_\\<^esub> _\" 70)\nwhere\n  \"c \\<rightarrow>\\<^bsub>ns\\<^esub> c' \\<equiv> meval_sched ns c c'\""], ["", "lemma meval_sched_det:\n  \"meval_sched ns c c' \\<Longrightarrow> meval_sched ns c c'' \\<Longrightarrow> c' = c''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c \\<rightarrow>\\<^bsub>ns\\<^esub> c';\n     c \\<rightarrow>\\<^bsub>ns\\<^esub> c''\\<rbrakk>\n    \\<Longrightarrow> c' = c''", "apply(induct ns arbitrary: c)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>c.\n       \\<lbrakk>c \\<rightarrow>\\<^bsub>[]\\<^esub> c';\n        c \\<rightarrow>\\<^bsub>[]\\<^esub> c''\\<rbrakk>\n       \\<Longrightarrow> c' = c''\n 2. \\<And>a ns c.\n       \\<lbrakk>\\<And>c.\n                   \\<lbrakk>c \\<rightarrow>\\<^bsub>ns\\<^esub> c';\n                    c \\<rightarrow>\\<^bsub>ns\\<^esub> c''\\<rbrakk>\n                   \\<Longrightarrow> c' = c'';\n        c \\<rightarrow>\\<^bsub>a # ns\\<^esub> c';\n        c \\<rightarrow>\\<^bsub>a # ns\\<^esub> c''\\<rbrakk>\n       \\<Longrightarrow> c' = c''", "apply(auto dest: deterministic)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection \\<open>Low-equivalence and Strong Low Bisimulations\\<close>"], ["", "(* Low-equality between memory states: *)"], ["", "definition \n  low_eq :: \"('Var, 'Val) Mem \\<Rightarrow> (_, _) Mem \\<Rightarrow> bool\" (infixl \"=\\<^sup>l\" 80)\nwhere\n  \"mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<equiv> (\\<forall> x. dma mem\\<^sub>1 x = Low \\<longrightarrow> mem\\<^sub>1 x = mem\\<^sub>2 x)\""], ["", "(* Low-equality modulo a given mode state: *)"], ["", "definition \n  low_mds_eq :: \"'Var Mds \\<Rightarrow> ('Var, 'Val) Mem \\<Rightarrow> (_, _) Mem \\<Rightarrow> bool\"\n  (\"_ =\\<index>\\<^sup>l _\" [100, 100] 80)\nwhere\n  \"(mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2) \\<equiv> (\\<forall> x. dma mem\\<^sub>1 x = Low \\<and> (x \\<in> \\<C> \\<or> x \\<notin> mds AsmNoReadOrWrite) \\<longrightarrow> mem\\<^sub>1 x = mem\\<^sub>2 x)\""], ["", "lemma low_eq_low_mds_eq:\n  \"(mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2) = (mem\\<^sub>1 =\\<^bsub>(\\<lambda>m. {})\\<^esub>\\<^sup>l mem\\<^sub>2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 =\n    mem\\<^sub>1 =\\<^bsub>\\<lambda>m. {}\\<^esub>\\<^sup>l mem\\<^sub>2", "by(simp add: low_eq_def low_mds_eq_def)"], ["", "lemma low_mds_eq_dma:\n  \"(mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2) \\<Longrightarrow> dma mem\\<^sub>1 = dma mem\\<^sub>2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2 \\<Longrightarrow>\n    dma mem\\<^sub>1 = dma mem\\<^sub>2", "apply(rule dma_\\<C>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2 \\<Longrightarrow>\n    \\<forall>x\\<in>\\<C>. mem\\<^sub>1 x = mem\\<^sub>2 x", "apply(simp add: low_mds_eq_def \\<C>_Low)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma low_mds_eq_sym:\n  \"(mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2) \\<Longrightarrow> (mem\\<^sub>2 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2 \\<Longrightarrow>\n    mem\\<^sub>2 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>1", "apply(frule low_mds_eq_dma)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2;\n     dma mem\\<^sub>1 = dma mem\\<^sub>2\\<rbrakk>\n    \\<Longrightarrow> mem\\<^sub>2 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>1", "apply(simp add: low_mds_eq_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma low_eq_sym:\n  \"(mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2) \\<Longrightarrow> (mem\\<^sub>2 =\\<^sup>l mem\\<^sub>1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<Longrightarrow>\n    mem\\<^sub>2 =\\<^sup>l mem\\<^sub>1", "apply(simp add: low_eq_low_mds_eq low_mds_eq_sym)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [simp]: \"mem =\\<^sup>l mem' \\<Longrightarrow> mem =\\<^bsub>mds\\<^esub>\\<^sup>l mem'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mem =\\<^sup>l mem' \\<Longrightarrow>\n    mem =\\<^bsub>mds\\<^esub>\\<^sup>l mem'", "by (simp add: low_mds_eq_def low_eq_def)"], ["", "lemma [simp]: \"(\\<forall> mds. mem =\\<^bsub>mds\\<^esub>\\<^sup>l mem') \\<Longrightarrow> mem =\\<^sup>l mem'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>mds. mem =\\<^bsub>mds\\<^esub>\\<^sup>l mem' \\<Longrightarrow>\n    mem =\\<^sup>l mem'", "by (auto simp: low_mds_eq_def low_eq_def)"], ["", "lemma High_not_in_\\<C> [simp]:\n  \"dma mem\\<^sub>1 x = High \\<Longrightarrow> x \\<notin> \\<C>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. dma mem\\<^sub>1 x = High \\<Longrightarrow> x \\<notin> \\<C>", "apply(case_tac \"x \\<in> \\<C>\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>dma mem\\<^sub>1 x = High; x \\<in> \\<C>\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> \\<C>\n 2. \\<lbrakk>dma mem\\<^sub>1 x = High; x \\<notin> \\<C>\\<rbrakk>\n    \\<Longrightarrow> x \\<notin> \\<C>", "by(simp add: \\<C>_Low)"], ["", "(* Closedness under globally consistent changes: *)"], ["", "definition \n  closed_glob_consistent :: \"(('Com, 'Var, 'Val) LocalConf) rel \\<Rightarrow> bool\"\nwhere\n  \"closed_glob_consistent \\<R> =\n  (\\<forall> c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2. (\\<langle> c\\<^sub>1, mds, mem\\<^sub>1 \\<rangle>, \\<langle> c\\<^sub>2, mds, mem\\<^sub>2 \\<rangle>) \\<in> \\<R> \\<longrightarrow>\n   (\\<forall> A. ((\\<forall>x. case A x of Some (v,v') \\<Rightarrow> (mem\\<^sub>1 x \\<noteq> v \\<or> mem\\<^sub>2 x \\<noteq> v') \\<longrightarrow> \\<not> var_asm_not_written mds x | _ \\<Rightarrow> True) \\<and>\n          (\\<forall>x. dma (mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]) x \\<noteq> dma mem\\<^sub>1 x \\<longrightarrow> \\<not> var_asm_not_written mds x) \\<and>\n          (\\<forall>x. dma (mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]) x = Low \\<and> (x \\<notin> mds AsmNoReadOrWrite \\<or> x \\<in> \\<C>) \\<longrightarrow> (mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]) x = (mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]) x)) \\<longrightarrow>\n         (\\<langle> c\\<^sub>1, mds, mem\\<^sub>1[\\<parallel>\\<^sub>1 A] \\<rangle>, \\<langle> c\\<^sub>2, mds, mem\\<^sub>2[\\<parallel>\\<^sub>2 A] \\<rangle>) \\<in> \\<R>))\""], ["", "(* Strong low bisimulations modulo modes: *)"], ["", "definition \n  strong_low_bisim_mm :: \"(('Com, 'Var, 'Val) LocalConf) rel \\<Rightarrow> bool\"\nwhere\n  \"strong_low_bisim_mm \\<R> \\<equiv>\n  sym \\<R> \\<and>\n  closed_glob_consistent \\<R> \\<and>\n  (\\<forall> c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2. (\\<langle> c\\<^sub>1, mds, mem\\<^sub>1 \\<rangle>, \\<langle> c\\<^sub>2, mds, mem\\<^sub>2 \\<rangle>) \\<in> \\<R> \\<longrightarrow>\n   (mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2) \\<and>\n   (\\<forall> c\\<^sub>1' mds' mem\\<^sub>1'. \\<langle> c\\<^sub>1, mds, mem\\<^sub>1 \\<rangle> \\<leadsto> \\<langle> c\\<^sub>1', mds', mem\\<^sub>1' \\<rangle> \\<longrightarrow>\n    (\\<exists> c\\<^sub>2' mem\\<^sub>2'. \\<langle> c\\<^sub>2, mds, mem\\<^sub>2 \\<rangle> \\<leadsto> \\<langle> c\\<^sub>2', mds', mem\\<^sub>2' \\<rangle> \\<and>\n                  (\\<langle> c\\<^sub>1', mds', mem\\<^sub>1' \\<rangle>, \\<langle> c\\<^sub>2', mds', mem\\<^sub>2' \\<rangle>) \\<in> \\<R>)))\""], ["", "inductive_set mm_equiv :: \"(('Com, 'Var, 'Val) LocalConf) rel\"\n  and mm_equiv_abv :: \"('Com, 'Var, 'Val) LocalConf \\<Rightarrow> \n  ('Com, 'Var, 'Val) LocalConf \\<Rightarrow> bool\" (infix \"\\<approx>\" 60)\nwhere\n  \"mm_equiv_abv x y \\<equiv> (x, y) \\<in> mm_equiv\" |\n  mm_equiv_intro [iff]: \"\\<lbrakk> strong_low_bisim_mm \\<R> ; (lc\\<^sub>1, lc\\<^sub>2) \\<in> \\<R> \\<rbrakk> \\<Longrightarrow> (lc\\<^sub>1, lc\\<^sub>2) \\<in> mm_equiv\""], ["", "inductive_cases mm_equiv_elim [elim]: \"\\<langle> c\\<^sub>1, mds, mem\\<^sub>1 \\<rangle> \\<approx> \\<langle> c\\<^sub>2, mds, mem\\<^sub>2 \\<rangle>\""], ["", "definition low_indistinguishable :: \"'Var Mds \\<Rightarrow> 'Com \\<Rightarrow> 'Com \\<Rightarrow> bool\"\n  (\"_ \\<sim>\\<index> _\" [100, 100] 80)\nwhere \n  \"c\\<^sub>1 \\<sim>\\<^bsub>mds\\<^esub> c\\<^sub>2 = (\\<forall> mem\\<^sub>1 mem\\<^sub>2. mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2 \\<longrightarrow> \\<langle> c\\<^sub>1, mds, mem\\<^sub>1 \\<rangle> \\<approx> \\<langle> c\\<^sub>2, mds, mem\\<^sub>2 \\<rangle>)\""], ["", "subsection \\<open>SIFUM-Security\\<close>"], ["", "(* SIFUM-security for commands: *)"], ["", "definition \n  com_sifum_secure :: \"'Com \\<times> 'Var Mds \\<Rightarrow> bool\"\nwhere \n  \"com_sifum_secure cmd \\<equiv> case cmd of (c,mds\\<^sub>s) \\<Rightarrow> c \\<sim>\\<^bsub>mds\\<^sub>s\\<^esub> c\""], ["", "(* Continuous SIFUM-security \n   (where we don't care about whether the prog has any assumptions at termination *)"], ["", "definition \n  prog_sifum_secure_cont :: \"('Com \\<times> 'Var Mds) list \\<Rightarrow> bool\"\nwhere \"prog_sifum_secure_cont cmds =\n   (\\<forall> mem\\<^sub>1 mem\\<^sub>2. INIT mem\\<^sub>1 \\<and> INIT mem\\<^sub>2 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<longrightarrow>\n    (\\<forall> sched cms\\<^sub>1' mem\\<^sub>1'.\n     (cmds, mem\\<^sub>1) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>1', mem\\<^sub>1') \\<longrightarrow>\n      (\\<exists> cms\\<^sub>2' mem\\<^sub>2'. (cmds, mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2', mem\\<^sub>2') \\<and>\n                      map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n                      length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n                      (\\<forall> x. dma mem\\<^sub>1' x = Low \\<and> (x \\<in> \\<C> \\<or> (\\<forall> i < length cms\\<^sub>1'.\n                        x \\<notin> snd (cms\\<^sub>1' ! i) AsmNoReadOrWrite)) \\<longrightarrow> mem\\<^sub>1' x = mem\\<^sub>2' x))))\""], ["", "(* Note that it is equivalent to the following because the \n   programming language is deterministic *)"], ["", "lemma prog_sifum_secure_cont_def2:\n  \"prog_sifum_secure_cont cmds \\<equiv>\n   (\\<forall> mem\\<^sub>1 mem\\<^sub>2. INIT mem\\<^sub>1 \\<and> INIT mem\\<^sub>2 \\<and> mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<longrightarrow>\n    (\\<forall> sched cms\\<^sub>1' mem\\<^sub>1'.\n     (cmds, mem\\<^sub>1) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>1', mem\\<^sub>1') \\<longrightarrow>\n      (\\<exists> cms\\<^sub>2' mem\\<^sub>2'. (cmds, mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2', mem\\<^sub>2')) \\<and>\n      (\\<forall> cms\\<^sub>2' mem\\<^sub>2'. (cmds, mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2', mem\\<^sub>2') \\<longrightarrow>\n                      map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n                      length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n                      (\\<forall> x. dma mem\\<^sub>1' x = Low \\<and> (x \\<in> \\<C> \\<or> (\\<forall> i < length cms\\<^sub>1'.\n                        x \\<notin> snd (cms\\<^sub>1' ! i) AsmNoReadOrWrite)) \\<longrightarrow> mem\\<^sub>1' x = mem\\<^sub>2' x))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prog_sifum_secure_cont cmds \\<equiv>\n    \\<forall>mem\\<^sub>1 mem\\<^sub>2.\n       INIT mem\\<^sub>1 \\<and>\n       INIT mem\\<^sub>2 \\<and>\n       mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<longrightarrow>\n       (\\<forall>sched cms\\<^sub>1' mem\\<^sub>1'.\n           (cmds,\n            mem\\<^sub>1) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>1',\n                       mem\\<^sub>1') \\<longrightarrow>\n           (\\<exists>cms\\<^sub>2' mem\\<^sub>2'.\n               (cmds,\n                mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2',\n                           mem\\<^sub>2')) \\<and>\n           (\\<forall>cms\\<^sub>2' mem\\<^sub>2'.\n               (cmds,\n                mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2',\n                           mem\\<^sub>2') \\<longrightarrow>\n               map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n               length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n               (\\<forall>x.\n                   dma mem\\<^sub>1' x = Low \\<and>\n                   (x \\<in> \\<C> \\<or>\n                    (\\<forall>i<length cms\\<^sub>1'.\n                        x \\<notin> snd (cms\\<^sub>1' ! i)\n                                    AsmNoReadOrWrite)) \\<longrightarrow>\n                   mem\\<^sub>1' x = mem\\<^sub>2' x)))", "apply(rule eq_reflection)"], ["proof (prove)\ngoal (1 subgoal):\n 1. prog_sifum_secure_cont cmds =\n    (\\<forall>mem\\<^sub>1 mem\\<^sub>2.\n        INIT mem\\<^sub>1 \\<and>\n        INIT mem\\<^sub>2 \\<and>\n        mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<longrightarrow>\n        (\\<forall>sched cms\\<^sub>1' mem\\<^sub>1'.\n            (cmds,\n             mem\\<^sub>1) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>1',\n                        mem\\<^sub>1') \\<longrightarrow>\n            (\\<exists>cms\\<^sub>2' mem\\<^sub>2'.\n                (cmds,\n                 mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2',\n                            mem\\<^sub>2')) \\<and>\n            (\\<forall>cms\\<^sub>2' mem\\<^sub>2'.\n                (cmds,\n                 mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2',\n                            mem\\<^sub>2') \\<longrightarrow>\n                map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n                length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n                (\\<forall>x.\n                    dma mem\\<^sub>1' x = Low \\<and>\n                    (x \\<in> \\<C> \\<or>\n                     (\\<forall>i<length cms\\<^sub>1'.\n                         x \\<notin> snd (cms\\<^sub>1' ! i)\n                                     AsmNoReadOrWrite)) \\<longrightarrow>\n                    mem\\<^sub>1' x = mem\\<^sub>2' x))))", "unfolding prog_sifum_secure_cont_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>mem\\<^sub>1 mem\\<^sub>2.\n        INIT mem\\<^sub>1 \\<and>\n        INIT mem\\<^sub>2 \\<and>\n        mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<longrightarrow>\n        (\\<forall>sched cms\\<^sub>1' mem\\<^sub>1'.\n            (cmds,\n             mem\\<^sub>1) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>1',\n                        mem\\<^sub>1') \\<longrightarrow>\n            (\\<exists>cms\\<^sub>2' mem\\<^sub>2'.\n                (cmds,\n                 mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2',\n                            mem\\<^sub>2') \\<and>\n                map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n                length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n                (\\<forall>x.\n                    dma mem\\<^sub>1' x = Low \\<and>\n                    (x \\<in> \\<C> \\<or>\n                     (\\<forall>i<length cms\\<^sub>1'.\n                         x \\<notin> snd (cms\\<^sub>1' ! i)\n                                     AsmNoReadOrWrite)) \\<longrightarrow>\n                    mem\\<^sub>1' x = mem\\<^sub>2' x)))) =\n    (\\<forall>mem\\<^sub>1 mem\\<^sub>2.\n        INIT mem\\<^sub>1 \\<and>\n        INIT mem\\<^sub>2 \\<and>\n        mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<longrightarrow>\n        (\\<forall>sched cms\\<^sub>1' mem\\<^sub>1'.\n            (cmds,\n             mem\\<^sub>1) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>1',\n                        mem\\<^sub>1') \\<longrightarrow>\n            (\\<exists>cms\\<^sub>2' mem\\<^sub>2'.\n                (cmds,\n                 mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2',\n                            mem\\<^sub>2')) \\<and>\n            (\\<forall>cms\\<^sub>2' mem\\<^sub>2'.\n                (cmds,\n                 mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2',\n                            mem\\<^sub>2') \\<longrightarrow>\n                map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n                length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n                (\\<forall>x.\n                    dma mem\\<^sub>1' x = Low \\<and>\n                    (x \\<in> \\<C> \\<or>\n                     (\\<forall>i<length cms\\<^sub>1'.\n                         x \\<notin> snd (cms\\<^sub>1' ! i)\n                                     AsmNoReadOrWrite)) \\<longrightarrow>\n                    mem\\<^sub>1' x = mem\\<^sub>2' x))))", "apply(rule iffI)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<forall>mem\\<^sub>1 mem\\<^sub>2.\n       INIT mem\\<^sub>1 \\<and>\n       INIT mem\\<^sub>2 \\<and>\n       mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<longrightarrow>\n       (\\<forall>sched cms\\<^sub>1' mem\\<^sub>1'.\n           (cmds,\n            mem\\<^sub>1) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>1',\n                       mem\\<^sub>1') \\<longrightarrow>\n           (\\<exists>cms\\<^sub>2' mem\\<^sub>2'.\n               (cmds,\n                mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2',\n                           mem\\<^sub>2') \\<and>\n               map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n               length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n               (\\<forall>x.\n                   dma mem\\<^sub>1' x = Low \\<and>\n                   (x \\<in> \\<C> \\<or>\n                    (\\<forall>i<length cms\\<^sub>1'.\n                        x \\<notin> snd (cms\\<^sub>1' ! i)\n                                    AsmNoReadOrWrite)) \\<longrightarrow>\n                   mem\\<^sub>1' x = mem\\<^sub>2' x))) \\<Longrightarrow>\n    \\<forall>mem\\<^sub>1 mem\\<^sub>2.\n       INIT mem\\<^sub>1 \\<and>\n       INIT mem\\<^sub>2 \\<and>\n       mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<longrightarrow>\n       (\\<forall>sched cms\\<^sub>1' mem\\<^sub>1'.\n           (cmds,\n            mem\\<^sub>1) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>1',\n                       mem\\<^sub>1') \\<longrightarrow>\n           (\\<exists>cms\\<^sub>2' mem\\<^sub>2'.\n               (cmds,\n                mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2',\n                           mem\\<^sub>2')) \\<and>\n           (\\<forall>cms\\<^sub>2' mem\\<^sub>2'.\n               (cmds,\n                mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2',\n                           mem\\<^sub>2') \\<longrightarrow>\n               map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n               length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n               (\\<forall>x.\n                   dma mem\\<^sub>1' x = Low \\<and>\n                   (x \\<in> \\<C> \\<or>\n                    (\\<forall>i<length cms\\<^sub>1'.\n                        x \\<notin> snd (cms\\<^sub>1' ! i)\n                                    AsmNoReadOrWrite)) \\<longrightarrow>\n                   mem\\<^sub>1' x = mem\\<^sub>2' x)))\n 2. \\<forall>mem\\<^sub>1 mem\\<^sub>2.\n       INIT mem\\<^sub>1 \\<and>\n       INIT mem\\<^sub>2 \\<and>\n       mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<longrightarrow>\n       (\\<forall>sched cms\\<^sub>1' mem\\<^sub>1'.\n           (cmds,\n            mem\\<^sub>1) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>1',\n                       mem\\<^sub>1') \\<longrightarrow>\n           (\\<exists>cms\\<^sub>2' mem\\<^sub>2'.\n               (cmds,\n                mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2',\n                           mem\\<^sub>2')) \\<and>\n           (\\<forall>cms\\<^sub>2' mem\\<^sub>2'.\n               (cmds,\n                mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2',\n                           mem\\<^sub>2') \\<longrightarrow>\n               map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n               length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n               (\\<forall>x.\n                   dma mem\\<^sub>1' x = Low \\<and>\n                   (x \\<in> \\<C> \\<or>\n                    (\\<forall>i<length cms\\<^sub>1'.\n                        x \\<notin> snd (cms\\<^sub>1' ! i)\n                                    AsmNoReadOrWrite)) \\<longrightarrow>\n                   mem\\<^sub>1' x = mem\\<^sub>2' x))) \\<Longrightarrow>\n    \\<forall>mem\\<^sub>1 mem\\<^sub>2.\n       INIT mem\\<^sub>1 \\<and>\n       INIT mem\\<^sub>2 \\<and>\n       mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<longrightarrow>\n       (\\<forall>sched cms\\<^sub>1' mem\\<^sub>1'.\n           (cmds,\n            mem\\<^sub>1) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>1',\n                       mem\\<^sub>1') \\<longrightarrow>\n           (\\<exists>cms\\<^sub>2' mem\\<^sub>2'.\n               (cmds,\n                mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2',\n                           mem\\<^sub>2') \\<and>\n               map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n               length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n               (\\<forall>x.\n                   dma mem\\<^sub>1' x = Low \\<and>\n                   (x \\<in> \\<C> \\<or>\n                    (\\<forall>i<length cms\\<^sub>1'.\n                        x \\<notin> snd (cms\\<^sub>1' ! i)\n                                    AsmNoReadOrWrite)) \\<longrightarrow>\n                   mem\\<^sub>1' x = mem\\<^sub>2' x)))", "apply(blast dest: meval_sched_det)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>mem\\<^sub>1 mem\\<^sub>2.\n       INIT mem\\<^sub>1 \\<and>\n       INIT mem\\<^sub>2 \\<and>\n       mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<longrightarrow>\n       (\\<forall>sched cms\\<^sub>1' mem\\<^sub>1'.\n           (cmds,\n            mem\\<^sub>1) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>1',\n                       mem\\<^sub>1') \\<longrightarrow>\n           (\\<exists>cms\\<^sub>2' mem\\<^sub>2'.\n               (cmds,\n                mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2',\n                           mem\\<^sub>2')) \\<and>\n           (\\<forall>cms\\<^sub>2' mem\\<^sub>2'.\n               (cmds,\n                mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2',\n                           mem\\<^sub>2') \\<longrightarrow>\n               map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n               length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n               (\\<forall>x.\n                   dma mem\\<^sub>1' x = Low \\<and>\n                   (x \\<in> \\<C> \\<or>\n                    (\\<forall>i<length cms\\<^sub>1'.\n                        x \\<notin> snd (cms\\<^sub>1' ! i)\n                                    AsmNoReadOrWrite)) \\<longrightarrow>\n                   mem\\<^sub>1' x = mem\\<^sub>2' x))) \\<Longrightarrow>\n    \\<forall>mem\\<^sub>1 mem\\<^sub>2.\n       INIT mem\\<^sub>1 \\<and>\n       INIT mem\\<^sub>2 \\<and>\n       mem\\<^sub>1 =\\<^sup>l mem\\<^sub>2 \\<longrightarrow>\n       (\\<forall>sched cms\\<^sub>1' mem\\<^sub>1'.\n           (cmds,\n            mem\\<^sub>1) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>1',\n                       mem\\<^sub>1') \\<longrightarrow>\n           (\\<exists>cms\\<^sub>2' mem\\<^sub>2'.\n               (cmds,\n                mem\\<^sub>2) \\<rightarrow>\\<^bsub>sched\\<^esub> (cms\\<^sub>2',\n                           mem\\<^sub>2') \\<and>\n               map snd cms\\<^sub>1' = map snd cms\\<^sub>2' \\<and>\n               length cms\\<^sub>2' = length cms\\<^sub>1' \\<and>\n               (\\<forall>x.\n                   dma mem\\<^sub>1' x = Low \\<and>\n                   (x \\<in> \\<C> \\<or>\n                    (\\<forall>i<length cms\\<^sub>1'.\n                        x \\<notin> snd (cms\\<^sub>1' ! i)\n                                    AsmNoReadOrWrite)) \\<longrightarrow>\n                   mem\\<^sub>1' x = mem\\<^sub>2' x)))", "by fastforce"], ["", "subsection \\<open>Sound Mode Use\\<close>"], ["", "(* Suggestive notation for substitution / function application *)"], ["", "definition \n  subst :: \"('a \\<rightharpoonup> 'b) \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> ('a \\<Rightarrow> 'b)\"\nwhere\n  \"subst f mem = (\\<lambda> x. case f x of\n                         None \\<Rightarrow> mem x |\n                         Some v \\<Rightarrow> v)\""], ["", "abbreviation \n  subst_abv :: \"('a \\<Rightarrow> 'b) \\<Rightarrow> ('a \\<rightharpoonup> 'b) \\<Rightarrow> ('a \\<Rightarrow> 'b)\" (\"_ [\\<mapsto>_]\" [900, 0] 1000)\nwhere\n  \"f [\\<mapsto> \\<sigma>] \\<equiv> subst \\<sigma> f\""], ["", "lemma subst_not_in_dom : \"\\<lbrakk> x \\<notin> dom \\<sigma> \\<rbrakk> \\<Longrightarrow> mem [\\<mapsto> \\<sigma>] x = mem x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> dom \\<sigma> \\<Longrightarrow> subst \\<sigma> mem x = mem x", "by (simp add: domIff subst_def)"], ["", "(* Toby: we restrict not reading to also imply not modifying a variable.\n         This is done mostly to simplify part of the reasoning in the\n         Compositionality theory, but also because reconciling doesnt_read_or_modify\n         forcing also not reading the variable's classification in the case\n         in the case where it would allow non-reading modifications proved\n         to get too unwieldy *)"], ["", "definition \n  doesnt_read_or_modify_vars :: \"'Com \\<Rightarrow> 'Var set \\<Rightarrow> bool\"\nwhere\n  \"doesnt_read_or_modify_vars c X = (\\<forall> mds mem c' mds' mem'.\n  \\<langle> c, mds, mem \\<rangle> \\<leadsto> \\<langle> c', mds', mem' \\<rangle> \\<longrightarrow>\n  ((\\<forall>x\\<in>X. (\\<forall> v. \\<langle> c, mds, mem (x := v) \\<rangle> \\<leadsto> \\<langle> c', mds', mem' (x := v) \\<rangle>))))\""], ["", "definition\n  vars_\\<C> :: \"'Var set \\<Rightarrow> 'Var set\"\nwhere\n  \"vars_\\<C> X \\<equiv> \\<Union>x\\<in>X. \\<C>_vars x\""], ["", "lemma vars_\\<C>_subset_\\<C>:\n  \"vars_\\<C> X \\<subseteq> \\<C>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. vars_\\<C> X \\<subseteq> \\<C>", "by(auto simp: \\<C>_def vars_\\<C>_def)"], ["", "(* Toby: doesnt_read_or_modify now implies that the classification is not read too *)"], ["", "definition \n  doesnt_read_or_modify :: \"'Com \\<Rightarrow> 'Var \\<Rightarrow> bool\"\nwhere\n  \"doesnt_read_or_modify c x \\<equiv> doesnt_read_or_modify_vars c ({x} \\<union> \\<C>_vars x)\""], ["", "definition \n  doesnt_modify :: \"'Com \\<Rightarrow> 'Var \\<Rightarrow> bool\"\nwhere\n  \"doesnt_modify c x = (\\<forall> mds mem c' mds' mem'. (\\<langle> c, mds, mem \\<rangle> \\<leadsto> \\<langle> c', mds', mem' \\<rangle>) \\<longrightarrow>\n                        mem x = mem' x \\<and>  dma mem x = dma mem' x)\""], ["", "lemma noread_nowrite:\n  assumes step: \"\\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\"\n  assumes noread: \"(\\<And>v. \\<langle>c, mds, mem(x := v)\\<rangle> \\<leadsto> \\<langle>c', mds', mem'(x := v)\\<rangle>)\"\n  shows \"mem x = mem' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mem x = mem' x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mem x = mem' x", "from noread"], ["proof (chain)\npicking this:\n  \\<langle>c, mds, mem(x := ?v5)\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\n  (x := ?v5)\\<rangle>", "have \"\\<langle>c, mds, mem(x := (mem x))\\<rangle> \\<leadsto> \\<langle>c', mds', mem'(x := (mem x))\\<rangle>\""], ["proof (prove)\nusing this:\n  \\<langle>c, mds, mem(x := ?v5)\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\n  (x := ?v5)\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, mem(x := mem x)\\<rangle> \\<leadsto>\n    \\<langle>c', mds', mem'(x := mem x)\\<rangle>", "by blast"], ["proof (state)\nthis:\n  \\<langle>c, mds, mem(x := mem x)\\<rangle> \\<leadsto>\n  \\<langle>c', mds', mem'(x := mem x)\\<rangle>\n\ngoal (1 subgoal):\n 1. mem x = mem' x", "hence \"\\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'(x := (mem x))\\<rangle>\""], ["proof (prove)\nusing this:\n  \\<langle>c, mds, mem(x := mem x)\\<rangle> \\<leadsto>\n  \\<langle>c', mds', mem'(x := mem x)\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\n    (x := mem x)\\<rangle>", "by simp"], ["proof (state)\nthis:\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\n  (x := mem x)\\<rangle>\n\ngoal (1 subgoal):\n 1. mem x = mem' x", "from step this"], ["proof (chain)\npicking this:\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\n  (x := mem x)\\<rangle>", "have \"mem' = mem'(x := (mem x))\""], ["proof (prove)\nusing this:\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\\<rangle>\n  \\<langle>c, mds, mem\\<rangle> \\<leadsto> \\<langle>c', mds', mem'\n  (x := mem x)\\<rangle>\n\ngoal (1 subgoal):\n 1. mem' = mem'(x := mem x)", "by (blast dest: deterministic)"], ["proof (state)\nthis:\n  mem' = mem'(x := mem x)\n\ngoal (1 subgoal):\n 1. mem x = mem' x", "hence \"mem' x = (mem'(x := (mem x))) x\""], ["proof (prove)\nusing this:\n  mem' = mem'(x := mem x)\n\ngoal (1 subgoal):\n 1. mem' x = (mem'(x := mem x)) x", "by(rule arg_cong)"], ["proof (state)\nthis:\n  mem' x = (mem'(x := mem x)) x\n\ngoal (1 subgoal):\n 1. mem x = mem' x", "thus ?thesis"], ["proof (prove)\nusing this:\n  mem' x = (mem'(x := mem x)) x\n\ngoal (1 subgoal):\n 1. mem x = mem' x", "by simp"], ["proof (state)\nthis:\n  mem x = mem' x\n\ngoal:\nNo subgoals!", "qed"], ["", "(* Toby: not sure whether this implication should just be made explicit in the\n         definition of doesnt_read_or_modify or not *)"], ["", "lemma doesnt_read_or_modify_doesnt_modify:\n  \"doesnt_read_or_modify c x \\<Longrightarrow> doesnt_modify c x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. doesnt_read_or_modify c x \\<Longrightarrow> doesnt_modify c x", "by(fastforce simp: doesnt_modify_def doesnt_read_or_modify_def doesnt_read_or_modify_vars_def \n               intro: noread_nowrite dma_\\<C>_vars)"], ["", "(* Local reachability of local configurations: *)"], ["", "inductive_set \n  loc_reach :: \"('Com, 'Var, 'Val) LocalConf \\<Rightarrow> ('Com, 'Var, 'Val) LocalConf set\"\n  for lc :: \"(_, _, _) LocalConf\"\nwhere\n  refl : \"\\<langle>fst (fst lc), snd (fst lc), snd lc\\<rangle> \\<in> loc_reach lc\" |\n  step : \"\\<lbrakk> \\<langle>c', mds', mem'\\<rangle> \\<in> loc_reach lc;\n            \\<langle>c', mds', mem'\\<rangle> \\<leadsto> \\<langle>c'', mds'', mem''\\<rangle> \\<rbrakk> \\<Longrightarrow>\n          \\<langle>c'', mds'', mem''\\<rangle> \\<in> loc_reach lc\" |\n  mem_diff : \"\\<lbrakk> \\<langle> c', mds', mem' \\<rangle> \\<in> loc_reach lc;\n                (\\<forall> x. var_asm_not_written mds' x \\<longrightarrow> mem' x = mem'' x \\<and> dma mem' x = dma mem'' x) \\<rbrakk> \\<Longrightarrow>\n              \\<langle> c', mds', mem'' \\<rangle> \\<in> loc_reach lc\""], ["", "lemma neval_loc_reach:\n  \"neval lc' n lc'' \\<Longrightarrow> lc' \\<in> loc_reach lc \\<Longrightarrow> lc'' \\<in> loc_reach lc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>lc' \\<leadsto>\\<^bsup>n\\<^esup> lc'';\n     lc' \\<in> loc_reach lc\\<rbrakk>\n    \\<Longrightarrow> lc'' \\<in> loc_reach lc", "proof(induct rule: neval.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x = y; x \\<in> loc_reach lc\\<rbrakk>\n       \\<Longrightarrow> y \\<in> loc_reach lc\n 2. \\<And>x y n z.\n       \\<lbrakk>x \\<leadsto> y; y \\<leadsto>\\<^bsup>n\\<^esup> z;\n        y \\<in> loc_reach lc \\<Longrightarrow> z \\<in> loc_reach lc;\n        x \\<in> loc_reach lc\\<rbrakk>\n       \\<Longrightarrow> z \\<in> loc_reach lc", "case (neval_0 x y)"], ["proof (state)\nthis:\n  x = y\n  x \\<in> loc_reach lc\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x = y; x \\<in> loc_reach lc\\<rbrakk>\n       \\<Longrightarrow> y \\<in> loc_reach lc\n 2. \\<And>x y n z.\n       \\<lbrakk>x \\<leadsto> y; y \\<leadsto>\\<^bsup>n\\<^esup> z;\n        y \\<in> loc_reach lc \\<Longrightarrow> z \\<in> loc_reach lc;\n        x \\<in> loc_reach lc\\<rbrakk>\n       \\<Longrightarrow> z \\<in> loc_reach lc", "thus ?case"], ["proof (prove)\nusing this:\n  x = y\n  x \\<in> loc_reach lc\n\ngoal (1 subgoal):\n 1. y \\<in> loc_reach lc", "by simp"], ["proof (state)\nthis:\n  y \\<in> loc_reach lc\n\ngoal (1 subgoal):\n 1. \\<And>x y n z.\n       \\<lbrakk>x \\<leadsto> y; y \\<leadsto>\\<^bsup>n\\<^esup> z;\n        y \\<in> loc_reach lc \\<Longrightarrow> z \\<in> loc_reach lc;\n        x \\<in> loc_reach lc\\<rbrakk>\n       \\<Longrightarrow> z \\<in> loc_reach lc", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y n z.\n       \\<lbrakk>x \\<leadsto> y; y \\<leadsto>\\<^bsup>n\\<^esup> z;\n        y \\<in> loc_reach lc \\<Longrightarrow> z \\<in> loc_reach lc;\n        x \\<in> loc_reach lc\\<rbrakk>\n       \\<Longrightarrow> z \\<in> loc_reach lc", "case (neval_S_n x y n z)"], ["proof (state)\nthis:\n  x \\<leadsto> y\n  y \\<leadsto>\\<^bsup>n\\<^esup> z\n  y \\<in> loc_reach lc \\<Longrightarrow> z \\<in> loc_reach lc\n  x \\<in> loc_reach lc\n\ngoal (1 subgoal):\n 1. \\<And>x y n z.\n       \\<lbrakk>x \\<leadsto> y; y \\<leadsto>\\<^bsup>n\\<^esup> z;\n        y \\<in> loc_reach lc \\<Longrightarrow> z \\<in> loc_reach lc;\n        x \\<in> loc_reach lc\\<rbrakk>\n       \\<Longrightarrow> z \\<in> loc_reach lc", "from \\<open>x \\<in> loc_reach lc\\<close> and \\<open>x \\<leadsto> y\\<close>"], ["proof (chain)\npicking this:\n  x \\<in> loc_reach lc\n  x \\<leadsto> y", "have \"y \\<in> loc_reach lc\""], ["proof (prove)\nusing this:\n  x \\<in> loc_reach lc\n  x \\<leadsto> y\n\ngoal (1 subgoal):\n 1. y \\<in> loc_reach lc", "(* TODO: can we get rid of this case_tac nonsense? *)"], ["proof (prove)\nusing this:\n  x \\<in> loc_reach lc\n  x \\<leadsto> y\n\ngoal (1 subgoal):\n 1. y \\<in> loc_reach lc", "apply(case_tac x, rename_tac a b, case_tac a, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ba aa baa.\n       \\<lbrakk>\\<langle>aa, baa, ba\\<rangle> \\<in> loc_reach lc;\n        \\<langle>aa, baa, ba\\<rangle> \\<leadsto> y;\n        x = \\<langle>aa, baa, ba\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> y \\<in> loc_reach lc", "apply(case_tac y, rename_tac c d, case_tac c, clarsimp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>ba aa baa d ab bb.\n       \\<lbrakk>\\<langle>aa, baa, ba\\<rangle> \\<in> loc_reach lc;\n        \\<langle>aa, baa, ba\\<rangle> \\<leadsto>\n        \\<langle>ab, bb, d\\<rangle>;\n        x = \\<langle>aa, baa, ba\\<rangle>;\n        y = \\<langle>ab, bb, d\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<langle>ab, bb, d\\<rangle> \\<in> loc_reach lc", "by(blast intro: loc_reach.step)"], ["proof (state)\nthis:\n  y \\<in> loc_reach lc\n\ngoal (1 subgoal):\n 1. \\<And>x y n z.\n       \\<lbrakk>x \\<leadsto> y; y \\<leadsto>\\<^bsup>n\\<^esup> z;\n        y \\<in> loc_reach lc \\<Longrightarrow> z \\<in> loc_reach lc;\n        x \\<in> loc_reach lc\\<rbrakk>\n       \\<Longrightarrow> z \\<in> loc_reach lc", "thus ?case"], ["proof (prove)\nusing this:\n  y \\<in> loc_reach lc\n\ngoal (1 subgoal):\n 1. z \\<in> loc_reach lc", "using neval_S_n(3)"], ["proof (prove)\nusing this:\n  y \\<in> loc_reach lc\n  y \\<in> loc_reach lc \\<Longrightarrow> z \\<in> loc_reach lc\n\ngoal (1 subgoal):\n 1. z \\<in> loc_reach lc", "by blast"], ["proof (state)\nthis:\n  z \\<in> loc_reach lc\n\ngoal:\nNo subgoals!", "qed"], ["", "definition \n  locally_sound_mode_use :: \"(_, _, _) LocalConf \\<Rightarrow> bool\"\nwhere\n  \"locally_sound_mode_use lc =\n  (\\<forall> c' mds' mem'. \\<langle> c', mds', mem' \\<rangle> \\<in> loc_reach lc \\<longrightarrow>\n    (\\<forall> x. (x \\<in> mds' GuarNoReadOrWrite \\<longrightarrow> doesnt_read_or_modify c' x) \\<and>\n          (x \\<in> mds' GuarNoWrite \\<longrightarrow> doesnt_modify c' x)))\""], ["", "(* RobS: The same property, but for an individual evaluation. Note it doesn't rely on mem! *)"], ["", "definition \n  respects_own_guarantees :: \"('Com \\<times> 'Var Mds) \\<Rightarrow> bool\"\nwhere\n  \"respects_own_guarantees cm \\<equiv>\n  (\\<forall> x. (x \\<in> (snd cm) GuarNoReadOrWrite \\<longrightarrow> doesnt_read_or_modify (fst cm) x) \\<and>\n        (x \\<in> (snd cm) GuarNoWrite \\<longrightarrow> doesnt_modify (fst cm) x))\""], ["", "lemma locally_sound_mode_use_def2:\n  \"locally_sound_mode_use lc \\<equiv> \\<forall>lc' \\<in> loc_reach lc. respects_own_guarantees (fst lc')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. locally_sound_mode_use lc \\<equiv>\n    \\<forall>lc'\\<in>loc_reach lc. respects_own_guarantees (fst lc')", "apply(rule eq_reflection)"], ["proof (prove)\ngoal (1 subgoal):\n 1. locally_sound_mode_use lc =\n    (\\<forall>lc'\\<in>loc_reach lc. respects_own_guarantees (fst lc'))", "apply(simp add: locally_sound_mode_use_def respects_own_guarantees_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<forall>c' mds'.\n        (\\<exists>mem'.\n            \\<langle>c', mds', mem'\\<rangle>\n            \\<in> loc_reach lc) \\<longrightarrow>\n        (\\<forall>x.\n            (x \\<in> mds' GuarNoReadOrWrite \\<longrightarrow>\n             doesnt_read_or_modify c' x) \\<and>\n            (x \\<in> mds' GuarNoWrite \\<longrightarrow>\n             doesnt_modify c' x))) =\n    (\\<forall>lc'\\<in>loc_reach lc.\n        \\<forall>x.\n           (x \\<in> snd (fst lc') GuarNoReadOrWrite \\<longrightarrow>\n            doesnt_read_or_modify (fst (fst lc')) x) \\<and>\n           (x \\<in> snd (fst lc') GuarNoWrite \\<longrightarrow>\n            doesnt_modify (fst (fst lc')) x))", "apply force"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma locally_sound_respects_guarantees:\n  \"locally_sound_mode_use (cm, mem) \\<Longrightarrow> respects_own_guarantees cm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. locally_sound_mode_use (cm, mem) \\<Longrightarrow>\n    respects_own_guarantees cm", "unfolding locally_sound_mode_use_def respects_own_guarantees_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c' mds' mem'.\n       \\<langle>c', mds', mem'\\<rangle>\n       \\<in> loc_reach (cm, mem) \\<longrightarrow>\n       (\\<forall>x.\n           (x \\<in> mds' GuarNoReadOrWrite \\<longrightarrow>\n            doesnt_read_or_modify c' x) \\<and>\n           (x \\<in> mds' GuarNoWrite \\<longrightarrow>\n            doesnt_modify c' x)) \\<Longrightarrow>\n    \\<forall>x.\n       (x \\<in> snd cm GuarNoReadOrWrite \\<longrightarrow>\n        doesnt_read_or_modify (fst cm) x) \\<and>\n       (x \\<in> snd cm GuarNoWrite \\<longrightarrow>\n        doesnt_modify (fst cm) x)", "by (metis fst_conv loc_reach.refl)"], ["", "definition \n  compatible_modes :: \"('Var Mds) list \\<Rightarrow> bool\"\nwhere\n  \"compatible_modes mdss = (\\<forall> (i :: nat) x. i < length mdss \\<longrightarrow>\n    (x \\<in> (mdss ! i) AsmNoReadOrWrite \\<longrightarrow>\n     (\\<forall> j < length mdss. j \\<noteq> i \\<longrightarrow> x \\<in> (mdss ! j) GuarNoReadOrWrite)) \\<and>\n    (x \\<in> (mdss ! i) AsmNoWrite \\<longrightarrow>\n     (\\<forall> j < length mdss. j \\<noteq> i \\<longrightarrow> x \\<in> (mdss ! j) GuarNoWrite)))\""], ["", "definition \n  reachable_mode_states :: \"('Com, 'Var, 'Val) GlobalConf \\<Rightarrow> (('Var Mds) list) set\"\nwhere \n  \"reachable_mode_states gc \\<equiv>\n     {mdss. (\\<exists> cms' mem' sched. gc \\<rightarrow>\\<^bsub>sched\\<^esub> (cms', mem') \\<and> map snd cms' = mdss)}\""], ["", "definition \n  globally_sound_mode_use :: \"('Com, 'Var, 'Val) GlobalConf \\<Rightarrow> bool\"\nwhere \n  \"globally_sound_mode_use gc \\<equiv>\n     (\\<forall> mdss. mdss \\<in> reachable_mode_states gc \\<longrightarrow> compatible_modes mdss)\""], ["", "primrec \n  sound_mode_use :: \"(_, _, _) GlobalConf \\<Rightarrow> bool\"\nwhere\n  \"sound_mode_use (cms, mem) =\n     (list_all (\\<lambda> cm. locally_sound_mode_use (cm, mem)) cms \\<and>\n      globally_sound_mode_use (cms, mem))\""], ["", "(* We now show that mm_equiv itself forms a strong low bisimulation modulo modes: *)"], ["", "lemma mm_equiv_sym:\n  assumes equivalent: \"\\<langle>c\\<^sub>1, mds\\<^sub>1, mem\\<^sub>1\\<rangle> \\<approx> \\<langle>c\\<^sub>2, mds\\<^sub>2, mem\\<^sub>2\\<rangle>\"\n  shows \"\\<langle>c\\<^sub>2, mds\\<^sub>2, mem\\<^sub>2\\<rangle> \\<approx> \\<langle>c\\<^sub>1, mds\\<^sub>1, mem\\<^sub>1\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>c\\<^sub>2, mds\\<^sub>2, mem\\<^sub>2\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>1, mds\\<^sub>1, mem\\<^sub>1\\<rangle>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<langle>c\\<^sub>2, mds\\<^sub>2, mem\\<^sub>2\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>1, mds\\<^sub>1, mem\\<^sub>1\\<rangle>", "from equivalent"], ["proof (chain)\npicking this:\n  \\<langle>c\\<^sub>1, mds\\<^sub>1, mem\\<^sub>1\\<rangle> \\<approx>\n  \\<langle>c\\<^sub>2, mds\\<^sub>2, mem\\<^sub>2\\<rangle>", "obtain \\<R>\n    where \\<R>_bisim: \"strong_low_bisim_mm \\<R> \\<and> (\\<langle>c\\<^sub>1, mds\\<^sub>1, mem\\<^sub>1\\<rangle>, \\<langle>c\\<^sub>2, mds\\<^sub>2, mem\\<^sub>2\\<rangle>) \\<in> \\<R>\""], ["proof (prove)\nusing this:\n  \\<langle>c\\<^sub>1, mds\\<^sub>1, mem\\<^sub>1\\<rangle> \\<approx>\n  \\<langle>c\\<^sub>2, mds\\<^sub>2, mem\\<^sub>2\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<R>.\n        strong_low_bisim_mm \\<R> \\<and>\n        (\\<langle>c\\<^sub>1, mds\\<^sub>1, mem\\<^sub>1\\<rangle>,\n         \\<langle>c\\<^sub>2, mds\\<^sub>2, mem\\<^sub>2\\<rangle>)\n        \\<in> \\<R> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis mm_equiv.simps)"], ["proof (state)\nthis:\n  strong_low_bisim_mm \\<R> \\<and>\n  (\\<langle>c\\<^sub>1, mds\\<^sub>1, mem\\<^sub>1\\<rangle>,\n   \\<langle>c\\<^sub>2, mds\\<^sub>2, mem\\<^sub>2\\<rangle>)\n  \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<langle>c\\<^sub>2, mds\\<^sub>2, mem\\<^sub>2\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>1, mds\\<^sub>1, mem\\<^sub>1\\<rangle>", "hence \"sym \\<R>\""], ["proof (prove)\nusing this:\n  strong_low_bisim_mm \\<R> \\<and>\n  (\\<langle>c\\<^sub>1, mds\\<^sub>1, mem\\<^sub>1\\<rangle>,\n   \\<langle>c\\<^sub>2, mds\\<^sub>2, mem\\<^sub>2\\<rangle>)\n  \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. sym \\<R>", "by (auto simp: strong_low_bisim_mm_def)"], ["proof (state)\nthis:\n  sym \\<R>\n\ngoal (1 subgoal):\n 1. \\<langle>c\\<^sub>2, mds\\<^sub>2, mem\\<^sub>2\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>1, mds\\<^sub>1, mem\\<^sub>1\\<rangle>", "hence \"(\\<langle>c\\<^sub>2, mds\\<^sub>2, mem\\<^sub>2\\<rangle>, \\<langle>c\\<^sub>1, mds\\<^sub>1, mem\\<^sub>1\\<rangle>) \\<in> \\<R>\""], ["proof (prove)\nusing this:\n  sym \\<R>\n\ngoal (1 subgoal):\n 1. (\\<langle>c\\<^sub>2, mds\\<^sub>2, mem\\<^sub>2\\<rangle>,\n     \\<langle>c\\<^sub>1, mds\\<^sub>1, mem\\<^sub>1\\<rangle>)\n    \\<in> \\<R>", "by (metis \\<R>_bisim symE)"], ["proof (state)\nthis:\n  (\\<langle>c\\<^sub>2, mds\\<^sub>2, mem\\<^sub>2\\<rangle>,\n   \\<langle>c\\<^sub>1, mds\\<^sub>1, mem\\<^sub>1\\<rangle>)\n  \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<langle>c\\<^sub>2, mds\\<^sub>2, mem\\<^sub>2\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>1, mds\\<^sub>1, mem\\<^sub>1\\<rangle>", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<langle>c\\<^sub>2, mds\\<^sub>2, mem\\<^sub>2\\<rangle>,\n   \\<langle>c\\<^sub>1, mds\\<^sub>1, mem\\<^sub>1\\<rangle>)\n  \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. \\<langle>c\\<^sub>2, mds\\<^sub>2, mem\\<^sub>2\\<rangle> \\<approx>\n    \\<langle>c\\<^sub>1, mds\\<^sub>1, mem\\<^sub>1\\<rangle>", "by (metis \\<R>_bisim mm_equiv.intros)"], ["proof (state)\nthis:\n  \\<langle>c\\<^sub>2, mds\\<^sub>2, mem\\<^sub>2\\<rangle> \\<approx>\n  \\<langle>c\\<^sub>1, mds\\<^sub>1, mem\\<^sub>1\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma low_indistinguishable_sym: \"lc \\<sim>\\<^bsub>mds\\<^esub> lc' \\<Longrightarrow> lc' \\<sim>\\<^bsub>mds\\<^esub> lc\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lc \\<sim>\\<^bsub>mds\\<^esub> lc' \\<Longrightarrow>\n    lc' \\<sim>\\<^bsub>mds\\<^esub> lc", "apply(clarsimp simp: low_indistinguishable_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>mem\\<^sub>1 mem\\<^sub>2.\n       \\<lbrakk>\\<forall>mem\\<^sub>1 mem\\<^sub>2.\n                   mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2 \\<longrightarrow>\n                   \\<langle>lc, mds, mem\\<^sub>1\\<rangle> \\<approx>\n                   \\<langle>lc', mds, mem\\<^sub>2\\<rangle>;\n        mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<langle>lc', mds, mem\\<^sub>1\\<rangle> \\<approx>\n                         \\<langle>lc, mds, mem\\<^sub>2\\<rangle>", "apply(rule mm_equiv_sym)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>mem\\<^sub>1 mem\\<^sub>2.\n       \\<lbrakk>\\<forall>mem\\<^sub>1 mem\\<^sub>2.\n                   mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2 \\<longrightarrow>\n                   \\<langle>lc, mds, mem\\<^sub>1\\<rangle> \\<approx>\n                   \\<langle>lc', mds, mem\\<^sub>2\\<rangle>;\n        mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2\\<rbrakk>\n       \\<Longrightarrow> \\<langle>lc, mds, mem\\<^sub>2\\<rangle> \\<approx>\n                         \\<langle>lc', mds, mem\\<^sub>1\\<rangle>", "apply(blast dest: low_mds_eq_sym)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma mm_equiv_glob_consistent: \"closed_glob_consistent mm_equiv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_glob_consistent mm_equiv", "unfolding closed_glob_consistent_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2.\n       \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n       \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<longrightarrow>\n       (\\<forall>A.\n           (\\<forall>x.\n               case A x of None \\<Rightarrow> True\n               | Some (v, v') \\<Rightarrow>\n                   mem\\<^sub>1 x \\<noteq> v \\<or>\n                   mem\\<^sub>2 x \\<noteq> v' \\<longrightarrow>\n                   \\<not> var_asm_not_written mds x) \\<and>\n           (\\<forall>x.\n               dma mem\\<^sub>1 [\\<parallel>\\<^sub>1 A] x \\<noteq>\n               dma mem\\<^sub>1 x \\<longrightarrow>\n               \\<not> var_asm_not_written mds x) \\<and>\n           (\\<forall>x.\n               dma mem\\<^sub>1 [\\<parallel>\\<^sub>1 A] x = Low \\<and>\n               (x \\<notin> mds AsmNoReadOrWrite \\<or>\n                x \\<in> \\<C>) \\<longrightarrow>\n               mem\\<^sub>1 [\\<parallel>\\<^sub>1 A] x =\n               mem\\<^sub>2 [\\<parallel>\\<^sub>2 A] x) \\<longrightarrow>\n           \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n           \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>)", "apply clarify"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2 A.\n       \\<lbrakk>\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n                \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>;\n        \\<forall>x.\n           case A x of None \\<Rightarrow> True\n           | Some (v, v') \\<Rightarrow>\n               mem\\<^sub>1 x \\<noteq> v \\<or>\n               mem\\<^sub>2 x \\<noteq> v' \\<longrightarrow>\n               \\<not> var_asm_not_written mds x;\n        \\<forall>x.\n           dma mem\\<^sub>1 [\\<parallel>\\<^sub>1 A] x \\<noteq>\n           dma mem\\<^sub>1 x \\<longrightarrow>\n           \\<not> var_asm_not_written mds x;\n        \\<forall>x.\n           dma mem\\<^sub>1 [\\<parallel>\\<^sub>1 A] x = Low \\<and>\n           (x \\<notin> mds AsmNoReadOrWrite \\<or>\n            x \\<in> \\<C>) \\<longrightarrow>\n           mem\\<^sub>1 [\\<parallel>\\<^sub>1 A] x =\n           mem\\<^sub>2 [\\<parallel>\\<^sub>2 A] x\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                         \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>", "apply (erule mm_equiv_elim)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2 A \\<R>.\n       \\<lbrakk>\\<forall>x.\n                   case A x of None \\<Rightarrow> True\n                   | Some (v, v') \\<Rightarrow>\n                       mem\\<^sub>1 x \\<noteq> v \\<or>\n                       mem\\<^sub>2 x \\<noteq> v' \\<longrightarrow>\n                       \\<not> var_asm_not_written mds x;\n        \\<forall>x.\n           dma mem\\<^sub>1 [\\<parallel>\\<^sub>1 A] x \\<noteq>\n           dma mem\\<^sub>1 x \\<longrightarrow>\n           \\<not> var_asm_not_written mds x;\n        \\<forall>x.\n           dma mem\\<^sub>1 [\\<parallel>\\<^sub>1 A] x = Low \\<and>\n           (x \\<notin> mds AsmNoReadOrWrite \\<or>\n            x \\<in> \\<C>) \\<longrightarrow>\n           mem\\<^sub>1 [\\<parallel>\\<^sub>1 A] x =\n           mem\\<^sub>2 [\\<parallel>\\<^sub>2 A] x;\n        strong_low_bisim_mm \\<R>;\n        (\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle>,\n         \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>)\n        \\<in> \\<R>\\<rbrakk>\n       \\<Longrightarrow> \\<langle>c\\<^sub>1, mds, mem\\<^sub>1 [\\<parallel>\\<^sub>1 A]\\<rangle> \\<approx>\n                         \\<langle>c\\<^sub>2, mds, mem\\<^sub>2 [\\<parallel>\\<^sub>2 A]\\<rangle>", "by (auto simp: strong_low_bisim_mm_def closed_glob_consistent_def)"], ["", "lemma mm_equiv_strong_low_bisim: \"strong_low_bisim_mm mm_equiv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strong_low_bisim_mm mm_equiv", "unfolding strong_low_bisim_mm_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sym mm_equiv \\<and>\n    closed_glob_consistent mm_equiv \\<and>\n    (\\<forall>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2.\n        \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n        \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<longrightarrow>\n        mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2 \\<and>\n        (\\<forall>c\\<^sub>1' mds' mem\\<^sub>1'.\n            \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n            \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<longrightarrow>\n            (\\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n                \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n                \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n                \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>)))", "proof (auto)"], ["proof (state)\ngoal (4 subgoals):\n 1. sym mm_equiv\n 2. closed_glob_consistent mm_equiv\n 3. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2.\n       \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n       \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<Longrightarrow>\n       mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2\n 4. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2 c\\<^sub>1' mds'\n       mem\\<^sub>1'.\n       \\<lbrakk>\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n                \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>;\n        \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n        \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                            \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n                            \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>", "show \"closed_glob_consistent mm_equiv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. closed_glob_consistent mm_equiv", "by (rule mm_equiv_glob_consistent)"], ["proof (state)\nthis:\n  closed_glob_consistent mm_equiv\n\ngoal (3 subgoals):\n 1. sym mm_equiv\n 2. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2.\n       \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n       \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<Longrightarrow>\n       mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2\n 3. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2 c\\<^sub>1' mds'\n       mem\\<^sub>1'.\n       \\<lbrakk>\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n                \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>;\n        \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n        \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                            \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n                            \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. sym mm_equiv\n 2. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2.\n       \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n       \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<Longrightarrow>\n       mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2\n 3. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2 c\\<^sub>1' mds'\n       mem\\<^sub>1'.\n       \\<lbrakk>\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n                \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>;\n        \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n        \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                            \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n                            \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>", "fix c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2 x"], ["proof (state)\ngoal (3 subgoals):\n 1. sym mm_equiv\n 2. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2.\n       \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n       \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<Longrightarrow>\n       mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2\n 3. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2 c\\<^sub>1' mds'\n       mem\\<^sub>1'.\n       \\<lbrakk>\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n                \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>;\n        \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n        \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                            \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n                            \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>", "assume \"\\<langle> c\\<^sub>1, mds, mem\\<^sub>1 \\<rangle> \\<approx> \\<langle> c\\<^sub>2, mds, mem\\<^sub>2 \\<rangle>\""], ["proof (state)\nthis:\n  \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n  \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>\n\ngoal (3 subgoals):\n 1. sym mm_equiv\n 2. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2.\n       \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n       \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<Longrightarrow>\n       mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2\n 3. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2 c\\<^sub>1' mds'\n       mem\\<^sub>1'.\n       \\<lbrakk>\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n                \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>;\n        \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n        \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                            \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n                            \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>", "then"], ["proof (chain)\npicking this:\n  \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n  \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>", "obtain \\<R> where\n    \"strong_low_bisim_mm \\<R> \\<and> (\\<langle> c\\<^sub>1, mds, mem\\<^sub>1 \\<rangle>, \\<langle> c\\<^sub>2, mds, mem\\<^sub>2 \\<rangle>) \\<in> \\<R>\""], ["proof (prove)\nusing this:\n  \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n  \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<R>.\n        strong_low_bisim_mm \\<R> \\<and>\n        (\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle>,\n         \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>)\n        \\<in> \\<R> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  strong_low_bisim_mm \\<R> \\<and>\n  (\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle>,\n   \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>)\n  \\<in> \\<R>\n\ngoal (3 subgoals):\n 1. sym mm_equiv\n 2. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2.\n       \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n       \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<Longrightarrow>\n       mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2\n 3. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2 c\\<^sub>1' mds'\n       mem\\<^sub>1'.\n       \\<lbrakk>\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n                \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>;\n        \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n        \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                            \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n                            \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>", "thus \"mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2\""], ["proof (prove)\nusing this:\n  strong_low_bisim_mm \\<R> \\<and>\n  (\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle>,\n   \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>)\n  \\<in> \\<R>\n\ngoal (1 subgoal):\n 1. mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2", "by (auto simp: strong_low_bisim_mm_def)"], ["proof (state)\nthis:\n  mem\\<^sub>1 =\\<^bsub>mds\\<^esub>\\<^sup>l mem\\<^sub>2\n\ngoal (2 subgoals):\n 1. sym mm_equiv\n 2. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2 c\\<^sub>1' mds'\n       mem\\<^sub>1'.\n       \\<lbrakk>\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n                \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>;\n        \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n        \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                            \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n                            \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. sym mm_equiv\n 2. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2 c\\<^sub>1' mds'\n       mem\\<^sub>1'.\n       \\<lbrakk>\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n                \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>;\n        \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n        \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                            \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n                            \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>", "fix c\\<^sub>1 :: 'Com"], ["proof (state)\ngoal (2 subgoals):\n 1. sym mm_equiv\n 2. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2 c\\<^sub>1' mds'\n       mem\\<^sub>1'.\n       \\<lbrakk>\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n                \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>;\n        \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n        \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                            \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n                            \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>", "fix mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2 c\\<^sub>1' mds' mem\\<^sub>1'"], ["proof (state)\ngoal (2 subgoals):\n 1. sym mm_equiv\n 2. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2 c\\<^sub>1' mds'\n       mem\\<^sub>1'.\n       \\<lbrakk>\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n                \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>;\n        \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n        \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                            \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n                            \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>", "let ?lc\\<^sub>1 = \"\\<langle> c\\<^sub>1, mds, mem\\<^sub>1 \\<rangle>\" and\n      ?lc\\<^sub>1' = \"\\<langle> c\\<^sub>1', mds', mem\\<^sub>1' \\<rangle>\" and\n      ?lc\\<^sub>2 = \"\\<langle> c\\<^sub>2, mds, mem\\<^sub>2 \\<rangle>\""], ["proof (state)\ngoal (2 subgoals):\n 1. sym mm_equiv\n 2. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2 c\\<^sub>1' mds'\n       mem\\<^sub>1'.\n       \\<lbrakk>\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n                \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>;\n        \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n        \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                            \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n                            \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>", "assume \"?lc\\<^sub>1 \\<approx> ?lc\\<^sub>2\""], ["proof (state)\nthis:\n  \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n  \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>\n\ngoal (2 subgoals):\n 1. sym mm_equiv\n 2. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2 c\\<^sub>1' mds'\n       mem\\<^sub>1'.\n       \\<lbrakk>\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n                \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>;\n        \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n        \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                            \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n                            \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>", "then"], ["proof (chain)\npicking this:\n  \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n  \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>", "obtain \\<R> where \"strong_low_bisim_mm \\<R> \\<and> (?lc\\<^sub>1, ?lc\\<^sub>2) \\<in> \\<R>\""], ["proof (prove)\nusing this:\n  \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n  \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<R>.\n        strong_low_bisim_mm \\<R> \\<and>\n        (\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle>,\n         \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>)\n        \\<in> \\<R> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (rule mm_equiv_elim, blast)"], ["proof (state)\nthis:\n  strong_low_bisim_mm \\<R> \\<and>\n  (\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle>,\n   \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>)\n  \\<in> \\<R>\n\ngoal (2 subgoals):\n 1. sym mm_equiv\n 2. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2 c\\<^sub>1' mds'\n       mem\\<^sub>1'.\n       \\<lbrakk>\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n                \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>;\n        \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n        \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                            \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n                            \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>", "moreover"], ["proof (state)\nthis:\n  strong_low_bisim_mm \\<R> \\<and>\n  (\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle>,\n   \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>)\n  \\<in> \\<R>\n\ngoal (2 subgoals):\n 1. sym mm_equiv\n 2. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2 c\\<^sub>1' mds'\n       mem\\<^sub>1'.\n       \\<lbrakk>\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n                \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>;\n        \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n        \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                            \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n                            \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>", "assume \"?lc\\<^sub>1 \\<leadsto> ?lc\\<^sub>1'\""], ["proof (state)\nthis:\n  \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n  \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle>\n\ngoal (2 subgoals):\n 1. sym mm_equiv\n 2. \\<And>c\\<^sub>1 mds mem\\<^sub>1 c\\<^sub>2 mem\\<^sub>2 c\\<^sub>1' mds'\n       mem\\<^sub>1'.\n       \\<lbrakk>\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<approx>\n                \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>;\n        \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n        \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n                            \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n                            \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n                            \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>", "ultimately"], ["proof (chain)\npicking this:\n  strong_low_bisim_mm \\<R> \\<and>\n  (\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle>,\n   \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>)\n  \\<in> \\<R>\n  \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n  \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle>", "show \"\\<exists> c\\<^sub>2' mem\\<^sub>2'. ?lc\\<^sub>2 \\<leadsto> \\<langle> c\\<^sub>2', mds', mem\\<^sub>2' \\<rangle> \\<and> ?lc\\<^sub>1' \\<approx> \\<langle> c\\<^sub>2', mds', mem\\<^sub>2' \\<rangle>\""], ["proof (prove)\nusing this:\n  strong_low_bisim_mm \\<R> \\<and>\n  (\\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle>,\n   \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle>)\n  \\<in> \\<R>\n  \\<langle>c\\<^sub>1, mds, mem\\<^sub>1\\<rangle> \\<leadsto>\n  \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n       \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n       \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n       \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n       \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>", "by (simp add: strong_low_bisim_mm_def mm_equiv_sym, blast)"], ["proof (state)\nthis:\n  \\<exists>c\\<^sub>2' mem\\<^sub>2'.\n     \\<langle>c\\<^sub>2, mds, mem\\<^sub>2\\<rangle> \\<leadsto>\n     \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle> \\<and>\n     \\<langle>c\\<^sub>1', mds', mem\\<^sub>1'\\<rangle> \\<approx>\n     \\<langle>c\\<^sub>2', mds', mem\\<^sub>2'\\<rangle>\n\ngoal (1 subgoal):\n 1. sym mm_equiv", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. sym mm_equiv", "show \"sym mm_equiv\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sym mm_equiv", "by (auto simp: sym_def mm_equiv_sym)"], ["proof (state)\nthis:\n  sym mm_equiv\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}