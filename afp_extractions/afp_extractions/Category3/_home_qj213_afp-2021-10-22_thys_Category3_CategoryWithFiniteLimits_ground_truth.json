{"file_name": "/home/qj213/afp-2021-10-22/thys/Category3/CategoryWithFiniteLimits.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Category3", "problem_names": ["lemma is_category_with_pullbacks:\n    shows \"category_with_pullbacks C\"", "lemma is_category_with_terminal_object:\n    shows \"category_with_terminal_object C\"", "lemma has_finite_products:\n    shows \"category_with_finite_products C\"", "lemma has_finite_limits:\n    shows \"category_with_finite_limits C\""], "translations": [["", "lemma is_category_with_pullbacks:\n    shows \"category_with_pullbacks C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. category_with_pullbacks (\\<cdot>)", ".."], ["", "sublocale category_with_pullbacks C"], ["proof (prove)\ngoal (1 subgoal):\n 1. category_with_pullbacks (\\<cdot>)", ".."], ["", "interpretation category_with_terminal_object C"], ["proof (prove)\ngoal (1 subgoal):\n 1. category_with_terminal_object (\\<cdot>)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. Ex terminal", "show \"\\<exists>a. terminal a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ex terminal", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Ex terminal", "interpret J: discrete_category \\<open>{} :: nat set\\<close> 0"], ["proof (prove)\ngoal (1 subgoal):\n 1. discrete_category {} 0", "by unfold_locales simp"], ["proof (state)\ngoal (1 subgoal):\n 1. Ex terminal", "have 1: \"has_limits_of_shape J.comp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_limits_of_shape J.comp", "using has_finite_limits"], ["proof (prove)\nusing this:\n  \\<lbrakk>category ?J; finite (Collect (partial_magma.arr ?J))\\<rbrakk>\n  \\<Longrightarrow> has_limits_of_shape ?J\n\ngoal (1 subgoal):\n 1. has_limits_of_shape J.comp", "by (metis Collect_empty_eq J.arr_char J.is_category empty_iff finite.emptyI)"], ["proof (state)\nthis:\n  has_limits_of_shape J.comp\n\ngoal (1 subgoal):\n 1. Ex terminal", "interpret D: diagram J.comp C \\<open>\\<lambda>_. null\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. diagram J.comp (\\<cdot>) (\\<lambda>_. null)", "by unfold_locales auto"], ["proof (state)\ngoal (1 subgoal):\n 1. Ex terminal", "obtain t \\<tau> where \\<tau>: \"D.limit_cone t \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t \\<tau>.\n        D.limit_cone t \\<tau> \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 1 D.diagram_axioms has_limits_of_shape_def"], ["proof (prove)\nusing this:\n  has_limits_of_shape J.comp\n  diagram J.comp (\\<cdot>) (\\<lambda>_. null)\n  has_limits_of_shape ?J \\<equiv>\n  \\<forall>D.\n     diagram ?J (\\<cdot>) D \\<longrightarrow>\n     (\\<exists>a \\<chi>. limit_cone ?J (\\<cdot>) D a \\<chi>)\n\ngoal (1 subgoal):\n 1. (\\<And>t \\<tau>.\n        D.limit_cone t \\<tau> \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  D.limit_cone t \\<tau>\n\ngoal (1 subgoal):\n 1. Ex terminal", "interpret \\<tau>: limit_cone J.comp C \\<open>\\<lambda>_. null\\<close> t \\<tau>"], ["proof (prove)\ngoal (1 subgoal):\n 1. D.limit_cone t \\<tau>", "using \\<tau>"], ["proof (prove)\nusing this:\n  D.limit_cone t \\<tau>\n\ngoal (1 subgoal):\n 1. D.limit_cone t \\<tau>", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. Ex terminal", "have \"terminal t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminal t", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ide t\n 2. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright>", "show \"ide t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide t", "using \\<tau>.ide_apex"], ["proof (prove)\nusing this:\n  ide t\n\ngoal (1 subgoal):\n 1. ide t", "by simp"], ["proof (state)\nthis:\n  ide t\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright>", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright>", "assume a: \"ide a\""], ["proof (state)\nthis:\n  ide a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright>", "show \"\\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright>", "interpret a: constant_functor J.comp C a"], ["proof (prove)\ngoal (1 subgoal):\n 1. constant_functor J.comp (\\<cdot>) a", "using a"], ["proof (prove)\nusing this:\n  ide a\n\ngoal (1 subgoal):\n 1. constant_functor J.comp (\\<cdot>) a", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright>", "interpret \\<chi>: cone J.comp C \\<open>\\<lambda>_.null\\<close> a \\<open>\\<lambda>_.null\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. D.cone a (\\<lambda>_. null)", "apply unfold_locales"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>f. \\<not> J.arr f \\<Longrightarrow> null = null\n 2. \\<And>f. J.arr f \\<Longrightarrow> local.dom null = a.map (J.dom f)\n 3. \\<And>f. J.arr f \\<Longrightarrow> cod null = null\n 4. \\<And>f. J.arr f \\<Longrightarrow> null \\<cdot> null = null\n 5. \\<And>f. J.arr f \\<Longrightarrow> null \\<cdot> a.map f = null", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>f. J.arr f \\<Longrightarrow> local.dom null = a.map (J.dom f)\n 2. \\<And>f. J.arr f \\<Longrightarrow> cod null = null\n 3. \\<And>f. J.arr f \\<Longrightarrow> null \\<cdot> null = null\n 4. \\<And>f. J.arr f \\<Longrightarrow> null \\<cdot> a.map f = null", "using dom_null cod_null comp_null"], ["proof (prove)\nusing this:\n  local.dom null = null\n  cod null = null\n  null \\<cdot> ?f = null\n  ?f \\<cdot> null = null\n\ngoal (4 subgoals):\n 1. \\<And>f. J.arr f \\<Longrightarrow> local.dom null = a.map (J.dom f)\n 2. \\<And>f. J.arr f \\<Longrightarrow> cod null = null\n 3. \\<And>f. J.arr f \\<Longrightarrow> null \\<cdot> null = null\n 4. \\<And>f. J.arr f \\<Longrightarrow> null \\<cdot> a.map f = null", "by blast+"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright>", "have \"\\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright> \\<and> D.cones_map f \\<tau> = (\\<lambda>_. null)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!f.\n       \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright> \\<and>\n       D.cones_map f \\<tau> = (\\<lambda>_. null)", "using \\<tau>.induced_arrowI [of \"\\<lambda>_.null\" a] \\<chi>.cone_axioms\n                    \\<tau>.is_universal [of a \"\\<lambda>_. null\"]"], ["proof (prove)\nusing this:\n  (\\<lambda>_. null) \\<in> D.cones a \\<Longrightarrow>\n  \\<guillemotleft>\\<tau>.induced_arrow a\n                   (\\<lambda>_. null) : a \\<rightarrow> t\\<guillemotright>\n  (\\<lambda>_. null) \\<in> D.cones a \\<Longrightarrow>\n  D.cones_map (\\<tau>.induced_arrow a (\\<lambda>_. null)) \\<tau> =\n  (\\<lambda>_. null)\n  D.cone a (\\<lambda>_. null)\n  D.cone a (\\<lambda>_. null) \\<Longrightarrow>\n  \\<exists>!f.\n     \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright> \\<and>\n     D.cones_map f \\<tau> = (\\<lambda>_. null)\n\ngoal (1 subgoal):\n 1. \\<exists>!f.\n       \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright> \\<and>\n       D.cones_map f \\<tau> = (\\<lambda>_. null)", "by simp"], ["proof (state)\nthis:\n  \\<exists>!f.\n     \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright> \\<and>\n     D.cones_map f \\<tau> = (\\<lambda>_. null)\n\ngoal (1 subgoal):\n 1. \\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright>", "moreover"], ["proof (state)\nthis:\n  \\<exists>!f.\n     \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright> \\<and>\n     D.cones_map f \\<tau> = (\\<lambda>_. null)\n\ngoal (1 subgoal):\n 1. \\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright>", "have \"\\<And>f. \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright> \\<Longrightarrow> D.cones_map f \\<tau> = (\\<lambda>_. null)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright> \\<Longrightarrow>\n       D.cones_map f \\<tau> = (\\<lambda>_. null)", "using \\<tau>.cone_axioms"], ["proof (prove)\nusing this:\n  D.cone t \\<tau>\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright> \\<Longrightarrow>\n       D.cones_map f \\<tau> = (\\<lambda>_. null)", "by auto"], ["proof (state)\nthis:\n  \\<guillemotleft>?f4 : a \\<rightarrow> t\\<guillemotright> \\<Longrightarrow>\n  D.cones_map ?f4 \\<tau> = (\\<lambda>_. null)\n\ngoal (1 subgoal):\n 1. \\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright>", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>!f.\n     \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright> \\<and>\n     D.cones_map f \\<tau> = (\\<lambda>_. null)\n  \\<guillemotleft>?f4 : a \\<rightarrow> t\\<guillemotright> \\<Longrightarrow>\n  D.cones_map ?f4 \\<tau> = (\\<lambda>_. null)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>!f.\n     \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright> \\<and>\n     D.cones_map f \\<tau> = (\\<lambda>_. null)\n  \\<guillemotleft>?f4 : a \\<rightarrow> t\\<guillemotright> \\<Longrightarrow>\n  D.cones_map ?f4 \\<tau> = (\\<lambda>_. null)\n\ngoal (1 subgoal):\n 1. \\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright>", "by auto"], ["proof (state)\nthis:\n  \\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  terminal t\n\ngoal (1 subgoal):\n 1. Ex terminal", "thus ?thesis"], ["proof (prove)\nusing this:\n  terminal t\n\ngoal (1 subgoal):\n 1. Ex terminal", "by blast"], ["proof (state)\nthis:\n  Ex terminal\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Ex terminal\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_category_with_terminal_object:\n    shows \"category_with_terminal_object C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. category_with_terminal_object (\\<cdot>)", ".."], ["", "sublocale category_with_terminal_object C"], ["proof (prove)\ngoal (1 subgoal):\n 1. category_with_terminal_object (\\<cdot>)", ".."], ["", "sublocale category_with_finite_products"], ["proof (prove)\ngoal (1 subgoal):\n 1. category_with_finite_products (\\<cdot>)", "using has_finite_limits has_finite_products_if_has_finite_limits\n            has_limits_of_shape_def diagram_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>category ?J; finite (Collect (partial_magma.arr ?J))\\<rbrakk>\n  \\<Longrightarrow> has_limits_of_shape ?J\n  \\<lbrakk>\\<And>J.\n              finite (Collect (partial_magma.arr J)) \\<Longrightarrow>\n              has_limits_of_shape J;\n   finite ?I; ?I \\<noteq> UNIV\\<rbrakk>\n  \\<Longrightarrow> has_products ?I\n  has_limits_of_shape ?J \\<equiv>\n  \\<forall>D.\n     diagram ?J (\\<cdot>) D \\<longrightarrow>\n     (\\<exists>a \\<chi>. limit_cone ?J (\\<cdot>) D a \\<chi>)\n  diagram ?J ?C ?D \\<equiv>\n  category ?C \\<and> category ?J \\<and> functor ?J ?C ?D\n\ngoal (1 subgoal):\n 1. category_with_finite_products (\\<cdot>)", "by unfold_locales blast"], ["", "sublocale cartesian_category"], ["proof (prove)\ngoal (1 subgoal):\n 1. cartesian_category (\\<cdot>)", ".."], ["", "end"], ["", "locale category_with_pullbacks_and_terminal =\n    category_with_pullbacks +\n    category_with_terminal_object"], ["", "sublocale category_with_finite_limits \\<subseteq> category_with_pullbacks_and_terminal"], ["proof (prove)\ngoal (1 subgoal):\n 1. category_with_pullbacks_and_terminal (\\<cdot>)", ".."], ["", "text\\<open>\n    Conversely, we show that a category with pullbacks and a terminal object also\n    has finite products and equalizers, and therefore has finite limits.\n  \\<close>"], ["", "context category_with_pullbacks_and_terminal\n  begin"], ["", "interpretation ECP: elementary_category_with_pullbacks C prj0 prj1"], ["proof (prove)\ngoal (1 subgoal):\n 1. elementary_category_with_pullbacks (\\<cdot>) prj0 prj1", "using extends_to_elementary_category_with_pullbacks"], ["proof (prove)\nusing this:\n  elementary_category_with_pullbacks (\\<cdot>) prj0 prj1\n\ngoal (1 subgoal):\n 1. elementary_category_with_pullbacks (\\<cdot>) prj0 prj1", "by simp"], ["", "abbreviation prj0'\n    where \"prj0' a b \\<equiv> (if ide a \\<and> ide b then prj0 (trm a) (trm b) else null)\""], ["", "abbreviation prj1'\n    where \"prj1' a b \\<equiv> (if ide a \\<and> ide b then prj1 (trm a) (trm b) else null)\""], ["", "interpretation ECC: elementary_cartesian_category C prj0' prj1' \\<one> trm"], ["proof (prove)\ngoal (1 subgoal):\n 1. elementary_cartesian_category (\\<cdot>) prj0' prj1' \\<one> trm", "using trm_naturality ECP.universal"], ["proof (prove)\nusing this:\n  arr ?f \\<Longrightarrow> \\<t>[cod ?f] \\<cdot> ?f = \\<t>[local.dom ?f]\n  commutative_square ?f ?g ?h ?k \\<Longrightarrow>\n  \\<exists>!l. prj1 ?f ?g \\<cdot> l = ?h \\<and> prj0 ?f ?g \\<cdot> l = ?k\n\ngoal (1 subgoal):\n 1. elementary_cartesian_category (\\<cdot>) prj0' prj1' \\<one> trm", "by unfold_locales auto"], ["", "interpretation category_with_equalizers C"], ["proof (prove)\ngoal (1 subgoal):\n 1. category_with_equalizers (\\<cdot>)", "proof (unfold_locales, unfold has_equalizers_def, intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f0 f1. par f0 f1 \\<Longrightarrow> Ex (has_as_equalizer f0 f1)", "fix f0 f1"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f0 f1. par f0 f1 \\<Longrightarrow> Ex (has_as_equalizer f0 f1)", "assume par: \"par f0 f1\""], ["proof (state)\nthis:\n  par f0 f1\n\ngoal (1 subgoal):\n 1. \\<And>f0 f1. par f0 f1 \\<Longrightarrow> Ex (has_as_equalizer f0 f1)", "interpret J: parallel_pair"], ["proof (prove)\ngoal:\nNo subgoals!", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f0 f1. par f0 f1 \\<Longrightarrow> Ex (has_as_equalizer f0 f1)", "interpret D: parallel_pair_diagram C f0 f1"], ["proof (prove)\ngoal (1 subgoal):\n 1. parallel_pair_diagram (\\<cdot>) f0 f1", "using par"], ["proof (prove)\nusing this:\n  par f0 f1\n\ngoal (1 subgoal):\n 1. parallel_pair_diagram (\\<cdot>) f0 f1", "by unfold_locales auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f0 f1. par f0 f1 \\<Longrightarrow> Ex (has_as_equalizer f0 f1)", "have 1: \"cospan (ECC.prod f1 (dom f0)) (ECC.prod f0 (dom f0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cospan (ECC.prod f1 (local.dom f0)) (ECC.prod f0 (local.dom f0))", "using par"], ["proof (prove)\nusing this:\n  par f0 f1\n\ngoal (1 subgoal):\n 1. cospan (ECC.prod f1 (local.dom f0)) (ECC.prod f0 (local.dom f0))", "by simp"], ["proof (state)\nthis:\n  cospan (ECC.prod f1 (local.dom f0)) (ECC.prod f0 (local.dom f0))\n\ngoal (1 subgoal):\n 1. \\<And>f0 f1. par f0 f1 \\<Longrightarrow> Ex (has_as_equalizer f0 f1)", "let ?g0 = \"ECC.prod f0 (dom f0) \\<cdot> ECC.dup (dom f0)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f0 f1. par f0 f1 \\<Longrightarrow> Ex (has_as_equalizer f0 f1)", "let ?g1 = \"ECC.prod f1 (dom f1) \\<cdot> ECC.dup (dom f1)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f0 f1. par f0 f1 \\<Longrightarrow> Ex (has_as_equalizer f0 f1)", "have g0: \"\\<guillemotleft>?g0 : dom f0 \\<rightarrow> ECC.prod (cod f0) (dom f0)\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>ECC.prod f0 (local.dom f0) \\<cdot>\n                    ECC.dup\n                     (local.dom\n                       f0) : local.dom\n                              f0 \\<rightarrow> ECC.prod (cod f0)\n          (local.dom f0)\\<guillemotright>", "using par"], ["proof (prove)\nusing this:\n  par f0 f1\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>ECC.prod f0 (local.dom f0) \\<cdot>\n                    ECC.dup\n                     (local.dom\n                       f0) : local.dom\n                              f0 \\<rightarrow> ECC.prod (cod f0)\n          (local.dom f0)\\<guillemotright>", "by simp"], ["proof (state)\nthis:\n  \\<guillemotleft>ECC.prod f0 (local.dom f0) \\<cdot>\n                  ECC.dup\n                   (local.dom\n                     f0) : local.dom\n                            f0 \\<rightarrow> ECC.prod (cod f0)\n        (local.dom f0)\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>f0 f1. par f0 f1 \\<Longrightarrow> Ex (has_as_equalizer f0 f1)", "have g1: \"\\<guillemotleft>?g1 : dom f1 \\<rightarrow> ECC.prod (cod f1) (dom f1)\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>ECC.prod f1 (local.dom f1) \\<cdot>\n                    ECC.dup\n                     (local.dom\n                       f1) : local.dom\n                              f1 \\<rightarrow> ECC.prod (cod f1)\n          (local.dom f1)\\<guillemotright>", "using par"], ["proof (prove)\nusing this:\n  par f0 f1\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>ECC.prod f1 (local.dom f1) \\<cdot>\n                    ECC.dup\n                     (local.dom\n                       f1) : local.dom\n                              f1 \\<rightarrow> ECC.prod (cod f1)\n          (local.dom f1)\\<guillemotright>", "by simp"], ["proof (state)\nthis:\n  \\<guillemotleft>ECC.prod f1 (local.dom f1) \\<cdot>\n                  ECC.dup\n                   (local.dom\n                     f1) : local.dom\n                            f1 \\<rightarrow> ECC.prod (cod f1)\n        (local.dom f1)\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>f0 f1. par f0 f1 \\<Longrightarrow> Ex (has_as_equalizer f0 f1)", "define e0 where \"e0 = prj0 ?g1 ?g0\""], ["proof (state)\nthis:\n  e0 =\n  prj0 (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n   (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0))\n\ngoal (1 subgoal):\n 1. \\<And>f0 f1. par f0 f1 \\<Longrightarrow> Ex (has_as_equalizer f0 f1)", "define e1 where \"e1 = prj1 ?g1 ?g0\""], ["proof (state)\nthis:\n  e1 =\n  prj1 (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n   (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0))\n\ngoal (1 subgoal):\n 1. \\<And>f0 f1. par f0 f1 \\<Longrightarrow> Ex (has_as_equalizer f0 f1)", "have e0: \"\\<guillemotleft>e0 : dom e0 \\<rightarrow> dom f0\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>e0 : local.dom\n                          e0 \\<rightarrow> local.dom f0\\<guillemotright>", "using par 1 e0_def"], ["proof (prove)\nusing this:\n  par f0 f1\n  cospan (ECC.prod f1 (local.dom f0)) (ECC.prod f0 (local.dom f0))\n  e0 =\n  prj0 (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n   (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0))\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>e0 : local.dom\n                          e0 \\<rightarrow> local.dom f0\\<guillemotright>", "by auto"], ["proof (state)\nthis:\n  \\<guillemotleft>e0 : local.dom\n                        e0 \\<rightarrow> local.dom f0\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>f0 f1. par f0 f1 \\<Longrightarrow> Ex (has_as_equalizer f0 f1)", "have e1: \"\\<guillemotleft>e1 : dom e0 \\<rightarrow> dom f1\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>e1 : local.dom\n                          e0 \\<rightarrow> local.dom f1\\<guillemotright>", "using par 1 e1_def e0_def"], ["proof (prove)\nusing this:\n  par f0 f1\n  cospan (ECC.prod f1 (local.dom f0)) (ECC.prod f0 (local.dom f0))\n  e1 =\n  prj1 (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n   (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0))\n  e0 =\n  prj0 (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n   (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0))\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>e1 : local.dom\n                          e0 \\<rightarrow> local.dom f1\\<guillemotright>", "by auto"], ["proof (state)\nthis:\n  \\<guillemotleft>e1 : local.dom\n                        e0 \\<rightarrow> local.dom f1\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>f0 f1. par f0 f1 \\<Longrightarrow> Ex (has_as_equalizer f0 f1)", "have eq: \"e0 = e1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e0 = e1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. e0 = e1", "have \"e1 = prj0' (cod f1) (dom f1) \\<cdot> ?g1 \\<cdot> e1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e1 =\n    prj0' (cod f1) (local.dom f1) \\<cdot>\n    (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot> e1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. e1 =\n    prj0' (cod f1) (local.dom f1) \\<cdot>\n    (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot> e1", "have \"((prj0' (cod f1) (dom f1) \\<cdot> (ECC.prod f1 (dom f1))) \\<cdot> ECC.dup (dom f1)) \\<cdot> e1 =\n                dom f1 \\<cdot> e1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((prj0' (cod f1) (local.dom f1) \\<cdot>\n      ECC.prod f1 (local.dom f1)) \\<cdot>\n     ECC.dup (local.dom f1)) \\<cdot>\n    e1 =\n    local.dom f1 \\<cdot> e1", "using par ECC.pr_naturality(1) [of \"dom f1\" \"dom f1\" \"dom f1\" f1 \"dom f1\" \"cod f1\"]\n                  comp_cod_arr ECC.pr_dup(1)"], ["proof (prove)\nusing this:\n  par f0 f1\n  \\<lbrakk>arr (local.dom f1); local.dom (local.dom f1) = local.dom f1;\n   cod (local.dom f1) = local.dom f1; arr f1; local.dom f1 = local.dom f1;\n   cod f1 = cod f1\\<rbrakk>\n  \\<Longrightarrow> prj0' (cod f1) (local.dom f1) \\<cdot>\n                    ECC.prod f1 (local.dom f1) =\n                    local.dom f1 \\<cdot> prj0' (local.dom f1) (local.dom f1)\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n  ide ?a \\<Longrightarrow> prj0' ?a ?a \\<cdot> ECC.dup ?a = ?a\n\ngoal (1 subgoal):\n 1. ((prj0' (cod f1) (local.dom f1) \\<cdot>\n      ECC.prod f1 (local.dom f1)) \\<cdot>\n     ECC.dup (local.dom f1)) \\<cdot>\n    e1 =\n    local.dom f1 \\<cdot> e1", "by auto"], ["proof (state)\nthis:\n  ((prj0' (cod f1) (local.dom f1) \\<cdot>\n    ECC.prod f1 (local.dom f1)) \\<cdot>\n   ECC.dup (local.dom f1)) \\<cdot>\n  e1 =\n  local.dom f1 \\<cdot> e1\n\ngoal (1 subgoal):\n 1. e1 =\n    prj0' (cod f1) (local.dom f1) \\<cdot>\n    (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot> e1", "also"], ["proof (state)\nthis:\n  ((prj0' (cod f1) (local.dom f1) \\<cdot>\n    ECC.prod f1 (local.dom f1)) \\<cdot>\n   ECC.dup (local.dom f1)) \\<cdot>\n  e1 =\n  local.dom f1 \\<cdot> e1\n\ngoal (1 subgoal):\n 1. e1 =\n    prj0' (cod f1) (local.dom f1) \\<cdot>\n    (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot> e1", "have \"... = e1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dom f1 \\<cdot> e1 = e1", "using par e1 comp_cod_arr"], ["proof (prove)\nusing this:\n  par f0 f1\n  \\<guillemotleft>e1 : local.dom\n                        e0 \\<rightarrow> local.dom f1\\<guillemotright>\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n\ngoal (1 subgoal):\n 1. local.dom f1 \\<cdot> e1 = e1", "by blast"], ["proof (state)\nthis:\n  local.dom f1 \\<cdot> e1 = e1\n\ngoal (1 subgoal):\n 1. e1 =\n    prj0' (cod f1) (local.dom f1) \\<cdot>\n    (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot> e1", "finally"], ["proof (chain)\npicking this:\n  ((prj0' (cod f1) (local.dom f1) \\<cdot>\n    ECC.prod f1 (local.dom f1)) \\<cdot>\n   ECC.dup (local.dom f1)) \\<cdot>\n  e1 =\n  e1", "show ?thesis"], ["proof (prove)\nusing this:\n  ((prj0' (cod f1) (local.dom f1) \\<cdot>\n    ECC.prod f1 (local.dom f1)) \\<cdot>\n   ECC.dup (local.dom f1)) \\<cdot>\n  e1 =\n  e1\n\ngoal (1 subgoal):\n 1. e1 =\n    prj0' (cod f1) (local.dom f1) \\<cdot>\n    (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot> e1", "using comp_assoc"], ["proof (prove)\nusing this:\n  ((prj0' (cod f1) (local.dom f1) \\<cdot>\n    ECC.prod f1 (local.dom f1)) \\<cdot>\n   ECC.dup (local.dom f1)) \\<cdot>\n  e1 =\n  e1\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. e1 =\n    prj0' (cod f1) (local.dom f1) \\<cdot>\n    (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot> e1", "by simp"], ["proof (state)\nthis:\n  e1 =\n  prj0' (cod f1) (local.dom f1) \\<cdot>\n  (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot> e1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  e1 =\n  prj0' (cod f1) (local.dom f1) \\<cdot>\n  (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot> e1\n\ngoal (1 subgoal):\n 1. e0 = e1", "also"], ["proof (state)\nthis:\n  e1 =\n  prj0' (cod f1) (local.dom f1) \\<cdot>\n  (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot> e1\n\ngoal (1 subgoal):\n 1. e0 = e1", "have \"... = prj0' (cod f1) (dom f1) \\<cdot> ?g0 \\<cdot> e0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prj0' (cod f1) (local.dom f1) \\<cdot>\n    (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot> e1 =\n    prj0' (cod f1) (local.dom f1) \\<cdot>\n    (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot> e0", "using par ECP.pullback_commutes"], ["proof (prove)\nusing this:\n  par f0 f1\n  cospan ?f ?g \\<Longrightarrow>\n  commutative_square ?f ?g (prj1 ?f ?g) (prj0 ?f ?g)\n\ngoal (1 subgoal):\n 1. prj0' (cod f1) (local.dom f1) \\<cdot>\n    (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot> e1 =\n    prj0' (cod f1) (local.dom f1) \\<cdot>\n    (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot> e0", "unfolding commutative_square_def e0_def e1_def"], ["proof (prove)\nusing this:\n  par f0 f1\n  cospan ?f ?g \\<Longrightarrow>\n  cospan ?f ?g \\<and>\n  span (prj1 ?f ?g) (prj0 ?f ?g) \\<and>\n  local.dom ?f = cod (prj1 ?f ?g) \\<and>\n  ?f \\<cdot> prj1 ?f ?g = ?g \\<cdot> prj0 ?f ?g\n\ngoal (1 subgoal):\n 1. prj0' (cod f1) (local.dom f1) \\<cdot>\n    (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot>\n    prj1 (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n     (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) =\n    prj0' (cod f1) (local.dom f1) \\<cdot>\n    (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot>\n    prj0 (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n     (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0))", "by simp"], ["proof (state)\nthis:\n  prj0' (cod f1) (local.dom f1) \\<cdot>\n  (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot> e1 =\n  prj0' (cod f1) (local.dom f1) \\<cdot>\n  (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot> e0\n\ngoal (1 subgoal):\n 1. e0 = e1", "also"], ["proof (state)\nthis:\n  prj0' (cod f1) (local.dom f1) \\<cdot>\n  (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot> e1 =\n  prj0' (cod f1) (local.dom f1) \\<cdot>\n  (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot> e0\n\ngoal (1 subgoal):\n 1. e0 = e1", "have \"... = e0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prj0' (cod f1) (local.dom f1) \\<cdot>\n    (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot> e0 =\n    e0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. prj0' (cod f1) (local.dom f1) \\<cdot>\n    (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot> e0 =\n    e0", "have \"((prj0' (cod f1) (dom f1) \\<cdot> (ECC.prod f0 (dom f0))) \\<cdot> ECC.dup (dom f0)) \\<cdot> e0 =\n                dom f0 \\<cdot> e0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((prj0' (cod f1) (local.dom f1) \\<cdot>\n      ECC.prod f0 (local.dom f0)) \\<cdot>\n     ECC.dup (local.dom f0)) \\<cdot>\n    e0 =\n    local.dom f0 \\<cdot> e0", "using par ECC.pr_naturality(1) [of \"dom f0\" \"dom f0\" \"dom f1\" f0 \"dom f0\" \"cod f0\"]\n                  comp_cod_arr ECC.pr_dup(1) ide_dom"], ["proof (prove)\nusing this:\n  par f0 f1\n  \\<lbrakk>arr (local.dom f0); local.dom (local.dom f0) = local.dom f0;\n   cod (local.dom f0) = local.dom f1; arr f0; local.dom f0 = local.dom f0;\n   cod f0 = cod f0\\<rbrakk>\n  \\<Longrightarrow> prj0' (cod f0) (local.dom f1) \\<cdot>\n                    ECC.prod f0 (local.dom f0) =\n                    local.dom f0 \\<cdot> prj0' (local.dom f0) (local.dom f0)\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n  ide ?a \\<Longrightarrow> prj0' ?a ?a \\<cdot> ECC.dup ?a = ?a\n  arr ?f \\<Longrightarrow> ide (local.dom ?f)\n\ngoal (1 subgoal):\n 1. ((prj0' (cod f1) (local.dom f1) \\<cdot>\n      ECC.prod f0 (local.dom f0)) \\<cdot>\n     ECC.dup (local.dom f0)) \\<cdot>\n    e0 =\n    local.dom f0 \\<cdot> e0", "by auto"], ["proof (state)\nthis:\n  ((prj0' (cod f1) (local.dom f1) \\<cdot>\n    ECC.prod f0 (local.dom f0)) \\<cdot>\n   ECC.dup (local.dom f0)) \\<cdot>\n  e0 =\n  local.dom f0 \\<cdot> e0\n\ngoal (1 subgoal):\n 1. prj0' (cod f1) (local.dom f1) \\<cdot>\n    (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot> e0 =\n    e0", "also"], ["proof (state)\nthis:\n  ((prj0' (cod f1) (local.dom f1) \\<cdot>\n    ECC.prod f0 (local.dom f0)) \\<cdot>\n   ECC.dup (local.dom f0)) \\<cdot>\n  e0 =\n  local.dom f0 \\<cdot> e0\n\ngoal (1 subgoal):\n 1. prj0' (cod f1) (local.dom f1) \\<cdot>\n    (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot> e0 =\n    e0", "have \"... = e0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dom f0 \\<cdot> e0 = e0", "using e0 comp_cod_arr"], ["proof (prove)\nusing this:\n  \\<guillemotleft>e0 : local.dom\n                        e0 \\<rightarrow> local.dom f0\\<guillemotright>\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n\ngoal (1 subgoal):\n 1. local.dom f0 \\<cdot> e0 = e0", "by blast"], ["proof (state)\nthis:\n  local.dom f0 \\<cdot> e0 = e0\n\ngoal (1 subgoal):\n 1. prj0' (cod f1) (local.dom f1) \\<cdot>\n    (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot> e0 =\n    e0", "finally"], ["proof (chain)\npicking this:\n  ((prj0' (cod f1) (local.dom f1) \\<cdot>\n    ECC.prod f0 (local.dom f0)) \\<cdot>\n   ECC.dup (local.dom f0)) \\<cdot>\n  e0 =\n  e0", "show ?thesis"], ["proof (prove)\nusing this:\n  ((prj0' (cod f1) (local.dom f1) \\<cdot>\n    ECC.prod f0 (local.dom f0)) \\<cdot>\n   ECC.dup (local.dom f0)) \\<cdot>\n  e0 =\n  e0\n\ngoal (1 subgoal):\n 1. prj0' (cod f1) (local.dom f1) \\<cdot>\n    (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot> e0 =\n    e0", "using comp_assoc"], ["proof (prove)\nusing this:\n  ((prj0' (cod f1) (local.dom f1) \\<cdot>\n    ECC.prod f0 (local.dom f0)) \\<cdot>\n   ECC.dup (local.dom f0)) \\<cdot>\n  e0 =\n  e0\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. prj0' (cod f1) (local.dom f1) \\<cdot>\n    (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot> e0 =\n    e0", "by simp"], ["proof (state)\nthis:\n  prj0' (cod f1) (local.dom f1) \\<cdot>\n  (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot> e0 =\n  e0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prj0' (cod f1) (local.dom f1) \\<cdot>\n  (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot> e0 =\n  e0\n\ngoal (1 subgoal):\n 1. e0 = e1", "finally"], ["proof (chain)\npicking this:\n  e1 = e0", "show ?thesis"], ["proof (prove)\nusing this:\n  e1 = e0\n\ngoal (1 subgoal):\n 1. e0 = e1", "by auto"], ["proof (state)\nthis:\n  e0 = e1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  e0 = e1\n\ngoal (1 subgoal):\n 1. \\<And>f0 f1. par f0 f1 \\<Longrightarrow> Ex (has_as_equalizer f0 f1)", "have equalizes: \"D.is_equalized_by e0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D.is_equalized_by e0", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. seq f0 e0\n 2. f0 \\<cdot> e0 = f1 \\<cdot> e0", "show \"seq f0 e0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq f0 e0", "using par e0"], ["proof (prove)\nusing this:\n  par f0 f1\n  \\<guillemotleft>e0 : local.dom\n                        e0 \\<rightarrow> local.dom f0\\<guillemotright>\n\ngoal (1 subgoal):\n 1. seq f0 e0", "by auto"], ["proof (state)\nthis:\n  seq f0 e0\n\ngoal (1 subgoal):\n 1. f0 \\<cdot> e0 = f1 \\<cdot> e0", "show \"f0 \\<cdot> e0 = f1 \\<cdot> e0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f0 \\<cdot> e0 = f1 \\<cdot> e0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f0 \\<cdot> e0 = f1 \\<cdot> e0", "have \"f0 \\<cdot> e0 = (f0 \\<cdot> dom f0) \\<cdot> e0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f0 \\<cdot> e0 = (f0 \\<cdot> local.dom f0) \\<cdot> e0", "using par comp_arr_dom"], ["proof (prove)\nusing this:\n  par f0 f1\n  \\<lbrakk>arr ?f; local.dom ?f = ?a\\<rbrakk>\n  \\<Longrightarrow> ?f \\<cdot> ?a = ?f\n\ngoal (1 subgoal):\n 1. f0 \\<cdot> e0 = (f0 \\<cdot> local.dom f0) \\<cdot> e0", "by simp"], ["proof (state)\nthis:\n  f0 \\<cdot> e0 = (f0 \\<cdot> local.dom f0) \\<cdot> e0\n\ngoal (1 subgoal):\n 1. f0 \\<cdot> e0 = f1 \\<cdot> e0", "also"], ["proof (state)\nthis:\n  f0 \\<cdot> e0 = (f0 \\<cdot> local.dom f0) \\<cdot> e0\n\ngoal (1 subgoal):\n 1. f0 \\<cdot> e0 = f1 \\<cdot> e0", "have \"... = (f0 \\<cdot> (prj1' (dom f0) (dom f0) \\<cdot> ECC.dup (dom f0))) \\<cdot> e0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f0 \\<cdot> local.dom f0) \\<cdot> e0 =\n    (f0 \\<cdot>\n     prj1' (local.dom f0) (local.dom f0) \\<cdot>\n     ECC.dup (local.dom f0)) \\<cdot>\n    e0", "using par ECC.pr_dup(2)"], ["proof (prove)\nusing this:\n  par f0 f1\n  ide ?a \\<Longrightarrow> prj1' ?a ?a \\<cdot> ECC.dup ?a = ?a\n\ngoal (1 subgoal):\n 1. (f0 \\<cdot> local.dom f0) \\<cdot> e0 =\n    (f0 \\<cdot>\n     prj1' (local.dom f0) (local.dom f0) \\<cdot>\n     ECC.dup (local.dom f0)) \\<cdot>\n    e0", "by auto"], ["proof (state)\nthis:\n  (f0 \\<cdot> local.dom f0) \\<cdot> e0 =\n  (f0 \\<cdot>\n   prj1' (local.dom f0) (local.dom f0) \\<cdot>\n   ECC.dup (local.dom f0)) \\<cdot>\n  e0\n\ngoal (1 subgoal):\n 1. f0 \\<cdot> e0 = f1 \\<cdot> e0", "also"], ["proof (state)\nthis:\n  (f0 \\<cdot> local.dom f0) \\<cdot> e0 =\n  (f0 \\<cdot>\n   prj1' (local.dom f0) (local.dom f0) \\<cdot>\n   ECC.dup (local.dom f0)) \\<cdot>\n  e0\n\ngoal (1 subgoal):\n 1. f0 \\<cdot> e0 = f1 \\<cdot> e0", "have \"... = ((f0 \\<cdot> prj1' (dom f0) (dom f0)) \\<cdot> ECC.dup (dom f0)) \\<cdot> e0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f0 \\<cdot>\n     prj1' (local.dom f0) (local.dom f0) \\<cdot>\n     ECC.dup (local.dom f0)) \\<cdot>\n    e0 =\n    ((f0 \\<cdot> prj1' (local.dom f0) (local.dom f0)) \\<cdot>\n     ECC.dup (local.dom f0)) \\<cdot>\n    e0", "using comp_assoc"], ["proof (prove)\nusing this:\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. (f0 \\<cdot>\n     prj1' (local.dom f0) (local.dom f0) \\<cdot>\n     ECC.dup (local.dom f0)) \\<cdot>\n    e0 =\n    ((f0 \\<cdot> prj1' (local.dom f0) (local.dom f0)) \\<cdot>\n     ECC.dup (local.dom f0)) \\<cdot>\n    e0", "by auto"], ["proof (state)\nthis:\n  (f0 \\<cdot>\n   prj1' (local.dom f0) (local.dom f0) \\<cdot>\n   ECC.dup (local.dom f0)) \\<cdot>\n  e0 =\n  ((f0 \\<cdot> prj1' (local.dom f0) (local.dom f0)) \\<cdot>\n   ECC.dup (local.dom f0)) \\<cdot>\n  e0\n\ngoal (1 subgoal):\n 1. f0 \\<cdot> e0 = f1 \\<cdot> e0", "also"], ["proof (state)\nthis:\n  (f0 \\<cdot>\n   prj1' (local.dom f0) (local.dom f0) \\<cdot>\n   ECC.dup (local.dom f0)) \\<cdot>\n  e0 =\n  ((f0 \\<cdot> prj1' (local.dom f0) (local.dom f0)) \\<cdot>\n   ECC.dup (local.dom f0)) \\<cdot>\n  e0\n\ngoal (1 subgoal):\n 1. f0 \\<cdot> e0 = f1 \\<cdot> e0", "have \"... = prj1' (cod f1) (dom f1) \\<cdot> ?g0 \\<cdot> e0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((f0 \\<cdot> prj1' (local.dom f0) (local.dom f0)) \\<cdot>\n     ECC.dup (local.dom f0)) \\<cdot>\n    e0 =\n    prj1' (cod f1) (local.dom f1) \\<cdot>\n    (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot> e0", "using par ECC.pr_naturality(2) [of \"dom f0\" \"dom f0\" \"dom f1\" f0 \"dom f0\" \"cod f0\"]"], ["proof (prove)\nusing this:\n  par f0 f1\n  \\<lbrakk>arr (local.dom f0); local.dom (local.dom f0) = local.dom f0;\n   cod (local.dom f0) = local.dom f1; arr f0; local.dom f0 = local.dom f0;\n   cod f0 = cod f0\\<rbrakk>\n  \\<Longrightarrow> prj1' (cod f0) (local.dom f1) \\<cdot>\n                    ECC.prod f0 (local.dom f0) =\n                    f0 \\<cdot> prj1' (local.dom f0) (local.dom f0)\n\ngoal (1 subgoal):\n 1. ((f0 \\<cdot> prj1' (local.dom f0) (local.dom f0)) \\<cdot>\n     ECC.dup (local.dom f0)) \\<cdot>\n    e0 =\n    prj1' (cod f1) (local.dom f1) \\<cdot>\n    (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot> e0", "by (metis (no_types, lifting) arr_dom cod_dom dom_dom comp_assoc)"], ["proof (state)\nthis:\n  ((f0 \\<cdot> prj1' (local.dom f0) (local.dom f0)) \\<cdot>\n   ECC.dup (local.dom f0)) \\<cdot>\n  e0 =\n  prj1' (cod f1) (local.dom f1) \\<cdot>\n  (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot> e0\n\ngoal (1 subgoal):\n 1. f0 \\<cdot> e0 = f1 \\<cdot> e0", "also"], ["proof (state)\nthis:\n  ((f0 \\<cdot> prj1' (local.dom f0) (local.dom f0)) \\<cdot>\n   ECC.dup (local.dom f0)) \\<cdot>\n  e0 =\n  prj1' (cod f1) (local.dom f1) \\<cdot>\n  (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot> e0\n\ngoal (1 subgoal):\n 1. f0 \\<cdot> e0 = f1 \\<cdot> e0", "have \"... = prj1' (cod f1) (dom f1) \\<cdot> ?g1 \\<cdot> e1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prj1' (cod f1) (local.dom f1) \\<cdot>\n    (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot> e0 =\n    prj1' (cod f1) (local.dom f1) \\<cdot>\n    (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot> e1", "using par ECP.pullback_commutes [of ?g1 ?g0]"], ["proof (prove)\nusing this:\n  par f0 f1\n  cospan (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n   (ECC.prod f0 (local.dom f0) \\<cdot>\n    ECC.dup (local.dom f0)) \\<Longrightarrow>\n  commutative_square\n   (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n   (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0))\n   (prj1 (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n     (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)))\n   (prj0 (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n     (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)))\n\ngoal (1 subgoal):\n 1. prj1' (cod f1) (local.dom f1) \\<cdot>\n    (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot> e0 =\n    prj1' (cod f1) (local.dom f1) \\<cdot>\n    (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot> e1", "unfolding commutative_square_def e0_def e1_def"], ["proof (prove)\nusing this:\n  par f0 f1\n  cospan (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n   (ECC.prod f0 (local.dom f0) \\<cdot>\n    ECC.dup (local.dom f0)) \\<Longrightarrow>\n  cospan (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n   (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<and>\n  span\n   (prj1 (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n     (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)))\n   (prj0 (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n     (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0))) \\<and>\n  local.dom (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) =\n  cod (prj1 (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n        (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0))) \\<and>\n  (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot>\n  prj1 (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n   (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) =\n  (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot>\n  prj0 (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n   (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0))\n\ngoal (1 subgoal):\n 1. prj1' (cod f1) (local.dom f1) \\<cdot>\n    (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot>\n    prj0 (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n     (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) =\n    prj1' (cod f1) (local.dom f1) \\<cdot>\n    (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot>\n    prj1 (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n     (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0))", "by simp"], ["proof (state)\nthis:\n  prj1' (cod f1) (local.dom f1) \\<cdot>\n  (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot> e0 =\n  prj1' (cod f1) (local.dom f1) \\<cdot>\n  (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot> e1\n\ngoal (1 subgoal):\n 1. f0 \\<cdot> e0 = f1 \\<cdot> e0", "also"], ["proof (state)\nthis:\n  prj1' (cod f1) (local.dom f1) \\<cdot>\n  (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot> e0 =\n  prj1' (cod f1) (local.dom f1) \\<cdot>\n  (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot> e1\n\ngoal (1 subgoal):\n 1. f0 \\<cdot> e0 = f1 \\<cdot> e0", "have \"... = (prj1' (cod f1) (dom f1) \\<cdot> ?g1) \\<cdot> e1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prj1' (cod f1) (local.dom f1) \\<cdot>\n    (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot> e1 =\n    (prj1' (cod f1) (local.dom f1) \\<cdot>\n     ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot>\n    e1", "using comp_assoc"], ["proof (prove)\nusing this:\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. prj1' (cod f1) (local.dom f1) \\<cdot>\n    (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot> e1 =\n    (prj1' (cod f1) (local.dom f1) \\<cdot>\n     ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot>\n    e1", "by simp"], ["proof (state)\nthis:\n  prj1' (cod f1) (local.dom f1) \\<cdot>\n  (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot> e1 =\n  (prj1' (cod f1) (local.dom f1) \\<cdot>\n   ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot>\n  e1\n\ngoal (1 subgoal):\n 1. f0 \\<cdot> e0 = f1 \\<cdot> e0", "also"], ["proof (state)\nthis:\n  prj1' (cod f1) (local.dom f1) \\<cdot>\n  (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot> e1 =\n  (prj1' (cod f1) (local.dom f1) \\<cdot>\n   ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot>\n  e1\n\ngoal (1 subgoal):\n 1. f0 \\<cdot> e0 = f1 \\<cdot> e0", "have \"... = (f1 \\<cdot> (prj1' (dom f1) (dom f1) \\<cdot> ECC.dup (dom f1))) \\<cdot> e1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (prj1' (cod f1) (local.dom f1) \\<cdot>\n     ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot>\n    e1 =\n    (f1 \\<cdot>\n     prj1' (local.dom f1) (local.dom f1) \\<cdot>\n     ECC.dup (local.dom f1)) \\<cdot>\n    e1", "using par ECC.pr_naturality(2) [of \"dom f1\" \"dom f1\" \"dom f1\" f1 \"dom f1\" \"cod f1\"]"], ["proof (prove)\nusing this:\n  par f0 f1\n  \\<lbrakk>arr (local.dom f1); local.dom (local.dom f1) = local.dom f1;\n   cod (local.dom f1) = local.dom f1; arr f1; local.dom f1 = local.dom f1;\n   cod f1 = cod f1\\<rbrakk>\n  \\<Longrightarrow> prj1' (cod f1) (local.dom f1) \\<cdot>\n                    ECC.prod f1 (local.dom f1) =\n                    f1 \\<cdot> prj1' (local.dom f1) (local.dom f1)\n\ngoal (1 subgoal):\n 1. (prj1' (cod f1) (local.dom f1) \\<cdot>\n     ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot>\n    e1 =\n    (f1 \\<cdot>\n     prj1' (local.dom f1) (local.dom f1) \\<cdot>\n     ECC.dup (local.dom f1)) \\<cdot>\n    e1", "by (metis (no_types, lifting) arr_dom cod_dom dom_dom comp_assoc)"], ["proof (state)\nthis:\n  (prj1' (cod f1) (local.dom f1) \\<cdot>\n   ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot>\n  e1 =\n  (f1 \\<cdot>\n   prj1' (local.dom f1) (local.dom f1) \\<cdot>\n   ECC.dup (local.dom f1)) \\<cdot>\n  e1\n\ngoal (1 subgoal):\n 1. f0 \\<cdot> e0 = f1 \\<cdot> e0", "also"], ["proof (state)\nthis:\n  (prj1' (cod f1) (local.dom f1) \\<cdot>\n   ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot>\n  e1 =\n  (f1 \\<cdot>\n   prj1' (local.dom f1) (local.dom f1) \\<cdot>\n   ECC.dup (local.dom f1)) \\<cdot>\n  e1\n\ngoal (1 subgoal):\n 1. f0 \\<cdot> e0 = f1 \\<cdot> e0", "have \"... = (f1 \\<cdot> dom f1) \\<cdot> e1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f1 \\<cdot>\n     prj1' (local.dom f1) (local.dom f1) \\<cdot>\n     ECC.dup (local.dom f1)) \\<cdot>\n    e1 =\n    (f1 \\<cdot> local.dom f1) \\<cdot> e1", "using par ECC.pr_dup(2)"], ["proof (prove)\nusing this:\n  par f0 f1\n  ide ?a \\<Longrightarrow> prj1' ?a ?a \\<cdot> ECC.dup ?a = ?a\n\ngoal (1 subgoal):\n 1. (f1 \\<cdot>\n     prj1' (local.dom f1) (local.dom f1) \\<cdot>\n     ECC.dup (local.dom f1)) \\<cdot>\n    e1 =\n    (f1 \\<cdot> local.dom f1) \\<cdot> e1", "by auto"], ["proof (state)\nthis:\n  (f1 \\<cdot>\n   prj1' (local.dom f1) (local.dom f1) \\<cdot>\n   ECC.dup (local.dom f1)) \\<cdot>\n  e1 =\n  (f1 \\<cdot> local.dom f1) \\<cdot> e1\n\ngoal (1 subgoal):\n 1. f0 \\<cdot> e0 = f1 \\<cdot> e0", "also"], ["proof (state)\nthis:\n  (f1 \\<cdot>\n   prj1' (local.dom f1) (local.dom f1) \\<cdot>\n   ECC.dup (local.dom f1)) \\<cdot>\n  e1 =\n  (f1 \\<cdot> local.dom f1) \\<cdot> e1\n\ngoal (1 subgoal):\n 1. f0 \\<cdot> e0 = f1 \\<cdot> e0", "have \"... = f1 \\<cdot> e1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f1 \\<cdot> local.dom f1) \\<cdot> e1 = f1 \\<cdot> e1", "using par comp_arr_dom"], ["proof (prove)\nusing this:\n  par f0 f1\n  \\<lbrakk>arr ?f; local.dom ?f = ?a\\<rbrakk>\n  \\<Longrightarrow> ?f \\<cdot> ?a = ?f\n\ngoal (1 subgoal):\n 1. (f1 \\<cdot> local.dom f1) \\<cdot> e1 = f1 \\<cdot> e1", "by simp"], ["proof (state)\nthis:\n  (f1 \\<cdot> local.dom f1) \\<cdot> e1 = f1 \\<cdot> e1\n\ngoal (1 subgoal):\n 1. f0 \\<cdot> e0 = f1 \\<cdot> e0", "also"], ["proof (state)\nthis:\n  (f1 \\<cdot> local.dom f1) \\<cdot> e1 = f1 \\<cdot> e1\n\ngoal (1 subgoal):\n 1. f0 \\<cdot> e0 = f1 \\<cdot> e0", "have \"... = f1 \\<cdot> e0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f1 \\<cdot> e1 = f1 \\<cdot> e0", "using eq"], ["proof (prove)\nusing this:\n  e0 = e1\n\ngoal (1 subgoal):\n 1. f1 \\<cdot> e1 = f1 \\<cdot> e0", "by simp"], ["proof (state)\nthis:\n  f1 \\<cdot> e1 = f1 \\<cdot> e0\n\ngoal (1 subgoal):\n 1. f0 \\<cdot> e0 = f1 \\<cdot> e0", "finally"], ["proof (chain)\npicking this:\n  f0 \\<cdot> e0 = f1 \\<cdot> e0", "show ?thesis"], ["proof (prove)\nusing this:\n  f0 \\<cdot> e0 = f1 \\<cdot> e0\n\ngoal (1 subgoal):\n 1. f0 \\<cdot> e0 = f1 \\<cdot> e0", "by simp"], ["proof (state)\nthis:\n  f0 \\<cdot> e0 = f1 \\<cdot> e0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f0 \\<cdot> e0 = f1 \\<cdot> e0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  D.is_equalized_by e0\n\ngoal (1 subgoal):\n 1. \\<And>f0 f1. par f0 f1 \\<Longrightarrow> Ex (has_as_equalizer f0 f1)", "show \"\\<exists>e. has_as_equalizer f0 f1 e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e. has_as_equalizer f0 f1 e", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. has_as_equalizer f0 f1 ?e", "interpret E: constant_functor J.comp C \\<open>dom e0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. constant_functor (\\<cdot>\\<^sub>J) (\\<cdot>) (local.dom e0)", "using par e0"], ["proof (prove)\nusing this:\n  par f0 f1\n  \\<guillemotleft>e0 : local.dom\n                        e0 \\<rightarrow> local.dom f0\\<guillemotright>\n\ngoal (1 subgoal):\n 1. constant_functor (\\<cdot>\\<^sub>J) (\\<cdot>) (local.dom e0)", "by unfold_locales auto"], ["proof (state)\ngoal (1 subgoal):\n 1. has_as_equalizer f0 f1 ?e", "interpret \\<chi>: cone J.comp C D.map \\<open>dom e0\\<close> \\<open>D.mkCone e0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. D.cone (local.dom e0) (D.mkCone e0)", "using equalizes D.cone_mkCone e0_def"], ["proof (prove)\nusing this:\n  D.is_equalized_by e0\n  D.is_equalized_by ?e \\<Longrightarrow> D.cone (local.dom ?e) (D.mkCone ?e)\n  e0 =\n  prj0 (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n   (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0))\n\ngoal (1 subgoal):\n 1. D.cone (local.dom e0) (D.mkCone e0)", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. has_as_equalizer f0 f1 ?e", "interpret \\<chi>: limit_cone J.comp C D.map \\<open>dom e0\\<close> \\<open>D.mkCone e0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. D.has_as_equalizer e0", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' \\<chi>'.\n       D.cone a' \\<chi>' \\<Longrightarrow>\n       \\<exists>!f.\n          \\<guillemotleft>f : a' \\<rightarrow> local.dom\n          e0\\<guillemotright> \\<and>\n          D.cones_map f (D.mkCone e0) = \\<chi>'", "show \"\\<And>a' \\<chi>'. D.cone a' \\<chi>' \\<Longrightarrow>\n                         \\<exists>!f. \\<guillemotleft>f : a' \\<rightarrow> dom e0\\<guillemotright> \\<and> D.cones_map f (D.mkCone e0) = \\<chi>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a' \\<chi>'.\n       D.cone a' \\<chi>' \\<Longrightarrow>\n       \\<exists>!f.\n          \\<guillemotleft>f : a' \\<rightarrow> local.dom\n          e0\\<guillemotright> \\<and>\n          D.cones_map f (D.mkCone e0) = \\<chi>'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' \\<chi>'.\n       D.cone a' \\<chi>' \\<Longrightarrow>\n       \\<exists>!f.\n          \\<guillemotleft>f : a' \\<rightarrow> local.dom\n          e0\\<guillemotright> \\<and>\n          D.cones_map f (D.mkCone e0) = \\<chi>'", "fix a' \\<chi>'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' \\<chi>'.\n       D.cone a' \\<chi>' \\<Longrightarrow>\n       \\<exists>!f.\n          \\<guillemotleft>f : a' \\<rightarrow> local.dom\n          e0\\<guillemotright> \\<and>\n          D.cones_map f (D.mkCone e0) = \\<chi>'", "assume \\<chi>': \"D.cone a' \\<chi>'\""], ["proof (state)\nthis:\n  D.cone a' \\<chi>'\n\ngoal (1 subgoal):\n 1. \\<And>a' \\<chi>'.\n       D.cone a' \\<chi>' \\<Longrightarrow>\n       \\<exists>!f.\n          \\<guillemotleft>f : a' \\<rightarrow> local.dom\n          e0\\<guillemotright> \\<and>\n          D.cones_map f (D.mkCone e0) = \\<chi>'", "interpret \\<chi>': cone J.comp C D.map a' \\<chi>'"], ["proof (prove)\ngoal (1 subgoal):\n 1. D.cone a' \\<chi>'", "using \\<chi>'"], ["proof (prove)\nusing this:\n  D.cone a' \\<chi>'\n\ngoal (1 subgoal):\n 1. D.cone a' \\<chi>'", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' \\<chi>'.\n       D.cone a' \\<chi>' \\<Longrightarrow>\n       \\<exists>!f.\n          \\<guillemotleft>f : a' \\<rightarrow> local.dom\n          e0\\<guillemotright> \\<and>\n          D.cones_map f (D.mkCone e0) = \\<chi>'", "have 3: \"commutative_square ?g1 ?g0 (\\<chi>' J.Zero) (\\<chi>' J.Zero)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. commutative_square\n     (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n     (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0))\n     (\\<chi>' J.Zero) (\\<chi>' J.Zero)", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. cospan (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n     (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0))\n 2. span (\\<chi>' J.Zero) (\\<chi>' J.Zero)\n 3. local.dom (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) =\n    cod (\\<chi>' J.Zero)\n 4. (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot>\n    \\<chi>' J.Zero =\n    (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot>\n    \\<chi>' J.Zero", "show \"cospan ?g1 ?g0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cospan (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n     (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0))", "using par g0 g1"], ["proof (prove)\nusing this:\n  par f0 f1\n  \\<guillemotleft>ECC.prod f0 (local.dom f0) \\<cdot>\n                  ECC.dup\n                   (local.dom\n                     f0) : local.dom\n                            f0 \\<rightarrow> ECC.prod (cod f0)\n        (local.dom f0)\\<guillemotright>\n  \\<guillemotleft>ECC.prod f1 (local.dom f1) \\<cdot>\n                  ECC.dup\n                   (local.dom\n                     f1) : local.dom\n                            f1 \\<rightarrow> ECC.prod (cod f1)\n        (local.dom f1)\\<guillemotright>\n\ngoal (1 subgoal):\n 1. cospan (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n     (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0))", "by simp"], ["proof (state)\nthis:\n  cospan (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n   (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0))\n\ngoal (3 subgoals):\n 1. span (\\<chi>' J.Zero) (\\<chi>' J.Zero)\n 2. local.dom (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) =\n    cod (\\<chi>' J.Zero)\n 3. (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot>\n    \\<chi>' J.Zero =\n    (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot>\n    \\<chi>' J.Zero", "show 4: \"span (\\<chi>' J.Zero) (\\<chi>' J.Zero)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. span (\\<chi>' J.Zero) (\\<chi>' J.Zero)", "using J.arr_char"], ["proof (prove)\nusing this:\n  J.arr ?f = (?f = J.Zero \\<or> ?f = J.One \\<or> ?f = J.j0 \\<or> ?f = J.j1)\n\ngoal (1 subgoal):\n 1. span (\\<chi>' J.Zero) (\\<chi>' J.Zero)", "by simp"], ["proof (state)\nthis:\n  span (\\<chi>' J.Zero) (\\<chi>' J.Zero)\n\ngoal (2 subgoals):\n 1. local.dom (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) =\n    cod (\\<chi>' J.Zero)\n 2. (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot>\n    \\<chi>' J.Zero =\n    (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot>\n    \\<chi>' J.Zero", "show 5: \"dom ?g1 = cod (\\<chi>' J.Zero)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dom (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) =\n    cod (\\<chi>' J.Zero)", "using par g1 J.arr_char D.map_def"], ["proof (prove)\nusing this:\n  par f0 f1\n  \\<guillemotleft>ECC.prod f1 (local.dom f1) \\<cdot>\n                  ECC.dup\n                   (local.dom\n                     f1) : local.dom\n                            f1 \\<rightarrow> ECC.prod (cod f1)\n        (local.dom f1)\\<guillemotright>\n  J.arr ?f = (?f = J.Zero \\<or> ?f = J.One \\<or> ?f = J.j0 \\<or> ?f = J.j1)\n  D.map \\<equiv>\n  \\<lambda>j.\n     if j = J.Zero then local.dom f0\n     else if j = J.One then cod f0\n          else if j = J.j0 then f0 else if j = J.j1 then f1 else null\n\ngoal (1 subgoal):\n 1. local.dom (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) =\n    cod (\\<chi>' J.Zero)", "by simp"], ["proof (state)\nthis:\n  local.dom (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) =\n  cod (\\<chi>' J.Zero)\n\ngoal (1 subgoal):\n 1. (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot>\n    \\<chi>' J.Zero =\n    (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot>\n    \\<chi>' J.Zero", "show \"?g1 \\<cdot> \\<chi>' J.Zero = ?g0 \\<cdot> \\<chi>' J.Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot>\n    \\<chi>' J.Zero =\n    (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot>\n    \\<chi>' J.Zero", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot>\n    \\<chi>' J.Zero =\n    (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot>\n    \\<chi>' J.Zero", "have \"?g1 \\<cdot> \\<chi>' J.Zero = ECC.prod f1 (dom f1) \\<cdot> ECC.dup (dom f1) \\<cdot> \\<chi>' J.Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot>\n    \\<chi>' J.Zero =\n    ECC.prod f1 (local.dom f1) \\<cdot>\n    ECC.dup (local.dom f1) \\<cdot> \\<chi>' J.Zero", "using comp_assoc"], ["proof (prove)\nusing this:\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot>\n    \\<chi>' J.Zero =\n    ECC.prod f1 (local.dom f1) \\<cdot>\n    ECC.dup (local.dom f1) \\<cdot> \\<chi>' J.Zero", "by simp"], ["proof (state)\nthis:\n  (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot>\n  \\<chi>' J.Zero =\n  ECC.prod f1 (local.dom f1) \\<cdot>\n  ECC.dup (local.dom f1) \\<cdot> \\<chi>' J.Zero\n\ngoal (1 subgoal):\n 1. (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot>\n    \\<chi>' J.Zero =\n    (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot>\n    \\<chi>' J.Zero", "also"], ["proof (state)\nthis:\n  (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot>\n  \\<chi>' J.Zero =\n  ECC.prod f1 (local.dom f1) \\<cdot>\n  ECC.dup (local.dom f1) \\<cdot> \\<chi>' J.Zero\n\ngoal (1 subgoal):\n 1. (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot>\n    \\<chi>' J.Zero =\n    (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot>\n    \\<chi>' J.Zero", "have \"... = ECC.prod f1 (dom f1) \\<cdot> ECC.tuple (\\<chi>' J.Zero) (\\<chi>' J.Zero)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ECC.prod f1 (local.dom f1) \\<cdot>\n    ECC.dup (local.dom f1) \\<cdot> \\<chi>' J.Zero =\n    ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (\\<chi>' J.Zero)", "using par D.map_def J.arr_char comp_cod_arr"], ["proof (prove)\nusing this:\n  par f0 f1\n  D.map \\<equiv>\n  \\<lambda>j.\n     if j = J.Zero then local.dom f0\n     else if j = J.One then cod f0\n          else if j = J.j0 then f0 else if j = J.j1 then f1 else null\n  J.arr ?f = (?f = J.Zero \\<or> ?f = J.One \\<or> ?f = J.j0 \\<or> ?f = J.j1)\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n\ngoal (1 subgoal):\n 1. ECC.prod f1 (local.dom f1) \\<cdot>\n    ECC.dup (local.dom f1) \\<cdot> \\<chi>' J.Zero =\n    ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (\\<chi>' J.Zero)", "by auto"], ["proof (state)\nthis:\n  ECC.prod f1 (local.dom f1) \\<cdot>\n  ECC.dup (local.dom f1) \\<cdot> \\<chi>' J.Zero =\n  ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (\\<chi>' J.Zero)\n\ngoal (1 subgoal):\n 1. (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot>\n    \\<chi>' J.Zero =\n    (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot>\n    \\<chi>' J.Zero", "also"], ["proof (state)\nthis:\n  ECC.prod f1 (local.dom f1) \\<cdot>\n  ECC.dup (local.dom f1) \\<cdot> \\<chi>' J.Zero =\n  ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (\\<chi>' J.Zero)\n\ngoal (1 subgoal):\n 1. (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot>\n    \\<chi>' J.Zero =\n    (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot>\n    \\<chi>' J.Zero", "have \"... = ECC.tuple (f1 \\<cdot> \\<chi>' J.Zero) (\\<chi>' J.Zero)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (\\<chi>' J.Zero) =\n    ECC.tuple (f1 \\<cdot> \\<chi>' J.Zero) (\\<chi>' J.Zero)", "using par ECC.prod_tuple [of \"\\<chi>' J.Zero\" \"\\<chi>' J.Zero\" f1 \"dom f1\"]\n                        comp_cod_arr"], ["proof (prove)\nusing this:\n  par f0 f1\n  \\<lbrakk>span (\\<chi>' J.Zero) (\\<chi>' J.Zero); seq f1 (\\<chi>' J.Zero);\n   seq (local.dom f1) (\\<chi>' J.Zero)\\<rbrakk>\n  \\<Longrightarrow> ECC.prod f1 (local.dom f1) \\<cdot>\n                    ECC.dup (\\<chi>' J.Zero) =\n                    ECC.tuple (f1 \\<cdot> \\<chi>' J.Zero)\n                     (local.dom f1 \\<cdot> \\<chi>' J.Zero)\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n\ngoal (1 subgoal):\n 1. ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (\\<chi>' J.Zero) =\n    ECC.tuple (f1 \\<cdot> \\<chi>' J.Zero) (\\<chi>' J.Zero)", "by (metis (no_types, lifting) 4 5 g1 in_homE seqI)"], ["proof (state)\nthis:\n  ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (\\<chi>' J.Zero) =\n  ECC.tuple (f1 \\<cdot> \\<chi>' J.Zero) (\\<chi>' J.Zero)\n\ngoal (1 subgoal):\n 1. (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot>\n    \\<chi>' J.Zero =\n    (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot>\n    \\<chi>' J.Zero", "also"], ["proof (state)\nthis:\n  ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (\\<chi>' J.Zero) =\n  ECC.tuple (f1 \\<cdot> \\<chi>' J.Zero) (\\<chi>' J.Zero)\n\ngoal (1 subgoal):\n 1. (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot>\n    \\<chi>' J.Zero =\n    (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot>\n    \\<chi>' J.Zero", "have \"... = ECC.tuple (f0 \\<cdot> \\<chi>' J.Zero) (\\<chi>' J.Zero)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ECC.tuple (f1 \\<cdot> \\<chi>' J.Zero) (\\<chi>' J.Zero) =\n    ECC.tuple (f0 \\<cdot> \\<chi>' J.Zero) (\\<chi>' J.Zero)", "using par D.is_equalized_by_cone \\<chi>'.cone_axioms"], ["proof (prove)\nusing this:\n  par f0 f1\n  D.cone ?a ?\\<chi> \\<Longrightarrow> D.is_equalized_by (?\\<chi> J.Zero)\n  D.cone a' \\<chi>'\n\ngoal (1 subgoal):\n 1. ECC.tuple (f1 \\<cdot> \\<chi>' J.Zero) (\\<chi>' J.Zero) =\n    ECC.tuple (f0 \\<cdot> \\<chi>' J.Zero) (\\<chi>' J.Zero)", "by auto"], ["proof (state)\nthis:\n  ECC.tuple (f1 \\<cdot> \\<chi>' J.Zero) (\\<chi>' J.Zero) =\n  ECC.tuple (f0 \\<cdot> \\<chi>' J.Zero) (\\<chi>' J.Zero)\n\ngoal (1 subgoal):\n 1. (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot>\n    \\<chi>' J.Zero =\n    (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot>\n    \\<chi>' J.Zero", "also"], ["proof (state)\nthis:\n  ECC.tuple (f1 \\<cdot> \\<chi>' J.Zero) (\\<chi>' J.Zero) =\n  ECC.tuple (f0 \\<cdot> \\<chi>' J.Zero) (\\<chi>' J.Zero)\n\ngoal (1 subgoal):\n 1. (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot>\n    \\<chi>' J.Zero =\n    (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot>\n    \\<chi>' J.Zero", "have \"... = ECC.prod f0 (dom f0) \\<cdot> ECC.tuple (\\<chi>' J.Zero) (\\<chi>' J.Zero)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ECC.tuple (f0 \\<cdot> \\<chi>' J.Zero) (\\<chi>' J.Zero) =\n    ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (\\<chi>' J.Zero)", "using par ECC.prod_tuple [of \"\\<chi>' J.Zero\" \"\\<chi>' J.Zero\" f0 \"dom f0\"]\n                        comp_cod_arr"], ["proof (prove)\nusing this:\n  par f0 f1\n  \\<lbrakk>span (\\<chi>' J.Zero) (\\<chi>' J.Zero); seq f0 (\\<chi>' J.Zero);\n   seq (local.dom f0) (\\<chi>' J.Zero)\\<rbrakk>\n  \\<Longrightarrow> ECC.prod f0 (local.dom f0) \\<cdot>\n                    ECC.dup (\\<chi>' J.Zero) =\n                    ECC.tuple (f0 \\<cdot> \\<chi>' J.Zero)\n                     (local.dom f0 \\<cdot> \\<chi>' J.Zero)\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n\ngoal (1 subgoal):\n 1. ECC.tuple (f0 \\<cdot> \\<chi>' J.Zero) (\\<chi>' J.Zero) =\n    ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (\\<chi>' J.Zero)", "by (metis (no_types, lifting) 4 5 g1 in_homE seqI)"], ["proof (state)\nthis:\n  ECC.tuple (f0 \\<cdot> \\<chi>' J.Zero) (\\<chi>' J.Zero) =\n  ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (\\<chi>' J.Zero)\n\ngoal (1 subgoal):\n 1. (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot>\n    \\<chi>' J.Zero =\n    (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot>\n    \\<chi>' J.Zero", "also"], ["proof (state)\nthis:\n  ECC.tuple (f0 \\<cdot> \\<chi>' J.Zero) (\\<chi>' J.Zero) =\n  ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (\\<chi>' J.Zero)\n\ngoal (1 subgoal):\n 1. (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot>\n    \\<chi>' J.Zero =\n    (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot>\n    \\<chi>' J.Zero", "have \"... = ECC.prod f0 (dom f0) \\<cdot> ECC.dup (dom f0) \\<cdot> \\<chi>' J.Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (\\<chi>' J.Zero) =\n    ECC.prod f0 (local.dom f0) \\<cdot>\n    ECC.dup (local.dom f0) \\<cdot> \\<chi>' J.Zero", "using par D.map_def J.arr_char comp_cod_arr"], ["proof (prove)\nusing this:\n  par f0 f1\n  D.map \\<equiv>\n  \\<lambda>j.\n     if j = J.Zero then local.dom f0\n     else if j = J.One then cod f0\n          else if j = J.j0 then f0 else if j = J.j1 then f1 else null\n  J.arr ?f = (?f = J.Zero \\<or> ?f = J.One \\<or> ?f = J.j0 \\<or> ?f = J.j1)\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n\ngoal (1 subgoal):\n 1. ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (\\<chi>' J.Zero) =\n    ECC.prod f0 (local.dom f0) \\<cdot>\n    ECC.dup (local.dom f0) \\<cdot> \\<chi>' J.Zero", "by auto"], ["proof (state)\nthis:\n  ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (\\<chi>' J.Zero) =\n  ECC.prod f0 (local.dom f0) \\<cdot>\n  ECC.dup (local.dom f0) \\<cdot> \\<chi>' J.Zero\n\ngoal (1 subgoal):\n 1. (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot>\n    \\<chi>' J.Zero =\n    (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot>\n    \\<chi>' J.Zero", "also"], ["proof (state)\nthis:\n  ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (\\<chi>' J.Zero) =\n  ECC.prod f0 (local.dom f0) \\<cdot>\n  ECC.dup (local.dom f0) \\<cdot> \\<chi>' J.Zero\n\ngoal (1 subgoal):\n 1. (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot>\n    \\<chi>' J.Zero =\n    (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot>\n    \\<chi>' J.Zero", "have \"... = ?g0 \\<cdot> \\<chi>' J.Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ECC.prod f0 (local.dom f0) \\<cdot>\n    ECC.dup (local.dom f0) \\<cdot> \\<chi>' J.Zero =\n    (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot>\n    \\<chi>' J.Zero", "using comp_assoc"], ["proof (prove)\nusing this:\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. ECC.prod f0 (local.dom f0) \\<cdot>\n    ECC.dup (local.dom f0) \\<cdot> \\<chi>' J.Zero =\n    (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot>\n    \\<chi>' J.Zero", "by simp"], ["proof (state)\nthis:\n  ECC.prod f0 (local.dom f0) \\<cdot>\n  ECC.dup (local.dom f0) \\<cdot> \\<chi>' J.Zero =\n  (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot>\n  \\<chi>' J.Zero\n\ngoal (1 subgoal):\n 1. (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot>\n    \\<chi>' J.Zero =\n    (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot>\n    \\<chi>' J.Zero", "finally"], ["proof (chain)\npicking this:\n  (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot>\n  \\<chi>' J.Zero =\n  (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot>\n  \\<chi>' J.Zero", "show ?thesis"], ["proof (prove)\nusing this:\n  (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot>\n  \\<chi>' J.Zero =\n  (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot>\n  \\<chi>' J.Zero\n\ngoal (1 subgoal):\n 1. (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot>\n    \\<chi>' J.Zero =\n    (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot>\n    \\<chi>' J.Zero", "by blast"], ["proof (state)\nthis:\n  (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot>\n  \\<chi>' J.Zero =\n  (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot>\n  \\<chi>' J.Zero\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1)) \\<cdot>\n  \\<chi>' J.Zero =\n  (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot>\n  \\<chi>' J.Zero\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  commutative_square\n   (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n   (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0))\n   (\\<chi>' J.Zero) (\\<chi>' J.Zero)\n\ngoal (1 subgoal):\n 1. \\<And>a' \\<chi>'.\n       D.cone a' \\<chi>' \\<Longrightarrow>\n       \\<exists>!f.\n          \\<guillemotleft>f : a' \\<rightarrow> local.dom\n          e0\\<guillemotright> \\<and>\n          D.cones_map f (D.mkCone e0) = \\<chi>'", "show \"\\<exists>!f. \\<guillemotleft>f : a' \\<rightarrow> dom e0\\<guillemotright> \\<and> D.cones_map f (D.mkCone e0) = \\<chi>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!f.\n       \\<guillemotleft>f : a' \\<rightarrow> local.dom\n       e0\\<guillemotright> \\<and>\n       D.cones_map f (D.mkCone e0) = \\<chi>'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : a' \\<rightarrow> local.dom\n     e0\\<guillemotright> \\<and>\n    D.cones_map ?a (D.mkCone e0) = \\<chi>'\n 2. \\<And>f.\n       \\<guillemotleft>f : a' \\<rightarrow> local.dom\n       e0\\<guillemotright> \\<and>\n       D.cones_map f (D.mkCone e0) = \\<chi>' \\<Longrightarrow>\n       f = ?a", "define f where \"f = ECP.tuple (\\<chi>' J.Zero) ?g1 ?g0 (\\<chi>' J.Zero)\""], ["proof (state)\nthis:\n  f =\n  ECP.tuple (\\<chi>' J.Zero)\n   (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n   (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0))\n   (\\<chi>' J.Zero)\n\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : a' \\<rightarrow> local.dom\n     e0\\<guillemotright> \\<and>\n    D.cones_map ?a (D.mkCone e0) = \\<chi>'\n 2. \\<And>f.\n       \\<guillemotleft>f : a' \\<rightarrow> local.dom\n       e0\\<guillemotright> \\<and>\n       D.cones_map f (D.mkCone e0) = \\<chi>' \\<Longrightarrow>\n       f = ?a", "have 4: \"e0 \\<cdot> f = \\<chi>' J.Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e0 \\<cdot> f = \\<chi>' J.Zero", "using ECP.universal"], ["proof (prove)\nusing this:\n  commutative_square ?f ?g ?h ?k \\<Longrightarrow>\n  \\<exists>!l. prj1 ?f ?g \\<cdot> l = ?h \\<and> prj0 ?f ?g \\<cdot> l = ?k\n\ngoal (1 subgoal):\n 1. e0 \\<cdot> f = \\<chi>' J.Zero", "by (simp add: \"3\" e1_def eq f_def)"], ["proof (state)\nthis:\n  e0 \\<cdot> f = \\<chi>' J.Zero\n\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : a' \\<rightarrow> local.dom\n     e0\\<guillemotright> \\<and>\n    D.cones_map ?a (D.mkCone e0) = \\<chi>'\n 2. \\<And>f.\n       \\<guillemotleft>f : a' \\<rightarrow> local.dom\n       e0\\<guillemotright> \\<and>\n       D.cones_map f (D.mkCone e0) = \\<chi>' \\<Longrightarrow>\n       f = ?a", "have f: \"\\<guillemotleft>f : a' \\<rightarrow> dom e0\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>f : a' \\<rightarrow> local.dom e0\\<guillemotright>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<guillemotleft>f : a' \\<rightarrow> local.dom e0\\<guillemotright>", "have \"a' = dom (\\<chi>' J.Zero)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a' = local.dom (\\<chi>' J.Zero)", "by (simp add: J.arr_char)"], ["proof (state)\nthis:\n  a' = local.dom (\\<chi>' J.Zero)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>f : a' \\<rightarrow> local.dom e0\\<guillemotright>", "thus ?thesis"], ["proof (prove)\nusing this:\n  a' = local.dom (\\<chi>' J.Zero)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>f : a' \\<rightarrow> local.dom e0\\<guillemotright>", "using 3 f_def e0_def g0 g1 ECP.tuple_in_hom ECP.pbdom_def"], ["proof (prove)\nusing this:\n  a' = local.dom (\\<chi>' J.Zero)\n  commutative_square\n   (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n   (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0))\n   (\\<chi>' J.Zero) (\\<chi>' J.Zero)\n  f =\n  ECP.tuple (\\<chi>' J.Zero)\n   (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n   (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0))\n   (\\<chi>' J.Zero)\n  e0 =\n  prj0 (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n   (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0))\n  \\<guillemotleft>ECC.prod f0 (local.dom f0) \\<cdot>\n                  ECC.dup\n                   (local.dom\n                     f0) : local.dom\n                            f0 \\<rightarrow> ECC.prod (cod f0)\n        (local.dom f0)\\<guillemotright>\n  \\<guillemotleft>ECC.prod f1 (local.dom f1) \\<cdot>\n                  ECC.dup\n                   (local.dom\n                     f1) : local.dom\n                            f1 \\<rightarrow> ECC.prod (cod f1)\n        (local.dom f1)\\<guillemotright>\n  commutative_square ?f ?g ?h ?k \\<Longrightarrow>\n  \\<guillemotleft>ECP.tuple ?h ?f ?g\n                   ?k : local.dom\n                         ?h \\<rightarrow> ECP.pbdom ?f ?g\\<guillemotright>\n  ECP.pbdom ?f ?g \\<equiv> local.dom (prj0 ?f ?g)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>f : a' \\<rightarrow> local.dom e0\\<guillemotright>", "by simp"], ["proof (state)\nthis:\n  \\<guillemotleft>f : a' \\<rightarrow> local.dom e0\\<guillemotright>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<guillemotleft>f : a' \\<rightarrow> local.dom e0\\<guillemotright>\n\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : a' \\<rightarrow> local.dom\n     e0\\<guillemotright> \\<and>\n    D.cones_map ?a (D.mkCone e0) = \\<chi>'\n 2. \\<And>f.\n       \\<guillemotleft>f : a' \\<rightarrow> local.dom\n       e0\\<guillemotright> \\<and>\n       D.cones_map f (D.mkCone e0) = \\<chi>' \\<Longrightarrow>\n       f = ?a", "moreover"], ["proof (state)\nthis:\n  \\<guillemotleft>f : a' \\<rightarrow> local.dom e0\\<guillemotright>\n\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : a' \\<rightarrow> local.dom\n     e0\\<guillemotright> \\<and>\n    D.cones_map ?a (D.mkCone e0) = \\<chi>'\n 2. \\<And>f.\n       \\<guillemotleft>f : a' \\<rightarrow> local.dom\n       e0\\<guillemotright> \\<and>\n       D.cones_map f (D.mkCone e0) = \\<chi>' \\<Longrightarrow>\n       f = ?a", "have 5: \"D.cones_map f (D.mkCone e0) = \\<chi>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D.cones_map f (D.mkCone e0) = \\<chi>'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. D.cones_map f (D.mkCone e0) = \\<chi>'", "have \"\\<And>j. J.arr j \\<Longrightarrow> D.mkCone e0 j \\<cdot> f = \\<chi>' j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j. J.arr j \\<Longrightarrow> D.mkCone e0 j \\<cdot> f = \\<chi>' j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j. J.arr j \\<Longrightarrow> D.mkCone e0 j \\<cdot> f = \\<chi>' j", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j. J.arr j \\<Longrightarrow> D.mkCone e0 j \\<cdot> f = \\<chi>' j", "assume j: \"J.arr j\""], ["proof (state)\nthis:\n  J.arr j\n\ngoal (1 subgoal):\n 1. \\<And>j. J.arr j \\<Longrightarrow> D.mkCone e0 j \\<cdot> f = \\<chi>' j", "show \"D.mkCone e0 j \\<cdot> f = \\<chi>' j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D.mkCone e0 j \\<cdot> f = \\<chi>' j", "proof (cases \"j = J.Zero\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j = J.Zero \\<Longrightarrow> D.mkCone e0 j \\<cdot> f = \\<chi>' j\n 2. j \\<noteq> J.Zero \\<Longrightarrow> D.mkCone e0 j \\<cdot> f = \\<chi>' j", "case True"], ["proof (state)\nthis:\n  j = J.Zero\n\ngoal (2 subgoals):\n 1. j = J.Zero \\<Longrightarrow> D.mkCone e0 j \\<cdot> f = \\<chi>' j\n 2. j \\<noteq> J.Zero \\<Longrightarrow> D.mkCone e0 j \\<cdot> f = \\<chi>' j", "moreover"], ["proof (state)\nthis:\n  j = J.Zero\n\ngoal (2 subgoals):\n 1. j = J.Zero \\<Longrightarrow> D.mkCone e0 j \\<cdot> f = \\<chi>' j\n 2. j \\<noteq> J.Zero \\<Longrightarrow> D.mkCone e0 j \\<cdot> f = \\<chi>' j", "have \"e0 \\<cdot> f = \\<chi>' J.Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e0 \\<cdot> f = \\<chi>' J.Zero", "using 4"], ["proof (prove)\nusing this:\n  e0 \\<cdot> f = \\<chi>' J.Zero\n\ngoal (1 subgoal):\n 1. e0 \\<cdot> f = \\<chi>' J.Zero", "by simp"], ["proof (state)\nthis:\n  e0 \\<cdot> f = \\<chi>' J.Zero\n\ngoal (2 subgoals):\n 1. j = J.Zero \\<Longrightarrow> D.mkCone e0 j \\<cdot> f = \\<chi>' j\n 2. j \\<noteq> J.Zero \\<Longrightarrow> D.mkCone e0 j \\<cdot> f = \\<chi>' j", "ultimately"], ["proof (chain)\npicking this:\n  j = J.Zero\n  e0 \\<cdot> f = \\<chi>' J.Zero", "show ?thesis"], ["proof (prove)\nusing this:\n  j = J.Zero\n  e0 \\<cdot> f = \\<chi>' J.Zero\n\ngoal (1 subgoal):\n 1. D.mkCone e0 j \\<cdot> f = \\<chi>' j", "unfolding f_def D.mkCone_def comp_assoc"], ["proof (prove)\nusing this:\n  j = J.Zero\n  e0 \\<cdot>\n  ECP.tuple (\\<chi>' J.Zero)\n   (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n   (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0))\n   (\\<chi>' J.Zero) =\n  \\<chi>' J.Zero\n\ngoal (1 subgoal):\n 1. (if J.arr j then if j = J.Zero then e0 else f0 \\<cdot> e0\n     else null) \\<cdot>\n    ECP.tuple (\\<chi>' J.Zero)\n     (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n     (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0))\n     (\\<chi>' J.Zero) =\n    \\<chi>' j", "using J.arr_char"], ["proof (prove)\nusing this:\n  j = J.Zero\n  e0 \\<cdot>\n  ECP.tuple (\\<chi>' J.Zero)\n   (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n   (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0))\n   (\\<chi>' J.Zero) =\n  \\<chi>' J.Zero\n  J.arr ?f = (?f = J.Zero \\<or> ?f = J.One \\<or> ?f = J.j0 \\<or> ?f = J.j1)\n\ngoal (1 subgoal):\n 1. (if J.arr j then if j = J.Zero then e0 else f0 \\<cdot> e0\n     else null) \\<cdot>\n    ECP.tuple (\\<chi>' J.Zero)\n     (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n     (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0))\n     (\\<chi>' J.Zero) =\n    \\<chi>' j", "by simp"], ["proof (state)\nthis:\n  D.mkCone e0 j \\<cdot> f = \\<chi>' j\n\ngoal (1 subgoal):\n 1. j \\<noteq> J.Zero \\<Longrightarrow> D.mkCone e0 j \\<cdot> f = \\<chi>' j", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. j \\<noteq> J.Zero \\<Longrightarrow> D.mkCone e0 j \\<cdot> f = \\<chi>' j", "case F: False"], ["proof (state)\nthis:\n  j \\<noteq> J.Zero\n\ngoal (1 subgoal):\n 1. j \\<noteq> J.Zero \\<Longrightarrow> D.mkCone e0 j \\<cdot> f = \\<chi>' j", "hence 1: \"(f0 \\<cdot> e0) \\<cdot> f = f0 \\<cdot> \\<chi>' J.Zero\""], ["proof (prove)\nusing this:\n  j \\<noteq> J.Zero\n\ngoal (1 subgoal):\n 1. (f0 \\<cdot> e0) \\<cdot> f = f0 \\<cdot> \\<chi>' J.Zero", "using 4 comp_assoc"], ["proof (prove)\nusing this:\n  j \\<noteq> J.Zero\n  e0 \\<cdot> f = \\<chi>' J.Zero\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. (f0 \\<cdot> e0) \\<cdot> f = f0 \\<cdot> \\<chi>' J.Zero", "by simp"], ["proof (state)\nthis:\n  (f0 \\<cdot> e0) \\<cdot> f = f0 \\<cdot> \\<chi>' J.Zero\n\ngoal (1 subgoal):\n 1. j \\<noteq> J.Zero \\<Longrightarrow> D.mkCone e0 j \\<cdot> f = \\<chi>' j", "also"], ["proof (state)\nthis:\n  (f0 \\<cdot> e0) \\<cdot> f = f0 \\<cdot> \\<chi>' J.Zero\n\ngoal (1 subgoal):\n 1. j \\<noteq> J.Zero \\<Longrightarrow> D.mkCone e0 j \\<cdot> f = \\<chi>' j", "have \"... = \\<chi>' j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f0 \\<cdot> \\<chi>' J.Zero = \\<chi>' j", "by (metis (no_types, lifting) F D.mkCone_cone D.mkCone_def\n                          \\<chi>'.cone_axioms j)"], ["proof (state)\nthis:\n  f0 \\<cdot> \\<chi>' J.Zero = \\<chi>' j\n\ngoal (1 subgoal):\n 1. j \\<noteq> J.Zero \\<Longrightarrow> D.mkCone e0 j \\<cdot> f = \\<chi>' j", "finally"], ["proof (chain)\npicking this:\n  (f0 \\<cdot> e0) \\<cdot> f = \\<chi>' j", "show ?thesis"], ["proof (prove)\nusing this:\n  (f0 \\<cdot> e0) \\<cdot> f = \\<chi>' j\n\ngoal (1 subgoal):\n 1. D.mkCone e0 j \\<cdot> f = \\<chi>' j", "by (simp add: F D.mkCone_def j)"], ["proof (state)\nthis:\n  D.mkCone e0 j \\<cdot> f = \\<chi>' j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  D.mkCone e0 j \\<cdot> f = \\<chi>' j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  J.arr ?j4 \\<Longrightarrow> D.mkCone e0 ?j4 \\<cdot> f = \\<chi>' ?j4\n\ngoal (1 subgoal):\n 1. D.cones_map f (D.mkCone e0) = \\<chi>'", "thus ?thesis"], ["proof (prove)\nusing this:\n  J.arr ?j4 \\<Longrightarrow> D.mkCone e0 ?j4 \\<cdot> f = \\<chi>' ?j4\n\ngoal (1 subgoal):\n 1. D.cones_map f (D.mkCone e0) = \\<chi>'", "using f e0 \\<chi>.cone_axioms \\<chi>'.is_extensional"], ["proof (prove)\nusing this:\n  J.arr ?j4 \\<Longrightarrow> D.mkCone e0 ?j4 \\<cdot> f = \\<chi>' ?j4\n  \\<guillemotleft>f : a' \\<rightarrow> local.dom e0\\<guillemotright>\n  \\<guillemotleft>e0 : local.dom\n                        e0 \\<rightarrow> local.dom f0\\<guillemotright>\n  D.cone (local.dom e0) (D.mkCone e0)\n  \\<not> J.arr ?f \\<Longrightarrow> \\<chi>' ?f = null\n\ngoal (1 subgoal):\n 1. D.cones_map f (D.mkCone e0) = \\<chi>'", "by auto"], ["proof (state)\nthis:\n  D.cones_map f (D.mkCone e0) = \\<chi>'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  D.cones_map f (D.mkCone e0) = \\<chi>'\n\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : a' \\<rightarrow> local.dom\n     e0\\<guillemotright> \\<and>\n    D.cones_map ?a (D.mkCone e0) = \\<chi>'\n 2. \\<And>f.\n       \\<guillemotleft>f : a' \\<rightarrow> local.dom\n       e0\\<guillemotright> \\<and>\n       D.cones_map f (D.mkCone e0) = \\<chi>' \\<Longrightarrow>\n       f = ?a", "ultimately"], ["proof (chain)\npicking this:\n  \\<guillemotleft>f : a' \\<rightarrow> local.dom e0\\<guillemotright>\n  D.cones_map f (D.mkCone e0) = \\<chi>'", "show \"\\<guillemotleft>f : a' \\<rightarrow> dom e0\\<guillemotright> \\<and> D.cones_map f (D.mkCone e0) = \\<chi>'\""], ["proof (prove)\nusing this:\n  \\<guillemotleft>f : a' \\<rightarrow> local.dom e0\\<guillemotright>\n  D.cones_map f (D.mkCone e0) = \\<chi>'\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>f : a' \\<rightarrow> local.dom\n    e0\\<guillemotright> \\<and>\n    D.cones_map f (D.mkCone e0) = \\<chi>'", "by simp"], ["proof (state)\nthis:\n  \\<guillemotleft>f : a' \\<rightarrow> local.dom e0\\<guillemotright> \\<and>\n  D.cones_map f (D.mkCone e0) = \\<chi>'\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<guillemotleft>f : a' \\<rightarrow> local.dom\n       e0\\<guillemotright> \\<and>\n       D.cones_map f (D.mkCone e0) = \\<chi>' \\<Longrightarrow>\n       f =\n       ECP.tuple (\\<chi>' J.Zero)\n        (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n        (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0))\n        (\\<chi>' J.Zero)", "fix f'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<guillemotleft>f : a' \\<rightarrow> local.dom\n       e0\\<guillemotright> \\<and>\n       D.cones_map f (D.mkCone e0) = \\<chi>' \\<Longrightarrow>\n       f =\n       ECP.tuple (\\<chi>' J.Zero)\n        (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n        (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0))\n        (\\<chi>' J.Zero)", "assume f': \"\\<guillemotleft>f' : a' \\<rightarrow> dom e0\\<guillemotright> \\<and> D.cones_map f' (D.mkCone e0) = \\<chi>'\""], ["proof (state)\nthis:\n  \\<guillemotleft>f' : a' \\<rightarrow> local.dom e0\\<guillemotright> \\<and>\n  D.cones_map f' (D.mkCone e0) = \\<chi>'\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<guillemotleft>f : a' \\<rightarrow> local.dom\n       e0\\<guillemotright> \\<and>\n       D.cones_map f (D.mkCone e0) = \\<chi>' \\<Longrightarrow>\n       f =\n       ECP.tuple (\\<chi>' J.Zero)\n        (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n        (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0))\n        (\\<chi>' J.Zero)", "show \"f' = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f' = f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f' = f", "have \"e0 \\<cdot> f' = \\<chi>' J.Zero\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e0 \\<cdot> f' = \\<chi>' J.Zero", "using f' D.mkCone_cone D.mkCone_def \\<chi>'.cone_axioms\n                        comp_assoc J.arr_char \\<chi>.cone_axioms"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f' : a' \\<rightarrow> local.dom e0\\<guillemotright> \\<and>\n  D.cones_map f' (D.mkCone e0) = \\<chi>'\n  D.cone ?a ?\\<chi> \\<Longrightarrow> D.mkCone (?\\<chi> J.Zero) = ?\\<chi>\n  D.mkCone ?e \\<equiv>\n  \\<lambda>j.\n     if J.arr j then if j = J.Zero then ?e else f0 \\<cdot> ?e else null\n  D.cone a' \\<chi>'\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n  J.arr ?f = (?f = J.Zero \\<or> ?f = J.One \\<or> ?f = J.j0 \\<or> ?f = J.j1)\n  D.cone (local.dom e0) (D.mkCone e0)\n\ngoal (1 subgoal):\n 1. e0 \\<cdot> f' = \\<chi>' J.Zero", "by auto"], ["proof (state)\nthis:\n  e0 \\<cdot> f' = \\<chi>' J.Zero\n\ngoal (1 subgoal):\n 1. f' = f", "thus ?thesis"], ["proof (prove)\nusing this:\n  e0 \\<cdot> f' = \\<chi>' J.Zero\n\ngoal (1 subgoal):\n 1. f' = f", "using f' 3 4 eq ECP.universal [of ?g1 ?g0 \"e1 \\<cdot> f'\" \"e0 \\<cdot> f'\"] e0_def e1_def"], ["proof (prove)\nusing this:\n  e0 \\<cdot> f' = \\<chi>' J.Zero\n  \\<guillemotleft>f' : a' \\<rightarrow> local.dom e0\\<guillemotright> \\<and>\n  D.cones_map f' (D.mkCone e0) = \\<chi>'\n  commutative_square\n   (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n   (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0))\n   (\\<chi>' J.Zero) (\\<chi>' J.Zero)\n  e0 \\<cdot> f = \\<chi>' J.Zero\n  e0 = e1\n  commutative_square\n   (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n   (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0))\n   (e1 \\<cdot> f') (e0 \\<cdot> f') \\<Longrightarrow>\n  \\<exists>!l.\n     prj1 (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n      (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot>\n     l =\n     e1 \\<cdot> f' \\<and>\n     prj0 (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n      (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0)) \\<cdot>\n     l =\n     e0 \\<cdot> f'\n  e0 =\n  prj0 (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n   (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0))\n  e1 =\n  prj1 (ECC.prod f1 (local.dom f1) \\<cdot> ECC.dup (local.dom f1))\n   (ECC.prod f0 (local.dom f0) \\<cdot> ECC.dup (local.dom f0))\n\ngoal (1 subgoal):\n 1. f' = f", "by (metis (no_types, lifting))"], ["proof (state)\nthis:\n  f' = f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f' = f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!f.\n     \\<guillemotleft>f : a' \\<rightarrow> local.dom\n     e0\\<guillemotright> \\<and>\n     D.cones_map f (D.mkCone e0) = \\<chi>'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  D.cone ?a'4 ?\\<chi>'4 \\<Longrightarrow>\n  \\<exists>!f.\n     \\<guillemotleft>f : ?a'4 \\<rightarrow> local.dom\n       e0\\<guillemotright> \\<and>\n     D.cones_map f (D.mkCone e0) = ?\\<chi>'4\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\ngoal (1 subgoal):\n 1. has_as_equalizer f0 f1 ?e", "show \"has_as_equalizer f0 f1 e0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_as_equalizer f0 f1 e0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. has_as_equalizer f0 f1 e0", "have \"par f0 f1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. par f0 f1", "by fact"], ["proof (state)\nthis:\n  par f0 f1\n\ngoal (1 subgoal):\n 1. has_as_equalizer f0 f1 e0", "moreover"], ["proof (state)\nthis:\n  par f0 f1\n\ngoal (1 subgoal):\n 1. has_as_equalizer f0 f1 e0", "have \"D.has_as_equalizer e0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D.has_as_equalizer e0", ".."], ["proof (state)\nthis:\n  D.has_as_equalizer e0\n\ngoal (1 subgoal):\n 1. has_as_equalizer f0 f1 e0", "ultimately"], ["proof (chain)\npicking this:\n  par f0 f1\n  D.has_as_equalizer e0", "show ?thesis"], ["proof (prove)\nusing this:\n  par f0 f1\n  D.has_as_equalizer e0\n\ngoal (1 subgoal):\n 1. has_as_equalizer f0 f1 e0", "using has_as_equalizer_def"], ["proof (prove)\nusing this:\n  par f0 f1\n  D.has_as_equalizer e0\n  has_as_equalizer ?f0.0 ?f1.0 ?e \\<equiv>\n  par ?f0.0 ?f1.0 \\<and>\n  limit_cone (\\<cdot>\\<^sub>J) (\\<cdot>)\n   (parallel_pair_diagram.map (\\<cdot>) ?f0.0 ?f1.0) (local.dom ?e)\n   (parallel_pair_diagram.mkCone (\\<cdot>) ?f0.0 ?e)\n\ngoal (1 subgoal):\n 1. has_as_equalizer f0 f1 e0", "by blast"], ["proof (state)\nthis:\n  has_as_equalizer f0 f1 e0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  has_as_equalizer f0 f1 e0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>e. has_as_equalizer f0 f1 e\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation category_with_finite_products C"], ["proof (prove)\ngoal (1 subgoal):\n 1. category_with_finite_products (\\<cdot>)", "by (simp add: ECC.is_cartesian_category cartesian_category.is_category_with_finite_products)"], ["", "lemma has_finite_products:\n    shows \"category_with_finite_products C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. category_with_finite_products (\\<cdot>)", ".."], ["", "lemma has_finite_limits:\n    shows \"category_with_finite_limits C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. category_with_finite_limits (\\<cdot>)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>J.\n       \\<lbrakk>category J; finite (Collect (partial_magma.arr J))\\<rbrakk>\n       \\<Longrightarrow> has_limits_of_shape J", "fix J :: \"nat comp\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>J.\n       \\<lbrakk>category J; finite (Collect (partial_magma.arr J))\\<rbrakk>\n       \\<Longrightarrow> has_limits_of_shape J", "assume J: \"category J\""], ["proof (state)\nthis:\n  category J\n\ngoal (1 subgoal):\n 1. \\<And>J.\n       \\<lbrakk>category J; finite (Collect (partial_magma.arr J))\\<rbrakk>\n       \\<Longrightarrow> has_limits_of_shape J", "interpret J: category J"], ["proof (prove)\ngoal (1 subgoal):\n 1. category J", "using J"], ["proof (prove)\nusing this:\n  category J\n\ngoal (1 subgoal):\n 1. category J", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>J.\n       \\<lbrakk>category J; finite (Collect (partial_magma.arr J))\\<rbrakk>\n       \\<Longrightarrow> has_limits_of_shape J", "assume finite: \"finite (Collect J.arr)\""], ["proof (state)\nthis:\n  finite (Collect J.arr)\n\ngoal (1 subgoal):\n 1. \\<And>J.\n       \\<lbrakk>category J; finite (Collect (partial_magma.arr J))\\<rbrakk>\n       \\<Longrightarrow> has_limits_of_shape J", "show \"has_limits_of_shape J\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_limits_of_shape J", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. has_limits_of_shape J", "have \"Collect (partial_magma.ide J) \\<subseteq> Collect J.arr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Collect J.ide \\<subseteq> Collect J.arr", "by auto"], ["proof (state)\nthis:\n  Collect J.ide \\<subseteq> Collect J.arr\n\ngoal (1 subgoal):\n 1. has_limits_of_shape J", "hence 1: \"finite (Collect J.ide)\""], ["proof (prove)\nusing this:\n  Collect J.ide \\<subseteq> Collect J.arr\n\ngoal (1 subgoal):\n 1. finite (Collect J.ide)", "using finite finite_subset"], ["proof (prove)\nusing this:\n  Collect J.ide \\<subseteq> Collect J.arr\n  finite (Collect J.arr)\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. finite (Collect J.ide)", "by blast"], ["proof (state)\nthis:\n  finite (Collect J.ide)\n\ngoal (1 subgoal):\n 1. has_limits_of_shape J", "have \"has_products (Collect (partial_magma.ide J))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_products (Collect J.ide)", "using 1 J.ideD(1) J.not_arr_null category_with_finite_products.has_finite_products\n                is_category_with_finite_products"], ["proof (prove)\nusing this:\n  finite (Collect J.ide)\n  J.ide ?a \\<Longrightarrow> J.arr ?a\n  \\<not> J.arr J.null\n  \\<lbrakk>category_with_finite_products ?C; finite ?I\\<rbrakk>\n  \\<Longrightarrow> category.has_products ?C ?I\n  category_with_finite_products (\\<cdot>)\n\ngoal (1 subgoal):\n 1. has_products (Collect J.ide)", "by simp"], ["proof (state)\nthis:\n  has_products (Collect J.ide)\n\ngoal (1 subgoal):\n 1. has_limits_of_shape J", "moreover"], ["proof (state)\nthis:\n  has_products (Collect J.ide)\n\ngoal (1 subgoal):\n 1. has_limits_of_shape J", "have \"Collect (partial_magma.ide J) \\<noteq> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Collect J.ide \\<noteq> UNIV", "using J.not_arr_null"], ["proof (prove)\nusing this:\n  \\<not> J.arr J.null\n\ngoal (1 subgoal):\n 1. Collect J.ide \\<noteq> UNIV", "by blast"], ["proof (state)\nthis:\n  Collect J.ide \\<noteq> UNIV\n\ngoal (1 subgoal):\n 1. has_limits_of_shape J", "moreover"], ["proof (state)\nthis:\n  Collect J.ide \\<noteq> UNIV\n\ngoal (1 subgoal):\n 1. has_limits_of_shape J", "have \"Collect (partial_magma.arr J) \\<noteq> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Collect J.arr \\<noteq> UNIV", "using J.not_arr_null"], ["proof (prove)\nusing this:\n  \\<not> J.arr J.null\n\ngoal (1 subgoal):\n 1. Collect J.arr \\<noteq> UNIV", "by blast"], ["proof (state)\nthis:\n  Collect J.arr \\<noteq> UNIV\n\ngoal (1 subgoal):\n 1. has_limits_of_shape J", "ultimately"], ["proof (chain)\npicking this:\n  has_products (Collect J.ide)\n  Collect J.ide \\<noteq> UNIV\n  Collect J.arr \\<noteq> UNIV", "show ?thesis"], ["proof (prove)\nusing this:\n  has_products (Collect J.ide)\n  Collect J.ide \\<noteq> UNIV\n  Collect J.arr \\<noteq> UNIV\n\ngoal (1 subgoal):\n 1. has_limits_of_shape J", "using finite 1 J.category_axioms has_limits_if_has_products\n                has_finite_products' [of \"Collect J.ide\"]\n                has_finite_products' [of \"Collect J.arr\"]"], ["proof (prove)\nusing this:\n  has_products (Collect J.ide)\n  Collect J.ide \\<noteq> UNIV\n  Collect J.arr \\<noteq> UNIV\n  finite (Collect J.arr)\n  finite (Collect J.ide)\n  category J\n  \\<lbrakk>category ?J; has_products (Collect (partial_magma.ide ?J));\n   has_products (Collect (partial_magma.arr ?J))\\<rbrakk>\n  \\<Longrightarrow> has_limits_of_shape ?J\n  \\<lbrakk>Collect J.ide \\<noteq> UNIV; finite (Collect J.ide)\\<rbrakk>\n  \\<Longrightarrow> has_products (Collect J.ide)\n  \\<lbrakk>Collect J.arr \\<noteq> UNIV; finite (Collect J.arr)\\<rbrakk>\n  \\<Longrightarrow> has_products (Collect J.arr)\n\ngoal (1 subgoal):\n 1. has_limits_of_shape J", "by simp"], ["proof (state)\nthis:\n  has_limits_of_shape J\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  has_limits_of_shape J\n\ngoal:\nNo subgoals!", "qed"], ["", "sublocale category_with_finite_limits C"], ["proof (prove)\ngoal (1 subgoal):\n 1. category_with_finite_limits (\\<cdot>)", "using has_finite_limits"], ["proof (prove)\nusing this:\n  category_with_finite_limits (\\<cdot>)\n\ngoal (1 subgoal):\n 1. category_with_finite_limits (\\<cdot>)", "by simp"], ["", "end"], ["", "end"]]}