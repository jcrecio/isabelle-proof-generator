{"file_name": "/home/qj213/afp-2021-10-22/thys/Category3/HFSetCat.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Category3", "problem_names": ["lemma hfunI [intro]:\n  assumes \"F \\<le> A * B\"\n  and \"\\<And>X. X \\<^bold>\\<in> A \\<Longrightarrow> \\<exists>!Y. \\<langle>X, Y\\<rangle> \\<^bold>\\<in> F\"\n  and \"\\<And>X Y. \\<langle>X, Y\\<rangle> \\<^bold>\\<in> F \\<Longrightarrow> Y \\<^bold>\\<in> B\"\n  shows \"hfun A B F\"", "lemma hfunE [elim]:\n  assumes \"hfun B C F\"\n  and \"(\\<And>Y. Y \\<^bold>\\<in> B \\<Longrightarrow> (\\<exists>!Z. \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F) \\<and> (\\<forall>Z. \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F \\<longrightarrow> Z \\<^bold>\\<in> C)) \\<Longrightarrow> T\"\n  shows T", "lemma hfun_in_hexp:\n  assumes \"hfun B C F\"\n  shows \"F \\<^bold>\\<in> hexp B C\"", "lemma happ_mapsto:\n  assumes \"F \\<^bold>\\<in> hexp B C\" and \"Y \\<^bold>\\<in> B\"\n  shows \"happ F Y \\<^bold>\\<in> C\" and \"happ F Y \\<^bold>\\<in> hrange F\"", "lemma happ_expansion:\n  assumes \"hfun B C F\"\n  shows \"F = \\<lbrace>XY \\<^bold>\\<in> B * C. hsnd XY = happ F (hfst XY)\\<rbrace>\"", "lemma hfun_hlam:\n  assumes \"hfun (A * B) C F\"\n  shows \"hfun A (hexp B C) (hlam A B C F)\"", "lemma happ_hlam:\n  assumes \"X \\<^bold>\\<in> A\" and \"hfun (A * B) C F\"\n  shows \"\\<exists>!G. \\<langle>X, G\\<rangle> \\<^bold>\\<in> hlam A B C F\"\n  and \"happ (hlam A B C F) X = (THE G. \\<langle>X, G\\<rangle> \\<^bold>\\<in> hlam A B C F)\"\n  and \"happ (hlam A B C F) X = \\<lbrace>yz \\<^bold>\\<in> B * C. \\<langle>\\<langle>X, hfst yz\\<rangle>, hsnd yz\\<rangle> \\<^bold>\\<in> F\\<rbrace>\"\n  and \"Y \\<^bold>\\<in> B \\<Longrightarrow> happ (happ (hlam A B C F) X) Y = happ F \\<langle>X, Y\\<rangle>\"", "lemma ide_to_hf_mapsto:\n    shows \"ide_to_hf \\<in> Collect ide \\<rightarrow> UNIV\"", "lemma hf_to_ide_mapsto:\n    shows \"hf_to_ide \\<in> UNIV \\<rightarrow> Collect ide\"", "lemma hf_to_ide_ide_to_hf:\n    assumes \"a \\<in> Collect ide\"\n    shows \"hf_to_ide (ide_to_hf a) = a\"", "lemma ide_to_hf_hf_to_ide:\n    assumes \"x \\<in> UNIV\"\n    shows \"ide_to_hf (hf_to_ide x) = x\"", "lemma bij_betw_ide_hf_set:\n    shows \"bij_betw ide_to_hf (Collect ide) (UNIV :: hf set)\"", "lemma ide_implies_finite_set:\n    assumes \"ide a\"\n    shows \"finite (set a)\" and \"finite (hom unity a)\"", "lemma UP_membI [intro]:\n    assumes \"x \\<^bold>\\<in> ide_to_hf a\"\n    shows \"UP x \\<in> set a\"", "lemma DOWN_membI [intro]:\n    assumes \"ide a\" and \"x \\<in> set a\"\n    shows \"DOWN x \\<^bold>\\<in> ide_to_hf a\"", "lemma hfun_arr_to_hfun:\n    assumes \"arr f\"\n    shows \"hfun (ide_to_hf (dom f)) (ide_to_hf (cod f)) (arr_to_hfun f)\"", "lemma arr_to_hfun_in_hexp:\n    assumes \"arr f\"\n    shows \"arr_to_hfun f \\<^bold>\\<in> hexp (ide_to_hf (dom f)) (ide_to_hf (cod f))\"", "lemma hfun_to_arr_in_hom:\n    assumes \"hfun B C F\"\n    shows \"\\<guillemotleft>hfun_to_arr B C F : hf_to_ide B \\<rightarrow> hf_to_ide C\\<guillemotright>\"", "lemma Fun_char:\n    assumes \"arr f\"\n    shows \"Fun f = restrict (\\<lambda>x. UP (happ (arr_to_hfun f) (DOWN x))) (Dom f)\"", "lemma Fun_hfun_to_arr:\n    assumes \"hfun B C F\"\n    shows \"Fun (hfun_to_arr B C F) = restrict (\\<lambda>x. UP (happ F (DOWN x))) (UP ` hfset B)\"", "lemma UP_img_hfset_ide_to_hf:\n    assumes \"ide a\"\n    shows \"UP ` hfset (ide_to_hf a) = set a\"", "lemma hfun_to_arr_arr_to_hfun:\n    assumes \"arr f\"\n    shows \"hfun_to_arr (ide_to_hf (dom f)) (ide_to_hf (cod f)) (arr_to_hfun f) = f\"", "lemma arr_to_hfun_hfun_to_arr:\n    assumes \"hfun B C F\"\n    shows \"arr_to_hfun (hfun_to_arr B C F) = F\"", "lemma bij_betw_hom_hfun:\n    assumes \"ide a\" and \"ide b\"\n    shows \"bij_betw arr_to_hfun (hom a b) {F. hfun (ide_to_hf a) (ide_to_hf b) F}\"", "lemma hfun_hcomp:\n    assumes \"hfun A B F\" and \"hfun B C G\"\n    shows \"hfun A C (hcomp G F)\"", "lemma arr_to_hfun_comp:\n    assumes \"seq g f\"\n    shows \"arr_to_hfun (comp g f) = hcomp (arr_to_hfun g) (arr_to_hfun f)\"", "lemma hfun_to_arr_hcomp:\n    assumes \"hfun A B F\" and \"hfun B C G\"\n    shows \"hfun_to_arr A C (hcomp G F) = comp (hfun_to_arr B C G) (hfun_to_arr A B F)\"", "lemma ide_prod:\n    assumes \"ide a\" and \"ide b\"\n    shows \"ide (prod a b)\"", "lemma pr1_in_hom [intro]:\n    assumes \"ide a\" and \"ide b\"\n    shows \"\\<guillemotleft>pr1 a b : prod a b \\<rightarrow> a\\<guillemotright>\"", "lemma pr1_simps [simp]:\n    assumes \"ide a\" and \"ide b\"\n    shows \"arr (pr1 a b)\" and \"dom (pr1 a b) = prod a b\" and \"cod (pr1 a b) = a\"", "lemma pr0_in_hom [intro]:\n    assumes \"ide a\" and \"ide b\"\n    shows \"\\<guillemotleft>pr0 a b : prod a b \\<rightarrow> b\\<guillemotright>\"", "lemma pr0_simps [simp]:\n    assumes \"ide a\" and \"ide b\"\n    shows \"arr (pr0 a b)\" and \"dom (pr0 a b) = prod a b\" and \"cod (pr0 a b) = b\"", "lemma UP_tuple_DOWN_membI:\n    assumes \"span f g\" and \"x \\<in> Dom f\"\n    shows \"UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle> \\<in> set (prod (cod f) (cod g))\"", "lemma tuple_in_hom [intro]:\n    assumes \"span f g\"\n    shows \"\\<guillemotleft>tuple f g : dom f \\<rightarrow> prod (cod f) (cod g)\\<guillemotright>\"", "lemma tuple_simps [simp]:\n    assumes \"span f g\"\n    shows \"arr (tuple f g)\" and \"dom (tuple f g) = dom f\"\n    and \"cod (tuple f g) = prod (cod f) (cod g)\"", "lemma Fun_pr1:\n    assumes \"ide a\" and \"ide b\"\n    shows \"Fun (pr1 a b) = restrict (\\<lambda>x. UP (hfst (DOWN x))) (set (prod a b))\"", "lemma Fun_pr0:\n    assumes \"ide a\" and \"ide b\"\n    shows \"Fun (pr0 a b) = restrict (\\<lambda>x. UP (hsnd (DOWN x))) (set (prod a b))\"", "lemma Fun_tuple:\n    assumes \"span f g\"\n    shows \"Fun (tuple f g) = restrict (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>) (Dom f)\"", "lemma pr1_tuple:\n    assumes \"span f g\"\n    shows \"comp (pr1 (cod f) (cod g)) (tuple f g) = f\"", "lemma pr0_tuple:\n    assumes \"span f g\"\n    shows \"comp (pr0 (cod f) (cod g)) (tuple f g) = g\"", "lemma tuple_pr:\n    assumes \"ide a\" and \"ide b\" and \"\\<guillemotleft>h : dom h \\<rightarrow> prod a b\\<guillemotright>\"\n    shows \"tuple (comp (pr1 a b) h) (comp (pr0 a b) h) = h\"", "lemma prod_ide_eq:\n    assumes \"ide a\" and \"ide b\"\n    shows \"prod a b = HF'.prod a b\"", "lemma tuple_span_eq:\n    assumes \"span f g\"\n    shows \"tuple f g = HF'.tuple f g\"", "lemma ide_exp:\n    assumes \"ide b\" and \"ide c\"\n    shows \"ide (exp b c)\"", "lemma hfset_ide_to_hf:\n    assumes \"ide a\"\n    shows \"hfset (ide_to_hf a) = DOWN ` set a\"", "lemma eval_in_hom [intro]:\n    assumes \"ide b\" and \"ide c\"\n    shows \"in_hom (eval b c) (HF'.prod (exp b c) b) c\"", "lemma eval_simps [simp]:\n    assumes \"ide b\" and \"ide c\"\n    shows \"arr (eval b c)\"\n    and \"dom (eval b c) = HF'.prod (exp b c) b\"\n    and \"cod (eval b c) = c\"", "lemma hlam_arr_to_hfun_in_hexp:\n    assumes \"ide a\" and \"ide b\" and \"ide c\"\n    and \"in_hom f (prod a b) c\"\n    shows \"hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun f)\n             \\<^bold>\\<in> hexp (ide_to_hf a) (ide_to_hf (exp b c))\"", "lemma lam_in_hom [intro]:\n    assumes \"ide a\" and \"ide b\" and \"ide c\"\n    and \"in_hom f (prod a b) c\"\n    shows \"in_hom (\\<Lambda> a b c f) a (exp b c)\"", "lemma lam_simps [simp]:\n    assumes \"ide a\" and \"ide b\" and \"ide c\"\n    and \"in_hom f (prod a b) c\"\n    shows \"arr (\\<Lambda> a b c f)\"\n    and \"dom (\\<Lambda> a b c f) = a\"\n    and \"cod (\\<Lambda> a b c f) = exp b c\"", "lemma Fun_lam:\n    assumes \"ide a\" and \"ide b\" and \"ide c\"\n    and \"in_hom f (prod a b) c\"\n    shows \"Fun (\\<Lambda> a b c f) =\n           restrict (\\<lambda>x. UP (happ (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun f))\n                                  (DOWN x)))\n                    (set a)\"", "lemma Fun_eval:\n    assumes \"ide b\" and \"ide c\"\n    shows \"Fun (eval b c) = restrict (\\<lambda>x. UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))\n                                     (set (HF'.prod (exp b c) b))\"", "lemma Fun_prod:\n    assumes \"arr f\" and \"arr g\" and \"x \\<in> set (prod (dom f) (dom g))\"\n    shows \"Fun (HF'.prod f g) x = UP \\<langle>DOWN (Fun f (UP (hfst (DOWN x)))),\n                                     DOWN (Fun g (UP (hsnd (DOWN x))))\\<rangle>\"", "lemma prod_in_terms_of_tuple:\n    assumes \"arr f\" and \"arr g\"\n    shows \"HF'.prod f g =\n           tuple (comp f (pr1 (dom f) (dom g))) (comp g (pr0 (dom f) (dom g)))\"", "lemma eval_prod_lam:\n    assumes \"ide a\" and \"ide b\" and \"ide c\"\n    and \"in_hom g (prod a b) c\"\n    shows \"comp (eval b c) (HF'.prod (\\<Lambda> a b c g) b) = g\"", "lemma lam_eval_prod:\n    assumes \"ide a\" and \"ide b\" and \"ide c\"\n    and \"in_hom h a (exp b c)\"\n    shows \"\\<Lambda> a b c (comp (eval b c) (HF'.prod h b)) = h\"", "theorem is_cartesian_closed_category:\n    shows \"cartesian_closed_category comp\"", "theorem is_category_with_finite_limits:\n    shows \"category_with_finite_limits comp\""], "translations": [["", "lemma hfunI [intro]:\n  assumes \"F \\<le> A * B\"\n  and \"\\<And>X. X \\<^bold>\\<in> A \\<Longrightarrow> \\<exists>!Y. \\<langle>X, Y\\<rangle> \\<^bold>\\<in> F\"\n  and \"\\<And>X Y. \\<langle>X, Y\\<rangle> \\<^bold>\\<in> F \\<Longrightarrow> Y \\<^bold>\\<in> B\"\n  shows \"hfun A B F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hfun A B F", "unfolding hfun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<le> A * B \\<and>\n    hfunction F \\<and> hdomain F = A \\<and> hrange F \\<le> B", "using assms hfunction_def hrelation_def is_hpair_def hrange_def hconverse_def hdomain_def"], ["proof (prove)\nusing this:\n  F \\<le> A * B\n  ?X \\<^bold>\\<in> A \\<Longrightarrow>\n  \\<exists>!Y. \\<langle>?X, Y\\<rangle> \\<^bold>\\<in> F\n  \\<langle>?X, ?Y\\<rangle> \\<^bold>\\<in> F \\<Longrightarrow>\n  ?Y \\<^bold>\\<in> B\n  hfunction ?r =\n  (\\<forall>x y.\n      \\<langle>x, y\\<rangle> \\<^bold>\\<in> ?r \\<longrightarrow>\n      (\\<forall>y'.\n          \\<langle>x, y'\\<rangle> \\<^bold>\\<in> ?r \\<longrightarrow>\n          y = y'))\n  hrelation ?r =\n  (\\<forall>z. z \\<^bold>\\<in> ?r \\<longrightarrow> is_hpair z)\n  is_hpair ?z = (\\<exists>x y. ?z = \\<langle>x, y\\<rangle>)\n  hrange ?r = hdomain (hconverse ?r)\n  hconverse ?r =\n  \\<lbrace>z .\n   w \\<^bold>\\<in> ?r, \\<exists>x y.\n                          w = \\<langle>x, y\\<rangle> \\<and>\n                          z = \\<langle>y, x\\<rangle>\\<rbrace>\n  hdomain ?r =\n  \\<lbrace>x .\n   w \\<^bold>\\<in> ?r, \\<exists>y. w = \\<langle>x, y\\<rangle>\\<rbrace>\n\ngoal (1 subgoal):\n 1. F \\<le> A * B \\<and>\n    hfunction F \\<and> hdomain F = A \\<and> hrange F \\<le> B", "apply (intro conjI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>F \\<le> A * B;\n     \\<And>X.\n        X \\<^bold>\\<in> A \\<Longrightarrow>\n        \\<exists>!Y. \\<langle>X, Y\\<rangle> \\<^bold>\\<in> F;\n     \\<And>X Y.\n        \\<langle>X, Y\\<rangle> \\<^bold>\\<in> F \\<Longrightarrow>\n        Y \\<^bold>\\<in> B;\n     \\<And>r.\n        hfunction r =\n        (\\<forall>x y.\n            \\<langle>x, y\\<rangle> \\<^bold>\\<in> r \\<longrightarrow>\n            (\\<forall>y'.\n                \\<langle>x, y'\\<rangle> \\<^bold>\\<in> r \\<longrightarrow>\n                y = y'));\n     \\<And>r.\n        hrelation r =\n        (\\<forall>z. z \\<^bold>\\<in> r \\<longrightarrow> is_hpair z);\n     \\<And>z. is_hpair z = (\\<exists>x y. z = \\<langle>x, y\\<rangle>);\n     \\<And>r. hrange r = hdomain (hconverse r);\n     \\<And>r.\n        hconverse r =\n        \\<lbrace>z .\n         w \\<^bold>\\<in> r, \\<exists>x y.\n                               w = \\<langle>x, y\\<rangle> \\<and>\n                               z = \\<langle>y, x\\<rangle>\\<rbrace>;\n     \\<And>r.\n        hdomain r =\n        \\<lbrace>x .\n         w \\<^bold>\\<in> r, \\<exists>y.\n                               w = \\<langle>x, y\\<rangle>\\<rbrace>\\<rbrakk>\n    \\<Longrightarrow> F \\<le> A * B\n 2. \\<lbrakk>F \\<le> A * B;\n     \\<And>X.\n        X \\<^bold>\\<in> A \\<Longrightarrow>\n        \\<exists>!Y. \\<langle>X, Y\\<rangle> \\<^bold>\\<in> F;\n     \\<And>X Y.\n        \\<langle>X, Y\\<rangle> \\<^bold>\\<in> F \\<Longrightarrow>\n        Y \\<^bold>\\<in> B;\n     \\<And>r.\n        hfunction r =\n        (\\<forall>x y.\n            \\<langle>x, y\\<rangle> \\<^bold>\\<in> r \\<longrightarrow>\n            (\\<forall>y'.\n                \\<langle>x, y'\\<rangle> \\<^bold>\\<in> r \\<longrightarrow>\n                y = y'));\n     \\<And>r.\n        hrelation r =\n        (\\<forall>z. z \\<^bold>\\<in> r \\<longrightarrow> is_hpair z);\n     \\<And>z. is_hpair z = (\\<exists>x y. z = \\<langle>x, y\\<rangle>);\n     \\<And>r. hrange r = hdomain (hconverse r);\n     \\<And>r.\n        hconverse r =\n        \\<lbrace>z .\n         w \\<^bold>\\<in> r, \\<exists>x y.\n                               w = \\<langle>x, y\\<rangle> \\<and>\n                               z = \\<langle>y, x\\<rangle>\\<rbrace>;\n     \\<And>r.\n        hdomain r =\n        \\<lbrace>x .\n         w \\<^bold>\\<in> r, \\<exists>y.\n                               w = \\<langle>x, y\\<rangle>\\<rbrace>\\<rbrakk>\n    \\<Longrightarrow> hfunction F\n 3. \\<lbrakk>F \\<le> A * B;\n     \\<And>X.\n        X \\<^bold>\\<in> A \\<Longrightarrow>\n        \\<exists>!Y. \\<langle>X, Y\\<rangle> \\<^bold>\\<in> F;\n     \\<And>X Y.\n        \\<langle>X, Y\\<rangle> \\<^bold>\\<in> F \\<Longrightarrow>\n        Y \\<^bold>\\<in> B;\n     \\<And>r.\n        hfunction r =\n        (\\<forall>x y.\n            \\<langle>x, y\\<rangle> \\<^bold>\\<in> r \\<longrightarrow>\n            (\\<forall>y'.\n                \\<langle>x, y'\\<rangle> \\<^bold>\\<in> r \\<longrightarrow>\n                y = y'));\n     \\<And>r.\n        hrelation r =\n        (\\<forall>z. z \\<^bold>\\<in> r \\<longrightarrow> is_hpair z);\n     \\<And>z. is_hpair z = (\\<exists>x y. z = \\<langle>x, y\\<rangle>);\n     \\<And>r. hrange r = hdomain (hconverse r);\n     \\<And>r.\n        hconverse r =\n        \\<lbrace>z .\n         w \\<^bold>\\<in> r, \\<exists>x y.\n                               w = \\<langle>x, y\\<rangle> \\<and>\n                               z = \\<langle>y, x\\<rangle>\\<rbrace>;\n     \\<And>r.\n        hdomain r =\n        \\<lbrace>x .\n         w \\<^bold>\\<in> r, \\<exists>y.\n                               w = \\<langle>x, y\\<rangle>\\<rbrace>\\<rbrakk>\n    \\<Longrightarrow> hdomain F = A\n 4. \\<lbrakk>F \\<le> A * B;\n     \\<And>X.\n        X \\<^bold>\\<in> A \\<Longrightarrow>\n        \\<exists>!Y. \\<langle>X, Y\\<rangle> \\<^bold>\\<in> F;\n     \\<And>X Y.\n        \\<langle>X, Y\\<rangle> \\<^bold>\\<in> F \\<Longrightarrow>\n        Y \\<^bold>\\<in> B;\n     \\<And>r.\n        hfunction r =\n        (\\<forall>x y.\n            \\<langle>x, y\\<rangle> \\<^bold>\\<in> r \\<longrightarrow>\n            (\\<forall>y'.\n                \\<langle>x, y'\\<rangle> \\<^bold>\\<in> r \\<longrightarrow>\n                y = y'));\n     \\<And>r.\n        hrelation r =\n        (\\<forall>z. z \\<^bold>\\<in> r \\<longrightarrow> is_hpair z);\n     \\<And>z. is_hpair z = (\\<exists>x y. z = \\<langle>x, y\\<rangle>);\n     \\<And>r. hrange r = hdomain (hconverse r);\n     \\<And>r.\n        hconverse r =\n        \\<lbrace>z .\n         w \\<^bold>\\<in> r, \\<exists>x y.\n                               w = \\<langle>x, y\\<rangle> \\<and>\n                               z = \\<langle>y, x\\<rangle>\\<rbrace>;\n     \\<And>r.\n        hdomain r =\n        \\<lbrace>x .\n         w \\<^bold>\\<in> r, \\<exists>y.\n                               w = \\<langle>x, y\\<rangle>\\<rbrace>\\<rbrakk>\n    \\<Longrightarrow> hrange F \\<le> B", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>F \\<le> A * B;\n     \\<And>X.\n        X \\<^bold>\\<in> A \\<Longrightarrow>\n        \\<exists>!Y. \\<langle>X, Y\\<rangle> \\<^bold>\\<in> F;\n     \\<And>X Y.\n        \\<langle>X, Y\\<rangle> \\<^bold>\\<in> F \\<Longrightarrow>\n        Y \\<^bold>\\<in> B;\n     \\<And>r.\n        hfunction r =\n        (\\<forall>x y.\n            \\<langle>x, y\\<rangle> \\<^bold>\\<in> r \\<longrightarrow>\n            (\\<forall>y'.\n                \\<langle>x, y'\\<rangle> \\<^bold>\\<in> r \\<longrightarrow>\n                y = y'));\n     \\<And>r.\n        hrelation r =\n        (\\<forall>z.\n            z \\<^bold>\\<in> r \\<longrightarrow>\n            (\\<exists>x y. z = \\<langle>x, y\\<rangle>));\n     \\<And>z. is_hpair z = (\\<exists>x y. z = \\<langle>x, y\\<rangle>);\n     \\<And>r.\n        hrange r =\n        \\<lbrace>x .\n         w \\<^bold>\\<in> \\<lbrace>z .\n                          w \\<^bold>\\<in> r, \\<exists>x y.\n          w = \\<langle>x, y\\<rangle> \\<and>\n          z =\n          \\<langle>y, x\\<rangle>\\<rbrace>, \\<exists>y.\n        w = \\<langle>x, y\\<rangle>\\<rbrace>;\n     \\<And>r.\n        hconverse r =\n        \\<lbrace>z .\n         w \\<^bold>\\<in> r, \\<exists>x y.\n                               w = \\<langle>x, y\\<rangle> \\<and>\n                               z = \\<langle>y, x\\<rangle>\\<rbrace>;\n     \\<And>r.\n        hdomain r =\n        \\<lbrace>x .\n         w \\<^bold>\\<in> r, \\<exists>y.\n                               w = \\<langle>x, y\\<rangle>\\<rbrace>\\<rbrakk>\n    \\<Longrightarrow> \\<lbrace>x .\n                       w \\<^bold>\\<in> F, \\<exists>y.\n       w = \\<langle>x, y\\<rangle>\\<rbrace> =\n                      A", "by fast"], ["", "lemma hfunE [elim]:\n  assumes \"hfun B C F\"\n  and \"(\\<And>Y. Y \\<^bold>\\<in> B \\<Longrightarrow> (\\<exists>!Z. \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F) \\<and> (\\<forall>Z. \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F \\<longrightarrow> Z \\<^bold>\\<in> C)) \\<Longrightarrow> T\"\n  shows T"], ["proof (prove)\ngoal (1 subgoal):\n 1. T", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. T", "have \"\\<And>Y. Y \\<^bold>\\<in> B \\<Longrightarrow> (\\<exists>!Z. \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F) \\<and> (\\<forall>Z. \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F \\<longrightarrow> Z \\<^bold>\\<in> C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       Y \\<^bold>\\<in> B \\<Longrightarrow>\n       (\\<exists>!Z. \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F) \\<and>\n       (\\<forall>Z.\n           \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F \\<longrightarrow>\n           Z \\<^bold>\\<in> C)", "proof (intro allI impI conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Y.\n       Y \\<^bold>\\<in> B \\<Longrightarrow>\n       \\<exists>!Z. \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F\n 2. \\<And>Y Z.\n       \\<lbrakk>Y \\<^bold>\\<in> B;\n        \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F\\<rbrakk>\n       \\<Longrightarrow> Z \\<^bold>\\<in> C", "fix Y"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>Y.\n       Y \\<^bold>\\<in> B \\<Longrightarrow>\n       \\<exists>!Z. \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F\n 2. \\<And>Y Z.\n       \\<lbrakk>Y \\<^bold>\\<in> B;\n        \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F\\<rbrakk>\n       \\<Longrightarrow> Z \\<^bold>\\<in> C", "assume Y: \"Y \\<^bold>\\<in> B\""], ["proof (state)\nthis:\n  Y \\<^bold>\\<in> B\n\ngoal (2 subgoals):\n 1. \\<And>Y.\n       Y \\<^bold>\\<in> B \\<Longrightarrow>\n       \\<exists>!Z. \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F\n 2. \\<And>Y Z.\n       \\<lbrakk>Y \\<^bold>\\<in> B;\n        \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F\\<rbrakk>\n       \\<Longrightarrow> Z \\<^bold>\\<in> C", "show \"\\<exists>!Z. \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!Z. \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!Z. \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F", "have \"\\<exists>Z. \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Z. \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F", "using assms Y hfun_def hdomain_def"], ["proof (prove)\nusing this:\n  hfun B C F\n  (\\<And>Y.\n      Y \\<^bold>\\<in> B \\<Longrightarrow>\n      (\\<exists>!Z. \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F) \\<and>\n      (\\<forall>Z.\n          \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F \\<longrightarrow>\n          Z \\<^bold>\\<in> C)) \\<Longrightarrow>\n  T\n  Y \\<^bold>\\<in> B\n  hfun ?B ?C ?F \\<equiv>\n  ?F \\<le> ?B * ?C \\<and>\n  hfunction ?F \\<and> hdomain ?F = ?B \\<and> hrange ?F \\<le> ?C\n  hdomain ?r =\n  \\<lbrace>x .\n   w \\<^bold>\\<in> ?r, \\<exists>y. w = \\<langle>x, y\\<rangle>\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<exists>Z. \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F", "by auto"], ["proof (state)\nthis:\n  \\<exists>Z. \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F\n\ngoal (1 subgoal):\n 1. \\<exists>!Z. \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F", "moreover"], ["proof (state)\nthis:\n  \\<exists>Z. \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F\n\ngoal (1 subgoal):\n 1. \\<exists>!Z. \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F", "have \"\\<And>Z Z'. \\<lbrakk> \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F; \\<langle>Y, Z'\\<rangle> \\<^bold>\\<in> F \\<rbrakk> \\<Longrightarrow> Z = Z'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Z Z'.\n       \\<lbrakk>\\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F;\n        \\<langle>Y, Z'\\<rangle> \\<^bold>\\<in> F\\<rbrakk>\n       \\<Longrightarrow> Z = Z'", "using assms hfun_def hfunction_def"], ["proof (prove)\nusing this:\n  hfun B C F\n  (\\<And>Y.\n      Y \\<^bold>\\<in> B \\<Longrightarrow>\n      (\\<exists>!Z. \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F) \\<and>\n      (\\<forall>Z.\n          \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F \\<longrightarrow>\n          Z \\<^bold>\\<in> C)) \\<Longrightarrow>\n  T\n  hfun ?B ?C ?F \\<equiv>\n  ?F \\<le> ?B * ?C \\<and>\n  hfunction ?F \\<and> hdomain ?F = ?B \\<and> hrange ?F \\<le> ?C\n  hfunction ?r =\n  (\\<forall>x y.\n      \\<langle>x, y\\<rangle> \\<^bold>\\<in> ?r \\<longrightarrow>\n      (\\<forall>y'.\n          \\<langle>x, y'\\<rangle> \\<^bold>\\<in> ?r \\<longrightarrow>\n          y = y'))\n\ngoal (1 subgoal):\n 1. \\<And>Z Z'.\n       \\<lbrakk>\\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F;\n        \\<langle>Y, Z'\\<rangle> \\<^bold>\\<in> F\\<rbrakk>\n       \\<Longrightarrow> Z = Z'", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>\\<langle>Y, ?Z\\<rangle> \\<^bold>\\<in> F;\n   \\<langle>Y, ?Z'\\<rangle> \\<^bold>\\<in> F\\<rbrakk>\n  \\<Longrightarrow> ?Z = ?Z'\n\ngoal (1 subgoal):\n 1. \\<exists>!Z. \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>Z. \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F\n  \\<lbrakk>\\<langle>Y, ?Z\\<rangle> \\<^bold>\\<in> F;\n   \\<langle>Y, ?Z'\\<rangle> \\<^bold>\\<in> F\\<rbrakk>\n  \\<Longrightarrow> ?Z = ?Z'", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>Z. \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F\n  \\<lbrakk>\\<langle>Y, ?Z\\<rangle> \\<^bold>\\<in> F;\n   \\<langle>Y, ?Z'\\<rangle> \\<^bold>\\<in> F\\<rbrakk>\n  \\<Longrightarrow> ?Z = ?Z'\n\ngoal (1 subgoal):\n 1. \\<exists>!Z. \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F", "by blast"], ["proof (state)\nthis:\n  \\<exists>!Z. \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!Z. \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F\n\ngoal (1 subgoal):\n 1. \\<And>Y Z.\n       \\<lbrakk>Y \\<^bold>\\<in> B;\n        \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F\\<rbrakk>\n       \\<Longrightarrow> Z \\<^bold>\\<in> C", "show \"\\<And>Z. \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F \\<Longrightarrow> Z \\<^bold>\\<in> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Z.\n       \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F \\<Longrightarrow>\n       Z \\<^bold>\\<in> C", "using assms Y hfun_def"], ["proof (prove)\nusing this:\n  hfun B C F\n  (\\<And>Y.\n      Y \\<^bold>\\<in> B \\<Longrightarrow>\n      (\\<exists>!Z. \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F) \\<and>\n      (\\<forall>Z.\n          \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F \\<longrightarrow>\n          Z \\<^bold>\\<in> C)) \\<Longrightarrow>\n  T\n  Y \\<^bold>\\<in> B\n  hfun ?B ?C ?F \\<equiv>\n  ?F \\<le> ?B * ?C \\<and>\n  hfunction ?F \\<and> hdomain ?F = ?B \\<and> hrange ?F \\<le> ?C\n\ngoal (1 subgoal):\n 1. \\<And>Z.\n       \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F \\<Longrightarrow>\n       Z \\<^bold>\\<in> C", "by auto"], ["proof (state)\nthis:\n  \\<langle>Y, ?Z\\<rangle> \\<^bold>\\<in> F \\<Longrightarrow>\n  ?Z \\<^bold>\\<in> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?Y \\<^bold>\\<in> B \\<Longrightarrow>\n  (\\<exists>!Z. \\<langle>?Y, Z\\<rangle> \\<^bold>\\<in> F) \\<and>\n  (\\<forall>Z.\n      \\<langle>?Y, Z\\<rangle> \\<^bold>\\<in> F \\<longrightarrow>\n      Z \\<^bold>\\<in> C)\n\ngoal (1 subgoal):\n 1. T", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?Y \\<^bold>\\<in> B \\<Longrightarrow>\n  (\\<exists>!Z. \\<langle>?Y, Z\\<rangle> \\<^bold>\\<in> F) \\<and>\n  (\\<forall>Z.\n      \\<langle>?Y, Z\\<rangle> \\<^bold>\\<in> F \\<longrightarrow>\n      Z \\<^bold>\\<in> C)\n\ngoal (1 subgoal):\n 1. T", "using assms(2)"], ["proof (prove)\nusing this:\n  ?Y \\<^bold>\\<in> B \\<Longrightarrow>\n  (\\<exists>!Z. \\<langle>?Y, Z\\<rangle> \\<^bold>\\<in> F) \\<and>\n  (\\<forall>Z.\n      \\<langle>?Y, Z\\<rangle> \\<^bold>\\<in> F \\<longrightarrow>\n      Z \\<^bold>\\<in> C)\n  (\\<And>Y.\n      Y \\<^bold>\\<in> B \\<Longrightarrow>\n      (\\<exists>!Z. \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F) \\<and>\n      (\\<forall>Z.\n          \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F \\<longrightarrow>\n          Z \\<^bold>\\<in> C)) \\<Longrightarrow>\n  T\n\ngoal (1 subgoal):\n 1. T", "by simp"], ["proof (state)\nthis:\n  T\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n    The hereditarily finite set \\<open>hexp B C\\<close> represents the collection of all functions\n    from \\<open>B\\<close> to \\<open>C\\<close>.\n  \\<close>"], ["", "definition hexp\n  where \"hexp B C = \\<lbrace>F \\<^bold>\\<in> HPow (B * C). hfun B C F\\<rbrace>\""], ["", "lemma hfun_in_hexp:\n  assumes \"hfun B C F\"\n  shows \"F \\<^bold>\\<in> hexp B C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<^bold>\\<in> hexp B C", "using assms"], ["proof (prove)\nusing this:\n  hfun B C F\n\ngoal (1 subgoal):\n 1. F \\<^bold>\\<in> hexp B C", "by (simp add: hexp_def hfun_def)"], ["", "text\\<open>\n    The function \\<open>happ\\<close> applies a function \\<open>F\\<close> from \\<open>B\\<close> to \\<open>C\\<close> to an element of \\<open>B\\<close>,\n    yielding an element of \\<open>C\\<close>.\n  \\<close>"], ["", "abbreviation happ\n  where \"happ \\<equiv> app\""], ["", "lemma happ_mapsto:\n  assumes \"F \\<^bold>\\<in> hexp B C\" and \"Y \\<^bold>\\<in> B\"\n  shows \"happ F Y \\<^bold>\\<in> C\" and \"happ F Y \\<^bold>\\<in> hrange F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. happ F Y \\<^bold>\\<in> C &&& happ F Y \\<^bold>\\<in> hrange F", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. happ F Y \\<^bold>\\<in> C\n 2. happ F Y \\<^bold>\\<in> hrange F", "show \"happ F Y \\<^bold>\\<in> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. happ F Y \\<^bold>\\<in> C", "using assms app_def hexp_def app_equality hdomain_def hfun_def"], ["proof (prove)\nusing this:\n  F \\<^bold>\\<in> hexp B C\n  Y \\<^bold>\\<in> B\n  happ ?f ?x = (THE y. \\<langle>?x, y\\<rangle> \\<^bold>\\<in> ?f)\n  hexp ?B ?C = HCollect (hfun ?B ?C) (HPow (?B * ?C))\n  \\<lbrakk>hfunction ?f; \\<langle>?x, ?y\\<rangle> \\<^bold>\\<in> ?f\\<rbrakk>\n  \\<Longrightarrow> happ ?f ?x = ?y\n  hdomain ?r =\n  \\<lbrace>x .\n   w \\<^bold>\\<in> ?r, \\<exists>y. w = \\<langle>x, y\\<rangle>\\<rbrace>\n  hfun ?B ?C ?F \\<equiv>\n  ?F \\<le> ?B * ?C \\<and>\n  hfunction ?F \\<and> hdomain ?F = ?B \\<and> hrange ?F \\<le> ?C\n\ngoal (1 subgoal):\n 1. happ F Y \\<^bold>\\<in> C", "by auto"], ["proof (state)\nthis:\n  happ F Y \\<^bold>\\<in> C\n\ngoal (1 subgoal):\n 1. happ F Y \\<^bold>\\<in> hrange F", "show \"happ F Y \\<^bold>\\<in> hrange F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. happ F Y \\<^bold>\\<in> hrange F", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. happ F Y \\<^bold>\\<in> hrange F", "have \"\\<langle>Y, happ F Y\\<rangle> \\<^bold>\\<in> F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Y, happ F Y\\<rangle> \\<^bold>\\<in> F", "using assms app_def hexp_def app_equality hdomain_def hfun_def"], ["proof (prove)\nusing this:\n  F \\<^bold>\\<in> hexp B C\n  Y \\<^bold>\\<in> B\n  happ ?f ?x = (THE y. \\<langle>?x, y\\<rangle> \\<^bold>\\<in> ?f)\n  hexp ?B ?C = HCollect (hfun ?B ?C) (HPow (?B * ?C))\n  \\<lbrakk>hfunction ?f; \\<langle>?x, ?y\\<rangle> \\<^bold>\\<in> ?f\\<rbrakk>\n  \\<Longrightarrow> happ ?f ?x = ?y\n  hdomain ?r =\n  \\<lbrace>x .\n   w \\<^bold>\\<in> ?r, \\<exists>y. w = \\<langle>x, y\\<rangle>\\<rbrace>\n  hfun ?B ?C ?F \\<equiv>\n  ?F \\<le> ?B * ?C \\<and>\n  hfunction ?F \\<and> hdomain ?F = ?B \\<and> hrange ?F \\<le> ?C\n\ngoal (1 subgoal):\n 1. \\<langle>Y, happ F Y\\<rangle> \\<^bold>\\<in> F", "by auto"], ["proof (state)\nthis:\n  \\<langle>Y, happ F Y\\<rangle> \\<^bold>\\<in> F\n\ngoal (1 subgoal):\n 1. happ F Y \\<^bold>\\<in> hrange F", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<langle>Y, happ F Y\\<rangle> \\<^bold>\\<in> F\n\ngoal (1 subgoal):\n 1. happ F Y \\<^bold>\\<in> hrange F", "using hdomain_def hrange_def hconverse_def"], ["proof (prove)\nusing this:\n  \\<langle>Y, happ F Y\\<rangle> \\<^bold>\\<in> F\n  hdomain ?r =\n  \\<lbrace>x .\n   w \\<^bold>\\<in> ?r, \\<exists>y. w = \\<langle>x, y\\<rangle>\\<rbrace>\n  hrange ?r = hdomain (hconverse ?r)\n  hconverse ?r =\n  \\<lbrace>z .\n   w \\<^bold>\\<in> ?r, \\<exists>x y.\n                          w = \\<langle>x, y\\<rangle> \\<and>\n                          z = \\<langle>y, x\\<rangle>\\<rbrace>\n\ngoal (1 subgoal):\n 1. happ F Y \\<^bold>\\<in> hrange F", "by auto"], ["proof (state)\nthis:\n  happ F Y \\<^bold>\\<in> hrange F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  happ F Y \\<^bold>\\<in> hrange F\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma happ_expansion:\n  assumes \"hfun B C F\"\n  shows \"F = \\<lbrace>XY \\<^bold>\\<in> B * C. hsnd XY = happ F (hfst XY)\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F = \\<lbrace>XY \\<^bold>\\<in> B * C. hsnd XY = happ F (hfst XY)\\<rbrace>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<^bold>\\<in> F) =\n       (x \\<^bold>\\<in>\n        \\<lbrace>XY \\<^bold>\\<in> B * C.\n         hsnd XY = happ F (hfst XY)\\<rbrace>)", "fix XY"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<^bold>\\<in> F) =\n       (x \\<^bold>\\<in>\n        \\<lbrace>XY \\<^bold>\\<in> B * C.\n         hsnd XY = happ F (hfst XY)\\<rbrace>)", "show \"XY \\<^bold>\\<in> F \\<longleftrightarrow> XY \\<^bold>\\<in> \\<lbrace>XY \\<^bold>\\<in> B * C. hsnd XY = happ F (hfst XY)\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (XY \\<^bold>\\<in> F) =\n    (XY \\<^bold>\\<in>\n     \\<lbrace>XY \\<^bold>\\<in> B * C. hsnd XY = happ F (hfst XY)\\<rbrace>)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. XY \\<^bold>\\<in> F \\<Longrightarrow>\n    XY \\<^bold>\\<in>\n    \\<lbrace>XY \\<^bold>\\<in> B * C. hsnd XY = happ F (hfst XY)\\<rbrace>\n 2. XY \\<^bold>\\<in>\n    \\<lbrace>XY \\<^bold>\\<in> B * C.\n     hsnd XY = happ F (hfst XY)\\<rbrace> \\<Longrightarrow>\n    XY \\<^bold>\\<in> F", "show \"XY \\<^bold>\\<in> F \\<Longrightarrow> XY \\<^bold>\\<in> \\<lbrace>XY \\<^bold>\\<in> B * C. hsnd XY = happ F (hfst XY)\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. XY \\<^bold>\\<in> F \\<Longrightarrow>\n    XY \\<^bold>\\<in>\n    \\<lbrace>XY \\<^bold>\\<in> B * C. hsnd XY = happ F (hfst XY)\\<rbrace>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. XY \\<^bold>\\<in> F \\<Longrightarrow>\n    XY \\<^bold>\\<in>\n    \\<lbrace>XY \\<^bold>\\<in> B * C. hsnd XY = happ F (hfst XY)\\<rbrace>", "assume XY: \"XY \\<^bold>\\<in> F\""], ["proof (state)\nthis:\n  XY \\<^bold>\\<in> F\n\ngoal (1 subgoal):\n 1. XY \\<^bold>\\<in> F \\<Longrightarrow>\n    XY \\<^bold>\\<in>\n    \\<lbrace>XY \\<^bold>\\<in> B * C. hsnd XY = happ F (hfst XY)\\<rbrace>", "have \"XY \\<^bold>\\<in> B * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. XY \\<^bold>\\<in> B * C", "using assms XY hfun_def"], ["proof (prove)\nusing this:\n  hfun B C F\n  XY \\<^bold>\\<in> F\n  hfun ?B ?C ?F \\<equiv>\n  ?F \\<le> ?B * ?C \\<and>\n  hfunction ?F \\<and> hdomain ?F = ?B \\<and> hrange ?F \\<le> ?C\n\ngoal (1 subgoal):\n 1. XY \\<^bold>\\<in> B * C", "by auto"], ["proof (state)\nthis:\n  XY \\<^bold>\\<in> B * C\n\ngoal (1 subgoal):\n 1. XY \\<^bold>\\<in> F \\<Longrightarrow>\n    XY \\<^bold>\\<in>\n    \\<lbrace>XY \\<^bold>\\<in> B * C. hsnd XY = happ F (hfst XY)\\<rbrace>", "moreover"], ["proof (state)\nthis:\n  XY \\<^bold>\\<in> B * C\n\ngoal (1 subgoal):\n 1. XY \\<^bold>\\<in> F \\<Longrightarrow>\n    XY \\<^bold>\\<in>\n    \\<lbrace>XY \\<^bold>\\<in> B * C. hsnd XY = happ F (hfst XY)\\<rbrace>", "have \"hsnd XY = happ F (hfst XY)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hsnd XY = happ F (hfst XY)", "using assms XY hfunE app_def [of F \"hfst XY\"] the1_equality [of \"\\<lambda>y. \\<langle>hfst XY, y\\<rangle> \\<^bold>\\<in> F\"]\n                calculation"], ["proof (prove)\nusing this:\n  hfun B C F\n  XY \\<^bold>\\<in> F\n  \\<lbrakk>hfun ?B ?C ?F;\n   (\\<And>Y.\n       Y \\<^bold>\\<in> ?B \\<Longrightarrow>\n       (\\<exists>!Z. \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> ?F) \\<and>\n       (\\<forall>Z.\n           \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> ?F \\<longrightarrow>\n           Z \\<^bold>\\<in> ?C)) \\<Longrightarrow>\n   ?T\\<rbrakk>\n  \\<Longrightarrow> ?T\n  happ F (hfst XY) = (THE y. \\<langle>hfst XY, y\\<rangle> \\<^bold>\\<in> F)\n  \\<lbrakk>\\<exists>!x. \\<langle>hfst XY, x\\<rangle> \\<^bold>\\<in> F;\n   \\<langle>hfst XY, ?a\\<rangle> \\<^bold>\\<in> F\\<rbrakk>\n  \\<Longrightarrow> (THE x. \\<langle>hfst XY, x\\<rangle> \\<^bold>\\<in> F) =\n                    ?a\n  XY \\<^bold>\\<in> B * C\n\ngoal (1 subgoal):\n 1. hsnd XY = happ F (hfst XY)", "by auto"], ["proof (state)\nthis:\n  hsnd XY = happ F (hfst XY)\n\ngoal (1 subgoal):\n 1. XY \\<^bold>\\<in> F \\<Longrightarrow>\n    XY \\<^bold>\\<in>\n    \\<lbrace>XY \\<^bold>\\<in> B * C. hsnd XY = happ F (hfst XY)\\<rbrace>", "ultimately"], ["proof (chain)\npicking this:\n  XY \\<^bold>\\<in> B * C\n  hsnd XY = happ F (hfst XY)", "show \"XY \\<^bold>\\<in> \\<lbrace>XY \\<^bold>\\<in> B * C. hsnd XY = happ F (hfst XY)\\<rbrace>\""], ["proof (prove)\nusing this:\n  XY \\<^bold>\\<in> B * C\n  hsnd XY = happ F (hfst XY)\n\ngoal (1 subgoal):\n 1. XY \\<^bold>\\<in>\n    \\<lbrace>XY \\<^bold>\\<in> B * C. hsnd XY = happ F (hfst XY)\\<rbrace>", "by simp"], ["proof (state)\nthis:\n  XY \\<^bold>\\<in>\n  \\<lbrace>XY \\<^bold>\\<in> B * C. hsnd XY = happ F (hfst XY)\\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  XY \\<^bold>\\<in> F \\<Longrightarrow>\n  XY \\<^bold>\\<in>\n  \\<lbrace>XY \\<^bold>\\<in> B * C. hsnd XY = happ F (hfst XY)\\<rbrace>\n\ngoal (1 subgoal):\n 1. XY \\<^bold>\\<in>\n    \\<lbrace>XY \\<^bold>\\<in> B * C.\n     hsnd XY = happ F (hfst XY)\\<rbrace> \\<Longrightarrow>\n    XY \\<^bold>\\<in> F", "show \"XY \\<^bold>\\<in> \\<lbrace>XY \\<^bold>\\<in> B * C. hsnd XY = happ F (hfst XY)\\<rbrace> \\<Longrightarrow> XY \\<^bold>\\<in> F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. XY \\<^bold>\\<in>\n    \\<lbrace>XY \\<^bold>\\<in> B * C.\n     hsnd XY = happ F (hfst XY)\\<rbrace> \\<Longrightarrow>\n    XY \\<^bold>\\<in> F", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. XY \\<^bold>\\<in>\n    \\<lbrace>XY \\<^bold>\\<in> B * C.\n     hsnd XY = happ F (hfst XY)\\<rbrace> \\<Longrightarrow>\n    XY \\<^bold>\\<in> F", "assume XY: \"XY \\<^bold>\\<in> \\<lbrace>XY \\<^bold>\\<in> B * C. hsnd XY = happ F (hfst XY)\\<rbrace>\""], ["proof (state)\nthis:\n  XY \\<^bold>\\<in>\n  \\<lbrace>XY \\<^bold>\\<in> B * C. hsnd XY = happ F (hfst XY)\\<rbrace>\n\ngoal (1 subgoal):\n 1. XY \\<^bold>\\<in>\n    \\<lbrace>XY \\<^bold>\\<in> B * C.\n     hsnd XY = happ F (hfst XY)\\<rbrace> \\<Longrightarrow>\n    XY \\<^bold>\\<in> F", "show \"XY \\<^bold>\\<in> F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. XY \\<^bold>\\<in> F", "using assms XY app_def [of F \"hfst XY\"] the1_equality [of \"\\<lambda>y. \\<langle>hfst XY, y\\<rangle> \\<^bold>\\<in> F\"]"], ["proof (prove)\nusing this:\n  hfun B C F\n  XY \\<^bold>\\<in>\n  \\<lbrace>XY \\<^bold>\\<in> B * C. hsnd XY = happ F (hfst XY)\\<rbrace>\n  happ F (hfst XY) = (THE y. \\<langle>hfst XY, y\\<rangle> \\<^bold>\\<in> F)\n  \\<lbrakk>\\<exists>!x. \\<langle>hfst XY, x\\<rangle> \\<^bold>\\<in> F;\n   \\<langle>hfst XY, ?a\\<rangle> \\<^bold>\\<in> F\\<rbrakk>\n  \\<Longrightarrow> (THE x. \\<langle>hfst XY, x\\<rangle> \\<^bold>\\<in> F) =\n                    ?a\n\ngoal (1 subgoal):\n 1. XY \\<^bold>\\<in> F", "by fastforce"], ["proof (state)\nthis:\n  XY \\<^bold>\\<in> F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  XY \\<^bold>\\<in>\n  \\<lbrace>XY \\<^bold>\\<in> B * C.\n   hsnd XY = happ F (hfst XY)\\<rbrace> \\<Longrightarrow>\n  XY \\<^bold>\\<in> F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (XY \\<^bold>\\<in> F) =\n  (XY \\<^bold>\\<in>\n   \\<lbrace>XY \\<^bold>\\<in> B * C. hsnd XY = happ F (hfst XY)\\<rbrace>)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n    Function \\<open>hlam\\<close> takes a function \\<open>F\\<close> from \\<open>A * B\\<close> to \\<open>C\\<close> to a function \\<open>hlam F\\<close>\n    from \\<open>A\\<close> to \\<open>hexp B C\\<close>.\n  \\<close>"], ["", "definition hlam\n  where \"hlam A B C F =\n         \\<lbrace>XG \\<^bold>\\<in> A * hexp B C.\n            \\<forall>YZ. YZ \\<^bold>\\<in> hsnd XG \\<longleftrightarrow> is_hpair YZ \\<and> \\<langle>\\<langle>hfst XG, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in> F\\<rbrace>\""], ["", "lemma hfun_hlam:\n  assumes \"hfun (A * B) C F\"\n  shows \"hfun A (hexp B C) (hlam A B C F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hfun A (hexp B C) (hlam A B C F)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. hlam A B C F \\<le> A * hexp B C\n 2. \\<And>X.\n       X \\<^bold>\\<in> A \\<Longrightarrow>\n       \\<exists>!Y. \\<langle>X, Y\\<rangle> \\<^bold>\\<in> hlam A B C F\n 3. \\<And>X Y.\n       \\<langle>X, Y\\<rangle> \\<^bold>\\<in> hlam A B C F \\<Longrightarrow>\n       Y \\<^bold>\\<in> hexp B C", "show \"hlam A B C F \\<le> A * hexp B C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hlam A B C F \\<le> A * hexp B C", "using assms hlam_def"], ["proof (prove)\nusing this:\n  hfun (A * B) C F\n  hlam ?A ?B ?C ?F =\n  \\<lbrace>XG \\<^bold>\\<in> ?A * hexp ?B ?C.\n   \\<forall>YZ.\n      (YZ \\<^bold>\\<in> hsnd XG) =\n      (is_hpair YZ \\<and>\n       \\<langle>\\<langle>hfst XG, hfst YZ\\<rangle>,\n                hsnd YZ\\<rangle> \\<^bold>\\<in>\n       ?F)\\<rbrace>\n\ngoal (1 subgoal):\n 1. hlam A B C F \\<le> A * hexp B C", "by auto"], ["proof (state)\nthis:\n  hlam A B C F \\<le> A * hexp B C\n\ngoal (2 subgoals):\n 1. \\<And>X.\n       X \\<^bold>\\<in> A \\<Longrightarrow>\n       \\<exists>!Y. \\<langle>X, Y\\<rangle> \\<^bold>\\<in> hlam A B C F\n 2. \\<And>X Y.\n       \\<langle>X, Y\\<rangle> \\<^bold>\\<in> hlam A B C F \\<Longrightarrow>\n       Y \\<^bold>\\<in> hexp B C", "show \"\\<And>X. X \\<^bold>\\<in> A \\<Longrightarrow> \\<exists>!Y. \\<langle>X, Y\\<rangle> \\<^bold>\\<in> hlam A B C F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X.\n       X \\<^bold>\\<in> A \\<Longrightarrow>\n       \\<exists>!Y. \\<langle>X, Y\\<rangle> \\<^bold>\\<in> hlam A B C F", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>X.\n       X \\<^bold>\\<in> A \\<Longrightarrow>\n       \\<langle>X, ?a X\\<rangle> \\<^bold>\\<in> hlam A B C F\n 2. \\<And>X Y.\n       \\<lbrakk>X \\<^bold>\\<in> A;\n        \\<langle>X, Y\\<rangle> \\<^bold>\\<in> hlam A B C F\\<rbrakk>\n       \\<Longrightarrow> Y = ?a X", "fix X"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>X.\n       X \\<^bold>\\<in> A \\<Longrightarrow>\n       \\<langle>X, ?a X\\<rangle> \\<^bold>\\<in> hlam A B C F\n 2. \\<And>X Y.\n       \\<lbrakk>X \\<^bold>\\<in> A;\n        \\<langle>X, Y\\<rangle> \\<^bold>\\<in> hlam A B C F\\<rbrakk>\n       \\<Longrightarrow> Y = ?a X", "assume X: \"X \\<^bold>\\<in> A\""], ["proof (state)\nthis:\n  X \\<^bold>\\<in> A\n\ngoal (2 subgoals):\n 1. \\<And>X.\n       X \\<^bold>\\<in> A \\<Longrightarrow>\n       \\<langle>X, ?a X\\<rangle> \\<^bold>\\<in> hlam A B C F\n 2. \\<And>X Y.\n       \\<lbrakk>X \\<^bold>\\<in> A;\n        \\<langle>X, Y\\<rangle> \\<^bold>\\<in> hlam A B C F\\<rbrakk>\n       \\<Longrightarrow> Y = ?a X", "let ?G = \"\\<lbrace>YZ \\<^bold>\\<in> B * C. \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in> F\\<rbrace>\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>X.\n       X \\<^bold>\\<in> A \\<Longrightarrow>\n       \\<langle>X, ?a X\\<rangle> \\<^bold>\\<in> hlam A B C F\n 2. \\<And>X Y.\n       \\<lbrakk>X \\<^bold>\\<in> A;\n        \\<langle>X, Y\\<rangle> \\<^bold>\\<in> hlam A B C F\\<rbrakk>\n       \\<Longrightarrow> Y = ?a X", "have 1: \"?G \\<^bold>\\<in> hexp B C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>YZ \\<^bold>\\<in> B * C.\n     \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in>\n     F\\<rbrace> \\<^bold>\\<in>\n    hexp B C", "using assms X hexp_def"], ["proof (prove)\nusing this:\n  hfun (A * B) C F\n  X \\<^bold>\\<in> A\n  hexp ?B ?C = HCollect (hfun ?B ?C) (HPow (?B * ?C))\n\ngoal (1 subgoal):\n 1. \\<lbrace>YZ \\<^bold>\\<in> B * C.\n     \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in>\n     F\\<rbrace> \\<^bold>\\<in>\n    hexp B C", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrace>YZ \\<^bold>\\<in> B * C.\n   \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in>\n   F\\<rbrace> \\<^bold>\\<in>\n  hexp B C\n\ngoal (2 subgoals):\n 1. \\<And>X.\n       X \\<^bold>\\<in> A \\<Longrightarrow>\n       \\<langle>X, ?a X\\<rangle> \\<^bold>\\<in> hlam A B C F\n 2. \\<And>X Y.\n       \\<lbrakk>X \\<^bold>\\<in> A;\n        \\<langle>X, Y\\<rangle> \\<^bold>\\<in> hlam A B C F\\<rbrakk>\n       \\<Longrightarrow> Y = ?a X", "show \"\\<langle>X, ?G\\<rangle> \\<^bold>\\<in> hlam A B C F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>X, \\<lbrace>YZ \\<^bold>\\<in> B * C.\n                 \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                          hsnd YZ\\<rangle> \\<^bold>\\<in>\n                 F\\<rbrace>\\<rangle> \\<^bold>\\<in>\n    hlam A B C F", "using assms X 1 is_hpair_def hfun_def hlam_def"], ["proof (prove)\nusing this:\n  hfun (A * B) C F\n  X \\<^bold>\\<in> A\n  \\<lbrace>YZ \\<^bold>\\<in> B * C.\n   \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in>\n   F\\<rbrace> \\<^bold>\\<in>\n  hexp B C\n  is_hpair ?z = (\\<exists>x y. ?z = \\<langle>x, y\\<rangle>)\n  hfun ?B ?C ?F \\<equiv>\n  ?F \\<le> ?B * ?C \\<and>\n  hfunction ?F \\<and> hdomain ?F = ?B \\<and> hrange ?F \\<le> ?C\n  hlam ?A ?B ?C ?F =\n  \\<lbrace>XG \\<^bold>\\<in> ?A * hexp ?B ?C.\n   \\<forall>YZ.\n      (YZ \\<^bold>\\<in> hsnd XG) =\n      (is_hpair YZ \\<and>\n       \\<langle>\\<langle>hfst XG, hfst YZ\\<rangle>,\n                hsnd YZ\\<rangle> \\<^bold>\\<in>\n       ?F)\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<langle>X, \\<lbrace>YZ \\<^bold>\\<in> B * C.\n                 \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                          hsnd YZ\\<rangle> \\<^bold>\\<in>\n                 F\\<rbrace>\\<rangle> \\<^bold>\\<in>\n    hlam A B C F", "by auto"], ["proof (state)\nthis:\n  \\<langle>X, \\<lbrace>YZ \\<^bold>\\<in> B * C.\n               \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                        hsnd YZ\\<rangle> \\<^bold>\\<in>\n               F\\<rbrace>\\<rangle> \\<^bold>\\<in>\n  hlam A B C F\n\ngoal (1 subgoal):\n 1. \\<And>X Y.\n       \\<lbrakk>X \\<^bold>\\<in> A;\n        \\<langle>X, Y\\<rangle> \\<^bold>\\<in> hlam A B C F\\<rbrakk>\n       \\<Longrightarrow> Y =\n                         \\<lbrace>YZ \\<^bold>\\<in> B * C.\n                          \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                                   hsnd YZ\\<rangle> \\<^bold>\\<in>\n                          F\\<rbrace>", "fix Y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X Y.\n       \\<lbrakk>X \\<^bold>\\<in> A;\n        \\<langle>X, Y\\<rangle> \\<^bold>\\<in> hlam A B C F\\<rbrakk>\n       \\<Longrightarrow> Y =\n                         \\<lbrace>YZ \\<^bold>\\<in> B * C.\n                          \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                                   hsnd YZ\\<rangle> \\<^bold>\\<in>\n                          F\\<rbrace>", "assume XY: \"\\<langle>X, Y\\<rangle> \\<^bold>\\<in> hlam A B C F\""], ["proof (state)\nthis:\n  \\<langle>X, Y\\<rangle> \\<^bold>\\<in> hlam A B C F\n\ngoal (1 subgoal):\n 1. \\<And>X Y.\n       \\<lbrakk>X \\<^bold>\\<in> A;\n        \\<langle>X, Y\\<rangle> \\<^bold>\\<in> hlam A B C F\\<rbrakk>\n       \\<Longrightarrow> Y =\n                         \\<lbrace>YZ \\<^bold>\\<in> B * C.\n                          \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                                   hsnd YZ\\<rangle> \\<^bold>\\<in>\n                          F\\<rbrace>", "show \"Y = ?G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y =\n    \\<lbrace>YZ \\<^bold>\\<in> B * C.\n     \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in>\n     F\\<rbrace>", "using assms X XY hlam_def hexp_def"], ["proof (prove)\nusing this:\n  hfun (A * B) C F\n  X \\<^bold>\\<in> A\n  \\<langle>X, Y\\<rangle> \\<^bold>\\<in> hlam A B C F\n  hlam ?A ?B ?C ?F =\n  \\<lbrace>XG \\<^bold>\\<in> ?A * hexp ?B ?C.\n   \\<forall>YZ.\n      (YZ \\<^bold>\\<in> hsnd XG) =\n      (is_hpair YZ \\<and>\n       \\<langle>\\<langle>hfst XG, hfst YZ\\<rangle>,\n                hsnd YZ\\<rangle> \\<^bold>\\<in>\n       ?F)\\<rbrace>\n  hexp ?B ?C = HCollect (hfun ?B ?C) (HPow (?B * ?C))\n\ngoal (1 subgoal):\n 1. Y =\n    \\<lbrace>YZ \\<^bold>\\<in> B * C.\n     \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in>\n     F\\<rbrace>", "by fastforce"], ["proof (state)\nthis:\n  Y =\n  \\<lbrace>YZ \\<^bold>\\<in> B * C.\n   \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in>\n   F\\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?X \\<^bold>\\<in> A \\<Longrightarrow>\n  \\<exists>!Y. \\<langle>?X, Y\\<rangle> \\<^bold>\\<in> hlam A B C F\n\ngoal (1 subgoal):\n 1. \\<And>X Y.\n       \\<langle>X, Y\\<rangle> \\<^bold>\\<in> hlam A B C F \\<Longrightarrow>\n       Y \\<^bold>\\<in> hexp B C", "show \"\\<And>X Y. \\<langle>X, Y\\<rangle> \\<^bold>\\<in> hlam A B C F \\<Longrightarrow> Y \\<^bold>\\<in> hexp B C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X Y.\n       \\<langle>X, Y\\<rangle> \\<^bold>\\<in> hlam A B C F \\<Longrightarrow>\n       Y \\<^bold>\\<in> hexp B C", "using assms hlam_def hexp_def"], ["proof (prove)\nusing this:\n  hfun (A * B) C F\n  hlam ?A ?B ?C ?F =\n  \\<lbrace>XG \\<^bold>\\<in> ?A * hexp ?B ?C.\n   \\<forall>YZ.\n      (YZ \\<^bold>\\<in> hsnd XG) =\n      (is_hpair YZ \\<and>\n       \\<langle>\\<langle>hfst XG, hfst YZ\\<rangle>,\n                hsnd YZ\\<rangle> \\<^bold>\\<in>\n       ?F)\\<rbrace>\n  hexp ?B ?C = HCollect (hfun ?B ?C) (HPow (?B * ?C))\n\ngoal (1 subgoal):\n 1. \\<And>X Y.\n       \\<langle>X, Y\\<rangle> \\<^bold>\\<in> hlam A B C F \\<Longrightarrow>\n       Y \\<^bold>\\<in> hexp B C", "by simp"], ["proof (state)\nthis:\n  \\<langle>?X, ?Y\\<rangle> \\<^bold>\\<in> hlam A B C F \\<Longrightarrow>\n  ?Y \\<^bold>\\<in> hexp B C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma happ_hlam:\n  assumes \"X \\<^bold>\\<in> A\" and \"hfun (A * B) C F\"\n  shows \"\\<exists>!G. \\<langle>X, G\\<rangle> \\<^bold>\\<in> hlam A B C F\"\n  and \"happ (hlam A B C F) X = (THE G. \\<langle>X, G\\<rangle> \\<^bold>\\<in> hlam A B C F)\"\n  and \"happ (hlam A B C F) X = \\<lbrace>yz \\<^bold>\\<in> B * C. \\<langle>\\<langle>X, hfst yz\\<rangle>, hsnd yz\\<rangle> \\<^bold>\\<in> F\\<rbrace>\"\n  and \"Y \\<^bold>\\<in> B \\<Longrightarrow> happ (happ (hlam A B C F) X) Y = happ F \\<langle>X, Y\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>!G. \\<langle>X, G\\<rangle> \\<^bold>\\<in> hlam A B C F &&&\n     happ (hlam A B C F) X =\n     (THE G. \\<langle>X, G\\<rangle> \\<^bold>\\<in> hlam A B C F)) &&&\n    happ (hlam A B C F) X =\n    \\<lbrace>yz \\<^bold>\\<in> B * C.\n     \\<langle>\\<langle>X, hfst yz\\<rangle>, hsnd yz\\<rangle> \\<^bold>\\<in>\n     F\\<rbrace> &&&\n    (Y \\<^bold>\\<in> B \\<Longrightarrow>\n     happ (happ (hlam A B C F) X) Y = happ F \\<langle>X, Y\\<rangle>)", "proof -"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<exists>!G. \\<langle>X, G\\<rangle> \\<^bold>\\<in> hlam A B C F\n 2. happ (hlam A B C F) X =\n    (THE G. \\<langle>X, G\\<rangle> \\<^bold>\\<in> hlam A B C F)\n 3. happ (hlam A B C F) X =\n    \\<lbrace>yz \\<^bold>\\<in> B * C.\n     \\<langle>\\<langle>X, hfst yz\\<rangle>, hsnd yz\\<rangle> \\<^bold>\\<in>\n     F\\<rbrace>\n 4. Y \\<^bold>\\<in> B \\<Longrightarrow>\n    happ (happ (hlam A B C F) X) Y = happ F \\<langle>X, Y\\<rangle>", "show 1: \"\\<exists>!G. \\<langle>X, G\\<rangle> \\<^bold>\\<in> hlam A B C F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!G. \\<langle>X, G\\<rangle> \\<^bold>\\<in> hlam A B C F", "using assms(1,2) hfun_hlam hfunE"], ["proof (prove)\nusing this:\n  X \\<^bold>\\<in> A\n  hfun (A * B) C F\n  hfun (?A * ?B) ?C ?F \\<Longrightarrow>\n  hfun ?A (hexp ?B ?C) (hlam ?A ?B ?C ?F)\n  \\<lbrakk>hfun ?B ?C ?F;\n   (\\<And>Y.\n       Y \\<^bold>\\<in> ?B \\<Longrightarrow>\n       (\\<exists>!Z. \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> ?F) \\<and>\n       (\\<forall>Z.\n           \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> ?F \\<longrightarrow>\n           Z \\<^bold>\\<in> ?C)) \\<Longrightarrow>\n   ?T\\<rbrakk>\n  \\<Longrightarrow> ?T\n\ngoal (1 subgoal):\n 1. \\<exists>!G. \\<langle>X, G\\<rangle> \\<^bold>\\<in> hlam A B C F", "by (metis (full_types))"], ["proof (state)\nthis:\n  \\<exists>!G. \\<langle>X, G\\<rangle> \\<^bold>\\<in> hlam A B C F\n\ngoal (3 subgoals):\n 1. happ (hlam A B C F) X =\n    (THE G. \\<langle>X, G\\<rangle> \\<^bold>\\<in> hlam A B C F)\n 2. happ (hlam A B C F) X =\n    \\<lbrace>yz \\<^bold>\\<in> B * C.\n     \\<langle>\\<langle>X, hfst yz\\<rangle>, hsnd yz\\<rangle> \\<^bold>\\<in>\n     F\\<rbrace>\n 3. Y \\<^bold>\\<in> B \\<Longrightarrow>\n    happ (happ (hlam A B C F) X) Y = happ F \\<langle>X, Y\\<rangle>", "show 2: \"happ (hlam A B C F) X = (THE G. \\<langle>X, G\\<rangle> \\<^bold>\\<in> hlam A B C F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. happ (hlam A B C F) X =\n    (THE G. \\<langle>X, G\\<rangle> \\<^bold>\\<in> hlam A B C F)", "using assms app_def"], ["proof (prove)\nusing this:\n  X \\<^bold>\\<in> A\n  hfun (A * B) C F\n  happ ?f ?x = (THE y. \\<langle>?x, y\\<rangle> \\<^bold>\\<in> ?f)\n\ngoal (1 subgoal):\n 1. happ (hlam A B C F) X =\n    (THE G. \\<langle>X, G\\<rangle> \\<^bold>\\<in> hlam A B C F)", "by simp"], ["proof (state)\nthis:\n  happ (hlam A B C F) X =\n  (THE G. \\<langle>X, G\\<rangle> \\<^bold>\\<in> hlam A B C F)\n\ngoal (2 subgoals):\n 1. happ (hlam A B C F) X =\n    \\<lbrace>yz \\<^bold>\\<in> B * C.\n     \\<langle>\\<langle>X, hfst yz\\<rangle>, hsnd yz\\<rangle> \\<^bold>\\<in>\n     F\\<rbrace>\n 2. Y \\<^bold>\\<in> B \\<Longrightarrow>\n    happ (happ (hlam A B C F) X) Y = happ F \\<langle>X, Y\\<rangle>", "show \"happ (happ (hlam A B C F) X) Y = happ F \\<langle>X, Y\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. happ (happ (hlam A B C F) X) Y = happ F \\<langle>X, Y\\<rangle>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. happ (happ (hlam A B C F) X) Y = happ F \\<langle>X, Y\\<rangle>", "have 3: \"\\<langle>X, happ (hlam A B C F) X\\<rangle> \\<^bold>\\<in> hlam A B C F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>X, happ (hlam A B C F) X\\<rangle> \\<^bold>\\<in> hlam A B C F", "using assms(1) 1 2 theI' [of \"\\<lambda>G. \\<langle>X, G\\<rangle> \\<^bold>\\<in> hlam A B C F\"]"], ["proof (prove)\nusing this:\n  X \\<^bold>\\<in> A\n  \\<exists>!G. \\<langle>X, G\\<rangle> \\<^bold>\\<in> hlam A B C F\n  happ (hlam A B C F) X =\n  (THE G. \\<langle>X, G\\<rangle> \\<^bold>\\<in> hlam A B C F)\n  \\<exists>!x.\n     \\<langle>X, x\\<rangle> \\<^bold>\\<in> hlam A B C F \\<Longrightarrow>\n  \\<langle>X, THE x.\n                 \\<langle>X, x\\<rangle> \\<^bold>\\<in>\n                 hlam A B C F\\<rangle> \\<^bold>\\<in>\n  hlam A B C F\n\ngoal (1 subgoal):\n 1. \\<langle>X, happ (hlam A B C F) X\\<rangle> \\<^bold>\\<in> hlam A B C F", "by simp"], ["proof (state)\nthis:\n  \\<langle>X, happ (hlam A B C F) X\\<rangle> \\<^bold>\\<in> hlam A B C F\n\ngoal (1 subgoal):\n 1. happ (happ (hlam A B C F) X) Y = happ F \\<langle>X, Y\\<rangle>", "hence \"\\<exists>!Z. happ (happ (hlam A B C F) X) = Z\""], ["proof (prove)\nusing this:\n  \\<langle>X, happ (hlam A B C F) X\\<rangle> \\<^bold>\\<in> hlam A B C F\n\ngoal (1 subgoal):\n 1. \\<exists>!Z. happ (happ (hlam A B C F) X) = Z", "by simp"], ["proof (state)\nthis:\n  \\<exists>!Z. happ (happ (hlam A B C F) X) = Z\n\ngoal (1 subgoal):\n 1. happ (happ (hlam A B C F) X) Y = happ F \\<langle>X, Y\\<rangle>", "moreover"], ["proof (state)\nthis:\n  \\<exists>!Z. happ (happ (hlam A B C F) X) = Z\n\ngoal (1 subgoal):\n 1. happ (happ (hlam A B C F) X) Y = happ F \\<langle>X, Y\\<rangle>", "have \"happ (happ (hlam A B C F) X) Y = happ F \\<langle>X, Y\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. happ (happ (hlam A B C F) X) Y = happ F \\<langle>X, Y\\<rangle>", "using assms(1-2) 3 hlam_def is_hpair_def app_def"], ["proof (prove)\nusing this:\n  X \\<^bold>\\<in> A\n  hfun (A * B) C F\n  \\<langle>X, happ (hlam A B C F) X\\<rangle> \\<^bold>\\<in> hlam A B C F\n  hlam ?A ?B ?C ?F =\n  \\<lbrace>XG \\<^bold>\\<in> ?A * hexp ?B ?C.\n   \\<forall>YZ.\n      (YZ \\<^bold>\\<in> hsnd XG) =\n      (is_hpair YZ \\<and>\n       \\<langle>\\<langle>hfst XG, hfst YZ\\<rangle>,\n                hsnd YZ\\<rangle> \\<^bold>\\<in>\n       ?F)\\<rbrace>\n  is_hpair ?z = (\\<exists>x y. ?z = \\<langle>x, y\\<rangle>)\n  happ ?f ?x = (THE y. \\<langle>?x, y\\<rangle> \\<^bold>\\<in> ?f)\n\ngoal (1 subgoal):\n 1. happ (happ (hlam A B C F) X) Y = happ F \\<langle>X, Y\\<rangle>", "by simp"], ["proof (state)\nthis:\n  happ (happ (hlam A B C F) X) Y = happ F \\<langle>X, Y\\<rangle>\n\ngoal (1 subgoal):\n 1. happ (happ (hlam A B C F) X) Y = happ F \\<langle>X, Y\\<rangle>", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>!Z. happ (happ (hlam A B C F) X) = Z\n  happ (happ (hlam A B C F) X) Y = happ F \\<langle>X, Y\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>!Z. happ (happ (hlam A B C F) X) = Z\n  happ (happ (hlam A B C F) X) Y = happ F \\<langle>X, Y\\<rangle>\n\ngoal (1 subgoal):\n 1. happ (happ (hlam A B C F) X) Y = happ F \\<langle>X, Y\\<rangle>", "by simp"], ["proof (state)\nthis:\n  happ (happ (hlam A B C F) X) Y = happ F \\<langle>X, Y\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  happ (happ (hlam A B C F) X) Y = happ F \\<langle>X, Y\\<rangle>\n\ngoal (1 subgoal):\n 1. happ (hlam A B C F) X =\n    \\<lbrace>yz \\<^bold>\\<in> B * C.\n     \\<langle>\\<langle>X, hfst yz\\<rangle>, hsnd yz\\<rangle> \\<^bold>\\<in>\n     F\\<rbrace>", "show \"happ (hlam A B C F) X = \\<lbrace>YZ \\<^bold>\\<in> B * C. \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in> F\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. happ (hlam A B C F) X =\n    \\<lbrace>YZ \\<^bold>\\<in> B * C.\n     \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in>\n     F\\<rbrace>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. happ (hlam A B C F) X =\n    \\<lbrace>YZ \\<^bold>\\<in> B * C.\n     \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in>\n     F\\<rbrace>", "let ?G = \"\\<lbrace>YZ \\<^bold>\\<in> B * C. \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in> F\\<rbrace>\""], ["proof (state)\ngoal (1 subgoal):\n 1. happ (hlam A B C F) X =\n    \\<lbrace>YZ \\<^bold>\\<in> B * C.\n     \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in>\n     F\\<rbrace>", "have 4: \"hfun B C ?G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hfun B C\n     \\<lbrace>YZ \\<^bold>\\<in> B * C.\n      \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in>\n      F\\<rbrace>", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrace>YZ \\<^bold>\\<in> B * C.\n     \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in>\n     F\\<rbrace>\n    \\<le> B * C\n 2. \\<And>Xa.\n       Xa \\<^bold>\\<in> B \\<Longrightarrow>\n       \\<exists>!Y.\n          \\<langle>Xa, Y\\<rangle> \\<^bold>\\<in>\n          \\<lbrace>YZ \\<^bold>\\<in> B * C.\n           \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                    hsnd YZ\\<rangle> \\<^bold>\\<in>\n           F\\<rbrace>\n 3. \\<And>Xa Y.\n       \\<langle>Xa, Y\\<rangle> \\<^bold>\\<in>\n       \\<lbrace>YZ \\<^bold>\\<in> B * C.\n        \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                 hsnd YZ\\<rangle> \\<^bold>\\<in>\n        F\\<rbrace> \\<Longrightarrow>\n       Y \\<^bold>\\<in> C", "show \"\\<lbrace>YZ \\<^bold>\\<in> B * C. \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in> F\\<rbrace> \\<le> B * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>YZ \\<^bold>\\<in> B * C.\n     \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in>\n     F\\<rbrace>\n    \\<le> B * C", "using assms"], ["proof (prove)\nusing this:\n  X \\<^bold>\\<in> A\n  hfun (A * B) C F\n\ngoal (1 subgoal):\n 1. \\<lbrace>YZ \\<^bold>\\<in> B * C.\n     \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in>\n     F\\<rbrace>\n    \\<le> B * C", "by auto"], ["proof (state)\nthis:\n  \\<lbrace>YZ \\<^bold>\\<in> B * C.\n   \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in>\n   F\\<rbrace>\n  \\<le> B * C\n\ngoal (2 subgoals):\n 1. \\<And>Xa.\n       Xa \\<^bold>\\<in> B \\<Longrightarrow>\n       \\<exists>!Y.\n          \\<langle>Xa, Y\\<rangle> \\<^bold>\\<in>\n          \\<lbrace>YZ \\<^bold>\\<in> B * C.\n           \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                    hsnd YZ\\<rangle> \\<^bold>\\<in>\n           F\\<rbrace>\n 2. \\<And>Xa Y.\n       \\<langle>Xa, Y\\<rangle> \\<^bold>\\<in>\n       \\<lbrace>YZ \\<^bold>\\<in> B * C.\n        \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                 hsnd YZ\\<rangle> \\<^bold>\\<in>\n        F\\<rbrace> \\<Longrightarrow>\n       Y \\<^bold>\\<in> C", "show \"\\<And>Y. Y \\<^bold>\\<in> B \\<Longrightarrow> \\<exists>!Z. \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> \\<lbrace>YZ \\<^bold>\\<in> B * C. \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in> F\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       Y \\<^bold>\\<in> B \\<Longrightarrow>\n       \\<exists>!Z.\n          \\<langle>Y, Z\\<rangle> \\<^bold>\\<in>\n          \\<lbrace>YZ \\<^bold>\\<in> B * C.\n           \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                    hsnd YZ\\<rangle> \\<^bold>\\<in>\n           F\\<rbrace>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       Y \\<^bold>\\<in> B \\<Longrightarrow>\n       \\<exists>!Z.\n          \\<langle>Y, Z\\<rangle> \\<^bold>\\<in>\n          \\<lbrace>YZ \\<^bold>\\<in> B * C.\n           \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                    hsnd YZ\\<rangle> \\<^bold>\\<in>\n           F\\<rbrace>", "fix Y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>Y.\n       Y \\<^bold>\\<in> B \\<Longrightarrow>\n       \\<exists>!Z.\n          \\<langle>Y, Z\\<rangle> \\<^bold>\\<in>\n          \\<lbrace>YZ \\<^bold>\\<in> B * C.\n           \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                    hsnd YZ\\<rangle> \\<^bold>\\<in>\n           F\\<rbrace>", "assume Y: \"Y \\<^bold>\\<in> B\""], ["proof (state)\nthis:\n  Y \\<^bold>\\<in> B\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       Y \\<^bold>\\<in> B \\<Longrightarrow>\n       \\<exists>!Z.\n          \\<langle>Y, Z\\<rangle> \\<^bold>\\<in>\n          \\<lbrace>YZ \\<^bold>\\<in> B * C.\n           \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                    hsnd YZ\\<rangle> \\<^bold>\\<in>\n           F\\<rbrace>", "have XY: \"\\<langle>X, Y\\<rangle> \\<^bold>\\<in> A * B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>X, Y\\<rangle> \\<^bold>\\<in> A * B", "using assms Y"], ["proof (prove)\nusing this:\n  X \\<^bold>\\<in> A\n  hfun (A * B) C F\n  Y \\<^bold>\\<in> B\n\ngoal (1 subgoal):\n 1. \\<langle>X, Y\\<rangle> \\<^bold>\\<in> A * B", "by simp"], ["proof (state)\nthis:\n  \\<langle>X, Y\\<rangle> \\<^bold>\\<in> A * B\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       Y \\<^bold>\\<in> B \\<Longrightarrow>\n       \\<exists>!Z.\n          \\<langle>Y, Z\\<rangle> \\<^bold>\\<in>\n          \\<lbrace>YZ \\<^bold>\\<in> B * C.\n           \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                    hsnd YZ\\<rangle> \\<^bold>\\<in>\n           F\\<rbrace>", "hence 1: \"\\<exists>!Z. \\<langle>\\<langle>X, Y\\<rangle>, Z\\<rangle> \\<^bold>\\<in> F\""], ["proof (prove)\nusing this:\n  \\<langle>X, Y\\<rangle> \\<^bold>\\<in> A * B\n\ngoal (1 subgoal):\n 1. \\<exists>!Z. \\<langle>\\<langle>X, Y\\<rangle>, Z\\<rangle> \\<^bold>\\<in> F", "using assms XY hfunE [of \"A * B\" C F]"], ["proof (prove)\nusing this:\n  \\<langle>X, Y\\<rangle> \\<^bold>\\<in> A * B\n  X \\<^bold>\\<in> A\n  hfun (A * B) C F\n  \\<langle>X, Y\\<rangle> \\<^bold>\\<in> A * B\n  \\<lbrakk>hfun (A * B) C F;\n   (\\<And>Y.\n       Y \\<^bold>\\<in> A * B \\<Longrightarrow>\n       (\\<exists>!Z. \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F) \\<and>\n       (\\<forall>Z.\n           \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> F \\<longrightarrow>\n           Z \\<^bold>\\<in> C)) \\<Longrightarrow>\n   ?T\\<rbrakk>\n  \\<Longrightarrow> ?T\n\ngoal (1 subgoal):\n 1. \\<exists>!Z. \\<langle>\\<langle>X, Y\\<rangle>, Z\\<rangle> \\<^bold>\\<in> F", "by blast"], ["proof (state)\nthis:\n  \\<exists>!Z. \\<langle>\\<langle>X, Y\\<rangle>, Z\\<rangle> \\<^bold>\\<in> F\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       Y \\<^bold>\\<in> B \\<Longrightarrow>\n       \\<exists>!Z.\n          \\<langle>Y, Z\\<rangle> \\<^bold>\\<in>\n          \\<lbrace>YZ \\<^bold>\\<in> B * C.\n           \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                    hsnd YZ\\<rangle> \\<^bold>\\<in>\n           F\\<rbrace>", "obtain Z where Z: \"\\<langle>\\<langle>X, Y\\<rangle>, Z\\<rangle> \\<^bold>\\<in> F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Z.\n        \\<langle>\\<langle>X, Y\\<rangle>, Z\\<rangle> \\<^bold>\\<in>\n        F \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using 1"], ["proof (prove)\nusing this:\n  \\<exists>!Z. \\<langle>\\<langle>X, Y\\<rangle>, Z\\<rangle> \\<^bold>\\<in> F\n\ngoal (1 subgoal):\n 1. (\\<And>Z.\n        \\<langle>\\<langle>X, Y\\<rangle>, Z\\<rangle> \\<^bold>\\<in>\n        F \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<langle>\\<langle>X, Y\\<rangle>, Z\\<rangle> \\<^bold>\\<in> F\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       Y \\<^bold>\\<in> B \\<Longrightarrow>\n       \\<exists>!Z.\n          \\<langle>Y, Z\\<rangle> \\<^bold>\\<in>\n          \\<lbrace>YZ \\<^bold>\\<in> B * C.\n           \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                    hsnd YZ\\<rangle> \\<^bold>\\<in>\n           F\\<rbrace>", "have \"\\<exists>Z. \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> \\<lbrace>YZ \\<^bold>\\<in> B * C. \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in> F\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>Z.\n       \\<langle>Y, Z\\<rangle> \\<^bold>\\<in>\n       \\<lbrace>YZ \\<^bold>\\<in> B * C.\n        \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                 hsnd YZ\\<rangle> \\<^bold>\\<in>\n        F\\<rbrace>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>Z.\n       \\<langle>Y, Z\\<rangle> \\<^bold>\\<in>\n       \\<lbrace>YZ \\<^bold>\\<in> B * C.\n        \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                 hsnd YZ\\<rangle> \\<^bold>\\<in>\n        F\\<rbrace>", "have \"\\<langle>Y, Z\\<rangle> \\<^bold>\\<in> B * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> B * C", "using assms Y Z"], ["proof (prove)\nusing this:\n  X \\<^bold>\\<in> A\n  hfun (A * B) C F\n  Y \\<^bold>\\<in> B\n  \\<langle>\\<langle>X, Y\\<rangle>, Z\\<rangle> \\<^bold>\\<in> F\n\ngoal (1 subgoal):\n 1. \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> B * C", "by blast"], ["proof (state)\nthis:\n  \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> B * C\n\ngoal (1 subgoal):\n 1. \\<exists>Z.\n       \\<langle>Y, Z\\<rangle> \\<^bold>\\<in>\n       \\<lbrace>YZ \\<^bold>\\<in> B * C.\n        \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                 hsnd YZ\\<rangle> \\<^bold>\\<in>\n        F\\<rbrace>", "moreover"], ["proof (state)\nthis:\n  \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> B * C\n\ngoal (1 subgoal):\n 1. \\<exists>Z.\n       \\<langle>Y, Z\\<rangle> \\<^bold>\\<in>\n       \\<lbrace>YZ \\<^bold>\\<in> B * C.\n        \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                 hsnd YZ\\<rangle> \\<^bold>\\<in>\n        F\\<rbrace>", "have \"\\<langle>\\<langle>X, hfst \\<langle>Y, Z\\<rangle>\\<rangle>, hsnd \\<langle>Y, Z\\<rangle>\\<rangle> \\<^bold>\\<in> F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<langle>X, hfst \\<langle>Y, Z\\<rangle>\\<rangle>,\n             hsnd \\<langle>Y, Z\\<rangle>\\<rangle> \\<^bold>\\<in>\n    F", "using assms Y Z"], ["proof (prove)\nusing this:\n  X \\<^bold>\\<in> A\n  hfun (A * B) C F\n  Y \\<^bold>\\<in> B\n  \\<langle>\\<langle>X, Y\\<rangle>, Z\\<rangle> \\<^bold>\\<in> F\n\ngoal (1 subgoal):\n 1. \\<langle>\\<langle>X, hfst \\<langle>Y, Z\\<rangle>\\<rangle>,\n             hsnd \\<langle>Y, Z\\<rangle>\\<rangle> \\<^bold>\\<in>\n    F", "by simp"], ["proof (state)\nthis:\n  \\<langle>\\<langle>X, hfst \\<langle>Y, Z\\<rangle>\\<rangle>,\n           hsnd \\<langle>Y, Z\\<rangle>\\<rangle> \\<^bold>\\<in>\n  F\n\ngoal (1 subgoal):\n 1. \\<exists>Z.\n       \\<langle>Y, Z\\<rangle> \\<^bold>\\<in>\n       \\<lbrace>YZ \\<^bold>\\<in> B * C.\n        \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                 hsnd YZ\\<rangle> \\<^bold>\\<in>\n        F\\<rbrace>", "ultimately"], ["proof (chain)\npicking this:\n  \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> B * C\n  \\<langle>\\<langle>X, hfst \\<langle>Y, Z\\<rangle>\\<rangle>,\n           hsnd \\<langle>Y, Z\\<rangle>\\<rangle> \\<^bold>\\<in>\n  F", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> B * C\n  \\<langle>\\<langle>X, hfst \\<langle>Y, Z\\<rangle>\\<rangle>,\n           hsnd \\<langle>Y, Z\\<rangle>\\<rangle> \\<^bold>\\<in>\n  F\n\ngoal (1 subgoal):\n 1. \\<exists>Z.\n       \\<langle>Y, Z\\<rangle> \\<^bold>\\<in>\n       \\<lbrace>YZ \\<^bold>\\<in> B * C.\n        \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                 hsnd YZ\\<rangle> \\<^bold>\\<in>\n        F\\<rbrace>", "by auto"], ["proof (state)\nthis:\n  \\<exists>Z.\n     \\<langle>Y, Z\\<rangle> \\<^bold>\\<in>\n     \\<lbrace>YZ \\<^bold>\\<in> B * C.\n      \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in>\n      F\\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>Z.\n     \\<langle>Y, Z\\<rangle> \\<^bold>\\<in>\n     \\<lbrace>YZ \\<^bold>\\<in> B * C.\n      \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in>\n      F\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       Y \\<^bold>\\<in> B \\<Longrightarrow>\n       \\<exists>!Z.\n          \\<langle>Y, Z\\<rangle> \\<^bold>\\<in>\n          \\<lbrace>YZ \\<^bold>\\<in> B * C.\n           \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                    hsnd YZ\\<rangle> \\<^bold>\\<in>\n           F\\<rbrace>", "moreover"], ["proof (state)\nthis:\n  \\<exists>Z.\n     \\<langle>Y, Z\\<rangle> \\<^bold>\\<in>\n     \\<lbrace>YZ \\<^bold>\\<in> B * C.\n      \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in>\n      F\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       Y \\<^bold>\\<in> B \\<Longrightarrow>\n       \\<exists>!Z.\n          \\<langle>Y, Z\\<rangle> \\<^bold>\\<in>\n          \\<lbrace>YZ \\<^bold>\\<in> B * C.\n           \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                    hsnd YZ\\<rangle> \\<^bold>\\<in>\n           F\\<rbrace>", "have \"\\<And>Z Z'. \\<lbrakk>\\<langle>Y, Z\\<rangle> \\<^bold>\\<in> \\<lbrace>YZ \\<^bold>\\<in> B * C. \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in> F\\<rbrace>;\n                                 \\<langle>Y, Z'\\<rangle> \\<^bold>\\<in> \\<lbrace>YZ \\<^bold>\\<in> B * C. \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in> F\\<rbrace>\\<rbrakk> \\<Longrightarrow> Z = Z'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Z Z'.\n       \\<lbrakk>\\<langle>Y, Z\\<rangle> \\<^bold>\\<in>\n                \\<lbrace>YZ \\<^bold>\\<in> B * C.\n                 \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                          hsnd YZ\\<rangle> \\<^bold>\\<in>\n                 F\\<rbrace>;\n        \\<langle>Y, Z'\\<rangle> \\<^bold>\\<in>\n        \\<lbrace>YZ \\<^bold>\\<in> B * C.\n         \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                  hsnd YZ\\<rangle> \\<^bold>\\<in>\n         F\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> Z = Z'", "using assms Y"], ["proof (prove)\nusing this:\n  X \\<^bold>\\<in> A\n  hfun (A * B) C F\n  Y \\<^bold>\\<in> B\n\ngoal (1 subgoal):\n 1. \\<And>Z Z'.\n       \\<lbrakk>\\<langle>Y, Z\\<rangle> \\<^bold>\\<in>\n                \\<lbrace>YZ \\<^bold>\\<in> B * C.\n                 \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                          hsnd YZ\\<rangle> \\<^bold>\\<in>\n                 F\\<rbrace>;\n        \\<langle>Y, Z'\\<rangle> \\<^bold>\\<in>\n        \\<lbrace>YZ \\<^bold>\\<in> B * C.\n         \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                  hsnd YZ\\<rangle> \\<^bold>\\<in>\n         F\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> Z = Z'", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>\\<langle>Y, ?Z\\<rangle> \\<^bold>\\<in>\n           \\<lbrace>YZ \\<^bold>\\<in> B * C.\n            \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                     hsnd YZ\\<rangle> \\<^bold>\\<in>\n            F\\<rbrace>;\n   \\<langle>Y, ?Z'\\<rangle> \\<^bold>\\<in>\n   \\<lbrace>YZ \\<^bold>\\<in> B * C.\n    \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in>\n    F\\<rbrace>\\<rbrakk>\n  \\<Longrightarrow> ?Z = ?Z'\n\ngoal (1 subgoal):\n 1. \\<And>Y.\n       Y \\<^bold>\\<in> B \\<Longrightarrow>\n       \\<exists>!Z.\n          \\<langle>Y, Z\\<rangle> \\<^bold>\\<in>\n          \\<lbrace>YZ \\<^bold>\\<in> B * C.\n           \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                    hsnd YZ\\<rangle> \\<^bold>\\<in>\n           F\\<rbrace>", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>Z.\n     \\<langle>Y, Z\\<rangle> \\<^bold>\\<in>\n     \\<lbrace>YZ \\<^bold>\\<in> B * C.\n      \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in>\n      F\\<rbrace>\n  \\<lbrakk>\\<langle>Y, ?Z\\<rangle> \\<^bold>\\<in>\n           \\<lbrace>YZ \\<^bold>\\<in> B * C.\n            \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                     hsnd YZ\\<rangle> \\<^bold>\\<in>\n            F\\<rbrace>;\n   \\<langle>Y, ?Z'\\<rangle> \\<^bold>\\<in>\n   \\<lbrace>YZ \\<^bold>\\<in> B * C.\n    \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in>\n    F\\<rbrace>\\<rbrakk>\n  \\<Longrightarrow> ?Z = ?Z'", "show \"\\<exists>!Z. \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> \\<lbrace>YZ \\<^bold>\\<in> B * C. \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in> F\\<rbrace>\""], ["proof (prove)\nusing this:\n  \\<exists>Z.\n     \\<langle>Y, Z\\<rangle> \\<^bold>\\<in>\n     \\<lbrace>YZ \\<^bold>\\<in> B * C.\n      \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in>\n      F\\<rbrace>\n  \\<lbrakk>\\<langle>Y, ?Z\\<rangle> \\<^bold>\\<in>\n           \\<lbrace>YZ \\<^bold>\\<in> B * C.\n            \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                     hsnd YZ\\<rangle> \\<^bold>\\<in>\n            F\\<rbrace>;\n   \\<langle>Y, ?Z'\\<rangle> \\<^bold>\\<in>\n   \\<lbrace>YZ \\<^bold>\\<in> B * C.\n    \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in>\n    F\\<rbrace>\\<rbrakk>\n  \\<Longrightarrow> ?Z = ?Z'\n\ngoal (1 subgoal):\n 1. \\<exists>!Z.\n       \\<langle>Y, Z\\<rangle> \\<^bold>\\<in>\n       \\<lbrace>YZ \\<^bold>\\<in> B * C.\n        \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                 hsnd YZ\\<rangle> \\<^bold>\\<in>\n        F\\<rbrace>", "by auto"], ["proof (state)\nthis:\n  \\<exists>!Z.\n     \\<langle>Y, Z\\<rangle> \\<^bold>\\<in>\n     \\<lbrace>YZ \\<^bold>\\<in> B * C.\n      \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in>\n      F\\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?Y \\<^bold>\\<in> B \\<Longrightarrow>\n  \\<exists>!Z.\n     \\<langle>?Y, Z\\<rangle> \\<^bold>\\<in>\n     \\<lbrace>YZ \\<^bold>\\<in> B * C.\n      \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in>\n      F\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<And>Xa Y.\n       \\<langle>Xa, Y\\<rangle> \\<^bold>\\<in>\n       \\<lbrace>YZ \\<^bold>\\<in> B * C.\n        \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                 hsnd YZ\\<rangle> \\<^bold>\\<in>\n        F\\<rbrace> \\<Longrightarrow>\n       Y \\<^bold>\\<in> C", "show \"\\<And>Y Z. \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> \\<lbrace>YZ \\<^bold>\\<in> B * C. \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in> F\\<rbrace> \\<Longrightarrow> Z \\<^bold>\\<in> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>Y Z.\n       \\<langle>Y, Z\\<rangle> \\<^bold>\\<in>\n       \\<lbrace>YZ \\<^bold>\\<in> B * C.\n        \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                 hsnd YZ\\<rangle> \\<^bold>\\<in>\n        F\\<rbrace> \\<Longrightarrow>\n       Z \\<^bold>\\<in> C", "using assms"], ["proof (prove)\nusing this:\n  X \\<^bold>\\<in> A\n  hfun (A * B) C F\n\ngoal (1 subgoal):\n 1. \\<And>Y Z.\n       \\<langle>Y, Z\\<rangle> \\<^bold>\\<in>\n       \\<lbrace>YZ \\<^bold>\\<in> B * C.\n        \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                 hsnd YZ\\<rangle> \\<^bold>\\<in>\n        F\\<rbrace> \\<Longrightarrow>\n       Z \\<^bold>\\<in> C", "by simp"], ["proof (state)\nthis:\n  \\<langle>?Y, ?Z\\<rangle> \\<^bold>\\<in>\n  \\<lbrace>YZ \\<^bold>\\<in> B * C.\n   \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in>\n   F\\<rbrace> \\<Longrightarrow>\n  ?Z \\<^bold>\\<in> C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hfun B C\n   \\<lbrace>YZ \\<^bold>\\<in> B * C.\n    \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in>\n    F\\<rbrace>\n\ngoal (1 subgoal):\n 1. happ (hlam A B C F) X =\n    \\<lbrace>YZ \\<^bold>\\<in> B * C.\n     \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in>\n     F\\<rbrace>", "have \"\\<langle>X, ?G\\<rangle> \\<^bold>\\<in> hlam A B C F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>X, \\<lbrace>YZ \\<^bold>\\<in> B * C.\n                 \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                          hsnd YZ\\<rangle> \\<^bold>\\<in>\n                 F\\<rbrace>\\<rangle> \\<^bold>\\<in>\n    hlam A B C F", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<langle>X, \\<lbrace>YZ \\<^bold>\\<in> B * C.\n                 \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                          hsnd YZ\\<rangle> \\<^bold>\\<in>\n                 F\\<rbrace>\\<rangle> \\<^bold>\\<in>\n    hlam A B C F", "have \"\\<langle>X, ?G\\<rangle> \\<^bold>\\<in> A * hexp B C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>X, \\<lbrace>YZ \\<^bold>\\<in> B * C.\n                 \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                          hsnd YZ\\<rangle> \\<^bold>\\<in>\n                 F\\<rbrace>\\<rangle> \\<^bold>\\<in>\n    A * hexp B C", "using assms 4"], ["proof (prove)\nusing this:\n  X \\<^bold>\\<in> A\n  hfun (A * B) C F\n  hfun B C\n   \\<lbrace>YZ \\<^bold>\\<in> B * C.\n    \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in>\n    F\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<langle>X, \\<lbrace>YZ \\<^bold>\\<in> B * C.\n                 \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                          hsnd YZ\\<rangle> \\<^bold>\\<in>\n                 F\\<rbrace>\\<rangle> \\<^bold>\\<in>\n    A * hexp B C", "by (simp add: hfun_in_hexp)"], ["proof (state)\nthis:\n  \\<langle>X, \\<lbrace>YZ \\<^bold>\\<in> B * C.\n               \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                        hsnd YZ\\<rangle> \\<^bold>\\<in>\n               F\\<rbrace>\\<rangle> \\<^bold>\\<in>\n  A * hexp B C\n\ngoal (1 subgoal):\n 1. \\<langle>X, \\<lbrace>YZ \\<^bold>\\<in> B * C.\n                 \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                          hsnd YZ\\<rangle> \\<^bold>\\<in>\n                 F\\<rbrace>\\<rangle> \\<^bold>\\<in>\n    hlam A B C F", "moreover"], ["proof (state)\nthis:\n  \\<langle>X, \\<lbrace>YZ \\<^bold>\\<in> B * C.\n               \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                        hsnd YZ\\<rangle> \\<^bold>\\<in>\n               F\\<rbrace>\\<rangle> \\<^bold>\\<in>\n  A * hexp B C\n\ngoal (1 subgoal):\n 1. \\<langle>X, \\<lbrace>YZ \\<^bold>\\<in> B * C.\n                 \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                          hsnd YZ\\<rangle> \\<^bold>\\<in>\n                 F\\<rbrace>\\<rangle> \\<^bold>\\<in>\n    hlam A B C F", "have \"\\<forall>YZ. YZ \\<^bold>\\<in> ?G \\<longleftrightarrow> is_hpair YZ \\<and> \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in> F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>YZ.\n       (YZ \\<^bold>\\<in>\n        \\<lbrace>YZ \\<^bold>\\<in> B * C.\n         \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                  hsnd YZ\\<rangle> \\<^bold>\\<in>\n         F\\<rbrace>) =\n       (is_hpair YZ \\<and>\n        \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                 hsnd YZ\\<rangle> \\<^bold>\\<in>\n        F)", "using assms 1 is_hpair_def hfun_def"], ["proof (prove)\nusing this:\n  X \\<^bold>\\<in> A\n  hfun (A * B) C F\n  \\<exists>!G. \\<langle>X, G\\<rangle> \\<^bold>\\<in> hlam A B C F\n  is_hpair ?z = (\\<exists>x y. ?z = \\<langle>x, y\\<rangle>)\n  hfun ?B ?C ?F \\<equiv>\n  ?F \\<le> ?B * ?C \\<and>\n  hfunction ?F \\<and> hdomain ?F = ?B \\<and> hrange ?F \\<le> ?C\n\ngoal (1 subgoal):\n 1. \\<forall>YZ.\n       (YZ \\<^bold>\\<in>\n        \\<lbrace>YZ \\<^bold>\\<in> B * C.\n         \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                  hsnd YZ\\<rangle> \\<^bold>\\<in>\n         F\\<rbrace>) =\n       (is_hpair YZ \\<and>\n        \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                 hsnd YZ\\<rangle> \\<^bold>\\<in>\n        F)", "by auto"], ["proof (state)\nthis:\n  \\<forall>YZ.\n     (YZ \\<^bold>\\<in>\n      \\<lbrace>YZ \\<^bold>\\<in> B * C.\n       \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in>\n       F\\<rbrace>) =\n     (is_hpair YZ \\<and>\n      \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in>\n      F)\n\ngoal (1 subgoal):\n 1. \\<langle>X, \\<lbrace>YZ \\<^bold>\\<in> B * C.\n                 \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                          hsnd YZ\\<rangle> \\<^bold>\\<in>\n                 F\\<rbrace>\\<rangle> \\<^bold>\\<in>\n    hlam A B C F", "ultimately"], ["proof (chain)\npicking this:\n  \\<langle>X, \\<lbrace>YZ \\<^bold>\\<in> B * C.\n               \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                        hsnd YZ\\<rangle> \\<^bold>\\<in>\n               F\\<rbrace>\\<rangle> \\<^bold>\\<in>\n  A * hexp B C\n  \\<forall>YZ.\n     (YZ \\<^bold>\\<in>\n      \\<lbrace>YZ \\<^bold>\\<in> B * C.\n       \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in>\n       F\\<rbrace>) =\n     (is_hpair YZ \\<and>\n      \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in>\n      F)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<langle>X, \\<lbrace>YZ \\<^bold>\\<in> B * C.\n               \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                        hsnd YZ\\<rangle> \\<^bold>\\<in>\n               F\\<rbrace>\\<rangle> \\<^bold>\\<in>\n  A * hexp B C\n  \\<forall>YZ.\n     (YZ \\<^bold>\\<in>\n      \\<lbrace>YZ \\<^bold>\\<in> B * C.\n       \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in>\n       F\\<rbrace>) =\n     (is_hpair YZ \\<and>\n      \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in>\n      F)\n\ngoal (1 subgoal):\n 1. \\<langle>X, \\<lbrace>YZ \\<^bold>\\<in> B * C.\n                 \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                          hsnd YZ\\<rangle> \\<^bold>\\<in>\n                 F\\<rbrace>\\<rangle> \\<^bold>\\<in>\n    hlam A B C F", "using assms 1 hlam_def"], ["proof (prove)\nusing this:\n  \\<langle>X, \\<lbrace>YZ \\<^bold>\\<in> B * C.\n               \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                        hsnd YZ\\<rangle> \\<^bold>\\<in>\n               F\\<rbrace>\\<rangle> \\<^bold>\\<in>\n  A * hexp B C\n  \\<forall>YZ.\n     (YZ \\<^bold>\\<in>\n      \\<lbrace>YZ \\<^bold>\\<in> B * C.\n       \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in>\n       F\\<rbrace>) =\n     (is_hpair YZ \\<and>\n      \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in>\n      F)\n  X \\<^bold>\\<in> A\n  hfun (A * B) C F\n  \\<exists>!G. \\<langle>X, G\\<rangle> \\<^bold>\\<in> hlam A B C F\n  hlam ?A ?B ?C ?F =\n  \\<lbrace>XG \\<^bold>\\<in> ?A * hexp ?B ?C.\n   \\<forall>YZ.\n      (YZ \\<^bold>\\<in> hsnd XG) =\n      (is_hpair YZ \\<and>\n       \\<langle>\\<langle>hfst XG, hfst YZ\\<rangle>,\n                hsnd YZ\\<rangle> \\<^bold>\\<in>\n       ?F)\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<langle>X, \\<lbrace>YZ \\<^bold>\\<in> B * C.\n                 \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                          hsnd YZ\\<rangle> \\<^bold>\\<in>\n                 F\\<rbrace>\\<rangle> \\<^bold>\\<in>\n    hlam A B C F", "by simp"], ["proof (state)\nthis:\n  \\<langle>X, \\<lbrace>YZ \\<^bold>\\<in> B * C.\n               \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                        hsnd YZ\\<rangle> \\<^bold>\\<in>\n               F\\<rbrace>\\<rangle> \\<^bold>\\<in>\n  hlam A B C F\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<langle>X, \\<lbrace>YZ \\<^bold>\\<in> B * C.\n               \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                        hsnd YZ\\<rangle> \\<^bold>\\<in>\n               F\\<rbrace>\\<rangle> \\<^bold>\\<in>\n  hlam A B C F\n\ngoal (1 subgoal):\n 1. happ (hlam A B C F) X =\n    \\<lbrace>YZ \\<^bold>\\<in> B * C.\n     \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in>\n     F\\<rbrace>", "thus \"happ (hlam A B C F) X = ?G\""], ["proof (prove)\nusing this:\n  \\<langle>X, \\<lbrace>YZ \\<^bold>\\<in> B * C.\n               \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                        hsnd YZ\\<rangle> \\<^bold>\\<in>\n               F\\<rbrace>\\<rangle> \\<^bold>\\<in>\n  hlam A B C F\n\ngoal (1 subgoal):\n 1. happ (hlam A B C F) X =\n    \\<lbrace>YZ \\<^bold>\\<in> B * C.\n     \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in>\n     F\\<rbrace>", "using assms 2 4 app_equality hfun_def hfun_hlam"], ["proof (prove)\nusing this:\n  \\<langle>X, \\<lbrace>YZ \\<^bold>\\<in> B * C.\n               \\<langle>\\<langle>X, hfst YZ\\<rangle>,\n                        hsnd YZ\\<rangle> \\<^bold>\\<in>\n               F\\<rbrace>\\<rangle> \\<^bold>\\<in>\n  hlam A B C F\n  X \\<^bold>\\<in> A\n  hfun (A * B) C F\n  happ (hlam A B C F) X =\n  (THE G. \\<langle>X, G\\<rangle> \\<^bold>\\<in> hlam A B C F)\n  hfun B C\n   \\<lbrace>YZ \\<^bold>\\<in> B * C.\n    \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in>\n    F\\<rbrace>\n  \\<lbrakk>hfunction ?f; \\<langle>?x, ?y\\<rangle> \\<^bold>\\<in> ?f\\<rbrakk>\n  \\<Longrightarrow> happ ?f ?x = ?y\n  hfun ?B ?C ?F \\<equiv>\n  ?F \\<le> ?B * ?C \\<and>\n  hfunction ?F \\<and> hdomain ?F = ?B \\<and> hrange ?F \\<le> ?C\n  hfun (?A * ?B) ?C ?F \\<Longrightarrow>\n  hfun ?A (hexp ?B ?C) (hlam ?A ?B ?C ?F)\n\ngoal (1 subgoal):\n 1. happ (hlam A B C F) X =\n    \\<lbrace>YZ \\<^bold>\\<in> B * C.\n     \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in>\n     F\\<rbrace>", "by auto"], ["proof (state)\nthis:\n  happ (hlam A B C F) X =\n  \\<lbrace>YZ \\<^bold>\\<in> B * C.\n   \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in>\n   F\\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  happ (hlam A B C F) X =\n  \\<lbrace>YZ \\<^bold>\\<in> B * C.\n   \\<langle>\\<langle>X, hfst YZ\\<rangle>, hsnd YZ\\<rangle> \\<^bold>\\<in>\n   F\\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["", "section \"Construction of the Category\""], ["", "locale hfsetcat\n  begin"], ["", "text\\<open>\n      We construct the category of hereditarily finite sets and function simply by applying\n      the generic ``set category'' construction, using the hereditarily finite sets as the\n      universe, and constraining the collections of such sets that determine objects of the\n      category to those having cardinality less than that of the natural numbers;\n      \\emph{i.e.}~to those that are finite.\n    \\<close>"], ["", "interpretation setcat \\<open>undefined :: hf\\<close> natLeq"], ["proof (prove)\ngoal (1 subgoal):\n 1. setcat natLeq", "using Field_natLeq natLeq_Card_order"], ["proof (prove)\nusing this:\n  Field natLeq = UNIV\n  Card_order natLeq\n\ngoal (1 subgoal):\n 1. setcat natLeq", "by unfold_locales auto"], ["", "interpretation category_with_terminal_object comp"], ["proof (prove)\ngoal (1 subgoal):\n 1. category_with_terminal_object local.comp", "using terminal_unity"], ["proof (prove)\nusing this:\n  terminal unity\n\ngoal (1 subgoal):\n 1. category_with_terminal_object local.comp", "by unfold_locales auto"], ["", "text\\<open>\n      We verify that the objects of HF are indeed in bijective correspondence with the\n      hereditarily finite sets.\n    \\<close>"], ["", "definition ide_to_hf\n    where \"ide_to_hf a = HF (DOWN ` set a)\""], ["", "definition hf_to_ide\n    where \"hf_to_ide x = mkIde (UP ` hfset x)\""], ["", "lemma ide_to_hf_mapsto:\n    shows \"ide_to_hf \\<in> Collect ide \\<rightarrow> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide_to_hf \\<in> Collect ide \\<rightarrow> UNIV", "by simp"], ["", "lemma hf_to_ide_mapsto:\n    shows \"hf_to_ide \\<in> UNIV \\<rightarrow> Collect ide\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hf_to_ide \\<in> UNIV \\<rightarrow> Collect ide", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> UNIV \\<Longrightarrow> hf_to_ide x \\<in> Collect ide", "fix x :: hf"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> UNIV \\<Longrightarrow> hf_to_ide x \\<in> Collect ide", "have \"finite (UP ` hfset x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (UP ` hfset x)", "by simp"], ["proof (state)\nthis:\n  finite (UP ` hfset x)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> UNIV \\<Longrightarrow> hf_to_ide x \\<in> Collect ide", "moreover"], ["proof (state)\nthis:\n  finite (UP ` hfset x)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> UNIV \\<Longrightarrow> hf_to_ide x \\<in> Collect ide", "have \"UP ` hfset x \\<subseteq> Univ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP ` hfset x \\<subseteq> Univ", "by (metis (mono_tags, lifting) UNIV_I bij_UP bij_betw_def imageE image_eqI subsetI)"], ["proof (state)\nthis:\n  UP ` hfset x \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> UNIV \\<Longrightarrow> hf_to_ide x \\<in> Collect ide", "ultimately"], ["proof (chain)\npicking this:\n  finite (UP ` hfset x)\n  UP ` hfset x \\<subseteq> Univ", "have \"ide (mkIde (UP ` hfset x))\""], ["proof (prove)\nusing this:\n  finite (UP ` hfset x)\n  UP ` hfset x \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. ide (mkIde (UP ` hfset x))", "using ide_mkIde_finite"], ["proof (prove)\nusing this:\n  finite (UP ` hfset x)\n  UP ` hfset x \\<subseteq> Univ\n  \\<lbrakk>?A \\<subseteq> Univ; finite ?A\\<rbrakk>\n  \\<Longrightarrow> ide (mkIde ?A)\n\ngoal (1 subgoal):\n 1. ide (mkIde (UP ` hfset x))", "by simp"], ["proof (state)\nthis:\n  ide (mkIde (UP ` hfset x))\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> UNIV \\<Longrightarrow> hf_to_ide x \\<in> Collect ide", "thus \"hf_to_ide x \\<in> Collect ide\""], ["proof (prove)\nusing this:\n  ide (mkIde (UP ` hfset x))\n\ngoal (1 subgoal):\n 1. hf_to_ide x \\<in> Collect ide", "using hf_to_ide_def"], ["proof (prove)\nusing this:\n  ide (mkIde (UP ` hfset x))\n  hf_to_ide ?x = mkIde (UP ` hfset ?x)\n\ngoal (1 subgoal):\n 1. hf_to_ide x \\<in> Collect ide", "by simp"], ["proof (state)\nthis:\n  hf_to_ide x \\<in> Collect ide\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hf_to_ide_ide_to_hf:\n    assumes \"a \\<in> Collect ide\"\n    shows \"hf_to_ide (ide_to_hf a) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hf_to_ide (ide_to_hf a) = a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. hf_to_ide (ide_to_hf a) = a", "have \"hf_to_ide (ide_to_hf a) = mkIde (UP ` hfset (HF (DOWN ` set a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hf_to_ide (ide_to_hf a) = mkIde (UP ` hfset (HF (DOWN ` local.set a)))", "using hf_to_ide_def ide_to_hf_def"], ["proof (prove)\nusing this:\n  hf_to_ide ?x = mkIde (UP ` hfset ?x)\n  ide_to_hf ?a = HF (DOWN ` local.set ?a)\n\ngoal (1 subgoal):\n 1. hf_to_ide (ide_to_hf a) = mkIde (UP ` hfset (HF (DOWN ` local.set a)))", "by simp"], ["proof (state)\nthis:\n  hf_to_ide (ide_to_hf a) = mkIde (UP ` hfset (HF (DOWN ` local.set a)))\n\ngoal (1 subgoal):\n 1. hf_to_ide (ide_to_hf a) = a", "also"], ["proof (state)\nthis:\n  hf_to_ide (ide_to_hf a) = mkIde (UP ` hfset (HF (DOWN ` local.set a)))\n\ngoal (1 subgoal):\n 1. hf_to_ide (ide_to_hf a) = a", "have \"... = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mkIde (UP ` hfset (HF (DOWN ` local.set a))) = a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mkIde (UP ` hfset (HF (DOWN ` local.set a))) = a", "have \"mkIde (UP ` hfset (HF (DOWN ` set a))) = mkIde (UP ` DOWN ` set a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mkIde (UP ` hfset (HF (DOWN ` local.set a))) =\n    mkIde (UP ` DOWN ` local.set a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mkIde (UP ` hfset (HF (DOWN ` local.set a))) =\n    mkIde (UP ` DOWN ` local.set a)", "have \"finite (set a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (local.set a)", "using assms set_card finite_iff_ordLess_natLeq"], ["proof (prove)\nusing this:\n  a \\<in> Collect ide\n  ide ?a \\<Longrightarrow> |local.set ?a| <o natLeq\n  finite ?A = (|?A| <o natLeq)\n\ngoal (1 subgoal):\n 1. finite (local.set a)", "by auto"], ["proof (state)\nthis:\n  finite (local.set a)\n\ngoal (1 subgoal):\n 1. mkIde (UP ` hfset (HF (DOWN ` local.set a))) =\n    mkIde (UP ` DOWN ` local.set a)", "hence \"finite (DOWN ` set a)\""], ["proof (prove)\nusing this:\n  finite (local.set a)\n\ngoal (1 subgoal):\n 1. finite (DOWN ` local.set a)", "by simp"], ["proof (state)\nthis:\n  finite (DOWN ` local.set a)\n\ngoal (1 subgoal):\n 1. mkIde (UP ` hfset (HF (DOWN ` local.set a))) =\n    mkIde (UP ` DOWN ` local.set a)", "hence \"hfset (HF (DOWN ` set a)) = DOWN ` set a\""], ["proof (prove)\nusing this:\n  finite (DOWN ` local.set a)\n\ngoal (1 subgoal):\n 1. hfset (HF (DOWN ` local.set a)) = DOWN ` local.set a", "using hfset_HF [of \"DOWN ` set a\"]"], ["proof (prove)\nusing this:\n  finite (DOWN ` local.set a)\n  finite (DOWN ` local.set a) \\<Longrightarrow>\n  hfset (HF (DOWN ` local.set a)) = DOWN ` local.set a\n\ngoal (1 subgoal):\n 1. hfset (HF (DOWN ` local.set a)) = DOWN ` local.set a", "by simp"], ["proof (state)\nthis:\n  hfset (HF (DOWN ` local.set a)) = DOWN ` local.set a\n\ngoal (1 subgoal):\n 1. mkIde (UP ` hfset (HF (DOWN ` local.set a))) =\n    mkIde (UP ` DOWN ` local.set a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  hfset (HF (DOWN ` local.set a)) = DOWN ` local.set a\n\ngoal (1 subgoal):\n 1. mkIde (UP ` hfset (HF (DOWN ` local.set a))) =\n    mkIde (UP ` DOWN ` local.set a)", "by simp"], ["proof (state)\nthis:\n  mkIde (UP ` hfset (HF (DOWN ` local.set a))) =\n  mkIde (UP ` DOWN ` local.set a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mkIde (UP ` hfset (HF (DOWN ` local.set a))) =\n  mkIde (UP ` DOWN ` local.set a)\n\ngoal (1 subgoal):\n 1. mkIde (UP ` hfset (HF (DOWN ` local.set a))) = a", "also"], ["proof (state)\nthis:\n  mkIde (UP ` hfset (HF (DOWN ` local.set a))) =\n  mkIde (UP ` DOWN ` local.set a)\n\ngoal (1 subgoal):\n 1. mkIde (UP ` hfset (HF (DOWN ` local.set a))) = a", "have \"... = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mkIde (UP ` DOWN ` local.set a) = a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mkIde (UP ` DOWN ` local.set a) = a", "have \"set a \\<subseteq> Univ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.set a \\<subseteq> Univ", "using assms set_subset_Univ ide_char"], ["proof (prove)\nusing this:\n  a \\<in> Collect ide\n  ide ?a \\<Longrightarrow> local.set ?a \\<subseteq> Univ\n  arr ?f \\<Longrightarrow>\n  ide ?f =\n  (Dom ?f = Cod ?f \\<and> Fun ?f = (\\<lambda>x\\<^bold>\\<in>Dom ?f. x))\n\ngoal (1 subgoal):\n 1. local.set a \\<subseteq> Univ", "by blast"], ["proof (state)\nthis:\n  local.set a \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. mkIde (UP ` DOWN ` local.set a) = a", "hence \"\\<And>x. x \\<in> set a \\<Longrightarrow> UP (DOWN x) = x\""], ["proof (prove)\nusing this:\n  local.set a \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> local.set a \\<Longrightarrow> UP (DOWN x) = x", "using assms"], ["proof (prove)\nusing this:\n  local.set a \\<subseteq> Univ\n  a \\<in> Collect ide\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> local.set a \\<Longrightarrow> UP (DOWN x) = x", "by auto"], ["proof (state)\nthis:\n  ?x1 \\<in> local.set a \\<Longrightarrow> UP (DOWN ?x1) = ?x1\n\ngoal (1 subgoal):\n 1. mkIde (UP ` DOWN ` local.set a) = a", "hence \"UP ` DOWN ` set a = set a\""], ["proof (prove)\nusing this:\n  ?x1 \\<in> local.set a \\<Longrightarrow> UP (DOWN ?x1) = ?x1\n\ngoal (1 subgoal):\n 1. UP ` DOWN ` local.set a = local.set a", "by force"], ["proof (state)\nthis:\n  UP ` DOWN ` local.set a = local.set a\n\ngoal (1 subgoal):\n 1. mkIde (UP ` DOWN ` local.set a) = a", "thus ?thesis"], ["proof (prove)\nusing this:\n  UP ` DOWN ` local.set a = local.set a\n\ngoal (1 subgoal):\n 1. mkIde (UP ` DOWN ` local.set a) = a", "using assms ide_char mkIde_set"], ["proof (prove)\nusing this:\n  UP ` DOWN ` local.set a = local.set a\n  a \\<in> Collect ide\n  arr ?f \\<Longrightarrow>\n  ide ?f =\n  (Dom ?f = Cod ?f \\<and> Fun ?f = (\\<lambda>x\\<^bold>\\<in>Dom ?f. x))\n  ide ?a \\<Longrightarrow> mkIde (local.set ?a) = ?a\n\ngoal (1 subgoal):\n 1. mkIde (UP ` DOWN ` local.set a) = a", "by simp"], ["proof (state)\nthis:\n  mkIde (UP ` DOWN ` local.set a) = a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mkIde (UP ` DOWN ` local.set a) = a\n\ngoal (1 subgoal):\n 1. mkIde (UP ` hfset (HF (DOWN ` local.set a))) = a", "finally"], ["proof (chain)\npicking this:\n  mkIde (UP ` hfset (HF (DOWN ` local.set a))) = a", "show ?thesis"], ["proof (prove)\nusing this:\n  mkIde (UP ` hfset (HF (DOWN ` local.set a))) = a\n\ngoal (1 subgoal):\n 1. mkIde (UP ` hfset (HF (DOWN ` local.set a))) = a", "by blast"], ["proof (state)\nthis:\n  mkIde (UP ` hfset (HF (DOWN ` local.set a))) = a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mkIde (UP ` hfset (HF (DOWN ` local.set a))) = a\n\ngoal (1 subgoal):\n 1. hf_to_ide (ide_to_hf a) = a", "finally"], ["proof (chain)\npicking this:\n  hf_to_ide (ide_to_hf a) = a", "show \"hf_to_ide (ide_to_hf a) = a\""], ["proof (prove)\nusing this:\n  hf_to_ide (ide_to_hf a) = a\n\ngoal (1 subgoal):\n 1. hf_to_ide (ide_to_hf a) = a", "by blast"], ["proof (state)\nthis:\n  hf_to_ide (ide_to_hf a) = a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ide_to_hf_hf_to_ide:\n    assumes \"x \\<in> UNIV\"\n    shows \"ide_to_hf (hf_to_ide x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide_to_hf (hf_to_ide x) = x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ide_to_hf (hf_to_ide x) = x", "have \"HF (DOWN ` set (mkIde (UP ` hfset x))) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HF (DOWN ` local.set (mkIde (UP ` hfset x))) = x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. HF (DOWN ` local.set (mkIde (UP ` hfset x))) = x", "have \"HF (DOWN ` set (mkIde (UP ` hfset x))) = HF (DOWN ` UP ` hfset x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HF (DOWN ` local.set (mkIde (UP ` hfset x))) = HF (DOWN ` UP ` hfset x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. HF (DOWN ` local.set (mkIde (UP ` hfset x))) = HF (DOWN ` UP ` hfset x)", "have \"|UP ` hfset x| <o natLeq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |UP ` hfset x| <o natLeq", "using assms finite_iff_ordLess_natLeq finite_hfset"], ["proof (prove)\nusing this:\n  x \\<in> UNIV\n  finite ?A = (|?A| <o natLeq)\n  finite (hfset ?a)\n\ngoal (1 subgoal):\n 1. |UP ` hfset x| <o natLeq", "by blast"], ["proof (state)\nthis:\n  |UP ` hfset x| <o natLeq\n\ngoal (1 subgoal):\n 1. HF (DOWN ` local.set (mkIde (UP ` hfset x))) = HF (DOWN ` UP ` hfset x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  |UP ` hfset x| <o natLeq\n\ngoal (1 subgoal):\n 1. HF (DOWN ` local.set (mkIde (UP ` hfset x))) = HF (DOWN ` UP ` hfset x)", "using assms set_mkIde [of \"UP ` hfset x\"] UP_mapsto mkIde_def"], ["proof (prove)\nusing this:\n  |UP ` hfset x| <o natLeq\n  x \\<in> UNIV\n  \\<lbrakk>UP ` hfset x \\<subseteq> Univ; |UP ` hfset x| <o natLeq\\<rbrakk>\n  \\<Longrightarrow> local.set (mkIde (UP ` hfset x)) = UP ` hfset x\n  UP \\<in> UNIV \\<rightarrow> Univ\n  mkIde ?A =\n  (if ?A \\<subseteq> Univ \\<and> |?A| <o natLeq\n   then inv_into (Collect ide) local.set ?A else null)\n\ngoal (1 subgoal):\n 1. HF (DOWN ` local.set (mkIde (UP ` hfset x))) = HF (DOWN ` UP ` hfset x)", "by auto"], ["proof (state)\nthis:\n  HF (DOWN ` local.set (mkIde (UP ` hfset x))) = HF (DOWN ` UP ` hfset x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  HF (DOWN ` local.set (mkIde (UP ` hfset x))) = HF (DOWN ` UP ` hfset x)\n\ngoal (1 subgoal):\n 1. HF (DOWN ` local.set (mkIde (UP ` hfset x))) = x", "also"], ["proof (state)\nthis:\n  HF (DOWN ` local.set (mkIde (UP ` hfset x))) = HF (DOWN ` UP ` hfset x)\n\ngoal (1 subgoal):\n 1. HF (DOWN ` local.set (mkIde (UP ` hfset x))) = x", "have \"... = HF (hfset x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HF (DOWN ` UP ` hfset x) = HF (hfset x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. HF (DOWN ` UP ` hfset x) = HF (hfset x)", "have \"\\<And>A. DOWN ` UP ` A = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A. DOWN ` UP ` A = A", "using DOWN_UP"], ["proof (prove)\nusing this:\n  DOWN (UP ?x) = ?x\n\ngoal (1 subgoal):\n 1. \\<And>A. DOWN ` UP ` A = A", "by force"], ["proof (state)\nthis:\n  DOWN ` UP ` ?A1 = ?A1\n\ngoal (1 subgoal):\n 1. HF (DOWN ` UP ` hfset x) = HF (hfset x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  DOWN ` UP ` ?A1 = ?A1\n\ngoal (1 subgoal):\n 1. HF (DOWN ` UP ` hfset x) = HF (hfset x)", "by metis"], ["proof (state)\nthis:\n  HF (DOWN ` UP ` hfset x) = HF (hfset x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  HF (DOWN ` UP ` hfset x) = HF (hfset x)\n\ngoal (1 subgoal):\n 1. HF (DOWN ` local.set (mkIde (UP ` hfset x))) = x", "also"], ["proof (state)\nthis:\n  HF (DOWN ` UP ` hfset x) = HF (hfset x)\n\ngoal (1 subgoal):\n 1. HF (DOWN ` local.set (mkIde (UP ` hfset x))) = x", "have \"... = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HF (hfset x) = x", "by simp"], ["proof (state)\nthis:\n  HF (hfset x) = x\n\ngoal (1 subgoal):\n 1. HF (DOWN ` local.set (mkIde (UP ` hfset x))) = x", "finally"], ["proof (chain)\npicking this:\n  HF (DOWN ` local.set (mkIde (UP ` hfset x))) = x", "show ?thesis"], ["proof (prove)\nusing this:\n  HF (DOWN ` local.set (mkIde (UP ` hfset x))) = x\n\ngoal (1 subgoal):\n 1. HF (DOWN ` local.set (mkIde (UP ` hfset x))) = x", "by blast"], ["proof (state)\nthis:\n  HF (DOWN ` local.set (mkIde (UP ` hfset x))) = x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  HF (DOWN ` local.set (mkIde (UP ` hfset x))) = x\n\ngoal (1 subgoal):\n 1. ide_to_hf (hf_to_ide x) = x", "thus ?thesis"], ["proof (prove)\nusing this:\n  HF (DOWN ` local.set (mkIde (UP ` hfset x))) = x\n\ngoal (1 subgoal):\n 1. ide_to_hf (hf_to_ide x) = x", "using assms ide_to_hf_def hf_to_ide_def"], ["proof (prove)\nusing this:\n  HF (DOWN ` local.set (mkIde (UP ` hfset x))) = x\n  x \\<in> UNIV\n  ide_to_hf ?a = HF (DOWN ` local.set ?a)\n  hf_to_ide ?x = mkIde (UP ` hfset ?x)\n\ngoal (1 subgoal):\n 1. ide_to_hf (hf_to_ide x) = x", "by simp"], ["proof (state)\nthis:\n  ide_to_hf (hf_to_ide x) = x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bij_betw_ide_hf_set:\n    shows \"bij_betw ide_to_hf (Collect ide) (UNIV :: hf set)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw ide_to_hf (Collect ide) UNIV", "using ide_to_hf_mapsto hf_to_ide_mapsto ide_to_hf_hf_to_ide hf_to_ide_ide_to_hf"], ["proof (prove)\nusing this:\n  ide_to_hf \\<in> Collect ide \\<rightarrow> UNIV\n  hf_to_ide \\<in> UNIV \\<rightarrow> Collect ide\n  ?x \\<in> UNIV \\<Longrightarrow> ide_to_hf (hf_to_ide ?x) = ?x\n  ?a \\<in> Collect ide \\<Longrightarrow> hf_to_ide (ide_to_hf ?a) = ?a\n\ngoal (1 subgoal):\n 1. bij_betw ide_to_hf (Collect ide) UNIV", "by (intro bij_betwI) auto"], ["", "lemma ide_implies_finite_set:\n    assumes \"ide a\"\n    shows \"finite (set a)\" and \"finite (hom unity a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (local.set a) &&& finite (hom unity a)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. finite (local.set a)\n 2. finite (hom unity a)", "show 1: \"finite (set a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (local.set a)", "using assms ide_char set_card finite_iff_ordLess_natLeq"], ["proof (prove)\nusing this:\n  ide a\n  arr ?f \\<Longrightarrow>\n  ide ?f =\n  (Dom ?f = Cod ?f \\<and> Fun ?f = (\\<lambda>x\\<^bold>\\<in>Dom ?f. x))\n  ide ?a \\<Longrightarrow> |local.set ?a| <o natLeq\n  finite ?A = (|?A| <o natLeq)\n\ngoal (1 subgoal):\n 1. finite (local.set a)", "by blast"], ["proof (state)\nthis:\n  finite (local.set a)\n\ngoal (1 subgoal):\n 1. finite (hom unity a)", "show \"finite (hom unity a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (hom unity a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (hom unity a)", "have \"|hom unity a| =o |set a|\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |hom unity a| =o |local.set a|", "using assms bij_betw_points_and_set card_of_ordIsoI"], ["proof (prove)\nusing this:\n  ide a\n  ide ?a \\<Longrightarrow> bij_betw img (hom unity ?a) (local.set ?a)\n  bij_betw ?f ?A ?B \\<Longrightarrow> |?A| =o |?B|\n\ngoal (1 subgoal):\n 1. |hom unity a| =o |local.set a|", "by auto"], ["proof (state)\nthis:\n  |hom unity a| =o |local.set a|\n\ngoal (1 subgoal):\n 1. finite (hom unity a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  |hom unity a| =o |local.set a|\n\ngoal (1 subgoal):\n 1. finite (hom unity a)", "using 1"], ["proof (prove)\nusing this:\n  |hom unity a| =o |local.set a|\n  finite (local.set a)\n\ngoal (1 subgoal):\n 1. finite (hom unity a)", "by simp"], ["proof (state)\nthis:\n  finite (hom unity a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite (hom unity a)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n      We establish the connection between the membership relation defined for hereditarily\n      finite sets and the corresponding membership relation associated with the set category.\n    \\<close>"], ["", "lemma UP_membI [intro]:\n    assumes \"x \\<^bold>\\<in> ide_to_hf a\"\n    shows \"UP x \\<in> set a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP x \\<in> local.set a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. UP x \\<in> local.set a", "let ?X = \"inv_into (set a) DOWN x\""], ["proof (state)\ngoal (1 subgoal):\n 1. UP x \\<in> local.set a", "have \"x = DOWN ?X \\<and> ?X \\<in> set a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = DOWN (inv_into (local.set a) DOWN x) \\<and>\n    inv_into (local.set a) DOWN x \\<in> local.set a", "using assms"], ["proof (prove)\nusing this:\n  x \\<^bold>\\<in> ide_to_hf a\n\ngoal (1 subgoal):\n 1. x = DOWN (inv_into (local.set a) DOWN x) \\<and>\n    inv_into (local.set a) DOWN x \\<in> local.set a", "by (simp add: f_inv_into_f ide_to_hf_def inv_into_into)"], ["proof (state)\nthis:\n  x = DOWN (inv_into (local.set a) DOWN x) \\<and>\n  inv_into (local.set a) DOWN x \\<in> local.set a\n\ngoal (1 subgoal):\n 1. UP x \\<in> local.set a", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = DOWN (inv_into (local.set a) DOWN x) \\<and>\n  inv_into (local.set a) DOWN x \\<in> local.set a\n\ngoal (1 subgoal):\n 1. UP x \\<in> local.set a", "by (metis (no_types, lifting) UP_DOWN elem_set_implies_incl_in incl_in_def\n            set_subset_Univ subsetD)"], ["proof (state)\nthis:\n  UP x \\<in> local.set a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma DOWN_membI [intro]:\n    assumes \"ide a\" and \"x \\<in> set a\"\n    shows \"DOWN x \\<^bold>\\<in> ide_to_hf a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DOWN x \\<^bold>\\<in> ide_to_hf a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. DOWN x \\<^bold>\\<in> ide_to_hf a", "have \"finite (DOWN ` set a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (DOWN ` local.set a)", "using assms ide_implies_finite_set [of a]"], ["proof (prove)\nusing this:\n  ide a\n  x \\<in> local.set a\n  ide a \\<Longrightarrow> finite (local.set a)\n  ide a \\<Longrightarrow> finite (hom unity a)\n\ngoal (1 subgoal):\n 1. finite (DOWN ` local.set a)", "by simp"], ["proof (state)\nthis:\n  finite (DOWN ` local.set a)\n\ngoal (1 subgoal):\n 1. DOWN x \\<^bold>\\<in> ide_to_hf a", "hence \"DOWN x \\<in> hfset (ide_to_hf a)\""], ["proof (prove)\nusing this:\n  finite (DOWN ` local.set a)\n\ngoal (1 subgoal):\n 1. DOWN x \\<in> hfset (ide_to_hf a)", "using assms ide_to_hf_def hfset_HF [of \"DOWN ` set a\"]"], ["proof (prove)\nusing this:\n  finite (DOWN ` local.set a)\n  ide a\n  x \\<in> local.set a\n  ide_to_hf ?a = HF (DOWN ` local.set ?a)\n  finite (DOWN ` local.set a) \\<Longrightarrow>\n  hfset (HF (DOWN ` local.set a)) = DOWN ` local.set a\n\ngoal (1 subgoal):\n 1. DOWN x \\<in> hfset (ide_to_hf a)", "by simp"], ["proof (state)\nthis:\n  DOWN x \\<in> hfset (ide_to_hf a)\n\ngoal (1 subgoal):\n 1. DOWN x \\<^bold>\\<in> ide_to_hf a", "thus ?thesis"], ["proof (prove)\nusing this:\n  DOWN x \\<in> hfset (ide_to_hf a)\n\ngoal (1 subgoal):\n 1. DOWN x \\<^bold>\\<in> ide_to_hf a", "using hmem_def"], ["proof (prove)\nusing this:\n  DOWN x \\<in> hfset (ide_to_hf a)\n  (?a \\<^bold>\\<in> ?b) = (?a \\<in> hfset ?b)\n\ngoal (1 subgoal):\n 1. DOWN x \\<^bold>\\<in> ide_to_hf a", "by blast"], ["proof (state)\nthis:\n  DOWN x \\<^bold>\\<in> ide_to_hf a\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n      We show that each hom-set \\<open>hom a b\\<close> is in bijective correspondence with\n      the elements of the hereditarily finite set \\<open>hfun (ide_to_hf a) (ide_to_hf b)\\<close>.\n    \\<close>"], ["", "definition arr_to_hfun\n    where \"arr_to_hfun f = \\<lbrace>XY \\<^bold>\\<in> ide_to_hf (dom f) * ide_to_hf (cod f).\n                              hsnd XY = DOWN (Fun f (UP (hfst XY)))\\<rbrace>\""], ["", "definition hfun_to_arr\n    where \"hfun_to_arr B C F =\n           mkArr (UP ` hfset B) (UP ` hfset C) (\\<lambda>x. UP (happ F (DOWN x)))\""], ["", "lemma hfun_arr_to_hfun:\n    assumes \"arr f\"\n    shows \"hfun (ide_to_hf (dom f)) (ide_to_hf (cod f)) (arr_to_hfun f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hfun (ide_to_hf (local.dom f)) (ide_to_hf (cod f)) (arr_to_hfun f)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. arr_to_hfun f \\<le> ide_to_hf (local.dom f) * ide_to_hf (cod f)\n 2. \\<And>X.\n       X \\<^bold>\\<in> ide_to_hf (local.dom f) \\<Longrightarrow>\n       \\<exists>!Y. \\<langle>X, Y\\<rangle> \\<^bold>\\<in> arr_to_hfun f\n 3. \\<And>X Y.\n       \\<langle>X, Y\\<rangle> \\<^bold>\\<in> arr_to_hfun f \\<Longrightarrow>\n       Y \\<^bold>\\<in> ide_to_hf (cod f)", "show \"arr_to_hfun f \\<le> ide_to_hf (dom f) * ide_to_hf (cod f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr_to_hfun f \\<le> ide_to_hf (local.dom f) * ide_to_hf (cod f)", "using assms arr_to_hfun_def"], ["proof (prove)\nusing this:\n  arr f\n  arr_to_hfun ?f =\n  \\<lbrace>XY \\<^bold>\\<in> ide_to_hf (local.dom ?f) * ide_to_hf (cod ?f).\n   hsnd XY = DOWN (Fun ?f (UP (hfst XY)))\\<rbrace>\n\ngoal (1 subgoal):\n 1. arr_to_hfun f \\<le> ide_to_hf (local.dom f) * ide_to_hf (cod f)", "by auto"], ["proof (state)\nthis:\n  arr_to_hfun f \\<le> ide_to_hf (local.dom f) * ide_to_hf (cod f)\n\ngoal (2 subgoals):\n 1. \\<And>X.\n       X \\<^bold>\\<in> ide_to_hf (local.dom f) \\<Longrightarrow>\n       \\<exists>!Y. \\<langle>X, Y\\<rangle> \\<^bold>\\<in> arr_to_hfun f\n 2. \\<And>X Y.\n       \\<langle>X, Y\\<rangle> \\<^bold>\\<in> arr_to_hfun f \\<Longrightarrow>\n       Y \\<^bold>\\<in> ide_to_hf (cod f)", "show \"\\<And>X. X \\<^bold>\\<in> ide_to_hf (dom f) \\<Longrightarrow> \\<exists>!Y. \\<langle>X, Y\\<rangle> \\<^bold>\\<in> arr_to_hfun f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X.\n       X \\<^bold>\\<in> ide_to_hf (local.dom f) \\<Longrightarrow>\n       \\<exists>!Y. \\<langle>X, Y\\<rangle> \\<^bold>\\<in> arr_to_hfun f", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>X.\n       X \\<^bold>\\<in> ide_to_hf (local.dom f) \\<Longrightarrow>\n       \\<langle>X, ?a X\\<rangle> \\<^bold>\\<in> arr_to_hfun f\n 2. \\<And>X Y.\n       \\<lbrakk>X \\<^bold>\\<in> ide_to_hf (local.dom f);\n        \\<langle>X, Y\\<rangle> \\<^bold>\\<in> arr_to_hfun f\\<rbrakk>\n       \\<Longrightarrow> Y = ?a X", "fix X"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>X.\n       X \\<^bold>\\<in> ide_to_hf (local.dom f) \\<Longrightarrow>\n       \\<langle>X, ?a X\\<rangle> \\<^bold>\\<in> arr_to_hfun f\n 2. \\<And>X Y.\n       \\<lbrakk>X \\<^bold>\\<in> ide_to_hf (local.dom f);\n        \\<langle>X, Y\\<rangle> \\<^bold>\\<in> arr_to_hfun f\\<rbrakk>\n       \\<Longrightarrow> Y = ?a X", "assume X: \"X \\<^bold>\\<in> ide_to_hf (dom f)\""], ["proof (state)\nthis:\n  X \\<^bold>\\<in> ide_to_hf (local.dom f)\n\ngoal (2 subgoals):\n 1. \\<And>X.\n       X \\<^bold>\\<in> ide_to_hf (local.dom f) \\<Longrightarrow>\n       \\<langle>X, ?a X\\<rangle> \\<^bold>\\<in> arr_to_hfun f\n 2. \\<And>X Y.\n       \\<lbrakk>X \\<^bold>\\<in> ide_to_hf (local.dom f);\n        \\<langle>X, Y\\<rangle> \\<^bold>\\<in> arr_to_hfun f\\<rbrakk>\n       \\<Longrightarrow> Y = ?a X", "show \"\\<langle>X, DOWN (Fun f (UP X))\\<rangle> \\<^bold>\\<in> arr_to_hfun f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>X, DOWN (Fun f (UP X))\\<rangle> \\<^bold>\\<in> arr_to_hfun f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<langle>X, DOWN (Fun f (UP X))\\<rangle> \\<^bold>\\<in> arr_to_hfun f", "have \"\\<langle>X, DOWN (Fun f (UP X))\\<rangle> \\<^bold>\\<in> \\<lbrace>XY \\<^bold>\\<in> ide_to_hf (dom f) * ide_to_hf (cod f).\n                     hsnd XY = DOWN (Fun f (UP (hfst XY)))\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>X, DOWN (Fun f (UP X))\\<rangle> \\<^bold>\\<in>\n    \\<lbrace>XY \\<^bold>\\<in> ide_to_hf (local.dom f) * ide_to_hf (cod f).\n     hsnd XY = DOWN (Fun f (UP (hfst XY)))\\<rbrace>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<langle>X, DOWN (Fun f (UP X))\\<rangle> \\<^bold>\\<in>\n    \\<lbrace>XY \\<^bold>\\<in> ide_to_hf (local.dom f) * ide_to_hf (cod f).\n     hsnd XY = DOWN (Fun f (UP (hfst XY)))\\<rbrace>", "have \"hsnd \\<langle>X, DOWN (Fun f (UP X))\\<rangle> =\n                  DOWN (Fun f (UP (hfst \\<langle>X, DOWN (Fun f (UP X))\\<rangle>)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hsnd \\<langle>X, DOWN (Fun f (UP X))\\<rangle> =\n    DOWN (Fun f (UP (hfst \\<langle>X, DOWN (Fun f (UP X))\\<rangle>)))", "using assms X"], ["proof (prove)\nusing this:\n  arr f\n  X \\<^bold>\\<in> ide_to_hf (local.dom f)\n\ngoal (1 subgoal):\n 1. hsnd \\<langle>X, DOWN (Fun f (UP X))\\<rangle> =\n    DOWN (Fun f (UP (hfst \\<langle>X, DOWN (Fun f (UP X))\\<rangle>)))", "by simp"], ["proof (state)\nthis:\n  hsnd \\<langle>X, DOWN (Fun f (UP X))\\<rangle> =\n  DOWN (Fun f (UP (hfst \\<langle>X, DOWN (Fun f (UP X))\\<rangle>)))\n\ngoal (1 subgoal):\n 1. \\<langle>X, DOWN (Fun f (UP X))\\<rangle> \\<^bold>\\<in>\n    \\<lbrace>XY \\<^bold>\\<in> ide_to_hf (local.dom f) * ide_to_hf (cod f).\n     hsnd XY = DOWN (Fun f (UP (hfst XY)))\\<rbrace>", "moreover"], ["proof (state)\nthis:\n  hsnd \\<langle>X, DOWN (Fun f (UP X))\\<rangle> =\n  DOWN (Fun f (UP (hfst \\<langle>X, DOWN (Fun f (UP X))\\<rangle>)))\n\ngoal (1 subgoal):\n 1. \\<langle>X, DOWN (Fun f (UP X))\\<rangle> \\<^bold>\\<in>\n    \\<lbrace>XY \\<^bold>\\<in> ide_to_hf (local.dom f) * ide_to_hf (cod f).\n     hsnd XY = DOWN (Fun f (UP (hfst XY)))\\<rbrace>", "have \"\\<langle>X, DOWN (Fun f (UP X))\\<rangle> \\<^bold>\\<in> ide_to_hf (dom f) * ide_to_hf (cod f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>X, DOWN (Fun f (UP X))\\<rangle> \\<^bold>\\<in>\n    ide_to_hf (local.dom f) * ide_to_hf (cod f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<langle>X, DOWN (Fun f (UP X))\\<rangle> \\<^bold>\\<in>\n    ide_to_hf (local.dom f) * ide_to_hf (cod f)", "have \"DOWN (Fun f (UP X)) \\<^bold>\\<in> ide_to_hf (cod f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DOWN (Fun f (UP X)) \\<^bold>\\<in> ide_to_hf (cod f)", "proof (intro DOWN_membI)"], ["proof (state)\ngoal (2 subgoals):\n 1. ide (cod f)\n 2. Fun f (UP X) \\<in> Cod f", "show \"ide (cod f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide (cod f)", "using assms ide_cod"], ["proof (prove)\nusing this:\n  arr f\n  arr ?f \\<Longrightarrow> ide (cod ?f)\n\ngoal (1 subgoal):\n 1. ide (cod f)", "by simp"], ["proof (state)\nthis:\n  ide (cod f)\n\ngoal (1 subgoal):\n 1. Fun f (UP X) \\<in> Cod f", "show \"Fun f (UP X) \\<in> Cod f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun f (UP X) \\<in> Cod f", "using assms X Fun_mapsto UP_membI"], ["proof (prove)\nusing this:\n  arr f\n  X \\<^bold>\\<in> ide_to_hf (local.dom f)\n  arr ?f \\<Longrightarrow>\n  Fun ?f \\<in> extensional (Dom ?f) \\<inter> (Dom ?f \\<rightarrow> Cod ?f)\n  ?x \\<^bold>\\<in> ide_to_hf ?a \\<Longrightarrow> UP ?x \\<in> local.set ?a\n\ngoal (1 subgoal):\n 1. Fun f (UP X) \\<in> Cod f", "by auto"], ["proof (state)\nthis:\n  Fun f (UP X) \\<in> Cod f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  DOWN (Fun f (UP X)) \\<^bold>\\<in> ide_to_hf (cod f)\n\ngoal (1 subgoal):\n 1. \\<langle>X, DOWN (Fun f (UP X))\\<rangle> \\<^bold>\\<in>\n    ide_to_hf (local.dom f) * ide_to_hf (cod f)", "thus ?thesis"], ["proof (prove)\nusing this:\n  DOWN (Fun f (UP X)) \\<^bold>\\<in> ide_to_hf (cod f)\n\ngoal (1 subgoal):\n 1. \\<langle>X, DOWN (Fun f (UP X))\\<rangle> \\<^bold>\\<in>\n    ide_to_hf (local.dom f) * ide_to_hf (cod f)", "using X"], ["proof (prove)\nusing this:\n  DOWN (Fun f (UP X)) \\<^bold>\\<in> ide_to_hf (cod f)\n  X \\<^bold>\\<in> ide_to_hf (local.dom f)\n\ngoal (1 subgoal):\n 1. \\<langle>X, DOWN (Fun f (UP X))\\<rangle> \\<^bold>\\<in>\n    ide_to_hf (local.dom f) * ide_to_hf (cod f)", "by simp"], ["proof (state)\nthis:\n  \\<langle>X, DOWN (Fun f (UP X))\\<rangle> \\<^bold>\\<in>\n  ide_to_hf (local.dom f) * ide_to_hf (cod f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<langle>X, DOWN (Fun f (UP X))\\<rangle> \\<^bold>\\<in>\n  ide_to_hf (local.dom f) * ide_to_hf (cod f)\n\ngoal (1 subgoal):\n 1. \\<langle>X, DOWN (Fun f (UP X))\\<rangle> \\<^bold>\\<in>\n    \\<lbrace>XY \\<^bold>\\<in> ide_to_hf (local.dom f) * ide_to_hf (cod f).\n     hsnd XY = DOWN (Fun f (UP (hfst XY)))\\<rbrace>", "ultimately"], ["proof (chain)\npicking this:\n  hsnd \\<langle>X, DOWN (Fun f (UP X))\\<rangle> =\n  DOWN (Fun f (UP (hfst \\<langle>X, DOWN (Fun f (UP X))\\<rangle>)))\n  \\<langle>X, DOWN (Fun f (UP X))\\<rangle> \\<^bold>\\<in>\n  ide_to_hf (local.dom f) * ide_to_hf (cod f)", "show ?thesis"], ["proof (prove)\nusing this:\n  hsnd \\<langle>X, DOWN (Fun f (UP X))\\<rangle> =\n  DOWN (Fun f (UP (hfst \\<langle>X, DOWN (Fun f (UP X))\\<rangle>)))\n  \\<langle>X, DOWN (Fun f (UP X))\\<rangle> \\<^bold>\\<in>\n  ide_to_hf (local.dom f) * ide_to_hf (cod f)\n\ngoal (1 subgoal):\n 1. \\<langle>X, DOWN (Fun f (UP X))\\<rangle> \\<^bold>\\<in>\n    \\<lbrace>XY \\<^bold>\\<in> ide_to_hf (local.dom f) * ide_to_hf (cod f).\n     hsnd XY = DOWN (Fun f (UP (hfst XY)))\\<rbrace>", "by simp"], ["proof (state)\nthis:\n  \\<langle>X, DOWN (Fun f (UP X))\\<rangle> \\<^bold>\\<in>\n  \\<lbrace>XY \\<^bold>\\<in> ide_to_hf (local.dom f) * ide_to_hf (cod f).\n   hsnd XY = DOWN (Fun f (UP (hfst XY)))\\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<langle>X, DOWN (Fun f (UP X))\\<rangle> \\<^bold>\\<in>\n  \\<lbrace>XY \\<^bold>\\<in> ide_to_hf (local.dom f) * ide_to_hf (cod f).\n   hsnd XY = DOWN (Fun f (UP (hfst XY)))\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<langle>X, DOWN (Fun f (UP X))\\<rangle> \\<^bold>\\<in> arr_to_hfun f", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<langle>X, DOWN (Fun f (UP X))\\<rangle> \\<^bold>\\<in>\n  \\<lbrace>XY \\<^bold>\\<in> ide_to_hf (local.dom f) * ide_to_hf (cod f).\n   hsnd XY = DOWN (Fun f (UP (hfst XY)))\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<langle>X, DOWN (Fun f (UP X))\\<rangle> \\<^bold>\\<in> arr_to_hfun f", "using arr_to_hfun_def"], ["proof (prove)\nusing this:\n  \\<langle>X, DOWN (Fun f (UP X))\\<rangle> \\<^bold>\\<in>\n  \\<lbrace>XY \\<^bold>\\<in> ide_to_hf (local.dom f) * ide_to_hf (cod f).\n   hsnd XY = DOWN (Fun f (UP (hfst XY)))\\<rbrace>\n  arr_to_hfun ?f =\n  \\<lbrace>XY \\<^bold>\\<in> ide_to_hf (local.dom ?f) * ide_to_hf (cod ?f).\n   hsnd XY = DOWN (Fun ?f (UP (hfst XY)))\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<langle>X, DOWN (Fun f (UP X))\\<rangle> \\<^bold>\\<in> arr_to_hfun f", "by simp"], ["proof (state)\nthis:\n  \\<langle>X, DOWN (Fun f (UP X))\\<rangle> \\<^bold>\\<in> arr_to_hfun f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<langle>X, DOWN (Fun f (UP X))\\<rangle> \\<^bold>\\<in> arr_to_hfun f\n\ngoal (1 subgoal):\n 1. \\<And>X Y.\n       \\<lbrakk>X \\<^bold>\\<in> ide_to_hf (local.dom f);\n        \\<langle>X, Y\\<rangle> \\<^bold>\\<in> arr_to_hfun f\\<rbrakk>\n       \\<Longrightarrow> Y = DOWN (Fun f (UP X))", "fix Y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>X Y.\n       \\<lbrakk>X \\<^bold>\\<in> ide_to_hf (local.dom f);\n        \\<langle>X, Y\\<rangle> \\<^bold>\\<in> arr_to_hfun f\\<rbrakk>\n       \\<Longrightarrow> Y = DOWN (Fun f (UP X))", "assume XY: \"\\<langle>X, Y\\<rangle> \\<^bold>\\<in> arr_to_hfun f\""], ["proof (state)\nthis:\n  \\<langle>X, Y\\<rangle> \\<^bold>\\<in> arr_to_hfun f\n\ngoal (1 subgoal):\n 1. \\<And>X Y.\n       \\<lbrakk>X \\<^bold>\\<in> ide_to_hf (local.dom f);\n        \\<langle>X, Y\\<rangle> \\<^bold>\\<in> arr_to_hfun f\\<rbrakk>\n       \\<Longrightarrow> Y = DOWN (Fun f (UP X))", "show \"Y = DOWN (Fun f (UP X))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y = DOWN (Fun f (UP X))", "using assms X XY arr_to_hfun_def"], ["proof (prove)\nusing this:\n  arr f\n  X \\<^bold>\\<in> ide_to_hf (local.dom f)\n  \\<langle>X, Y\\<rangle> \\<^bold>\\<in> arr_to_hfun f\n  arr_to_hfun ?f =\n  \\<lbrace>XY \\<^bold>\\<in> ide_to_hf (local.dom ?f) * ide_to_hf (cod ?f).\n   hsnd XY = DOWN (Fun ?f (UP (hfst XY)))\\<rbrace>\n\ngoal (1 subgoal):\n 1. Y = DOWN (Fun f (UP X))", "by auto"], ["proof (state)\nthis:\n  Y = DOWN (Fun f (UP X))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?X1 \\<^bold>\\<in> ide_to_hf (local.dom f) \\<Longrightarrow>\n  \\<exists>!Y. \\<langle>?X1, Y\\<rangle> \\<^bold>\\<in> arr_to_hfun f\n\ngoal (1 subgoal):\n 1. \\<And>X Y.\n       \\<langle>X, Y\\<rangle> \\<^bold>\\<in> arr_to_hfun f \\<Longrightarrow>\n       Y \\<^bold>\\<in> ide_to_hf (cod f)", "show \"\\<And>X Y. \\<langle>X, Y\\<rangle> \\<^bold>\\<in> arr_to_hfun f \\<Longrightarrow> Y \\<^bold>\\<in> ide_to_hf (cod f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X Y.\n       \\<langle>X, Y\\<rangle> \\<^bold>\\<in> arr_to_hfun f \\<Longrightarrow>\n       Y \\<^bold>\\<in> ide_to_hf (cod f)", "using assms arr_to_hfun_def ide_to_hf_def\n              \\<open>arr_to_hfun f \\<le> ide_to_hf (dom f) * ide_to_hf (cod f)\\<close>"], ["proof (prove)\nusing this:\n  arr f\n  arr_to_hfun ?f =\n  \\<lbrace>XY \\<^bold>\\<in> ide_to_hf (local.dom ?f) * ide_to_hf (cod ?f).\n   hsnd XY = DOWN (Fun ?f (UP (hfst XY)))\\<rbrace>\n  ide_to_hf ?a = HF (DOWN ` local.set ?a)\n  arr_to_hfun f \\<le> ide_to_hf (local.dom f) * ide_to_hf (cod f)\n\ngoal (1 subgoal):\n 1. \\<And>X Y.\n       \\<langle>X, Y\\<rangle> \\<^bold>\\<in> arr_to_hfun f \\<Longrightarrow>\n       Y \\<^bold>\\<in> ide_to_hf (cod f)", "by blast"], ["proof (state)\nthis:\n  \\<langle>?X1, ?Y1\\<rangle> \\<^bold>\\<in> arr_to_hfun f \\<Longrightarrow>\n  ?Y1 \\<^bold>\\<in> ide_to_hf (cod f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma arr_to_hfun_in_hexp:\n    assumes \"arr f\"\n    shows \"arr_to_hfun f \\<^bold>\\<in> hexp (ide_to_hf (dom f)) (ide_to_hf (cod f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr_to_hfun f \\<^bold>\\<in>\n    hexp (ide_to_hf (local.dom f)) (ide_to_hf (cod f))", "using assms arr_to_hfun_def hfun_arr_to_hfun hexp_def"], ["proof (prove)\nusing this:\n  arr f\n  arr_to_hfun ?f =\n  \\<lbrace>XY \\<^bold>\\<in> ide_to_hf (local.dom ?f) * ide_to_hf (cod ?f).\n   hsnd XY = DOWN (Fun ?f (UP (hfst XY)))\\<rbrace>\n  arr ?f \\<Longrightarrow>\n  hfun (ide_to_hf (local.dom ?f)) (ide_to_hf (cod ?f)) (arr_to_hfun ?f)\n  hexp ?B ?C = HCollect (hfun ?B ?C) (HPow (?B * ?C))\n\ngoal (1 subgoal):\n 1. arr_to_hfun f \\<^bold>\\<in>\n    hexp (ide_to_hf (local.dom f)) (ide_to_hf (cod f))", "by auto"], ["", "lemma hfun_to_arr_in_hom:\n    assumes \"hfun B C F\"\n    shows \"\\<guillemotleft>hfun_to_arr B C F : hf_to_ide B \\<rightarrow> hf_to_ide C\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>hfun_to_arr B C\n                     F : hf_to_ide\n                          B \\<rightarrow> hf_to_ide C\\<guillemotright>", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. arr (hfun_to_arr B C F)\n 2. local.dom (hfun_to_arr B C F) = hf_to_ide B\n 3. cod (hfun_to_arr B C F) = hf_to_ide C", "let ?f = \"mkArr (UP ` hfset B) (UP ` hfset C) (\\<lambda>x. UP (happ F (DOWN x)))\""], ["proof (state)\ngoal (3 subgoals):\n 1. arr (hfun_to_arr B C F)\n 2. local.dom (hfun_to_arr B C F) = hf_to_ide B\n 3. cod (hfun_to_arr B C F) = hf_to_ide C", "have 0: \"arr ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (mkArr (UP ` hfset B) (UP ` hfset C)\n          (\\<lambda>x. UP (happ F (DOWN x))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. arr (mkArr (UP ` hfset B) (UP ` hfset C)\n          (\\<lambda>x. UP (happ F (DOWN x))))", "have \"UP ` hfset B \\<subseteq> Univ \\<and> UP ` hfset C \\<subseteq> Univ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP ` hfset B \\<subseteq> Univ \\<and> UP ` hfset C \\<subseteq> Univ", "using UP_mapsto"], ["proof (prove)\nusing this:\n  UP \\<in> UNIV \\<rightarrow> Univ\n\ngoal (1 subgoal):\n 1. UP ` hfset B \\<subseteq> Univ \\<and> UP ` hfset C \\<subseteq> Univ", "by auto"], ["proof (state)\nthis:\n  UP ` hfset B \\<subseteq> Univ \\<and> UP ` hfset C \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. arr (mkArr (UP ` hfset B) (UP ` hfset C)\n          (\\<lambda>x. UP (happ F (DOWN x))))", "moreover"], ["proof (state)\nthis:\n  UP ` hfset B \\<subseteq> Univ \\<and> UP ` hfset C \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. arr (mkArr (UP ` hfset B) (UP ` hfset C)\n          (\\<lambda>x. UP (happ F (DOWN x))))", "have \"(\\<lambda>x. UP (happ F (DOWN x))) \\<in> UP ` hfset B \\<rightarrow> UP ` hfset C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. UP (happ F (DOWN x)))\n    \\<in> UP ` hfset B \\<rightarrow> UP ` hfset C", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> UP ` hfset B \\<Longrightarrow>\n       UP (happ F (DOWN x)) \\<in> UP ` hfset C", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> UP ` hfset B \\<Longrightarrow>\n       UP (happ F (DOWN x)) \\<in> UP ` hfset C", "assume x: \"x \\<in> UP ` hfset B\""], ["proof (state)\nthis:\n  x \\<in> UP ` hfset B\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> UP ` hfset B \\<Longrightarrow>\n       UP (happ F (DOWN x)) \\<in> UP ` hfset C", "have \"happ F (DOWN x) \\<in> hfset C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. happ F (DOWN x) \\<in> hfset C", "using assms x happ_mapsto hfun_in_hexp"], ["proof (prove)\nusing this:\n  hfun B C F\n  x \\<in> UP ` hfset B\n  \\<lbrakk>?F \\<^bold>\\<in> hexp ?B ?C; ?Y \\<^bold>\\<in> ?B\\<rbrakk>\n  \\<Longrightarrow> happ ?F ?Y \\<^bold>\\<in> ?C\n  \\<lbrakk>?F \\<^bold>\\<in> hexp ?B ?C; ?Y \\<^bold>\\<in> ?B\\<rbrakk>\n  \\<Longrightarrow> happ ?F ?Y \\<^bold>\\<in> hrange ?F\n  hfun ?B ?C ?F \\<Longrightarrow> ?F \\<^bold>\\<in> hexp ?B ?C\n\ngoal (1 subgoal):\n 1. happ F (DOWN x) \\<in> hfset C", "by (metis DOWN_UP HF_hfset finite_hfset hmem_HF_iff imageE)"], ["proof (state)\nthis:\n  happ F (DOWN x) \\<in> hfset C\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> UP ` hfset B \\<Longrightarrow>\n       UP (happ F (DOWN x)) \\<in> UP ` hfset C", "thus \"UP (happ F (DOWN x)) \\<in> UP ` hfset C\""], ["proof (prove)\nusing this:\n  happ F (DOWN x) \\<in> hfset C\n\ngoal (1 subgoal):\n 1. UP (happ F (DOWN x)) \\<in> UP ` hfset C", "by simp"], ["proof (state)\nthis:\n  UP (happ F (DOWN x)) \\<in> UP ` hfset C\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>x. UP (happ F (DOWN x)))\n  \\<in> UP ` hfset B \\<rightarrow> UP ` hfset C\n\ngoal (1 subgoal):\n 1. arr (mkArr (UP ` hfset B) (UP ` hfset C)\n          (\\<lambda>x. UP (happ F (DOWN x))))", "ultimately"], ["proof (chain)\npicking this:\n  UP ` hfset B \\<subseteq> Univ \\<and> UP ` hfset C \\<subseteq> Univ\n  (\\<lambda>x. UP (happ F (DOWN x)))\n  \\<in> UP ` hfset B \\<rightarrow> UP ` hfset C", "show ?thesis"], ["proof (prove)\nusing this:\n  UP ` hfset B \\<subseteq> Univ \\<and> UP ` hfset C \\<subseteq> Univ\n  (\\<lambda>x. UP (happ F (DOWN x)))\n  \\<in> UP ` hfset B \\<rightarrow> UP ` hfset C\n\ngoal (1 subgoal):\n 1. arr (mkArr (UP ` hfset B) (UP ` hfset C)\n          (\\<lambda>x. UP (happ F (DOWN x))))", "using arr_mkArr"], ["proof (prove)\nusing this:\n  UP ` hfset B \\<subseteq> Univ \\<and> UP ` hfset C \\<subseteq> Univ\n  (\\<lambda>x. UP (happ F (DOWN x)))\n  \\<in> UP ` hfset B \\<rightarrow> UP ` hfset C\n  arr (mkArr ?A ?B ?F) =\n  (?A \\<subseteq> Univ \\<and>\n   |?A| <o natLeq \\<and>\n   ?B \\<subseteq> Univ \\<and>\n   |?B| <o natLeq \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n\ngoal (1 subgoal):\n 1. arr (mkArr (UP ` hfset B) (UP ` hfset C)\n          (\\<lambda>x. UP (happ F (DOWN x))))", "by (meson finite_hfset finite_iff_ordLess_natLeq finite_imageI)"], ["proof (state)\nthis:\n  arr (mkArr (UP ` hfset B) (UP ` hfset C)\n        (\\<lambda>x. UP (happ F (DOWN x))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  arr (mkArr (UP ` hfset B) (UP ` hfset C)\n        (\\<lambda>x. UP (happ F (DOWN x))))\n\ngoal (3 subgoals):\n 1. arr (hfun_to_arr B C F)\n 2. local.dom (hfun_to_arr B C F) = hf_to_ide B\n 3. cod (hfun_to_arr B C F) = hf_to_ide C", "show 1: \"arr (hfun_to_arr B C F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (hfun_to_arr B C F)", "using 0 hfun_to_arr_def"], ["proof (prove)\nusing this:\n  arr (mkArr (UP ` hfset B) (UP ` hfset C)\n        (\\<lambda>x. UP (happ F (DOWN x))))\n  hfun_to_arr ?B ?C ?F =\n  mkArr (UP ` hfset ?B) (UP ` hfset ?C) (\\<lambda>x. UP (happ ?F (DOWN x)))\n\ngoal (1 subgoal):\n 1. arr (hfun_to_arr B C F)", "by simp"], ["proof (state)\nthis:\n  arr (hfun_to_arr B C F)\n\ngoal (2 subgoals):\n 1. local.dom (hfun_to_arr B C F) = hf_to_ide B\n 2. cod (hfun_to_arr B C F) = hf_to_ide C", "show \"dom (hfun_to_arr B C F) = hf_to_ide B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dom (hfun_to_arr B C F) = hf_to_ide B", "using 1 hfun_to_arr_def hf_to_ide_def dom_mkArr"], ["proof (prove)\nusing this:\n  arr (hfun_to_arr B C F)\n  hfun_to_arr ?B ?C ?F =\n  mkArr (UP ` hfset ?B) (UP ` hfset ?C) (\\<lambda>x. UP (happ ?F (DOWN x)))\n  hf_to_ide ?x = mkIde (UP ` hfset ?x)\n  arr (mkArr ?A ?B ?F) \\<Longrightarrow>\n  local.dom (mkArr ?A ?B ?F) = mkIde ?A\n\ngoal (1 subgoal):\n 1. local.dom (hfun_to_arr B C F) = hf_to_ide B", "by auto"], ["proof (state)\nthis:\n  local.dom (hfun_to_arr B C F) = hf_to_ide B\n\ngoal (1 subgoal):\n 1. cod (hfun_to_arr B C F) = hf_to_ide C", "show \"cod (hfun_to_arr B C F) = hf_to_ide C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cod (hfun_to_arr B C F) = hf_to_ide C", "using 1 hfun_to_arr_def hf_to_ide_def cod_mkArr"], ["proof (prove)\nusing this:\n  arr (hfun_to_arr B C F)\n  hfun_to_arr ?B ?C ?F =\n  mkArr (UP ` hfset ?B) (UP ` hfset ?C) (\\<lambda>x. UP (happ ?F (DOWN x)))\n  hf_to_ide ?x = mkIde (UP ` hfset ?x)\n  arr (mkArr ?A ?B ?F) \\<Longrightarrow> cod (mkArr ?A ?B ?F) = mkIde ?B\n\ngoal (1 subgoal):\n 1. cod (hfun_to_arr B C F) = hf_to_ide C", "by auto"], ["proof (state)\nthis:\n  cod (hfun_to_arr B C F) = hf_to_ide C\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n      The comprehension notation from @{theory HereditarilyFinite.HF} interferes in an\n      unfortunate way with the restriction notation from @{theory \"HOL-Library.FuncSet\"},\n      making it impossible to use both in the present context.\n    \\<close>"], ["", "lemma Fun_char:\n    assumes \"arr f\"\n    shows \"Fun f = restrict (\\<lambda>x. UP (happ (arr_to_hfun f) (DOWN x))) (Dom f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun f =\n    (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x)))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       Fun f x =\n       (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x))) x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       Fun f x =\n       (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x))) x", "show \"Fun f x = restrict (\\<lambda>x. UP (happ (arr_to_hfun f) (DOWN x))) (Dom f) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun f x =\n    (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x))) x", "proof (cases \"x \\<in> Dom f\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> Dom f \\<Longrightarrow>\n    Fun f x =\n    (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x))) x\n 2. x \\<notin> Dom f \\<Longrightarrow>\n    Fun f x =\n    (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x))) x", "show \"x \\<notin> Dom f \\<Longrightarrow> ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> Dom f \\<Longrightarrow>\n    Fun f x =\n    (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x))) x", "using assms Fun_mapsto Fun_def restrict_apply"], ["proof (prove)\nusing this:\n  arr f\n  arr ?f \\<Longrightarrow>\n  Fun ?f \\<in> extensional (Dom ?f) \\<inter> (Dom ?f \\<rightarrow> Cod ?f)\n  Fun ?f =\n  restrict\n   (some_img \\<circ> local.comp ?f \\<circ>\n    inv_into (hom unity (local.dom ?f)) some_img)\n   (Dom ?f)\n  restrict ?f ?A ?x = (if ?x \\<in> ?A then ?f ?x else undefined)\n\ngoal (1 subgoal):\n 1. x \\<notin> Dom f \\<Longrightarrow>\n    Fun f x =\n    (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x))) x", "by simp"], ["proof (state)\nthis:\n  x \\<notin> Dom f \\<Longrightarrow>\n  Fun f x =\n  (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x))) x\n\ngoal (1 subgoal):\n 1. x \\<in> Dom f \\<Longrightarrow>\n    Fun f x =\n    (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x))) x", "show \"x \\<in> Dom f \\<Longrightarrow> ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Dom f \\<Longrightarrow>\n    Fun f x =\n    (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x))) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> Dom f \\<Longrightarrow>\n    Fun f x =\n    (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x))) x", "assume x: \"x \\<in> Dom f\""], ["proof (state)\nthis:\n  x \\<in> Dom f\n\ngoal (1 subgoal):\n 1. x \\<in> Dom f \\<Longrightarrow>\n    Fun f x =\n    (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x))) x", "have 1: \"hfun (ide_to_hf (dom f)) (ide_to_hf (cod f)) (arr_to_hfun f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hfun (ide_to_hf (local.dom f)) (ide_to_hf (cod f)) (arr_to_hfun f)", "using assms app_def arr_to_hfun_def hfun_arr_to_hfun\n                  the1_equality [of \"\\<lambda>y. \\<langle>DOWN x, y\\<rangle> \\<^bold>\\<in> arr_to_hfun f\" \"DOWN (Fun f x)\"]"], ["proof (prove)\nusing this:\n  arr f\n  happ ?f ?x = (THE y. \\<langle>?x, y\\<rangle> \\<^bold>\\<in> ?f)\n  arr_to_hfun ?f =\n  \\<lbrace>XY \\<^bold>\\<in> ide_to_hf (local.dom ?f) * ide_to_hf (cod ?f).\n   hsnd XY = DOWN (Fun ?f (UP (hfst XY)))\\<rbrace>\n  arr ?f \\<Longrightarrow>\n  hfun (ide_to_hf (local.dom ?f)) (ide_to_hf (cod ?f)) (arr_to_hfun ?f)\n  \\<lbrakk>\\<exists>!xa.\n              \\<langle>DOWN x, xa\\<rangle> \\<^bold>\\<in> arr_to_hfun f;\n   \\<langle>DOWN x, DOWN (Fun f x)\\<rangle> \\<^bold>\\<in>\n   arr_to_hfun f\\<rbrakk>\n  \\<Longrightarrow> (THE xa.\n                        \\<langle>DOWN x, xa\\<rangle> \\<^bold>\\<in>\n                        arr_to_hfun f) =\n                    DOWN (Fun f x)\n\ngoal (1 subgoal):\n 1. hfun (ide_to_hf (local.dom f)) (ide_to_hf (cod f)) (arr_to_hfun f)", "by simp"], ["proof (state)\nthis:\n  hfun (ide_to_hf (local.dom f)) (ide_to_hf (cod f)) (arr_to_hfun f)\n\ngoal (1 subgoal):\n 1. x \\<in> Dom f \\<Longrightarrow>\n    Fun f x =\n    (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x))) x", "have 2: \"\\<exists>!Y. \\<langle>DOWN x, Y\\<rangle> \\<^bold>\\<in> arr_to_hfun f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!Y. \\<langle>DOWN x, Y\\<rangle> \\<^bold>\\<in> arr_to_hfun f", "using assms x 1 hfunE DOWN_membI ide_dom"], ["proof (prove)\nusing this:\n  arr f\n  x \\<in> Dom f\n  hfun (ide_to_hf (local.dom f)) (ide_to_hf (cod f)) (arr_to_hfun f)\n  \\<lbrakk>hfun ?B ?C ?F;\n   (\\<And>Y.\n       Y \\<^bold>\\<in> ?B \\<Longrightarrow>\n       (\\<exists>!Z. \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> ?F) \\<and>\n       (\\<forall>Z.\n           \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> ?F \\<longrightarrow>\n           Z \\<^bold>\\<in> ?C)) \\<Longrightarrow>\n   ?T\\<rbrakk>\n  \\<Longrightarrow> ?T\n  \\<lbrakk>ide ?a; ?x \\<in> local.set ?a\\<rbrakk>\n  \\<Longrightarrow> DOWN ?x \\<^bold>\\<in> ide_to_hf ?a\n  arr ?f \\<Longrightarrow> ide (local.dom ?f)\n\ngoal (1 subgoal):\n 1. \\<exists>!Y. \\<langle>DOWN x, Y\\<rangle> \\<^bold>\\<in> arr_to_hfun f", "by (metis (no_types, lifting))"], ["proof (state)\nthis:\n  \\<exists>!Y. \\<langle>DOWN x, Y\\<rangle> \\<^bold>\\<in> arr_to_hfun f\n\ngoal (1 subgoal):\n 1. x \\<in> Dom f \\<Longrightarrow>\n    Fun f x =\n    (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x))) x", "have \"Fun f x = UP (DOWN (Fun f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun f x = UP (DOWN (Fun f x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Fun f x = UP (DOWN (Fun f x))", "have \"Fun f x \\<in> Univ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun f x \\<in> Univ", "using assms x ide_cod Fun_mapsto [of f] set_subset_Univ"], ["proof (prove)\nusing this:\n  arr f\n  x \\<in> Dom f\n  arr ?f \\<Longrightarrow> ide (cod ?f)\n  arr f \\<Longrightarrow>\n  Fun f \\<in> extensional (Dom f) \\<inter> (Dom f \\<rightarrow> Cod f)\n  ide ?a \\<Longrightarrow> local.set ?a \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. Fun f x \\<in> Univ", "by auto"], ["proof (state)\nthis:\n  Fun f x \\<in> Univ\n\ngoal (1 subgoal):\n 1. Fun f x = UP (DOWN (Fun f x))", "thus ?thesis"], ["proof (prove)\nusing this:\n  Fun f x \\<in> Univ\n\ngoal (1 subgoal):\n 1. Fun f x = UP (DOWN (Fun f x))", "using UP_DOWN"], ["proof (prove)\nusing this:\n  Fun f x \\<in> Univ\n  ?t \\<in> Univ \\<Longrightarrow> UP (DOWN ?t) = ?t\n\ngoal (1 subgoal):\n 1. Fun f x = UP (DOWN (Fun f x))", "by simp"], ["proof (state)\nthis:\n  Fun f x = UP (DOWN (Fun f x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Fun f x = UP (DOWN (Fun f x))\n\ngoal (1 subgoal):\n 1. x \\<in> Dom f \\<Longrightarrow>\n    Fun f x =\n    (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x))) x", "also"], ["proof (state)\nthis:\n  Fun f x = UP (DOWN (Fun f x))\n\ngoal (1 subgoal):\n 1. x \\<in> Dom f \\<Longrightarrow>\n    Fun f x =\n    (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x))) x", "have \"... = UP (happ (arr_to_hfun f) (DOWN x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP (DOWN (Fun f x)) = UP (happ (arr_to_hfun f) (DOWN x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. UP (DOWN (Fun f x)) = UP (happ (arr_to_hfun f) (DOWN x))", "have \"\\<langle>DOWN x, DOWN (Fun f x)\\<rangle> \\<^bold>\\<in> arr_to_hfun f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>DOWN x, DOWN (Fun f x)\\<rangle> \\<^bold>\\<in> arr_to_hfun f", "using assms x 2 ide_dom arr_to_hfun_def set_subset_Univ UP_DOWN"], ["proof (prove)\nusing this:\n  arr f\n  x \\<in> Dom f\n  \\<exists>!Y. \\<langle>DOWN x, Y\\<rangle> \\<^bold>\\<in> arr_to_hfun f\n  arr ?f \\<Longrightarrow> ide (local.dom ?f)\n  arr_to_hfun ?f =\n  \\<lbrace>XY \\<^bold>\\<in> ide_to_hf (local.dom ?f) * ide_to_hf (cod ?f).\n   hsnd XY = DOWN (Fun ?f (UP (hfst XY)))\\<rbrace>\n  ide ?a \\<Longrightarrow> local.set ?a \\<subseteq> Univ\n  ?t \\<in> Univ \\<Longrightarrow> UP (DOWN ?t) = ?t\n\ngoal (1 subgoal):\n 1. \\<langle>DOWN x, DOWN (Fun f x)\\<rangle> \\<^bold>\\<in> arr_to_hfun f", "by (metis (mono_tags, lifting) HCollectE hfst_conv hsnd_conv subsetD)"], ["proof (state)\nthis:\n  \\<langle>DOWN x, DOWN (Fun f x)\\<rangle> \\<^bold>\\<in> arr_to_hfun f\n\ngoal (1 subgoal):\n 1. UP (DOWN (Fun f x)) = UP (happ (arr_to_hfun f) (DOWN x))", "moreover"], ["proof (state)\nthis:\n  \\<langle>DOWN x, DOWN (Fun f x)\\<rangle> \\<^bold>\\<in> arr_to_hfun f\n\ngoal (1 subgoal):\n 1. UP (DOWN (Fun f x)) = UP (happ (arr_to_hfun f) (DOWN x))", "have \"\\<langle>DOWN x, happ (arr_to_hfun f) (DOWN x)\\<rangle> \\<^bold>\\<in> arr_to_hfun f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>DOWN x, happ (arr_to_hfun f) (DOWN x)\\<rangle> \\<^bold>\\<in>\n    arr_to_hfun f", "using assms x 1 2 app_equality hfun_def"], ["proof (prove)\nusing this:\n  arr f\n  x \\<in> Dom f\n  hfun (ide_to_hf (local.dom f)) (ide_to_hf (cod f)) (arr_to_hfun f)\n  \\<exists>!Y. \\<langle>DOWN x, Y\\<rangle> \\<^bold>\\<in> arr_to_hfun f\n  \\<lbrakk>hfunction ?f; \\<langle>?x, ?y\\<rangle> \\<^bold>\\<in> ?f\\<rbrakk>\n  \\<Longrightarrow> happ ?f ?x = ?y\n  hfun ?B ?C ?F \\<equiv>\n  ?F \\<le> ?B * ?C \\<and>\n  hfunction ?F \\<and> hdomain ?F = ?B \\<and> hrange ?F \\<le> ?C\n\ngoal (1 subgoal):\n 1. \\<langle>DOWN x, happ (arr_to_hfun f) (DOWN x)\\<rangle> \\<^bold>\\<in>\n    arr_to_hfun f", "by blast"], ["proof (state)\nthis:\n  \\<langle>DOWN x, happ (arr_to_hfun f) (DOWN x)\\<rangle> \\<^bold>\\<in>\n  arr_to_hfun f\n\ngoal (1 subgoal):\n 1. UP (DOWN (Fun f x)) = UP (happ (arr_to_hfun f) (DOWN x))", "ultimately"], ["proof (chain)\npicking this:\n  \\<langle>DOWN x, DOWN (Fun f x)\\<rangle> \\<^bold>\\<in> arr_to_hfun f\n  \\<langle>DOWN x, happ (arr_to_hfun f) (DOWN x)\\<rangle> \\<^bold>\\<in>\n  arr_to_hfun f", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<langle>DOWN x, DOWN (Fun f x)\\<rangle> \\<^bold>\\<in> arr_to_hfun f\n  \\<langle>DOWN x, happ (arr_to_hfun f) (DOWN x)\\<rangle> \\<^bold>\\<in>\n  arr_to_hfun f\n\ngoal (1 subgoal):\n 1. UP (DOWN (Fun f x)) = UP (happ (arr_to_hfun f) (DOWN x))", "using 2"], ["proof (prove)\nusing this:\n  \\<langle>DOWN x, DOWN (Fun f x)\\<rangle> \\<^bold>\\<in> arr_to_hfun f\n  \\<langle>DOWN x, happ (arr_to_hfun f) (DOWN x)\\<rangle> \\<^bold>\\<in>\n  arr_to_hfun f\n  \\<exists>!Y. \\<langle>DOWN x, Y\\<rangle> \\<^bold>\\<in> arr_to_hfun f\n\ngoal (1 subgoal):\n 1. UP (DOWN (Fun f x)) = UP (happ (arr_to_hfun f) (DOWN x))", "by fastforce"], ["proof (state)\nthis:\n  UP (DOWN (Fun f x)) = UP (happ (arr_to_hfun f) (DOWN x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  UP (DOWN (Fun f x)) = UP (happ (arr_to_hfun f) (DOWN x))\n\ngoal (1 subgoal):\n 1. x \\<in> Dom f \\<Longrightarrow>\n    Fun f x =\n    (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x))) x", "also"], ["proof (state)\nthis:\n  UP (DOWN (Fun f x)) = UP (happ (arr_to_hfun f) (DOWN x))\n\ngoal (1 subgoal):\n 1. x \\<in> Dom f \\<Longrightarrow>\n    Fun f x =\n    (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x))) x", "have \"... = restrict (\\<lambda>x. UP (happ (arr_to_hfun f) (DOWN x))) (Dom f) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP (happ (arr_to_hfun f) (DOWN x)) =\n    (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x))) x", "using assms x ide_dom"], ["proof (prove)\nusing this:\n  arr f\n  x \\<in> Dom f\n  arr ?f \\<Longrightarrow> ide (local.dom ?f)\n\ngoal (1 subgoal):\n 1. UP (happ (arr_to_hfun f) (DOWN x)) =\n    (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x))) x", "by auto"], ["proof (state)\nthis:\n  UP (happ (arr_to_hfun f) (DOWN x)) =\n  (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x))) x\n\ngoal (1 subgoal):\n 1. x \\<in> Dom f \\<Longrightarrow>\n    Fun f x =\n    (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x))) x", "finally"], ["proof (chain)\npicking this:\n  Fun f x =\n  (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x))) x", "show ?thesis"], ["proof (prove)\nusing this:\n  Fun f x =\n  (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x))) x\n\ngoal (1 subgoal):\n 1. Fun f x =\n    (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x))) x", "by simp"], ["proof (state)\nthis:\n  Fun f x =\n  (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x))) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> Dom f \\<Longrightarrow>\n  Fun f x =\n  (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x))) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Fun f x =\n  (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x))) x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Fun_hfun_to_arr:\n    assumes \"hfun B C F\"\n    shows \"Fun (hfun_to_arr B C F) = restrict (\\<lambda>x. UP (happ F (DOWN x))) (UP ` hfset B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (hfun_to_arr B C F) =\n    (\\<lambda>x\\<^bold>\\<in>UP ` hfset B. UP (happ F (DOWN x)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Fun (hfun_to_arr B C F) =\n    (\\<lambda>x\\<^bold>\\<in>UP ` hfset B. UP (happ F (DOWN x)))", "have \"arr (hfun_to_arr B C F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (hfun_to_arr B C F)", "using assms hfun_to_arr_in_hom"], ["proof (prove)\nusing this:\n  hfun B C F\n  hfun ?B ?C ?F \\<Longrightarrow>\n  \\<guillemotleft>hfun_to_arr ?B ?C\n                   ?F : hf_to_ide\n                         ?B \\<rightarrow> hf_to_ide ?C\\<guillemotright>\n\ngoal (1 subgoal):\n 1. arr (hfun_to_arr B C F)", "by blast"], ["proof (state)\nthis:\n  arr (hfun_to_arr B C F)\n\ngoal (1 subgoal):\n 1. Fun (hfun_to_arr B C F) =\n    (\\<lambda>x\\<^bold>\\<in>UP ` hfset B. UP (happ F (DOWN x)))", "hence \"arr (mkArr (UP ` hfset B) (UP ` hfset C) (\\<lambda>x. UP (happ F (DOWN x))))\""], ["proof (prove)\nusing this:\n  arr (hfun_to_arr B C F)\n\ngoal (1 subgoal):\n 1. arr (mkArr (UP ` hfset B) (UP ` hfset C)\n          (\\<lambda>x. UP (happ F (DOWN x))))", "using hfun_to_arr_def"], ["proof (prove)\nusing this:\n  arr (hfun_to_arr B C F)\n  hfun_to_arr ?B ?C ?F =\n  mkArr (UP ` hfset ?B) (UP ` hfset ?C) (\\<lambda>x. UP (happ ?F (DOWN x)))\n\ngoal (1 subgoal):\n 1. arr (mkArr (UP ` hfset B) (UP ` hfset C)\n          (\\<lambda>x. UP (happ F (DOWN x))))", "by simp"], ["proof (state)\nthis:\n  arr (mkArr (UP ` hfset B) (UP ` hfset C)\n        (\\<lambda>x. UP (happ F (DOWN x))))\n\ngoal (1 subgoal):\n 1. Fun (hfun_to_arr B C F) =\n    (\\<lambda>x\\<^bold>\\<in>UP ` hfset B. UP (happ F (DOWN x)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  arr (mkArr (UP ` hfset B) (UP ` hfset C)\n        (\\<lambda>x. UP (happ F (DOWN x))))\n\ngoal (1 subgoal):\n 1. Fun (hfun_to_arr B C F) =\n    (\\<lambda>x\\<^bold>\\<in>UP ` hfset B. UP (happ F (DOWN x)))", "using assms hfun_to_arr_def Fun_mkArr"], ["proof (prove)\nusing this:\n  arr (mkArr (UP ` hfset B) (UP ` hfset C)\n        (\\<lambda>x. UP (happ F (DOWN x))))\n  hfun B C F\n  hfun_to_arr ?B ?C ?F =\n  mkArr (UP ` hfset ?B) (UP ` hfset ?C) (\\<lambda>x. UP (happ ?F (DOWN x)))\n  arr (mkArr ?A ?B ?F) \\<Longrightarrow>\n  Fun (mkArr ?A ?B ?F) = restrict ?F ?A\n\ngoal (1 subgoal):\n 1. Fun (hfun_to_arr B C F) =\n    (\\<lambda>x\\<^bold>\\<in>UP ` hfset B. UP (happ F (DOWN x)))", "by simp"], ["proof (state)\nthis:\n  Fun (hfun_to_arr B C F) =\n  (\\<lambda>x\\<^bold>\\<in>UP ` hfset B. UP (happ F (DOWN x)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma UP_img_hfset_ide_to_hf:\n    assumes \"ide a\"\n    shows \"UP ` hfset (ide_to_hf a) = set a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP ` hfset (ide_to_hf a) = local.set a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. UP ` hfset (ide_to_hf a) = local.set a", "have \"UP ` hfset (ide_to_hf a) = UP ` hfset (HF (DOWN ` set a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP ` hfset (ide_to_hf a) = UP ` hfset (HF (DOWN ` local.set a))", "using ide_to_hf_def"], ["proof (prove)\nusing this:\n  ide_to_hf ?a = HF (DOWN ` local.set ?a)\n\ngoal (1 subgoal):\n 1. UP ` hfset (ide_to_hf a) = UP ` hfset (HF (DOWN ` local.set a))", "by simp"], ["proof (state)\nthis:\n  UP ` hfset (ide_to_hf a) = UP ` hfset (HF (DOWN ` local.set a))\n\ngoal (1 subgoal):\n 1. UP ` hfset (ide_to_hf a) = local.set a", "also"], ["proof (state)\nthis:\n  UP ` hfset (ide_to_hf a) = UP ` hfset (HF (DOWN ` local.set a))\n\ngoal (1 subgoal):\n 1. UP ` hfset (ide_to_hf a) = local.set a", "have \"... = UP ` DOWN ` set a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP ` hfset (HF (DOWN ` local.set a)) = UP ` DOWN ` local.set a", "using assms ide_implies_finite_set(1) ide_char"], ["proof (prove)\nusing this:\n  ide a\n  ide ?a \\<Longrightarrow> finite (local.set ?a)\n  arr ?f \\<Longrightarrow>\n  ide ?f =\n  (Dom ?f = Cod ?f \\<and> Fun ?f = (\\<lambda>x\\<^bold>\\<in>Dom ?f. x))\n\ngoal (1 subgoal):\n 1. UP ` hfset (HF (DOWN ` local.set a)) = UP ` DOWN ` local.set a", "by auto"], ["proof (state)\nthis:\n  UP ` hfset (HF (DOWN ` local.set a)) = UP ` DOWN ` local.set a\n\ngoal (1 subgoal):\n 1. UP ` hfset (ide_to_hf a) = local.set a", "also"], ["proof (state)\nthis:\n  UP ` hfset (HF (DOWN ` local.set a)) = UP ` DOWN ` local.set a\n\ngoal (1 subgoal):\n 1. UP ` hfset (ide_to_hf a) = local.set a", "have \"... = set a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP ` DOWN ` local.set a = local.set a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. UP ` DOWN ` local.set a = local.set a", "have \"\\<And>x. x \\<in> set a \\<Longrightarrow> UP (DOWN x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> local.set a \\<Longrightarrow> UP (DOWN x) = x", "using assms ide_char"], ["proof (prove)\nusing this:\n  ide a\n  arr ?f \\<Longrightarrow>\n  ide ?f =\n  (Dom ?f = Cod ?f \\<and> Fun ?f = (\\<lambda>x\\<^bold>\\<in>Dom ?f. x))\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> local.set a \\<Longrightarrow> UP (DOWN x) = x", "by (metis (no_types, lifting) UP_DOWN set_subset_Univ subsetD)"], ["proof (state)\nthis:\n  ?x1 \\<in> local.set a \\<Longrightarrow> UP (DOWN ?x1) = ?x1\n\ngoal (1 subgoal):\n 1. UP ` DOWN ` local.set a = local.set a", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?x1 \\<in> local.set a \\<Longrightarrow> UP (DOWN ?x1) = ?x1\n\ngoal (1 subgoal):\n 1. UP ` DOWN ` local.set a = local.set a", "by force"], ["proof (state)\nthis:\n  UP ` DOWN ` local.set a = local.set a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  UP ` DOWN ` local.set a = local.set a\n\ngoal (1 subgoal):\n 1. UP ` hfset (ide_to_hf a) = local.set a", "finally"], ["proof (chain)\npicking this:\n  UP ` hfset (ide_to_hf a) = local.set a", "show ?thesis"], ["proof (prove)\nusing this:\n  UP ` hfset (ide_to_hf a) = local.set a\n\ngoal (1 subgoal):\n 1. UP ` hfset (ide_to_hf a) = local.set a", "by blast"], ["proof (state)\nthis:\n  UP ` hfset (ide_to_hf a) = local.set a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hfun_to_arr_arr_to_hfun:\n    assumes \"arr f\"\n    shows \"hfun_to_arr (ide_to_hf (dom f)) (ide_to_hf (cod f)) (arr_to_hfun f) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hfun_to_arr (ide_to_hf (local.dom f)) (ide_to_hf (cod f))\n     (arr_to_hfun f) =\n    f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. hfun_to_arr (ide_to_hf (local.dom f)) (ide_to_hf (cod f))\n     (arr_to_hfun f) =\n    f", "have 0: \"hfun_to_arr (ide_to_hf (dom f)) (ide_to_hf (cod f)) (arr_to_hfun f) =\n               mkArr (UP ` hfset (ide_to_hf (dom f))) (UP ` hfset (ide_to_hf (cod f)))\n                     (\\<lambda>x. UP (happ (arr_to_hfun f) (DOWN x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hfun_to_arr (ide_to_hf (local.dom f)) (ide_to_hf (cod f))\n     (arr_to_hfun f) =\n    mkArr (UP ` hfset (ide_to_hf (local.dom f)))\n     (UP ` hfset (ide_to_hf (cod f)))\n     (\\<lambda>x. UP (happ (arr_to_hfun f) (DOWN x)))", "unfolding hfun_to_arr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. mkArr (UP ` hfset (ide_to_hf (local.dom f)))\n     (UP ` hfset (ide_to_hf (cod f)))\n     (\\<lambda>x. UP (happ (arr_to_hfun f) (DOWN x))) =\n    mkArr (UP ` hfset (ide_to_hf (local.dom f)))\n     (UP ` hfset (ide_to_hf (cod f)))\n     (\\<lambda>x. UP (happ (arr_to_hfun f) (DOWN x)))", "by blast"], ["proof (state)\nthis:\n  hfun_to_arr (ide_to_hf (local.dom f)) (ide_to_hf (cod f))\n   (arr_to_hfun f) =\n  mkArr (UP ` hfset (ide_to_hf (local.dom f)))\n   (UP ` hfset (ide_to_hf (cod f)))\n   (\\<lambda>x. UP (happ (arr_to_hfun f) (DOWN x)))\n\ngoal (1 subgoal):\n 1. hfun_to_arr (ide_to_hf (local.dom f)) (ide_to_hf (cod f))\n     (arr_to_hfun f) =\n    f", "also"], ["proof (state)\nthis:\n  hfun_to_arr (ide_to_hf (local.dom f)) (ide_to_hf (cod f))\n   (arr_to_hfun f) =\n  mkArr (UP ` hfset (ide_to_hf (local.dom f)))\n   (UP ` hfset (ide_to_hf (cod f)))\n   (\\<lambda>x. UP (happ (arr_to_hfun f) (DOWN x)))\n\ngoal (1 subgoal):\n 1. hfun_to_arr (ide_to_hf (local.dom f)) (ide_to_hf (cod f))\n     (arr_to_hfun f) =\n    f", "have \"... = mkArr (Dom f) (Cod f)\n                             (restrict (\\<lambda>x. UP (happ (arr_to_hfun f) (DOWN x))) (Dom f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mkArr (UP ` hfset (ide_to_hf (local.dom f)))\n     (UP ` hfset (ide_to_hf (cod f)))\n     (\\<lambda>x. UP (happ (arr_to_hfun f) (DOWN x))) =\n    mkArr (Dom f) (Cod f)\n     (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x)))", "proof (intro mkArr_eqI)"], ["proof (state)\ngoal (4 subgoals):\n 1. arr (mkArr (UP ` hfset (ide_to_hf (local.dom f)))\n          (UP ` hfset (ide_to_hf (cod f)))\n          (\\<lambda>x. UP (happ (arr_to_hfun f) (DOWN x))))\n 2. UP ` hfset (ide_to_hf (local.dom f)) = Dom f\n 3. UP ` hfset (ide_to_hf (cod f)) = Cod f\n 4. \\<And>x.\n       x \\<in> UP ` hfset (ide_to_hf (local.dom f)) \\<Longrightarrow>\n       UP (happ (arr_to_hfun f) (DOWN x)) =\n       (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x))) x", "show 1: \"UP ` hfset (ide_to_hf (dom f)) = Dom f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP ` hfset (ide_to_hf (local.dom f)) = Dom f", "using assms UP_img_hfset_ide_to_hf ide_dom"], ["proof (prove)\nusing this:\n  arr f\n  ide ?a \\<Longrightarrow> UP ` hfset (ide_to_hf ?a) = local.set ?a\n  arr ?f \\<Longrightarrow> ide (local.dom ?f)\n\ngoal (1 subgoal):\n 1. UP ` hfset (ide_to_hf (local.dom f)) = Dom f", "by simp"], ["proof (state)\nthis:\n  UP ` hfset (ide_to_hf (local.dom f)) = Dom f\n\ngoal (3 subgoals):\n 1. arr (mkArr (UP ` hfset (ide_to_hf (local.dom f)))\n          (UP ` hfset (ide_to_hf (cod f)))\n          (\\<lambda>x. UP (happ (arr_to_hfun f) (DOWN x))))\n 2. UP ` hfset (ide_to_hf (cod f)) = Cod f\n 3. \\<And>x.\n       x \\<in> UP ` hfset (ide_to_hf (local.dom f)) \\<Longrightarrow>\n       UP (happ (arr_to_hfun f) (DOWN x)) =\n       (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x))) x", "show 2: \"UP ` hfset (ide_to_hf (cod f)) = Cod f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP ` hfset (ide_to_hf (cod f)) = Cod f", "using assms UP_img_hfset_ide_to_hf ide_cod"], ["proof (prove)\nusing this:\n  arr f\n  ide ?a \\<Longrightarrow> UP ` hfset (ide_to_hf ?a) = local.set ?a\n  arr ?f \\<Longrightarrow> ide (cod ?f)\n\ngoal (1 subgoal):\n 1. UP ` hfset (ide_to_hf (cod f)) = Cod f", "by simp"], ["proof (state)\nthis:\n  UP ` hfset (ide_to_hf (cod f)) = Cod f\n\ngoal (2 subgoals):\n 1. arr (mkArr (UP ` hfset (ide_to_hf (local.dom f)))\n          (UP ` hfset (ide_to_hf (cod f)))\n          (\\<lambda>x. UP (happ (arr_to_hfun f) (DOWN x))))\n 2. \\<And>x.\n       x \\<in> UP ` hfset (ide_to_hf (local.dom f)) \\<Longrightarrow>\n       UP (happ (arr_to_hfun f) (DOWN x)) =\n       (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x))) x", "show \"arr (mkArr (UP ` hfset (ide_to_hf (dom f))) (UP ` hfset (ide_to_hf (cod f)))\n                         (\\<lambda>x. UP (happ (arr_to_hfun f) (DOWN x))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (mkArr (UP ` hfset (ide_to_hf (local.dom f)))\n          (UP ` hfset (ide_to_hf (cod f)))\n          (\\<lambda>x. UP (happ (arr_to_hfun f) (DOWN x))))", "using 0 1 2"], ["proof (prove)\nusing this:\n  hfun_to_arr (ide_to_hf (local.dom f)) (ide_to_hf (cod f))\n   (arr_to_hfun f) =\n  mkArr (UP ` hfset (ide_to_hf (local.dom f)))\n   (UP ` hfset (ide_to_hf (cod f)))\n   (\\<lambda>x. UP (happ (arr_to_hfun f) (DOWN x)))\n  UP ` hfset (ide_to_hf (local.dom f)) = Dom f\n  UP ` hfset (ide_to_hf (cod f)) = Cod f\n\ngoal (1 subgoal):\n 1. arr (mkArr (UP ` hfset (ide_to_hf (local.dom f)))\n          (UP ` hfset (ide_to_hf (cod f)))\n          (\\<lambda>x. UP (happ (arr_to_hfun f) (DOWN x))))", "by (metis (no_types, lifting) arrI assms hfun_arr_to_hfun hfun_to_arr_in_hom)"], ["proof (state)\nthis:\n  arr (mkArr (UP ` hfset (ide_to_hf (local.dom f)))\n        (UP ` hfset (ide_to_hf (cod f)))\n        (\\<lambda>x. UP (happ (arr_to_hfun f) (DOWN x))))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> UP ` hfset (ide_to_hf (local.dom f)) \\<Longrightarrow>\n       UP (happ (arr_to_hfun f) (DOWN x)) =\n       (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x))) x", "show \"\\<And>x. x \\<in> UP ` hfset (ide_to_hf (dom f)) \\<Longrightarrow>\n                     UP (happ (arr_to_hfun f) (DOWN x)) =\n                     restrict (\\<lambda>x. UP (happ (arr_to_hfun f) (DOWN x))) (Dom f) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> UP ` hfset (ide_to_hf (local.dom f)) \\<Longrightarrow>\n       UP (happ (arr_to_hfun f) (DOWN x)) =\n       (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x))) x", "using assms 1"], ["proof (prove)\nusing this:\n  arr f\n  UP ` hfset (ide_to_hf (local.dom f)) = Dom f\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> UP ` hfset (ide_to_hf (local.dom f)) \\<Longrightarrow>\n       UP (happ (arr_to_hfun f) (DOWN x)) =\n       (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x))) x", "by simp"], ["proof (state)\nthis:\n  ?x1 \\<in> UP ` hfset (ide_to_hf (local.dom f)) \\<Longrightarrow>\n  UP (happ (arr_to_hfun f) (DOWN ?x1)) =\n  (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x))) ?x1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mkArr (UP ` hfset (ide_to_hf (local.dom f)))\n   (UP ` hfset (ide_to_hf (cod f)))\n   (\\<lambda>x. UP (happ (arr_to_hfun f) (DOWN x))) =\n  mkArr (Dom f) (Cod f)\n   (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x)))\n\ngoal (1 subgoal):\n 1. hfun_to_arr (ide_to_hf (local.dom f)) (ide_to_hf (cod f))\n     (arr_to_hfun f) =\n    f", "also"], ["proof (state)\nthis:\n  mkArr (UP ` hfset (ide_to_hf (local.dom f)))\n   (UP ` hfset (ide_to_hf (cod f)))\n   (\\<lambda>x. UP (happ (arr_to_hfun f) (DOWN x))) =\n  mkArr (Dom f) (Cod f)\n   (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x)))\n\ngoal (1 subgoal):\n 1. hfun_to_arr (ide_to_hf (local.dom f)) (ide_to_hf (cod f))\n     (arr_to_hfun f) =\n    f", "have \"... = mkArr (Dom f) (Cod f) (Fun f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mkArr (Dom f) (Cod f)\n     (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x))) =\n    mkArr (Dom f) (Cod f) (Fun f)", "using assms Fun_char mkArr_eqI"], ["proof (prove)\nusing this:\n  arr f\n  arr ?f \\<Longrightarrow>\n  Fun ?f =\n  (\\<lambda>x\\<^bold>\\<in>Dom ?f. UP (happ (arr_to_hfun ?f) (DOWN x)))\n  \\<lbrakk>arr (mkArr ?A ?B ?F); ?A = ?A'; ?B = ?B';\n   \\<And>x. x \\<in> ?A \\<Longrightarrow> ?F x = ?F' x\\<rbrakk>\n  \\<Longrightarrow> mkArr ?A ?B ?F = mkArr ?A' ?B' ?F'\n\ngoal (1 subgoal):\n 1. mkArr (Dom f) (Cod f)\n     (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x))) =\n    mkArr (Dom f) (Cod f) (Fun f)", "by simp"], ["proof (state)\nthis:\n  mkArr (Dom f) (Cod f)\n   (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x))) =\n  mkArr (Dom f) (Cod f) (Fun f)\n\ngoal (1 subgoal):\n 1. hfun_to_arr (ide_to_hf (local.dom f)) (ide_to_hf (cod f))\n     (arr_to_hfun f) =\n    f", "also"], ["proof (state)\nthis:\n  mkArr (Dom f) (Cod f)\n   (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x))) =\n  mkArr (Dom f) (Cod f) (Fun f)\n\ngoal (1 subgoal):\n 1. hfun_to_arr (ide_to_hf (local.dom f)) (ide_to_hf (cod f))\n     (arr_to_hfun f) =\n    f", "have \"... = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mkArr (Dom f) (Cod f) (Fun f) = f", "using assms mkArr_Fun"], ["proof (prove)\nusing this:\n  arr f\n  arr ?f \\<Longrightarrow> mkArr (Dom ?f) (Cod ?f) (Fun ?f) = ?f\n\ngoal (1 subgoal):\n 1. mkArr (Dom f) (Cod f) (Fun f) = f", "by blast"], ["proof (state)\nthis:\n  mkArr (Dom f) (Cod f) (Fun f) = f\n\ngoal (1 subgoal):\n 1. hfun_to_arr (ide_to_hf (local.dom f)) (ide_to_hf (cod f))\n     (arr_to_hfun f) =\n    f", "finally"], ["proof (chain)\npicking this:\n  hfun_to_arr (ide_to_hf (local.dom f)) (ide_to_hf (cod f))\n   (arr_to_hfun f) =\n  f", "show ?thesis"], ["proof (prove)\nusing this:\n  hfun_to_arr (ide_to_hf (local.dom f)) (ide_to_hf (cod f))\n   (arr_to_hfun f) =\n  f\n\ngoal (1 subgoal):\n 1. hfun_to_arr (ide_to_hf (local.dom f)) (ide_to_hf (cod f))\n     (arr_to_hfun f) =\n    f", "by simp"], ["proof (state)\nthis:\n  hfun_to_arr (ide_to_hf (local.dom f)) (ide_to_hf (cod f))\n   (arr_to_hfun f) =\n  f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma arr_to_hfun_hfun_to_arr:\n    assumes \"hfun B C F\"\n    shows \"arr_to_hfun (hfun_to_arr B C F) = F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr_to_hfun (hfun_to_arr B C F) = F", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. arr_to_hfun (hfun_to_arr B C F) = F", "have \"arr_to_hfun (hfun_to_arr B C F) =\n            \\<lbrace>XY \\<^bold>\\<in> ide_to_hf (dom (hfun_to_arr B C F)) * ide_to_hf (cod (hfun_to_arr B C F)).\n               hsnd XY = DOWN (Fun (hfun_to_arr B C F) (UP (hfst XY)))\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr_to_hfun (hfun_to_arr B C F) =\n    \\<lbrace>XY \\<^bold>\\<in>\n     ide_to_hf (local.dom (hfun_to_arr B C F)) *\n     ide_to_hf (cod (hfun_to_arr B C F)).\n     hsnd XY = DOWN (Fun (hfun_to_arr B C F) (UP (hfst XY)))\\<rbrace>", "unfolding arr_to_hfun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>XY \\<^bold>\\<in>\n     ide_to_hf (local.dom (hfun_to_arr B C F)) *\n     ide_to_hf (cod (hfun_to_arr B C F)).\n     hsnd XY = DOWN (Fun (hfun_to_arr B C F) (UP (hfst XY)))\\<rbrace> =\n    \\<lbrace>XY \\<^bold>\\<in>\n     ide_to_hf (local.dom (hfun_to_arr B C F)) *\n     ide_to_hf (cod (hfun_to_arr B C F)).\n     hsnd XY = DOWN (Fun (hfun_to_arr B C F) (UP (hfst XY)))\\<rbrace>", "by blast"], ["proof (state)\nthis:\n  arr_to_hfun (hfun_to_arr B C F) =\n  \\<lbrace>XY \\<^bold>\\<in>\n   ide_to_hf (local.dom (hfun_to_arr B C F)) *\n   ide_to_hf (cod (hfun_to_arr B C F)).\n   hsnd XY = DOWN (Fun (hfun_to_arr B C F) (UP (hfst XY)))\\<rbrace>\n\ngoal (1 subgoal):\n 1. arr_to_hfun (hfun_to_arr B C F) = F", "also"], ["proof (state)\nthis:\n  arr_to_hfun (hfun_to_arr B C F) =\n  \\<lbrace>XY \\<^bold>\\<in>\n   ide_to_hf (local.dom (hfun_to_arr B C F)) *\n   ide_to_hf (cod (hfun_to_arr B C F)).\n   hsnd XY = DOWN (Fun (hfun_to_arr B C F) (UP (hfst XY)))\\<rbrace>\n\ngoal (1 subgoal):\n 1. arr_to_hfun (hfun_to_arr B C F) = F", "have\n          \"... = \\<lbrace>XY \\<^bold>\\<in> ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n                    hsnd XY = DOWN (Fun (hfun_to_arr B C F) (UP (hfst XY)))\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>XY \\<^bold>\\<in>\n     ide_to_hf (local.dom (hfun_to_arr B C F)) *\n     ide_to_hf (cod (hfun_to_arr B C F)).\n     hsnd XY = DOWN (Fun (hfun_to_arr B C F) (UP (hfst XY)))\\<rbrace> =\n    \\<lbrace>XY \\<^bold>\\<in>\n     ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n     hsnd XY = DOWN (Fun (hfun_to_arr B C F) (UP (hfst XY)))\\<rbrace>", "using assms hfun_to_arr_in_hom [of B C F] hf_to_ide_def"], ["proof (prove)\nusing this:\n  hfun B C F\n  hfun B C F \\<Longrightarrow>\n  \\<guillemotleft>hfun_to_arr B C\n                   F : hf_to_ide\n                        B \\<rightarrow> hf_to_ide C\\<guillemotright>\n  hf_to_ide ?x = mkIde (UP ` hfset ?x)\n\ngoal (1 subgoal):\n 1. \\<lbrace>XY \\<^bold>\\<in>\n     ide_to_hf (local.dom (hfun_to_arr B C F)) *\n     ide_to_hf (cod (hfun_to_arr B C F)).\n     hsnd XY = DOWN (Fun (hfun_to_arr B C F) (UP (hfst XY)))\\<rbrace> =\n    \\<lbrace>XY \\<^bold>\\<in>\n     ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n     hsnd XY = DOWN (Fun (hfun_to_arr B C F) (UP (hfst XY)))\\<rbrace>", "by (metis (no_types, lifting) in_homE)"], ["proof (state)\nthis:\n  \\<lbrace>XY \\<^bold>\\<in>\n   ide_to_hf (local.dom (hfun_to_arr B C F)) *\n   ide_to_hf (cod (hfun_to_arr B C F)).\n   hsnd XY = DOWN (Fun (hfun_to_arr B C F) (UP (hfst XY)))\\<rbrace> =\n  \\<lbrace>XY \\<^bold>\\<in>\n   ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n   hsnd XY = DOWN (Fun (hfun_to_arr B C F) (UP (hfst XY)))\\<rbrace>\n\ngoal (1 subgoal):\n 1. arr_to_hfun (hfun_to_arr B C F) = F", "also"], ["proof (state)\nthis:\n  \\<lbrace>XY \\<^bold>\\<in>\n   ide_to_hf (local.dom (hfun_to_arr B C F)) *\n   ide_to_hf (cod (hfun_to_arr B C F)).\n   hsnd XY = DOWN (Fun (hfun_to_arr B C F) (UP (hfst XY)))\\<rbrace> =\n  \\<lbrace>XY \\<^bold>\\<in>\n   ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n   hsnd XY = DOWN (Fun (hfun_to_arr B C F) (UP (hfst XY)))\\<rbrace>\n\ngoal (1 subgoal):\n 1. arr_to_hfun (hfun_to_arr B C F) = F", "have\n          \"... = \\<lbrace>XY \\<^bold>\\<in> ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n                    hsnd XY = DOWN (restrict (\\<lambda>x. UP (happ F (DOWN x))) (UP ` hfset B)\n                                   (UP (hfst XY)))\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>XY \\<^bold>\\<in>\n     ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n     hsnd XY = DOWN (Fun (hfun_to_arr B C F) (UP (hfst XY)))\\<rbrace> =\n    \\<lbrace>XY \\<^bold>\\<in>\n     ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n     hsnd XY =\n     DOWN\n      ((\\<lambda>x\\<^bold>\\<in>UP ` hfset B. UP (happ F (DOWN x)))\n        (UP (hfst XY)))\\<rbrace>", "using assms Fun_hfun_to_arr"], ["proof (prove)\nusing this:\n  hfun B C F\n  hfun ?B ?C ?F \\<Longrightarrow>\n  Fun (hfun_to_arr ?B ?C ?F) =\n  (\\<lambda>x\\<^bold>\\<in>UP ` hfset ?B. UP (happ ?F (DOWN x)))\n\ngoal (1 subgoal):\n 1. \\<lbrace>XY \\<^bold>\\<in>\n     ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n     hsnd XY = DOWN (Fun (hfun_to_arr B C F) (UP (hfst XY)))\\<rbrace> =\n    \\<lbrace>XY \\<^bold>\\<in>\n     ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n     hsnd XY =\n     DOWN\n      ((\\<lambda>x\\<^bold>\\<in>UP ` hfset B. UP (happ F (DOWN x)))\n        (UP (hfst XY)))\\<rbrace>", "by simp"], ["proof (state)\nthis:\n  \\<lbrace>XY \\<^bold>\\<in>\n   ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n   hsnd XY = DOWN (Fun (hfun_to_arr B C F) (UP (hfst XY)))\\<rbrace> =\n  \\<lbrace>XY \\<^bold>\\<in>\n   ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n   hsnd XY =\n   DOWN\n    ((\\<lambda>x\\<^bold>\\<in>UP ` hfset B. UP (happ F (DOWN x)))\n      (UP (hfst XY)))\\<rbrace>\n\ngoal (1 subgoal):\n 1. arr_to_hfun (hfun_to_arr B C F) = F", "also"], ["proof (state)\nthis:\n  \\<lbrace>XY \\<^bold>\\<in>\n   ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n   hsnd XY = DOWN (Fun (hfun_to_arr B C F) (UP (hfst XY)))\\<rbrace> =\n  \\<lbrace>XY \\<^bold>\\<in>\n   ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n   hsnd XY =\n   DOWN\n    ((\\<lambda>x\\<^bold>\\<in>UP ` hfset B. UP (happ F (DOWN x)))\n      (UP (hfst XY)))\\<rbrace>\n\ngoal (1 subgoal):\n 1. arr_to_hfun (hfun_to_arr B C F) = F", "have\n          \"... = \\<lbrace>XY \\<^bold>\\<in> ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n                    hsnd XY = DOWN (UP (happ F (DOWN (UP (hfst XY)))))\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>XY \\<^bold>\\<in>\n     ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n     hsnd XY =\n     DOWN\n      ((\\<lambda>x\\<^bold>\\<in>UP ` hfset B. UP (happ F (DOWN x)))\n        (UP (hfst XY)))\\<rbrace> =\n    \\<lbrace>XY \\<^bold>\\<in>\n     ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n     hsnd XY = DOWN (UP (happ F (DOWN (UP (hfst XY)))))\\<rbrace>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrace>XY \\<^bold>\\<in>\n     ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n     hsnd XY =\n     DOWN\n      ((\\<lambda>x\\<^bold>\\<in>UP ` hfset B. UP (happ F (DOWN x)))\n        (UP (hfst XY)))\\<rbrace> =\n    \\<lbrace>XY \\<^bold>\\<in>\n     ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n     hsnd XY = DOWN (UP (happ F (DOWN (UP (hfst XY)))))\\<rbrace>", "have\n          1: \"\\<And>XY. XY \\<^bold>\\<in> ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C))\n                     \\<Longrightarrow> UP (hfst XY) \\<in> UP ` hfset B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>XY.\n       XY \\<^bold>\\<in>\n       ide_to_hf (mkIde (UP ` hfset B)) *\n       ide_to_hf (mkIde (UP ` hfset C)) \\<Longrightarrow>\n       UP (hfst XY) \\<in> UP ` hfset B", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>XY.\n       XY \\<^bold>\\<in>\n       ide_to_hf (mkIde (UP ` hfset B)) *\n       ide_to_hf (mkIde (UP ` hfset C)) \\<Longrightarrow>\n       UP (hfst XY) \\<in> UP ` hfset B", "fix XY"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>XY.\n       XY \\<^bold>\\<in>\n       ide_to_hf (mkIde (UP ` hfset B)) *\n       ide_to_hf (mkIde (UP ` hfset C)) \\<Longrightarrow>\n       UP (hfst XY) \\<in> UP ` hfset B", "assume\n            XY: \"XY \\<^bold>\\<in> ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C))\""], ["proof (state)\nthis:\n  XY \\<^bold>\\<in>\n  ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C))\n\ngoal (1 subgoal):\n 1. \\<And>XY.\n       XY \\<^bold>\\<in>\n       ide_to_hf (mkIde (UP ` hfset B)) *\n       ide_to_hf (mkIde (UP ` hfset C)) \\<Longrightarrow>\n       UP (hfst XY) \\<in> UP ` hfset B", "have \"hfst XY \\<^bold>\\<in> ide_to_hf (mkIde (UP ` hfset B))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hfst XY \\<^bold>\\<in> ide_to_hf (mkIde (UP ` hfset B))", "using XY"], ["proof (prove)\nusing this:\n  XY \\<^bold>\\<in>\n  ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C))\n\ngoal (1 subgoal):\n 1. hfst XY \\<^bold>\\<in> ide_to_hf (mkIde (UP ` hfset B))", "by auto"], ["proof (state)\nthis:\n  hfst XY \\<^bold>\\<in> ide_to_hf (mkIde (UP ` hfset B))\n\ngoal (1 subgoal):\n 1. \\<And>XY.\n       XY \\<^bold>\\<in>\n       ide_to_hf (mkIde (UP ` hfset B)) *\n       ide_to_hf (mkIde (UP ` hfset C)) \\<Longrightarrow>\n       UP (hfst XY) \\<in> UP ` hfset B", "thus \"UP (hfst XY) \\<in> UP ` hfset B\""], ["proof (prove)\nusing this:\n  hfst XY \\<^bold>\\<in> ide_to_hf (mkIde (UP ` hfset B))\n\ngoal (1 subgoal):\n 1. UP (hfst XY) \\<in> UP ` hfset B", "using assms UP_membI [of \"hfst XY\" \"mkIde (UP ` hfset B)\"] set_mkIde"], ["proof (prove)\nusing this:\n  hfst XY \\<^bold>\\<in> ide_to_hf (mkIde (UP ` hfset B))\n  hfun B C F\n  hfst XY \\<^bold>\\<in> ide_to_hf (mkIde (UP ` hfset B)) \\<Longrightarrow>\n  UP (hfst XY) \\<in> local.set (mkIde (UP ` hfset B))\n  \\<lbrakk>?A \\<subseteq> Univ; |?A| <o natLeq\\<rbrakk>\n  \\<Longrightarrow> local.set (mkIde ?A) = ?A\n\ngoal (1 subgoal):\n 1. UP (hfst XY) \\<in> UP ` hfset B", "by (metis (mono_tags, lifting) arrI arr_mkArr hfun_to_arr_def hfun_to_arr_in_hom)"], ["proof (state)\nthis:\n  UP (hfst XY) \\<in> UP ` hfset B\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?XY1 \\<^bold>\\<in>\n  ide_to_hf (mkIde (UP ` hfset B)) *\n  ide_to_hf (mkIde (UP ` hfset C)) \\<Longrightarrow>\n  UP (hfst ?XY1) \\<in> UP ` hfset B\n\ngoal (1 subgoal):\n 1. \\<lbrace>XY \\<^bold>\\<in>\n     ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n     hsnd XY =\n     DOWN\n      ((\\<lambda>x\\<^bold>\\<in>UP ` hfset B. UP (happ F (DOWN x)))\n        (UP (hfst XY)))\\<rbrace> =\n    \\<lbrace>XY \\<^bold>\\<in>\n     ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n     hsnd XY = DOWN (UP (happ F (DOWN (UP (hfst XY)))))\\<rbrace>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>XY \\<^bold>\\<in>\n     ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n     hsnd XY =\n     DOWN\n      ((\\<lambda>x\\<^bold>\\<in>UP ` hfset B. UP (happ F (DOWN x)))\n        (UP (hfst XY)))\\<rbrace> =\n    \\<lbrace>XY \\<^bold>\\<in>\n     ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n     hsnd XY = DOWN (UP (happ F (DOWN (UP (hfst XY)))))\\<rbrace>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrace>XY \\<^bold>\\<in>\n     ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n     hsnd XY =\n     DOWN\n      ((\\<lambda>x\\<^bold>\\<in>UP ` hfset B. UP (happ F (DOWN x)))\n        (UP (hfst XY)))\\<rbrace> =\n    \\<lbrace>XY \\<^bold>\\<in>\n     ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n     hsnd XY = DOWN (UP (happ F (DOWN (UP (hfst XY)))))\\<rbrace>", "have\n            \"\\<And>XY. (XY \\<^bold>\\<in> ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)) \\<and>\n                     hsnd XY = DOWN (restrict (\\<lambda>x. UP (happ F (DOWN x))) (UP ` hfset B)\n                                       (UP (hfst XY))))\n                   \\<longleftrightarrow>\n                   (XY \\<^bold>\\<in> ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)) \\<and>\n                     hsnd XY = DOWN (UP (happ F (DOWN (UP (hfst XY))))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>XY.\n       (XY \\<^bold>\\<in>\n        ide_to_hf (mkIde (UP ` hfset B)) *\n        ide_to_hf (mkIde (UP ` hfset C)) \\<and>\n        hsnd XY =\n        DOWN\n         ((\\<lambda>x\\<^bold>\\<in>UP ` hfset B. UP (happ F (DOWN x)))\n           (UP (hfst XY)))) =\n       (XY \\<^bold>\\<in>\n        ide_to_hf (mkIde (UP ` hfset B)) *\n        ide_to_hf (mkIde (UP ` hfset C)) \\<and>\n        hsnd XY = DOWN (UP (happ F (DOWN (UP (hfst XY))))))", "using 1"], ["proof (prove)\nusing this:\n  ?XY1 \\<^bold>\\<in>\n  ide_to_hf (mkIde (UP ` hfset B)) *\n  ide_to_hf (mkIde (UP ` hfset C)) \\<Longrightarrow>\n  UP (hfst ?XY1) \\<in> UP ` hfset B\n\ngoal (1 subgoal):\n 1. \\<And>XY.\n       (XY \\<^bold>\\<in>\n        ide_to_hf (mkIde (UP ` hfset B)) *\n        ide_to_hf (mkIde (UP ` hfset C)) \\<and>\n        hsnd XY =\n        DOWN\n         ((\\<lambda>x\\<^bold>\\<in>UP ` hfset B. UP (happ F (DOWN x)))\n           (UP (hfst XY)))) =\n       (XY \\<^bold>\\<in>\n        ide_to_hf (mkIde (UP ` hfset B)) *\n        ide_to_hf (mkIde (UP ` hfset C)) \\<and>\n        hsnd XY = DOWN (UP (happ F (DOWN (UP (hfst XY))))))", "by auto"], ["proof (state)\nthis:\n  (?XY1 \\<^bold>\\<in>\n   ide_to_hf (mkIde (UP ` hfset B)) *\n   ide_to_hf (mkIde (UP ` hfset C)) \\<and>\n   hsnd ?XY1 =\n   DOWN\n    ((\\<lambda>x\\<^bold>\\<in>UP ` hfset B. UP (happ F (DOWN x)))\n      (UP (hfst ?XY1)))) =\n  (?XY1 \\<^bold>\\<in>\n   ide_to_hf (mkIde (UP ` hfset B)) *\n   ide_to_hf (mkIde (UP ` hfset C)) \\<and>\n   hsnd ?XY1 = DOWN (UP (happ F (DOWN (UP (hfst ?XY1))))))\n\ngoal (1 subgoal):\n 1. \\<lbrace>XY \\<^bold>\\<in>\n     ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n     hsnd XY =\n     DOWN\n      ((\\<lambda>x\\<^bold>\\<in>UP ` hfset B. UP (happ F (DOWN x)))\n        (UP (hfst XY)))\\<rbrace> =\n    \\<lbrace>XY \\<^bold>\\<in>\n     ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n     hsnd XY = DOWN (UP (happ F (DOWN (UP (hfst XY)))))\\<rbrace>", "thus ?thesis"], ["proof (prove)\nusing this:\n  (?XY1 \\<^bold>\\<in>\n   ide_to_hf (mkIde (UP ` hfset B)) *\n   ide_to_hf (mkIde (UP ` hfset C)) \\<and>\n   hsnd ?XY1 =\n   DOWN\n    ((\\<lambda>x\\<^bold>\\<in>UP ` hfset B. UP (happ F (DOWN x)))\n      (UP (hfst ?XY1)))) =\n  (?XY1 \\<^bold>\\<in>\n   ide_to_hf (mkIde (UP ` hfset B)) *\n   ide_to_hf (mkIde (UP ` hfset C)) \\<and>\n   hsnd ?XY1 = DOWN (UP (happ F (DOWN (UP (hfst ?XY1))))))\n\ngoal (1 subgoal):\n 1. \\<lbrace>XY \\<^bold>\\<in>\n     ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n     hsnd XY =\n     DOWN\n      ((\\<lambda>x\\<^bold>\\<in>UP ` hfset B. UP (happ F (DOWN x)))\n        (UP (hfst XY)))\\<rbrace> =\n    \\<lbrace>XY \\<^bold>\\<in>\n     ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n     hsnd XY = DOWN (UP (happ F (DOWN (UP (hfst XY)))))\\<rbrace>", "by blast"], ["proof (state)\nthis:\n  \\<lbrace>XY \\<^bold>\\<in>\n   ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n   hsnd XY =\n   DOWN\n    ((\\<lambda>x\\<^bold>\\<in>UP ` hfset B. UP (happ F (DOWN x)))\n      (UP (hfst XY)))\\<rbrace> =\n  \\<lbrace>XY \\<^bold>\\<in>\n   ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n   hsnd XY = DOWN (UP (happ F (DOWN (UP (hfst XY)))))\\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrace>XY \\<^bold>\\<in>\n   ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n   hsnd XY =\n   DOWN\n    ((\\<lambda>x\\<^bold>\\<in>UP ` hfset B. UP (happ F (DOWN x)))\n      (UP (hfst XY)))\\<rbrace> =\n  \\<lbrace>XY \\<^bold>\\<in>\n   ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n   hsnd XY = DOWN (UP (happ F (DOWN (UP (hfst XY)))))\\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrace>XY \\<^bold>\\<in>\n   ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n   hsnd XY =\n   DOWN\n    ((\\<lambda>x\\<^bold>\\<in>UP ` hfset B. UP (happ F (DOWN x)))\n      (UP (hfst XY)))\\<rbrace> =\n  \\<lbrace>XY \\<^bold>\\<in>\n   ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n   hsnd XY = DOWN (UP (happ F (DOWN (UP (hfst XY)))))\\<rbrace>\n\ngoal (1 subgoal):\n 1. arr_to_hfun (hfun_to_arr B C F) = F", "also"], ["proof (state)\nthis:\n  \\<lbrace>XY \\<^bold>\\<in>\n   ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n   hsnd XY =\n   DOWN\n    ((\\<lambda>x\\<^bold>\\<in>UP ` hfset B. UP (happ F (DOWN x)))\n      (UP (hfst XY)))\\<rbrace> =\n  \\<lbrace>XY \\<^bold>\\<in>\n   ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n   hsnd XY = DOWN (UP (happ F (DOWN (UP (hfst XY)))))\\<rbrace>\n\ngoal (1 subgoal):\n 1. arr_to_hfun (hfun_to_arr B C F) = F", "have\n        \"... = \\<lbrace>XY \\<^bold>\\<in> ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n                  hsnd XY = happ F (hfst XY)\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>XY \\<^bold>\\<in>\n     ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n     hsnd XY = DOWN (UP (happ F (DOWN (UP (hfst XY)))))\\<rbrace> =\n    \\<lbrace>XY \\<^bold>\\<in>\n     ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n     hsnd XY = happ F (hfst XY)\\<rbrace>", "by simp"], ["proof (state)\nthis:\n  \\<lbrace>XY \\<^bold>\\<in>\n   ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n   hsnd XY = DOWN (UP (happ F (DOWN (UP (hfst XY)))))\\<rbrace> =\n  \\<lbrace>XY \\<^bold>\\<in>\n   ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n   hsnd XY = happ F (hfst XY)\\<rbrace>\n\ngoal (1 subgoal):\n 1. arr_to_hfun (hfun_to_arr B C F) = F", "also"], ["proof (state)\nthis:\n  \\<lbrace>XY \\<^bold>\\<in>\n   ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n   hsnd XY = DOWN (UP (happ F (DOWN (UP (hfst XY)))))\\<rbrace> =\n  \\<lbrace>XY \\<^bold>\\<in>\n   ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n   hsnd XY = happ F (hfst XY)\\<rbrace>\n\ngoal (1 subgoal):\n 1. arr_to_hfun (hfun_to_arr B C F) = F", "have \"... = \\<lbrace>XY \\<^bold>\\<in> B * C. hsnd XY = happ F (hfst XY)\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>XY \\<^bold>\\<in>\n     ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n     hsnd XY = happ F (hfst XY)\\<rbrace> =\n    \\<lbrace>XY \\<^bold>\\<in> B * C. hsnd XY = happ F (hfst XY)\\<rbrace>", "using assms hf_to_ide_def ide_to_hf_hf_to_ide"], ["proof (prove)\nusing this:\n  hfun B C F\n  hf_to_ide ?x = mkIde (UP ` hfset ?x)\n  ?x \\<in> UNIV \\<Longrightarrow> ide_to_hf (hf_to_ide ?x) = ?x\n\ngoal (1 subgoal):\n 1. \\<lbrace>XY \\<^bold>\\<in>\n     ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n     hsnd XY = happ F (hfst XY)\\<rbrace> =\n    \\<lbrace>XY \\<^bold>\\<in> B * C. hsnd XY = happ F (hfst XY)\\<rbrace>", "by force"], ["proof (state)\nthis:\n  \\<lbrace>XY \\<^bold>\\<in>\n   ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n   hsnd XY = happ F (hfst XY)\\<rbrace> =\n  \\<lbrace>XY \\<^bold>\\<in> B * C. hsnd XY = happ F (hfst XY)\\<rbrace>\n\ngoal (1 subgoal):\n 1. arr_to_hfun (hfun_to_arr B C F) = F", "also"], ["proof (state)\nthis:\n  \\<lbrace>XY \\<^bold>\\<in>\n   ide_to_hf (mkIde (UP ` hfset B)) * ide_to_hf (mkIde (UP ` hfset C)).\n   hsnd XY = happ F (hfst XY)\\<rbrace> =\n  \\<lbrace>XY \\<^bold>\\<in> B * C. hsnd XY = happ F (hfst XY)\\<rbrace>\n\ngoal (1 subgoal):\n 1. arr_to_hfun (hfun_to_arr B C F) = F", "have \"... = F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>XY \\<^bold>\\<in> B * C. hsnd XY = happ F (hfst XY)\\<rbrace> = F", "using assms happ_expansion"], ["proof (prove)\nusing this:\n  hfun B C F\n  hfun ?B ?C ?F \\<Longrightarrow>\n  ?F =\n  \\<lbrace>XY \\<^bold>\\<in> ?B * ?C. hsnd XY = happ ?F (hfst XY)\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<lbrace>XY \\<^bold>\\<in> B * C. hsnd XY = happ F (hfst XY)\\<rbrace> = F", "by simp"], ["proof (state)\nthis:\n  \\<lbrace>XY \\<^bold>\\<in> B * C. hsnd XY = happ F (hfst XY)\\<rbrace> = F\n\ngoal (1 subgoal):\n 1. arr_to_hfun (hfun_to_arr B C F) = F", "finally"], ["proof (chain)\npicking this:\n  arr_to_hfun (hfun_to_arr B C F) = F", "show ?thesis"], ["proof (prove)\nusing this:\n  arr_to_hfun (hfun_to_arr B C F) = F\n\ngoal (1 subgoal):\n 1. arr_to_hfun (hfun_to_arr B C F) = F", "by simp"], ["proof (state)\nthis:\n  arr_to_hfun (hfun_to_arr B C F) = F\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma bij_betw_hom_hfun:\n    assumes \"ide a\" and \"ide b\"\n    shows \"bij_betw arr_to_hfun (hom a b) {F. hfun (ide_to_hf a) (ide_to_hf b) F}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw arr_to_hfun (hom a b) {F. hfun (ide_to_hf a) (ide_to_hf b) F}", "proof (intro bij_betwI)"], ["proof (state)\ngoal (4 subgoals):\n 1. arr_to_hfun\n    \\<in> hom a b \\<rightarrow> {F. hfun (ide_to_hf a) (ide_to_hf b) F}\n 2. ?g \\<in> {F. hfun (ide_to_hf a) (ide_to_hf b) F} \\<rightarrow> hom a b\n 3. \\<And>x. x \\<in> hom a b \\<Longrightarrow> ?g (arr_to_hfun x) = x\n 4. \\<And>y.\n       y \\<in> {F. hfun (ide_to_hf a) (ide_to_hf b) F} \\<Longrightarrow>\n       arr_to_hfun (?g y) = y", "show \"arr_to_hfun \\<in> hom a b \\<rightarrow> {F. hfun (ide_to_hf a) (ide_to_hf b) F}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr_to_hfun\n    \\<in> hom a b \\<rightarrow> {F. hfun (ide_to_hf a) (ide_to_hf b) F}", "using assms arr_to_hfun_in_hexp hexp_def hfun_arr_to_hfun"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  arr ?f \\<Longrightarrow>\n  arr_to_hfun ?f \\<^bold>\\<in>\n  hexp (ide_to_hf (local.dom ?f)) (ide_to_hf (cod ?f))\n  hexp ?B ?C = HCollect (hfun ?B ?C) (HPow (?B * ?C))\n  arr ?f \\<Longrightarrow>\n  hfun (ide_to_hf (local.dom ?f)) (ide_to_hf (cod ?f)) (arr_to_hfun ?f)\n\ngoal (1 subgoal):\n 1. arr_to_hfun\n    \\<in> hom a b \\<rightarrow> {F. hfun (ide_to_hf a) (ide_to_hf b) F}", "by blast"], ["proof (state)\nthis:\n  arr_to_hfun\n  \\<in> hom a b \\<rightarrow> {F. hfun (ide_to_hf a) (ide_to_hf b) F}\n\ngoal (3 subgoals):\n 1. ?g \\<in> {F. hfun (ide_to_hf a) (ide_to_hf b) F} \\<rightarrow> hom a b\n 2. \\<And>x. x \\<in> hom a b \\<Longrightarrow> ?g (arr_to_hfun x) = x\n 3. \\<And>y.\n       y \\<in> {F. hfun (ide_to_hf a) (ide_to_hf b) F} \\<Longrightarrow>\n       arr_to_hfun (?g y) = y", "show \"hfun_to_arr (ide_to_hf a) (ide_to_hf b)\n              \\<in> {F. hfun (ide_to_hf a) (ide_to_hf b) F} \\<rightarrow> hom a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hfun_to_arr (ide_to_hf a) (ide_to_hf b)\n    \\<in> {F. hfun (ide_to_hf a) (ide_to_hf b) F} \\<rightarrow> hom a b", "using assms hfun_to_arr_in_hom"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  hfun ?B ?C ?F \\<Longrightarrow>\n  \\<guillemotleft>hfun_to_arr ?B ?C\n                   ?F : hf_to_ide\n                         ?B \\<rightarrow> hf_to_ide ?C\\<guillemotright>\n\ngoal (1 subgoal):\n 1. hfun_to_arr (ide_to_hf a) (ide_to_hf b)\n    \\<in> {F. hfun (ide_to_hf a) (ide_to_hf b) F} \\<rightarrow> hom a b", "by (metis (no_types, lifting) Pi_I hf_to_ide_ide_to_hf mem_Collect_eq)"], ["proof (state)\nthis:\n  hfun_to_arr (ide_to_hf a) (ide_to_hf b)\n  \\<in> {F. hfun (ide_to_hf a) (ide_to_hf b) F} \\<rightarrow> hom a b\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> hom a b \\<Longrightarrow>\n       hfun_to_arr (ide_to_hf a) (ide_to_hf b) (arr_to_hfun x) = x\n 2. \\<And>y.\n       y \\<in> {F. hfun (ide_to_hf a) (ide_to_hf b) F} \\<Longrightarrow>\n       arr_to_hfun (hfun_to_arr (ide_to_hf a) (ide_to_hf b) y) = y", "show \"\\<And>x. x \\<in> hom a b \\<Longrightarrow> hfun_to_arr (ide_to_hf a) (ide_to_hf b) (arr_to_hfun x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> hom a b \\<Longrightarrow>\n       hfun_to_arr (ide_to_hf a) (ide_to_hf b) (arr_to_hfun x) = x", "using assms hfun_to_arr_arr_to_hfun"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  arr ?f \\<Longrightarrow>\n  hfun_to_arr (ide_to_hf (local.dom ?f)) (ide_to_hf (cod ?f))\n   (arr_to_hfun ?f) =\n  ?f\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> hom a b \\<Longrightarrow>\n       hfun_to_arr (ide_to_hf a) (ide_to_hf b) (arr_to_hfun x) = x", "by blast"], ["proof (state)\nthis:\n  ?x1 \\<in> hom a b \\<Longrightarrow>\n  hfun_to_arr (ide_to_hf a) (ide_to_hf b) (arr_to_hfun ?x1) = ?x1\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> {F. hfun (ide_to_hf a) (ide_to_hf b) F} \\<Longrightarrow>\n       arr_to_hfun (hfun_to_arr (ide_to_hf a) (ide_to_hf b) y) = y", "show \"\\<And>y. y \\<in> {F. hfun (ide_to_hf a) (ide_to_hf b) F} \\<Longrightarrow>\n                  arr_to_hfun (hfun_to_arr (ide_to_hf a) (ide_to_hf b) y) = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> {F. hfun (ide_to_hf a) (ide_to_hf b) F} \\<Longrightarrow>\n       arr_to_hfun (hfun_to_arr (ide_to_hf a) (ide_to_hf b) y) = y", "using assms arr_to_hfun_hfun_to_arr"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  hfun ?B ?C ?F \\<Longrightarrow> arr_to_hfun (hfun_to_arr ?B ?C ?F) = ?F\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> {F. hfun (ide_to_hf a) (ide_to_hf b) F} \\<Longrightarrow>\n       arr_to_hfun (hfun_to_arr (ide_to_hf a) (ide_to_hf b) y) = y", "by simp"], ["proof (state)\nthis:\n  ?y1 \\<in> {F. hfun (ide_to_hf a) (ide_to_hf b) F} \\<Longrightarrow>\n  arr_to_hfun (hfun_to_arr (ide_to_hf a) (ide_to_hf b) ?y1) = ?y1\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n      We next relate composition of arrows in the category to the corresponding operation\n      on hereditarily finite sets.\n    \\<close>"], ["", "definition hcomp\n    where \"hcomp G F =\n           \\<lbrace>XZ \\<^bold>\\<in> hdomain F * hrange G. hsnd XZ = happ G (happ F (hfst XZ))\\<rbrace>\""], ["", "lemma hfun_hcomp:\n    assumes \"hfun A B F\" and \"hfun B C G\"\n    shows \"hfun A C (hcomp G F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hfun A C (hcomp G F)", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. hcomp G F \\<le> A * C\n 2. \\<And>X.\n       X \\<^bold>\\<in> A \\<Longrightarrow>\n       \\<exists>!Y. \\<langle>X, Y\\<rangle> \\<^bold>\\<in> hcomp G F\n 3. \\<And>X Y.\n       \\<langle>X, Y\\<rangle> \\<^bold>\\<in> hcomp G F \\<Longrightarrow>\n       Y \\<^bold>\\<in> C", "show \"hcomp G F \\<le> A * C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hcomp G F \\<le> A * C", "using assms hcomp_def hfun_def"], ["proof (prove)\nusing this:\n  hfun A B F\n  hfun B C G\n  hcomp ?G ?F =\n  \\<lbrace>XZ \\<^bold>\\<in> hdomain ?F * hrange ?G.\n   hsnd XZ = happ ?G (happ ?F (hfst XZ))\\<rbrace>\n  hfun ?B ?C ?F \\<equiv>\n  ?F \\<le> ?B * ?C \\<and>\n  hfunction ?F \\<and> hdomain ?F = ?B \\<and> hrange ?F \\<le> ?C\n\ngoal (1 subgoal):\n 1. hcomp G F \\<le> A * C", "by auto"], ["proof (state)\nthis:\n  hcomp G F \\<le> A * C\n\ngoal (2 subgoals):\n 1. \\<And>X.\n       X \\<^bold>\\<in> A \\<Longrightarrow>\n       \\<exists>!Y. \\<langle>X, Y\\<rangle> \\<^bold>\\<in> hcomp G F\n 2. \\<And>X Y.\n       \\<langle>X, Y\\<rangle> \\<^bold>\\<in> hcomp G F \\<Longrightarrow>\n       Y \\<^bold>\\<in> C", "show \"\\<And>X. X \\<^bold>\\<in> A \\<Longrightarrow> \\<exists>!Y. \\<langle>X, Y\\<rangle> \\<^bold>\\<in> hcomp G F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X.\n       X \\<^bold>\\<in> A \\<Longrightarrow>\n       \\<exists>!Y. \\<langle>X, Y\\<rangle> \\<^bold>\\<in> hcomp G F", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>X.\n       X \\<^bold>\\<in> A \\<Longrightarrow>\n       \\<langle>X, ?a X\\<rangle> \\<^bold>\\<in> hcomp G F\n 2. \\<And>X Y.\n       \\<lbrakk>X \\<^bold>\\<in> A;\n        \\<langle>X, Y\\<rangle> \\<^bold>\\<in> hcomp G F\\<rbrakk>\n       \\<Longrightarrow> Y = ?a X", "fix X"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>X.\n       X \\<^bold>\\<in> A \\<Longrightarrow>\n       \\<langle>X, ?a X\\<rangle> \\<^bold>\\<in> hcomp G F\n 2. \\<And>X Y.\n       \\<lbrakk>X \\<^bold>\\<in> A;\n        \\<langle>X, Y\\<rangle> \\<^bold>\\<in> hcomp G F\\<rbrakk>\n       \\<Longrightarrow> Y = ?a X", "assume X: \"X \\<^bold>\\<in> A\""], ["proof (state)\nthis:\n  X \\<^bold>\\<in> A\n\ngoal (2 subgoals):\n 1. \\<And>X.\n       X \\<^bold>\\<in> A \\<Longrightarrow>\n       \\<langle>X, ?a X\\<rangle> \\<^bold>\\<in> hcomp G F\n 2. \\<And>X Y.\n       \\<lbrakk>X \\<^bold>\\<in> A;\n        \\<langle>X, Y\\<rangle> \\<^bold>\\<in> hcomp G F\\<rbrakk>\n       \\<Longrightarrow> Y = ?a X", "show \"\\<langle>X, happ G (happ F X)\\<rangle> \\<^bold>\\<in> hcomp G F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>X, happ G (happ F X)\\<rangle> \\<^bold>\\<in> hcomp G F", "unfolding hcomp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>X, happ G (happ F X)\\<rangle> \\<^bold>\\<in>\n    \\<lbrace>XZ \\<^bold>\\<in> hdomain F * hrange G.\n     hsnd XZ = happ G (happ F (hfst XZ))\\<rbrace>", "using assms X hfunE happ_mapsto hfun_in_hexp"], ["proof (prove)\nusing this:\n  hfun A B F\n  hfun B C G\n  X \\<^bold>\\<in> A\n  \\<lbrakk>hfun ?B ?C ?F;\n   (\\<And>Y.\n       Y \\<^bold>\\<in> ?B \\<Longrightarrow>\n       (\\<exists>!Z. \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> ?F) \\<and>\n       (\\<forall>Z.\n           \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> ?F \\<longrightarrow>\n           Z \\<^bold>\\<in> ?C)) \\<Longrightarrow>\n   ?T\\<rbrakk>\n  \\<Longrightarrow> ?T\n  \\<lbrakk>?F \\<^bold>\\<in> hexp ?B ?C; ?Y \\<^bold>\\<in> ?B\\<rbrakk>\n  \\<Longrightarrow> happ ?F ?Y \\<^bold>\\<in> ?C\n  \\<lbrakk>?F \\<^bold>\\<in> hexp ?B ?C; ?Y \\<^bold>\\<in> ?B\\<rbrakk>\n  \\<Longrightarrow> happ ?F ?Y \\<^bold>\\<in> hrange ?F\n  hfun ?B ?C ?F \\<Longrightarrow> ?F \\<^bold>\\<in> hexp ?B ?C\n\ngoal (1 subgoal):\n 1. \\<langle>X, happ G (happ F X)\\<rangle> \\<^bold>\\<in>\n    \\<lbrace>XZ \\<^bold>\\<in> hdomain F * hrange G.\n     hsnd XZ = happ G (happ F (hfst XZ))\\<rbrace>", "by (metis (mono_tags, lifting) HCollect_iff hfst_conv hfun_def hsnd_conv timesI)"], ["proof (state)\nthis:\n  \\<langle>X, happ G (happ F X)\\<rangle> \\<^bold>\\<in> hcomp G F\n\ngoal (1 subgoal):\n 1. \\<And>X Y.\n       \\<lbrakk>X \\<^bold>\\<in> A;\n        \\<langle>X, Y\\<rangle> \\<^bold>\\<in> hcomp G F\\<rbrakk>\n       \\<Longrightarrow> Y = happ G (happ F X)", "show \"\\<And>X Y. \\<lbrakk>X \\<^bold>\\<in> A; \\<langle>X, Y\\<rangle> \\<^bold>\\<in> hcomp G F\\<rbrakk> \\<Longrightarrow> Y = happ G (happ F X)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X Y.\n       \\<lbrakk>X \\<^bold>\\<in> A;\n        \\<langle>X, Y\\<rangle> \\<^bold>\\<in> hcomp G F\\<rbrakk>\n       \\<Longrightarrow> Y = happ G (happ F X)", "unfolding hcomp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X Y.\n       \\<lbrakk>X \\<^bold>\\<in> A;\n        \\<langle>X, Y\\<rangle> \\<^bold>\\<in>\n        \\<lbrace>XZ \\<^bold>\\<in> hdomain F * hrange G.\n         hsnd XZ = happ G (happ F (hfst XZ))\\<rbrace>\\<rbrakk>\n       \\<Longrightarrow> Y = happ G (happ F X)", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>?X1 \\<^bold>\\<in> A;\n   \\<langle>?X1, ?Y1\\<rangle> \\<^bold>\\<in> hcomp G F\\<rbrakk>\n  \\<Longrightarrow> ?Y1 = happ G (happ F ?X1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?X1 \\<^bold>\\<in> A \\<Longrightarrow>\n  \\<exists>!Y. \\<langle>?X1, Y\\<rangle> \\<^bold>\\<in> hcomp G F\n\ngoal (1 subgoal):\n 1. \\<And>X Y.\n       \\<langle>X, Y\\<rangle> \\<^bold>\\<in> hcomp G F \\<Longrightarrow>\n       Y \\<^bold>\\<in> C", "show \"\\<And>X Y. \\<langle>X, Y\\<rangle> \\<^bold>\\<in> hcomp G F \\<Longrightarrow> Y \\<^bold>\\<in> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X Y.\n       \\<langle>X, Y\\<rangle> \\<^bold>\\<in> hcomp G F \\<Longrightarrow>\n       Y \\<^bold>\\<in> C", "unfolding hcomp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X Y.\n       \\<langle>X, Y\\<rangle> \\<^bold>\\<in>\n       \\<lbrace>XZ \\<^bold>\\<in> hdomain F * hrange G.\n        hsnd XZ = happ G (happ F (hfst XZ))\\<rbrace> \\<Longrightarrow>\n       Y \\<^bold>\\<in> C", "using assms hfunE happ_mapsto hfun_in_hexp"], ["proof (prove)\nusing this:\n  hfun A B F\n  hfun B C G\n  \\<lbrakk>hfun ?B ?C ?F;\n   (\\<And>Y.\n       Y \\<^bold>\\<in> ?B \\<Longrightarrow>\n       (\\<exists>!Z. \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> ?F) \\<and>\n       (\\<forall>Z.\n           \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> ?F \\<longrightarrow>\n           Z \\<^bold>\\<in> ?C)) \\<Longrightarrow>\n   ?T\\<rbrakk>\n  \\<Longrightarrow> ?T\n  \\<lbrakk>?F \\<^bold>\\<in> hexp ?B ?C; ?Y \\<^bold>\\<in> ?B\\<rbrakk>\n  \\<Longrightarrow> happ ?F ?Y \\<^bold>\\<in> ?C\n  \\<lbrakk>?F \\<^bold>\\<in> hexp ?B ?C; ?Y \\<^bold>\\<in> ?B\\<rbrakk>\n  \\<Longrightarrow> happ ?F ?Y \\<^bold>\\<in> hrange ?F\n  hfun ?B ?C ?F \\<Longrightarrow> ?F \\<^bold>\\<in> hexp ?B ?C\n\ngoal (1 subgoal):\n 1. \\<And>X Y.\n       \\<langle>X, Y\\<rangle> \\<^bold>\\<in>\n       \\<lbrace>XZ \\<^bold>\\<in> hdomain F * hrange G.\n        hsnd XZ = happ G (happ F (hfst XZ))\\<rbrace> \\<Longrightarrow>\n       Y \\<^bold>\\<in> C", "by (metis HCollectE hfun_def hsubsetCE timesD2)"], ["proof (state)\nthis:\n  \\<langle>?X1, ?Y1\\<rangle> \\<^bold>\\<in> hcomp G F \\<Longrightarrow>\n  ?Y1 \\<^bold>\\<in> C\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma arr_to_hfun_comp:\n    assumes \"seq g f\"\n    shows \"arr_to_hfun (comp g f) = hcomp (arr_to_hfun g) (arr_to_hfun f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr_to_hfun (local.comp g f) = hcomp (arr_to_hfun g) (arr_to_hfun f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. arr_to_hfun (local.comp g f) = hcomp (arr_to_hfun g) (arr_to_hfun f)", "have 1: \"hdomain (arr_to_hfun f) = ide_to_hf (dom f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hdomain (arr_to_hfun f) = ide_to_hf (local.dom f)", "using assms hfun_arr_to_hfun hfun_def"], ["proof (prove)\nusing this:\n  seq g f\n  arr ?f \\<Longrightarrow>\n  hfun (ide_to_hf (local.dom ?f)) (ide_to_hf (cod ?f)) (arr_to_hfun ?f)\n  hfun ?B ?C ?F \\<equiv>\n  ?F \\<le> ?B * ?C \\<and>\n  hfunction ?F \\<and> hdomain ?F = ?B \\<and> hrange ?F \\<le> ?C\n\ngoal (1 subgoal):\n 1. hdomain (arr_to_hfun f) = ide_to_hf (local.dom f)", "by blast"], ["proof (state)\nthis:\n  hdomain (arr_to_hfun f) = ide_to_hf (local.dom f)\n\ngoal (1 subgoal):\n 1. arr_to_hfun (local.comp g f) = hcomp (arr_to_hfun g) (arr_to_hfun f)", "have \"arr_to_hfun (comp g f) =\n            \\<lbrace>XZ \\<^bold>\\<in> ide_to_hf (dom f) * ide_to_hf (cod g).\n               hsnd XZ = DOWN (Fun (comp g f) (UP (hfst XZ)))\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr_to_hfun (local.comp g f) =\n    \\<lbrace>XZ \\<^bold>\\<in> ide_to_hf (local.dom f) * ide_to_hf (cod g).\n     hsnd XZ = DOWN (Fun (local.comp g f) (UP (hfst XZ)))\\<rbrace>", "unfolding arr_to_hfun_def comp_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>XY \\<^bold>\\<in>\n     ide_to_hf (local.dom (local.comp g f)) *\n     ide_to_hf (cod (local.comp g f)).\n     hsnd XY = DOWN (Fun (local.comp g f) (UP (hfst XY)))\\<rbrace> =\n    \\<lbrace>XZ \\<^bold>\\<in> ide_to_hf (local.dom f) * ide_to_hf (cod g).\n     hsnd XZ = DOWN (Fun (local.comp g f) (UP (hfst XZ)))\\<rbrace>", "using assms"], ["proof (prove)\nusing this:\n  seq g f\n\ngoal (1 subgoal):\n 1. \\<lbrace>XY \\<^bold>\\<in>\n     ide_to_hf (local.dom (local.comp g f)) *\n     ide_to_hf (cod (local.comp g f)).\n     hsnd XY = DOWN (Fun (local.comp g f) (UP (hfst XY)))\\<rbrace> =\n    \\<lbrace>XZ \\<^bold>\\<in> ide_to_hf (local.dom f) * ide_to_hf (cod g).\n     hsnd XZ = DOWN (Fun (local.comp g f) (UP (hfst XZ)))\\<rbrace>", "by fastforce"], ["proof (state)\nthis:\n  arr_to_hfun (local.comp g f) =\n  \\<lbrace>XZ \\<^bold>\\<in> ide_to_hf (local.dom f) * ide_to_hf (cod g).\n   hsnd XZ = DOWN (Fun (local.comp g f) (UP (hfst XZ)))\\<rbrace>\n\ngoal (1 subgoal):\n 1. arr_to_hfun (local.comp g f) = hcomp (arr_to_hfun g) (arr_to_hfun f)", "also"], ["proof (state)\nthis:\n  arr_to_hfun (local.comp g f) =\n  \\<lbrace>XZ \\<^bold>\\<in> ide_to_hf (local.dom f) * ide_to_hf (cod g).\n   hsnd XZ = DOWN (Fun (local.comp g f) (UP (hfst XZ)))\\<rbrace>\n\ngoal (1 subgoal):\n 1. arr_to_hfun (local.comp g f) = hcomp (arr_to_hfun g) (arr_to_hfun f)", "have \"... = \\<lbrace>XZ \\<^bold>\\<in> hdomain (arr_to_hfun f) * hrange (arr_to_hfun g).\n                          hsnd XZ = happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>XZ \\<^bold>\\<in> ide_to_hf (local.dom f) * ide_to_hf (cod g).\n     hsnd XZ = DOWN (Fun (local.comp g f) (UP (hfst XZ)))\\<rbrace> =\n    \\<lbrace>XZ \\<^bold>\\<in>\n     hdomain (arr_to_hfun f) * hrange (arr_to_hfun g).\n     hsnd XZ =\n     happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))\\<rbrace>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<^bold>\\<in>\n        \\<lbrace>XZ \\<^bold>\\<in>\n         ide_to_hf (local.dom f) * ide_to_hf (cod g).\n         hsnd XZ = DOWN (Fun (local.comp g f) (UP (hfst XZ)))\\<rbrace>) =\n       (x \\<^bold>\\<in>\n        \\<lbrace>XZ \\<^bold>\\<in>\n         hdomain (arr_to_hfun f) * hrange (arr_to_hfun g).\n         hsnd XZ =\n         happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))\\<rbrace>)", "fix XZ"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<^bold>\\<in>\n        \\<lbrace>XZ \\<^bold>\\<in>\n         ide_to_hf (local.dom f) * ide_to_hf (cod g).\n         hsnd XZ = DOWN (Fun (local.comp g f) (UP (hfst XZ)))\\<rbrace>) =\n       (x \\<^bold>\\<in>\n        \\<lbrace>XZ \\<^bold>\\<in>\n         hdomain (arr_to_hfun f) * hrange (arr_to_hfun g).\n         hsnd XZ =\n         happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))\\<rbrace>)", "have \"hfst XZ \\<^bold>\\<in> hdomain (arr_to_hfun f)\n                 \\<Longrightarrow> hsnd XZ \\<^bold>\\<in> ide_to_hf (cod g) \\<and>\n                       hsnd XZ = DOWN (Fun (comp g f) (UP (hfst XZ)))\n                      \\<longleftrightarrow>\n                     hsnd XZ \\<^bold>\\<in> hrange (arr_to_hfun g) \\<and>\n                       hsnd XZ = happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hfst XZ \\<^bold>\\<in> hdomain (arr_to_hfun f) \\<Longrightarrow>\n    (hsnd XZ \\<^bold>\\<in> ide_to_hf (cod g) \\<and>\n     hsnd XZ = DOWN (Fun (local.comp g f) (UP (hfst XZ)))) =\n    (hsnd XZ \\<^bold>\\<in> hrange (arr_to_hfun g) \\<and>\n     hsnd XZ = happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>hfst XZ \\<^bold>\\<in> hdomain (arr_to_hfun f);\n     hsnd XZ \\<^bold>\\<in> ide_to_hf (cod g) \\<and>\n     hsnd XZ = DOWN (Fun (local.comp g f) (UP (hfst XZ)))\\<rbrakk>\n    \\<Longrightarrow> hsnd XZ \\<^bold>\\<in> hrange (arr_to_hfun g) \\<and>\n                      hsnd XZ =\n                      happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))\n 2. \\<lbrakk>hfst XZ \\<^bold>\\<in> hdomain (arr_to_hfun f);\n     hsnd XZ \\<^bold>\\<in> hrange (arr_to_hfun g) \\<and>\n     hsnd XZ =\n     happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))\\<rbrakk>\n    \\<Longrightarrow> hsnd XZ \\<^bold>\\<in> ide_to_hf (cod g) \\<and>\n                      hsnd XZ = DOWN (Fun (local.comp g f) (UP (hfst XZ)))", "assume XZ: \"hfst XZ \\<^bold>\\<in> hdomain (arr_to_hfun f)\""], ["proof (state)\nthis:\n  hfst XZ \\<^bold>\\<in> hdomain (arr_to_hfun f)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>hfst XZ \\<^bold>\\<in> hdomain (arr_to_hfun f);\n     hsnd XZ \\<^bold>\\<in> ide_to_hf (cod g) \\<and>\n     hsnd XZ = DOWN (Fun (local.comp g f) (UP (hfst XZ)))\\<rbrakk>\n    \\<Longrightarrow> hsnd XZ \\<^bold>\\<in> hrange (arr_to_hfun g) \\<and>\n                      hsnd XZ =\n                      happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))\n 2. \\<lbrakk>hfst XZ \\<^bold>\\<in> hdomain (arr_to_hfun f);\n     hsnd XZ \\<^bold>\\<in> hrange (arr_to_hfun g) \\<and>\n     hsnd XZ =\n     happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))\\<rbrakk>\n    \\<Longrightarrow> hsnd XZ \\<^bold>\\<in> ide_to_hf (cod g) \\<and>\n                      hsnd XZ = DOWN (Fun (local.comp g f) (UP (hfst XZ)))", "have 2: \"UP (hfst XZ) \\<in> Dom f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP (hfst XZ) \\<in> Dom f", "using XZ 1 hfsetcat.UP_membI"], ["proof (prove)\nusing this:\n  hfst XZ \\<^bold>\\<in> hdomain (arr_to_hfun f)\n  hdomain (arr_to_hfun f) = ide_to_hf (local.dom f)\n  ?x \\<^bold>\\<in> ide_to_hf ?a \\<Longrightarrow> UP ?x \\<in> local.set ?a\n\ngoal (1 subgoal):\n 1. UP (hfst XZ) \\<in> Dom f", "by auto"], ["proof (state)\nthis:\n  UP (hfst XZ) \\<in> Dom f\n\ngoal (2 subgoals):\n 1. \\<lbrakk>hfst XZ \\<^bold>\\<in> hdomain (arr_to_hfun f);\n     hsnd XZ \\<^bold>\\<in> ide_to_hf (cod g) \\<and>\n     hsnd XZ = DOWN (Fun (local.comp g f) (UP (hfst XZ)))\\<rbrakk>\n    \\<Longrightarrow> hsnd XZ \\<^bold>\\<in> hrange (arr_to_hfun g) \\<and>\n                      hsnd XZ =\n                      happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))\n 2. \\<lbrakk>hfst XZ \\<^bold>\\<in> hdomain (arr_to_hfun f);\n     hsnd XZ \\<^bold>\\<in> hrange (arr_to_hfun g) \\<and>\n     hsnd XZ =\n     happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))\\<rbrakk>\n    \\<Longrightarrow> hsnd XZ \\<^bold>\\<in> ide_to_hf (cod g) \\<and>\n                      hsnd XZ = DOWN (Fun (local.comp g f) (UP (hfst XZ)))", "have 3: \"UP (happ (arr_to_hfun f) (hfst XZ)) \\<in> Dom g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP (happ (arr_to_hfun f) (hfst XZ)) \\<in> Dom g", "using assms XZ 2"], ["proof (prove)\nusing this:\n  seq g f\n  hfst XZ \\<^bold>\\<in> hdomain (arr_to_hfun f)\n  UP (hfst XZ) \\<in> Dom f\n\ngoal (1 subgoal):\n 1. UP (happ (arr_to_hfun f) (hfst XZ)) \\<in> Dom g", "by (metis (no_types, lifting) \"1\" happ_mapsto(1) hfsetcat.UP_membI\n                arr_to_hfun_in_hexp seqE)"], ["proof (state)\nthis:\n  UP (happ (arr_to_hfun f) (hfst XZ)) \\<in> Dom g\n\ngoal (2 subgoals):\n 1. \\<lbrakk>hfst XZ \\<^bold>\\<in> hdomain (arr_to_hfun f);\n     hsnd XZ \\<^bold>\\<in> ide_to_hf (cod g) \\<and>\n     hsnd XZ = DOWN (Fun (local.comp g f) (UP (hfst XZ)))\\<rbrakk>\n    \\<Longrightarrow> hsnd XZ \\<^bold>\\<in> hrange (arr_to_hfun g) \\<and>\n                      hsnd XZ =\n                      happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))\n 2. \\<lbrakk>hfst XZ \\<^bold>\\<in> hdomain (arr_to_hfun f);\n     hsnd XZ \\<^bold>\\<in> hrange (arr_to_hfun g) \\<and>\n     hsnd XZ =\n     happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))\\<rbrakk>\n    \\<Longrightarrow> hsnd XZ \\<^bold>\\<in> ide_to_hf (cod g) \\<and>\n                      hsnd XZ = DOWN (Fun (local.comp g f) (UP (hfst XZ)))", "have 4: \"DOWN (Fun (comp g f) (UP (hfst XZ))) =\n                   happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DOWN (Fun (local.comp g f) (UP (hfst XZ))) =\n    happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. DOWN (Fun (local.comp g f) (UP (hfst XZ))) =\n    happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))", "have \"DOWN (Fun (comp g f) (UP (hfst XZ))) =\n                  DOWN (restrict (Fun g o Fun f) (Dom f) (UP (hfst XZ)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DOWN (Fun (local.comp g f) (UP (hfst XZ))) =\n    DOWN (restrict (Fun g \\<circ> Fun f) (Dom f) (UP (hfst XZ)))", "using assms Fun_comp Fun_char"], ["proof (prove)\nusing this:\n  seq g f\n  seq ?g ?f \\<Longrightarrow>\n  Fun (local.comp ?g ?f) = restrict (Fun ?g \\<circ> Fun ?f) (Dom ?f)\n  arr ?f \\<Longrightarrow>\n  Fun ?f =\n  (\\<lambda>x\\<^bold>\\<in>Dom ?f. UP (happ (arr_to_hfun ?f) (DOWN x)))\n\ngoal (1 subgoal):\n 1. DOWN (Fun (local.comp g f) (UP (hfst XZ))) =\n    DOWN (restrict (Fun g \\<circ> Fun f) (Dom f) (UP (hfst XZ)))", "by simp"], ["proof (state)\nthis:\n  DOWN (Fun (local.comp g f) (UP (hfst XZ))) =\n  DOWN (restrict (Fun g \\<circ> Fun f) (Dom f) (UP (hfst XZ)))\n\ngoal (1 subgoal):\n 1. DOWN (Fun (local.comp g f) (UP (hfst XZ))) =\n    happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))", "also"], ["proof (state)\nthis:\n  DOWN (Fun (local.comp g f) (UP (hfst XZ))) =\n  DOWN (restrict (Fun g \\<circ> Fun f) (Dom f) (UP (hfst XZ)))\n\ngoal (1 subgoal):\n 1. DOWN (Fun (local.comp g f) (UP (hfst XZ))) =\n    happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))", "have \"... = DOWN ((Fun g o Fun f) (UP (hfst XZ)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DOWN (restrict (Fun g \\<circ> Fun f) (Dom f) (UP (hfst XZ))) =\n    DOWN ((Fun g \\<circ> Fun f) (UP (hfst XZ)))", "using XZ 2"], ["proof (prove)\nusing this:\n  hfst XZ \\<^bold>\\<in> hdomain (arr_to_hfun f)\n  UP (hfst XZ) \\<in> Dom f\n\ngoal (1 subgoal):\n 1. DOWN (restrict (Fun g \\<circ> Fun f) (Dom f) (UP (hfst XZ))) =\n    DOWN ((Fun g \\<circ> Fun f) (UP (hfst XZ)))", "by auto"], ["proof (state)\nthis:\n  DOWN (restrict (Fun g \\<circ> Fun f) (Dom f) (UP (hfst XZ))) =\n  DOWN ((Fun g \\<circ> Fun f) (UP (hfst XZ)))\n\ngoal (1 subgoal):\n 1. DOWN (Fun (local.comp g f) (UP (hfst XZ))) =\n    happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))", "also"], ["proof (state)\nthis:\n  DOWN (restrict (Fun g \\<circ> Fun f) (Dom f) (UP (hfst XZ))) =\n  DOWN ((Fun g \\<circ> Fun f) (UP (hfst XZ)))\n\ngoal (1 subgoal):\n 1. DOWN (Fun (local.comp g f) (UP (hfst XZ))) =\n    happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))", "have \"... = DOWN (Fun g (Fun f (UP (hfst XZ))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DOWN ((Fun g \\<circ> Fun f) (UP (hfst XZ))) =\n    DOWN (Fun g (Fun f (UP (hfst XZ))))", "by simp"], ["proof (state)\nthis:\n  DOWN ((Fun g \\<circ> Fun f) (UP (hfst XZ))) =\n  DOWN (Fun g (Fun f (UP (hfst XZ))))\n\ngoal (1 subgoal):\n 1. DOWN (Fun (local.comp g f) (UP (hfst XZ))) =\n    happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))", "also"], ["proof (state)\nthis:\n  DOWN ((Fun g \\<circ> Fun f) (UP (hfst XZ))) =\n  DOWN (Fun g (Fun f (UP (hfst XZ))))\n\ngoal (1 subgoal):\n 1. DOWN (Fun (local.comp g f) (UP (hfst XZ))) =\n    happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))", "have\n              \"... = DOWN (Fun g (restrict (\\<lambda>x. UP (happ (arr_to_hfun f) (DOWN x))) (Dom f)\n                                           (UP (hfst XZ))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DOWN (Fun g (Fun f (UP (hfst XZ)))) =\n    DOWN\n     (Fun g\n       ((\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x)))\n         (UP (hfst XZ))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. DOWN (Fun g (Fun f (UP (hfst XZ)))) =\n    DOWN\n     (Fun g\n       ((\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x)))\n         (UP (hfst XZ))))", "have \"Fun f = restrict (\\<lambda>x. UP (happ (arr_to_hfun f) (DOWN x))) (Dom f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun f =\n    (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x)))", "using assms Fun_char [of f]"], ["proof (prove)\nusing this:\n  seq g f\n  arr f \\<Longrightarrow>\n  Fun f = (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x)))\n\ngoal (1 subgoal):\n 1. Fun f =\n    (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x)))", "by blast"], ["proof (state)\nthis:\n  Fun f = (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x)))\n\ngoal (1 subgoal):\n 1. DOWN (Fun g (Fun f (UP (hfst XZ)))) =\n    DOWN\n     (Fun g\n       ((\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x)))\n         (UP (hfst XZ))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  Fun f = (\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x)))\n\ngoal (1 subgoal):\n 1. DOWN (Fun g (Fun f (UP (hfst XZ)))) =\n    DOWN\n     (Fun g\n       ((\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x)))\n         (UP (hfst XZ))))", "by simp"], ["proof (state)\nthis:\n  DOWN (Fun g (Fun f (UP (hfst XZ)))) =\n  DOWN\n   (Fun g\n     ((\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x)))\n       (UP (hfst XZ))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  DOWN (Fun g (Fun f (UP (hfst XZ)))) =\n  DOWN\n   (Fun g\n     ((\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x)))\n       (UP (hfst XZ))))\n\ngoal (1 subgoal):\n 1. DOWN (Fun (local.comp g f) (UP (hfst XZ))) =\n    happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))", "also"], ["proof (state)\nthis:\n  DOWN (Fun g (Fun f (UP (hfst XZ)))) =\n  DOWN\n   (Fun g\n     ((\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x)))\n       (UP (hfst XZ))))\n\ngoal (1 subgoal):\n 1. DOWN (Fun (local.comp g f) (UP (hfst XZ))) =\n    happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))", "have \"... = DOWN (Fun g (UP (happ (arr_to_hfun f) (hfst XZ))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DOWN\n     (Fun g\n       ((\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x)))\n         (UP (hfst XZ)))) =\n    DOWN (Fun g (UP (happ (arr_to_hfun f) (hfst XZ))))", "using 2"], ["proof (prove)\nusing this:\n  UP (hfst XZ) \\<in> Dom f\n\ngoal (1 subgoal):\n 1. DOWN\n     (Fun g\n       ((\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x)))\n         (UP (hfst XZ)))) =\n    DOWN (Fun g (UP (happ (arr_to_hfun f) (hfst XZ))))", "by simp"], ["proof (state)\nthis:\n  DOWN\n   (Fun g\n     ((\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x)))\n       (UP (hfst XZ)))) =\n  DOWN (Fun g (UP (happ (arr_to_hfun f) (hfst XZ))))\n\ngoal (1 subgoal):\n 1. DOWN (Fun (local.comp g f) (UP (hfst XZ))) =\n    happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))", "also"], ["proof (state)\nthis:\n  DOWN\n   (Fun g\n     ((\\<lambda>x\\<^bold>\\<in>Dom f. UP (happ (arr_to_hfun f) (DOWN x)))\n       (UP (hfst XZ)))) =\n  DOWN (Fun g (UP (happ (arr_to_hfun f) (hfst XZ))))\n\ngoal (1 subgoal):\n 1. DOWN (Fun (local.comp g f) (UP (hfst XZ))) =\n    happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))", "have \"... = DOWN (restrict (\\<lambda>x. UP (happ (arr_to_hfun g) (DOWN x))) (Dom g)\n                                            (UP (happ (arr_to_hfun f) (hfst XZ))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DOWN (Fun g (UP (happ (arr_to_hfun f) (hfst XZ)))) =\n    DOWN\n     ((\\<lambda>x\\<^bold>\\<in>Dom g. UP (happ (arr_to_hfun g) (DOWN x)))\n       (UP (happ (arr_to_hfun f) (hfst XZ))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. DOWN (Fun g (UP (happ (arr_to_hfun f) (hfst XZ)))) =\n    DOWN\n     ((\\<lambda>x\\<^bold>\\<in>Dom g. UP (happ (arr_to_hfun g) (DOWN x)))\n       (UP (happ (arr_to_hfun f) (hfst XZ))))", "have \"Fun g = restrict (\\<lambda>x. UP (happ (arr_to_hfun g) (DOWN x))) (Dom g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun g =\n    (\\<lambda>x\\<^bold>\\<in>Dom g. UP (happ (arr_to_hfun g) (DOWN x)))", "using assms Fun_char [of g]"], ["proof (prove)\nusing this:\n  seq g f\n  arr g \\<Longrightarrow>\n  Fun g = (\\<lambda>x\\<^bold>\\<in>Dom g. UP (happ (arr_to_hfun g) (DOWN x)))\n\ngoal (1 subgoal):\n 1. Fun g =\n    (\\<lambda>x\\<^bold>\\<in>Dom g. UP (happ (arr_to_hfun g) (DOWN x)))", "by blast"], ["proof (state)\nthis:\n  Fun g = (\\<lambda>x\\<^bold>\\<in>Dom g. UP (happ (arr_to_hfun g) (DOWN x)))\n\ngoal (1 subgoal):\n 1. DOWN (Fun g (UP (happ (arr_to_hfun f) (hfst XZ)))) =\n    DOWN\n     ((\\<lambda>x\\<^bold>\\<in>Dom g. UP (happ (arr_to_hfun g) (DOWN x)))\n       (UP (happ (arr_to_hfun f) (hfst XZ))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  Fun g = (\\<lambda>x\\<^bold>\\<in>Dom g. UP (happ (arr_to_hfun g) (DOWN x)))\n\ngoal (1 subgoal):\n 1. DOWN (Fun g (UP (happ (arr_to_hfun f) (hfst XZ)))) =\n    DOWN\n     ((\\<lambda>x\\<^bold>\\<in>Dom g. UP (happ (arr_to_hfun g) (DOWN x)))\n       (UP (happ (arr_to_hfun f) (hfst XZ))))", "by simp"], ["proof (state)\nthis:\n  DOWN (Fun g (UP (happ (arr_to_hfun f) (hfst XZ)))) =\n  DOWN\n   ((\\<lambda>x\\<^bold>\\<in>Dom g. UP (happ (arr_to_hfun g) (DOWN x)))\n     (UP (happ (arr_to_hfun f) (hfst XZ))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  DOWN (Fun g (UP (happ (arr_to_hfun f) (hfst XZ)))) =\n  DOWN\n   ((\\<lambda>x\\<^bold>\\<in>Dom g. UP (happ (arr_to_hfun g) (DOWN x)))\n     (UP (happ (arr_to_hfun f) (hfst XZ))))\n\ngoal (1 subgoal):\n 1. DOWN (Fun (local.comp g f) (UP (hfst XZ))) =\n    happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))", "also"], ["proof (state)\nthis:\n  DOWN (Fun g (UP (happ (arr_to_hfun f) (hfst XZ)))) =\n  DOWN\n   ((\\<lambda>x\\<^bold>\\<in>Dom g. UP (happ (arr_to_hfun g) (DOWN x)))\n     (UP (happ (arr_to_hfun f) (hfst XZ))))\n\ngoal (1 subgoal):\n 1. DOWN (Fun (local.comp g f) (UP (hfst XZ))) =\n    happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))", "have \"... = happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DOWN\n     ((\\<lambda>x\\<^bold>\\<in>Dom g. UP (happ (arr_to_hfun g) (DOWN x)))\n       (UP (happ (arr_to_hfun f) (hfst XZ)))) =\n    happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))", "using 3"], ["proof (prove)\nusing this:\n  UP (happ (arr_to_hfun f) (hfst XZ)) \\<in> Dom g\n\ngoal (1 subgoal):\n 1. DOWN\n     ((\\<lambda>x\\<^bold>\\<in>Dom g. UP (happ (arr_to_hfun g) (DOWN x)))\n       (UP (happ (arr_to_hfun f) (hfst XZ)))) =\n    happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))", "by simp"], ["proof (state)\nthis:\n  DOWN\n   ((\\<lambda>x\\<^bold>\\<in>Dom g. UP (happ (arr_to_hfun g) (DOWN x)))\n     (UP (happ (arr_to_hfun f) (hfst XZ)))) =\n  happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))\n\ngoal (1 subgoal):\n 1. DOWN (Fun (local.comp g f) (UP (hfst XZ))) =\n    happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))", "finally"], ["proof (chain)\npicking this:\n  DOWN (Fun (local.comp g f) (UP (hfst XZ))) =\n  happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))", "show ?thesis"], ["proof (prove)\nusing this:\n  DOWN (Fun (local.comp g f) (UP (hfst XZ))) =\n  happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))\n\ngoal (1 subgoal):\n 1. DOWN (Fun (local.comp g f) (UP (hfst XZ))) =\n    happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))", "by blast"], ["proof (state)\nthis:\n  DOWN (Fun (local.comp g f) (UP (hfst XZ))) =\n  happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  DOWN (Fun (local.comp g f) (UP (hfst XZ))) =\n  happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))\n\ngoal (2 subgoals):\n 1. \\<lbrakk>hfst XZ \\<^bold>\\<in> hdomain (arr_to_hfun f);\n     hsnd XZ \\<^bold>\\<in> ide_to_hf (cod g) \\<and>\n     hsnd XZ = DOWN (Fun (local.comp g f) (UP (hfst XZ)))\\<rbrakk>\n    \\<Longrightarrow> hsnd XZ \\<^bold>\\<in> hrange (arr_to_hfun g) \\<and>\n                      hsnd XZ =\n                      happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))\n 2. \\<lbrakk>hfst XZ \\<^bold>\\<in> hdomain (arr_to_hfun f);\n     hsnd XZ \\<^bold>\\<in> hrange (arr_to_hfun g) \\<and>\n     hsnd XZ =\n     happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))\\<rbrakk>\n    \\<Longrightarrow> hsnd XZ \\<^bold>\\<in> ide_to_hf (cod g) \\<and>\n                      hsnd XZ = DOWN (Fun (local.comp g f) (UP (hfst XZ)))", "have 5: \"DOWN (Fun (comp g f) (UP (hfst XZ))) \\<^bold>\\<in> hrange (arr_to_hfun g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DOWN (Fun (local.comp g f) (UP (hfst XZ))) \\<^bold>\\<in>\n    hrange (arr_to_hfun g)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. DOWN (Fun (local.comp g f) (UP (hfst XZ))) \\<^bold>\\<in>\n    hrange (arr_to_hfun g)", "have \"happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ)) \\<^bold>\\<in> hrange (arr_to_hfun g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ)) \\<^bold>\\<in>\n    hrange (arr_to_hfun g)", "using assms 1 3 XZ hfun_arr_to_hfun happ_mapsto arr_to_hfun_in_hexp arr_to_hfun_def"], ["proof (prove)\nusing this:\n  seq g f\n  hdomain (arr_to_hfun f) = ide_to_hf (local.dom f)\n  UP (happ (arr_to_hfun f) (hfst XZ)) \\<in> Dom g\n  hfst XZ \\<^bold>\\<in> hdomain (arr_to_hfun f)\n  arr ?f \\<Longrightarrow>\n  hfun (ide_to_hf (local.dom ?f)) (ide_to_hf (cod ?f)) (arr_to_hfun ?f)\n  \\<lbrakk>?F \\<^bold>\\<in> hexp ?B ?C; ?Y \\<^bold>\\<in> ?B\\<rbrakk>\n  \\<Longrightarrow> happ ?F ?Y \\<^bold>\\<in> ?C\n  \\<lbrakk>?F \\<^bold>\\<in> hexp ?B ?C; ?Y \\<^bold>\\<in> ?B\\<rbrakk>\n  \\<Longrightarrow> happ ?F ?Y \\<^bold>\\<in> hrange ?F\n  arr ?f \\<Longrightarrow>\n  arr_to_hfun ?f \\<^bold>\\<in>\n  hexp (ide_to_hf (local.dom ?f)) (ide_to_hf (cod ?f))\n  arr_to_hfun ?f =\n  \\<lbrace>XY \\<^bold>\\<in> ide_to_hf (local.dom ?f) * ide_to_hf (cod ?f).\n   hsnd XY = DOWN (Fun ?f (UP (hfst XY)))\\<rbrace>\n\ngoal (1 subgoal):\n 1. happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ)) \\<^bold>\\<in>\n    hrange (arr_to_hfun g)", "by (metis (no_types, lifting) seqE)"], ["proof (state)\nthis:\n  happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ)) \\<^bold>\\<in>\n  hrange (arr_to_hfun g)\n\ngoal (1 subgoal):\n 1. DOWN (Fun (local.comp g f) (UP (hfst XZ))) \\<^bold>\\<in>\n    hrange (arr_to_hfun g)", "thus ?thesis"], ["proof (prove)\nusing this:\n  happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ)) \\<^bold>\\<in>\n  hrange (arr_to_hfun g)\n\ngoal (1 subgoal):\n 1. DOWN (Fun (local.comp g f) (UP (hfst XZ))) \\<^bold>\\<in>\n    hrange (arr_to_hfun g)", "using XZ 4"], ["proof (prove)\nusing this:\n  happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ)) \\<^bold>\\<in>\n  hrange (arr_to_hfun g)\n  hfst XZ \\<^bold>\\<in> hdomain (arr_to_hfun f)\n  DOWN (Fun (local.comp g f) (UP (hfst XZ))) =\n  happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))\n\ngoal (1 subgoal):\n 1. DOWN (Fun (local.comp g f) (UP (hfst XZ))) \\<^bold>\\<in>\n    hrange (arr_to_hfun g)", "by simp"], ["proof (state)\nthis:\n  DOWN (Fun (local.comp g f) (UP (hfst XZ))) \\<^bold>\\<in>\n  hrange (arr_to_hfun g)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  DOWN (Fun (local.comp g f) (UP (hfst XZ))) \\<^bold>\\<in>\n  hrange (arr_to_hfun g)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>hfst XZ \\<^bold>\\<in> hdomain (arr_to_hfun f);\n     hsnd XZ \\<^bold>\\<in> ide_to_hf (cod g) \\<and>\n     hsnd XZ = DOWN (Fun (local.comp g f) (UP (hfst XZ)))\\<rbrakk>\n    \\<Longrightarrow> hsnd XZ \\<^bold>\\<in> hrange (arr_to_hfun g) \\<and>\n                      hsnd XZ =\n                      happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))\n 2. \\<lbrakk>hfst XZ \\<^bold>\\<in> hdomain (arr_to_hfun f);\n     hsnd XZ \\<^bold>\\<in> hrange (arr_to_hfun g) \\<and>\n     hsnd XZ =\n     happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))\\<rbrakk>\n    \\<Longrightarrow> hsnd XZ \\<^bold>\\<in> ide_to_hf (cod g) \\<and>\n                      hsnd XZ = DOWN (Fun (local.comp g f) (UP (hfst XZ)))", "show \"hsnd XZ \\<^bold>\\<in> ide_to_hf (cod g) \\<and>\n                  hsnd XZ = DOWN (Fun (comp g f) (UP (hfst XZ)))\n                          \\<Longrightarrow>\n                hsnd XZ \\<^bold>\\<in> hrange (arr_to_hfun g) \\<and>\n                  hsnd XZ = happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hsnd XZ \\<^bold>\\<in> ide_to_hf (cod g) \\<and>\n    hsnd XZ = DOWN (Fun (local.comp g f) (UP (hfst XZ))) \\<Longrightarrow>\n    hsnd XZ \\<^bold>\\<in> hrange (arr_to_hfun g) \\<and>\n    hsnd XZ = happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))", "using XZ 4 5"], ["proof (prove)\nusing this:\n  hfst XZ \\<^bold>\\<in> hdomain (arr_to_hfun f)\n  DOWN (Fun (local.comp g f) (UP (hfst XZ))) =\n  happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))\n  DOWN (Fun (local.comp g f) (UP (hfst XZ))) \\<^bold>\\<in>\n  hrange (arr_to_hfun g)\n\ngoal (1 subgoal):\n 1. hsnd XZ \\<^bold>\\<in> ide_to_hf (cod g) \\<and>\n    hsnd XZ = DOWN (Fun (local.comp g f) (UP (hfst XZ))) \\<Longrightarrow>\n    hsnd XZ \\<^bold>\\<in> hrange (arr_to_hfun g) \\<and>\n    hsnd XZ = happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))", "by simp"], ["proof (state)\nthis:\n  hsnd XZ \\<^bold>\\<in> ide_to_hf (cod g) \\<and>\n  hsnd XZ = DOWN (Fun (local.comp g f) (UP (hfst XZ))) \\<Longrightarrow>\n  hsnd XZ \\<^bold>\\<in> hrange (arr_to_hfun g) \\<and>\n  hsnd XZ = happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))\n\ngoal (1 subgoal):\n 1. \\<lbrakk>hfst XZ \\<^bold>\\<in> hdomain (arr_to_hfun f);\n     hsnd XZ \\<^bold>\\<in> hrange (arr_to_hfun g) \\<and>\n     hsnd XZ =\n     happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))\\<rbrakk>\n    \\<Longrightarrow> hsnd XZ \\<^bold>\\<in> ide_to_hf (cod g) \\<and>\n                      hsnd XZ = DOWN (Fun (local.comp g f) (UP (hfst XZ)))", "show \"hsnd XZ \\<^bold>\\<in> hrange (arr_to_hfun g) \\<and>\n                  hsnd XZ = happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))\n                          \\<Longrightarrow>\n                hsnd XZ \\<^bold>\\<in> ide_to_hf (cod g) \\<and>\n                  hsnd XZ = DOWN (Fun (comp g f) (UP (hfst XZ)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hsnd XZ \\<^bold>\\<in> hrange (arr_to_hfun g) \\<and>\n    hsnd XZ =\n    happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ)) \\<Longrightarrow>\n    hsnd XZ \\<^bold>\\<in> ide_to_hf (cod g) \\<and>\n    hsnd XZ = DOWN (Fun (local.comp g f) (UP (hfst XZ)))", "using assms XZ 1 4"], ["proof (prove)\nusing this:\n  seq g f\n  hfst XZ \\<^bold>\\<in> hdomain (arr_to_hfun f)\n  hdomain (arr_to_hfun f) = ide_to_hf (local.dom f)\n  DOWN (Fun (local.comp g f) (UP (hfst XZ))) =\n  happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))\n\ngoal (1 subgoal):\n 1. hsnd XZ \\<^bold>\\<in> hrange (arr_to_hfun g) \\<and>\n    hsnd XZ =\n    happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ)) \\<Longrightarrow>\n    hsnd XZ \\<^bold>\\<in> ide_to_hf (cod g) \\<and>\n    hsnd XZ = DOWN (Fun (local.comp g f) (UP (hfst XZ)))", "by (metis (no_types, lifting) arr_to_hfun_in_hexp happ_mapsto(1) seqE)"], ["proof (state)\nthis:\n  hsnd XZ \\<^bold>\\<in> hrange (arr_to_hfun g) \\<and>\n  hsnd XZ =\n  happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ)) \\<Longrightarrow>\n  hsnd XZ \\<^bold>\\<in> ide_to_hf (cod g) \\<and>\n  hsnd XZ = DOWN (Fun (local.comp g f) (UP (hfst XZ)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hfst XZ \\<^bold>\\<in> hdomain (arr_to_hfun f) \\<Longrightarrow>\n  (hsnd XZ \\<^bold>\\<in> ide_to_hf (cod g) \\<and>\n   hsnd XZ = DOWN (Fun (local.comp g f) (UP (hfst XZ)))) =\n  (hsnd XZ \\<^bold>\\<in> hrange (arr_to_hfun g) \\<and>\n   hsnd XZ = happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       (x \\<^bold>\\<in>\n        \\<lbrace>XZ \\<^bold>\\<in>\n         ide_to_hf (local.dom f) * ide_to_hf (cod g).\n         hsnd XZ = DOWN (Fun (local.comp g f) (UP (hfst XZ)))\\<rbrace>) =\n       (x \\<^bold>\\<in>\n        \\<lbrace>XZ \\<^bold>\\<in>\n         hdomain (arr_to_hfun f) * hrange (arr_to_hfun g).\n         hsnd XZ =\n         happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))\\<rbrace>)", "thus \"XZ \\<^bold>\\<in> \\<lbrace>XZ \\<^bold>\\<in> ide_to_hf (dom f) * ide_to_hf (cod g).\n                      hsnd XZ = DOWN (Fun (comp g f) (UP (hfst XZ)))\\<rbrace>\n                \\<longleftrightarrow>\n              XZ \\<^bold>\\<in> \\<lbrace>XZ \\<^bold>\\<in> hdomain (arr_to_hfun f) * hrange (arr_to_hfun g).\n                      hsnd XZ = happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))\\<rbrace>\""], ["proof (prove)\nusing this:\n  hfst XZ \\<^bold>\\<in> hdomain (arr_to_hfun f) \\<Longrightarrow>\n  (hsnd XZ \\<^bold>\\<in> ide_to_hf (cod g) \\<and>\n   hsnd XZ = DOWN (Fun (local.comp g f) (UP (hfst XZ)))) =\n  (hsnd XZ \\<^bold>\\<in> hrange (arr_to_hfun g) \\<and>\n   hsnd XZ = happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ)))\n\ngoal (1 subgoal):\n 1. (XZ \\<^bold>\\<in>\n     \\<lbrace>XZ \\<^bold>\\<in> ide_to_hf (local.dom f) * ide_to_hf (cod g).\n      hsnd XZ = DOWN (Fun (local.comp g f) (UP (hfst XZ)))\\<rbrace>) =\n    (XZ \\<^bold>\\<in>\n     \\<lbrace>XZ \\<^bold>\\<in>\n      hdomain (arr_to_hfun f) * hrange (arr_to_hfun g).\n      hsnd XZ =\n      happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))\\<rbrace>)", "using 1 is_hpair_def"], ["proof (prove)\nusing this:\n  hfst XZ \\<^bold>\\<in> hdomain (arr_to_hfun f) \\<Longrightarrow>\n  (hsnd XZ \\<^bold>\\<in> ide_to_hf (cod g) \\<and>\n   hsnd XZ = DOWN (Fun (local.comp g f) (UP (hfst XZ)))) =\n  (hsnd XZ \\<^bold>\\<in> hrange (arr_to_hfun g) \\<and>\n   hsnd XZ = happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ)))\n  hdomain (arr_to_hfun f) = ide_to_hf (local.dom f)\n  is_hpair ?z = (\\<exists>x y. ?z = \\<langle>x, y\\<rangle>)\n\ngoal (1 subgoal):\n 1. (XZ \\<^bold>\\<in>\n     \\<lbrace>XZ \\<^bold>\\<in> ide_to_hf (local.dom f) * ide_to_hf (cod g).\n      hsnd XZ = DOWN (Fun (local.comp g f) (UP (hfst XZ)))\\<rbrace>) =\n    (XZ \\<^bold>\\<in>\n     \\<lbrace>XZ \\<^bold>\\<in>\n      hdomain (arr_to_hfun f) * hrange (arr_to_hfun g).\n      hsnd XZ =\n      happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))\\<rbrace>)", "by auto"], ["proof (state)\nthis:\n  (XZ \\<^bold>\\<in>\n   \\<lbrace>XZ \\<^bold>\\<in> ide_to_hf (local.dom f) * ide_to_hf (cod g).\n    hsnd XZ = DOWN (Fun (local.comp g f) (UP (hfst XZ)))\\<rbrace>) =\n  (XZ \\<^bold>\\<in>\n   \\<lbrace>XZ \\<^bold>\\<in>\n    hdomain (arr_to_hfun f) * hrange (arr_to_hfun g).\n    hsnd XZ =\n    happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))\\<rbrace>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrace>XZ \\<^bold>\\<in> ide_to_hf (local.dom f) * ide_to_hf (cod g).\n   hsnd XZ = DOWN (Fun (local.comp g f) (UP (hfst XZ)))\\<rbrace> =\n  \\<lbrace>XZ \\<^bold>\\<in>\n   hdomain (arr_to_hfun f) * hrange (arr_to_hfun g).\n   hsnd XZ = happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))\\<rbrace>\n\ngoal (1 subgoal):\n 1. arr_to_hfun (local.comp g f) = hcomp (arr_to_hfun g) (arr_to_hfun f)", "also"], ["proof (state)\nthis:\n  \\<lbrace>XZ \\<^bold>\\<in> ide_to_hf (local.dom f) * ide_to_hf (cod g).\n   hsnd XZ = DOWN (Fun (local.comp g f) (UP (hfst XZ)))\\<rbrace> =\n  \\<lbrace>XZ \\<^bold>\\<in>\n   hdomain (arr_to_hfun f) * hrange (arr_to_hfun g).\n   hsnd XZ = happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))\\<rbrace>\n\ngoal (1 subgoal):\n 1. arr_to_hfun (local.comp g f) = hcomp (arr_to_hfun g) (arr_to_hfun f)", "have \"... = hcomp (arr_to_hfun g) (arr_to_hfun f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>XZ \\<^bold>\\<in>\n     hdomain (arr_to_hfun f) * hrange (arr_to_hfun g).\n     hsnd XZ =\n     happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))\\<rbrace> =\n    hcomp (arr_to_hfun g) (arr_to_hfun f)", "using assms arr_to_hfun_def hcomp_def"], ["proof (prove)\nusing this:\n  seq g f\n  arr_to_hfun ?f =\n  \\<lbrace>XY \\<^bold>\\<in> ide_to_hf (local.dom ?f) * ide_to_hf (cod ?f).\n   hsnd XY = DOWN (Fun ?f (UP (hfst XY)))\\<rbrace>\n  hcomp ?G ?F =\n  \\<lbrace>XZ \\<^bold>\\<in> hdomain ?F * hrange ?G.\n   hsnd XZ = happ ?G (happ ?F (hfst XZ))\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<lbrace>XZ \\<^bold>\\<in>\n     hdomain (arr_to_hfun f) * hrange (arr_to_hfun g).\n     hsnd XZ =\n     happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))\\<rbrace> =\n    hcomp (arr_to_hfun g) (arr_to_hfun f)", "by simp"], ["proof (state)\nthis:\n  \\<lbrace>XZ \\<^bold>\\<in>\n   hdomain (arr_to_hfun f) * hrange (arr_to_hfun g).\n   hsnd XZ =\n   happ (arr_to_hfun g) (happ (arr_to_hfun f) (hfst XZ))\\<rbrace> =\n  hcomp (arr_to_hfun g) (arr_to_hfun f)\n\ngoal (1 subgoal):\n 1. arr_to_hfun (local.comp g f) = hcomp (arr_to_hfun g) (arr_to_hfun f)", "finally"], ["proof (chain)\npicking this:\n  arr_to_hfun (local.comp g f) = hcomp (arr_to_hfun g) (arr_to_hfun f)", "show ?thesis"], ["proof (prove)\nusing this:\n  arr_to_hfun (local.comp g f) = hcomp (arr_to_hfun g) (arr_to_hfun f)\n\ngoal (1 subgoal):\n 1. arr_to_hfun (local.comp g f) = hcomp (arr_to_hfun g) (arr_to_hfun f)", "by simp"], ["proof (state)\nthis:\n  arr_to_hfun (local.comp g f) = hcomp (arr_to_hfun g) (arr_to_hfun f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma hfun_to_arr_hcomp:\n    assumes \"hfun A B F\" and \"hfun B C G\"\n    shows \"hfun_to_arr A C (hcomp G F) = comp (hfun_to_arr B C G) (hfun_to_arr A B F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hfun_to_arr A C (hcomp G F) =\n    local.comp (hfun_to_arr B C G) (hfun_to_arr A B F)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. hfun_to_arr A C (hcomp G F) =\n    local.comp (hfun_to_arr B C G) (hfun_to_arr A B F)", "have 1: \"arr_to_hfun (hfun_to_arr A C (hcomp G F)) =\n               arr_to_hfun (comp (hfun_to_arr B C G) (hfun_to_arr A B F))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr_to_hfun (hfun_to_arr A C (hcomp G F)) =\n    arr_to_hfun (local.comp (hfun_to_arr B C G) (hfun_to_arr A B F))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. arr_to_hfun (hfun_to_arr A C (hcomp G F)) =\n    arr_to_hfun (local.comp (hfun_to_arr B C G) (hfun_to_arr A B F))", "have \"arr_to_hfun (comp (hfun_to_arr B C G) (hfun_to_arr A B F)) =\n              hcomp (arr_to_hfun (hfun_to_arr B C G)) (arr_to_hfun (hfun_to_arr A B F))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr_to_hfun (local.comp (hfun_to_arr B C G) (hfun_to_arr A B F)) =\n    hcomp (arr_to_hfun (hfun_to_arr B C G))\n     (arr_to_hfun (hfun_to_arr A B F))", "using assms arr_to_hfun_comp hfun_to_arr_in_hom"], ["proof (prove)\nusing this:\n  hfun A B F\n  hfun B C G\n  seq ?g ?f \\<Longrightarrow>\n  arr_to_hfun (local.comp ?g ?f) = hcomp (arr_to_hfun ?g) (arr_to_hfun ?f)\n  hfun ?B ?C ?F \\<Longrightarrow>\n  \\<guillemotleft>hfun_to_arr ?B ?C\n                   ?F : hf_to_ide\n                         ?B \\<rightarrow> hf_to_ide ?C\\<guillemotright>\n\ngoal (1 subgoal):\n 1. arr_to_hfun (local.comp (hfun_to_arr B C G) (hfun_to_arr A B F)) =\n    hcomp (arr_to_hfun (hfun_to_arr B C G))\n     (arr_to_hfun (hfun_to_arr A B F))", "by blast"], ["proof (state)\nthis:\n  arr_to_hfun (local.comp (hfun_to_arr B C G) (hfun_to_arr A B F)) =\n  hcomp (arr_to_hfun (hfun_to_arr B C G)) (arr_to_hfun (hfun_to_arr A B F))\n\ngoal (1 subgoal):\n 1. arr_to_hfun (hfun_to_arr A C (hcomp G F)) =\n    arr_to_hfun (local.comp (hfun_to_arr B C G) (hfun_to_arr A B F))", "also"], ["proof (state)\nthis:\n  arr_to_hfun (local.comp (hfun_to_arr B C G) (hfun_to_arr A B F)) =\n  hcomp (arr_to_hfun (hfun_to_arr B C G)) (arr_to_hfun (hfun_to_arr A B F))\n\ngoal (1 subgoal):\n 1. arr_to_hfun (hfun_to_arr A C (hcomp G F)) =\n    arr_to_hfun (local.comp (hfun_to_arr B C G) (hfun_to_arr A B F))", "have \"... = hcomp G F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hcomp (arr_to_hfun (hfun_to_arr B C G))\n     (arr_to_hfun (hfun_to_arr A B F)) =\n    hcomp G F", "using assms"], ["proof (prove)\nusing this:\n  hfun A B F\n  hfun B C G\n\ngoal (1 subgoal):\n 1. hcomp (arr_to_hfun (hfun_to_arr B C G))\n     (arr_to_hfun (hfun_to_arr A B F)) =\n    hcomp G F", "by (simp add: arr_to_hfun_hfun_to_arr)"], ["proof (state)\nthis:\n  hcomp (arr_to_hfun (hfun_to_arr B C G))\n   (arr_to_hfun (hfun_to_arr A B F)) =\n  hcomp G F\n\ngoal (1 subgoal):\n 1. arr_to_hfun (hfun_to_arr A C (hcomp G F)) =\n    arr_to_hfun (local.comp (hfun_to_arr B C G) (hfun_to_arr A B F))", "also"], ["proof (state)\nthis:\n  hcomp (arr_to_hfun (hfun_to_arr B C G))\n   (arr_to_hfun (hfun_to_arr A B F)) =\n  hcomp G F\n\ngoal (1 subgoal):\n 1. arr_to_hfun (hfun_to_arr A C (hcomp G F)) =\n    arr_to_hfun (local.comp (hfun_to_arr B C G) (hfun_to_arr A B F))", "have \"... = arr_to_hfun (hfun_to_arr A C (hcomp G F))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hcomp G F = arr_to_hfun (hfun_to_arr A C (hcomp G F))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. hcomp G F = arr_to_hfun (hfun_to_arr A C (hcomp G F))", "have \"hfun A C (hcomp G F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hfun A C (hcomp G F)", "using assms hfun_hcomp"], ["proof (prove)\nusing this:\n  hfun A B F\n  hfun B C G\n  \\<lbrakk>hfun ?A ?B ?F; hfun ?B ?C ?G\\<rbrakk>\n  \\<Longrightarrow> hfun ?A ?C (hcomp ?G ?F)\n\ngoal (1 subgoal):\n 1. hfun A C (hcomp G F)", "by simp"], ["proof (state)\nthis:\n  hfun A C (hcomp G F)\n\ngoal (1 subgoal):\n 1. hcomp G F = arr_to_hfun (hfun_to_arr A C (hcomp G F))", "thus ?thesis"], ["proof (prove)\nusing this:\n  hfun A C (hcomp G F)\n\ngoal (1 subgoal):\n 1. hcomp G F = arr_to_hfun (hfun_to_arr A C (hcomp G F))", "by (simp add: arr_to_hfun_hfun_to_arr)"], ["proof (state)\nthis:\n  hcomp G F = arr_to_hfun (hfun_to_arr A C (hcomp G F))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hcomp G F = arr_to_hfun (hfun_to_arr A C (hcomp G F))\n\ngoal (1 subgoal):\n 1. arr_to_hfun (hfun_to_arr A C (hcomp G F)) =\n    arr_to_hfun (local.comp (hfun_to_arr B C G) (hfun_to_arr A B F))", "finally"], ["proof (chain)\npicking this:\n  arr_to_hfun (local.comp (hfun_to_arr B C G) (hfun_to_arr A B F)) =\n  arr_to_hfun (hfun_to_arr A C (hcomp G F))", "show ?thesis"], ["proof (prove)\nusing this:\n  arr_to_hfun (local.comp (hfun_to_arr B C G) (hfun_to_arr A B F)) =\n  arr_to_hfun (hfun_to_arr A C (hcomp G F))\n\ngoal (1 subgoal):\n 1. arr_to_hfun (hfun_to_arr A C (hcomp G F)) =\n    arr_to_hfun (local.comp (hfun_to_arr B C G) (hfun_to_arr A B F))", "by simp"], ["proof (state)\nthis:\n  arr_to_hfun (hfun_to_arr A C (hcomp G F)) =\n  arr_to_hfun (local.comp (hfun_to_arr B C G) (hfun_to_arr A B F))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  arr_to_hfun (hfun_to_arr A C (hcomp G F)) =\n  arr_to_hfun (local.comp (hfun_to_arr B C G) (hfun_to_arr A B F))\n\ngoal (1 subgoal):\n 1. hfun_to_arr A C (hcomp G F) =\n    local.comp (hfun_to_arr B C G) (hfun_to_arr A B F)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. hfun_to_arr A C (hcomp G F) =\n    local.comp (hfun_to_arr B C G) (hfun_to_arr A B F)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. hfun_to_arr A C (hcomp G F) =\n    local.comp (hfun_to_arr B C G) (hfun_to_arr A B F)", "have \"hfun_to_arr A C (hcomp G F) \\<in> hom (hf_to_ide A) (hf_to_ide C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hfun_to_arr A C (hcomp G F) \\<in> hom (hf_to_ide A) (hf_to_ide C)", "using assms hfun_hcomp hf_to_ide_def hfun_to_arr_in_hom"], ["proof (prove)\nusing this:\n  hfun A B F\n  hfun B C G\n  \\<lbrakk>hfun ?A ?B ?F; hfun ?B ?C ?G\\<rbrakk>\n  \\<Longrightarrow> hfun ?A ?C (hcomp ?G ?F)\n  hf_to_ide ?x = mkIde (UP ` hfset ?x)\n  hfun ?B ?C ?F \\<Longrightarrow>\n  \\<guillemotleft>hfun_to_arr ?B ?C\n                   ?F : hf_to_ide\n                         ?B \\<rightarrow> hf_to_ide ?C\\<guillemotright>\n\ngoal (1 subgoal):\n 1. hfun_to_arr A C (hcomp G F) \\<in> hom (hf_to_ide A) (hf_to_ide C)", "by auto"], ["proof (state)\nthis:\n  hfun_to_arr A C (hcomp G F) \\<in> hom (hf_to_ide A) (hf_to_ide C)\n\ngoal (1 subgoal):\n 1. hfun_to_arr A C (hcomp G F) =\n    local.comp (hfun_to_arr B C G) (hfun_to_arr A B F)", "moreover"], ["proof (state)\nthis:\n  hfun_to_arr A C (hcomp G F) \\<in> hom (hf_to_ide A) (hf_to_ide C)\n\ngoal (1 subgoal):\n 1. hfun_to_arr A C (hcomp G F) =\n    local.comp (hfun_to_arr B C G) (hfun_to_arr A B F)", "have \"comp (hfun_to_arr B C G) (hfun_to_arr A B F)\n                          \\<in> hom (hf_to_ide A) (hf_to_ide C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.comp (hfun_to_arr B C G) (hfun_to_arr A B F)\n    \\<in> hom (hf_to_ide A) (hf_to_ide C)", "using assms hfun_to_arr_in_hom hf_to_ide_def"], ["proof (prove)\nusing this:\n  hfun A B F\n  hfun B C G\n  hfun ?B ?C ?F \\<Longrightarrow>\n  \\<guillemotleft>hfun_to_arr ?B ?C\n                   ?F : hf_to_ide\n                         ?B \\<rightarrow> hf_to_ide ?C\\<guillemotright>\n  hf_to_ide ?x = mkIde (UP ` hfset ?x)\n\ngoal (1 subgoal):\n 1. local.comp (hfun_to_arr B C G) (hfun_to_arr A B F)\n    \\<in> hom (hf_to_ide A) (hf_to_ide C)", "by (metis (no_types, lifting) comp_in_homI mem_Collect_eq)"], ["proof (state)\nthis:\n  local.comp (hfun_to_arr B C G) (hfun_to_arr A B F)\n  \\<in> hom (hf_to_ide A) (hf_to_ide C)\n\ngoal (1 subgoal):\n 1. hfun_to_arr A C (hcomp G F) =\n    local.comp (hfun_to_arr B C G) (hfun_to_arr A B F)", "moreover"], ["proof (state)\nthis:\n  local.comp (hfun_to_arr B C G) (hfun_to_arr A B F)\n  \\<in> hom (hf_to_ide A) (hf_to_ide C)\n\ngoal (1 subgoal):\n 1. hfun_to_arr A C (hcomp G F) =\n    local.comp (hfun_to_arr B C G) (hfun_to_arr A B F)", "have \"inj_on arr_to_hfun (hom (hf_to_ide A) (hf_to_ide C))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on arr_to_hfun (hom (hf_to_ide A) (hf_to_ide C))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on arr_to_hfun (hom (hf_to_ide A) (hf_to_ide C))", "have \"ide (hf_to_ide A) \\<and> ide (hf_to_ide C)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide (hf_to_ide A) \\<and> ide (hf_to_ide C)", "using assms hf_to_ide_mapsto"], ["proof (prove)\nusing this:\n  hfun A B F\n  hfun B C G\n  hf_to_ide \\<in> UNIV \\<rightarrow> Collect ide\n\ngoal (1 subgoal):\n 1. ide (hf_to_ide A) \\<and> ide (hf_to_ide C)", "by auto"], ["proof (state)\nthis:\n  ide (hf_to_ide A) \\<and> ide (hf_to_ide C)\n\ngoal (1 subgoal):\n 1. inj_on arr_to_hfun (hom (hf_to_ide A) (hf_to_ide C))", "thus ?thesis"], ["proof (prove)\nusing this:\n  ide (hf_to_ide A) \\<and> ide (hf_to_ide C)\n\ngoal (1 subgoal):\n 1. inj_on arr_to_hfun (hom (hf_to_ide A) (hf_to_ide C))", "using bij_betw_hom_hfun [of \"hf_to_ide A\" \"hf_to_ide C\"] bij_betw_imp_inj_on"], ["proof (prove)\nusing this:\n  ide (hf_to_ide A) \\<and> ide (hf_to_ide C)\n  \\<lbrakk>ide (hf_to_ide A); ide (hf_to_ide C)\\<rbrakk>\n  \\<Longrightarrow> bij_betw arr_to_hfun (hom (hf_to_ide A) (hf_to_ide C))\n                     {F. hfun (ide_to_hf (hf_to_ide A))\n                          (ide_to_hf (hf_to_ide C)) F}\n  bij_betw ?f ?A ?B \\<Longrightarrow> inj_on ?f ?A\n\ngoal (1 subgoal):\n 1. inj_on arr_to_hfun (hom (hf_to_ide A) (hf_to_ide C))", "by auto"], ["proof (state)\nthis:\n  inj_on arr_to_hfun (hom (hf_to_ide A) (hf_to_ide C))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on arr_to_hfun (hom (hf_to_ide A) (hf_to_ide C))\n\ngoal (1 subgoal):\n 1. hfun_to_arr A C (hcomp G F) =\n    local.comp (hfun_to_arr B C G) (hfun_to_arr A B F)", "ultimately"], ["proof (chain)\npicking this:\n  hfun_to_arr A C (hcomp G F) \\<in> hom (hf_to_ide A) (hf_to_ide C)\n  local.comp (hfun_to_arr B C G) (hfun_to_arr A B F)\n  \\<in> hom (hf_to_ide A) (hf_to_ide C)\n  inj_on arr_to_hfun (hom (hf_to_ide A) (hf_to_ide C))", "show ?thesis"], ["proof (prove)\nusing this:\n  hfun_to_arr A C (hcomp G F) \\<in> hom (hf_to_ide A) (hf_to_ide C)\n  local.comp (hfun_to_arr B C G) (hfun_to_arr A B F)\n  \\<in> hom (hf_to_ide A) (hf_to_ide C)\n  inj_on arr_to_hfun (hom (hf_to_ide A) (hf_to_ide C))\n\ngoal (1 subgoal):\n 1. hfun_to_arr A C (hcomp G F) =\n    local.comp (hfun_to_arr B C G) (hfun_to_arr A B F)", "using 1 inj_on_def [of arr_to_hfun \"hom (hf_to_ide A) (hf_to_ide C)\"]"], ["proof (prove)\nusing this:\n  hfun_to_arr A C (hcomp G F) \\<in> hom (hf_to_ide A) (hf_to_ide C)\n  local.comp (hfun_to_arr B C G) (hfun_to_arr A B F)\n  \\<in> hom (hf_to_ide A) (hf_to_ide C)\n  inj_on arr_to_hfun (hom (hf_to_ide A) (hf_to_ide C))\n  arr_to_hfun (hfun_to_arr A C (hcomp G F)) =\n  arr_to_hfun (local.comp (hfun_to_arr B C G) (hfun_to_arr A B F))\n  inj_on arr_to_hfun (hom (hf_to_ide A) (hf_to_ide C)) =\n  (\\<forall>x\\<in>hom (hf_to_ide A) (hf_to_ide C).\n      \\<forall>y\\<in>hom (hf_to_ide A) (hf_to_ide C).\n         arr_to_hfun x = arr_to_hfun y \\<longrightarrow> x = y)\n\ngoal (1 subgoal):\n 1. hfun_to_arr A C (hcomp G F) =\n    local.comp (hfun_to_arr B C G) (hfun_to_arr A B F)", "by simp"], ["proof (state)\nthis:\n  hfun_to_arr A C (hcomp G F) =\n  local.comp (hfun_to_arr B C G) (hfun_to_arr A B F)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  hfun_to_arr A C (hcomp G F) =\n  local.comp (hfun_to_arr B C G) (hfun_to_arr A B F)\n\ngoal:\nNo subgoals!", "qed"], ["", "section \"Binary Products\""], ["", "text\\<open>\n      The category of hereditarily finite sets has binary products,\n      given by cartesian product of sets in the usual way.\n    \\<close>"], ["", "definition prod\n    where \"prod a b = hf_to_ide (ide_to_hf a * ide_to_hf b)\""], ["", "definition pr0\n    where \"pr0 a b = (if ide a \\<and> ide b then\n                         mkArr (set (prod a b)) (set b) (\\<lambda>x. UP (hsnd (DOWN x)))\n                      else null)\""], ["", "definition pr1\n    where \"pr1 a b = (if ide a \\<and> ide b then\n                         mkArr (set (prod a b)) (set a) (\\<lambda>x. UP (hfst (DOWN x)))\n                      else null)\""], ["", "definition tuple\n    where \"tuple f g = mkArr (set (dom f)) (set (prod (cod f) (cod g)))\n                             (\\<lambda>x. UP (hpair (DOWN (Fun f x)) (DOWN (Fun g x))))\""], ["", "lemma ide_prod:\n    assumes \"ide a\" and \"ide b\"\n    shows \"ide (prod a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide (local.prod a b)", "using assms prod_def hf_to_ide_mapsto ide_to_hf_mapsto"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  local.prod ?a ?b = hf_to_ide (ide_to_hf ?a * ide_to_hf ?b)\n  hf_to_ide \\<in> UNIV \\<rightarrow> Collect ide\n  ide_to_hf \\<in> Collect ide \\<rightarrow> UNIV\n\ngoal (1 subgoal):\n 1. ide (local.prod a b)", "by auto"], ["", "lemma pr1_in_hom [intro]:\n    assumes \"ide a\" and \"ide b\"\n    shows \"\\<guillemotleft>pr1 a b : prod a b \\<rightarrow> a\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>pr1 a\n                     b : local.prod a b \\<rightarrow> a\\<guillemotright>", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. arr (pr1 a b)\n 2. local.dom (pr1 a b) = local.prod a b\n 3. cod (pr1 a b) = a", "show 0: \"arr (pr1 a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (pr1 a b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. arr (pr1 a b)", "have \"set (prod a b) \\<subseteq> Univ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.set (local.prod a b) \\<subseteq> Univ", "using assms ide_prod ide_char set_subset_Univ"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk> \\<Longrightarrow> ide (local.prod ?a ?b)\n  arr ?f \\<Longrightarrow>\n  ide ?f =\n  (Dom ?f = Cod ?f \\<and> Fun ?f = (\\<lambda>x\\<^bold>\\<in>Dom ?f. x))\n  ide ?a \\<Longrightarrow> local.set ?a \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. local.set (local.prod a b) \\<subseteq> Univ", "by blast"], ["proof (state)\nthis:\n  local.set (local.prod a b) \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. arr (pr1 a b)", "moreover"], ["proof (state)\nthis:\n  local.set (local.prod a b) \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. arr (pr1 a b)", "have \"set a \\<subseteq> Univ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.set a \\<subseteq> Univ", "using assms ide_char set_subset_Univ"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  arr ?f \\<Longrightarrow>\n  ide ?f =\n  (Dom ?f = Cod ?f \\<and> Fun ?f = (\\<lambda>x\\<^bold>\\<in>Dom ?f. x))\n  ide ?a \\<Longrightarrow> local.set ?a \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. local.set a \\<subseteq> Univ", "by blast"], ["proof (state)\nthis:\n  local.set a \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. arr (pr1 a b)", "moreover"], ["proof (state)\nthis:\n  local.set a \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. arr (pr1 a b)", "have \"(\\<lambda>x. UP (hfst (DOWN x))) \\<in> set (prod a b) \\<rightarrow> set a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. UP (hfst (DOWN x)))\n    \\<in> local.set (local.prod a b) \\<rightarrow> local.set a", "proof (unfold prod_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>x. UP (hfst (DOWN x)))\n    \\<in> local.set (hf_to_ide (ide_to_hf a * ide_to_hf b)) \\<rightarrow>\n          local.set a", "show \"(\\<lambda>x. UP (hfst (DOWN x))) \\<in> set (hf_to_ide (ide_to_hf a * ide_to_hf b)) \\<rightarrow> set a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. UP (hfst (DOWN x)))\n    \\<in> local.set (hf_to_ide (ide_to_hf a * ide_to_hf b)) \\<rightarrow>\n          local.set a", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> local.set\n                (hf_to_ide (ide_to_hf a * ide_to_hf b)) \\<Longrightarrow>\n       UP (hfst (DOWN x)) \\<in> local.set a", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> local.set\n                (hf_to_ide (ide_to_hf a * ide_to_hf b)) \\<Longrightarrow>\n       UP (hfst (DOWN x)) \\<in> local.set a", "assume x: \"x \\<in> set (hf_to_ide (ide_to_hf a * ide_to_hf b))\""], ["proof (state)\nthis:\n  x \\<in> local.set (hf_to_ide (ide_to_hf a * ide_to_hf b))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> local.set\n                (hf_to_ide (ide_to_hf a * ide_to_hf b)) \\<Longrightarrow>\n       UP (hfst (DOWN x)) \\<in> local.set a", "have \"DOWN x \\<in> hfset (ide_to_hf a * ide_to_hf b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DOWN x \\<in> hfset (ide_to_hf a * ide_to_hf b)", "using assms ide_char x"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  arr ?f \\<Longrightarrow>\n  ide ?f =\n  (Dom ?f = Cod ?f \\<and> Fun ?f = (\\<lambda>x\\<^bold>\\<in>Dom ?f. x))\n  x \\<in> local.set (hf_to_ide (ide_to_hf a * ide_to_hf b))\n\ngoal (1 subgoal):\n 1. DOWN x \\<in> hfset (ide_to_hf a * ide_to_hf b)", "by (metis (no_types, lifting) prod_def DOWN_membI HF_hfset UNIV_I hmem_HF_iff\n                    ide_prod ide_to_hf_hf_to_ide)"], ["proof (state)\nthis:\n  DOWN x \\<in> hfset (ide_to_hf a * ide_to_hf b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> local.set\n                (hf_to_ide (ide_to_hf a * ide_to_hf b)) \\<Longrightarrow>\n       UP (hfst (DOWN x)) \\<in> local.set a", "hence \"hfst (DOWN x) \\<^bold>\\<in> ide_to_hf a\""], ["proof (prove)\nusing this:\n  DOWN x \\<in> hfset (ide_to_hf a * ide_to_hf b)\n\ngoal (1 subgoal):\n 1. hfst (DOWN x) \\<^bold>\\<in> ide_to_hf a", "by (metis HF_hfset finite_hfset hfst_conv hmem_HF_iff timesE)"], ["proof (state)\nthis:\n  hfst (DOWN x) \\<^bold>\\<in> ide_to_hf a\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> local.set\n                (hf_to_ide (ide_to_hf a * ide_to_hf b)) \\<Longrightarrow>\n       UP (hfst (DOWN x)) \\<in> local.set a", "thus \"UP (hfst (DOWN x)) \\<in> set a\""], ["proof (prove)\nusing this:\n  hfst (DOWN x) \\<^bold>\\<in> ide_to_hf a\n\ngoal (1 subgoal):\n 1. UP (hfst (DOWN x)) \\<in> local.set a", "using UP_membI"], ["proof (prove)\nusing this:\n  hfst (DOWN x) \\<^bold>\\<in> ide_to_hf a\n  ?x \\<^bold>\\<in> ide_to_hf ?a \\<Longrightarrow> UP ?x \\<in> local.set ?a\n\ngoal (1 subgoal):\n 1. UP (hfst (DOWN x)) \\<in> local.set a", "by simp"], ["proof (state)\nthis:\n  UP (hfst (DOWN x)) \\<in> local.set a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>x. UP (hfst (DOWN x)))\n  \\<in> local.set (hf_to_ide (ide_to_hf a * ide_to_hf b)) \\<rightarrow>\n        local.set a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>x. UP (hfst (DOWN x)))\n  \\<in> local.set (local.prod a b) \\<rightarrow> local.set a\n\ngoal (1 subgoal):\n 1. arr (pr1 a b)", "ultimately"], ["proof (chain)\npicking this:\n  local.set (local.prod a b) \\<subseteq> Univ\n  local.set a \\<subseteq> Univ\n  (\\<lambda>x. UP (hfst (DOWN x)))\n  \\<in> local.set (local.prod a b) \\<rightarrow> local.set a", "show ?thesis"], ["proof (prove)\nusing this:\n  local.set (local.prod a b) \\<subseteq> Univ\n  local.set a \\<subseteq> Univ\n  (\\<lambda>x. UP (hfst (DOWN x)))\n  \\<in> local.set (local.prod a b) \\<rightarrow> local.set a\n\ngoal (1 subgoal):\n 1. arr (pr1 a b)", "unfolding pr1_def"], ["proof (prove)\nusing this:\n  local.set (local.prod a b) \\<subseteq> Univ\n  local.set a \\<subseteq> Univ\n  (\\<lambda>x. UP (hfst (DOWN x)))\n  \\<in> local.set (local.prod a b) \\<rightarrow> local.set a\n\ngoal (1 subgoal):\n 1. arr (if ide a \\<and> ide b\n         then mkArr (local.set (local.prod a b)) (local.set a)\n               (\\<lambda>x. UP (hfst (DOWN x)))\n         else null)", "using assms arr_mkArr ide_prod set_card"], ["proof (prove)\nusing this:\n  local.set (local.prod a b) \\<subseteq> Univ\n  local.set a \\<subseteq> Univ\n  (\\<lambda>x. UP (hfst (DOWN x)))\n  \\<in> local.set (local.prod a b) \\<rightarrow> local.set a\n  ide a\n  ide b\n  arr (mkArr ?A ?B ?F) =\n  (?A \\<subseteq> Univ \\<and>\n   |?A| <o natLeq \\<and>\n   ?B \\<subseteq> Univ \\<and>\n   |?B| <o natLeq \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk> \\<Longrightarrow> ide (local.prod ?a ?b)\n  ide ?a \\<Longrightarrow> |local.set ?a| <o natLeq\n\ngoal (1 subgoal):\n 1. arr (if ide a \\<and> ide b\n         then mkArr (local.set (local.prod a b)) (local.set a)\n               (\\<lambda>x. UP (hfst (DOWN x)))\n         else null)", "by presburger"], ["proof (state)\nthis:\n  arr (pr1 a b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  arr (pr1 a b)\n\ngoal (2 subgoals):\n 1. local.dom (pr1 a b) = local.prod a b\n 2. cod (pr1 a b) = a", "show \"dom (pr1 a b) = prod a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dom (pr1 a b) = local.prod a b", "using assms 0 ide_char ide_prod dom_mkArr"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  arr (pr1 a b)\n  arr ?f \\<Longrightarrow>\n  ide ?f =\n  (Dom ?f = Cod ?f \\<and> Fun ?f = (\\<lambda>x\\<^bold>\\<in>Dom ?f. x))\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk> \\<Longrightarrow> ide (local.prod ?a ?b)\n  arr (mkArr ?A ?B ?F) \\<Longrightarrow>\n  local.dom (mkArr ?A ?B ?F) = mkIde ?A\n\ngoal (1 subgoal):\n 1. local.dom (pr1 a b) = local.prod a b", "by (metis (no_types, lifting) mkIde_set pr1_def)"], ["proof (state)\nthis:\n  local.dom (pr1 a b) = local.prod a b\n\ngoal (1 subgoal):\n 1. cod (pr1 a b) = a", "show \"cod (pr1 a b) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cod (pr1 a b) = a", "using assms 0 ide_char ide_prod cod_mkArr"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  arr (pr1 a b)\n  arr ?f \\<Longrightarrow>\n  ide ?f =\n  (Dom ?f = Cod ?f \\<and> Fun ?f = (\\<lambda>x\\<^bold>\\<in>Dom ?f. x))\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk> \\<Longrightarrow> ide (local.prod ?a ?b)\n  arr (mkArr ?A ?B ?F) \\<Longrightarrow> cod (mkArr ?A ?B ?F) = mkIde ?B\n\ngoal (1 subgoal):\n 1. cod (pr1 a b) = a", "by (metis (no_types, lifting) mkIde_set pr1_def)"], ["proof (state)\nthis:\n  cod (pr1 a b) = a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pr1_simps [simp]:\n    assumes \"ide a\" and \"ide b\"\n    shows \"arr (pr1 a b)\" and \"dom (pr1 a b) = prod a b\" and \"cod (pr1 a b) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (pr1 a b) &&&\n    local.dom (pr1 a b) = local.prod a b &&& cod (pr1 a b) = a", "using assms pr1_in_hom"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>pr1 ?a\n                                     ?b : local.prod ?a\n     ?b \\<rightarrow> ?a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. arr (pr1 a b) &&&\n    local.dom (pr1 a b) = local.prod a b &&& cod (pr1 a b) = a", "by blast+"], ["", "lemma pr0_in_hom [intro]:\n    assumes \"ide a\" and \"ide b\"\n    shows \"\\<guillemotleft>pr0 a b : prod a b \\<rightarrow> b\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>pr0 a\n                     b : local.prod a b \\<rightarrow> b\\<guillemotright>", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. arr (pr0 a b)\n 2. local.dom (pr0 a b) = local.prod a b\n 3. cod (pr0 a b) = b", "show 0: \"arr (pr0 a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (pr0 a b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. arr (pr0 a b)", "have \"set (prod a b) \\<subseteq> Univ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.set (local.prod a b) \\<subseteq> Univ", "using assms ide_prod ide_char set_subset_Univ"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk> \\<Longrightarrow> ide (local.prod ?a ?b)\n  arr ?f \\<Longrightarrow>\n  ide ?f =\n  (Dom ?f = Cod ?f \\<and> Fun ?f = (\\<lambda>x\\<^bold>\\<in>Dom ?f. x))\n  ide ?a \\<Longrightarrow> local.set ?a \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. local.set (local.prod a b) \\<subseteq> Univ", "by blast"], ["proof (state)\nthis:\n  local.set (local.prod a b) \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. arr (pr0 a b)", "moreover"], ["proof (state)\nthis:\n  local.set (local.prod a b) \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. arr (pr0 a b)", "have \"set b \\<subseteq> Univ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.set b \\<subseteq> Univ", "using assms ide_char set_subset_Univ"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  arr ?f \\<Longrightarrow>\n  ide ?f =\n  (Dom ?f = Cod ?f \\<and> Fun ?f = (\\<lambda>x\\<^bold>\\<in>Dom ?f. x))\n  ide ?a \\<Longrightarrow> local.set ?a \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. local.set b \\<subseteq> Univ", "by blast"], ["proof (state)\nthis:\n  local.set b \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. arr (pr0 a b)", "moreover"], ["proof (state)\nthis:\n  local.set b \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. arr (pr0 a b)", "have \"(\\<lambda>x. UP (hsnd (DOWN x))) \\<in> set (prod a b) \\<rightarrow> set b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. UP (hsnd (DOWN x)))\n    \\<in> local.set (local.prod a b) \\<rightarrow> local.set b", "proof (unfold prod_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>x. UP (hsnd (DOWN x)))\n    \\<in> local.set (hf_to_ide (ide_to_hf a * ide_to_hf b)) \\<rightarrow>\n          local.set b", "show \"(\\<lambda>x. UP (hsnd (DOWN x))) \\<in> set (hf_to_ide (ide_to_hf a * ide_to_hf b)) \\<rightarrow> set b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. UP (hsnd (DOWN x)))\n    \\<in> local.set (hf_to_ide (ide_to_hf a * ide_to_hf b)) \\<rightarrow>\n          local.set b", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> local.set\n                (hf_to_ide (ide_to_hf a * ide_to_hf b)) \\<Longrightarrow>\n       UP (hsnd (DOWN x)) \\<in> local.set b", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> local.set\n                (hf_to_ide (ide_to_hf a * ide_to_hf b)) \\<Longrightarrow>\n       UP (hsnd (DOWN x)) \\<in> local.set b", "assume x: \"x \\<in> set (hf_to_ide (ide_to_hf a * ide_to_hf b))\""], ["proof (state)\nthis:\n  x \\<in> local.set (hf_to_ide (ide_to_hf a * ide_to_hf b))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> local.set\n                (hf_to_ide (ide_to_hf a * ide_to_hf b)) \\<Longrightarrow>\n       UP (hsnd (DOWN x)) \\<in> local.set b", "have \"DOWN x \\<in> hfset (ide_to_hf a * ide_to_hf b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DOWN x \\<in> hfset (ide_to_hf a * ide_to_hf b)", "using assms ide_char x"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  arr ?f \\<Longrightarrow>\n  ide ?f =\n  (Dom ?f = Cod ?f \\<and> Fun ?f = (\\<lambda>x\\<^bold>\\<in>Dom ?f. x))\n  x \\<in> local.set (hf_to_ide (ide_to_hf a * ide_to_hf b))\n\ngoal (1 subgoal):\n 1. DOWN x \\<in> hfset (ide_to_hf a * ide_to_hf b)", "by (metis (no_types, lifting) prod_def DOWN_membI HF_hfset UNIV_I hmem_HF_iff\n                    ide_prod ide_to_hf_hf_to_ide)"], ["proof (state)\nthis:\n  DOWN x \\<in> hfset (ide_to_hf a * ide_to_hf b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> local.set\n                (hf_to_ide (ide_to_hf a * ide_to_hf b)) \\<Longrightarrow>\n       UP (hsnd (DOWN x)) \\<in> local.set b", "hence \"hsnd (DOWN x) \\<^bold>\\<in> ide_to_hf b\""], ["proof (prove)\nusing this:\n  DOWN x \\<in> hfset (ide_to_hf a * ide_to_hf b)\n\ngoal (1 subgoal):\n 1. hsnd (DOWN x) \\<^bold>\\<in> ide_to_hf b", "by (metis HF_hfset finite_hfset hsnd_conv hmem_HF_iff timesE)"], ["proof (state)\nthis:\n  hsnd (DOWN x) \\<^bold>\\<in> ide_to_hf b\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> local.set\n                (hf_to_ide (ide_to_hf a * ide_to_hf b)) \\<Longrightarrow>\n       UP (hsnd (DOWN x)) \\<in> local.set b", "thus \"UP (hsnd (DOWN x)) \\<in> set b\""], ["proof (prove)\nusing this:\n  hsnd (DOWN x) \\<^bold>\\<in> ide_to_hf b\n\ngoal (1 subgoal):\n 1. UP (hsnd (DOWN x)) \\<in> local.set b", "using UP_membI"], ["proof (prove)\nusing this:\n  hsnd (DOWN x) \\<^bold>\\<in> ide_to_hf b\n  ?x \\<^bold>\\<in> ide_to_hf ?a \\<Longrightarrow> UP ?x \\<in> local.set ?a\n\ngoal (1 subgoal):\n 1. UP (hsnd (DOWN x)) \\<in> local.set b", "by simp"], ["proof (state)\nthis:\n  UP (hsnd (DOWN x)) \\<in> local.set b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>x. UP (hsnd (DOWN x)))\n  \\<in> local.set (hf_to_ide (ide_to_hf a * ide_to_hf b)) \\<rightarrow>\n        local.set b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>x. UP (hsnd (DOWN x)))\n  \\<in> local.set (local.prod a b) \\<rightarrow> local.set b\n\ngoal (1 subgoal):\n 1. arr (pr0 a b)", "ultimately"], ["proof (chain)\npicking this:\n  local.set (local.prod a b) \\<subseteq> Univ\n  local.set b \\<subseteq> Univ\n  (\\<lambda>x. UP (hsnd (DOWN x)))\n  \\<in> local.set (local.prod a b) \\<rightarrow> local.set b", "show ?thesis"], ["proof (prove)\nusing this:\n  local.set (local.prod a b) \\<subseteq> Univ\n  local.set b \\<subseteq> Univ\n  (\\<lambda>x. UP (hsnd (DOWN x)))\n  \\<in> local.set (local.prod a b) \\<rightarrow> local.set b\n\ngoal (1 subgoal):\n 1. arr (pr0 a b)", "unfolding pr0_def"], ["proof (prove)\nusing this:\n  local.set (local.prod a b) \\<subseteq> Univ\n  local.set b \\<subseteq> Univ\n  (\\<lambda>x. UP (hsnd (DOWN x)))\n  \\<in> local.set (local.prod a b) \\<rightarrow> local.set b\n\ngoal (1 subgoal):\n 1. arr (if ide a \\<and> ide b\n         then mkArr (local.set (local.prod a b)) (local.set b)\n               (\\<lambda>x. UP (hsnd (DOWN x)))\n         else null)", "using assms arr_mkArr ide_prod set_card"], ["proof (prove)\nusing this:\n  local.set (local.prod a b) \\<subseteq> Univ\n  local.set b \\<subseteq> Univ\n  (\\<lambda>x. UP (hsnd (DOWN x)))\n  \\<in> local.set (local.prod a b) \\<rightarrow> local.set b\n  ide a\n  ide b\n  arr (mkArr ?A ?B ?F) =\n  (?A \\<subseteq> Univ \\<and>\n   |?A| <o natLeq \\<and>\n   ?B \\<subseteq> Univ \\<and>\n   |?B| <o natLeq \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk> \\<Longrightarrow> ide (local.prod ?a ?b)\n  ide ?a \\<Longrightarrow> |local.set ?a| <o natLeq\n\ngoal (1 subgoal):\n 1. arr (if ide a \\<and> ide b\n         then mkArr (local.set (local.prod a b)) (local.set b)\n               (\\<lambda>x. UP (hsnd (DOWN x)))\n         else null)", "by presburger"], ["proof (state)\nthis:\n  arr (pr0 a b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  arr (pr0 a b)\n\ngoal (2 subgoals):\n 1. local.dom (pr0 a b) = local.prod a b\n 2. cod (pr0 a b) = b", "show \"dom (pr0 a b) = prod a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dom (pr0 a b) = local.prod a b", "using assms 0 ide_char ide_prod dom_mkArr"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  arr (pr0 a b)\n  arr ?f \\<Longrightarrow>\n  ide ?f =\n  (Dom ?f = Cod ?f \\<and> Fun ?f = (\\<lambda>x\\<^bold>\\<in>Dom ?f. x))\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk> \\<Longrightarrow> ide (local.prod ?a ?b)\n  arr (mkArr ?A ?B ?F) \\<Longrightarrow>\n  local.dom (mkArr ?A ?B ?F) = mkIde ?A\n\ngoal (1 subgoal):\n 1. local.dom (pr0 a b) = local.prod a b", "by (metis (no_types, lifting) mkIde_set pr0_def)"], ["proof (state)\nthis:\n  local.dom (pr0 a b) = local.prod a b\n\ngoal (1 subgoal):\n 1. cod (pr0 a b) = b", "show \"cod (pr0 a b) = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cod (pr0 a b) = b", "using assms 0 ide_char ide_prod cod_mkArr"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  arr (pr0 a b)\n  arr ?f \\<Longrightarrow>\n  ide ?f =\n  (Dom ?f = Cod ?f \\<and> Fun ?f = (\\<lambda>x\\<^bold>\\<in>Dom ?f. x))\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk> \\<Longrightarrow> ide (local.prod ?a ?b)\n  arr (mkArr ?A ?B ?F) \\<Longrightarrow> cod (mkArr ?A ?B ?F) = mkIde ?B\n\ngoal (1 subgoal):\n 1. cod (pr0 a b) = b", "by (metis (no_types, lifting) mkIde_set pr0_def)"], ["proof (state)\nthis:\n  cod (pr0 a b) = b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pr0_simps [simp]:\n    assumes \"ide a\" and \"ide b\"\n    shows \"arr (pr0 a b)\" and \"dom (pr0 a b) = prod a b\" and \"cod (pr0 a b) = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (pr0 a b) &&&\n    local.dom (pr0 a b) = local.prod a b &&& cod (pr0 a b) = b", "using assms pr0_in_hom"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>pr0 ?a\n                                     ?b : local.prod ?a\n     ?b \\<rightarrow> ?b\\<guillemotright>\n\ngoal (1 subgoal):\n 1. arr (pr0 a b) &&&\n    local.dom (pr0 a b) = local.prod a b &&& cod (pr0 a b) = b", "by blast+"], ["", "lemma UP_tuple_DOWN_membI:\n    assumes \"span f g\" and \"x \\<in> Dom f\"\n    shows \"UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle> \\<in> set (prod (cod f) (cod g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>\n    \\<in> local.set (local.prod (cod f) (cod g))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>\n    \\<in> local.set (local.prod (cod f) (cod g))", "have \"Fun f x \\<in> set (cod f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun f x \\<in> Cod f", "using assms Fun_mapsto"], ["proof (prove)\nusing this:\n  span f g\n  x \\<in> Dom f\n  arr ?f \\<Longrightarrow>\n  Fun ?f \\<in> extensional (Dom ?f) \\<inter> (Dom ?f \\<rightarrow> Cod ?f)\n\ngoal (1 subgoal):\n 1. Fun f x \\<in> Cod f", "by blast"], ["proof (state)\nthis:\n  Fun f x \\<in> Cod f\n\ngoal (1 subgoal):\n 1. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>\n    \\<in> local.set (local.prod (cod f) (cod g))", "moreover"], ["proof (state)\nthis:\n  Fun f x \\<in> Cod f\n\ngoal (1 subgoal):\n 1. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>\n    \\<in> local.set (local.prod (cod f) (cod g))", "have \"Fun g x \\<in> set (cod g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun g x \\<in> Cod g", "using assms Fun_mapsto"], ["proof (prove)\nusing this:\n  span f g\n  x \\<in> Dom f\n  arr ?f \\<Longrightarrow>\n  Fun ?f \\<in> extensional (Dom ?f) \\<inter> (Dom ?f \\<rightarrow> Cod ?f)\n\ngoal (1 subgoal):\n 1. Fun g x \\<in> Cod g", "by auto"], ["proof (state)\nthis:\n  Fun g x \\<in> Cod g\n\ngoal (1 subgoal):\n 1. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>\n    \\<in> local.set (local.prod (cod f) (cod g))", "ultimately"], ["proof (chain)\npicking this:\n  Fun f x \\<in> Cod f\n  Fun g x \\<in> Cod g", "have \"\\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>\n                          \\<^bold>\\<in> ide_to_hf (cod f) * ide_to_hf (cod g)\""], ["proof (prove)\nusing this:\n  Fun f x \\<in> Cod f\n  Fun g x \\<in> Cod g\n\ngoal (1 subgoal):\n 1. \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle> \\<^bold>\\<in>\n    ide_to_hf (cod f) * ide_to_hf (cod g)", "using assms ide_cod"], ["proof (prove)\nusing this:\n  Fun f x \\<in> Cod f\n  Fun g x \\<in> Cod g\n  span f g\n  x \\<in> Dom f\n  arr ?f \\<Longrightarrow> ide (cod ?f)\n\ngoal (1 subgoal):\n 1. \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle> \\<^bold>\\<in>\n    ide_to_hf (cod f) * ide_to_hf (cod g)", "by auto"], ["proof (state)\nthis:\n  \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle> \\<^bold>\\<in>\n  ide_to_hf (cod f) * ide_to_hf (cod g)\n\ngoal (1 subgoal):\n 1. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>\n    \\<in> local.set (local.prod (cod f) (cod g))", "moreover"], ["proof (state)\nthis:\n  \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle> \\<^bold>\\<in>\n  ide_to_hf (cod f) * ide_to_hf (cod g)\n\ngoal (1 subgoal):\n 1. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>\n    \\<in> local.set (local.prod (cod f) (cod g))", "have \"set (prod (cod f) (cod g)) \\<subseteq> Univ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.set (local.prod (cod f) (cod g)) \\<subseteq> Univ", "using assms ide_char ide_cod set_subset_Univ ide_prod"], ["proof (prove)\nusing this:\n  span f g\n  x \\<in> Dom f\n  arr ?f \\<Longrightarrow>\n  ide ?f =\n  (Dom ?f = Cod ?f \\<and> Fun ?f = (\\<lambda>x\\<^bold>\\<in>Dom ?f. x))\n  arr ?f \\<Longrightarrow> ide (cod ?f)\n  ide ?a \\<Longrightarrow> local.set ?a \\<subseteq> Univ\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk> \\<Longrightarrow> ide (local.prod ?a ?b)\n\ngoal (1 subgoal):\n 1. local.set (local.prod (cod f) (cod g)) \\<subseteq> Univ", "by presburger"], ["proof (state)\nthis:\n  local.set (local.prod (cod f) (cod g)) \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>\n    \\<in> local.set (local.prod (cod f) (cod g))", "ultimately"], ["proof (chain)\npicking this:\n  \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle> \\<^bold>\\<in>\n  ide_to_hf (cod f) * ide_to_hf (cod g)\n  local.set (local.prod (cod f) (cod g)) \\<subseteq> Univ", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle> \\<^bold>\\<in>\n  ide_to_hf (cod f) * ide_to_hf (cod g)\n  local.set (local.prod (cod f) (cod g)) \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>\n    \\<in> local.set (local.prod (cod f) (cod g))", "using prod_def UP_membI ide_to_hf_hf_to_ide"], ["proof (prove)\nusing this:\n  \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle> \\<^bold>\\<in>\n  ide_to_hf (cod f) * ide_to_hf (cod g)\n  local.set (local.prod (cod f) (cod g)) \\<subseteq> Univ\n  local.prod ?a ?b = hf_to_ide (ide_to_hf ?a * ide_to_hf ?b)\n  ?x \\<^bold>\\<in> ide_to_hf ?a \\<Longrightarrow> UP ?x \\<in> local.set ?a\n  ?x \\<in> UNIV \\<Longrightarrow> ide_to_hf (hf_to_ide ?x) = ?x\n\ngoal (1 subgoal):\n 1. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>\n    \\<in> local.set (local.prod (cod f) (cod g))", "by auto"], ["proof (state)\nthis:\n  UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>\n  \\<in> local.set (local.prod (cod f) (cod g))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tuple_in_hom [intro]:\n    assumes \"span f g\"\n    shows \"\\<guillemotleft>tuple f g : dom f \\<rightarrow> prod (cod f) (cod g)\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>tuple f\n                     g : local.dom\n                          f \\<rightarrow> local.prod (cod f)\n     (cod g)\\<guillemotright>", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. arr (tuple f g)\n 2. local.dom (tuple f g) = local.dom f\n 3. cod (tuple f g) = local.prod (cod f) (cod g)", "show 1: \"arr (tuple f g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (tuple f g)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. arr (tuple f g)", "have \"Dom f \\<subseteq> Univ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dom f \\<subseteq> Univ", "using assms set_subset_Univ ide_dom"], ["proof (prove)\nusing this:\n  span f g\n  ide ?a \\<Longrightarrow> local.set ?a \\<subseteq> Univ\n  arr ?f \\<Longrightarrow> ide (local.dom ?f)\n\ngoal (1 subgoal):\n 1. Dom f \\<subseteq> Univ", "by blast"], ["proof (state)\nthis:\n  Dom f \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. arr (tuple f g)", "moreover"], ["proof (state)\nthis:\n  Dom f \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. arr (tuple f g)", "have \"set (prod (cod f) (cod g)) \\<subseteq> Univ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.set (local.prod (cod f) (cod g)) \\<subseteq> Univ", "using assms ide_char ide_cod set_subset_Univ ide_prod"], ["proof (prove)\nusing this:\n  span f g\n  arr ?f \\<Longrightarrow>\n  ide ?f =\n  (Dom ?f = Cod ?f \\<and> Fun ?f = (\\<lambda>x\\<^bold>\\<in>Dom ?f. x))\n  arr ?f \\<Longrightarrow> ide (cod ?f)\n  ide ?a \\<Longrightarrow> local.set ?a \\<subseteq> Univ\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk> \\<Longrightarrow> ide (local.prod ?a ?b)\n\ngoal (1 subgoal):\n 1. local.set (local.prod (cod f) (cod g)) \\<subseteq> Univ", "by presburger"], ["proof (state)\nthis:\n  local.set (local.prod (cod f) (cod g)) \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. arr (tuple f g)", "moreover"], ["proof (state)\nthis:\n  local.set (local.prod (cod f) (cod g)) \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. arr (tuple f g)", "have \"(\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)\n                          \\<in> Dom f \\<rightarrow> set (prod (cod f) (cod g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)\n    \\<in> Dom f \\<rightarrow> local.set (local.prod (cod f) (cod g))", "using assms UP_tuple_DOWN_membI"], ["proof (prove)\nusing this:\n  span f g\n  \\<lbrakk>span ?f ?g; ?x \\<in> Dom ?f\\<rbrakk>\n  \\<Longrightarrow> UP \\<langle>DOWN (Fun ?f ?x), DOWN (Fun ?g ?x)\\<rangle>\n                    \\<in> local.set (local.prod (cod ?f) (cod ?g))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)\n    \\<in> Dom f \\<rightarrow> local.set (local.prod (cod f) (cod g))", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)\n  \\<in> Dom f \\<rightarrow> local.set (local.prod (cod f) (cod g))\n\ngoal (1 subgoal):\n 1. arr (tuple f g)", "ultimately"], ["proof (chain)\npicking this:\n  Dom f \\<subseteq> Univ\n  local.set (local.prod (cod f) (cod g)) \\<subseteq> Univ\n  (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)\n  \\<in> Dom f \\<rightarrow> local.set (local.prod (cod f) (cod g))", "show ?thesis"], ["proof (prove)\nusing this:\n  Dom f \\<subseteq> Univ\n  local.set (local.prod (cod f) (cod g)) \\<subseteq> Univ\n  (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)\n  \\<in> Dom f \\<rightarrow> local.set (local.prod (cod f) (cod g))\n\ngoal (1 subgoal):\n 1. arr (tuple f g)", "using assms ide_prod tuple_def arr_mkArr set_card ide_dom ide_cod"], ["proof (prove)\nusing this:\n  Dom f \\<subseteq> Univ\n  local.set (local.prod (cod f) (cod g)) \\<subseteq> Univ\n  (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)\n  \\<in> Dom f \\<rightarrow> local.set (local.prod (cod f) (cod g))\n  span f g\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk> \\<Longrightarrow> ide (local.prod ?a ?b)\n  tuple ?f ?g =\n  mkArr (Dom ?f) (local.set (local.prod (cod ?f) (cod ?g)))\n   (\\<lambda>x. UP \\<langle>DOWN (Fun ?f x), DOWN (Fun ?g x)\\<rangle>)\n  arr (mkArr ?A ?B ?F) =\n  (?A \\<subseteq> Univ \\<and>\n   |?A| <o natLeq \\<and>\n   ?B \\<subseteq> Univ \\<and>\n   |?B| <o natLeq \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n  ide ?a \\<Longrightarrow> |local.set ?a| <o natLeq\n  arr ?f \\<Longrightarrow> ide (local.dom ?f)\n  arr ?f \\<Longrightarrow> ide (cod ?f)\n\ngoal (1 subgoal):\n 1. arr (tuple f g)", "by simp"], ["proof (state)\nthis:\n  arr (tuple f g)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  arr (tuple f g)\n\ngoal (2 subgoals):\n 1. local.dom (tuple f g) = local.dom f\n 2. cod (tuple f g) = local.prod (cod f) (cod g)", "show \"dom (tuple f g) = dom f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dom (tuple f g) = local.dom f", "using assms 1 dom_mkArr ide_dom mkIde_set tuple_def"], ["proof (prove)\nusing this:\n  span f g\n  arr (tuple f g)\n  arr (mkArr ?A ?B ?F) \\<Longrightarrow>\n  local.dom (mkArr ?A ?B ?F) = mkIde ?A\n  arr ?f \\<Longrightarrow> ide (local.dom ?f)\n  ide ?a \\<Longrightarrow> mkIde (local.set ?a) = ?a\n  tuple ?f ?g =\n  mkArr (Dom ?f) (local.set (local.prod (cod ?f) (cod ?g)))\n   (\\<lambda>x. UP \\<langle>DOWN (Fun ?f x), DOWN (Fun ?g x)\\<rangle>)\n\ngoal (1 subgoal):\n 1. local.dom (tuple f g) = local.dom f", "by auto"], ["proof (state)\nthis:\n  local.dom (tuple f g) = local.dom f\n\ngoal (1 subgoal):\n 1. cod (tuple f g) = local.prod (cod f) (cod g)", "show \"cod (tuple f g) = prod (cod f) (cod g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cod (tuple f g) = local.prod (cod f) (cod g)", "using assms 1 cod_mkArr ide_cod mkIde_set tuple_def ide_prod"], ["proof (prove)\nusing this:\n  span f g\n  arr (tuple f g)\n  arr (mkArr ?A ?B ?F) \\<Longrightarrow> cod (mkArr ?A ?B ?F) = mkIde ?B\n  arr ?f \\<Longrightarrow> ide (cod ?f)\n  ide ?a \\<Longrightarrow> mkIde (local.set ?a) = ?a\n  tuple ?f ?g =\n  mkArr (Dom ?f) (local.set (local.prod (cod ?f) (cod ?g)))\n   (\\<lambda>x. UP \\<langle>DOWN (Fun ?f x), DOWN (Fun ?g x)\\<rangle>)\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk> \\<Longrightarrow> ide (local.prod ?a ?b)\n\ngoal (1 subgoal):\n 1. cod (tuple f g) = local.prod (cod f) (cod g)", "by auto"], ["proof (state)\nthis:\n  cod (tuple f g) = local.prod (cod f) (cod g)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tuple_simps [simp]:\n    assumes \"span f g\"\n    shows \"arr (tuple f g)\" and \"dom (tuple f g) = dom f\"\n    and \"cod (tuple f g) = prod (cod f) (cod g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (tuple f g) &&&\n    local.dom (tuple f g) = local.dom f &&&\n    cod (tuple f g) = local.prod (cod f) (cod g)", "using assms tuple_in_hom"], ["proof (prove)\nusing this:\n  span f g\n  span ?f ?g \\<Longrightarrow>\n  \\<guillemotleft>tuple ?f\n                   ?g : local.dom\n                         ?f \\<rightarrow> local.prod (cod ?f)\n     (cod ?g)\\<guillemotright>\n\ngoal (1 subgoal):\n 1. arr (tuple f g) &&&\n    local.dom (tuple f g) = local.dom f &&&\n    cod (tuple f g) = local.prod (cod f) (cod g)", "by blast+"], ["", "lemma Fun_pr1:\n    assumes \"ide a\" and \"ide b\"\n    shows \"Fun (pr1 a b) = restrict (\\<lambda>x. UP (hfst (DOWN x))) (set (prod a b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (pr1 a b) =\n    (\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b). UP (hfst (DOWN x)))", "using assms pr1_def Fun_mkArr arr_char pr1_simps(1)"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  pr1 ?a ?b =\n  (if ide ?a \\<and> ide ?b\n   then mkArr (local.set (local.prod ?a ?b)) (local.set ?a)\n         (\\<lambda>x. UP (hfst (DOWN x)))\n   else null)\n  arr (mkArr ?A ?B ?F) \\<Longrightarrow>\n  Fun (mkArr ?A ?B ?F) = restrict ?F ?A\n  arr ?f =\n  (?f \\<noteq> concrete_category.Null \\<and>\n   |concrete_category.Dom ?f| <o natLeq \\<and>\n   |concrete_category.Cod ?f| <o natLeq \\<and>\n   concrete_category.Map ?f\n   \\<in> extensional (concrete_category.Dom ?f) \\<inter>\n         (concrete_category.Dom ?f \\<rightarrow> concrete_category.Cod ?f))\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk> \\<Longrightarrow> arr (pr1 ?a ?b)\n\ngoal (1 subgoal):\n 1. Fun (pr1 a b) =\n    (\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b). UP (hfst (DOWN x)))", "by presburger"], ["", "lemma Fun_pr0:\n    assumes \"ide a\" and \"ide b\"\n    shows \"Fun (pr0 a b) = restrict (\\<lambda>x. UP (hsnd (DOWN x))) (set (prod a b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (pr0 a b) =\n    (\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b). UP (hsnd (DOWN x)))", "using assms pr0_def Fun_mkArr arr_char pr0_simps(1)"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  pr0 ?a ?b =\n  (if ide ?a \\<and> ide ?b\n   then mkArr (local.set (local.prod ?a ?b)) (local.set ?b)\n         (\\<lambda>x. UP (hsnd (DOWN x)))\n   else null)\n  arr (mkArr ?A ?B ?F) \\<Longrightarrow>\n  Fun (mkArr ?A ?B ?F) = restrict ?F ?A\n  arr ?f =\n  (?f \\<noteq> concrete_category.Null \\<and>\n   |concrete_category.Dom ?f| <o natLeq \\<and>\n   |concrete_category.Cod ?f| <o natLeq \\<and>\n   concrete_category.Map ?f\n   \\<in> extensional (concrete_category.Dom ?f) \\<inter>\n         (concrete_category.Dom ?f \\<rightarrow> concrete_category.Cod ?f))\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk> \\<Longrightarrow> arr (pr0 ?a ?b)\n\ngoal (1 subgoal):\n 1. Fun (pr0 a b) =\n    (\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b). UP (hsnd (DOWN x)))", "by presburger"], ["", "lemma Fun_tuple:\n    assumes \"span f g\"\n    shows \"Fun (tuple f g) = restrict (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>) (Dom f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (tuple f g) =\n    (\\<lambda>x\\<^bold>\\<in>Dom f.\n        UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Fun (tuple f g) =\n    (\\<lambda>x\\<^bold>\\<in>Dom f.\n        UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)", "have \"arr (tuple f g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (tuple f g)", "using assms tuple_in_hom"], ["proof (prove)\nusing this:\n  span f g\n  span ?f ?g \\<Longrightarrow>\n  \\<guillemotleft>tuple ?f\n                   ?g : local.dom\n                         ?f \\<rightarrow> local.prod (cod ?f)\n     (cod ?g)\\<guillemotright>\n\ngoal (1 subgoal):\n 1. arr (tuple f g)", "by blast"], ["proof (state)\nthis:\n  arr (tuple f g)\n\ngoal (1 subgoal):\n 1. Fun (tuple f g) =\n    (\\<lambda>x\\<^bold>\\<in>Dom f.\n        UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  arr (tuple f g)\n\ngoal (1 subgoal):\n 1. Fun (tuple f g) =\n    (\\<lambda>x\\<^bold>\\<in>Dom f.\n        UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)", "using assms tuple_def Fun_mkArr"], ["proof (prove)\nusing this:\n  arr (tuple f g)\n  span f g\n  tuple ?f ?g =\n  mkArr (Dom ?f) (local.set (local.prod (cod ?f) (cod ?g)))\n   (\\<lambda>x. UP \\<langle>DOWN (Fun ?f x), DOWN (Fun ?g x)\\<rangle>)\n  arr (mkArr ?A ?B ?F) \\<Longrightarrow>\n  Fun (mkArr ?A ?B ?F) = restrict ?F ?A\n\ngoal (1 subgoal):\n 1. Fun (tuple f g) =\n    (\\<lambda>x\\<^bold>\\<in>Dom f.\n        UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)", "by simp"], ["proof (state)\nthis:\n  Fun (tuple f g) =\n  (\\<lambda>x\\<^bold>\\<in>Dom f.\n      UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pr1_tuple:\n    assumes \"span f g\"\n    shows \"comp (pr1 (cod f) (cod g)) (tuple f g) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.comp (pr1 (cod f) (cod g)) (tuple f g) = f", "proof (intro arr_eqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. par (local.comp (pr1 (cod f) (cod g)) (tuple f g)) f\n 2. Fun (local.comp (pr1 (cod f) (cod g)) (tuple f g)) = Fun f", "have pr1: \"\\<guillemotleft>pr1 (cod f) (cod g) : prod (cod f) (cod g) \\<rightarrow> cod f\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>pr1 (cod f)\n                     (cod g) : local.prod (cod f)\n                                (cod g) \\<rightarrow> cod f\\<guillemotright>", "using assms ide_cod"], ["proof (prove)\nusing this:\n  span f g\n  arr ?f \\<Longrightarrow> ide (cod ?f)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>pr1 (cod f)\n                     (cod g) : local.prod (cod f)\n                                (cod g) \\<rightarrow> cod f\\<guillemotright>", "by blast"], ["proof (state)\nthis:\n  \\<guillemotleft>pr1 (cod f)\n                   (cod g) : local.prod (cod f)\n                              (cod g) \\<rightarrow> cod f\\<guillemotright>\n\ngoal (2 subgoals):\n 1. par (local.comp (pr1 (cod f) (cod g)) (tuple f g)) f\n 2. Fun (local.comp (pr1 (cod f) (cod g)) (tuple f g)) = Fun f", "have tuple: \"\\<guillemotleft>tuple f g : dom f \\<rightarrow> prod (cod f) (cod g)\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>tuple f\n                     g : local.dom\n                          f \\<rightarrow> local.prod (cod f)\n     (cod g)\\<guillemotright>", "using assms"], ["proof (prove)\nusing this:\n  span f g\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>tuple f\n                     g : local.dom\n                          f \\<rightarrow> local.prod (cod f)\n     (cod g)\\<guillemotright>", "by blast"], ["proof (state)\nthis:\n  \\<guillemotleft>tuple f\n                   g : local.dom\n                        f \\<rightarrow> local.prod (cod f)\n   (cod g)\\<guillemotright>\n\ngoal (2 subgoals):\n 1. par (local.comp (pr1 (cod f) (cod g)) (tuple f g)) f\n 2. Fun (local.comp (pr1 (cod f) (cod g)) (tuple f g)) = Fun f", "show par: \"par (comp (pr1 (cod f) (cod g)) (tuple f g)) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. par (local.comp (pr1 (cod f) (cod g)) (tuple f g)) f", "using assms pr1_in_hom tuple_in_hom"], ["proof (prove)\nusing this:\n  span f g\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>pr1 ?a\n                                     ?b : local.prod ?a\n     ?b \\<rightarrow> ?a\\<guillemotright>\n  span ?f ?g \\<Longrightarrow>\n  \\<guillemotleft>tuple ?f\n                   ?g : local.dom\n                         ?f \\<rightarrow> local.prod (cod ?f)\n     (cod ?g)\\<guillemotright>\n\ngoal (1 subgoal):\n 1. par (local.comp (pr1 (cod f) (cod g)) (tuple f g)) f", "by (metis (no_types, lifting) comp_in_homI' ide_cod in_homE)"], ["proof (state)\nthis:\n  par (local.comp (pr1 (cod f) (cod g)) (tuple f g)) f\n\ngoal (1 subgoal):\n 1. Fun (local.comp (pr1 (cod f) (cod g)) (tuple f g)) = Fun f", "show \"Fun (comp (pr1 (cod f) (cod g)) (tuple f g)) = Fun f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (local.comp (pr1 (cod f) (cod g)) (tuple f g)) = Fun f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Fun (local.comp (pr1 (cod f) (cod g)) (tuple f g)) = Fun f", "have seq: \"seq (pr1 (cod f) (cod g)) (tuple f g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq (pr1 (cod f) (cod g)) (tuple f g)", "using par"], ["proof (prove)\nusing this:\n  par (local.comp (pr1 (cod f) (cod g)) (tuple f g)) f\n\ngoal (1 subgoal):\n 1. seq (pr1 (cod f) (cod g)) (tuple f g)", "by blast"], ["proof (state)\nthis:\n  seq (pr1 (cod f) (cod g)) (tuple f g)\n\ngoal (1 subgoal):\n 1. Fun (local.comp (pr1 (cod f) (cod g)) (tuple f g)) = Fun f", "have \"Fun (comp (pr1 (cod f) (cod g)) (tuple f g)) =\n              restrict (Fun (pr1 (cod f) (cod g)) \\<circ> Fun (tuple f g)) (Dom (tuple f g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (local.comp (pr1 (cod f) (cod g)) (tuple f g)) =\n    restrict (Fun (pr1 (cod f) (cod g)) \\<circ> Fun (tuple f g))\n     (Dom (tuple f g))", "using pr1 tuple seq Fun_comp"], ["proof (prove)\nusing this:\n  \\<guillemotleft>pr1 (cod f)\n                   (cod g) : local.prod (cod f)\n                              (cod g) \\<rightarrow> cod f\\<guillemotright>\n  \\<guillemotleft>tuple f\n                   g : local.dom\n                        f \\<rightarrow> local.prod (cod f)\n   (cod g)\\<guillemotright>\n  seq (pr1 (cod f) (cod g)) (tuple f g)\n  seq ?g ?f \\<Longrightarrow>\n  Fun (local.comp ?g ?f) = restrict (Fun ?g \\<circ> Fun ?f) (Dom ?f)\n\ngoal (1 subgoal):\n 1. Fun (local.comp (pr1 (cod f) (cod g)) (tuple f g)) =\n    restrict (Fun (pr1 (cod f) (cod g)) \\<circ> Fun (tuple f g))\n     (Dom (tuple f g))", "by simp"], ["proof (state)\nthis:\n  Fun (local.comp (pr1 (cod f) (cod g)) (tuple f g)) =\n  restrict (Fun (pr1 (cod f) (cod g)) \\<circ> Fun (tuple f g))\n   (Dom (tuple f g))\n\ngoal (1 subgoal):\n 1. Fun (local.comp (pr1 (cod f) (cod g)) (tuple f g)) = Fun f", "also"], ["proof (state)\nthis:\n  Fun (local.comp (pr1 (cod f) (cod g)) (tuple f g)) =\n  restrict (Fun (pr1 (cod f) (cod g)) \\<circ> Fun (tuple f g))\n   (Dom (tuple f g))\n\ngoal (1 subgoal):\n 1. Fun (local.comp (pr1 (cod f) (cod g)) (tuple f g)) = Fun f", "have \"... = restrict\n                           (Fun (mkArr (set (prod (cod f) (cod g))) (Cod f)\n                                       (\\<lambda>x. UP (hfst (DOWN x)))) \\<circ>\n                            Fun (mkArr (Dom f) (set (prod (cod f) (cod g)))\n                                       (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)))\n                           (Dom (tuple f g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict (Fun (pr1 (cod f) (cod g)) \\<circ> Fun (tuple f g))\n     (Dom (tuple f g)) =\n    restrict\n     (Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod f)\n            (\\<lambda>x. UP (hfst (DOWN x)))) \\<circ>\n      Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n            (\\<lambda>x.\n                UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)))\n     (Dom (tuple f g))", "unfolding pr1_def tuple_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict\n     (Fun (if ide (cod f) \\<and> ide (cod g)\n           then mkArr (local.set (local.prod (cod f) (cod g))) (Cod f)\n                 (\\<lambda>x. UP (hfst (DOWN x)))\n           else null) \\<circ>\n      Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n            (\\<lambda>x.\n                UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)))\n     (Dom (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n            (\\<lambda>x.\n                UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))) =\n    restrict\n     (Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod f)\n            (\\<lambda>x. UP (hfst (DOWN x)))) \\<circ>\n      Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n            (\\<lambda>x.\n                UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)))\n     (Dom (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n            (\\<lambda>x.\n                UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)))", "using assms ide_cod"], ["proof (prove)\nusing this:\n  span f g\n  arr ?f \\<Longrightarrow> ide (cod ?f)\n\ngoal (1 subgoal):\n 1. restrict\n     (Fun (if ide (cod f) \\<and> ide (cod g)\n           then mkArr (local.set (local.prod (cod f) (cod g))) (Cod f)\n                 (\\<lambda>x. UP (hfst (DOWN x)))\n           else null) \\<circ>\n      Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n            (\\<lambda>x.\n                UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)))\n     (Dom (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n            (\\<lambda>x.\n                UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))) =\n    restrict\n     (Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod f)\n            (\\<lambda>x. UP (hfst (DOWN x)))) \\<circ>\n      Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n            (\\<lambda>x.\n                UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)))\n     (Dom (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n            (\\<lambda>x.\n                UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)))", "by presburger"], ["proof (state)\nthis:\n  restrict (Fun (pr1 (cod f) (cod g)) \\<circ> Fun (tuple f g))\n   (Dom (tuple f g)) =\n  restrict\n   (Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod f)\n          (\\<lambda>x. UP (hfst (DOWN x)))) \\<circ>\n    Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n          (\\<lambda>x.\n              UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)))\n   (Dom (tuple f g))\n\ngoal (1 subgoal):\n 1. Fun (local.comp (pr1 (cod f) (cod g)) (tuple f g)) = Fun f", "also"], ["proof (state)\nthis:\n  restrict (Fun (pr1 (cod f) (cod g)) \\<circ> Fun (tuple f g))\n   (Dom (tuple f g)) =\n  restrict\n   (Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod f)\n          (\\<lambda>x. UP (hfst (DOWN x)))) \\<circ>\n    Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n          (\\<lambda>x.\n              UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)))\n   (Dom (tuple f g))\n\ngoal (1 subgoal):\n 1. Fun (local.comp (pr1 (cod f) (cod g)) (tuple f g)) = Fun f", "have\n          \"... = restrict\n                   (restrict (\\<lambda>x. UP (hfst (DOWN x))) (set (prod (cod f) (cod g))) o\n                      restrict (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>) (Dom f))\n                   (Dom f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict\n     (Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod f)\n            (\\<lambda>x. UP (hfst (DOWN x)))) \\<circ>\n      Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n            (\\<lambda>x.\n                UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)))\n     (Dom (tuple f g)) =\n    restrict\n     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod (cod f) (cod g)).\n          UP (hfst (DOWN x))) \\<circ>\n      (\\<lambda>x\\<^bold>\\<in>Dom f.\n          UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n     (Dom f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. restrict\n     (Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod f)\n            (\\<lambda>x. UP (hfst (DOWN x)))) \\<circ>\n      Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n            (\\<lambda>x.\n                UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)))\n     (Dom (tuple f g)) =\n    restrict\n     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod (cod f) (cod g)).\n          UP (hfst (DOWN x))) \\<circ>\n      (\\<lambda>x\\<^bold>\\<in>Dom f.\n          UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n     (Dom f)", "have \"Fun (mkArr (set (prod (cod f) (cod g))) (Cod f) (\\<lambda>x. UP (hfst (DOWN x)))) =\n                restrict (\\<lambda>x. UP (hfst (DOWN x))) (set (prod (cod f) (cod g)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod f)\n          (\\<lambda>x. UP (hfst (DOWN x)))) =\n    (\\<lambda>x\\<^bold>\\<in>local.set (local.prod (cod f) (cod g)).\n        UP (hfst (DOWN x)))", "using assms Fun_mkArr ide_prod pr1"], ["proof (prove)\nusing this:\n  span f g\n  arr (mkArr ?A ?B ?F) \\<Longrightarrow>\n  Fun (mkArr ?A ?B ?F) = restrict ?F ?A\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk> \\<Longrightarrow> ide (local.prod ?a ?b)\n  \\<guillemotleft>pr1 (cod f)\n                   (cod g) : local.prod (cod f)\n                              (cod g) \\<rightarrow> cod f\\<guillemotright>\n\ngoal (1 subgoal):\n 1. Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod f)\n          (\\<lambda>x. UP (hfst (DOWN x)))) =\n    (\\<lambda>x\\<^bold>\\<in>local.set (local.prod (cod f) (cod g)).\n        UP (hfst (DOWN x)))", "by (metis (no_types, lifting) arrI ide_cod pr1_def)"], ["proof (state)\nthis:\n  Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod f)\n        (\\<lambda>x. UP (hfst (DOWN x)))) =\n  (\\<lambda>x\\<^bold>\\<in>local.set (local.prod (cod f) (cod g)).\n      UP (hfst (DOWN x)))\n\ngoal (1 subgoal):\n 1. restrict\n     (Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod f)\n            (\\<lambda>x. UP (hfst (DOWN x)))) \\<circ>\n      Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n            (\\<lambda>x.\n                UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)))\n     (Dom (tuple f g)) =\n    restrict\n     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod (cod f) (cod g)).\n          UP (hfst (DOWN x))) \\<circ>\n      (\\<lambda>x\\<^bold>\\<in>Dom f.\n          UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n     (Dom f)", "moreover"], ["proof (state)\nthis:\n  Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod f)\n        (\\<lambda>x. UP (hfst (DOWN x)))) =\n  (\\<lambda>x\\<^bold>\\<in>local.set (local.prod (cod f) (cod g)).\n      UP (hfst (DOWN x)))\n\ngoal (1 subgoal):\n 1. restrict\n     (Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod f)\n            (\\<lambda>x. UP (hfst (DOWN x)))) \\<circ>\n      Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n            (\\<lambda>x.\n                UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)))\n     (Dom (tuple f g)) =\n    restrict\n     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod (cod f) (cod g)).\n          UP (hfst (DOWN x))) \\<circ>\n      (\\<lambda>x\\<^bold>\\<in>Dom f.\n          UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n     (Dom f)", "have \"Fun (mkArr (Dom f) (set (prod (cod f) (cod g)))\n                                    (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)) =\n                         restrict (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>) (Dom f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n          (\\<lambda>x.\n              UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)) =\n    (\\<lambda>x\\<^bold>\\<in>Dom f.\n        UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)", "using assms Fun_mkArr ide_prod ide_cod tuple_def tuple arrI"], ["proof (prove)\nusing this:\n  span f g\n  arr (mkArr ?A ?B ?F) \\<Longrightarrow>\n  Fun (mkArr ?A ?B ?F) = restrict ?F ?A\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk> \\<Longrightarrow> ide (local.prod ?a ?b)\n  arr ?f \\<Longrightarrow> ide (cod ?f)\n  tuple ?f ?g =\n  mkArr (Dom ?f) (local.set (local.prod (cod ?f) (cod ?g)))\n   (\\<lambda>x. UP \\<langle>DOWN (Fun ?f x), DOWN (Fun ?g x)\\<rangle>)\n  \\<guillemotleft>tuple f\n                   g : local.dom\n                        f \\<rightarrow> local.prod (cod f)\n   (cod g)\\<guillemotright>\n  \\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright> \\<Longrightarrow>\n  arr ?f\n\ngoal (1 subgoal):\n 1. Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n          (\\<lambda>x.\n              UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)) =\n    (\\<lambda>x\\<^bold>\\<in>Dom f.\n        UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)", "by simp"], ["proof (state)\nthis:\n  Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n        (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)) =\n  (\\<lambda>x\\<^bold>\\<in>Dom f.\n      UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)\n\ngoal (1 subgoal):\n 1. restrict\n     (Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod f)\n            (\\<lambda>x. UP (hfst (DOWN x)))) \\<circ>\n      Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n            (\\<lambda>x.\n                UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)))\n     (Dom (tuple f g)) =\n    restrict\n     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod (cod f) (cod g)).\n          UP (hfst (DOWN x))) \\<circ>\n      (\\<lambda>x\\<^bold>\\<in>Dom f.\n          UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n     (Dom f)", "ultimately"], ["proof (chain)\npicking this:\n  Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod f)\n        (\\<lambda>x. UP (hfst (DOWN x)))) =\n  (\\<lambda>x\\<^bold>\\<in>local.set (local.prod (cod f) (cod g)).\n      UP (hfst (DOWN x)))\n  Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n        (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)) =\n  (\\<lambda>x\\<^bold>\\<in>Dom f.\n      UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)", "show ?thesis"], ["proof (prove)\nusing this:\n  Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod f)\n        (\\<lambda>x. UP (hfst (DOWN x)))) =\n  (\\<lambda>x\\<^bold>\\<in>local.set (local.prod (cod f) (cod g)).\n      UP (hfst (DOWN x)))\n  Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n        (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)) =\n  (\\<lambda>x\\<^bold>\\<in>Dom f.\n      UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)\n\ngoal (1 subgoal):\n 1. restrict\n     (Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod f)\n            (\\<lambda>x. UP (hfst (DOWN x)))) \\<circ>\n      Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n            (\\<lambda>x.\n                UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)))\n     (Dom (tuple f g)) =\n    restrict\n     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod (cod f) (cod g)).\n          UP (hfst (DOWN x))) \\<circ>\n      (\\<lambda>x\\<^bold>\\<in>Dom f.\n          UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n     (Dom f)", "using assms tuple_simps(2)"], ["proof (prove)\nusing this:\n  Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod f)\n        (\\<lambda>x. UP (hfst (DOWN x)))) =\n  (\\<lambda>x\\<^bold>\\<in>local.set (local.prod (cod f) (cod g)).\n      UP (hfst (DOWN x)))\n  Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n        (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)) =\n  (\\<lambda>x\\<^bold>\\<in>Dom f.\n      UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)\n  span f g\n  span ?f ?g \\<Longrightarrow> local.dom (tuple ?f ?g) = local.dom ?f\n\ngoal (1 subgoal):\n 1. restrict\n     (Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod f)\n            (\\<lambda>x. UP (hfst (DOWN x)))) \\<circ>\n      Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n            (\\<lambda>x.\n                UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)))\n     (Dom (tuple f g)) =\n    restrict\n     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod (cod f) (cod g)).\n          UP (hfst (DOWN x))) \\<circ>\n      (\\<lambda>x\\<^bold>\\<in>Dom f.\n          UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n     (Dom f)", "by simp"], ["proof (state)\nthis:\n  restrict\n   (Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod f)\n          (\\<lambda>x. UP (hfst (DOWN x)))) \\<circ>\n    Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n          (\\<lambda>x.\n              UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)))\n   (Dom (tuple f g)) =\n  restrict\n   ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod (cod f) (cod g)).\n        UP (hfst (DOWN x))) \\<circ>\n    (\\<lambda>x\\<^bold>\\<in>Dom f.\n        UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n   (Dom f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  restrict\n   (Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod f)\n          (\\<lambda>x. UP (hfst (DOWN x)))) \\<circ>\n    Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n          (\\<lambda>x.\n              UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)))\n   (Dom (tuple f g)) =\n  restrict\n   ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod (cod f) (cod g)).\n        UP (hfst (DOWN x))) \\<circ>\n    (\\<lambda>x\\<^bold>\\<in>Dom f.\n        UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n   (Dom f)\n\ngoal (1 subgoal):\n 1. Fun (local.comp (pr1 (cod f) (cod g)) (tuple f g)) = Fun f", "also"], ["proof (state)\nthis:\n  restrict\n   (Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod f)\n          (\\<lambda>x. UP (hfst (DOWN x)))) \\<circ>\n    Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n          (\\<lambda>x.\n              UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)))\n   (Dom (tuple f g)) =\n  restrict\n   ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod (cod f) (cod g)).\n        UP (hfst (DOWN x))) \\<circ>\n    (\\<lambda>x\\<^bold>\\<in>Dom f.\n        UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n   (Dom f)\n\ngoal (1 subgoal):\n 1. Fun (local.comp (pr1 (cod f) (cod g)) (tuple f g)) = Fun f", "have\n          \"... = restrict\n                   ((\\<lambda>x. UP (hfst (DOWN x))) o (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n                   (Dom f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict\n     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod (cod f) (cod g)).\n          UP (hfst (DOWN x))) \\<circ>\n      (\\<lambda>x\\<^bold>\\<in>Dom f.\n          UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n     (Dom f) =\n    restrict\n     ((\\<lambda>x. UP (hfst (DOWN x))) \\<circ>\n      (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n     (Dom f)", "using assms tuple tuple_def UP_tuple_DOWN_membI"], ["proof (prove)\nusing this:\n  span f g\n  \\<guillemotleft>tuple f\n                   g : local.dom\n                        f \\<rightarrow> local.prod (cod f)\n   (cod g)\\<guillemotright>\n  tuple ?f ?g =\n  mkArr (Dom ?f) (local.set (local.prod (cod ?f) (cod ?g)))\n   (\\<lambda>x. UP \\<langle>DOWN (Fun ?f x), DOWN (Fun ?g x)\\<rangle>)\n  \\<lbrakk>span ?f ?g; ?x \\<in> Dom ?f\\<rbrakk>\n  \\<Longrightarrow> UP \\<langle>DOWN (Fun ?f ?x), DOWN (Fun ?g ?x)\\<rangle>\n                    \\<in> local.set (local.prod (cod ?f) (cod ?g))\n\ngoal (1 subgoal):\n 1. restrict\n     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod (cod f) (cod g)).\n          UP (hfst (DOWN x))) \\<circ>\n      (\\<lambda>x\\<^bold>\\<in>Dom f.\n          UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n     (Dom f) =\n    restrict\n     ((\\<lambda>x. UP (hfst (DOWN x))) \\<circ>\n      (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n     (Dom f)", "by auto"], ["proof (state)\nthis:\n  restrict\n   ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod (cod f) (cod g)).\n        UP (hfst (DOWN x))) \\<circ>\n    (\\<lambda>x\\<^bold>\\<in>Dom f.\n        UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n   (Dom f) =\n  restrict\n   ((\\<lambda>x. UP (hfst (DOWN x))) \\<circ>\n    (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n   (Dom f)\n\ngoal (1 subgoal):\n 1. Fun (local.comp (pr1 (cod f) (cod g)) (tuple f g)) = Fun f", "also"], ["proof (state)\nthis:\n  restrict\n   ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod (cod f) (cod g)).\n        UP (hfst (DOWN x))) \\<circ>\n    (\\<lambda>x\\<^bold>\\<in>Dom f.\n        UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n   (Dom f) =\n  restrict\n   ((\\<lambda>x. UP (hfst (DOWN x))) \\<circ>\n    (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n   (Dom f)\n\ngoal (1 subgoal):\n 1. Fun (local.comp (pr1 (cod f) (cod g)) (tuple f g)) = Fun f", "have \"... = restrict (Fun f) (Dom f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict\n     ((\\<lambda>x. UP (hfst (DOWN x))) \\<circ>\n      (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n     (Dom f) =\n    restrict (Fun f) (Dom f)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       restrict\n        ((\\<lambda>x. UP (hfst (DOWN x))) \\<circ>\n         (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n        (Dom f) x =\n       restrict (Fun f) (Dom f) x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       restrict\n        ((\\<lambda>x. UP (hfst (DOWN x))) \\<circ>\n         (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n        (Dom f) x =\n       restrict (Fun f) (Dom f) x", "have \"restrict ((\\<lambda>x. UP (hfst (DOWN x))) o (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n                         (Dom f) x =\n                restrict (\\<lambda>x. UP (DOWN (Fun f x))) (Dom f) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict\n     ((\\<lambda>x. UP (hfst (DOWN x))) \\<circ>\n      (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n     (Dom f) x =\n    (\\<lambda>x\\<^bold>\\<in>Dom f. UP (DOWN (Fun f x))) x", "by simp"], ["proof (state)\nthis:\n  restrict\n   ((\\<lambda>x. UP (hfst (DOWN x))) \\<circ>\n    (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n   (Dom f) x =\n  (\\<lambda>x\\<^bold>\\<in>Dom f. UP (DOWN (Fun f x))) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       restrict\n        ((\\<lambda>x. UP (hfst (DOWN x))) \\<circ>\n         (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n        (Dom f) x =\n       restrict (Fun f) (Dom f) x", "also"], ["proof (state)\nthis:\n  restrict\n   ((\\<lambda>x. UP (hfst (DOWN x))) \\<circ>\n    (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n   (Dom f) x =\n  (\\<lambda>x\\<^bold>\\<in>Dom f. UP (DOWN (Fun f x))) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       restrict\n        ((\\<lambda>x. UP (hfst (DOWN x))) \\<circ>\n         (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n        (Dom f) x =\n       restrict (Fun f) (Dom f) x", "have \"... = restrict (Fun f) (Dom f) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<^bold>\\<in>Dom f. UP (DOWN (Fun f x))) x =\n    restrict (Fun f) (Dom f) x", "proof (cases \"x \\<in> Dom f\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> Dom f \\<Longrightarrow>\n    (\\<lambda>x\\<^bold>\\<in>Dom f. UP (DOWN (Fun f x))) x =\n    restrict (Fun f) (Dom f) x\n 2. x \\<notin> Dom f \\<Longrightarrow>\n    (\\<lambda>x\\<^bold>\\<in>Dom f. UP (DOWN (Fun f x))) x =\n    restrict (Fun f) (Dom f) x", "show \"x \\<notin> Dom f \\<Longrightarrow> ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> Dom f \\<Longrightarrow>\n    (\\<lambda>x\\<^bold>\\<in>Dom f. UP (DOWN (Fun f x))) x =\n    restrict (Fun f) (Dom f) x", "by simp"], ["proof (state)\nthis:\n  x \\<notin> Dom f \\<Longrightarrow>\n  (\\<lambda>x\\<^bold>\\<in>Dom f. UP (DOWN (Fun f x))) x =\n  restrict (Fun f) (Dom f) x\n\ngoal (1 subgoal):\n 1. x \\<in> Dom f \\<Longrightarrow>\n    (\\<lambda>x\\<^bold>\\<in>Dom f. UP (DOWN (Fun f x))) x =\n    restrict (Fun f) (Dom f) x", "assume x: \"x \\<in> Dom f\""], ["proof (state)\nthis:\n  x \\<in> Dom f\n\ngoal (1 subgoal):\n 1. x \\<in> Dom f \\<Longrightarrow>\n    (\\<lambda>x\\<^bold>\\<in>Dom f. UP (DOWN (Fun f x))) x =\n    restrict (Fun f) (Dom f) x", "have \"Fun f x \\<in> Cod f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun f x \\<in> Cod f", "using assms x Fun_mapsto arr_char"], ["proof (prove)\nusing this:\n  span f g\n  x \\<in> Dom f\n  arr ?f \\<Longrightarrow>\n  Fun ?f \\<in> extensional (Dom ?f) \\<inter> (Dom ?f \\<rightarrow> Cod ?f)\n  arr ?f =\n  (?f \\<noteq> concrete_category.Null \\<and>\n   |concrete_category.Dom ?f| <o natLeq \\<and>\n   |concrete_category.Cod ?f| <o natLeq \\<and>\n   concrete_category.Map ?f\n   \\<in> extensional (concrete_category.Dom ?f) \\<inter>\n         (concrete_category.Dom ?f \\<rightarrow> concrete_category.Cod ?f))\n\ngoal (1 subgoal):\n 1. Fun f x \\<in> Cod f", "by blast"], ["proof (state)\nthis:\n  Fun f x \\<in> Cod f\n\ngoal (1 subgoal):\n 1. x \\<in> Dom f \\<Longrightarrow>\n    (\\<lambda>x\\<^bold>\\<in>Dom f. UP (DOWN (Fun f x))) x =\n    restrict (Fun f) (Dom f) x", "moreover"], ["proof (state)\nthis:\n  Fun f x \\<in> Cod f\n\ngoal (1 subgoal):\n 1. x \\<in> Dom f \\<Longrightarrow>\n    (\\<lambda>x\\<^bold>\\<in>Dom f. UP (DOWN (Fun f x))) x =\n    restrict (Fun f) (Dom f) x", "have \"Cod f \\<subseteq> Univ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cod f \\<subseteq> Univ", "using assms pr1 ide_cod set_subset_Univ"], ["proof (prove)\nusing this:\n  span f g\n  \\<guillemotleft>pr1 (cod f)\n                   (cod g) : local.prod (cod f)\n                              (cod g) \\<rightarrow> cod f\\<guillemotright>\n  arr ?f \\<Longrightarrow> ide (cod ?f)\n  ide ?a \\<Longrightarrow> local.set ?a \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. Cod f \\<subseteq> Univ", "by simp"], ["proof (state)\nthis:\n  Cod f \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. x \\<in> Dom f \\<Longrightarrow>\n    (\\<lambda>x\\<^bold>\\<in>Dom f. UP (DOWN (Fun f x))) x =\n    restrict (Fun f) (Dom f) x", "ultimately"], ["proof (chain)\npicking this:\n  Fun f x \\<in> Cod f\n  Cod f \\<subseteq> Univ", "show ?thesis"], ["proof (prove)\nusing this:\n  Fun f x \\<in> Cod f\n  Cod f \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<^bold>\\<in>Dom f. UP (DOWN (Fun f x))) x =\n    restrict (Fun f) (Dom f) x", "using assms UP_DOWN Fun_mapsto"], ["proof (prove)\nusing this:\n  Fun f x \\<in> Cod f\n  Cod f \\<subseteq> Univ\n  span f g\n  ?t \\<in> Univ \\<Longrightarrow> UP (DOWN ?t) = ?t\n  arr ?f \\<Longrightarrow>\n  Fun ?f \\<in> extensional (Dom ?f) \\<inter> (Dom ?f \\<rightarrow> Cod ?f)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<^bold>\\<in>Dom f. UP (DOWN (Fun f x))) x =\n    restrict (Fun f) (Dom f) x", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x\\<^bold>\\<in>Dom f. UP (DOWN (Fun f x))) x =\n  restrict (Fun f) (Dom f) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>x\\<^bold>\\<in>Dom f. UP (DOWN (Fun f x))) x =\n  restrict (Fun f) (Dom f) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       restrict\n        ((\\<lambda>x. UP (hfst (DOWN x))) \\<circ>\n         (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n        (Dom f) x =\n       restrict (Fun f) (Dom f) x", "finally"], ["proof (chain)\npicking this:\n  restrict\n   ((\\<lambda>x. UP (hfst (DOWN x))) \\<circ>\n    (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n   (Dom f) x =\n  restrict (Fun f) (Dom f) x", "show \"restrict ((\\<lambda>x. UP (hfst (DOWN x))) \\<circ>\n                                    (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n                                 (Dom f) x =\n                        restrict (Fun f) (Dom f) x\""], ["proof (prove)\nusing this:\n  restrict\n   ((\\<lambda>x. UP (hfst (DOWN x))) \\<circ>\n    (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n   (Dom f) x =\n  restrict (Fun f) (Dom f) x\n\ngoal (1 subgoal):\n 1. restrict\n     ((\\<lambda>x. UP (hfst (DOWN x))) \\<circ>\n      (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n     (Dom f) x =\n    restrict (Fun f) (Dom f) x", "by blast"], ["proof (state)\nthis:\n  restrict\n   ((\\<lambda>x. UP (hfst (DOWN x))) \\<circ>\n    (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n   (Dom f) x =\n  restrict (Fun f) (Dom f) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  restrict\n   ((\\<lambda>x. UP (hfst (DOWN x))) \\<circ>\n    (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n   (Dom f) =\n  restrict (Fun f) (Dom f)\n\ngoal (1 subgoal):\n 1. Fun (local.comp (pr1 (cod f) (cod g)) (tuple f g)) = Fun f", "also"], ["proof (state)\nthis:\n  restrict\n   ((\\<lambda>x. UP (hfst (DOWN x))) \\<circ>\n    (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n   (Dom f) =\n  restrict (Fun f) (Dom f)\n\ngoal (1 subgoal):\n 1. Fun (local.comp (pr1 (cod f) (cod g)) (tuple f g)) = Fun f", "have \"... = Fun f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict (Fun f) (Dom f) = Fun f", "using assms par Fun_mapsto Fun_mkArr mkArr_Fun"], ["proof (prove)\nusing this:\n  span f g\n  par (local.comp (pr1 (cod f) (cod g)) (tuple f g)) f\n  arr ?f \\<Longrightarrow>\n  Fun ?f \\<in> extensional (Dom ?f) \\<inter> (Dom ?f \\<rightarrow> Cod ?f)\n  arr (mkArr ?A ?B ?F) \\<Longrightarrow>\n  Fun (mkArr ?A ?B ?F) = restrict ?F ?A\n  arr ?f \\<Longrightarrow> mkArr (Dom ?f) (Cod ?f) (Fun ?f) = ?f\n\ngoal (1 subgoal):\n 1. restrict (Fun f) (Dom f) = Fun f", "by (metis (no_types, lifting))"], ["proof (state)\nthis:\n  restrict (Fun f) (Dom f) = Fun f\n\ngoal (1 subgoal):\n 1. Fun (local.comp (pr1 (cod f) (cod g)) (tuple f g)) = Fun f", "finally"], ["proof (chain)\npicking this:\n  Fun (local.comp (pr1 (cod f) (cod g)) (tuple f g)) = Fun f", "show ?thesis"], ["proof (prove)\nusing this:\n  Fun (local.comp (pr1 (cod f) (cod g)) (tuple f g)) = Fun f\n\ngoal (1 subgoal):\n 1. Fun (local.comp (pr1 (cod f) (cod g)) (tuple f g)) = Fun f", "by blast"], ["proof (state)\nthis:\n  Fun (local.comp (pr1 (cod f) (cod g)) (tuple f g)) = Fun f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Fun (local.comp (pr1 (cod f) (cod g)) (tuple f g)) = Fun f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pr0_tuple:\n    assumes \"span f g\"\n    shows \"comp (pr0 (cod f) (cod g)) (tuple f g) = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.comp (pr0 (cod f) (cod g)) (tuple f g) = g", "proof (intro arr_eqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. par (local.comp (pr0 (cod f) (cod g)) (tuple f g)) g\n 2. Fun (local.comp (pr0 (cod f) (cod g)) (tuple f g)) = Fun g", "have pr0: \"\\<guillemotleft>pr0 (cod f) (cod g) : prod (cod f) (cod g) \\<rightarrow> cod g\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>pr0 (cod f)\n                     (cod g) : local.prod (cod f)\n                                (cod g) \\<rightarrow> cod g\\<guillemotright>", "using assms ide_cod"], ["proof (prove)\nusing this:\n  span f g\n  arr ?f \\<Longrightarrow> ide (cod ?f)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>pr0 (cod f)\n                     (cod g) : local.prod (cod f)\n                                (cod g) \\<rightarrow> cod g\\<guillemotright>", "by blast"], ["proof (state)\nthis:\n  \\<guillemotleft>pr0 (cod f)\n                   (cod g) : local.prod (cod f)\n                              (cod g) \\<rightarrow> cod g\\<guillemotright>\n\ngoal (2 subgoals):\n 1. par (local.comp (pr0 (cod f) (cod g)) (tuple f g)) g\n 2. Fun (local.comp (pr0 (cod f) (cod g)) (tuple f g)) = Fun g", "have tuple: \"\\<guillemotleft>tuple f g : dom f \\<rightarrow> prod (cod f) (cod g)\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>tuple f\n                     g : local.dom\n                          f \\<rightarrow> local.prod (cod f)\n     (cod g)\\<guillemotright>", "using assms"], ["proof (prove)\nusing this:\n  span f g\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>tuple f\n                     g : local.dom\n                          f \\<rightarrow> local.prod (cod f)\n     (cod g)\\<guillemotright>", "by blast"], ["proof (state)\nthis:\n  \\<guillemotleft>tuple f\n                   g : local.dom\n                        f \\<rightarrow> local.prod (cod f)\n   (cod g)\\<guillemotright>\n\ngoal (2 subgoals):\n 1. par (local.comp (pr0 (cod f) (cod g)) (tuple f g)) g\n 2. Fun (local.comp (pr0 (cod f) (cod g)) (tuple f g)) = Fun g", "show par: \"par (comp (pr0 (cod f) (cod g)) (tuple f g)) g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. par (local.comp (pr0 (cod f) (cod g)) (tuple f g)) g", "using assms pr0_in_hom tuple_in_hom"], ["proof (prove)\nusing this:\n  span f g\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>pr0 ?a\n                                     ?b : local.prod ?a\n     ?b \\<rightarrow> ?b\\<guillemotright>\n  span ?f ?g \\<Longrightarrow>\n  \\<guillemotleft>tuple ?f\n                   ?g : local.dom\n                         ?f \\<rightarrow> local.prod (cod ?f)\n     (cod ?g)\\<guillemotright>\n\ngoal (1 subgoal):\n 1. par (local.comp (pr0 (cod f) (cod g)) (tuple f g)) g", "by (metis (no_types, lifting) comp_in_homI' ide_cod in_homE)"], ["proof (state)\nthis:\n  par (local.comp (pr0 (cod f) (cod g)) (tuple f g)) g\n\ngoal (1 subgoal):\n 1. Fun (local.comp (pr0 (cod f) (cod g)) (tuple f g)) = Fun g", "show \"Fun (comp (pr0 (cod f) (cod g)) (tuple f g)) = Fun g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (local.comp (pr0 (cod f) (cod g)) (tuple f g)) = Fun g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Fun (local.comp (pr0 (cod f) (cod g)) (tuple f g)) = Fun g", "have seq: \"seq (pr0 (cod f) (cod g)) (tuple f g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq (pr0 (cod f) (cod g)) (tuple f g)", "using par"], ["proof (prove)\nusing this:\n  par (local.comp (pr0 (cod f) (cod g)) (tuple f g)) g\n\ngoal (1 subgoal):\n 1. seq (pr0 (cod f) (cod g)) (tuple f g)", "by blast"], ["proof (state)\nthis:\n  seq (pr0 (cod f) (cod g)) (tuple f g)\n\ngoal (1 subgoal):\n 1. Fun (local.comp (pr0 (cod f) (cod g)) (tuple f g)) = Fun g", "have \"Fun (comp (pr0 (cod f) (cod g)) (tuple f g)) =\n              restrict (Fun (pr0 (cod f) (cod g)) \\<circ> Fun (tuple f g)) (Dom (tuple f g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (local.comp (pr0 (cod f) (cod g)) (tuple f g)) =\n    restrict (Fun (pr0 (cod f) (cod g)) \\<circ> Fun (tuple f g))\n     (Dom (tuple f g))", "using pr0 tuple seq Fun_comp"], ["proof (prove)\nusing this:\n  \\<guillemotleft>pr0 (cod f)\n                   (cod g) : local.prod (cod f)\n                              (cod g) \\<rightarrow> cod g\\<guillemotright>\n  \\<guillemotleft>tuple f\n                   g : local.dom\n                        f \\<rightarrow> local.prod (cod f)\n   (cod g)\\<guillemotright>\n  seq (pr0 (cod f) (cod g)) (tuple f g)\n  seq ?g ?f \\<Longrightarrow>\n  Fun (local.comp ?g ?f) = restrict (Fun ?g \\<circ> Fun ?f) (Dom ?f)\n\ngoal (1 subgoal):\n 1. Fun (local.comp (pr0 (cod f) (cod g)) (tuple f g)) =\n    restrict (Fun (pr0 (cod f) (cod g)) \\<circ> Fun (tuple f g))\n     (Dom (tuple f g))", "by simp"], ["proof (state)\nthis:\n  Fun (local.comp (pr0 (cod f) (cod g)) (tuple f g)) =\n  restrict (Fun (pr0 (cod f) (cod g)) \\<circ> Fun (tuple f g))\n   (Dom (tuple f g))\n\ngoal (1 subgoal):\n 1. Fun (local.comp (pr0 (cod f) (cod g)) (tuple f g)) = Fun g", "also"], ["proof (state)\nthis:\n  Fun (local.comp (pr0 (cod f) (cod g)) (tuple f g)) =\n  restrict (Fun (pr0 (cod f) (cod g)) \\<circ> Fun (tuple f g))\n   (Dom (tuple f g))\n\ngoal (1 subgoal):\n 1. Fun (local.comp (pr0 (cod f) (cod g)) (tuple f g)) = Fun g", "have\n          \"... = restrict\n                   (Fun (mkArr (set (prod (cod f) (cod g))) (Cod g)\n                               (\\<lambda>x. UP (hsnd (DOWN x)))) \\<circ>\n                    Fun (mkArr (Dom f) (set (prod (cod f) (cod g)))\n                               (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)))\n                   (Dom (tuple f g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict (Fun (pr0 (cod f) (cod g)) \\<circ> Fun (tuple f g))\n     (Dom (tuple f g)) =\n    restrict\n     (Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod g)\n            (\\<lambda>x. UP (hsnd (DOWN x)))) \\<circ>\n      Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n            (\\<lambda>x.\n                UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)))\n     (Dom (tuple f g))", "unfolding pr0_def tuple_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict\n     (Fun (if ide (cod f) \\<and> ide (cod g)\n           then mkArr (local.set (local.prod (cod f) (cod g))) (Cod g)\n                 (\\<lambda>x. UP (hsnd (DOWN x)))\n           else null) \\<circ>\n      Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n            (\\<lambda>x.\n                UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)))\n     (Dom (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n            (\\<lambda>x.\n                UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))) =\n    restrict\n     (Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod g)\n            (\\<lambda>x. UP (hsnd (DOWN x)))) \\<circ>\n      Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n            (\\<lambda>x.\n                UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)))\n     (Dom (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n            (\\<lambda>x.\n                UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)))", "using assms ide_cod"], ["proof (prove)\nusing this:\n  span f g\n  arr ?f \\<Longrightarrow> ide (cod ?f)\n\ngoal (1 subgoal):\n 1. restrict\n     (Fun (if ide (cod f) \\<and> ide (cod g)\n           then mkArr (local.set (local.prod (cod f) (cod g))) (Cod g)\n                 (\\<lambda>x. UP (hsnd (DOWN x)))\n           else null) \\<circ>\n      Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n            (\\<lambda>x.\n                UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)))\n     (Dom (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n            (\\<lambda>x.\n                UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))) =\n    restrict\n     (Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod g)\n            (\\<lambda>x. UP (hsnd (DOWN x)))) \\<circ>\n      Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n            (\\<lambda>x.\n                UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)))\n     (Dom (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n            (\\<lambda>x.\n                UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)))", "by presburger"], ["proof (state)\nthis:\n  restrict (Fun (pr0 (cod f) (cod g)) \\<circ> Fun (tuple f g))\n   (Dom (tuple f g)) =\n  restrict\n   (Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod g)\n          (\\<lambda>x. UP (hsnd (DOWN x)))) \\<circ>\n    Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n          (\\<lambda>x.\n              UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)))\n   (Dom (tuple f g))\n\ngoal (1 subgoal):\n 1. Fun (local.comp (pr0 (cod f) (cod g)) (tuple f g)) = Fun g", "also"], ["proof (state)\nthis:\n  restrict (Fun (pr0 (cod f) (cod g)) \\<circ> Fun (tuple f g))\n   (Dom (tuple f g)) =\n  restrict\n   (Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod g)\n          (\\<lambda>x. UP (hsnd (DOWN x)))) \\<circ>\n    Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n          (\\<lambda>x.\n              UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)))\n   (Dom (tuple f g))\n\ngoal (1 subgoal):\n 1. Fun (local.comp (pr0 (cod f) (cod g)) (tuple f g)) = Fun g", "have \"... = restrict\n                           (restrict (\\<lambda>x. UP (hsnd (DOWN x))) (set (prod (cod f) (cod g))) o\n                            restrict (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>) (Dom g))\n                           (Dom g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict\n     (Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod g)\n            (\\<lambda>x. UP (hsnd (DOWN x)))) \\<circ>\n      Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n            (\\<lambda>x.\n                UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)))\n     (Dom (tuple f g)) =\n    restrict\n     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod (cod f) (cod g)).\n          UP (hsnd (DOWN x))) \\<circ>\n      (\\<lambda>x\\<^bold>\\<in>Dom g.\n          UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n     (Dom g)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. restrict\n     (Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod g)\n            (\\<lambda>x. UP (hsnd (DOWN x)))) \\<circ>\n      Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n            (\\<lambda>x.\n                UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)))\n     (Dom (tuple f g)) =\n    restrict\n     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod (cod f) (cod g)).\n          UP (hsnd (DOWN x))) \\<circ>\n      (\\<lambda>x\\<^bold>\\<in>Dom g.\n          UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n     (Dom g)", "have \"Fun (mkArr (set (prod (cod f) (cod g))) (Cod g) (\\<lambda>x. UP (hsnd (DOWN x)))) =\n                restrict (\\<lambda>x. UP (hsnd (DOWN x))) (set (prod (cod f) (cod g)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod g)\n          (\\<lambda>x. UP (hsnd (DOWN x)))) =\n    (\\<lambda>x\\<^bold>\\<in>local.set (local.prod (cod f) (cod g)).\n        UP (hsnd (DOWN x)))", "using assms Fun_mkArr ide_prod arrI"], ["proof (prove)\nusing this:\n  span f g\n  arr (mkArr ?A ?B ?F) \\<Longrightarrow>\n  Fun (mkArr ?A ?B ?F) = restrict ?F ?A\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk> \\<Longrightarrow> ide (local.prod ?a ?b)\n  \\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright> \\<Longrightarrow>\n  arr ?f\n\ngoal (1 subgoal):\n 1. Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod g)\n          (\\<lambda>x. UP (hsnd (DOWN x)))) =\n    (\\<lambda>x\\<^bold>\\<in>local.set (local.prod (cod f) (cod g)).\n        UP (hsnd (DOWN x)))", "by (metis (no_types, lifting) ide_cod pr0 pr0_def)"], ["proof (state)\nthis:\n  Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod g)\n        (\\<lambda>x. UP (hsnd (DOWN x)))) =\n  (\\<lambda>x\\<^bold>\\<in>local.set (local.prod (cod f) (cod g)).\n      UP (hsnd (DOWN x)))\n\ngoal (1 subgoal):\n 1. restrict\n     (Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod g)\n            (\\<lambda>x. UP (hsnd (DOWN x)))) \\<circ>\n      Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n            (\\<lambda>x.\n                UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)))\n     (Dom (tuple f g)) =\n    restrict\n     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod (cod f) (cod g)).\n          UP (hsnd (DOWN x))) \\<circ>\n      (\\<lambda>x\\<^bold>\\<in>Dom g.\n          UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n     (Dom g)", "moreover"], ["proof (state)\nthis:\n  Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod g)\n        (\\<lambda>x. UP (hsnd (DOWN x)))) =\n  (\\<lambda>x\\<^bold>\\<in>local.set (local.prod (cod f) (cod g)).\n      UP (hsnd (DOWN x)))\n\ngoal (1 subgoal):\n 1. restrict\n     (Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod g)\n            (\\<lambda>x. UP (hsnd (DOWN x)))) \\<circ>\n      Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n            (\\<lambda>x.\n                UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)))\n     (Dom (tuple f g)) =\n    restrict\n     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod (cod f) (cod g)).\n          UP (hsnd (DOWN x))) \\<circ>\n      (\\<lambda>x\\<^bold>\\<in>Dom g.\n          UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n     (Dom g)", "have \"Fun (mkArr (Dom f) (set (prod (cod f) (cod g)))\n                                    (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)) =\n                         restrict (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>) (Dom f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n          (\\<lambda>x.\n              UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)) =\n    (\\<lambda>x\\<^bold>\\<in>Dom f.\n        UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)", "using assms Fun_mkArr ide_prod ide_cod tuple_def tuple arrI"], ["proof (prove)\nusing this:\n  span f g\n  arr (mkArr ?A ?B ?F) \\<Longrightarrow>\n  Fun (mkArr ?A ?B ?F) = restrict ?F ?A\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk> \\<Longrightarrow> ide (local.prod ?a ?b)\n  arr ?f \\<Longrightarrow> ide (cod ?f)\n  tuple ?f ?g =\n  mkArr (Dom ?f) (local.set (local.prod (cod ?f) (cod ?g)))\n   (\\<lambda>x. UP \\<langle>DOWN (Fun ?f x), DOWN (Fun ?g x)\\<rangle>)\n  \\<guillemotleft>tuple f\n                   g : local.dom\n                        f \\<rightarrow> local.prod (cod f)\n   (cod g)\\<guillemotright>\n  \\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright> \\<Longrightarrow>\n  arr ?f\n\ngoal (1 subgoal):\n 1. Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n          (\\<lambda>x.\n              UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)) =\n    (\\<lambda>x\\<^bold>\\<in>Dom f.\n        UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)", "by simp"], ["proof (state)\nthis:\n  Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n        (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)) =\n  (\\<lambda>x\\<^bold>\\<in>Dom f.\n      UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)\n\ngoal (1 subgoal):\n 1. restrict\n     (Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod g)\n            (\\<lambda>x. UP (hsnd (DOWN x)))) \\<circ>\n      Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n            (\\<lambda>x.\n                UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)))\n     (Dom (tuple f g)) =\n    restrict\n     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod (cod f) (cod g)).\n          UP (hsnd (DOWN x))) \\<circ>\n      (\\<lambda>x\\<^bold>\\<in>Dom g.\n          UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n     (Dom g)", "ultimately"], ["proof (chain)\npicking this:\n  Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod g)\n        (\\<lambda>x. UP (hsnd (DOWN x)))) =\n  (\\<lambda>x\\<^bold>\\<in>local.set (local.prod (cod f) (cod g)).\n      UP (hsnd (DOWN x)))\n  Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n        (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)) =\n  (\\<lambda>x\\<^bold>\\<in>Dom f.\n      UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)", "show ?thesis"], ["proof (prove)\nusing this:\n  Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod g)\n        (\\<lambda>x. UP (hsnd (DOWN x)))) =\n  (\\<lambda>x\\<^bold>\\<in>local.set (local.prod (cod f) (cod g)).\n      UP (hsnd (DOWN x)))\n  Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n        (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)) =\n  (\\<lambda>x\\<^bold>\\<in>Dom f.\n      UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)\n\ngoal (1 subgoal):\n 1. restrict\n     (Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod g)\n            (\\<lambda>x. UP (hsnd (DOWN x)))) \\<circ>\n      Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n            (\\<lambda>x.\n                UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)))\n     (Dom (tuple f g)) =\n    restrict\n     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod (cod f) (cod g)).\n          UP (hsnd (DOWN x))) \\<circ>\n      (\\<lambda>x\\<^bold>\\<in>Dom g.\n          UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n     (Dom g)", "using assms tuple_simps(2)"], ["proof (prove)\nusing this:\n  Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod g)\n        (\\<lambda>x. UP (hsnd (DOWN x)))) =\n  (\\<lambda>x\\<^bold>\\<in>local.set (local.prod (cod f) (cod g)).\n      UP (hsnd (DOWN x)))\n  Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n        (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)) =\n  (\\<lambda>x\\<^bold>\\<in>Dom f.\n      UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)\n  span f g\n  span ?f ?g \\<Longrightarrow> local.dom (tuple ?f ?g) = local.dom ?f\n\ngoal (1 subgoal):\n 1. restrict\n     (Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod g)\n            (\\<lambda>x. UP (hsnd (DOWN x)))) \\<circ>\n      Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n            (\\<lambda>x.\n                UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)))\n     (Dom (tuple f g)) =\n    restrict\n     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod (cod f) (cod g)).\n          UP (hsnd (DOWN x))) \\<circ>\n      (\\<lambda>x\\<^bold>\\<in>Dom g.\n          UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n     (Dom g)", "by simp"], ["proof (state)\nthis:\n  restrict\n   (Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod g)\n          (\\<lambda>x. UP (hsnd (DOWN x)))) \\<circ>\n    Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n          (\\<lambda>x.\n              UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)))\n   (Dom (tuple f g)) =\n  restrict\n   ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod (cod f) (cod g)).\n        UP (hsnd (DOWN x))) \\<circ>\n    (\\<lambda>x\\<^bold>\\<in>Dom g.\n        UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n   (Dom g)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  restrict\n   (Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod g)\n          (\\<lambda>x. UP (hsnd (DOWN x)))) \\<circ>\n    Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n          (\\<lambda>x.\n              UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)))\n   (Dom (tuple f g)) =\n  restrict\n   ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod (cod f) (cod g)).\n        UP (hsnd (DOWN x))) \\<circ>\n    (\\<lambda>x\\<^bold>\\<in>Dom g.\n        UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n   (Dom g)\n\ngoal (1 subgoal):\n 1. Fun (local.comp (pr0 (cod f) (cod g)) (tuple f g)) = Fun g", "also"], ["proof (state)\nthis:\n  restrict\n   (Fun (mkArr (local.set (local.prod (cod f) (cod g))) (Cod g)\n          (\\<lambda>x. UP (hsnd (DOWN x)))) \\<circ>\n    Fun (mkArr (Dom f) (local.set (local.prod (cod f) (cod g)))\n          (\\<lambda>x.\n              UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>)))\n   (Dom (tuple f g)) =\n  restrict\n   ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod (cod f) (cod g)).\n        UP (hsnd (DOWN x))) \\<circ>\n    (\\<lambda>x\\<^bold>\\<in>Dom g.\n        UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n   (Dom g)\n\ngoal (1 subgoal):\n 1. Fun (local.comp (pr0 (cod f) (cod g)) (tuple f g)) = Fun g", "have \"... = restrict\n                           ((\\<lambda>x. UP (hsnd (DOWN x))) o (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n                           (Dom g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict\n     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod (cod f) (cod g)).\n          UP (hsnd (DOWN x))) \\<circ>\n      (\\<lambda>x\\<^bold>\\<in>Dom g.\n          UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n     (Dom g) =\n    restrict\n     ((\\<lambda>x. UP (hsnd (DOWN x))) \\<circ>\n      (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n     (Dom g)", "using assms tuple tuple_def UP_tuple_DOWN_membI"], ["proof (prove)\nusing this:\n  span f g\n  \\<guillemotleft>tuple f\n                   g : local.dom\n                        f \\<rightarrow> local.prod (cod f)\n   (cod g)\\<guillemotright>\n  tuple ?f ?g =\n  mkArr (Dom ?f) (local.set (local.prod (cod ?f) (cod ?g)))\n   (\\<lambda>x. UP \\<langle>DOWN (Fun ?f x), DOWN (Fun ?g x)\\<rangle>)\n  \\<lbrakk>span ?f ?g; ?x \\<in> Dom ?f\\<rbrakk>\n  \\<Longrightarrow> UP \\<langle>DOWN (Fun ?f ?x), DOWN (Fun ?g ?x)\\<rangle>\n                    \\<in> local.set (local.prod (cod ?f) (cod ?g))\n\ngoal (1 subgoal):\n 1. restrict\n     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod (cod f) (cod g)).\n          UP (hsnd (DOWN x))) \\<circ>\n      (\\<lambda>x\\<^bold>\\<in>Dom g.\n          UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n     (Dom g) =\n    restrict\n     ((\\<lambda>x. UP (hsnd (DOWN x))) \\<circ>\n      (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n     (Dom g)", "by auto"], ["proof (state)\nthis:\n  restrict\n   ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod (cod f) (cod g)).\n        UP (hsnd (DOWN x))) \\<circ>\n    (\\<lambda>x\\<^bold>\\<in>Dom g.\n        UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n   (Dom g) =\n  restrict\n   ((\\<lambda>x. UP (hsnd (DOWN x))) \\<circ>\n    (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n   (Dom g)\n\ngoal (1 subgoal):\n 1. Fun (local.comp (pr0 (cod f) (cod g)) (tuple f g)) = Fun g", "also"], ["proof (state)\nthis:\n  restrict\n   ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod (cod f) (cod g)).\n        UP (hsnd (DOWN x))) \\<circ>\n    (\\<lambda>x\\<^bold>\\<in>Dom g.\n        UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n   (Dom g) =\n  restrict\n   ((\\<lambda>x. UP (hsnd (DOWN x))) \\<circ>\n    (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n   (Dom g)\n\ngoal (1 subgoal):\n 1. Fun (local.comp (pr0 (cod f) (cod g)) (tuple f g)) = Fun g", "have \"... = restrict (Fun g) (Dom g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict\n     ((\\<lambda>x. UP (hsnd (DOWN x))) \\<circ>\n      (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n     (Dom g) =\n    restrict (Fun g) (Dom g)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       restrict\n        ((\\<lambda>x. UP (hsnd (DOWN x))) \\<circ>\n         (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n        (Dom g) x =\n       restrict (Fun g) (Dom g) x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       restrict\n        ((\\<lambda>x. UP (hsnd (DOWN x))) \\<circ>\n         (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n        (Dom g) x =\n       restrict (Fun g) (Dom g) x", "have \"restrict ((\\<lambda>x. UP (hsnd (DOWN x)))\n                            o (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n                         (Dom g) x =\n                restrict (\\<lambda>x. UP (DOWN (Fun g x))) (Dom g) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict\n     ((\\<lambda>x. UP (hsnd (DOWN x))) \\<circ>\n      (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n     (Dom g) x =\n    (\\<lambda>x\\<^bold>\\<in>Dom g. UP (DOWN (Fun g x))) x", "by simp"], ["proof (state)\nthis:\n  restrict\n   ((\\<lambda>x. UP (hsnd (DOWN x))) \\<circ>\n    (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n   (Dom g) x =\n  (\\<lambda>x\\<^bold>\\<in>Dom g. UP (DOWN (Fun g x))) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       restrict\n        ((\\<lambda>x. UP (hsnd (DOWN x))) \\<circ>\n         (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n        (Dom g) x =\n       restrict (Fun g) (Dom g) x", "also"], ["proof (state)\nthis:\n  restrict\n   ((\\<lambda>x. UP (hsnd (DOWN x))) \\<circ>\n    (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n   (Dom g) x =\n  (\\<lambda>x\\<^bold>\\<in>Dom g. UP (DOWN (Fun g x))) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       restrict\n        ((\\<lambda>x. UP (hsnd (DOWN x))) \\<circ>\n         (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n        (Dom g) x =\n       restrict (Fun g) (Dom g) x", "have \"... = restrict (Fun g) (Dom g) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<^bold>\\<in>Dom g. UP (DOWN (Fun g x))) x =\n    restrict (Fun g) (Dom g) x", "proof (cases \"x \\<in> Dom g\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x \\<in> Dom g \\<Longrightarrow>\n    (\\<lambda>x\\<^bold>\\<in>Dom g. UP (DOWN (Fun g x))) x =\n    restrict (Fun g) (Dom g) x\n 2. x \\<notin> Dom g \\<Longrightarrow>\n    (\\<lambda>x\\<^bold>\\<in>Dom g. UP (DOWN (Fun g x))) x =\n    restrict (Fun g) (Dom g) x", "show \"x \\<notin> Dom g \\<Longrightarrow> ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> Dom g \\<Longrightarrow>\n    (\\<lambda>x\\<^bold>\\<in>Dom g. UP (DOWN (Fun g x))) x =\n    restrict (Fun g) (Dom g) x", "by simp"], ["proof (state)\nthis:\n  x \\<notin> Dom g \\<Longrightarrow>\n  (\\<lambda>x\\<^bold>\\<in>Dom g. UP (DOWN (Fun g x))) x =\n  restrict (Fun g) (Dom g) x\n\ngoal (1 subgoal):\n 1. x \\<in> Dom g \\<Longrightarrow>\n    (\\<lambda>x\\<^bold>\\<in>Dom g. UP (DOWN (Fun g x))) x =\n    restrict (Fun g) (Dom g) x", "assume x: \"x \\<in> Dom g\""], ["proof (state)\nthis:\n  x \\<in> Dom g\n\ngoal (1 subgoal):\n 1. x \\<in> Dom g \\<Longrightarrow>\n    (\\<lambda>x\\<^bold>\\<in>Dom g. UP (DOWN (Fun g x))) x =\n    restrict (Fun g) (Dom g) x", "have \"Fun g x \\<in> Cod g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun g x \\<in> Cod g", "using assms x Fun_mapsto arr_char"], ["proof (prove)\nusing this:\n  span f g\n  x \\<in> Dom g\n  arr ?f \\<Longrightarrow>\n  Fun ?f \\<in> extensional (Dom ?f) \\<inter> (Dom ?f \\<rightarrow> Cod ?f)\n  arr ?f =\n  (?f \\<noteq> concrete_category.Null \\<and>\n   |concrete_category.Dom ?f| <o natLeq \\<and>\n   |concrete_category.Cod ?f| <o natLeq \\<and>\n   concrete_category.Map ?f\n   \\<in> extensional (concrete_category.Dom ?f) \\<inter>\n         (concrete_category.Dom ?f \\<rightarrow> concrete_category.Cod ?f))\n\ngoal (1 subgoal):\n 1. Fun g x \\<in> Cod g", "by blast"], ["proof (state)\nthis:\n  Fun g x \\<in> Cod g\n\ngoal (1 subgoal):\n 1. x \\<in> Dom g \\<Longrightarrow>\n    (\\<lambda>x\\<^bold>\\<in>Dom g. UP (DOWN (Fun g x))) x =\n    restrict (Fun g) (Dom g) x", "moreover"], ["proof (state)\nthis:\n  Fun g x \\<in> Cod g\n\ngoal (1 subgoal):\n 1. x \\<in> Dom g \\<Longrightarrow>\n    (\\<lambda>x\\<^bold>\\<in>Dom g. UP (DOWN (Fun g x))) x =\n    restrict (Fun g) (Dom g) x", "have \"Cod g \\<subseteq> Univ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cod g \\<subseteq> Univ", "using assms pr0 ide_cod set_subset_Univ"], ["proof (prove)\nusing this:\n  span f g\n  \\<guillemotleft>pr0 (cod f)\n                   (cod g) : local.prod (cod f)\n                              (cod g) \\<rightarrow> cod g\\<guillemotright>\n  arr ?f \\<Longrightarrow> ide (cod ?f)\n  ide ?a \\<Longrightarrow> local.set ?a \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. Cod g \\<subseteq> Univ", "by simp"], ["proof (state)\nthis:\n  Cod g \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. x \\<in> Dom g \\<Longrightarrow>\n    (\\<lambda>x\\<^bold>\\<in>Dom g. UP (DOWN (Fun g x))) x =\n    restrict (Fun g) (Dom g) x", "ultimately"], ["proof (chain)\npicking this:\n  Fun g x \\<in> Cod g\n  Cod g \\<subseteq> Univ", "show ?thesis"], ["proof (prove)\nusing this:\n  Fun g x \\<in> Cod g\n  Cod g \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<^bold>\\<in>Dom g. UP (DOWN (Fun g x))) x =\n    restrict (Fun g) (Dom g) x", "using assms UP_DOWN Fun_mapsto"], ["proof (prove)\nusing this:\n  Fun g x \\<in> Cod g\n  Cod g \\<subseteq> Univ\n  span f g\n  ?t \\<in> Univ \\<Longrightarrow> UP (DOWN ?t) = ?t\n  arr ?f \\<Longrightarrow>\n  Fun ?f \\<in> extensional (Dom ?f) \\<inter> (Dom ?f \\<rightarrow> Cod ?f)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<^bold>\\<in>Dom g. UP (DOWN (Fun g x))) x =\n    restrict (Fun g) (Dom g) x", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x\\<^bold>\\<in>Dom g. UP (DOWN (Fun g x))) x =\n  restrict (Fun g) (Dom g) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>x\\<^bold>\\<in>Dom g. UP (DOWN (Fun g x))) x =\n  restrict (Fun g) (Dom g) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       restrict\n        ((\\<lambda>x. UP (hsnd (DOWN x))) \\<circ>\n         (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n        (Dom g) x =\n       restrict (Fun g) (Dom g) x", "finally"], ["proof (chain)\npicking this:\n  restrict\n   ((\\<lambda>x. UP (hsnd (DOWN x))) \\<circ>\n    (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n   (Dom g) x =\n  restrict (Fun g) (Dom g) x", "show \"restrict ((\\<lambda>x. UP (hsnd (DOWN x))) \\<circ>\n                                    (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n                                 (Dom g) x =\n                        restrict (Fun g) (Dom g) x\""], ["proof (prove)\nusing this:\n  restrict\n   ((\\<lambda>x. UP (hsnd (DOWN x))) \\<circ>\n    (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n   (Dom g) x =\n  restrict (Fun g) (Dom g) x\n\ngoal (1 subgoal):\n 1. restrict\n     ((\\<lambda>x. UP (hsnd (DOWN x))) \\<circ>\n      (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n     (Dom g) x =\n    restrict (Fun g) (Dom g) x", "by blast"], ["proof (state)\nthis:\n  restrict\n   ((\\<lambda>x. UP (hsnd (DOWN x))) \\<circ>\n    (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n   (Dom g) x =\n  restrict (Fun g) (Dom g) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  restrict\n   ((\\<lambda>x. UP (hsnd (DOWN x))) \\<circ>\n    (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n   (Dom g) =\n  restrict (Fun g) (Dom g)\n\ngoal (1 subgoal):\n 1. Fun (local.comp (pr0 (cod f) (cod g)) (tuple f g)) = Fun g", "also"], ["proof (state)\nthis:\n  restrict\n   ((\\<lambda>x. UP (hsnd (DOWN x))) \\<circ>\n    (\\<lambda>x. UP \\<langle>DOWN (Fun f x), DOWN (Fun g x)\\<rangle>))\n   (Dom g) =\n  restrict (Fun g) (Dom g)\n\ngoal (1 subgoal):\n 1. Fun (local.comp (pr0 (cod f) (cod g)) (tuple f g)) = Fun g", "have \"... = Fun g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict (Fun g) (Dom g) = Fun g", "using assms par Fun_mapsto Fun_mkArr mkArr_Fun"], ["proof (prove)\nusing this:\n  span f g\n  par (local.comp (pr0 (cod f) (cod g)) (tuple f g)) g\n  arr ?f \\<Longrightarrow>\n  Fun ?f \\<in> extensional (Dom ?f) \\<inter> (Dom ?f \\<rightarrow> Cod ?f)\n  arr (mkArr ?A ?B ?F) \\<Longrightarrow>\n  Fun (mkArr ?A ?B ?F) = restrict ?F ?A\n  arr ?f \\<Longrightarrow> mkArr (Dom ?f) (Cod ?f) (Fun ?f) = ?f\n\ngoal (1 subgoal):\n 1. restrict (Fun g) (Dom g) = Fun g", "by (metis (no_types, lifting))"], ["proof (state)\nthis:\n  restrict (Fun g) (Dom g) = Fun g\n\ngoal (1 subgoal):\n 1. Fun (local.comp (pr0 (cod f) (cod g)) (tuple f g)) = Fun g", "finally"], ["proof (chain)\npicking this:\n  Fun (local.comp (pr0 (cod f) (cod g)) (tuple f g)) = Fun g", "show ?thesis"], ["proof (prove)\nusing this:\n  Fun (local.comp (pr0 (cod f) (cod g)) (tuple f g)) = Fun g\n\ngoal (1 subgoal):\n 1. Fun (local.comp (pr0 (cod f) (cod g)) (tuple f g)) = Fun g", "by blast"], ["proof (state)\nthis:\n  Fun (local.comp (pr0 (cod f) (cod g)) (tuple f g)) = Fun g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Fun (local.comp (pr0 (cod f) (cod g)) (tuple f g)) = Fun g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tuple_pr:\n    assumes \"ide a\" and \"ide b\" and \"\\<guillemotleft>h : dom h \\<rightarrow> prod a b\\<guillemotright>\"\n    shows \"tuple (comp (pr1 a b) h) (comp (pr0 a b) h) = h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tuple (local.comp (pr1 a b) h) (local.comp (pr0 a b) h) = h", "proof (intro arr_eqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. par (tuple (local.comp (pr1 a b) h) (local.comp (pr0 a b) h)) h\n 2. Fun (tuple (local.comp (pr1 a b) h) (local.comp (pr0 a b) h)) = Fun h", "have pr0: \"\\<guillemotleft>pr0 a b : prod a b \\<rightarrow> b\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>pr0 a\n                     b : local.prod a b \\<rightarrow> b\\<guillemotright>", "using assms pr0_in_hom ide_cod"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  \\<guillemotleft>h : local.dom\n                       h \\<rightarrow> local.prod a b\\<guillemotright>\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>pr0 ?a\n                                     ?b : local.prod ?a\n     ?b \\<rightarrow> ?b\\<guillemotright>\n  arr ?f \\<Longrightarrow> ide (cod ?f)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>pr0 a\n                     b : local.prod a b \\<rightarrow> b\\<guillemotright>", "by blast"], ["proof (state)\nthis:\n  \\<guillemotleft>pr0 a b : local.prod a b \\<rightarrow> b\\<guillemotright>\n\ngoal (2 subgoals):\n 1. par (tuple (local.comp (pr1 a b) h) (local.comp (pr0 a b) h)) h\n 2. Fun (tuple (local.comp (pr1 a b) h) (local.comp (pr0 a b) h)) = Fun h", "have pr1: \"\\<guillemotleft>pr1 a b : prod a b \\<rightarrow> a\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>pr1 a\n                     b : local.prod a b \\<rightarrow> a\\<guillemotright>", "using assms pr1_in_hom ide_cod"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  \\<guillemotleft>h : local.dom\n                       h \\<rightarrow> local.prod a b\\<guillemotright>\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>pr1 ?a\n                                     ?b : local.prod ?a\n     ?b \\<rightarrow> ?a\\<guillemotright>\n  arr ?f \\<Longrightarrow> ide (cod ?f)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>pr1 a\n                     b : local.prod a b \\<rightarrow> a\\<guillemotright>", "by blast"], ["proof (state)\nthis:\n  \\<guillemotleft>pr1 a b : local.prod a b \\<rightarrow> a\\<guillemotright>\n\ngoal (2 subgoals):\n 1. par (tuple (local.comp (pr1 a b) h) (local.comp (pr0 a b) h)) h\n 2. Fun (tuple (local.comp (pr1 a b) h) (local.comp (pr0 a b) h)) = Fun h", "have tuple: \"\\<guillemotleft>tuple (comp (pr1 a b) h) (comp (pr0 a b) h) : dom h \\<rightarrow> prod a b\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>tuple (local.comp (pr1 a b) h)\n                     (local.comp (pr0 a b)\n                       h) : local.dom\n                             h \\<rightarrow> local.prod a b\\<guillemotright>", "using assms pr0 pr1"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  \\<guillemotleft>h : local.dom\n                       h \\<rightarrow> local.prod a b\\<guillemotright>\n  \\<guillemotleft>pr0 a b : local.prod a b \\<rightarrow> b\\<guillemotright>\n  \\<guillemotleft>pr1 a b : local.prod a b \\<rightarrow> a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>tuple (local.comp (pr1 a b) h)\n                     (local.comp (pr0 a b)\n                       h) : local.dom\n                             h \\<rightarrow> local.prod a b\\<guillemotright>", "by (metis (no_types, lifting) cod_comp dom_comp pr0_simps(3) pr1_simps(3)\n            seqI' tuple_in_hom)"], ["proof (state)\nthis:\n  \\<guillemotleft>tuple (local.comp (pr1 a b) h)\n                   (local.comp (pr0 a b)\n                     h) : local.dom\n                           h \\<rightarrow> local.prod a b\\<guillemotright>\n\ngoal (2 subgoals):\n 1. par (tuple (local.comp (pr1 a b) h) (local.comp (pr0 a b) h)) h\n 2. Fun (tuple (local.comp (pr1 a b) h) (local.comp (pr0 a b) h)) = Fun h", "show par: \"par (tuple (comp (pr1 a b) h) (comp (pr0 a b) h)) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. par (tuple (local.comp (pr1 a b) h) (local.comp (pr0 a b) h)) h", "using assms tuple"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  \\<guillemotleft>h : local.dom\n                       h \\<rightarrow> local.prod a b\\<guillemotright>\n  \\<guillemotleft>tuple (local.comp (pr1 a b) h)\n                   (local.comp (pr0 a b)\n                     h) : local.dom\n                           h \\<rightarrow> local.prod a b\\<guillemotright>\n\ngoal (1 subgoal):\n 1. par (tuple (local.comp (pr1 a b) h) (local.comp (pr0 a b) h)) h", "by (metis (no_types, lifting) in_homE)"], ["proof (state)\nthis:\n  par (tuple (local.comp (pr1 a b) h) (local.comp (pr0 a b) h)) h\n\ngoal (1 subgoal):\n 1. Fun (tuple (local.comp (pr1 a b) h) (local.comp (pr0 a b) h)) = Fun h", "show \"Fun (tuple (comp (pr1 a b) h) (comp (pr0 a b) h)) = Fun h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (tuple (local.comp (pr1 a b) h) (local.comp (pr0 a b) h)) = Fun h", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Fun (tuple (local.comp (pr1 a b) h) (local.comp (pr0 a b) h)) = Fun h", "have 1: \"Fun (comp (pr1 a b) h) =\n                 restrict (restrict (\\<lambda>x. UP (hfst (DOWN x))) (set (prod a b)) \\<circ> Fun h) (Dom h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (local.comp (pr1 a b) h) =\n    restrict\n     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n          UP (hfst (DOWN x))) \\<circ>\n      Fun h)\n     (Dom h)", "using assms pr1 Fun_comp Fun_pr1 seqI'"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  \\<guillemotleft>h : local.dom\n                       h \\<rightarrow> local.prod a b\\<guillemotright>\n  \\<guillemotleft>pr1 a b : local.prod a b \\<rightarrow> a\\<guillemotright>\n  seq ?g ?f \\<Longrightarrow>\n  Fun (local.comp ?g ?f) = restrict (Fun ?g \\<circ> Fun ?f) (Dom ?f)\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> Fun (pr1 ?a ?b) =\n                    (\\<lambda>x\\<^bold>\\<in>local.set (local.prod ?a ?b).\n                        UP (hfst (DOWN x)))\n  \\<lbrakk>\\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright>;\n   \\<guillemotleft>?g : ?b \\<rightarrow> ?c\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> seq ?g ?f\n\ngoal (1 subgoal):\n 1. Fun (local.comp (pr1 a b) h) =\n    restrict\n     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n          UP (hfst (DOWN x))) \\<circ>\n      Fun h)\n     (Dom h)", "by auto"], ["proof (state)\nthis:\n  Fun (local.comp (pr1 a b) h) =\n  restrict\n   ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n        UP (hfst (DOWN x))) \\<circ>\n    Fun h)\n   (Dom h)\n\ngoal (1 subgoal):\n 1. Fun (tuple (local.comp (pr1 a b) h) (local.comp (pr0 a b) h)) = Fun h", "have 2: \"Fun (comp (pr0 a b) h) =\n                 restrict (restrict (\\<lambda>x. UP (hsnd (DOWN x))) (set (prod a b)) \\<circ> Fun h) (Dom h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (local.comp (pr0 a b) h) =\n    restrict\n     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n          UP (hsnd (DOWN x))) \\<circ>\n      Fun h)\n     (Dom h)", "using assms pr0 Fun_comp Fun_pr0 seqI'"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  \\<guillemotleft>h : local.dom\n                       h \\<rightarrow> local.prod a b\\<guillemotright>\n  \\<guillemotleft>pr0 a b : local.prod a b \\<rightarrow> b\\<guillemotright>\n  seq ?g ?f \\<Longrightarrow>\n  Fun (local.comp ?g ?f) = restrict (Fun ?g \\<circ> Fun ?f) (Dom ?f)\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> Fun (pr0 ?a ?b) =\n                    (\\<lambda>x\\<^bold>\\<in>local.set (local.prod ?a ?b).\n                        UP (hsnd (DOWN x)))\n  \\<lbrakk>\\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright>;\n   \\<guillemotleft>?g : ?b \\<rightarrow> ?c\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> seq ?g ?f\n\ngoal (1 subgoal):\n 1. Fun (local.comp (pr0 a b) h) =\n    restrict\n     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n          UP (hsnd (DOWN x))) \\<circ>\n      Fun h)\n     (Dom h)", "by auto"], ["proof (state)\nthis:\n  Fun (local.comp (pr0 a b) h) =\n  restrict\n   ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n        UP (hsnd (DOWN x))) \\<circ>\n    Fun h)\n   (Dom h)\n\ngoal (1 subgoal):\n 1. Fun (tuple (local.comp (pr1 a b) h) (local.comp (pr0 a b) h)) = Fun h", "have \"Fun (tuple (comp (pr1 a b) h) (comp (pr0 a b) h)) =\n              restrict (\\<lambda>x. UP \\<langle>DOWN (restrict\n                                       (restrict (\\<lambda>x. UP (hfst (DOWN x))) (set (prod a b)) \\<circ> Fun h)\n                                                 (Dom h) x),\n                                DOWN (restrict\n                                       (restrict (\\<lambda>x. UP (hsnd (DOWN x))) (set (prod a b)) \\<circ> Fun h)\n                                                 (Dom h) x)\\<rangle>)\n                       (Dom h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (tuple (local.comp (pr1 a b) h) (local.comp (pr0 a b) h)) =\n    (\\<lambda>x\\<^bold>\\<in>Dom h.\n        UP \\<langle>DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hfst (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x),\n                    DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hsnd (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x)\\<rangle>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Fun (tuple (local.comp (pr1 a b) h) (local.comp (pr0 a b) h)) =\n    (\\<lambda>x\\<^bold>\\<in>Dom h.\n        UP \\<langle>DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hfst (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x),\n                    DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hsnd (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x)\\<rangle>)", "have \"Dom (comp (pr1 a b) h) = Dom h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dom (local.comp (pr1 a b) h) = Dom h", "using assms pr1_in_hom"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  \\<guillemotleft>h : local.dom\n                       h \\<rightarrow> local.prod a b\\<guillemotright>\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>pr1 ?a\n                                     ?b : local.prod ?a\n     ?b \\<rightarrow> ?a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. Dom (local.comp (pr1 a b) h) = Dom h", "by (metis (no_types, lifting) in_homE dom_comp seqI)"], ["proof (state)\nthis:\n  Dom (local.comp (pr1 a b) h) = Dom h\n\ngoal (1 subgoal):\n 1. Fun (tuple (local.comp (pr1 a b) h) (local.comp (pr0 a b) h)) =\n    (\\<lambda>x\\<^bold>\\<in>Dom h.\n        UP \\<langle>DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hfst (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x),\n                    DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hsnd (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x)\\<rangle>)", "moreover"], ["proof (state)\nthis:\n  Dom (local.comp (pr1 a b) h) = Dom h\n\ngoal (1 subgoal):\n 1. Fun (tuple (local.comp (pr1 a b) h) (local.comp (pr0 a b) h)) =\n    (\\<lambda>x\\<^bold>\\<in>Dom h.\n        UP \\<langle>DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hfst (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x),\n                    DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hsnd (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x)\\<rangle>)", "have \"arr (mkArr (Dom (comp (pr1 a b) h))\n                             (set (prod (cod (comp (pr1 a b) h)) (cod (comp (pr0 a b) h))))\n                             (\\<lambda>x. UP \\<langle>DOWN (Fun (comp (pr1 a b) h) x),\n                                      DOWN (Fun (comp (pr0 a b) h) x)\\<rangle>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (mkArr (Dom (local.comp (pr1 a b) h))\n          (local.set\n            (local.prod (cod (local.comp (pr1 a b) h))\n              (cod (local.comp (pr0 a b) h))))\n          (\\<lambda>x.\n              UP \\<langle>DOWN (Fun (local.comp (pr1 a b) h) x),\n                          DOWN (Fun (local.comp (pr0 a b) h) x)\\<rangle>))", "using tuple"], ["proof (prove)\nusing this:\n  \\<guillemotleft>tuple (local.comp (pr1 a b) h)\n                   (local.comp (pr0 a b)\n                     h) : local.dom\n                           h \\<rightarrow> local.prod a b\\<guillemotright>\n\ngoal (1 subgoal):\n 1. arr (mkArr (Dom (local.comp (pr1 a b) h))\n          (local.set\n            (local.prod (cod (local.comp (pr1 a b) h))\n              (cod (local.comp (pr0 a b) h))))\n          (\\<lambda>x.\n              UP \\<langle>DOWN (Fun (local.comp (pr1 a b) h) x),\n                          DOWN (Fun (local.comp (pr0 a b) h) x)\\<rangle>))", "unfolding tuple_def"], ["proof (prove)\nusing this:\n  \\<guillemotleft>mkArr (Dom (local.comp (pr1 a b) h))\n                   (local.set\n                     (local.prod (cod (local.comp (pr1 a b) h))\n                       (cod (local.comp (pr0 a b) h))))\n                   (\\<lambda>x.\n                       UP \\<langle>DOWN (Fun (local.comp (pr1 a b) h) x),\n                                   DOWN\n                                    (Fun (local.comp (pr0 a b) h)\nx)\\<rangle>) : local.dom h \\<rightarrow> local.prod a b\\<guillemotright>\n\ngoal (1 subgoal):\n 1. arr (mkArr (Dom (local.comp (pr1 a b) h))\n          (local.set\n            (local.prod (cod (local.comp (pr1 a b) h))\n              (cod (local.comp (pr0 a b) h))))\n          (\\<lambda>x.\n              UP \\<langle>DOWN (Fun (local.comp (pr1 a b) h) x),\n                          DOWN (Fun (local.comp (pr0 a b) h) x)\\<rangle>))", "by blast"], ["proof (state)\nthis:\n  arr (mkArr (Dom (local.comp (pr1 a b) h))\n        (local.set\n          (local.prod (cod (local.comp (pr1 a b) h))\n            (cod (local.comp (pr0 a b) h))))\n        (\\<lambda>x.\n            UP \\<langle>DOWN (Fun (local.comp (pr1 a b) h) x),\n                        DOWN (Fun (local.comp (pr0 a b) h) x)\\<rangle>))\n\ngoal (1 subgoal):\n 1. Fun (tuple (local.comp (pr1 a b) h) (local.comp (pr0 a b) h)) =\n    (\\<lambda>x\\<^bold>\\<in>Dom h.\n        UP \\<langle>DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hfst (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x),\n                    DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hsnd (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x)\\<rangle>)", "ultimately"], ["proof (chain)\npicking this:\n  Dom (local.comp (pr1 a b) h) = Dom h\n  arr (mkArr (Dom (local.comp (pr1 a b) h))\n        (local.set\n          (local.prod (cod (local.comp (pr1 a b) h))\n            (cod (local.comp (pr0 a b) h))))\n        (\\<lambda>x.\n            UP \\<langle>DOWN (Fun (local.comp (pr1 a b) h) x),\n                        DOWN (Fun (local.comp (pr0 a b) h) x)\\<rangle>))", "show ?thesis"], ["proof (prove)\nusing this:\n  Dom (local.comp (pr1 a b) h) = Dom h\n  arr (mkArr (Dom (local.comp (pr1 a b) h))\n        (local.set\n          (local.prod (cod (local.comp (pr1 a b) h))\n            (cod (local.comp (pr0 a b) h))))\n        (\\<lambda>x.\n            UP \\<langle>DOWN (Fun (local.comp (pr1 a b) h) x),\n                        DOWN (Fun (local.comp (pr0 a b) h) x)\\<rangle>))\n\ngoal (1 subgoal):\n 1. Fun (tuple (local.comp (pr1 a b) h) (local.comp (pr0 a b) h)) =\n    (\\<lambda>x\\<^bold>\\<in>Dom h.\n        UP \\<langle>DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hfst (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x),\n                    DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hsnd (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x)\\<rangle>)", "using 1 2 tuple tuple_def\n                  Fun_mkArr [of \"Dom (comp (pr1 a b) h)\"\n                                 \"set (prod (cod (comp (pr1 a b) h))\n                                            (cod (comp (pr0 a b) h)))\"\n                                 \"\\<lambda>x. UP \\<langle>DOWN (Fun (comp (pr1 a b) h) x),\n                                          DOWN (Fun (comp (pr0 a b) h) x)\\<rangle>\"]"], ["proof (prove)\nusing this:\n  Dom (local.comp (pr1 a b) h) = Dom h\n  arr (mkArr (Dom (local.comp (pr1 a b) h))\n        (local.set\n          (local.prod (cod (local.comp (pr1 a b) h))\n            (cod (local.comp (pr0 a b) h))))\n        (\\<lambda>x.\n            UP \\<langle>DOWN (Fun (local.comp (pr1 a b) h) x),\n                        DOWN (Fun (local.comp (pr0 a b) h) x)\\<rangle>))\n  Fun (local.comp (pr1 a b) h) =\n  restrict\n   ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n        UP (hfst (DOWN x))) \\<circ>\n    Fun h)\n   (Dom h)\n  Fun (local.comp (pr0 a b) h) =\n  restrict\n   ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n        UP (hsnd (DOWN x))) \\<circ>\n    Fun h)\n   (Dom h)\n  \\<guillemotleft>tuple (local.comp (pr1 a b) h)\n                   (local.comp (pr0 a b)\n                     h) : local.dom\n                           h \\<rightarrow> local.prod a b\\<guillemotright>\n  tuple ?f ?g =\n  mkArr (Dom ?f) (local.set (local.prod (cod ?f) (cod ?g)))\n   (\\<lambda>x. UP \\<langle>DOWN (Fun ?f x), DOWN (Fun ?g x)\\<rangle>)\n  arr (mkArr (Dom (local.comp (pr1 a b) h))\n        (local.set\n          (local.prod (cod (local.comp (pr1 a b) h))\n            (cod (local.comp (pr0 a b) h))))\n        (\\<lambda>x.\n            UP \\<langle>DOWN (Fun (local.comp (pr1 a b) h) x),\n                        DOWN\n                         (Fun (local.comp (pr0 a b) h)\n                           x)\\<rangle>)) \\<Longrightarrow>\n  Fun (mkArr (Dom (local.comp (pr1 a b) h))\n        (local.set\n          (local.prod (cod (local.comp (pr1 a b) h))\n            (cod (local.comp (pr0 a b) h))))\n        (\\<lambda>x.\n            UP \\<langle>DOWN (Fun (local.comp (pr1 a b) h) x),\n                        DOWN (Fun (local.comp (pr0 a b) h) x)\\<rangle>)) =\n  (\\<lambda>x\\<^bold>\\<in>Dom (local.comp (pr1 a b) h).\n      UP \\<langle>DOWN (Fun (local.comp (pr1 a b) h) x),\n                  DOWN (Fun (local.comp (pr0 a b) h) x)\\<rangle>)\n\ngoal (1 subgoal):\n 1. Fun (tuple (local.comp (pr1 a b) h) (local.comp (pr0 a b) h)) =\n    (\\<lambda>x\\<^bold>\\<in>Dom h.\n        UP \\<langle>DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hfst (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x),\n                    DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hsnd (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x)\\<rangle>)", "by simp"], ["proof (state)\nthis:\n  Fun (tuple (local.comp (pr1 a b) h) (local.comp (pr0 a b) h)) =\n  (\\<lambda>x\\<^bold>\\<in>Dom h.\n      UP \\<langle>DOWN\n                   (restrict\n                     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                          UP (hfst (DOWN x))) \\<circ>\n                      Fun h)\n                     (Dom h) x),\n                  DOWN\n                   (restrict\n                     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                          UP (hsnd (DOWN x))) \\<circ>\n                      Fun h)\n                     (Dom h) x)\\<rangle>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Fun (tuple (local.comp (pr1 a b) h) (local.comp (pr0 a b) h)) =\n  (\\<lambda>x\\<^bold>\\<in>Dom h.\n      UP \\<langle>DOWN\n                   (restrict\n                     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                          UP (hfst (DOWN x))) \\<circ>\n                      Fun h)\n                     (Dom h) x),\n                  DOWN\n                   (restrict\n                     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                          UP (hsnd (DOWN x))) \\<circ>\n                      Fun h)\n                     (Dom h) x)\\<rangle>)\n\ngoal (1 subgoal):\n 1. Fun (tuple (local.comp (pr1 a b) h) (local.comp (pr0 a b) h)) = Fun h", "also"], ["proof (state)\nthis:\n  Fun (tuple (local.comp (pr1 a b) h) (local.comp (pr0 a b) h)) =\n  (\\<lambda>x\\<^bold>\\<in>Dom h.\n      UP \\<langle>DOWN\n                   (restrict\n                     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                          UP (hfst (DOWN x))) \\<circ>\n                      Fun h)\n                     (Dom h) x),\n                  DOWN\n                   (restrict\n                     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                          UP (hsnd (DOWN x))) \\<circ>\n                      Fun h)\n                     (Dom h) x)\\<rangle>)\n\ngoal (1 subgoal):\n 1. Fun (tuple (local.comp (pr1 a b) h) (local.comp (pr0 a b) h)) = Fun h", "have \"... = Fun h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<^bold>\\<in>Dom h.\n        UP \\<langle>DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hfst (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x),\n                    DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hsnd (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x)\\<rangle>) =\n    Fun h", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<lambda>x\\<^bold>\\<in>Dom h.\n           UP \\<langle>DOWN\n                        (restrict\n                          ((\\<lambda>x\\<^bold>\\<in>local.set\n              (local.prod a b).\n                               UP (hfst (DOWN x))) \\<circ>\n                           Fun h)\n                          (Dom h) x),\n                       DOWN\n                        (restrict\n                          ((\\<lambda>x\\<^bold>\\<in>local.set\n              (local.prod a b).\n                               UP (hsnd (DOWN x))) \\<circ>\n                           Fun h)\n                          (Dom h) x)\\<rangle>)\n        x =\n       Fun h x", "let ?f = \"...\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<lambda>x\\<^bold>\\<in>Dom h.\n           UP \\<langle>DOWN\n                        (restrict\n                          ((\\<lambda>x\\<^bold>\\<in>local.set\n              (local.prod a b).\n                               UP (hfst (DOWN x))) \\<circ>\n                           Fun h)\n                          (Dom h) x),\n                       DOWN\n                        (restrict\n                          ((\\<lambda>x\\<^bold>\\<in>local.set\n              (local.prod a b).\n                               UP (hsnd (DOWN x))) \\<circ>\n                           Fun h)\n                          (Dom h) x)\\<rangle>)\n        x =\n       Fun h x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (\\<lambda>x\\<^bold>\\<in>Dom h.\n           UP \\<langle>DOWN\n                        (restrict\n                          ((\\<lambda>x\\<^bold>\\<in>local.set\n              (local.prod a b).\n                               UP (hfst (DOWN x))) \\<circ>\n                           Fun h)\n                          (Dom h) x),\n                       DOWN\n                        (restrict\n                          ((\\<lambda>x\\<^bold>\\<in>local.set\n              (local.prod a b).\n                               UP (hsnd (DOWN x))) \\<circ>\n                           Fun h)\n                          (Dom h) x)\\<rangle>)\n        x =\n       Fun h x", "show \"?f x = Fun h x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<^bold>\\<in>Dom h.\n        UP \\<langle>DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hfst (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x),\n                    DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hsnd (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x)\\<rangle>)\n     x =\n    Fun h x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<^bold>\\<in>Dom h.\n        UP \\<langle>DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hfst (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x),\n                    DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hsnd (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x)\\<rangle>)\n     x =\n    Fun h x", "have \"x \\<notin> Dom h \\<Longrightarrow> ?f x = Fun h x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> Dom h \\<Longrightarrow>\n    (\\<lambda>x\\<^bold>\\<in>Dom h.\n        UP \\<langle>DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hfst (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x),\n                    DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hsnd (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x)\\<rangle>)\n     x =\n    Fun h x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> Dom h \\<Longrightarrow>\n    (\\<lambda>x\\<^bold>\\<in>Dom h.\n        UP \\<langle>DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hfst (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x),\n                    DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hsnd (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x)\\<rangle>)\n     x =\n    Fun h x", "assume x: \"x \\<notin> Dom h\""], ["proof (state)\nthis:\n  x \\<notin> Dom h\n\ngoal (1 subgoal):\n 1. x \\<notin> Dom h \\<Longrightarrow>\n    (\\<lambda>x\\<^bold>\\<in>Dom h.\n        UP \\<langle>DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hfst (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x),\n                    DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hsnd (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x)\\<rangle>)\n     x =\n    Fun h x", "have \"restrict ?f (Dom h) x = undefined\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict\n     (\\<lambda>x\\<^bold>\\<in>Dom h.\n         UP \\<langle>DOWN\n                      (restrict\n                        ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                             UP (hfst (DOWN x))) \\<circ>\n                         Fun h)\n                        (Dom h) x),\n                     DOWN\n                      (restrict\n                        ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                             UP (hsnd (DOWN x))) \\<circ>\n                         Fun h)\n                        (Dom h) x)\\<rangle>)\n     (Dom h) x =\n    undefined", "using assms x restrict_apply"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  \\<guillemotleft>h : local.dom\n                       h \\<rightarrow> local.prod a b\\<guillemotright>\n  x \\<notin> Dom h\n  restrict ?f ?A ?x = (if ?x \\<in> ?A then ?f ?x else undefined)\n\ngoal (1 subgoal):\n 1. restrict\n     (\\<lambda>x\\<^bold>\\<in>Dom h.\n         UP \\<langle>DOWN\n                      (restrict\n                        ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                             UP (hfst (DOWN x))) \\<circ>\n                         Fun h)\n                        (Dom h) x),\n                     DOWN\n                      (restrict\n                        ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                             UP (hsnd (DOWN x))) \\<circ>\n                         Fun h)\n                        (Dom h) x)\\<rangle>)\n     (Dom h) x =\n    undefined", "by auto"], ["proof (state)\nthis:\n  restrict\n   (\\<lambda>x\\<^bold>\\<in>Dom h.\n       UP \\<langle>DOWN\n                    (restrict\n                      ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                           UP (hfst (DOWN x))) \\<circ>\n                       Fun h)\n                      (Dom h) x),\n                   DOWN\n                    (restrict\n                      ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                           UP (hsnd (DOWN x))) \\<circ>\n                       Fun h)\n                      (Dom h) x)\\<rangle>)\n   (Dom h) x =\n  undefined\n\ngoal (1 subgoal):\n 1. x \\<notin> Dom h \\<Longrightarrow>\n    (\\<lambda>x\\<^bold>\\<in>Dom h.\n        UP \\<langle>DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hfst (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x),\n                    DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hsnd (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x)\\<rangle>)\n     x =\n    Fun h x", "also"], ["proof (state)\nthis:\n  restrict\n   (\\<lambda>x\\<^bold>\\<in>Dom h.\n       UP \\<langle>DOWN\n                    (restrict\n                      ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                           UP (hfst (DOWN x))) \\<circ>\n                       Fun h)\n                      (Dom h) x),\n                   DOWN\n                    (restrict\n                      ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                           UP (hsnd (DOWN x))) \\<circ>\n                       Fun h)\n                      (Dom h) x)\\<rangle>)\n   (Dom h) x =\n  undefined\n\ngoal (1 subgoal):\n 1. x \\<notin> Dom h \\<Longrightarrow>\n    (\\<lambda>x\\<^bold>\\<in>Dom h.\n        UP \\<langle>DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hfst (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x),\n                    DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hsnd (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x)\\<rangle>)\n     x =\n    Fun h x", "have \"... = Fun h x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. undefined = Fun h x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. undefined = Fun h x", "have \"arr h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr h", "using assms"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  \\<guillemotleft>h : local.dom\n                       h \\<rightarrow> local.prod a b\\<guillemotright>\n\ngoal (1 subgoal):\n 1. arr h", "by blast"], ["proof (state)\nthis:\n  arr h\n\ngoal (1 subgoal):\n 1. undefined = Fun h x", "thus ?thesis"], ["proof (prove)\nusing this:\n  arr h\n\ngoal (1 subgoal):\n 1. undefined = Fun h x", "using assms x Fun_mapsto [of h] extensional_arb [of \"Fun h\" \"Dom h\" x]"], ["proof (prove)\nusing this:\n  arr h\n  ide a\n  ide b\n  \\<guillemotleft>h : local.dom\n                       h \\<rightarrow> local.prod a b\\<guillemotright>\n  x \\<notin> Dom h\n  arr h \\<Longrightarrow>\n  Fun h \\<in> extensional (Dom h) \\<inter> (Dom h \\<rightarrow> Cod h)\n  \\<lbrakk>Fun h \\<in> extensional (Dom h); x \\<notin> Dom h\\<rbrakk>\n  \\<Longrightarrow> Fun h x = undefined\n\ngoal (1 subgoal):\n 1. undefined = Fun h x", "by simp"], ["proof (state)\nthis:\n  undefined = Fun h x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  undefined = Fun h x\n\ngoal (1 subgoal):\n 1. x \\<notin> Dom h \\<Longrightarrow>\n    (\\<lambda>x\\<^bold>\\<in>Dom h.\n        UP \\<langle>DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hfst (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x),\n                    DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hsnd (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x)\\<rangle>)\n     x =\n    Fun h x", "finally"], ["proof (chain)\npicking this:\n  restrict\n   (\\<lambda>x\\<^bold>\\<in>Dom h.\n       UP \\<langle>DOWN\n                    (restrict\n                      ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                           UP (hfst (DOWN x))) \\<circ>\n                       Fun h)\n                      (Dom h) x),\n                   DOWN\n                    (restrict\n                      ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                           UP (hsnd (DOWN x))) \\<circ>\n                       Fun h)\n                      (Dom h) x)\\<rangle>)\n   (Dom h) x =\n  Fun h x", "show ?thesis"], ["proof (prove)\nusing this:\n  restrict\n   (\\<lambda>x\\<^bold>\\<in>Dom h.\n       UP \\<langle>DOWN\n                    (restrict\n                      ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                           UP (hfst (DOWN x))) \\<circ>\n                       Fun h)\n                      (Dom h) x),\n                   DOWN\n                    (restrict\n                      ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                           UP (hsnd (DOWN x))) \\<circ>\n                       Fun h)\n                      (Dom h) x)\\<rangle>)\n   (Dom h) x =\n  Fun h x\n\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<^bold>\\<in>Dom h.\n        UP \\<langle>DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hfst (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x),\n                    DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hsnd (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x)\\<rangle>)\n     x =\n    Fun h x", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x\\<^bold>\\<in>Dom h.\n      UP \\<langle>DOWN\n                   (restrict\n                     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                          UP (hfst (DOWN x))) \\<circ>\n                      Fun h)\n                     (Dom h) x),\n                  DOWN\n                   (restrict\n                     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                          UP (hsnd (DOWN x))) \\<circ>\n                      Fun h)\n                     (Dom h) x)\\<rangle>)\n   x =\n  Fun h x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<notin> Dom h \\<Longrightarrow>\n  (\\<lambda>x\\<^bold>\\<in>Dom h.\n      UP \\<langle>DOWN\n                   (restrict\n                     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                          UP (hfst (DOWN x))) \\<circ>\n                      Fun h)\n                     (Dom h) x),\n                  DOWN\n                   (restrict\n                     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                          UP (hsnd (DOWN x))) \\<circ>\n                      Fun h)\n                     (Dom h) x)\\<rangle>)\n   x =\n  Fun h x\n\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<^bold>\\<in>Dom h.\n        UP \\<langle>DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hfst (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x),\n                    DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hsnd (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x)\\<rangle>)\n     x =\n    Fun h x", "moreover"], ["proof (state)\nthis:\n  x \\<notin> Dom h \\<Longrightarrow>\n  (\\<lambda>x\\<^bold>\\<in>Dom h.\n      UP \\<langle>DOWN\n                   (restrict\n                     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                          UP (hfst (DOWN x))) \\<circ>\n                      Fun h)\n                     (Dom h) x),\n                  DOWN\n                   (restrict\n                     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                          UP (hsnd (DOWN x))) \\<circ>\n                      Fun h)\n                     (Dom h) x)\\<rangle>)\n   x =\n  Fun h x\n\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<^bold>\\<in>Dom h.\n        UP \\<langle>DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hfst (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x),\n                    DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hsnd (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x)\\<rangle>)\n     x =\n    Fun h x", "have \"x \\<in> Dom h \\<Longrightarrow> ?f x = Fun h x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Dom h \\<Longrightarrow>\n    (\\<lambda>x\\<^bold>\\<in>Dom h.\n        UP \\<langle>DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hfst (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x),\n                    DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hsnd (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x)\\<rangle>)\n     x =\n    Fun h x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> Dom h \\<Longrightarrow>\n    (\\<lambda>x\\<^bold>\\<in>Dom h.\n        UP \\<langle>DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hfst (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x),\n                    DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hsnd (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x)\\<rangle>)\n     x =\n    Fun h x", "assume x: \"x \\<in> Dom h\""], ["proof (state)\nthis:\n  x \\<in> Dom h\n\ngoal (1 subgoal):\n 1. x \\<in> Dom h \\<Longrightarrow>\n    (\\<lambda>x\\<^bold>\\<in>Dom h.\n        UP \\<langle>DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hfst (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x),\n                    DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hsnd (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x)\\<rangle>)\n     x =\n    Fun h x", "have 1: \"Fun h x \\<in> set (prod a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun h x \\<in> local.set (local.prod a b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Fun h x \\<in> local.set (local.prod a b)", "have \"Fun h x \\<in> Cod h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun h x \\<in> Cod h", "using assms x Fun_mapsto [of h]"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  \\<guillemotleft>h : local.dom\n                       h \\<rightarrow> local.prod a b\\<guillemotright>\n  x \\<in> Dom h\n  arr h \\<Longrightarrow>\n  Fun h \\<in> extensional (Dom h) \\<inter> (Dom h \\<rightarrow> Cod h)\n\ngoal (1 subgoal):\n 1. Fun h x \\<in> Cod h", "by blast"], ["proof (state)\nthis:\n  Fun h x \\<in> Cod h\n\ngoal (1 subgoal):\n 1. Fun h x \\<in> local.set (local.prod a b)", "moreover"], ["proof (state)\nthis:\n  Fun h x \\<in> Cod h\n\ngoal (1 subgoal):\n 1. Fun h x \\<in> local.set (local.prod a b)", "have \"Cod h = set (prod a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cod h = local.set (local.prod a b)", "using assms ide_prod"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  \\<guillemotleft>h : local.dom\n                       h \\<rightarrow> local.prod a b\\<guillemotright>\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk> \\<Longrightarrow> ide (local.prod ?a ?b)\n\ngoal (1 subgoal):\n 1. Cod h = local.set (local.prod a b)", "by (metis (no_types, lifting) in_homE)"], ["proof (state)\nthis:\n  Cod h = local.set (local.prod a b)\n\ngoal (1 subgoal):\n 1. Fun h x \\<in> local.set (local.prod a b)", "ultimately"], ["proof (chain)\npicking this:\n  Fun h x \\<in> Cod h\n  Cod h = local.set (local.prod a b)", "show ?thesis"], ["proof (prove)\nusing this:\n  Fun h x \\<in> Cod h\n  Cod h = local.set (local.prod a b)\n\ngoal (1 subgoal):\n 1. Fun h x \\<in> local.set (local.prod a b)", "by fast"], ["proof (state)\nthis:\n  Fun h x \\<in> local.set (local.prod a b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Fun h x \\<in> local.set (local.prod a b)\n\ngoal (1 subgoal):\n 1. x \\<in> Dom h \\<Longrightarrow>\n    (\\<lambda>x\\<^bold>\\<in>Dom h.\n        UP \\<langle>DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hfst (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x),\n                    DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hsnd (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x)\\<rangle>)\n     x =\n    Fun h x", "have \"?f x = UP \\<langle>hfst (DOWN (Fun h x)), hsnd (DOWN (Fun h x))\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<^bold>\\<in>Dom h.\n        UP \\<langle>DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hfst (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x),\n                    DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hsnd (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x)\\<rangle>)\n     x =\n    UP \\<langle>hfst (DOWN (Fun h x)), hsnd (DOWN (Fun h x))\\<rangle>", "using x 1"], ["proof (prove)\nusing this:\n  x \\<in> Dom h\n  Fun h x \\<in> local.set (local.prod a b)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<^bold>\\<in>Dom h.\n        UP \\<langle>DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hfst (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x),\n                    DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hsnd (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x)\\<rangle>)\n     x =\n    UP \\<langle>hfst (DOWN (Fun h x)), hsnd (DOWN (Fun h x))\\<rangle>", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>x\\<^bold>\\<in>Dom h.\n      UP \\<langle>DOWN\n                   (restrict\n                     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                          UP (hfst (DOWN x))) \\<circ>\n                      Fun h)\n                     (Dom h) x),\n                  DOWN\n                   (restrict\n                     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                          UP (hsnd (DOWN x))) \\<circ>\n                      Fun h)\n                     (Dom h) x)\\<rangle>)\n   x =\n  UP \\<langle>hfst (DOWN (Fun h x)), hsnd (DOWN (Fun h x))\\<rangle>\n\ngoal (1 subgoal):\n 1. x \\<in> Dom h \\<Longrightarrow>\n    (\\<lambda>x\\<^bold>\\<in>Dom h.\n        UP \\<langle>DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hfst (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x),\n                    DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hsnd (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x)\\<rangle>)\n     x =\n    Fun h x", "also"], ["proof (state)\nthis:\n  (\\<lambda>x\\<^bold>\\<in>Dom h.\n      UP \\<langle>DOWN\n                   (restrict\n                     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                          UP (hfst (DOWN x))) \\<circ>\n                      Fun h)\n                     (Dom h) x),\n                  DOWN\n                   (restrict\n                     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                          UP (hsnd (DOWN x))) \\<circ>\n                      Fun h)\n                     (Dom h) x)\\<rangle>)\n   x =\n  UP \\<langle>hfst (DOWN (Fun h x)), hsnd (DOWN (Fun h x))\\<rangle>\n\ngoal (1 subgoal):\n 1. x \\<in> Dom h \\<Longrightarrow>\n    (\\<lambda>x\\<^bold>\\<in>Dom h.\n        UP \\<langle>DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hfst (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x),\n                    DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hsnd (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x)\\<rangle>)\n     x =\n    Fun h x", "have \"... = UP (DOWN (Fun h x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP \\<langle>hfst (DOWN (Fun h x)), hsnd (DOWN (Fun h x))\\<rangle> =\n    UP (DOWN (Fun h x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. UP \\<langle>hfst (DOWN (Fun h x)), hsnd (DOWN (Fun h x))\\<rangle> =\n    UP (DOWN (Fun h x))", "have \"DOWN (Fun h x) \\<^bold>\\<in> ide_to_hf a * ide_to_hf b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DOWN (Fun h x) \\<^bold>\\<in> ide_to_hf a * ide_to_hf b", "using assms x 1 par"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  \\<guillemotleft>h : local.dom\n                       h \\<rightarrow> local.prod a b\\<guillemotright>\n  x \\<in> Dom h\n  Fun h x \\<in> local.set (local.prod a b)\n  par (tuple (local.comp (pr1 a b) h) (local.comp (pr0 a b) h)) h\n\ngoal (1 subgoal):\n 1. DOWN (Fun h x) \\<^bold>\\<in> ide_to_hf a * ide_to_hf b", "by (metis (no_types, lifting) prod_def DOWN_membI UNIV_I ide_prod\n                      ide_to_hf_hf_to_ide)"], ["proof (state)\nthis:\n  DOWN (Fun h x) \\<^bold>\\<in> ide_to_hf a * ide_to_hf b\n\ngoal (1 subgoal):\n 1. UP \\<langle>hfst (DOWN (Fun h x)), hsnd (DOWN (Fun h x))\\<rangle> =\n    UP (DOWN (Fun h x))", "thus ?thesis"], ["proof (prove)\nusing this:\n  DOWN (Fun h x) \\<^bold>\\<in> ide_to_hf a * ide_to_hf b\n\ngoal (1 subgoal):\n 1. UP \\<langle>hfst (DOWN (Fun h x)), hsnd (DOWN (Fun h x))\\<rangle> =\n    UP (DOWN (Fun h x))", "using x is_hpair_def"], ["proof (prove)\nusing this:\n  DOWN (Fun h x) \\<^bold>\\<in> ide_to_hf a * ide_to_hf b\n  x \\<in> Dom h\n  is_hpair ?z = (\\<exists>x y. ?z = \\<langle>x, y\\<rangle>)\n\ngoal (1 subgoal):\n 1. UP \\<langle>hfst (DOWN (Fun h x)), hsnd (DOWN (Fun h x))\\<rangle> =\n    UP (DOWN (Fun h x))", "by auto"], ["proof (state)\nthis:\n  UP \\<langle>hfst (DOWN (Fun h x)), hsnd (DOWN (Fun h x))\\<rangle> =\n  UP (DOWN (Fun h x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  UP \\<langle>hfst (DOWN (Fun h x)), hsnd (DOWN (Fun h x))\\<rangle> =\n  UP (DOWN (Fun h x))\n\ngoal (1 subgoal):\n 1. x \\<in> Dom h \\<Longrightarrow>\n    (\\<lambda>x\\<^bold>\\<in>Dom h.\n        UP \\<langle>DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hfst (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x),\n                    DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hsnd (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x)\\<rangle>)\n     x =\n    Fun h x", "also"], ["proof (state)\nthis:\n  UP \\<langle>hfst (DOWN (Fun h x)), hsnd (DOWN (Fun h x))\\<rangle> =\n  UP (DOWN (Fun h x))\n\ngoal (1 subgoal):\n 1. x \\<in> Dom h \\<Longrightarrow>\n    (\\<lambda>x\\<^bold>\\<in>Dom h.\n        UP \\<langle>DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hfst (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x),\n                    DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hsnd (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x)\\<rangle>)\n     x =\n    Fun h x", "have \"... = Fun h x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP (DOWN (Fun h x)) = Fun h x", "using assms 1 ide_prod set_subset_Univ UP_DOWN"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  \\<guillemotleft>h : local.dom\n                       h \\<rightarrow> local.prod a b\\<guillemotright>\n  Fun h x \\<in> local.set (local.prod a b)\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk> \\<Longrightarrow> ide (local.prod ?a ?b)\n  ide ?a \\<Longrightarrow> local.set ?a \\<subseteq> Univ\n  ?t \\<in> Univ \\<Longrightarrow> UP (DOWN ?t) = ?t\n\ngoal (1 subgoal):\n 1. UP (DOWN (Fun h x)) = Fun h x", "by (meson subsetD)"], ["proof (state)\nthis:\n  UP (DOWN (Fun h x)) = Fun h x\n\ngoal (1 subgoal):\n 1. x \\<in> Dom h \\<Longrightarrow>\n    (\\<lambda>x\\<^bold>\\<in>Dom h.\n        UP \\<langle>DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hfst (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x),\n                    DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hsnd (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x)\\<rangle>)\n     x =\n    Fun h x", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>x\\<^bold>\\<in>Dom h.\n      UP \\<langle>DOWN\n                   (restrict\n                     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                          UP (hfst (DOWN x))) \\<circ>\n                      Fun h)\n                     (Dom h) x),\n                  DOWN\n                   (restrict\n                     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                          UP (hsnd (DOWN x))) \\<circ>\n                      Fun h)\n                     (Dom h) x)\\<rangle>)\n   x =\n  Fun h x", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>x\\<^bold>\\<in>Dom h.\n      UP \\<langle>DOWN\n                   (restrict\n                     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                          UP (hfst (DOWN x))) \\<circ>\n                      Fun h)\n                     (Dom h) x),\n                  DOWN\n                   (restrict\n                     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                          UP (hsnd (DOWN x))) \\<circ>\n                      Fun h)\n                     (Dom h) x)\\<rangle>)\n   x =\n  Fun h x\n\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<^bold>\\<in>Dom h.\n        UP \\<langle>DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hfst (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x),\n                    DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hsnd (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x)\\<rangle>)\n     x =\n    Fun h x", "by blast"], ["proof (state)\nthis:\n  (\\<lambda>x\\<^bold>\\<in>Dom h.\n      UP \\<langle>DOWN\n                   (restrict\n                     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                          UP (hfst (DOWN x))) \\<circ>\n                      Fun h)\n                     (Dom h) x),\n                  DOWN\n                   (restrict\n                     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                          UP (hsnd (DOWN x))) \\<circ>\n                      Fun h)\n                     (Dom h) x)\\<rangle>)\n   x =\n  Fun h x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> Dom h \\<Longrightarrow>\n  (\\<lambda>x\\<^bold>\\<in>Dom h.\n      UP \\<langle>DOWN\n                   (restrict\n                     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                          UP (hfst (DOWN x))) \\<circ>\n                      Fun h)\n                     (Dom h) x),\n                  DOWN\n                   (restrict\n                     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                          UP (hsnd (DOWN x))) \\<circ>\n                      Fun h)\n                     (Dom h) x)\\<rangle>)\n   x =\n  Fun h x\n\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<^bold>\\<in>Dom h.\n        UP \\<langle>DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hfst (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x),\n                    DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hsnd (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x)\\<rangle>)\n     x =\n    Fun h x", "ultimately"], ["proof (chain)\npicking this:\n  x \\<notin> Dom h \\<Longrightarrow>\n  (\\<lambda>x\\<^bold>\\<in>Dom h.\n      UP \\<langle>DOWN\n                   (restrict\n                     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                          UP (hfst (DOWN x))) \\<circ>\n                      Fun h)\n                     (Dom h) x),\n                  DOWN\n                   (restrict\n                     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                          UP (hsnd (DOWN x))) \\<circ>\n                      Fun h)\n                     (Dom h) x)\\<rangle>)\n   x =\n  Fun h x\n  x \\<in> Dom h \\<Longrightarrow>\n  (\\<lambda>x\\<^bold>\\<in>Dom h.\n      UP \\<langle>DOWN\n                   (restrict\n                     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                          UP (hfst (DOWN x))) \\<circ>\n                      Fun h)\n                     (Dom h) x),\n                  DOWN\n                   (restrict\n                     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                          UP (hsnd (DOWN x))) \\<circ>\n                      Fun h)\n                     (Dom h) x)\\<rangle>)\n   x =\n  Fun h x", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<notin> Dom h \\<Longrightarrow>\n  (\\<lambda>x\\<^bold>\\<in>Dom h.\n      UP \\<langle>DOWN\n                   (restrict\n                     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                          UP (hfst (DOWN x))) \\<circ>\n                      Fun h)\n                     (Dom h) x),\n                  DOWN\n                   (restrict\n                     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                          UP (hsnd (DOWN x))) \\<circ>\n                      Fun h)\n                     (Dom h) x)\\<rangle>)\n   x =\n  Fun h x\n  x \\<in> Dom h \\<Longrightarrow>\n  (\\<lambda>x\\<^bold>\\<in>Dom h.\n      UP \\<langle>DOWN\n                   (restrict\n                     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                          UP (hfst (DOWN x))) \\<circ>\n                      Fun h)\n                     (Dom h) x),\n                  DOWN\n                   (restrict\n                     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                          UP (hsnd (DOWN x))) \\<circ>\n                      Fun h)\n                     (Dom h) x)\\<rangle>)\n   x =\n  Fun h x\n\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<^bold>\\<in>Dom h.\n        UP \\<langle>DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hfst (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x),\n                    DOWN\n                     (restrict\n                       ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                            UP (hsnd (DOWN x))) \\<circ>\n                        Fun h)\n                       (Dom h) x)\\<rangle>)\n     x =\n    Fun h x", "by blast"], ["proof (state)\nthis:\n  (\\<lambda>x\\<^bold>\\<in>Dom h.\n      UP \\<langle>DOWN\n                   (restrict\n                     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                          UP (hfst (DOWN x))) \\<circ>\n                      Fun h)\n                     (Dom h) x),\n                  DOWN\n                   (restrict\n                     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                          UP (hsnd (DOWN x))) \\<circ>\n                      Fun h)\n                     (Dom h) x)\\<rangle>)\n   x =\n  Fun h x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>x\\<^bold>\\<in>Dom h.\n      UP \\<langle>DOWN\n                   (restrict\n                     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                          UP (hfst (DOWN x))) \\<circ>\n                      Fun h)\n                     (Dom h) x),\n                  DOWN\n                   (restrict\n                     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                          UP (hsnd (DOWN x))) \\<circ>\n                      Fun h)\n                     (Dom h) x)\\<rangle>)\n   x =\n  Fun h x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>x\\<^bold>\\<in>Dom h.\n      UP \\<langle>DOWN\n                   (restrict\n                     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                          UP (hfst (DOWN x))) \\<circ>\n                      Fun h)\n                     (Dom h) x),\n                  DOWN\n                   (restrict\n                     ((\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n                          UP (hsnd (DOWN x))) \\<circ>\n                      Fun h)\n                     (Dom h) x)\\<rangle>) =\n  Fun h\n\ngoal (1 subgoal):\n 1. Fun (tuple (local.comp (pr1 a b) h) (local.comp (pr0 a b) h)) = Fun h", "finally"], ["proof (chain)\npicking this:\n  Fun (tuple (local.comp (pr1 a b) h) (local.comp (pr0 a b) h)) = Fun h", "show ?thesis"], ["proof (prove)\nusing this:\n  Fun (tuple (local.comp (pr1 a b) h) (local.comp (pr0 a b) h)) = Fun h\n\ngoal (1 subgoal):\n 1. Fun (tuple (local.comp (pr1 a b) h) (local.comp (pr0 a b) h)) = Fun h", "by blast"], ["proof (state)\nthis:\n  Fun (tuple (local.comp (pr1 a b) h) (local.comp (pr0 a b) h)) = Fun h\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Fun (tuple (local.comp (pr1 a b) h) (local.comp (pr0 a b) h)) = Fun h\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation HF': elementary_category_with_binary_products comp pr0 pr1"], ["proof (prove)\ngoal (1 subgoal):\n 1. elementary_category_with_binary_products local.comp pr0 pr1", "proof"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>a b. \\<not> (ide a \\<and> ide b) \\<Longrightarrow> pr0 a b = null\n 2. \\<And>a b. \\<not> (ide a \\<and> ide b) \\<Longrightarrow> pr1 a b = null\n 3. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> span (pr1 a b) (pr0 a b)\n 4. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk> \\<Longrightarrow> cod (pr0 a b) = b\n 5. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk> \\<Longrightarrow> cod (pr1 a b) = a\n 6. \\<And>f g.\n       span f g \\<Longrightarrow>\n       \\<exists>!l.\n          local.comp (pr1 (cod f) (cod g)) l = f \\<and>\n          local.comp (pr0 (cod f) (cod g)) l = g", "show \"\\<And>a b. \\<lbrakk>ide a; ide b\\<rbrakk> \\<Longrightarrow> span (pr1 a b) (pr0 a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> span (pr1 a b) (pr0 a b)", "using pr0_simps(1) pr0_simps(2) pr1_simps(1) pr1_simps(2)"], ["proof (prove)\nusing this:\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk> \\<Longrightarrow> arr (pr0 ?a ?b)\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> local.dom (pr0 ?a ?b) = local.prod ?a ?b\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk> \\<Longrightarrow> arr (pr1 ?a ?b)\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> local.dom (pr1 ?a ?b) = local.prod ?a ?b\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> span (pr1 a b) (pr0 a b)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>ide ?a1; ide ?b1\\<rbrakk>\n  \\<Longrightarrow> span (pr1 ?a1 ?b1) (pr0 ?a1 ?b1)\n\ngoal (5 subgoals):\n 1. \\<And>a b. \\<not> (ide a \\<and> ide b) \\<Longrightarrow> pr0 a b = null\n 2. \\<And>a b. \\<not> (ide a \\<and> ide b) \\<Longrightarrow> pr1 a b = null\n 3. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk> \\<Longrightarrow> cod (pr0 a b) = b\n 4. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk> \\<Longrightarrow> cod (pr1 a b) = a\n 5. \\<And>f g.\n       span f g \\<Longrightarrow>\n       \\<exists>!l.\n          local.comp (pr1 (cod f) (cod g)) l = f \\<and>\n          local.comp (pr0 (cod f) (cod g)) l = g", "show \"\\<And>a b. \\<lbrakk>ide a; ide b\\<rbrakk> \\<Longrightarrow> cod (pr0 a b) = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk> \\<Longrightarrow> cod (pr0 a b) = b", "using pr0_simps(1-3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk> \\<Longrightarrow> arr (pr0 ?a ?b)\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> local.dom (pr0 ?a ?b) = local.prod ?a ?b\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk> \\<Longrightarrow> cod (pr0 ?a ?b) = ?b\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk> \\<Longrightarrow> cod (pr0 a b) = b", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>ide ?a1; ide ?b1\\<rbrakk>\n  \\<Longrightarrow> cod (pr0 ?a1 ?b1) = ?b1\n\ngoal (4 subgoals):\n 1. \\<And>a b. \\<not> (ide a \\<and> ide b) \\<Longrightarrow> pr0 a b = null\n 2. \\<And>a b. \\<not> (ide a \\<and> ide b) \\<Longrightarrow> pr1 a b = null\n 3. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk> \\<Longrightarrow> cod (pr1 a b) = a\n 4. \\<And>f g.\n       span f g \\<Longrightarrow>\n       \\<exists>!l.\n          local.comp (pr1 (cod f) (cod g)) l = f \\<and>\n          local.comp (pr0 (cod f) (cod g)) l = g", "show \"\\<And>a b. \\<lbrakk>ide a; ide b\\<rbrakk> \\<Longrightarrow> cod (pr1 a b) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk> \\<Longrightarrow> cod (pr1 a b) = a", "using pr1_simps(1-3)"], ["proof (prove)\nusing this:\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk> \\<Longrightarrow> arr (pr1 ?a ?b)\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> local.dom (pr1 ?a ?b) = local.prod ?a ?b\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk> \\<Longrightarrow> cod (pr1 ?a ?b) = ?a\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk> \\<Longrightarrow> cod (pr1 a b) = a", "by blast"], ["proof (state)\nthis:\n  \\<lbrakk>ide ?a1; ide ?b1\\<rbrakk>\n  \\<Longrightarrow> cod (pr1 ?a1 ?b1) = ?a1\n\ngoal (3 subgoals):\n 1. \\<And>a b. \\<not> (ide a \\<and> ide b) \\<Longrightarrow> pr0 a b = null\n 2. \\<And>a b. \\<not> (ide a \\<and> ide b) \\<Longrightarrow> pr1 a b = null\n 3. \\<And>f g.\n       span f g \\<Longrightarrow>\n       \\<exists>!l.\n          local.comp (pr1 (cod f) (cod g)) l = f \\<and>\n          local.comp (pr0 (cod f) (cod g)) l = g", "show \"\\<And>f g. span f g \\<Longrightarrow>\n                    \\<exists>!l. comp (pr1 (cod f) (cod g)) l = f \\<and> comp (pr0 (cod f) (cod g)) l = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f g.\n       span f g \\<Longrightarrow>\n       \\<exists>!l.\n          local.comp (pr1 (cod f) (cod g)) l = f \\<and>\n          local.comp (pr0 (cod f) (cod g)) l = g", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f g.\n       span f g \\<Longrightarrow>\n       local.comp (pr1 (cod f) (cod g)) (?a f g) = f \\<and>\n       local.comp (pr0 (cod f) (cod g)) (?a f g) = g\n 2. \\<And>f g l.\n       \\<lbrakk>span f g;\n        local.comp (pr1 (cod f) (cod g)) l = f \\<and>\n        local.comp (pr0 (cod f) (cod g)) l = g\\<rbrakk>\n       \\<Longrightarrow> l = ?a f g", "fix f g"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f g.\n       span f g \\<Longrightarrow>\n       local.comp (pr1 (cod f) (cod g)) (?a f g) = f \\<and>\n       local.comp (pr0 (cod f) (cod g)) (?a f g) = g\n 2. \\<And>f g l.\n       \\<lbrakk>span f g;\n        local.comp (pr1 (cod f) (cod g)) l = f \\<and>\n        local.comp (pr0 (cod f) (cod g)) l = g\\<rbrakk>\n       \\<Longrightarrow> l = ?a f g", "assume fg: \"span f g\""], ["proof (state)\nthis:\n  span f g\n\ngoal (2 subgoals):\n 1. \\<And>f g.\n       span f g \\<Longrightarrow>\n       local.comp (pr1 (cod f) (cod g)) (?a f g) = f \\<and>\n       local.comp (pr0 (cod f) (cod g)) (?a f g) = g\n 2. \\<And>f g l.\n       \\<lbrakk>span f g;\n        local.comp (pr1 (cod f) (cod g)) l = f \\<and>\n        local.comp (pr0 (cod f) (cod g)) l = g\\<rbrakk>\n       \\<Longrightarrow> l = ?a f g", "show \"comp (pr1 (cod f) (cod g)) (tuple f g) = f \\<and>\n              comp (pr0 (cod f) (cod g)) (tuple f g) = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.comp (pr1 (cod f) (cod g)) (tuple f g) = f \\<and>\n    local.comp (pr0 (cod f) (cod g)) (tuple f g) = g", "using fg pr0_simps pr1_simps tuple_simps pr0_tuple pr1_tuple"], ["proof (prove)\nusing this:\n  span f g\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk> \\<Longrightarrow> arr (pr0 ?a ?b)\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> local.dom (pr0 ?a ?b) = local.prod ?a ?b\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk> \\<Longrightarrow> cod (pr0 ?a ?b) = ?b\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk> \\<Longrightarrow> arr (pr1 ?a ?b)\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> local.dom (pr1 ?a ?b) = local.prod ?a ?b\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk> \\<Longrightarrow> cod (pr1 ?a ?b) = ?a\n  span ?f ?g \\<Longrightarrow> arr (tuple ?f ?g)\n  span ?f ?g \\<Longrightarrow> local.dom (tuple ?f ?g) = local.dom ?f\n  span ?f ?g \\<Longrightarrow>\n  cod (tuple ?f ?g) = local.prod (cod ?f) (cod ?g)\n  span ?f ?g \\<Longrightarrow>\n  local.comp (pr0 (cod ?f) (cod ?g)) (tuple ?f ?g) = ?g\n  span ?f ?g \\<Longrightarrow>\n  local.comp (pr1 (cod ?f) (cod ?g)) (tuple ?f ?g) = ?f\n\ngoal (1 subgoal):\n 1. local.comp (pr1 (cod f) (cod g)) (tuple f g) = f \\<and>\n    local.comp (pr0 (cod f) (cod g)) (tuple f g) = g", "by presburger"], ["proof (state)\nthis:\n  local.comp (pr1 (cod f) (cod g)) (tuple f g) = f \\<and>\n  local.comp (pr0 (cod f) (cod g)) (tuple f g) = g\n\ngoal (1 subgoal):\n 1. \\<And>f g l.\n       \\<lbrakk>span f g;\n        local.comp (pr1 (cod f) (cod g)) l = f \\<and>\n        local.comp (pr0 (cod f) (cod g)) l = g\\<rbrakk>\n       \\<Longrightarrow> l = tuple f g", "show \"\\<And>l. \\<lbrakk>comp (pr1 (cod f) (cod g)) l = f \\<and> comp (pr0 (cod f) (cod g)) l = g\\<rbrakk>\n                      \\<Longrightarrow> l = tuple f g \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       local.comp (pr1 (cod f) (cod g)) l = f \\<and>\n       local.comp (pr0 (cod f) (cod g)) l = g \\<Longrightarrow>\n       l = tuple f g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l.\n       local.comp (pr1 (cod f) (cod g)) l = f \\<and>\n       local.comp (pr0 (cod f) (cod g)) l = g \\<Longrightarrow>\n       l = tuple f g", "fix l"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>l.\n       local.comp (pr1 (cod f) (cod g)) l = f \\<and>\n       local.comp (pr0 (cod f) (cod g)) l = g \\<Longrightarrow>\n       l = tuple f g", "assume l: \"comp (pr1 (cod f) (cod g)) l = f \\<and> comp (pr0 (cod f) (cod g)) l = g\""], ["proof (state)\nthis:\n  local.comp (pr1 (cod f) (cod g)) l = f \\<and>\n  local.comp (pr0 (cod f) (cod g)) l = g\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       local.comp (pr1 (cod f) (cod g)) l = f \\<and>\n       local.comp (pr0 (cod f) (cod g)) l = g \\<Longrightarrow>\n       l = tuple f g", "show \"l = tuple f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. l = tuple f g", "using fg l tuple_pr"], ["proof (prove)\nusing this:\n  span f g\n  local.comp (pr1 (cod f) (cod g)) l = f \\<and>\n  local.comp (pr0 (cod f) (cod g)) l = g\n  \\<lbrakk>ide ?a; ide ?b;\n   \\<guillemotleft>?h : local.dom\n                         ?h \\<rightarrow> local.prod ?a\n     ?b\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> tuple (local.comp (pr1 ?a ?b) ?h)\n                     (local.comp (pr0 ?a ?b) ?h) =\n                    ?h\n\ngoal (1 subgoal):\n 1. l = tuple f g", "by (metis (no_types, lifting) arr_iff_in_hom ide_cod seqE pr0_simps(2))"], ["proof (state)\nthis:\n  l = tuple f g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.comp (pr1 (cod f) (cod g)) ?l1 = f \\<and>\n  local.comp (pr0 (cod f) (cod g)) ?l1 = g \\<Longrightarrow>\n  ?l1 = tuple f g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  span ?f1 ?g1 \\<Longrightarrow>\n  \\<exists>!l.\n     local.comp (pr1 (cod ?f1) (cod ?g1)) l = ?f1 \\<and>\n     local.comp (pr0 (cod ?f1) (cod ?g1)) l = ?g1\n\ngoal (2 subgoals):\n 1. \\<And>a b. \\<not> (ide a \\<and> ide b) \\<Longrightarrow> pr0 a b = null\n 2. \\<And>a b. \\<not> (ide a \\<and> ide b) \\<Longrightarrow> pr1 a b = null", "show \"\\<And>a b. \\<not> (ide a \\<and> ide b) \\<Longrightarrow> pr0 a b = null\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b. \\<not> (ide a \\<and> ide b) \\<Longrightarrow> pr0 a b = null", "using pr0_def"], ["proof (prove)\nusing this:\n  pr0 ?a ?b =\n  (if ide ?a \\<and> ide ?b\n   then mkArr (local.set (local.prod ?a ?b)) (local.set ?b)\n         (\\<lambda>x. UP (hsnd (DOWN x)))\n   else null)\n\ngoal (1 subgoal):\n 1. \\<And>a b. \\<not> (ide a \\<and> ide b) \\<Longrightarrow> pr0 a b = null", "by auto"], ["proof (state)\nthis:\n  \\<not> (ide ?a1 \\<and> ide ?b1) \\<Longrightarrow> pr0 ?a1 ?b1 = null\n\ngoal (1 subgoal):\n 1. \\<And>a b. \\<not> (ide a \\<and> ide b) \\<Longrightarrow> pr1 a b = null", "show \"\\<And>a b. \\<not> (ide a \\<and> ide b) \\<Longrightarrow> pr1 a b = null\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b. \\<not> (ide a \\<and> ide b) \\<Longrightarrow> pr1 a b = null", "using pr1_def"], ["proof (prove)\nusing this:\n  pr1 ?a ?b =\n  (if ide ?a \\<and> ide ?b\n   then mkArr (local.set (local.prod ?a ?b)) (local.set ?a)\n         (\\<lambda>x. UP (hfst (DOWN x)))\n   else null)\n\ngoal (1 subgoal):\n 1. \\<And>a b. \\<not> (ide a \\<and> ide b) \\<Longrightarrow> pr1 a b = null", "by auto"], ["proof (state)\nthis:\n  \\<not> (ide ?a1 \\<and> ide ?b1) \\<Longrightarrow> pr1 ?a1 ?b1 = null\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n      For reasons of economy of locale parameters, the notion \\<open>prod\\<close> is a defined notion\n      of the @{locale elementary_category_with_binary_products} locale.\n      However, we need to be able to relate this notion to that of cartesian product of\n      hereditarily finite sets, which we have already used to give a definition of \\<open>prod\\<close>.\n      The locale assumptions for @{locale elementary_cartesian_closed_category} refer\n      specifically to \\<open>HF'.prod\\<close>, even though in the end the notion itself does not depend\n      on that choice.  To be able to show that the locale assumptions of\n      @{locale elementary_cartesian_closed_category} are satisfied, we need to use a choice\n      of products that we can relate to the cartesian product of hereditarily\n      finite sets.  We therefore need to show that our previously defined \\<open>prod\\<close> coincides\n      (on objects) with the one defined in the @{locale elementary_category_with_binary_products} locale;\n      \\emph{i.e.}~\\<open>HF'.prod\\<close>.  Note that the latter is defined for all arrows,\n      not just identity arrows, so we need to use that for the subsequent definitions and proofs.\n    \\<close>"], ["", "lemma prod_ide_eq:\n    assumes \"ide a\" and \"ide b\"\n    shows \"prod a b = HF'.prod a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.prod a b = HF'.prod a b", "using assms prod_def HF'.pr_simps(2) HF'.prod_def pr0_simps(2)"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  local.prod ?a ?b = hf_to_ide (ide_to_hf ?a * ide_to_hf ?b)\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> local.dom (pr0 ?a ?b) = HF'.prod ?a ?b\n  HF'.prod ?f ?g \\<equiv>\n  HF'.tuple (local.comp ?f (pr1 (local.dom ?f) (local.dom ?g)))\n   (local.comp ?g (pr0 (local.dom ?f) (local.dom ?g)))\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> local.dom (pr0 ?a ?b) = local.prod ?a ?b\n\ngoal (1 subgoal):\n 1. local.prod a b = HF'.prod a b", "by presburger"], ["", "lemma tuple_span_eq:\n    assumes \"span f g\"\n    shows \"tuple f g = HF'.tuple f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tuple f g = HF'.tuple f g", "using assms tuple_def HF'.tuple_def"], ["proof (prove)\nusing this:\n  span f g\n  tuple ?f ?g =\n  mkArr (Dom ?f) (local.set (local.prod (cod ?f) (cod ?g)))\n   (\\<lambda>x. UP \\<langle>DOWN (Fun ?f x), DOWN (Fun ?g x)\\<rangle>)\n  HF'.tuple ?f ?g \\<equiv>\n  if span ?f ?g\n  then THE l.\n          local.comp (pr1 (cod ?f) (cod ?g)) l = ?f \\<and>\n          local.comp (pr0 (cod ?f) (cod ?g)) l = ?g\n  else null\n\ngoal (1 subgoal):\n 1. tuple f g = HF'.tuple f g", "by (metis (no_types, lifting) HF'.tuple_eqI pr0_tuple pr1_tuple)"], ["", "section \"Exponentials\""], ["", "text\\<open>\n      We now turn our attention to exponentials.\n    \\<close>"], ["", "definition exp\n    where \"exp b c = hf_to_ide (hexp (ide_to_hf b) (ide_to_hf c))\""], ["", "definition eval\n    where \"eval b c = mkArr (set (HF'.prod (exp b c) b)) (set c)\n                            (\\<lambda>x. UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))\""], ["", "definition \\<Lambda>\n    where \"\\<Lambda> a b c f = mkArr (set a) (set (exp b c))\n                             (\\<lambda>x. UP (happ (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n                                                 (arr_to_hfun f))\n                                           (DOWN x)))\""], ["", "lemma ide_exp:\n    assumes \"ide b\" and \"ide c\"\n    shows \"ide (exp b c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide (exp b c)", "using assms exp_def hf_to_ide_mapsto ide_to_hf_mapsto"], ["proof (prove)\nusing this:\n  ide b\n  ide c\n  exp ?b ?c = hf_to_ide (hexp (ide_to_hf ?b) (ide_to_hf ?c))\n  hf_to_ide \\<in> UNIV \\<rightarrow> Collect ide\n  ide_to_hf \\<in> Collect ide \\<rightarrow> UNIV\n\ngoal (1 subgoal):\n 1. ide (exp b c)", "by auto"], ["", "lemma hfset_ide_to_hf:\n    assumes \"ide a\"\n    shows \"hfset (ide_to_hf a) = DOWN ` set a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hfset (ide_to_hf a) = DOWN ` local.set a", "using assms ide_to_hf_def ide_implies_finite_set(1)"], ["proof (prove)\nusing this:\n  ide a\n  ide_to_hf ?a = HF (DOWN ` local.set ?a)\n  ide ?a \\<Longrightarrow> finite (local.set ?a)\n\ngoal (1 subgoal):\n 1. hfset (ide_to_hf a) = DOWN ` local.set a", "by auto"], ["", "lemma eval_in_hom [intro]:\n    assumes \"ide b\" and \"ide c\"\n    shows \"in_hom (eval b c) (HF'.prod (exp b c) b) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>eval b\n                     c : HF'.prod (exp b c)\n                          b \\<rightarrow> c\\<guillemotright>", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. arr (eval b c)\n 2. local.dom (eval b c) = HF'.prod (exp b c) b\n 3. cod (eval b c) = c", "show 1: \"arr (eval b c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (eval b c)", "proof (unfold eval_def arr_mkArr, intro conjI)"], ["proof (state)\ngoal (5 subgoals):\n 1. local.set (HF'.prod (exp b c) b) \\<subseteq> Univ\n 2. |local.set (HF'.prod (exp b c) b)| <o natLeq\n 3. local.set c \\<subseteq> Univ\n 4. |local.set c| <o natLeq\n 5. (\\<lambda>x. UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))\n    \\<in> local.set (HF'.prod (exp b c) b) \\<rightarrow> local.set c", "show \"set (HF'.prod (exp b c) b) \\<subseteq> Univ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.set (HF'.prod (exp b c) b) \\<subseteq> Univ", "using assms ide_char HF'.ide_prod ide_exp set_subset_Univ"], ["proof (prove)\nusing this:\n  ide b\n  ide c\n  arr ?f \\<Longrightarrow>\n  ide ?f =\n  (Dom ?f = Cod ?f \\<and> Fun ?f = (\\<lambda>x\\<^bold>\\<in>Dom ?f. x))\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk> \\<Longrightarrow> ide (HF'.prod ?a ?b)\n  \\<lbrakk>ide ?b; ide ?c\\<rbrakk> \\<Longrightarrow> ide (exp ?b ?c)\n  ide ?a \\<Longrightarrow> local.set ?a \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. local.set (HF'.prod (exp b c) b) \\<subseteq> Univ", "by simp"], ["proof (state)\nthis:\n  local.set (HF'.prod (exp b c) b) \\<subseteq> Univ\n\ngoal (4 subgoals):\n 1. |local.set (HF'.prod (exp b c) b)| <o natLeq\n 2. local.set c \\<subseteq> Univ\n 3. |local.set c| <o natLeq\n 4. (\\<lambda>x. UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))\n    \\<in> local.set (HF'.prod (exp b c) b) \\<rightarrow> local.set c", "show \"set c \\<subseteq> Univ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.set c \\<subseteq> Univ", "using assms ide_char set_subset_Univ"], ["proof (prove)\nusing this:\n  ide b\n  ide c\n  arr ?f \\<Longrightarrow>\n  ide ?f =\n  (Dom ?f = Cod ?f \\<and> Fun ?f = (\\<lambda>x\\<^bold>\\<in>Dom ?f. x))\n  ide ?a \\<Longrightarrow> local.set ?a \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. local.set c \\<subseteq> Univ", "by simp"], ["proof (state)\nthis:\n  local.set c \\<subseteq> Univ\n\ngoal (3 subgoals):\n 1. |local.set (HF'.prod (exp b c) b)| <o natLeq\n 2. |local.set c| <o natLeq\n 3. (\\<lambda>x. UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))\n    \\<in> local.set (HF'.prod (exp b c) b) \\<rightarrow> local.set c", "show \"(\\<lambda>x. UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))\n                 \\<in> set (HF'.prod (exp b c) b) \\<rightarrow> set c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))\n    \\<in> local.set (HF'.prod (exp b c) b) \\<rightarrow> local.set c", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> local.set (HF'.prod (exp b c) b) \\<Longrightarrow>\n       UP (happ (hfst (DOWN x)) (hsnd (DOWN x))) \\<in> local.set c", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> local.set (HF'.prod (exp b c) b) \\<Longrightarrow>\n       UP (happ (hfst (DOWN x)) (hsnd (DOWN x))) \\<in> local.set c", "assume \"x \\<in> set (HF'.prod (exp b c) b)\""], ["proof (state)\nthis:\n  x \\<in> local.set (HF'.prod (exp b c) b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> local.set (HF'.prod (exp b c) b) \\<Longrightarrow>\n       UP (happ (hfst (DOWN x)) (hsnd (DOWN x))) \\<in> local.set c", "hence x: \"x \\<in> set (prod (exp b c) b)\""], ["proof (prove)\nusing this:\n  x \\<in> local.set (HF'.prod (exp b c) b)\n\ngoal (1 subgoal):\n 1. x \\<in> local.set (local.prod (exp b c) b)", "using assms prod_ide_eq ide_exp"], ["proof (prove)\nusing this:\n  x \\<in> local.set (HF'.prod (exp b c) b)\n  ide b\n  ide c\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> local.prod ?a ?b = HF'.prod ?a ?b\n  \\<lbrakk>ide ?b; ide ?c\\<rbrakk> \\<Longrightarrow> ide (exp ?b ?c)\n\ngoal (1 subgoal):\n 1. x \\<in> local.set (local.prod (exp b c) b)", "by auto"], ["proof (state)\nthis:\n  x \\<in> local.set (local.prod (exp b c) b)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> local.set (HF'.prod (exp b c) b) \\<Longrightarrow>\n       UP (happ (hfst (DOWN x)) (hsnd (DOWN x))) \\<in> local.set c", "show \"UP (happ (hfst (DOWN x)) (hsnd (DOWN x))) \\<in> set c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP (happ (hfst (DOWN x)) (hsnd (DOWN x))) \\<in> local.set c", "proof (intro UP_membI)"], ["proof (state)\ngoal (1 subgoal):\n 1. happ (hfst (DOWN x)) (hsnd (DOWN x)) \\<^bold>\\<in> ide_to_hf c", "show \"happ (hfst (DOWN x)) (hsnd (DOWN x)) \\<^bold>\\<in> ide_to_hf c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. happ (hfst (DOWN x)) (hsnd (DOWN x)) \\<^bold>\\<in> ide_to_hf c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. happ (hfst (DOWN x)) (hsnd (DOWN x)) \\<^bold>\\<in> ide_to_hf c", "have 1: \"DOWN x \\<^bold>\\<in> ide_to_hf (exp b c) * ide_to_hf b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DOWN x \\<^bold>\\<in> ide_to_hf (exp b c) * ide_to_hf b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. DOWN x \\<^bold>\\<in> ide_to_hf (exp b c) * ide_to_hf b", "have \"DOWN x \\<^bold>\\<in> ide_to_hf (prod (exp b c) b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DOWN x \\<^bold>\\<in> ide_to_hf (local.prod (exp b c) b)", "using assms x DOWN_membI ide_prod ide_exp"], ["proof (prove)\nusing this:\n  ide b\n  ide c\n  x \\<in> local.set (local.prod (exp b c) b)\n  \\<lbrakk>ide ?a; ?x \\<in> local.set ?a\\<rbrakk>\n  \\<Longrightarrow> DOWN ?x \\<^bold>\\<in> ide_to_hf ?a\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk> \\<Longrightarrow> ide (local.prod ?a ?b)\n  \\<lbrakk>ide ?b; ide ?c\\<rbrakk> \\<Longrightarrow> ide (exp ?b ?c)\n\ngoal (1 subgoal):\n 1. DOWN x \\<^bold>\\<in> ide_to_hf (local.prod (exp b c) b)", "by simp"], ["proof (state)\nthis:\n  DOWN x \\<^bold>\\<in> ide_to_hf (local.prod (exp b c) b)\n\ngoal (1 subgoal):\n 1. DOWN x \\<^bold>\\<in> ide_to_hf (exp b c) * ide_to_hf b", "thus ?thesis"], ["proof (prove)\nusing this:\n  DOWN x \\<^bold>\\<in> ide_to_hf (local.prod (exp b c) b)\n\ngoal (1 subgoal):\n 1. DOWN x \\<^bold>\\<in> ide_to_hf (exp b c) * ide_to_hf b", "using assms x prod_def ide_to_hf_hf_to_ide"], ["proof (prove)\nusing this:\n  DOWN x \\<^bold>\\<in> ide_to_hf (local.prod (exp b c) b)\n  ide b\n  ide c\n  x \\<in> local.set (local.prod (exp b c) b)\n  local.prod ?a ?b = hf_to_ide (ide_to_hf ?a * ide_to_hf ?b)\n  ?x \\<in> UNIV \\<Longrightarrow> ide_to_hf (hf_to_ide ?x) = ?x\n\ngoal (1 subgoal):\n 1. DOWN x \\<^bold>\\<in> ide_to_hf (exp b c) * ide_to_hf b", "by auto"], ["proof (state)\nthis:\n  DOWN x \\<^bold>\\<in> ide_to_hf (exp b c) * ide_to_hf b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  DOWN x \\<^bold>\\<in> ide_to_hf (exp b c) * ide_to_hf b\n\ngoal (1 subgoal):\n 1. happ (hfst (DOWN x)) (hsnd (DOWN x)) \\<^bold>\\<in> ide_to_hf c", "have \"hfst (DOWN x) \\<^bold>\\<in> hexp (ide_to_hf b) (ide_to_hf c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hfst (DOWN x) \\<^bold>\\<in> hexp (ide_to_hf b) (ide_to_hf c)", "using assms 1 x exp_def ide_to_hf_hf_to_ide"], ["proof (prove)\nusing this:\n  ide b\n  ide c\n  DOWN x \\<^bold>\\<in> ide_to_hf (exp b c) * ide_to_hf b\n  x \\<in> local.set (local.prod (exp b c) b)\n  exp ?b ?c = hf_to_ide (hexp (ide_to_hf ?b) (ide_to_hf ?c))\n  ?x \\<in> UNIV \\<Longrightarrow> ide_to_hf (hf_to_ide ?x) = ?x\n\ngoal (1 subgoal):\n 1. hfst (DOWN x) \\<^bold>\\<in> hexp (ide_to_hf b) (ide_to_hf c)", "by auto"], ["proof (state)\nthis:\n  hfst (DOWN x) \\<^bold>\\<in> hexp (ide_to_hf b) (ide_to_hf c)\n\ngoal (1 subgoal):\n 1. happ (hfst (DOWN x)) (hsnd (DOWN x)) \\<^bold>\\<in> ide_to_hf c", "moreover"], ["proof (state)\nthis:\n  hfst (DOWN x) \\<^bold>\\<in> hexp (ide_to_hf b) (ide_to_hf c)\n\ngoal (1 subgoal):\n 1. happ (hfst (DOWN x)) (hsnd (DOWN x)) \\<^bold>\\<in> ide_to_hf c", "have \"hsnd (DOWN x) \\<^bold>\\<in> ide_to_hf b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hsnd (DOWN x) \\<^bold>\\<in> ide_to_hf b", "using assms 1"], ["proof (prove)\nusing this:\n  ide b\n  ide c\n  DOWN x \\<^bold>\\<in> ide_to_hf (exp b c) * ide_to_hf b\n\ngoal (1 subgoal):\n 1. hsnd (DOWN x) \\<^bold>\\<in> ide_to_hf b", "by auto"], ["proof (state)\nthis:\n  hsnd (DOWN x) \\<^bold>\\<in> ide_to_hf b\n\ngoal (1 subgoal):\n 1. happ (hfst (DOWN x)) (hsnd (DOWN x)) \\<^bold>\\<in> ide_to_hf c", "ultimately"], ["proof (chain)\npicking this:\n  hfst (DOWN x) \\<^bold>\\<in> hexp (ide_to_hf b) (ide_to_hf c)\n  hsnd (DOWN x) \\<^bold>\\<in> ide_to_hf b", "show ?thesis"], ["proof (prove)\nusing this:\n  hfst (DOWN x) \\<^bold>\\<in> hexp (ide_to_hf b) (ide_to_hf c)\n  hsnd (DOWN x) \\<^bold>\\<in> ide_to_hf b\n\ngoal (1 subgoal):\n 1. happ (hfst (DOWN x)) (hsnd (DOWN x)) \\<^bold>\\<in> ide_to_hf c", "using happ_mapsto [of \"hfst (DOWN x)\" \"ide_to_hf b\" \"ide_to_hf c\"\n                                      \"hsnd (DOWN x)\"]"], ["proof (prove)\nusing this:\n  hfst (DOWN x) \\<^bold>\\<in> hexp (ide_to_hf b) (ide_to_hf c)\n  hsnd (DOWN x) \\<^bold>\\<in> ide_to_hf b\n  \\<lbrakk>hfst (DOWN x) \\<^bold>\\<in> hexp (ide_to_hf b) (ide_to_hf c);\n   hsnd (DOWN x) \\<^bold>\\<in> ide_to_hf b\\<rbrakk>\n  \\<Longrightarrow> happ (hfst (DOWN x)) (hsnd (DOWN x)) \\<^bold>\\<in>\n                    ide_to_hf c\n  \\<lbrakk>hfst (DOWN x) \\<^bold>\\<in> hexp (ide_to_hf b) (ide_to_hf c);\n   hsnd (DOWN x) \\<^bold>\\<in> ide_to_hf b\\<rbrakk>\n  \\<Longrightarrow> happ (hfst (DOWN x)) (hsnd (DOWN x)) \\<^bold>\\<in>\n                    hrange (hfst (DOWN x))\n\ngoal (1 subgoal):\n 1. happ (hfst (DOWN x)) (hsnd (DOWN x)) \\<^bold>\\<in> ide_to_hf c", "by simp"], ["proof (state)\nthis:\n  happ (hfst (DOWN x)) (hsnd (DOWN x)) \\<^bold>\\<in> ide_to_hf c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  happ (hfst (DOWN x)) (hsnd (DOWN x)) \\<^bold>\\<in> ide_to_hf c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  UP (happ (hfst (DOWN x)) (hsnd (DOWN x))) \\<in> local.set c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>x. UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))\n  \\<in> local.set (HF'.prod (exp b c) b) \\<rightarrow> local.set c\n\ngoal (2 subgoals):\n 1. |local.set (HF'.prod (exp b c) b)| <o natLeq\n 2. |local.set c| <o natLeq", "show \"|set (HF'.prod (exp b c) b)| <o natLeq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |local.set (HF'.prod (exp b c) b)| <o natLeq", "using assms ide_exp HF'.ide_prod set_card"], ["proof (prove)\nusing this:\n  ide b\n  ide c\n  \\<lbrakk>ide ?b; ide ?c\\<rbrakk> \\<Longrightarrow> ide (exp ?b ?c)\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk> \\<Longrightarrow> ide (HF'.prod ?a ?b)\n  ide ?a \\<Longrightarrow> |local.set ?a| <o natLeq\n\ngoal (1 subgoal):\n 1. |local.set (HF'.prod (exp b c) b)| <o natLeq", "by auto"], ["proof (state)\nthis:\n  |local.set (HF'.prod (exp b c) b)| <o natLeq\n\ngoal (1 subgoal):\n 1. |local.set c| <o natLeq", "show \"|set c| <o natLeq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |local.set c| <o natLeq", "using assms set_card"], ["proof (prove)\nusing this:\n  ide b\n  ide c\n  ide ?a \\<Longrightarrow> |local.set ?a| <o natLeq\n\ngoal (1 subgoal):\n 1. |local.set c| <o natLeq", "by auto"], ["proof (state)\nthis:\n  |local.set c| <o natLeq\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  arr (eval b c)\n\ngoal (2 subgoals):\n 1. local.dom (eval b c) = HF'.prod (exp b c) b\n 2. cod (eval b c) = c", "show \"dom (eval b c) = HF'.prod (exp b c) b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dom (eval b c) = HF'.prod (exp b c) b", "using assms 1 ide_char HF'.ide_prod ide_exp dom_mkArr eval_def"], ["proof (prove)\nusing this:\n  ide b\n  ide c\n  arr (eval b c)\n  arr ?f \\<Longrightarrow>\n  ide ?f =\n  (Dom ?f = Cod ?f \\<and> Fun ?f = (\\<lambda>x\\<^bold>\\<in>Dom ?f. x))\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk> \\<Longrightarrow> ide (HF'.prod ?a ?b)\n  \\<lbrakk>ide ?b; ide ?c\\<rbrakk> \\<Longrightarrow> ide (exp ?b ?c)\n  arr (mkArr ?A ?B ?F) \\<Longrightarrow>\n  local.dom (mkArr ?A ?B ?F) = mkIde ?A\n  eval ?b ?c =\n  mkArr (local.set (HF'.prod (exp ?b ?c) ?b)) (local.set ?c)\n   (\\<lambda>x. UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))\n\ngoal (1 subgoal):\n 1. local.dom (eval b c) = HF'.prod (exp b c) b", "by (metis (no_types, lifting) mkIde_set)"], ["proof (state)\nthis:\n  local.dom (eval b c) = HF'.prod (exp b c) b\n\ngoal (1 subgoal):\n 1. cod (eval b c) = c", "show \"cod (eval b c) = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cod (eval b c) = c", "using assms 1 ide_char cod_mkArr eval_def"], ["proof (prove)\nusing this:\n  ide b\n  ide c\n  arr (eval b c)\n  arr ?f \\<Longrightarrow>\n  ide ?f =\n  (Dom ?f = Cod ?f \\<and> Fun ?f = (\\<lambda>x\\<^bold>\\<in>Dom ?f. x))\n  arr (mkArr ?A ?B ?F) \\<Longrightarrow> cod (mkArr ?A ?B ?F) = mkIde ?B\n  eval ?b ?c =\n  mkArr (local.set (HF'.prod (exp ?b ?c) ?b)) (local.set ?c)\n   (\\<lambda>x. UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))\n\ngoal (1 subgoal):\n 1. cod (eval b c) = c", "by (metis (no_types, lifting) mkIde_set)"], ["proof (state)\nthis:\n  cod (eval b c) = c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma eval_simps [simp]:\n    assumes \"ide b\" and \"ide c\"\n    shows \"arr (eval b c)\"\n    and \"dom (eval b c) = HF'.prod (exp b c) b\"\n    and \"cod (eval b c) = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (eval b c) &&&\n    local.dom (eval b c) = HF'.prod (exp b c) b &&& cod (eval b c) = c", "using assms eval_in_hom"], ["proof (prove)\nusing this:\n  ide b\n  ide c\n  \\<lbrakk>ide ?b; ide ?c\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>eval ?b\n                                     ?c : HF'.prod (exp ?b ?c)\n     ?b \\<rightarrow> ?c\\<guillemotright>\n\ngoal (1 subgoal):\n 1. arr (eval b c) &&&\n    local.dom (eval b c) = HF'.prod (exp b c) b &&& cod (eval b c) = c", "by blast+"], ["", "lemma hlam_arr_to_hfun_in_hexp:\n    assumes \"ide a\" and \"ide b\" and \"ide c\"\n    and \"in_hom f (prod a b) c\"\n    shows \"hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun f)\n             \\<^bold>\\<in> hexp (ide_to_hf a) (ide_to_hf (exp b c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n     (arr_to_hfun f) \\<^bold>\\<in>\n    hexp (ide_to_hf a) (ide_to_hf (exp b c))", "using assms hfun_in_hexp hfun_hlam"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>f : local.prod a b \\<rightarrow> c\\<guillemotright>\n  hfun ?B ?C ?F \\<Longrightarrow> ?F \\<^bold>\\<in> hexp ?B ?C\n  hfun (?A * ?B) ?C ?F \\<Longrightarrow>\n  hfun ?A (hexp ?B ?C) (hlam ?A ?B ?C ?F)\n\ngoal (1 subgoal):\n 1. hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n     (arr_to_hfun f) \\<^bold>\\<in>\n    hexp (ide_to_hf a) (ide_to_hf (exp b c))", "by (metis (no_types, lifting) prod_def HCollect_iff in_homE UNIV_I\n          arr_to_hfun_in_hexp exp_def hexp_def ide_to_hf_hf_to_ide)"], ["", "lemma lam_in_hom [intro]:\n    assumes \"ide a\" and \"ide b\" and \"ide c\"\n    and \"in_hom f (prod a b) c\"\n    shows \"in_hom (\\<Lambda> a b c f) a (exp b c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<Lambda> a b c\n                     f : a \\<rightarrow> exp b c\\<guillemotright>", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. arr (\\<Lambda> a b c f)\n 2. local.dom (\\<Lambda> a b c f) = a\n 3. cod (\\<Lambda> a b c f) = exp b c", "show 1: \"arr (\\<Lambda> a b c f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (\\<Lambda> a b c f)", "proof (unfold \\<Lambda>_def arr_mkArr, intro conjI)"], ["proof (state)\ngoal (5 subgoals):\n 1. local.set a \\<subseteq> Univ\n 2. |local.set a| <o natLeq\n 3. local.set (exp b c) \\<subseteq> Univ\n 4. |local.set (exp b c)| <o natLeq\n 5. (\\<lambda>x.\n        UP (happ\n             (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n               (arr_to_hfun f))\n             (DOWN x)))\n    \\<in> local.set a \\<rightarrow> local.set (exp b c)", "show \"set a \\<subseteq> Univ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.set a \\<subseteq> Univ", "using assms(1) set_subset_Univ ide_char"], ["proof (prove)\nusing this:\n  ide a\n  ide ?a \\<Longrightarrow> local.set ?a \\<subseteq> Univ\n  arr ?f \\<Longrightarrow>\n  ide ?f =\n  (Dom ?f = Cod ?f \\<and> Fun ?f = (\\<lambda>x\\<^bold>\\<in>Dom ?f. x))\n\ngoal (1 subgoal):\n 1. local.set a \\<subseteq> Univ", "by blast"], ["proof (state)\nthis:\n  local.set a \\<subseteq> Univ\n\ngoal (4 subgoals):\n 1. |local.set a| <o natLeq\n 2. local.set (exp b c) \\<subseteq> Univ\n 3. |local.set (exp b c)| <o natLeq\n 4. (\\<lambda>x.\n        UP (happ\n             (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n               (arr_to_hfun f))\n             (DOWN x)))\n    \\<in> local.set a \\<rightarrow> local.set (exp b c)", "show \"set (exp b c) \\<subseteq> Univ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.set (exp b c) \\<subseteq> Univ", "using assms(2-3) set_subset_Univ ide_exp ide_char"], ["proof (prove)\nusing this:\n  ide b\n  ide c\n  ide ?a \\<Longrightarrow> local.set ?a \\<subseteq> Univ\n  \\<lbrakk>ide ?b; ide ?c\\<rbrakk> \\<Longrightarrow> ide (exp ?b ?c)\n  arr ?f \\<Longrightarrow>\n  ide ?f =\n  (Dom ?f = Cod ?f \\<and> Fun ?f = (\\<lambda>x\\<^bold>\\<in>Dom ?f. x))\n\ngoal (1 subgoal):\n 1. local.set (exp b c) \\<subseteq> Univ", "by simp"], ["proof (state)\nthis:\n  local.set (exp b c) \\<subseteq> Univ\n\ngoal (3 subgoals):\n 1. |local.set a| <o natLeq\n 2. |local.set (exp b c)| <o natLeq\n 3. (\\<lambda>x.\n        UP (happ\n             (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n               (arr_to_hfun f))\n             (DOWN x)))\n    \\<in> local.set a \\<rightarrow> local.set (exp b c)", "show \"|set a| <o natLeq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |local.set a| <o natLeq", "using assms(1) set_card"], ["proof (prove)\nusing this:\n  ide a\n  ide ?a \\<Longrightarrow> |local.set ?a| <o natLeq\n\ngoal (1 subgoal):\n 1. |local.set a| <o natLeq", "by simp"], ["proof (state)\nthis:\n  |local.set a| <o natLeq\n\ngoal (2 subgoals):\n 1. |local.set (exp b c)| <o natLeq\n 2. (\\<lambda>x.\n        UP (happ\n             (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n               (arr_to_hfun f))\n             (DOWN x)))\n    \\<in> local.set a \\<rightarrow> local.set (exp b c)", "show \"|set (exp b c)| <o natLeq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |local.set (exp b c)| <o natLeq", "using assms(2-3) set_card ide_exp"], ["proof (prove)\nusing this:\n  ide b\n  ide c\n  ide ?a \\<Longrightarrow> |local.set ?a| <o natLeq\n  \\<lbrakk>ide ?b; ide ?c\\<rbrakk> \\<Longrightarrow> ide (exp ?b ?c)\n\ngoal (1 subgoal):\n 1. |local.set (exp b c)| <o natLeq", "by auto"], ["proof (state)\nthis:\n  |local.set (exp b c)| <o natLeq\n\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        UP (happ\n             (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n               (arr_to_hfun f))\n             (DOWN x)))\n    \\<in> local.set a \\<rightarrow> local.set (exp b c)", "show \"(\\<lambda>x. UP (happ (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun f))\n                            (DOWN x)))\n                 \\<in> set a \\<rightarrow> set (exp b c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x.\n        UP (happ\n             (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n               (arr_to_hfun f))\n             (DOWN x)))\n    \\<in> local.set a \\<rightarrow> local.set (exp b c)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> local.set a \\<Longrightarrow>\n       UP (happ\n            (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun f))\n            (DOWN x))\n       \\<in> local.set (exp b c)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> local.set a \\<Longrightarrow>\n       UP (happ\n            (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun f))\n            (DOWN x))\n       \\<in> local.set (exp b c)", "assume x: \"x \\<in> set a\""], ["proof (state)\nthis:\n  x \\<in> local.set a\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> local.set a \\<Longrightarrow>\n       UP (happ\n            (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun f))\n            (DOWN x))\n       \\<in> local.set (exp b c)", "show \"UP (happ (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun f))\n                         (DOWN x))\n                     \\<in> set (exp b c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP (happ\n         (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun f))\n         (DOWN x))\n    \\<in> local.set (exp b c)", "using assms x hlam_arr_to_hfun_in_hexp ide_to_hf_def DOWN_membI happ_mapsto\n                  UP_membI"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>f : local.prod a b \\<rightarrow> c\\<guillemotright>\n  x \\<in> local.set a\n  \\<lbrakk>ide ?a; ide ?b; ide ?c;\n   \\<guillemotleft>?f : local.prod ?a\n                         ?b \\<rightarrow> ?c\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> hlam (ide_to_hf ?a) (ide_to_hf ?b) (ide_to_hf ?c)\n                     (arr_to_hfun ?f) \\<^bold>\\<in>\n                    hexp (ide_to_hf ?a) (ide_to_hf (exp ?b ?c))\n  ide_to_hf ?a = HF (DOWN ` local.set ?a)\n  \\<lbrakk>ide ?a; ?x \\<in> local.set ?a\\<rbrakk>\n  \\<Longrightarrow> DOWN ?x \\<^bold>\\<in> ide_to_hf ?a\n  \\<lbrakk>?F \\<^bold>\\<in> hexp ?B ?C; ?Y \\<^bold>\\<in> ?B\\<rbrakk>\n  \\<Longrightarrow> happ ?F ?Y \\<^bold>\\<in> ?C\n  \\<lbrakk>?F \\<^bold>\\<in> hexp ?B ?C; ?Y \\<^bold>\\<in> ?B\\<rbrakk>\n  \\<Longrightarrow> happ ?F ?Y \\<^bold>\\<in> hrange ?F\n  ?x \\<^bold>\\<in> ide_to_hf ?a \\<Longrightarrow> UP ?x \\<in> local.set ?a\n\ngoal (1 subgoal):\n 1. UP (happ\n         (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun f))\n         (DOWN x))\n    \\<in> local.set (exp b c)", "by meson"], ["proof (state)\nthis:\n  UP (happ (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun f))\n       (DOWN x))\n  \\<in> local.set (exp b c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>x.\n      UP (happ\n           (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun f))\n           (DOWN x)))\n  \\<in> local.set a \\<rightarrow> local.set (exp b c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  arr (\\<Lambda> a b c f)\n\ngoal (2 subgoals):\n 1. local.dom (\\<Lambda> a b c f) = a\n 2. cod (\\<Lambda> a b c f) = exp b c", "show \"dom (\\<Lambda> a b c f) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dom (\\<Lambda> a b c f) = a", "using assms(1) 1 \\<Lambda>_def ide_char dom_mkArr mkIde_set"], ["proof (prove)\nusing this:\n  ide a\n  arr (\\<Lambda> a b c f)\n  \\<Lambda> ?a ?b ?c ?f =\n  mkArr (local.set ?a) (local.set (exp ?b ?c))\n   (\\<lambda>x.\n       UP (happ\n            (hlam (ide_to_hf ?a) (ide_to_hf ?b) (ide_to_hf ?c)\n              (arr_to_hfun ?f))\n            (DOWN x)))\n  arr ?f \\<Longrightarrow>\n  ide ?f =\n  (Dom ?f = Cod ?f \\<and> Fun ?f = (\\<lambda>x\\<^bold>\\<in>Dom ?f. x))\n  arr (mkArr ?A ?B ?F) \\<Longrightarrow>\n  local.dom (mkArr ?A ?B ?F) = mkIde ?A\n  ide ?a \\<Longrightarrow> mkIde (local.set ?a) = ?a\n\ngoal (1 subgoal):\n 1. local.dom (\\<Lambda> a b c f) = a", "by auto"], ["proof (state)\nthis:\n  local.dom (\\<Lambda> a b c f) = a\n\ngoal (1 subgoal):\n 1. cod (\\<Lambda> a b c f) = exp b c", "show \"cod (\\<Lambda> a b c f) = exp b c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cod (\\<Lambda> a b c f) = exp b c", "using assms(2-3) 1 \\<Lambda>_def cod_mkArr ide_exp mkIde_set"], ["proof (prove)\nusing this:\n  ide b\n  ide c\n  arr (\\<Lambda> a b c f)\n  \\<Lambda> ?a ?b ?c ?f =\n  mkArr (local.set ?a) (local.set (exp ?b ?c))\n   (\\<lambda>x.\n       UP (happ\n            (hlam (ide_to_hf ?a) (ide_to_hf ?b) (ide_to_hf ?c)\n              (arr_to_hfun ?f))\n            (DOWN x)))\n  arr (mkArr ?A ?B ?F) \\<Longrightarrow> cod (mkArr ?A ?B ?F) = mkIde ?B\n  \\<lbrakk>ide ?b; ide ?c\\<rbrakk> \\<Longrightarrow> ide (exp ?b ?c)\n  ide ?a \\<Longrightarrow> mkIde (local.set ?a) = ?a\n\ngoal (1 subgoal):\n 1. cod (\\<Lambda> a b c f) = exp b c", "by auto"], ["proof (state)\nthis:\n  cod (\\<Lambda> a b c f) = exp b c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lam_simps [simp]:\n    assumes \"ide a\" and \"ide b\" and \"ide c\"\n    and \"in_hom f (prod a b) c\"\n    shows \"arr (\\<Lambda> a b c f)\"\n    and \"dom (\\<Lambda> a b c f) = a\"\n    and \"cod (\\<Lambda> a b c f) = exp b c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (\\<Lambda> a b c f) &&&\n    local.dom (\\<Lambda> a b c f) = a &&& cod (\\<Lambda> a b c f) = exp b c", "using assms lam_in_hom"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>f : local.prod a b \\<rightarrow> c\\<guillemotright>\n  \\<lbrakk>ide ?a; ide ?b; ide ?c;\n   \\<guillemotleft>?f : local.prod ?a\n                         ?b \\<rightarrow> ?c\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>\\<Lambda> ?a ?b ?c\n                                     ?f : ?a \\<rightarrow> exp ?b\n                      ?c\\<guillemotright>\n\ngoal (1 subgoal):\n 1. arr (\\<Lambda> a b c f) &&&\n    local.dom (\\<Lambda> a b c f) = a &&& cod (\\<Lambda> a b c f) = exp b c", "by blast+"], ["", "lemma Fun_lam:\n    assumes \"ide a\" and \"ide b\" and \"ide c\"\n    and \"in_hom f (prod a b) c\"\n    shows \"Fun (\\<Lambda> a b c f) =\n           restrict (\\<lambda>x. UP (happ (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun f))\n                                  (DOWN x)))\n                    (set a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (\\<Lambda> a b c f) =\n    (\\<lambda>x\\<^bold>\\<in>local.set a.\n        UP (happ\n             (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n               (arr_to_hfun f))\n             (DOWN x)))", "using assms arr_char lam_simps(1) \\<Lambda>_def Fun_mkArr"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>f : local.prod a b \\<rightarrow> c\\<guillemotright>\n  arr ?f =\n  (?f \\<noteq> concrete_category.Null \\<and>\n   |concrete_category.Dom ?f| <o natLeq \\<and>\n   |concrete_category.Cod ?f| <o natLeq \\<and>\n   concrete_category.Map ?f\n   \\<in> extensional (concrete_category.Dom ?f) \\<inter>\n         (concrete_category.Dom ?f \\<rightarrow> concrete_category.Cod ?f))\n  \\<lbrakk>ide ?a; ide ?b; ide ?c;\n   \\<guillemotleft>?f : local.prod ?a\n                         ?b \\<rightarrow> ?c\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> arr (\\<Lambda> ?a ?b ?c ?f)\n  \\<Lambda> ?a ?b ?c ?f =\n  mkArr (local.set ?a) (local.set (exp ?b ?c))\n   (\\<lambda>x.\n       UP (happ\n            (hlam (ide_to_hf ?a) (ide_to_hf ?b) (ide_to_hf ?c)\n              (arr_to_hfun ?f))\n            (DOWN x)))\n  arr (mkArr ?A ?B ?F) \\<Longrightarrow>\n  Fun (mkArr ?A ?B ?F) = restrict ?F ?A\n\ngoal (1 subgoal):\n 1. Fun (\\<Lambda> a b c f) =\n    (\\<lambda>x\\<^bold>\\<in>local.set a.\n        UP (happ\n             (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n               (arr_to_hfun f))\n             (DOWN x)))", "by simp"], ["", "lemma Fun_eval:\n    assumes \"ide b\" and \"ide c\"\n    shows \"Fun (eval b c) = restrict (\\<lambda>x. UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))\n                                     (set (HF'.prod (exp b c) b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (eval b c) =\n    (\\<lambda>x\\<^bold>\\<in>local.set (HF'.prod (exp b c) b).\n        UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))", "using assms arr_char eval_simps(1) eval_def Fun_mkArr"], ["proof (prove)\nusing this:\n  ide b\n  ide c\n  arr ?f =\n  (?f \\<noteq> concrete_category.Null \\<and>\n   |concrete_category.Dom ?f| <o natLeq \\<and>\n   |concrete_category.Cod ?f| <o natLeq \\<and>\n   concrete_category.Map ?f\n   \\<in> extensional (concrete_category.Dom ?f) \\<inter>\n         (concrete_category.Dom ?f \\<rightarrow> concrete_category.Cod ?f))\n  \\<lbrakk>ide ?b; ide ?c\\<rbrakk> \\<Longrightarrow> arr (eval ?b ?c)\n  eval ?b ?c =\n  mkArr (local.set (HF'.prod (exp ?b ?c) ?b)) (local.set ?c)\n   (\\<lambda>x. UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))\n  arr (mkArr ?A ?B ?F) \\<Longrightarrow>\n  Fun (mkArr ?A ?B ?F) = restrict ?F ?A\n\ngoal (1 subgoal):\n 1. Fun (eval b c) =\n    (\\<lambda>x\\<^bold>\\<in>local.set (HF'.prod (exp b c) b).\n        UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))", "by force"], ["", "lemma Fun_prod:\n    assumes \"arr f\" and \"arr g\" and \"x \\<in> set (prod (dom f) (dom g))\"\n    shows \"Fun (HF'.prod f g) x = UP \\<langle>DOWN (Fun f (UP (hfst (DOWN x)))),\n                                     DOWN (Fun g (UP (hsnd (DOWN x))))\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (HF'.prod f g) x =\n    UP \\<langle>DOWN (Fun f (UP (hfst (DOWN x)))),\n                DOWN (Fun g (UP (hsnd (DOWN x))))\\<rangle>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Fun (HF'.prod f g) x =\n    UP \\<langle>DOWN (Fun f (UP (hfst (DOWN x)))),\n                DOWN (Fun g (UP (hsnd (DOWN x))))\\<rangle>", "have 1: \"span (comp f (pr1 (dom f) (dom g))) (comp g (pr0 (dom f) (dom g)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. span (local.comp f (pr1 (local.dom f) (local.dom g)))\n     (local.comp g (pr0 (local.dom f) (local.dom g)))", "using assms"], ["proof (prove)\nusing this:\n  arr f\n  arr g\n  x \\<in> local.set (local.prod (local.dom f) (local.dom g))\n\ngoal (1 subgoal):\n 1. span (local.comp f (pr1 (local.dom f) (local.dom g)))\n     (local.comp g (pr0 (local.dom f) (local.dom g)))", "by (metis (no_types, lifting) HF'.prod_def HF'.prod_simps(1) HF'.tuple_ext not_arr_null)"], ["proof (state)\nthis:\n  span (local.comp f (pr1 (local.dom f) (local.dom g)))\n   (local.comp g (pr0 (local.dom f) (local.dom g)))\n\ngoal (1 subgoal):\n 1. Fun (HF'.prod f g) x =\n    UP \\<langle>DOWN (Fun f (UP (hfst (DOWN x)))),\n                DOWN (Fun g (UP (hsnd (DOWN x))))\\<rangle>", "have 2: \"Dom (comp f (pr1 (dom f) (dom g))) = set (prod (dom f) (dom g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dom (local.comp f (pr1 (local.dom f) (local.dom g))) =\n    local.set (local.prod (local.dom f) (local.dom g))", "using assms"], ["proof (prove)\nusing this:\n  arr f\n  arr g\n  x \\<in> local.set (local.prod (local.dom f) (local.dom g))\n\ngoal (1 subgoal):\n 1. Dom (local.comp f (pr1 (local.dom f) (local.dom g))) =\n    local.set (local.prod (local.dom f) (local.dom g))", "by (metis (mono_tags, lifting) 1 dom_comp ide_dom pr0_simps(2))"], ["proof (state)\nthis:\n  Dom (local.comp f (pr1 (local.dom f) (local.dom g))) =\n  local.set (local.prod (local.dom f) (local.dom g))\n\ngoal (1 subgoal):\n 1. Fun (HF'.prod f g) x =\n    UP \\<langle>DOWN (Fun f (UP (hfst (DOWN x)))),\n                DOWN (Fun g (UP (hsnd (DOWN x))))\\<rangle>", "have 3: \"Dom (comp g (pr0 (dom f) (dom g))) = set (prod (dom f) (dom g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dom (local.comp g (pr0 (local.dom f) (local.dom g))) =\n    local.set (local.prod (local.dom f) (local.dom g))", "using assms 1 2"], ["proof (prove)\nusing this:\n  arr f\n  arr g\n  x \\<in> local.set (local.prod (local.dom f) (local.dom g))\n  span (local.comp f (pr1 (local.dom f) (local.dom g)))\n   (local.comp g (pr0 (local.dom f) (local.dom g)))\n  Dom (local.comp f (pr1 (local.dom f) (local.dom g))) =\n  local.set (local.prod (local.dom f) (local.dom g))\n\ngoal (1 subgoal):\n 1. Dom (local.comp g (pr0 (local.dom f) (local.dom g))) =\n    local.set (local.prod (local.dom f) (local.dom g))", "by force"], ["proof (state)\nthis:\n  Dom (local.comp g (pr0 (local.dom f) (local.dom g))) =\n  local.set (local.prod (local.dom f) (local.dom g))\n\ngoal (1 subgoal):\n 1. Fun (HF'.prod f g) x =\n    UP \\<langle>DOWN (Fun f (UP (hfst (DOWN x)))),\n                DOWN (Fun g (UP (hsnd (DOWN x))))\\<rangle>", "have \"Fun (HF'.prod f g) x =\n            Fun (HF'.tuple (comp f (pr1 (dom f) (dom g))) (comp g (pr0 (dom f) (dom g)))) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (HF'.prod f g) x =\n    Fun (HF'.tuple (local.comp f (pr1 (local.dom f) (local.dom g)))\n          (local.comp g (pr0 (local.dom f) (local.dom g))))\n     x", "using assms(3) HF'.prod_def"], ["proof (prove)\nusing this:\n  x \\<in> local.set (local.prod (local.dom f) (local.dom g))\n  HF'.prod ?f ?g \\<equiv>\n  HF'.tuple (local.comp ?f (pr1 (local.dom ?f) (local.dom ?g)))\n   (local.comp ?g (pr0 (local.dom ?f) (local.dom ?g)))\n\ngoal (1 subgoal):\n 1. Fun (HF'.prod f g) x =\n    Fun (HF'.tuple (local.comp f (pr1 (local.dom f) (local.dom g)))\n          (local.comp g (pr0 (local.dom f) (local.dom g))))\n     x", "by simp"], ["proof (state)\nthis:\n  Fun (HF'.prod f g) x =\n  Fun (HF'.tuple (local.comp f (pr1 (local.dom f) (local.dom g)))\n        (local.comp g (pr0 (local.dom f) (local.dom g))))\n   x\n\ngoal (1 subgoal):\n 1. Fun (HF'.prod f g) x =\n    UP \\<langle>DOWN (Fun f (UP (hfst (DOWN x)))),\n                DOWN (Fun g (UP (hsnd (DOWN x))))\\<rangle>", "also"], ["proof (state)\nthis:\n  Fun (HF'.prod f g) x =\n  Fun (HF'.tuple (local.comp f (pr1 (local.dom f) (local.dom g)))\n        (local.comp g (pr0 (local.dom f) (local.dom g))))\n   x\n\ngoal (1 subgoal):\n 1. Fun (HF'.prod f g) x =\n    UP \\<langle>DOWN (Fun f (UP (hfst (DOWN x)))),\n                DOWN (Fun g (UP (hsnd (DOWN x))))\\<rangle>", "have \"... = restrict (\\<lambda>x. UP \\<langle>DOWN (Fun (comp f (pr1 (dom f) (dom g))) x),\n                                         DOWN (Fun (comp g (pr0 (dom f) (dom g))) x)\\<rangle>)\n                                (Dom (comp f (pr1 (dom f) (dom g))))\n                                x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (HF'.tuple (local.comp f (pr1 (local.dom f) (local.dom g)))\n          (local.comp g (pr0 (local.dom f) (local.dom g))))\n     x =\n    (\\<lambda>x\\<^bold>\\<in>Dom (local.comp f\n                                  (pr1 (local.dom f) (local.dom g))).\n        UP \\<langle>DOWN\n                     (Fun (local.comp f (pr1 (local.dom f) (local.dom g)))\n                       x),\n                    DOWN\n                     (Fun (local.comp g (pr0 (local.dom f) (local.dom g)))\n                       x)\\<rangle>)\n     x", "using assms 1 tuple_span_eq Fun_tuple"], ["proof (prove)\nusing this:\n  arr f\n  arr g\n  x \\<in> local.set (local.prod (local.dom f) (local.dom g))\n  span (local.comp f (pr1 (local.dom f) (local.dom g)))\n   (local.comp g (pr0 (local.dom f) (local.dom g)))\n  span ?f ?g \\<Longrightarrow> tuple ?f ?g = HF'.tuple ?f ?g\n  span ?f ?g \\<Longrightarrow>\n  Fun (tuple ?f ?g) =\n  (\\<lambda>x\\<^bold>\\<in>Dom ?f.\n      UP \\<langle>DOWN (Fun ?f x), DOWN (Fun ?g x)\\<rangle>)\n\ngoal (1 subgoal):\n 1. Fun (HF'.tuple (local.comp f (pr1 (local.dom f) (local.dom g)))\n          (local.comp g (pr0 (local.dom f) (local.dom g))))\n     x =\n    (\\<lambda>x\\<^bold>\\<in>Dom (local.comp f\n                                  (pr1 (local.dom f) (local.dom g))).\n        UP \\<langle>DOWN\n                     (Fun (local.comp f (pr1 (local.dom f) (local.dom g)))\n                       x),\n                    DOWN\n                     (Fun (local.comp g (pr0 (local.dom f) (local.dom g)))\n                       x)\\<rangle>)\n     x", "by simp"], ["proof (state)\nthis:\n  Fun (HF'.tuple (local.comp f (pr1 (local.dom f) (local.dom g)))\n        (local.comp g (pr0 (local.dom f) (local.dom g))))\n   x =\n  (\\<lambda>x\\<^bold>\\<in>Dom (local.comp f\n                                (pr1 (local.dom f) (local.dom g))).\n      UP \\<langle>DOWN\n                   (Fun (local.comp f (pr1 (local.dom f) (local.dom g))) x),\n                  DOWN\n                   (Fun (local.comp g (pr0 (local.dom f) (local.dom g)))\n                     x)\\<rangle>)\n   x\n\ngoal (1 subgoal):\n 1. Fun (HF'.prod f g) x =\n    UP \\<langle>DOWN (Fun f (UP (hfst (DOWN x)))),\n                DOWN (Fun g (UP (hsnd (DOWN x))))\\<rangle>", "also"], ["proof (state)\nthis:\n  Fun (HF'.tuple (local.comp f (pr1 (local.dom f) (local.dom g)))\n        (local.comp g (pr0 (local.dom f) (local.dom g))))\n   x =\n  (\\<lambda>x\\<^bold>\\<in>Dom (local.comp f\n                                (pr1 (local.dom f) (local.dom g))).\n      UP \\<langle>DOWN\n                   (Fun (local.comp f (pr1 (local.dom f) (local.dom g))) x),\n                  DOWN\n                   (Fun (local.comp g (pr0 (local.dom f) (local.dom g)))\n                     x)\\<rangle>)\n   x\n\ngoal (1 subgoal):\n 1. Fun (HF'.prod f g) x =\n    UP \\<langle>DOWN (Fun f (UP (hfst (DOWN x)))),\n                DOWN (Fun g (UP (hsnd (DOWN x))))\\<rangle>", "have \"... = UP \\<langle>DOWN (Fun (comp f (pr1 (dom f) (dom g))) x),\n                           DOWN (Fun (comp g (pr0 (dom f) (dom g))) x)\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<^bold>\\<in>Dom (local.comp f\n                                  (pr1 (local.dom f) (local.dom g))).\n        UP \\<langle>DOWN\n                     (Fun (local.comp f (pr1 (local.dom f) (local.dom g)))\n                       x),\n                    DOWN\n                     (Fun (local.comp g (pr0 (local.dom f) (local.dom g)))\n                       x)\\<rangle>)\n     x =\n    UP \\<langle>DOWN\n                 (Fun (local.comp f (pr1 (local.dom f) (local.dom g))) x),\n                DOWN\n                 (Fun (local.comp g (pr0 (local.dom f) (local.dom g)))\n                   x)\\<rangle>", "using assms(3) 2"], ["proof (prove)\nusing this:\n  x \\<in> local.set (local.prod (local.dom f) (local.dom g))\n  Dom (local.comp f (pr1 (local.dom f) (local.dom g))) =\n  local.set (local.prod (local.dom f) (local.dom g))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<^bold>\\<in>Dom (local.comp f\n                                  (pr1 (local.dom f) (local.dom g))).\n        UP \\<langle>DOWN\n                     (Fun (local.comp f (pr1 (local.dom f) (local.dom g)))\n                       x),\n                    DOWN\n                     (Fun (local.comp g (pr0 (local.dom f) (local.dom g)))\n                       x)\\<rangle>)\n     x =\n    UP \\<langle>DOWN\n                 (Fun (local.comp f (pr1 (local.dom f) (local.dom g))) x),\n                DOWN\n                 (Fun (local.comp g (pr0 (local.dom f) (local.dom g)))\n                   x)\\<rangle>", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>x\\<^bold>\\<in>Dom (local.comp f\n                                (pr1 (local.dom f) (local.dom g))).\n      UP \\<langle>DOWN\n                   (Fun (local.comp f (pr1 (local.dom f) (local.dom g))) x),\n                  DOWN\n                   (Fun (local.comp g (pr0 (local.dom f) (local.dom g)))\n                     x)\\<rangle>)\n   x =\n  UP \\<langle>DOWN (Fun (local.comp f (pr1 (local.dom f) (local.dom g))) x),\n              DOWN\n               (Fun (local.comp g (pr0 (local.dom f) (local.dom g)))\n                 x)\\<rangle>\n\ngoal (1 subgoal):\n 1. Fun (HF'.prod f g) x =\n    UP \\<langle>DOWN (Fun f (UP (hfst (DOWN x)))),\n                DOWN (Fun g (UP (hsnd (DOWN x))))\\<rangle>", "also"], ["proof (state)\nthis:\n  (\\<lambda>x\\<^bold>\\<in>Dom (local.comp f\n                                (pr1 (local.dom f) (local.dom g))).\n      UP \\<langle>DOWN\n                   (Fun (local.comp f (pr1 (local.dom f) (local.dom g))) x),\n                  DOWN\n                   (Fun (local.comp g (pr0 (local.dom f) (local.dom g)))\n                     x)\\<rangle>)\n   x =\n  UP \\<langle>DOWN (Fun (local.comp f (pr1 (local.dom f) (local.dom g))) x),\n              DOWN\n               (Fun (local.comp g (pr0 (local.dom f) (local.dom g)))\n                 x)\\<rangle>\n\ngoal (1 subgoal):\n 1. Fun (HF'.prod f g) x =\n    UP \\<langle>DOWN (Fun f (UP (hfst (DOWN x)))),\n                DOWN (Fun g (UP (hsnd (DOWN x))))\\<rangle>", "have \"... = UP \\<langle>DOWN (Fun f (UP (hfst (DOWN x)))),\n                           DOWN (Fun g (UP (hsnd (DOWN x))))\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP \\<langle>DOWN\n                 (Fun (local.comp f (pr1 (local.dom f) (local.dom g))) x),\n                DOWN\n                 (Fun (local.comp g (pr0 (local.dom f) (local.dom g)))\n                   x)\\<rangle> =\n    UP \\<langle>DOWN (Fun f (UP (hfst (DOWN x)))),\n                DOWN (Fun g (UP (hsnd (DOWN x))))\\<rangle>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. UP \\<langle>DOWN\n                 (Fun (local.comp f (pr1 (local.dom f) (local.dom g))) x),\n                DOWN\n                 (Fun (local.comp g (pr0 (local.dom f) (local.dom g)))\n                   x)\\<rangle> =\n    UP \\<langle>DOWN (Fun f (UP (hfst (DOWN x)))),\n                DOWN (Fun g (UP (hsnd (DOWN x))))\\<rangle>", "have \"Fun (comp f (pr1 (dom f) (dom g))) x = Fun f (UP (hfst (DOWN x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (local.comp f (pr1 (local.dom f) (local.dom g))) x =\n    Fun f (UP (hfst (DOWN x)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Fun (local.comp f (pr1 (local.dom f) (local.dom g))) x =\n    Fun f (UP (hfst (DOWN x)))", "(* TODO: Figure out what is making this proof so \"stiff\". *)"], ["proof (state)\ngoal (1 subgoal):\n 1. Fun (local.comp f (pr1 (local.dom f) (local.dom g))) x =\n    Fun f (UP (hfst (DOWN x)))", "have 4: \"seq f (pr1 (dom f) (dom g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq f (pr1 (local.dom f) (local.dom g))", "using assms 1"], ["proof (prove)\nusing this:\n  arr f\n  arr g\n  x \\<in> local.set (local.prod (local.dom f) (local.dom g))\n  span (local.comp f (pr1 (local.dom f) (local.dom g)))\n   (local.comp g (pr0 (local.dom f) (local.dom g)))\n\ngoal (1 subgoal):\n 1. seq f (pr1 (local.dom f) (local.dom g))", "by blast"], ["proof (state)\nthis:\n  seq f (pr1 (local.dom f) (local.dom g))\n\ngoal (1 subgoal):\n 1. Fun (local.comp f (pr1 (local.dom f) (local.dom g))) x =\n    Fun f (UP (hfst (DOWN x)))", "have \"Fun (comp f (pr1 (dom f) (dom g))) x =\n                restrict (Fun f \\<circ> Fun (pr1 (dom f) (dom g))) (Dom (pr1 (dom f) (dom g))) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (local.comp f (pr1 (local.dom f) (local.dom g))) x =\n    restrict (Fun f \\<circ> Fun (pr1 (local.dom f) (local.dom g)))\n     (Dom (pr1 (local.dom f) (local.dom g))) x", "using assms 1 Fun_comp [of f \"pr1 (dom f) (dom g)\"]"], ["proof (prove)\nusing this:\n  arr f\n  arr g\n  x \\<in> local.set (local.prod (local.dom f) (local.dom g))\n  span (local.comp f (pr1 (local.dom f) (local.dom g)))\n   (local.comp g (pr0 (local.dom f) (local.dom g)))\n  seq f (pr1 (local.dom f) (local.dom g)) \\<Longrightarrow>\n  Fun (local.comp f (pr1 (local.dom f) (local.dom g))) =\n  restrict (Fun f \\<circ> Fun (pr1 (local.dom f) (local.dom g)))\n   (Dom (pr1 (local.dom f) (local.dom g)))\n\ngoal (1 subgoal):\n 1. Fun (local.comp f (pr1 (local.dom f) (local.dom g))) x =\n    restrict (Fun f \\<circ> Fun (pr1 (local.dom f) (local.dom g)))\n     (Dom (pr1 (local.dom f) (local.dom g))) x", "by (metis (no_types, lifting))"], ["proof (state)\nthis:\n  Fun (local.comp f (pr1 (local.dom f) (local.dom g))) x =\n  restrict (Fun f \\<circ> Fun (pr1 (local.dom f) (local.dom g)))\n   (Dom (pr1 (local.dom f) (local.dom g))) x\n\ngoal (1 subgoal):\n 1. Fun (local.comp f (pr1 (local.dom f) (local.dom g))) x =\n    Fun f (UP (hfst (DOWN x)))", "also"], ["proof (state)\nthis:\n  Fun (local.comp f (pr1 (local.dom f) (local.dom g))) x =\n  restrict (Fun f \\<circ> Fun (pr1 (local.dom f) (local.dom g)))\n   (Dom (pr1 (local.dom f) (local.dom g))) x\n\ngoal (1 subgoal):\n 1. Fun (local.comp f (pr1 (local.dom f) (local.dom g))) x =\n    Fun f (UP (hfst (DOWN x)))", "have \"... = (Fun f \\<circ> Fun (pr1 (dom f) (dom g))) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict (Fun f \\<circ> Fun (pr1 (local.dom f) (local.dom g)))\n     (Dom (pr1 (local.dom f) (local.dom g))) x =\n    (Fun f \\<circ> Fun (pr1 (local.dom f) (local.dom g))) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. restrict (Fun f \\<circ> Fun (pr1 (local.dom f) (local.dom g)))\n     (Dom (pr1 (local.dom f) (local.dom g))) x =\n    (Fun f \\<circ> Fun (pr1 (local.dom f) (local.dom g))) x", "have \"x \\<in> Dom (pr1 (dom f) (dom g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Dom (pr1 (local.dom f) (local.dom g))", "using assms 1 2 4"], ["proof (prove)\nusing this:\n  arr f\n  arr g\n  x \\<in> local.set (local.prod (local.dom f) (local.dom g))\n  span (local.comp f (pr1 (local.dom f) (local.dom g)))\n   (local.comp g (pr0 (local.dom f) (local.dom g)))\n  Dom (local.comp f (pr1 (local.dom f) (local.dom g))) =\n  local.set (local.prod (local.dom f) (local.dom g))\n  seq f (pr1 (local.dom f) (local.dom g))\n\ngoal (1 subgoal):\n 1. x \\<in> Dom (pr1 (local.dom f) (local.dom g))", "by (metis (no_types, lifting) dom_comp)"], ["proof (state)\nthis:\n  x \\<in> Dom (pr1 (local.dom f) (local.dom g))\n\ngoal (1 subgoal):\n 1. restrict (Fun f \\<circ> Fun (pr1 (local.dom f) (local.dom g)))\n     (Dom (pr1 (local.dom f) (local.dom g))) x =\n    (Fun f \\<circ> Fun (pr1 (local.dom f) (local.dom g))) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> Dom (pr1 (local.dom f) (local.dom g))\n\ngoal (1 subgoal):\n 1. restrict (Fun f \\<circ> Fun (pr1 (local.dom f) (local.dom g)))\n     (Dom (pr1 (local.dom f) (local.dom g))) x =\n    (Fun f \\<circ> Fun (pr1 (local.dom f) (local.dom g))) x", "by simp"], ["proof (state)\nthis:\n  restrict (Fun f \\<circ> Fun (pr1 (local.dom f) (local.dom g)))\n   (Dom (pr1 (local.dom f) (local.dom g))) x =\n  (Fun f \\<circ> Fun (pr1 (local.dom f) (local.dom g))) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  restrict (Fun f \\<circ> Fun (pr1 (local.dom f) (local.dom g)))\n   (Dom (pr1 (local.dom f) (local.dom g))) x =\n  (Fun f \\<circ> Fun (pr1 (local.dom f) (local.dom g))) x\n\ngoal (1 subgoal):\n 1. Fun (local.comp f (pr1 (local.dom f) (local.dom g))) x =\n    Fun f (UP (hfst (DOWN x)))", "also"], ["proof (state)\nthis:\n  restrict (Fun f \\<circ> Fun (pr1 (local.dom f) (local.dom g)))\n   (Dom (pr1 (local.dom f) (local.dom g))) x =\n  (Fun f \\<circ> Fun (pr1 (local.dom f) (local.dom g))) x\n\ngoal (1 subgoal):\n 1. Fun (local.comp f (pr1 (local.dom f) (local.dom g))) x =\n    Fun f (UP (hfst (DOWN x)))", "have \"... = Fun f (Fun (pr1 (dom f) (dom g)) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Fun f \\<circ> Fun (pr1 (local.dom f) (local.dom g))) x =\n    Fun f (Fun (pr1 (local.dom f) (local.dom g)) x)", "by simp"], ["proof (state)\nthis:\n  (Fun f \\<circ> Fun (pr1 (local.dom f) (local.dom g))) x =\n  Fun f (Fun (pr1 (local.dom f) (local.dom g)) x)\n\ngoal (1 subgoal):\n 1. Fun (local.comp f (pr1 (local.dom f) (local.dom g))) x =\n    Fun f (UP (hfst (DOWN x)))", "also"], ["proof (state)\nthis:\n  (Fun f \\<circ> Fun (pr1 (local.dom f) (local.dom g))) x =\n  Fun f (Fun (pr1 (local.dom f) (local.dom g)) x)\n\ngoal (1 subgoal):\n 1. Fun (local.comp f (pr1 (local.dom f) (local.dom g))) x =\n    Fun f (UP (hfst (DOWN x)))", "have \"... = Fun f (UP (hfst (DOWN x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun f (Fun (pr1 (local.dom f) (local.dom g)) x) =\n    Fun f (UP (hfst (DOWN x)))", "using assms 1 Fun_pr1 [of \"dom f\" \"dom g\"] ide_dom"], ["proof (prove)\nusing this:\n  arr f\n  arr g\n  x \\<in> local.set (local.prod (local.dom f) (local.dom g))\n  span (local.comp f (pr1 (local.dom f) (local.dom g)))\n   (local.comp g (pr0 (local.dom f) (local.dom g)))\n  \\<lbrakk>ide (local.dom f); ide (local.dom g)\\<rbrakk>\n  \\<Longrightarrow> Fun (pr1 (local.dom f) (local.dom g)) =\n                    (\\<lambda>x\\<^bold>\\<in>local.set\n       (local.prod (local.dom f) (local.dom g)).\n                        UP (hfst (DOWN x)))\n  arr ?f \\<Longrightarrow> ide (local.dom ?f)\n\ngoal (1 subgoal):\n 1. Fun f (Fun (pr1 (local.dom f) (local.dom g)) x) =\n    Fun f (UP (hfst (DOWN x)))", "by simp"], ["proof (state)\nthis:\n  Fun f (Fun (pr1 (local.dom f) (local.dom g)) x) =\n  Fun f (UP (hfst (DOWN x)))\n\ngoal (1 subgoal):\n 1. Fun (local.comp f (pr1 (local.dom f) (local.dom g))) x =\n    Fun f (UP (hfst (DOWN x)))", "finally"], ["proof (chain)\npicking this:\n  Fun (local.comp f (pr1 (local.dom f) (local.dom g))) x =\n  Fun f (UP (hfst (DOWN x)))", "show ?thesis"], ["proof (prove)\nusing this:\n  Fun (local.comp f (pr1 (local.dom f) (local.dom g))) x =\n  Fun f (UP (hfst (DOWN x)))\n\ngoal (1 subgoal):\n 1. Fun (local.comp f (pr1 (local.dom f) (local.dom g))) x =\n    Fun f (UP (hfst (DOWN x)))", "by blast"], ["proof (state)\nthis:\n  Fun (local.comp f (pr1 (local.dom f) (local.dom g))) x =\n  Fun f (UP (hfst (DOWN x)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Fun (local.comp f (pr1 (local.dom f) (local.dom g))) x =\n  Fun f (UP (hfst (DOWN x)))\n\ngoal (1 subgoal):\n 1. UP \\<langle>DOWN\n                 (Fun (local.comp f (pr1 (local.dom f) (local.dom g))) x),\n                DOWN\n                 (Fun (local.comp g (pr0 (local.dom f) (local.dom g)))\n                   x)\\<rangle> =\n    UP \\<langle>DOWN (Fun f (UP (hfst (DOWN x)))),\n                DOWN (Fun g (UP (hsnd (DOWN x))))\\<rangle>", "moreover"], ["proof (state)\nthis:\n  Fun (local.comp f (pr1 (local.dom f) (local.dom g))) x =\n  Fun f (UP (hfst (DOWN x)))\n\ngoal (1 subgoal):\n 1. UP \\<langle>DOWN\n                 (Fun (local.comp f (pr1 (local.dom f) (local.dom g))) x),\n                DOWN\n                 (Fun (local.comp g (pr0 (local.dom f) (local.dom g)))\n                   x)\\<rangle> =\n    UP \\<langle>DOWN (Fun f (UP (hfst (DOWN x)))),\n                DOWN (Fun g (UP (hsnd (DOWN x))))\\<rangle>", "have \"Fun (comp g (pr0 (dom f) (dom g))) x = Fun g (UP (hsnd (DOWN x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (local.comp g (pr0 (local.dom f) (local.dom g))) x =\n    Fun g (UP (hsnd (DOWN x)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Fun (local.comp g (pr0 (local.dom f) (local.dom g))) x =\n    Fun g (UP (hsnd (DOWN x)))", "have 4: \"seq g (pr0 (dom f) (dom g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq g (pr0 (local.dom f) (local.dom g))", "using assms 1"], ["proof (prove)\nusing this:\n  arr f\n  arr g\n  x \\<in> local.set (local.prod (local.dom f) (local.dom g))\n  span (local.comp f (pr1 (local.dom f) (local.dom g)))\n   (local.comp g (pr0 (local.dom f) (local.dom g)))\n\ngoal (1 subgoal):\n 1. seq g (pr0 (local.dom f) (local.dom g))", "by blast"], ["proof (state)\nthis:\n  seq g (pr0 (local.dom f) (local.dom g))\n\ngoal (1 subgoal):\n 1. Fun (local.comp g (pr0 (local.dom f) (local.dom g))) x =\n    Fun g (UP (hsnd (DOWN x)))", "have \"Fun (comp g (pr0 (dom f) (dom g))) x =\n                restrict (Fun g \\<circ> Fun (pr0 (dom f) (dom g))) (Dom (pr0 (dom f) (dom g))) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (local.comp g (pr0 (local.dom f) (local.dom g))) x =\n    restrict (Fun g \\<circ> Fun (pr0 (local.dom f) (local.dom g)))\n     (Dom (pr0 (local.dom f) (local.dom g))) x", "using assms 1 Fun_comp [of g \"pr0 (dom f) (dom g)\"]"], ["proof (prove)\nusing this:\n  arr f\n  arr g\n  x \\<in> local.set (local.prod (local.dom f) (local.dom g))\n  span (local.comp f (pr1 (local.dom f) (local.dom g)))\n   (local.comp g (pr0 (local.dom f) (local.dom g)))\n  seq g (pr0 (local.dom f) (local.dom g)) \\<Longrightarrow>\n  Fun (local.comp g (pr0 (local.dom f) (local.dom g))) =\n  restrict (Fun g \\<circ> Fun (pr0 (local.dom f) (local.dom g)))\n   (Dom (pr0 (local.dom f) (local.dom g)))\n\ngoal (1 subgoal):\n 1. Fun (local.comp g (pr0 (local.dom f) (local.dom g))) x =\n    restrict (Fun g \\<circ> Fun (pr0 (local.dom f) (local.dom g)))\n     (Dom (pr0 (local.dom f) (local.dom g))) x", "by (metis (no_types, lifting))"], ["proof (state)\nthis:\n  Fun (local.comp g (pr0 (local.dom f) (local.dom g))) x =\n  restrict (Fun g \\<circ> Fun (pr0 (local.dom f) (local.dom g)))\n   (Dom (pr0 (local.dom f) (local.dom g))) x\n\ngoal (1 subgoal):\n 1. Fun (local.comp g (pr0 (local.dom f) (local.dom g))) x =\n    Fun g (UP (hsnd (DOWN x)))", "also"], ["proof (state)\nthis:\n  Fun (local.comp g (pr0 (local.dom f) (local.dom g))) x =\n  restrict (Fun g \\<circ> Fun (pr0 (local.dom f) (local.dom g)))\n   (Dom (pr0 (local.dom f) (local.dom g))) x\n\ngoal (1 subgoal):\n 1. Fun (local.comp g (pr0 (local.dom f) (local.dom g))) x =\n    Fun g (UP (hsnd (DOWN x)))", "have \"... = (Fun g \\<circ> Fun (pr0 (dom f) (dom g))) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict (Fun g \\<circ> Fun (pr0 (local.dom f) (local.dom g)))\n     (Dom (pr0 (local.dom f) (local.dom g))) x =\n    (Fun g \\<circ> Fun (pr0 (local.dom f) (local.dom g))) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. restrict (Fun g \\<circ> Fun (pr0 (local.dom f) (local.dom g)))\n     (Dom (pr0 (local.dom f) (local.dom g))) x =\n    (Fun g \\<circ> Fun (pr0 (local.dom f) (local.dom g))) x", "have \"x \\<in> Dom (pr0 (dom f) (dom g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Dom (pr0 (local.dom f) (local.dom g))", "using assms 1 2 4"], ["proof (prove)\nusing this:\n  arr f\n  arr g\n  x \\<in> local.set (local.prod (local.dom f) (local.dom g))\n  span (local.comp f (pr1 (local.dom f) (local.dom g)))\n   (local.comp g (pr0 (local.dom f) (local.dom g)))\n  Dom (local.comp f (pr1 (local.dom f) (local.dom g))) =\n  local.set (local.prod (local.dom f) (local.dom g))\n  seq g (pr0 (local.dom f) (local.dom g))\n\ngoal (1 subgoal):\n 1. x \\<in> Dom (pr0 (local.dom f) (local.dom g))", "by (metis (no_types, lifting) dom_comp)"], ["proof (state)\nthis:\n  x \\<in> Dom (pr0 (local.dom f) (local.dom g))\n\ngoal (1 subgoal):\n 1. restrict (Fun g \\<circ> Fun (pr0 (local.dom f) (local.dom g)))\n     (Dom (pr0 (local.dom f) (local.dom g))) x =\n    (Fun g \\<circ> Fun (pr0 (local.dom f) (local.dom g))) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> Dom (pr0 (local.dom f) (local.dom g))\n\ngoal (1 subgoal):\n 1. restrict (Fun g \\<circ> Fun (pr0 (local.dom f) (local.dom g)))\n     (Dom (pr0 (local.dom f) (local.dom g))) x =\n    (Fun g \\<circ> Fun (pr0 (local.dom f) (local.dom g))) x", "by simp"], ["proof (state)\nthis:\n  restrict (Fun g \\<circ> Fun (pr0 (local.dom f) (local.dom g)))\n   (Dom (pr0 (local.dom f) (local.dom g))) x =\n  (Fun g \\<circ> Fun (pr0 (local.dom f) (local.dom g))) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  restrict (Fun g \\<circ> Fun (pr0 (local.dom f) (local.dom g)))\n   (Dom (pr0 (local.dom f) (local.dom g))) x =\n  (Fun g \\<circ> Fun (pr0 (local.dom f) (local.dom g))) x\n\ngoal (1 subgoal):\n 1. Fun (local.comp g (pr0 (local.dom f) (local.dom g))) x =\n    Fun g (UP (hsnd (DOWN x)))", "also"], ["proof (state)\nthis:\n  restrict (Fun g \\<circ> Fun (pr0 (local.dom f) (local.dom g)))\n   (Dom (pr0 (local.dom f) (local.dom g))) x =\n  (Fun g \\<circ> Fun (pr0 (local.dom f) (local.dom g))) x\n\ngoal (1 subgoal):\n 1. Fun (local.comp g (pr0 (local.dom f) (local.dom g))) x =\n    Fun g (UP (hsnd (DOWN x)))", "have \"... = Fun g (Fun (pr0 (dom f) (dom g)) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Fun g \\<circ> Fun (pr0 (local.dom f) (local.dom g))) x =\n    Fun g (Fun (pr0 (local.dom f) (local.dom g)) x)", "by simp"], ["proof (state)\nthis:\n  (Fun g \\<circ> Fun (pr0 (local.dom f) (local.dom g))) x =\n  Fun g (Fun (pr0 (local.dom f) (local.dom g)) x)\n\ngoal (1 subgoal):\n 1. Fun (local.comp g (pr0 (local.dom f) (local.dom g))) x =\n    Fun g (UP (hsnd (DOWN x)))", "also"], ["proof (state)\nthis:\n  (Fun g \\<circ> Fun (pr0 (local.dom f) (local.dom g))) x =\n  Fun g (Fun (pr0 (local.dom f) (local.dom g)) x)\n\ngoal (1 subgoal):\n 1. Fun (local.comp g (pr0 (local.dom f) (local.dom g))) x =\n    Fun g (UP (hsnd (DOWN x)))", "have \"... = Fun g (UP (hsnd (DOWN x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun g (Fun (pr0 (local.dom f) (local.dom g)) x) =\n    Fun g (UP (hsnd (DOWN x)))", "using assms 1 Fun_pr0 [of \"dom f\" \"dom g\"] ide_dom"], ["proof (prove)\nusing this:\n  arr f\n  arr g\n  x \\<in> local.set (local.prod (local.dom f) (local.dom g))\n  span (local.comp f (pr1 (local.dom f) (local.dom g)))\n   (local.comp g (pr0 (local.dom f) (local.dom g)))\n  \\<lbrakk>ide (local.dom f); ide (local.dom g)\\<rbrakk>\n  \\<Longrightarrow> Fun (pr0 (local.dom f) (local.dom g)) =\n                    (\\<lambda>x\\<^bold>\\<in>local.set\n       (local.prod (local.dom f) (local.dom g)).\n                        UP (hsnd (DOWN x)))\n  arr ?f \\<Longrightarrow> ide (local.dom ?f)\n\ngoal (1 subgoal):\n 1. Fun g (Fun (pr0 (local.dom f) (local.dom g)) x) =\n    Fun g (UP (hsnd (DOWN x)))", "by simp"], ["proof (state)\nthis:\n  Fun g (Fun (pr0 (local.dom f) (local.dom g)) x) =\n  Fun g (UP (hsnd (DOWN x)))\n\ngoal (1 subgoal):\n 1. Fun (local.comp g (pr0 (local.dom f) (local.dom g))) x =\n    Fun g (UP (hsnd (DOWN x)))", "finally"], ["proof (chain)\npicking this:\n  Fun (local.comp g (pr0 (local.dom f) (local.dom g))) x =\n  Fun g (UP (hsnd (DOWN x)))", "show ?thesis"], ["proof (prove)\nusing this:\n  Fun (local.comp g (pr0 (local.dom f) (local.dom g))) x =\n  Fun g (UP (hsnd (DOWN x)))\n\ngoal (1 subgoal):\n 1. Fun (local.comp g (pr0 (local.dom f) (local.dom g))) x =\n    Fun g (UP (hsnd (DOWN x)))", "by blast"], ["proof (state)\nthis:\n  Fun (local.comp g (pr0 (local.dom f) (local.dom g))) x =\n  Fun g (UP (hsnd (DOWN x)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Fun (local.comp g (pr0 (local.dom f) (local.dom g))) x =\n  Fun g (UP (hsnd (DOWN x)))\n\ngoal (1 subgoal):\n 1. UP \\<langle>DOWN\n                 (Fun (local.comp f (pr1 (local.dom f) (local.dom g))) x),\n                DOWN\n                 (Fun (local.comp g (pr0 (local.dom f) (local.dom g)))\n                   x)\\<rangle> =\n    UP \\<langle>DOWN (Fun f (UP (hfst (DOWN x)))),\n                DOWN (Fun g (UP (hsnd (DOWN x))))\\<rangle>", "ultimately"], ["proof (chain)\npicking this:\n  Fun (local.comp f (pr1 (local.dom f) (local.dom g))) x =\n  Fun f (UP (hfst (DOWN x)))\n  Fun (local.comp g (pr0 (local.dom f) (local.dom g))) x =\n  Fun g (UP (hsnd (DOWN x)))", "show ?thesis"], ["proof (prove)\nusing this:\n  Fun (local.comp f (pr1 (local.dom f) (local.dom g))) x =\n  Fun f (UP (hfst (DOWN x)))\n  Fun (local.comp g (pr0 (local.dom f) (local.dom g))) x =\n  Fun g (UP (hsnd (DOWN x)))\n\ngoal (1 subgoal):\n 1. UP \\<langle>DOWN\n                 (Fun (local.comp f (pr1 (local.dom f) (local.dom g))) x),\n                DOWN\n                 (Fun (local.comp g (pr0 (local.dom f) (local.dom g)))\n                   x)\\<rangle> =\n    UP \\<langle>DOWN (Fun f (UP (hfst (DOWN x)))),\n                DOWN (Fun g (UP (hsnd (DOWN x))))\\<rangle>", "by simp"], ["proof (state)\nthis:\n  UP \\<langle>DOWN (Fun (local.comp f (pr1 (local.dom f) (local.dom g))) x),\n              DOWN\n               (Fun (local.comp g (pr0 (local.dom f) (local.dom g)))\n                 x)\\<rangle> =\n  UP \\<langle>DOWN (Fun f (UP (hfst (DOWN x)))),\n              DOWN (Fun g (UP (hsnd (DOWN x))))\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  UP \\<langle>DOWN (Fun (local.comp f (pr1 (local.dom f) (local.dom g))) x),\n              DOWN\n               (Fun (local.comp g (pr0 (local.dom f) (local.dom g)))\n                 x)\\<rangle> =\n  UP \\<langle>DOWN (Fun f (UP (hfst (DOWN x)))),\n              DOWN (Fun g (UP (hsnd (DOWN x))))\\<rangle>\n\ngoal (1 subgoal):\n 1. Fun (HF'.prod f g) x =\n    UP \\<langle>DOWN (Fun f (UP (hfst (DOWN x)))),\n                DOWN (Fun g (UP (hsnd (DOWN x))))\\<rangle>", "finally"], ["proof (chain)\npicking this:\n  Fun (HF'.prod f g) x =\n  UP \\<langle>DOWN (Fun f (UP (hfst (DOWN x)))),\n              DOWN (Fun g (UP (hsnd (DOWN x))))\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  Fun (HF'.prod f g) x =\n  UP \\<langle>DOWN (Fun f (UP (hfst (DOWN x)))),\n              DOWN (Fun g (UP (hsnd (DOWN x))))\\<rangle>\n\ngoal (1 subgoal):\n 1. Fun (HF'.prod f g) x =\n    UP \\<langle>DOWN (Fun f (UP (hfst (DOWN x)))),\n                DOWN (Fun g (UP (hsnd (DOWN x))))\\<rangle>", "by simp"], ["proof (state)\nthis:\n  Fun (HF'.prod f g) x =\n  UP \\<langle>DOWN (Fun f (UP (hfst (DOWN x)))),\n              DOWN (Fun g (UP (hsnd (DOWN x))))\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma prod_in_terms_of_tuple:\n    assumes \"arr f\" and \"arr g\"\n    shows \"HF'.prod f g =\n           tuple (comp f (pr1 (dom f) (dom g))) (comp g (pr0 (dom f) (dom g)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. HF'.prod f g =\n    tuple (local.comp f (pr1 (local.dom f) (local.dom g)))\n     (local.comp g (pr0 (local.dom f) (local.dom g)))", "using assms HF'.prod_def tuple_span_eq"], ["proof (prove)\nusing this:\n  arr f\n  arr g\n  HF'.prod ?f ?g \\<equiv>\n  HF'.tuple (local.comp ?f (pr1 (local.dom ?f) (local.dom ?g)))\n   (local.comp ?g (pr0 (local.dom ?f) (local.dom ?g)))\n  span ?f ?g \\<Longrightarrow> tuple ?f ?g = HF'.tuple ?f ?g\n\ngoal (1 subgoal):\n 1. HF'.prod f g =\n    tuple (local.comp f (pr1 (local.dom f) (local.dom g)))\n     (local.comp g (pr0 (local.dom f) (local.dom g)))", "by (metis (no_types, lifting) HF'.prod_simps(1) HF'.tuple_ext not_arr_null)"], ["", "lemma eval_prod_lam:\n    assumes \"ide a\" and \"ide b\" and \"ide c\"\n    and \"in_hom g (prod a b) c\"\n    shows \"comp (eval b c) (HF'.prod (\\<Lambda> a b c g) b) = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.comp (eval b c) (HF'.prod (\\<Lambda> a b c g) b) = g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.comp (eval b c) (HF'.prod (\\<Lambda> a b c g) b) = g", "have ide_dom_lam: \"ide (dom (\\<Lambda> a b c g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide (local.dom (\\<Lambda> a b c g))", "using assms lam_in_hom [of a b c g] ide_dom"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>g : local.prod a b \\<rightarrow> c\\<guillemotright>\n  \\<lbrakk>ide a; ide b; ide c;\n   \\<guillemotleft>g : local.prod a\n                        b \\<rightarrow> c\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>\\<Lambda> a b c\n                                     g : a \\<rightarrow> exp b\n                    c\\<guillemotright>\n  arr ?f \\<Longrightarrow> ide (local.dom ?f)\n\ngoal (1 subgoal):\n 1. ide (local.dom (\\<Lambda> a b c g))", "by blast"], ["proof (state)\nthis:\n  ide (local.dom (\\<Lambda> a b c g))\n\ngoal (1 subgoal):\n 1. local.comp (eval b c) (HF'.prod (\\<Lambda> a b c g) b) = g", "have ide_dom_b: \"ide (dom b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide (local.dom b)", "using assms ide_dom ideD(1)"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>g : local.prod a b \\<rightarrow> c\\<guillemotright>\n  arr ?f \\<Longrightarrow> ide (local.dom ?f)\n  ide ?a \\<Longrightarrow> arr ?a\n\ngoal (1 subgoal):\n 1. ide (local.dom b)", "by blast"], ["proof (state)\nthis:\n  ide (local.dom b)\n\ngoal (1 subgoal):\n 1. local.comp (eval b c) (HF'.prod (\\<Lambda> a b c g) b) = g", "define \\<Lambda>_pr1 where \"\\<Lambda>_pr1 = comp (\\<Lambda> a b c g) (pr1 (dom (\\<Lambda> a b c g)) (dom b))\""], ["proof (state)\nthis:\n  \\<Lambda>_pr1 =\n  local.comp (\\<Lambda> a b c g)\n   (pr1 (local.dom (\\<Lambda> a b c g)) (local.dom b))\n\ngoal (1 subgoal):\n 1. local.comp (eval b c) (HF'.prod (\\<Lambda> a b c g) b) = g", "define b_pr0 where \"b_pr0 = comp b (pr0 (dom (\\<Lambda> a b c g)) (dom b))\""], ["proof (state)\nthis:\n  b_pr0 = local.comp b (pr0 (local.dom (\\<Lambda> a b c g)) (local.dom b))\n\ngoal (1 subgoal):\n 1. local.comp (eval b c) (HF'.prod (\\<Lambda> a b c g) b) = g", "have lam_pr1: \"in_hom \\<Lambda>_pr1 (prod a b) (exp b c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<Lambda>_pr1 : local.prod a\n                                     b \\<rightarrow> exp b\n                c\\<guillemotright>", "proof (unfold \\<Lambda>_pr1_def, intro comp_in_homI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<guillemotleft>pr1 (local.dom (\\<Lambda> a b c g))\n                     (local.dom\n                       b) : local.prod a b \\<rightarrow> ?b\\<guillemotright>\n 2. \\<guillemotleft>\\<Lambda> a b c\n                     g : ?b \\<rightarrow> exp b c\\<guillemotright>", "show \"in_hom (pr1 (dom (\\<Lambda> a b c g)) (dom b)) (prod a b) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>pr1 (local.dom (\\<Lambda> a b c g))\n                     (local.dom\n                       b) : local.prod a b \\<rightarrow> a\\<guillemotright>", "using assms ide_dom_lam ide_dom_b ideD(2) lam_simps(2) pr1_in_hom"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>g : local.prod a b \\<rightarrow> c\\<guillemotright>\n  ide (local.dom (\\<Lambda> a b c g))\n  ide (local.dom b)\n  ide ?a \\<Longrightarrow> local.dom ?a = ?a\n  \\<lbrakk>ide ?a; ide ?b; ide ?c;\n   \\<guillemotleft>?f : local.prod ?a\n                         ?b \\<rightarrow> ?c\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> local.dom (\\<Lambda> ?a ?b ?c ?f) = ?a\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>pr1 ?a\n                                     ?b : local.prod ?a\n     ?b \\<rightarrow> ?a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>pr1 (local.dom (\\<Lambda> a b c g))\n                     (local.dom\n                       b) : local.prod a b \\<rightarrow> a\\<guillemotright>", "by auto"], ["proof (state)\nthis:\n  \\<guillemotleft>pr1 (local.dom (\\<Lambda> a b c g))\n                   (local.dom\n                     b) : local.prod a b \\<rightarrow> a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<Lambda> a b c\n                     g : a \\<rightarrow> exp b c\\<guillemotright>", "show \"in_hom (\\<Lambda> a b c g) a (exp b c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<Lambda> a b c\n                     g : a \\<rightarrow> exp b c\\<guillemotright>", "using assms lam_in_hom"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>g : local.prod a b \\<rightarrow> c\\<guillemotright>\n  \\<lbrakk>ide ?a; ide ?b; ide ?c;\n   \\<guillemotleft>?f : local.prod ?a\n                         ?b \\<rightarrow> ?c\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>\\<Lambda> ?a ?b ?c\n                                     ?f : ?a \\<rightarrow> exp ?b\n                      ?c\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<Lambda> a b c\n                     g : a \\<rightarrow> exp b c\\<guillemotright>", "by simp"], ["proof (state)\nthis:\n  \\<guillemotleft>\\<Lambda> a b c\n                   g : a \\<rightarrow> exp b c\\<guillemotright>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<guillemotleft>\\<Lambda>_pr1 : local.prod a\n                                   b \\<rightarrow> exp b c\\<guillemotright>\n\ngoal (1 subgoal):\n 1. local.comp (eval b c) (HF'.prod (\\<Lambda> a b c g) b) = g", "have b_pr0: \"in_hom b_pr0 (prod a b) b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>b_pr0 : local.prod a b \\<rightarrow> b\\<guillemotright>", "using assms b_pr0_def"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>g : local.prod a b \\<rightarrow> c\\<guillemotright>\n  b_pr0 = local.comp b (pr0 (local.dom (\\<Lambda> a b c g)) (local.dom b))\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>b_pr0 : local.prod a b \\<rightarrow> b\\<guillemotright>", "by (metis (no_types, lifting) HF'.arr_pr0_iff HF'.cod_pr0 comp_in_homI'\n            ideD(1-3) lam_simps(2) pr0_simps(2))"], ["proof (state)\nthis:\n  \\<guillemotleft>b_pr0 : local.prod a b \\<rightarrow> b\\<guillemotright>\n\ngoal (1 subgoal):\n 1. local.comp (eval b c) (HF'.prod (\\<Lambda> a b c g) b) = g", "have 1: \"span \\<Lambda>_pr1 b_pr0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. span \\<Lambda>_pr1 b_pr0", "using lam_pr1 b_pr0"], ["proof (prove)\nusing this:\n  \\<guillemotleft>\\<Lambda>_pr1 : local.prod a\n                                   b \\<rightarrow> exp b c\\<guillemotright>\n  \\<guillemotleft>b_pr0 : local.prod a b \\<rightarrow> b\\<guillemotright>\n\ngoal (1 subgoal):\n 1. span \\<Lambda>_pr1 b_pr0", "by (metis (no_types, lifting) in_homE)"], ["proof (state)\nthis:\n  span \\<Lambda>_pr1 b_pr0\n\ngoal (1 subgoal):\n 1. local.comp (eval b c) (HF'.prod (\\<Lambda> a b c g) b) = g", "have tuple: \"in_hom (tuple \\<Lambda>_pr1 b_pr0) (prod a b) (prod (exp b c) b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>tuple \\<Lambda>_pr1\n                     b_pr0 : local.prod a\n                              b \\<rightarrow> local.prod (exp b c)\n         b\\<guillemotright>", "using 1 lam_pr1 b_pr0 tuple_in_hom [of \\<Lambda>_pr1 b_pr0]"], ["proof (prove)\nusing this:\n  span \\<Lambda>_pr1 b_pr0\n  \\<guillemotleft>\\<Lambda>_pr1 : local.prod a\n                                   b \\<rightarrow> exp b c\\<guillemotright>\n  \\<guillemotleft>b_pr0 : local.prod a b \\<rightarrow> b\\<guillemotright>\n  span \\<Lambda>_pr1 b_pr0 \\<Longrightarrow>\n  \\<guillemotleft>tuple \\<Lambda>_pr1\n                   b_pr0 : local.dom\n                            \\<Lambda>_pr1 \\<rightarrow> local.prod\n                   (cod \\<Lambda>_pr1) (cod b_pr0)\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>tuple \\<Lambda>_pr1\n                     b_pr0 : local.prod a\n                              b \\<rightarrow> local.prod (exp b c)\n         b\\<guillemotright>", "by (metis (mono_tags, lifting) in_homE)"], ["proof (state)\nthis:\n  \\<guillemotleft>tuple \\<Lambda>_pr1\n                   b_pr0 : local.prod a\n                            b \\<rightarrow> local.prod (exp b c)\n       b\\<guillemotright>\n\ngoal (1 subgoal):\n 1. local.comp (eval b c) (HF'.prod (\\<Lambda> a b c g) b) = g", "define \\<Lambda>_pr1' where \"\\<Lambda>_pr1' = comp (\\<Lambda> a b c g) (pr1 a b)\""], ["proof (state)\nthis:\n  \\<Lambda>_pr1' = local.comp (\\<Lambda> a b c g) (pr1 a b)\n\ngoal (1 subgoal):\n 1. local.comp (eval b c) (HF'.prod (\\<Lambda> a b c g) b) = g", "define b_pr0' where \"b_pr0' = pr0 a b\""], ["proof (state)\nthis:\n  b_pr0' = pr0 a b\n\ngoal (1 subgoal):\n 1. local.comp (eval b c) (HF'.prod (\\<Lambda> a b c g) b) = g", "have lam_pr1_eq: \"\\<Lambda>_pr1 = \\<Lambda>_pr1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Lambda>_pr1 = \\<Lambda>_pr1'", "using assms \\<Lambda>_pr1_def \\<Lambda>_pr1'_def ideD(2) lam_simps(2)"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>g : local.prod a b \\<rightarrow> c\\<guillemotright>\n  \\<Lambda>_pr1 =\n  local.comp (\\<Lambda> a b c g)\n   (pr1 (local.dom (\\<Lambda> a b c g)) (local.dom b))\n  \\<Lambda>_pr1' = local.comp (\\<Lambda> a b c g) (pr1 a b)\n  ide ?a \\<Longrightarrow> local.dom ?a = ?a\n  \\<lbrakk>ide ?a; ide ?b; ide ?c;\n   \\<guillemotleft>?f : local.prod ?a\n                         ?b \\<rightarrow> ?c\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> local.dom (\\<Lambda> ?a ?b ?c ?f) = ?a\n\ngoal (1 subgoal):\n 1. \\<Lambda>_pr1 = \\<Lambda>_pr1'", "by auto"], ["proof (state)\nthis:\n  \\<Lambda>_pr1 = \\<Lambda>_pr1'\n\ngoal (1 subgoal):\n 1. local.comp (eval b c) (HF'.prod (\\<Lambda> a b c g) b) = g", "have b_pr0_eq: \"b_pr0 = b_pr0'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b_pr0 = b_pr0'", "using assms b_pr0_def b_pr0'_def b_pr0 comp_ide_arr"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>g : local.prod a b \\<rightarrow> c\\<guillemotright>\n  b_pr0 = local.comp b (pr0 (local.dom (\\<Lambda> a b c g)) (local.dom b))\n  b_pr0' = pr0 a b\n  \\<guillemotleft>b_pr0 : local.prod a b \\<rightarrow> b\\<guillemotright>\n  \\<lbrakk>ide ?b; seq ?b ?f\\<rbrakk>\n  \\<Longrightarrow> local.comp ?b ?f = ?f\n\ngoal (1 subgoal):\n 1. b_pr0 = b_pr0'", "by (metis (no_types, lifting) ideD(2) in_homE lam_simps(2))"], ["proof (state)\nthis:\n  b_pr0 = b_pr0'\n\ngoal (1 subgoal):\n 1. local.comp (eval b c) (HF'.prod (\\<Lambda> a b c g) b) = g", "have Fun_pr0: \"Fun (pr0 a b) = restrict (\\<lambda>x. UP (hsnd (DOWN x))) (set (prod a b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (pr0 a b) =\n    (\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b). UP (hsnd (DOWN x)))", "using assms Fun_pr0"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>g : local.prod a b \\<rightarrow> c\\<guillemotright>\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> Fun (pr0 ?a ?b) =\n                    (\\<lambda>x\\<^bold>\\<in>local.set (local.prod ?a ?b).\n                        UP (hsnd (DOWN x)))\n\ngoal (1 subgoal):\n 1. Fun (pr0 a b) =\n    (\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b). UP (hsnd (DOWN x)))", "by simp"], ["proof (state)\nthis:\n  Fun (pr0 a b) =\n  (\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b). UP (hsnd (DOWN x)))\n\ngoal (1 subgoal):\n 1. local.comp (eval b c) (HF'.prod (\\<Lambda> a b c g) b) = g", "have Fun_lam_pr1: \"Fun \\<Lambda>_pr1 =\n                         restrict (Fun (\\<Lambda> a b c g) o\n                                   restrict (\\<lambda>x. UP (hfst (DOWN x))) (set (prod a b)))\n                                  (set (prod a b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun \\<Lambda>_pr1 =\n    restrict\n     (Fun (\\<Lambda> a b c g) \\<circ>\n      (\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n          UP (hfst (DOWN x))))\n     (local.set (local.prod a b))", "using assms 1 Fun_comp Fun_pr1 lam_pr1_eq \\<Lambda>_pr1'_def"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>g : local.prod a b \\<rightarrow> c\\<guillemotright>\n  span \\<Lambda>_pr1 b_pr0\n  seq ?g ?f \\<Longrightarrow>\n  Fun (local.comp ?g ?f) = restrict (Fun ?g \\<circ> Fun ?f) (Dom ?f)\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> Fun (pr1 ?a ?b) =\n                    (\\<lambda>x\\<^bold>\\<in>local.set (local.prod ?a ?b).\n                        UP (hfst (DOWN x)))\n  \\<Lambda>_pr1 = \\<Lambda>_pr1'\n  \\<Lambda>_pr1' = local.comp (\\<Lambda> a b c g) (pr1 a b)\n\ngoal (1 subgoal):\n 1. Fun \\<Lambda>_pr1 =\n    restrict\n     (Fun (\\<Lambda> a b c g) \\<circ>\n      (\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b).\n          UP (hfst (DOWN x))))\n     (local.set (local.prod a b))", "by (metis (no_types, lifting) pr1_simps(2))"], ["proof (state)\nthis:\n  Fun \\<Lambda>_pr1 =\n  restrict\n   (Fun (\\<Lambda> a b c g) \\<circ>\n    (\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b). UP (hfst (DOWN x))))\n   (local.set (local.prod a b))\n\ngoal (1 subgoal):\n 1. local.comp (eval b c) (HF'.prod (\\<Lambda> a b c g) b) = g", "have \"comp (eval b c) (HF'.prod (\\<Lambda> a b c g) b) = comp (eval b c) (tuple \\<Lambda>_pr1 b_pr0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.comp (eval b c) (HF'.prod (\\<Lambda> a b c g) b) =\n    local.comp (eval b c) (tuple \\<Lambda>_pr1 b_pr0)", "using assms \\<Lambda>_pr1_def b_pr0_def 1 prod_in_terms_of_tuple ideD(1) lam_simps(1)"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>g : local.prod a b \\<rightarrow> c\\<guillemotright>\n  \\<Lambda>_pr1 =\n  local.comp (\\<Lambda> a b c g)\n   (pr1 (local.dom (\\<Lambda> a b c g)) (local.dom b))\n  b_pr0 = local.comp b (pr0 (local.dom (\\<Lambda> a b c g)) (local.dom b))\n  span \\<Lambda>_pr1 b_pr0\n  \\<lbrakk>arr ?f; arr ?g\\<rbrakk>\n  \\<Longrightarrow> HF'.prod ?f ?g =\n                    tuple\n                     (local.comp ?f (pr1 (local.dom ?f) (local.dom ?g)))\n                     (local.comp ?g (pr0 (local.dom ?f) (local.dom ?g)))\n  ide ?a \\<Longrightarrow> arr ?a\n  \\<lbrakk>ide ?a; ide ?b; ide ?c;\n   \\<guillemotleft>?f : local.prod ?a\n                         ?b \\<rightarrow> ?c\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> arr (\\<Lambda> ?a ?b ?c ?f)\n\ngoal (1 subgoal):\n 1. local.comp (eval b c) (HF'.prod (\\<Lambda> a b c g) b) =\n    local.comp (eval b c) (tuple \\<Lambda>_pr1 b_pr0)", "by presburger"], ["proof (state)\nthis:\n  local.comp (eval b c) (HF'.prod (\\<Lambda> a b c g) b) =\n  local.comp (eval b c) (tuple \\<Lambda>_pr1 b_pr0)\n\ngoal (1 subgoal):\n 1. local.comp (eval b c) (HF'.prod (\\<Lambda> a b c g) b) = g", "also"], ["proof (state)\nthis:\n  local.comp (eval b c) (HF'.prod (\\<Lambda> a b c g) b) =\n  local.comp (eval b c) (tuple \\<Lambda>_pr1 b_pr0)\n\ngoal (1 subgoal):\n 1. local.comp (eval b c) (HF'.prod (\\<Lambda> a b c g) b) = g", "have 5: \"... = comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.comp (eval b c) (tuple \\<Lambda>_pr1 b_pr0) =\n    local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')", "using lam_pr1_eq b_pr0_eq"], ["proof (prove)\nusing this:\n  \\<Lambda>_pr1 = \\<Lambda>_pr1'\n  b_pr0 = b_pr0'\n\ngoal (1 subgoal):\n 1. local.comp (eval b c) (tuple \\<Lambda>_pr1 b_pr0) =\n    local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')", "by simp"], ["proof (state)\nthis:\n  local.comp (eval b c) (tuple \\<Lambda>_pr1 b_pr0) =\n  local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')\n\ngoal (1 subgoal):\n 1. local.comp (eval b c) (HF'.prod (\\<Lambda> a b c g) b) = g", "also"], ["proof (state)\nthis:\n  local.comp (eval b c) (tuple \\<Lambda>_pr1 b_pr0) =\n  local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')\n\ngoal (1 subgoal):\n 1. local.comp (eval b c) (HF'.prod (\\<Lambda> a b c g) b) = g", "have \"... = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0') = g", "proof (intro arr_eqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. par (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) g\n 2. Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) = Fun g", "have 2: \"arr (comp (eval b c) (tuple \\<Lambda>_pr1 b_pr0))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq (eval b c) (tuple \\<Lambda>_pr1 b_pr0)", "using assms tuple arr_char"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>g : local.prod a b \\<rightarrow> c\\<guillemotright>\n  \\<guillemotleft>tuple \\<Lambda>_pr1\n                   b_pr0 : local.prod a\n                            b \\<rightarrow> local.prod (exp b c)\n       b\\<guillemotright>\n  arr ?f =\n  (?f \\<noteq> concrete_category.Null \\<and>\n   |concrete_category.Dom ?f| <o natLeq \\<and>\n   |concrete_category.Cod ?f| <o natLeq \\<and>\n   concrete_category.Map ?f\n   \\<in> extensional (concrete_category.Dom ?f) \\<inter>\n         (concrete_category.Dom ?f \\<rightarrow> concrete_category.Cod ?f))\n\ngoal (1 subgoal):\n 1. seq (eval b c) (tuple \\<Lambda>_pr1 b_pr0)", "by (metis (no_types, lifting) in_homE seqI eval_simps(1-2) ide_exp prod_ide_eq)"], ["proof (state)\nthis:\n  seq (eval b c) (tuple \\<Lambda>_pr1 b_pr0)\n\ngoal (2 subgoals):\n 1. par (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) g\n 2. Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) = Fun g", "have 3: \"arr g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr g", "using assms"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>g : local.prod a b \\<rightarrow> c\\<guillemotright>\n\ngoal (1 subgoal):\n 1. arr g", "by blast"], ["proof (state)\nthis:\n  arr g\n\ngoal (2 subgoals):\n 1. par (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) g\n 2. Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) = Fun g", "have tuple': \"in_hom (tuple \\<Lambda>_pr1' b_pr0') (prod a b) (prod (exp b c) b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>tuple \\<Lambda>_pr1'\n                     b_pr0' : local.prod a\n                               b \\<rightarrow> local.prod (exp b c)\n          b\\<guillemotright>", "using tuple lam_pr1_eq b_pr0_eq"], ["proof (prove)\nusing this:\n  \\<guillemotleft>tuple \\<Lambda>_pr1\n                   b_pr0 : local.prod a\n                            b \\<rightarrow> local.prod (exp b c)\n       b\\<guillemotright>\n  \\<Lambda>_pr1 = \\<Lambda>_pr1'\n  b_pr0 = b_pr0'\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>tuple \\<Lambda>_pr1'\n                     b_pr0' : local.prod a\n                               b \\<rightarrow> local.prod (exp b c)\n          b\\<guillemotright>", "by blast"], ["proof (state)\nthis:\n  \\<guillemotleft>tuple \\<Lambda>_pr1'\n                   b_pr0' : local.prod a\n                             b \\<rightarrow> local.prod (exp b c)\n        b\\<guillemotright>\n\ngoal (2 subgoals):\n 1. par (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) g\n 2. Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) = Fun g", "have 4: \"Dom g = set (prod a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dom g = local.set (local.prod a b)", "using assms"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>g : local.prod a b \\<rightarrow> c\\<guillemotright>\n\ngoal (1 subgoal):\n 1. Dom g = local.set (local.prod a b)", "by (metis (no_types, lifting) in_homE)"], ["proof (state)\nthis:\n  Dom g = local.set (local.prod a b)\n\ngoal (2 subgoals):\n 1. par (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) g\n 2. Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) = Fun g", "show par: \"par (comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. par (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) g", "using assms tuple' 2 3 5"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>g : local.prod a b \\<rightarrow> c\\<guillemotright>\n  \\<guillemotleft>tuple \\<Lambda>_pr1'\n                   b_pr0' : local.prod a\n                             b \\<rightarrow> local.prod (exp b c)\n        b\\<guillemotright>\n  seq (eval b c) (tuple \\<Lambda>_pr1 b_pr0)\n  arr g\n  local.comp (eval b c) (tuple \\<Lambda>_pr1 b_pr0) =\n  local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')\n\ngoal (1 subgoal):\n 1. par (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) g", "by (metis (no_types, lifting) cod_comp dom_comp in_homE eval_simps(3))"], ["proof (state)\nthis:\n  par (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) g\n\ngoal (1 subgoal):\n 1. Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) = Fun g", "show \"Fun (comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) = Fun g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) = Fun g", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x", "have \"x \\<notin> set (prod a b) \\<Longrightarrow> Fun (comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> local.set (local.prod a b) \\<Longrightarrow>\n    Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<notin> local.set (local.prod a b) \\<Longrightarrow>\n    Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x", "have 5: \"Fun g \\<in> extensional (Dom g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun g \\<in> extensional (Dom g)", "using assms 3 Fun_mapsto"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>g : local.prod a b \\<rightarrow> c\\<guillemotright>\n  arr g\n  arr ?f \\<Longrightarrow>\n  Fun ?f \\<in> extensional (Dom ?f) \\<inter> (Dom ?f \\<rightarrow> Cod ?f)\n\ngoal (1 subgoal):\n 1. Fun g \\<in> extensional (Dom g)", "by simp"], ["proof (state)\nthis:\n  Fun g \\<in> extensional (Dom g)\n\ngoal (1 subgoal):\n 1. x \\<notin> local.set (local.prod a b) \\<Longrightarrow>\n    Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x", "moreover"], ["proof (state)\nthis:\n  Fun g \\<in> extensional (Dom g)\n\ngoal (1 subgoal):\n 1. x \\<notin> local.set (local.prod a b) \\<Longrightarrow>\n    Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x", "have \"Fun (comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) \\<in> extensional (Dom g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0'))\n    \\<in> extensional (Dom g)", "using 5 par Fun_mapsto"], ["proof (prove)\nusing this:\n  Fun g \\<in> extensional (Dom g)\n  par (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) g\n  arr ?f \\<Longrightarrow>\n  Fun ?f \\<in> extensional (Dom ?f) \\<inter> (Dom ?f \\<rightarrow> Cod ?f)\n\ngoal (1 subgoal):\n 1. Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0'))\n    \\<in> extensional (Dom g)", "by (metis (no_types, lifting) Int_iff)"], ["proof (state)\nthis:\n  Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0'))\n  \\<in> extensional (Dom g)\n\ngoal (1 subgoal):\n 1. x \\<notin> local.set (local.prod a b) \\<Longrightarrow>\n    Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x", "ultimately"], ["proof (chain)\npicking this:\n  Fun g \\<in> extensional (Dom g)\n  Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0'))\n  \\<in> extensional (Dom g)", "show \"x \\<notin> set (prod a b) \\<Longrightarrow>\n                             Fun (comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x\""], ["proof (prove)\nusing this:\n  Fun g \\<in> extensional (Dom g)\n  Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0'))\n  \\<in> extensional (Dom g)\n\ngoal (1 subgoal):\n 1. x \\<notin> local.set (local.prod a b) \\<Longrightarrow>\n    Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x", "using 4 extensional_arb [of \"Fun g\" \"Dom g\" x]\n                    extensional_arb [of \"Fun (comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0'))\" \"Dom g\" x]"], ["proof (prove)\nusing this:\n  Fun g \\<in> extensional (Dom g)\n  Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0'))\n  \\<in> extensional (Dom g)\n  Dom g = local.set (local.prod a b)\n  \\<lbrakk>Fun g \\<in> extensional (Dom g); x \\<notin> Dom g\\<rbrakk>\n  \\<Longrightarrow> Fun g x = undefined\n  \\<lbrakk>Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0'))\n           \\<in> extensional (Dom g);\n   x \\<notin> Dom g\\<rbrakk>\n  \\<Longrightarrow> Fun (local.comp (eval b c)\n                          (tuple \\<Lambda>_pr1' b_pr0'))\n                     x =\n                    undefined\n\ngoal (1 subgoal):\n 1. x \\<notin> local.set (local.prod a b) \\<Longrightarrow>\n    Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x", "by force"], ["proof (state)\nthis:\n  x \\<notin> local.set (local.prod a b) \\<Longrightarrow>\n  Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<notin> local.set (local.prod a b) \\<Longrightarrow>\n  Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x", "moreover"], ["proof (state)\nthis:\n  x \\<notin> local.set (local.prod a b) \\<Longrightarrow>\n  Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x", "have \"x \\<in> set (prod a b) \\<Longrightarrow>\n                           Fun (comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> local.set (local.prod a b) \\<Longrightarrow>\n    Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> local.set (local.prod a b) \\<Longrightarrow>\n    Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x", "assume x: \"x \\<in> set (prod a b)\""], ["proof (state)\nthis:\n  x \\<in> local.set (local.prod a b)\n\ngoal (1 subgoal):\n 1. x \\<in> local.set (local.prod a b) \\<Longrightarrow>\n    Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x", "have 6: \"Dom (tuple \\<Lambda>_pr1' b_pr0') = set (prod a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dom (tuple \\<Lambda>_pr1' b_pr0') = local.set (local.prod a b)", "using assms 4 tuple' par"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>g : local.prod a b \\<rightarrow> c\\<guillemotright>\n  Dom g = local.set (local.prod a b)\n  \\<guillemotleft>tuple \\<Lambda>_pr1'\n                   b_pr0' : local.prod a\n                             b \\<rightarrow> local.prod (exp b c)\n        b\\<guillemotright>\n  par (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) g\n\ngoal (1 subgoal):\n 1. Dom (tuple \\<Lambda>_pr1' b_pr0') = local.set (local.prod a b)", "by (metis (no_types, lifting) in_homE)"], ["proof (state)\nthis:\n  Dom (tuple \\<Lambda>_pr1' b_pr0') = local.set (local.prod a b)\n\ngoal (1 subgoal):\n 1. x \\<in> local.set (local.prod a b) \\<Longrightarrow>\n    Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x", "have \"Fun (comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x =\n                  Fun (eval b c) (Fun (tuple \\<Lambda>_pr1' b_pr0') x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x =\n    Fun (eval b c) (Fun (tuple \\<Lambda>_pr1' b_pr0') x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x =\n    Fun (eval b c) (Fun (tuple \\<Lambda>_pr1' b_pr0') x)", "have \"Fun (comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x =\n                    (Fun (eval b c) \\<circ> Fun (tuple \\<Lambda>_pr1' b_pr0')) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x =\n    (Fun (eval b c) \\<circ> Fun (tuple \\<Lambda>_pr1' b_pr0')) x", "using assms par x 6 Fun_comp [of \"eval b c\" \"tuple \\<Lambda>_pr1' b_pr0'\"]"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>g : local.prod a b \\<rightarrow> c\\<guillemotright>\n  par (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) g\n  x \\<in> local.set (local.prod a b)\n  Dom (tuple \\<Lambda>_pr1' b_pr0') = local.set (local.prod a b)\n  seq (eval b c) (tuple \\<Lambda>_pr1' b_pr0') \\<Longrightarrow>\n  Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) =\n  restrict (Fun (eval b c) \\<circ> Fun (tuple \\<Lambda>_pr1' b_pr0'))\n   (Dom (tuple \\<Lambda>_pr1' b_pr0'))\n\ngoal (1 subgoal):\n 1. Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x =\n    (Fun (eval b c) \\<circ> Fun (tuple \\<Lambda>_pr1' b_pr0')) x", "by auto"], ["proof (state)\nthis:\n  Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x =\n  (Fun (eval b c) \\<circ> Fun (tuple \\<Lambda>_pr1' b_pr0')) x\n\ngoal (1 subgoal):\n 1. Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x =\n    Fun (eval b c) (Fun (tuple \\<Lambda>_pr1' b_pr0') x)", "also"], ["proof (state)\nthis:\n  Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x =\n  (Fun (eval b c) \\<circ> Fun (tuple \\<Lambda>_pr1' b_pr0')) x\n\ngoal (1 subgoal):\n 1. Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x =\n    Fun (eval b c) (Fun (tuple \\<Lambda>_pr1' b_pr0') x)", "have \"... = Fun (eval b c) (Fun (tuple \\<Lambda>_pr1' b_pr0') x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Fun (eval b c) \\<circ> Fun (tuple \\<Lambda>_pr1' b_pr0')) x =\n    Fun (eval b c) (Fun (tuple \\<Lambda>_pr1' b_pr0') x)", "by simp"], ["proof (state)\nthis:\n  (Fun (eval b c) \\<circ> Fun (tuple \\<Lambda>_pr1' b_pr0')) x =\n  Fun (eval b c) (Fun (tuple \\<Lambda>_pr1' b_pr0') x)\n\ngoal (1 subgoal):\n 1. Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x =\n    Fun (eval b c) (Fun (tuple \\<Lambda>_pr1' b_pr0') x)", "finally"], ["proof (chain)\npicking this:\n  Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x =\n  Fun (eval b c) (Fun (tuple \\<Lambda>_pr1' b_pr0') x)", "show ?thesis"], ["proof (prove)\nusing this:\n  Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x =\n  Fun (eval b c) (Fun (tuple \\<Lambda>_pr1' b_pr0') x)\n\ngoal (1 subgoal):\n 1. Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x =\n    Fun (eval b c) (Fun (tuple \\<Lambda>_pr1' b_pr0') x)", "by blast"], ["proof (state)\nthis:\n  Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x =\n  Fun (eval b c) (Fun (tuple \\<Lambda>_pr1' b_pr0') x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x =\n  Fun (eval b c) (Fun (tuple \\<Lambda>_pr1' b_pr0') x)\n\ngoal (1 subgoal):\n 1. x \\<in> local.set (local.prod a b) \\<Longrightarrow>\n    Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x", "also"], ["proof (state)\nthis:\n  Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x =\n  Fun (eval b c) (Fun (tuple \\<Lambda>_pr1' b_pr0') x)\n\ngoal (1 subgoal):\n 1. x \\<in> local.set (local.prod a b) \\<Longrightarrow>\n    Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x", "have \"... = restrict (\\<lambda>x. UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))\n                                      (set (HF'.prod (exp b c) b))\n                                      (Fun (tuple \\<Lambda>_pr1' b_pr0') x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (eval b c) (Fun (tuple \\<Lambda>_pr1' b_pr0') x) =\n    (\\<lambda>x\\<^bold>\\<in>local.set (HF'.prod (exp b c) b).\n        UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))\n     (Fun (tuple \\<Lambda>_pr1' b_pr0') x)", "using assms Fun_eval"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>g : local.prod a b \\<rightarrow> c\\<guillemotright>\n  \\<lbrakk>ide ?b; ide ?c\\<rbrakk>\n  \\<Longrightarrow> Fun (eval ?b ?c) =\n                    (\\<lambda>x\\<^bold>\\<in>local.set\n       (HF'.prod (exp ?b ?c) ?b).\n                        UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))\n\ngoal (1 subgoal):\n 1. Fun (eval b c) (Fun (tuple \\<Lambda>_pr1' b_pr0') x) =\n    (\\<lambda>x\\<^bold>\\<in>local.set (HF'.prod (exp b c) b).\n        UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))\n     (Fun (tuple \\<Lambda>_pr1' b_pr0') x)", "by simp"], ["proof (state)\nthis:\n  Fun (eval b c) (Fun (tuple \\<Lambda>_pr1' b_pr0') x) =\n  (\\<lambda>x\\<^bold>\\<in>local.set (HF'.prod (exp b c) b).\n      UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))\n   (Fun (tuple \\<Lambda>_pr1' b_pr0') x)\n\ngoal (1 subgoal):\n 1. x \\<in> local.set (local.prod a b) \\<Longrightarrow>\n    Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x", "also"], ["proof (state)\nthis:\n  Fun (eval b c) (Fun (tuple \\<Lambda>_pr1' b_pr0') x) =\n  (\\<lambda>x\\<^bold>\\<in>local.set (HF'.prod (exp b c) b).\n      UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))\n   (Fun (tuple \\<Lambda>_pr1' b_pr0') x)\n\ngoal (1 subgoal):\n 1. x \\<in> local.set (local.prod a b) \\<Longrightarrow>\n    Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x", "have \"... = (\\<lambda>x. UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))\n                               (Fun (tuple \\<Lambda>_pr1' b_pr0') x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<^bold>\\<in>local.set (HF'.prod (exp b c) b).\n        UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))\n     (Fun (tuple \\<Lambda>_pr1' b_pr0') x) =\n    UP (happ (hfst (DOWN (Fun (tuple \\<Lambda>_pr1' b_pr0') x)))\n         (hsnd (DOWN (Fun (tuple \\<Lambda>_pr1' b_pr0') x))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<^bold>\\<in>local.set (HF'.prod (exp b c) b).\n        UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))\n     (Fun (tuple \\<Lambda>_pr1' b_pr0') x) =\n    UP (happ (hfst (DOWN (Fun (tuple \\<Lambda>_pr1' b_pr0') x)))\n         (hsnd (DOWN (Fun (tuple \\<Lambda>_pr1' b_pr0') x))))", "have \"Fun (tuple \\<Lambda>_pr1' b_pr0') x \\<in> set (HF'.prod (exp b c) b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (tuple \\<Lambda>_pr1' b_pr0') x\n    \\<in> local.set (HF'.prod (exp b c) b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Fun (tuple \\<Lambda>_pr1' b_pr0') x\n    \\<in> local.set (HF'.prod (exp b c) b)", "have \"x \\<in> Dom (tuple \\<Lambda>_pr1' b_pr0')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Dom (tuple \\<Lambda>_pr1' b_pr0')", "using x 6"], ["proof (prove)\nusing this:\n  x \\<in> local.set (local.prod a b)\n  Dom (tuple \\<Lambda>_pr1' b_pr0') = local.set (local.prod a b)\n\ngoal (1 subgoal):\n 1. x \\<in> Dom (tuple \\<Lambda>_pr1' b_pr0')", "by blast"], ["proof (state)\nthis:\n  x \\<in> Dom (tuple \\<Lambda>_pr1' b_pr0')\n\ngoal (1 subgoal):\n 1. Fun (tuple \\<Lambda>_pr1' b_pr0') x\n    \\<in> local.set (HF'.prod (exp b c) b)", "moreover"], ["proof (state)\nthis:\n  x \\<in> Dom (tuple \\<Lambda>_pr1' b_pr0')\n\ngoal (1 subgoal):\n 1. Fun (tuple \\<Lambda>_pr1' b_pr0') x\n    \\<in> local.set (HF'.prod (exp b c) b)", "have \"Cod (tuple \\<Lambda>_pr1' b_pr0') = set (HF'.prod (exp b c) b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cod (tuple \\<Lambda>_pr1' b_pr0') = local.set (HF'.prod (exp b c) b)", "by (metis (no_types, lifting) in_homE assms(2-3) ide_exp\n                      prod_ide_eq tuple')"], ["proof (state)\nthis:\n  Cod (tuple \\<Lambda>_pr1' b_pr0') = local.set (HF'.prod (exp b c) b)\n\ngoal (1 subgoal):\n 1. Fun (tuple \\<Lambda>_pr1' b_pr0') x\n    \\<in> local.set (HF'.prod (exp b c) b)", "moreover"], ["proof (state)\nthis:\n  Cod (tuple \\<Lambda>_pr1' b_pr0') = local.set (HF'.prod (exp b c) b)\n\ngoal (1 subgoal):\n 1. Fun (tuple \\<Lambda>_pr1' b_pr0') x\n    \\<in> local.set (HF'.prod (exp b c) b)", "have \"arr (tuple \\<Lambda>_pr1' b_pr0')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (tuple \\<Lambda>_pr1' b_pr0')", "using tuple'"], ["proof (prove)\nusing this:\n  \\<guillemotleft>tuple \\<Lambda>_pr1'\n                   b_pr0' : local.prod a\n                             b \\<rightarrow> local.prod (exp b c)\n        b\\<guillemotright>\n\ngoal (1 subgoal):\n 1. arr (tuple \\<Lambda>_pr1' b_pr0')", "by blast"], ["proof (state)\nthis:\n  arr (tuple \\<Lambda>_pr1' b_pr0')\n\ngoal (1 subgoal):\n 1. Fun (tuple \\<Lambda>_pr1' b_pr0') x\n    \\<in> local.set (HF'.prod (exp b c) b)", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> Dom (tuple \\<Lambda>_pr1' b_pr0')\n  Cod (tuple \\<Lambda>_pr1' b_pr0') = local.set (HF'.prod (exp b c) b)\n  arr (tuple \\<Lambda>_pr1' b_pr0')", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> Dom (tuple \\<Lambda>_pr1' b_pr0')\n  Cod (tuple \\<Lambda>_pr1' b_pr0') = local.set (HF'.prod (exp b c) b)\n  arr (tuple \\<Lambda>_pr1' b_pr0')\n\ngoal (1 subgoal):\n 1. Fun (tuple \\<Lambda>_pr1' b_pr0') x\n    \\<in> local.set (HF'.prod (exp b c) b)", "using tuple' Fun_mapsto [of \"tuple \\<Lambda>_pr1' b_pr0'\"]"], ["proof (prove)\nusing this:\n  x \\<in> Dom (tuple \\<Lambda>_pr1' b_pr0')\n  Cod (tuple \\<Lambda>_pr1' b_pr0') = local.set (HF'.prod (exp b c) b)\n  arr (tuple \\<Lambda>_pr1' b_pr0')\n  \\<guillemotleft>tuple \\<Lambda>_pr1'\n                   b_pr0' : local.prod a\n                             b \\<rightarrow> local.prod (exp b c)\n        b\\<guillemotright>\n  arr (tuple \\<Lambda>_pr1' b_pr0') \\<Longrightarrow>\n  Fun (tuple \\<Lambda>_pr1' b_pr0')\n  \\<in> extensional (Dom (tuple \\<Lambda>_pr1' b_pr0')) \\<inter>\n        (Dom (tuple \\<Lambda>_pr1' b_pr0') \\<rightarrow>\n         Cod (tuple \\<Lambda>_pr1' b_pr0'))\n\ngoal (1 subgoal):\n 1. Fun (tuple \\<Lambda>_pr1' b_pr0') x\n    \\<in> local.set (HF'.prod (exp b c) b)", "by auto"], ["proof (state)\nthis:\n  Fun (tuple \\<Lambda>_pr1' b_pr0') x \\<in> local.set (HF'.prod (exp b c) b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Fun (tuple \\<Lambda>_pr1' b_pr0') x \\<in> local.set (HF'.prod (exp b c) b)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<^bold>\\<in>local.set (HF'.prod (exp b c) b).\n        UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))\n     (Fun (tuple \\<Lambda>_pr1' b_pr0') x) =\n    UP (happ (hfst (DOWN (Fun (tuple \\<Lambda>_pr1' b_pr0') x)))\n         (hsnd (DOWN (Fun (tuple \\<Lambda>_pr1' b_pr0') x))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  Fun (tuple \\<Lambda>_pr1' b_pr0') x \\<in> local.set (HF'.prod (exp b c) b)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<^bold>\\<in>local.set (HF'.prod (exp b c) b).\n        UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))\n     (Fun (tuple \\<Lambda>_pr1' b_pr0') x) =\n    UP (happ (hfst (DOWN (Fun (tuple \\<Lambda>_pr1' b_pr0') x)))\n         (hsnd (DOWN (Fun (tuple \\<Lambda>_pr1' b_pr0') x))))", "using restrict_apply"], ["proof (prove)\nusing this:\n  Fun (tuple \\<Lambda>_pr1' b_pr0') x \\<in> local.set (HF'.prod (exp b c) b)\n  restrict ?f ?A ?x = (if ?x \\<in> ?A then ?f ?x else undefined)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<^bold>\\<in>local.set (HF'.prod (exp b c) b).\n        UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))\n     (Fun (tuple \\<Lambda>_pr1' b_pr0') x) =\n    UP (happ (hfst (DOWN (Fun (tuple \\<Lambda>_pr1' b_pr0') x)))\n         (hsnd (DOWN (Fun (tuple \\<Lambda>_pr1' b_pr0') x))))", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>x\\<^bold>\\<in>local.set (HF'.prod (exp b c) b).\n      UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))\n   (Fun (tuple \\<Lambda>_pr1' b_pr0') x) =\n  UP (happ (hfst (DOWN (Fun (tuple \\<Lambda>_pr1' b_pr0') x)))\n       (hsnd (DOWN (Fun (tuple \\<Lambda>_pr1' b_pr0') x))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>x\\<^bold>\\<in>local.set (HF'.prod (exp b c) b).\n      UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))\n   (Fun (tuple \\<Lambda>_pr1' b_pr0') x) =\n  UP (happ (hfst (DOWN (Fun (tuple \\<Lambda>_pr1' b_pr0') x)))\n       (hsnd (DOWN (Fun (tuple \\<Lambda>_pr1' b_pr0') x))))\n\ngoal (1 subgoal):\n 1. x \\<in> local.set (local.prod a b) \\<Longrightarrow>\n    Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x", "also"], ["proof (state)\nthis:\n  (\\<lambda>x\\<^bold>\\<in>local.set (HF'.prod (exp b c) b).\n      UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))\n   (Fun (tuple \\<Lambda>_pr1' b_pr0') x) =\n  UP (happ (hfst (DOWN (Fun (tuple \\<Lambda>_pr1' b_pr0') x)))\n       (hsnd (DOWN (Fun (tuple \\<Lambda>_pr1' b_pr0') x))))\n\ngoal (1 subgoal):\n 1. x \\<in> local.set (local.prod a b) \\<Longrightarrow>\n    Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x", "have \"... = (\\<lambda>x. UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))\n                               (UP \\<langle>DOWN (Fun \\<Lambda>_pr1' x), DOWN (Fun b_pr0' x)\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP (happ (hfst (DOWN (Fun (tuple \\<Lambda>_pr1' b_pr0') x)))\n         (hsnd (DOWN (Fun (tuple \\<Lambda>_pr1' b_pr0') x)))) =\n    UP (happ\n         (hfst\n           (DOWN\n             (UP \\<langle>DOWN (Fun \\<Lambda>_pr1' x),\n                          DOWN (Fun b_pr0' x)\\<rangle>)))\n         (hsnd\n           (DOWN\n             (UP \\<langle>DOWN (Fun \\<Lambda>_pr1' x),\n                          DOWN (Fun b_pr0' x)\\<rangle>))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. UP (happ (hfst (DOWN (Fun (tuple \\<Lambda>_pr1' b_pr0') x)))\n         (hsnd (DOWN (Fun (tuple \\<Lambda>_pr1' b_pr0') x)))) =\n    UP (happ\n         (hfst\n           (DOWN\n             (UP \\<langle>DOWN (Fun \\<Lambda>_pr1' x),\n                          DOWN (Fun b_pr0' x)\\<rangle>)))\n         (hsnd\n           (DOWN\n             (UP \\<langle>DOWN (Fun \\<Lambda>_pr1' x),\n                          DOWN (Fun b_pr0' x)\\<rangle>))))", "have 7: \"Dom \\<Lambda>_pr1' = set (prod a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dom \\<Lambda>_pr1' = local.set (local.prod a b)", "using assms"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>g : local.prod a b \\<rightarrow> c\\<guillemotright>\n\ngoal (1 subgoal):\n 1. Dom \\<Lambda>_pr1' = local.set (local.prod a b)", "by (metis (no_types, lifting) 1 comp_ide_arr ideD(2)\n                    b_pr0_def lam_pr1_eq lam_simps(2) pr0_simps(2))"], ["proof (state)\nthis:\n  Dom \\<Lambda>_pr1' = local.set (local.prod a b)\n\ngoal (1 subgoal):\n 1. UP (happ (hfst (DOWN (Fun (tuple \\<Lambda>_pr1' b_pr0') x)))\n         (hsnd (DOWN (Fun (tuple \\<Lambda>_pr1' b_pr0') x)))) =\n    UP (happ\n         (hfst\n           (DOWN\n             (UP \\<langle>DOWN (Fun \\<Lambda>_pr1' x),\n                          DOWN (Fun b_pr0' x)\\<rangle>)))\n         (hsnd\n           (DOWN\n             (UP \\<langle>DOWN (Fun \\<Lambda>_pr1' x),\n                          DOWN (Fun b_pr0' x)\\<rangle>))))", "moreover"], ["proof (state)\nthis:\n  Dom \\<Lambda>_pr1' = local.set (local.prod a b)\n\ngoal (1 subgoal):\n 1. UP (happ (hfst (DOWN (Fun (tuple \\<Lambda>_pr1' b_pr0') x)))\n         (hsnd (DOWN (Fun (tuple \\<Lambda>_pr1' b_pr0') x)))) =\n    UP (happ\n         (hfst\n           (DOWN\n             (UP \\<langle>DOWN (Fun \\<Lambda>_pr1' x),\n                          DOWN (Fun b_pr0' x)\\<rangle>)))\n         (hsnd\n           (DOWN\n             (UP \\<langle>DOWN (Fun \\<Lambda>_pr1' x),\n                          DOWN (Fun b_pr0' x)\\<rangle>))))", "have \"span \\<Lambda>_pr1' b_pr0'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. span \\<Lambda>_pr1' b_pr0'", "using assms 1 b_pr0_eq lam_pr1_eq"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>g : local.prod a b \\<rightarrow> c\\<guillemotright>\n  span \\<Lambda>_pr1 b_pr0\n  b_pr0 = b_pr0'\n  \\<Lambda>_pr1 = \\<Lambda>_pr1'\n\ngoal (1 subgoal):\n 1. span \\<Lambda>_pr1' b_pr0'", "by auto"], ["proof (state)\nthis:\n  span \\<Lambda>_pr1' b_pr0'\n\ngoal (1 subgoal):\n 1. UP (happ (hfst (DOWN (Fun (tuple \\<Lambda>_pr1' b_pr0') x)))\n         (hsnd (DOWN (Fun (tuple \\<Lambda>_pr1' b_pr0') x)))) =\n    UP (happ\n         (hfst\n           (DOWN\n             (UP \\<langle>DOWN (Fun \\<Lambda>_pr1' x),\n                          DOWN (Fun b_pr0' x)\\<rangle>)))\n         (hsnd\n           (DOWN\n             (UP \\<langle>DOWN (Fun \\<Lambda>_pr1' x),\n                          DOWN (Fun b_pr0' x)\\<rangle>))))", "moreover"], ["proof (state)\nthis:\n  span \\<Lambda>_pr1' b_pr0'\n\ngoal (1 subgoal):\n 1. UP (happ (hfst (DOWN (Fun (tuple \\<Lambda>_pr1' b_pr0') x)))\n         (hsnd (DOWN (Fun (tuple \\<Lambda>_pr1' b_pr0') x)))) =\n    UP (happ\n         (hfst\n           (DOWN\n             (UP \\<langle>DOWN (Fun \\<Lambda>_pr1' x),\n                          DOWN (Fun b_pr0' x)\\<rangle>)))\n         (hsnd\n           (DOWN\n             (UP \\<langle>DOWN (Fun \\<Lambda>_pr1' x),\n                          DOWN (Fun b_pr0' x)\\<rangle>))))", "have \"x \\<in> Dom \\<Lambda>_pr1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Dom \\<Lambda>_pr1'", "using x 7"], ["proof (prove)\nusing this:\n  x \\<in> local.set (local.prod a b)\n  Dom \\<Lambda>_pr1' = local.set (local.prod a b)\n\ngoal (1 subgoal):\n 1. x \\<in> Dom \\<Lambda>_pr1'", "by simp"], ["proof (state)\nthis:\n  x \\<in> Dom \\<Lambda>_pr1'\n\ngoal (1 subgoal):\n 1. UP (happ (hfst (DOWN (Fun (tuple \\<Lambda>_pr1' b_pr0') x)))\n         (hsnd (DOWN (Fun (tuple \\<Lambda>_pr1' b_pr0') x)))) =\n    UP (happ\n         (hfst\n           (DOWN\n             (UP \\<langle>DOWN (Fun \\<Lambda>_pr1' x),\n                          DOWN (Fun b_pr0' x)\\<rangle>)))\n         (hsnd\n           (DOWN\n             (UP \\<langle>DOWN (Fun \\<Lambda>_pr1' x),\n                          DOWN (Fun b_pr0' x)\\<rangle>))))", "ultimately"], ["proof (chain)\npicking this:\n  Dom \\<Lambda>_pr1' = local.set (local.prod a b)\n  span \\<Lambda>_pr1' b_pr0'\n  x \\<in> Dom \\<Lambda>_pr1'", "have \"Fun (tuple \\<Lambda>_pr1' b_pr0') x =\n                               UP \\<langle>DOWN (Fun \\<Lambda>_pr1' x), DOWN (Fun b_pr0' x)\\<rangle>\""], ["proof (prove)\nusing this:\n  Dom \\<Lambda>_pr1' = local.set (local.prod a b)\n  span \\<Lambda>_pr1' b_pr0'\n  x \\<in> Dom \\<Lambda>_pr1'\n\ngoal (1 subgoal):\n 1. Fun (tuple \\<Lambda>_pr1' b_pr0') x =\n    UP \\<langle>DOWN (Fun \\<Lambda>_pr1' x), DOWN (Fun b_pr0' x)\\<rangle>", "using assms x restrict_apply Fun_tuple"], ["proof (prove)\nusing this:\n  Dom \\<Lambda>_pr1' = local.set (local.prod a b)\n  span \\<Lambda>_pr1' b_pr0'\n  x \\<in> Dom \\<Lambda>_pr1'\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>g : local.prod a b \\<rightarrow> c\\<guillemotright>\n  x \\<in> local.set (local.prod a b)\n  restrict ?f ?A ?x = (if ?x \\<in> ?A then ?f ?x else undefined)\n  span ?f ?g \\<Longrightarrow>\n  Fun (tuple ?f ?g) =\n  (\\<lambda>x\\<^bold>\\<in>Dom ?f.\n      UP \\<langle>DOWN (Fun ?f x), DOWN (Fun ?g x)\\<rangle>)\n\ngoal (1 subgoal):\n 1. Fun (tuple \\<Lambda>_pr1' b_pr0') x =\n    UP \\<langle>DOWN (Fun \\<Lambda>_pr1' x), DOWN (Fun b_pr0' x)\\<rangle>", "by simp"], ["proof (state)\nthis:\n  Fun (tuple \\<Lambda>_pr1' b_pr0') x =\n  UP \\<langle>DOWN (Fun \\<Lambda>_pr1' x), DOWN (Fun b_pr0' x)\\<rangle>\n\ngoal (1 subgoal):\n 1. UP (happ (hfst (DOWN (Fun (tuple \\<Lambda>_pr1' b_pr0') x)))\n         (hsnd (DOWN (Fun (tuple \\<Lambda>_pr1' b_pr0') x)))) =\n    UP (happ\n         (hfst\n           (DOWN\n             (UP \\<langle>DOWN (Fun \\<Lambda>_pr1' x),\n                          DOWN (Fun b_pr0' x)\\<rangle>)))\n         (hsnd\n           (DOWN\n             (UP \\<langle>DOWN (Fun \\<Lambda>_pr1' x),\n                          DOWN (Fun b_pr0' x)\\<rangle>))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  Fun (tuple \\<Lambda>_pr1' b_pr0') x =\n  UP \\<langle>DOWN (Fun \\<Lambda>_pr1' x), DOWN (Fun b_pr0' x)\\<rangle>\n\ngoal (1 subgoal):\n 1. UP (happ (hfst (DOWN (Fun (tuple \\<Lambda>_pr1' b_pr0') x)))\n         (hsnd (DOWN (Fun (tuple \\<Lambda>_pr1' b_pr0') x)))) =\n    UP (happ\n         (hfst\n           (DOWN\n             (UP \\<langle>DOWN (Fun \\<Lambda>_pr1' x),\n                          DOWN (Fun b_pr0' x)\\<rangle>)))\n         (hsnd\n           (DOWN\n             (UP \\<langle>DOWN (Fun \\<Lambda>_pr1' x),\n                          DOWN (Fun b_pr0' x)\\<rangle>))))", "by simp"], ["proof (state)\nthis:\n  UP (happ (hfst (DOWN (Fun (tuple \\<Lambda>_pr1' b_pr0') x)))\n       (hsnd (DOWN (Fun (tuple \\<Lambda>_pr1' b_pr0') x)))) =\n  UP (happ\n       (hfst\n         (DOWN\n           (UP \\<langle>DOWN (Fun \\<Lambda>_pr1' x),\n                        DOWN (Fun b_pr0' x)\\<rangle>)))\n       (hsnd\n         (DOWN\n           (UP \\<langle>DOWN (Fun \\<Lambda>_pr1' x),\n                        DOWN (Fun b_pr0' x)\\<rangle>))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  UP (happ (hfst (DOWN (Fun (tuple \\<Lambda>_pr1' b_pr0') x)))\n       (hsnd (DOWN (Fun (tuple \\<Lambda>_pr1' b_pr0') x)))) =\n  UP (happ\n       (hfst\n         (DOWN\n           (UP \\<langle>DOWN (Fun \\<Lambda>_pr1' x),\n                        DOWN (Fun b_pr0' x)\\<rangle>)))\n       (hsnd\n         (DOWN\n           (UP \\<langle>DOWN (Fun \\<Lambda>_pr1' x),\n                        DOWN (Fun b_pr0' x)\\<rangle>))))\n\ngoal (1 subgoal):\n 1. x \\<in> local.set (local.prod a b) \\<Longrightarrow>\n    Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x", "also"], ["proof (state)\nthis:\n  UP (happ (hfst (DOWN (Fun (tuple \\<Lambda>_pr1' b_pr0') x)))\n       (hsnd (DOWN (Fun (tuple \\<Lambda>_pr1' b_pr0') x)))) =\n  UP (happ\n       (hfst\n         (DOWN\n           (UP \\<langle>DOWN (Fun \\<Lambda>_pr1' x),\n                        DOWN (Fun b_pr0' x)\\<rangle>)))\n       (hsnd\n         (DOWN\n           (UP \\<langle>DOWN (Fun \\<Lambda>_pr1' x),\n                        DOWN (Fun b_pr0' x)\\<rangle>))))\n\ngoal (1 subgoal):\n 1. x \\<in> local.set (local.prod a b) \\<Longrightarrow>\n    Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x", "have \"... = UP (happ (DOWN (Fun \\<Lambda>_pr1' x)) (DOWN (Fun b_pr0' x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP (happ\n         (hfst\n           (DOWN\n             (UP \\<langle>DOWN (Fun \\<Lambda>_pr1' x),\n                          DOWN (Fun b_pr0' x)\\<rangle>)))\n         (hsnd\n           (DOWN\n             (UP \\<langle>DOWN (Fun \\<Lambda>_pr1' x),\n                          DOWN (Fun b_pr0' x)\\<rangle>)))) =\n    UP (happ (DOWN (Fun \\<Lambda>_pr1' x)) (DOWN (Fun b_pr0' x)))", "using assms"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>g : local.prod a b \\<rightarrow> c\\<guillemotright>\n\ngoal (1 subgoal):\n 1. UP (happ\n         (hfst\n           (DOWN\n             (UP \\<langle>DOWN (Fun \\<Lambda>_pr1' x),\n                          DOWN (Fun b_pr0' x)\\<rangle>)))\n         (hsnd\n           (DOWN\n             (UP \\<langle>DOWN (Fun \\<Lambda>_pr1' x),\n                          DOWN (Fun b_pr0' x)\\<rangle>)))) =\n    UP (happ (DOWN (Fun \\<Lambda>_pr1' x)) (DOWN (Fun b_pr0' x)))", "by simp"], ["proof (state)\nthis:\n  UP (happ\n       (hfst\n         (DOWN\n           (UP \\<langle>DOWN (Fun \\<Lambda>_pr1' x),\n                        DOWN (Fun b_pr0' x)\\<rangle>)))\n       (hsnd\n         (DOWN\n           (UP \\<langle>DOWN (Fun \\<Lambda>_pr1' x),\n                        DOWN (Fun b_pr0' x)\\<rangle>)))) =\n  UP (happ (DOWN (Fun \\<Lambda>_pr1' x)) (DOWN (Fun b_pr0' x)))\n\ngoal (1 subgoal):\n 1. x \\<in> local.set (local.prod a b) \\<Longrightarrow>\n    Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x", "also"], ["proof (state)\nthis:\n  UP (happ\n       (hfst\n         (DOWN\n           (UP \\<langle>DOWN (Fun \\<Lambda>_pr1' x),\n                        DOWN (Fun b_pr0' x)\\<rangle>)))\n       (hsnd\n         (DOWN\n           (UP \\<langle>DOWN (Fun \\<Lambda>_pr1' x),\n                        DOWN (Fun b_pr0' x)\\<rangle>)))) =\n  UP (happ (DOWN (Fun \\<Lambda>_pr1' x)) (DOWN (Fun b_pr0' x)))\n\ngoal (1 subgoal):\n 1. x \\<in> local.set (local.prod a b) \\<Longrightarrow>\n    Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x", "have \"... = UP (happ (DOWN (UP (happ (hlam (ide_to_hf a) (ide_to_hf b)\n                                                            (ide_to_hf c) (arr_to_hfun g))\n                                      (hfst (DOWN x)))))\n                                      (DOWN (UP (hsnd (DOWN x)))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP (happ (DOWN (Fun \\<Lambda>_pr1' x)) (DOWN (Fun b_pr0' x))) =\n    UP (happ\n         (DOWN\n           (UP (happ\n                 (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n                   (arr_to_hfun g))\n                 (hfst (DOWN x)))))\n         (DOWN (UP (hsnd (DOWN x)))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. UP (happ (DOWN (Fun \\<Lambda>_pr1' x)) (DOWN (Fun b_pr0' x))) =\n    UP (happ\n         (DOWN\n           (UP (happ\n                 (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n                   (arr_to_hfun g))\n                 (hfst (DOWN x)))))\n         (DOWN (UP (hsnd (DOWN x)))))", "have \"Fun b_pr0' x = UP (hsnd (DOWN x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun b_pr0' x = UP (hsnd (DOWN x))", "using assms x Fun_pr0 b_pr0'_def"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>g : local.prod a b \\<rightarrow> c\\<guillemotright>\n  x \\<in> local.set (local.prod a b)\n  Fun (pr0 a b) =\n  (\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b). UP (hsnd (DOWN x)))\n  b_pr0' = pr0 a b\n\ngoal (1 subgoal):\n 1. Fun b_pr0' x = UP (hsnd (DOWN x))", "by simp"], ["proof (state)\nthis:\n  Fun b_pr0' x = UP (hsnd (DOWN x))\n\ngoal (1 subgoal):\n 1. UP (happ (DOWN (Fun \\<Lambda>_pr1' x)) (DOWN (Fun b_pr0' x))) =\n    UP (happ\n         (DOWN\n           (UP (happ\n                 (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n                   (arr_to_hfun g))\n                 (hfst (DOWN x)))))\n         (DOWN (UP (hsnd (DOWN x)))))", "moreover"], ["proof (state)\nthis:\n  Fun b_pr0' x = UP (hsnd (DOWN x))\n\ngoal (1 subgoal):\n 1. UP (happ (DOWN (Fun \\<Lambda>_pr1' x)) (DOWN (Fun b_pr0' x))) =\n    UP (happ\n         (DOWN\n           (UP (happ\n                 (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n                   (arr_to_hfun g))\n                 (hfst (DOWN x)))))\n         (DOWN (UP (hsnd (DOWN x)))))", "have \"Fun \\<Lambda>_pr1' x =\n                             UP (happ (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n                                            (arr_to_hfun g))\n                                      (hfst (DOWN x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun \\<Lambda>_pr1' x =\n    UP (happ\n         (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n         (hfst (DOWN x)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Fun \\<Lambda>_pr1' x =\n    UP (happ\n         (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n         (hfst (DOWN x)))", "have \"Fun \\<Lambda>_pr1' x =\n                      restrict (Fun (\\<Lambda> a b c g) o Fun (pr1 a b)) (Dom (pr1 a b)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun \\<Lambda>_pr1' x =\n    restrict (Fun (\\<Lambda> a b c g) \\<circ> Fun (pr1 a b)) (Dom (pr1 a b))\n     x", "using assms x Fun_pr1 Fun_comp lam_pr1_eq Fun_lam_pr1 pr1_simps(1-2)"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>g : local.prod a b \\<rightarrow> c\\<guillemotright>\n  x \\<in> local.set (local.prod a b)\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> Fun (pr1 ?a ?b) =\n                    (\\<lambda>x\\<^bold>\\<in>local.set (local.prod ?a ?b).\n                        UP (hfst (DOWN x)))\n  seq ?g ?f \\<Longrightarrow>\n  Fun (local.comp ?g ?f) = restrict (Fun ?g \\<circ> Fun ?f) (Dom ?f)\n  \\<Lambda>_pr1 = \\<Lambda>_pr1'\n  Fun \\<Lambda>_pr1 =\n  restrict\n   (Fun (\\<Lambda> a b c g) \\<circ>\n    (\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b). UP (hfst (DOWN x))))\n   (local.set (local.prod a b))\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk> \\<Longrightarrow> arr (pr1 ?a ?b)\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> local.dom (pr1 ?a ?b) = local.prod ?a ?b\n\ngoal (1 subgoal):\n 1. Fun \\<Lambda>_pr1' x =\n    restrict (Fun (\\<Lambda> a b c g) \\<circ> Fun (pr1 a b)) (Dom (pr1 a b))\n     x", "by presburger"], ["proof (state)\nthis:\n  Fun \\<Lambda>_pr1' x =\n  restrict (Fun (\\<Lambda> a b c g) \\<circ> Fun (pr1 a b)) (Dom (pr1 a b)) x\n\ngoal (1 subgoal):\n 1. Fun \\<Lambda>_pr1' x =\n    UP (happ\n         (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n         (hfst (DOWN x)))", "also"], ["proof (state)\nthis:\n  Fun \\<Lambda>_pr1' x =\n  restrict (Fun (\\<Lambda> a b c g) \\<circ> Fun (pr1 a b)) (Dom (pr1 a b)) x\n\ngoal (1 subgoal):\n 1. Fun \\<Lambda>_pr1' x =\n    UP (happ\n         (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n         (hfst (DOWN x)))", "have \"... = Fun (\\<Lambda> a b c g) (Fun (pr1 a b) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict (Fun (\\<Lambda> a b c g) \\<circ> Fun (pr1 a b)) (Dom (pr1 a b))\n     x =\n    Fun (\\<Lambda> a b c g) (Fun (pr1 a b) x)", "using assms x restrict_apply Fun_lam_pr1 Fun_pr1 calculation lam_pr1_eq"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>g : local.prod a b \\<rightarrow> c\\<guillemotright>\n  x \\<in> local.set (local.prod a b)\n  restrict ?f ?A ?x = (if ?x \\<in> ?A then ?f ?x else undefined)\n  Fun \\<Lambda>_pr1 =\n  restrict\n   (Fun (\\<Lambda> a b c g) \\<circ>\n    (\\<lambda>x\\<^bold>\\<in>local.set (local.prod a b). UP (hfst (DOWN x))))\n   (local.set (local.prod a b))\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> Fun (pr1 ?a ?b) =\n                    (\\<lambda>x\\<^bold>\\<in>local.set (local.prod ?a ?b).\n                        UP (hfst (DOWN x)))\n  Fun \\<Lambda>_pr1' x =\n  restrict (Fun (\\<Lambda> a b c g) \\<circ> Fun (pr1 a b)) (Dom (pr1 a b)) x\n  \\<Lambda>_pr1 = \\<Lambda>_pr1'\n\ngoal (1 subgoal):\n 1. restrict (Fun (\\<Lambda> a b c g) \\<circ> Fun (pr1 a b)) (Dom (pr1 a b))\n     x =\n    Fun (\\<Lambda> a b c g) (Fun (pr1 a b) x)", "by auto"], ["proof (state)\nthis:\n  restrict (Fun (\\<Lambda> a b c g) \\<circ> Fun (pr1 a b)) (Dom (pr1 a b))\n   x =\n  Fun (\\<Lambda> a b c g) (Fun (pr1 a b) x)\n\ngoal (1 subgoal):\n 1. Fun \\<Lambda>_pr1' x =\n    UP (happ\n         (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n         (hfst (DOWN x)))", "also"], ["proof (state)\nthis:\n  restrict (Fun (\\<Lambda> a b c g) \\<circ> Fun (pr1 a b)) (Dom (pr1 a b))\n   x =\n  Fun (\\<Lambda> a b c g) (Fun (pr1 a b) x)\n\ngoal (1 subgoal):\n 1. Fun \\<Lambda>_pr1' x =\n    UP (happ\n         (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n         (hfst (DOWN x)))", "have \"... = restrict (\\<lambda>x. UP (happ (hlam (ide_to_hf a) (ide_to_hf b)\n                                                              (ide_to_hf c) (arr_to_hfun g))\n                                          (DOWN x)))\n                                          (set a)\n                                          (Fun (pr1 a b) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (\\<Lambda> a b c g) (Fun (pr1 a b) x) =\n    (\\<lambda>x\\<^bold>\\<in>local.set a.\n        UP (happ\n             (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n               (arr_to_hfun g))\n             (DOWN x)))\n     (Fun (pr1 a b) x)", "using assms x Fun_lam"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>g : local.prod a b \\<rightarrow> c\\<guillemotright>\n  x \\<in> local.set (local.prod a b)\n  \\<lbrakk>ide ?a; ide ?b; ide ?c;\n   \\<guillemotleft>?f : local.prod ?a\n                         ?b \\<rightarrow> ?c\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> Fun (\\<Lambda> ?a ?b ?c ?f) =\n                    (\\<lambda>x\\<^bold>\\<in>local.set ?a.\n                        UP (happ\n                             (hlam (ide_to_hf ?a) (ide_to_hf ?b)\n                               (ide_to_hf ?c) (arr_to_hfun ?f))\n                             (DOWN x)))\n\ngoal (1 subgoal):\n 1. Fun (\\<Lambda> a b c g) (Fun (pr1 a b) x) =\n    (\\<lambda>x\\<^bold>\\<in>local.set a.\n        UP (happ\n             (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n               (arr_to_hfun g))\n             (DOWN x)))\n     (Fun (pr1 a b) x)", "by simp"], ["proof (state)\nthis:\n  Fun (\\<Lambda> a b c g) (Fun (pr1 a b) x) =\n  (\\<lambda>x\\<^bold>\\<in>local.set a.\n      UP (happ\n           (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n           (DOWN x)))\n   (Fun (pr1 a b) x)\n\ngoal (1 subgoal):\n 1. Fun \\<Lambda>_pr1' x =\n    UP (happ\n         (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n         (hfst (DOWN x)))", "also"], ["proof (state)\nthis:\n  Fun (\\<Lambda> a b c g) (Fun (pr1 a b) x) =\n  (\\<lambda>x\\<^bold>\\<in>local.set a.\n      UP (happ\n           (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n           (DOWN x)))\n   (Fun (pr1 a b) x)\n\ngoal (1 subgoal):\n 1. Fun \\<Lambda>_pr1' x =\n    UP (happ\n         (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n         (hfst (DOWN x)))", "have \"... = UP (happ (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n                                                (arr_to_hfun g))\n                                          (DOWN (Fun (pr1 a b) x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<^bold>\\<in>local.set a.\n        UP (happ\n             (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n               (arr_to_hfun g))\n             (DOWN x)))\n     (Fun (pr1 a b) x) =\n    UP (happ\n         (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n         (DOWN (Fun (pr1 a b) x)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<^bold>\\<in>local.set a.\n        UP (happ\n             (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n               (arr_to_hfun g))\n             (DOWN x)))\n     (Fun (pr1 a b) x) =\n    UP (happ\n         (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n         (DOWN (Fun (pr1 a b) x)))", "have \"Fun (pr1 a b) x \\<in> set a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (pr1 a b) x \\<in> local.set a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Fun (pr1 a b) x \\<in> local.set a", "have \"x \\<in> Dom (pr1 a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Dom (pr1 a b)", "using assms x pr1_simps(1-2)"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>g : local.prod a b \\<rightarrow> c\\<guillemotright>\n  x \\<in> local.set (local.prod a b)\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk> \\<Longrightarrow> arr (pr1 ?a ?b)\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> local.dom (pr1 ?a ?b) = local.prod ?a ?b\n\ngoal (1 subgoal):\n 1. x \\<in> Dom (pr1 a b)", "by auto"], ["proof (state)\nthis:\n  x \\<in> Dom (pr1 a b)\n\ngoal (1 subgoal):\n 1. Fun (pr1 a b) x \\<in> local.set a", "moreover"], ["proof (state)\nthis:\n  x \\<in> Dom (pr1 a b)\n\ngoal (1 subgoal):\n 1. Fun (pr1 a b) x \\<in> local.set a", "have \"Cod (pr1 a b) = set a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cod (pr1 a b) = local.set a", "using assms HF'.cod_pr1 pr1_simps(1)"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>g : local.prod a b \\<rightarrow> c\\<guillemotright>\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk> \\<Longrightarrow> cod (pr1 ?a ?b) = ?a\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk> \\<Longrightarrow> arr (pr1 ?a ?b)\n\ngoal (1 subgoal):\n 1. Cod (pr1 a b) = local.set a", "by auto"], ["proof (state)\nthis:\n  Cod (pr1 a b) = local.set a\n\ngoal (1 subgoal):\n 1. Fun (pr1 a b) x \\<in> local.set a", "moreover"], ["proof (state)\nthis:\n  Cod (pr1 a b) = local.set a\n\ngoal (1 subgoal):\n 1. Fun (pr1 a b) x \\<in> local.set a", "have \"arr (pr1 a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (pr1 a b)", "using assms arr_char"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>g : local.prod a b \\<rightarrow> c\\<guillemotright>\n  arr ?f =\n  (?f \\<noteq> concrete_category.Null \\<and>\n   |concrete_category.Dom ?f| <o natLeq \\<and>\n   |concrete_category.Cod ?f| <o natLeq \\<and>\n   concrete_category.Map ?f\n   \\<in> extensional (concrete_category.Dom ?f) \\<inter>\n         (concrete_category.Dom ?f \\<rightarrow> concrete_category.Cod ?f))\n\ngoal (1 subgoal):\n 1. arr (pr1 a b)", "by blast"], ["proof (state)\nthis:\n  arr (pr1 a b)\n\ngoal (1 subgoal):\n 1. Fun (pr1 a b) x \\<in> local.set a", "ultimately"], ["proof (chain)\npicking this:\n  x \\<in> Dom (pr1 a b)\n  Cod (pr1 a b) = local.set a\n  arr (pr1 a b)", "show ?thesis"], ["proof (prove)\nusing this:\n  x \\<in> Dom (pr1 a b)\n  Cod (pr1 a b) = local.set a\n  arr (pr1 a b)\n\ngoal (1 subgoal):\n 1. Fun (pr1 a b) x \\<in> local.set a", "using Fun_mapsto [of \"pr1 a b\"]"], ["proof (prove)\nusing this:\n  x \\<in> Dom (pr1 a b)\n  Cod (pr1 a b) = local.set a\n  arr (pr1 a b)\n  arr (pr1 a b) \\<Longrightarrow>\n  Fun (pr1 a b)\n  \\<in> extensional (Dom (pr1 a b)) \\<inter>\n        (Dom (pr1 a b) \\<rightarrow> Cod (pr1 a b))\n\ngoal (1 subgoal):\n 1. Fun (pr1 a b) x \\<in> local.set a", "by auto"], ["proof (state)\nthis:\n  Fun (pr1 a b) x \\<in> local.set a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Fun (pr1 a b) x \\<in> local.set a\n\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<^bold>\\<in>local.set a.\n        UP (happ\n             (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n               (arr_to_hfun g))\n             (DOWN x)))\n     (Fun (pr1 a b) x) =\n    UP (happ\n         (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n         (DOWN (Fun (pr1 a b) x)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  Fun (pr1 a b) x \\<in> local.set a\n\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<^bold>\\<in>local.set a.\n        UP (happ\n             (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n               (arr_to_hfun g))\n             (DOWN x)))\n     (Fun (pr1 a b) x) =\n    UP (happ\n         (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n         (DOWN (Fun (pr1 a b) x)))", "using restrict_apply"], ["proof (prove)\nusing this:\n  Fun (pr1 a b) x \\<in> local.set a\n  restrict ?f ?A ?x = (if ?x \\<in> ?A then ?f ?x else undefined)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<^bold>\\<in>local.set a.\n        UP (happ\n             (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n               (arr_to_hfun g))\n             (DOWN x)))\n     (Fun (pr1 a b) x) =\n    UP (happ\n         (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n         (DOWN (Fun (pr1 a b) x)))", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>x\\<^bold>\\<in>local.set a.\n      UP (happ\n           (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n           (DOWN x)))\n   (Fun (pr1 a b) x) =\n  UP (happ (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n       (DOWN (Fun (pr1 a b) x)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>x\\<^bold>\\<in>local.set a.\n      UP (happ\n           (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n           (DOWN x)))\n   (Fun (pr1 a b) x) =\n  UP (happ (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n       (DOWN (Fun (pr1 a b) x)))\n\ngoal (1 subgoal):\n 1. Fun \\<Lambda>_pr1' x =\n    UP (happ\n         (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n         (hfst (DOWN x)))", "also"], ["proof (state)\nthis:\n  (\\<lambda>x\\<^bold>\\<in>local.set a.\n      UP (happ\n           (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n           (DOWN x)))\n   (Fun (pr1 a b) x) =\n  UP (happ (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n       (DOWN (Fun (pr1 a b) x)))\n\ngoal (1 subgoal):\n 1. Fun \\<Lambda>_pr1' x =\n    UP (happ\n         (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n         (hfst (DOWN x)))", "have \"... = UP (happ (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n                                                (arr_to_hfun g))\n                                          (hfst (DOWN x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP (happ\n         (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n         (DOWN (Fun (pr1 a b) x))) =\n    UP (happ\n         (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n         (hfst (DOWN x)))", "using assms x Fun_pr1 Fun_lam [of a b c g]"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>g : local.prod a b \\<rightarrow> c\\<guillemotright>\n  x \\<in> local.set (local.prod a b)\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> Fun (pr1 ?a ?b) =\n                    (\\<lambda>x\\<^bold>\\<in>local.set (local.prod ?a ?b).\n                        UP (hfst (DOWN x)))\n  \\<lbrakk>ide a; ide b; ide c;\n   \\<guillemotleft>g : local.prod a\n                        b \\<rightarrow> c\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> Fun (\\<Lambda> a b c g) =\n                    (\\<lambda>x\\<^bold>\\<in>local.set a.\n                        UP (happ\n                             (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n                               (arr_to_hfun g))\n                             (DOWN x)))\n\ngoal (1 subgoal):\n 1. UP (happ\n         (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n         (DOWN (Fun (pr1 a b) x))) =\n    UP (happ\n         (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n         (hfst (DOWN x)))", "by simp"], ["proof (state)\nthis:\n  UP (happ (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n       (DOWN (Fun (pr1 a b) x))) =\n  UP (happ (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n       (hfst (DOWN x)))\n\ngoal (1 subgoal):\n 1. Fun \\<Lambda>_pr1' x =\n    UP (happ\n         (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n         (hfst (DOWN x)))", "finally"], ["proof (chain)\npicking this:\n  Fun \\<Lambda>_pr1' x =\n  UP (happ (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n       (hfst (DOWN x)))", "show ?thesis"], ["proof (prove)\nusing this:\n  Fun \\<Lambda>_pr1' x =\n  UP (happ (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n       (hfst (DOWN x)))\n\ngoal (1 subgoal):\n 1. Fun \\<Lambda>_pr1' x =\n    UP (happ\n         (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n         (hfst (DOWN x)))", "by simp"], ["proof (state)\nthis:\n  Fun \\<Lambda>_pr1' x =\n  UP (happ (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n       (hfst (DOWN x)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Fun \\<Lambda>_pr1' x =\n  UP (happ (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n       (hfst (DOWN x)))\n\ngoal (1 subgoal):\n 1. UP (happ (DOWN (Fun \\<Lambda>_pr1' x)) (DOWN (Fun b_pr0' x))) =\n    UP (happ\n         (DOWN\n           (UP (happ\n                 (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n                   (arr_to_hfun g))\n                 (hfst (DOWN x)))))\n         (DOWN (UP (hsnd (DOWN x)))))", "ultimately"], ["proof (chain)\npicking this:\n  Fun b_pr0' x = UP (hsnd (DOWN x))\n  Fun \\<Lambda>_pr1' x =\n  UP (happ (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n       (hfst (DOWN x)))", "show ?thesis"], ["proof (prove)\nusing this:\n  Fun b_pr0' x = UP (hsnd (DOWN x))\n  Fun \\<Lambda>_pr1' x =\n  UP (happ (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n       (hfst (DOWN x)))\n\ngoal (1 subgoal):\n 1. UP (happ (DOWN (Fun \\<Lambda>_pr1' x)) (DOWN (Fun b_pr0' x))) =\n    UP (happ\n         (DOWN\n           (UP (happ\n                 (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n                   (arr_to_hfun g))\n                 (hfst (DOWN x)))))\n         (DOWN (UP (hsnd (DOWN x)))))", "by simp"], ["proof (state)\nthis:\n  UP (happ (DOWN (Fun \\<Lambda>_pr1' x)) (DOWN (Fun b_pr0' x))) =\n  UP (happ\n       (DOWN\n         (UP (happ\n               (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n                 (arr_to_hfun g))\n               (hfst (DOWN x)))))\n       (DOWN (UP (hsnd (DOWN x)))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  UP (happ (DOWN (Fun \\<Lambda>_pr1' x)) (DOWN (Fun b_pr0' x))) =\n  UP (happ\n       (DOWN\n         (UP (happ\n               (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n                 (arr_to_hfun g))\n               (hfst (DOWN x)))))\n       (DOWN (UP (hsnd (DOWN x)))))\n\ngoal (1 subgoal):\n 1. x \\<in> local.set (local.prod a b) \\<Longrightarrow>\n    Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x", "also"], ["proof (state)\nthis:\n  UP (happ (DOWN (Fun \\<Lambda>_pr1' x)) (DOWN (Fun b_pr0' x))) =\n  UP (happ\n       (DOWN\n         (UP (happ\n               (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n                 (arr_to_hfun g))\n               (hfst (DOWN x)))))\n       (DOWN (UP (hsnd (DOWN x)))))\n\ngoal (1 subgoal):\n 1. x \\<in> local.set (local.prod a b) \\<Longrightarrow>\n    Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x", "have \"... = UP (happ (happ (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n                                                  (arr_to_hfun g))\n                                            (hfst (DOWN x)))\n                                      (hsnd (DOWN x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP (happ\n         (DOWN\n           (UP (happ\n                 (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n                   (arr_to_hfun g))\n                 (hfst (DOWN x)))))\n         (DOWN (UP (hsnd (DOWN x))))) =\n    UP (happ\n         (happ\n           (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n           (hfst (DOWN x)))\n         (hsnd (DOWN x)))", "by simp"], ["proof (state)\nthis:\n  UP (happ\n       (DOWN\n         (UP (happ\n               (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n                 (arr_to_hfun g))\n               (hfst (DOWN x)))))\n       (DOWN (UP (hsnd (DOWN x))))) =\n  UP (happ\n       (happ\n         (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n         (hfst (DOWN x)))\n       (hsnd (DOWN x)))\n\ngoal (1 subgoal):\n 1. x \\<in> local.set (local.prod a b) \\<Longrightarrow>\n    Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x", "also"], ["proof (state)\nthis:\n  UP (happ\n       (DOWN\n         (UP (happ\n               (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n                 (arr_to_hfun g))\n               (hfst (DOWN x)))))\n       (DOWN (UP (hsnd (DOWN x))))) =\n  UP (happ\n       (happ\n         (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n         (hfst (DOWN x)))\n       (hsnd (DOWN x)))\n\ngoal (1 subgoal):\n 1. x \\<in> local.set (local.prod a b) \\<Longrightarrow>\n    Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x", "have \"... = UP (happ (arr_to_hfun g) (DOWN x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP (happ\n         (happ\n           (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n           (hfst (DOWN x)))\n         (hsnd (DOWN x))) =\n    UP (happ (arr_to_hfun g) (DOWN x))", "using assms x happ_hlam"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>g : local.prod a b \\<rightarrow> c\\<guillemotright>\n  x \\<in> local.set (local.prod a b)\n  \\<lbrakk>?X \\<^bold>\\<in> ?A; hfun (?A * ?B) ?C ?F\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!G.\n                       \\<langle>?X, G\\<rangle> \\<^bold>\\<in>\n                       hlam ?A ?B ?C ?F\n  \\<lbrakk>?X \\<^bold>\\<in> ?A; hfun (?A * ?B) ?C ?F\\<rbrakk>\n  \\<Longrightarrow> happ (hlam ?A ?B ?C ?F) ?X =\n                    (THE G.\n                        \\<langle>?X, G\\<rangle> \\<^bold>\\<in>\n                        hlam ?A ?B ?C ?F)\n  \\<lbrakk>?X \\<^bold>\\<in> ?A; hfun (?A * ?B) ?C ?F\\<rbrakk>\n  \\<Longrightarrow> happ (hlam ?A ?B ?C ?F) ?X =\n                    \\<lbrace>yz \\<^bold>\\<in> ?B * ?C.\n                     \\<langle>\\<langle>?X, hfst yz\\<rangle>,\n                              hsnd yz\\<rangle> \\<^bold>\\<in>\n                     ?F\\<rbrace>\n  \\<lbrakk>?X \\<^bold>\\<in> ?A; hfun (?A * ?B) ?C ?F;\n   ?Y \\<^bold>\\<in> ?B\\<rbrakk>\n  \\<Longrightarrow> happ (happ (hlam ?A ?B ?C ?F) ?X) ?Y =\n                    happ ?F \\<langle>?X, ?Y\\<rangle>\n\ngoal (1 subgoal):\n 1. UP (happ\n         (happ\n           (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n           (hfst (DOWN x)))\n         (hsnd (DOWN x))) =\n    UP (happ (arr_to_hfun g) (DOWN x))", "by (metis (no_types, lifting) prod_def DOWN_membI HCollect_iff ide_dom\n                  in_homE UNIV_I arr_to_hfun_in_hexp hexp_def hfst_conv hsnd_conv\n                  ide_to_hf_hf_to_ide timesE)"], ["proof (state)\nthis:\n  UP (happ\n       (happ\n         (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n         (hfst (DOWN x)))\n       (hsnd (DOWN x))) =\n  UP (happ (arr_to_hfun g) (DOWN x))\n\ngoal (1 subgoal):\n 1. x \\<in> local.set (local.prod a b) \\<Longrightarrow>\n    Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x", "also"], ["proof (state)\nthis:\n  UP (happ\n       (happ\n         (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c) (arr_to_hfun g))\n         (hfst (DOWN x)))\n       (hsnd (DOWN x))) =\n  UP (happ (arr_to_hfun g) (DOWN x))\n\ngoal (1 subgoal):\n 1. x \\<in> local.set (local.prod a b) \\<Longrightarrow>\n    Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x", "have \"... = Fun g x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP (happ (arr_to_hfun g) (DOWN x)) = Fun g x", "using assms x 3 4 Fun_char [of g] restrict_apply [of \"Fun g\" \"Dom g\" x]"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>g : local.prod a b \\<rightarrow> c\\<guillemotright>\n  x \\<in> local.set (local.prod a b)\n  arr g\n  Dom g = local.set (local.prod a b)\n  arr g \\<Longrightarrow>\n  Fun g = (\\<lambda>x\\<^bold>\\<in>Dom g. UP (happ (arr_to_hfun g) (DOWN x)))\n  restrict (Fun g) (Dom g) x =\n  (if x \\<in> Dom g then Fun g x else undefined)\n\ngoal (1 subgoal):\n 1. UP (happ (arr_to_hfun g) (DOWN x)) = Fun g x", "by simp"], ["proof (state)\nthis:\n  UP (happ (arr_to_hfun g) (DOWN x)) = Fun g x\n\ngoal (1 subgoal):\n 1. x \\<in> local.set (local.prod a b) \\<Longrightarrow>\n    Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x", "finally"], ["proof (chain)\npicking this:\n  Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x", "show ?thesis"], ["proof (prove)\nusing this:\n  Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x\n\ngoal (1 subgoal):\n 1. Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x", "by simp"], ["proof (state)\nthis:\n  Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> local.set (local.prod a b) \\<Longrightarrow>\n  Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x", "ultimately"], ["proof (chain)\npicking this:\n  x \\<notin> local.set (local.prod a b) \\<Longrightarrow>\n  Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x\n  x \\<in> local.set (local.prod a b) \\<Longrightarrow>\n  Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x", "show \"Fun (comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x\""], ["proof (prove)\nusing this:\n  x \\<notin> local.set (local.prod a b) \\<Longrightarrow>\n  Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x\n  x \\<in> local.set (local.prod a b) \\<Longrightarrow>\n  Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x\n\ngoal (1 subgoal):\n 1. Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x", "by auto"], ["proof (state)\nthis:\n  Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) x = Fun g x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Fun (local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0')) = Fun g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.comp (eval b c) (tuple \\<Lambda>_pr1' b_pr0') = g\n\ngoal (1 subgoal):\n 1. local.comp (eval b c) (HF'.prod (\\<Lambda> a b c g) b) = g", "finally"], ["proof (chain)\npicking this:\n  local.comp (eval b c) (HF'.prod (\\<Lambda> a b c g) b) = g", "show ?thesis"], ["proof (prove)\nusing this:\n  local.comp (eval b c) (HF'.prod (\\<Lambda> a b c g) b) = g\n\ngoal (1 subgoal):\n 1. local.comp (eval b c) (HF'.prod (\\<Lambda> a b c g) b) = g", "by simp"], ["proof (state)\nthis:\n  local.comp (eval b c) (HF'.prod (\\<Lambda> a b c g) b) = g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lam_eval_prod:\n    assumes \"ide a\" and \"ide b\" and \"ide c\"\n    and \"in_hom h a (exp b c)\"\n    shows \"\\<Lambda> a b c (comp (eval b c) (HF'.prod h b)) = h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b)) = h", "proof (intro arr_eqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. par (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) h\n 2. Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) = Fun h", "have 0: \"in_hom (comp (eval b c) (HF'.prod h b)) (prod a b) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>local.comp (eval b c)\n                     (HF'.prod h\n                       b) : local.prod a b \\<rightarrow> c\\<guillemotright>", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<guillemotleft>HF'.prod h\n                     b : local.prod a b \\<rightarrow> ?b\\<guillemotright>\n 2. \\<guillemotleft>eval b c : ?b \\<rightarrow> c\\<guillemotright>", "show \"in_hom (HF'.prod h b) (prod a b) (HF'.prod (exp b c) b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>HF'.prod h\n                     b : local.prod a\n                          b \\<rightarrow> HF'.prod (exp b c)\n     b\\<guillemotright>", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. arr (HF'.prod h b)\n 2. local.dom (HF'.prod h b) = local.prod a b\n 3. cod (HF'.prod h b) = HF'.prod (exp b c) b", "show 1: \"arr (HF'.prod h b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (HF'.prod h b)", "using assms HF'.prod_in_hom'"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  \\<lbrakk>arr ?f; local.dom ?f = ?a; cod ?f = ?c; arr ?g;\n   local.dom ?g = ?b; cod ?g = ?d\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>HF'.prod ?f\n                                     ?g : HF'.prod ?a\n     ?b \\<rightarrow> HF'.prod ?c ?d\\<guillemotright>\n\ngoal (1 subgoal):\n 1. arr (HF'.prod h b)", "by (metis (no_types, lifting) ideD(1) in_homE)"], ["proof (state)\nthis:\n  arr (HF'.prod h b)\n\ngoal (2 subgoals):\n 1. local.dom (HF'.prod h b) = local.prod a b\n 2. cod (HF'.prod h b) = HF'.prod (exp b c) b", "show \"dom (HF'.prod h b) = prod a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dom (HF'.prod h b) = local.prod a b", "using assms 1"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  arr (HF'.prod h b)\n\ngoal (1 subgoal):\n 1. local.dom (HF'.prod h b) = local.prod a b", "by (metis (no_types, lifting) HF'.prod_simps(2) ideD(1-2) in_homE prod_ide_eq)"], ["proof (state)\nthis:\n  local.dom (HF'.prod h b) = local.prod a b\n\ngoal (1 subgoal):\n 1. cod (HF'.prod h b) = HF'.prod (exp b c) b", "show \"cod (HF'.prod h b) = HF'.prod (exp b c) b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cod (HF'.prod h b) = HF'.prod (exp b c) b", "using assms 1"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  arr (HF'.prod h b)\n\ngoal (1 subgoal):\n 1. cod (HF'.prod h b) = HF'.prod (exp b c) b", "by (metis (no_types, lifting) HF'.prod_simps(3) ideD(1,3) in_homE)"], ["proof (state)\nthis:\n  cod (HF'.prod h b) = HF'.prod (exp b c) b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<guillemotleft>HF'.prod h\n                   b : local.prod a\n                        b \\<rightarrow> HF'.prod (exp b c)\n   b\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>eval b\n                     c : HF'.prod (exp b c)\n                          b \\<rightarrow> c\\<guillemotright>", "show \"in_hom (eval b c) (HF'.prod (exp b c) b) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>eval b\n                     c : HF'.prod (exp b c)\n                          b \\<rightarrow> c\\<guillemotright>", "using assms"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>eval b\n                     c : HF'.prod (exp b c)\n                          b \\<rightarrow> c\\<guillemotright>", "by blast"], ["proof (state)\nthis:\n  \\<guillemotleft>eval b\n                   c : HF'.prod (exp b c) b \\<rightarrow> c\\<guillemotright>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<guillemotleft>local.comp (eval b c)\n                   (HF'.prod h\n                     b) : local.prod a b \\<rightarrow> c\\<guillemotright>\n\ngoal (2 subgoals):\n 1. par (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) h\n 2. Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) = Fun h", "have 1: \"in_hom (\\<Lambda> a b c (comp (eval b c) (HF'.prod h b))) a (exp b c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<Lambda> a b c\n                     (local.comp (eval b c)\n                       (HF'.prod h\n                         b)) : a \\<rightarrow> exp b c\\<guillemotright>", "using assms 0"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  \\<guillemotleft>local.comp (eval b c)\n                   (HF'.prod h\n                     b) : local.prod a b \\<rightarrow> c\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<Lambda> a b c\n                     (local.comp (eval b c)\n                       (HF'.prod h\n                         b)) : a \\<rightarrow> exp b c\\<guillemotright>", "by blast"], ["proof (state)\nthis:\n  \\<guillemotleft>\\<Lambda> a b c\n                   (local.comp (eval b c)\n                     (HF'.prod h\n                       b)) : a \\<rightarrow> exp b c\\<guillemotright>\n\ngoal (2 subgoals):\n 1. par (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) h\n 2. Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) = Fun h", "have 2: \"Fun (comp (eval b c) (HF'.prod h b)) =\n               restrict (Fun (eval b c) \\<circ> Fun (HF'.prod h b))\n                        (set (HF'.prod a b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (local.comp (eval b c) (HF'.prod h b)) =\n    restrict (Fun (eval b c) \\<circ> Fun (HF'.prod h b))\n     (local.set (HF'.prod a b))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Fun (local.comp (eval b c) (HF'.prod h b)) =\n    restrict (Fun (eval b c) \\<circ> Fun (HF'.prod h b))\n     (local.set (HF'.prod a b))", "have \"seq (eval b c) (HF'.prod h b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq (eval b c) (HF'.prod h b)", "using assms 1"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  \\<guillemotleft>\\<Lambda> a b c\n                   (local.comp (eval b c)\n                     (HF'.prod h\n                       b)) : a \\<rightarrow> exp b c\\<guillemotright>\n\ngoal (1 subgoal):\n 1. seq (eval b c) (HF'.prod h b)", "by (metis (no_types, lifting) 0 in_homE)"], ["proof (state)\nthis:\n  seq (eval b c) (HF'.prod h b)\n\ngoal (1 subgoal):\n 1. Fun (local.comp (eval b c) (HF'.prod h b)) =\n    restrict (Fun (eval b c) \\<circ> Fun (HF'.prod h b))\n     (local.set (HF'.prod a b))", "moreover"], ["proof (state)\nthis:\n  seq (eval b c) (HF'.prod h b)\n\ngoal (1 subgoal):\n 1. Fun (local.comp (eval b c) (HF'.prod h b)) =\n    restrict (Fun (eval b c) \\<circ> Fun (HF'.prod h b))\n     (local.set (HF'.prod a b))", "have \"Dom (HF'.prod h b) = set (HF'.prod a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dom (HF'.prod h b) = local.set (HF'.prod a b)", "using assms"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n\ngoal (1 subgoal):\n 1. Dom (HF'.prod h b) = local.set (HF'.prod a b)", "by (metis (no_types, lifting) HF'.prod_simps(2) ideD(1-2) in_homE)"], ["proof (state)\nthis:\n  Dom (HF'.prod h b) = local.set (HF'.prod a b)\n\ngoal (1 subgoal):\n 1. Fun (local.comp (eval b c) (HF'.prod h b)) =\n    restrict (Fun (eval b c) \\<circ> Fun (HF'.prod h b))\n     (local.set (HF'.prod a b))", "ultimately"], ["proof (chain)\npicking this:\n  seq (eval b c) (HF'.prod h b)\n  Dom (HF'.prod h b) = local.set (HF'.prod a b)", "show ?thesis"], ["proof (prove)\nusing this:\n  seq (eval b c) (HF'.prod h b)\n  Dom (HF'.prod h b) = local.set (HF'.prod a b)\n\ngoal (1 subgoal):\n 1. Fun (local.comp (eval b c) (HF'.prod h b)) =\n    restrict (Fun (eval b c) \\<circ> Fun (HF'.prod h b))\n     (local.set (HF'.prod a b))", "using assms Fun_comp [of \"eval b c\" \"HF'.prod h b\"]"], ["proof (prove)\nusing this:\n  seq (eval b c) (HF'.prod h b)\n  Dom (HF'.prod h b) = local.set (HF'.prod a b)\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  seq (eval b c) (HF'.prod h b) \\<Longrightarrow>\n  Fun (local.comp (eval b c) (HF'.prod h b)) =\n  restrict (Fun (eval b c) \\<circ> Fun (HF'.prod h b)) (Dom (HF'.prod h b))\n\ngoal (1 subgoal):\n 1. Fun (local.comp (eval b c) (HF'.prod h b)) =\n    restrict (Fun (eval b c) \\<circ> Fun (HF'.prod h b))\n     (local.set (HF'.prod a b))", "by simp"], ["proof (state)\nthis:\n  Fun (local.comp (eval b c) (HF'.prod h b)) =\n  restrict (Fun (eval b c) \\<circ> Fun (HF'.prod h b))\n   (local.set (HF'.prod a b))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Fun (local.comp (eval b c) (HF'.prod h b)) =\n  restrict (Fun (eval b c) \\<circ> Fun (HF'.prod h b))\n   (local.set (HF'.prod a b))\n\ngoal (2 subgoals):\n 1. par (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) h\n 2. Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) = Fun h", "show par: \"par (\\<Lambda> a b c (comp (eval b c) (HF'.prod h b))) h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. par (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) h", "using assms 1"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  \\<guillemotleft>\\<Lambda> a b c\n                   (local.comp (eval b c)\n                     (HF'.prod h\n                       b)) : a \\<rightarrow> exp b c\\<guillemotright>\n\ngoal (1 subgoal):\n 1. par (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) h", "by (metis (no_types, lifting) in_homE)"], ["proof (state)\nthis:\n  par (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) h\n\ngoal (1 subgoal):\n 1. Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) = Fun h", "show \"Fun (\\<Lambda> a b c (comp (eval b c) (HF'.prod h b))) = Fun h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) = Fun h", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x =\n       Fun h x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x =\n       Fun h x", "show \"Fun (\\<Lambda> a b c (comp (eval b c) (HF'.prod h b))) x = Fun h x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x = Fun h x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x = Fun h x", "have \"x \\<notin> set a \\<Longrightarrow> ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> local.set a \\<Longrightarrow>\n    Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x = Fun h x", "using assms 1 Fun_mapsto\n                  extensional_arb [of \"Fun h\" \"set a\" x]\n                  extensional_arb [of \"Fun (\\<Lambda> a b c (comp (eval b c) (HF'.prod h b)))\"\n                                      \"set a\" x]"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  \\<guillemotleft>\\<Lambda> a b c\n                   (local.comp (eval b c)\n                     (HF'.prod h\n                       b)) : a \\<rightarrow> exp b c\\<guillemotright>\n  arr ?f \\<Longrightarrow>\n  Fun ?f \\<in> extensional (Dom ?f) \\<inter> (Dom ?f \\<rightarrow> Cod ?f)\n  \\<lbrakk>Fun h \\<in> extensional (local.set a);\n   x \\<notin> local.set a\\<rbrakk>\n  \\<Longrightarrow> Fun h x = undefined\n  \\<lbrakk>Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b)))\n           \\<in> extensional (local.set a);\n   x \\<notin> local.set a\\<rbrakk>\n  \\<Longrightarrow> Fun (\\<Lambda> a b c\n                          (local.comp (eval b c) (HF'.prod h b)))\n                     x =\n                    undefined\n\ngoal (1 subgoal):\n 1. x \\<notin> local.set a \\<Longrightarrow>\n    Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x = Fun h x", "by (metis (no_types, lifting) 0 Int_iff lam_simps(2) par)"], ["proof (state)\nthis:\n  x \\<notin> local.set a \\<Longrightarrow>\n  Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x = Fun h x\n\ngoal (1 subgoal):\n 1. Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x = Fun h x", "moreover"], ["proof (state)\nthis:\n  x \\<notin> local.set a \\<Longrightarrow>\n  Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x = Fun h x\n\ngoal (1 subgoal):\n 1. Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x = Fun h x", "have \"x \\<in> set a \\<Longrightarrow> ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> local.set a \\<Longrightarrow>\n    Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x = Fun h x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> local.set a \\<Longrightarrow>\n    Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x = Fun h x", "assume x: \"x \\<in> set a\""], ["proof (state)\nthis:\n  x \\<in> local.set a\n\ngoal (1 subgoal):\n 1. x \\<in> local.set a \\<Longrightarrow>\n    Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x = Fun h x", "have 3: \"dom (comp (eval b c) (HF'.prod h b)) = HF'.prod a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dom (local.comp (eval b c) (HF'.prod h b)) = HF'.prod a b", "using assms 0 in_homE prod_ide_eq"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  \\<guillemotleft>local.comp (eval b c)\n                   (HF'.prod h\n                     b) : local.prod a b \\<rightarrow> c\\<guillemotright>\n  \\<lbrakk>\\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright>;\n   \\<lbrakk>arr ?f; local.dom ?f = ?a; cod ?f = ?b\\<rbrakk>\n   \\<Longrightarrow> ?T\\<rbrakk>\n  \\<Longrightarrow> ?T\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> local.prod ?a ?b = HF'.prod ?a ?b\n\ngoal (1 subgoal):\n 1. local.dom (local.comp (eval b c) (HF'.prod h b)) = HF'.prod a b", "by auto"], ["proof (state)\nthis:\n  local.dom (local.comp (eval b c) (HF'.prod h b)) = HF'.prod a b\n\ngoal (1 subgoal):\n 1. x \\<in> local.set a \\<Longrightarrow>\n    Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x = Fun h x", "have 4: \"cod (comp (eval b c) (HF'.prod h b)) = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cod (local.comp (eval b c) (HF'.prod h b)) = c", "using assms 0"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  \\<guillemotleft>local.comp (eval b c)\n                   (HF'.prod h\n                     b) : local.prod a b \\<rightarrow> c\\<guillemotright>\n\ngoal (1 subgoal):\n 1. cod (local.comp (eval b c) (HF'.prod h b)) = c", "by blast"], ["proof (state)\nthis:\n  cod (local.comp (eval b c) (HF'.prod h b)) = c\n\ngoal (1 subgoal):\n 1. x \\<in> local.set a \\<Longrightarrow>\n    Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x = Fun h x", "have 5: \"dom (comp (eval b c) (HF'.prod h b)) = HF'.prod a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dom (local.comp (eval b c) (HF'.prod h b)) = HF'.prod a b", "using assms 3"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  local.dom (local.comp (eval b c) (HF'.prod h b)) = HF'.prod a b\n\ngoal (1 subgoal):\n 1. local.dom (local.comp (eval b c) (HF'.prod h b)) = HF'.prod a b", "by (metis (mono_tags, lifting))"], ["proof (state)\nthis:\n  local.dom (local.comp (eval b c) (HF'.prod h b)) = HF'.prod a b\n\ngoal (1 subgoal):\n 1. x \\<in> local.set a \\<Longrightarrow>\n    Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x = Fun h x", "have 6: \"cod (comp (eval b c) (HF'.prod h b)) = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cod (local.comp (eval b c) (HF'.prod h b)) = c", "using assms 4"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  cod (local.comp (eval b c) (HF'.prod h b)) = c\n\ngoal (1 subgoal):\n 1. cod (local.comp (eval b c) (HF'.prod h b)) = c", "by (metis (no_types, lifting))"], ["proof (state)\nthis:\n  cod (local.comp (eval b c) (HF'.prod h b)) = c\n\ngoal (1 subgoal):\n 1. x \\<in> local.set a \\<Longrightarrow>\n    Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x = Fun h x", "have \"arr_to_hfun (comp (eval b c) (HF'.prod h b)) =\n                  \\<lbrace>xy \\<^bold>\\<in> ide_to_hf (HF'.prod a b) * ide_to_hf c.\n                     hsnd xy = DOWN (Fun (comp (eval b c) (HF'.prod h b)) (UP (hfst xy)))\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr_to_hfun (local.comp (eval b c) (HF'.prod h b)) =\n    \\<lbrace>xy \\<^bold>\\<in> ide_to_hf (HF'.prod a b) * ide_to_hf c.\n     hsnd xy =\n     DOWN\n      (Fun (local.comp (eval b c) (HF'.prod h b)) (UP (hfst xy)))\\<rbrace>", "unfolding arr_to_hfun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>XY \\<^bold>\\<in>\n     ide_to_hf (local.dom (local.comp (eval b c) (HF'.prod h b))) *\n     ide_to_hf (cod (local.comp (eval b c) (HF'.prod h b))).\n     hsnd XY =\n     DOWN\n      (Fun (local.comp (eval b c) (HF'.prod h b)) (UP (hfst XY)))\\<rbrace> =\n    \\<lbrace>xy \\<^bold>\\<in> ide_to_hf (HF'.prod a b) * ide_to_hf c.\n     hsnd xy =\n     DOWN\n      (Fun (local.comp (eval b c) (HF'.prod h b)) (UP (hfst xy)))\\<rbrace>", "using 2 5 6"], ["proof (prove)\nusing this:\n  Fun (local.comp (eval b c) (HF'.prod h b)) =\n  restrict (Fun (eval b c) \\<circ> Fun (HF'.prod h b))\n   (local.set (HF'.prod a b))\n  local.dom (local.comp (eval b c) (HF'.prod h b)) = HF'.prod a b\n  cod (local.comp (eval b c) (HF'.prod h b)) = c\n\ngoal (1 subgoal):\n 1. \\<lbrace>XY \\<^bold>\\<in>\n     ide_to_hf (local.dom (local.comp (eval b c) (HF'.prod h b))) *\n     ide_to_hf (cod (local.comp (eval b c) (HF'.prod h b))).\n     hsnd XY =\n     DOWN\n      (Fun (local.comp (eval b c) (HF'.prod h b)) (UP (hfst XY)))\\<rbrace> =\n    \\<lbrace>xy \\<^bold>\\<in> ide_to_hf (HF'.prod a b) * ide_to_hf c.\n     hsnd xy =\n     DOWN\n      (Fun (local.comp (eval b c) (HF'.prod h b)) (UP (hfst xy)))\\<rbrace>", "by metis"], ["proof (state)\nthis:\n  arr_to_hfun (local.comp (eval b c) (HF'.prod h b)) =\n  \\<lbrace>xy \\<^bold>\\<in> ide_to_hf (HF'.prod a b) * ide_to_hf c.\n   hsnd xy =\n   DOWN (Fun (local.comp (eval b c) (HF'.prod h b)) (UP (hfst xy)))\\<rbrace>\n\ngoal (1 subgoal):\n 1. x \\<in> local.set a \\<Longrightarrow>\n    Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x = Fun h x", "have \"Fun (\\<Lambda> a b c (comp (eval b c) (HF'.prod h b))) x =\n                  UP (happ (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n                                 (arr_to_hfun (comp (eval b c) (HF'.prod h b))))\n                           (DOWN x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x =\n    UP (happ\n         (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n           (arr_to_hfun (local.comp (eval b c) (HF'.prod h b))))\n         (DOWN x))", "using assms 0 x Fun_lam"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  \\<guillemotleft>local.comp (eval b c)\n                   (HF'.prod h\n                     b) : local.prod a b \\<rightarrow> c\\<guillemotright>\n  x \\<in> local.set a\n  \\<lbrakk>ide ?a; ide ?b; ide ?c;\n   \\<guillemotleft>?f : local.prod ?a\n                         ?b \\<rightarrow> ?c\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> Fun (\\<Lambda> ?a ?b ?c ?f) =\n                    (\\<lambda>x\\<^bold>\\<in>local.set ?a.\n                        UP (happ\n                             (hlam (ide_to_hf ?a) (ide_to_hf ?b)\n                               (ide_to_hf ?c) (arr_to_hfun ?f))\n                             (DOWN x)))\n\ngoal (1 subgoal):\n 1. Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x =\n    UP (happ\n         (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n           (arr_to_hfun (local.comp (eval b c) (HF'.prod h b))))\n         (DOWN x))", "by auto"], ["proof (state)\nthis:\n  Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x =\n  UP (happ\n       (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n         (arr_to_hfun (local.comp (eval b c) (HF'.prod h b))))\n       (DOWN x))\n\ngoal (1 subgoal):\n 1. x \\<in> local.set a \\<Longrightarrow>\n    Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x = Fun h x", "also"], ["proof (state)\nthis:\n  Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x =\n  UP (happ\n       (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n         (arr_to_hfun (local.comp (eval b c) (HF'.prod h b))))\n       (DOWN x))\n\ngoal (1 subgoal):\n 1. x \\<in> local.set a \\<Longrightarrow>\n    Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x = Fun h x", "have \"... = UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n                                   \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>, hsnd yz\\<rangle>\n                                      \\<^bold>\\<in> arr_to_hfun (comp (eval b c) (HF'.prod h b))\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP (happ\n         (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n           (arr_to_hfun (local.comp (eval b c) (HF'.prod h b))))\n         (DOWN x)) =\n    UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n        \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n                 hsnd yz\\<rangle> \\<^bold>\\<in>\n        arr_to_hfun (local.comp (eval b c) (HF'.prod h b))\\<rbrace>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. UP (happ\n         (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n           (arr_to_hfun (local.comp (eval b c) (HF'.prod h b))))\n         (DOWN x)) =\n    UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n        \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n                 hsnd yz\\<rangle> \\<^bold>\\<in>\n        arr_to_hfun (local.comp (eval b c) (HF'.prod h b))\\<rbrace>", "have \"seq (eval b c) (HF'.prod h b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq (eval b c) (HF'.prod h b)", "using assms 0"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  \\<guillemotleft>local.comp (eval b c)\n                   (HF'.prod h\n                     b) : local.prod a b \\<rightarrow> c\\<guillemotright>\n\ngoal (1 subgoal):\n 1. seq (eval b c) (HF'.prod h b)", "by blast"], ["proof (state)\nthis:\n  seq (eval b c) (HF'.prod h b)\n\ngoal (1 subgoal):\n 1. UP (happ\n         (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n           (arr_to_hfun (local.comp (eval b c) (HF'.prod h b))))\n         (DOWN x)) =\n    UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n        \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n                 hsnd yz\\<rangle> \\<^bold>\\<in>\n        arr_to_hfun (local.comp (eval b c) (HF'.prod h b))\\<rbrace>", "moreover"], ["proof (state)\nthis:\n  seq (eval b c) (HF'.prod h b)\n\ngoal (1 subgoal):\n 1. UP (happ\n         (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n           (arr_to_hfun (local.comp (eval b c) (HF'.prod h b))))\n         (DOWN x)) =\n    UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n        \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n                 hsnd yz\\<rangle> \\<^bold>\\<in>\n        arr_to_hfun (local.comp (eval b c) (HF'.prod h b))\\<rbrace>", "have \"ide_to_hf (dom (comp (eval b c) (HF'.prod h b))) =\n                             ide_to_hf a * ide_to_hf b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide_to_hf (local.dom (local.comp (eval b c) (HF'.prod h b))) =\n    ide_to_hf a * ide_to_hf b", "using assms 1 3"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  \\<guillemotleft>\\<Lambda> a b c\n                   (local.comp (eval b c)\n                     (HF'.prod h\n                       b)) : a \\<rightarrow> exp b c\\<guillemotright>\n  local.dom (local.comp (eval b c) (HF'.prod h b)) = HF'.prod a b\n\ngoal (1 subgoal):\n 1. ide_to_hf (local.dom (local.comp (eval b c) (HF'.prod h b))) =\n    ide_to_hf a * ide_to_hf b", "by (metis (no_types, lifting) prod_def UNIV_I ide_to_hf_hf_to_ide prod_ide_eq)"], ["proof (state)\nthis:\n  ide_to_hf (local.dom (local.comp (eval b c) (HF'.prod h b))) =\n  ide_to_hf a * ide_to_hf b\n\ngoal (1 subgoal):\n 1. UP (happ\n         (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n           (arr_to_hfun (local.comp (eval b c) (HF'.prod h b))))\n         (DOWN x)) =\n    UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n        \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n                 hsnd yz\\<rangle> \\<^bold>\\<in>\n        arr_to_hfun (local.comp (eval b c) (HF'.prod h b))\\<rbrace>", "moreover"], ["proof (state)\nthis:\n  ide_to_hf (local.dom (local.comp (eval b c) (HF'.prod h b))) =\n  ide_to_hf a * ide_to_hf b\n\ngoal (1 subgoal):\n 1. UP (happ\n         (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n           (arr_to_hfun (local.comp (eval b c) (HF'.prod h b))))\n         (DOWN x)) =\n    UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n        \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n                 hsnd yz\\<rangle> \\<^bold>\\<in>\n        arr_to_hfun (local.comp (eval b c) (HF'.prod h b))\\<rbrace>", "have \"ide_to_hf (cod (comp (eval b c) (HF'.prod h b))) = ide_to_hf c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide_to_hf (cod (local.comp (eval b c) (HF'.prod h b))) = ide_to_hf c", "using assms 2 4"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  Fun (local.comp (eval b c) (HF'.prod h b)) =\n  restrict (Fun (eval b c) \\<circ> Fun (HF'.prod h b))\n   (local.set (HF'.prod a b))\n  cod (local.comp (eval b c) (HF'.prod h b)) = c\n\ngoal (1 subgoal):\n 1. ide_to_hf (cod (local.comp (eval b c) (HF'.prod h b))) = ide_to_hf c", "by auto"], ["proof (state)\nthis:\n  ide_to_hf (cod (local.comp (eval b c) (HF'.prod h b))) = ide_to_hf c\n\ngoal (1 subgoal):\n 1. UP (happ\n         (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n           (arr_to_hfun (local.comp (eval b c) (HF'.prod h b))))\n         (DOWN x)) =\n    UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n        \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n                 hsnd yz\\<rangle> \\<^bold>\\<in>\n        arr_to_hfun (local.comp (eval b c) (HF'.prod h b))\\<rbrace>", "ultimately"], ["proof (chain)\npicking this:\n  seq (eval b c) (HF'.prod h b)\n  ide_to_hf (local.dom (local.comp (eval b c) (HF'.prod h b))) =\n  ide_to_hf a * ide_to_hf b\n  ide_to_hf (cod (local.comp (eval b c) (HF'.prod h b))) = ide_to_hf c", "show ?thesis"], ["proof (prove)\nusing this:\n  seq (eval b c) (HF'.prod h b)\n  ide_to_hf (local.dom (local.comp (eval b c) (HF'.prod h b))) =\n  ide_to_hf a * ide_to_hf b\n  ide_to_hf (cod (local.comp (eval b c) (HF'.prod h b))) = ide_to_hf c\n\ngoal (1 subgoal):\n 1. UP (happ\n         (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n           (arr_to_hfun (local.comp (eval b c) (HF'.prod h b))))\n         (DOWN x)) =\n    UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n        \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n                 hsnd yz\\<rangle> \\<^bold>\\<in>\n        arr_to_hfun (local.comp (eval b c) (HF'.prod h b))\\<rbrace>", "using assms 0 x happ_hlam(3) DOWN_membI\n                      hfun_arr_to_hfun [of \"comp (eval b c) (HF'.prod h b)\"]"], ["proof (prove)\nusing this:\n  seq (eval b c) (HF'.prod h b)\n  ide_to_hf (local.dom (local.comp (eval b c) (HF'.prod h b))) =\n  ide_to_hf a * ide_to_hf b\n  ide_to_hf (cod (local.comp (eval b c) (HF'.prod h b))) = ide_to_hf c\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  \\<guillemotleft>local.comp (eval b c)\n                   (HF'.prod h\n                     b) : local.prod a b \\<rightarrow> c\\<guillemotright>\n  x \\<in> local.set a\n  \\<lbrakk>?X \\<^bold>\\<in> ?A; hfun (?A * ?B) ?C ?F\\<rbrakk>\n  \\<Longrightarrow> happ (hlam ?A ?B ?C ?F) ?X =\n                    \\<lbrace>yz \\<^bold>\\<in> ?B * ?C.\n                     \\<langle>\\<langle>?X, hfst yz\\<rangle>,\n                              hsnd yz\\<rangle> \\<^bold>\\<in>\n                     ?F\\<rbrace>\n  \\<lbrakk>ide ?a; ?x \\<in> local.set ?a\\<rbrakk>\n  \\<Longrightarrow> DOWN ?x \\<^bold>\\<in> ide_to_hf ?a\n  seq (eval b c) (HF'.prod h b) \\<Longrightarrow>\n  hfun (ide_to_hf (local.dom (local.comp (eval b c) (HF'.prod h b))))\n   (ide_to_hf (cod (local.comp (eval b c) (HF'.prod h b))))\n   (arr_to_hfun (local.comp (eval b c) (HF'.prod h b)))\n\ngoal (1 subgoal):\n 1. UP (happ\n         (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n           (arr_to_hfun (local.comp (eval b c) (HF'.prod h b))))\n         (DOWN x)) =\n    UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n        \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n                 hsnd yz\\<rangle> \\<^bold>\\<in>\n        arr_to_hfun (local.comp (eval b c) (HF'.prod h b))\\<rbrace>", "by simp"], ["proof (state)\nthis:\n  UP (happ\n       (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n         (arr_to_hfun (local.comp (eval b c) (HF'.prod h b))))\n       (DOWN x)) =\n  UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n      \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n               hsnd yz\\<rangle> \\<^bold>\\<in>\n      arr_to_hfun (local.comp (eval b c) (HF'.prod h b))\\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  UP (happ\n       (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n         (arr_to_hfun (local.comp (eval b c) (HF'.prod h b))))\n       (DOWN x)) =\n  UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n      \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n               hsnd yz\\<rangle> \\<^bold>\\<in>\n      arr_to_hfun (local.comp (eval b c) (HF'.prod h b))\\<rbrace>\n\ngoal (1 subgoal):\n 1. x \\<in> local.set a \\<Longrightarrow>\n    Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x = Fun h x", "also"], ["proof (state)\nthis:\n  UP (happ\n       (hlam (ide_to_hf a) (ide_to_hf b) (ide_to_hf c)\n         (arr_to_hfun (local.comp (eval b c) (HF'.prod h b))))\n       (DOWN x)) =\n  UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n      \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n               hsnd yz\\<rangle> \\<^bold>\\<in>\n      arr_to_hfun (local.comp (eval b c) (HF'.prod h b))\\<rbrace>\n\ngoal (1 subgoal):\n 1. x \\<in> local.set a \\<Longrightarrow>\n    Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x = Fun h x", "have \"... = UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n                                   hsnd yz = DOWN (Fun (comp (eval b c) (HF'.prod h b))\n                                                       (UP \\<langle>DOWN x, hfst yz\\<rangle>))\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n        \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n                 hsnd yz\\<rangle> \\<^bold>\\<in>\n        arr_to_hfun (local.comp (eval b c) (HF'.prod h b))\\<rbrace> =\n    UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n        hsnd yz =\n        DOWN\n         (Fun (local.comp (eval b c) (HF'.prod h b))\n           (UP \\<langle>DOWN x, hfst yz\\<rangle>))\\<rbrace>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n        \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n                 hsnd yz\\<rangle> \\<^bold>\\<in>\n        arr_to_hfun (local.comp (eval b c) (HF'.prod h b))\\<rbrace> =\n    UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n        hsnd yz =\n        DOWN\n         (Fun (local.comp (eval b c) (HF'.prod h b))\n           (UP \\<langle>DOWN x, hfst yz\\<rangle>))\\<rbrace>", "have \"\\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n                       \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>, hsnd yz\\<rangle>\n                          \\<^bold>\\<in> arr_to_hfun (comp (eval b c) (HF'.prod h b))\\<rbrace> =\n                    \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n                                   hsnd yz = DOWN (Fun (comp (eval b c) (HF'.prod h b))\n                                                       (UP \\<langle>DOWN x, hfst yz\\<rangle>))\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n     \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n              hsnd yz\\<rangle> \\<^bold>\\<in>\n     arr_to_hfun (local.comp (eval b c) (HF'.prod h b))\\<rbrace> =\n    \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n     hsnd yz =\n     DOWN\n      (Fun (local.comp (eval b c) (HF'.prod h b))\n        (UP \\<langle>DOWN x, hfst yz\\<rangle>))\\<rbrace>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (xa \\<^bold>\\<in>\n        \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n         \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n                  hsnd yz\\<rangle> \\<^bold>\\<in>\n         arr_to_hfun (local.comp (eval b c) (HF'.prod h b))\\<rbrace>) =\n       (xa \\<^bold>\\<in>\n        \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n         hsnd yz =\n         DOWN\n          (Fun (local.comp (eval b c) (HF'.prod h b))\n            (UP \\<langle>DOWN x, hfst yz\\<rangle>))\\<rbrace>)", "fix yz"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (xa \\<^bold>\\<in>\n        \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n         \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n                  hsnd yz\\<rangle> \\<^bold>\\<in>\n         arr_to_hfun (local.comp (eval b c) (HF'.prod h b))\\<rbrace>) =\n       (xa \\<^bold>\\<in>\n        \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n         hsnd yz =\n         DOWN\n          (Fun (local.comp (eval b c) (HF'.prod h b))\n            (UP \\<langle>DOWN x, hfst yz\\<rangle>))\\<rbrace>)", "show \"yz \\<^bold>\\<in> \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n                                   \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>, hsnd yz\\<rangle>\n                                      \\<^bold>\\<in> arr_to_hfun (comp (eval b c) (HF'.prod h b))\\<rbrace> \\<longleftrightarrow>\n                      yz \\<^bold>\\<in> \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n                                   hsnd yz = DOWN (Fun (comp (eval b c) (HF'.prod h b))\n                                                     (UP \\<langle>DOWN x, hfst yz\\<rangle>))\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (yz \\<^bold>\\<in>\n     \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n      \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n               hsnd yz\\<rangle> \\<^bold>\\<in>\n      arr_to_hfun (local.comp (eval b c) (HF'.prod h b))\\<rbrace>) =\n    (yz \\<^bold>\\<in>\n     \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n      hsnd yz =\n      DOWN\n       (Fun (local.comp (eval b c) (HF'.prod h b))\n         (UP \\<langle>DOWN x, hfst yz\\<rangle>))\\<rbrace>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (yz \\<^bold>\\<in>\n     \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n      \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n               hsnd yz\\<rangle> \\<^bold>\\<in>\n      arr_to_hfun (local.comp (eval b c) (HF'.prod h b))\\<rbrace>) =\n    (yz \\<^bold>\\<in>\n     \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n      hsnd yz =\n      DOWN\n       (Fun (local.comp (eval b c) (HF'.prod h b))\n         (UP \\<langle>DOWN x, hfst yz\\<rangle>))\\<rbrace>)", "have \"yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c \\<Longrightarrow>\n                        \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>, hsnd yz\\<rangle> \\<^bold>\\<in> arr_to_hfun (comp (eval b c) (HF'.prod h b))\n                          \\<longleftrightarrow> hsnd yz = DOWN (Fun (comp (eval b c) (HF'.prod h b))\n                                                     (UP \\<langle>DOWN x, hfst yz\\<rangle>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c \\<Longrightarrow>\n    (\\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n              hsnd yz\\<rangle> \\<^bold>\\<in>\n     arr_to_hfun (local.comp (eval b c) (HF'.prod h b))) =\n    (hsnd yz =\n     DOWN\n      (Fun (local.comp (eval b c) (HF'.prod h b))\n        (UP \\<langle>DOWN x, hfst yz\\<rangle>)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c \\<Longrightarrow>\n    (\\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n              hsnd yz\\<rangle> \\<^bold>\\<in>\n     arr_to_hfun (local.comp (eval b c) (HF'.prod h b))) =\n    (hsnd yz =\n     DOWN\n      (Fun (local.comp (eval b c) (HF'.prod h b))\n        (UP \\<langle>DOWN x, hfst yz\\<rangle>)))", "assume yz: \"yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c\""], ["proof (state)\nthis:\n  yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c\n\ngoal (1 subgoal):\n 1. yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c \\<Longrightarrow>\n    (\\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n              hsnd yz\\<rangle> \\<^bold>\\<in>\n     arr_to_hfun (local.comp (eval b c) (HF'.prod h b))) =\n    (hsnd yz =\n     DOWN\n      (Fun (local.comp (eval b c) (HF'.prod h b))\n        (UP \\<langle>DOWN x, hfst yz\\<rangle>)))", "have \"\\<langle>\\<langle>DOWN x, hfst yz\\<rangle>, hsnd yz\\<rangle>\n                             \\<^bold>\\<in> arr_to_hfun (comp (eval b c) (HF'.prod h b))\n                            \\<longleftrightarrow>\n                          \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>, hsnd yz\\<rangle> \\<^bold>\\<in> ide_to_hf (HF'.prod a b) * ide_to_hf c \\<and>\n                          hsnd yz = DOWN (Fun (comp (eval b c) (HF'.prod h b))\n                                         (UP \\<langle>DOWN x, hfst yz\\<rangle>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n              hsnd yz\\<rangle> \\<^bold>\\<in>\n     arr_to_hfun (local.comp (eval b c) (HF'.prod h b))) =\n    (\\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n              hsnd yz\\<rangle> \\<^bold>\\<in>\n     ide_to_hf (HF'.prod a b) * ide_to_hf c \\<and>\n     hsnd yz =\n     DOWN\n      (Fun (local.comp (eval b c) (HF'.prod h b))\n        (UP \\<langle>DOWN x, hfst yz\\<rangle>)))", "unfolding arr_to_hfun_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n              hsnd yz\\<rangle> \\<^bold>\\<in>\n     \\<lbrace>XY \\<^bold>\\<in>\n      ide_to_hf (local.dom (local.comp (eval b c) (HF'.prod h b))) *\n      ide_to_hf (cod (local.comp (eval b c) (HF'.prod h b))).\n      hsnd XY =\n      DOWN\n       (Fun (local.comp (eval b c) (HF'.prod h b))\n         (UP (hfst XY)))\\<rbrace>) =\n    (\\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n              hsnd yz\\<rangle> \\<^bold>\\<in>\n     ide_to_hf (HF'.prod a b) * ide_to_hf c \\<and>\n     hsnd yz =\n     DOWN\n      (Fun (local.comp (eval b c) (HF'.prod h b))\n        (UP \\<langle>DOWN x, hfst yz\\<rangle>)))", "using assms 5 6"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  local.dom (local.comp (eval b c) (HF'.prod h b)) = HF'.prod a b\n  cod (local.comp (eval b c) (HF'.prod h b)) = c\n\ngoal (1 subgoal):\n 1. (\\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n              hsnd yz\\<rangle> \\<^bold>\\<in>\n     \\<lbrace>XY \\<^bold>\\<in>\n      ide_to_hf (local.dom (local.comp (eval b c) (HF'.prod h b))) *\n      ide_to_hf (cod (local.comp (eval b c) (HF'.prod h b))).\n      hsnd XY =\n      DOWN\n       (Fun (local.comp (eval b c) (HF'.prod h b))\n         (UP (hfst XY)))\\<rbrace>) =\n    (\\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n              hsnd yz\\<rangle> \\<^bold>\\<in>\n     ide_to_hf (HF'.prod a b) * ide_to_hf c \\<and>\n     hsnd yz =\n     DOWN\n      (Fun (local.comp (eval b c) (HF'.prod h b))\n        (UP \\<langle>DOWN x, hfst yz\\<rangle>)))", "by (metis (mono_tags, lifting) HCollect_iff hfst_conv hsnd_conv)"], ["proof (state)\nthis:\n  (\\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n            hsnd yz\\<rangle> \\<^bold>\\<in>\n   arr_to_hfun (local.comp (eval b c) (HF'.prod h b))) =\n  (\\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n            hsnd yz\\<rangle> \\<^bold>\\<in>\n   ide_to_hf (HF'.prod a b) * ide_to_hf c \\<and>\n   hsnd yz =\n   DOWN\n    (Fun (local.comp (eval b c) (HF'.prod h b))\n      (UP \\<langle>DOWN x, hfst yz\\<rangle>)))\n\ngoal (1 subgoal):\n 1. yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c \\<Longrightarrow>\n    (\\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n              hsnd yz\\<rangle> \\<^bold>\\<in>\n     arr_to_hfun (local.comp (eval b c) (HF'.prod h b))) =\n    (hsnd yz =\n     DOWN\n      (Fun (local.comp (eval b c) (HF'.prod h b))\n        (UP \\<langle>DOWN x, hfst yz\\<rangle>)))", "(* 20 sec *)"], ["proof (state)\nthis:\n  (\\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n            hsnd yz\\<rangle> \\<^bold>\\<in>\n   arr_to_hfun (local.comp (eval b c) (HF'.prod h b))) =\n  (\\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n            hsnd yz\\<rangle> \\<^bold>\\<in>\n   ide_to_hf (HF'.prod a b) * ide_to_hf c \\<and>\n   hsnd yz =\n   DOWN\n    (Fun (local.comp (eval b c) (HF'.prod h b))\n      (UP \\<langle>DOWN x, hfst yz\\<rangle>)))\n\ngoal (1 subgoal):\n 1. yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c \\<Longrightarrow>\n    (\\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n              hsnd yz\\<rangle> \\<^bold>\\<in>\n     arr_to_hfun (local.comp (eval b c) (HF'.prod h b))) =\n    (hsnd yz =\n     DOWN\n      (Fun (local.comp (eval b c) (HF'.prod h b))\n        (UP \\<langle>DOWN x, hfst yz\\<rangle>)))", "moreover"], ["proof (state)\nthis:\n  (\\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n            hsnd yz\\<rangle> \\<^bold>\\<in>\n   arr_to_hfun (local.comp (eval b c) (HF'.prod h b))) =\n  (\\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n            hsnd yz\\<rangle> \\<^bold>\\<in>\n   ide_to_hf (HF'.prod a b) * ide_to_hf c \\<and>\n   hsnd yz =\n   DOWN\n    (Fun (local.comp (eval b c) (HF'.prod h b))\n      (UP \\<langle>DOWN x, hfst yz\\<rangle>)))\n\ngoal (1 subgoal):\n 1. yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c \\<Longrightarrow>\n    (\\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n              hsnd yz\\<rangle> \\<^bold>\\<in>\n     arr_to_hfun (local.comp (eval b c) (HF'.prod h b))) =\n    (hsnd yz =\n     DOWN\n      (Fun (local.comp (eval b c) (HF'.prod h b))\n        (UP \\<langle>DOWN x, hfst yz\\<rangle>)))", "have \"\\<langle>\\<langle>DOWN x, hfst yz\\<rangle>, hsnd yz\\<rangle>\n                                      \\<^bold>\\<in> ide_to_hf (prod a b) * ide_to_hf c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n             hsnd yz\\<rangle> \\<^bold>\\<in>\n    ide_to_hf (local.prod a b) * ide_to_hf c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n             hsnd yz\\<rangle> \\<^bold>\\<in>\n    ide_to_hf (local.prod a b) * ide_to_hf c", "have \"\\<langle>DOWN x, hfst yz\\<rangle> \\<^bold>\\<in> ide_to_hf (HF'.prod a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>DOWN x, hfst yz\\<rangle> \\<^bold>\\<in> ide_to_hf (HF'.prod a b)", "using assms x yz"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  x \\<in> local.set a\n  yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c\n\ngoal (1 subgoal):\n 1. \\<langle>DOWN x, hfst yz\\<rangle> \\<^bold>\\<in> ide_to_hf (HF'.prod a b)", "by (metis (no_types, lifting) prod_def DOWN_membI UNIV_I hfst_conv\n                            ide_to_hf_hf_to_ide prod_ide_eq timesE times_iff)"], ["proof (state)\nthis:\n  \\<langle>DOWN x, hfst yz\\<rangle> \\<^bold>\\<in> ide_to_hf (HF'.prod a b)\n\ngoal (1 subgoal):\n 1. \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n             hsnd yz\\<rangle> \\<^bold>\\<in>\n    ide_to_hf (local.prod a b) * ide_to_hf c", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<langle>DOWN x, hfst yz\\<rangle> \\<^bold>\\<in> ide_to_hf (HF'.prod a b)\n\ngoal (1 subgoal):\n 1. \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n             hsnd yz\\<rangle> \\<^bold>\\<in>\n    ide_to_hf (local.prod a b) * ide_to_hf c", "using yz assms(1-2) prod_ide_eq"], ["proof (prove)\nusing this:\n  \\<langle>DOWN x, hfst yz\\<rangle> \\<^bold>\\<in> ide_to_hf (HF'.prod a b)\n  yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c\n  ide a\n  ide b\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> local.prod ?a ?b = HF'.prod ?a ?b\n\ngoal (1 subgoal):\n 1. \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n             hsnd yz\\<rangle> \\<^bold>\\<in>\n    ide_to_hf (local.prod a b) * ide_to_hf c", "by auto"], ["proof (state)\nthis:\n  \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>, hsnd yz\\<rangle> \\<^bold>\\<in>\n  ide_to_hf (local.prod a b) * ide_to_hf c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>, hsnd yz\\<rangle> \\<^bold>\\<in>\n  ide_to_hf (local.prod a b) * ide_to_hf c\n\ngoal (1 subgoal):\n 1. yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c \\<Longrightarrow>\n    (\\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n              hsnd yz\\<rangle> \\<^bold>\\<in>\n     arr_to_hfun (local.comp (eval b c) (HF'.prod h b))) =\n    (hsnd yz =\n     DOWN\n      (Fun (local.comp (eval b c) (HF'.prod h b))\n        (UP \\<langle>DOWN x, hfst yz\\<rangle>)))", "ultimately"], ["proof (chain)\npicking this:\n  (\\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n            hsnd yz\\<rangle> \\<^bold>\\<in>\n   arr_to_hfun (local.comp (eval b c) (HF'.prod h b))) =\n  (\\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n            hsnd yz\\<rangle> \\<^bold>\\<in>\n   ide_to_hf (HF'.prod a b) * ide_to_hf c \\<and>\n   hsnd yz =\n   DOWN\n    (Fun (local.comp (eval b c) (HF'.prod h b))\n      (UP \\<langle>DOWN x, hfst yz\\<rangle>)))\n  \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>, hsnd yz\\<rangle> \\<^bold>\\<in>\n  ide_to_hf (local.prod a b) * ide_to_hf c", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n            hsnd yz\\<rangle> \\<^bold>\\<in>\n   arr_to_hfun (local.comp (eval b c) (HF'.prod h b))) =\n  (\\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n            hsnd yz\\<rangle> \\<^bold>\\<in>\n   ide_to_hf (HF'.prod a b) * ide_to_hf c \\<and>\n   hsnd yz =\n   DOWN\n    (Fun (local.comp (eval b c) (HF'.prod h b))\n      (UP \\<langle>DOWN x, hfst yz\\<rangle>)))\n  \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>, hsnd yz\\<rangle> \\<^bold>\\<in>\n  ide_to_hf (local.prod a b) * ide_to_hf c\n\ngoal (1 subgoal):\n 1. (\\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n              hsnd yz\\<rangle> \\<^bold>\\<in>\n     arr_to_hfun (local.comp (eval b c) (HF'.prod h b))) =\n    (hsnd yz =\n     DOWN\n      (Fun (local.comp (eval b c) (HF'.prod h b))\n        (UP \\<langle>DOWN x, hfst yz\\<rangle>)))", "using assms(1-2) prod_ide_eq"], ["proof (prove)\nusing this:\n  (\\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n            hsnd yz\\<rangle> \\<^bold>\\<in>\n   arr_to_hfun (local.comp (eval b c) (HF'.prod h b))) =\n  (\\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n            hsnd yz\\<rangle> \\<^bold>\\<in>\n   ide_to_hf (HF'.prod a b) * ide_to_hf c \\<and>\n   hsnd yz =\n   DOWN\n    (Fun (local.comp (eval b c) (HF'.prod h b))\n      (UP \\<langle>DOWN x, hfst yz\\<rangle>)))\n  \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>, hsnd yz\\<rangle> \\<^bold>\\<in>\n  ide_to_hf (local.prod a b) * ide_to_hf c\n  ide a\n  ide b\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> local.prod ?a ?b = HF'.prod ?a ?b\n\ngoal (1 subgoal):\n 1. (\\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n              hsnd yz\\<rangle> \\<^bold>\\<in>\n     arr_to_hfun (local.comp (eval b c) (HF'.prod h b))) =\n    (hsnd yz =\n     DOWN\n      (Fun (local.comp (eval b c) (HF'.prod h b))\n        (UP \\<langle>DOWN x, hfst yz\\<rangle>)))", "by auto"], ["proof (state)\nthis:\n  (\\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n            hsnd yz\\<rangle> \\<^bold>\\<in>\n   arr_to_hfun (local.comp (eval b c) (HF'.prod h b))) =\n  (hsnd yz =\n   DOWN\n    (Fun (local.comp (eval b c) (HF'.prod h b))\n      (UP \\<langle>DOWN x, hfst yz\\<rangle>)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c \\<Longrightarrow>\n  (\\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n            hsnd yz\\<rangle> \\<^bold>\\<in>\n   arr_to_hfun (local.comp (eval b c) (HF'.prod h b))) =\n  (hsnd yz =\n   DOWN\n    (Fun (local.comp (eval b c) (HF'.prod h b))\n      (UP \\<langle>DOWN x, hfst yz\\<rangle>)))\n\ngoal (1 subgoal):\n 1. (yz \\<^bold>\\<in>\n     \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n      \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n               hsnd yz\\<rangle> \\<^bold>\\<in>\n      arr_to_hfun (local.comp (eval b c) (HF'.prod h b))\\<rbrace>) =\n    (yz \\<^bold>\\<in>\n     \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n      hsnd yz =\n      DOWN\n       (Fun (local.comp (eval b c) (HF'.prod h b))\n         (UP \\<langle>DOWN x, hfst yz\\<rangle>))\\<rbrace>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c \\<Longrightarrow>\n  (\\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n            hsnd yz\\<rangle> \\<^bold>\\<in>\n   arr_to_hfun (local.comp (eval b c) (HF'.prod h b))) =\n  (hsnd yz =\n   DOWN\n    (Fun (local.comp (eval b c) (HF'.prod h b))\n      (UP \\<langle>DOWN x, hfst yz\\<rangle>)))\n\ngoal (1 subgoal):\n 1. (yz \\<^bold>\\<in>\n     \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n      \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n               hsnd yz\\<rangle> \\<^bold>\\<in>\n      arr_to_hfun (local.comp (eval b c) (HF'.prod h b))\\<rbrace>) =\n    (yz \\<^bold>\\<in>\n     \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n      hsnd yz =\n      DOWN\n       (Fun (local.comp (eval b c) (HF'.prod h b))\n         (UP \\<langle>DOWN x, hfst yz\\<rangle>))\\<rbrace>)", "by auto"], ["proof (state)\nthis:\n  (yz \\<^bold>\\<in>\n   \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n    \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n             hsnd yz\\<rangle> \\<^bold>\\<in>\n    arr_to_hfun (local.comp (eval b c) (HF'.prod h b))\\<rbrace>) =\n  (yz \\<^bold>\\<in>\n   \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n    hsnd yz =\n    DOWN\n     (Fun (local.comp (eval b c) (HF'.prod h b))\n       (UP \\<langle>DOWN x, hfst yz\\<rangle>))\\<rbrace>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (yz \\<^bold>\\<in>\n   \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n    \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n             hsnd yz\\<rangle> \\<^bold>\\<in>\n    arr_to_hfun (local.comp (eval b c) (HF'.prod h b))\\<rbrace>) =\n  (yz \\<^bold>\\<in>\n   \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n    hsnd yz =\n    DOWN\n     (Fun (local.comp (eval b c) (HF'.prod h b))\n       (UP \\<langle>DOWN x, hfst yz\\<rangle>))\\<rbrace>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n   \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n            hsnd yz\\<rangle> \\<^bold>\\<in>\n   arr_to_hfun (local.comp (eval b c) (HF'.prod h b))\\<rbrace> =\n  \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n   hsnd yz =\n   DOWN\n    (Fun (local.comp (eval b c) (HF'.prod h b))\n      (UP \\<langle>DOWN x, hfst yz\\<rangle>))\\<rbrace>\n\ngoal (1 subgoal):\n 1. UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n        \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n                 hsnd yz\\<rangle> \\<^bold>\\<in>\n        arr_to_hfun (local.comp (eval b c) (HF'.prod h b))\\<rbrace> =\n    UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n        hsnd yz =\n        DOWN\n         (Fun (local.comp (eval b c) (HF'.prod h b))\n           (UP \\<langle>DOWN x, hfst yz\\<rangle>))\\<rbrace>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n   \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n            hsnd yz\\<rangle> \\<^bold>\\<in>\n   arr_to_hfun (local.comp (eval b c) (HF'.prod h b))\\<rbrace> =\n  \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n   hsnd yz =\n   DOWN\n    (Fun (local.comp (eval b c) (HF'.prod h b))\n      (UP \\<langle>DOWN x, hfst yz\\<rangle>))\\<rbrace>\n\ngoal (1 subgoal):\n 1. UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n        \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n                 hsnd yz\\<rangle> \\<^bold>\\<in>\n        arr_to_hfun (local.comp (eval b c) (HF'.prod h b))\\<rbrace> =\n    UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n        hsnd yz =\n        DOWN\n         (Fun (local.comp (eval b c) (HF'.prod h b))\n           (UP \\<langle>DOWN x, hfst yz\\<rangle>))\\<rbrace>", "by simp"], ["proof (state)\nthis:\n  UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n      \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n               hsnd yz\\<rangle> \\<^bold>\\<in>\n      arr_to_hfun (local.comp (eval b c) (HF'.prod h b))\\<rbrace> =\n  UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n      hsnd yz =\n      DOWN\n       (Fun (local.comp (eval b c) (HF'.prod h b))\n         (UP \\<langle>DOWN x, hfst yz\\<rangle>))\\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n      \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n               hsnd yz\\<rangle> \\<^bold>\\<in>\n      arr_to_hfun (local.comp (eval b c) (HF'.prod h b))\\<rbrace> =\n  UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n      hsnd yz =\n      DOWN\n       (Fun (local.comp (eval b c) (HF'.prod h b))\n         (UP \\<langle>DOWN x, hfst yz\\<rangle>))\\<rbrace>\n\ngoal (1 subgoal):\n 1. x \\<in> local.set a \\<Longrightarrow>\n    Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x = Fun h x", "also"], ["proof (state)\nthis:\n  UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n      \\<langle>\\<langle>DOWN x, hfst yz\\<rangle>,\n               hsnd yz\\<rangle> \\<^bold>\\<in>\n      arr_to_hfun (local.comp (eval b c) (HF'.prod h b))\\<rbrace> =\n  UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n      hsnd yz =\n      DOWN\n       (Fun (local.comp (eval b c) (HF'.prod h b))\n         (UP \\<langle>DOWN x, hfst yz\\<rangle>))\\<rbrace>\n\ngoal (1 subgoal):\n 1. x \\<in> local.set a \\<Longrightarrow>\n    Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x = Fun h x", "have \"... = UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c. yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n        hsnd yz =\n        DOWN\n         (Fun (local.comp (eval b c) (HF'.prod h b))\n           (UP \\<langle>DOWN x, hfst yz\\<rangle>))\\<rbrace> =\n    UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n        yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n        hsnd yz =\n        DOWN\n         (Fun (local.comp (eval b c) (HF'.prod h b))\n           (UP \\<langle>DOWN x, hfst yz\\<rangle>))\\<rbrace> =\n    UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n        yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>", "have \"\\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n                       hsnd yz = DOWN (Fun (comp (eval b c) (HF'.prod h b))\n                                               (UP \\<langle>DOWN x, hfst yz\\<rangle>))\\<rbrace> =\n                    \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c. yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n     hsnd yz =\n     DOWN\n      (Fun (local.comp (eval b c) (HF'.prod h b))\n        (UP \\<langle>DOWN x, hfst yz\\<rangle>))\\<rbrace> =\n    \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n     yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n     hsnd yz =\n     DOWN\n      (Fun (local.comp (eval b c) (HF'.prod h b))\n        (UP \\<langle>DOWN x, hfst yz\\<rangle>))\\<rbrace> =\n    \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n     yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>", "have \"\\<And>yz. yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c \\<Longrightarrow>\n                             hsnd yz = DOWN (Fun (comp (eval b c) (HF'.prod h b))\n                                            (UP \\<langle>DOWN x, hfst yz\\<rangle>))\n                               \\<longleftrightarrow>\n                             yz \\<^bold>\\<in> DOWN (Fun h x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>yz.\n       yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c \\<Longrightarrow>\n       (hsnd yz =\n        DOWN\n         (Fun (local.comp (eval b c) (HF'.prod h b))\n           (UP \\<langle>DOWN x, hfst yz\\<rangle>))) =\n       (yz \\<^bold>\\<in> DOWN (Fun h x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>yz.\n       yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c \\<Longrightarrow>\n       (hsnd yz =\n        DOWN\n         (Fun (local.comp (eval b c) (HF'.prod h b))\n           (UP \\<langle>DOWN x, hfst yz\\<rangle>))) =\n       (yz \\<^bold>\\<in> DOWN (Fun h x))", "fix yz"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>yz.\n       yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c \\<Longrightarrow>\n       (hsnd yz =\n        DOWN\n         (Fun (local.comp (eval b c) (HF'.prod h b))\n           (UP \\<langle>DOWN x, hfst yz\\<rangle>))) =\n       (yz \\<^bold>\\<in> DOWN (Fun h x))", "assume yz: \"yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c\""], ["proof (state)\nthis:\n  yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c\n\ngoal (1 subgoal):\n 1. \\<And>yz.\n       yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c \\<Longrightarrow>\n       (hsnd yz =\n        DOWN\n         (Fun (local.comp (eval b c) (HF'.prod h b))\n           (UP \\<langle>DOWN x, hfst yz\\<rangle>))) =\n       (yz \\<^bold>\\<in> DOWN (Fun h x))", "have 7: \"UP \\<langle>DOWN x, hfst yz\\<rangle> \\<in> set (HF'.prod a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP \\<langle>DOWN x, hfst yz\\<rangle> \\<in> local.set (HF'.prod a b)", "using assms x yz UP_membI"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  x \\<in> local.set a\n  yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c\n  ?x \\<^bold>\\<in> ide_to_hf ?a \\<Longrightarrow> UP ?x \\<in> local.set ?a\n\ngoal (1 subgoal):\n 1. UP \\<langle>DOWN x, hfst yz\\<rangle> \\<in> local.set (HF'.prod a b)", "by (metis (no_types, lifting) prod_def DOWN_membI UNIV_I hfst_conv\n                        ide_to_hf_hf_to_ide prod_ide_eq timesE times_iff)"], ["proof (state)\nthis:\n  UP \\<langle>DOWN x, hfst yz\\<rangle> \\<in> local.set (HF'.prod a b)\n\ngoal (1 subgoal):\n 1. \\<And>yz.\n       yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c \\<Longrightarrow>\n       (hsnd yz =\n        DOWN\n         (Fun (local.comp (eval b c) (HF'.prod h b))\n           (UP \\<langle>DOWN x, hfst yz\\<rangle>))) =\n       (yz \\<^bold>\\<in> DOWN (Fun h x))", "have 8: \"Fun h x \\<in> set (exp b c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun h x \\<in> local.set (exp b c)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Fun h x \\<in> local.set (exp b c)", "have \"Fun h x \\<in> Cod h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun h x \\<in> Cod h", "using assms x Fun_mapsto"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  x \\<in> local.set a\n  arr ?f \\<Longrightarrow>\n  Fun ?f \\<in> extensional (Dom ?f) \\<inter> (Dom ?f \\<rightarrow> Cod ?f)\n\ngoal (1 subgoal):\n 1. Fun h x \\<in> Cod h", "by blast"], ["proof (state)\nthis:\n  Fun h x \\<in> Cod h\n\ngoal (1 subgoal):\n 1. Fun h x \\<in> local.set (exp b c)", "moreover"], ["proof (state)\nthis:\n  Fun h x \\<in> Cod h\n\ngoal (1 subgoal):\n 1. Fun h x \\<in> local.set (exp b c)", "have \"Cod h = set (exp b c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cod h = local.set (exp b c)", "using assms 0 lam_simps(3) par"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  \\<guillemotleft>local.comp (eval b c)\n                   (HF'.prod h\n                     b) : local.prod a b \\<rightarrow> c\\<guillemotright>\n  \\<lbrakk>ide ?a; ide ?b; ide ?c;\n   \\<guillemotleft>?f : local.prod ?a\n                         ?b \\<rightarrow> ?c\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> cod (\\<Lambda> ?a ?b ?c ?f) = exp ?b ?c\n  par (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) h\n\ngoal (1 subgoal):\n 1. Cod h = local.set (exp b c)", "by auto"], ["proof (state)\nthis:\n  Cod h = local.set (exp b c)\n\ngoal (1 subgoal):\n 1. Fun h x \\<in> local.set (exp b c)", "ultimately"], ["proof (chain)\npicking this:\n  Fun h x \\<in> Cod h\n  Cod h = local.set (exp b c)", "show ?thesis"], ["proof (prove)\nusing this:\n  Fun h x \\<in> Cod h\n  Cod h = local.set (exp b c)\n\ngoal (1 subgoal):\n 1. Fun h x \\<in> local.set (exp b c)", "by blast"], ["proof (state)\nthis:\n  Fun h x \\<in> local.set (exp b c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Fun h x \\<in> local.set (exp b c)\n\ngoal (1 subgoal):\n 1. \\<And>yz.\n       yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c \\<Longrightarrow>\n       (hsnd yz =\n        DOWN\n         (Fun (local.comp (eval b c) (HF'.prod h b))\n           (UP \\<langle>DOWN x, hfst yz\\<rangle>))) =\n       (yz \\<^bold>\\<in> DOWN (Fun h x))", "show \"hsnd yz = DOWN (Fun (comp (eval b c) (HF'.prod h b))\n                                            (UP \\<langle>DOWN x, hfst yz\\<rangle>))\n                           \\<longleftrightarrow>\n                        yz \\<^bold>\\<in> DOWN (Fun h x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hsnd yz =\n     DOWN\n      (Fun (local.comp (eval b c) (HF'.prod h b))\n        (UP \\<langle>DOWN x, hfst yz\\<rangle>))) =\n    (yz \\<^bold>\\<in> DOWN (Fun h x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (hsnd yz =\n     DOWN\n      (Fun (local.comp (eval b c) (HF'.prod h b))\n        (UP \\<langle>DOWN x, hfst yz\\<rangle>))) =\n    (yz \\<^bold>\\<in> DOWN (Fun h x))", "have \"Fun (comp (eval b c) (HF'.prod h b)) (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n                            UP (happ (DOWN (Fun h x)) (hfst yz))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (local.comp (eval b c) (HF'.prod h b))\n     (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n    UP (happ (DOWN (Fun h x)) (hfst yz))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Fun (local.comp (eval b c) (HF'.prod h b))\n     (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n    UP (happ (DOWN (Fun h x)) (hfst yz))", "have \"Fun (comp (eval b c) (HF'.prod h b)) (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n                            restrict (Fun (eval b c) \\<circ> Fun (HF'.prod h b))\n                                     (set (HF'.prod a b))\n                                     (UP \\<langle>DOWN x, hfst yz\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (local.comp (eval b c) (HF'.prod h b))\n     (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n    restrict (Fun (eval b c) \\<circ> Fun (HF'.prod h b))\n     (local.set (HF'.prod a b)) (UP \\<langle>DOWN x, hfst yz\\<rangle>)", "using assms x yz 2"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  x \\<in> local.set a\n  yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c\n  Fun (local.comp (eval b c) (HF'.prod h b)) =\n  restrict (Fun (eval b c) \\<circ> Fun (HF'.prod h b))\n   (local.set (HF'.prod a b))\n\ngoal (1 subgoal):\n 1. Fun (local.comp (eval b c) (HF'.prod h b))\n     (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n    restrict (Fun (eval b c) \\<circ> Fun (HF'.prod h b))\n     (local.set (HF'.prod a b)) (UP \\<langle>DOWN x, hfst yz\\<rangle>)", "by simp"], ["proof (state)\nthis:\n  Fun (local.comp (eval b c) (HF'.prod h b))\n   (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n  restrict (Fun (eval b c) \\<circ> Fun (HF'.prod h b))\n   (local.set (HF'.prod a b)) (UP \\<langle>DOWN x, hfst yz\\<rangle>)\n\ngoal (1 subgoal):\n 1. Fun (local.comp (eval b c) (HF'.prod h b))\n     (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n    UP (happ (DOWN (Fun h x)) (hfst yz))", "also"], ["proof (state)\nthis:\n  Fun (local.comp (eval b c) (HF'.prod h b))\n   (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n  restrict (Fun (eval b c) \\<circ> Fun (HF'.prod h b))\n   (local.set (HF'.prod a b)) (UP \\<langle>DOWN x, hfst yz\\<rangle>)\n\ngoal (1 subgoal):\n 1. Fun (local.comp (eval b c) (HF'.prod h b))\n     (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n    UP (happ (DOWN (Fun h x)) (hfst yz))", "have \"... = Fun (eval b c)\n                                               (Fun (HF'.prod h b) (UP \\<langle>DOWN x, hfst yz\\<rangle>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict (Fun (eval b c) \\<circ> Fun (HF'.prod h b))\n     (local.set (HF'.prod a b)) (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n    Fun (eval b c)\n     (Fun (HF'.prod h b) (UP \\<langle>DOWN x, hfst yz\\<rangle>))", "using 7"], ["proof (prove)\nusing this:\n  UP \\<langle>DOWN x, hfst yz\\<rangle> \\<in> local.set (HF'.prod a b)\n\ngoal (1 subgoal):\n 1. restrict (Fun (eval b c) \\<circ> Fun (HF'.prod h b))\n     (local.set (HF'.prod a b)) (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n    Fun (eval b c)\n     (Fun (HF'.prod h b) (UP \\<langle>DOWN x, hfst yz\\<rangle>))", "by simp"], ["proof (state)\nthis:\n  restrict (Fun (eval b c) \\<circ> Fun (HF'.prod h b))\n   (local.set (HF'.prod a b)) (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n  Fun (eval b c) (Fun (HF'.prod h b) (UP \\<langle>DOWN x, hfst yz\\<rangle>))\n\ngoal (1 subgoal):\n 1. Fun (local.comp (eval b c) (HF'.prod h b))\n     (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n    UP (happ (DOWN (Fun h x)) (hfst yz))", "also"], ["proof (state)\nthis:\n  restrict (Fun (eval b c) \\<circ> Fun (HF'.prod h b))\n   (local.set (HF'.prod a b)) (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n  Fun (eval b c) (Fun (HF'.prod h b) (UP \\<langle>DOWN x, hfst yz\\<rangle>))\n\ngoal (1 subgoal):\n 1. Fun (local.comp (eval b c) (HF'.prod h b))\n     (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n    UP (happ (DOWN (Fun h x)) (hfst yz))", "have \"... = Fun (eval b c)\n                                               (UP \\<langle>DOWN (Fun h x),\n                                                    DOWN (Fun b (UP (hfst yz)))\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (eval b c)\n     (Fun (HF'.prod h b) (UP \\<langle>DOWN x, hfst yz\\<rangle>)) =\n    Fun (eval b c)\n     (UP \\<langle>DOWN (Fun h x), DOWN (Fun b (UP (hfst yz)))\\<rangle>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Fun (eval b c)\n     (Fun (HF'.prod h b) (UP \\<langle>DOWN x, hfst yz\\<rangle>)) =\n    Fun (eval b c)\n     (UP \\<langle>DOWN (Fun h x), DOWN (Fun b (UP (hfst yz)))\\<rangle>)", "have \"Fun (HF'.prod h b) (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n                           UP \\<langle>DOWN (Fun h x), DOWN (Fun b (UP (hfst yz)))\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (HF'.prod h b) (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n    UP \\<langle>DOWN (Fun h x), DOWN (Fun b (UP (hfst yz)))\\<rangle>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Fun (HF'.prod h b) (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n    UP \\<langle>DOWN (Fun h x), DOWN (Fun b (UP (hfst yz)))\\<rangle>", "have \"Fun (HF'.prod h b) (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n                                UP \\<langle>DOWN (Fun h (UP (hfst (DOWN (UP \\<langle>DOWN x, hfst yz\\<rangle>))))),\n                                    DOWN (Fun b (UP (hsnd (DOWN (UP \\<langle>DOWN x, hfst yz\\<rangle>)))))\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (HF'.prod h b) (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n    UP \\<langle>DOWN\n                 (Fun h\n                   (UP (hfst\n                         (DOWN (UP \\<langle>DOWN x, hfst yz\\<rangle>))))),\n                DOWN\n                 (Fun b\n                   (UP (hsnd\n                         (DOWN\n                           (UP \\<langle>DOWN x,\n  hfst yz\\<rangle>)))))\\<rangle>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Fun (HF'.prod h b) (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n    UP \\<langle>DOWN\n                 (Fun h\n                   (UP (hfst\n                         (DOWN (UP \\<langle>DOWN x, hfst yz\\<rangle>))))),\n                DOWN\n                 (Fun b\n                   (UP (hsnd\n                         (DOWN\n                           (UP \\<langle>DOWN x,\n  hfst yz\\<rangle>)))))\\<rangle>", "have \"UP \\<langle>DOWN x, hfst yz\\<rangle> \\<in> set (prod (dom h) (dom b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP \\<langle>DOWN x, hfst yz\\<rangle>\n    \\<in> local.set (local.prod (local.dom h) (local.dom b))", "using assms x yz 7"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  x \\<in> local.set a\n  yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c\n  UP \\<langle>DOWN x, hfst yz\\<rangle> \\<in> local.set (HF'.prod a b)\n\ngoal (1 subgoal):\n 1. UP \\<langle>DOWN x, hfst yz\\<rangle>\n    \\<in> local.set (local.prod (local.dom h) (local.dom b))", "by (metis (no_types, lifting) ideD(2) in_homE prod_ide_eq)"], ["proof (state)\nthis:\n  UP \\<langle>DOWN x, hfst yz\\<rangle>\n  \\<in> local.set (local.prod (local.dom h) (local.dom b))\n\ngoal (1 subgoal):\n 1. Fun (HF'.prod h b) (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n    UP \\<langle>DOWN\n                 (Fun h\n                   (UP (hfst\n                         (DOWN (UP \\<langle>DOWN x, hfst yz\\<rangle>))))),\n                DOWN\n                 (Fun b\n                   (UP (hsnd\n                         (DOWN\n                           (UP \\<langle>DOWN x,\n  hfst yz\\<rangle>)))))\\<rangle>", "thus ?thesis"], ["proof (prove)\nusing this:\n  UP \\<langle>DOWN x, hfst yz\\<rangle>\n  \\<in> local.set (local.prod (local.dom h) (local.dom b))\n\ngoal (1 subgoal):\n 1. Fun (HF'.prod h b) (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n    UP \\<langle>DOWN\n                 (Fun h\n                   (UP (hfst\n                         (DOWN (UP \\<langle>DOWN x, hfst yz\\<rangle>))))),\n                DOWN\n                 (Fun b\n                   (UP (hsnd\n                         (DOWN\n                           (UP \\<langle>DOWN x,\n  hfst yz\\<rangle>)))))\\<rangle>", "using assms x yz Fun_prod ideD(1)"], ["proof (prove)\nusing this:\n  UP \\<langle>DOWN x, hfst yz\\<rangle>\n  \\<in> local.set (local.prod (local.dom h) (local.dom b))\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  x \\<in> local.set a\n  yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c\n  \\<lbrakk>arr ?f; arr ?g;\n   ?x \\<in> local.set (local.prod (local.dom ?f) (local.dom ?g))\\<rbrakk>\n  \\<Longrightarrow> Fun (HF'.prod ?f ?g) ?x =\n                    UP \\<langle>DOWN (Fun ?f (UP (hfst (DOWN ?x)))),\n                                DOWN (Fun ?g (UP (hsnd (DOWN ?x))))\\<rangle>\n  ide ?a \\<Longrightarrow> arr ?a\n\ngoal (1 subgoal):\n 1. Fun (HF'.prod h b) (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n    UP \\<langle>DOWN\n                 (Fun h\n                   (UP (hfst\n                         (DOWN (UP \\<langle>DOWN x, hfst yz\\<rangle>))))),\n                DOWN\n                 (Fun b\n                   (UP (hsnd\n                         (DOWN\n                           (UP \\<langle>DOWN x,\n  hfst yz\\<rangle>)))))\\<rangle>", "by blast"], ["proof (state)\nthis:\n  Fun (HF'.prod h b) (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n  UP \\<langle>DOWN\n               (Fun h\n                 (UP (hfst (DOWN (UP \\<langle>DOWN x, hfst yz\\<rangle>))))),\n              DOWN\n               (Fun b\n                 (UP (hsnd\n                       (DOWN\n                         (UP \\<langle>DOWN x, hfst yz\\<rangle>)))))\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Fun (HF'.prod h b) (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n  UP \\<langle>DOWN\n               (Fun h\n                 (UP (hfst (DOWN (UP \\<langle>DOWN x, hfst yz\\<rangle>))))),\n              DOWN\n               (Fun b\n                 (UP (hsnd\n                       (DOWN\n                         (UP \\<langle>DOWN x, hfst yz\\<rangle>)))))\\<rangle>\n\ngoal (1 subgoal):\n 1. Fun (HF'.prod h b) (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n    UP \\<langle>DOWN (Fun h x), DOWN (Fun b (UP (hfst yz)))\\<rangle>", "also"], ["proof (state)\nthis:\n  Fun (HF'.prod h b) (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n  UP \\<langle>DOWN\n               (Fun h\n                 (UP (hfst (DOWN (UP \\<langle>DOWN x, hfst yz\\<rangle>))))),\n              DOWN\n               (Fun b\n                 (UP (hsnd\n                       (DOWN\n                         (UP \\<langle>DOWN x, hfst yz\\<rangle>)))))\\<rangle>\n\ngoal (1 subgoal):\n 1. Fun (HF'.prod h b) (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n    UP \\<langle>DOWN (Fun h x), DOWN (Fun b (UP (hfst yz)))\\<rangle>", "have \"... = UP \\<langle>DOWN (Fun h (UP (DOWN x))),\n                                               DOWN (Fun b (UP (hfst yz)))\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP \\<langle>DOWN\n                 (Fun h\n                   (UP (hfst\n                         (DOWN (UP \\<langle>DOWN x, hfst yz\\<rangle>))))),\n                DOWN\n                 (Fun b\n                   (UP (hsnd\n                         (DOWN\n                           (UP \\<langle>DOWN x,\n  hfst yz\\<rangle>)))))\\<rangle> =\n    UP \\<langle>DOWN (Fun h (UP (DOWN x))),\n                DOWN (Fun b (UP (hfst yz)))\\<rangle>", "using assms x yz"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  x \\<in> local.set a\n  yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c\n\ngoal (1 subgoal):\n 1. UP \\<langle>DOWN\n                 (Fun h\n                   (UP (hfst\n                         (DOWN (UP \\<langle>DOWN x, hfst yz\\<rangle>))))),\n                DOWN\n                 (Fun b\n                   (UP (hsnd\n                         (DOWN\n                           (UP \\<langle>DOWN x,\n  hfst yz\\<rangle>)))))\\<rangle> =\n    UP \\<langle>DOWN (Fun h (UP (DOWN x))),\n                DOWN (Fun b (UP (hfst yz)))\\<rangle>", "by simp"], ["proof (state)\nthis:\n  UP \\<langle>DOWN\n               (Fun h\n                 (UP (hfst (DOWN (UP \\<langle>DOWN x, hfst yz\\<rangle>))))),\n              DOWN\n               (Fun b\n                 (UP (hsnd\n                       (DOWN\n                         (UP \\<langle>DOWN x,\nhfst yz\\<rangle>)))))\\<rangle> =\n  UP \\<langle>DOWN (Fun h (UP (DOWN x))),\n              DOWN (Fun b (UP (hfst yz)))\\<rangle>\n\ngoal (1 subgoal):\n 1. Fun (HF'.prod h b) (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n    UP \\<langle>DOWN (Fun h x), DOWN (Fun b (UP (hfst yz)))\\<rangle>", "also"], ["proof (state)\nthis:\n  UP \\<langle>DOWN\n               (Fun h\n                 (UP (hfst (DOWN (UP \\<langle>DOWN x, hfst yz\\<rangle>))))),\n              DOWN\n               (Fun b\n                 (UP (hsnd\n                       (DOWN\n                         (UP \\<langle>DOWN x,\nhfst yz\\<rangle>)))))\\<rangle> =\n  UP \\<langle>DOWN (Fun h (UP (DOWN x))),\n              DOWN (Fun b (UP (hfst yz)))\\<rangle>\n\ngoal (1 subgoal):\n 1. Fun (HF'.prod h b) (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n    UP \\<langle>DOWN (Fun h x), DOWN (Fun b (UP (hfst yz)))\\<rangle>", "have \"... = UP \\<langle>DOWN (Fun h x), DOWN (Fun b (UP (hfst yz)))\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP \\<langle>DOWN (Fun h (UP (DOWN x))),\n                DOWN (Fun b (UP (hfst yz)))\\<rangle> =\n    UP \\<langle>DOWN (Fun h x), DOWN (Fun b (UP (hfst yz)))\\<rangle>", "using assms(1) set_subset_Univ x"], ["proof (prove)\nusing this:\n  ide a\n  ide ?a \\<Longrightarrow> local.set ?a \\<subseteq> Univ\n  x \\<in> local.set a\n\ngoal (1 subgoal):\n 1. UP \\<langle>DOWN (Fun h (UP (DOWN x))),\n                DOWN (Fun b (UP (hfst yz)))\\<rangle> =\n    UP \\<langle>DOWN (Fun h x), DOWN (Fun b (UP (hfst yz)))\\<rangle>", "by force"], ["proof (state)\nthis:\n  UP \\<langle>DOWN (Fun h (UP (DOWN x))),\n              DOWN (Fun b (UP (hfst yz)))\\<rangle> =\n  UP \\<langle>DOWN (Fun h x), DOWN (Fun b (UP (hfst yz)))\\<rangle>\n\ngoal (1 subgoal):\n 1. Fun (HF'.prod h b) (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n    UP \\<langle>DOWN (Fun h x), DOWN (Fun b (UP (hfst yz)))\\<rangle>", "finally"], ["proof (chain)\npicking this:\n  Fun (HF'.prod h b) (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n  UP \\<langle>DOWN (Fun h x), DOWN (Fun b (UP (hfst yz)))\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  Fun (HF'.prod h b) (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n  UP \\<langle>DOWN (Fun h x), DOWN (Fun b (UP (hfst yz)))\\<rangle>\n\ngoal (1 subgoal):\n 1. Fun (HF'.prod h b) (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n    UP \\<langle>DOWN (Fun h x), DOWN (Fun b (UP (hfst yz)))\\<rangle>", "by simp"], ["proof (state)\nthis:\n  Fun (HF'.prod h b) (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n  UP \\<langle>DOWN (Fun h x), DOWN (Fun b (UP (hfst yz)))\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Fun (HF'.prod h b) (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n  UP \\<langle>DOWN (Fun h x), DOWN (Fun b (UP (hfst yz)))\\<rangle>\n\ngoal (1 subgoal):\n 1. Fun (eval b c)\n     (Fun (HF'.prod h b) (UP \\<langle>DOWN x, hfst yz\\<rangle>)) =\n    Fun (eval b c)\n     (UP \\<langle>DOWN (Fun h x), DOWN (Fun b (UP (hfst yz)))\\<rangle>)", "thus ?thesis"], ["proof (prove)\nusing this:\n  Fun (HF'.prod h b) (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n  UP \\<langle>DOWN (Fun h x), DOWN (Fun b (UP (hfst yz)))\\<rangle>\n\ngoal (1 subgoal):\n 1. Fun (eval b c)\n     (Fun (HF'.prod h b) (UP \\<langle>DOWN x, hfst yz\\<rangle>)) =\n    Fun (eval b c)\n     (UP \\<langle>DOWN (Fun h x), DOWN (Fun b (UP (hfst yz)))\\<rangle>)", "by simp"], ["proof (state)\nthis:\n  Fun (eval b c)\n   (Fun (HF'.prod h b) (UP \\<langle>DOWN x, hfst yz\\<rangle>)) =\n  Fun (eval b c)\n   (UP \\<langle>DOWN (Fun h x), DOWN (Fun b (UP (hfst yz)))\\<rangle>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Fun (eval b c)\n   (Fun (HF'.prod h b) (UP \\<langle>DOWN x, hfst yz\\<rangle>)) =\n  Fun (eval b c)\n   (UP \\<langle>DOWN (Fun h x), DOWN (Fun b (UP (hfst yz)))\\<rangle>)\n\ngoal (1 subgoal):\n 1. Fun (local.comp (eval b c) (HF'.prod h b))\n     (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n    UP (happ (DOWN (Fun h x)) (hfst yz))", "also"], ["proof (state)\nthis:\n  Fun (eval b c)\n   (Fun (HF'.prod h b) (UP \\<langle>DOWN x, hfst yz\\<rangle>)) =\n  Fun (eval b c)\n   (UP \\<langle>DOWN (Fun h x), DOWN (Fun b (UP (hfst yz)))\\<rangle>)\n\ngoal (1 subgoal):\n 1. Fun (local.comp (eval b c) (HF'.prod h b))\n     (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n    UP (happ (DOWN (Fun h x)) (hfst yz))", "have \"... = Fun (eval b c) (UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (eval b c)\n     (UP \\<langle>DOWN (Fun h x), DOWN (Fun b (UP (hfst yz)))\\<rangle>) =\n    Fun (eval b c) (UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>)", "using assms x yz Fun_ide ide_char UP_membI"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  x \\<in> local.set a\n  yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c\n  ide ?a \\<Longrightarrow> Fun ?a = (\\<lambda>x\\<^bold>\\<in>local.set ?a. x)\n  arr ?f \\<Longrightarrow>\n  ide ?f =\n  (Dom ?f = Cod ?f \\<and> Fun ?f = (\\<lambda>x\\<^bold>\\<in>Dom ?f. x))\n  ?x \\<^bold>\\<in> ide_to_hf ?a \\<Longrightarrow> UP ?x \\<in> local.set ?a\n\ngoal (1 subgoal):\n 1. Fun (eval b c)\n     (UP \\<langle>DOWN (Fun h x), DOWN (Fun b (UP (hfst yz)))\\<rangle>) =\n    Fun (eval b c) (UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>)", "by auto"], ["proof (state)\nthis:\n  Fun (eval b c)\n   (UP \\<langle>DOWN (Fun h x), DOWN (Fun b (UP (hfst yz)))\\<rangle>) =\n  Fun (eval b c) (UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>)\n\ngoal (1 subgoal):\n 1. Fun (local.comp (eval b c) (HF'.prod h b))\n     (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n    UP (happ (DOWN (Fun h x)) (hfst yz))", "also"], ["proof (state)\nthis:\n  Fun (eval b c)\n   (UP \\<langle>DOWN (Fun h x), DOWN (Fun b (UP (hfst yz)))\\<rangle>) =\n  Fun (eval b c) (UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>)\n\ngoal (1 subgoal):\n 1. Fun (local.comp (eval b c) (HF'.prod h b))\n     (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n    UP (happ (DOWN (Fun h x)) (hfst yz))", "have \"... = restrict (\\<lambda>x. UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))\n                                                (set (HF'.prod (exp b c) b))\n                                                (UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (eval b c) (UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>) =\n    (\\<lambda>x\\<^bold>\\<in>local.set (HF'.prod (exp b c) b).\n        UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))\n     (UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>)", "using assms Fun_eval [of b c]"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  \\<lbrakk>ide b; ide c\\<rbrakk>\n  \\<Longrightarrow> Fun (eval b c) =\n                    (\\<lambda>x\\<^bold>\\<in>local.set\n       (HF'.prod (exp b c) b).\n                        UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))\n\ngoal (1 subgoal):\n 1. Fun (eval b c) (UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>) =\n    (\\<lambda>x\\<^bold>\\<in>local.set (HF'.prod (exp b c) b).\n        UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))\n     (UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>)", "by simp"], ["proof (state)\nthis:\n  Fun (eval b c) (UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>) =\n  (\\<lambda>x\\<^bold>\\<in>local.set (HF'.prod (exp b c) b).\n      UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))\n   (UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>)\n\ngoal (1 subgoal):\n 1. Fun (local.comp (eval b c) (HF'.prod h b))\n     (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n    UP (happ (DOWN (Fun h x)) (hfst yz))", "also"], ["proof (state)\nthis:\n  Fun (eval b c) (UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>) =\n  (\\<lambda>x\\<^bold>\\<in>local.set (HF'.prod (exp b c) b).\n      UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))\n   (UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>)\n\ngoal (1 subgoal):\n 1. Fun (local.comp (eval b c) (HF'.prod h b))\n     (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n    UP (happ (DOWN (Fun h x)) (hfst yz))", "have \"... = (\\<lambda>x. UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))\n                                         (UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<^bold>\\<in>local.set (HF'.prod (exp b c) b).\n        UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))\n     (UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>) =\n    UP (happ (hfst (DOWN (UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>)))\n         (hsnd (DOWN (UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<^bold>\\<in>local.set (HF'.prod (exp b c) b).\n        UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))\n     (UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>) =\n    UP (happ (hfst (DOWN (UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>)))\n         (hsnd (DOWN (UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>))))", "have \"UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>\n                                 \\<in> set (HF'.prod (exp b c) b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>\n    \\<in> local.set (HF'.prod (exp b c) b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>\n    \\<in> local.set (HF'.prod (exp b c) b)", "have 1: \"ide_to_hf (HF'.prod (exp b c) b) =\n                                   HF (DOWN ` set (HF'.prod (exp b c) b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide_to_hf (HF'.prod (exp b c) b) =\n    HF (DOWN ` local.set (HF'.prod (exp b c) b))", "unfolding ide_to_hf_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. HF (DOWN ` local.set (HF'.prod (exp b c) b)) =\n    HF (DOWN ` local.set (HF'.prod (exp b c) b))", "by blast"], ["proof (state)\nthis:\n  ide_to_hf (HF'.prod (exp b c) b) =\n  HF (DOWN ` local.set (HF'.prod (exp b c) b))\n\ngoal (1 subgoal):\n 1. UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>\n    \\<in> local.set (HF'.prod (exp b c) b)", "have \"\\<langle>DOWN (Fun h x), hfst yz\\<rangle>\n                                  \\<^bold>\\<in> HF (DOWN ` set (HF'.prod (exp b c) b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>DOWN (Fun h x), hfst yz\\<rangle> \\<^bold>\\<in>\n    HF (DOWN ` local.set (HF'.prod (exp b c) b))", "using assms x yz 1 8 Fun_mapsto [of h]"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  x \\<in> local.set a\n  yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c\n  ide_to_hf (HF'.prod (exp b c) b) =\n  HF (DOWN ` local.set (HF'.prod (exp b c) b))\n  Fun h x \\<in> local.set (exp b c)\n  arr h \\<Longrightarrow>\n  Fun h \\<in> extensional (Dom h) \\<inter> (Dom h \\<rightarrow> Cod h)\n\ngoal (1 subgoal):\n 1. \\<langle>DOWN (Fun h x), hfst yz\\<rangle> \\<^bold>\\<in>\n    HF (DOWN ` local.set (HF'.prod (exp b c) b))", "by (metis (no_types, lifting) prod_def DOWN_membI UNIV_I\n                                hfst_conv ide_exp ide_to_hf_hf_to_ide prod_ide_eq timesE times_iff)"], ["proof (state)\nthis:\n  \\<langle>DOWN (Fun h x), hfst yz\\<rangle> \\<^bold>\\<in>\n  HF (DOWN ` local.set (HF'.prod (exp b c) b))\n\ngoal (1 subgoal):\n 1. UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>\n    \\<in> local.set (HF'.prod (exp b c) b)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<langle>DOWN (Fun h x), hfst yz\\<rangle> \\<^bold>\\<in>\n  HF (DOWN ` local.set (HF'.prod (exp b c) b))\n\ngoal (1 subgoal):\n 1. UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>\n    \\<in> local.set (HF'.prod (exp b c) b)", "using assms x yz 1 UP_membI [of \"\\<langle>DOWN (Fun h x), hfst yz\\<rangle>\"]"], ["proof (prove)\nusing this:\n  \\<langle>DOWN (Fun h x), hfst yz\\<rangle> \\<^bold>\\<in>\n  HF (DOWN ` local.set (HF'.prod (exp b c) b))\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  x \\<in> local.set a\n  yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c\n  ide_to_hf (HF'.prod (exp b c) b) =\n  HF (DOWN ` local.set (HF'.prod (exp b c) b))\n  \\<langle>DOWN (Fun h x), hfst yz\\<rangle> \\<^bold>\\<in>\n  ide_to_hf ?a \\<Longrightarrow>\n  UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle> \\<in> local.set ?a\n\ngoal (1 subgoal):\n 1. UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>\n    \\<in> local.set (HF'.prod (exp b c) b)", "by auto"], ["proof (state)\nthis:\n  UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>\n  \\<in> local.set (HF'.prod (exp b c) b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>\n  \\<in> local.set (HF'.prod (exp b c) b)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<^bold>\\<in>local.set (HF'.prod (exp b c) b).\n        UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))\n     (UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>) =\n    UP (happ (hfst (DOWN (UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>)))\n         (hsnd (DOWN (UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>\n  \\<in> local.set (HF'.prod (exp b c) b)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<^bold>\\<in>local.set (HF'.prod (exp b c) b).\n        UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))\n     (UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>) =\n    UP (happ (hfst (DOWN (UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>)))\n         (hsnd (DOWN (UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>))))", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>x\\<^bold>\\<in>local.set (HF'.prod (exp b c) b).\n      UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))\n   (UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>) =\n  UP (happ (hfst (DOWN (UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>)))\n       (hsnd (DOWN (UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>x\\<^bold>\\<in>local.set (HF'.prod (exp b c) b).\n      UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))\n   (UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>) =\n  UP (happ (hfst (DOWN (UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>)))\n       (hsnd (DOWN (UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>))))\n\ngoal (1 subgoal):\n 1. Fun (local.comp (eval b c) (HF'.prod h b))\n     (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n    UP (happ (DOWN (Fun h x)) (hfst yz))", "also"], ["proof (state)\nthis:\n  (\\<lambda>x\\<^bold>\\<in>local.set (HF'.prod (exp b c) b).\n      UP (happ (hfst (DOWN x)) (hsnd (DOWN x))))\n   (UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>) =\n  UP (happ (hfst (DOWN (UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>)))\n       (hsnd (DOWN (UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>))))\n\ngoal (1 subgoal):\n 1. Fun (local.comp (eval b c) (HF'.prod h b))\n     (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n    UP (happ (DOWN (Fun h x)) (hfst yz))", "have \"... = UP (happ (DOWN (Fun h x)) (hfst yz))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP (happ (hfst (DOWN (UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>)))\n         (hsnd (DOWN (UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>)))) =\n    UP (happ (DOWN (Fun h x)) (hfst yz))", "by simp"], ["proof (state)\nthis:\n  UP (happ (hfst (DOWN (UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>)))\n       (hsnd (DOWN (UP \\<langle>DOWN (Fun h x), hfst yz\\<rangle>)))) =\n  UP (happ (DOWN (Fun h x)) (hfst yz))\n\ngoal (1 subgoal):\n 1. Fun (local.comp (eval b c) (HF'.prod h b))\n     (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n    UP (happ (DOWN (Fun h x)) (hfst yz))", "finally"], ["proof (chain)\npicking this:\n  Fun (local.comp (eval b c) (HF'.prod h b))\n   (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n  UP (happ (DOWN (Fun h x)) (hfst yz))", "show ?thesis"], ["proof (prove)\nusing this:\n  Fun (local.comp (eval b c) (HF'.prod h b))\n   (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n  UP (happ (DOWN (Fun h x)) (hfst yz))\n\ngoal (1 subgoal):\n 1. Fun (local.comp (eval b c) (HF'.prod h b))\n     (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n    UP (happ (DOWN (Fun h x)) (hfst yz))", "by simp"], ["proof (state)\nthis:\n  Fun (local.comp (eval b c) (HF'.prod h b))\n   (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n  UP (happ (DOWN (Fun h x)) (hfst yz))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Fun (local.comp (eval b c) (HF'.prod h b))\n   (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n  UP (happ (DOWN (Fun h x)) (hfst yz))\n\ngoal (1 subgoal):\n 1. (hsnd yz =\n     DOWN\n      (Fun (local.comp (eval b c) (HF'.prod h b))\n        (UP \\<langle>DOWN x, hfst yz\\<rangle>))) =\n    (yz \\<^bold>\\<in> DOWN (Fun h x))", "hence 9: \"DOWN (Fun (comp (eval b c) (HF'.prod h b))\n                                        (UP \\<langle>DOWN x, hfst yz\\<rangle>)) =\n                              happ (DOWN (Fun h x)) (hfst yz)\""], ["proof (prove)\nusing this:\n  Fun (local.comp (eval b c) (HF'.prod h b))\n   (UP \\<langle>DOWN x, hfst yz\\<rangle>) =\n  UP (happ (DOWN (Fun h x)) (hfst yz))\n\ngoal (1 subgoal):\n 1. DOWN\n     (Fun (local.comp (eval b c) (HF'.prod h b))\n       (UP \\<langle>DOWN x, hfst yz\\<rangle>)) =\n    happ (DOWN (Fun h x)) (hfst yz)", "by simp"], ["proof (state)\nthis:\n  DOWN\n   (Fun (local.comp (eval b c) (HF'.prod h b))\n     (UP \\<langle>DOWN x, hfst yz\\<rangle>)) =\n  happ (DOWN (Fun h x)) (hfst yz)\n\ngoal (1 subgoal):\n 1. (hsnd yz =\n     DOWN\n      (Fun (local.comp (eval b c) (HF'.prod h b))\n        (UP \\<langle>DOWN x, hfst yz\\<rangle>))) =\n    (yz \\<^bold>\\<in> DOWN (Fun h x))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (hsnd yz =\n     DOWN\n      (Fun (local.comp (eval b c) (HF'.prod h b))\n        (UP \\<langle>DOWN x, hfst yz\\<rangle>))) =\n    (yz \\<^bold>\\<in> DOWN (Fun h x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (hsnd yz =\n     DOWN\n      (Fun (local.comp (eval b c) (HF'.prod h b))\n        (UP \\<langle>DOWN x, hfst yz\\<rangle>))) =\n    (yz \\<^bold>\\<in> DOWN (Fun h x))", "have \"hsnd yz = happ (DOWN (Fun h x)) (hfst yz)\n                              \\<longleftrightarrow> yz \\<^bold>\\<in> DOWN (Fun h x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (hsnd yz = happ (DOWN (Fun h x)) (hfst yz)) =\n    (yz \\<^bold>\\<in> DOWN (Fun h x))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. hsnd yz = happ (DOWN (Fun h x)) (hfst yz) \\<Longrightarrow>\n    yz \\<^bold>\\<in> DOWN (Fun h x)\n 2. yz \\<^bold>\\<in> DOWN (Fun h x) \\<Longrightarrow>\n    hsnd yz = happ (DOWN (Fun h x)) (hfst yz)", "have 10: \"\\<exists>!z. \\<langle>hfst yz, z\\<rangle> \\<^bold>\\<in> DOWN (Fun h x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!z. \\<langle>hfst yz, z\\<rangle> \\<^bold>\\<in> DOWN (Fun h x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!z. \\<langle>hfst yz, z\\<rangle> \\<^bold>\\<in> DOWN (Fun h x)", "have \"hfun (ide_to_hf b) (ide_to_hf c) (DOWN (Fun h x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hfun (ide_to_hf b) (ide_to_hf c) (DOWN (Fun h x))", "using assms x 8"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  x \\<in> local.set a\n  Fun h x \\<in> local.set (exp b c)\n\ngoal (1 subgoal):\n 1. hfun (ide_to_hf b) (ide_to_hf c) (DOWN (Fun h x))", "by (metis (no_types, lifting) DOWN_membI HCollect_iff UNIV_I\n                                exp_def hexp_def ide_exp ide_to_hf_hf_to_ide)"], ["proof (state)\nthis:\n  hfun (ide_to_hf b) (ide_to_hf c) (DOWN (Fun h x))\n\ngoal (1 subgoal):\n 1. \\<exists>!z. \\<langle>hfst yz, z\\<rangle> \\<^bold>\\<in> DOWN (Fun h x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  hfun (ide_to_hf b) (ide_to_hf c) (DOWN (Fun h x))\n\ngoal (1 subgoal):\n 1. \\<exists>!z. \\<langle>hfst yz, z\\<rangle> \\<^bold>\\<in> DOWN (Fun h x)", "using assms yz\n                                  hfunE [of \"ide_to_hf b\" \"ide_to_hf c\" \"DOWN (Fun h x)\"]"], ["proof (prove)\nusing this:\n  hfun (ide_to_hf b) (ide_to_hf c) (DOWN (Fun h x))\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c\n  \\<lbrakk>hfun (ide_to_hf b) (ide_to_hf c) (DOWN (Fun h x));\n   (\\<And>Y.\n       Y \\<^bold>\\<in> ide_to_hf b \\<Longrightarrow>\n       (\\<exists>!Z.\n           \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> DOWN (Fun h x)) \\<and>\n       (\\<forall>Z.\n           \\<langle>Y, Z\\<rangle> \\<^bold>\\<in>\n           DOWN (Fun h x) \\<longrightarrow>\n           Z \\<^bold>\\<in> ide_to_hf c)) \\<Longrightarrow>\n   ?T\\<rbrakk>\n  \\<Longrightarrow> ?T\n\ngoal (1 subgoal):\n 1. \\<exists>!z. \\<langle>hfst yz, z\\<rangle> \\<^bold>\\<in> DOWN (Fun h x)", "by (metis (no_types, lifting) hfst_conv timesE)"], ["proof (state)\nthis:\n  \\<exists>!z. \\<langle>hfst yz, z\\<rangle> \\<^bold>\\<in> DOWN (Fun h x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!z. \\<langle>hfst yz, z\\<rangle> \\<^bold>\\<in> DOWN (Fun h x)\n\ngoal (2 subgoals):\n 1. hsnd yz = happ (DOWN (Fun h x)) (hfst yz) \\<Longrightarrow>\n    yz \\<^bold>\\<in> DOWN (Fun h x)\n 2. yz \\<^bold>\\<in> DOWN (Fun h x) \\<Longrightarrow>\n    hsnd yz = happ (DOWN (Fun h x)) (hfst yz)", "show \"yz \\<^bold>\\<in> DOWN (Fun h x)\n                                \\<Longrightarrow> hsnd yz = happ (DOWN (Fun h x)) (hfst yz)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. yz \\<^bold>\\<in> DOWN (Fun h x) \\<Longrightarrow>\n    hsnd yz = happ (DOWN (Fun h x)) (hfst yz)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. yz \\<^bold>\\<in> DOWN (Fun h x) \\<Longrightarrow>\n    hsnd yz = happ (DOWN (Fun h x)) (hfst yz)", "assume yz1: \"yz \\<^bold>\\<in> DOWN (Fun h x)\""], ["proof (state)\nthis:\n  yz \\<^bold>\\<in> DOWN (Fun h x)\n\ngoal (1 subgoal):\n 1. yz \\<^bold>\\<in> DOWN (Fun h x) \\<Longrightarrow>\n    hsnd yz = happ (DOWN (Fun h x)) (hfst yz)", "show \"hsnd yz = happ (DOWN (Fun h x)) (hfst yz)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hsnd yz = happ (DOWN (Fun h x)) (hfst yz)", "unfolding app_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hsnd yz =\n    (THE y. \\<langle>hfst yz, y\\<rangle> \\<^bold>\\<in> DOWN (Fun h x))", "using assms x yz yz1 10 hfun_arr_to_hfun arr_to_hfun_def\n                                  the1_equality\n                                    [of \"\\<lambda>y. \\<langle>hfst yz, y\\<rangle> \\<^bold>\\<in> DOWN (Fun h x)\" \"hsnd yz\"]"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  x \\<in> local.set a\n  yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c\n  yz \\<^bold>\\<in> DOWN (Fun h x)\n  \\<exists>!z. \\<langle>hfst yz, z\\<rangle> \\<^bold>\\<in> DOWN (Fun h x)\n  arr ?f \\<Longrightarrow>\n  hfun (ide_to_hf (local.dom ?f)) (ide_to_hf (cod ?f)) (arr_to_hfun ?f)\n  arr_to_hfun ?f =\n  \\<lbrace>XY \\<^bold>\\<in> ide_to_hf (local.dom ?f) * ide_to_hf (cod ?f).\n   hsnd XY = DOWN (Fun ?f (UP (hfst XY)))\\<rbrace>\n  \\<lbrakk>\\<exists>!xa.\n              \\<langle>hfst yz, xa\\<rangle> \\<^bold>\\<in> DOWN (Fun h x);\n   \\<langle>hfst yz, hsnd yz\\<rangle> \\<^bold>\\<in> DOWN (Fun h x)\\<rbrakk>\n  \\<Longrightarrow> (THE xa.\n                        \\<langle>hfst yz, xa\\<rangle> \\<^bold>\\<in>\n                        DOWN (Fun h x)) =\n                    hsnd yz\n\ngoal (1 subgoal):\n 1. hsnd yz =\n    (THE y. \\<langle>hfst yz, y\\<rangle> \\<^bold>\\<in> DOWN (Fun h x))", "by (metis (no_types, lifting) hfst_conv hsnd_conv timesE)"], ["proof (state)\nthis:\n  hsnd yz = happ (DOWN (Fun h x)) (hfst yz)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  yz \\<^bold>\\<in> DOWN (Fun h x) \\<Longrightarrow>\n  hsnd yz = happ (DOWN (Fun h x)) (hfst yz)\n\ngoal (1 subgoal):\n 1. hsnd yz = happ (DOWN (Fun h x)) (hfst yz) \\<Longrightarrow>\n    yz \\<^bold>\\<in> DOWN (Fun h x)", "show \"hsnd yz = happ (DOWN (Fun h x)) (hfst yz)\n                                \\<Longrightarrow> yz \\<^bold>\\<in> DOWN (Fun h x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hsnd yz = happ (DOWN (Fun h x)) (hfst yz) \\<Longrightarrow>\n    yz \\<^bold>\\<in> DOWN (Fun h x)", "unfolding app_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. hsnd yz =\n    (THE y.\n        \\<langle>hfst yz, y\\<rangle> \\<^bold>\\<in>\n        DOWN (Fun h x)) \\<Longrightarrow>\n    yz \\<^bold>\\<in> DOWN (Fun h x)", "using assms x yz 10\n                                theI' [of \"\\<lambda>y. \\<langle>hfst yz, y\\<rangle> \\<^bold>\\<in> DOWN (Fun h x)\"]"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  x \\<in> local.set a\n  yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c\n  \\<exists>!z. \\<langle>hfst yz, z\\<rangle> \\<^bold>\\<in> DOWN (Fun h x)\n  \\<exists>!xa.\n     \\<langle>hfst yz, xa\\<rangle> \\<^bold>\\<in>\n     DOWN (Fun h x) \\<Longrightarrow>\n  \\<langle>hfst yz,\n           THE xa.\n              \\<langle>hfst yz, xa\\<rangle> \\<^bold>\\<in>\n              DOWN (Fun h x)\\<rangle> \\<^bold>\\<in>\n  DOWN (Fun h x)\n\ngoal (1 subgoal):\n 1. hsnd yz =\n    (THE y.\n        \\<langle>hfst yz, y\\<rangle> \\<^bold>\\<in>\n        DOWN (Fun h x)) \\<Longrightarrow>\n    yz \\<^bold>\\<in> DOWN (Fun h x)", "by (metis (no_types, lifting) hfst_conv hsnd_conv timesE)"], ["proof (state)\nthis:\n  hsnd yz = happ (DOWN (Fun h x)) (hfst yz) \\<Longrightarrow>\n  yz \\<^bold>\\<in> DOWN (Fun h x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (hsnd yz = happ (DOWN (Fun h x)) (hfst yz)) =\n  (yz \\<^bold>\\<in> DOWN (Fun h x))\n\ngoal (1 subgoal):\n 1. (hsnd yz =\n     DOWN\n      (Fun (local.comp (eval b c) (HF'.prod h b))\n        (UP \\<langle>DOWN x, hfst yz\\<rangle>))) =\n    (yz \\<^bold>\\<in> DOWN (Fun h x))", "thus ?thesis"], ["proof (prove)\nusing this:\n  (hsnd yz = happ (DOWN (Fun h x)) (hfst yz)) =\n  (yz \\<^bold>\\<in> DOWN (Fun h x))\n\ngoal (1 subgoal):\n 1. (hsnd yz =\n     DOWN\n      (Fun (local.comp (eval b c) (HF'.prod h b))\n        (UP \\<langle>DOWN x, hfst yz\\<rangle>))) =\n    (yz \\<^bold>\\<in> DOWN (Fun h x))", "using 9"], ["proof (prove)\nusing this:\n  (hsnd yz = happ (DOWN (Fun h x)) (hfst yz)) =\n  (yz \\<^bold>\\<in> DOWN (Fun h x))\n  DOWN\n   (Fun (local.comp (eval b c) (HF'.prod h b))\n     (UP \\<langle>DOWN x, hfst yz\\<rangle>)) =\n  happ (DOWN (Fun h x)) (hfst yz)\n\ngoal (1 subgoal):\n 1. (hsnd yz =\n     DOWN\n      (Fun (local.comp (eval b c) (HF'.prod h b))\n        (UP \\<langle>DOWN x, hfst yz\\<rangle>))) =\n    (yz \\<^bold>\\<in> DOWN (Fun h x))", "by simp"], ["proof (state)\nthis:\n  (hsnd yz =\n   DOWN\n    (Fun (local.comp (eval b c) (HF'.prod h b))\n      (UP \\<langle>DOWN x, hfst yz\\<rangle>))) =\n  (yz \\<^bold>\\<in> DOWN (Fun h x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (hsnd yz =\n   DOWN\n    (Fun (local.comp (eval b c) (HF'.prod h b))\n      (UP \\<langle>DOWN x, hfst yz\\<rangle>))) =\n  (yz \\<^bold>\\<in> DOWN (Fun h x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (hsnd yz =\n   DOWN\n    (Fun (local.comp (eval b c) (HF'.prod h b))\n      (UP \\<langle>DOWN x, hfst yz\\<rangle>))) =\n  (yz \\<^bold>\\<in> DOWN (Fun h x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?yz1 \\<^bold>\\<in> ide_to_hf b * ide_to_hf c \\<Longrightarrow>\n  (hsnd ?yz1 =\n   DOWN\n    (Fun (local.comp (eval b c) (HF'.prod h b))\n      (UP \\<langle>DOWN x, hfst ?yz1\\<rangle>))) =\n  (?yz1 \\<^bold>\\<in> DOWN (Fun h x))\n\ngoal (1 subgoal):\n 1. \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n     hsnd yz =\n     DOWN\n      (Fun (local.comp (eval b c) (HF'.prod h b))\n        (UP \\<langle>DOWN x, hfst yz\\<rangle>))\\<rbrace> =\n    \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n     yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?yz1 \\<^bold>\\<in> ide_to_hf b * ide_to_hf c \\<Longrightarrow>\n  (hsnd ?yz1 =\n   DOWN\n    (Fun (local.comp (eval b c) (HF'.prod h b))\n      (UP \\<langle>DOWN x, hfst ?yz1\\<rangle>))) =\n  (?yz1 \\<^bold>\\<in> DOWN (Fun h x))\n\ngoal (1 subgoal):\n 1. \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n     hsnd yz =\n     DOWN\n      (Fun (local.comp (eval b c) (HF'.prod h b))\n        (UP \\<langle>DOWN x, hfst yz\\<rangle>))\\<rbrace> =\n    \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n     yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>", "by blast"], ["proof (state)\nthis:\n  \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n   hsnd yz =\n   DOWN\n    (Fun (local.comp (eval b c) (HF'.prod h b))\n      (UP \\<langle>DOWN x, hfst yz\\<rangle>))\\<rbrace> =\n  \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n   yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n   hsnd yz =\n   DOWN\n    (Fun (local.comp (eval b c) (HF'.prod h b))\n      (UP \\<langle>DOWN x, hfst yz\\<rangle>))\\<rbrace> =\n  \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n   yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>\n\ngoal (1 subgoal):\n 1. UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n        hsnd yz =\n        DOWN\n         (Fun (local.comp (eval b c) (HF'.prod h b))\n           (UP \\<langle>DOWN x, hfst yz\\<rangle>))\\<rbrace> =\n    UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n        yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n   hsnd yz =\n   DOWN\n    (Fun (local.comp (eval b c) (HF'.prod h b))\n      (UP \\<langle>DOWN x, hfst yz\\<rangle>))\\<rbrace> =\n  \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n   yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>\n\ngoal (1 subgoal):\n 1. UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n        hsnd yz =\n        DOWN\n         (Fun (local.comp (eval b c) (HF'.prod h b))\n           (UP \\<langle>DOWN x, hfst yz\\<rangle>))\\<rbrace> =\n    UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n        yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>", "by simp"], ["proof (state)\nthis:\n  UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n      hsnd yz =\n      DOWN\n       (Fun (local.comp (eval b c) (HF'.prod h b))\n         (UP \\<langle>DOWN x, hfst yz\\<rangle>))\\<rbrace> =\n  UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n      yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n      hsnd yz =\n      DOWN\n       (Fun (local.comp (eval b c) (HF'.prod h b))\n         (UP \\<langle>DOWN x, hfst yz\\<rangle>))\\<rbrace> =\n  UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n      yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>\n\ngoal (1 subgoal):\n 1. x \\<in> local.set a \\<Longrightarrow>\n    Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x = Fun h x", "also"], ["proof (state)\nthis:\n  UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n      hsnd yz =\n      DOWN\n       (Fun (local.comp (eval b c) (HF'.prod h b))\n         (UP \\<langle>DOWN x, hfst yz\\<rangle>))\\<rbrace> =\n  UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n      yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>\n\ngoal (1 subgoal):\n 1. x \\<in> local.set a \\<Longrightarrow>\n    Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x = Fun h x", "have \"... = Fun h x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n        yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace> =\n    Fun h x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n        yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace> =\n    Fun h x", "have H: \"Fun h x = restrict (\\<lambda>x. UP (happ (arr_to_hfun h) (DOWN x))) (Dom h) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun h x =\n    (\\<lambda>x\\<^bold>\\<in>Dom h. UP (happ (arr_to_hfun h) (DOWN x))) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Fun h x =\n    (\\<lambda>x\\<^bold>\\<in>Dom h. UP (happ (arr_to_hfun h) (DOWN x))) x", "have \"arr h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr h", "using assms"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n\ngoal (1 subgoal):\n 1. arr h", "by blast"], ["proof (state)\nthis:\n  arr h\n\ngoal (1 subgoal):\n 1. Fun h x =\n    (\\<lambda>x\\<^bold>\\<in>Dom h. UP (happ (arr_to_hfun h) (DOWN x))) x", "thus ?thesis"], ["proof (prove)\nusing this:\n  arr h\n\ngoal (1 subgoal):\n 1. Fun h x =\n    (\\<lambda>x\\<^bold>\\<in>Dom h. UP (happ (arr_to_hfun h) (DOWN x))) x", "using assms x Fun_char"], ["proof (prove)\nusing this:\n  arr h\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  x \\<in> local.set a\n  arr ?f \\<Longrightarrow>\n  Fun ?f =\n  (\\<lambda>x\\<^bold>\\<in>Dom ?f. UP (happ (arr_to_hfun ?f) (DOWN x)))\n\ngoal (1 subgoal):\n 1. Fun h x =\n    (\\<lambda>x\\<^bold>\\<in>Dom h. UP (happ (arr_to_hfun h) (DOWN x))) x", "by simp"], ["proof (state)\nthis:\n  Fun h x =\n  (\\<lambda>x\\<^bold>\\<in>Dom h. UP (happ (arr_to_hfun h) (DOWN x))) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Fun h x =\n  (\\<lambda>x\\<^bold>\\<in>Dom h. UP (happ (arr_to_hfun h) (DOWN x))) x\n\ngoal (1 subgoal):\n 1. UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n        yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace> =\n    Fun h x", "also"], ["proof (state)\nthis:\n  Fun h x =\n  (\\<lambda>x\\<^bold>\\<in>Dom h. UP (happ (arr_to_hfun h) (DOWN x))) x\n\ngoal (1 subgoal):\n 1. UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n        yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace> =\n    Fun h x", "have \"... = UP (happ (arr_to_hfun h) (DOWN x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<^bold>\\<in>Dom h. UP (happ (arr_to_hfun h) (DOWN x))) x =\n    UP (happ (arr_to_hfun h) (DOWN x))", "using assms x par"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  x \\<in> local.set a\n  par (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) h\n\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<^bold>\\<in>Dom h. UP (happ (arr_to_hfun h) (DOWN x))) x =\n    UP (happ (arr_to_hfun h) (DOWN x))", "by (metis (no_types, lifting) 0 lam_simps(2) restrict_apply)"], ["proof (state)\nthis:\n  (\\<lambda>x\\<^bold>\\<in>Dom h. UP (happ (arr_to_hfun h) (DOWN x))) x =\n  UP (happ (arr_to_hfun h) (DOWN x))\n\ngoal (1 subgoal):\n 1. UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n        yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace> =\n    Fun h x", "also"], ["proof (state)\nthis:\n  (\\<lambda>x\\<^bold>\\<in>Dom h. UP (happ (arr_to_hfun h) (DOWN x))) x =\n  UP (happ (arr_to_hfun h) (DOWN x))\n\ngoal (1 subgoal):\n 1. UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n        yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace> =\n    Fun h x", "have \"... = UP (THE g. \\<langle>DOWN x, g\\<rangle> \\<^bold>\\<in> arr_to_hfun h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP (happ (arr_to_hfun h) (DOWN x)) =\n    UP (THE g. \\<langle>DOWN x, g\\<rangle> \\<^bold>\\<in> arr_to_hfun h)", "using app_def"], ["proof (prove)\nusing this:\n  happ ?f ?x = (THE y. \\<langle>?x, y\\<rangle> \\<^bold>\\<in> ?f)\n\ngoal (1 subgoal):\n 1. UP (happ (arr_to_hfun h) (DOWN x)) =\n    UP (THE g. \\<langle>DOWN x, g\\<rangle> \\<^bold>\\<in> arr_to_hfun h)", "by simp"], ["proof (state)\nthis:\n  UP (happ (arr_to_hfun h) (DOWN x)) =\n  UP (THE g. \\<langle>DOWN x, g\\<rangle> \\<^bold>\\<in> arr_to_hfun h)\n\ngoal (1 subgoal):\n 1. UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n        yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace> =\n    Fun h x", "also"], ["proof (state)\nthis:\n  UP (happ (arr_to_hfun h) (DOWN x)) =\n  UP (THE g. \\<langle>DOWN x, g\\<rangle> \\<^bold>\\<in> arr_to_hfun h)\n\ngoal (1 subgoal):\n 1. UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n        yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace> =\n    Fun h x", "have \"... = UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c. yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP (THE g. \\<langle>DOWN x, g\\<rangle> \\<^bold>\\<in> arr_to_hfun h) =\n    UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n        yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. UP (THE g. \\<langle>DOWN x, g\\<rangle> \\<^bold>\\<in> arr_to_hfun h) =\n    UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n        yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>", "have ex_un_g: \"\\<exists>!g. \\<langle>DOWN x, g\\<rangle> \\<^bold>\\<in> arr_to_hfun h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!g. \\<langle>DOWN x, g\\<rangle> \\<^bold>\\<in> arr_to_hfun h", "using assms x arr_to_hfun_def hfun_arr_to_hfun\n                        hfunE [of \"ide_to_hf a\" \"ide_to_hf (exp b c)\" \"arr_to_hfun h\"]"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  x \\<in> local.set a\n  arr_to_hfun ?f =\n  \\<lbrace>XY \\<^bold>\\<in> ide_to_hf (local.dom ?f) * ide_to_hf (cod ?f).\n   hsnd XY = DOWN (Fun ?f (UP (hfst XY)))\\<rbrace>\n  arr ?f \\<Longrightarrow>\n  hfun (ide_to_hf (local.dom ?f)) (ide_to_hf (cod ?f)) (arr_to_hfun ?f)\n  \\<lbrakk>hfun (ide_to_hf a) (ide_to_hf (exp b c)) (arr_to_hfun h);\n   (\\<And>Y.\n       Y \\<^bold>\\<in> ide_to_hf a \\<Longrightarrow>\n       (\\<exists>!Z.\n           \\<langle>Y, Z\\<rangle> \\<^bold>\\<in> arr_to_hfun h) \\<and>\n       (\\<forall>Z.\n           \\<langle>Y, Z\\<rangle> \\<^bold>\\<in>\n           arr_to_hfun h \\<longrightarrow>\n           Z \\<^bold>\\<in> ide_to_hf (exp b c))) \\<Longrightarrow>\n   ?T\\<rbrakk>\n  \\<Longrightarrow> ?T\n\ngoal (1 subgoal):\n 1. \\<exists>!g. \\<langle>DOWN x, g\\<rangle> \\<^bold>\\<in> arr_to_hfun h", "by (metis (no_types, lifting) DOWN_membI in_homE)"], ["proof (state)\nthis:\n  \\<exists>!g. \\<langle>DOWN x, g\\<rangle> \\<^bold>\\<in> arr_to_hfun h\n\ngoal (1 subgoal):\n 1. UP (THE g. \\<langle>DOWN x, g\\<rangle> \\<^bold>\\<in> arr_to_hfun h) =\n    UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n        yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>", "moreover"], ["proof (state)\nthis:\n  \\<exists>!g. \\<langle>DOWN x, g\\<rangle> \\<^bold>\\<in> arr_to_hfun h\n\ngoal (1 subgoal):\n 1. UP (THE g. \\<langle>DOWN x, g\\<rangle> \\<^bold>\\<in> arr_to_hfun h) =\n    UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n        yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>", "have\n                   \"\\<langle>DOWN x, \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c. yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>\\<rangle>\n                       \\<^bold>\\<in> arr_to_hfun h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>DOWN x,\n             \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n              yz \\<^bold>\\<in>\n              DOWN (Fun h x)\\<rbrace>\\<rangle> \\<^bold>\\<in>\n    arr_to_hfun h", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<langle>DOWN x,\n             \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n              yz \\<^bold>\\<in>\n              DOWN (Fun h x)\\<rbrace>\\<rangle> \\<^bold>\\<in>\n    arr_to_hfun h", "have \"DOWN (Fun h x) =\n                        \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c. yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DOWN (Fun h x) =\n    \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n     yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (xa \\<^bold>\\<in> DOWN (Fun h x)) =\n       (xa \\<^bold>\\<in>\n        \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n         yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>)", "fix yz"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       (xa \\<^bold>\\<in> DOWN (Fun h x)) =\n       (xa \\<^bold>\\<in>\n        \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n         yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>)", "show \"yz \\<^bold>\\<in> DOWN (Fun h x) \\<longleftrightarrow>\n                          yz \\<^bold>\\<in> \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c. yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (yz \\<^bold>\\<in> DOWN (Fun h x)) =\n    (yz \\<^bold>\\<in>\n     \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n      yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. yz \\<^bold>\\<in> DOWN (Fun h x) \\<Longrightarrow>\n    yz \\<^bold>\\<in>\n    \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n     yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>\n 2. yz \\<^bold>\\<in>\n    \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n     yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace> \\<Longrightarrow>\n    yz \\<^bold>\\<in> DOWN (Fun h x)", "show \"yz \\<^bold>\\<in> DOWN (Fun h x)\n                              \\<Longrightarrow> yz \\<^bold>\\<in> \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c. yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. yz \\<^bold>\\<in> DOWN (Fun h x) \\<Longrightarrow>\n    yz \\<^bold>\\<in>\n    \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n     yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. yz \\<^bold>\\<in> DOWN (Fun h x) \\<Longrightarrow>\n    yz \\<^bold>\\<in>\n    \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n     yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>", "assume yz: \"yz \\<^bold>\\<in> DOWN (Fun h x)\""], ["proof (state)\nthis:\n  yz \\<^bold>\\<in> DOWN (Fun h x)\n\ngoal (1 subgoal):\n 1. yz \\<^bold>\\<in> DOWN (Fun h x) \\<Longrightarrow>\n    yz \\<^bold>\\<in>\n    \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n     yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>", "have \"yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c", "have \"DOWN (Fun h x) \\<^bold>\\<in> hexp (ide_to_hf b) (ide_to_hf c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DOWN (Fun h x) \\<^bold>\\<in> hexp (ide_to_hf b) (ide_to_hf c)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. DOWN (Fun h x) \\<^bold>\\<in> hexp (ide_to_hf b) (ide_to_hf c)", "have \"ide (hf_to_ide (hexp (ide_to_hf b) (ide_to_hf c)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide (hf_to_ide (hexp (ide_to_hf b) (ide_to_hf c)))", "using assms exp_def ide_exp"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  exp ?b ?c = hf_to_ide (hexp (ide_to_hf ?b) (ide_to_hf ?c))\n  \\<lbrakk>ide ?b; ide ?c\\<rbrakk> \\<Longrightarrow> ide (exp ?b ?c)\n\ngoal (1 subgoal):\n 1. ide (hf_to_ide (hexp (ide_to_hf b) (ide_to_hf c)))", "by auto"], ["proof (state)\nthis:\n  ide (hf_to_ide (hexp (ide_to_hf b) (ide_to_hf c)))\n\ngoal (1 subgoal):\n 1. DOWN (Fun h x) \\<^bold>\\<in> hexp (ide_to_hf b) (ide_to_hf c)", "moreover"], ["proof (state)\nthis:\n  ide (hf_to_ide (hexp (ide_to_hf b) (ide_to_hf c)))\n\ngoal (1 subgoal):\n 1. DOWN (Fun h x) \\<^bold>\\<in> hexp (ide_to_hf b) (ide_to_hf c)", "have\n                              \"Fun h x \\<in> set (hf_to_ide (hexp (ide_to_hf b) (ide_to_hf c)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun h x \\<in> local.set (hf_to_ide (hexp (ide_to_hf b) (ide_to_hf c)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Fun h x \\<in> local.set (hf_to_ide (hexp (ide_to_hf b) (ide_to_hf c)))", "have \"Fun h x \\<in> Cod h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun h x \\<in> Cod h", "using assms x Fun_mapsto"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  x \\<in> local.set a\n  arr ?f \\<Longrightarrow>\n  Fun ?f \\<in> extensional (Dom ?f) \\<inter> (Dom ?f \\<rightarrow> Cod ?f)\n\ngoal (1 subgoal):\n 1. Fun h x \\<in> Cod h", "by blast"], ["proof (state)\nthis:\n  Fun h x \\<in> Cod h\n\ngoal (1 subgoal):\n 1. Fun h x \\<in> local.set (hf_to_ide (hexp (ide_to_hf b) (ide_to_hf c)))", "moreover"], ["proof (state)\nthis:\n  Fun h x \\<in> Cod h\n\ngoal (1 subgoal):\n 1. Fun h x \\<in> local.set (hf_to_ide (hexp (ide_to_hf b) (ide_to_hf c)))", "have\n                                \"Cod h = set (hf_to_ide (hexp (ide_to_hf b) (ide_to_hf c)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cod h = local.set (hf_to_ide (hexp (ide_to_hf b) (ide_to_hf c)))", "using assms 0 exp_def lam_simps(3) par"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  \\<guillemotleft>local.comp (eval b c)\n                   (HF'.prod h\n                     b) : local.prod a b \\<rightarrow> c\\<guillemotright>\n  exp ?b ?c = hf_to_ide (hexp (ide_to_hf ?b) (ide_to_hf ?c))\n  \\<lbrakk>ide ?a; ide ?b; ide ?c;\n   \\<guillemotleft>?f : local.prod ?a\n                         ?b \\<rightarrow> ?c\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> cod (\\<Lambda> ?a ?b ?c ?f) = exp ?b ?c\n  par (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) h\n\ngoal (1 subgoal):\n 1. Cod h = local.set (hf_to_ide (hexp (ide_to_hf b) (ide_to_hf c)))", "by auto"], ["proof (state)\nthis:\n  Cod h = local.set (hf_to_ide (hexp (ide_to_hf b) (ide_to_hf c)))\n\ngoal (1 subgoal):\n 1. Fun h x \\<in> local.set (hf_to_ide (hexp (ide_to_hf b) (ide_to_hf c)))", "ultimately"], ["proof (chain)\npicking this:\n  Fun h x \\<in> Cod h\n  Cod h = local.set (hf_to_ide (hexp (ide_to_hf b) (ide_to_hf c)))", "show ?thesis"], ["proof (prove)\nusing this:\n  Fun h x \\<in> Cod h\n  Cod h = local.set (hf_to_ide (hexp (ide_to_hf b) (ide_to_hf c)))\n\ngoal (1 subgoal):\n 1. Fun h x \\<in> local.set (hf_to_ide (hexp (ide_to_hf b) (ide_to_hf c)))", "by blast"], ["proof (state)\nthis:\n  Fun h x \\<in> local.set (hf_to_ide (hexp (ide_to_hf b) (ide_to_hf c)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Fun h x \\<in> local.set (hf_to_ide (hexp (ide_to_hf b) (ide_to_hf c)))\n\ngoal (1 subgoal):\n 1. DOWN (Fun h x) \\<^bold>\\<in> hexp (ide_to_hf b) (ide_to_hf c)", "ultimately"], ["proof (chain)\npicking this:\n  ide (hf_to_ide (hexp (ide_to_hf b) (ide_to_hf c)))\n  Fun h x \\<in> local.set (hf_to_ide (hexp (ide_to_hf b) (ide_to_hf c)))", "show ?thesis"], ["proof (prove)\nusing this:\n  ide (hf_to_ide (hexp (ide_to_hf b) (ide_to_hf c)))\n  Fun h x \\<in> local.set (hf_to_ide (hexp (ide_to_hf b) (ide_to_hf c)))\n\ngoal (1 subgoal):\n 1. DOWN (Fun h x) \\<^bold>\\<in> hexp (ide_to_hf b) (ide_to_hf c)", "using DOWN_membI [of \"hf_to_ide (hexp (ide_to_hf b) (ide_to_hf c))\"\n                                                   \"Fun h x\"]"], ["proof (prove)\nusing this:\n  ide (hf_to_ide (hexp (ide_to_hf b) (ide_to_hf c)))\n  Fun h x \\<in> local.set (hf_to_ide (hexp (ide_to_hf b) (ide_to_hf c)))\n  \\<lbrakk>ide (hf_to_ide (hexp (ide_to_hf b) (ide_to_hf c)));\n   Fun h x\n   \\<in> local.set (hf_to_ide (hexp (ide_to_hf b) (ide_to_hf c)))\\<rbrakk>\n  \\<Longrightarrow> DOWN (Fun h x) \\<^bold>\\<in>\n                    ide_to_hf (hf_to_ide (hexp (ide_to_hf b) (ide_to_hf c)))\n\ngoal (1 subgoal):\n 1. DOWN (Fun h x) \\<^bold>\\<in> hexp (ide_to_hf b) (ide_to_hf c)", "by (simp add: ide_to_hf_hf_to_ide)"], ["proof (state)\nthis:\n  DOWN (Fun h x) \\<^bold>\\<in> hexp (ide_to_hf b) (ide_to_hf c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  DOWN (Fun h x) \\<^bold>\\<in> hexp (ide_to_hf b) (ide_to_hf c)\n\ngoal (1 subgoal):\n 1. yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c", "thus ?thesis"], ["proof (prove)\nusing this:\n  DOWN (Fun h x) \\<^bold>\\<in> hexp (ide_to_hf b) (ide_to_hf c)\n\ngoal (1 subgoal):\n 1. yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c", "using assms yz hexp_def"], ["proof (prove)\nusing this:\n  DOWN (Fun h x) \\<^bold>\\<in> hexp (ide_to_hf b) (ide_to_hf c)\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  yz \\<^bold>\\<in> DOWN (Fun h x)\n  hexp ?B ?C = HCollect (hfun ?B ?C) (HPow (?B * ?C))\n\ngoal (1 subgoal):\n 1. yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c", "by auto"], ["proof (state)\nthis:\n  yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c\n\ngoal (1 subgoal):\n 1. yz \\<^bold>\\<in> DOWN (Fun h x) \\<Longrightarrow>\n    yz \\<^bold>\\<in>\n    \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n     yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>", "thus ?thesis"], ["proof (prove)\nusing this:\n  yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c\n\ngoal (1 subgoal):\n 1. yz \\<^bold>\\<in>\n    \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n     yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>", "using assms x yz"], ["proof (prove)\nusing this:\n  yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  x \\<in> local.set a\n  yz \\<^bold>\\<in> DOWN (Fun h x)\n\ngoal (1 subgoal):\n 1. yz \\<^bold>\\<in>\n    \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n     yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>", "by blast"], ["proof (state)\nthis:\n  yz \\<^bold>\\<in>\n  \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n   yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  yz \\<^bold>\\<in> DOWN (Fun h x) \\<Longrightarrow>\n  yz \\<^bold>\\<in>\n  \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n   yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>\n\ngoal (1 subgoal):\n 1. yz \\<^bold>\\<in>\n    \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n     yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace> \\<Longrightarrow>\n    yz \\<^bold>\\<in> DOWN (Fun h x)", "show \"yz \\<^bold>\\<in> \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c. yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>\n                              \\<Longrightarrow> yz \\<^bold>\\<in> DOWN (Fun h x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. yz \\<^bold>\\<in>\n    \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n     yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace> \\<Longrightarrow>\n    yz \\<^bold>\\<in> DOWN (Fun h x)", "using assms"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n\ngoal (1 subgoal):\n 1. yz \\<^bold>\\<in>\n    \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n     yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace> \\<Longrightarrow>\n    yz \\<^bold>\\<in> DOWN (Fun h x)", "by simp"], ["proof (state)\nthis:\n  yz \\<^bold>\\<in>\n  \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n   yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace> \\<Longrightarrow>\n  yz \\<^bold>\\<in> DOWN (Fun h x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (yz \\<^bold>\\<in> DOWN (Fun h x)) =\n  (yz \\<^bold>\\<in>\n   \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n    yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  DOWN (Fun h x) =\n  \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n   yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<langle>DOWN x,\n             \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n              yz \\<^bold>\\<in>\n              DOWN (Fun h x)\\<rbrace>\\<rangle> \\<^bold>\\<in>\n    arr_to_hfun h", "moreover"], ["proof (state)\nthis:\n  DOWN (Fun h x) =\n  \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n   yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<langle>DOWN x,\n             \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n              yz \\<^bold>\\<in>\n              DOWN (Fun h x)\\<rbrace>\\<rangle> \\<^bold>\\<in>\n    arr_to_hfun h", "have \"UP (DOWN x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP (DOWN x) = x", "using assms x ide_char set_subset_Univ UP_DOWN"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  x \\<in> local.set a\n  arr ?f \\<Longrightarrow>\n  ide ?f =\n  (Dom ?f = Cod ?f \\<and> Fun ?f = (\\<lambda>x\\<^bold>\\<in>Dom ?f. x))\n  ide ?a \\<Longrightarrow> local.set ?a \\<subseteq> Univ\n  ?t \\<in> Univ \\<Longrightarrow> UP (DOWN ?t) = ?t\n\ngoal (1 subgoal):\n 1. UP (DOWN x) = x", "by (meson subsetD)"], ["proof (state)\nthis:\n  UP (DOWN x) = x\n\ngoal (1 subgoal):\n 1. \\<langle>DOWN x,\n             \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n              yz \\<^bold>\\<in>\n              DOWN (Fun h x)\\<rbrace>\\<rangle> \\<^bold>\\<in>\n    arr_to_hfun h", "ultimately"], ["proof (chain)\npicking this:\n  DOWN (Fun h x) =\n  \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n   yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>\n  UP (DOWN x) = x", "show ?thesis"], ["proof (prove)\nusing this:\n  DOWN (Fun h x) =\n  \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n   yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>\n  UP (DOWN x) = x\n\ngoal (1 subgoal):\n 1. \\<langle>DOWN x,\n             \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n              yz \\<^bold>\\<in>\n              DOWN (Fun h x)\\<rbrace>\\<rangle> \\<^bold>\\<in>\n    arr_to_hfun h", "using assms x arr_to_hfun_def ex_un_g"], ["proof (prove)\nusing this:\n  DOWN (Fun h x) =\n  \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n   yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>\n  UP (DOWN x) = x\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  x \\<in> local.set a\n  arr_to_hfun ?f =\n  \\<lbrace>XY \\<^bold>\\<in> ide_to_hf (local.dom ?f) * ide_to_hf (cod ?f).\n   hsnd XY = DOWN (Fun ?f (UP (hfst XY)))\\<rbrace>\n  \\<exists>!g. \\<langle>DOWN x, g\\<rangle> \\<^bold>\\<in> arr_to_hfun h\n\ngoal (1 subgoal):\n 1. \\<langle>DOWN x,\n             \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n              yz \\<^bold>\\<in>\n              DOWN (Fun h x)\\<rbrace>\\<rangle> \\<^bold>\\<in>\n    arr_to_hfun h", "by auto"], ["proof (state)\nthis:\n  \\<langle>DOWN x,\n           \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n            yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>\\<rangle> \\<^bold>\\<in>\n  arr_to_hfun h\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<langle>DOWN x,\n           \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n            yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>\\<rangle> \\<^bold>\\<in>\n  arr_to_hfun h\n\ngoal (1 subgoal):\n 1. UP (THE g. \\<langle>DOWN x, g\\<rangle> \\<^bold>\\<in> arr_to_hfun h) =\n    UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n        yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>!g. \\<langle>DOWN x, g\\<rangle> \\<^bold>\\<in> arr_to_hfun h\n  \\<langle>DOWN x,\n           \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n            yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>\\<rangle> \\<^bold>\\<in>\n  arr_to_hfun h", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>!g. \\<langle>DOWN x, g\\<rangle> \\<^bold>\\<in> arr_to_hfun h\n  \\<langle>DOWN x,\n           \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n            yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>\\<rangle> \\<^bold>\\<in>\n  arr_to_hfun h\n\ngoal (1 subgoal):\n 1. UP (THE g. \\<langle>DOWN x, g\\<rangle> \\<^bold>\\<in> arr_to_hfun h) =\n    UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n        yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>", "using assms x theI' [of \"\\<lambda>g. \\<langle>DOWN x, g\\<rangle> \\<^bold>\\<in> arr_to_hfun h\"]"], ["proof (prove)\nusing this:\n  \\<exists>!g. \\<langle>DOWN x, g\\<rangle> \\<^bold>\\<in> arr_to_hfun h\n  \\<langle>DOWN x,\n           \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n            yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>\\<rangle> \\<^bold>\\<in>\n  arr_to_hfun h\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  x \\<in> local.set a\n  \\<exists>!xa.\n     \\<langle>DOWN x, xa\\<rangle> \\<^bold>\\<in>\n     arr_to_hfun h \\<Longrightarrow>\n  \\<langle>DOWN x,\n           THE xa.\n              \\<langle>DOWN x, xa\\<rangle> \\<^bold>\\<in>\n              arr_to_hfun h\\<rangle> \\<^bold>\\<in>\n  arr_to_hfun h\n\ngoal (1 subgoal):\n 1. UP (THE g. \\<langle>DOWN x, g\\<rangle> \\<^bold>\\<in> arr_to_hfun h) =\n    UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n        yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>", "by fastforce"], ["proof (state)\nthis:\n  UP (THE g. \\<langle>DOWN x, g\\<rangle> \\<^bold>\\<in> arr_to_hfun h) =\n  UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n      yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  UP (THE g. \\<langle>DOWN x, g\\<rangle> \\<^bold>\\<in> arr_to_hfun h) =\n  UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n      yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>\n\ngoal (1 subgoal):\n 1. UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n        yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace> =\n    Fun h x", "finally"], ["proof (chain)\npicking this:\n  Fun h x =\n  UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n      yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>", "show ?thesis"], ["proof (prove)\nusing this:\n  Fun h x =\n  UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n      yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>\n\ngoal (1 subgoal):\n 1. UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n        yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace> =\n    Fun h x", "using assms x"], ["proof (prove)\nusing this:\n  Fun h x =\n  UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n      yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace>\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  x \\<in> local.set a\n\ngoal (1 subgoal):\n 1. UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n        yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace> =\n    Fun h x", "by simp"], ["proof (state)\nthis:\n  UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n      yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace> =\n  Fun h x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  UP \\<lbrace>yz \\<^bold>\\<in> ide_to_hf b * ide_to_hf c.\n      yz \\<^bold>\\<in> DOWN (Fun h x)\\<rbrace> =\n  Fun h x\n\ngoal (1 subgoal):\n 1. x \\<in> local.set a \\<Longrightarrow>\n    Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x = Fun h x", "finally"], ["proof (chain)\npicking this:\n  Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x = Fun h x", "show ?thesis"], ["proof (prove)\nusing this:\n  Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x = Fun h x\n\ngoal (1 subgoal):\n 1. Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x = Fun h x", "by simp"], ["proof (state)\nthis:\n  Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x = Fun h x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> local.set a \\<Longrightarrow>\n  Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x = Fun h x\n\ngoal (1 subgoal):\n 1. Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x = Fun h x", "ultimately"], ["proof (chain)\npicking this:\n  x \\<notin> local.set a \\<Longrightarrow>\n  Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x = Fun h x\n  x \\<in> local.set a \\<Longrightarrow>\n  Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x = Fun h x", "show \"Fun (\\<Lambda> a b c (comp (eval b c) (HF'.prod h b))) x = Fun h x\""], ["proof (prove)\nusing this:\n  x \\<notin> local.set a \\<Longrightarrow>\n  Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x = Fun h x\n  x \\<in> local.set a \\<Longrightarrow>\n  Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x = Fun h x\n\ngoal (1 subgoal):\n 1. Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x = Fun h x", "by blast"], ["proof (state)\nthis:\n  Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x = Fun h x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) x = Fun h x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Fun (\\<Lambda> a b c (local.comp (eval b c) (HF'.prod h b))) = Fun h\n\ngoal:\nNo subgoals!", "qed"], ["", "section \"The Main Results\""], ["", "interpretation cartesian_closed_category comp"], ["proof (prove)\ngoal (1 subgoal):\n 1. cartesian_closed_category local.comp", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cartesian_closed_category local.comp", "interpret elementary_cartesian_closed_category comp pr0 pr1\n                       some_terminal trm exp eval \\<Lambda>"], ["proof (prove)\ngoal (1 subgoal):\n 1. elementary_cartesian_closed_category local.comp pr0 pr1 some_terminal\n     trm exp eval \\<Lambda>", "using ide_exp eval_in_hom lam_in_hom prod_ide_eq eval_prod_lam lam_eval_prod"], ["proof (prove)\nusing this:\n  \\<lbrakk>ide ?b; ide ?c\\<rbrakk> \\<Longrightarrow> ide (exp ?b ?c)\n  \\<lbrakk>ide ?b; ide ?c\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>eval ?b\n                                     ?c : HF'.prod (exp ?b ?c)\n     ?b \\<rightarrow> ?c\\<guillemotright>\n  \\<lbrakk>ide ?a; ide ?b; ide ?c;\n   \\<guillemotleft>?f : local.prod ?a\n                         ?b \\<rightarrow> ?c\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>\\<Lambda> ?a ?b ?c\n                                     ?f : ?a \\<rightarrow> exp ?b\n                      ?c\\<guillemotright>\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> local.prod ?a ?b = HF'.prod ?a ?b\n  \\<lbrakk>ide ?a; ide ?b; ide ?c;\n   \\<guillemotleft>?g : local.prod ?a\n                         ?b \\<rightarrow> ?c\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> local.comp (eval ?b ?c)\n                     (HF'.prod (\\<Lambda> ?a ?b ?c ?g) ?b) =\n                    ?g\n  \\<lbrakk>ide ?a; ide ?b; ide ?c;\n   \\<guillemotleft>?h : ?a \\<rightarrow> exp ?b ?c\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> \\<Lambda> ?a ?b ?c\n                     (local.comp (eval ?b ?c) (HF'.prod ?h ?b)) =\n                    ?h\n\ngoal (1 subgoal):\n 1. elementary_cartesian_closed_category local.comp pr0 pr1 some_terminal\n     trm exp eval \\<Lambda>", "by unfold_locales auto"], ["proof (state)\ngoal (1 subgoal):\n 1. cartesian_closed_category local.comp", "show \"cartesian_closed_category comp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cartesian_closed_category local.comp", "using is_cartesian_closed_category"], ["proof (prove)\nusing this:\n  cartesian_closed_category local.comp\n\ngoal (1 subgoal):\n 1. cartesian_closed_category local.comp", "by simp"], ["proof (state)\nthis:\n  cartesian_closed_category local.comp\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem is_cartesian_closed_category:\n    shows \"cartesian_closed_category comp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cartesian_closed_category local.comp", ".."], ["", "theorem is_category_with_finite_limits:\n    shows \"category_with_finite_limits comp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. category_with_finite_limits local.comp", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>J.\n       \\<lbrakk>category J; finite (Collect (partial_magma.arr J))\\<rbrakk>\n       \\<Longrightarrow> has_limits_of_shape J", "fix J :: \"'j comp\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>J.\n       \\<lbrakk>category J; finite (Collect (partial_magma.arr J))\\<rbrakk>\n       \\<Longrightarrow> has_limits_of_shape J", "assume J: \"category J\""], ["proof (state)\nthis:\n  category J\n\ngoal (1 subgoal):\n 1. \\<And>J.\n       \\<lbrakk>category J; finite (Collect (partial_magma.arr J))\\<rbrakk>\n       \\<Longrightarrow> has_limits_of_shape J", "interpret J: category J"], ["proof (prove)\ngoal (1 subgoal):\n 1. category J", "using J"], ["proof (prove)\nusing this:\n  category J\n\ngoal (1 subgoal):\n 1. category J", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>J.\n       \\<lbrakk>category J; finite (Collect (partial_magma.arr J))\\<rbrakk>\n       \\<Longrightarrow> has_limits_of_shape J", "assume finite: \"finite (Collect J.arr)\""], ["proof (state)\nthis:\n  finite (Collect J.arr)\n\ngoal (1 subgoal):\n 1. \\<And>J.\n       \\<lbrakk>category J; finite (Collect (partial_magma.arr J))\\<rbrakk>\n       \\<Longrightarrow> has_limits_of_shape J", "have \"has_products (Collect J.ide)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_products (Collect J.ide)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. has_products (Collect J.ide)", "have \"Collect J.ide \\<noteq> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Collect J.ide \\<noteq> UNIV", "using J.not_arr_null"], ["proof (prove)\nusing this:\n  \\<not> J.arr J.null\n\ngoal (1 subgoal):\n 1. Collect J.ide \\<noteq> UNIV", "by blast"], ["proof (state)\nthis:\n  Collect J.ide \\<noteq> UNIV\n\ngoal (1 subgoal):\n 1. has_products (Collect J.ide)", "moreover"], ["proof (state)\nthis:\n  Collect J.ide \\<noteq> UNIV\n\ngoal (1 subgoal):\n 1. has_products (Collect J.ide)", "have \"finite (Collect J.ide)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Collect J.ide)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite (Collect J.ide)", "have \"Collect J.ide \\<subseteq> Collect J.arr\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Collect J.ide \\<subseteq> Collect J.arr", "by auto"], ["proof (state)\nthis:\n  Collect J.ide \\<subseteq> Collect J.arr\n\ngoal (1 subgoal):\n 1. finite (Collect J.ide)", "thus ?thesis"], ["proof (prove)\nusing this:\n  Collect J.ide \\<subseteq> Collect J.arr\n\ngoal (1 subgoal):\n 1. finite (Collect J.ide)", "using finite J.ideD(1) finite_subset"], ["proof (prove)\nusing this:\n  Collect J.ide \\<subseteq> Collect J.arr\n  finite (Collect J.arr)\n  J.ide ?a \\<Longrightarrow> J.arr ?a\n  \\<lbrakk>?A \\<subseteq> ?B; finite ?B\\<rbrakk> \\<Longrightarrow> finite ?A\n\ngoal (1 subgoal):\n 1. finite (Collect J.ide)", "by blast"], ["proof (state)\nthis:\n  finite (Collect J.ide)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite (Collect J.ide)\n\ngoal (1 subgoal):\n 1. has_products (Collect J.ide)", "ultimately"], ["proof (chain)\npicking this:\n  Collect J.ide \\<noteq> UNIV\n  finite (Collect J.ide)", "show ?thesis"], ["proof (prove)\nusing this:\n  Collect J.ide \\<noteq> UNIV\n  finite (Collect J.ide)\n\ngoal (1 subgoal):\n 1. has_products (Collect J.ide)", "using finite has_finite_products'"], ["proof (prove)\nusing this:\n  Collect J.ide \\<noteq> UNIV\n  finite (Collect J.ide)\n  finite (Collect J.arr)\n  \\<lbrakk>?I \\<noteq> UNIV; finite ?I\\<rbrakk>\n  \\<Longrightarrow> has_products ?I\n\ngoal (1 subgoal):\n 1. has_products (Collect J.ide)", "by simp"], ["proof (state)\nthis:\n  has_products (Collect J.ide)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  has_products (Collect J.ide)\n\ngoal (1 subgoal):\n 1. \\<And>J.\n       \\<lbrakk>category J; finite (Collect (partial_magma.arr J))\\<rbrakk>\n       \\<Longrightarrow> has_limits_of_shape J", "moreover"], ["proof (state)\nthis:\n  has_products (Collect J.ide)\n\ngoal (1 subgoal):\n 1. \\<And>J.\n       \\<lbrakk>category J; finite (Collect (partial_magma.arr J))\\<rbrakk>\n       \\<Longrightarrow> has_limits_of_shape J", "have \"has_products (Collect J.arr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_products (Collect J.arr)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. has_products (Collect J.arr)", "have \"Collect J.arr \\<noteq> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Collect J.arr \\<noteq> UNIV", "using J.not_arr_null"], ["proof (prove)\nusing this:\n  \\<not> J.arr J.null\n\ngoal (1 subgoal):\n 1. Collect J.arr \\<noteq> UNIV", "by blast"], ["proof (state)\nthis:\n  Collect J.arr \\<noteq> UNIV\n\ngoal (1 subgoal):\n 1. has_products (Collect J.arr)", "thus ?thesis"], ["proof (prove)\nusing this:\n  Collect J.arr \\<noteq> UNIV\n\ngoal (1 subgoal):\n 1. has_products (Collect J.arr)", "using finite has_finite_products'"], ["proof (prove)\nusing this:\n  Collect J.arr \\<noteq> UNIV\n  finite (Collect J.arr)\n  \\<lbrakk>?I \\<noteq> UNIV; finite ?I\\<rbrakk>\n  \\<Longrightarrow> has_products ?I\n\ngoal (1 subgoal):\n 1. has_products (Collect J.arr)", "by simp"], ["proof (state)\nthis:\n  has_products (Collect J.arr)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  has_products (Collect J.arr)\n\ngoal (1 subgoal):\n 1. \\<And>J.\n       \\<lbrakk>category J; finite (Collect (partial_magma.arr J))\\<rbrakk>\n       \\<Longrightarrow> has_limits_of_shape J", "ultimately"], ["proof (chain)\npicking this:\n  has_products (Collect J.ide)\n  has_products (Collect J.arr)", "show \"has_limits_of_shape J\""], ["proof (prove)\nusing this:\n  has_products (Collect J.ide)\n  has_products (Collect J.arr)\n\ngoal (1 subgoal):\n 1. has_limits_of_shape J", "using J.category_axioms has_limits_if_has_products [of J]"], ["proof (prove)\nusing this:\n  has_products (Collect J.ide)\n  has_products (Collect J.arr)\n  category J\n  \\<lbrakk>category J; has_products (Collect J.ide);\n   has_products (Collect J.arr)\\<rbrakk>\n  \\<Longrightarrow> has_limits_of_shape J\n\ngoal (1 subgoal):\n 1. has_limits_of_shape J", "by simp"], ["proof (state)\nthis:\n  has_limits_of_shape J\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "end"]]}