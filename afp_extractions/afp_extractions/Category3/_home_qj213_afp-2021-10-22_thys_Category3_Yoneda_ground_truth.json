{"file_name": "/home/qj213/afp-2021-10-22/thys/Category3/Yoneda.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Category3", "problem_names": ["lemma set_subset_Univ:\n    assumes \"C.ide b\" and \"C.ide a\"\n    shows \"set (b, a) \\<subseteq> S.Univ\"", "lemma \\<phi>_mapsto:\n    assumes \"C.ide b\" and \"C.ide a\"\n    shows \"\\<phi> (b, a) \\<in> C.hom b a \\<rightarrow> set (b, a)\"", "lemma \\<psi>_mapsto:\n    assumes \"C.ide b\" and \"C.ide a\"\n    shows \"\\<psi> (b, a) \\<in> set (b, a) \\<rightarrow> C.hom b a\"", "lemma \\<psi>_\\<phi> [simp]:\n    assumes \"\\<guillemotleft>f : b \\<rightarrow> a\\<guillemotright>\"\n    shows \"\\<psi> (b, a) (\\<phi> (b, a) f) = f\"", "lemma \\<phi>_\\<psi> [simp]:\n    assumes \"C.ide b\" and \"C.ide a\"\n    and \"x \\<in> set (b, a)\"\n    shows \"\\<phi> (b, a) (\\<psi> (b, a) x) = x\"", "lemma \\<psi>_img_set:\n    assumes \"C.ide b\" and \"C.ide a\"\n    shows \"\\<psi> (b, a) ` set (b, a) = C.hom b a\"", "lemma arr_map:\n    assumes \"CopxC.arr gf\"\n    shows \"S.arr (map gf)\"", "lemma map_ide [simp]:\n    assumes \"C.ide b\" and \"C.ide a\"\n    shows \"map (b, a) = S.mkIde (set (b, a))\"", "lemma set_map:\n    assumes \"C.ide a\" and \"C.ide b\"\n    shows \"S.set (map (b, a)) = set (b, a)\"", "lemma is_binary_functor:\n    shows \"binary_functor Cop.comp C S map\"", "lemma \\<phi>_local_bij:\n    assumes \"C.ide b\" and \"C.ide a\"\n    shows \"bij_betw (\\<phi> (b, a)) (C.hom b a) (set (b, a))\"", "lemma \\<phi>_natural:\n    assumes \"C.arr g\" and \"C.arr f\" and \"h \\<in> C.hom (C.cod g) (C.dom f)\"\n    shows \"\\<phi> (C.dom g, C.cod f) (f \\<cdot> h \\<cdot> g) = S.Fun (map (g, f)) (\\<phi> (C.cod g, C.dom f) h)\"", "lemma Dom_map:\n    assumes \"C.arr g\" and \"C.arr f\"\n    shows \"S.Dom (map (g, f)) = set (C.cod g, C.dom f)\"", "lemma Cod_map:\n    assumes \"C.arr g\" and \"C.arr f\"\n    shows \"S.Cod (map (g, f)) = set (C.dom g, C.cod f)\"", "lemma Fun_map:\n    assumes \"C.arr g\" and \"C.arr f\"\n    shows \"S.Fun (map (g, f)) =\n             restrict (\\<phi> (C.dom g, C.cod f) o (\\<lambda>h. f \\<cdot> h \\<cdot> g) o \\<psi> (C.cod g, C.dom f))\n                      (set (C.cod g, C.dom f))\"", "lemma map_simp_1:\n    assumes \"C.arr g\" and \"C.ide a\"\n    shows \"map (g, a) = S.mkArr (set (C.cod g, a)) (set (C.dom g, a))\n                                (\\<phi> (C.dom g, a) o Cop.comp g o \\<psi> (C.cod g, a))\"", "lemma map_simp_2:\n    assumes \"C.ide b\" and \"C.arr f\"\n    shows \"map (b, f) = S.mkArr (set (b, C.dom f)) (set (b, C.cod f))\n                                (\\<phi> (b, C.cod f) o C f o \\<psi> (b, C.dom f))\"", "lemma has_hom_functor:\n    shows \"hom_functor C (S.comp :: 'a setcat.arr comp) (\\<lambda>_. S.UP)\"", "lemma Y_simp [simp]:\n    assumes \"C.arr f\"\n    shows \"Y f = (\\<lambda>g. Hom.map (g, f))\"", "lemma Y_ide_is_functor:\n    assumes \"C.ide a\"\n    shows \"functor Cop.comp S (Y a)\"", "lemma Y_arr_is_transformation:\n    assumes \"C.arr f\"\n    shows \"natural_transformation Cop.comp S (Y (C.dom f)) (Y (C.cod f)) (Y f)\"", "lemma Y_ide_arr [simp]:\n    assumes a: \"C.ide a\" and \"\\<guillemotleft>g : b' \\<rightarrow> b\\<guillemotright>\"\n    shows \"\\<guillemotleft>Y a g : Hom.map (b, a) \\<rightarrow>\\<^sub>S Hom.map (b', a)\\<guillemotright>\"\n    and \"Y a g =\n         S.mkArr (Hom.set (b, a)) (Hom.set (b', a)) (\\<phi> (b', a) o Cop.comp g o \\<psi> (b, a))\"", "lemma Y_arr_ide [simp]:\n    assumes \"C.ide b\" and \"\\<guillemotleft>f : a \\<rightarrow> a'\\<guillemotright>\"\n    shows \"\\<guillemotleft>Y f b : Hom.map (b, a) \\<rightarrow>\\<^sub>S Hom.map (b, a')\\<guillemotright>\"\n    and \"Y f b = S.mkArr (Hom.set (b, a)) (Hom.set (b, a')) (\\<phi> (b, a') o C f o \\<psi> (b, a))\"", "lemma \\<T>o_e_ide:\n    assumes e: \"e \\<in> S.set (F a)\" and b: \"C.ide b\"\n    shows \"\\<guillemotleft>\\<T>o e b : Y a b \\<rightarrow>\\<^sub>S F b\\<guillemotright>\"\n    and \"\\<T>o e b = S.mkArr (Hom.set (b, a)) (F.SET b) (\\<lambda>x. F.FUN (\\<psi> (b, a) x) e)\"", "lemma \\<T>o_e_induces_transformation:\n    assumes e: \"e \\<in> S.set (F a)\"\n    shows \"transformation_by_components Cop.comp S (Y a) F (\\<T>o e)\"", "lemma natural_transformation_\\<T>e:\n    shows \"natural_transformation Cop.comp S (Y a) F (\\<T> e)\"", "lemma \\<T>e_ide:\n    assumes \"Cop.ide b\"\n    shows \"S.arr (\\<T> e b)\"\n    and \"\\<T> e b = S.mkArr (Hom.set (b, a)) (F.SET b) (\\<lambda>x. F.FUN (\\<psi> (b, a) x) e)\"", "lemma \\<tau>_ide:\n    assumes b: \"Cop.ide b\"\n    shows \"\\<tau> b = S.mkArr (Hom.set (b, a)) (F.SET b)\n                         (\\<lambda>x. (F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a))))\"", "lemma eqI:\n    assumes \"natural_transformation Cop.comp S (Y a) F \\<tau>'\" and \"\\<tau>' a = \\<tau> a\"\n    shows \"\\<tau>' = \\<tau>\"", "lemma \\<T>_is_injection:\n    assumes \"e \\<in> F.SET a\"\n    shows \"natural_transformation Cop.comp S (Y a) F (\\<T> e)\" and \"\\<E> (\\<T> e) = e\"", "lemma \\<E>\\<tau>_in_Fa:\n    assumes \"natural_transformation Cop.comp S (Y a) F \\<tau>\"\n    shows \"\\<E> \\<tau> \\<in> F.SET a\"", "lemma \\<T>_is_surjection:\n    assumes \"natural_transformation Cop.comp S (Y a) F \\<tau>\"\n    shows \"\\<E> \\<tau> \\<in> F.SET a\" and \"\\<T> (\\<E> \\<tau>) = \\<tau>\"", "theorem yoneda_lemma:\n    shows \"bij_betw \\<T> (F.SET a) {\\<tau>. natural_transformation Cop.comp S (Y a) F \\<tau>}\"", "lemma \\<T>_equals_Yo\\<psi>:\n    assumes e: \"e \\<in> Hom.set (a, a')\"\n    shows \"\\<T> e = Y (\\<psi> (a, a') e)\"", "lemma Y_injective_on_homs:\n    assumes \"\\<guillemotleft>f : a \\<rightarrow> a'\\<guillemotright>\" and \"\\<guillemotleft>f' : a \\<rightarrow> a'\\<guillemotright>\" and \"map f = map f'\"\n    shows \"f = f'\"", "lemma Y_surjective_on_homs:\n    assumes \\<tau>: \"natural_transformation Cop.comp S (Y a) (Y a') \\<tau>\"\n    shows \"Y (\\<psi> (a, a') (\\<E> \\<tau>)) = \\<tau>\"", "lemma is_faithful_functor:\n    shows \"faithful_functor C Cop_S.comp map\"", "lemma is_full_functor:\n    shows \"full_functor C Cop_S.comp map\""], "translations": [["", "lemma set_subset_Univ:\n    assumes \"C.ide b\" and \"C.ide a\"\n    shows \"set (b, a) \\<subseteq> S.Univ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.set (b, a) \\<subseteq> S.Univ", "using assms set_def maps_arr_to_Univ CopxC.ide_char"], ["proof (prove)\nusing this:\n  C.ide b\n  C.ide a\n  local.set ?ba \\<equiv>\n  \\<phi> (fst ?ba, snd ?ba) ` C.hom (fst ?ba) (snd ?ba)\n  C.arr ?f \\<Longrightarrow> \\<phi> (C.dom ?f, C.cod ?f) ?f \\<in> S.Univ\n  CopxC.ide ?f = (Cop.ide (fst ?f) \\<and> C.ide (snd ?f))\n\ngoal (1 subgoal):\n 1. local.set (b, a) \\<subseteq> S.Univ", "by auto"], ["", "definition \\<psi> :: \"'c * 'c \\<Rightarrow> 's \\<Rightarrow> 'c\"\n    where \"\\<psi> ba = inv_into (C.hom (fst ba) (snd ba)) (\\<phi> ba)\""], ["", "lemma \\<phi>_mapsto:\n    assumes \"C.ide b\" and \"C.ide a\"\n    shows \"\\<phi> (b, a) \\<in> C.hom b a \\<rightarrow> set (b, a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> (b, a) \\<in> C.hom b a \\<rightarrow> local.set (b, a)", "using assms set_def maps_arr_to_Univ"], ["proof (prove)\nusing this:\n  C.ide b\n  C.ide a\n  local.set ?ba \\<equiv>\n  \\<phi> (fst ?ba, snd ?ba) ` C.hom (fst ?ba) (snd ?ba)\n  C.arr ?f \\<Longrightarrow> \\<phi> (C.dom ?f, C.cod ?f) ?f \\<in> S.Univ\n\ngoal (1 subgoal):\n 1. \\<phi> (b, a) \\<in> C.hom b a \\<rightarrow> local.set (b, a)", "by auto"], ["", "lemma \\<psi>_mapsto:\n    assumes \"C.ide b\" and \"C.ide a\"\n    shows \"\\<psi> (b, a) \\<in> set (b, a) \\<rightarrow> C.hom b a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> (b, a) \\<in> local.set (b, a) \\<rightarrow> C.hom b a", "using assms set_def \\<psi>_def local_inj"], ["proof (prove)\nusing this:\n  C.ide b\n  C.ide a\n  local.set ?ba \\<equiv>\n  \\<phi> (fst ?ba, snd ?ba) ` C.hom (fst ?ba) (snd ?ba)\n  \\<psi> ?ba = inv_into (C.hom (fst ?ba) (snd ?ba)) (\\<phi> ?ba)\n  \\<lbrakk>C.ide ?b; C.ide ?a\\<rbrakk>\n  \\<Longrightarrow> inj_on (\\<phi> (?b, ?a)) (C.hom ?b ?a)\n\ngoal (1 subgoal):\n 1. \\<psi> (b, a) \\<in> local.set (b, a) \\<rightarrow> C.hom b a", "by auto"], ["", "lemma \\<psi>_\\<phi> [simp]:\n    assumes \"\\<guillemotleft>f : b \\<rightarrow> a\\<guillemotright>\"\n    shows \"\\<psi> (b, a) (\\<phi> (b, a) f) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> (b, a) (\\<phi> (b, a) f) = f", "using assms local_inj [of b a] \\<psi>_def"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f : b \\<rightarrow> a\\<guillemotright>\n  \\<lbrakk>C.ide b; C.ide a\\<rbrakk>\n  \\<Longrightarrow> inj_on (\\<phi> (b, a)) (C.hom b a)\n  \\<psi> ?ba = inv_into (C.hom (fst ?ba) (snd ?ba)) (\\<phi> ?ba)\n\ngoal (1 subgoal):\n 1. \\<psi> (b, a) (\\<phi> (b, a) f) = f", "by fastforce"], ["", "lemma \\<phi>_\\<psi> [simp]:\n    assumes \"C.ide b\" and \"C.ide a\"\n    and \"x \\<in> set (b, a)\"\n    shows \"\\<phi> (b, a) (\\<psi> (b, a) x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> (b, a) (\\<psi> (b, a) x) = x", "using assms set_def local_inj \\<psi>_def"], ["proof (prove)\nusing this:\n  C.ide b\n  C.ide a\n  x \\<in> local.set (b, a)\n  local.set ?ba \\<equiv>\n  \\<phi> (fst ?ba, snd ?ba) ` C.hom (fst ?ba) (snd ?ba)\n  \\<lbrakk>C.ide ?b; C.ide ?a\\<rbrakk>\n  \\<Longrightarrow> inj_on (\\<phi> (?b, ?a)) (C.hom ?b ?a)\n  \\<psi> ?ba = inv_into (C.hom (fst ?ba) (snd ?ba)) (\\<phi> ?ba)\n\ngoal (1 subgoal):\n 1. \\<phi> (b, a) (\\<psi> (b, a) x) = x", "by auto"], ["", "lemma \\<psi>_img_set:\n    assumes \"C.ide b\" and \"C.ide a\"\n    shows \"\\<psi> (b, a) ` set (b, a) = C.hom b a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> (b, a) ` local.set (b, a) = C.hom b a", "using assms \\<psi>_def set_def local_inj"], ["proof (prove)\nusing this:\n  C.ide b\n  C.ide a\n  \\<psi> ?ba = inv_into (C.hom (fst ?ba) (snd ?ba)) (\\<phi> ?ba)\n  local.set ?ba \\<equiv>\n  \\<phi> (fst ?ba, snd ?ba) ` C.hom (fst ?ba) (snd ?ba)\n  \\<lbrakk>C.ide ?b; C.ide ?a\\<rbrakk>\n  \\<Longrightarrow> inj_on (\\<phi> (?b, ?a)) (C.hom ?b ?a)\n\ngoal (1 subgoal):\n 1. \\<psi> (b, a) ` local.set (b, a) = C.hom b a", "by auto"], ["", "text\\<open>\n      A hom-functor maps each arrow @{term \"(g, f)\"} of @{term \"CopxC\"}\n      to the arrow of the set category @{term[source=true] S} corresponding to the function\n      that takes an arrow @{term h} of @{term C} to the arrow @{term \"C f (C h g)\"} of @{term C}\n      obtained by precomposing with @{term g} and postcomposing with @{term f}.\n\\<close>"], ["", "definition map\n    where \"map gf =\n             (if CopxC.arr gf then\n                S.mkArr (set (CopxC.dom gf)) (set (CopxC.cod gf))\n                        (\\<phi> (CopxC.cod gf) o (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf) o \\<psi> (CopxC.dom gf))\n              else S.null)\""], ["", "lemma arr_map:\n    assumes \"CopxC.arr gf\"\n    shows \"S.arr (map gf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.arr (local.map gf)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. S.arr (local.map gf)", "have \"\\<phi> (CopxC.cod gf) o (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf) o \\<psi> (CopxC.dom gf)\n              \\<in> set (CopxC.dom gf) \\<rightarrow> set (CopxC.cod gf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> (CopxC.cod gf) \\<circ>\n    (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf) \\<circ>\n    \\<psi> (CopxC.dom gf)\n    \\<in> local.set (CopxC.dom gf) \\<rightarrow> local.set (CopxC.cod gf)", "using assms \\<phi>_mapsto [of \"fst (CopxC.cod gf)\" \"snd (CopxC.cod gf)\"]\n              \\<psi>_mapsto [of \"fst (CopxC.dom gf)\" \"snd (CopxC.dom gf)\"]"], ["proof (prove)\nusing this:\n  CopxC.arr gf\n  \\<lbrakk>C.ide (fst (CopxC.cod gf)); C.ide (snd (CopxC.cod gf))\\<rbrakk>\n  \\<Longrightarrow> \\<phi> (fst (CopxC.cod gf), snd (CopxC.cod gf))\n                    \\<in> C.hom (fst (CopxC.cod gf))\n                           (snd (CopxC.cod gf)) \\<rightarrow>\n                          local.set (fst (CopxC.cod gf), snd (CopxC.cod gf))\n  \\<lbrakk>C.ide (fst (CopxC.dom gf)); C.ide (snd (CopxC.dom gf))\\<rbrakk>\n  \\<Longrightarrow> \\<psi> (fst (CopxC.dom gf), snd (CopxC.dom gf))\n                    \\<in> local.set\n                           (fst (CopxC.dom gf),\n                            snd (CopxC.dom gf)) \\<rightarrow>\n                          C.hom (fst (CopxC.dom gf)) (snd (CopxC.dom gf))\n\ngoal (1 subgoal):\n 1. \\<phi> (CopxC.cod gf) \\<circ>\n    (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf) \\<circ>\n    \\<psi> (CopxC.dom gf)\n    \\<in> local.set (CopxC.dom gf) \\<rightarrow> local.set (CopxC.cod gf)", "by fastforce"], ["proof (state)\nthis:\n  \\<phi> (CopxC.cod gf) \\<circ>\n  (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf) \\<circ>\n  \\<psi> (CopxC.dom gf)\n  \\<in> local.set (CopxC.dom gf) \\<rightarrow> local.set (CopxC.cod gf)\n\ngoal (1 subgoal):\n 1. S.arr (local.map gf)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<phi> (CopxC.cod gf) \\<circ>\n  (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf) \\<circ>\n  \\<psi> (CopxC.dom gf)\n  \\<in> local.set (CopxC.dom gf) \\<rightarrow> local.set (CopxC.cod gf)\n\ngoal (1 subgoal):\n 1. S.arr (local.map gf)", "using assms map_def S.arr_mkArr set_subset_Univ S.card_of_leq"], ["proof (prove)\nusing this:\n  \\<phi> (CopxC.cod gf) \\<circ>\n  (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf) \\<circ>\n  \\<psi> (CopxC.dom gf)\n  \\<in> local.set (CopxC.dom gf) \\<rightarrow> local.set (CopxC.cod gf)\n  CopxC.arr gf\n  local.map ?gf =\n  (if CopxC.arr ?gf\n   then S.mkArr (local.set (CopxC.dom ?gf)) (local.set (CopxC.cod ?gf))\n         (\\<phi> (CopxC.cod ?gf) \\<circ>\n          (\\<lambda>h. snd ?gf \\<cdot> h \\<cdot> fst ?gf) \\<circ>\n          \\<psi> (CopxC.dom ?gf))\n   else S.null)\n  S.arr (S.mkArr ?A ?B ?F) =\n  (?A \\<subseteq> S.Univ \\<and>\n   ?B \\<subseteq> S.Univ \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n  \\<lbrakk>C.ide ?b; C.ide ?a\\<rbrakk>\n  \\<Longrightarrow> local.set (?b, ?a) \\<subseteq> S.Univ\n  ?A \\<subseteq> S.Univ \\<Longrightarrow>\n  |?A| <o cardSuc (cmax |UNIV| natLeq)\n\ngoal (1 subgoal):\n 1. S.arr (local.map gf)", "by simp"], ["proof (state)\nthis:\n  S.arr (local.map gf)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_ide [simp]:\n    assumes \"C.ide b\" and \"C.ide a\"\n    shows \"map (b, a) = S.mkIde (set (b, a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.map (b, a) = S.mkIde (local.set (b, a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.map (b, a) = S.mkIde (local.set (b, a))", "have \"map (b, a) = S.mkArr (set (b, a)) (set (b, a))\n                                 (\\<phi> (b, a) o (\\<lambda>h. a \\<cdot> h \\<cdot> b) o \\<psi> (b, a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.map (b, a) =\n    S.mkArr (local.set (b, a)) (local.set (b, a))\n     (\\<phi> (b, a) \\<circ> (\\<lambda>h. a \\<cdot> h \\<cdot> b) \\<circ>\n      \\<psi> (b, a))", "using assms map_def"], ["proof (prove)\nusing this:\n  C.ide b\n  C.ide a\n  local.map ?gf =\n  (if CopxC.arr ?gf\n   then S.mkArr (local.set (CopxC.dom ?gf)) (local.set (CopxC.cod ?gf))\n         (\\<phi> (CopxC.cod ?gf) \\<circ>\n          (\\<lambda>h. snd ?gf \\<cdot> h \\<cdot> fst ?gf) \\<circ>\n          \\<psi> (CopxC.dom ?gf))\n   else S.null)\n\ngoal (1 subgoal):\n 1. local.map (b, a) =\n    S.mkArr (local.set (b, a)) (local.set (b, a))\n     (\\<phi> (b, a) \\<circ> (\\<lambda>h. a \\<cdot> h \\<cdot> b) \\<circ>\n      \\<psi> (b, a))", "by auto"], ["proof (state)\nthis:\n  local.map (b, a) =\n  S.mkArr (local.set (b, a)) (local.set (b, a))\n   (\\<phi> (b, a) \\<circ> (\\<lambda>h. a \\<cdot> h \\<cdot> b) \\<circ>\n    \\<psi> (b, a))\n\ngoal (1 subgoal):\n 1. local.map (b, a) = S.mkIde (local.set (b, a))", "also"], ["proof (state)\nthis:\n  local.map (b, a) =\n  S.mkArr (local.set (b, a)) (local.set (b, a))\n   (\\<phi> (b, a) \\<circ> (\\<lambda>h. a \\<cdot> h \\<cdot> b) \\<circ>\n    \\<psi> (b, a))\n\ngoal (1 subgoal):\n 1. local.map (b, a) = S.mkIde (local.set (b, a))", "have \"... = S.mkArr (set (b, a)) (set (b, a)) (\\<lambda>h. h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.mkArr (local.set (b, a)) (local.set (b, a))\n     (\\<phi> (b, a) \\<circ> (\\<lambda>h. a \\<cdot> h \\<cdot> b) \\<circ>\n      \\<psi> (b, a)) =\n    S.mkArr (local.set (b, a)) (local.set (b, a)) (\\<lambda>h. h)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. S.mkArr (local.set (b, a)) (local.set (b, a))\n     (\\<phi> (b, a) \\<circ> (\\<lambda>h. a \\<cdot> h \\<cdot> b) \\<circ>\n      \\<psi> (b, a)) =\n    S.mkArr (local.set (b, a)) (local.set (b, a)) (\\<lambda>h. h)", "have \"S.mkArr (set (b, a)) (set (b, a)) (\\<lambda>h. h) = ...\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.mkArr (local.set (b, a)) (local.set (b, a)) (\\<lambda>h. h) =\n    S.mkArr (local.set (b, a)) (local.set (b, a))\n     (\\<phi> (b, a) \\<circ> (\\<lambda>h. a \\<cdot> h \\<cdot> b) \\<circ>\n      \\<psi> (b, a))", "using assms S.arr_mkArr set_subset_Univ set_def C.comp_arr_dom C.comp_cod_arr\n                S.card_of_leq S.arr_mkIde"], ["proof (prove)\nusing this:\n  C.ide b\n  C.ide a\n  S.arr (S.mkArr ?A ?B ?F) =\n  (?A \\<subseteq> S.Univ \\<and>\n   ?B \\<subseteq> S.Univ \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n  \\<lbrakk>C.ide ?b; C.ide ?a\\<rbrakk>\n  \\<Longrightarrow> local.set (?b, ?a) \\<subseteq> S.Univ\n  local.set ?ba \\<equiv>\n  \\<phi> (fst ?ba, snd ?ba) ` C.hom (fst ?ba) (snd ?ba)\n  \\<lbrakk>C.arr ?f; C.dom ?f = ?a\\<rbrakk>\n  \\<Longrightarrow> ?f \\<cdot> ?a = ?f\n  \\<lbrakk>C.arr ?f; C.cod ?f = ?b\\<rbrakk>\n  \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n  ?A \\<subseteq> S.Univ \\<Longrightarrow>\n  |?A| <o cardSuc (cmax |UNIV| natLeq)\n  S.arr (S.mkIde ?A) = (?A \\<subseteq> S.Univ)\n\ngoal (1 subgoal):\n 1. S.mkArr (local.set (b, a)) (local.set (b, a)) (\\<lambda>h. h) =\n    S.mkArr (local.set (b, a)) (local.set (b, a))\n     (\\<phi> (b, a) \\<circ> (\\<lambda>h. a \\<cdot> h \\<cdot> b) \\<circ>\n      \\<psi> (b, a))", "by (intro S.mkArr_eqI', simp, fastforce)"], ["proof (state)\nthis:\n  S.mkArr (local.set (b, a)) (local.set (b, a)) (\\<lambda>h. h) =\n  S.mkArr (local.set (b, a)) (local.set (b, a))\n   (\\<phi> (b, a) \\<circ> (\\<lambda>h. a \\<cdot> h \\<cdot> b) \\<circ>\n    \\<psi> (b, a))\n\ngoal (1 subgoal):\n 1. S.mkArr (local.set (b, a)) (local.set (b, a))\n     (\\<phi> (b, a) \\<circ> (\\<lambda>h. a \\<cdot> h \\<cdot> b) \\<circ>\n      \\<psi> (b, a)) =\n    S.mkArr (local.set (b, a)) (local.set (b, a)) (\\<lambda>h. h)", "thus ?thesis"], ["proof (prove)\nusing this:\n  S.mkArr (local.set (b, a)) (local.set (b, a)) (\\<lambda>h. h) =\n  S.mkArr (local.set (b, a)) (local.set (b, a))\n   (\\<phi> (b, a) \\<circ> (\\<lambda>h. a \\<cdot> h \\<cdot> b) \\<circ>\n    \\<psi> (b, a))\n\ngoal (1 subgoal):\n 1. S.mkArr (local.set (b, a)) (local.set (b, a))\n     (\\<phi> (b, a) \\<circ> (\\<lambda>h. a \\<cdot> h \\<cdot> b) \\<circ>\n      \\<psi> (b, a)) =\n    S.mkArr (local.set (b, a)) (local.set (b, a)) (\\<lambda>h. h)", "by auto"], ["proof (state)\nthis:\n  S.mkArr (local.set (b, a)) (local.set (b, a))\n   (\\<phi> (b, a) \\<circ> (\\<lambda>h. a \\<cdot> h \\<cdot> b) \\<circ>\n    \\<psi> (b, a)) =\n  S.mkArr (local.set (b, a)) (local.set (b, a)) (\\<lambda>h. h)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S.mkArr (local.set (b, a)) (local.set (b, a))\n   (\\<phi> (b, a) \\<circ> (\\<lambda>h. a \\<cdot> h \\<cdot> b) \\<circ>\n    \\<psi> (b, a)) =\n  S.mkArr (local.set (b, a)) (local.set (b, a)) (\\<lambda>h. h)\n\ngoal (1 subgoal):\n 1. local.map (b, a) = S.mkIde (local.set (b, a))", "also"], ["proof (state)\nthis:\n  S.mkArr (local.set (b, a)) (local.set (b, a))\n   (\\<phi> (b, a) \\<circ> (\\<lambda>h. a \\<cdot> h \\<cdot> b) \\<circ>\n    \\<psi> (b, a)) =\n  S.mkArr (local.set (b, a)) (local.set (b, a)) (\\<lambda>h. h)\n\ngoal (1 subgoal):\n 1. local.map (b, a) = S.mkIde (local.set (b, a))", "have \"... = S.mkIde (set (b, a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.mkArr (local.set (b, a)) (local.set (b, a)) (\\<lambda>h. h) =\n    S.mkIde (local.set (b, a))", "using assms S.mkIde_as_mkArr set_subset_Univ"], ["proof (prove)\nusing this:\n  C.ide b\n  C.ide a\n  ?A \\<subseteq> S.Univ \\<Longrightarrow>\n  S.mkArr ?A ?A (\\<lambda>x. x) = S.mkIde ?A\n  \\<lbrakk>C.ide ?b; C.ide ?a\\<rbrakk>\n  \\<Longrightarrow> local.set (?b, ?a) \\<subseteq> S.Univ\n\ngoal (1 subgoal):\n 1. S.mkArr (local.set (b, a)) (local.set (b, a)) (\\<lambda>h. h) =\n    S.mkIde (local.set (b, a))", "by simp"], ["proof (state)\nthis:\n  S.mkArr (local.set (b, a)) (local.set (b, a)) (\\<lambda>h. h) =\n  S.mkIde (local.set (b, a))\n\ngoal (1 subgoal):\n 1. local.map (b, a) = S.mkIde (local.set (b, a))", "finally"], ["proof (chain)\npicking this:\n  local.map (b, a) = S.mkIde (local.set (b, a))", "show ?thesis"], ["proof (prove)\nusing this:\n  local.map (b, a) = S.mkIde (local.set (b, a))\n\ngoal (1 subgoal):\n 1. local.map (b, a) = S.mkIde (local.set (b, a))", "by auto"], ["proof (state)\nthis:\n  local.map (b, a) = S.mkIde (local.set (b, a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_map:\n    assumes \"C.ide a\" and \"C.ide b\"\n    shows \"S.set (map (b, a)) = set (b, a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.set (local.map (b, a)) = local.set (b, a)", "using assms map_ide S.set_mkIde set_subset_Univ"], ["proof (prove)\nusing this:\n  C.ide a\n  C.ide b\n  \\<lbrakk>C.ide ?b; C.ide ?a\\<rbrakk>\n  \\<Longrightarrow> local.map (?b, ?a) = S.mkIde (local.set (?b, ?a))\n  ?A \\<subseteq> S.Univ \\<Longrightarrow> S.set (S.mkIde ?A) = ?A\n  \\<lbrakk>C.ide ?b; C.ide ?a\\<rbrakk>\n  \\<Longrightarrow> local.set (?b, ?a) \\<subseteq> S.Univ\n\ngoal (1 subgoal):\n 1. S.set (local.map (b, a)) = local.set (b, a)", "by simp"], ["", "text\\<open>\n      The definition does in fact yield a functor.\n\\<close>"], ["", "interpretation \"functor\" CopxC.comp S map"], ["proof (prove)\ngoal (1 subgoal):\n 1. functor (\\<odot>) (\\<cdot>\\<^sub>S) local.map", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>f. \\<not> CopxC.arr f \\<Longrightarrow> local.map f = S.null\n 2. \\<And>f. CopxC.arr f \\<Longrightarrow> S.arr (local.map f)\n 3. \\<And>f.\n       CopxC.arr f \\<Longrightarrow>\n       S.dom (local.map f) = local.map (CopxC.dom f)\n 4. \\<And>f.\n       CopxC.arr f \\<Longrightarrow>\n       S.cod (local.map f) = local.map (CopxC.cod f)\n 5. \\<And>g f.\n       CopxC.seq g f \\<Longrightarrow>\n       local.map (g \\<odot> f) = local.map g \\<cdot>\\<^sub>S local.map f", "fix gf"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>f. \\<not> CopxC.arr f \\<Longrightarrow> local.map f = S.null\n 2. \\<And>f. CopxC.arr f \\<Longrightarrow> S.arr (local.map f)\n 3. \\<And>f.\n       CopxC.arr f \\<Longrightarrow>\n       S.dom (local.map f) = local.map (CopxC.dom f)\n 4. \\<And>f.\n       CopxC.arr f \\<Longrightarrow>\n       S.cod (local.map f) = local.map (CopxC.cod f)\n 5. \\<And>g f.\n       CopxC.seq g f \\<Longrightarrow>\n       local.map (g \\<odot> f) = local.map g \\<cdot>\\<^sub>S local.map f", "assume \"\\<not>CopxC.arr gf\""], ["proof (state)\nthis:\n  \\<not> CopxC.arr gf\n\ngoal (5 subgoals):\n 1. \\<And>f. \\<not> CopxC.arr f \\<Longrightarrow> local.map f = S.null\n 2. \\<And>f. CopxC.arr f \\<Longrightarrow> S.arr (local.map f)\n 3. \\<And>f.\n       CopxC.arr f \\<Longrightarrow>\n       S.dom (local.map f) = local.map (CopxC.dom f)\n 4. \\<And>f.\n       CopxC.arr f \\<Longrightarrow>\n       S.cod (local.map f) = local.map (CopxC.cod f)\n 5. \\<And>g f.\n       CopxC.seq g f \\<Longrightarrow>\n       local.map (g \\<odot> f) = local.map g \\<cdot>\\<^sub>S local.map f", "thus \"map gf = S.null\""], ["proof (prove)\nusing this:\n  \\<not> CopxC.arr gf\n\ngoal (1 subgoal):\n 1. local.map gf = S.null", "using map_def"], ["proof (prove)\nusing this:\n  \\<not> CopxC.arr gf\n  local.map ?gf =\n  (if CopxC.arr ?gf\n   then S.mkArr (local.set (CopxC.dom ?gf)) (local.set (CopxC.cod ?gf))\n         (\\<phi> (CopxC.cod ?gf) \\<circ>\n          (\\<lambda>h. snd ?gf \\<cdot> h \\<cdot> fst ?gf) \\<circ>\n          \\<psi> (CopxC.dom ?gf))\n   else S.null)\n\ngoal (1 subgoal):\n 1. local.map gf = S.null", "by auto"], ["proof (state)\nthis:\n  local.map gf = S.null\n\ngoal (4 subgoals):\n 1. \\<And>f. CopxC.arr f \\<Longrightarrow> S.arr (local.map f)\n 2. \\<And>f.\n       CopxC.arr f \\<Longrightarrow>\n       S.dom (local.map f) = local.map (CopxC.dom f)\n 3. \\<And>f.\n       CopxC.arr f \\<Longrightarrow>\n       S.cod (local.map f) = local.map (CopxC.cod f)\n 4. \\<And>g f.\n       CopxC.seq g f \\<Longrightarrow>\n       local.map (g \\<odot> f) = local.map g \\<cdot>\\<^sub>S local.map f", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>f. CopxC.arr f \\<Longrightarrow> S.arr (local.map f)\n 2. \\<And>f.\n       CopxC.arr f \\<Longrightarrow>\n       S.dom (local.map f) = local.map (CopxC.dom f)\n 3. \\<And>f.\n       CopxC.arr f \\<Longrightarrow>\n       S.cod (local.map f) = local.map (CopxC.cod f)\n 4. \\<And>g f.\n       CopxC.seq g f \\<Longrightarrow>\n       local.map (g \\<odot> f) = local.map g \\<cdot>\\<^sub>S local.map f", "fix gf"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>f. CopxC.arr f \\<Longrightarrow> S.arr (local.map f)\n 2. \\<And>f.\n       CopxC.arr f \\<Longrightarrow>\n       S.dom (local.map f) = local.map (CopxC.dom f)\n 3. \\<And>f.\n       CopxC.arr f \\<Longrightarrow>\n       S.cod (local.map f) = local.map (CopxC.cod f)\n 4. \\<And>g f.\n       CopxC.seq g f \\<Longrightarrow>\n       local.map (g \\<odot> f) = local.map g \\<cdot>\\<^sub>S local.map f", "assume gf: \"CopxC.arr gf\""], ["proof (state)\nthis:\n  CopxC.arr gf\n\ngoal (4 subgoals):\n 1. \\<And>f. CopxC.arr f \\<Longrightarrow> S.arr (local.map f)\n 2. \\<And>f.\n       CopxC.arr f \\<Longrightarrow>\n       S.dom (local.map f) = local.map (CopxC.dom f)\n 3. \\<And>f.\n       CopxC.arr f \\<Longrightarrow>\n       S.cod (local.map f) = local.map (CopxC.cod f)\n 4. \\<And>g f.\n       CopxC.seq g f \\<Longrightarrow>\n       local.map (g \\<odot> f) = local.map g \\<cdot>\\<^sub>S local.map f", "thus arr: \"S.arr (map gf)\""], ["proof (prove)\nusing this:\n  CopxC.arr gf\n\ngoal (1 subgoal):\n 1. S.arr (local.map gf)", "using gf arr_map"], ["proof (prove)\nusing this:\n  CopxC.arr gf\n  CopxC.arr gf\n  CopxC.arr ?gf \\<Longrightarrow> S.arr (local.map ?gf)\n\ngoal (1 subgoal):\n 1. S.arr (local.map gf)", "by blast"], ["proof (state)\nthis:\n  S.arr (local.map gf)\n\ngoal (3 subgoals):\n 1. \\<And>f.\n       CopxC.arr f \\<Longrightarrow>\n       S.dom (local.map f) = local.map (CopxC.dom f)\n 2. \\<And>f.\n       CopxC.arr f \\<Longrightarrow>\n       S.cod (local.map f) = local.map (CopxC.cod f)\n 3. \\<And>g f.\n       CopxC.seq g f \\<Longrightarrow>\n       local.map (g \\<odot> f) = local.map g \\<cdot>\\<^sub>S local.map f", "show \"S.dom (map gf) = map (CopxC.dom gf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.dom (local.map gf) = local.map (CopxC.dom gf)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. S.dom (local.map gf) = local.map (CopxC.dom gf)", "have \"S.dom (map gf) = S.mkArr (set (CopxC.dom gf)) (set (CopxC.dom gf)) (\\<lambda>x. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.dom (local.map gf) =\n    S.mkArr (local.set (CopxC.dom gf)) (local.set (CopxC.dom gf))\n     (\\<lambda>x. x)", "using gf arr_map map_def S.mkIde_as_mkArr S.arr_mkArr"], ["proof (prove)\nusing this:\n  CopxC.arr gf\n  CopxC.arr ?gf \\<Longrightarrow> S.arr (local.map ?gf)\n  local.map ?gf =\n  (if CopxC.arr ?gf\n   then S.mkArr (local.set (CopxC.dom ?gf)) (local.set (CopxC.cod ?gf))\n         (\\<phi> (CopxC.cod ?gf) \\<circ>\n          (\\<lambda>h. snd ?gf \\<cdot> h \\<cdot> fst ?gf) \\<circ>\n          \\<psi> (CopxC.dom ?gf))\n   else S.null)\n  ?A \\<subseteq> S.Univ \\<Longrightarrow>\n  S.mkArr ?A ?A (\\<lambda>x. x) = S.mkIde ?A\n  S.arr (S.mkArr ?A ?B ?F) =\n  (?A \\<subseteq> S.Univ \\<and>\n   ?B \\<subseteq> S.Univ \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n\ngoal (1 subgoal):\n 1. S.dom (local.map gf) =\n    S.mkArr (local.set (CopxC.dom gf)) (local.set (CopxC.dom gf))\n     (\\<lambda>x. x)", "by simp"], ["proof (state)\nthis:\n  S.dom (local.map gf) =\n  S.mkArr (local.set (CopxC.dom gf)) (local.set (CopxC.dom gf))\n   (\\<lambda>x. x)\n\ngoal (1 subgoal):\n 1. S.dom (local.map gf) = local.map (CopxC.dom gf)", "also"], ["proof (state)\nthis:\n  S.dom (local.map gf) =\n  S.mkArr (local.set (CopxC.dom gf)) (local.set (CopxC.dom gf))\n   (\\<lambda>x. x)\n\ngoal (1 subgoal):\n 1. S.dom (local.map gf) = local.map (CopxC.dom gf)", "have \"... = S.mkArr (set (CopxC.dom gf)) (set (CopxC.dom gf))\n                                 (\\<phi> (CopxC.dom gf) o\n                                  (\\<lambda>h. snd (CopxC.dom gf) \\<cdot> h \\<cdot> fst (CopxC.dom gf)) o\n                                  \\<psi> (CopxC.dom gf))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.mkArr (local.set (CopxC.dom gf)) (local.set (CopxC.dom gf))\n     (\\<lambda>x. x) =\n    S.mkArr (local.set (CopxC.dom gf)) (local.set (CopxC.dom gf))\n     (\\<phi> (CopxC.dom gf) \\<circ>\n      (\\<lambda>h.\n          snd (CopxC.dom gf) \\<cdot> h \\<cdot> fst (CopxC.dom gf)) \\<circ>\n      \\<psi> (CopxC.dom gf))", "using gf set_subset_Univ \\<psi>_mapsto map_def set_def S.card_of_leq S.arr_mkIde S.arr_mkArr"], ["proof (prove)\nusing this:\n  CopxC.arr gf\n  \\<lbrakk>C.ide ?b; C.ide ?a\\<rbrakk>\n  \\<Longrightarrow> local.set (?b, ?a) \\<subseteq> S.Univ\n  \\<lbrakk>C.ide ?b; C.ide ?a\\<rbrakk>\n  \\<Longrightarrow> \\<psi> (?b, ?a)\n                    \\<in> local.set (?b, ?a) \\<rightarrow> C.hom ?b ?a\n  local.map ?gf =\n  (if CopxC.arr ?gf\n   then S.mkArr (local.set (CopxC.dom ?gf)) (local.set (CopxC.cod ?gf))\n         (\\<phi> (CopxC.cod ?gf) \\<circ>\n          (\\<lambda>h. snd ?gf \\<cdot> h \\<cdot> fst ?gf) \\<circ>\n          \\<psi> (CopxC.dom ?gf))\n   else S.null)\n  local.set ?ba \\<equiv>\n  \\<phi> (fst ?ba, snd ?ba) ` C.hom (fst ?ba) (snd ?ba)\n  ?A \\<subseteq> S.Univ \\<Longrightarrow>\n  |?A| <o cardSuc (cmax |UNIV| natLeq)\n  S.arr (S.mkIde ?A) = (?A \\<subseteq> S.Univ)\n  S.arr (S.mkArr ?A ?B ?F) =\n  (?A \\<subseteq> S.Univ \\<and>\n   ?B \\<subseteq> S.Univ \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n\ngoal (1 subgoal):\n 1. S.mkArr (local.set (CopxC.dom gf)) (local.set (CopxC.dom gf))\n     (\\<lambda>x. x) =\n    S.mkArr (local.set (CopxC.dom gf)) (local.set (CopxC.dom gf))\n     (\\<phi> (CopxC.dom gf) \\<circ>\n      (\\<lambda>h.\n          snd (CopxC.dom gf) \\<cdot> h \\<cdot> fst (CopxC.dom gf)) \\<circ>\n      \\<psi> (CopxC.dom gf))", "apply (intro S.mkArr_eqI', auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<And>b a.\n                   \\<lbrakk>C.ide b; C.ide a\\<rbrakk>\n                   \\<Longrightarrow> \\<phi> (b, a) ` C.hom b a\n                                     \\<subseteq> S.Univ;\n        \\<And>b a.\n           \\<lbrakk>C.ide b; C.ide a\\<rbrakk>\n           \\<Longrightarrow> \\<psi> (b, a)\n                             \\<in> \\<phi> (b, a) ` C.hom b a \\<rightarrow>\n                                   C.hom b a;\n        \\<And>a b.\n           \\<phi> (a, b) ` C.hom a b \\<equiv> \\<phi> (a, b) ` C.hom a b;\n        \\<And>a b.\n           local.map (a, b) =\n           (if C.arr a \\<and> C.arr b\n            then S.mkArr (local.set (CopxC.dom (a, b)))\n                  (local.set (CopxC.cod (a, b)))\n                  (\\<phi> (CopxC.cod (a, b)) \\<circ>\n                   (\\<lambda>h.\n                       snd (a, b) \\<cdot> h \\<cdot> fst (a, b)) \\<circ>\n                   \\<psi> (CopxC.dom (a, b)))\n            else S.null);\n        \\<And>a b. local.set (a, b) \\<equiv> \\<phi> (a, b) ` C.hom a b;\n        \\<And>A.\n           A \\<subseteq> S.Univ \\<Longrightarrow>\n           |A| <o cardSuc (cmax |UNIV| natLeq);\n        \\<And>A B F.\n           S.arr (S.mkArr A B F) =\n           (A \\<subseteq> S.Univ \\<and>\n            B \\<subseteq> S.Univ \\<and> F \\<in> A \\<rightarrow> B);\n        \\<guillemotleft>xa : C.cod\n                              (fst gf) \\<rightarrow> C.dom\n                (snd gf)\\<guillemotright>;\n        C.arr (fst gf); C.arr (snd gf)\\<rbrakk>\n       \\<Longrightarrow> \\<phi> (C.cod (fst gf), C.dom (snd gf)) xa =\n                         \\<phi> (C.cod (fst gf), C.dom (snd gf))\n                          (C.dom (snd gf) \\<cdot> xa \\<cdot> C.cod (fst gf))", "by (metis C.comp_arr_dom C.comp_cod_arr C.in_homE)"], ["proof (state)\nthis:\n  S.mkArr (local.set (CopxC.dom gf)) (local.set (CopxC.dom gf))\n   (\\<lambda>x. x) =\n  S.mkArr (local.set (CopxC.dom gf)) (local.set (CopxC.dom gf))\n   (\\<phi> (CopxC.dom gf) \\<circ>\n    (\\<lambda>h.\n        snd (CopxC.dom gf) \\<cdot> h \\<cdot> fst (CopxC.dom gf)) \\<circ>\n    \\<psi> (CopxC.dom gf))\n\ngoal (1 subgoal):\n 1. S.dom (local.map gf) = local.map (CopxC.dom gf)", "also"], ["proof (state)\nthis:\n  S.mkArr (local.set (CopxC.dom gf)) (local.set (CopxC.dom gf))\n   (\\<lambda>x. x) =\n  S.mkArr (local.set (CopxC.dom gf)) (local.set (CopxC.dom gf))\n   (\\<phi> (CopxC.dom gf) \\<circ>\n    (\\<lambda>h.\n        snd (CopxC.dom gf) \\<cdot> h \\<cdot> fst (CopxC.dom gf)) \\<circ>\n    \\<psi> (CopxC.dom gf))\n\ngoal (1 subgoal):\n 1. S.dom (local.map gf) = local.map (CopxC.dom gf)", "have \"... = map (CopxC.dom gf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.mkArr (local.set (CopxC.dom gf)) (local.set (CopxC.dom gf))\n     (\\<phi> (CopxC.dom gf) \\<circ>\n      (\\<lambda>h.\n          snd (CopxC.dom gf) \\<cdot> h \\<cdot> fst (CopxC.dom gf)) \\<circ>\n      \\<psi> (CopxC.dom gf)) =\n    local.map (CopxC.dom gf)", "using gf map_def C.arr_dom_iff_arr C.arr_cod_iff_arr"], ["proof (prove)\nusing this:\n  CopxC.arr gf\n  local.map ?gf =\n  (if CopxC.arr ?gf\n   then S.mkArr (local.set (CopxC.dom ?gf)) (local.set (CopxC.cod ?gf))\n         (\\<phi> (CopxC.cod ?gf) \\<circ>\n          (\\<lambda>h. snd ?gf \\<cdot> h \\<cdot> fst ?gf) \\<circ>\n          \\<psi> (CopxC.dom ?gf))\n   else S.null)\n  C.arr (C.dom ?f) = C.arr ?f\n  C.arr (C.cod ?f) = C.arr ?f\n\ngoal (1 subgoal):\n 1. S.mkArr (local.set (CopxC.dom gf)) (local.set (CopxC.dom gf))\n     (\\<phi> (CopxC.dom gf) \\<circ>\n      (\\<lambda>h.\n          snd (CopxC.dom gf) \\<cdot> h \\<cdot> fst (CopxC.dom gf)) \\<circ>\n      \\<psi> (CopxC.dom gf)) =\n    local.map (CopxC.dom gf)", "by simp"], ["proof (state)\nthis:\n  S.mkArr (local.set (CopxC.dom gf)) (local.set (CopxC.dom gf))\n   (\\<phi> (CopxC.dom gf) \\<circ>\n    (\\<lambda>h.\n        snd (CopxC.dom gf) \\<cdot> h \\<cdot> fst (CopxC.dom gf)) \\<circ>\n    \\<psi> (CopxC.dom gf)) =\n  local.map (CopxC.dom gf)\n\ngoal (1 subgoal):\n 1. S.dom (local.map gf) = local.map (CopxC.dom gf)", "finally"], ["proof (chain)\npicking this:\n  S.dom (local.map gf) = local.map (CopxC.dom gf)", "show ?thesis"], ["proof (prove)\nusing this:\n  S.dom (local.map gf) = local.map (CopxC.dom gf)\n\ngoal (1 subgoal):\n 1. S.dom (local.map gf) = local.map (CopxC.dom gf)", "by auto"], ["proof (state)\nthis:\n  S.dom (local.map gf) = local.map (CopxC.dom gf)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S.dom (local.map gf) = local.map (CopxC.dom gf)\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       CopxC.arr f \\<Longrightarrow>\n       S.cod (local.map f) = local.map (CopxC.cod f)\n 2. \\<And>g f.\n       CopxC.seq g f \\<Longrightarrow>\n       local.map (g \\<odot> f) = local.map g \\<cdot>\\<^sub>S local.map f", "show \"S.cod (map gf) = map (CopxC.cod gf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.cod (local.map gf) = local.map (CopxC.cod gf)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. S.cod (local.map gf) = local.map (CopxC.cod gf)", "have \"S.cod (map gf) = S.mkArr (set (CopxC.cod gf)) (set (CopxC.cod gf)) (\\<lambda>x. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.cod (local.map gf) =\n    S.mkArr (local.set (CopxC.cod gf)) (local.set (CopxC.cod gf))\n     (\\<lambda>x. x)", "using gf map_def arr_map S.mkIde_as_mkArr S.arr_mkArr"], ["proof (prove)\nusing this:\n  CopxC.arr gf\n  local.map ?gf =\n  (if CopxC.arr ?gf\n   then S.mkArr (local.set (CopxC.dom ?gf)) (local.set (CopxC.cod ?gf))\n         (\\<phi> (CopxC.cod ?gf) \\<circ>\n          (\\<lambda>h. snd ?gf \\<cdot> h \\<cdot> fst ?gf) \\<circ>\n          \\<psi> (CopxC.dom ?gf))\n   else S.null)\n  CopxC.arr ?gf \\<Longrightarrow> S.arr (local.map ?gf)\n  ?A \\<subseteq> S.Univ \\<Longrightarrow>\n  S.mkArr ?A ?A (\\<lambda>x. x) = S.mkIde ?A\n  S.arr (S.mkArr ?A ?B ?F) =\n  (?A \\<subseteq> S.Univ \\<and>\n   ?B \\<subseteq> S.Univ \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n\ngoal (1 subgoal):\n 1. S.cod (local.map gf) =\n    S.mkArr (local.set (CopxC.cod gf)) (local.set (CopxC.cod gf))\n     (\\<lambda>x. x)", "by simp"], ["proof (state)\nthis:\n  S.cod (local.map gf) =\n  S.mkArr (local.set (CopxC.cod gf)) (local.set (CopxC.cod gf))\n   (\\<lambda>x. x)\n\ngoal (1 subgoal):\n 1. S.cod (local.map gf) = local.map (CopxC.cod gf)", "also"], ["proof (state)\nthis:\n  S.cod (local.map gf) =\n  S.mkArr (local.set (CopxC.cod gf)) (local.set (CopxC.cod gf))\n   (\\<lambda>x. x)\n\ngoal (1 subgoal):\n 1. S.cod (local.map gf) = local.map (CopxC.cod gf)", "have \"... = S.mkArr (set (CopxC.cod gf)) (set (CopxC.cod gf))\n                                 (\\<phi> (CopxC.cod gf) o\n                                  (\\<lambda>h. snd (CopxC.cod gf) \\<cdot> h \\<cdot> fst (CopxC.cod gf)) o\n                                  \\<psi> (CopxC.cod gf))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.mkArr (local.set (CopxC.cod gf)) (local.set (CopxC.cod gf))\n     (\\<lambda>x. x) =\n    S.mkArr (local.set (CopxC.cod gf)) (local.set (CopxC.cod gf))\n     (\\<phi> (CopxC.cod gf) \\<circ>\n      (\\<lambda>h.\n          snd (CopxC.cod gf) \\<cdot> h \\<cdot> fst (CopxC.cod gf)) \\<circ>\n      \\<psi> (CopxC.cod gf))", "using gf set_subset_Univ \\<psi>_mapsto map_def set_def S.card_of_leq S.arr_mkIde S.arr_mkArr"], ["proof (prove)\nusing this:\n  CopxC.arr gf\n  \\<lbrakk>C.ide ?b; C.ide ?a\\<rbrakk>\n  \\<Longrightarrow> local.set (?b, ?a) \\<subseteq> S.Univ\n  \\<lbrakk>C.ide ?b; C.ide ?a\\<rbrakk>\n  \\<Longrightarrow> \\<psi> (?b, ?a)\n                    \\<in> local.set (?b, ?a) \\<rightarrow> C.hom ?b ?a\n  local.map ?gf =\n  (if CopxC.arr ?gf\n   then S.mkArr (local.set (CopxC.dom ?gf)) (local.set (CopxC.cod ?gf))\n         (\\<phi> (CopxC.cod ?gf) \\<circ>\n          (\\<lambda>h. snd ?gf \\<cdot> h \\<cdot> fst ?gf) \\<circ>\n          \\<psi> (CopxC.dom ?gf))\n   else S.null)\n  local.set ?ba \\<equiv>\n  \\<phi> (fst ?ba, snd ?ba) ` C.hom (fst ?ba) (snd ?ba)\n  ?A \\<subseteq> S.Univ \\<Longrightarrow>\n  |?A| <o cardSuc (cmax |UNIV| natLeq)\n  S.arr (S.mkIde ?A) = (?A \\<subseteq> S.Univ)\n  S.arr (S.mkArr ?A ?B ?F) =\n  (?A \\<subseteq> S.Univ \\<and>\n   ?B \\<subseteq> S.Univ \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n\ngoal (1 subgoal):\n 1. S.mkArr (local.set (CopxC.cod gf)) (local.set (CopxC.cod gf))\n     (\\<lambda>x. x) =\n    S.mkArr (local.set (CopxC.cod gf)) (local.set (CopxC.cod gf))\n     (\\<phi> (CopxC.cod gf) \\<circ>\n      (\\<lambda>h.\n          snd (CopxC.cod gf) \\<cdot> h \\<cdot> fst (CopxC.cod gf)) \\<circ>\n      \\<psi> (CopxC.cod gf))", "apply (intro S.mkArr_eqI', auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<lbrakk>\\<And>b a.\n                   \\<lbrakk>C.ide b; C.ide a\\<rbrakk>\n                   \\<Longrightarrow> \\<phi> (b, a) ` C.hom b a\n                                     \\<subseteq> S.Univ;\n        \\<And>b a.\n           \\<lbrakk>C.ide b; C.ide a\\<rbrakk>\n           \\<Longrightarrow> \\<psi> (b, a)\n                             \\<in> \\<phi> (b, a) ` C.hom b a \\<rightarrow>\n                                   C.hom b a;\n        \\<And>a b.\n           \\<phi> (a, b) ` C.hom a b \\<equiv> \\<phi> (a, b) ` C.hom a b;\n        \\<And>a b.\n           local.map (a, b) =\n           (if C.arr a \\<and> C.arr b\n            then S.mkArr (local.set (CopxC.dom (a, b)))\n                  (local.set (CopxC.cod (a, b)))\n                  (\\<phi> (CopxC.cod (a, b)) \\<circ>\n                   (\\<lambda>h.\n                       snd (a, b) \\<cdot> h \\<cdot> fst (a, b)) \\<circ>\n                   \\<psi> (CopxC.dom (a, b)))\n            else S.null);\n        \\<And>a b. local.set (a, b) \\<equiv> \\<phi> (a, b) ` C.hom a b;\n        \\<And>A.\n           A \\<subseteq> S.Univ \\<Longrightarrow>\n           |A| <o cardSuc (cmax |UNIV| natLeq);\n        \\<And>A B F.\n           S.arr (S.mkArr A B F) =\n           (A \\<subseteq> S.Univ \\<and>\n            B \\<subseteq> S.Univ \\<and> F \\<in> A \\<rightarrow> B);\n        \\<guillemotleft>xa : C.dom\n                              (fst gf) \\<rightarrow> C.cod\n                (snd gf)\\<guillemotright>;\n        C.arr (fst gf); C.arr (snd gf)\\<rbrakk>\n       \\<Longrightarrow> \\<phi> (C.dom (fst gf), C.cod (snd gf)) xa =\n                         \\<phi> (C.dom (fst gf), C.cod (snd gf))\n                          (C.cod (snd gf) \\<cdot> xa \\<cdot> C.dom (fst gf))", "by (metis C.comp_arr_dom C.comp_cod_arr C.in_homE)"], ["proof (state)\nthis:\n  S.mkArr (local.set (CopxC.cod gf)) (local.set (CopxC.cod gf))\n   (\\<lambda>x. x) =\n  S.mkArr (local.set (CopxC.cod gf)) (local.set (CopxC.cod gf))\n   (\\<phi> (CopxC.cod gf) \\<circ>\n    (\\<lambda>h.\n        snd (CopxC.cod gf) \\<cdot> h \\<cdot> fst (CopxC.cod gf)) \\<circ>\n    \\<psi> (CopxC.cod gf))\n\ngoal (1 subgoal):\n 1. S.cod (local.map gf) = local.map (CopxC.cod gf)", "also"], ["proof (state)\nthis:\n  S.mkArr (local.set (CopxC.cod gf)) (local.set (CopxC.cod gf))\n   (\\<lambda>x. x) =\n  S.mkArr (local.set (CopxC.cod gf)) (local.set (CopxC.cod gf))\n   (\\<phi> (CopxC.cod gf) \\<circ>\n    (\\<lambda>h.\n        snd (CopxC.cod gf) \\<cdot> h \\<cdot> fst (CopxC.cod gf)) \\<circ>\n    \\<psi> (CopxC.cod gf))\n\ngoal (1 subgoal):\n 1. S.cod (local.map gf) = local.map (CopxC.cod gf)", "have \"... = map (CopxC.cod gf)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.mkArr (local.set (CopxC.cod gf)) (local.set (CopxC.cod gf))\n     (\\<phi> (CopxC.cod gf) \\<circ>\n      (\\<lambda>h.\n          snd (CopxC.cod gf) \\<cdot> h \\<cdot> fst (CopxC.cod gf)) \\<circ>\n      \\<psi> (CopxC.cod gf)) =\n    local.map (CopxC.cod gf)", "using gf map_def"], ["proof (prove)\nusing this:\n  CopxC.arr gf\n  local.map ?gf =\n  (if CopxC.arr ?gf\n   then S.mkArr (local.set (CopxC.dom ?gf)) (local.set (CopxC.cod ?gf))\n         (\\<phi> (CopxC.cod ?gf) \\<circ>\n          (\\<lambda>h. snd ?gf \\<cdot> h \\<cdot> fst ?gf) \\<circ>\n          \\<psi> (CopxC.dom ?gf))\n   else S.null)\n\ngoal (1 subgoal):\n 1. S.mkArr (local.set (CopxC.cod gf)) (local.set (CopxC.cod gf))\n     (\\<phi> (CopxC.cod gf) \\<circ>\n      (\\<lambda>h.\n          snd (CopxC.cod gf) \\<cdot> h \\<cdot> fst (CopxC.cod gf)) \\<circ>\n      \\<psi> (CopxC.cod gf)) =\n    local.map (CopxC.cod gf)", "by simp"], ["proof (state)\nthis:\n  S.mkArr (local.set (CopxC.cod gf)) (local.set (CopxC.cod gf))\n   (\\<phi> (CopxC.cod gf) \\<circ>\n    (\\<lambda>h.\n        snd (CopxC.cod gf) \\<cdot> h \\<cdot> fst (CopxC.cod gf)) \\<circ>\n    \\<psi> (CopxC.cod gf)) =\n  local.map (CopxC.cod gf)\n\ngoal (1 subgoal):\n 1. S.cod (local.map gf) = local.map (CopxC.cod gf)", "finally"], ["proof (chain)\npicking this:\n  S.cod (local.map gf) = local.map (CopxC.cod gf)", "show ?thesis"], ["proof (prove)\nusing this:\n  S.cod (local.map gf) = local.map (CopxC.cod gf)\n\ngoal (1 subgoal):\n 1. S.cod (local.map gf) = local.map (CopxC.cod gf)", "by auto"], ["proof (state)\nthis:\n  S.cod (local.map gf) = local.map (CopxC.cod gf)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S.cod (local.map gf) = local.map (CopxC.cod gf)\n\ngoal (1 subgoal):\n 1. \\<And>g f.\n       CopxC.seq g f \\<Longrightarrow>\n       local.map (g \\<odot> f) = local.map g \\<cdot>\\<^sub>S local.map f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g f.\n       CopxC.seq g f \\<Longrightarrow>\n       local.map (g \\<odot> f) = local.map g \\<cdot>\\<^sub>S local.map f", "fix gf gf'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g f.\n       CopxC.seq g f \\<Longrightarrow>\n       local.map (g \\<odot> f) = local.map g \\<cdot>\\<^sub>S local.map f", "assume gf': \"CopxC.seq gf' gf\""], ["proof (state)\nthis:\n  CopxC.seq gf' gf\n\ngoal (1 subgoal):\n 1. \\<And>g f.\n       CopxC.seq g f \\<Longrightarrow>\n       local.map (g \\<odot> f) = local.map g \\<cdot>\\<^sub>S local.map f", "hence seq: \"C.arr (fst gf) \\<and> C.arr (snd gf) \\<and> C.dom (snd gf') = C.cod (snd gf) \\<and>\n                  C.arr (fst gf') \\<and> C.arr (snd gf') \\<and> C.dom (fst gf) = C.cod (fst gf')\""], ["proof (prove)\nusing this:\n  CopxC.seq gf' gf\n\ngoal (1 subgoal):\n 1. C.arr (fst gf) \\<and>\n    C.arr (snd gf) \\<and>\n    C.dom (snd gf') = C.cod (snd gf) \\<and>\n    C.arr (fst gf') \\<and>\n    C.arr (snd gf') \\<and> C.dom (fst gf) = C.cod (fst gf')", "by (elim CopxC.seqE C.seqE, auto)"], ["proof (state)\nthis:\n  C.arr (fst gf) \\<and>\n  C.arr (snd gf) \\<and>\n  C.dom (snd gf') = C.cod (snd gf) \\<and>\n  C.arr (fst gf') \\<and>\n  C.arr (snd gf') \\<and> C.dom (fst gf) = C.cod (fst gf')\n\ngoal (1 subgoal):\n 1. \\<And>g f.\n       CopxC.seq g f \\<Longrightarrow>\n       local.map (g \\<odot> f) = local.map g \\<cdot>\\<^sub>S local.map f", "have 0: \"S.arr (map (CopxC.comp gf' gf))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.arr (local.map (gf' \\<odot> gf))", "using gf' arr_map"], ["proof (prove)\nusing this:\n  CopxC.seq gf' gf\n  CopxC.arr ?gf \\<Longrightarrow> S.arr (local.map ?gf)\n\ngoal (1 subgoal):\n 1. S.arr (local.map (gf' \\<odot> gf))", "by blast"], ["proof (state)\nthis:\n  S.arr (local.map (gf' \\<odot> gf))\n\ngoal (1 subgoal):\n 1. \\<And>g f.\n       CopxC.seq g f \\<Longrightarrow>\n       local.map (g \\<odot> f) = local.map g \\<cdot>\\<^sub>S local.map f", "have 1: \"map (gf' \\<odot> gf) =\n                    S.mkArr (set (CopxC.dom gf)) (set (CopxC.cod gf'))\n                            (\\<phi> (CopxC.cod gf') o (\\<lambda>h. snd (gf' \\<odot> gf) \\<cdot> h \\<cdot> fst (gf' \\<odot> gf))\n                                               o \\<psi> (CopxC.dom gf))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.map (gf' \\<odot> gf) =\n    S.mkArr (local.set (CopxC.dom gf)) (local.set (CopxC.cod gf'))\n     (\\<phi> (CopxC.cod gf') \\<circ>\n      (\\<lambda>h.\n          snd (gf' \\<odot> gf) \\<cdot>\n          h \\<cdot> fst (gf' \\<odot> gf)) \\<circ>\n      \\<psi> (CopxC.dom gf))", "using gf' map_def"], ["proof (prove)\nusing this:\n  CopxC.seq gf' gf\n  local.map ?gf =\n  (if CopxC.arr ?gf\n   then S.mkArr (local.set (CopxC.dom ?gf)) (local.set (CopxC.cod ?gf))\n         (\\<phi> (CopxC.cod ?gf) \\<circ>\n          (\\<lambda>h. snd ?gf \\<cdot> h \\<cdot> fst ?gf) \\<circ>\n          \\<psi> (CopxC.dom ?gf))\n   else S.null)\n\ngoal (1 subgoal):\n 1. local.map (gf' \\<odot> gf) =\n    S.mkArr (local.set (CopxC.dom gf)) (local.set (CopxC.cod gf'))\n     (\\<phi> (CopxC.cod gf') \\<circ>\n      (\\<lambda>h.\n          snd (gf' \\<odot> gf) \\<cdot>\n          h \\<cdot> fst (gf' \\<odot> gf)) \\<circ>\n      \\<psi> (CopxC.dom gf))", "using CopxC.cod_comp CopxC.dom_comp"], ["proof (prove)\nusing this:\n  CopxC.seq gf' gf\n  local.map ?gf =\n  (if CopxC.arr ?gf\n   then S.mkArr (local.set (CopxC.dom ?gf)) (local.set (CopxC.cod ?gf))\n         (\\<phi> (CopxC.cod ?gf) \\<circ>\n          (\\<lambda>h. snd ?gf \\<cdot> h \\<cdot> fst ?gf) \\<circ>\n          \\<psi> (CopxC.dom ?gf))\n   else S.null)\n  CopxC.seq ?g ?f \\<Longrightarrow> CopxC.cod (?g \\<odot> ?f) = CopxC.cod ?g\n  CopxC.seq ?g ?f \\<Longrightarrow> CopxC.dom (?g \\<odot> ?f) = CopxC.dom ?f\n\ngoal (1 subgoal):\n 1. local.map (gf' \\<odot> gf) =\n    S.mkArr (local.set (CopxC.dom gf)) (local.set (CopxC.cod gf'))\n     (\\<phi> (CopxC.cod gf') \\<circ>\n      (\\<lambda>h.\n          snd (gf' \\<odot> gf) \\<cdot>\n          h \\<cdot> fst (gf' \\<odot> gf)) \\<circ>\n      \\<psi> (CopxC.dom gf))", "by auto"], ["proof (state)\nthis:\n  local.map (gf' \\<odot> gf) =\n  S.mkArr (local.set (CopxC.dom gf)) (local.set (CopxC.cod gf'))\n   (\\<phi> (CopxC.cod gf') \\<circ>\n    (\\<lambda>h.\n        snd (gf' \\<odot> gf) \\<cdot> h \\<cdot> fst (gf' \\<odot> gf)) \\<circ>\n    \\<psi> (CopxC.dom gf))\n\ngoal (1 subgoal):\n 1. \\<And>g f.\n       CopxC.seq g f \\<Longrightarrow>\n       local.map (g \\<odot> f) = local.map g \\<cdot>\\<^sub>S local.map f", "also"], ["proof (state)\nthis:\n  local.map (gf' \\<odot> gf) =\n  S.mkArr (local.set (CopxC.dom gf)) (local.set (CopxC.cod gf'))\n   (\\<phi> (CopxC.cod gf') \\<circ>\n    (\\<lambda>h.\n        snd (gf' \\<odot> gf) \\<cdot> h \\<cdot> fst (gf' \\<odot> gf)) \\<circ>\n    \\<psi> (CopxC.dom gf))\n\ngoal (1 subgoal):\n 1. \\<And>g f.\n       CopxC.seq g f \\<Longrightarrow>\n       local.map (g \\<odot> f) = local.map g \\<cdot>\\<^sub>S local.map f", "have \"... = S.mkArr (set (CopxC.dom gf)) (set (CopxC.cod gf'))\n                               (\\<phi> (CopxC.cod gf') \\<circ> (\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ> \\<psi> (CopxC.dom gf')\n                                \\<circ>\n                               (\\<phi> (CopxC.cod gf) \\<circ> (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf) \\<circ> \\<psi> (CopxC.dom gf)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.mkArr (local.set (CopxC.dom gf)) (local.set (CopxC.cod gf'))\n     (\\<phi> (CopxC.cod gf') \\<circ>\n      (\\<lambda>h.\n          snd (gf' \\<odot> gf) \\<cdot>\n          h \\<cdot> fst (gf' \\<odot> gf)) \\<circ>\n      \\<psi> (CopxC.dom gf)) =\n    S.mkArr (local.set (CopxC.dom gf)) (local.set (CopxC.cod gf'))\n     (\\<phi> (CopxC.cod gf') \\<circ>\n      (\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ>\n      \\<psi> (CopxC.dom gf') \\<circ>\n      (\\<phi> (CopxC.cod gf) \\<circ>\n       (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf) \\<circ>\n       \\<psi> (CopxC.dom gf)))", "proof (intro S.mkArr_eqI')"], ["proof (state)\ngoal (2 subgoals):\n 1. S.arr\n     (S.mkArr (local.set (CopxC.dom gf)) (local.set (CopxC.cod gf'))\n       (\\<phi> (CopxC.cod gf') \\<circ>\n        (\\<lambda>h.\n            snd (gf' \\<odot> gf) \\<cdot>\n            h \\<cdot> fst (gf' \\<odot> gf)) \\<circ>\n        \\<psi> (CopxC.dom gf)))\n 2. \\<And>x.\n       x \\<in> local.set (CopxC.dom gf) \\<Longrightarrow>\n       (\\<phi> (CopxC.cod gf') \\<circ>\n        (\\<lambda>h.\n            snd (gf' \\<odot> gf) \\<cdot>\n            h \\<cdot> fst (gf' \\<odot> gf)) \\<circ>\n        \\<psi> (CopxC.dom gf))\n        x =\n       (\\<phi> (CopxC.cod gf') \\<circ>\n        (\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ>\n        \\<psi> (CopxC.dom gf') \\<circ>\n        (\\<phi> (CopxC.cod gf) \\<circ>\n         (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf) \\<circ>\n         \\<psi> (CopxC.dom gf)))\n        x", "show \"S.arr (S.mkArr (set (CopxC.dom gf)) (set (CopxC.cod gf'))\n                             (\\<phi> (CopxC.cod gf') \\<circ> (\\<lambda>h. snd (gf' \\<odot> gf) \\<cdot> h \\<cdot> fst (gf' \\<odot> gf))\n                                                \\<circ> \\<psi> (CopxC.dom gf)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.arr\n     (S.mkArr (local.set (CopxC.dom gf)) (local.set (CopxC.cod gf'))\n       (\\<phi> (CopxC.cod gf') \\<circ>\n        (\\<lambda>h.\n            snd (gf' \\<odot> gf) \\<cdot>\n            h \\<cdot> fst (gf' \\<odot> gf)) \\<circ>\n        \\<psi> (CopxC.dom gf)))", "using 0 1"], ["proof (prove)\nusing this:\n  S.arr (local.map (gf' \\<odot> gf))\n  local.map (gf' \\<odot> gf) =\n  S.mkArr (local.set (CopxC.dom gf)) (local.set (CopxC.cod gf'))\n   (\\<phi> (CopxC.cod gf') \\<circ>\n    (\\<lambda>h.\n        snd (gf' \\<odot> gf) \\<cdot> h \\<cdot> fst (gf' \\<odot> gf)) \\<circ>\n    \\<psi> (CopxC.dom gf))\n\ngoal (1 subgoal):\n 1. S.arr\n     (S.mkArr (local.set (CopxC.dom gf)) (local.set (CopxC.cod gf'))\n       (\\<phi> (CopxC.cod gf') \\<circ>\n        (\\<lambda>h.\n            snd (gf' \\<odot> gf) \\<cdot>\n            h \\<cdot> fst (gf' \\<odot> gf)) \\<circ>\n        \\<psi> (CopxC.dom gf)))", "by simp"], ["proof (state)\nthis:\n  S.arr\n   (S.mkArr (local.set (CopxC.dom gf)) (local.set (CopxC.cod gf'))\n     (\\<phi> (CopxC.cod gf') \\<circ>\n      (\\<lambda>h.\n          snd (gf' \\<odot> gf) \\<cdot>\n          h \\<cdot> fst (gf' \\<odot> gf)) \\<circ>\n      \\<psi> (CopxC.dom gf)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> local.set (CopxC.dom gf) \\<Longrightarrow>\n       (\\<phi> (CopxC.cod gf') \\<circ>\n        (\\<lambda>h.\n            snd (gf' \\<odot> gf) \\<cdot>\n            h \\<cdot> fst (gf' \\<odot> gf)) \\<circ>\n        \\<psi> (CopxC.dom gf))\n        x =\n       (\\<phi> (CopxC.cod gf') \\<circ>\n        (\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ>\n        \\<psi> (CopxC.dom gf') \\<circ>\n        (\\<phi> (CopxC.cod gf) \\<circ>\n         (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf) \\<circ>\n         \\<psi> (CopxC.dom gf)))\n        x", "show \"\\<And>x. x \\<in> set (CopxC.dom gf) \\<Longrightarrow>\n                     (\\<phi> (CopxC.cod gf') \\<circ> (\\<lambda>h. snd (gf' \\<odot> gf) \\<cdot> h \\<cdot> fst (gf' \\<odot> gf)) \\<circ>\n                      \\<psi> (CopxC.dom gf)) x =\n                     (\\<phi> (CopxC.cod gf') \\<circ> (\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ> \\<psi> (CopxC.dom gf') \\<circ>\n                      (\\<phi> (CopxC.cod gf) \\<circ> (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf) \\<circ> \\<psi> (CopxC.dom gf))) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> local.set (CopxC.dom gf) \\<Longrightarrow>\n       (\\<phi> (CopxC.cod gf') \\<circ>\n        (\\<lambda>h.\n            snd (gf' \\<odot> gf) \\<cdot>\n            h \\<cdot> fst (gf' \\<odot> gf)) \\<circ>\n        \\<psi> (CopxC.dom gf))\n        x =\n       (\\<phi> (CopxC.cod gf') \\<circ>\n        (\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ>\n        \\<psi> (CopxC.dom gf') \\<circ>\n        (\\<phi> (CopxC.cod gf) \\<circ>\n         (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf) \\<circ>\n         \\<psi> (CopxC.dom gf)))\n        x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> local.set (CopxC.dom gf) \\<Longrightarrow>\n       (\\<phi> (CopxC.cod gf') \\<circ>\n        (\\<lambda>h.\n            snd (gf' \\<odot> gf) \\<cdot>\n            h \\<cdot> fst (gf' \\<odot> gf)) \\<circ>\n        \\<psi> (CopxC.dom gf))\n        x =\n       (\\<phi> (CopxC.cod gf') \\<circ>\n        (\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ>\n        \\<psi> (CopxC.dom gf') \\<circ>\n        (\\<phi> (CopxC.cod gf) \\<circ>\n         (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf) \\<circ>\n         \\<psi> (CopxC.dom gf)))\n        x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> local.set (CopxC.dom gf) \\<Longrightarrow>\n       (\\<phi> (CopxC.cod gf') \\<circ>\n        (\\<lambda>h.\n            snd (gf' \\<odot> gf) \\<cdot>\n            h \\<cdot> fst (gf' \\<odot> gf)) \\<circ>\n        \\<psi> (CopxC.dom gf))\n        x =\n       (\\<phi> (CopxC.cod gf') \\<circ>\n        (\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ>\n        \\<psi> (CopxC.dom gf') \\<circ>\n        (\\<phi> (CopxC.cod gf) \\<circ>\n         (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf) \\<circ>\n         \\<psi> (CopxC.dom gf)))\n        x", "assume \"x \\<in> set (CopxC.dom gf)\""], ["proof (state)\nthis:\n  x \\<in> local.set (CopxC.dom gf)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> local.set (CopxC.dom gf) \\<Longrightarrow>\n       (\\<phi> (CopxC.cod gf') \\<circ>\n        (\\<lambda>h.\n            snd (gf' \\<odot> gf) \\<cdot>\n            h \\<cdot> fst (gf' \\<odot> gf)) \\<circ>\n        \\<psi> (CopxC.dom gf))\n        x =\n       (\\<phi> (CopxC.cod gf') \\<circ>\n        (\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ>\n        \\<psi> (CopxC.dom gf') \\<circ>\n        (\\<phi> (CopxC.cod gf) \\<circ>\n         (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf) \\<circ>\n         \\<psi> (CopxC.dom gf)))\n        x", "hence x: \"x \\<in> set (C.cod (fst gf), C.dom (snd gf))\""], ["proof (prove)\nusing this:\n  x \\<in> local.set (CopxC.dom gf)\n\ngoal (1 subgoal):\n 1. x \\<in> local.set (C.cod (fst gf), C.dom (snd gf))", "using gf' CopxC.seqE"], ["proof (prove)\nusing this:\n  x \\<in> local.set (CopxC.dom gf)\n  CopxC.seq gf' gf\n  \\<lbrakk>CopxC.seq ?g ?f;\n   \\<lbrakk>Cop.seq (fst ?g) (fst ?f); C.seq (snd ?g) (snd ?f)\\<rbrakk>\n   \\<Longrightarrow> ?T\\<rbrakk>\n  \\<Longrightarrow> ?T\n\ngoal (1 subgoal):\n 1. x \\<in> local.set (C.cod (fst gf), C.dom (snd gf))", "by (elim CopxC.seqE, fastforce)"], ["proof (state)\nthis:\n  x \\<in> local.set (C.cod (fst gf), C.dom (snd gf))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> local.set (CopxC.dom gf) \\<Longrightarrow>\n       (\\<phi> (CopxC.cod gf') \\<circ>\n        (\\<lambda>h.\n            snd (gf' \\<odot> gf) \\<cdot>\n            h \\<cdot> fst (gf' \\<odot> gf)) \\<circ>\n        \\<psi> (CopxC.dom gf))\n        x =\n       (\\<phi> (CopxC.cod gf') \\<circ>\n        (\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ>\n        \\<psi> (CopxC.dom gf') \\<circ>\n        (\\<phi> (CopxC.cod gf) \\<circ>\n         (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf) \\<circ>\n         \\<psi> (CopxC.dom gf)))\n        x", "show \"(\\<phi> (CopxC.cod gf') \\<circ> (\\<lambda>h. snd (gf' \\<odot> gf) \\<cdot> h \\<cdot> fst (gf' \\<odot> gf)) \\<circ>\n                 \\<psi> (CopxC.dom gf)) x =\n                (\\<phi> (CopxC.cod gf') \\<circ> (\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ> \\<psi> (CopxC.dom gf') \\<circ>\n                 (\\<phi> (CopxC.cod gf) \\<circ> (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf) \\<circ> \\<psi> (CopxC.dom gf))) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<phi> (CopxC.cod gf') \\<circ>\n     (\\<lambda>h.\n         snd (gf' \\<odot> gf) \\<cdot>\n         h \\<cdot> fst (gf' \\<odot> gf)) \\<circ>\n     \\<psi> (CopxC.dom gf))\n     x =\n    (\\<phi> (CopxC.cod gf') \\<circ>\n     (\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ>\n     \\<psi> (CopxC.dom gf') \\<circ>\n     (\\<phi> (CopxC.cod gf) \\<circ>\n      (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf) \\<circ>\n      \\<psi> (CopxC.dom gf)))\n     x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<phi> (CopxC.cod gf') \\<circ>\n     (\\<lambda>h.\n         snd (gf' \\<odot> gf) \\<cdot>\n         h \\<cdot> fst (gf' \\<odot> gf)) \\<circ>\n     \\<psi> (CopxC.dom gf))\n     x =\n    (\\<phi> (CopxC.cod gf') \\<circ>\n     (\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ>\n     \\<psi> (CopxC.dom gf') \\<circ>\n     (\\<phi> (CopxC.cod gf) \\<circ>\n      (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf) \\<circ>\n      \\<psi> (CopxC.dom gf)))\n     x", "have \"(\\<phi> (CopxC.cod gf') o (\\<lambda>h. snd (gf' \\<odot> gf) \\<cdot> h \\<cdot> fst (gf' \\<odot> gf))\n                                     o \\<psi> (CopxC.dom gf)) x =\n                  \\<phi> (CopxC.cod gf') (snd (gf' \\<odot> gf) \\<cdot> \\<psi> (CopxC.dom gf) x \\<cdot> fst (gf' \\<odot> gf))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<phi> (CopxC.cod gf') \\<circ>\n     (\\<lambda>h.\n         snd (gf' \\<odot> gf) \\<cdot>\n         h \\<cdot> fst (gf' \\<odot> gf)) \\<circ>\n     \\<psi> (CopxC.dom gf))\n     x =\n    \\<phi> (CopxC.cod gf')\n     (snd (gf' \\<odot> gf) \\<cdot>\n      \\<psi> (CopxC.dom gf) x \\<cdot> fst (gf' \\<odot> gf))", "by simp"], ["proof (state)\nthis:\n  (\\<phi> (CopxC.cod gf') \\<circ>\n   (\\<lambda>h.\n       snd (gf' \\<odot> gf) \\<cdot> h \\<cdot> fst (gf' \\<odot> gf)) \\<circ>\n   \\<psi> (CopxC.dom gf))\n   x =\n  \\<phi> (CopxC.cod gf')\n   (snd (gf' \\<odot> gf) \\<cdot>\n    \\<psi> (CopxC.dom gf) x \\<cdot> fst (gf' \\<odot> gf))\n\ngoal (1 subgoal):\n 1. (\\<phi> (CopxC.cod gf') \\<circ>\n     (\\<lambda>h.\n         snd (gf' \\<odot> gf) \\<cdot>\n         h \\<cdot> fst (gf' \\<odot> gf)) \\<circ>\n     \\<psi> (CopxC.dom gf))\n     x =\n    (\\<phi> (CopxC.cod gf') \\<circ>\n     (\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ>\n     \\<psi> (CopxC.dom gf') \\<circ>\n     (\\<phi> (CopxC.cod gf) \\<circ>\n      (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf) \\<circ>\n      \\<psi> (CopxC.dom gf)))\n     x", "also"], ["proof (state)\nthis:\n  (\\<phi> (CopxC.cod gf') \\<circ>\n   (\\<lambda>h.\n       snd (gf' \\<odot> gf) \\<cdot> h \\<cdot> fst (gf' \\<odot> gf)) \\<circ>\n   \\<psi> (CopxC.dom gf))\n   x =\n  \\<phi> (CopxC.cod gf')\n   (snd (gf' \\<odot> gf) \\<cdot>\n    \\<psi> (CopxC.dom gf) x \\<cdot> fst (gf' \\<odot> gf))\n\ngoal (1 subgoal):\n 1. (\\<phi> (CopxC.cod gf') \\<circ>\n     (\\<lambda>h.\n         snd (gf' \\<odot> gf) \\<cdot>\n         h \\<cdot> fst (gf' \\<odot> gf)) \\<circ>\n     \\<psi> (CopxC.dom gf))\n     x =\n    (\\<phi> (CopxC.cod gf') \\<circ>\n     (\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ>\n     \\<psi> (CopxC.dom gf') \\<circ>\n     (\\<phi> (CopxC.cod gf) \\<circ>\n      (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf) \\<circ>\n      \\<psi> (CopxC.dom gf)))\n     x", "have \"... = \\<phi> (CopxC.cod gf')\n                               (((\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ> \\<psi> (CopxC.dom gf') \\<circ>\n                                 (\\<phi> (CopxC.dom gf') \\<circ> (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf)))\n                                (\\<psi> (CopxC.dom gf) x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> (CopxC.cod gf')\n     (snd (gf' \\<odot> gf) \\<cdot>\n      \\<psi> (CopxC.dom gf) x \\<cdot> fst (gf' \\<odot> gf)) =\n    \\<phi> (CopxC.cod gf')\n     (((\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ>\n       \\<psi> (CopxC.dom gf') \\<circ>\n       (\\<phi> (CopxC.dom gf') \\<circ>\n        (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf)))\n       (\\<psi> (CopxC.dom gf) x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<phi> (CopxC.cod gf')\n     (snd (gf' \\<odot> gf) \\<cdot>\n      \\<psi> (CopxC.dom gf) x \\<cdot> fst (gf' \\<odot> gf)) =\n    \\<phi> (CopxC.cod gf')\n     (((\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ>\n       \\<psi> (CopxC.dom gf') \\<circ>\n       (\\<phi> (CopxC.dom gf') \\<circ>\n        (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf)))\n       (\\<psi> (CopxC.dom gf) x))", "have \"C.ide (C.cod (fst gf)) \\<and> C.ide (C.dom (snd gf))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C.ide (C.cod (fst gf)) \\<and> C.ide (C.dom (snd gf))", "using gf'"], ["proof (prove)\nusing this:\n  CopxC.seq gf' gf\n\ngoal (1 subgoal):\n 1. C.ide (C.cod (fst gf)) \\<and> C.ide (C.dom (snd gf))", "by (elim CopxC.seqE, auto)"], ["proof (state)\nthis:\n  C.ide (C.cod (fst gf)) \\<and> C.ide (C.dom (snd gf))\n\ngoal (1 subgoal):\n 1. \\<phi> (CopxC.cod gf')\n     (snd (gf' \\<odot> gf) \\<cdot>\n      \\<psi> (CopxC.dom gf) x \\<cdot> fst (gf' \\<odot> gf)) =\n    \\<phi> (CopxC.cod gf')\n     (((\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ>\n       \\<psi> (CopxC.dom gf') \\<circ>\n       (\\<phi> (CopxC.dom gf') \\<circ>\n        (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf)))\n       (\\<psi> (CopxC.dom gf) x))", "hence \"\\<guillemotleft>\\<psi> (C.cod (fst gf), C.dom (snd gf)) x : C.cod (fst gf) \\<rightarrow> C.dom (snd gf)\\<guillemotright>\""], ["proof (prove)\nusing this:\n  C.ide (C.cod (fst gf)) \\<and> C.ide (C.dom (snd gf))\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<psi> (C.cod (fst gf), C.dom (snd gf))\n                     x : C.cod\n                          (fst gf) \\<rightarrow> C.dom\n            (snd gf)\\<guillemotright>", "using x \\<psi>_mapsto"], ["proof (prove)\nusing this:\n  C.ide (C.cod (fst gf)) \\<and> C.ide (C.dom (snd gf))\n  x \\<in> local.set (C.cod (fst gf), C.dom (snd gf))\n  \\<lbrakk>C.ide ?b; C.ide ?a\\<rbrakk>\n  \\<Longrightarrow> \\<psi> (?b, ?a)\n                    \\<in> local.set (?b, ?a) \\<rightarrow> C.hom ?b ?a\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<psi> (C.cod (fst gf), C.dom (snd gf))\n                     x : C.cod\n                          (fst gf) \\<rightarrow> C.dom\n            (snd gf)\\<guillemotright>", "by auto"], ["proof (state)\nthis:\n  \\<guillemotleft>\\<psi> (C.cod (fst gf), C.dom (snd gf))\n                   x : C.cod\n                        (fst gf) \\<rightarrow> C.dom\n          (snd gf)\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<phi> (CopxC.cod gf')\n     (snd (gf' \\<odot> gf) \\<cdot>\n      \\<psi> (CopxC.dom gf) x \\<cdot> fst (gf' \\<odot> gf)) =\n    \\<phi> (CopxC.cod gf')\n     (((\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ>\n       \\<psi> (CopxC.dom gf') \\<circ>\n       (\\<phi> (CopxC.dom gf') \\<circ>\n        (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf)))\n       (\\<psi> (CopxC.dom gf) x))", "hence \"\\<guillemotleft>snd gf \\<cdot> \\<psi> (C.cod (fst gf), C.dom (snd gf)) x \\<cdot> fst gf :\n                        C.cod (fst gf') \\<rightarrow> C.dom (snd gf')\\<guillemotright>\""], ["proof (prove)\nusing this:\n  \\<guillemotleft>\\<psi> (C.cod (fst gf), C.dom (snd gf))\n                   x : C.cod\n                        (fst gf) \\<rightarrow> C.dom\n          (snd gf)\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>snd gf \\<cdot>\n                    \\<psi> (C.cod (fst gf), C.dom (snd gf)) x \\<cdot>\n                    fst gf : C.cod\n                              (fst gf') \\<rightarrow> C.dom\n                 (snd gf')\\<guillemotright>", "using x seq"], ["proof (prove)\nusing this:\n  \\<guillemotleft>\\<psi> (C.cod (fst gf), C.dom (snd gf))\n                   x : C.cod\n                        (fst gf) \\<rightarrow> C.dom\n          (snd gf)\\<guillemotright>\n  x \\<in> local.set (C.cod (fst gf), C.dom (snd gf))\n  C.arr (fst gf) \\<and>\n  C.arr (snd gf) \\<and>\n  C.dom (snd gf') = C.cod (snd gf) \\<and>\n  C.arr (fst gf') \\<and>\n  C.arr (snd gf') \\<and> C.dom (fst gf) = C.cod (fst gf')\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>snd gf \\<cdot>\n                    \\<psi> (C.cod (fst gf), C.dom (snd gf)) x \\<cdot>\n                    fst gf : C.cod\n                              (fst gf') \\<rightarrow> C.dom\n                 (snd gf')\\<guillemotright>", "by auto"], ["proof (state)\nthis:\n  \\<guillemotleft>snd gf \\<cdot>\n                  \\<psi> (C.cod (fst gf), C.dom (snd gf)) x \\<cdot>\n                  fst gf : C.cod\n                            (fst gf') \\<rightarrow> C.dom\n               (snd gf')\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<phi> (CopxC.cod gf')\n     (snd (gf' \\<odot> gf) \\<cdot>\n      \\<psi> (CopxC.dom gf) x \\<cdot> fst (gf' \\<odot> gf)) =\n    \\<phi> (CopxC.cod gf')\n     (((\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ>\n       \\<psi> (CopxC.dom gf') \\<circ>\n       (\\<phi> (CopxC.dom gf') \\<circ>\n        (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf)))\n       (\\<psi> (CopxC.dom gf) x))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<guillemotleft>snd gf \\<cdot>\n                  \\<psi> (C.cod (fst gf), C.dom (snd gf)) x \\<cdot>\n                  fst gf : C.cod\n                            (fst gf') \\<rightarrow> C.dom\n               (snd gf')\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<phi> (CopxC.cod gf')\n     (snd (gf' \\<odot> gf) \\<cdot>\n      \\<psi> (CopxC.dom gf) x \\<cdot> fst (gf' \\<odot> gf)) =\n    \\<phi> (CopxC.cod gf')\n     (((\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ>\n       \\<psi> (CopxC.dom gf') \\<circ>\n       (\\<phi> (CopxC.dom gf') \\<circ>\n        (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf)))\n       (\\<psi> (CopxC.dom gf) x))", "using seq \\<psi>_\\<phi> C.comp_assoc"], ["proof (prove)\nusing this:\n  \\<guillemotleft>snd gf \\<cdot>\n                  \\<psi> (C.cod (fst gf), C.dom (snd gf)) x \\<cdot>\n                  fst gf : C.cod\n                            (fst gf') \\<rightarrow> C.dom\n               (snd gf')\\<guillemotright>\n  C.arr (fst gf) \\<and>\n  C.arr (snd gf) \\<and>\n  C.dom (snd gf') = C.cod (snd gf) \\<and>\n  C.arr (fst gf') \\<and>\n  C.arr (snd gf') \\<and> C.dom (fst gf) = C.cod (fst gf')\n  \\<guillemotleft>?f : ?b \\<rightarrow> ?a\\<guillemotright> \\<Longrightarrow>\n  \\<psi> (?b, ?a) (\\<phi> (?b, ?a) ?f) = ?f\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. \\<phi> (CopxC.cod gf')\n     (snd (gf' \\<odot> gf) \\<cdot>\n      \\<psi> (CopxC.dom gf) x \\<cdot> fst (gf' \\<odot> gf)) =\n    \\<phi> (CopxC.cod gf')\n     (((\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ>\n       \\<psi> (CopxC.dom gf') \\<circ>\n       (\\<phi> (CopxC.dom gf') \\<circ>\n        (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf)))\n       (\\<psi> (CopxC.dom gf) x))", "by auto"], ["proof (state)\nthis:\n  \\<phi> (CopxC.cod gf')\n   (snd (gf' \\<odot> gf) \\<cdot>\n    \\<psi> (CopxC.dom gf) x \\<cdot> fst (gf' \\<odot> gf)) =\n  \\<phi> (CopxC.cod gf')\n   (((\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ>\n     \\<psi> (CopxC.dom gf') \\<circ>\n     (\\<phi> (CopxC.dom gf') \\<circ>\n      (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf)))\n     (\\<psi> (CopxC.dom gf) x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<phi> (CopxC.cod gf')\n   (snd (gf' \\<odot> gf) \\<cdot>\n    \\<psi> (CopxC.dom gf) x \\<cdot> fst (gf' \\<odot> gf)) =\n  \\<phi> (CopxC.cod gf')\n   (((\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ>\n     \\<psi> (CopxC.dom gf') \\<circ>\n     (\\<phi> (CopxC.dom gf') \\<circ>\n      (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf)))\n     (\\<psi> (CopxC.dom gf) x))\n\ngoal (1 subgoal):\n 1. (\\<phi> (CopxC.cod gf') \\<circ>\n     (\\<lambda>h.\n         snd (gf' \\<odot> gf) \\<cdot>\n         h \\<cdot> fst (gf' \\<odot> gf)) \\<circ>\n     \\<psi> (CopxC.dom gf))\n     x =\n    (\\<phi> (CopxC.cod gf') \\<circ>\n     (\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ>\n     \\<psi> (CopxC.dom gf') \\<circ>\n     (\\<phi> (CopxC.cod gf) \\<circ>\n      (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf) \\<circ>\n      \\<psi> (CopxC.dom gf)))\n     x", "also"], ["proof (state)\nthis:\n  \\<phi> (CopxC.cod gf')\n   (snd (gf' \\<odot> gf) \\<cdot>\n    \\<psi> (CopxC.dom gf) x \\<cdot> fst (gf' \\<odot> gf)) =\n  \\<phi> (CopxC.cod gf')\n   (((\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ>\n     \\<psi> (CopxC.dom gf') \\<circ>\n     (\\<phi> (CopxC.dom gf') \\<circ>\n      (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf)))\n     (\\<psi> (CopxC.dom gf) x))\n\ngoal (1 subgoal):\n 1. (\\<phi> (CopxC.cod gf') \\<circ>\n     (\\<lambda>h.\n         snd (gf' \\<odot> gf) \\<cdot>\n         h \\<cdot> fst (gf' \\<odot> gf)) \\<circ>\n     \\<psi> (CopxC.dom gf))\n     x =\n    (\\<phi> (CopxC.cod gf') \\<circ>\n     (\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ>\n     \\<psi> (CopxC.dom gf') \\<circ>\n     (\\<phi> (CopxC.cod gf) \\<circ>\n      (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf) \\<circ>\n      \\<psi> (CopxC.dom gf)))\n     x", "have \"... = (\\<phi> (CopxC.cod gf') \\<circ> (\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ> \\<psi> (CopxC.dom gf') \\<circ>\n                              (\\<phi> (CopxC.dom gf') \\<circ> (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf) \\<circ> \\<psi> (CopxC.dom gf)))\n                              x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> (CopxC.cod gf')\n     (((\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ>\n       \\<psi> (CopxC.dom gf') \\<circ>\n       (\\<phi> (CopxC.dom gf') \\<circ>\n        (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf)))\n       (\\<psi> (CopxC.dom gf) x)) =\n    (\\<phi> (CopxC.cod gf') \\<circ>\n     (\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ>\n     \\<psi> (CopxC.dom gf') \\<circ>\n     (\\<phi> (CopxC.dom gf') \\<circ>\n      (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf) \\<circ>\n      \\<psi> (CopxC.dom gf)))\n     x", "by auto"], ["proof (state)\nthis:\n  \\<phi> (CopxC.cod gf')\n   (((\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ>\n     \\<psi> (CopxC.dom gf') \\<circ>\n     (\\<phi> (CopxC.dom gf') \\<circ>\n      (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf)))\n     (\\<psi> (CopxC.dom gf) x)) =\n  (\\<phi> (CopxC.cod gf') \\<circ>\n   (\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ>\n   \\<psi> (CopxC.dom gf') \\<circ>\n   (\\<phi> (CopxC.dom gf') \\<circ>\n    (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf) \\<circ>\n    \\<psi> (CopxC.dom gf)))\n   x\n\ngoal (1 subgoal):\n 1. (\\<phi> (CopxC.cod gf') \\<circ>\n     (\\<lambda>h.\n         snd (gf' \\<odot> gf) \\<cdot>\n         h \\<cdot> fst (gf' \\<odot> gf)) \\<circ>\n     \\<psi> (CopxC.dom gf))\n     x =\n    (\\<phi> (CopxC.cod gf') \\<circ>\n     (\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ>\n     \\<psi> (CopxC.dom gf') \\<circ>\n     (\\<phi> (CopxC.cod gf) \\<circ>\n      (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf) \\<circ>\n      \\<psi> (CopxC.dom gf)))\n     x", "finally"], ["proof (chain)\npicking this:\n  (\\<phi> (CopxC.cod gf') \\<circ>\n   (\\<lambda>h.\n       snd (gf' \\<odot> gf) \\<cdot> h \\<cdot> fst (gf' \\<odot> gf)) \\<circ>\n   \\<psi> (CopxC.dom gf))\n   x =\n  (\\<phi> (CopxC.cod gf') \\<circ>\n   (\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ>\n   \\<psi> (CopxC.dom gf') \\<circ>\n   (\\<phi> (CopxC.dom gf') \\<circ>\n    (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf) \\<circ>\n    \\<psi> (CopxC.dom gf)))\n   x", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<phi> (CopxC.cod gf') \\<circ>\n   (\\<lambda>h.\n       snd (gf' \\<odot> gf) \\<cdot> h \\<cdot> fst (gf' \\<odot> gf)) \\<circ>\n   \\<psi> (CopxC.dom gf))\n   x =\n  (\\<phi> (CopxC.cod gf') \\<circ>\n   (\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ>\n   \\<psi> (CopxC.dom gf') \\<circ>\n   (\\<phi> (CopxC.dom gf') \\<circ>\n    (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf) \\<circ>\n    \\<psi> (CopxC.dom gf)))\n   x\n\ngoal (1 subgoal):\n 1. (\\<phi> (CopxC.cod gf') \\<circ>\n     (\\<lambda>h.\n         snd (gf' \\<odot> gf) \\<cdot>\n         h \\<cdot> fst (gf' \\<odot> gf)) \\<circ>\n     \\<psi> (CopxC.dom gf))\n     x =\n    (\\<phi> (CopxC.cod gf') \\<circ>\n     (\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ>\n     \\<psi> (CopxC.dom gf') \\<circ>\n     (\\<phi> (CopxC.cod gf) \\<circ>\n      (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf) \\<circ>\n      \\<psi> (CopxC.dom gf)))\n     x", "using seq"], ["proof (prove)\nusing this:\n  (\\<phi> (CopxC.cod gf') \\<circ>\n   (\\<lambda>h.\n       snd (gf' \\<odot> gf) \\<cdot> h \\<cdot> fst (gf' \\<odot> gf)) \\<circ>\n   \\<psi> (CopxC.dom gf))\n   x =\n  (\\<phi> (CopxC.cod gf') \\<circ>\n   (\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ>\n   \\<psi> (CopxC.dom gf') \\<circ>\n   (\\<phi> (CopxC.dom gf') \\<circ>\n    (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf) \\<circ>\n    \\<psi> (CopxC.dom gf)))\n   x\n  C.arr (fst gf) \\<and>\n  C.arr (snd gf) \\<and>\n  C.dom (snd gf') = C.cod (snd gf) \\<and>\n  C.arr (fst gf') \\<and>\n  C.arr (snd gf') \\<and> C.dom (fst gf) = C.cod (fst gf')\n\ngoal (1 subgoal):\n 1. (\\<phi> (CopxC.cod gf') \\<circ>\n     (\\<lambda>h.\n         snd (gf' \\<odot> gf) \\<cdot>\n         h \\<cdot> fst (gf' \\<odot> gf)) \\<circ>\n     \\<psi> (CopxC.dom gf))\n     x =\n    (\\<phi> (CopxC.cod gf') \\<circ>\n     (\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ>\n     \\<psi> (CopxC.dom gf') \\<circ>\n     (\\<phi> (CopxC.cod gf) \\<circ>\n      (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf) \\<circ>\n      \\<psi> (CopxC.dom gf)))\n     x", "by simp"], ["proof (state)\nthis:\n  (\\<phi> (CopxC.cod gf') \\<circ>\n   (\\<lambda>h.\n       snd (gf' \\<odot> gf) \\<cdot> h \\<cdot> fst (gf' \\<odot> gf)) \\<circ>\n   \\<psi> (CopxC.dom gf))\n   x =\n  (\\<phi> (CopxC.cod gf') \\<circ>\n   (\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ>\n   \\<psi> (CopxC.dom gf') \\<circ>\n   (\\<phi> (CopxC.cod gf) \\<circ>\n    (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf) \\<circ>\n    \\<psi> (CopxC.dom gf)))\n   x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<phi> (CopxC.cod gf') \\<circ>\n   (\\<lambda>h.\n       snd (gf' \\<odot> gf) \\<cdot> h \\<cdot> fst (gf' \\<odot> gf)) \\<circ>\n   \\<psi> (CopxC.dom gf))\n   x =\n  (\\<phi> (CopxC.cod gf') \\<circ>\n   (\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ>\n   \\<psi> (CopxC.dom gf') \\<circ>\n   (\\<phi> (CopxC.cod gf) \\<circ>\n    (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf) \\<circ>\n    \\<psi> (CopxC.dom gf)))\n   x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> local.set (CopxC.dom gf) \\<Longrightarrow>\n  (\\<phi> (CopxC.cod gf') \\<circ>\n   (\\<lambda>h.\n       snd (gf' \\<odot> gf) \\<cdot> h \\<cdot> fst (gf' \\<odot> gf)) \\<circ>\n   \\<psi> (CopxC.dom gf))\n   ?x =\n  (\\<phi> (CopxC.cod gf') \\<circ>\n   (\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ>\n   \\<psi> (CopxC.dom gf') \\<circ>\n   (\\<phi> (CopxC.cod gf) \\<circ>\n    (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf) \\<circ>\n    \\<psi> (CopxC.dom gf)))\n   ?x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S.mkArr (local.set (CopxC.dom gf)) (local.set (CopxC.cod gf'))\n   (\\<phi> (CopxC.cod gf') \\<circ>\n    (\\<lambda>h.\n        snd (gf' \\<odot> gf) \\<cdot> h \\<cdot> fst (gf' \\<odot> gf)) \\<circ>\n    \\<psi> (CopxC.dom gf)) =\n  S.mkArr (local.set (CopxC.dom gf)) (local.set (CopxC.cod gf'))\n   (\\<phi> (CopxC.cod gf') \\<circ>\n    (\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ>\n    \\<psi> (CopxC.dom gf') \\<circ>\n    (\\<phi> (CopxC.cod gf) \\<circ>\n     (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf) \\<circ>\n     \\<psi> (CopxC.dom gf)))\n\ngoal (1 subgoal):\n 1. \\<And>g f.\n       CopxC.seq g f \\<Longrightarrow>\n       local.map (g \\<odot> f) = local.map g \\<cdot>\\<^sub>S local.map f", "also"], ["proof (state)\nthis:\n  S.mkArr (local.set (CopxC.dom gf)) (local.set (CopxC.cod gf'))\n   (\\<phi> (CopxC.cod gf') \\<circ>\n    (\\<lambda>h.\n        snd (gf' \\<odot> gf) \\<cdot> h \\<cdot> fst (gf' \\<odot> gf)) \\<circ>\n    \\<psi> (CopxC.dom gf)) =\n  S.mkArr (local.set (CopxC.dom gf)) (local.set (CopxC.cod gf'))\n   (\\<phi> (CopxC.cod gf') \\<circ>\n    (\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ>\n    \\<psi> (CopxC.dom gf') \\<circ>\n    (\\<phi> (CopxC.cod gf) \\<circ>\n     (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf) \\<circ>\n     \\<psi> (CopxC.dom gf)))\n\ngoal (1 subgoal):\n 1. \\<And>g f.\n       CopxC.seq g f \\<Longrightarrow>\n       local.map (g \\<odot> f) = local.map g \\<cdot>\\<^sub>S local.map f", "have \"... = map gf' \\<cdot>\\<^sub>S map gf\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.mkArr (local.set (CopxC.dom gf)) (local.set (CopxC.cod gf'))\n     (\\<phi> (CopxC.cod gf') \\<circ>\n      (\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ>\n      \\<psi> (CopxC.dom gf') \\<circ>\n      (\\<phi> (CopxC.cod gf) \\<circ>\n       (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf) \\<circ>\n       \\<psi> (CopxC.dom gf))) =\n    local.map gf' \\<cdot>\\<^sub>S local.map gf", "using seq gf' map_def arr_map [of gf] arr_map [of gf'] S.comp_mkArr"], ["proof (prove)\nusing this:\n  C.arr (fst gf) \\<and>\n  C.arr (snd gf) \\<and>\n  C.dom (snd gf') = C.cod (snd gf) \\<and>\n  C.arr (fst gf') \\<and>\n  C.arr (snd gf') \\<and> C.dom (fst gf) = C.cod (fst gf')\n  CopxC.seq gf' gf\n  local.map ?gf =\n  (if CopxC.arr ?gf\n   then S.mkArr (local.set (CopxC.dom ?gf)) (local.set (CopxC.cod ?gf))\n         (\\<phi> (CopxC.cod ?gf) \\<circ>\n          (\\<lambda>h. snd ?gf \\<cdot> h \\<cdot> fst ?gf) \\<circ>\n          \\<psi> (CopxC.dom ?gf))\n   else S.null)\n  CopxC.arr gf \\<Longrightarrow> S.arr (local.map gf)\n  CopxC.arr gf' \\<Longrightarrow> S.arr (local.map gf')\n  \\<lbrakk>S.arr (S.mkArr ?A ?B ?F); S.arr (S.mkArr ?B ?C ?G)\\<rbrakk>\n  \\<Longrightarrow> S.mkArr ?B ?C ?G \\<cdot>\\<^sub>S S.mkArr ?A ?B ?F =\n                    S.mkArr ?A ?C (?G \\<circ> ?F)\n\ngoal (1 subgoal):\n 1. S.mkArr (local.set (CopxC.dom gf)) (local.set (CopxC.cod gf'))\n     (\\<phi> (CopxC.cod gf') \\<circ>\n      (\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ>\n      \\<psi> (CopxC.dom gf') \\<circ>\n      (\\<phi> (CopxC.cod gf) \\<circ>\n       (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf) \\<circ>\n       \\<psi> (CopxC.dom gf))) =\n    local.map gf' \\<cdot>\\<^sub>S local.map gf", "by auto"], ["proof (state)\nthis:\n  S.mkArr (local.set (CopxC.dom gf)) (local.set (CopxC.cod gf'))\n   (\\<phi> (CopxC.cod gf') \\<circ>\n    (\\<lambda>h. snd gf' \\<cdot> h \\<cdot> fst gf') \\<circ>\n    \\<psi> (CopxC.dom gf') \\<circ>\n    (\\<phi> (CopxC.cod gf) \\<circ>\n     (\\<lambda>h. snd gf \\<cdot> h \\<cdot> fst gf) \\<circ>\n     \\<psi> (CopxC.dom gf))) =\n  local.map gf' \\<cdot>\\<^sub>S local.map gf\n\ngoal (1 subgoal):\n 1. \\<And>g f.\n       CopxC.seq g f \\<Longrightarrow>\n       local.map (g \\<odot> f) = local.map g \\<cdot>\\<^sub>S local.map f", "finally"], ["proof (chain)\npicking this:\n  local.map (gf' \\<odot> gf) = local.map gf' \\<cdot>\\<^sub>S local.map gf", "show \"map (gf' \\<odot> gf) = map gf' \\<cdot>\\<^sub>S map gf\""], ["proof (prove)\nusing this:\n  local.map (gf' \\<odot> gf) = local.map gf' \\<cdot>\\<^sub>S local.map gf\n\ngoal (1 subgoal):\n 1. local.map (gf' \\<odot> gf) = local.map gf' \\<cdot>\\<^sub>S local.map gf", "using seq gf'"], ["proof (prove)\nusing this:\n  local.map (gf' \\<odot> gf) = local.map gf' \\<cdot>\\<^sub>S local.map gf\n  C.arr (fst gf) \\<and>\n  C.arr (snd gf) \\<and>\n  C.dom (snd gf') = C.cod (snd gf) \\<and>\n  C.arr (fst gf') \\<and>\n  C.arr (snd gf') \\<and> C.dom (fst gf) = C.cod (fst gf')\n  CopxC.seq gf' gf\n\ngoal (1 subgoal):\n 1. local.map (gf' \\<odot> gf) = local.map gf' \\<cdot>\\<^sub>S local.map gf", "by auto"], ["proof (state)\nthis:\n  local.map (gf' \\<odot> gf) = local.map gf' \\<cdot>\\<^sub>S local.map gf\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation binary_functor Cop.comp C S map"], ["proof (prove)\ngoal (1 subgoal):\n 1. binary_functor (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>) (\\<cdot>\\<^sub>S)\n     local.map", ".."], ["", "lemma is_binary_functor:\n    shows \"binary_functor Cop.comp C S map\""], ["proof (prove)\ngoal (1 subgoal):\n 1. binary_functor (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>) (\\<cdot>\\<^sub>S)\n     local.map", ".."], ["", "end"], ["", "sublocale hom_functor \\<subseteq> binary_functor Cop.comp C S map"], ["proof (prove)\ngoal (1 subgoal):\n 1. binary_functor (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>) (\\<cdot>\\<^sub>S)\n     local.map", "using is_binary_functor"], ["proof (prove)\nusing this:\n  binary_functor (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>) (\\<cdot>\\<^sub>S)\n   local.map\n\ngoal (1 subgoal):\n 1. binary_functor (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>) (\\<cdot>\\<^sub>S)\n     local.map", "by auto"], ["", "context hom_functor\n  begin"], ["", "text\\<open>\n      The map @{term \\<phi>} determines a bijection between @{term \"C.hom b a\"} and\n      @{term \"set (b, a)\"} which is natural in @{term \"(b, a)\"}.\n\\<close>"], ["", "lemma \\<phi>_local_bij:\n    assumes \"C.ide b\" and \"C.ide a\"\n    shows \"bij_betw (\\<phi> (b, a)) (C.hom b a) (set (b, a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (\\<phi> (b, a)) (C.hom b a) (local.set (b, a))", "using assms local_inj inj_on_imp_bij_betw set_def"], ["proof (prove)\nusing this:\n  C.ide b\n  C.ide a\n  \\<lbrakk>C.ide ?b; C.ide ?a\\<rbrakk>\n  \\<Longrightarrow> inj_on (\\<phi> (?b, ?a)) (C.hom ?b ?a)\n  inj_on ?f ?A \\<Longrightarrow> bij_betw ?f ?A (?f ` ?A)\n  local.set ?ba \\<equiv>\n  \\<phi> (fst ?ba, snd ?ba) ` C.hom (fst ?ba) (snd ?ba)\n\ngoal (1 subgoal):\n 1. bij_betw (\\<phi> (b, a)) (C.hom b a) (local.set (b, a))", "by auto"], ["", "lemma \\<phi>_natural:\n    assumes \"C.arr g\" and \"C.arr f\" and \"h \\<in> C.hom (C.cod g) (C.dom f)\"\n    shows \"\\<phi> (C.dom g, C.cod f) (f \\<cdot> h \\<cdot> g) = S.Fun (map (g, f)) (\\<phi> (C.cod g, C.dom f) h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> (C.dom g, C.cod f) (f \\<cdot> h \\<cdot> g) =\n    S.Fun (local.map (g, f)) (\\<phi> (C.cod g, C.dom f) h)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<phi> (C.dom g, C.cod f) (f \\<cdot> h \\<cdot> g) =\n    S.Fun (local.map (g, f)) (\\<phi> (C.cod g, C.dom f) h)", "let ?\\<phi>h = \"\\<phi> (C.cod g, C.dom f) h\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<phi> (C.dom g, C.cod f) (f \\<cdot> h \\<cdot> g) =\n    S.Fun (local.map (g, f)) (\\<phi> (C.cod g, C.dom f) h)", "have \\<phi>h: \"?\\<phi>h \\<in> set (C.cod g, C.dom f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> (C.cod g, C.dom f) h \\<in> local.set (C.cod g, C.dom f)", "using assms \\<phi>_mapsto set_def"], ["proof (prove)\nusing this:\n  C.arr g\n  C.arr f\n  h \\<in> C.hom (C.cod g) (C.dom f)\n  \\<lbrakk>C.ide ?b; C.ide ?a\\<rbrakk>\n  \\<Longrightarrow> \\<phi> (?b, ?a)\n                    \\<in> C.hom ?b ?a \\<rightarrow> local.set (?b, ?a)\n  local.set ?ba \\<equiv>\n  \\<phi> (fst ?ba, snd ?ba) ` C.hom (fst ?ba) (snd ?ba)\n\ngoal (1 subgoal):\n 1. \\<phi> (C.cod g, C.dom f) h \\<in> local.set (C.cod g, C.dom f)", "by simp"], ["proof (state)\nthis:\n  \\<phi> (C.cod g, C.dom f) h \\<in> local.set (C.cod g, C.dom f)\n\ngoal (1 subgoal):\n 1. \\<phi> (C.dom g, C.cod f) (f \\<cdot> h \\<cdot> g) =\n    S.Fun (local.map (g, f)) (\\<phi> (C.cod g, C.dom f) h)", "have gf: \"CopxC.arr (g, f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CopxC.arr (g, f)", "using assms"], ["proof (prove)\nusing this:\n  C.arr g\n  C.arr f\n  h \\<in> C.hom (C.cod g) (C.dom f)\n\ngoal (1 subgoal):\n 1. CopxC.arr (g, f)", "by simp"], ["proof (state)\nthis:\n  CopxC.arr (g, f)\n\ngoal (1 subgoal):\n 1. \\<phi> (C.dom g, C.cod f) (f \\<cdot> h \\<cdot> g) =\n    S.Fun (local.map (g, f)) (\\<phi> (C.cod g, C.dom f) h)", "have \"map (g, f) =\n               S.mkArr (set (C.cod g, C.dom f)) (set (C.dom g, C.cod f))\n                       (\\<phi> (C.dom g, C.cod f) \\<circ> (\\<lambda>h. f \\<cdot> h \\<cdot> g) \\<circ> \\<psi> (C.cod g, C.dom f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.map (g, f) =\n    S.mkArr (local.set (C.cod g, C.dom f)) (local.set (C.dom g, C.cod f))\n     (\\<phi> (C.dom g, C.cod f) \\<circ>\n      (\\<lambda>h. f \\<cdot> h \\<cdot> g) \\<circ>\n      \\<psi> (C.cod g, C.dom f))", "using assms map_def"], ["proof (prove)\nusing this:\n  C.arr g\n  C.arr f\n  h \\<in> C.hom (C.cod g) (C.dom f)\n  local.map ?gf =\n  (if CopxC.arr ?gf\n   then S.mkArr (local.set (CopxC.dom ?gf)) (local.set (CopxC.cod ?gf))\n         (\\<phi> (CopxC.cod ?gf) \\<circ>\n          (\\<lambda>h. snd ?gf \\<cdot> h \\<cdot> fst ?gf) \\<circ>\n          \\<psi> (CopxC.dom ?gf))\n   else S.null)\n\ngoal (1 subgoal):\n 1. local.map (g, f) =\n    S.mkArr (local.set (C.cod g, C.dom f)) (local.set (C.dom g, C.cod f))\n     (\\<phi> (C.dom g, C.cod f) \\<circ>\n      (\\<lambda>h. f \\<cdot> h \\<cdot> g) \\<circ>\n      \\<psi> (C.cod g, C.dom f))", "by simp"], ["proof (state)\nthis:\n  local.map (g, f) =\n  S.mkArr (local.set (C.cod g, C.dom f)) (local.set (C.dom g, C.cod f))\n   (\\<phi> (C.dom g, C.cod f) \\<circ>\n    (\\<lambda>h. f \\<cdot> h \\<cdot> g) \\<circ>\n    \\<psi> (C.cod g, C.dom f))\n\ngoal (1 subgoal):\n 1. \\<phi> (C.dom g, C.cod f) (f \\<cdot> h \\<cdot> g) =\n    S.Fun (local.map (g, f)) (\\<phi> (C.cod g, C.dom f) h)", "moreover"], ["proof (state)\nthis:\n  local.map (g, f) =\n  S.mkArr (local.set (C.cod g, C.dom f)) (local.set (C.dom g, C.cod f))\n   (\\<phi> (C.dom g, C.cod f) \\<circ>\n    (\\<lambda>h. f \\<cdot> h \\<cdot> g) \\<circ>\n    \\<psi> (C.cod g, C.dom f))\n\ngoal (1 subgoal):\n 1. \\<phi> (C.dom g, C.cod f) (f \\<cdot> h \\<cdot> g) =\n    S.Fun (local.map (g, f)) (\\<phi> (C.cod g, C.dom f) h)", "have \"S.arr (map (g, f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.arr (local.map (g, f))", "using gf"], ["proof (prove)\nusing this:\n  CopxC.arr (g, f)\n\ngoal (1 subgoal):\n 1. S.arr (local.map (g, f))", "by simp"], ["proof (state)\nthis:\n  S.arr (local.map (g, f))\n\ngoal (1 subgoal):\n 1. \\<phi> (C.dom g, C.cod f) (f \\<cdot> h \\<cdot> g) =\n    S.Fun (local.map (g, f)) (\\<phi> (C.cod g, C.dom f) h)", "ultimately"], ["proof (chain)\npicking this:\n  local.map (g, f) =\n  S.mkArr (local.set (C.cod g, C.dom f)) (local.set (C.dom g, C.cod f))\n   (\\<phi> (C.dom g, C.cod f) \\<circ>\n    (\\<lambda>h. f \\<cdot> h \\<cdot> g) \\<circ>\n    \\<psi> (C.cod g, C.dom f))\n  S.arr (local.map (g, f))", "have\n          \"S.Fun (map (g, f)) =\n               restrict (\\<phi> (C.dom g, C.cod f) \\<circ> (\\<lambda>h. f \\<cdot> h \\<cdot> g) \\<circ> \\<psi> (C.cod g, C.dom f))\n                        (set (C.cod g, C.dom f))\""], ["proof (prove)\nusing this:\n  local.map (g, f) =\n  S.mkArr (local.set (C.cod g, C.dom f)) (local.set (C.dom g, C.cod f))\n   (\\<phi> (C.dom g, C.cod f) \\<circ>\n    (\\<lambda>h. f \\<cdot> h \\<cdot> g) \\<circ>\n    \\<psi> (C.cod g, C.dom f))\n  S.arr (local.map (g, f))\n\ngoal (1 subgoal):\n 1. S.Fun (local.map (g, f)) =\n    restrict\n     (\\<phi> (C.dom g, C.cod f) \\<circ>\n      (\\<lambda>h. f \\<cdot> h \\<cdot> g) \\<circ>\n      \\<psi> (C.cod g, C.dom f))\n     (local.set (C.cod g, C.dom f))", "using S.Fun_mkArr"], ["proof (prove)\nusing this:\n  local.map (g, f) =\n  S.mkArr (local.set (C.cod g, C.dom f)) (local.set (C.dom g, C.cod f))\n   (\\<phi> (C.dom g, C.cod f) \\<circ>\n    (\\<lambda>h. f \\<cdot> h \\<cdot> g) \\<circ>\n    \\<psi> (C.cod g, C.dom f))\n  S.arr (local.map (g, f))\n  S.arr (S.mkArr ?A ?B ?F) \\<Longrightarrow>\n  S.Fun (S.mkArr ?A ?B ?F) = restrict ?F ?A\n\ngoal (1 subgoal):\n 1. S.Fun (local.map (g, f)) =\n    restrict\n     (\\<phi> (C.dom g, C.cod f) \\<circ>\n      (\\<lambda>h. f \\<cdot> h \\<cdot> g) \\<circ>\n      \\<psi> (C.cod g, C.dom f))\n     (local.set (C.cod g, C.dom f))", "by simp"], ["proof (state)\nthis:\n  S.Fun (local.map (g, f)) =\n  restrict\n   (\\<phi> (C.dom g, C.cod f) \\<circ>\n    (\\<lambda>h. f \\<cdot> h \\<cdot> g) \\<circ>\n    \\<psi> (C.cod g, C.dom f))\n   (local.set (C.cod g, C.dom f))\n\ngoal (1 subgoal):\n 1. \\<phi> (C.dom g, C.cod f) (f \\<cdot> h \\<cdot> g) =\n    S.Fun (local.map (g, f)) (\\<phi> (C.cod g, C.dom f) h)", "hence \"S.Fun (map (g, f)) ?\\<phi>h =\n                (\\<phi> (C.dom g, C.cod f) \\<circ> (\\<lambda>h. f \\<cdot> h \\<cdot> g) \\<circ> \\<psi> (C.cod g, C.dom f)) ?\\<phi>h\""], ["proof (prove)\nusing this:\n  S.Fun (local.map (g, f)) =\n  restrict\n   (\\<phi> (C.dom g, C.cod f) \\<circ>\n    (\\<lambda>h. f \\<cdot> h \\<cdot> g) \\<circ>\n    \\<psi> (C.cod g, C.dom f))\n   (local.set (C.cod g, C.dom f))\n\ngoal (1 subgoal):\n 1. S.Fun (local.map (g, f)) (\\<phi> (C.cod g, C.dom f) h) =\n    (\\<phi> (C.dom g, C.cod f) \\<circ>\n     (\\<lambda>h. f \\<cdot> h \\<cdot> g) \\<circ>\n     \\<psi> (C.cod g, C.dom f))\n     (\\<phi> (C.cod g, C.dom f) h)", "using \\<phi>h"], ["proof (prove)\nusing this:\n  S.Fun (local.map (g, f)) =\n  restrict\n   (\\<phi> (C.dom g, C.cod f) \\<circ>\n    (\\<lambda>h. f \\<cdot> h \\<cdot> g) \\<circ>\n    \\<psi> (C.cod g, C.dom f))\n   (local.set (C.cod g, C.dom f))\n  \\<phi> (C.cod g, C.dom f) h \\<in> local.set (C.cod g, C.dom f)\n\ngoal (1 subgoal):\n 1. S.Fun (local.map (g, f)) (\\<phi> (C.cod g, C.dom f) h) =\n    (\\<phi> (C.dom g, C.cod f) \\<circ>\n     (\\<lambda>h. f \\<cdot> h \\<cdot> g) \\<circ>\n     \\<psi> (C.cod g, C.dom f))\n     (\\<phi> (C.cod g, C.dom f) h)", "by simp"], ["proof (state)\nthis:\n  S.Fun (local.map (g, f)) (\\<phi> (C.cod g, C.dom f) h) =\n  (\\<phi> (C.dom g, C.cod f) \\<circ>\n   (\\<lambda>h. f \\<cdot> h \\<cdot> g) \\<circ>\n   \\<psi> (C.cod g, C.dom f))\n   (\\<phi> (C.cod g, C.dom f) h)\n\ngoal (1 subgoal):\n 1. \\<phi> (C.dom g, C.cod f) (f \\<cdot> h \\<cdot> g) =\n    S.Fun (local.map (g, f)) (\\<phi> (C.cod g, C.dom f) h)", "also"], ["proof (state)\nthis:\n  S.Fun (local.map (g, f)) (\\<phi> (C.cod g, C.dom f) h) =\n  (\\<phi> (C.dom g, C.cod f) \\<circ>\n   (\\<lambda>h. f \\<cdot> h \\<cdot> g) \\<circ>\n   \\<psi> (C.cod g, C.dom f))\n   (\\<phi> (C.cod g, C.dom f) h)\n\ngoal (1 subgoal):\n 1. \\<phi> (C.dom g, C.cod f) (f \\<cdot> h \\<cdot> g) =\n    S.Fun (local.map (g, f)) (\\<phi> (C.cod g, C.dom f) h)", "have \"... = \\<phi> (C.dom g, C.cod f) (f \\<cdot> h \\<cdot> g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<phi> (C.dom g, C.cod f) \\<circ>\n     (\\<lambda>h. f \\<cdot> h \\<cdot> g) \\<circ>\n     \\<psi> (C.cod g, C.dom f))\n     (\\<phi> (C.cod g, C.dom f) h) =\n    \\<phi> (C.dom g, C.cod f) (f \\<cdot> h \\<cdot> g)", "using assms(3)"], ["proof (prove)\nusing this:\n  h \\<in> C.hom (C.cod g) (C.dom f)\n\ngoal (1 subgoal):\n 1. (\\<phi> (C.dom g, C.cod f) \\<circ>\n     (\\<lambda>h. f \\<cdot> h \\<cdot> g) \\<circ>\n     \\<psi> (C.cod g, C.dom f))\n     (\\<phi> (C.cod g, C.dom f) h) =\n    \\<phi> (C.dom g, C.cod f) (f \\<cdot> h \\<cdot> g)", "by simp"], ["proof (state)\nthis:\n  (\\<phi> (C.dom g, C.cod f) \\<circ>\n   (\\<lambda>h. f \\<cdot> h \\<cdot> g) \\<circ>\n   \\<psi> (C.cod g, C.dom f))\n   (\\<phi> (C.cod g, C.dom f) h) =\n  \\<phi> (C.dom g, C.cod f) (f \\<cdot> h \\<cdot> g)\n\ngoal (1 subgoal):\n 1. \\<phi> (C.dom g, C.cod f) (f \\<cdot> h \\<cdot> g) =\n    S.Fun (local.map (g, f)) (\\<phi> (C.cod g, C.dom f) h)", "finally"], ["proof (chain)\npicking this:\n  S.Fun (local.map (g, f)) (\\<phi> (C.cod g, C.dom f) h) =\n  \\<phi> (C.dom g, C.cod f) (f \\<cdot> h \\<cdot> g)", "show ?thesis"], ["proof (prove)\nusing this:\n  S.Fun (local.map (g, f)) (\\<phi> (C.cod g, C.dom f) h) =\n  \\<phi> (C.dom g, C.cod f) (f \\<cdot> h \\<cdot> g)\n\ngoal (1 subgoal):\n 1. \\<phi> (C.dom g, C.cod f) (f \\<cdot> h \\<cdot> g) =\n    S.Fun (local.map (g, f)) (\\<phi> (C.cod g, C.dom f) h)", "by auto"], ["proof (state)\nthis:\n  \\<phi> (C.dom g, C.cod f) (f \\<cdot> h \\<cdot> g) =\n  S.Fun (local.map (g, f)) (\\<phi> (C.cod g, C.dom f) h)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Dom_map:\n    assumes \"C.arr g\" and \"C.arr f\"\n    shows \"S.Dom (map (g, f)) = set (C.cod g, C.dom f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.Dom (local.map (g, f)) = local.set (C.cod g, C.dom f)", "using assms map_def preserves_arr S.set_mkIde S.arr_mkArr"], ["proof (prove)\nusing this:\n  C.arr g\n  C.arr f\n  local.map ?gf =\n  (if CopxC.arr ?gf\n   then S.mkArr (local.set (CopxC.dom ?gf)) (local.set (CopxC.cod ?gf))\n         (\\<phi> (CopxC.cod ?gf) \\<circ>\n          (\\<lambda>h. snd ?gf \\<cdot> h \\<cdot> fst ?gf) \\<circ>\n          \\<psi> (CopxC.dom ?gf))\n   else S.null)\n  CopxC.arr ?f \\<Longrightarrow> S.arr (local.map ?f)\n  ?A \\<subseteq> S.Univ \\<Longrightarrow> S.set (S.mkIde ?A) = ?A\n  S.arr (S.mkArr ?A ?B ?F) =\n  (?A \\<subseteq> S.Univ \\<and>\n   ?B \\<subseteq> S.Univ \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n\ngoal (1 subgoal):\n 1. S.Dom (local.map (g, f)) = local.set (C.cod g, C.dom f)", "by auto"], ["", "lemma Cod_map:\n    assumes \"C.arr g\" and \"C.arr f\"\n    shows \"S.Cod (map (g, f)) = set (C.dom g, C.cod f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.Cod (local.map (g, f)) = local.set (C.dom g, C.cod f)", "using assms map_def preserves_arr S.set_mkIde S.arr_mkArr"], ["proof (prove)\nusing this:\n  C.arr g\n  C.arr f\n  local.map ?gf =\n  (if CopxC.arr ?gf\n   then S.mkArr (local.set (CopxC.dom ?gf)) (local.set (CopxC.cod ?gf))\n         (\\<phi> (CopxC.cod ?gf) \\<circ>\n          (\\<lambda>h. snd ?gf \\<cdot> h \\<cdot> fst ?gf) \\<circ>\n          \\<psi> (CopxC.dom ?gf))\n   else S.null)\n  CopxC.arr ?f \\<Longrightarrow> S.arr (local.map ?f)\n  ?A \\<subseteq> S.Univ \\<Longrightarrow> S.set (S.mkIde ?A) = ?A\n  S.arr (S.mkArr ?A ?B ?F) =\n  (?A \\<subseteq> S.Univ \\<and>\n   ?B \\<subseteq> S.Univ \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n\ngoal (1 subgoal):\n 1. S.Cod (local.map (g, f)) = local.set (C.dom g, C.cod f)", "by auto"], ["", "lemma Fun_map:\n    assumes \"C.arr g\" and \"C.arr f\"\n    shows \"S.Fun (map (g, f)) =\n             restrict (\\<phi> (C.dom g, C.cod f) o (\\<lambda>h. f \\<cdot> h \\<cdot> g) o \\<psi> (C.cod g, C.dom f))\n                      (set (C.cod g, C.dom f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.Fun (local.map (g, f)) =\n    restrict\n     (\\<phi> (C.dom g, C.cod f) \\<circ>\n      (\\<lambda>h. f \\<cdot> h \\<cdot> g) \\<circ>\n      \\<psi> (C.cod g, C.dom f))\n     (local.set (C.cod g, C.dom f))", "using assms map_def preserves_arr"], ["proof (prove)\nusing this:\n  C.arr g\n  C.arr f\n  local.map ?gf =\n  (if CopxC.arr ?gf\n   then S.mkArr (local.set (CopxC.dom ?gf)) (local.set (CopxC.cod ?gf))\n         (\\<phi> (CopxC.cod ?gf) \\<circ>\n          (\\<lambda>h. snd ?gf \\<cdot> h \\<cdot> fst ?gf) \\<circ>\n          \\<psi> (CopxC.dom ?gf))\n   else S.null)\n  CopxC.arr ?f \\<Longrightarrow> S.arr (local.map ?f)\n\ngoal (1 subgoal):\n 1. S.Fun (local.map (g, f)) =\n    restrict\n     (\\<phi> (C.dom g, C.cod f) \\<circ>\n      (\\<lambda>h. f \\<cdot> h \\<cdot> g) \\<circ>\n      \\<psi> (C.cod g, C.dom f))\n     (local.set (C.cod g, C.dom f))", "by force"], ["", "lemma map_simp_1:\n    assumes \"C.arr g\" and \"C.ide a\"\n    shows \"map (g, a) = S.mkArr (set (C.cod g, a)) (set (C.dom g, a))\n                                (\\<phi> (C.dom g, a) o Cop.comp g o \\<psi> (C.cod g, a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.map (g, a) =\n    S.mkArr (local.set (C.cod g, a)) (local.set (C.dom g, a))\n     (\\<phi> (C.dom g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n      \\<psi> (C.cod g, a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.map (g, a) =\n    S.mkArr (local.set (C.cod g, a)) (local.set (C.dom g, a))\n     (\\<phi> (C.dom g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n      \\<psi> (C.cod g, a))", "have 1: \"map (g, a) = S.mkArr (set (C.cod g, a)) (set (C.dom g, a))\n                                    (\\<phi> (C.dom g, a) o (\\<lambda>h. a \\<cdot> h \\<cdot> g) o \\<psi> (C.cod g, a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.map (g, a) =\n    S.mkArr (local.set (C.cod g, a)) (local.set (C.dom g, a))\n     (\\<phi> (C.dom g, a) \\<circ>\n      (\\<lambda>h. a \\<cdot> h \\<cdot> g) \\<circ>\n      \\<psi> (C.cod g, a))", "using assms map_def"], ["proof (prove)\nusing this:\n  C.arr g\n  C.ide a\n  local.map ?gf =\n  (if CopxC.arr ?gf\n   then S.mkArr (local.set (CopxC.dom ?gf)) (local.set (CopxC.cod ?gf))\n         (\\<phi> (CopxC.cod ?gf) \\<circ>\n          (\\<lambda>h. snd ?gf \\<cdot> h \\<cdot> fst ?gf) \\<circ>\n          \\<psi> (CopxC.dom ?gf))\n   else S.null)\n\ngoal (1 subgoal):\n 1. local.map (g, a) =\n    S.mkArr (local.set (C.cod g, a)) (local.set (C.dom g, a))\n     (\\<phi> (C.dom g, a) \\<circ>\n      (\\<lambda>h. a \\<cdot> h \\<cdot> g) \\<circ>\n      \\<psi> (C.cod g, a))", "by force"], ["proof (state)\nthis:\n  local.map (g, a) =\n  S.mkArr (local.set (C.cod g, a)) (local.set (C.dom g, a))\n   (\\<phi> (C.dom g, a) \\<circ> (\\<lambda>h. a \\<cdot> h \\<cdot> g) \\<circ>\n    \\<psi> (C.cod g, a))\n\ngoal (1 subgoal):\n 1. local.map (g, a) =\n    S.mkArr (local.set (C.cod g, a)) (local.set (C.dom g, a))\n     (\\<phi> (C.dom g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n      \\<psi> (C.cod g, a))", "also"], ["proof (state)\nthis:\n  local.map (g, a) =\n  S.mkArr (local.set (C.cod g, a)) (local.set (C.dom g, a))\n   (\\<phi> (C.dom g, a) \\<circ> (\\<lambda>h. a \\<cdot> h \\<cdot> g) \\<circ>\n    \\<psi> (C.cod g, a))\n\ngoal (1 subgoal):\n 1. local.map (g, a) =\n    S.mkArr (local.set (C.cod g, a)) (local.set (C.dom g, a))\n     (\\<phi> (C.dom g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n      \\<psi> (C.cod g, a))", "have \"... = S.mkArr (set (C.cod g, a)) (set (C.dom g, a))\n                               (\\<phi> (C.dom g, a) o Cop.comp g o \\<psi> (C.cod g, a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.mkArr (local.set (C.cod g, a)) (local.set (C.dom g, a))\n     (\\<phi> (C.dom g, a) \\<circ>\n      (\\<lambda>h. a \\<cdot> h \\<cdot> g) \\<circ>\n      \\<psi> (C.cod g, a)) =\n    S.mkArr (local.set (C.cod g, a)) (local.set (C.dom g, a))\n     (\\<phi> (C.dom g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n      \\<psi> (C.cod g, a))", "using assms 1 preserves_arr [of \"(g, a)\"] set_def C.in_homI C.comp_cod_arr"], ["proof (prove)\nusing this:\n  C.arr g\n  C.ide a\n  local.map (g, a) =\n  S.mkArr (local.set (C.cod g, a)) (local.set (C.dom g, a))\n   (\\<phi> (C.dom g, a) \\<circ> (\\<lambda>h. a \\<cdot> h \\<cdot> g) \\<circ>\n    \\<psi> (C.cod g, a))\n  CopxC.arr (g, a) \\<Longrightarrow> S.arr (local.map (g, a))\n  local.set ?ba \\<equiv>\n  \\<phi> (fst ?ba, snd ?ba) ` C.hom (fst ?ba) (snd ?ba)\n  \\<lbrakk>C.arr ?f; C.dom ?f = ?a; C.cod ?f = ?b\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright>\n  \\<lbrakk>C.arr ?f; C.cod ?f = ?b\\<rbrakk>\n  \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n\ngoal (1 subgoal):\n 1. S.mkArr (local.set (C.cod g, a)) (local.set (C.dom g, a))\n     (\\<phi> (C.dom g, a) \\<circ>\n      (\\<lambda>h. a \\<cdot> h \\<cdot> g) \\<circ>\n      \\<psi> (C.cod g, a)) =\n    S.mkArr (local.set (C.cod g, a)) (local.set (C.dom g, a))\n     (\\<phi> (C.dom g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n      \\<psi> (C.cod g, a))", "apply (intro S.mkArr_eqI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>C.arr g; C.ide a;\n     local.map (g, a) =\n     S.mkArr (local.set (C.cod g, a)) (local.set (C.dom g, a))\n      (\\<phi> (C.dom g, a) \\<circ>\n       (\\<lambda>h. a \\<cdot> h \\<cdot> g) \\<circ>\n       \\<psi> (C.cod g, a));\n     CopxC.arr (g, a) \\<Longrightarrow> S.arr (local.map (g, a));\n     \\<And>ba.\n        local.set ba \\<equiv>\n        \\<phi> (fst ba, snd ba) ` C.hom (fst ba) (snd ba);\n     \\<And>f a b.\n        \\<lbrakk>C.arr f; C.dom f = a; C.cod f = b\\<rbrakk>\n        \\<Longrightarrow> \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>;\n     \\<And>f b.\n        \\<lbrakk>C.arr f; C.cod f = b\\<rbrakk>\n        \\<Longrightarrow> b \\<cdot> f = f\\<rbrakk>\n    \\<Longrightarrow> S.arr\n                       (S.mkArr (local.set (C.cod g, a))\n                         (local.set (C.dom g, a))\n                         (\\<phi> (C.dom g, a) \\<circ>\n                          (\\<lambda>h. a \\<cdot> h \\<cdot> g) \\<circ>\n                          \\<psi> (C.cod g, a)))\n 2. \\<lbrakk>C.arr g; C.ide a;\n     local.map (g, a) =\n     S.mkArr (local.set (C.cod g, a)) (local.set (C.dom g, a))\n      (\\<phi> (C.dom g, a) \\<circ>\n       (\\<lambda>h. a \\<cdot> h \\<cdot> g) \\<circ>\n       \\<psi> (C.cod g, a));\n     CopxC.arr (g, a) \\<Longrightarrow> S.arr (local.map (g, a));\n     \\<And>ba.\n        local.set ba \\<equiv>\n        \\<phi> (fst ba, snd ba) ` C.hom (fst ba) (snd ba);\n     \\<And>f a b.\n        \\<lbrakk>C.arr f; C.dom f = a; C.cod f = b\\<rbrakk>\n        \\<Longrightarrow> \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>;\n     \\<And>f b.\n        \\<lbrakk>C.arr f; C.cod f = b\\<rbrakk>\n        \\<Longrightarrow> b \\<cdot> f = f\\<rbrakk>\n    \\<Longrightarrow> local.set (C.cod g, a) = local.set (C.cod g, a)\n 3. \\<lbrakk>C.arr g; C.ide a;\n     local.map (g, a) =\n     S.mkArr (local.set (C.cod g, a)) (local.set (C.dom g, a))\n      (\\<phi> (C.dom g, a) \\<circ>\n       (\\<lambda>h. a \\<cdot> h \\<cdot> g) \\<circ>\n       \\<psi> (C.cod g, a));\n     CopxC.arr (g, a) \\<Longrightarrow> S.arr (local.map (g, a));\n     \\<And>ba.\n        local.set ba \\<equiv>\n        \\<phi> (fst ba, snd ba) ` C.hom (fst ba) (snd ba);\n     \\<And>f a b.\n        \\<lbrakk>C.arr f; C.dom f = a; C.cod f = b\\<rbrakk>\n        \\<Longrightarrow> \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>;\n     \\<And>f b.\n        \\<lbrakk>C.arr f; C.cod f = b\\<rbrakk>\n        \\<Longrightarrow> b \\<cdot> f = f\\<rbrakk>\n    \\<Longrightarrow> local.set (C.dom g, a) = local.set (C.dom g, a)\n 4. \\<And>x.\n       \\<lbrakk>C.arr g; C.ide a;\n        local.map (g, a) =\n        S.mkArr (local.set (C.cod g, a)) (local.set (C.dom g, a))\n         (\\<phi> (C.dom g, a) \\<circ>\n          (\\<lambda>h. a \\<cdot> h \\<cdot> g) \\<circ>\n          \\<psi> (C.cod g, a));\n        CopxC.arr (g, a) \\<Longrightarrow> S.arr (local.map (g, a));\n        \\<And>ba.\n           local.set ba \\<equiv>\n           \\<phi> (fst ba, snd ba) ` C.hom (fst ba) (snd ba);\n        \\<And>f a b.\n           \\<lbrakk>C.arr f; C.dom f = a; C.cod f = b\\<rbrakk>\n           \\<Longrightarrow> \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>;\n        \\<And>f b.\n           \\<lbrakk>C.arr f; C.cod f = b\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        x \\<in> local.set (C.cod g, a)\\<rbrakk>\n       \\<Longrightarrow> (\\<phi> (C.dom g, a) \\<circ>\n                          (\\<lambda>h. a \\<cdot> h \\<cdot> g) \\<circ>\n                          \\<psi> (C.cod g, a))\n                          x =\n                         (\\<phi> (C.dom g, a) \\<circ>\n                          (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n                          \\<psi> (C.cod g, a))\n                          x", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>C.arr g; C.ide a;\n        local.map (g, a) =\n        S.mkArr (\\<phi> (C.cod g, a) ` C.hom (C.cod g) a)\n         (\\<phi> (C.dom g, a) ` C.hom (C.dom g) a)\n         (\\<phi> (C.dom g, a) \\<circ>\n          (\\<lambda>h. a \\<cdot> h \\<cdot> g) \\<circ>\n          \\<psi> (C.cod g, a));\n        S.arr\n         (S.mkArr (\\<phi> (C.cod g, a) ` C.hom (C.cod g) a)\n           (\\<phi> (C.dom g, a) ` C.hom (C.dom g) a)\n           (\\<phi> (C.dom g, a) \\<circ>\n            (\\<lambda>h. a \\<cdot> h \\<cdot> g) \\<circ>\n            \\<psi> (C.cod g, a)));\n        \\<And>ba. local.set ba \\<equiv> \\<phi> ba ` C.hom (fst ba) (snd ba);\n        \\<And>f a b.\n           \\<lbrakk>C.arr f; C.dom f = a; C.cod f = b\\<rbrakk>\n           \\<Longrightarrow> \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>;\n        \\<And>f b.\n           \\<lbrakk>C.arr f; C.cod f = b\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        x \\<in> \\<phi> (C.cod g, a) ` C.hom (C.cod g) a\\<rbrakk>\n       \\<Longrightarrow> \\<phi> (C.dom g, a)\n                          (a \\<cdot> \\<psi> (C.cod g, a) x \\<cdot> g) =\n                         \\<phi> (C.dom g, a)\n                          (\\<psi> (C.cod g, a) x \\<cdot> g)", "by auto"], ["proof (state)\nthis:\n  S.mkArr (local.set (C.cod g, a)) (local.set (C.dom g, a))\n   (\\<phi> (C.dom g, a) \\<circ> (\\<lambda>h. a \\<cdot> h \\<cdot> g) \\<circ>\n    \\<psi> (C.cod g, a)) =\n  S.mkArr (local.set (C.cod g, a)) (local.set (C.dom g, a))\n   (\\<phi> (C.dom g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n    \\<psi> (C.cod g, a))\n\ngoal (1 subgoal):\n 1. local.map (g, a) =\n    S.mkArr (local.set (C.cod g, a)) (local.set (C.dom g, a))\n     (\\<phi> (C.dom g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n      \\<psi> (C.cod g, a))", "finally"], ["proof (chain)\npicking this:\n  local.map (g, a) =\n  S.mkArr (local.set (C.cod g, a)) (local.set (C.dom g, a))\n   (\\<phi> (C.dom g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n    \\<psi> (C.cod g, a))", "show ?thesis"], ["proof (prove)\nusing this:\n  local.map (g, a) =\n  S.mkArr (local.set (C.cod g, a)) (local.set (C.dom g, a))\n   (\\<phi> (C.dom g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n    \\<psi> (C.cod g, a))\n\ngoal (1 subgoal):\n 1. local.map (g, a) =\n    S.mkArr (local.set (C.cod g, a)) (local.set (C.dom g, a))\n     (\\<phi> (C.dom g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n      \\<psi> (C.cod g, a))", "by blast"], ["proof (state)\nthis:\n  local.map (g, a) =\n  S.mkArr (local.set (C.cod g, a)) (local.set (C.dom g, a))\n   (\\<phi> (C.dom g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n    \\<psi> (C.cod g, a))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma map_simp_2:\n    assumes \"C.ide b\" and \"C.arr f\"\n    shows \"map (b, f) = S.mkArr (set (b, C.dom f)) (set (b, C.cod f))\n                                (\\<phi> (b, C.cod f) o C f o \\<psi> (b, C.dom f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.map (b, f) =\n    S.mkArr (local.set (b, C.dom f)) (local.set (b, C.cod f))\n     (\\<phi> (b, C.cod f) \\<circ> (\\<cdot>) f \\<circ> \\<psi> (b, C.dom f))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.map (b, f) =\n    S.mkArr (local.set (b, C.dom f)) (local.set (b, C.cod f))\n     (\\<phi> (b, C.cod f) \\<circ> (\\<cdot>) f \\<circ> \\<psi> (b, C.dom f))", "have 1: \"map (b, f) = S.mkArr (set (b, C.dom f)) (set (b, C.cod f))\n                                    (\\<phi> (b, C.cod f) o (\\<lambda>h. f \\<cdot> h \\<cdot> b) o \\<psi> (b, C.dom f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.map (b, f) =\n    S.mkArr (local.set (b, C.dom f)) (local.set (b, C.cod f))\n     (\\<phi> (b, C.cod f) \\<circ>\n      (\\<lambda>h. f \\<cdot> h \\<cdot> b) \\<circ>\n      \\<psi> (b, C.dom f))", "using assms map_def"], ["proof (prove)\nusing this:\n  C.ide b\n  C.arr f\n  local.map ?gf =\n  (if CopxC.arr ?gf\n   then S.mkArr (local.set (CopxC.dom ?gf)) (local.set (CopxC.cod ?gf))\n         (\\<phi> (CopxC.cod ?gf) \\<circ>\n          (\\<lambda>h. snd ?gf \\<cdot> h \\<cdot> fst ?gf) \\<circ>\n          \\<psi> (CopxC.dom ?gf))\n   else S.null)\n\ngoal (1 subgoal):\n 1. local.map (b, f) =\n    S.mkArr (local.set (b, C.dom f)) (local.set (b, C.cod f))\n     (\\<phi> (b, C.cod f) \\<circ>\n      (\\<lambda>h. f \\<cdot> h \\<cdot> b) \\<circ>\n      \\<psi> (b, C.dom f))", "by force"], ["proof (state)\nthis:\n  local.map (b, f) =\n  S.mkArr (local.set (b, C.dom f)) (local.set (b, C.cod f))\n   (\\<phi> (b, C.cod f) \\<circ> (\\<lambda>h. f \\<cdot> h \\<cdot> b) \\<circ>\n    \\<psi> (b, C.dom f))\n\ngoal (1 subgoal):\n 1. local.map (b, f) =\n    S.mkArr (local.set (b, C.dom f)) (local.set (b, C.cod f))\n     (\\<phi> (b, C.cod f) \\<circ> (\\<cdot>) f \\<circ> \\<psi> (b, C.dom f))", "also"], ["proof (state)\nthis:\n  local.map (b, f) =\n  S.mkArr (local.set (b, C.dom f)) (local.set (b, C.cod f))\n   (\\<phi> (b, C.cod f) \\<circ> (\\<lambda>h. f \\<cdot> h \\<cdot> b) \\<circ>\n    \\<psi> (b, C.dom f))\n\ngoal (1 subgoal):\n 1. local.map (b, f) =\n    S.mkArr (local.set (b, C.dom f)) (local.set (b, C.cod f))\n     (\\<phi> (b, C.cod f) \\<circ> (\\<cdot>) f \\<circ> \\<psi> (b, C.dom f))", "have \"... = S.mkArr (set (b, C.dom f)) (set (b, C.cod f))\n                               (\\<phi> (b, C.cod f) o C f o \\<psi> (b, C.dom f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.mkArr (local.set (b, C.dom f)) (local.set (b, C.cod f))\n     (\\<phi> (b, C.cod f) \\<circ>\n      (\\<lambda>h. f \\<cdot> h \\<cdot> b) \\<circ>\n      \\<psi> (b, C.dom f)) =\n    S.mkArr (local.set (b, C.dom f)) (local.set (b, C.cod f))\n     (\\<phi> (b, C.cod f) \\<circ> (\\<cdot>) f \\<circ> \\<psi> (b, C.dom f))", "using assms 1 preserves_arr [of \"(b, f)\"] set_def C.in_homI C.comp_arr_dom"], ["proof (prove)\nusing this:\n  C.ide b\n  C.arr f\n  local.map (b, f) =\n  S.mkArr (local.set (b, C.dom f)) (local.set (b, C.cod f))\n   (\\<phi> (b, C.cod f) \\<circ> (\\<lambda>h. f \\<cdot> h \\<cdot> b) \\<circ>\n    \\<psi> (b, C.dom f))\n  CopxC.arr (b, f) \\<Longrightarrow> S.arr (local.map (b, f))\n  local.set ?ba \\<equiv>\n  \\<phi> (fst ?ba, snd ?ba) ` C.hom (fst ?ba) (snd ?ba)\n  \\<lbrakk>C.arr ?f; C.dom ?f = ?a; C.cod ?f = ?b\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright>\n  \\<lbrakk>C.arr ?f; C.dom ?f = ?a\\<rbrakk>\n  \\<Longrightarrow> ?f \\<cdot> ?a = ?f\n\ngoal (1 subgoal):\n 1. S.mkArr (local.set (b, C.dom f)) (local.set (b, C.cod f))\n     (\\<phi> (b, C.cod f) \\<circ>\n      (\\<lambda>h. f \\<cdot> h \\<cdot> b) \\<circ>\n      \\<psi> (b, C.dom f)) =\n    S.mkArr (local.set (b, C.dom f)) (local.set (b, C.cod f))\n     (\\<phi> (b, C.cod f) \\<circ> (\\<cdot>) f \\<circ> \\<psi> (b, C.dom f))", "apply (intro S.mkArr_eqI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>C.ide b; C.arr f;\n     local.map (b, f) =\n     S.mkArr (local.set (b, C.dom f)) (local.set (b, C.cod f))\n      (\\<phi> (b, C.cod f) \\<circ>\n       (\\<lambda>h. f \\<cdot> h \\<cdot> b) \\<circ>\n       \\<psi> (b, C.dom f));\n     CopxC.arr (b, f) \\<Longrightarrow> S.arr (local.map (b, f));\n     \\<And>ba.\n        local.set ba \\<equiv>\n        \\<phi> (fst ba, snd ba) ` C.hom (fst ba) (snd ba);\n     \\<And>f a b.\n        \\<lbrakk>C.arr f; C.dom f = a; C.cod f = b\\<rbrakk>\n        \\<Longrightarrow> \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>;\n     \\<And>f a.\n        \\<lbrakk>C.arr f; C.dom f = a\\<rbrakk>\n        \\<Longrightarrow> f \\<cdot> a = f\\<rbrakk>\n    \\<Longrightarrow> S.arr\n                       (S.mkArr (local.set (b, C.dom f))\n                         (local.set (b, C.cod f))\n                         (\\<phi> (b, C.cod f) \\<circ>\n                          (\\<lambda>h. f \\<cdot> h \\<cdot> b) \\<circ>\n                          \\<psi> (b, C.dom f)))\n 2. \\<lbrakk>C.ide b; C.arr f;\n     local.map (b, f) =\n     S.mkArr (local.set (b, C.dom f)) (local.set (b, C.cod f))\n      (\\<phi> (b, C.cod f) \\<circ>\n       (\\<lambda>h. f \\<cdot> h \\<cdot> b) \\<circ>\n       \\<psi> (b, C.dom f));\n     CopxC.arr (b, f) \\<Longrightarrow> S.arr (local.map (b, f));\n     \\<And>ba.\n        local.set ba \\<equiv>\n        \\<phi> (fst ba, snd ba) ` C.hom (fst ba) (snd ba);\n     \\<And>f a b.\n        \\<lbrakk>C.arr f; C.dom f = a; C.cod f = b\\<rbrakk>\n        \\<Longrightarrow> \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>;\n     \\<And>f a.\n        \\<lbrakk>C.arr f; C.dom f = a\\<rbrakk>\n        \\<Longrightarrow> f \\<cdot> a = f\\<rbrakk>\n    \\<Longrightarrow> local.set (b, C.dom f) = local.set (b, C.dom f)\n 3. \\<lbrakk>C.ide b; C.arr f;\n     local.map (b, f) =\n     S.mkArr (local.set (b, C.dom f)) (local.set (b, C.cod f))\n      (\\<phi> (b, C.cod f) \\<circ>\n       (\\<lambda>h. f \\<cdot> h \\<cdot> b) \\<circ>\n       \\<psi> (b, C.dom f));\n     CopxC.arr (b, f) \\<Longrightarrow> S.arr (local.map (b, f));\n     \\<And>ba.\n        local.set ba \\<equiv>\n        \\<phi> (fst ba, snd ba) ` C.hom (fst ba) (snd ba);\n     \\<And>f a b.\n        \\<lbrakk>C.arr f; C.dom f = a; C.cod f = b\\<rbrakk>\n        \\<Longrightarrow> \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>;\n     \\<And>f a.\n        \\<lbrakk>C.arr f; C.dom f = a\\<rbrakk>\n        \\<Longrightarrow> f \\<cdot> a = f\\<rbrakk>\n    \\<Longrightarrow> local.set (b, C.cod f) = local.set (b, C.cod f)\n 4. \\<And>x.\n       \\<lbrakk>C.ide b; C.arr f;\n        local.map (b, f) =\n        S.mkArr (local.set (b, C.dom f)) (local.set (b, C.cod f))\n         (\\<phi> (b, C.cod f) \\<circ>\n          (\\<lambda>h. f \\<cdot> h \\<cdot> b) \\<circ>\n          \\<psi> (b, C.dom f));\n        CopxC.arr (b, f) \\<Longrightarrow> S.arr (local.map (b, f));\n        \\<And>ba.\n           local.set ba \\<equiv>\n           \\<phi> (fst ba, snd ba) ` C.hom (fst ba) (snd ba);\n        \\<And>f a b.\n           \\<lbrakk>C.arr f; C.dom f = a; C.cod f = b\\<rbrakk>\n           \\<Longrightarrow> \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>;\n        \\<And>f a.\n           \\<lbrakk>C.arr f; C.dom f = a\\<rbrakk>\n           \\<Longrightarrow> f \\<cdot> a = f;\n        x \\<in> local.set (b, C.dom f)\\<rbrakk>\n       \\<Longrightarrow> (\\<phi> (b, C.cod f) \\<circ>\n                          (\\<lambda>h. f \\<cdot> h \\<cdot> b) \\<circ>\n                          \\<psi> (b, C.dom f))\n                          x =\n                         (\\<phi> (b, C.cod f) \\<circ> (\\<cdot>) f \\<circ>\n                          \\<psi> (b, C.dom f))\n                          x", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>C.ide b; C.arr f;\n        local.map (b, f) =\n        S.mkArr (\\<phi> (b, C.dom f) ` C.hom b (C.dom f))\n         (\\<phi> (b, C.cod f) ` C.hom b (C.cod f))\n         (\\<phi> (b, C.cod f) \\<circ>\n          (\\<lambda>h. f \\<cdot> h \\<cdot> b) \\<circ>\n          \\<psi> (b, C.dom f));\n        S.arr\n         (S.mkArr (\\<phi> (b, C.dom f) ` C.hom b (C.dom f))\n           (\\<phi> (b, C.cod f) ` C.hom b (C.cod f))\n           (\\<phi> (b, C.cod f) \\<circ>\n            (\\<lambda>h. f \\<cdot> h \\<cdot> b) \\<circ>\n            \\<psi> (b, C.dom f)));\n        \\<And>ba. local.set ba \\<equiv> \\<phi> ba ` C.hom (fst ba) (snd ba);\n        \\<And>f a b.\n           \\<lbrakk>C.arr f; C.dom f = a; C.cod f = b\\<rbrakk>\n           \\<Longrightarrow> \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>;\n        \\<And>f a.\n           \\<lbrakk>C.arr f; C.dom f = a\\<rbrakk>\n           \\<Longrightarrow> f \\<cdot> a = f;\n        x \\<in> \\<phi> (b, C.dom f) ` C.hom b (C.dom f)\\<rbrakk>\n       \\<Longrightarrow> \\<phi> (b, C.cod f)\n                          (f \\<cdot> \\<psi> (b, C.dom f) x \\<cdot> b) =\n                         \\<phi> (b, C.cod f)\n                          (f \\<cdot> \\<psi> (b, C.dom f) x)", "by auto"], ["proof (state)\nthis:\n  S.mkArr (local.set (b, C.dom f)) (local.set (b, C.cod f))\n   (\\<phi> (b, C.cod f) \\<circ> (\\<lambda>h. f \\<cdot> h \\<cdot> b) \\<circ>\n    \\<psi> (b, C.dom f)) =\n  S.mkArr (local.set (b, C.dom f)) (local.set (b, C.cod f))\n   (\\<phi> (b, C.cod f) \\<circ> (\\<cdot>) f \\<circ> \\<psi> (b, C.dom f))\n\ngoal (1 subgoal):\n 1. local.map (b, f) =\n    S.mkArr (local.set (b, C.dom f)) (local.set (b, C.cod f))\n     (\\<phi> (b, C.cod f) \\<circ> (\\<cdot>) f \\<circ> \\<psi> (b, C.dom f))", "finally"], ["proof (chain)\npicking this:\n  local.map (b, f) =\n  S.mkArr (local.set (b, C.dom f)) (local.set (b, C.cod f))\n   (\\<phi> (b, C.cod f) \\<circ> (\\<cdot>) f \\<circ> \\<psi> (b, C.dom f))", "show ?thesis"], ["proof (prove)\nusing this:\n  local.map (b, f) =\n  S.mkArr (local.set (b, C.dom f)) (local.set (b, C.cod f))\n   (\\<phi> (b, C.cod f) \\<circ> (\\<cdot>) f \\<circ> \\<psi> (b, C.dom f))\n\ngoal (1 subgoal):\n 1. local.map (b, f) =\n    S.mkArr (local.set (b, C.dom f)) (local.set (b, C.cod f))\n     (\\<phi> (b, C.cod f) \\<circ> (\\<cdot>) f \\<circ> \\<psi> (b, C.dom f))", "by blast"], ["proof (state)\nthis:\n  local.map (b, f) =\n  S.mkArr (local.set (b, C.dom f)) (local.set (b, C.cod f))\n   (\\<phi> (b, C.cod f) \\<circ> (\\<cdot>) f \\<circ> \\<psi> (b, C.dom f))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text\\<open>\n    Every category @{term C} has a hom-functor: take @{term S} to be the replete set category\n    generated by the arrow type \\<open>'a\\<close> of @{term C} and take @{term \"\\<phi> (b, a)\"} to be the map\n    \\<open>S.UP :: 'a \\<Rightarrow> 'a SC.arr\\<close>.\n\\<close>"], ["", "context category\n  begin"], ["", "interpretation Cop: dual_category C"], ["proof (prove)\ngoal (1 subgoal):\n 1. dual_category (\\<cdot>)", ".."], ["", "interpretation CopxC: product_category Cop.comp C"], ["proof (prove)\ngoal (1 subgoal):\n 1. product_category (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>)", ".."], ["", "interpretation S: replete_setcat \\<open>undefined :: 'a\\<close>"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["", "lemma has_hom_functor:\n    shows \"hom_functor C (S.comp :: 'a setcat.arr comp) (\\<lambda>_. S.UP)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom_functor (\\<cdot>) S.comp (\\<lambda>_. S.UP)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f. arr f \\<Longrightarrow> S.UP f \\<in> S.Univ\n 2. \\<And>b a.\n       \\<lbrakk>ide b; ide a\\<rbrakk>\n       \\<Longrightarrow> inj_on S.UP (hom b a)", "show \"\\<And>f. arr f \\<Longrightarrow> S.UP f \\<in> S.Univ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f. arr f \\<Longrightarrow> S.UP f \\<in> S.Univ", "using S.UP_mapsto"], ["proof (prove)\nusing this:\n  S.UP \\<in> UNIV \\<rightarrow> S.Univ\n\ngoal (1 subgoal):\n 1. \\<And>f. arr f \\<Longrightarrow> S.UP f \\<in> S.Univ", "by auto"], ["proof (state)\nthis:\n  arr ?f \\<Longrightarrow> S.UP ?f \\<in> S.Univ\n\ngoal (1 subgoal):\n 1. \\<And>b a.\n       \\<lbrakk>ide b; ide a\\<rbrakk>\n       \\<Longrightarrow> inj_on S.UP (hom b a)", "show \"\\<And>b a. \\<lbrakk>ide b; ide a\\<rbrakk> \\<Longrightarrow> inj_on S.UP (hom b a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b a.\n       \\<lbrakk>ide b; ide a\\<rbrakk>\n       \\<Longrightarrow> inj_on S.UP (hom b a)", "by (meson S.inj_UP injD inj_onI)"], ["proof (state)\nthis:\n  \\<lbrakk>ide ?b; ide ?a\\<rbrakk> \\<Longrightarrow> inj_on S.UP (hom ?b ?a)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text\\<open>\n    The locales \\<open>set_valued_functor\\<close> and \\<open>set_valued_transformation\\<close> provide some\n    abbreviations that are convenient when working with functors and natural transformations\n    into a set category.\n\\<close>"], ["", "locale set_valued_functor =\n    C: category C +\n    S: replete_set_category S +\n    \"functor\" C S F\n    for C :: \"'c comp\"\n    and S :: \"'s comp\"\n    and F :: \"'c \\<Rightarrow> 's\"\n  begin"], ["", "abbreviation SET :: \"'c \\<Rightarrow> 's set\"\n    where \"SET a \\<equiv> S.set (F a)\""], ["", "abbreviation DOM :: \"'c \\<Rightarrow> 's set\"\n    where \"DOM f \\<equiv> S.Dom (F f)\""], ["", "abbreviation COD :: \"'c \\<Rightarrow> 's set\"\n    where \"COD f \\<equiv> S.Cod (F f)\""], ["", "abbreviation FUN :: \"'c \\<Rightarrow> 's \\<Rightarrow> 's\"\n    where \"FUN f \\<equiv> S.Fun (F f)\""], ["", "end"], ["", "locale set_valued_transformation =\n    C: category C +\n    S: replete_set_category S +\n    F: set_valued_functor C S F +\n    G: set_valued_functor C S G +\n    natural_transformation C S F G \\<tau>\n  for C :: \"'c comp\"\n  and S :: \"'s comp\"\n  and F :: \"'c \\<Rightarrow> 's\"\n  and G :: \"'c \\<Rightarrow> 's\"\n  and \\<tau> :: \"'c \\<Rightarrow> 's\"\n  begin"], ["", "abbreviation DOM :: \"'c \\<Rightarrow> 's set\"\n    where \"DOM f \\<equiv> S.Dom (\\<tau> f)\""], ["", "abbreviation COD :: \"'c \\<Rightarrow> 's set\"\n    where \"COD f \\<equiv> S.Cod (\\<tau> f)\""], ["", "abbreviation FUN :: \"'c \\<Rightarrow> 's \\<Rightarrow> 's\"\n    where \"FUN f \\<equiv> S.Fun (\\<tau> f)\""], ["", "end"], ["", "section \"Yoneda Functors\""], ["", "text\\<open>\n    A Yoneda functor is the functor from @{term C} to \\<open>[Cop, S]\\<close> obtained by ``currying''\n    a hom-functor in its first argument.\n\\<close>"], ["", "locale yoneda_functor =\n    C: category C +\n    Cop: dual_category C +\n    CopxC: product_category Cop.comp C +\n    S: replete_set_category S +\n    Hom: hom_functor C S \\<phi> +\n    Cop_S: functor_category Cop.comp S +\n    curried_functor' Cop.comp C S Hom.map\n  for C :: \"'c comp\"      (infixr \"\\<cdot>\" 55)\n  and S :: \"'s comp\"      (infixr \"\\<cdot>\\<^sub>S\" 55)\n  and \\<phi> :: \"'c * 'c \\<Rightarrow> 'c \\<Rightarrow> 's\"\n  begin"], ["", "notation Cop_S.in_hom (\"\\<guillemotleft>_ : _ \\<rightarrow>\\<^sub>[\\<^sub>C\\<^sub>o\\<^sub>p\\<^sub>,\\<^sub>S\\<^sub>] _\\<guillemotright>\")"], ["", "abbreviation \\<psi>\n    where \"\\<psi> \\<equiv> Hom.\\<psi>\""], ["", "text\\<open>\n      An arrow of the functor category \\<open>[Cop, S]\\<close> consists of a natural transformation\n      bundled together with its domain and codomain functors.  However, when considering\n      a Yoneda functor from @{term[source=true] C} to \\<open>[Cop, S]\\<close> we generally are only\n      interested in the mapping @{term Y} that takes each arrow @{term f} of @{term[source=true] C}\n      to the corresponding natural transformation @{term \"Y f\"}.  The domain and codomain functors\n      are then the identity transformations @{term \"Y (C.dom f)\"} and @{term \"Y (C.cod f)\"}.\n\\<close>"], ["", "definition Y\n    where \"Y f \\<equiv> Cop_S.Map (map f)\""], ["", "lemma Y_simp [simp]:\n    assumes \"C.arr f\"\n    shows \"Y f = (\\<lambda>g. Hom.map (g, f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y f = (\\<lambda>g. Hom.map (g, f))", "using assms preserves_arr Y_def"], ["proof (prove)\nusing this:\n  C.arr f\n  C.arr ?f \\<Longrightarrow> Cop_S.arr (local.map ?f)\n  Y ?f \\<equiv> Cop_S.Map (local.map ?f)\n\ngoal (1 subgoal):\n 1. Y f = (\\<lambda>g. Hom.map (g, f))", "by simp"], ["", "lemma Y_ide_is_functor:\n    assumes \"C.ide a\"\n    shows \"functor Cop.comp S (Y a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. functor (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)", "using assms Y_def Hom.fixing_ide_gives_functor_2"], ["proof (prove)\nusing this:\n  C.ide a\n  Y ?f \\<equiv> Cop_S.Map (local.map ?f)\n  C.ide ?a2.0 \\<Longrightarrow>\n  functor (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S)\n   (\\<lambda>f1. Hom.map (f1, ?a2.0))\n\ngoal (1 subgoal):\n 1. functor (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)", "by force"], ["", "lemma Y_arr_is_transformation:\n    assumes \"C.arr f\"\n    shows \"natural_transformation Cop.comp S (Y (C.dom f)) (Y (C.cod f)) (Y f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S)\n     (Y (C.dom f)) (Y (C.cod f)) (Y f)", "using assms Y_def [of f] map_def Hom.fixing_arr_gives_natural_transformation_2\n            preserves_dom preserves_cod"], ["proof (prove)\nusing this:\n  C.arr f\n  Y f \\<equiv> Cop_S.Map (local.map f)\n  local.map \\<equiv> local.curry Hom.sym Hom.sym Hom.sym\n  C.arr ?f2.0 \\<Longrightarrow>\n  natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S)\n   (\\<lambda>f1. Hom.map (f1, C.dom ?f2.0))\n   (\\<lambda>f1. Hom.map (f1, C.cod ?f2.0))\n   (\\<lambda>f1. Hom.map (f1, ?f2.0))\n  C.arr ?f \\<Longrightarrow> Cop_S.dom (local.map ?f) = local.map (C.dom ?f)\n  C.arr ?f \\<Longrightarrow> Cop_S.cod (local.map ?f) = local.map (C.cod ?f)\n\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S)\n     (Y (C.dom f)) (Y (C.cod f)) (Y f)", "by fastforce"], ["", "lemma Y_ide_arr [simp]:\n    assumes a: \"C.ide a\" and \"\\<guillemotleft>g : b' \\<rightarrow> b\\<guillemotright>\"\n    shows \"\\<guillemotleft>Y a g : Hom.map (b, a) \\<rightarrow>\\<^sub>S Hom.map (b', a)\\<guillemotright>\"\n    and \"Y a g =\n         S.mkArr (Hom.set (b, a)) (Hom.set (b', a)) (\\<phi> (b', a) o Cop.comp g o \\<psi> (b, a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>Y a g : Hom.map\n                             (b, a) \\<rightarrow>\\<^sub>S Hom.map\n                     (b', a)\\<guillemotright> &&&\n    Y a g =\n    S.mkArr (Hom.set (b, a)) (Hom.set (b', a))\n     (\\<phi> (b', a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n      \\<psi> (b, a))", "using assms Hom.map_simp_1"], ["proof (prove)\nusing this:\n  C.ide a\n  \\<guillemotleft>g : b' \\<rightarrow> b\\<guillemotright>\n  \\<lbrakk>C.arr ?g; C.ide ?a\\<rbrakk>\n  \\<Longrightarrow> Hom.map (?g, ?a) =\n                    S.mkArr (Hom.set (C.cod ?g, ?a))\n                     (Hom.set (C.dom ?g, ?a))\n                     (\\<phi> (C.dom ?g, ?a) \\<circ>\n                      (\\<cdot>\\<^sup>o\\<^sup>p) ?g \\<circ>\n                      \\<psi> (C.cod ?g, ?a))\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>Y a g : Hom.map\n                             (b, a) \\<rightarrow>\\<^sub>S Hom.map\n                     (b', a)\\<guillemotright> &&&\n    Y a g =\n    S.mkArr (Hom.set (b, a)) (Hom.set (b', a))\n     (\\<phi> (b', a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n      \\<psi> (b, a))", "by (fastforce, auto)"], ["", "lemma Y_arr_ide [simp]:\n    assumes \"C.ide b\" and \"\\<guillemotleft>f : a \\<rightarrow> a'\\<guillemotright>\"\n    shows \"\\<guillemotleft>Y f b : Hom.map (b, a) \\<rightarrow>\\<^sub>S Hom.map (b, a')\\<guillemotright>\"\n    and \"Y f b = S.mkArr (Hom.set (b, a)) (Hom.set (b, a')) (\\<phi> (b, a') o C f o \\<psi> (b, a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>Y f b : Hom.map\n                             (b, a) \\<rightarrow>\\<^sub>S Hom.map\n                     (b, a')\\<guillemotright> &&&\n    Y f b =\n    S.mkArr (Hom.set (b, a)) (Hom.set (b, a'))\n     (\\<phi> (b, a') \\<circ> (\\<cdot>) f \\<circ> \\<psi> (b, a))", "using assms"], ["proof (prove)\nusing this:\n  C.ide b\n  \\<guillemotleft>f : a \\<rightarrow> a'\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>Y f b : Hom.map\n                             (b, a) \\<rightarrow>\\<^sub>S Hom.map\n                     (b, a')\\<guillemotright> &&&\n    Y f b =\n    S.mkArr (Hom.set (b, a)) (Hom.set (b, a'))\n     (\\<phi> (b, a') \\<circ> (\\<cdot>) f \\<circ> \\<psi> (b, a))", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. Y f b =\n    S.mkArr (Hom.set (b, a)) (Hom.set (b, a'))\n     (\\<phi> (b, a') \\<circ> (\\<cdot>) f \\<circ> \\<psi> (b, a))", "using assms Hom.map_simp_2"], ["proof (prove)\nusing this:\n  C.ide b\n  \\<guillemotleft>f : a \\<rightarrow> a'\\<guillemotright>\n  \\<lbrakk>C.ide ?b; C.arr ?f\\<rbrakk>\n  \\<Longrightarrow> Hom.map (?b, ?f) =\n                    S.mkArr (Hom.set (?b, C.dom ?f))\n                     (Hom.set (?b, C.cod ?f))\n                     (\\<phi> (?b, C.cod ?f) \\<circ> (\\<cdot>) ?f \\<circ>\n                      \\<psi> (?b, C.dom ?f))\n\ngoal (1 subgoal):\n 1. Y f b =\n    S.mkArr (Hom.set (b, a)) (Hom.set (b, a'))\n     (\\<phi> (b, a') \\<circ> (\\<cdot>) f \\<circ> \\<psi> (b, a))", "by auto"], ["", "end"], ["", "locale yoneda_functor_fixed_object =\n    yoneda_functor C S \\<phi>\n  for C :: \"'c comp\" (infixr \"\\<cdot>\" 55)\n  and S :: \"'s comp\" (infixr \"\\<cdot>\\<^sub>S\" 55)\n  and \\<phi> :: \"'c * 'c \\<Rightarrow> 'c \\<Rightarrow> 's\"\n  and a :: 'c +\n  assumes ide_a: \"C.ide a\""], ["", "sublocale yoneda_functor_fixed_object \\<subseteq> \"functor\" Cop.comp S \"(Y a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. functor (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)", "using ide_a Y_ide_is_functor"], ["proof (prove)\nusing this:\n  C.ide a\n  C.ide ?a \\<Longrightarrow>\n  functor (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y ?a)\n\ngoal (1 subgoal):\n 1. functor (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)", "by auto"], ["", "sublocale yoneda_functor_fixed_object \\<subseteq> set_valued_functor Cop.comp S \"(Y a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_valued_functor (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)", ".."], ["", "text\\<open>\n    The Yoneda lemma states that, given a category @{term C} and a functor @{term F}\n    from @{term Cop} to a set category @{term S}, for each object @{term a} of @{term C},\n    the set of natural transformations from the contravariant functor @{term \"Y a\"}\n    to @{term F} is in bijective correspondence with the set \\<open>F.SET a\\<close>\n    of elements of @{term \"F a\"}.\n\n    Explicitly, if @{term e} is an arbitrary element of the set \\<open>F.SET a\\<close>,\n    then the functions \\<open>\\<lambda>x. F.FUN (\\<psi> (b, a) x) e\\<close> are the components of a\n    natural transformation from @{term \"Y a\"} to @{term F}.\n    Conversely, if @{term \\<tau>} is a natural transformation from @{term \"Y a\"} to @{term F},\n    then the component @{term \"\\<tau> b\"} of @{term \\<tau>} at an arbitrary object @{term b}\n    is completely determined by the single arrow \\<open>\\<tau>.FUN a (\\<phi> (a, a) a)))\\<close>,\n    which is the the element of \\<open>F.SET a\\<close> that corresponds to the image of the\n    identity @{term a} under the function \\<open>\\<tau>.FUN a\\<close>.\n    Then @{term \"\\<tau> b\"} is the arrow from @{term \"Y a b\"} to @{term \"F b\"} corresponding\n    to the function \\<open>\\<lambda>x. (F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a)))\\<close>\n    from \\<open>S.set (Y a b)\\<close> to \\<open>F.SET b\\<close>.\n   \n    The above expressions look somewhat more complicated than the usual versions due to the\n    need to account for the coercions @{term \\<phi>} and @{term \\<psi>}.\n\\<close>"], ["", "locale yoneda_lemma =\n    C: category C +\n    Cop: dual_category C +\n    S: replete_set_category S +\n    F: set_valued_functor Cop.comp S F +\n    yoneda_functor_fixed_object C S \\<phi> a\n  for C :: \"'c comp\" (infixr \"\\<cdot>\" 55)\n  and S :: \"'s comp\" (infixr \"\\<cdot>\\<^sub>S\" 55)\n  and \\<phi> :: \"'c * 'c \\<Rightarrow> 'c \\<Rightarrow> 's\"\n  and F :: \"'c \\<Rightarrow> 's\"\n  and a :: 'c\n  begin"], ["", "text\\<open>\n      The mapping that evaluates the component @{term \"\\<tau> a\"} at @{term a} of a\n      natural transformation @{term \\<tau>} from @{term Y} to @{term F} on the element\n      @{term \"\\<phi> (a, a) a\"} of @{term \"SET a\"}, yielding an element of @{term \"F.SET a\"}.\n\\<close>"], ["", "definition \\<E> :: \"('c \\<Rightarrow> 's) \\<Rightarrow> 's\"\n    where \"\\<E> \\<tau> = S.Fun (\\<tau> a) (\\<phi> (a, a) a)\""], ["", "text\\<open>\n      The mapping that takes an element @{term e} of @{term \"F.SET a\"} and produces\n      a map on objects of @{term[source=true] C} whose value at @{term b} is the arrow of\n      @{term[source=true] S} corresponding to the function\n      @{term \"(\\<lambda>x. F.FUN (\\<psi> (b, a) x) e) \\<in> Hom.set (b, a) \\<rightarrow> F.SET b\"}.\n\\<close>"], ["", "definition \\<T>o :: \"'s \\<Rightarrow> 'c \\<Rightarrow> 's\"\n    where \"\\<T>o e b = S.mkArr (Hom.set (b, a)) (F.SET b) (\\<lambda>x. F.FUN (\\<psi> (b, a) x) e)\""], ["", "lemma \\<T>o_e_ide:\n    assumes e: \"e \\<in> S.set (F a)\" and b: \"C.ide b\"\n    shows \"\\<guillemotleft>\\<T>o e b : Y a b \\<rightarrow>\\<^sub>S F b\\<guillemotright>\"\n    and \"\\<T>o e b = S.mkArr (Hom.set (b, a)) (F.SET b) (\\<lambda>x. F.FUN (\\<psi> (b, a) x) e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<T>o e\n                     b : Y a b \\<rightarrow>\\<^sub>S F\n                b\\<guillemotright> &&&\n    \\<T>o e b =\n    S.mkArr (Hom.set (b, a)) (F.SET b)\n     (\\<lambda>x. F.FUN (\\<psi> (b, a) x) e)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<guillemotleft>\\<T>o e\n                     b : Y a b \\<rightarrow>\\<^sub>S F b\\<guillemotright>\n 2. \\<T>o e b =\n    S.mkArr (Hom.set (b, a)) (F.SET b)\n     (\\<lambda>x. F.FUN (\\<psi> (b, a) x) e)", "show \"\\<T>o e b = S.mkArr (Hom.set (b, a)) (F.SET b) (\\<lambda>x. F.FUN (\\<psi> (b, a) x) e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<T>o e b =\n    S.mkArr (Hom.set (b, a)) (F.SET b)\n     (\\<lambda>x. F.FUN (\\<psi> (b, a) x) e)", "using \\<T>o_def"], ["proof (prove)\nusing this:\n  \\<T>o ?e ?b =\n  S.mkArr (Hom.set (?b, a)) (F.SET ?b)\n   (\\<lambda>x. F.FUN (\\<psi> (?b, a) x) ?e)\n\ngoal (1 subgoal):\n 1. \\<T>o e b =\n    S.mkArr (Hom.set (b, a)) (F.SET b)\n     (\\<lambda>x. F.FUN (\\<psi> (b, a) x) e)", "by auto"], ["proof (state)\nthis:\n  \\<T>o e b =\n  S.mkArr (Hom.set (b, a)) (F.SET b) (\\<lambda>x. F.FUN (\\<psi> (b, a) x) e)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<T>o e\n                     b : Y a b \\<rightarrow>\\<^sub>S F b\\<guillemotright>", "moreover"], ["proof (state)\nthis:\n  \\<T>o e b =\n  S.mkArr (Hom.set (b, a)) (F.SET b) (\\<lambda>x. F.FUN (\\<psi> (b, a) x) e)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<T>o e\n                     b : Y a b \\<rightarrow>\\<^sub>S F b\\<guillemotright>", "have \"(\\<lambda>x. F.FUN (\\<psi> (b, a) x) e) \\<in> Hom.set (b, a) \\<rightarrow> F.SET b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. F.FUN (\\<psi> (b, a) x) e)\n    \\<in> Hom.set (b, a) \\<rightarrow> F.SET b", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Hom.set (b, a) \\<Longrightarrow>\n       F.FUN (\\<psi> (b, a) x) e \\<in> F.SET b", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Hom.set (b, a) \\<Longrightarrow>\n       F.FUN (\\<psi> (b, a) x) e \\<in> F.SET b", "assume x: \"x \\<in> Hom.set (b, a)\""], ["proof (state)\nthis:\n  x \\<in> Hom.set (b, a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Hom.set (b, a) \\<Longrightarrow>\n       F.FUN (\\<psi> (b, a) x) e \\<in> F.SET b", "hence \"\\<guillemotleft>\\<psi> (b, a) x : b \\<rightarrow> a\\<guillemotright>\""], ["proof (prove)\nusing this:\n  x \\<in> Hom.set (b, a)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<psi> (b, a) x : b \\<rightarrow> a\\<guillemotright>", "using assms ide_a Hom.\\<psi>_mapsto"], ["proof (prove)\nusing this:\n  x \\<in> Hom.set (b, a)\n  e \\<in> F.SET a\n  C.ide b\n  C.ide a\n  \\<lbrakk>C.ide ?b; C.ide ?a\\<rbrakk>\n  \\<Longrightarrow> \\<psi> (?b, ?a)\n                    \\<in> Hom.set (?b, ?a) \\<rightarrow> C.hom ?b ?a\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<psi> (b, a) x : b \\<rightarrow> a\\<guillemotright>", "by auto"], ["proof (state)\nthis:\n  \\<guillemotleft>\\<psi> (b, a) x : b \\<rightarrow> a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Hom.set (b, a) \\<Longrightarrow>\n       F.FUN (\\<psi> (b, a) x) e \\<in> F.SET b", "hence \"F.FUN (\\<psi> (b, a) x) \\<in> F.SET a \\<rightarrow> F.SET b\""], ["proof (prove)\nusing this:\n  \\<guillemotleft>\\<psi> (b, a) x : b \\<rightarrow> a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. F.FUN (\\<psi> (b, a) x) \\<in> F.SET a \\<rightarrow> F.SET b", "using S.Fun_mapsto [of \"F (\\<psi> (b, a) x)\"]"], ["proof (prove)\nusing this:\n  \\<guillemotleft>\\<psi> (b, a) x : b \\<rightarrow> a\\<guillemotright>\n  S.arr (F (\\<psi> (b, a) x)) \\<Longrightarrow>\n  F.FUN (\\<psi> (b, a) x)\n  \\<in> extensional (F.DOM (\\<psi> (b, a) x)) \\<inter>\n        (F.DOM (\\<psi> (b, a) x) \\<rightarrow> F.COD (\\<psi> (b, a) x))\n\ngoal (1 subgoal):\n 1. F.FUN (\\<psi> (b, a) x) \\<in> F.SET a \\<rightarrow> F.SET b", "by fastforce"], ["proof (state)\nthis:\n  F.FUN (\\<psi> (b, a) x) \\<in> F.SET a \\<rightarrow> F.SET b\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Hom.set (b, a) \\<Longrightarrow>\n       F.FUN (\\<psi> (b, a) x) e \\<in> F.SET b", "thus \"F.FUN (\\<psi> (b, a) x) e \\<in> F.SET b\""], ["proof (prove)\nusing this:\n  F.FUN (\\<psi> (b, a) x) \\<in> F.SET a \\<rightarrow> F.SET b\n\ngoal (1 subgoal):\n 1. F.FUN (\\<psi> (b, a) x) e \\<in> F.SET b", "using e"], ["proof (prove)\nusing this:\n  F.FUN (\\<psi> (b, a) x) \\<in> F.SET a \\<rightarrow> F.SET b\n  e \\<in> F.SET a\n\ngoal (1 subgoal):\n 1. F.FUN (\\<psi> (b, a) x) e \\<in> F.SET b", "by auto"], ["proof (state)\nthis:\n  F.FUN (\\<psi> (b, a) x) e \\<in> F.SET b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>x. F.FUN (\\<psi> (b, a) x) e)\n  \\<in> Hom.set (b, a) \\<rightarrow> F.SET b\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<T>o e\n                     b : Y a b \\<rightarrow>\\<^sub>S F b\\<guillemotright>", "ultimately"], ["proof (chain)\npicking this:\n  \\<T>o e b =\n  S.mkArr (Hom.set (b, a)) (F.SET b) (\\<lambda>x. F.FUN (\\<psi> (b, a) x) e)\n  (\\<lambda>x. F.FUN (\\<psi> (b, a) x) e)\n  \\<in> Hom.set (b, a) \\<rightarrow> F.SET b", "show \"\\<guillemotleft>\\<T>o e b : Y a b \\<rightarrow>\\<^sub>S F b\\<guillemotright>\""], ["proof (prove)\nusing this:\n  \\<T>o e b =\n  S.mkArr (Hom.set (b, a)) (F.SET b) (\\<lambda>x. F.FUN (\\<psi> (b, a) x) e)\n  (\\<lambda>x. F.FUN (\\<psi> (b, a) x) e)\n  \\<in> Hom.set (b, a) \\<rightarrow> F.SET b\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<T>o e\n                     b : Y a b \\<rightarrow>\\<^sub>S F b\\<guillemotright>", "using ide_a b S.mkArr_in_hom [of \"Hom.set (b, a)\" \"F.SET b\"] Hom.set_subset_Univ\n              S.mkIde_set"], ["proof (prove)\nusing this:\n  \\<T>o e b =\n  S.mkArr (Hom.set (b, a)) (F.SET b) (\\<lambda>x. F.FUN (\\<psi> (b, a) x) e)\n  (\\<lambda>x. F.FUN (\\<psi> (b, a) x) e)\n  \\<in> Hom.set (b, a) \\<rightarrow> F.SET b\n  C.ide a\n  C.ide b\n  \\<lbrakk>Hom.set (b, a) \\<subseteq> S.Univ; F.SET b \\<subseteq> S.Univ;\n   ?F \\<in> Hom.set (b, a) \\<rightarrow> F.SET b\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>S.mkArr (Hom.set (b, a)) (F.SET b)\n                                     ?F : S.mkIde\n     (Hom.set\n       (b, a)) \\<rightarrow>\\<^sub>S S.mkIde (F.SET b)\\<guillemotright>\n  \\<lbrakk>C.ide ?b; C.ide ?a\\<rbrakk>\n  \\<Longrightarrow> Hom.set (?b, ?a) \\<subseteq> S.Univ\n  S.ide ?a \\<Longrightarrow> S.mkIde (S.set ?a) = ?a\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<T>o e\n                     b : Y a b \\<rightarrow>\\<^sub>S F b\\<guillemotright>", "by auto"], ["proof (state)\nthis:\n  \\<guillemotleft>\\<T>o e\n                   b : Y a b \\<rightarrow>\\<^sub>S F b\\<guillemotright>\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n      For each @{term \"e \\<in> F.SET a\"}, the mapping @{term \"\\<T>o e\"} gives the components\n      of a natural transformation @{term \\<T>} from @{term \"Y a\"} to @{term F}.\n\\<close>"], ["", "lemma \\<T>o_e_induces_transformation:\n    assumes e: \"e \\<in> S.set (F a)\"\n    shows \"transformation_by_components Cop.comp S (Y a) F (\\<T>o e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. transformation_by_components (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S)\n     (Y a) F (\\<T>o e)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>aa.\n       Cop.ide aa \\<Longrightarrow>\n       \\<guillemotleft>\\<T>o e\n                        aa : Y a aa \\<rightarrow>\\<^sub>S F\n                     aa\\<guillemotright>\n 2. \\<And>f.\n       Cop.arr f \\<Longrightarrow>\n       \\<T>o e (Cop.cod f) \\<cdot>\\<^sub>S Y a f =\n       F f \\<cdot>\\<^sub>S \\<T>o e (Cop.dom f)", "fix b :: 'c"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>aa.\n       Cop.ide aa \\<Longrightarrow>\n       \\<guillemotleft>\\<T>o e\n                        aa : Y a aa \\<rightarrow>\\<^sub>S F\n                     aa\\<guillemotright>\n 2. \\<And>f.\n       Cop.arr f \\<Longrightarrow>\n       \\<T>o e (Cop.cod f) \\<cdot>\\<^sub>S Y a f =\n       F f \\<cdot>\\<^sub>S \\<T>o e (Cop.dom f)", "assume b: \"Cop.ide b\""], ["proof (state)\nthis:\n  Cop.ide b\n\ngoal (2 subgoals):\n 1. \\<And>aa.\n       Cop.ide aa \\<Longrightarrow>\n       \\<guillemotleft>\\<T>o e\n                        aa : Y a aa \\<rightarrow>\\<^sub>S F\n                     aa\\<guillemotright>\n 2. \\<And>f.\n       Cop.arr f \\<Longrightarrow>\n       \\<T>o e (Cop.cod f) \\<cdot>\\<^sub>S Y a f =\n       F f \\<cdot>\\<^sub>S \\<T>o e (Cop.dom f)", "show \"\\<guillemotleft>\\<T>o e b : Y a b \\<rightarrow>\\<^sub>S F b\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<T>o e\n                     b : Y a b \\<rightarrow>\\<^sub>S F b\\<guillemotright>", "using ide_a b e \\<T>o_e_ide"], ["proof (prove)\nusing this:\n  C.ide a\n  Cop.ide b\n  e \\<in> F.SET a\n  \\<lbrakk>?e \\<in> F.SET a; C.ide ?b\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>\\<T>o ?e\n                                     ?b : Y a\n     ?b \\<rightarrow>\\<^sub>S F ?b\\<guillemotright>\n  \\<lbrakk>?e \\<in> F.SET a; C.ide ?b\\<rbrakk>\n  \\<Longrightarrow> \\<T>o ?e ?b =\n                    S.mkArr (Hom.set (?b, a)) (F.SET ?b)\n                     (\\<lambda>x. F.FUN (\\<psi> (?b, a) x) ?e)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<T>o e\n                     b : Y a b \\<rightarrow>\\<^sub>S F b\\<guillemotright>", "by simp"], ["proof (state)\nthis:\n  \\<guillemotleft>\\<T>o e\n                   b : Y a b \\<rightarrow>\\<^sub>S F b\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       Cop.arr f \\<Longrightarrow>\n       \\<T>o e (Cop.cod f) \\<cdot>\\<^sub>S Y a f =\n       F f \\<cdot>\\<^sub>S \\<T>o e (Cop.dom f)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       Cop.arr f \\<Longrightarrow>\n       \\<T>o e (Cop.cod f) \\<cdot>\\<^sub>S Y a f =\n       F f \\<cdot>\\<^sub>S \\<T>o e (Cop.dom f)", "fix g :: 'c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       Cop.arr f \\<Longrightarrow>\n       \\<T>o e (Cop.cod f) \\<cdot>\\<^sub>S Y a f =\n       F f \\<cdot>\\<^sub>S \\<T>o e (Cop.dom f)", "assume g: \"Cop.arr g\""], ["proof (state)\nthis:\n  Cop.arr g\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       Cop.arr f \\<Longrightarrow>\n       \\<T>o e (Cop.cod f) \\<cdot>\\<^sub>S Y a f =\n       F f \\<cdot>\\<^sub>S \\<T>o e (Cop.dom f)", "let ?b = \"Cop.dom g\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       Cop.arr f \\<Longrightarrow>\n       \\<T>o e (Cop.cod f) \\<cdot>\\<^sub>S Y a f =\n       F f \\<cdot>\\<^sub>S \\<T>o e (Cop.dom f)", "let ?b' = \"Cop.cod g\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       Cop.arr f \\<Longrightarrow>\n       \\<T>o e (Cop.cod f) \\<cdot>\\<^sub>S Y a f =\n       F f \\<cdot>\\<^sub>S \\<T>o e (Cop.dom f)", "show \"\\<T>o e (Cop.cod g) \\<cdot>\\<^sub>S Y a g = F g \\<cdot>\\<^sub>S \\<T>o e (Cop.dom g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<T>o e (Cop.cod g) \\<cdot>\\<^sub>S Y a g =\n    F g \\<cdot>\\<^sub>S \\<T>o e (Cop.dom g)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<T>o e (Cop.cod g) \\<cdot>\\<^sub>S Y a g =\n    F g \\<cdot>\\<^sub>S \\<T>o e (Cop.dom g)", "have 1: \"\\<T>o e (Cop.cod g) \\<cdot>\\<^sub>S Y a g\n                   = S.mkArr (Hom.set (?b, a)) (F.SET ?b')\n                             ((\\<lambda>x. F.FUN (\\<psi> (?b', a) x) e)\n                                o (\\<phi> (?b', a) o Cop.comp g o \\<psi> (?b, a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<T>o e (Cop.cod g) \\<cdot>\\<^sub>S Y a g =\n    S.mkArr (Hom.set (Cop.dom g, a)) (F.SET (Cop.cod g))\n     ((\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n      (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n       \\<psi> (Cop.dom g, a)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<T>o e (Cop.cod g) \\<cdot>\\<^sub>S Y a g =\n    S.mkArr (Hom.set (Cop.dom g, a)) (F.SET (Cop.cod g))\n     ((\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n      (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n       \\<psi> (Cop.dom g, a)))", "have \"S.arr (S.mkArr (Hom.set (Cop.cod g, a)) (F.SET (Cop.cod g))\n                      (\\<lambda>s. F.FUN (\\<psi> (Cop.cod g, a) s) e)) \\<and>\n                S.dom (S.mkArr (Hom.set (Cop.cod g, a)) (F.SET (Cop.cod g))\n                      (\\<lambda>s. F.FUN (\\<psi> (Cop.cod g, a) s) e)) = Y a (Cop.cod g) \\<and>\n                S.cod (S.mkArr (Hom.set (Cop.cod g, a)) (F.SET (Cop.cod g))\n                      (\\<lambda>s. F.FUN (\\<psi> (Cop.cod g, a) s) e)) = F (Cop.cod g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.arr\n     (S.mkArr (Hom.set (Cop.cod g, a)) (F.SET (Cop.cod g))\n       (\\<lambda>s. F.FUN (\\<psi> (Cop.cod g, a) s) e)) \\<and>\n    S.dom\n     (S.mkArr (Hom.set (Cop.cod g, a)) (F.SET (Cop.cod g))\n       (\\<lambda>s. F.FUN (\\<psi> (Cop.cod g, a) s) e)) =\n    Y a (Cop.cod g) \\<and>\n    S.cod\n     (S.mkArr (Hom.set (Cop.cod g, a)) (F.SET (Cop.cod g))\n       (\\<lambda>s. F.FUN (\\<psi> (Cop.cod g, a) s) e)) =\n    F (Cop.cod g)", "using Cop.cod_char \\<T>o_e_ide [of e ?b'] \\<T>o_e_ide [of e ?b'] e g"], ["proof (prove)\nusing this:\n  Cop.cod ?f = C.dom ?f\n  \\<lbrakk>e \\<in> F.SET a; C.ide (Cop.cod g)\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>\\<T>o e\n                                     (Cop.cod\n g) : Y a (Cop.cod g) \\<rightarrow>\\<^sub>S F (Cop.cod g)\\<guillemotright>\n  \\<lbrakk>e \\<in> F.SET a; C.ide (Cop.cod g)\\<rbrakk>\n  \\<Longrightarrow> \\<T>o e (Cop.cod g) =\n                    S.mkArr (Hom.set (Cop.cod g, a)) (F.SET (Cop.cod g))\n                     (\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e)\n  \\<lbrakk>e \\<in> F.SET a; C.ide (Cop.cod g)\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>\\<T>o e\n                                     (Cop.cod\n g) : Y a (Cop.cod g) \\<rightarrow>\\<^sub>S F (Cop.cod g)\\<guillemotright>\n  \\<lbrakk>e \\<in> F.SET a; C.ide (Cop.cod g)\\<rbrakk>\n  \\<Longrightarrow> \\<T>o e (Cop.cod g) =\n                    S.mkArr (Hom.set (Cop.cod g, a)) (F.SET (Cop.cod g))\n                     (\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e)\n  e \\<in> F.SET a\n  Cop.arr g\n\ngoal (1 subgoal):\n 1. S.arr\n     (S.mkArr (Hom.set (Cop.cod g, a)) (F.SET (Cop.cod g))\n       (\\<lambda>s. F.FUN (\\<psi> (Cop.cod g, a) s) e)) \\<and>\n    S.dom\n     (S.mkArr (Hom.set (Cop.cod g, a)) (F.SET (Cop.cod g))\n       (\\<lambda>s. F.FUN (\\<psi> (Cop.cod g, a) s) e)) =\n    Y a (Cop.cod g) \\<and>\n    S.cod\n     (S.mkArr (Hom.set (Cop.cod g, a)) (F.SET (Cop.cod g))\n       (\\<lambda>s. F.FUN (\\<psi> (Cop.cod g, a) s) e)) =\n    F (Cop.cod g)", "by (metis Cop.ide_char Cop.ide_cod S.in_homE)"], ["proof (state)\nthis:\n  S.arr\n   (S.mkArr (Hom.set (Cop.cod g, a)) (F.SET (Cop.cod g))\n     (\\<lambda>s. F.FUN (\\<psi> (Cop.cod g, a) s) e)) \\<and>\n  S.dom\n   (S.mkArr (Hom.set (Cop.cod g, a)) (F.SET (Cop.cod g))\n     (\\<lambda>s. F.FUN (\\<psi> (Cop.cod g, a) s) e)) =\n  Y a (Cop.cod g) \\<and>\n  S.cod\n   (S.mkArr (Hom.set (Cop.cod g, a)) (F.SET (Cop.cod g))\n     (\\<lambda>s. F.FUN (\\<psi> (Cop.cod g, a) s) e)) =\n  F (Cop.cod g)\n\ngoal (1 subgoal):\n 1. \\<T>o e (Cop.cod g) \\<cdot>\\<^sub>S Y a g =\n    S.mkArr (Hom.set (Cop.dom g, a)) (F.SET (Cop.cod g))\n     ((\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n      (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n       \\<psi> (Cop.dom g, a)))", "moreover"], ["proof (state)\nthis:\n  S.arr\n   (S.mkArr (Hom.set (Cop.cod g, a)) (F.SET (Cop.cod g))\n     (\\<lambda>s. F.FUN (\\<psi> (Cop.cod g, a) s) e)) \\<and>\n  S.dom\n   (S.mkArr (Hom.set (Cop.cod g, a)) (F.SET (Cop.cod g))\n     (\\<lambda>s. F.FUN (\\<psi> (Cop.cod g, a) s) e)) =\n  Y a (Cop.cod g) \\<and>\n  S.cod\n   (S.mkArr (Hom.set (Cop.cod g, a)) (F.SET (Cop.cod g))\n     (\\<lambda>s. F.FUN (\\<psi> (Cop.cod g, a) s) e)) =\n  F (Cop.cod g)\n\ngoal (1 subgoal):\n 1. \\<T>o e (Cop.cod g) \\<cdot>\\<^sub>S Y a g =\n    S.mkArr (Hom.set (Cop.dom g, a)) (F.SET (Cop.cod g))\n     ((\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n      (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n       \\<psi> (Cop.dom g, a)))", "have \"Y a g = S.mkArr (Hom.set (Cop.dom g, a)) (Hom.set (Cop.cod g, a))\n                                         (\\<phi> (Cop.cod g, a) \\<circ> Cop.comp g \\<circ> \\<psi> (Cop.dom g, a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y a g =\n    S.mkArr (Hom.set (Cop.dom g, a)) (Hom.set (Cop.cod g, a))\n     (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n      \\<psi> (Cop.dom g, a))", "using Y_ide_arr [of a g ?b' ?b] ide_a g"], ["proof (prove)\nusing this:\n  \\<lbrakk>C.ide a;\n   \\<guillemotleft>g : Cop.cod\n                        g \\<rightarrow> Cop.dom g\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>Y a g : Hom.map\n       (Cop.dom g,\n        a) \\<rightarrow>\\<^sub>S Hom.map (Cop.cod g, a)\\<guillemotright>\n  \\<lbrakk>C.ide a;\n   \\<guillemotleft>g : Cop.cod\n                        g \\<rightarrow> Cop.dom g\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> Y a g =\n                    S.mkArr (Hom.set (Cop.dom g, a))\n                     (Hom.set (Cop.cod g, a))\n                     (\\<phi> (Cop.cod g, a) \\<circ>\n                      (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n                      \\<psi> (Cop.dom g, a))\n  C.ide a\n  Cop.arr g\n\ngoal (1 subgoal):\n 1. Y a g =\n    S.mkArr (Hom.set (Cop.dom g, a)) (Hom.set (Cop.cod g, a))\n     (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n      \\<psi> (Cop.dom g, a))", "by auto"], ["proof (state)\nthis:\n  Y a g =\n  S.mkArr (Hom.set (Cop.dom g, a)) (Hom.set (Cop.cod g, a))\n   (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n    \\<psi> (Cop.dom g, a))\n\ngoal (1 subgoal):\n 1. \\<T>o e (Cop.cod g) \\<cdot>\\<^sub>S Y a g =\n    S.mkArr (Hom.set (Cop.dom g, a)) (F.SET (Cop.cod g))\n     ((\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n      (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n       \\<psi> (Cop.dom g, a)))", "ultimately"], ["proof (chain)\npicking this:\n  S.arr\n   (S.mkArr (Hom.set (Cop.cod g, a)) (F.SET (Cop.cod g))\n     (\\<lambda>s. F.FUN (\\<psi> (Cop.cod g, a) s) e)) \\<and>\n  S.dom\n   (S.mkArr (Hom.set (Cop.cod g, a)) (F.SET (Cop.cod g))\n     (\\<lambda>s. F.FUN (\\<psi> (Cop.cod g, a) s) e)) =\n  Y a (Cop.cod g) \\<and>\n  S.cod\n   (S.mkArr (Hom.set (Cop.cod g, a)) (F.SET (Cop.cod g))\n     (\\<lambda>s. F.FUN (\\<psi> (Cop.cod g, a) s) e)) =\n  F (Cop.cod g)\n  Y a g =\n  S.mkArr (Hom.set (Cop.dom g, a)) (Hom.set (Cop.cod g, a))\n   (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n    \\<psi> (Cop.dom g, a))", "show ?thesis"], ["proof (prove)\nusing this:\n  S.arr\n   (S.mkArr (Hom.set (Cop.cod g, a)) (F.SET (Cop.cod g))\n     (\\<lambda>s. F.FUN (\\<psi> (Cop.cod g, a) s) e)) \\<and>\n  S.dom\n   (S.mkArr (Hom.set (Cop.cod g, a)) (F.SET (Cop.cod g))\n     (\\<lambda>s. F.FUN (\\<psi> (Cop.cod g, a) s) e)) =\n  Y a (Cop.cod g) \\<and>\n  S.cod\n   (S.mkArr (Hom.set (Cop.cod g, a)) (F.SET (Cop.cod g))\n     (\\<lambda>s. F.FUN (\\<psi> (Cop.cod g, a) s) e)) =\n  F (Cop.cod g)\n  Y a g =\n  S.mkArr (Hom.set (Cop.dom g, a)) (Hom.set (Cop.cod g, a))\n   (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n    \\<psi> (Cop.dom g, a))\n\ngoal (1 subgoal):\n 1. \\<T>o e (Cop.cod g) \\<cdot>\\<^sub>S Y a g =\n    S.mkArr (Hom.set (Cop.dom g, a)) (F.SET (Cop.cod g))\n     ((\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n      (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n       \\<psi> (Cop.dom g, a)))", "using ide_a e g Y_ide_arr Cop.cod_char \\<T>o_e_ide\n                  S.comp_mkArr [of \"Hom.set (?b, a)\" \"Hom.set (?b', a)\"\n                                   \"\\<phi> (?b', a) o Cop.comp g o \\<psi> (?b, a)\"\n                                   \"F.SET ?b'\" \"\\<lambda>x. F.FUN (\\<psi> (?b', a) x) e\"]"], ["proof (prove)\nusing this:\n  S.arr\n   (S.mkArr (Hom.set (Cop.cod g, a)) (F.SET (Cop.cod g))\n     (\\<lambda>s. F.FUN (\\<psi> (Cop.cod g, a) s) e)) \\<and>\n  S.dom\n   (S.mkArr (Hom.set (Cop.cod g, a)) (F.SET (Cop.cod g))\n     (\\<lambda>s. F.FUN (\\<psi> (Cop.cod g, a) s) e)) =\n  Y a (Cop.cod g) \\<and>\n  S.cod\n   (S.mkArr (Hom.set (Cop.cod g, a)) (F.SET (Cop.cod g))\n     (\\<lambda>s. F.FUN (\\<psi> (Cop.cod g, a) s) e)) =\n  F (Cop.cod g)\n  Y a g =\n  S.mkArr (Hom.set (Cop.dom g, a)) (Hom.set (Cop.cod g, a))\n   (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n    \\<psi> (Cop.dom g, a))\n  C.ide a\n  e \\<in> F.SET a\n  Cop.arr g\n  \\<lbrakk>C.ide ?a;\n   \\<guillemotleft>?g : ?b' \\<rightarrow> ?b\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>Y ?a\n                                     ?g : Hom.map\n     (?b, ?a) \\<rightarrow>\\<^sub>S Hom.map (?b', ?a)\\<guillemotright>\n  \\<lbrakk>C.ide ?a;\n   \\<guillemotleft>?g : ?b' \\<rightarrow> ?b\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> Y ?a ?g =\n                    S.mkArr (Hom.set (?b, ?a)) (Hom.set (?b', ?a))\n                     (\\<phi> (?b', ?a) \\<circ>\n                      (\\<cdot>\\<^sup>o\\<^sup>p) ?g \\<circ>\n                      \\<psi> (?b, ?a))\n  Cop.cod ?f = C.dom ?f\n  \\<lbrakk>?e \\<in> F.SET a; C.ide ?b\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>\\<T>o ?e\n                                     ?b : Y a\n     ?b \\<rightarrow>\\<^sub>S F ?b\\<guillemotright>\n  \\<lbrakk>?e \\<in> F.SET a; C.ide ?b\\<rbrakk>\n  \\<Longrightarrow> \\<T>o ?e ?b =\n                    S.mkArr (Hom.set (?b, a)) (F.SET ?b)\n                     (\\<lambda>x. F.FUN (\\<psi> (?b, a) x) ?e)\n  \\<lbrakk>S.arr\n            (S.mkArr (Hom.set (Cop.dom g, a)) (Hom.set (Cop.cod g, a))\n              (\\<phi> (Cop.cod g, a) \\<circ>\n               (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n               \\<psi> (Cop.dom g, a)));\n   S.arr\n    (S.mkArr (Hom.set (Cop.cod g, a)) (F.SET (Cop.cod g))\n      (\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e))\\<rbrakk>\n  \\<Longrightarrow> S.mkArr (Hom.set (Cop.cod g, a)) (F.SET (Cop.cod g))\n                     (\\<lambda>x.\n                         F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<cdot>\\<^sub>S\n                    S.mkArr (Hom.set (Cop.dom g, a))\n                     (Hom.set (Cop.cod g, a))\n                     (\\<phi> (Cop.cod g, a) \\<circ>\n                      (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n                      \\<psi> (Cop.dom g, a)) =\n                    S.mkArr (Hom.set (Cop.dom g, a)) (F.SET (Cop.cod g))\n                     ((\\<lambda>x.\n                          F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n                      (\\<phi> (Cop.cod g, a) \\<circ>\n                       (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n                       \\<psi> (Cop.dom g, a)))\n\ngoal (1 subgoal):\n 1. \\<T>o e (Cop.cod g) \\<cdot>\\<^sub>S Y a g =\n    S.mkArr (Hom.set (Cop.dom g, a)) (F.SET (Cop.cod g))\n     ((\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n      (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n       \\<psi> (Cop.dom g, a)))", "by (metis C.ide_dom Cop.arr_char preserves_arr)"], ["proof (state)\nthis:\n  \\<T>o e (Cop.cod g) \\<cdot>\\<^sub>S Y a g =\n  S.mkArr (Hom.set (Cop.dom g, a)) (F.SET (Cop.cod g))\n   ((\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n    (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n     \\<psi> (Cop.dom g, a)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<T>o e (Cop.cod g) \\<cdot>\\<^sub>S Y a g =\n  S.mkArr (Hom.set (Cop.dom g, a)) (F.SET (Cop.cod g))\n   ((\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n    (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n     \\<psi> (Cop.dom g, a)))\n\ngoal (1 subgoal):\n 1. \\<T>o e (Cop.cod g) \\<cdot>\\<^sub>S Y a g =\n    F g \\<cdot>\\<^sub>S \\<T>o e (Cop.dom g)", "also"], ["proof (state)\nthis:\n  \\<T>o e (Cop.cod g) \\<cdot>\\<^sub>S Y a g =\n  S.mkArr (Hom.set (Cop.dom g, a)) (F.SET (Cop.cod g))\n   ((\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n    (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n     \\<psi> (Cop.dom g, a)))\n\ngoal (1 subgoal):\n 1. \\<T>o e (Cop.cod g) \\<cdot>\\<^sub>S Y a g =\n    F g \\<cdot>\\<^sub>S \\<T>o e (Cop.dom g)", "have \"... = S.mkArr (Hom.set (?b, a)) (F.SET ?b')\n                                 (F.FUN g o (\\<lambda>x. F.FUN (\\<psi> (?b, a) x) e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.mkArr (Hom.set (Cop.dom g, a)) (F.SET (Cop.cod g))\n     ((\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n      (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n       \\<psi> (Cop.dom g, a))) =\n    S.mkArr (Hom.set (Cop.dom g, a)) (F.SET (Cop.cod g))\n     (F.FUN g \\<circ> (\\<lambda>x. F.FUN (\\<psi> (Cop.dom g, a) x) e))", "proof (intro S.mkArr_eqI')"], ["proof (state)\ngoal (2 subgoals):\n 1. S.arr\n     (S.mkArr (Hom.set (Cop.dom g, a)) (F.SET (Cop.cod g))\n       ((\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n        (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n         \\<psi> (Cop.dom g, a))))\n 2. \\<And>x.\n       x \\<in> Hom.set (Cop.dom g, a) \\<Longrightarrow>\n       ((\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n        (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n         \\<psi> (Cop.dom g, a)))\n        x =\n       (F.FUN g \\<circ> (\\<lambda>x. F.FUN (\\<psi> (Cop.dom g, a) x) e)) x", "have \"(\\<lambda>x. F.FUN (\\<psi> (?b', a) x) e)\n                   o (\\<phi> (?b', a) o Cop.comp g o \\<psi> (?b, a)) \\<in> Hom.set (?b, a) \\<rightarrow> F.SET ?b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n    (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n     \\<psi> (Cop.dom g, a))\n    \\<in> Hom.set (Cop.dom g, a) \\<rightarrow> F.SET (Cop.cod g)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n    (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n     \\<psi> (Cop.dom g, a))\n    \\<in> Hom.set (Cop.dom g, a) \\<rightarrow> F.SET (Cop.cod g)", "have \"S.arr (S (\\<T>o e ?b') (Y a g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.seq (\\<T>o e (Cop.cod g)) (Y a g)", "using ide_a e g \\<T>o_e_ide [of e ?b'] Y_ide_arr(1) [of a \"C.dom g\" \"C.cod g\" g]\n                    Cop.ide_char Cop.ide_cod"], ["proof (prove)\nusing this:\n  C.ide a\n  e \\<in> F.SET a\n  Cop.arr g\n  \\<lbrakk>e \\<in> F.SET a; C.ide (Cop.cod g)\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>\\<T>o e\n                                     (Cop.cod\n g) : Y a (Cop.cod g) \\<rightarrow>\\<^sub>S F (Cop.cod g)\\<guillemotright>\n  \\<lbrakk>e \\<in> F.SET a; C.ide (Cop.cod g)\\<rbrakk>\n  \\<Longrightarrow> \\<T>o e (Cop.cod g) =\n                    S.mkArr (Hom.set (Cop.cod g, a)) (F.SET (Cop.cod g))\n                     (\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e)\n  \\<lbrakk>C.ide a;\n   \\<guillemotleft>C.dom\n                    g : C.cod g \\<rightarrow> g\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>Y a (C.dom\n    g) : Hom.map\n          (g, a) \\<rightarrow>\\<^sub>S Hom.map (C.cod g, a)\\<guillemotright>\n  Cop.ide ?a = C.ide ?a\n  Cop.arr ?f \\<Longrightarrow> Cop.ide (Cop.cod ?f)\n\ngoal (1 subgoal):\n 1. S.seq (\\<T>o e (Cop.cod g)) (Y a g)", "by blast"], ["proof (state)\nthis:\n  S.seq (\\<T>o e (Cop.cod g)) (Y a g)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n    (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n     \\<psi> (Cop.dom g, a))\n    \\<in> Hom.set (Cop.dom g, a) \\<rightarrow> F.SET (Cop.cod g)", "thus ?thesis"], ["proof (prove)\nusing this:\n  S.seq (\\<T>o e (Cop.cod g)) (Y a g)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n    (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n     \\<psi> (Cop.dom g, a))\n    \\<in> Hom.set (Cop.dom g, a) \\<rightarrow> F.SET (Cop.cod g)", "using 1 S.arr_mkArr"], ["proof (prove)\nusing this:\n  S.seq (\\<T>o e (Cop.cod g)) (Y a g)\n  \\<T>o e (Cop.cod g) \\<cdot>\\<^sub>S Y a g =\n  S.mkArr (Hom.set (Cop.dom g, a)) (F.SET (Cop.cod g))\n   ((\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n    (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n     \\<psi> (Cop.dom g, a)))\n  S.arr (S.mkArr ?A ?B ?F) =\n  (?A \\<subseteq> S.Univ \\<and>\n   ?B \\<subseteq> S.Univ \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n    (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n     \\<psi> (Cop.dom g, a))\n    \\<in> Hom.set (Cop.dom g, a) \\<rightarrow> F.SET (Cop.cod g)", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n  (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n   \\<psi> (Cop.dom g, a))\n  \\<in> Hom.set (Cop.dom g, a) \\<rightarrow> F.SET (Cop.cod g)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n  (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n   \\<psi> (Cop.dom g, a))\n  \\<in> Hom.set (Cop.dom g, a) \\<rightarrow> F.SET (Cop.cod g)\n\ngoal (2 subgoals):\n 1. S.arr\n     (S.mkArr (Hom.set (Cop.dom g, a)) (F.SET (Cop.cod g))\n       ((\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n        (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n         \\<psi> (Cop.dom g, a))))\n 2. \\<And>x.\n       x \\<in> Hom.set (Cop.dom g, a) \\<Longrightarrow>\n       ((\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n        (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n         \\<psi> (Cop.dom g, a)))\n        x =\n       (F.FUN g \\<circ> (\\<lambda>x. F.FUN (\\<psi> (Cop.dom g, a) x) e)) x", "thus \"S.arr (S.mkArr (Hom.set (?b, a)) (F.SET ?b')\n                               ((\\<lambda>x. F.FUN (\\<psi> (?b', a) x) e)\n                                  o (\\<phi> (?b', a) o Cop.comp g o \\<psi> (?b, a))))\""], ["proof (prove)\nusing this:\n  (\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n  (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n   \\<psi> (Cop.dom g, a))\n  \\<in> Hom.set (Cop.dom g, a) \\<rightarrow> F.SET (Cop.cod g)\n\ngoal (1 subgoal):\n 1. S.arr\n     (S.mkArr (Hom.set (Cop.dom g, a)) (F.SET (Cop.cod g))\n       ((\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n        (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n         \\<psi> (Cop.dom g, a))))", "using ide_a e g Hom.set_subset_Univ S.arr_mkArr"], ["proof (prove)\nusing this:\n  (\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n  (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n   \\<psi> (Cop.dom g, a))\n  \\<in> Hom.set (Cop.dom g, a) \\<rightarrow> F.SET (Cop.cod g)\n  C.ide a\n  e \\<in> F.SET a\n  Cop.arr g\n  \\<lbrakk>C.ide ?b; C.ide ?a\\<rbrakk>\n  \\<Longrightarrow> Hom.set (?b, ?a) \\<subseteq> S.Univ\n  S.arr (S.mkArr ?A ?B ?F) =\n  (?A \\<subseteq> S.Univ \\<and>\n   ?B \\<subseteq> S.Univ \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n\ngoal (1 subgoal):\n 1. S.arr\n     (S.mkArr (Hom.set (Cop.dom g, a)) (F.SET (Cop.cod g))\n       ((\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n        (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n         \\<psi> (Cop.dom g, a))))", "by force"], ["proof (state)\nthis:\n  S.arr\n   (S.mkArr (Hom.set (Cop.dom g, a)) (F.SET (Cop.cod g))\n     ((\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n      (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n       \\<psi> (Cop.dom g, a))))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Hom.set (Cop.dom g, a) \\<Longrightarrow>\n       ((\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n        (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n         \\<psi> (Cop.dom g, a)))\n        x =\n       (F.FUN g \\<circ> (\\<lambda>x. F.FUN (\\<psi> (Cop.dom g, a) x) e)) x", "show \"\\<And>x. x \\<in> Hom.set (?b, a) \\<Longrightarrow>\n                        ((\\<lambda>x. F.FUN (\\<psi> (?b', a) x) e) o (\\<phi> (?b', a) o Cop.comp g o \\<psi> (?b, a))) x\n                        = (F.FUN g o (\\<lambda>x. F.FUN (\\<psi> (?b, a) x) e)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Hom.set (Cop.dom g, a) \\<Longrightarrow>\n       ((\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n        (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n         \\<psi> (Cop.dom g, a)))\n        x =\n       (F.FUN g \\<circ> (\\<lambda>x. F.FUN (\\<psi> (Cop.dom g, a) x) e)) x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Hom.set (Cop.dom g, a) \\<Longrightarrow>\n       ((\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n        (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n         \\<psi> (Cop.dom g, a)))\n        x =\n       (F.FUN g \\<circ> (\\<lambda>x. F.FUN (\\<psi> (Cop.dom g, a) x) e)) x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Hom.set (Cop.dom g, a) \\<Longrightarrow>\n       ((\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n        (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n         \\<psi> (Cop.dom g, a)))\n        x =\n       (F.FUN g \\<circ> (\\<lambda>x. F.FUN (\\<psi> (Cop.dom g, a) x) e)) x", "assume x: \"x \\<in> Hom.set (?b, a)\""], ["proof (state)\nthis:\n  x \\<in> Hom.set (Cop.dom g, a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Hom.set (Cop.dom g, a) \\<Longrightarrow>\n       ((\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n        (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n         \\<psi> (Cop.dom g, a)))\n        x =\n       (F.FUN g \\<circ> (\\<lambda>x. F.FUN (\\<psi> (Cop.dom g, a) x) e)) x", "have \"((\\<lambda>x. (F.FUN o \\<psi> (?b', a)) x e)\n                       o (\\<phi> (?b', a) o Cop.comp g o \\<psi> (?b, a))) x\n                    = F.FUN (\\<psi> (?b', a) (\\<phi> (?b', a) (C (\\<psi> (?b, a) x) g))) e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lambda>x. (F.FUN \\<circ> \\<psi> (Cop.cod g, a)) x e) \\<circ>\n     (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n      \\<psi> (Cop.dom g, a)))\n     x =\n    F.FUN\n     (\\<psi> (Cop.cod g, a)\n       (\\<phi> (Cop.cod g, a) (\\<psi> (Cop.dom g, a) x \\<cdot> g)))\n     e", "by simp"], ["proof (state)\nthis:\n  ((\\<lambda>x. (F.FUN \\<circ> \\<psi> (Cop.cod g, a)) x e) \\<circ>\n   (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n    \\<psi> (Cop.dom g, a)))\n   x =\n  F.FUN\n   (\\<psi> (Cop.cod g, a)\n     (\\<phi> (Cop.cod g, a) (\\<psi> (Cop.dom g, a) x \\<cdot> g)))\n   e\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Hom.set (Cop.dom g, a) \\<Longrightarrow>\n       ((\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n        (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n         \\<psi> (Cop.dom g, a)))\n        x =\n       (F.FUN g \\<circ> (\\<lambda>x. F.FUN (\\<psi> (Cop.dom g, a) x) e)) x", "also"], ["proof (state)\nthis:\n  ((\\<lambda>x. (F.FUN \\<circ> \\<psi> (Cop.cod g, a)) x e) \\<circ>\n   (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n    \\<psi> (Cop.dom g, a)))\n   x =\n  F.FUN\n   (\\<psi> (Cop.cod g, a)\n     (\\<phi> (Cop.cod g, a) (\\<psi> (Cop.dom g, a) x \\<cdot> g)))\n   e\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Hom.set (Cop.dom g, a) \\<Longrightarrow>\n       ((\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n        (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n         \\<psi> (Cop.dom g, a)))\n        x =\n       (F.FUN g \\<circ> (\\<lambda>x. F.FUN (\\<psi> (Cop.dom g, a) x) e)) x", "have \"... = (F.FUN g o (F.FUN o \\<psi> (?b, a)) x) e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F.FUN\n     (\\<psi> (Cop.cod g, a)\n       (\\<phi> (Cop.cod g, a) (\\<psi> (Cop.dom g, a) x \\<cdot> g)))\n     e =\n    (F.FUN g \\<circ> (F.FUN \\<circ> \\<psi> (Cop.dom g, a)) x) e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. F.FUN\n     (\\<psi> (Cop.cod g, a)\n       (\\<phi> (Cop.cod g, a) (\\<psi> (Cop.dom g, a) x \\<cdot> g)))\n     e =\n    (F.FUN g \\<circ> (F.FUN \\<circ> \\<psi> (Cop.dom g, a)) x) e", "have 1: \"\\<guillemotleft>\\<psi> (Cop.dom g, a) x : Cop.dom g \\<rightarrow> a\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<psi> (Cop.dom g, a)\n                     x : Cop.dom g \\<rightarrow> a\\<guillemotright>", "using ide_a x g Hom.\\<psi>_mapsto [of ?b a]"], ["proof (prove)\nusing this:\n  C.ide a\n  x \\<in> Hom.set (Cop.dom g, a)\n  Cop.arr g\n  \\<lbrakk>C.ide (Cop.dom g); C.ide a\\<rbrakk>\n  \\<Longrightarrow> \\<psi> (Cop.dom g, a)\n                    \\<in> Hom.set (Cop.dom g, a) \\<rightarrow>\n                          C.hom (Cop.dom g) a\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<psi> (Cop.dom g, a)\n                     x : Cop.dom g \\<rightarrow> a\\<guillemotright>", "by auto"], ["proof (state)\nthis:\n  \\<guillemotleft>\\<psi> (Cop.dom g, a)\n                   x : Cop.dom g \\<rightarrow> a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. F.FUN\n     (\\<psi> (Cop.cod g, a)\n       (\\<phi> (Cop.cod g, a) (\\<psi> (Cop.dom g, a) x \\<cdot> g)))\n     e =\n    (F.FUN g \\<circ> (F.FUN \\<circ> \\<psi> (Cop.dom g, a)) x) e", "moreover"], ["proof (state)\nthis:\n  \\<guillemotleft>\\<psi> (Cop.dom g, a)\n                   x : Cop.dom g \\<rightarrow> a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. F.FUN\n     (\\<psi> (Cop.cod g, a)\n       (\\<phi> (Cop.cod g, a) (\\<psi> (Cop.dom g, a) x \\<cdot> g)))\n     e =\n    (F.FUN g \\<circ> (F.FUN \\<circ> \\<psi> (Cop.dom g, a)) x) e", "have \"S.seq (F g) (F (\\<psi> (C.cod g, a) x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.seq (F g) (F (\\<psi> (C.cod g, a) x))", "using 1 g"], ["proof (prove)\nusing this:\n  \\<guillemotleft>\\<psi> (Cop.dom g, a)\n                   x : Cop.dom g \\<rightarrow> a\\<guillemotright>\n  Cop.arr g\n\ngoal (1 subgoal):\n 1. S.seq (F g) (F (\\<psi> (C.cod g, a) x))", "by (intro S.seqI', auto)"], ["proof (state)\nthis:\n  S.seq (F g) (F (\\<psi> (C.cod g, a) x))\n\ngoal (1 subgoal):\n 1. F.FUN\n     (\\<psi> (Cop.cod g, a)\n       (\\<phi> (Cop.cod g, a) (\\<psi> (Cop.dom g, a) x \\<cdot> g)))\n     e =\n    (F.FUN g \\<circ> (F.FUN \\<circ> \\<psi> (Cop.dom g, a)) x) e", "moreover"], ["proof (state)\nthis:\n  S.seq (F g) (F (\\<psi> (C.cod g, a) x))\n\ngoal (1 subgoal):\n 1. F.FUN\n     (\\<psi> (Cop.cod g, a)\n       (\\<phi> (Cop.cod g, a) (\\<psi> (Cop.dom g, a) x \\<cdot> g)))\n     e =\n    (F.FUN g \\<circ> (F.FUN \\<circ> \\<psi> (Cop.dom g, a)) x) e", "have \"\\<psi> (C.dom g, a) (\\<phi> (C.dom g, a) (C (\\<psi> (C.cod g, a) x) g)) =\n                             C (\\<psi> (C.cod g, a) x) g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> (C.dom g, a)\n     (\\<phi> (C.dom g, a) (\\<psi> (C.cod g, a) x \\<cdot> g)) =\n    \\<psi> (C.cod g, a) x \\<cdot> g", "using g 1 Hom.\\<psi>_\\<phi> [of \"C (\\<psi> (?b, a) x) g\" ?b' a]"], ["proof (prove)\nusing this:\n  Cop.arr g\n  \\<guillemotleft>\\<psi> (Cop.dom g, a)\n                   x : Cop.dom g \\<rightarrow> a\\<guillemotright>\n  \\<guillemotleft>\\<psi> (Cop.dom g, a) x \\<cdot>\n                  g : Cop.cod\n                       g \\<rightarrow> a\\<guillemotright> \\<Longrightarrow>\n  \\<psi> (Cop.cod g, a)\n   (\\<phi> (Cop.cod g, a) (\\<psi> (Cop.dom g, a) x \\<cdot> g)) =\n  \\<psi> (Cop.dom g, a) x \\<cdot> g\n\ngoal (1 subgoal):\n 1. \\<psi> (C.dom g, a)\n     (\\<phi> (C.dom g, a) (\\<psi> (C.cod g, a) x \\<cdot> g)) =\n    \\<psi> (C.cod g, a) x \\<cdot> g", "by fastforce"], ["proof (state)\nthis:\n  \\<psi> (C.dom g, a)\n   (\\<phi> (C.dom g, a) (\\<psi> (C.cod g, a) x \\<cdot> g)) =\n  \\<psi> (C.cod g, a) x \\<cdot> g\n\ngoal (1 subgoal):\n 1. F.FUN\n     (\\<psi> (Cop.cod g, a)\n       (\\<phi> (Cop.cod g, a) (\\<psi> (Cop.dom g, a) x \\<cdot> g)))\n     e =\n    (F.FUN g \\<circ> (F.FUN \\<circ> \\<psi> (Cop.dom g, a)) x) e", "ultimately"], ["proof (chain)\npicking this:\n  \\<guillemotleft>\\<psi> (Cop.dom g, a)\n                   x : Cop.dom g \\<rightarrow> a\\<guillemotright>\n  S.seq (F g) (F (\\<psi> (C.cod g, a) x))\n  \\<psi> (C.dom g, a)\n   (\\<phi> (C.dom g, a) (\\<psi> (C.cod g, a) x \\<cdot> g)) =\n  \\<psi> (C.cod g, a) x \\<cdot> g", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<guillemotleft>\\<psi> (Cop.dom g, a)\n                   x : Cop.dom g \\<rightarrow> a\\<guillemotright>\n  S.seq (F g) (F (\\<psi> (C.cod g, a) x))\n  \\<psi> (C.dom g, a)\n   (\\<phi> (C.dom g, a) (\\<psi> (C.cod g, a) x \\<cdot> g)) =\n  \\<psi> (C.cod g, a) x \\<cdot> g\n\ngoal (1 subgoal):\n 1. F.FUN\n     (\\<psi> (Cop.cod g, a)\n       (\\<phi> (Cop.cod g, a) (\\<psi> (Cop.dom g, a) x \\<cdot> g)))\n     e =\n    (F.FUN g \\<circ> (F.FUN \\<circ> \\<psi> (Cop.dom g, a)) x) e", "using assms F.preserves_comp"], ["proof (prove)\nusing this:\n  \\<guillemotleft>\\<psi> (Cop.dom g, a)\n                   x : Cop.dom g \\<rightarrow> a\\<guillemotright>\n  S.seq (F g) (F (\\<psi> (C.cod g, a) x))\n  \\<psi> (C.dom g, a)\n   (\\<phi> (C.dom g, a) (\\<psi> (C.cod g, a) x \\<cdot> g)) =\n  \\<psi> (C.cod g, a) x \\<cdot> g\n  e \\<in> F.SET a\n  Cop.seq ?g ?f \\<Longrightarrow>\n  F (?g \\<cdot>\\<^sup>o\\<^sup>p ?f) = F ?g \\<cdot>\\<^sub>S F ?f\n\ngoal (1 subgoal):\n 1. F.FUN\n     (\\<psi> (Cop.cod g, a)\n       (\\<phi> (Cop.cod g, a) (\\<psi> (Cop.dom g, a) x \\<cdot> g)))\n     e =\n    (F.FUN g \\<circ> (F.FUN \\<circ> \\<psi> (Cop.dom g, a)) x) e", "by fastforce"], ["proof (state)\nthis:\n  F.FUN\n   (\\<psi> (Cop.cod g, a)\n     (\\<phi> (Cop.cod g, a) (\\<psi> (Cop.dom g, a) x \\<cdot> g)))\n   e =\n  (F.FUN g \\<circ> (F.FUN \\<circ> \\<psi> (Cop.dom g, a)) x) e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  F.FUN\n   (\\<psi> (Cop.cod g, a)\n     (\\<phi> (Cop.cod g, a) (\\<psi> (Cop.dom g, a) x \\<cdot> g)))\n   e =\n  (F.FUN g \\<circ> (F.FUN \\<circ> \\<psi> (Cop.dom g, a)) x) e\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Hom.set (Cop.dom g, a) \\<Longrightarrow>\n       ((\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n        (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n         \\<psi> (Cop.dom g, a)))\n        x =\n       (F.FUN g \\<circ> (\\<lambda>x. F.FUN (\\<psi> (Cop.dom g, a) x) e)) x", "also"], ["proof (state)\nthis:\n  F.FUN\n   (\\<psi> (Cop.cod g, a)\n     (\\<phi> (Cop.cod g, a) (\\<psi> (Cop.dom g, a) x \\<cdot> g)))\n   e =\n  (F.FUN g \\<circ> (F.FUN \\<circ> \\<psi> (Cop.dom g, a)) x) e\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Hom.set (Cop.dom g, a) \\<Longrightarrow>\n       ((\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n        (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n         \\<psi> (Cop.dom g, a)))\n        x =\n       (F.FUN g \\<circ> (\\<lambda>x. F.FUN (\\<psi> (Cop.dom g, a) x) e)) x", "have \"... = (F.FUN g o (\\<lambda>x. F.FUN (\\<psi> (?b, a) x) e)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (F.FUN g \\<circ> (F.FUN \\<circ> \\<psi> (Cop.dom g, a)) x) e =\n    (F.FUN g \\<circ> (\\<lambda>x. F.FUN (\\<psi> (Cop.dom g, a) x) e)) x", "by fastforce"], ["proof (state)\nthis:\n  (F.FUN g \\<circ> (F.FUN \\<circ> \\<psi> (Cop.dom g, a)) x) e =\n  (F.FUN g \\<circ> (\\<lambda>x. F.FUN (\\<psi> (Cop.dom g, a) x) e)) x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Hom.set (Cop.dom g, a) \\<Longrightarrow>\n       ((\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n        (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n         \\<psi> (Cop.dom g, a)))\n        x =\n       (F.FUN g \\<circ> (\\<lambda>x. F.FUN (\\<psi> (Cop.dom g, a) x) e)) x", "finally"], ["proof (chain)\npicking this:\n  ((\\<lambda>x. (F.FUN \\<circ> \\<psi> (Cop.cod g, a)) x e) \\<circ>\n   (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n    \\<psi> (Cop.dom g, a)))\n   x =\n  (F.FUN g \\<circ> (\\<lambda>x. F.FUN (\\<psi> (Cop.dom g, a) x) e)) x", "show \"((\\<lambda>x. F.FUN (\\<psi> (?b', a) x) e)\n                             o (\\<phi> (?b', a) o Cop.comp g o \\<psi> (?b, a))) x\n                            = (F.FUN g o (\\<lambda>x. F.FUN (\\<psi> (?b, a) x) e)) x\""], ["proof (prove)\nusing this:\n  ((\\<lambda>x. (F.FUN \\<circ> \\<psi> (Cop.cod g, a)) x e) \\<circ>\n   (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n    \\<psi> (Cop.dom g, a)))\n   x =\n  (F.FUN g \\<circ> (\\<lambda>x. F.FUN (\\<psi> (Cop.dom g, a) x) e)) x\n\ngoal (1 subgoal):\n 1. ((\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n     (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n      \\<psi> (Cop.dom g, a)))\n     x =\n    (F.FUN g \\<circ> (\\<lambda>x. F.FUN (\\<psi> (Cop.dom g, a) x) e)) x", "by simp"], ["proof (state)\nthis:\n  ((\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n   (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n    \\<psi> (Cop.dom g, a)))\n   x =\n  (F.FUN g \\<circ> (\\<lambda>x. F.FUN (\\<psi> (Cop.dom g, a) x) e)) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> Hom.set (Cop.dom g, a) \\<Longrightarrow>\n  ((\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n   (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n    \\<psi> (Cop.dom g, a)))\n   ?x =\n  (F.FUN g \\<circ> (\\<lambda>x. F.FUN (\\<psi> (Cop.dom g, a) x) e)) ?x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S.mkArr (Hom.set (Cop.dom g, a)) (F.SET (Cop.cod g))\n   ((\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n    (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n     \\<psi> (Cop.dom g, a))) =\n  S.mkArr (Hom.set (Cop.dom g, a)) (F.SET (Cop.cod g))\n   (F.FUN g \\<circ> (\\<lambda>x. F.FUN (\\<psi> (Cop.dom g, a) x) e))\n\ngoal (1 subgoal):\n 1. \\<T>o e (Cop.cod g) \\<cdot>\\<^sub>S Y a g =\n    F g \\<cdot>\\<^sub>S \\<T>o e (Cop.dom g)", "also"], ["proof (state)\nthis:\n  S.mkArr (Hom.set (Cop.dom g, a)) (F.SET (Cop.cod g))\n   ((\\<lambda>x. F.FUN (\\<psi> (Cop.cod g, a) x) e) \\<circ>\n    (\\<phi> (Cop.cod g, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) g \\<circ>\n     \\<psi> (Cop.dom g, a))) =\n  S.mkArr (Hom.set (Cop.dom g, a)) (F.SET (Cop.cod g))\n   (F.FUN g \\<circ> (\\<lambda>x. F.FUN (\\<psi> (Cop.dom g, a) x) e))\n\ngoal (1 subgoal):\n 1. \\<T>o e (Cop.cod g) \\<cdot>\\<^sub>S Y a g =\n    F g \\<cdot>\\<^sub>S \\<T>o e (Cop.dom g)", "have \"... = F g \\<cdot>\\<^sub>S \\<T>o e (Cop.dom g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.mkArr (Hom.set (Cop.dom g, a)) (F.SET (Cop.cod g))\n     (F.FUN g \\<circ> (\\<lambda>x. F.FUN (\\<psi> (Cop.dom g, a) x) e)) =\n    F g \\<cdot>\\<^sub>S \\<T>o e (Cop.dom g)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. S.mkArr (Hom.set (Cop.dom g, a)) (F.SET (Cop.cod g))\n     (F.FUN g \\<circ> (\\<lambda>x. F.FUN (\\<psi> (Cop.dom g, a) x) e)) =\n    F g \\<cdot>\\<^sub>S \\<T>o e (Cop.dom g)", "have \"S.arr (F g) \\<and> F g = S.mkArr (F.SET ?b) (F.SET ?b') (F.FUN g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.arr (F g) \\<and>\n    F g = S.mkArr (F.SET (Cop.dom g)) (F.SET (Cop.cod g)) (F.FUN g)", "using g S.mkArr_Fun [of \"F g\"]"], ["proof (prove)\nusing this:\n  Cop.arr g\n  S.arr (F g) \\<Longrightarrow> S.mkArr (F.DOM g) (F.COD g) (F.FUN g) = F g\n\ngoal (1 subgoal):\n 1. S.arr (F g) \\<and>\n    F g = S.mkArr (F.SET (Cop.dom g)) (F.SET (Cop.cod g)) (F.FUN g)", "by simp"], ["proof (state)\nthis:\n  S.arr (F g) \\<and>\n  F g = S.mkArr (F.SET (Cop.dom g)) (F.SET (Cop.cod g)) (F.FUN g)\n\ngoal (1 subgoal):\n 1. S.mkArr (Hom.set (Cop.dom g, a)) (F.SET (Cop.cod g))\n     (F.FUN g \\<circ> (\\<lambda>x. F.FUN (\\<psi> (Cop.dom g, a) x) e)) =\n    F g \\<cdot>\\<^sub>S \\<T>o e (Cop.dom g)", "moreover"], ["proof (state)\nthis:\n  S.arr (F g) \\<and>\n  F g = S.mkArr (F.SET (Cop.dom g)) (F.SET (Cop.cod g)) (F.FUN g)\n\ngoal (1 subgoal):\n 1. S.mkArr (Hom.set (Cop.dom g, a)) (F.SET (Cop.cod g))\n     (F.FUN g \\<circ> (\\<lambda>x. F.FUN (\\<psi> (Cop.dom g, a) x) e)) =\n    F g \\<cdot>\\<^sub>S \\<T>o e (Cop.dom g)", "have\n              \"S.arr (\\<T>o e ?b) \\<and>\n               \\<T>o e ?b = S.mkArr (Hom.set (?b, a)) (F.SET ?b) (\\<lambda>x. F.FUN (\\<psi> (?b, a) x) e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.arr (\\<T>o e (Cop.dom g)) \\<and>\n    \\<T>o e (Cop.dom g) =\n    S.mkArr (Hom.set (Cop.dom g, a)) (F.SET (Cop.dom g))\n     (\\<lambda>x. F.FUN (\\<psi> (Cop.dom g, a) x) e)", "using e g \\<T>o_e_ide"], ["proof (prove)\nusing this:\n  e \\<in> F.SET a\n  Cop.arr g\n  \\<lbrakk>?e \\<in> F.SET a; C.ide ?b\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>\\<T>o ?e\n                                     ?b : Y a\n     ?b \\<rightarrow>\\<^sub>S F ?b\\<guillemotright>\n  \\<lbrakk>?e \\<in> F.SET a; C.ide ?b\\<rbrakk>\n  \\<Longrightarrow> \\<T>o ?e ?b =\n                    S.mkArr (Hom.set (?b, a)) (F.SET ?b)\n                     (\\<lambda>x. F.FUN (\\<psi> (?b, a) x) ?e)\n\ngoal (1 subgoal):\n 1. S.arr (\\<T>o e (Cop.dom g)) \\<and>\n    \\<T>o e (Cop.dom g) =\n    S.mkArr (Hom.set (Cop.dom g, a)) (F.SET (Cop.dom g))\n     (\\<lambda>x. F.FUN (\\<psi> (Cop.dom g, a) x) e)", "by (metis C.ide_cod Cop.arr_char Cop.dom_char S.in_homE)"], ["proof (state)\nthis:\n  S.arr (\\<T>o e (Cop.dom g)) \\<and>\n  \\<T>o e (Cop.dom g) =\n  S.mkArr (Hom.set (Cop.dom g, a)) (F.SET (Cop.dom g))\n   (\\<lambda>x. F.FUN (\\<psi> (Cop.dom g, a) x) e)\n\ngoal (1 subgoal):\n 1. S.mkArr (Hom.set (Cop.dom g, a)) (F.SET (Cop.cod g))\n     (F.FUN g \\<circ> (\\<lambda>x. F.FUN (\\<psi> (Cop.dom g, a) x) e)) =\n    F g \\<cdot>\\<^sub>S \\<T>o e (Cop.dom g)", "ultimately"], ["proof (chain)\npicking this:\n  S.arr (F g) \\<and>\n  F g = S.mkArr (F.SET (Cop.dom g)) (F.SET (Cop.cod g)) (F.FUN g)\n  S.arr (\\<T>o e (Cop.dom g)) \\<and>\n  \\<T>o e (Cop.dom g) =\n  S.mkArr (Hom.set (Cop.dom g, a)) (F.SET (Cop.dom g))\n   (\\<lambda>x. F.FUN (\\<psi> (Cop.dom g, a) x) e)", "show ?thesis"], ["proof (prove)\nusing this:\n  S.arr (F g) \\<and>\n  F g = S.mkArr (F.SET (Cop.dom g)) (F.SET (Cop.cod g)) (F.FUN g)\n  S.arr (\\<T>o e (Cop.dom g)) \\<and>\n  \\<T>o e (Cop.dom g) =\n  S.mkArr (Hom.set (Cop.dom g, a)) (F.SET (Cop.dom g))\n   (\\<lambda>x. F.FUN (\\<psi> (Cop.dom g, a) x) e)\n\ngoal (1 subgoal):\n 1. S.mkArr (Hom.set (Cop.dom g, a)) (F.SET (Cop.cod g))\n     (F.FUN g \\<circ> (\\<lambda>x. F.FUN (\\<psi> (Cop.dom g, a) x) e)) =\n    F g \\<cdot>\\<^sub>S \\<T>o e (Cop.dom g)", "using S.comp_mkArr [of \"Hom.set (?b, a)\" \"F.SET ?b\" \"\\<lambda>x. F.FUN (\\<psi> (?b, a) x) e\"\n                                   \"F.SET ?b'\" \"F.FUN g\"]"], ["proof (prove)\nusing this:\n  S.arr (F g) \\<and>\n  F g = S.mkArr (F.SET (Cop.dom g)) (F.SET (Cop.cod g)) (F.FUN g)\n  S.arr (\\<T>o e (Cop.dom g)) \\<and>\n  \\<T>o e (Cop.dom g) =\n  S.mkArr (Hom.set (Cop.dom g, a)) (F.SET (Cop.dom g))\n   (\\<lambda>x. F.FUN (\\<psi> (Cop.dom g, a) x) e)\n  \\<lbrakk>S.arr\n            (S.mkArr (Hom.set (Cop.dom g, a)) (F.SET (Cop.dom g))\n              (\\<lambda>x. F.FUN (\\<psi> (Cop.dom g, a) x) e));\n   S.arr\n    (S.mkArr (F.SET (Cop.dom g)) (F.SET (Cop.cod g)) (F.FUN g))\\<rbrakk>\n  \\<Longrightarrow> S.mkArr (F.SET (Cop.dom g)) (F.SET (Cop.cod g))\n                     (F.FUN g) \\<cdot>\\<^sub>S\n                    S.mkArr (Hom.set (Cop.dom g, a)) (F.SET (Cop.dom g))\n                     (\\<lambda>x. F.FUN (\\<psi> (Cop.dom g, a) x) e) =\n                    S.mkArr (Hom.set (Cop.dom g, a)) (F.SET (Cop.cod g))\n                     (F.FUN g \\<circ>\n                      (\\<lambda>x. F.FUN (\\<psi> (Cop.dom g, a) x) e))\n\ngoal (1 subgoal):\n 1. S.mkArr (Hom.set (Cop.dom g, a)) (F.SET (Cop.cod g))\n     (F.FUN g \\<circ> (\\<lambda>x. F.FUN (\\<psi> (Cop.dom g, a) x) e)) =\n    F g \\<cdot>\\<^sub>S \\<T>o e (Cop.dom g)", "by metis"], ["proof (state)\nthis:\n  S.mkArr (Hom.set (Cop.dom g, a)) (F.SET (Cop.cod g))\n   (F.FUN g \\<circ> (\\<lambda>x. F.FUN (\\<psi> (Cop.dom g, a) x) e)) =\n  F g \\<cdot>\\<^sub>S \\<T>o e (Cop.dom g)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S.mkArr (Hom.set (Cop.dom g, a)) (F.SET (Cop.cod g))\n   (F.FUN g \\<circ> (\\<lambda>x. F.FUN (\\<psi> (Cop.dom g, a) x) e)) =\n  F g \\<cdot>\\<^sub>S \\<T>o e (Cop.dom g)\n\ngoal (1 subgoal):\n 1. \\<T>o e (Cop.cod g) \\<cdot>\\<^sub>S Y a g =\n    F g \\<cdot>\\<^sub>S \\<T>o e (Cop.dom g)", "finally"], ["proof (chain)\npicking this:\n  \\<T>o e (Cop.cod g) \\<cdot>\\<^sub>S Y a g =\n  F g \\<cdot>\\<^sub>S \\<T>o e (Cop.dom g)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<T>o e (Cop.cod g) \\<cdot>\\<^sub>S Y a g =\n  F g \\<cdot>\\<^sub>S \\<T>o e (Cop.dom g)\n\ngoal (1 subgoal):\n 1. \\<T>o e (Cop.cod g) \\<cdot>\\<^sub>S Y a g =\n    F g \\<cdot>\\<^sub>S \\<T>o e (Cop.dom g)", "by blast"], ["proof (state)\nthis:\n  \\<T>o e (Cop.cod g) \\<cdot>\\<^sub>S Y a g =\n  F g \\<cdot>\\<^sub>S \\<T>o e (Cop.dom g)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<T>o e (Cop.cod g) \\<cdot>\\<^sub>S Y a g =\n  F g \\<cdot>\\<^sub>S \\<T>o e (Cop.dom g)\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation \\<T> :: \"'s \\<Rightarrow> 'c \\<Rightarrow> 's\"\n    where \"\\<T> e \\<equiv> transformation_by_components.map Cop.comp S (Y a) (\\<T>o e)\""], ["", "end"], ["", "locale yoneda_lemma_fixed_e =\n    yoneda_lemma C S \\<phi> F a\n  for C :: \"'c comp\" (infixr \"\\<cdot>\" 55)\n  and S :: \"'s comp\" (infixr \"\\<cdot>\\<^sub>S\" 55)\n  and \\<phi> :: \"'c * 'c \\<Rightarrow> 'c \\<Rightarrow> 's\"\n  and F :: \"'c \\<Rightarrow> 's\"\n  and a :: 'c\n  and e :: 's +\n  assumes E: \"e \\<in> F.SET a\"\n  begin"], ["", "interpretation \\<T>e: transformation_by_components Cop.comp S \\<open>Y a\\<close> F \\<open>\\<T>o e\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. transformation_by_components (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S)\n     (Y a) F (\\<T>o e)", "using E \\<T>o_e_induces_transformation"], ["proof (prove)\nusing this:\n  e \\<in> F.SET a\n  ?e \\<in> F.SET a \\<Longrightarrow>\n  transformation_by_components (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S)\n   (Y a) F (\\<T>o ?e)\n\ngoal (1 subgoal):\n 1. transformation_by_components (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S)\n     (Y a) F (\\<T>o e)", "by auto"], ["", "lemma natural_transformation_\\<T>e:\n    shows \"natural_transformation Cop.comp S (Y a) F (\\<T> e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n     F \\<T>e.map", ".."], ["", "lemma \\<T>e_ide:\n    assumes \"Cop.ide b\"\n    shows \"S.arr (\\<T> e b)\"\n    and \"\\<T> e b = S.mkArr (Hom.set (b, a)) (F.SET b) (\\<lambda>x. F.FUN (\\<psi> (b, a) x) e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.arr (\\<T>e.map b) &&&\n    \\<T>e.map b =\n    S.mkArr (Hom.set (b, a)) (F.SET b)\n     (\\<lambda>x. F.FUN (\\<psi> (b, a) x) e)", "using assms"], ["proof (prove)\nusing this:\n  Cop.ide b\n\ngoal (1 subgoal):\n 1. S.arr (\\<T>e.map b) &&&\n    \\<T>e.map b =\n    S.mkArr (Hom.set (b, a)) (F.SET b)\n     (\\<lambda>x. F.FUN (\\<psi> (b, a) x) e)", "apply fastforce"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<T>e.map b =\n    S.mkArr (Hom.set (b, a)) (F.SET b)\n     (\\<lambda>x. F.FUN (\\<psi> (b, a) x) e)", "using assms \\<T>o_def"], ["proof (prove)\nusing this:\n  Cop.ide b\n  \\<T>o ?e ?b =\n  S.mkArr (Hom.set (?b, a)) (F.SET ?b)\n   (\\<lambda>x. F.FUN (\\<psi> (?b, a) x) ?e)\n\ngoal (1 subgoal):\n 1. \\<T>e.map b =\n    S.mkArr (Hom.set (b, a)) (F.SET b)\n     (\\<lambda>x. F.FUN (\\<psi> (b, a) x) e)", "by auto"], ["", "end"], ["", "locale yoneda_lemma_fixed_\\<tau> =\n    yoneda_lemma C S \\<phi> F a +\n    \\<tau>: set_valued_transformation Cop.comp S \"Y a\" F \\<tau>\n  for C :: \"'c comp\" (infixr \"\\<cdot>\" 55)\n  and S :: \"'s comp\" (infixr \"\\<cdot>\\<^sub>S\" 55)\n  and \\<phi> :: \"'c * 'c \\<Rightarrow> 'c \\<Rightarrow> 's\"\n  and F :: \"'c \\<Rightarrow> 's\"\n  and a :: 'c\n  and \\<tau> :: \"'c \\<Rightarrow> 's\"\n  begin"], ["", "text\\<open>\n      The key lemma: The component @{term \"\\<tau> b\"} of @{term \\<tau>} at an arbitrary object @{term b}\n      is completely determined by the single element @{term \"\\<tau>.FUN a (\\<phi> (a, a) a) \\<in> F.SET a\"}.\n\\<close>"], ["", "lemma \\<tau>_ide:\n    assumes b: \"Cop.ide b\"\n    shows \"\\<tau> b = S.mkArr (Hom.set (b, a)) (F.SET b)\n                         (\\<lambda>x. (F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> b =\n    S.mkArr (Hom.set (b, a)) (F.SET b)\n     (\\<lambda>x. F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<tau> b =\n    S.mkArr (Hom.set (b, a)) (F.SET b)\n     (\\<lambda>x. F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a)))", "let ?\\<phi>a = \"\\<phi> (a, a) a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<tau> b =\n    S.mkArr (Hom.set (b, a)) (F.SET b)\n     (\\<lambda>x. F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a)))", "have \\<phi>a: \"\\<phi> (a, a) a \\<in> Hom.set (a, a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> (a, a) a \\<in> Hom.set (a, a)", "using ide_a Hom.\\<phi>_mapsto [of a a]"], ["proof (prove)\nusing this:\n  C.ide a\n  \\<lbrakk>C.ide a; C.ide a\\<rbrakk>\n  \\<Longrightarrow> \\<phi> (a, a)\n                    \\<in> C.hom a a \\<rightarrow> Hom.set (a, a)\n\ngoal (1 subgoal):\n 1. \\<phi> (a, a) a \\<in> Hom.set (a, a)", "by fastforce"], ["proof (state)\nthis:\n  \\<phi> (a, a) a \\<in> Hom.set (a, a)\n\ngoal (1 subgoal):\n 1. \\<tau> b =\n    S.mkArr (Hom.set (b, a)) (F.SET b)\n     (\\<lambda>x. F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a)))", "have 1: \"\\<tau> b = S.mkArr (Hom.set (b, a)) (F.SET b) (\\<tau>.FUN b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> b = S.mkArr (Hom.set (b, a)) (F.SET b) (\\<tau>.FUN b)", "using ide_a b S.mkArr_Fun [of \"\\<tau> b\"] Hom.set_map"], ["proof (prove)\nusing this:\n  C.ide a\n  Cop.ide b\n  S.arr (\\<tau> b) \\<Longrightarrow>\n  S.mkArr (\\<tau>.DOM b) (\\<tau>.COD b) (\\<tau>.FUN b) = \\<tau> b\n  \\<lbrakk>C.ide ?a; C.ide ?b\\<rbrakk>\n  \\<Longrightarrow> S.set (Hom.map (?b, ?a)) = Hom.set (?b, ?a)\n\ngoal (1 subgoal):\n 1. \\<tau> b = S.mkArr (Hom.set (b, a)) (F.SET b) (\\<tau>.FUN b)", "by auto"], ["proof (state)\nthis:\n  \\<tau> b = S.mkArr (Hom.set (b, a)) (F.SET b) (\\<tau>.FUN b)\n\ngoal (1 subgoal):\n 1. \\<tau> b =\n    S.mkArr (Hom.set (b, a)) (F.SET b)\n     (\\<lambda>x. F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a)))", "also"], ["proof (state)\nthis:\n  \\<tau> b = S.mkArr (Hom.set (b, a)) (F.SET b) (\\<tau>.FUN b)\n\ngoal (1 subgoal):\n 1. \\<tau> b =\n    S.mkArr (Hom.set (b, a)) (F.SET b)\n     (\\<lambda>x. F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a)))", "have\n          \"... = S.mkArr (Hom.set (b, a)) (F.SET b) (\\<lambda>x. (F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a ?\\<phi>a)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.mkArr (Hom.set (b, a)) (F.SET b) (\\<tau>.FUN b) =\n    S.mkArr (Hom.set (b, a)) (F.SET b)\n     (\\<lambda>x. F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a)))", "proof (intro S.mkArr_eqI')"], ["proof (state)\ngoal (2 subgoals):\n 1. S.arr (S.mkArr (Hom.set (b, a)) (F.SET b) (\\<tau>.FUN b))\n 2. \\<And>x.\n       x \\<in> Hom.set (b, a) \\<Longrightarrow>\n       \\<tau>.FUN b x =\n       F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a))", "show \"S.arr (S.mkArr (Hom.set (b, a)) (F.SET b) (\\<tau>.FUN b))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.arr (S.mkArr (Hom.set (b, a)) (F.SET b) (\\<tau>.FUN b))", "using ide_a b 1 S.mkArr_Fun [of \"\\<tau> b\"] Hom.set_map"], ["proof (prove)\nusing this:\n  C.ide a\n  Cop.ide b\n  \\<tau> b = S.mkArr (Hom.set (b, a)) (F.SET b) (\\<tau>.FUN b)\n  S.arr (\\<tau> b) \\<Longrightarrow>\n  S.mkArr (\\<tau>.DOM b) (\\<tau>.COD b) (\\<tau>.FUN b) = \\<tau> b\n  \\<lbrakk>C.ide ?a; C.ide ?b\\<rbrakk>\n  \\<Longrightarrow> S.set (Hom.map (?b, ?a)) = Hom.set (?b, ?a)\n\ngoal (1 subgoal):\n 1. S.arr (S.mkArr (Hom.set (b, a)) (F.SET b) (\\<tau>.FUN b))", "by auto"], ["proof (state)\nthis:\n  S.arr (S.mkArr (Hom.set (b, a)) (F.SET b) (\\<tau>.FUN b))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Hom.set (b, a) \\<Longrightarrow>\n       \\<tau>.FUN b x =\n       F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a))", "show \"\\<And>x. x \\<in> Hom.set (b, a) \\<Longrightarrow> \\<tau>.FUN b x = (F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a ?\\<phi>a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Hom.set (b, a) \\<Longrightarrow>\n       \\<tau>.FUN b x =\n       F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Hom.set (b, a) \\<Longrightarrow>\n       \\<tau>.FUN b x =\n       F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a))", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Hom.set (b, a) \\<Longrightarrow>\n       \\<tau>.FUN b x =\n       F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a))", "assume x: \"x \\<in> Hom.set (b, a)\""], ["proof (state)\nthis:\n  x \\<in> Hom.set (b, a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Hom.set (b, a) \\<Longrightarrow>\n       \\<tau>.FUN b x =\n       F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a))", "let ?\\<psi>x = \"\\<psi> (b, a) x\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Hom.set (b, a) \\<Longrightarrow>\n       \\<tau>.FUN b x =\n       F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a))", "have \\<psi>x: \"\\<guillemotleft>?\\<psi>x : b \\<rightarrow> a\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<psi> (b, a) x : b \\<rightarrow> a\\<guillemotright>", "using ide_a b x Hom.\\<psi>_mapsto [of b a]"], ["proof (prove)\nusing this:\n  C.ide a\n  Cop.ide b\n  x \\<in> Hom.set (b, a)\n  \\<lbrakk>C.ide b; C.ide a\\<rbrakk>\n  \\<Longrightarrow> \\<psi> (b, a)\n                    \\<in> Hom.set (b, a) \\<rightarrow> C.hom b a\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<psi> (b, a) x : b \\<rightarrow> a\\<guillemotright>", "by auto"], ["proof (state)\nthis:\n  \\<guillemotleft>\\<psi> (b, a) x : b \\<rightarrow> a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Hom.set (b, a) \\<Longrightarrow>\n       \\<tau>.FUN b x =\n       F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a))", "show \"\\<tau>.FUN b x = (F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a ?\\<phi>a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>.FUN b x =\n    F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<tau>.FUN b x =\n    F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a))", "have \"\\<tau>.FUN b x = S.Fun (\\<tau> b \\<cdot>\\<^sub>S Y a ?\\<psi>x) ?\\<phi>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>.FUN b x =\n    S.Fun (\\<tau> b \\<cdot>\\<^sub>S Y a (\\<psi> (b, a) x)) (\\<phi> (a, a) a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<tau>.FUN b x =\n    S.Fun (\\<tau> b \\<cdot>\\<^sub>S Y a (\\<psi> (b, a) x)) (\\<phi> (a, a) a)", "have \"\\<tau>.FUN b x = \\<tau>.FUN b ((\\<phi> (b, a) o Cop.comp ?\\<psi>x) a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>.FUN b x =\n    \\<tau>.FUN b\n     ((\\<phi> (b, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (b, a) x)) a)", "using ide_a b x \\<psi>x Hom.\\<phi>_\\<psi>"], ["proof (prove)\nusing this:\n  C.ide a\n  Cop.ide b\n  x \\<in> Hom.set (b, a)\n  \\<guillemotleft>\\<psi> (b, a) x : b \\<rightarrow> a\\<guillemotright>\n  \\<lbrakk>C.ide ?b; C.ide ?a; ?x \\<in> Hom.set (?b, ?a)\\<rbrakk>\n  \\<Longrightarrow> \\<phi> (?b, ?a) (\\<psi> (?b, ?a) ?x) = ?x\n\ngoal (1 subgoal):\n 1. \\<tau>.FUN b x =\n    \\<tau>.FUN b\n     ((\\<phi> (b, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (b, a) x)) a)", "by (metis C.comp_cod_arr C.in_homE C.ide_dom Cop.comp_def comp_apply)"], ["proof (state)\nthis:\n  \\<tau>.FUN b x =\n  \\<tau>.FUN b\n   ((\\<phi> (b, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (b, a) x)) a)\n\ngoal (1 subgoal):\n 1. \\<tau>.FUN b x =\n    S.Fun (\\<tau> b \\<cdot>\\<^sub>S Y a (\\<psi> (b, a) x)) (\\<phi> (a, a) a)", "also"], ["proof (state)\nthis:\n  \\<tau>.FUN b x =\n  \\<tau>.FUN b\n   ((\\<phi> (b, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (b, a) x)) a)\n\ngoal (1 subgoal):\n 1. \\<tau>.FUN b x =\n    S.Fun (\\<tau> b \\<cdot>\\<^sub>S Y a (\\<psi> (b, a) x)) (\\<phi> (a, a) a)", "have \"\\<tau>.FUN b ((\\<phi> (b, a) o Cop.comp ?\\<psi>x) a)\n                           = (\\<tau>.FUN b o (\\<phi> (b, a) o Cop.comp ?\\<psi>x o \\<psi> (a, a))) ?\\<phi>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>.FUN b\n     ((\\<phi> (b, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (b, a) x))\n       a) =\n    (\\<tau>.FUN b \\<circ>\n     (\\<phi> (b, a) \\<circ>\n      (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (b, a) x) \\<circ>\n      \\<psi> (a, a)))\n     (\\<phi> (a, a) a)", "using ide_a b C.ide_in_hom"], ["proof (prove)\nusing this:\n  C.ide a\n  Cop.ide b\n  C.ide ?a = \\<guillemotleft>?a : ?a \\<rightarrow> ?a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<tau>.FUN b\n     ((\\<phi> (b, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (b, a) x))\n       a) =\n    (\\<tau>.FUN b \\<circ>\n     (\\<phi> (b, a) \\<circ>\n      (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (b, a) x) \\<circ>\n      \\<psi> (a, a)))\n     (\\<phi> (a, a) a)", "by simp"], ["proof (state)\nthis:\n  \\<tau>.FUN b\n   ((\\<phi> (b, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (b, a) x)) a) =\n  (\\<tau>.FUN b \\<circ>\n   (\\<phi> (b, a) \\<circ>\n    (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (b, a) x) \\<circ>\n    \\<psi> (a, a)))\n   (\\<phi> (a, a) a)\n\ngoal (1 subgoal):\n 1. \\<tau>.FUN b x =\n    S.Fun (\\<tau> b \\<cdot>\\<^sub>S Y a (\\<psi> (b, a) x)) (\\<phi> (a, a) a)", "also"], ["proof (state)\nthis:\n  \\<tau>.FUN b\n   ((\\<phi> (b, a) \\<circ> (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (b, a) x)) a) =\n  (\\<tau>.FUN b \\<circ>\n   (\\<phi> (b, a) \\<circ>\n    (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (b, a) x) \\<circ>\n    \\<psi> (a, a)))\n   (\\<phi> (a, a) a)\n\ngoal (1 subgoal):\n 1. \\<tau>.FUN b x =\n    S.Fun (\\<tau> b \\<cdot>\\<^sub>S Y a (\\<psi> (b, a) x)) (\\<phi> (a, a) a)", "have \"... = S.Fun (\\<tau> b \\<cdot>\\<^sub>S Y a ?\\<psi>x) ?\\<phi>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<tau>.FUN b \\<circ>\n     (\\<phi> (b, a) \\<circ>\n      (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (b, a) x) \\<circ>\n      \\<psi> (a, a)))\n     (\\<phi> (a, a) a) =\n    S.Fun (\\<tau> b \\<cdot>\\<^sub>S Y a (\\<psi> (b, a) x)) (\\<phi> (a, a) a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<tau>.FUN b \\<circ>\n     (\\<phi> (b, a) \\<circ>\n      (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (b, a) x) \\<circ>\n      \\<psi> (a, a)))\n     (\\<phi> (a, a) a) =\n    S.Fun (\\<tau> b \\<cdot>\\<^sub>S Y a (\\<psi> (b, a) x)) (\\<phi> (a, a) a)", "have \"S.arr (Y a ?\\<psi>x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.arr (Y a (\\<psi> (b, a) x))", "using ide_a \\<psi>x preserves_arr"], ["proof (prove)\nusing this:\n  C.ide a\n  \\<guillemotleft>\\<psi> (b, a) x : b \\<rightarrow> a\\<guillemotright>\n  Cop.arr ?f \\<Longrightarrow> S.arr (Y a ?f)\n\ngoal (1 subgoal):\n 1. S.arr (Y a (\\<psi> (b, a) x))", "by (elim C.in_homE, auto)"], ["proof (state)\nthis:\n  S.arr (Y a (\\<psi> (b, a) x))\n\ngoal (1 subgoal):\n 1. (\\<tau>.FUN b \\<circ>\n     (\\<phi> (b, a) \\<circ>\n      (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (b, a) x) \\<circ>\n      \\<psi> (a, a)))\n     (\\<phi> (a, a) a) =\n    S.Fun (\\<tau> b \\<cdot>\\<^sub>S Y a (\\<psi> (b, a) x)) (\\<phi> (a, a) a)", "moreover"], ["proof (state)\nthis:\n  S.arr (Y a (\\<psi> (b, a) x))\n\ngoal (1 subgoal):\n 1. (\\<tau>.FUN b \\<circ>\n     (\\<phi> (b, a) \\<circ>\n      (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (b, a) x) \\<circ>\n      \\<psi> (a, a)))\n     (\\<phi> (a, a) a) =\n    S.Fun (\\<tau> b \\<cdot>\\<^sub>S Y a (\\<psi> (b, a) x)) (\\<phi> (a, a) a)", "have \"Y a ?\\<psi>x = S.mkArr (Hom.set (a, a)) (SET b)\n                                                 (\\<phi> (b, a) \\<circ> Cop.comp ?\\<psi>x \\<circ> \\<psi> (a, a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y a (\\<psi> (b, a) x) =\n    S.mkArr (Hom.set (a, a)) (SET b)\n     (\\<phi> (b, a) \\<circ>\n      (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (b, a) x) \\<circ>\n      \\<psi> (a, a))", "using ide_a b \\<psi>x preserves_hom Y_ide_arr Hom.set_map C.arrI"], ["proof (prove)\nusing this:\n  C.ide a\n  Cop.ide b\n  \\<guillemotleft>\\<psi> (b, a) x : b \\<rightarrow> a\\<guillemotright>\n  Cop.in_hom ?f ?a ?b \\<Longrightarrow>\n  \\<guillemotleft>Y a ?f : Y a ?a \\<rightarrow>\\<^sub>S Y a\n                   ?b\\<guillemotright>\n  \\<lbrakk>C.ide ?a;\n   \\<guillemotleft>?g : ?b' \\<rightarrow> ?b\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>Y ?a\n                                     ?g : Hom.map\n     (?b, ?a) \\<rightarrow>\\<^sub>S Hom.map (?b', ?a)\\<guillemotright>\n  \\<lbrakk>C.ide ?a;\n   \\<guillemotleft>?g : ?b' \\<rightarrow> ?b\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> Y ?a ?g =\n                    S.mkArr (Hom.set (?b, ?a)) (Hom.set (?b', ?a))\n                     (\\<phi> (?b', ?a) \\<circ>\n                      (\\<cdot>\\<^sup>o\\<^sup>p) ?g \\<circ>\n                      \\<psi> (?b, ?a))\n  \\<lbrakk>C.ide ?a; C.ide ?b\\<rbrakk>\n  \\<Longrightarrow> S.set (Hom.map (?b, ?a)) = Hom.set (?b, ?a)\n  \\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright> \\<Longrightarrow>\n  C.arr ?f\n\ngoal (1 subgoal):\n 1. Y a (\\<psi> (b, a) x) =\n    S.mkArr (Hom.set (a, a)) (SET b)\n     (\\<phi> (b, a) \\<circ>\n      (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (b, a) x) \\<circ>\n      \\<psi> (a, a))", "by auto"], ["proof (state)\nthis:\n  Y a (\\<psi> (b, a) x) =\n  S.mkArr (Hom.set (a, a)) (SET b)\n   (\\<phi> (b, a) \\<circ>\n    (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (b, a) x) \\<circ>\n    \\<psi> (a, a))\n\ngoal (1 subgoal):\n 1. (\\<tau>.FUN b \\<circ>\n     (\\<phi> (b, a) \\<circ>\n      (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (b, a) x) \\<circ>\n      \\<psi> (a, a)))\n     (\\<phi> (a, a) a) =\n    S.Fun (\\<tau> b \\<cdot>\\<^sub>S Y a (\\<psi> (b, a) x)) (\\<phi> (a, a) a)", "moreover"], ["proof (state)\nthis:\n  Y a (\\<psi> (b, a) x) =\n  S.mkArr (Hom.set (a, a)) (SET b)\n   (\\<phi> (b, a) \\<circ>\n    (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (b, a) x) \\<circ>\n    \\<psi> (a, a))\n\ngoal (1 subgoal):\n 1. (\\<tau>.FUN b \\<circ>\n     (\\<phi> (b, a) \\<circ>\n      (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (b, a) x) \\<circ>\n      \\<psi> (a, a)))\n     (\\<phi> (a, a) a) =\n    S.Fun (\\<tau> b \\<cdot>\\<^sub>S Y a (\\<psi> (b, a) x)) (\\<phi> (a, a) a)", "have \"S.arr (\\<tau> b) \\<and> \\<tau> b = S.mkArr (SET b) (F.SET b) (\\<tau>.FUN b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.arr (\\<tau> b) \\<and>\n    \\<tau> b = S.mkArr (SET b) (F.SET b) (\\<tau>.FUN b)", "using ide_a b S.mkArr_Fun [of \"\\<tau> b\"]"], ["proof (prove)\nusing this:\n  C.ide a\n  Cop.ide b\n  S.arr (\\<tau> b) \\<Longrightarrow>\n  S.mkArr (\\<tau>.DOM b) (\\<tau>.COD b) (\\<tau>.FUN b) = \\<tau> b\n\ngoal (1 subgoal):\n 1. S.arr (\\<tau> b) \\<and>\n    \\<tau> b = S.mkArr (SET b) (F.SET b) (\\<tau>.FUN b)", "by simp"], ["proof (state)\nthis:\n  S.arr (\\<tau> b) \\<and>\n  \\<tau> b = S.mkArr (SET b) (F.SET b) (\\<tau>.FUN b)\n\ngoal (1 subgoal):\n 1. (\\<tau>.FUN b \\<circ>\n     (\\<phi> (b, a) \\<circ>\n      (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (b, a) x) \\<circ>\n      \\<psi> (a, a)))\n     (\\<phi> (a, a) a) =\n    S.Fun (\\<tau> b \\<cdot>\\<^sub>S Y a (\\<psi> (b, a) x)) (\\<phi> (a, a) a)", "ultimately"], ["proof (chain)\npicking this:\n  S.arr (Y a (\\<psi> (b, a) x))\n  Y a (\\<psi> (b, a) x) =\n  S.mkArr (Hom.set (a, a)) (SET b)\n   (\\<phi> (b, a) \\<circ>\n    (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (b, a) x) \\<circ>\n    \\<psi> (a, a))\n  S.arr (\\<tau> b) \\<and>\n  \\<tau> b = S.mkArr (SET b) (F.SET b) (\\<tau>.FUN b)", "have\n                     \"S.seq (\\<tau> b) (Y a ?\\<psi>x) \\<and>\n                      \\<tau> b \\<cdot>\\<^sub>S Y a ?\\<psi>x =\n                         S.mkArr (Hom.set (a, a)) (F.SET b)\n                                 (\\<tau>.FUN b o (\\<phi> (b, a) \\<circ> Cop.comp ?\\<psi>x \\<circ> \\<psi> (a, a)))\""], ["proof (prove)\nusing this:\n  S.arr (Y a (\\<psi> (b, a) x))\n  Y a (\\<psi> (b, a) x) =\n  S.mkArr (Hom.set (a, a)) (SET b)\n   (\\<phi> (b, a) \\<circ>\n    (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (b, a) x) \\<circ>\n    \\<psi> (a, a))\n  S.arr (\\<tau> b) \\<and>\n  \\<tau> b = S.mkArr (SET b) (F.SET b) (\\<tau>.FUN b)\n\ngoal (1 subgoal):\n 1. S.seq (\\<tau> b) (Y a (\\<psi> (b, a) x)) \\<and>\n    \\<tau> b \\<cdot>\\<^sub>S Y a (\\<psi> (b, a) x) =\n    S.mkArr (Hom.set (a, a)) (F.SET b)\n     (\\<tau>.FUN b \\<circ>\n      (\\<phi> (b, a) \\<circ>\n       (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (b, a) x) \\<circ>\n       \\<psi> (a, a)))", "using 1 S.comp_mkArr S.seqI"], ["proof (prove)\nusing this:\n  S.arr (Y a (\\<psi> (b, a) x))\n  Y a (\\<psi> (b, a) x) =\n  S.mkArr (Hom.set (a, a)) (SET b)\n   (\\<phi> (b, a) \\<circ>\n    (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (b, a) x) \\<circ>\n    \\<psi> (a, a))\n  S.arr (\\<tau> b) \\<and>\n  \\<tau> b = S.mkArr (SET b) (F.SET b) (\\<tau>.FUN b)\n  \\<tau> b = S.mkArr (Hom.set (b, a)) (F.SET b) (\\<tau>.FUN b)\n  \\<lbrakk>S.arr (S.mkArr ?A ?B ?F); S.arr (S.mkArr ?B ?C ?G)\\<rbrakk>\n  \\<Longrightarrow> S.mkArr ?B ?C ?G \\<cdot>\\<^sub>S S.mkArr ?A ?B ?F =\n                    S.mkArr ?A ?C (?G \\<circ> ?F)\n  \\<lbrakk>S.arr ?f; S.arr ?g; S.dom ?g = S.cod ?f\\<rbrakk>\n  \\<Longrightarrow> S.seq ?g ?f\n\ngoal (1 subgoal):\n 1. S.seq (\\<tau> b) (Y a (\\<psi> (b, a) x)) \\<and>\n    \\<tau> b \\<cdot>\\<^sub>S Y a (\\<psi> (b, a) x) =\n    S.mkArr (Hom.set (a, a)) (F.SET b)\n     (\\<tau>.FUN b \\<circ>\n      (\\<phi> (b, a) \\<circ>\n       (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (b, a) x) \\<circ>\n       \\<psi> (a, a)))", "by (metis S.cod_mkArr S.dom_mkArr)"], ["proof (state)\nthis:\n  S.seq (\\<tau> b) (Y a (\\<psi> (b, a) x)) \\<and>\n  \\<tau> b \\<cdot>\\<^sub>S Y a (\\<psi> (b, a) x) =\n  S.mkArr (Hom.set (a, a)) (F.SET b)\n   (\\<tau>.FUN b \\<circ>\n    (\\<phi> (b, a) \\<circ>\n     (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (b, a) x) \\<circ>\n     \\<psi> (a, a)))\n\ngoal (1 subgoal):\n 1. (\\<tau>.FUN b \\<circ>\n     (\\<phi> (b, a) \\<circ>\n      (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (b, a) x) \\<circ>\n      \\<psi> (a, a)))\n     (\\<phi> (a, a) a) =\n    S.Fun (\\<tau> b \\<cdot>\\<^sub>S Y a (\\<psi> (b, a) x)) (\\<phi> (a, a) a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  S.seq (\\<tau> b) (Y a (\\<psi> (b, a) x)) \\<and>\n  \\<tau> b \\<cdot>\\<^sub>S Y a (\\<psi> (b, a) x) =\n  S.mkArr (Hom.set (a, a)) (F.SET b)\n   (\\<tau>.FUN b \\<circ>\n    (\\<phi> (b, a) \\<circ>\n     (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (b, a) x) \\<circ>\n     \\<psi> (a, a)))\n\ngoal (1 subgoal):\n 1. (\\<tau>.FUN b \\<circ>\n     (\\<phi> (b, a) \\<circ>\n      (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (b, a) x) \\<circ>\n      \\<psi> (a, a)))\n     (\\<phi> (a, a) a) =\n    S.Fun (\\<tau> b \\<cdot>\\<^sub>S Y a (\\<psi> (b, a) x)) (\\<phi> (a, a) a)", "using ide_a b x Hom.\\<phi>_mapsto S.Fun_mkArr"], ["proof (prove)\nusing this:\n  S.seq (\\<tau> b) (Y a (\\<psi> (b, a) x)) \\<and>\n  \\<tau> b \\<cdot>\\<^sub>S Y a (\\<psi> (b, a) x) =\n  S.mkArr (Hom.set (a, a)) (F.SET b)\n   (\\<tau>.FUN b \\<circ>\n    (\\<phi> (b, a) \\<circ>\n     (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (b, a) x) \\<circ>\n     \\<psi> (a, a)))\n  C.ide a\n  Cop.ide b\n  x \\<in> Hom.set (b, a)\n  \\<lbrakk>C.ide ?b; C.ide ?a\\<rbrakk>\n  \\<Longrightarrow> \\<phi> (?b, ?a)\n                    \\<in> C.hom ?b ?a \\<rightarrow> Hom.set (?b, ?a)\n  S.arr (S.mkArr ?A ?B ?F) \\<Longrightarrow>\n  S.Fun (S.mkArr ?A ?B ?F) = restrict ?F ?A\n\ngoal (1 subgoal):\n 1. (\\<tau>.FUN b \\<circ>\n     (\\<phi> (b, a) \\<circ>\n      (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (b, a) x) \\<circ>\n      \\<psi> (a, a)))\n     (\\<phi> (a, a) a) =\n    S.Fun (\\<tau> b \\<cdot>\\<^sub>S Y a (\\<psi> (b, a) x)) (\\<phi> (a, a) a)", "by force"], ["proof (state)\nthis:\n  (\\<tau>.FUN b \\<circ>\n   (\\<phi> (b, a) \\<circ>\n    (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (b, a) x) \\<circ>\n    \\<psi> (a, a)))\n   (\\<phi> (a, a) a) =\n  S.Fun (\\<tau> b \\<cdot>\\<^sub>S Y a (\\<psi> (b, a) x)) (\\<phi> (a, a) a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<tau>.FUN b \\<circ>\n   (\\<phi> (b, a) \\<circ>\n    (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (b, a) x) \\<circ>\n    \\<psi> (a, a)))\n   (\\<phi> (a, a) a) =\n  S.Fun (\\<tau> b \\<cdot>\\<^sub>S Y a (\\<psi> (b, a) x)) (\\<phi> (a, a) a)\n\ngoal (1 subgoal):\n 1. \\<tau>.FUN b x =\n    S.Fun (\\<tau> b \\<cdot>\\<^sub>S Y a (\\<psi> (b, a) x)) (\\<phi> (a, a) a)", "finally"], ["proof (chain)\npicking this:\n  \\<tau>.FUN b x =\n  S.Fun (\\<tau> b \\<cdot>\\<^sub>S Y a (\\<psi> (b, a) x)) (\\<phi> (a, a) a)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<tau>.FUN b x =\n  S.Fun (\\<tau> b \\<cdot>\\<^sub>S Y a (\\<psi> (b, a) x)) (\\<phi> (a, a) a)\n\ngoal (1 subgoal):\n 1. \\<tau>.FUN b x =\n    S.Fun (\\<tau> b \\<cdot>\\<^sub>S Y a (\\<psi> (b, a) x)) (\\<phi> (a, a) a)", "by auto"], ["proof (state)\nthis:\n  \\<tau>.FUN b x =\n  S.Fun (\\<tau> b \\<cdot>\\<^sub>S Y a (\\<psi> (b, a) x)) (\\<phi> (a, a) a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<tau>.FUN b x =\n  S.Fun (\\<tau> b \\<cdot>\\<^sub>S Y a (\\<psi> (b, a) x)) (\\<phi> (a, a) a)\n\ngoal (1 subgoal):\n 1. \\<tau>.FUN b x =\n    F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a))", "also"], ["proof (state)\nthis:\n  \\<tau>.FUN b x =\n  S.Fun (\\<tau> b \\<cdot>\\<^sub>S Y a (\\<psi> (b, a) x)) (\\<phi> (a, a) a)\n\ngoal (1 subgoal):\n 1. \\<tau>.FUN b x =\n    F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a))", "have \"... = S.Fun (F ?\\<psi>x \\<cdot>\\<^sub>S \\<tau> a) ?\\<phi>a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.Fun (\\<tau> b \\<cdot>\\<^sub>S Y a (\\<psi> (b, a) x))\n     (\\<phi> (a, a) a) =\n    S.Fun (F (\\<psi> (b, a) x) \\<cdot>\\<^sub>S \\<tau> a) (\\<phi> (a, a) a)", "using ide_a b \\<psi>x \\<tau>.naturality [of ?\\<psi>x]"], ["proof (prove)\nusing this:\n  C.ide a\n  Cop.ide b\n  \\<guillemotleft>\\<psi> (b, a) x : b \\<rightarrow> a\\<guillemotright>\n  Cop.arr (\\<psi> (b, a) x) \\<Longrightarrow>\n  \\<tau> (Cop.cod (\\<psi> (b, a) x)) \\<cdot>\\<^sub>S Y a (\\<psi> (b, a) x) =\n  F (\\<psi> (b, a) x) \\<cdot>\\<^sub>S \\<tau> (Cop.dom (\\<psi> (b, a) x))\n\ngoal (1 subgoal):\n 1. S.Fun (\\<tau> b \\<cdot>\\<^sub>S Y a (\\<psi> (b, a) x))\n     (\\<phi> (a, a) a) =\n    S.Fun (F (\\<psi> (b, a) x) \\<cdot>\\<^sub>S \\<tau> a) (\\<phi> (a, a) a)", "by force"], ["proof (state)\nthis:\n  S.Fun (\\<tau> b \\<cdot>\\<^sub>S Y a (\\<psi> (b, a) x)) (\\<phi> (a, a) a) =\n  S.Fun (F (\\<psi> (b, a) x) \\<cdot>\\<^sub>S \\<tau> a) (\\<phi> (a, a) a)\n\ngoal (1 subgoal):\n 1. \\<tau>.FUN b x =\n    F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a))", "also"], ["proof (state)\nthis:\n  S.Fun (\\<tau> b \\<cdot>\\<^sub>S Y a (\\<psi> (b, a) x)) (\\<phi> (a, a) a) =\n  S.Fun (F (\\<psi> (b, a) x) \\<cdot>\\<^sub>S \\<tau> a) (\\<phi> (a, a) a)\n\ngoal (1 subgoal):\n 1. \\<tau>.FUN b x =\n    F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a))", "have \"... = F.FUN ?\\<psi>x (\\<tau>.FUN a ?\\<phi>a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.Fun (F (\\<psi> (b, a) x) \\<cdot>\\<^sub>S \\<tau> a) (\\<phi> (a, a) a) =\n    F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. S.Fun (F (\\<psi> (b, a) x) \\<cdot>\\<^sub>S \\<tau> a) (\\<phi> (a, a) a) =\n    F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a))", "have \"restrict (S.Fun (F ?\\<psi>x \\<cdot>\\<^sub>S \\<tau> a)) (Hom.set (a, a))\n                               = restrict (F.FUN (\\<psi> (b, a) x) o \\<tau>.FUN a) (Hom.set (a, a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict (S.Fun (F (\\<psi> (b, a) x) \\<cdot>\\<^sub>S \\<tau> a))\n     (Hom.set (a, a)) =\n    restrict (F.FUN (\\<psi> (b, a) x) \\<circ> \\<tau>.FUN a) (Hom.set (a, a))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. restrict (S.Fun (F (\\<psi> (b, a) x) \\<cdot>\\<^sub>S \\<tau> a))\n     (Hom.set (a, a)) =\n    restrict (F.FUN (\\<psi> (b, a) x) \\<circ> \\<tau>.FUN a) (Hom.set (a, a))", "have\n                  \"S.arr (F ?\\<psi>x \\<cdot>\\<^sub>S \\<tau> a) \\<and>\n                   F ?\\<psi>x \\<cdot>\\<^sub>S \\<tau> a = S.mkArr (Hom.set (a, a)) (F.SET b) (F.FUN ?\\<psi>x o \\<tau>.FUN a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.seq (F (\\<psi> (b, a) x)) (\\<tau> a) \\<and>\n    F (\\<psi> (b, a) x) \\<cdot>\\<^sub>S \\<tau> a =\n    S.mkArr (Hom.set (a, a)) (F.SET b)\n     (F.FUN (\\<psi> (b, a) x) \\<circ> \\<tau>.FUN a)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. S.seq (F (\\<psi> (b, a) x)) (\\<tau> a)\n 2. F (\\<psi> (b, a) x) \\<cdot>\\<^sub>S \\<tau> a =\n    S.mkArr (Hom.set (a, a)) (F.SET b)\n     (F.FUN (\\<psi> (b, a) x) \\<circ> \\<tau>.FUN a)", "show 1: \"S.seq (F ?\\<psi>x) (\\<tau> a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.seq (F (\\<psi> (b, a) x)) (\\<tau> a)", "using \\<psi>x ide_a \\<tau>.preserves_cod F.preserves_dom"], ["proof (prove)\nusing this:\n  \\<guillemotleft>\\<psi> (b, a) x : b \\<rightarrow> a\\<guillemotright>\n  C.ide a\n  Cop.arr ?f \\<Longrightarrow> S.cod (\\<tau> ?f) = F (Cop.cod ?f)\n  Cop.arr ?f \\<Longrightarrow> S.dom (F ?f) = F (Cop.dom ?f)\n\ngoal (1 subgoal):\n 1. S.seq (F (\\<psi> (b, a) x)) (\\<tau> a)", "by (elim C.in_homE, auto)"], ["proof (state)\nthis:\n  S.seq (F (\\<psi> (b, a) x)) (\\<tau> a)\n\ngoal (1 subgoal):\n 1. F (\\<psi> (b, a) x) \\<cdot>\\<^sub>S \\<tau> a =\n    S.mkArr (Hom.set (a, a)) (F.SET b)\n     (F.FUN (\\<psi> (b, a) x) \\<circ> \\<tau>.FUN a)", "have \"\\<tau> a = S.mkArr (Hom.set (a, a)) (F.SET a) (\\<tau>.FUN a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau> a = S.mkArr (Hom.set (a, a)) (F.SET a) (\\<tau>.FUN a)", "using ide_a 1 S.mkArr_Fun [of \"\\<tau> a\"] Hom.set_map"], ["proof (prove)\nusing this:\n  C.ide a\n  S.seq (F (\\<psi> (b, a) x)) (\\<tau> a)\n  S.arr (\\<tau> a) \\<Longrightarrow>\n  S.mkArr (\\<tau>.DOM a) (\\<tau>.COD a) (\\<tau>.FUN a) = \\<tau> a\n  \\<lbrakk>C.ide ?a; C.ide ?b\\<rbrakk>\n  \\<Longrightarrow> S.set (Hom.map (?b, ?a)) = Hom.set (?b, ?a)\n\ngoal (1 subgoal):\n 1. \\<tau> a = S.mkArr (Hom.set (a, a)) (F.SET a) (\\<tau>.FUN a)", "by auto"], ["proof (state)\nthis:\n  \\<tau> a = S.mkArr (Hom.set (a, a)) (F.SET a) (\\<tau>.FUN a)\n\ngoal (1 subgoal):\n 1. F (\\<psi> (b, a) x) \\<cdot>\\<^sub>S \\<tau> a =\n    S.mkArr (Hom.set (a, a)) (F.SET b)\n     (F.FUN (\\<psi> (b, a) x) \\<circ> \\<tau>.FUN a)", "moreover"], ["proof (state)\nthis:\n  \\<tau> a = S.mkArr (Hom.set (a, a)) (F.SET a) (\\<tau>.FUN a)\n\ngoal (1 subgoal):\n 1. F (\\<psi> (b, a) x) \\<cdot>\\<^sub>S \\<tau> a =\n    S.mkArr (Hom.set (a, a)) (F.SET b)\n     (F.FUN (\\<psi> (b, a) x) \\<circ> \\<tau>.FUN a)", "have \"F ?\\<psi>x = S.mkArr (F.SET a) (F.SET b) (F.FUN ?\\<psi>x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F (\\<psi> (b, a) x) =\n    S.mkArr (F.SET a) (F.SET b) (F.FUN (\\<psi> (b, a) x))", "using x \\<psi>x 1 S.mkArr_Fun [of \"F ?\\<psi>x\"]"], ["proof (prove)\nusing this:\n  x \\<in> Hom.set (b, a)\n  \\<guillemotleft>\\<psi> (b, a) x : b \\<rightarrow> a\\<guillemotright>\n  S.seq (F (\\<psi> (b, a) x)) (\\<tau> a)\n  S.arr (F (\\<psi> (b, a) x)) \\<Longrightarrow>\n  S.mkArr (F.DOM (\\<psi> (b, a) x)) (F.COD (\\<psi> (b, a) x))\n   (F.FUN (\\<psi> (b, a) x)) =\n  F (\\<psi> (b, a) x)\n\ngoal (1 subgoal):\n 1. F (\\<psi> (b, a) x) =\n    S.mkArr (F.SET a) (F.SET b) (F.FUN (\\<psi> (b, a) x))", "by fastforce"], ["proof (state)\nthis:\n  F (\\<psi> (b, a) x) =\n  S.mkArr (F.SET a) (F.SET b) (F.FUN (\\<psi> (b, a) x))\n\ngoal (1 subgoal):\n 1. F (\\<psi> (b, a) x) \\<cdot>\\<^sub>S \\<tau> a =\n    S.mkArr (Hom.set (a, a)) (F.SET b)\n     (F.FUN (\\<psi> (b, a) x) \\<circ> \\<tau>.FUN a)", "ultimately"], ["proof (chain)\npicking this:\n  \\<tau> a = S.mkArr (Hom.set (a, a)) (F.SET a) (\\<tau>.FUN a)\n  F (\\<psi> (b, a) x) =\n  S.mkArr (F.SET a) (F.SET b) (F.FUN (\\<psi> (b, a) x))", "show \"F ?\\<psi>x \\<cdot>\\<^sub>S \\<tau> a =\n                                   S.mkArr (Hom.set (a, a)) (F.SET b) (F.FUN ?\\<psi>x o \\<tau>.FUN a)\""], ["proof (prove)\nusing this:\n  \\<tau> a = S.mkArr (Hom.set (a, a)) (F.SET a) (\\<tau>.FUN a)\n  F (\\<psi> (b, a) x) =\n  S.mkArr (F.SET a) (F.SET b) (F.FUN (\\<psi> (b, a) x))\n\ngoal (1 subgoal):\n 1. F (\\<psi> (b, a) x) \\<cdot>\\<^sub>S \\<tau> a =\n    S.mkArr (Hom.set (a, a)) (F.SET b)\n     (F.FUN (\\<psi> (b, a) x) \\<circ> \\<tau>.FUN a)", "using 1 S.comp_mkArr [of \"Hom.set (a, a)\" \"F.SET a\" \"\\<tau>.FUN a\"\n                                             \"F.SET b\" \"F.FUN ?\\<psi>x\"]"], ["proof (prove)\nusing this:\n  \\<tau> a = S.mkArr (Hom.set (a, a)) (F.SET a) (\\<tau>.FUN a)\n  F (\\<psi> (b, a) x) =\n  S.mkArr (F.SET a) (F.SET b) (F.FUN (\\<psi> (b, a) x))\n  S.seq (F (\\<psi> (b, a) x)) (\\<tau> a)\n  \\<lbrakk>S.arr (S.mkArr (Hom.set (a, a)) (F.SET a) (\\<tau>.FUN a));\n   S.arr (S.mkArr (F.SET a) (F.SET b) (F.FUN (\\<psi> (b, a) x)))\\<rbrakk>\n  \\<Longrightarrow> S.mkArr (F.SET a) (F.SET b)\n                     (F.FUN (\\<psi> (b, a) x)) \\<cdot>\\<^sub>S\n                    S.mkArr (Hom.set (a, a)) (F.SET a) (\\<tau>.FUN a) =\n                    S.mkArr (Hom.set (a, a)) (F.SET b)\n                     (F.FUN (\\<psi> (b, a) x) \\<circ> \\<tau>.FUN a)\n\ngoal (1 subgoal):\n 1. F (\\<psi> (b, a) x) \\<cdot>\\<^sub>S \\<tau> a =\n    S.mkArr (Hom.set (a, a)) (F.SET b)\n     (F.FUN (\\<psi> (b, a) x) \\<circ> \\<tau>.FUN a)", "by (elim S.seqE, auto)"], ["proof (state)\nthis:\n  F (\\<psi> (b, a) x) \\<cdot>\\<^sub>S \\<tau> a =\n  S.mkArr (Hom.set (a, a)) (F.SET b)\n   (F.FUN (\\<psi> (b, a) x) \\<circ> \\<tau>.FUN a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S.seq (F (\\<psi> (b, a) x)) (\\<tau> a) \\<and>\n  F (\\<psi> (b, a) x) \\<cdot>\\<^sub>S \\<tau> a =\n  S.mkArr (Hom.set (a, a)) (F.SET b)\n   (F.FUN (\\<psi> (b, a) x) \\<circ> \\<tau>.FUN a)\n\ngoal (1 subgoal):\n 1. restrict (S.Fun (F (\\<psi> (b, a) x) \\<cdot>\\<^sub>S \\<tau> a))\n     (Hom.set (a, a)) =\n    restrict (F.FUN (\\<psi> (b, a) x) \\<circ> \\<tau>.FUN a) (Hom.set (a, a))", "thus ?thesis"], ["proof (prove)\nusing this:\n  S.seq (F (\\<psi> (b, a) x)) (\\<tau> a) \\<and>\n  F (\\<psi> (b, a) x) \\<cdot>\\<^sub>S \\<tau> a =\n  S.mkArr (Hom.set (a, a)) (F.SET b)\n   (F.FUN (\\<psi> (b, a) x) \\<circ> \\<tau>.FUN a)\n\ngoal (1 subgoal):\n 1. restrict (S.Fun (F (\\<psi> (b, a) x) \\<cdot>\\<^sub>S \\<tau> a))\n     (Hom.set (a, a)) =\n    restrict (F.FUN (\\<psi> (b, a) x) \\<circ> \\<tau>.FUN a) (Hom.set (a, a))", "by force"], ["proof (state)\nthis:\n  restrict (S.Fun (F (\\<psi> (b, a) x) \\<cdot>\\<^sub>S \\<tau> a))\n   (Hom.set (a, a)) =\n  restrict (F.FUN (\\<psi> (b, a) x) \\<circ> \\<tau>.FUN a) (Hom.set (a, a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  restrict (S.Fun (F (\\<psi> (b, a) x) \\<cdot>\\<^sub>S \\<tau> a))\n   (Hom.set (a, a)) =\n  restrict (F.FUN (\\<psi> (b, a) x) \\<circ> \\<tau>.FUN a) (Hom.set (a, a))\n\ngoal (1 subgoal):\n 1. S.Fun (F (\\<psi> (b, a) x) \\<cdot>\\<^sub>S \\<tau> a) (\\<phi> (a, a) a) =\n    F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a))", "thus \"S.Fun (F (\\<psi> (b, a) x) \\<cdot>\\<^sub>S \\<tau> a) ?\\<phi>a = F.FUN ?\\<psi>x (\\<tau>.FUN a ?\\<phi>a)\""], ["proof (prove)\nusing this:\n  restrict (S.Fun (F (\\<psi> (b, a) x) \\<cdot>\\<^sub>S \\<tau> a))\n   (Hom.set (a, a)) =\n  restrict (F.FUN (\\<psi> (b, a) x) \\<circ> \\<tau>.FUN a) (Hom.set (a, a))\n\ngoal (1 subgoal):\n 1. S.Fun (F (\\<psi> (b, a) x) \\<cdot>\\<^sub>S \\<tau> a) (\\<phi> (a, a) a) =\n    F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a))", "using ide_a \\<phi>a restr_eqE [of \"S.Fun (F ?\\<psi>x \\<cdot>\\<^sub>S \\<tau> a)\"\n                                           \"Hom.set (a, a)\" \"F.FUN ?\\<psi>x o \\<tau>.FUN a\"]"], ["proof (prove)\nusing this:\n  restrict (S.Fun (F (\\<psi> (b, a) x) \\<cdot>\\<^sub>S \\<tau> a))\n   (Hom.set (a, a)) =\n  restrict (F.FUN (\\<psi> (b, a) x) \\<circ> \\<tau>.FUN a) (Hom.set (a, a))\n  C.ide a\n  \\<phi> (a, a) a \\<in> Hom.set (a, a)\n  \\<lbrakk>restrict (S.Fun (F (\\<psi> (b, a) x) \\<cdot>\\<^sub>S \\<tau> a))\n            (Hom.set (a, a)) =\n           restrict (F.FUN (\\<psi> (b, a) x) \\<circ> \\<tau>.FUN a)\n            (Hom.set (a, a));\n   ?x \\<in> Hom.set (a, a)\\<rbrakk>\n  \\<Longrightarrow> S.Fun (F (\\<psi> (b, a) x) \\<cdot>\\<^sub>S \\<tau> a)\n                     ?x =\n                    (F.FUN (\\<psi> (b, a) x) \\<circ> \\<tau>.FUN a) ?x\n\ngoal (1 subgoal):\n 1. S.Fun (F (\\<psi> (b, a) x) \\<cdot>\\<^sub>S \\<tau> a) (\\<phi> (a, a) a) =\n    F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a))", "by simp"], ["proof (state)\nthis:\n  S.Fun (F (\\<psi> (b, a) x) \\<cdot>\\<^sub>S \\<tau> a) (\\<phi> (a, a) a) =\n  F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S.Fun (F (\\<psi> (b, a) x) \\<cdot>\\<^sub>S \\<tau> a) (\\<phi> (a, a) a) =\n  F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a))\n\ngoal (1 subgoal):\n 1. \\<tau>.FUN b x =\n    F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a))", "finally"], ["proof (chain)\npicking this:\n  \\<tau>.FUN b x = F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<tau>.FUN b x = F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a))\n\ngoal (1 subgoal):\n 1. \\<tau>.FUN b x =\n    F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a))", "by simp"], ["proof (state)\nthis:\n  \\<tau>.FUN b x = F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<tau>.FUN b x = F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> Hom.set (b, a) \\<Longrightarrow>\n  \\<tau>.FUN b ?x =\n  F.FUN (\\<psi> (b, a) ?x) (\\<tau>.FUN a (\\<phi> (a, a) a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S.mkArr (Hom.set (b, a)) (F.SET b) (\\<tau>.FUN b) =\n  S.mkArr (Hom.set (b, a)) (F.SET b)\n   (\\<lambda>x. F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a)))\n\ngoal (1 subgoal):\n 1. \\<tau> b =\n    S.mkArr (Hom.set (b, a)) (F.SET b)\n     (\\<lambda>x. F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a)))", "finally"], ["proof (chain)\npicking this:\n  \\<tau> b =\n  S.mkArr (Hom.set (b, a)) (F.SET b)\n   (\\<lambda>x. F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a)))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<tau> b =\n  S.mkArr (Hom.set (b, a)) (F.SET b)\n   (\\<lambda>x. F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a)))\n\ngoal (1 subgoal):\n 1. \\<tau> b =\n    S.mkArr (Hom.set (b, a)) (F.SET b)\n     (\\<lambda>x. F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a)))", "by auto"], ["proof (state)\nthis:\n  \\<tau> b =\n  S.mkArr (Hom.set (b, a)) (F.SET b)\n   (\\<lambda>x. F.FUN (\\<psi> (b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a)))\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n      Consequently, if @{term \\<tau>'} is any natural transformation from @{term \"Y a\"} to @{term F}\n      that agrees with @{term \\<tau>} at @{term a}, then @{term \"\\<tau>' = \\<tau>\"}.\n\\<close>"], ["", "lemma eqI:\n    assumes \"natural_transformation Cop.comp S (Y a) F \\<tau>'\" and \"\\<tau>' a = \\<tau> a\"\n    shows \"\\<tau>' = \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<tau>' = \\<tau>", "proof (intro NaturalTransformation.eqI)"], ["proof (state)\ngoal (3 subgoals):\n 1. natural_transformation ?A ?B ?F ?G \\<tau>'\n 2. natural_transformation ?A ?B ?F ?G \\<tau>\n 3. \\<And>a. partial_magma.ide ?A a \\<Longrightarrow> \\<tau>' a = \\<tau> a", "interpret \\<tau>': natural_transformation Cop.comp S \\<open>Y a\\<close> F \\<tau>'"], ["proof (prove)\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n     F \\<tau>'", "using assms"], ["proof (prove)\nusing this:\n  natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a) F\n   \\<tau>'\n  \\<tau>' a = \\<tau> a\n\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n     F \\<tau>'", "by auto"], ["proof (state)\ngoal (3 subgoals):\n 1. natural_transformation ?A ?B ?F ?G \\<tau>'\n 2. natural_transformation ?A ?B ?F ?G \\<tau>\n 3. \\<And>a. partial_magma.ide ?A a \\<Longrightarrow> \\<tau>' a = \\<tau> a", "interpret T': yoneda_lemma_fixed_\\<tau> C S \\<phi> F a \\<tau>'"], ["proof (prove)\ngoal (1 subgoal):\n 1. yoneda_lemma_fixed_\\<tau> (\\<cdot>) (\\<cdot>\\<^sub>S) \\<phi> F a \\<tau>'", ".."], ["proof (state)\ngoal (3 subgoals):\n 1. natural_transformation ?A ?B ?F ?G \\<tau>'\n 2. natural_transformation ?A ?B ?F ?G \\<tau>\n 3. \\<And>a. partial_magma.ide ?A a \\<Longrightarrow> \\<tau>' a = \\<tau> a", "show \"natural_transformation Cop.comp S (Y a) F \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n     F \\<tau>", ".."], ["proof (state)\nthis:\n  natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a) F\n   \\<tau>\n\ngoal (2 subgoals):\n 1. natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n     F \\<tau>'\n 2. \\<And>a. Cop.ide a \\<Longrightarrow> \\<tau>' a = \\<tau> a", "show \"natural_transformation Cop.comp S (Y a) F \\<tau>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n     F \\<tau>'", ".."], ["proof (state)\nthis:\n  natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a) F\n   \\<tau>'\n\ngoal (1 subgoal):\n 1. \\<And>a. Cop.ide a \\<Longrightarrow> \\<tau>' a = \\<tau> a", "show \"\\<And>b. Cop.ide b \\<Longrightarrow> \\<tau>' b = \\<tau> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b. Cop.ide b \\<Longrightarrow> \\<tau>' b = \\<tau> b", "using assms(2) \\<tau>_ide T'.\\<tau>_ide"], ["proof (prove)\nusing this:\n  \\<tau>' a = \\<tau> a\n  Cop.ide ?b \\<Longrightarrow>\n  \\<tau> ?b =\n  S.mkArr (Hom.set (?b, a)) (F.SET ?b)\n   (\\<lambda>x. F.FUN (\\<psi> (?b, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a)))\n  Cop.ide ?b \\<Longrightarrow>\n  \\<tau>' ?b =\n  S.mkArr (Hom.set (?b, a)) (F.SET ?b)\n   (\\<lambda>x.\n       F.FUN (\\<psi> (?b, a) x) (T'.\\<tau>.FUN a (\\<phi> (a, a) a)))\n\ngoal (1 subgoal):\n 1. \\<And>b. Cop.ide b \\<Longrightarrow> \\<tau>' b = \\<tau> b", "by simp"], ["proof (state)\nthis:\n  Cop.ide ?b \\<Longrightarrow> \\<tau>' ?b = \\<tau> ?b\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context yoneda_lemma\n  begin"], ["", "text\\<open>\n      One half of the Yoneda lemma:\n      The mapping @{term \\<T>} is an injection, with left inverse @{term \\<E>},\n      from the set @{term \"F.SET a\"} to the set of natural transformations from\n      @{term \"Y a\"} to @{term F}.\n\\<close>"], ["", "lemma \\<T>_is_injection:\n    assumes \"e \\<in> F.SET a\"\n    shows \"natural_transformation Cop.comp S (Y a) F (\\<T> e)\" and \"\\<E> (\\<T> e) = e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n     F (\\<T> e) &&&\n    \\<E> (\\<T> e) = e", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n     F (\\<T> e)\n 2. \\<E> (\\<T> e) = e", "interpret yoneda_lemma_fixed_e C S \\<phi> F a e"], ["proof (prove)\ngoal (1 subgoal):\n 1. yoneda_lemma_fixed_e (\\<cdot>) (\\<cdot>\\<^sub>S) \\<phi> F a e", "using assms"], ["proof (prove)\nusing this:\n  e \\<in> F.SET a\n\ngoal (1 subgoal):\n 1. yoneda_lemma_fixed_e (\\<cdot>) (\\<cdot>\\<^sub>S) \\<phi> F a e", "by (unfold_locales, auto)"], ["proof (state)\ngoal (2 subgoals):\n 1. natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n     F (\\<T> e)\n 2. \\<E> (\\<T> e) = e", "interpret \\<T>e: natural_transformation Cop.comp S \\<open>Y a\\<close> F \\<open>\\<T> e\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n     F (\\<T> e)", "using natural_transformation_\\<T>e"], ["proof (prove)\nusing this:\n  natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a) F\n   (\\<T> e)\n\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n     F (\\<T> e)", "by auto"], ["proof (state)\ngoal (2 subgoals):\n 1. natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n     F (\\<T> e)\n 2. \\<E> (\\<T> e) = e", "show \"natural_transformation Cop.comp S (Y a) F (\\<T> e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n     F (\\<T> e)", ".."], ["proof (state)\nthis:\n  natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a) F\n   (\\<T> e)\n\ngoal (1 subgoal):\n 1. \\<E> (\\<T> e) = e", "show \"\\<E> (\\<T> e) = e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<E> (\\<T> e) = e", "unfolding \\<E>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. S.Fun (\\<T> e a) (\\<phi> (a, a) a) = e", "using assms \\<T>e_ide S.Fun_mkArr Hom.\\<phi>_mapsto Hom.\\<psi>_\\<phi> ide_a\n              F.preserves_ide S.Fun_ide restrict_apply C.ide_in_hom"], ["proof (prove)\nusing this:\n  e \\<in> F.SET a\n  Cop.ide ?b \\<Longrightarrow> S.arr (\\<T> e ?b)\n  Cop.ide ?b \\<Longrightarrow>\n  \\<T> e ?b =\n  S.mkArr (Hom.set (?b, a)) (F.SET ?b)\n   (\\<lambda>x. F.FUN (\\<psi> (?b, a) x) e)\n  S.arr (S.mkArr ?A ?B ?F) \\<Longrightarrow>\n  S.Fun (S.mkArr ?A ?B ?F) = restrict ?F ?A\n  \\<lbrakk>C.ide ?b; C.ide ?a\\<rbrakk>\n  \\<Longrightarrow> \\<phi> (?b, ?a)\n                    \\<in> C.hom ?b ?a \\<rightarrow> Hom.set (?b, ?a)\n  \\<guillemotleft>?f : ?b \\<rightarrow> ?a\\<guillemotright> \\<Longrightarrow>\n  \\<psi> (?b, ?a) (\\<phi> (?b, ?a) ?f) = ?f\n  C.ide a\n  Cop.ide ?a \\<Longrightarrow> S.ide (F ?a)\n  S.ide ?a \\<Longrightarrow> S.Fun ?a = (\\<lambda>x\\<in>S.set ?a. x)\n  restrict ?f ?A ?x = (if ?x \\<in> ?A then ?f ?x else undefined)\n  C.ide ?a = \\<guillemotleft>?a : ?a \\<rightarrow> ?a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. S.Fun (\\<T> e a) (\\<phi> (a, a) a) = e", "by (auto simp add: Pi_iff)"], ["proof (state)\nthis:\n  \\<E> (\\<T> e) = e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<E>\\<tau>_in_Fa:\n    assumes \"natural_transformation Cop.comp S (Y a) F \\<tau>\"\n    shows \"\\<E> \\<tau> \\<in> F.SET a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<E> \\<tau> \\<in> F.SET a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<E> \\<tau> \\<in> F.SET a", "interpret \\<tau>: natural_transformation Cop.comp S \\<open>Y a\\<close> F \\<tau>"], ["proof (prove)\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n     F \\<tau>", "using assms"], ["proof (prove)\nusing this:\n  natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a) F\n   \\<tau>\n\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n     F \\<tau>", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<E> \\<tau> \\<in> F.SET a", "interpret yoneda_lemma_fixed_\\<tau> C S \\<phi> F a \\<tau>"], ["proof (prove)\ngoal (1 subgoal):\n 1. yoneda_lemma_fixed_\\<tau> (\\<cdot>) (\\<cdot>\\<^sub>S) \\<phi> F a \\<tau>", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<E> \\<tau> \\<in> F.SET a", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<E> \\<tau> \\<in> F.SET a", "proof (unfold \\<E>_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<tau>.FUN a (\\<phi> (a, a) a) \\<in> F.SET a", "have \"S.arr (\\<tau> a) \\<and> S.Dom (\\<tau> a) = Hom.set (a, a) \\<and> S.Cod (\\<tau> a) = F.SET a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.arr (\\<tau> a) \\<and>\n    \\<tau>.DOM a = Hom.set (a, a) \\<and> \\<tau>.COD a = F.SET a", "using ide_a Hom.set_map"], ["proof (prove)\nusing this:\n  C.ide a\n  \\<lbrakk>C.ide ?a; C.ide ?b\\<rbrakk>\n  \\<Longrightarrow> S.set (Hom.map (?b, ?a)) = Hom.set (?b, ?a)\n\ngoal (1 subgoal):\n 1. S.arr (\\<tau> a) \\<and>\n    \\<tau>.DOM a = Hom.set (a, a) \\<and> \\<tau>.COD a = F.SET a", "by auto"], ["proof (state)\nthis:\n  S.arr (\\<tau> a) \\<and>\n  \\<tau>.DOM a = Hom.set (a, a) \\<and> \\<tau>.COD a = F.SET a\n\ngoal (1 subgoal):\n 1. \\<tau>.FUN a (\\<phi> (a, a) a) \\<in> F.SET a", "hence \"\\<tau>.FUN a \\<in> Hom.set (a, a) \\<rightarrow> F.SET a\""], ["proof (prove)\nusing this:\n  S.arr (\\<tau> a) \\<and>\n  \\<tau>.DOM a = Hom.set (a, a) \\<and> \\<tau>.COD a = F.SET a\n\ngoal (1 subgoal):\n 1. \\<tau>.FUN a \\<in> Hom.set (a, a) \\<rightarrow> F.SET a", "using S.Fun_mapsto"], ["proof (prove)\nusing this:\n  S.arr (\\<tau> a) \\<and>\n  \\<tau>.DOM a = Hom.set (a, a) \\<and> \\<tau>.COD a = F.SET a\n  S.arr ?f \\<Longrightarrow>\n  S.Fun ?f\n  \\<in> extensional (S.Dom ?f) \\<inter> (S.Dom ?f \\<rightarrow> S.Cod ?f)\n\ngoal (1 subgoal):\n 1. \\<tau>.FUN a \\<in> Hom.set (a, a) \\<rightarrow> F.SET a", "by blast"], ["proof (state)\nthis:\n  \\<tau>.FUN a \\<in> Hom.set (a, a) \\<rightarrow> F.SET a\n\ngoal (1 subgoal):\n 1. \\<tau>.FUN a (\\<phi> (a, a) a) \\<in> F.SET a", "thus \"\\<tau>.FUN a (\\<phi> (a, a) a) \\<in> F.SET a\""], ["proof (prove)\nusing this:\n  \\<tau>.FUN a \\<in> Hom.set (a, a) \\<rightarrow> F.SET a\n\ngoal (1 subgoal):\n 1. \\<tau>.FUN a (\\<phi> (a, a) a) \\<in> F.SET a", "using ide_a Hom.\\<phi>_mapsto"], ["proof (prove)\nusing this:\n  \\<tau>.FUN a \\<in> Hom.set (a, a) \\<rightarrow> F.SET a\n  C.ide a\n  \\<lbrakk>C.ide ?b; C.ide ?a\\<rbrakk>\n  \\<Longrightarrow> \\<phi> (?b, ?a)\n                    \\<in> C.hom ?b ?a \\<rightarrow> Hom.set (?b, ?a)\n\ngoal (1 subgoal):\n 1. \\<tau>.FUN a (\\<phi> (a, a) a) \\<in> F.SET a", "by fastforce"], ["proof (state)\nthis:\n  \\<tau>.FUN a (\\<phi> (a, a) a) \\<in> F.SET a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<E> \\<tau> \\<in> F.SET a\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n      The other half of the Yoneda lemma:\n      The mapping @{term \\<T>} is a surjection, with right inverse @{term \\<E>},\n      taking natural transformations from @{term \"Y a\"} to @{term F}\n      to elements of @{term \"F.SET a\"}.\n\\<close>"], ["", "lemma \\<T>_is_surjection:\n    assumes \"natural_transformation Cop.comp S (Y a) F \\<tau>\"\n    shows \"\\<E> \\<tau> \\<in> F.SET a\" and \"\\<T> (\\<E> \\<tau>) = \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<E> \\<tau> \\<in> F.SET a &&& \\<T> (\\<E> \\<tau>) = \\<tau>", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<E> \\<tau> \\<in> F.SET a\n 2. \\<T> (\\<E> \\<tau>) = \\<tau>", "interpret natural_transformation Cop.comp S \\<open>Y a\\<close> F \\<tau>"], ["proof (prove)\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n     F \\<tau>", "using assms"], ["proof (prove)\nusing this:\n  natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a) F\n   \\<tau>\n\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n     F \\<tau>", "by auto"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<E> \\<tau> \\<in> F.SET a\n 2. \\<T> (\\<E> \\<tau>) = \\<tau>", "interpret yoneda_lemma_fixed_\\<tau> C S \\<phi> F a \\<tau>"], ["proof (prove)\ngoal (1 subgoal):\n 1. yoneda_lemma_fixed_\\<tau> (\\<cdot>) (\\<cdot>\\<^sub>S) \\<phi> F a \\<tau>", ".."], ["proof (state)\ngoal (2 subgoals):\n 1. \\<E> \\<tau> \\<in> F.SET a\n 2. \\<T> (\\<E> \\<tau>) = \\<tau>", "show 1: \"\\<E> \\<tau> \\<in> F.SET a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<E> \\<tau> \\<in> F.SET a", "using assms \\<E>\\<tau>_in_Fa"], ["proof (prove)\nusing this:\n  natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a) F\n   \\<tau>\n  natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a) F\n   ?\\<tau> \\<Longrightarrow>\n  \\<E> ?\\<tau> \\<in> F.SET a\n\ngoal (1 subgoal):\n 1. \\<E> \\<tau> \\<in> F.SET a", "by auto"], ["proof (state)\nthis:\n  \\<E> \\<tau> \\<in> F.SET a\n\ngoal (1 subgoal):\n 1. \\<T> (\\<E> \\<tau>) = \\<tau>", "interpret yoneda_lemma_fixed_e C S \\<phi> F a \\<open>\\<E> \\<tau>\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. yoneda_lemma_fixed_e (\\<cdot>) (\\<cdot>\\<^sub>S) \\<phi> F a\n     (\\<E> \\<tau>)", "using 1"], ["proof (prove)\nusing this:\n  \\<E> \\<tau> \\<in> F.SET a\n\ngoal (1 subgoal):\n 1. yoneda_lemma_fixed_e (\\<cdot>) (\\<cdot>\\<^sub>S) \\<phi> F a\n     (\\<E> \\<tau>)", "by (unfold_locales, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<T> (\\<E> \\<tau>) = \\<tau>", "interpret \\<T>e: natural_transformation Cop.comp S \\<open>Y a\\<close> F \\<open>\\<T> (\\<E> \\<tau>)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n     F (\\<T> (\\<E> \\<tau>))", "using natural_transformation_\\<T>e"], ["proof (prove)\nusing this:\n  natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a) F\n   (\\<T> (\\<E> \\<tau>))\n\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n     F (\\<T> (\\<E> \\<tau>))", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<T> (\\<E> \\<tau>) = \\<tau>", "show \"\\<T> (\\<E> \\<tau>) = \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<T> (\\<E> \\<tau>) = \\<tau>", "proof (intro eqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n     F (\\<T> (\\<E> \\<tau>))\n 2. \\<T> (\\<E> \\<tau>) a = \\<tau> a", "show \"natural_transformation Cop.comp S (Y a) F (\\<T> (\\<E> \\<tau>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n     F (\\<T> (\\<E> \\<tau>))", ".."], ["proof (state)\nthis:\n  natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a) F\n   (\\<T> (\\<E> \\<tau>))\n\ngoal (1 subgoal):\n 1. \\<T> (\\<E> \\<tau>) a = \\<tau> a", "show \"\\<T> (\\<E> \\<tau>) a = \\<tau> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<T> (\\<E> \\<tau>) a = \\<tau> a", "using ide_a \\<tau>_ide [of a] \\<T>e_ide \\<E>_def"], ["proof (prove)\nusing this:\n  C.ide a\n  Cop.ide a \\<Longrightarrow>\n  \\<tau> a =\n  S.mkArr (Hom.set (a, a)) (F.SET a)\n   (\\<lambda>x. F.FUN (\\<psi> (a, a) x) (\\<tau>.FUN a (\\<phi> (a, a) a)))\n  Cop.ide ?b \\<Longrightarrow> S.arr (\\<T> (\\<E> \\<tau>) ?b)\n  Cop.ide ?b \\<Longrightarrow>\n  \\<T> (\\<E> \\<tau>) ?b =\n  S.mkArr (Hom.set (?b, a)) (F.SET ?b)\n   (\\<lambda>x. F.FUN (\\<psi> (?b, a) x) (\\<E> \\<tau>))\n  \\<E> ?\\<tau> = S.Fun (?\\<tau> a) (\\<phi> (a, a) a)\n\ngoal (1 subgoal):\n 1. \\<T> (\\<E> \\<tau>) a = \\<tau> a", "by simp"], ["proof (state)\nthis:\n  \\<T> (\\<E> \\<tau>) a = \\<tau> a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<T> (\\<E> \\<tau>) = \\<tau>\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n      The main result.\n\\<close>"], ["", "theorem yoneda_lemma:\n    shows \"bij_betw \\<T> (F.SET a) {\\<tau>. natural_transformation Cop.comp S (Y a) F \\<tau>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw \\<T> (F.SET a)\n     {\\<tau>.\n      natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S)\n       (Y a) F \\<tau>}", "using \\<T>_is_injection \\<T>_is_surjection"], ["proof (prove)\nusing this:\n  ?e \\<in> F.SET a \\<Longrightarrow>\n  natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a) F\n   (\\<T> ?e)\n  ?e \\<in> F.SET a \\<Longrightarrow> \\<E> (\\<T> ?e) = ?e\n  natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a) F\n   ?\\<tau> \\<Longrightarrow>\n  \\<E> ?\\<tau> \\<in> F.SET a\n  natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a) F\n   ?\\<tau> \\<Longrightarrow>\n  \\<T> (\\<E> ?\\<tau>) = ?\\<tau>\n\ngoal (1 subgoal):\n 1. bij_betw \\<T> (F.SET a)\n     {\\<tau>.\n      natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S)\n       (Y a) F \\<tau>}", "by (intro bij_betwI, auto)"], ["", "end"], ["", "text\\<open>\n    We now consider the special case in which @{term F} is the contravariant\n    functor @{term \"Y a'\"}.  Then for any @{term e} in \\<open>Hom.set (a, a')\\<close>\n    we have @{term \"\\<T> e = Y (\\<psi> (a, a') e)\"}, and @{term \\<T>} is a bijection from\n    \\<open>Hom.set (a, a')\\<close> to the set of natural transformations from @{term \"Y a\"}\n    to @{term \"Y a'\"}.  It then follows that that the Yoneda functor @{term Y}\n    is a fully faithful functor from @{term C} to the functor category \\<open>[Cop, S]\\<close>.\n\\<close>"], ["", "locale yoneda_lemma_for_hom =\n    C: category C +\n    Cop: dual_category C +\n    S: replete_set_category S +\n    yoneda_functor_fixed_object C S \\<phi> a +\n    Ya': yoneda_functor_fixed_object C S \\<phi> a' +\n    yoneda_lemma C S \\<phi> \"Y a'\" a\n  for C :: \"'c comp\" (infixr \"\\<cdot>\" 55)\n  and S :: \"'s comp\" (infixr \"\\<cdot>\\<^sub>S\" 55)\n  and \\<phi> :: \"'c * 'c \\<Rightarrow> 'c \\<Rightarrow> 's\"\n  and F :: \"'c \\<Rightarrow> 's\"\n  and a :: 'c\n  and a' :: 'c +\n  assumes ide_a': \"C.ide a'\"\n  begin"], ["", "text\\<open>\n      In case @{term F} is the functor @{term \"Y a'\"}, for any @{term \"e \\<in> Hom.set (a, a')\"}\n      the induced natural transformation @{term \"\\<T> e\"} from @{term \"Y a\"} to @{term \"Y a'\"}\n      is just @{term \"Y (\\<psi> (a, a') e)\"}.\n\\<close>"], ["", "lemma \\<T>_equals_Yo\\<psi>:\n    assumes e: \"e \\<in> Hom.set (a, a')\"\n    shows \"\\<T> e = Y (\\<psi> (a, a') e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<T> e = Y (\\<psi> (a, a') e)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<T> e = Y (\\<psi> (a, a') e)", "let ?\\<psi>e = \"\\<psi> (a, a') e\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<T> e = Y (\\<psi> (a, a') e)", "have \\<psi>e: \"\\<guillemotleft>?\\<psi>e : a \\<rightarrow> a'\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<psi> (a, a') e : a \\<rightarrow> a'\\<guillemotright>", "using ide_a ide_a' e Hom.\\<psi>_mapsto [of a a']"], ["proof (prove)\nusing this:\n  C.ide a\n  C.ide a'\n  e \\<in> Hom.set (a, a')\n  \\<lbrakk>C.ide a; C.ide a'\\<rbrakk>\n  \\<Longrightarrow> \\<psi> (a, a')\n                    \\<in> Hom.set (a, a') \\<rightarrow> C.hom a a'\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<psi> (a, a') e : a \\<rightarrow> a'\\<guillemotright>", "by auto"], ["proof (state)\nthis:\n  \\<guillemotleft>\\<psi> (a, a') e : a \\<rightarrow> a'\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<T> e = Y (\\<psi> (a, a') e)", "interpret Ye: natural_transformation Cop.comp S \\<open>Y a\\<close> \\<open>Y a'\\<close> \\<open>Y ?\\<psi>e\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n     (Y a') (Y (\\<psi> (a, a') e))", "using Y_arr_is_transformation [of ?\\<psi>e] \\<psi>e"], ["proof (prove)\nusing this:\n  C.arr (\\<psi> (a, a') e) \\<Longrightarrow>\n  natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S)\n   (Y (C.dom (\\<psi> (a, a') e))) (Y (C.cod (\\<psi> (a, a') e)))\n   (Y (\\<psi> (a, a') e))\n  \\<guillemotleft>\\<psi> (a, a') e : a \\<rightarrow> a'\\<guillemotright>\n\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n     (Y a') (Y (\\<psi> (a, a') e))", "by (elim C.in_homE, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<T> e = Y (\\<psi> (a, a') e)", "interpret yoneda_lemma_fixed_e C S \\<phi> \\<open>Y a'\\<close> a e"], ["proof (prove)\ngoal (1 subgoal):\n 1. yoneda_lemma_fixed_e (\\<cdot>) (\\<cdot>\\<^sub>S) \\<phi> (Y a') a e", "using ide_a ide_a' e S.set_mkIde Hom.set_map"], ["proof (prove)\nusing this:\n  C.ide a\n  C.ide a'\n  e \\<in> Hom.set (a, a')\n  ?A \\<subseteq> S.Univ \\<Longrightarrow> S.set (S.mkIde ?A) = ?A\n  \\<lbrakk>C.ide ?a; C.ide ?b\\<rbrakk>\n  \\<Longrightarrow> S.set (Hom.map (?b, ?a)) = Hom.set (?b, ?a)\n\ngoal (1 subgoal):\n 1. yoneda_lemma_fixed_e (\\<cdot>) (\\<cdot>\\<^sub>S) \\<phi> (Y a') a e", "by (unfold_locales, simp_all)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<T> e = Y (\\<psi> (a, a') e)", "interpret \\<T>e: natural_transformation Cop.comp S \\<open>Y a\\<close> \\<open>Y a'\\<close> \\<open>\\<T> e\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n     (Y a') (\\<T> e)", "using natural_transformation_\\<T>e"], ["proof (prove)\nusing this:\n  natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n   (Y a') (\\<T> e)\n\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n     (Y a') (\\<T> e)", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<T> e = Y (\\<psi> (a, a') e)", "interpret yoneda_lemma_fixed_\\<tau> C S \\<phi> \\<open>Y a'\\<close> a \\<open>\\<T> e\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. yoneda_lemma_fixed_\\<tau> (\\<cdot>) (\\<cdot>\\<^sub>S) \\<phi> (Y a') a\n     (\\<T> e)", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<T> e = Y (\\<psi> (a, a') e)", "have \"natural_transformation Cop.comp S (Y a) (Y a') (Y ?\\<psi>e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n     (Y a') (Y (\\<psi> (a, a') e))", ".."], ["proof (state)\nthis:\n  natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n   (Y a') (Y (\\<psi> (a, a') e))\n\ngoal (1 subgoal):\n 1. \\<T> e = Y (\\<psi> (a, a') e)", "moreover"], ["proof (state)\nthis:\n  natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n   (Y a') (Y (\\<psi> (a, a') e))\n\ngoal (1 subgoal):\n 1. \\<T> e = Y (\\<psi> (a, a') e)", "have \"natural_transformation Cop.comp S (Y a) (Y a') (\\<T> e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n     (Y a') (\\<T> e)", ".."], ["proof (state)\nthis:\n  natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n   (Y a') (\\<T> e)\n\ngoal (1 subgoal):\n 1. \\<T> e = Y (\\<psi> (a, a') e)", "moreover"], ["proof (state)\nthis:\n  natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n   (Y a') (\\<T> e)\n\ngoal (1 subgoal):\n 1. \\<T> e = Y (\\<psi> (a, a') e)", "have \"\\<T> e a = Y ?\\<psi>e a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<T> e a = Y (\\<psi> (a, a') e) a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<T> e a = Y (\\<psi> (a, a') e) a", "have 1: \"S.arr (\\<T> e a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.arr (\\<T> e a)", "using ide_a e \\<T>e.preserves_reflects_arr"], ["proof (prove)\nusing this:\n  C.ide a\n  e \\<in> Hom.set (a, a')\n  S.arr (\\<T> e ?f) = Cop.arr ?f\n\ngoal (1 subgoal):\n 1. S.arr (\\<T> e a)", "by simp"], ["proof (state)\nthis:\n  S.arr (\\<T> e a)\n\ngoal (1 subgoal):\n 1. \\<T> e a = Y (\\<psi> (a, a') e) a", "have 2: \"\\<T> e a = S.mkArr (Hom.set (a, a)) (Ya'.SET a) (\\<lambda>x. Ya'.FUN (\\<psi> (a, a) x) e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<T> e a =\n    S.mkArr (Hom.set (a, a)) (Ya'.SET a)\n     (\\<lambda>x. Ya'.FUN (\\<psi> (a, a) x) e)", "using ide_a \\<T>o_def \\<T>e_ide"], ["proof (prove)\nusing this:\n  C.ide a\n  \\<T>o ?e ?b =\n  S.mkArr (Hom.set (?b, a)) (Ya'.SET ?b)\n   (\\<lambda>x. Ya'.FUN (\\<psi> (?b, a) x) ?e)\n  Cop.ide ?b \\<Longrightarrow> S.arr (\\<T> e ?b)\n  Cop.ide ?b \\<Longrightarrow>\n  \\<T> e ?b =\n  S.mkArr (Hom.set (?b, a)) (Ya'.SET ?b)\n   (\\<lambda>x. Ya'.FUN (\\<psi> (?b, a) x) e)\n\ngoal (1 subgoal):\n 1. \\<T> e a =\n    S.mkArr (Hom.set (a, a)) (Ya'.SET a)\n     (\\<lambda>x. Ya'.FUN (\\<psi> (a, a) x) e)", "by simp"], ["proof (state)\nthis:\n  \\<T> e a =\n  S.mkArr (Hom.set (a, a)) (Ya'.SET a)\n   (\\<lambda>x. Ya'.FUN (\\<psi> (a, a) x) e)\n\ngoal (1 subgoal):\n 1. \\<T> e a = Y (\\<psi> (a, a') e) a", "also"], ["proof (state)\nthis:\n  \\<T> e a =\n  S.mkArr (Hom.set (a, a)) (Ya'.SET a)\n   (\\<lambda>x. Ya'.FUN (\\<psi> (a, a) x) e)\n\ngoal (1 subgoal):\n 1. \\<T> e a = Y (\\<psi> (a, a') e) a", "have\n            \"... = S.mkArr (Hom.set (a, a)) (Hom.set (a, a')) (\\<phi> (a, a') o C ?\\<psi>e o \\<psi> (a, a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.mkArr (Hom.set (a, a)) (Ya'.SET a)\n     (\\<lambda>x. Ya'.FUN (\\<psi> (a, a) x) e) =\n    S.mkArr (Hom.set (a, a)) (Hom.set (a, a'))\n     (\\<phi> (a, a') \\<circ> (\\<cdot>) (\\<psi> (a, a') e) \\<circ>\n      \\<psi> (a, a))", "proof (intro S.mkArr_eqI)"], ["proof (state)\ngoal (4 subgoals):\n 1. S.arr\n     (S.mkArr (Hom.set (a, a)) (Ya'.SET a)\n       (\\<lambda>x. Ya'.FUN (\\<psi> (a, a) x) e))\n 2. Hom.set (a, a) = Hom.set (a, a)\n 3. Ya'.SET a = Hom.set (a, a')\n 4. \\<And>x.\n       x \\<in> Hom.set (a, a) \\<Longrightarrow>\n       Ya'.FUN (\\<psi> (a, a) x) e =\n       (\\<phi> (a, a') \\<circ> (\\<cdot>) (\\<psi> (a, a') e) \\<circ>\n        \\<psi> (a, a))\n        x", "show \"S.arr (S.mkArr (Hom.set (a, a)) (Ya'.SET a) (\\<lambda>x. Ya'.FUN (\\<psi> (a, a) x) e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.arr\n     (S.mkArr (Hom.set (a, a)) (Ya'.SET a)\n       (\\<lambda>x. Ya'.FUN (\\<psi> (a, a) x) e))", "using ide_a e 1 2"], ["proof (prove)\nusing this:\n  C.ide a\n  e \\<in> Hom.set (a, a')\n  S.arr (\\<T> e a)\n  \\<T> e a =\n  S.mkArr (Hom.set (a, a)) (Ya'.SET a)\n   (\\<lambda>x. Ya'.FUN (\\<psi> (a, a) x) e)\n\ngoal (1 subgoal):\n 1. S.arr\n     (S.mkArr (Hom.set (a, a)) (Ya'.SET a)\n       (\\<lambda>x. Ya'.FUN (\\<psi> (a, a) x) e))", "by simp"], ["proof (state)\nthis:\n  S.arr\n   (S.mkArr (Hom.set (a, a)) (Ya'.SET a)\n     (\\<lambda>x. Ya'.FUN (\\<psi> (a, a) x) e))\n\ngoal (3 subgoals):\n 1. Hom.set (a, a) = Hom.set (a, a)\n 2. Ya'.SET a = Hom.set (a, a')\n 3. \\<And>x.\n       x \\<in> Hom.set (a, a) \\<Longrightarrow>\n       Ya'.FUN (\\<psi> (a, a) x) e =\n       (\\<phi> (a, a') \\<circ> (\\<cdot>) (\\<psi> (a, a') e) \\<circ>\n        \\<psi> (a, a))\n        x", "show \"Hom.set (a, a) = Hom.set (a, a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Hom.set (a, a) = Hom.set (a, a)", ".."], ["proof (state)\nthis:\n  Hom.set (a, a) = Hom.set (a, a)\n\ngoal (2 subgoals):\n 1. Ya'.SET a = Hom.set (a, a')\n 2. \\<And>x.\n       x \\<in> Hom.set (a, a) \\<Longrightarrow>\n       Ya'.FUN (\\<psi> (a, a) x) e =\n       (\\<phi> (a, a') \\<circ> (\\<cdot>) (\\<psi> (a, a') e) \\<circ>\n        \\<psi> (a, a))\n        x", "show 3: \"Ya'.SET a = Hom.set (a, a')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Ya'.SET a = Hom.set (a, a')", "using ide_a ide_a' Y_simp Hom.set_map"], ["proof (prove)\nusing this:\n  C.ide a\n  C.ide a'\n  C.arr ?f \\<Longrightarrow> Y ?f = (\\<lambda>g. Hom.map (g, ?f))\n  \\<lbrakk>C.ide ?a; C.ide ?b\\<rbrakk>\n  \\<Longrightarrow> S.set (Hom.map (?b, ?a)) = Hom.set (?b, ?a)\n\ngoal (1 subgoal):\n 1. Ya'.SET a = Hom.set (a, a')", "by simp"], ["proof (state)\nthis:\n  Ya'.SET a = Hom.set (a, a')\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Hom.set (a, a) \\<Longrightarrow>\n       Ya'.FUN (\\<psi> (a, a) x) e =\n       (\\<phi> (a, a') \\<circ> (\\<cdot>) (\\<psi> (a, a') e) \\<circ>\n        \\<psi> (a, a))\n        x", "show \"\\<And>x. x \\<in> Hom.set (a, a) \\<Longrightarrow>\n                      Ya'.FUN (\\<psi> (a, a) x) e = (\\<phi> (a, a') o C ?\\<psi>e o \\<psi> (a, a)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Hom.set (a, a) \\<Longrightarrow>\n       Ya'.FUN (\\<psi> (a, a) x) e =\n       (\\<phi> (a, a') \\<circ> (\\<cdot>) (\\<psi> (a, a') e) \\<circ>\n        \\<psi> (a, a))\n        x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Hom.set (a, a) \\<Longrightarrow>\n       Ya'.FUN (\\<psi> (a, a) x) e =\n       (\\<phi> (a, a') \\<circ> (\\<cdot>) (\\<psi> (a, a') e) \\<circ>\n        \\<psi> (a, a))\n        x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Hom.set (a, a) \\<Longrightarrow>\n       Ya'.FUN (\\<psi> (a, a) x) e =\n       (\\<phi> (a, a') \\<circ> (\\<cdot>) (\\<psi> (a, a') e) \\<circ>\n        \\<psi> (a, a))\n        x", "assume x: \"x \\<in> Hom.set (a, a)\""], ["proof (state)\nthis:\n  x \\<in> Hom.set (a, a)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Hom.set (a, a) \\<Longrightarrow>\n       Ya'.FUN (\\<psi> (a, a) x) e =\n       (\\<phi> (a, a') \\<circ> (\\<cdot>) (\\<psi> (a, a') e) \\<circ>\n        \\<psi> (a, a))\n        x", "have \\<psi>x: \"\\<guillemotleft>\\<psi> (a, a) x : a \\<rightarrow> a\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<psi> (a, a) x : a \\<rightarrow> a\\<guillemotright>", "using ide_a x Hom.\\<psi>_mapsto [of a a]"], ["proof (prove)\nusing this:\n  C.ide a\n  x \\<in> Hom.set (a, a)\n  \\<lbrakk>C.ide a; C.ide a\\<rbrakk>\n  \\<Longrightarrow> \\<psi> (a, a)\n                    \\<in> Hom.set (a, a) \\<rightarrow> C.hom a a\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<psi> (a, a) x : a \\<rightarrow> a\\<guillemotright>", "by auto"], ["proof (state)\nthis:\n  \\<guillemotleft>\\<psi> (a, a) x : a \\<rightarrow> a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Hom.set (a, a) \\<Longrightarrow>\n       Ya'.FUN (\\<psi> (a, a) x) e =\n       (\\<phi> (a, a') \\<circ> (\\<cdot>) (\\<psi> (a, a') e) \\<circ>\n        \\<psi> (a, a))\n        x", "have \"S.arr (Y a' (\\<psi> (a, a) x)) \\<and>\n                  Y a' (\\<psi> (a, a) x) = S.mkArr (Hom.set (a, a')) (Hom.set (a, a'))\n                                              (\\<phi> (a, a') \\<circ> Cop.comp (\\<psi> (a, a) x) \\<circ> \\<psi> (a, a'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.arr (Y a' (\\<psi> (a, a) x)) \\<and>\n    Y a' (\\<psi> (a, a) x) =\n    S.mkArr (Hom.set (a, a')) (Hom.set (a, a'))\n     (\\<phi> (a, a') \\<circ>\n      (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (a, a) x) \\<circ>\n      \\<psi> (a, a'))", "using Y_ide_arr ide_a ide_a' \\<psi>x"], ["proof (prove)\nusing this:\n  \\<lbrakk>C.ide ?a;\n   \\<guillemotleft>?g : ?b' \\<rightarrow> ?b\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>Y ?a\n                                     ?g : Hom.map\n     (?b, ?a) \\<rightarrow>\\<^sub>S Hom.map (?b', ?a)\\<guillemotright>\n  \\<lbrakk>C.ide ?a;\n   \\<guillemotleft>?g : ?b' \\<rightarrow> ?b\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> Y ?a ?g =\n                    S.mkArr (Hom.set (?b, ?a)) (Hom.set (?b', ?a))\n                     (\\<phi> (?b', ?a) \\<circ>\n                      (\\<cdot>\\<^sup>o\\<^sup>p) ?g \\<circ>\n                      \\<psi> (?b, ?a))\n  C.ide a\n  C.ide a'\n  \\<guillemotleft>\\<psi> (a, a) x : a \\<rightarrow> a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. S.arr (Y a' (\\<psi> (a, a) x)) \\<and>\n    Y a' (\\<psi> (a, a) x) =\n    S.mkArr (Hom.set (a, a')) (Hom.set (a, a'))\n     (\\<phi> (a, a') \\<circ>\n      (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (a, a) x) \\<circ>\n      \\<psi> (a, a'))", "by blast"], ["proof (state)\nthis:\n  S.arr (Y a' (\\<psi> (a, a) x)) \\<and>\n  Y a' (\\<psi> (a, a) x) =\n  S.mkArr (Hom.set (a, a')) (Hom.set (a, a'))\n   (\\<phi> (a, a') \\<circ>\n    (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (a, a) x) \\<circ>\n    \\<psi> (a, a'))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Hom.set (a, a) \\<Longrightarrow>\n       Ya'.FUN (\\<psi> (a, a) x) e =\n       (\\<phi> (a, a') \\<circ> (\\<cdot>) (\\<psi> (a, a') e) \\<circ>\n        \\<psi> (a, a))\n        x", "hence \"Ya'.FUN (\\<psi> (a, a) x) e = (\\<phi> (a, a') \\<circ> Cop.comp (\\<psi> (a, a) x) \\<circ> \\<psi> (a, a')) e\""], ["proof (prove)\nusing this:\n  S.arr (Y a' (\\<psi> (a, a) x)) \\<and>\n  Y a' (\\<psi> (a, a) x) =\n  S.mkArr (Hom.set (a, a')) (Hom.set (a, a'))\n   (\\<phi> (a, a') \\<circ>\n    (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (a, a) x) \\<circ>\n    \\<psi> (a, a'))\n\ngoal (1 subgoal):\n 1. Ya'.FUN (\\<psi> (a, a) x) e =\n    (\\<phi> (a, a') \\<circ>\n     (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (a, a) x) \\<circ>\n     \\<psi> (a, a'))\n     e", "using e 3 S.Fun_mkArr Ya'.preserves_reflects_arr [of \"\\<psi> (a, a) x\"]"], ["proof (prove)\nusing this:\n  S.arr (Y a' (\\<psi> (a, a) x)) \\<and>\n  Y a' (\\<psi> (a, a) x) =\n  S.mkArr (Hom.set (a, a')) (Hom.set (a, a'))\n   (\\<phi> (a, a') \\<circ>\n    (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (a, a) x) \\<circ>\n    \\<psi> (a, a'))\n  e \\<in> Hom.set (a, a')\n  Ya'.SET a = Hom.set (a, a')\n  S.arr (S.mkArr ?A ?B ?F) \\<Longrightarrow>\n  S.Fun (S.mkArr ?A ?B ?F) = restrict ?F ?A\n  S.arr (Y a' (\\<psi> (a, a) x)) = Cop.arr (\\<psi> (a, a) x)\n\ngoal (1 subgoal):\n 1. Ya'.FUN (\\<psi> (a, a) x) e =\n    (\\<phi> (a, a') \\<circ>\n     (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (a, a) x) \\<circ>\n     \\<psi> (a, a'))\n     e", "by simp"], ["proof (state)\nthis:\n  Ya'.FUN (\\<psi> (a, a) x) e =\n  (\\<phi> (a, a') \\<circ>\n   (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (a, a) x) \\<circ>\n   \\<psi> (a, a'))\n   e\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Hom.set (a, a) \\<Longrightarrow>\n       Ya'.FUN (\\<psi> (a, a) x) e =\n       (\\<phi> (a, a') \\<circ> (\\<cdot>) (\\<psi> (a, a') e) \\<circ>\n        \\<psi> (a, a))\n        x", "also"], ["proof (state)\nthis:\n  Ya'.FUN (\\<psi> (a, a) x) e =\n  (\\<phi> (a, a') \\<circ>\n   (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (a, a) x) \\<circ>\n   \\<psi> (a, a'))\n   e\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Hom.set (a, a) \\<Longrightarrow>\n       Ya'.FUN (\\<psi> (a, a) x) e =\n       (\\<phi> (a, a') \\<circ> (\\<cdot>) (\\<psi> (a, a') e) \\<circ>\n        \\<psi> (a, a))\n        x", "have \"... = (\\<phi> (a, a') o C ?\\<psi>e o \\<psi> (a, a)) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<phi> (a, a') \\<circ>\n     (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (a, a) x) \\<circ>\n     \\<psi> (a, a'))\n     e =\n    (\\<phi> (a, a') \\<circ> (\\<cdot>) (\\<psi> (a, a') e) \\<circ>\n     \\<psi> (a, a))\n     x", "by simp"], ["proof (state)\nthis:\n  (\\<phi> (a, a') \\<circ>\n   (\\<cdot>\\<^sup>o\\<^sup>p) (\\<psi> (a, a) x) \\<circ>\n   \\<psi> (a, a'))\n   e =\n  (\\<phi> (a, a') \\<circ> (\\<cdot>) (\\<psi> (a, a') e) \\<circ>\n   \\<psi> (a, a))\n   x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Hom.set (a, a) \\<Longrightarrow>\n       Ya'.FUN (\\<psi> (a, a) x) e =\n       (\\<phi> (a, a') \\<circ> (\\<cdot>) (\\<psi> (a, a') e) \\<circ>\n        \\<psi> (a, a))\n        x", "finally"], ["proof (chain)\npicking this:\n  Ya'.FUN (\\<psi> (a, a) x) e =\n  (\\<phi> (a, a') \\<circ> (\\<cdot>) (\\<psi> (a, a') e) \\<circ>\n   \\<psi> (a, a))\n   x", "show \"Ya'.FUN (\\<psi> (a, a) x) e = (\\<phi> (a, a') o C ?\\<psi>e o \\<psi> (a, a)) x\""], ["proof (prove)\nusing this:\n  Ya'.FUN (\\<psi> (a, a) x) e =\n  (\\<phi> (a, a') \\<circ> (\\<cdot>) (\\<psi> (a, a') e) \\<circ>\n   \\<psi> (a, a))\n   x\n\ngoal (1 subgoal):\n 1. Ya'.FUN (\\<psi> (a, a) x) e =\n    (\\<phi> (a, a') \\<circ> (\\<cdot>) (\\<psi> (a, a') e) \\<circ>\n     \\<psi> (a, a))\n     x", "by auto"], ["proof (state)\nthis:\n  Ya'.FUN (\\<psi> (a, a) x) e =\n  (\\<phi> (a, a') \\<circ> (\\<cdot>) (\\<psi> (a, a') e) \\<circ>\n   \\<psi> (a, a))\n   x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> Hom.set (a, a) \\<Longrightarrow>\n  Ya'.FUN (\\<psi> (a, a) ?x) e =\n  (\\<phi> (a, a') \\<circ> (\\<cdot>) (\\<psi> (a, a') e) \\<circ>\n   \\<psi> (a, a))\n   ?x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S.mkArr (Hom.set (a, a)) (Ya'.SET a)\n   (\\<lambda>x. Ya'.FUN (\\<psi> (a, a) x) e) =\n  S.mkArr (Hom.set (a, a)) (Hom.set (a, a'))\n   (\\<phi> (a, a') \\<circ> (\\<cdot>) (\\<psi> (a, a') e) \\<circ>\n    \\<psi> (a, a))\n\ngoal (1 subgoal):\n 1. \\<T> e a = Y (\\<psi> (a, a') e) a", "also"], ["proof (state)\nthis:\n  S.mkArr (Hom.set (a, a)) (Ya'.SET a)\n   (\\<lambda>x. Ya'.FUN (\\<psi> (a, a) x) e) =\n  S.mkArr (Hom.set (a, a)) (Hom.set (a, a'))\n   (\\<phi> (a, a') \\<circ> (\\<cdot>) (\\<psi> (a, a') e) \\<circ>\n    \\<psi> (a, a))\n\ngoal (1 subgoal):\n 1. \\<T> e a = Y (\\<psi> (a, a') e) a", "have \"... = Y ?\\<psi>e a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.mkArr (Hom.set (a, a)) (Hom.set (a, a'))\n     (\\<phi> (a, a') \\<circ> (\\<cdot>) (\\<psi> (a, a') e) \\<circ>\n      \\<psi> (a, a)) =\n    Y (\\<psi> (a, a') e) a", "using ide_a ide_a' Y_arr_ide \\<psi>e"], ["proof (prove)\nusing this:\n  C.ide a\n  C.ide a'\n  \\<lbrakk>C.ide ?b;\n   \\<guillemotleft>?f : ?a \\<rightarrow> ?a'\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>Y ?f\n                                     ?b : Hom.map\n     (?b, ?a) \\<rightarrow>\\<^sub>S Hom.map (?b, ?a')\\<guillemotright>\n  \\<lbrakk>C.ide ?b;\n   \\<guillemotleft>?f : ?a \\<rightarrow> ?a'\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> Y ?f ?b =\n                    S.mkArr (Hom.set (?b, ?a)) (Hom.set (?b, ?a'))\n                     (\\<phi> (?b, ?a') \\<circ> (\\<cdot>) ?f \\<circ>\n                      \\<psi> (?b, ?a))\n  \\<guillemotleft>\\<psi> (a, a') e : a \\<rightarrow> a'\\<guillemotright>\n\ngoal (1 subgoal):\n 1. S.mkArr (Hom.set (a, a)) (Hom.set (a, a'))\n     (\\<phi> (a, a') \\<circ> (\\<cdot>) (\\<psi> (a, a') e) \\<circ>\n      \\<psi> (a, a)) =\n    Y (\\<psi> (a, a') e) a", "by simp"], ["proof (state)\nthis:\n  S.mkArr (Hom.set (a, a)) (Hom.set (a, a'))\n   (\\<phi> (a, a') \\<circ> (\\<cdot>) (\\<psi> (a, a') e) \\<circ>\n    \\<psi> (a, a)) =\n  Y (\\<psi> (a, a') e) a\n\ngoal (1 subgoal):\n 1. \\<T> e a = Y (\\<psi> (a, a') e) a", "finally"], ["proof (chain)\npicking this:\n  \\<T> e a = Y (\\<psi> (a, a') e) a", "show \"\\<T> e a = Y ?\\<psi>e a\""], ["proof (prove)\nusing this:\n  \\<T> e a = Y (\\<psi> (a, a') e) a\n\ngoal (1 subgoal):\n 1. \\<T> e a = Y (\\<psi> (a, a') e) a", "by auto"], ["proof (state)\nthis:\n  \\<T> e a = Y (\\<psi> (a, a') e) a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<T> e a = Y (\\<psi> (a, a') e) a\n\ngoal (1 subgoal):\n 1. \\<T> e = Y (\\<psi> (a, a') e)", "ultimately"], ["proof (chain)\npicking this:\n  natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n   (Y a') (Y (\\<psi> (a, a') e))\n  natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n   (Y a') (\\<T> e)\n  \\<T> e a = Y (\\<psi> (a, a') e) a", "show ?thesis"], ["proof (prove)\nusing this:\n  natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n   (Y a') (Y (\\<psi> (a, a') e))\n  natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n   (Y a') (\\<T> e)\n  \\<T> e a = Y (\\<psi> (a, a') e) a\n\ngoal (1 subgoal):\n 1. \\<T> e = Y (\\<psi> (a, a') e)", "using eqI"], ["proof (prove)\nusing this:\n  natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n   (Y a') (Y (\\<psi> (a, a') e))\n  natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n   (Y a') (\\<T> e)\n  \\<T> e a = Y (\\<psi> (a, a') e) a\n  \\<lbrakk>natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p)\n            (\\<cdot>\\<^sub>S) (Y a) (Y a') ?\\<tau>';\n   ?\\<tau>' a = \\<T> e a\\<rbrakk>\n  \\<Longrightarrow> ?\\<tau>' = \\<T> e\n\ngoal (1 subgoal):\n 1. \\<T> e = Y (\\<psi> (a, a') e)", "by auto"], ["proof (state)\nthis:\n  \\<T> e = Y (\\<psi> (a, a') e)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Y_injective_on_homs:\n    assumes \"\\<guillemotleft>f : a \\<rightarrow> a'\\<guillemotright>\" and \"\\<guillemotleft>f' : a \\<rightarrow> a'\\<guillemotright>\" and \"map f = map f'\"\n    shows \"f = f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = f'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f = f'", "have \"f = \\<psi> (a, a') (\\<phi> (a, a') f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = \\<psi> (a, a') (\\<phi> (a, a') f)", "using assms ide_a Hom.\\<psi>_\\<phi>"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f : a \\<rightarrow> a'\\<guillemotright>\n  \\<guillemotleft>f' : a \\<rightarrow> a'\\<guillemotright>\n  local.map f = local.map f'\n  C.ide a\n  \\<guillemotleft>?f : ?b \\<rightarrow> ?a\\<guillemotright> \\<Longrightarrow>\n  \\<psi> (?b, ?a) (\\<phi> (?b, ?a) ?f) = ?f\n\ngoal (1 subgoal):\n 1. f = \\<psi> (a, a') (\\<phi> (a, a') f)", "by simp"], ["proof (state)\nthis:\n  f = \\<psi> (a, a') (\\<phi> (a, a') f)\n\ngoal (1 subgoal):\n 1. f = f'", "also"], ["proof (state)\nthis:\n  f = \\<psi> (a, a') (\\<phi> (a, a') f)\n\ngoal (1 subgoal):\n 1. f = f'", "have \"... = \\<psi> (a, a') (\\<E> (\\<T> (\\<phi> (a, a') f)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> (a, a') (\\<phi> (a, a') f) =\n    \\<psi> (a, a') (\\<E> (\\<T> (\\<phi> (a, a') f)))", "using ide_a ide_a' assms(1) \\<T>_is_injection Hom.\\<phi>_mapsto Hom.set_map"], ["proof (prove)\nusing this:\n  C.ide a\n  C.ide a'\n  \\<guillemotleft>f : a \\<rightarrow> a'\\<guillemotright>\n  ?e \\<in> Ya'.SET a \\<Longrightarrow>\n  natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n   (Y a') (\\<T> ?e)\n  ?e \\<in> Ya'.SET a \\<Longrightarrow> \\<E> (\\<T> ?e) = ?e\n  \\<lbrakk>C.ide ?b; C.ide ?a\\<rbrakk>\n  \\<Longrightarrow> \\<phi> (?b, ?a)\n                    \\<in> C.hom ?b ?a \\<rightarrow> Hom.set (?b, ?a)\n  \\<lbrakk>C.ide ?a; C.ide ?b\\<rbrakk>\n  \\<Longrightarrow> S.set (Hom.map (?b, ?a)) = Hom.set (?b, ?a)\n\ngoal (1 subgoal):\n 1. \\<psi> (a, a') (\\<phi> (a, a') f) =\n    \\<psi> (a, a') (\\<E> (\\<T> (\\<phi> (a, a') f)))", "by (elim C.in_homE, simp add: Pi_iff)"], ["proof (state)\nthis:\n  \\<psi> (a, a') (\\<phi> (a, a') f) =\n  \\<psi> (a, a') (\\<E> (\\<T> (\\<phi> (a, a') f)))\n\ngoal (1 subgoal):\n 1. f = f'", "also"], ["proof (state)\nthis:\n  \\<psi> (a, a') (\\<phi> (a, a') f) =\n  \\<psi> (a, a') (\\<E> (\\<T> (\\<phi> (a, a') f)))\n\ngoal (1 subgoal):\n 1. f = f'", "have \"... = \\<psi> (a, a') (\\<E> (Y (\\<psi> (a, a') (\\<phi> (a, a') f))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> (a, a') (\\<E> (\\<T> (\\<phi> (a, a') f))) =\n    \\<psi> (a, a') (\\<E> (Y (\\<psi> (a, a') (\\<phi> (a, a') f))))", "using assms Hom.\\<phi>_mapsto [of a a'] \\<T>_equals_Yo\\<psi> [of \"\\<phi> (a, a') f\"]"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f : a \\<rightarrow> a'\\<guillemotright>\n  \\<guillemotleft>f' : a \\<rightarrow> a'\\<guillemotright>\n  local.map f = local.map f'\n  \\<lbrakk>C.ide a; C.ide a'\\<rbrakk>\n  \\<Longrightarrow> \\<phi> (a, a')\n                    \\<in> C.hom a a' \\<rightarrow> Hom.set (a, a')\n  \\<phi> (a, a') f \\<in> Hom.set (a, a') \\<Longrightarrow>\n  \\<T> (\\<phi> (a, a') f) = Y (\\<psi> (a, a') (\\<phi> (a, a') f))\n\ngoal (1 subgoal):\n 1. \\<psi> (a, a') (\\<E> (\\<T> (\\<phi> (a, a') f))) =\n    \\<psi> (a, a') (\\<E> (Y (\\<psi> (a, a') (\\<phi> (a, a') f))))", "by force"], ["proof (state)\nthis:\n  \\<psi> (a, a') (\\<E> (\\<T> (\\<phi> (a, a') f))) =\n  \\<psi> (a, a') (\\<E> (Y (\\<psi> (a, a') (\\<phi> (a, a') f))))\n\ngoal (1 subgoal):\n 1. f = f'", "also"], ["proof (state)\nthis:\n  \\<psi> (a, a') (\\<E> (\\<T> (\\<phi> (a, a') f))) =\n  \\<psi> (a, a') (\\<E> (Y (\\<psi> (a, a') (\\<phi> (a, a') f))))\n\ngoal (1 subgoal):\n 1. f = f'", "have \"... = \\<psi> (a, a') (\\<E> (\\<T> (\\<phi> (a, a') f')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> (a, a') (\\<E> (Y (\\<psi> (a, a') (\\<phi> (a, a') f)))) =\n    \\<psi> (a, a') (\\<E> (\\<T> (\\<phi> (a, a') f')))", "using assms Hom.\\<phi>_mapsto [of a a'] ide_a Hom.\\<psi>_\\<phi> Y_def\n              \\<T>_equals_Yo\\<psi> [of \"\\<phi> (a, a') f'\"]"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f : a \\<rightarrow> a'\\<guillemotright>\n  \\<guillemotleft>f' : a \\<rightarrow> a'\\<guillemotright>\n  local.map f = local.map f'\n  \\<lbrakk>C.ide a; C.ide a'\\<rbrakk>\n  \\<Longrightarrow> \\<phi> (a, a')\n                    \\<in> C.hom a a' \\<rightarrow> Hom.set (a, a')\n  C.ide a\n  \\<guillemotleft>?f : ?b \\<rightarrow> ?a\\<guillemotright> \\<Longrightarrow>\n  \\<psi> (?b, ?a) (\\<phi> (?b, ?a) ?f) = ?f\n  Y ?f \\<equiv> Cop_S.Map (local.map ?f)\n  \\<phi> (a, a') f' \\<in> Hom.set (a, a') \\<Longrightarrow>\n  \\<T> (\\<phi> (a, a') f') = Y (\\<psi> (a, a') (\\<phi> (a, a') f'))\n\ngoal (1 subgoal):\n 1. \\<psi> (a, a') (\\<E> (Y (\\<psi> (a, a') (\\<phi> (a, a') f)))) =\n    \\<psi> (a, a') (\\<E> (\\<T> (\\<phi> (a, a') f')))", "by fastforce"], ["proof (state)\nthis:\n  \\<psi> (a, a') (\\<E> (Y (\\<psi> (a, a') (\\<phi> (a, a') f)))) =\n  \\<psi> (a, a') (\\<E> (\\<T> (\\<phi> (a, a') f')))\n\ngoal (1 subgoal):\n 1. f = f'", "also"], ["proof (state)\nthis:\n  \\<psi> (a, a') (\\<E> (Y (\\<psi> (a, a') (\\<phi> (a, a') f)))) =\n  \\<psi> (a, a') (\\<E> (\\<T> (\\<phi> (a, a') f')))\n\ngoal (1 subgoal):\n 1. f = f'", "have \"... = \\<psi> (a, a') (\\<phi> (a, a') f')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> (a, a') (\\<E> (\\<T> (\\<phi> (a, a') f'))) =\n    \\<psi> (a, a') (\\<phi> (a, a') f')", "using ide_a ide_a' assms(2) \\<T>_is_injection Hom.\\<phi>_mapsto Hom.set_map"], ["proof (prove)\nusing this:\n  C.ide a\n  C.ide a'\n  \\<guillemotleft>f' : a \\<rightarrow> a'\\<guillemotright>\n  ?e \\<in> Ya'.SET a \\<Longrightarrow>\n  natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n   (Y a') (\\<T> ?e)\n  ?e \\<in> Ya'.SET a \\<Longrightarrow> \\<E> (\\<T> ?e) = ?e\n  \\<lbrakk>C.ide ?b; C.ide ?a\\<rbrakk>\n  \\<Longrightarrow> \\<phi> (?b, ?a)\n                    \\<in> C.hom ?b ?a \\<rightarrow> Hom.set (?b, ?a)\n  \\<lbrakk>C.ide ?a; C.ide ?b\\<rbrakk>\n  \\<Longrightarrow> S.set (Hom.map (?b, ?a)) = Hom.set (?b, ?a)\n\ngoal (1 subgoal):\n 1. \\<psi> (a, a') (\\<E> (\\<T> (\\<phi> (a, a') f'))) =\n    \\<psi> (a, a') (\\<phi> (a, a') f')", "by (elim C.in_homE, simp add: Pi_iff)"], ["proof (state)\nthis:\n  \\<psi> (a, a') (\\<E> (\\<T> (\\<phi> (a, a') f'))) =\n  \\<psi> (a, a') (\\<phi> (a, a') f')\n\ngoal (1 subgoal):\n 1. f = f'", "also"], ["proof (state)\nthis:\n  \\<psi> (a, a') (\\<E> (\\<T> (\\<phi> (a, a') f'))) =\n  \\<psi> (a, a') (\\<phi> (a, a') f')\n\ngoal (1 subgoal):\n 1. f = f'", "have \"... = f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> (a, a') (\\<phi> (a, a') f') = f'", "using assms ide_a Hom.\\<psi>_\\<phi>"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f : a \\<rightarrow> a'\\<guillemotright>\n  \\<guillemotleft>f' : a \\<rightarrow> a'\\<guillemotright>\n  local.map f = local.map f'\n  C.ide a\n  \\<guillemotleft>?f : ?b \\<rightarrow> ?a\\<guillemotright> \\<Longrightarrow>\n  \\<psi> (?b, ?a) (\\<phi> (?b, ?a) ?f) = ?f\n\ngoal (1 subgoal):\n 1. \\<psi> (a, a') (\\<phi> (a, a') f') = f'", "by simp"], ["proof (state)\nthis:\n  \\<psi> (a, a') (\\<phi> (a, a') f') = f'\n\ngoal (1 subgoal):\n 1. f = f'", "finally"], ["proof (chain)\npicking this:\n  f = f'", "show \"f = f'\""], ["proof (prove)\nusing this:\n  f = f'\n\ngoal (1 subgoal):\n 1. f = f'", "by auto"], ["proof (state)\nthis:\n  f = f'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Y_surjective_on_homs:\n    assumes \\<tau>: \"natural_transformation Cop.comp S (Y a) (Y a') \\<tau>\"\n    shows \"Y (\\<psi> (a, a') (\\<E> \\<tau>)) = \\<tau>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Y (\\<psi> (a, a') (\\<E> \\<tau>)) = \\<tau>", "using ide_a ide_a' \\<tau> \\<T>_is_surjection \\<T>_equals_Yo\\<psi> \\<E>\\<tau>_in_Fa Hom.set_map"], ["proof (prove)\nusing this:\n  C.ide a\n  C.ide a'\n  natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n   (Y a') \\<tau>\n  natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n   (Y a') ?\\<tau> \\<Longrightarrow>\n  \\<E> ?\\<tau> \\<in> Ya'.SET a\n  natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n   (Y a') ?\\<tau> \\<Longrightarrow>\n  \\<T> (\\<E> ?\\<tau>) = ?\\<tau>\n  ?e \\<in> Hom.set (a, a') \\<Longrightarrow> \\<T> ?e = Y (\\<psi> (a, a') ?e)\n  natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n   (Y a') ?\\<tau> \\<Longrightarrow>\n  \\<E> ?\\<tau> \\<in> Ya'.SET a\n  \\<lbrakk>C.ide ?a; C.ide ?b\\<rbrakk>\n  \\<Longrightarrow> S.set (Hom.map (?b, ?a)) = Hom.set (?b, ?a)\n\ngoal (1 subgoal):\n 1. Y (\\<psi> (a, a') (\\<E> \\<tau>)) = \\<tau>", "by simp"], ["", "end"], ["", "context yoneda_functor\n  begin"], ["", "lemma is_faithful_functor:\n    shows \"faithful_functor C Cop_S.comp map\""], ["proof (prove)\ngoal (1 subgoal):\n 1. faithful_functor (\\<cdot>) Cop_S.comp local.map", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f f'.\n       \\<lbrakk>C.par f f'; local.map f = local.map f'\\<rbrakk>\n       \\<Longrightarrow> f = f'", "fix f :: 'c and f' :: 'c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f f'.\n       \\<lbrakk>C.par f f'; local.map f = local.map f'\\<rbrakk>\n       \\<Longrightarrow> f = f'", "assume par: \"C.par f f'\" and ff': \"map f = map f'\""], ["proof (state)\nthis:\n  C.par f f'\n  local.map f = local.map f'\n\ngoal (1 subgoal):\n 1. \\<And>f f'.\n       \\<lbrakk>C.par f f'; local.map f = local.map f'\\<rbrakk>\n       \\<Longrightarrow> f = f'", "show \"f = f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = f'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f = f'", "interpret Ya': yoneda_functor_fixed_object C S \\<phi> \\<open>C.cod f\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. yoneda_functor_fixed_object (\\<cdot>) (\\<cdot>\\<^sub>S) \\<phi> (C.cod f)", "using par"], ["proof (prove)\nusing this:\n  C.par f f'\n\ngoal (1 subgoal):\n 1. yoneda_functor_fixed_object (\\<cdot>) (\\<cdot>\\<^sub>S) \\<phi> (C.cod f)", "by (unfold_locales, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. f = f'", "interpret yoneda_lemma_for_hom C S \\<phi> \\<open>Y (C.cod f)\\<close> \\<open>C.dom f\\<close> \\<open>C.cod f\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. yoneda_lemma_for_hom (\\<cdot>) (\\<cdot>\\<^sub>S) \\<phi> (C.dom f)\n     (C.cod f)", "using par"], ["proof (prove)\nusing this:\n  C.par f f'\n\ngoal (1 subgoal):\n 1. yoneda_lemma_for_hom (\\<cdot>) (\\<cdot>\\<^sub>S) \\<phi> (C.dom f)\n     (C.cod f)", "by (unfold_locales, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. f = f'", "show \"f = f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = f'", "using par ff' Y_injective_on_homs [of f f']"], ["proof (prove)\nusing this:\n  C.par f f'\n  local.map f = local.map f'\n  \\<lbrakk>\\<guillemotleft>f : C.dom\n                                f \\<rightarrow> C.cod f\\<guillemotright>;\n   \\<guillemotleft>f' : C.dom f \\<rightarrow> C.cod f\\<guillemotright>;\n   local.map f = local.map f'\\<rbrakk>\n  \\<Longrightarrow> f = f'\n\ngoal (1 subgoal):\n 1. f = f'", "by fastforce"], ["proof (state)\nthis:\n  f = f'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f = f'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_full_functor:\n    shows \"full_functor C Cop_S.comp map\""], ["proof (prove)\ngoal (1 subgoal):\n 1. full_functor (\\<cdot>) Cop_S.comp local.map", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a' g.\n       \\<lbrakk>C.ide a; C.ide a';\n        \\<guillemotleft>g : local.map\n                             a' \\<rightarrow>\\<^sub>[\\<^sub>C\\<^sub>o\\<^sub>p\\<^sub>,\\<^sub>S\\<^sub>] local.map\n                           a\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            \\<guillemotleft>f : a' \\<rightarrow> a\\<guillemotright> \\<and>\n                            local.map f = g", "fix a :: 'c and a' :: 'c and t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a' g.\n       \\<lbrakk>C.ide a; C.ide a';\n        \\<guillemotleft>g : local.map\n                             a' \\<rightarrow>\\<^sub>[\\<^sub>C\\<^sub>o\\<^sub>p\\<^sub>,\\<^sub>S\\<^sub>] local.map\n                           a\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            \\<guillemotleft>f : a' \\<rightarrow> a\\<guillemotright> \\<and>\n                            local.map f = g", "assume a: \"C.ide a\" and a': \"C.ide a'\""], ["proof (state)\nthis:\n  C.ide a\n  C.ide a'\n\ngoal (1 subgoal):\n 1. \\<And>a a' g.\n       \\<lbrakk>C.ide a; C.ide a';\n        \\<guillemotleft>g : local.map\n                             a' \\<rightarrow>\\<^sub>[\\<^sub>C\\<^sub>o\\<^sub>p\\<^sub>,\\<^sub>S\\<^sub>] local.map\n                           a\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            \\<guillemotleft>f : a' \\<rightarrow> a\\<guillemotright> \\<and>\n                            local.map f = g", "assume t: \"\\<guillemotleft>t : map a \\<rightarrow>\\<^sub>[\\<^sub>C\\<^sub>o\\<^sub>p\\<^sub>,\\<^sub>S\\<^sub>] map a'\\<guillemotright>\""], ["proof (state)\nthis:\n  \\<guillemotleft>t : local.map\n                       a \\<rightarrow>\\<^sub>[\\<^sub>C\\<^sub>o\\<^sub>p\\<^sub>,\\<^sub>S\\<^sub>] local.map\n                    a'\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>a a' g.\n       \\<lbrakk>C.ide a; C.ide a';\n        \\<guillemotleft>g : local.map\n                             a' \\<rightarrow>\\<^sub>[\\<^sub>C\\<^sub>o\\<^sub>p\\<^sub>,\\<^sub>S\\<^sub>] local.map\n                           a\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            \\<guillemotleft>f : a' \\<rightarrow> a\\<guillemotright> \\<and>\n                            local.map f = g", "show \"\\<exists>e. \\<guillemotleft>e : a \\<rightarrow> a'\\<guillemotright> \\<and> map e = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>e.\n       \\<guillemotleft>e : a \\<rightarrow> a'\\<guillemotright> \\<and>\n       local.map e = t", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<guillemotleft>?e : a \\<rightarrow> a'\\<guillemotright> \\<and>\n    local.map ?e = t", "interpret Ya': yoneda_functor_fixed_object C S \\<phi> a'"], ["proof (prove)\ngoal (1 subgoal):\n 1. yoneda_functor_fixed_object (\\<cdot>) (\\<cdot>\\<^sub>S) \\<phi> a'", "using a'"], ["proof (prove)\nusing this:\n  C.ide a'\n\ngoal (1 subgoal):\n 1. yoneda_functor_fixed_object (\\<cdot>) (\\<cdot>\\<^sub>S) \\<phi> a'", "by (unfold_locales, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<guillemotleft>?e : a \\<rightarrow> a'\\<guillemotright> \\<and>\n    local.map ?e = t", "interpret yoneda_lemma_for_hom C S \\<phi> \\<open>Y a'\\<close> a a'"], ["proof (prove)\ngoal (1 subgoal):\n 1. yoneda_lemma_for_hom (\\<cdot>) (\\<cdot>\\<^sub>S) \\<phi> a a'", "using a a'"], ["proof (prove)\nusing this:\n  C.ide a\n  C.ide a'\n\ngoal (1 subgoal):\n 1. yoneda_lemma_for_hom (\\<cdot>) (\\<cdot>\\<^sub>S) \\<phi> a a'", "by (unfold_locales, auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<guillemotleft>?e : a \\<rightarrow> a'\\<guillemotright> \\<and>\n    local.map ?e = t", "have NT: \"natural_transformation Cop.comp S (Y a) (Y a') (Cop_S.Map t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n     (Y a') (Cop_S.Map t)", "using t a' Y_def Cop_S.Map_dom Cop_S.Map_cod Cop_S.dom_char Cop_S.cod_char\n                Cop_S.in_homE Cop_S.arrE"], ["proof (prove)\nusing this:\n  \\<guillemotleft>t : local.map\n                       a \\<rightarrow>\\<^sub>[\\<^sub>C\\<^sub>o\\<^sub>p\\<^sub>,\\<^sub>S\\<^sub>] local.map\n                    a'\\<guillemotright>\n  C.ide a'\n  Y ?f \\<equiv> Cop_S.Map (local.map ?f)\n  Cop_S.arr ?f \\<Longrightarrow> Cop_S.Map (Cop_S.dom ?f) = Cop_S.Dom ?f\n  Cop_S.arr ?f \\<Longrightarrow> Cop_S.Map (Cop_S.cod ?f) = Cop_S.Cod ?f\n  Cop_S.dom ?f =\n  (if Cop_S.arr ?f then Cop_S.MkIde (Cop_S.Dom ?f) else Cop_S.null)\n  Cop_S.cod ?f =\n  (if Cop_S.arr ?f then Cop_S.MkIde (Cop_S.Cod ?f) else Cop_S.null)\n  \\<lbrakk>\\<guillemotleft>?f : ?a \\<rightarrow>\\<^sub>[\\<^sub>C\\<^sub>o\\<^sub>p\\<^sub>,\\<^sub>S\\<^sub>] ?b\\<guillemotright>;\n   \\<lbrakk>Cop_S.arr ?f; Cop_S.dom ?f = ?a; Cop_S.cod ?f = ?b\\<rbrakk>\n   \\<Longrightarrow> ?T\\<rbrakk>\n  \\<Longrightarrow> ?T\n  \\<lbrakk>Cop_S.arr ?f;\n   \\<lbrakk>?f \\<noteq> Cop_S.null;\n    natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S)\n     (Cop_S.Dom ?f) (Cop_S.Cod ?f) (Cop_S.Map ?f)\\<rbrakk>\n   \\<Longrightarrow> ?T\\<rbrakk>\n  \\<Longrightarrow> ?T\n\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n     (Y a') (Cop_S.Map t)", "by metis"], ["proof (state)\nthis:\n  natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n   (Y a') (Cop_S.Map t)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>?e : a \\<rightarrow> a'\\<guillemotright> \\<and>\n    local.map ?e = t", "hence 1: \"\\<E> (Cop_S.Map t) \\<in> Hom.set (a, a')\""], ["proof (prove)\nusing this:\n  natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n   (Y a') (Cop_S.Map t)\n\ngoal (1 subgoal):\n 1. \\<E> (Cop_S.Map t) \\<in> Hom.set (a, a')", "using \\<E>\\<tau>_in_Fa ide_a ide_a' Hom.set_map"], ["proof (prove)\nusing this:\n  natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n   (Y a') (Cop_S.Map t)\n  natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n   (Y a') ?\\<tau> \\<Longrightarrow>\n  \\<E> ?\\<tau> \\<in> Ya'.SET a\n  C.ide a\n  C.ide a'\n  \\<lbrakk>C.ide ?a; C.ide ?b\\<rbrakk>\n  \\<Longrightarrow> S.set (Hom.map (?b, ?a)) = Hom.set (?b, ?a)\n\ngoal (1 subgoal):\n 1. \\<E> (Cop_S.Map t) \\<in> Hom.set (a, a')", "by simp"], ["proof (state)\nthis:\n  \\<E> (Cop_S.Map t) \\<in> Hom.set (a, a')\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>?e : a \\<rightarrow> a'\\<guillemotright> \\<and>\n    local.map ?e = t", "moreover"], ["proof (state)\nthis:\n  \\<E> (Cop_S.Map t) \\<in> Hom.set (a, a')\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>?e : a \\<rightarrow> a'\\<guillemotright> \\<and>\n    local.map ?e = t", "have \"map (\\<psi> (a, a') (\\<E> (Cop_S.Map t))) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.map (\\<psi> (a, a') (\\<E> (Cop_S.Map t))) = t", "proof (intro Cop_S.arr_eqI)"], ["proof (state)\ngoal (5 subgoals):\n 1. Cop_S.arr (local.map (\\<psi> (a, a') (\\<E> (Cop_S.Map t))))\n 2. Cop_S.arr t\n 3. Cop_S.Dom (local.map (\\<psi> (a, a') (\\<E> (Cop_S.Map t)))) =\n    Cop_S.Dom t\n 4. Cop_S.Cod (local.map (\\<psi> (a, a') (\\<E> (Cop_S.Map t)))) =\n    Cop_S.Cod t\n 5. Cop_S.Map (local.map (\\<psi> (a, a') (\\<E> (Cop_S.Map t)))) =\n    Cop_S.Map t", "have 2: \"\\<guillemotleft>map (\\<psi> (a, a') (\\<E> (Cop_S.Map t))) : map a \\<rightarrow>\\<^sub>[\\<^sub>C\\<^sub>o\\<^sub>p\\<^sub>,\\<^sub>S\\<^sub>] map a'\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>local.map\n                     (\\<psi> (a, a')\n                       (\\<E>\n                         (Cop_S.Map\n                           t))) : local.map\n                                   a \\<rightarrow>\\<^sub>[\\<^sub>C\\<^sub>o\\<^sub>p\\<^sub>,\\<^sub>S\\<^sub>] local.map\n                                a'\\<guillemotright>", "using 1 ide_a ide_a' Hom.\\<psi>_mapsto [of a a']"], ["proof (prove)\nusing this:\n  \\<E> (Cop_S.Map t) \\<in> Hom.set (a, a')\n  C.ide a\n  C.ide a'\n  \\<lbrakk>C.ide a; C.ide a'\\<rbrakk>\n  \\<Longrightarrow> \\<psi> (a, a')\n                    \\<in> Hom.set (a, a') \\<rightarrow> C.hom a a'\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>local.map\n                     (\\<psi> (a, a')\n                       (\\<E>\n                         (Cop_S.Map\n                           t))) : local.map\n                                   a \\<rightarrow>\\<^sub>[\\<^sub>C\\<^sub>o\\<^sub>p\\<^sub>,\\<^sub>S\\<^sub>] local.map\n                                a'\\<guillemotright>", "by blast"], ["proof (state)\nthis:\n  \\<guillemotleft>local.map\n                   (\\<psi> (a, a')\n                     (\\<E>\n                       (Cop_S.Map\n                         t))) : local.map\n                                 a \\<rightarrow>\\<^sub>[\\<^sub>C\\<^sub>o\\<^sub>p\\<^sub>,\\<^sub>S\\<^sub>] local.map\n                              a'\\<guillemotright>\n\ngoal (5 subgoals):\n 1. Cop_S.arr (local.map (\\<psi> (a, a') (\\<E> (Cop_S.Map t))))\n 2. Cop_S.arr t\n 3. Cop_S.Dom (local.map (\\<psi> (a, a') (\\<E> (Cop_S.Map t)))) =\n    Cop_S.Dom t\n 4. Cop_S.Cod (local.map (\\<psi> (a, a') (\\<E> (Cop_S.Map t)))) =\n    Cop_S.Cod t\n 5. Cop_S.Map (local.map (\\<psi> (a, a') (\\<E> (Cop_S.Map t)))) =\n    Cop_S.Map t", "show \"Cop_S.arr t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cop_S.arr t", "using t"], ["proof (prove)\nusing this:\n  \\<guillemotleft>t : local.map\n                       a \\<rightarrow>\\<^sub>[\\<^sub>C\\<^sub>o\\<^sub>p\\<^sub>,\\<^sub>S\\<^sub>] local.map\n                    a'\\<guillemotright>\n\ngoal (1 subgoal):\n 1. Cop_S.arr t", "by blast"], ["proof (state)\nthis:\n  Cop_S.arr t\n\ngoal (4 subgoals):\n 1. Cop_S.arr (local.map (\\<psi> (a, a') (\\<E> (Cop_S.Map t))))\n 2. Cop_S.Dom (local.map (\\<psi> (a, a') (\\<E> (Cop_S.Map t)))) =\n    Cop_S.Dom t\n 3. Cop_S.Cod (local.map (\\<psi> (a, a') (\\<E> (Cop_S.Map t)))) =\n    Cop_S.Cod t\n 4. Cop_S.Map (local.map (\\<psi> (a, a') (\\<E> (Cop_S.Map t)))) =\n    Cop_S.Map t", "show \"Cop_S.arr (map (\\<psi> (a, a') (\\<E> (Cop_S.Map t))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cop_S.arr (local.map (\\<psi> (a, a') (\\<E> (Cop_S.Map t))))", "using 2"], ["proof (prove)\nusing this:\n  \\<guillemotleft>local.map\n                   (\\<psi> (a, a')\n                     (\\<E>\n                       (Cop_S.Map\n                         t))) : local.map\n                                 a \\<rightarrow>\\<^sub>[\\<^sub>C\\<^sub>o\\<^sub>p\\<^sub>,\\<^sub>S\\<^sub>] local.map\n                              a'\\<guillemotright>\n\ngoal (1 subgoal):\n 1. Cop_S.arr (local.map (\\<psi> (a, a') (\\<E> (Cop_S.Map t))))", "by blast"], ["proof (state)\nthis:\n  Cop_S.arr (local.map (\\<psi> (a, a') (\\<E> (Cop_S.Map t))))\n\ngoal (3 subgoals):\n 1. Cop_S.Dom (local.map (\\<psi> (a, a') (\\<E> (Cop_S.Map t)))) =\n    Cop_S.Dom t\n 2. Cop_S.Cod (local.map (\\<psi> (a, a') (\\<E> (Cop_S.Map t)))) =\n    Cop_S.Cod t\n 3. Cop_S.Map (local.map (\\<psi> (a, a') (\\<E> (Cop_S.Map t)))) =\n    Cop_S.Map t", "show 3: \"Cop_S.Map (map (\\<psi> (a, a') (\\<E> (Cop_S.Map t)))) = Cop_S.Map t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cop_S.Map (local.map (\\<psi> (a, a') (\\<E> (Cop_S.Map t)))) =\n    Cop_S.Map t", "using NT Y_surjective_on_homs Y_def"], ["proof (prove)\nusing this:\n  natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n   (Y a') (Cop_S.Map t)\n  natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n   (Y a') ?\\<tau> \\<Longrightarrow>\n  Y (\\<psi> (a, a') (\\<E> ?\\<tau>)) = ?\\<tau>\n  Y ?f \\<equiv> Cop_S.Map (local.map ?f)\n\ngoal (1 subgoal):\n 1. Cop_S.Map (local.map (\\<psi> (a, a') (\\<E> (Cop_S.Map t)))) =\n    Cop_S.Map t", "by simp"], ["proof (state)\nthis:\n  Cop_S.Map (local.map (\\<psi> (a, a') (\\<E> (Cop_S.Map t)))) = Cop_S.Map t\n\ngoal (2 subgoals):\n 1. Cop_S.Dom (local.map (\\<psi> (a, a') (\\<E> (Cop_S.Map t)))) =\n    Cop_S.Dom t\n 2. Cop_S.Cod (local.map (\\<psi> (a, a') (\\<E> (Cop_S.Map t)))) =\n    Cop_S.Cod t", "show 4: \"Cop_S.Dom (map (\\<psi> (a, a') (\\<E> (Cop_S.Map t)))) = Cop_S.Dom t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cop_S.Dom (local.map (\\<psi> (a, a') (\\<E> (Cop_S.Map t)))) =\n    Cop_S.Dom t", "using t 2 natural_transformation_axioms Cop_S.Map_dom"], ["proof (prove)\nusing this:\n  \\<guillemotleft>t : local.map\n                       a \\<rightarrow>\\<^sub>[\\<^sub>C\\<^sub>o\\<^sub>p\\<^sub>,\\<^sub>S\\<^sub>] local.map\n                    a'\\<guillemotright>\n  \\<guillemotleft>local.map\n                   (\\<psi> (a, a')\n                     (\\<E>\n                       (Cop_S.Map\n                         t))) : local.map\n                                 a \\<rightarrow>\\<^sub>[\\<^sub>C\\<^sub>o\\<^sub>p\\<^sub>,\\<^sub>S\\<^sub>] local.map\n                              a'\\<guillemotright>\n  natural_transformation (\\<cdot>\\<^sup>o\\<^sup>p) (\\<cdot>\\<^sub>S) (Y a)\n   (Y a) (Y a)\n  Cop_S.arr ?f \\<Longrightarrow> Cop_S.Map (Cop_S.dom ?f) = Cop_S.Dom ?f\n\ngoal (1 subgoal):\n 1. Cop_S.Dom (local.map (\\<psi> (a, a') (\\<E> (Cop_S.Map t)))) =\n    Cop_S.Dom t", "by (metis Cop_S.in_homE)"], ["proof (state)\nthis:\n  Cop_S.Dom (local.map (\\<psi> (a, a') (\\<E> (Cop_S.Map t)))) = Cop_S.Dom t\n\ngoal (1 subgoal):\n 1. Cop_S.Cod (local.map (\\<psi> (a, a') (\\<E> (Cop_S.Map t)))) =\n    Cop_S.Cod t", "show \"Cop_S.Cod (map (\\<psi> (a, a') (\\<E> (Cop_S.Map t)))) = Cop_S.Cod t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cop_S.Cod (local.map (\\<psi> (a, a') (\\<E> (Cop_S.Map t)))) =\n    Cop_S.Cod t", "using 2 3 4 t Cop_S.Map_cod"], ["proof (prove)\nusing this:\n  \\<guillemotleft>local.map\n                   (\\<psi> (a, a')\n                     (\\<E>\n                       (Cop_S.Map\n                         t))) : local.map\n                                 a \\<rightarrow>\\<^sub>[\\<^sub>C\\<^sub>o\\<^sub>p\\<^sub>,\\<^sub>S\\<^sub>] local.map\n                              a'\\<guillemotright>\n  Cop_S.Map (local.map (\\<psi> (a, a') (\\<E> (Cop_S.Map t)))) = Cop_S.Map t\n  Cop_S.Dom (local.map (\\<psi> (a, a') (\\<E> (Cop_S.Map t)))) = Cop_S.Dom t\n  \\<guillemotleft>t : local.map\n                       a \\<rightarrow>\\<^sub>[\\<^sub>C\\<^sub>o\\<^sub>p\\<^sub>,\\<^sub>S\\<^sub>] local.map\n                    a'\\<guillemotright>\n  Cop_S.arr ?f \\<Longrightarrow> Cop_S.Map (Cop_S.cod ?f) = Cop_S.Cod ?f\n\ngoal (1 subgoal):\n 1. Cop_S.Cod (local.map (\\<psi> (a, a') (\\<E> (Cop_S.Map t)))) =\n    Cop_S.Cod t", "by (metis Cop_S.in_homE)"], ["proof (state)\nthis:\n  Cop_S.Cod (local.map (\\<psi> (a, a') (\\<E> (Cop_S.Map t)))) = Cop_S.Cod t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.map (\\<psi> (a, a') (\\<E> (Cop_S.Map t))) = t\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>?e : a \\<rightarrow> a'\\<guillemotright> \\<and>\n    local.map ?e = t", "ultimately"], ["proof (chain)\npicking this:\n  \\<E> (Cop_S.Map t) \\<in> Hom.set (a, a')\n  local.map (\\<psi> (a, a') (\\<E> (Cop_S.Map t))) = t", "show \"\\<guillemotleft>\\<psi> (a, a') (\\<E> (Cop_S.Map t)) : a \\<rightarrow> a'\\<guillemotright> \\<and>\n                         map (\\<psi> (a, a') (\\<E> (Cop_S.Map t))) = t\""], ["proof (prove)\nusing this:\n  \\<E> (Cop_S.Map t) \\<in> Hom.set (a, a')\n  local.map (\\<psi> (a, a') (\\<E> (Cop_S.Map t))) = t\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<psi> (a, a')\n                     (\\<E>\n                       (Cop_S.Map\n                         t)) : a \\<rightarrow> a'\\<guillemotright> \\<and>\n    local.map (\\<psi> (a, a') (\\<E> (Cop_S.Map t))) = t", "using ide_a ide_a' Hom.\\<psi>_mapsto"], ["proof (prove)\nusing this:\n  \\<E> (Cop_S.Map t) \\<in> Hom.set (a, a')\n  local.map (\\<psi> (a, a') (\\<E> (Cop_S.Map t))) = t\n  C.ide a\n  C.ide a'\n  \\<lbrakk>C.ide ?b; C.ide ?a\\<rbrakk>\n  \\<Longrightarrow> \\<psi> (?b, ?a)\n                    \\<in> Hom.set (?b, ?a) \\<rightarrow> C.hom ?b ?a\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<psi> (a, a')\n                     (\\<E>\n                       (Cop_S.Map\n                         t)) : a \\<rightarrow> a'\\<guillemotright> \\<and>\n    local.map (\\<psi> (a, a') (\\<E> (Cop_S.Map t))) = t", "by auto"], ["proof (state)\nthis:\n  \\<guillemotleft>\\<psi> (a, a')\n                   (\\<E>\n                     (Cop_S.Map\n                       t)) : a \\<rightarrow> a'\\<guillemotright> \\<and>\n  local.map (\\<psi> (a, a') (\\<E> (Cop_S.Map t))) = t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>e.\n     \\<guillemotleft>e : a \\<rightarrow> a'\\<guillemotright> \\<and>\n     local.map e = t\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "sublocale yoneda_functor \\<subseteq> faithful_functor C Cop_S.comp map"], ["proof (prove)\ngoal (1 subgoal):\n 1. faithful_functor (\\<cdot>) Cop_S.comp local.map", "using is_faithful_functor"], ["proof (prove)\nusing this:\n  faithful_functor (\\<cdot>) Cop_S.comp local.map\n\ngoal (1 subgoal):\n 1. faithful_functor (\\<cdot>) Cop_S.comp local.map", "by auto"], ["", "sublocale yoneda_functor \\<subseteq> full_functor C Cop_S.comp map"], ["proof (prove)\ngoal (1 subgoal):\n 1. full_functor (\\<cdot>) Cop_S.comp local.map", "using is_full_functor"], ["proof (prove)\nusing this:\n  full_functor (\\<cdot>) Cop_S.comp local.map\n\ngoal (1 subgoal):\n 1. full_functor (\\<cdot>) Cop_S.comp local.map", "by auto"], ["", "sublocale yoneda_functor \\<subseteq> fully_faithful_functor C Cop_S.comp map"], ["proof (prove)\ngoal (1 subgoal):\n 1. fully_faithful_functor (\\<cdot>) Cop_S.comp local.map", ".."], ["", "end"]]}