{"file_name": "/home/qj213/afp-2021-10-22/thys/Category3/Category.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Category3", "problem_names": ["lemma null_eqI:\n    assumes \"\\<And>f. n \\<cdot> f = n \\<and> f \\<cdot> n = n\"\n    shows \"n = null\"", "lemma comp_null [simp]:\n    shows \"null \\<cdot> f = null\" and \"f \\<cdot> null = null\"", "lemma domains_null:\n    shows \"domains null = {}\"", "lemma codomains_null:\n    shows \"codomains null = {}\"", "lemma self_domain_iff_ide:\n    shows \"a \\<in> domains a \\<longleftrightarrow> ide a\"", "lemma self_codomain_iff_ide:\n    shows \"a \\<in> codomains a \\<longleftrightarrow> ide a\"", "lemma not_arr_null [simp]:\n    shows \"\\<not> arr null\"", "lemma arrI:\n    assumes \"\\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>\"\n    shows \"arr f\"", "lemma ide_in_hom [intro]:\n    shows \"ide a \\<longleftrightarrow> \\<guillemotleft>a : a \\<rightarrow> a\\<guillemotright>\"", "lemma comp_arr_ide:\n    assumes \"ide a\" and \"seq f a\"\n    shows \"f \\<cdot> a = f\"", "lemma comp_ide_arr:\n    assumes \"ide b\" and \"seq b f\"\n    shows \"b \\<cdot> f = f\"", "lemma dom_null [simp]:\n    shows \"dom null = null\"", "lemma cod_null [simp]:\n    shows \"cod null = null\"", "lemma dom_in_domains:\n    assumes \"domains f \\<noteq> {}\"\n    shows \"dom f \\<in> domains f\"", "lemma cod_in_codomains:\n    assumes \"codomains f \\<noteq> {}\"\n    shows \"cod f \\<in> codomains f\"", "lemma comp_assoc:\n    shows \"(h \\<cdot> g) \\<cdot> f = h \\<cdot> g \\<cdot> f\"", "lemma match_4:\n    assumes \"seq g f\" and \"seq h g\"\n    shows \"seq h (g \\<cdot> f)\"", "lemma domains_comp:\n    assumes \"seq g f\"\n    shows \"domains (g \\<cdot> f) = domains f\"", "lemma codomains_comp:\n    assumes \"seq g f\"\n    shows \"codomains (g \\<cdot> f) = codomains g\"", "lemma has_domain_iff_arr:\n    shows \"domains f \\<noteq> {} \\<longleftrightarrow> arr f\"", "lemma has_codomain_iff_arr:\n    shows \"codomains f \\<noteq> {} \\<longleftrightarrow> arr f\"", "lemma domain_unique:\n    assumes \"a \\<in> domains f\" and \"a' \\<in> domains f\"\n    shows \"a = a'\"", "lemma codomain_unique:\n    assumes \"b \\<in> codomains f\" and \"b' \\<in> codomains f\"\n    shows \"b = b'\"", "lemma domains_simp:\n    assumes \"arr f\"\n    shows \"domains f = {dom f}\"", "lemma codomains_simp:\n    assumes \"arr f\"\n    shows \"codomains f = {cod f}\"", "lemma domains_char:\n    shows \"domains f = (if arr f then {dom f} else {})\"", "lemma codomains_char:\n    shows \"codomains f = (if arr f then {cod f} else {})\"", "lemma arr_iff_in_hom:\n    shows \"arr f \\<longleftrightarrow> \\<guillemotleft>f : dom f \\<rightarrow> cod f\\<guillemotright>\"", "lemma in_homI [intro]:\n    assumes \"arr f\" and \"dom f = a\" and \"cod f = b\"\n    shows \"\\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>\"", "lemma in_homE [elim]:\n    assumes \"\\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>\"\n    and \"arr f \\<Longrightarrow> dom f = a \\<Longrightarrow> cod f = b \\<Longrightarrow> T\"\n    shows \"T\"", "lemma arr_dom_iff_arr:\n    shows \"arr (dom f) \\<longleftrightarrow> arr f\"", "lemma arr_cod_iff_arr:\n    shows \"arr (cod f) \\<longleftrightarrow> arr f\"", "lemma arr_dom [simp]:\n    assumes \"arr f\"\n    shows \"arr (dom f)\"", "lemma arr_cod [simp]:\n    assumes \"arr f\"\n    shows \"arr (cod f)\"", "lemma seqI [simp]:\n    assumes \"arr f\" and \"arr g\" and \"dom g = cod f\"\n    shows \"seq g f\"", "lemma seqI' [intro]:\n    assumes \"\\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>\" and \"\\<guillemotleft>g : b \\<rightarrow> c\\<guillemotright>\"\n    shows \"seq g f\"", "lemma compatible_iff_seq:\n    shows \"domains g \\<inter> codomains f \\<noteq> {} \\<longleftrightarrow> seq g f\"", "lemma seqE [elim]:\n    assumes \"seq g f\"\n    and \"arr f \\<Longrightarrow> arr g \\<Longrightarrow> dom g = cod f \\<Longrightarrow> T\"\n    shows \"T\"", "lemma comp_in_homI [intro]:\n    assumes \"\\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>\" and \"\\<guillemotleft>g : b \\<rightarrow> c\\<guillemotright>\"\n    shows \"\\<guillemotleft>g \\<cdot> f : a \\<rightarrow> c\\<guillemotright>\"", "lemma comp_in_homI' [simp]:\n    assumes \"arr f\" and \"arr g\" and \"dom f = a\" and \"cod g = c\" and \"dom g = cod f\"\n    shows \"\\<guillemotleft>g \\<cdot> f : a \\<rightarrow> c\\<guillemotright>\"", "lemma comp_in_homE [elim]:\n    assumes \"\\<guillemotleft>g \\<cdot> f : a \\<rightarrow> c\\<guillemotright>\"\n    obtains b where \"\\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>\" and \"\\<guillemotleft>g : b \\<rightarrow> c\\<guillemotright>\"", "lemma comp_arr_dom:\n    assumes \"arr f\" and \"dom f = a\"\n    shows \"f \\<cdot> a = f\"", "lemma comp_cod_arr:\n    assumes \"arr f\" and \"cod f = b\"\n    shows \"b \\<cdot> f = f\"", "lemma ide_char:\n    shows \"ide a \\<longleftrightarrow> arr a \\<and> dom a = a \\<and> cod a = a\"", "lemma ideD [simp]:\n    assumes \"ide a\"\n    shows \"arr a\" and \"dom a = a\" and \"cod a = a\"", "lemma ide_dom [simp]:\n    assumes \"arr f\"\n    shows \"ide (dom f)\"", "lemma ide_cod [simp]:\n    assumes \"arr f\"\n    shows \"ide (cod f)\"", "lemma dom_eqI:\n    assumes \"ide a\" and \"seq f a\"\n    shows \"dom f = a\"", "lemma cod_eqI:\n    assumes \"ide b\" and \"seq b f\"\n    shows \"cod f = b\"", "lemma dom_eqI':\n    assumes \"a \\<in> domains f\"\n    shows \"a = dom f\"", "lemma cod_eqI':\n    assumes \"a \\<in> codomains f\"\n    shows \"a = cod f\"", "lemma ide_char':\n    shows \"ide a \\<longleftrightarrow> arr a \\<and> (dom a = a \\<or> cod a = a)\"", "lemma dom_dom:\n    assumes \"arr f\"\n    shows \"dom (dom f) = dom f\"", "lemma cod_cod:\n    assumes \"arr f\"\n    shows \"cod (cod f) = cod f\"", "lemma dom_cod:\n    assumes \"arr f\"\n    shows \"dom (cod f) = cod f\"", "lemma cod_dom:\n    assumes \"arr f\"\n    shows \"cod (dom f) = dom f\"", "lemma dom_comp [simp]:\n    assumes \"seq g f\"\n    shows \"dom (g \\<cdot> f) = dom f\"", "lemma cod_comp [simp]:\n    assumes \"seq g f\"\n    shows \"cod (g \\<cdot> f) = cod g\"", "lemma comp_ide_self [simp]:\n    assumes \"ide a\"\n    shows \"a \\<cdot> a = a\"", "lemma ide_compE [elim]:\n    assumes \"ide (g \\<cdot> f)\"\n    and \"seq g f \\<Longrightarrow> seq f g \\<Longrightarrow> g \\<cdot> f = dom f \\<Longrightarrow> g \\<cdot> f = cod g \\<Longrightarrow> T\"\n    shows \"T\"", "lemma comp_permute:\n    assumes \"f \\<cdot> g = k \\<cdot> l\" and \"seq f g\" and \"seq g h\"\n    shows \"f \\<cdot> g \\<cdot> h = k \\<cdot> l \\<cdot> h\"", "lemma comp_reduce:\n    assumes \"f \\<cdot> g = k\" and \"seq f g\" and \"seq g h\"\n    shows \"f \\<cdot> g \\<cdot> h = k \\<cdot> h\""], "translations": [["", "lemma null_eqI:\n    assumes \"\\<And>f. n \\<cdot> f = n \\<and> f \\<cdot> n = n\"\n    shows \"n = null\""], ["proof (prove)\ngoal (1 subgoal):\n 1. n = null", "using assms null_def ex_un_null the1_equality [of \"\\<lambda>n. \\<forall>f. n \\<cdot> f = n \\<and> f \\<cdot> n = n\"]"], ["proof (prove)\nusing this:\n  n \\<cdot> ?f = n \\<and> ?f \\<cdot> n = n\n  null = (THE n. \\<forall>f. n \\<cdot> f = n \\<and> f \\<cdot> n = n)\n  \\<exists>!n. \\<forall>f. n \\<cdot> f = n \\<and> f \\<cdot> n = n\n  \\<lbrakk>\\<exists>!x. \\<forall>f. x \\<cdot> f = x \\<and> f \\<cdot> x = x;\n   \\<forall>f. ?a \\<cdot> f = ?a \\<and> f \\<cdot> ?a = ?a\\<rbrakk>\n  \\<Longrightarrow> (THE x.\n                        \\<forall>f.\n                           x \\<cdot> f = x \\<and> f \\<cdot> x = x) =\n                    ?a\n\ngoal (1 subgoal):\n 1. n = null", "by auto"], ["", "lemma comp_null [simp]:\n    shows \"null \\<cdot> f = null\" and \"f \\<cdot> null = null\""], ["proof (prove)\ngoal (1 subgoal):\n 1. null \\<cdot> f = null &&& f \\<cdot> null = null", "using null_def ex_un_null theI' [of \"\\<lambda>n. \\<forall>f. n \\<cdot> f = n \\<and> f \\<cdot> n = n\"]"], ["proof (prove)\nusing this:\n  null = (THE n. \\<forall>f. n \\<cdot> f = n \\<and> f \\<cdot> n = n)\n  \\<exists>!n. \\<forall>f. n \\<cdot> f = n \\<and> f \\<cdot> n = n\n  \\<exists>!x.\n     \\<forall>f. x \\<cdot> f = x \\<and> f \\<cdot> x = x \\<Longrightarrow>\n  \\<forall>f.\n     (THE x. \\<forall>f. x \\<cdot> f = x \\<and> f \\<cdot> x = x) \\<cdot> f =\n     (THE x. \\<forall>f. x \\<cdot> f = x \\<and> f \\<cdot> x = x) \\<and>\n     f \\<cdot> (THE x. \\<forall>f. x \\<cdot> f = x \\<and> f \\<cdot> x = x) =\n     (THE x. \\<forall>f. x \\<cdot> f = x \\<and> f \\<cdot> x = x)\n\ngoal (1 subgoal):\n 1. null \\<cdot> f = null &&& f \\<cdot> null = null", "by auto"], ["", "text \\<open>\n      An \\emph{identity} is a self-composable element \\<open>a\\<close> such that composition of\n      any other element \\<open>f\\<close> with \\<open>a\\<close> on either the left or the right results in\n      \\<open>f\\<close> whenever the composition is defined.\n\\<close>"], ["", "definition ide\n    where \"ide a \\<equiv> a \\<cdot> a \\<noteq> null \\<and>\n                   (\\<forall>f. (f \\<cdot> a \\<noteq> null \\<longrightarrow> f \\<cdot> a = f) \\<and> (a \\<cdot> f \\<noteq> null \\<longrightarrow> a \\<cdot> f = f))\""], ["", "text \\<open>\n      A \\emph{domain} of an element \\<open>f\\<close> is an identity \\<open>a\\<close> for which composition of\n      \\<open>f\\<close> with \\<open>a\\<close> on the right is defined.\n      The notion \\emph{codomain} is defined similarly, using composition on the left.\n      Note that, although these definitions are completely dual, the choice of terminology\n      implies that we will think of composition as being written in traditional order,\n      as opposed to diagram order.  It is pretty much essential to do it this way, to maintain\n      compatibility with the notation for function application once we start working with\n      functors and natural transformations.\n\\<close>"], ["", "definition domains\n    where \"domains f \\<equiv> {a. ide a \\<and> f \\<cdot> a \\<noteq> null}\""], ["", "definition codomains\n    where \"codomains f \\<equiv> {b. ide b \\<and> b \\<cdot> f \\<noteq> null}\""], ["", "lemma domains_null:\n    shows \"domains null = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domains null = {}", "by (simp add: domains_def)"], ["", "lemma codomains_null:\n    shows \"codomains null = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. codomains null = {}", "by (simp add: codomains_def)"], ["", "lemma self_domain_iff_ide:\n    shows \"a \\<in> domains a \\<longleftrightarrow> ide a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<in> domains a) = ide a", "using ide_def domains_def"], ["proof (prove)\nusing this:\n  ide ?a \\<equiv>\n  ?a \\<cdot> ?a \\<noteq> null \\<and>\n  (\\<forall>f.\n      (f \\<cdot> ?a \\<noteq> null \\<longrightarrow> f \\<cdot> ?a = f) \\<and>\n      (?a \\<cdot> f \\<noteq> null \\<longrightarrow> ?a \\<cdot> f = f))\n  domains ?f \\<equiv> {a. ide a \\<and> ?f \\<cdot> a \\<noteq> null}\n\ngoal (1 subgoal):\n 1. (a \\<in> domains a) = ide a", "by auto"], ["", "lemma self_codomain_iff_ide:\n    shows \"a \\<in> codomains a \\<longleftrightarrow> ide a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<in> codomains a) = ide a", "using ide_def codomains_def"], ["proof (prove)\nusing this:\n  ide ?a \\<equiv>\n  ?a \\<cdot> ?a \\<noteq> null \\<and>\n  (\\<forall>f.\n      (f \\<cdot> ?a \\<noteq> null \\<longrightarrow> f \\<cdot> ?a = f) \\<and>\n      (?a \\<cdot> f \\<noteq> null \\<longrightarrow> ?a \\<cdot> f = f))\n  codomains ?f \\<equiv> {b. ide b \\<and> b \\<cdot> ?f \\<noteq> null}\n\ngoal (1 subgoal):\n 1. (a \\<in> codomains a) = ide a", "by auto"], ["", "text \\<open>\n      An element \\<open>f\\<close> is an \\emph{arrow} if either it has a domain or it has a codomain.\n      In an arbitrary partial magma it is possible for \\<open>f\\<close> to have one but not the other,\n      but the \\<open>category\\<close> locale will include assumptions to rule this out.\n\\<close>"], ["", "definition arr\n    where \"arr f \\<equiv> domains f \\<noteq> {} \\<or> codomains f \\<noteq> {}\""], ["", "lemma not_arr_null [simp]:\n    shows \"\\<not> arr null\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> arr null", "by (simp add: arr_def domains_null codomains_null)"], ["", "text \\<open>\n      Using the notions of domain and codomain, we can define \\emph{homs}.\n      The predicate @{term \"in_hom f a b\"} expresses ``@{term f} is an arrow from @{term a}\n      to @{term b},'' and the term @{term \"hom a b\"} denotes the set of all such arrows.\n      It is convenient to have both of these, though passing back and forth sometimes involves\n      extra work.  We choose @{term \"in_hom\"} as the more fundamental notion.\n\\<close>"], ["", "definition in_hom     (\"\\<guillemotleft>_ : _ \\<rightarrow> _\\<guillemotright>\")\n    where \"\\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<equiv> a \\<in> domains f \\<and> b \\<in> codomains f\""], ["", "abbreviation hom\n    where \"hom a b \\<equiv> {f. \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>}\""], ["", "lemma arrI:\n    assumes \"\\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>\"\n    shows \"arr f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr f", "using assms arr_def in_hom_def"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>\n  arr ?f \\<equiv> domains ?f \\<noteq> {} \\<or> codomains ?f \\<noteq> {}\n  \\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright> \\<equiv>\n  ?a \\<in> domains ?f \\<and> ?b \\<in> codomains ?f\n\ngoal (1 subgoal):\n 1. arr f", "by auto"], ["", "lemma ide_in_hom [intro]:\n    shows \"ide a \\<longleftrightarrow> \\<guillemotleft>a : a \\<rightarrow> a\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide a = \\<guillemotleft>a : a \\<rightarrow> a\\<guillemotright>", "using self_domain_iff_ide self_codomain_iff_ide in_hom_def ide_def"], ["proof (prove)\nusing this:\n  (?a \\<in> domains ?a) = ide ?a\n  (?a \\<in> codomains ?a) = ide ?a\n  \\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright> \\<equiv>\n  ?a \\<in> domains ?f \\<and> ?b \\<in> codomains ?f\n  ide ?a \\<equiv>\n  ?a \\<cdot> ?a \\<noteq> null \\<and>\n  (\\<forall>f.\n      (f \\<cdot> ?a \\<noteq> null \\<longrightarrow> f \\<cdot> ?a = f) \\<and>\n      (?a \\<cdot> f \\<noteq> null \\<longrightarrow> ?a \\<cdot> f = f))\n\ngoal (1 subgoal):\n 1. ide a = \\<guillemotleft>a : a \\<rightarrow> a\\<guillemotright>", "by fastforce"], ["", "text \\<open>\n      Arrows @{term \"f\"} @{term \"g\"} for which the composite @{term \"g \\<cdot> f\"} is defined\n      are \\emph{sequential}.\n\\<close>"], ["", "abbreviation seq\n    where \"seq g f \\<equiv> arr (g \\<cdot> f)\""], ["", "lemma comp_arr_ide:\n    assumes \"ide a\" and \"seq f a\"\n    shows \"f \\<cdot> a = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<cdot> a = f", "using assms ide_in_hom ide_def not_arr_null"], ["proof (prove)\nusing this:\n  ide a\n  seq f a\n  ide ?a = \\<guillemotleft>?a : ?a \\<rightarrow> ?a\\<guillemotright>\n  ide ?a \\<equiv>\n  ?a \\<cdot> ?a \\<noteq> null \\<and>\n  (\\<forall>f.\n      (f \\<cdot> ?a \\<noteq> null \\<longrightarrow> f \\<cdot> ?a = f) \\<and>\n      (?a \\<cdot> f \\<noteq> null \\<longrightarrow> ?a \\<cdot> f = f))\n  \\<not> arr null\n\ngoal (1 subgoal):\n 1. f \\<cdot> a = f", "by metis"], ["", "lemma comp_ide_arr:\n    assumes \"ide b\" and \"seq b f\"\n    shows \"b \\<cdot> f = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<cdot> f = f", "using assms ide_in_hom ide_def not_arr_null"], ["proof (prove)\nusing this:\n  ide b\n  seq b f\n  ide ?a = \\<guillemotleft>?a : ?a \\<rightarrow> ?a\\<guillemotright>\n  ide ?a \\<equiv>\n  ?a \\<cdot> ?a \\<noteq> null \\<and>\n  (\\<forall>f.\n      (f \\<cdot> ?a \\<noteq> null \\<longrightarrow> f \\<cdot> ?a = f) \\<and>\n      (?a \\<cdot> f \\<noteq> null \\<longrightarrow> ?a \\<cdot> f = f))\n  \\<not> arr null\n\ngoal (1 subgoal):\n 1. b \\<cdot> f = f", "by metis"], ["", "text \\<open>\n      The \\emph{domain} of an arrow @{term f} is an element chosen arbitrarily from the\n      set of domains of @{term f} and the \\emph{codomain} of @{term f} is an element chosen\n      arbitrarily from the set of codomains.\n\\<close>"], ["", "definition dom\n    where \"dom f = (if domains f \\<noteq> {} then (SOME a. a \\<in> domains f) else null)\""], ["", "definition cod\n    where \"cod f = (if codomains f \\<noteq> {} then (SOME b. b \\<in> codomains f) else null)\""], ["", "lemma dom_null [simp]:\n    shows \"dom null = null\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dom null = null", "by (simp add: dom_def domains_null)"], ["", "lemma cod_null [simp]:\n    shows \"cod null = null\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cod null = null", "by (simp add: cod_def codomains_null)"], ["", "lemma dom_in_domains:\n    assumes \"domains f \\<noteq> {}\"\n    shows \"dom f \\<in> domains f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dom f \\<in> domains f", "using assms dom_def someI [of \"\\<lambda>a. a \\<in> domains f\"]"], ["proof (prove)\nusing this:\n  domains f \\<noteq> {}\n  local.dom ?f =\n  (if domains ?f \\<noteq> {} then SOME a. a \\<in> domains ?f else null)\n  ?x \\<in> domains f \\<Longrightarrow>\n  (SOME a. a \\<in> domains f) \\<in> domains f\n\ngoal (1 subgoal):\n 1. local.dom f \\<in> domains f", "by auto"], ["", "lemma cod_in_codomains:\n    assumes \"codomains f \\<noteq> {}\"\n    shows \"cod f \\<in> codomains f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cod f \\<in> codomains f", "using assms cod_def someI [of \"\\<lambda>b. b \\<in> codomains f\"]"], ["proof (prove)\nusing this:\n  codomains f \\<noteq> {}\n  cod ?f =\n  (if codomains ?f \\<noteq> {} then SOME b. b \\<in> codomains ?f else null)\n  ?x \\<in> codomains f \\<Longrightarrow>\n  (SOME b. b \\<in> codomains f) \\<in> codomains f\n\ngoal (1 subgoal):\n 1. cod f \\<in> codomains f", "by auto"], ["", "end"], ["", "section \"Categories\""], ["", "text\\<open>\n    A \\emph{category} is defined to be a partial magma whose composition satisfies an\n    extensionality condition, an associativity condition, and the requirement that every\n    arrow have both a domain and a codomain.\n    The associativity condition involves four ``matching conditions''\n    (\\<open>match_1\\<close>, \\<open>match_2\\<close>, \\<open>match_3\\<close>, and \\<open>match_4\\<close>)\n    which constrain the domain of definition of the composition, and a fifth condition\n    (\\<open>comp_assoc'\\<close>) which states that the results of the two ways of composing\n    three elements are equal.  In the presence of the \\<open>comp_assoc'\\<close> axiom\n    \\<open>match_4\\<close> can be derived from \\<open>match_3\\<close> and vice versa.\n\\<close>"], ["", "locale category = partial_magma +\n  assumes ext: \"g \\<cdot> f \\<noteq> null \\<Longrightarrow> seq g f\"\n  and has_domain_iff_has_codomain: \"domains f \\<noteq> {} \\<longleftrightarrow> codomains f \\<noteq> {}\"\n  and match_1: \"\\<lbrakk> seq h g; seq (h \\<cdot> g) f \\<rbrakk> \\<Longrightarrow> seq g f\"\n  and match_2: \"\\<lbrakk> seq h (g \\<cdot> f); seq g f \\<rbrakk> \\<Longrightarrow> seq h g\"\n  and match_3: \"\\<lbrakk> seq g f; seq h g \\<rbrakk> \\<Longrightarrow> seq (h \\<cdot> g) f\"\n  and comp_assoc': \"\\<lbrakk> seq g f; seq h g \\<rbrakk> \\<Longrightarrow> (h \\<cdot> g) \\<cdot> f = h \\<cdot> g \\<cdot> f\"\n  begin"], ["", "text\\<open>\n      Associativity of composition holds unconditionally.  This was not the case in\n      previous, weaker versions of this theory, and I did not notice this for some\n      time after updating to the current axioms.  It is obviously an advantage that\n      no additional hypotheses have to be verified in order to apply associativity,\n      but a disadvantage is that this fact is now ``too readily applicable,''\n      so that if it is made a default simplification it tends to get in the way of\n      applying other simplifications that we would also like to be able to apply automatically.\n      So, it now seems best not to make this fact a default simplification, but rather\n      to invoke it explicitly where it is required.\n\\<close>"], ["", "lemma comp_assoc:\n    shows \"(h \\<cdot> g) \\<cdot> f = h \\<cdot> g \\<cdot> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h \\<cdot> g) \\<cdot> f = h \\<cdot> g \\<cdot> f", "by (metis comp_assoc' ex_un_null ext match_1 match_2)"], ["", "lemma match_4:\n    assumes \"seq g f\" and \"seq h g\"\n    shows \"seq h (g \\<cdot> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq h (g \\<cdot> f)", "using assms match_3 comp_assoc"], ["proof (prove)\nusing this:\n  seq g f\n  seq h g\n  \\<lbrakk>seq ?g ?f; seq ?h ?g\\<rbrakk>\n  \\<Longrightarrow> seq (?h \\<cdot> ?g) ?f\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. seq h (g \\<cdot> f)", "by auto"], ["", "lemma domains_comp:\n    assumes \"seq g f\"\n    shows \"domains (g \\<cdot> f) = domains f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domains (g \\<cdot> f) = domains f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. domains (g \\<cdot> f) = domains f", "have \"domains (g \\<cdot> f) = {a. ide a \\<and> seq (g \\<cdot> f) a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domains (g \\<cdot> f) = {a. ide a \\<and> seq (g \\<cdot> f) a}", "using domains_def ext"], ["proof (prove)\nusing this:\n  domains ?f \\<equiv> {a. ide a \\<and> ?f \\<cdot> a \\<noteq> null}\n  ?g \\<cdot> ?f \\<noteq> null \\<Longrightarrow> seq ?g ?f\n\ngoal (1 subgoal):\n 1. domains (g \\<cdot> f) = {a. ide a \\<and> seq (g \\<cdot> f) a}", "by auto"], ["proof (state)\nthis:\n  domains (g \\<cdot> f) = {a. ide a \\<and> seq (g \\<cdot> f) a}\n\ngoal (1 subgoal):\n 1. domains (g \\<cdot> f) = domains f", "also"], ["proof (state)\nthis:\n  domains (g \\<cdot> f) = {a. ide a \\<and> seq (g \\<cdot> f) a}\n\ngoal (1 subgoal):\n 1. domains (g \\<cdot> f) = domains f", "have \"... = {a. ide a \\<and> seq f a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a. ide a \\<and> seq (g \\<cdot> f) a} = {a. ide a \\<and> seq f a}", "using assms ide_def match_1 match_3"], ["proof (prove)\nusing this:\n  seq g f\n  ide ?a \\<equiv>\n  ?a \\<cdot> ?a \\<noteq> null \\<and>\n  (\\<forall>f.\n      (f \\<cdot> ?a \\<noteq> null \\<longrightarrow> f \\<cdot> ?a = f) \\<and>\n      (?a \\<cdot> f \\<noteq> null \\<longrightarrow> ?a \\<cdot> f = f))\n  \\<lbrakk>seq ?h ?g; seq (?h \\<cdot> ?g) ?f\\<rbrakk>\n  \\<Longrightarrow> seq ?g ?f\n  \\<lbrakk>seq ?g ?f; seq ?h ?g\\<rbrakk>\n  \\<Longrightarrow> seq (?h \\<cdot> ?g) ?f\n\ngoal (1 subgoal):\n 1. {a. ide a \\<and> seq (g \\<cdot> f) a} = {a. ide a \\<and> seq f a}", "by meson"], ["proof (state)\nthis:\n  {a. ide a \\<and> seq (g \\<cdot> f) a} = {a. ide a \\<and> seq f a}\n\ngoal (1 subgoal):\n 1. domains (g \\<cdot> f) = domains f", "also"], ["proof (state)\nthis:\n  {a. ide a \\<and> seq (g \\<cdot> f) a} = {a. ide a \\<and> seq f a}\n\ngoal (1 subgoal):\n 1. domains (g \\<cdot> f) = domains f", "have \"... = domains f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {a. ide a \\<and> seq f a} = domains f", "using domains_def ext"], ["proof (prove)\nusing this:\n  domains ?f \\<equiv> {a. ide a \\<and> ?f \\<cdot> a \\<noteq> null}\n  ?g \\<cdot> ?f \\<noteq> null \\<Longrightarrow> seq ?g ?f\n\ngoal (1 subgoal):\n 1. {a. ide a \\<and> seq f a} = domains f", "by auto"], ["proof (state)\nthis:\n  {a. ide a \\<and> seq f a} = domains f\n\ngoal (1 subgoal):\n 1. domains (g \\<cdot> f) = domains f", "finally"], ["proof (chain)\npicking this:\n  domains (g \\<cdot> f) = domains f", "show ?thesis"], ["proof (prove)\nusing this:\n  domains (g \\<cdot> f) = domains f\n\ngoal (1 subgoal):\n 1. domains (g \\<cdot> f) = domains f", "by blast"], ["proof (state)\nthis:\n  domains (g \\<cdot> f) = domains f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma codomains_comp:\n    assumes \"seq g f\"\n    shows \"codomains (g \\<cdot> f) = codomains g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. codomains (g \\<cdot> f) = codomains g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. codomains (g \\<cdot> f) = codomains g", "have \"codomains (g \\<cdot> f) = {b. ide b \\<and> seq b (g \\<cdot> f)}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. codomains (g \\<cdot> f) = {b. ide b \\<and> seq b (g \\<cdot> f)}", "using codomains_def ext"], ["proof (prove)\nusing this:\n  codomains ?f \\<equiv> {b. ide b \\<and> b \\<cdot> ?f \\<noteq> null}\n  ?g \\<cdot> ?f \\<noteq> null \\<Longrightarrow> seq ?g ?f\n\ngoal (1 subgoal):\n 1. codomains (g \\<cdot> f) = {b. ide b \\<and> seq b (g \\<cdot> f)}", "by auto"], ["proof (state)\nthis:\n  codomains (g \\<cdot> f) = {b. ide b \\<and> seq b (g \\<cdot> f)}\n\ngoal (1 subgoal):\n 1. codomains (g \\<cdot> f) = codomains g", "also"], ["proof (state)\nthis:\n  codomains (g \\<cdot> f) = {b. ide b \\<and> seq b (g \\<cdot> f)}\n\ngoal (1 subgoal):\n 1. codomains (g \\<cdot> f) = codomains g", "have \"... = {b. ide b \\<and> seq b g}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {b. ide b \\<and> seq b (g \\<cdot> f)} = {b. ide b \\<and> seq b g}", "using assms ide_def match_2 match_4"], ["proof (prove)\nusing this:\n  seq g f\n  ide ?a \\<equiv>\n  ?a \\<cdot> ?a \\<noteq> null \\<and>\n  (\\<forall>f.\n      (f \\<cdot> ?a \\<noteq> null \\<longrightarrow> f \\<cdot> ?a = f) \\<and>\n      (?a \\<cdot> f \\<noteq> null \\<longrightarrow> ?a \\<cdot> f = f))\n  \\<lbrakk>seq ?h (?g \\<cdot> ?f); seq ?g ?f\\<rbrakk>\n  \\<Longrightarrow> seq ?h ?g\n  \\<lbrakk>seq ?g ?f; seq ?h ?g\\<rbrakk>\n  \\<Longrightarrow> seq ?h (?g \\<cdot> ?f)\n\ngoal (1 subgoal):\n 1. {b. ide b \\<and> seq b (g \\<cdot> f)} = {b. ide b \\<and> seq b g}", "by meson"], ["proof (state)\nthis:\n  {b. ide b \\<and> seq b (g \\<cdot> f)} = {b. ide b \\<and> seq b g}\n\ngoal (1 subgoal):\n 1. codomains (g \\<cdot> f) = codomains g", "also"], ["proof (state)\nthis:\n  {b. ide b \\<and> seq b (g \\<cdot> f)} = {b. ide b \\<and> seq b g}\n\ngoal (1 subgoal):\n 1. codomains (g \\<cdot> f) = codomains g", "have \"... = codomains g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {b. ide b \\<and> seq b g} = codomains g", "using codomains_def ext"], ["proof (prove)\nusing this:\n  codomains ?f \\<equiv> {b. ide b \\<and> b \\<cdot> ?f \\<noteq> null}\n  ?g \\<cdot> ?f \\<noteq> null \\<Longrightarrow> seq ?g ?f\n\ngoal (1 subgoal):\n 1. {b. ide b \\<and> seq b g} = codomains g", "by auto"], ["proof (state)\nthis:\n  {b. ide b \\<and> seq b g} = codomains g\n\ngoal (1 subgoal):\n 1. codomains (g \\<cdot> f) = codomains g", "finally"], ["proof (chain)\npicking this:\n  codomains (g \\<cdot> f) = codomains g", "show ?thesis"], ["proof (prove)\nusing this:\n  codomains (g \\<cdot> f) = codomains g\n\ngoal (1 subgoal):\n 1. codomains (g \\<cdot> f) = codomains g", "by blast"], ["proof (state)\nthis:\n  codomains (g \\<cdot> f) = codomains g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma has_domain_iff_arr:\n    shows \"domains f \\<noteq> {} \\<longleftrightarrow> arr f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (domains f \\<noteq> {}) = arr f", "by (simp add: arr_def has_domain_iff_has_codomain)"], ["", "lemma has_codomain_iff_arr:\n    shows \"codomains f \\<noteq> {} \\<longleftrightarrow> arr f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (codomains f \\<noteq> {}) = arr f", "using has_domain_iff_arr has_domain_iff_has_codomain"], ["proof (prove)\nusing this:\n  (domains ?f \\<noteq> {}) = arr ?f\n  (domains ?f \\<noteq> {}) = (codomains ?f \\<noteq> {})\n\ngoal (1 subgoal):\n 1. (codomains f \\<noteq> {}) = arr f", "by auto"], ["", "text\\<open>\n      A consequence of the category axioms is that domains and codomains, if they exist,\n      are unique.\n\\<close>"], ["", "lemma domain_unique:\n    assumes \"a \\<in> domains f\" and \"a' \\<in> domains f\"\n    shows \"a = a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = a'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. a = a'", "have \"ide a \\<and> seq f a \\<and> ide a' \\<and> seq f a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide a \\<and> seq f a \\<and> ide a' \\<and> seq f a'", "using assms domains_def ext"], ["proof (prove)\nusing this:\n  a \\<in> domains f\n  a' \\<in> domains f\n  domains ?f \\<equiv> {a. ide a \\<and> ?f \\<cdot> a \\<noteq> null}\n  ?g \\<cdot> ?f \\<noteq> null \\<Longrightarrow> seq ?g ?f\n\ngoal (1 subgoal):\n 1. ide a \\<and> seq f a \\<and> ide a' \\<and> seq f a'", "by force"], ["proof (state)\nthis:\n  ide a \\<and> seq f a \\<and> ide a' \\<and> seq f a'\n\ngoal (1 subgoal):\n 1. a = a'", "thus ?thesis"], ["proof (prove)\nusing this:\n  ide a \\<and> seq f a \\<and> ide a' \\<and> seq f a'\n\ngoal (1 subgoal):\n 1. a = a'", "using match_1 ide_def not_arr_null"], ["proof (prove)\nusing this:\n  ide a \\<and> seq f a \\<and> ide a' \\<and> seq f a'\n  \\<lbrakk>seq ?h ?g; seq (?h \\<cdot> ?g) ?f\\<rbrakk>\n  \\<Longrightarrow> seq ?g ?f\n  ide ?a \\<equiv>\n  ?a \\<cdot> ?a \\<noteq> null \\<and>\n  (\\<forall>f.\n      (f \\<cdot> ?a \\<noteq> null \\<longrightarrow> f \\<cdot> ?a = f) \\<and>\n      (?a \\<cdot> f \\<noteq> null \\<longrightarrow> ?a \\<cdot> f = f))\n  \\<not> arr null\n\ngoal (1 subgoal):\n 1. a = a'", "by metis"], ["proof (state)\nthis:\n  a = a'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma codomain_unique:\n    assumes \"b \\<in> codomains f\" and \"b' \\<in> codomains f\"\n    shows \"b = b'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b = b'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. b = b'", "have \"ide b \\<and> seq b f \\<and> ide b' \\<and> seq b' f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide b \\<and> seq b f \\<and> ide b' \\<and> seq b' f", "using assms codomains_def ext"], ["proof (prove)\nusing this:\n  b \\<in> codomains f\n  b' \\<in> codomains f\n  codomains ?f \\<equiv> {b. ide b \\<and> b \\<cdot> ?f \\<noteq> null}\n  ?g \\<cdot> ?f \\<noteq> null \\<Longrightarrow> seq ?g ?f\n\ngoal (1 subgoal):\n 1. ide b \\<and> seq b f \\<and> ide b' \\<and> seq b' f", "by force"], ["proof (state)\nthis:\n  ide b \\<and> seq b f \\<and> ide b' \\<and> seq b' f\n\ngoal (1 subgoal):\n 1. b = b'", "thus ?thesis"], ["proof (prove)\nusing this:\n  ide b \\<and> seq b f \\<and> ide b' \\<and> seq b' f\n\ngoal (1 subgoal):\n 1. b = b'", "using match_2 ide_def not_arr_null"], ["proof (prove)\nusing this:\n  ide b \\<and> seq b f \\<and> ide b' \\<and> seq b' f\n  \\<lbrakk>seq ?h (?g \\<cdot> ?f); seq ?g ?f\\<rbrakk>\n  \\<Longrightarrow> seq ?h ?g\n  ide ?a \\<equiv>\n  ?a \\<cdot> ?a \\<noteq> null \\<and>\n  (\\<forall>f.\n      (f \\<cdot> ?a \\<noteq> null \\<longrightarrow> f \\<cdot> ?a = f) \\<and>\n      (?a \\<cdot> f \\<noteq> null \\<longrightarrow> ?a \\<cdot> f = f))\n  \\<not> arr null\n\ngoal (1 subgoal):\n 1. b = b'", "by metis"], ["proof (state)\nthis:\n  b = b'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma domains_simp:\n    assumes \"arr f\"\n    shows \"domains f = {dom f}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domains f = {local.dom f}", "using assms dom_in_domains has_domain_iff_arr domain_unique"], ["proof (prove)\nusing this:\n  arr f\n  domains ?f \\<noteq> {} \\<Longrightarrow> local.dom ?f \\<in> domains ?f\n  (domains ?f \\<noteq> {}) = arr ?f\n  \\<lbrakk>?a \\<in> domains ?f; ?a' \\<in> domains ?f\\<rbrakk>\n  \\<Longrightarrow> ?a = ?a'\n\ngoal (1 subgoal):\n 1. domains f = {local.dom f}", "by auto"], ["", "lemma codomains_simp:\n    assumes \"arr f\"\n    shows \"codomains f = {cod f}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. codomains f = {cod f}", "using assms cod_in_codomains has_codomain_iff_arr codomain_unique"], ["proof (prove)\nusing this:\n  arr f\n  codomains ?f \\<noteq> {} \\<Longrightarrow> cod ?f \\<in> codomains ?f\n  (codomains ?f \\<noteq> {}) = arr ?f\n  \\<lbrakk>?b \\<in> codomains ?f; ?b' \\<in> codomains ?f\\<rbrakk>\n  \\<Longrightarrow> ?b = ?b'\n\ngoal (1 subgoal):\n 1. codomains f = {cod f}", "by auto"], ["", "lemma domains_char:\n    shows \"domains f = (if arr f then {dom f} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domains f = (if arr f then {local.dom f} else {})", "using dom_in_domains has_domain_iff_arr domain_unique"], ["proof (prove)\nusing this:\n  domains ?f \\<noteq> {} \\<Longrightarrow> local.dom ?f \\<in> domains ?f\n  (domains ?f \\<noteq> {}) = arr ?f\n  \\<lbrakk>?a \\<in> domains ?f; ?a' \\<in> domains ?f\\<rbrakk>\n  \\<Longrightarrow> ?a = ?a'\n\ngoal (1 subgoal):\n 1. domains f = (if arr f then {local.dom f} else {})", "by auto"], ["", "lemma codomains_char:\n    shows \"codomains f = (if arr f then {cod f} else {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. codomains f = (if arr f then {cod f} else {})", "using cod_in_codomains has_codomain_iff_arr codomain_unique"], ["proof (prove)\nusing this:\n  codomains ?f \\<noteq> {} \\<Longrightarrow> cod ?f \\<in> codomains ?f\n  (codomains ?f \\<noteq> {}) = arr ?f\n  \\<lbrakk>?b \\<in> codomains ?f; ?b' \\<in> codomains ?f\\<rbrakk>\n  \\<Longrightarrow> ?b = ?b'\n\ngoal (1 subgoal):\n 1. codomains f = (if arr f then {cod f} else {})", "by auto"], ["", "text\\<open>\n      A consequence of the following lemma is that the notion @{term \"arr\"} is redundant,\n      given @{term \"in_hom\"}, @{term \"dom\"}, and @{term \"cod\"}.  However, I have retained it\n      because I have not been able to find a set of usefully powerful simplification rules\n      expressed only in terms of @{term \"in_hom\"} that does not result in looping in many\n      situations.\n\\<close>"], ["", "lemma arr_iff_in_hom:\n    shows \"arr f \\<longleftrightarrow> \\<guillemotleft>f : dom f \\<rightarrow> cod f\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr f =\n    \\<guillemotleft>f : local.dom f \\<rightarrow> cod f\\<guillemotright>", "using cod_in_codomains dom_in_domains has_domain_iff_arr has_codomain_iff_arr in_hom_def"], ["proof (prove)\nusing this:\n  codomains ?f \\<noteq> {} \\<Longrightarrow> cod ?f \\<in> codomains ?f\n  domains ?f \\<noteq> {} \\<Longrightarrow> local.dom ?f \\<in> domains ?f\n  (domains ?f \\<noteq> {}) = arr ?f\n  (codomains ?f \\<noteq> {}) = arr ?f\n  \\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright> \\<equiv>\n  ?a \\<in> domains ?f \\<and> ?b \\<in> codomains ?f\n\ngoal (1 subgoal):\n 1. arr f =\n    \\<guillemotleft>f : local.dom f \\<rightarrow> cod f\\<guillemotright>", "by auto"], ["", "lemma in_homI [intro]:\n    assumes \"arr f\" and \"dom f = a\" and \"cod f = b\"\n    shows \"\\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>", "using assms cod_in_codomains dom_in_domains has_domain_iff_arr has_codomain_iff_arr\n            in_hom_def"], ["proof (prove)\nusing this:\n  arr f\n  local.dom f = a\n  cod f = b\n  codomains ?f \\<noteq> {} \\<Longrightarrow> cod ?f \\<in> codomains ?f\n  domains ?f \\<noteq> {} \\<Longrightarrow> local.dom ?f \\<in> domains ?f\n  (domains ?f \\<noteq> {}) = arr ?f\n  (codomains ?f \\<noteq> {}) = arr ?f\n  \\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright> \\<equiv>\n  ?a \\<in> domains ?f \\<and> ?b \\<in> codomains ?f\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>", "by auto"], ["", "lemma in_homE [elim]:\n    assumes \"\\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>\"\n    and \"arr f \\<Longrightarrow> dom f = a \\<Longrightarrow> cod f = b \\<Longrightarrow> T\"\n    shows \"T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T", "using assms in_hom_def domains_char codomains_char has_domain_iff_arr"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>\n  \\<lbrakk>arr f; local.dom f = a; cod f = b\\<rbrakk> \\<Longrightarrow> T\n  \\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright> \\<equiv>\n  ?a \\<in> domains ?f \\<and> ?b \\<in> codomains ?f\n  domains ?f = (if arr ?f then {local.dom ?f} else {})\n  codomains ?f = (if arr ?f then {cod ?f} else {})\n  (domains ?f \\<noteq> {}) = arr ?f\n\ngoal (1 subgoal):\n 1. T", "by (metis empty_iff singleton_iff)"], ["", "text\\<open>\n      To obtain the ``only if'' direction in the next two results and in similar results later\n      for composition and the application of functors and natural transformations,\n      is the reason for assuming the existence of @{term null} as a special element of the\n      arrow type, as opposed to, say, using option types to represent partiality.\n      The presence of @{term null} allows us not only to make the ``upward'' inference that\n      the domain of an arrow is again an arrow, but also to make the ``downward'' inference\n      that if @{term \"dom f\"} is an arrow then so is @{term f}.  Similarly, we will be able\n      to infer not only that if @{term f} and @{term g} are composable arrows then\n      @{term \"C g f\"} is an arrow, but also that if @{term \"C g f\"} is an arrow then\n      \\<open>f\\<close> and \\<open>g\\<close> are composable arrows.  These inferences allow most necessary\n      facts about what terms denote arrows to be deduced automatically from minimal\n      assumptions.  Typically all that is required is to assume or establish that certain\n      terms denote arrows in particular homs at the point where those terms are first\n      introduced, and then similar facts about related terms can be derived automatically.\n      Without this feature, nearly every proof would involve many tedious additional steps\n      to establish that each of the terms appearing in the proof (including all its subterms)\n      in fact denote arrows.\n\\<close>"], ["", "lemma arr_dom_iff_arr:\n    shows \"arr (dom f) \\<longleftrightarrow> arr f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (local.dom f) = arr f", "using dom_def dom_in_domains has_domain_iff_arr self_domain_iff_ide domains_def"], ["proof (prove)\nusing this:\n  local.dom ?f =\n  (if domains ?f \\<noteq> {} then SOME a. a \\<in> domains ?f else null)\n  domains ?f \\<noteq> {} \\<Longrightarrow> local.dom ?f \\<in> domains ?f\n  (domains ?f \\<noteq> {}) = arr ?f\n  (?a \\<in> domains ?a) = ide ?a\n  domains ?f \\<equiv> {a. ide a \\<and> ?f \\<cdot> a \\<noteq> null}\n\ngoal (1 subgoal):\n 1. arr (local.dom f) = arr f", "by fastforce"], ["", "lemma arr_cod_iff_arr:\n    shows \"arr (cod f) \\<longleftrightarrow> arr f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (cod f) = arr f", "using cod_def cod_in_codomains has_codomain_iff_arr self_codomain_iff_ide codomains_def"], ["proof (prove)\nusing this:\n  cod ?f =\n  (if codomains ?f \\<noteq> {} then SOME b. b \\<in> codomains ?f else null)\n  codomains ?f \\<noteq> {} \\<Longrightarrow> cod ?f \\<in> codomains ?f\n  (codomains ?f \\<noteq> {}) = arr ?f\n  (?a \\<in> codomains ?a) = ide ?a\n  codomains ?f \\<equiv> {b. ide b \\<and> b \\<cdot> ?f \\<noteq> null}\n\ngoal (1 subgoal):\n 1. arr (cod f) = arr f", "by fastforce"], ["", "lemma arr_dom [simp]:\n    assumes \"arr f\"\n    shows \"arr (dom f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (local.dom f)", "using assms arr_dom_iff_arr"], ["proof (prove)\nusing this:\n  arr f\n  arr (local.dom ?f) = arr ?f\n\ngoal (1 subgoal):\n 1. arr (local.dom f)", "by simp"], ["", "lemma arr_cod [simp]:\n    assumes \"arr f\"\n    shows \"arr (cod f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (cod f)", "using assms arr_cod_iff_arr"], ["proof (prove)\nusing this:\n  arr f\n  arr (cod ?f) = arr ?f\n\ngoal (1 subgoal):\n 1. arr (cod f)", "by simp"], ["", "lemma seqI [simp]:\n    assumes \"arr f\" and \"arr g\" and \"dom g = cod f\"\n    shows \"seq g f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq g f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. seq g f", "have \"ide (cod f) \\<and> seq (cod f) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide (cod f) \\<and> seq (cod f) f", "using assms(1) has_codomain_iff_arr codomains_def cod_in_codomains ext"], ["proof (prove)\nusing this:\n  arr f\n  (codomains ?f \\<noteq> {}) = arr ?f\n  codomains ?f \\<equiv> {b. ide b \\<and> b \\<cdot> ?f \\<noteq> null}\n  codomains ?f \\<noteq> {} \\<Longrightarrow> cod ?f \\<in> codomains ?f\n  ?g \\<cdot> ?f \\<noteq> null \\<Longrightarrow> seq ?g ?f\n\ngoal (1 subgoal):\n 1. ide (cod f) \\<and> seq (cod f) f", "by blast"], ["proof (state)\nthis:\n  ide (cod f) \\<and> seq (cod f) f\n\ngoal (1 subgoal):\n 1. seq g f", "moreover"], ["proof (state)\nthis:\n  ide (cod f) \\<and> seq (cod f) f\n\ngoal (1 subgoal):\n 1. seq g f", "have \"ide (cod f) \\<and> seq g (cod f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide (cod f) \\<and> seq g (cod f)", "using assms(2-3) domains_def domains_simp ext"], ["proof (prove)\nusing this:\n  arr g\n  local.dom g = cod f\n  domains ?f \\<equiv> {a. ide a \\<and> ?f \\<cdot> a \\<noteq> null}\n  arr ?f \\<Longrightarrow> domains ?f = {local.dom ?f}\n  ?g \\<cdot> ?f \\<noteq> null \\<Longrightarrow> seq ?g ?f\n\ngoal (1 subgoal):\n 1. ide (cod f) \\<and> seq g (cod f)", "by fastforce"], ["proof (state)\nthis:\n  ide (cod f) \\<and> seq g (cod f)\n\ngoal (1 subgoal):\n 1. seq g f", "ultimately"], ["proof (chain)\npicking this:\n  ide (cod f) \\<and> seq (cod f) f\n  ide (cod f) \\<and> seq g (cod f)", "show ?thesis"], ["proof (prove)\nusing this:\n  ide (cod f) \\<and> seq (cod f) f\n  ide (cod f) \\<and> seq g (cod f)\n\ngoal (1 subgoal):\n 1. seq g f", "using match_4 ide_def ext"], ["proof (prove)\nusing this:\n  ide (cod f) \\<and> seq (cod f) f\n  ide (cod f) \\<and> seq g (cod f)\n  \\<lbrakk>seq ?g ?f; seq ?h ?g\\<rbrakk>\n  \\<Longrightarrow> seq ?h (?g \\<cdot> ?f)\n  ide ?a \\<equiv>\n  ?a \\<cdot> ?a \\<noteq> null \\<and>\n  (\\<forall>f.\n      (f \\<cdot> ?a \\<noteq> null \\<longrightarrow> f \\<cdot> ?a = f) \\<and>\n      (?a \\<cdot> f \\<noteq> null \\<longrightarrow> ?a \\<cdot> f = f))\n  ?g \\<cdot> ?f \\<noteq> null \\<Longrightarrow> seq ?g ?f\n\ngoal (1 subgoal):\n 1. seq g f", "by metis"], ["proof (state)\nthis:\n  seq g f\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n      This version of \\<open>seqI\\<close> is useful as an introduction rule, but not as useful\n      as a simplification, because it requires finding the intermediary term \\<open>b\\<close>.\n      Sometimes \\emph{auto} is able to do this, but other times it is more expedient\n      just to invoke this rule and fill in the missing terms manually, especially\n      when dealing with a chain of compositions.\n    \\<close>"], ["", "lemma seqI' [intro]:\n    assumes \"\\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>\" and \"\\<guillemotleft>g : b \\<rightarrow> c\\<guillemotright>\"\n    shows \"seq g f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq g f", "using assms"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>\n  \\<guillemotleft>g : b \\<rightarrow> c\\<guillemotright>\n\ngoal (1 subgoal):\n 1. seq g f", "by fastforce"], ["", "lemma compatible_iff_seq:\n    shows \"domains g \\<inter> codomains f \\<noteq> {} \\<longleftrightarrow> seq g f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (domains g \\<inter> codomains f \\<noteq> {}) = seq g f", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. domains g \\<inter> codomains f \\<noteq> {} \\<Longrightarrow> seq g f\n 2. seq g f \\<Longrightarrow> domains g \\<inter> codomains f \\<noteq> {}", "show \"domains g \\<inter> codomains f \\<noteq> {} \\<Longrightarrow> seq g f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. domains g \\<inter> codomains f \\<noteq> {} \\<Longrightarrow> seq g f", "using cod_in_codomains dom_in_domains empty_iff has_domain_iff_arr has_codomain_iff_arr\n              domain_unique codomain_unique"], ["proof (prove)\nusing this:\n  codomains ?f \\<noteq> {} \\<Longrightarrow> cod ?f \\<in> codomains ?f\n  domains ?f \\<noteq> {} \\<Longrightarrow> local.dom ?f \\<in> domains ?f\n  (?c \\<in> {}) = False\n  (domains ?f \\<noteq> {}) = arr ?f\n  (codomains ?f \\<noteq> {}) = arr ?f\n  \\<lbrakk>?a \\<in> domains ?f; ?a' \\<in> domains ?f\\<rbrakk>\n  \\<Longrightarrow> ?a = ?a'\n  \\<lbrakk>?b \\<in> codomains ?f; ?b' \\<in> codomains ?f\\<rbrakk>\n  \\<Longrightarrow> ?b = ?b'\n\ngoal (1 subgoal):\n 1. domains g \\<inter> codomains f \\<noteq> {} \\<Longrightarrow> seq g f", "by (metis Int_emptyI seqI)"], ["proof (state)\nthis:\n  domains g \\<inter> codomains f \\<noteq> {} \\<Longrightarrow> seq g f\n\ngoal (1 subgoal):\n 1. seq g f \\<Longrightarrow> domains g \\<inter> codomains f \\<noteq> {}", "show \"seq g f \\<Longrightarrow> domains g \\<inter> codomains f \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq g f \\<Longrightarrow> domains g \\<inter> codomains f \\<noteq> {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. seq g f \\<Longrightarrow> domains g \\<inter> codomains f \\<noteq> {}", "assume gf: \"seq g f\""], ["proof (state)\nthis:\n  seq g f\n\ngoal (1 subgoal):\n 1. seq g f \\<Longrightarrow> domains g \\<inter> codomains f \\<noteq> {}", "have 1: \"cod f \\<in> codomains f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cod f \\<in> codomains f", "using gf has_domain_iff_arr domains_comp cod_in_codomains codomains_simp"], ["proof (prove)\nusing this:\n  seq g f\n  (domains ?f \\<noteq> {}) = arr ?f\n  seq ?g ?f \\<Longrightarrow> domains (?g \\<cdot> ?f) = domains ?f\n  codomains ?f \\<noteq> {} \\<Longrightarrow> cod ?f \\<in> codomains ?f\n  arr ?f \\<Longrightarrow> codomains ?f = {cod ?f}\n\ngoal (1 subgoal):\n 1. cod f \\<in> codomains f", "by blast"], ["proof (state)\nthis:\n  cod f \\<in> codomains f\n\ngoal (1 subgoal):\n 1. seq g f \\<Longrightarrow> domains g \\<inter> codomains f \\<noteq> {}", "have \"ide (cod f) \\<and> seq (cod f) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide (cod f) \\<and> seq (cod f) f", "using 1 codomains_def ext"], ["proof (prove)\nusing this:\n  cod f \\<in> codomains f\n  codomains ?f \\<equiv> {b. ide b \\<and> b \\<cdot> ?f \\<noteq> null}\n  ?g \\<cdot> ?f \\<noteq> null \\<Longrightarrow> seq ?g ?f\n\ngoal (1 subgoal):\n 1. ide (cod f) \\<and> seq (cod f) f", "by auto"], ["proof (state)\nthis:\n  ide (cod f) \\<and> seq (cod f) f\n\ngoal (1 subgoal):\n 1. seq g f \\<Longrightarrow> domains g \\<inter> codomains f \\<noteq> {}", "hence \"seq g (cod f)\""], ["proof (prove)\nusing this:\n  ide (cod f) \\<and> seq (cod f) f\n\ngoal (1 subgoal):\n 1. seq g (cod f)", "using gf has_domain_iff_arr match_2 domains_null ide_def"], ["proof (prove)\nusing this:\n  ide (cod f) \\<and> seq (cod f) f\n  seq g f\n  (domains ?f \\<noteq> {}) = arr ?f\n  \\<lbrakk>seq ?h (?g \\<cdot> ?f); seq ?g ?f\\<rbrakk>\n  \\<Longrightarrow> seq ?h ?g\n  domains null = {}\n  ide ?a \\<equiv>\n  ?a \\<cdot> ?a \\<noteq> null \\<and>\n  (\\<forall>f.\n      (f \\<cdot> ?a \\<noteq> null \\<longrightarrow> f \\<cdot> ?a = f) \\<and>\n      (?a \\<cdot> f \\<noteq> null \\<longrightarrow> ?a \\<cdot> f = f))\n\ngoal (1 subgoal):\n 1. seq g (cod f)", "by metis"], ["proof (state)\nthis:\n  seq g (cod f)\n\ngoal (1 subgoal):\n 1. seq g f \\<Longrightarrow> domains g \\<inter> codomains f \\<noteq> {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  seq g (cod f)\n\ngoal (1 subgoal):\n 1. domains g \\<inter> codomains f \\<noteq> {}", "using domains_def 1 codomains_def"], ["proof (prove)\nusing this:\n  seq g (cod f)\n  domains ?f \\<equiv> {a. ide a \\<and> ?f \\<cdot> a \\<noteq> null}\n  cod f \\<in> codomains f\n  codomains ?f \\<equiv> {b. ide b \\<and> b \\<cdot> ?f \\<noteq> null}\n\ngoal (1 subgoal):\n 1. domains g \\<inter> codomains f \\<noteq> {}", "by auto"], ["proof (state)\nthis:\n  domains g \\<inter> codomains f \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  seq g f \\<Longrightarrow> domains g \\<inter> codomains f \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n      The following is another example of a crucial ``downward'' rule that would not be possible\n      without a reserved @{term null} value.\n\\<close>"], ["", "lemma seqE [elim]:\n    assumes \"seq g f\"\n    and \"arr f \\<Longrightarrow> arr g \\<Longrightarrow> dom g = cod f \\<Longrightarrow> T\"\n    shows \"T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T", "using assms cod_in_codomains compatible_iff_seq has_domain_iff_arr has_codomain_iff_arr\n            domains_comp codomains_comp domains_char codomain_unique"], ["proof (prove)\nusing this:\n  seq g f\n  \\<lbrakk>arr f; arr g; local.dom g = cod f\\<rbrakk> \\<Longrightarrow> T\n  codomains ?f \\<noteq> {} \\<Longrightarrow> cod ?f \\<in> codomains ?f\n  (domains ?g \\<inter> codomains ?f \\<noteq> {}) = seq ?g ?f\n  (domains ?f \\<noteq> {}) = arr ?f\n  (codomains ?f \\<noteq> {}) = arr ?f\n  seq ?g ?f \\<Longrightarrow> domains (?g \\<cdot> ?f) = domains ?f\n  seq ?g ?f \\<Longrightarrow> codomains (?g \\<cdot> ?f) = codomains ?g\n  domains ?f = (if arr ?f then {local.dom ?f} else {})\n  \\<lbrakk>?b \\<in> codomains ?f; ?b' \\<in> codomains ?f\\<rbrakk>\n  \\<Longrightarrow> ?b = ?b'\n\ngoal (1 subgoal):\n 1. T", "by (metis Int_emptyI singletonD)"], ["", "lemma comp_in_homI [intro]:\n    assumes \"\\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>\" and \"\\<guillemotleft>g : b \\<rightarrow> c\\<guillemotright>\"\n    shows \"\\<guillemotleft>g \\<cdot> f : a \\<rightarrow> c\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>g \\<cdot> f : a \\<rightarrow> c\\<guillemotright>", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. seq g f\n 2. local.dom (g \\<cdot> f) = a\n 3. cod (g \\<cdot> f) = c", "show 1: \"seq g f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq g f", "using assms compatible_iff_seq"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>\n  \\<guillemotleft>g : b \\<rightarrow> c\\<guillemotright>\n  (domains ?g \\<inter> codomains ?f \\<noteq> {}) = seq ?g ?f\n\ngoal (1 subgoal):\n 1. seq g f", "by blast"], ["proof (state)\nthis:\n  seq g f\n\ngoal (2 subgoals):\n 1. local.dom (g \\<cdot> f) = a\n 2. cod (g \\<cdot> f) = c", "show \"dom (g \\<cdot> f) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dom (g \\<cdot> f) = a", "using assms 1 domains_comp domains_simp"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>\n  \\<guillemotleft>g : b \\<rightarrow> c\\<guillemotright>\n  seq g f\n  seq ?g ?f \\<Longrightarrow> domains (?g \\<cdot> ?f) = domains ?f\n  arr ?f \\<Longrightarrow> domains ?f = {local.dom ?f}\n\ngoal (1 subgoal):\n 1. local.dom (g \\<cdot> f) = a", "by blast"], ["proof (state)\nthis:\n  local.dom (g \\<cdot> f) = a\n\ngoal (1 subgoal):\n 1. cod (g \\<cdot> f) = c", "show \"cod (g \\<cdot> f) = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cod (g \\<cdot> f) = c", "using assms 1 codomains_comp codomains_simp"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>\n  \\<guillemotleft>g : b \\<rightarrow> c\\<guillemotright>\n  seq g f\n  seq ?g ?f \\<Longrightarrow> codomains (?g \\<cdot> ?f) = codomains ?g\n  arr ?f \\<Longrightarrow> codomains ?f = {cod ?f}\n\ngoal (1 subgoal):\n 1. cod (g \\<cdot> f) = c", "by blast"], ["proof (state)\nthis:\n  cod (g \\<cdot> f) = c\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma comp_in_homI' [simp]:\n    assumes \"arr f\" and \"arr g\" and \"dom f = a\" and \"cod g = c\" and \"dom g = cod f\"\n    shows \"\\<guillemotleft>g \\<cdot> f : a \\<rightarrow> c\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>g \\<cdot> f : a \\<rightarrow> c\\<guillemotright>", "using assms"], ["proof (prove)\nusing this:\n  arr f\n  arr g\n  local.dom f = a\n  cod g = c\n  local.dom g = cod f\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>g \\<cdot> f : a \\<rightarrow> c\\<guillemotright>", "by auto"], ["", "lemma comp_in_homE [elim]:\n    assumes \"\\<guillemotleft>g \\<cdot> f : a \\<rightarrow> c\\<guillemotright>\"\n    obtains b where \"\\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>\" and \"\\<guillemotleft>g : b \\<rightarrow> c\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>\\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>;\n         \\<guillemotleft>g : b \\<rightarrow> c\\<guillemotright>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms in_hom_def domains_comp codomains_comp"], ["proof (prove)\nusing this:\n  \\<guillemotleft>g \\<cdot> f : a \\<rightarrow> c\\<guillemotright>\n  \\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright> \\<equiv>\n  ?a \\<in> domains ?f \\<and> ?b \\<in> codomains ?f\n  seq ?g ?f \\<Longrightarrow> domains (?g \\<cdot> ?f) = domains ?f\n  seq ?g ?f \\<Longrightarrow> codomains (?g \\<cdot> ?f) = codomains ?g\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        \\<lbrakk>\\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>;\n         \\<guillemotleft>g : b \\<rightarrow> c\\<guillemotright>\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis arrI in_homI seqE)"], ["", "text \\<open>\n      The next two rules are useful as simplifications, but they slow down the\n      simplifier too much to use them by default.  So it is necessary to guess when\n      they are needed and cite them explicitly.  This is usually not too difficult.\n    \\<close>"], ["", "lemma comp_arr_dom:\n    assumes \"arr f\" and \"dom f = a\"\n    shows \"f \\<cdot> a = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<cdot> a = f", "using assms dom_in_domains has_domain_iff_arr domains_def ide_def"], ["proof (prove)\nusing this:\n  arr f\n  local.dom f = a\n  domains ?f \\<noteq> {} \\<Longrightarrow> local.dom ?f \\<in> domains ?f\n  (domains ?f \\<noteq> {}) = arr ?f\n  domains ?f \\<equiv> {a. ide a \\<and> ?f \\<cdot> a \\<noteq> null}\n  ide ?a \\<equiv>\n  ?a \\<cdot> ?a \\<noteq> null \\<and>\n  (\\<forall>f.\n      (f \\<cdot> ?a \\<noteq> null \\<longrightarrow> f \\<cdot> ?a = f) \\<and>\n      (?a \\<cdot> f \\<noteq> null \\<longrightarrow> ?a \\<cdot> f = f))\n\ngoal (1 subgoal):\n 1. f \\<cdot> a = f", "by auto"], ["", "lemma comp_cod_arr:\n    assumes \"arr f\" and \"cod f = b\"\n    shows \"b \\<cdot> f = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<cdot> f = f", "using assms cod_in_codomains has_codomain_iff_arr ide_def codomains_def"], ["proof (prove)\nusing this:\n  arr f\n  cod f = b\n  codomains ?f \\<noteq> {} \\<Longrightarrow> cod ?f \\<in> codomains ?f\n  (codomains ?f \\<noteq> {}) = arr ?f\n  ide ?a \\<equiv>\n  ?a \\<cdot> ?a \\<noteq> null \\<and>\n  (\\<forall>f.\n      (f \\<cdot> ?a \\<noteq> null \\<longrightarrow> f \\<cdot> ?a = f) \\<and>\n      (?a \\<cdot> f \\<noteq> null \\<longrightarrow> ?a \\<cdot> f = f))\n  codomains ?f \\<equiv> {b. ide b \\<and> b \\<cdot> ?f \\<noteq> null}\n\ngoal (1 subgoal):\n 1. b \\<cdot> f = f", "by auto"], ["", "lemma ide_char:\n    shows \"ide a \\<longleftrightarrow> arr a \\<and> dom a = a \\<and> cod a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide a = (arr a \\<and> local.dom a = a \\<and> cod a = a)", "using ide_in_hom"], ["proof (prove)\nusing this:\n  ide ?a = \\<guillemotleft>?a : ?a \\<rightarrow> ?a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. ide a = (arr a \\<and> local.dom a = a \\<and> cod a = a)", "by auto"], ["", "text \\<open>\n      In some contexts, this rule causes the simplifier to loop, but it is too useful\n      not to have as a default simplification.  In cases where it is a problem, usually\n      a method like \\emph{blast} or \\emph{force} will succeed if this rule is cited\n      explicitly.\n    \\<close>"], ["", "lemma ideD [simp]:\n    assumes \"ide a\"\n    shows \"arr a\" and \"dom a = a\" and \"cod a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr a &&& local.dom a = a &&& cod a = a", "using assms ide_char"], ["proof (prove)\nusing this:\n  ide a\n  ide ?a = (arr ?a \\<and> local.dom ?a = ?a \\<and> cod ?a = ?a)\n\ngoal (1 subgoal):\n 1. arr a &&& local.dom a = a &&& cod a = a", "by auto"], ["", "lemma ide_dom [simp]:\n    assumes \"arr f\"\n    shows \"ide (dom f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide (local.dom f)", "using assms dom_in_domains has_domain_iff_arr domains_def"], ["proof (prove)\nusing this:\n  arr f\n  domains ?f \\<noteq> {} \\<Longrightarrow> local.dom ?f \\<in> domains ?f\n  (domains ?f \\<noteq> {}) = arr ?f\n  domains ?f \\<equiv> {a. ide a \\<and> ?f \\<cdot> a \\<noteq> null}\n\ngoal (1 subgoal):\n 1. ide (local.dom f)", "by auto"], ["", "lemma ide_cod [simp]:\n    assumes \"arr f\"\n    shows \"ide (cod f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide (cod f)", "using assms cod_in_codomains has_codomain_iff_arr codomains_def"], ["proof (prove)\nusing this:\n  arr f\n  codomains ?f \\<noteq> {} \\<Longrightarrow> cod ?f \\<in> codomains ?f\n  (codomains ?f \\<noteq> {}) = arr ?f\n  codomains ?f \\<equiv> {b. ide b \\<and> b \\<cdot> ?f \\<noteq> null}\n\ngoal (1 subgoal):\n 1. ide (cod f)", "by auto"], ["", "lemma dom_eqI:\n    assumes \"ide a\" and \"seq f a\"\n    shows \"dom f = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dom f = a", "using assms cod_in_codomains codomain_unique ide_char"], ["proof (prove)\nusing this:\n  ide a\n  seq f a\n  codomains ?f \\<noteq> {} \\<Longrightarrow> cod ?f \\<in> codomains ?f\n  \\<lbrakk>?b \\<in> codomains ?f; ?b' \\<in> codomains ?f\\<rbrakk>\n  \\<Longrightarrow> ?b = ?b'\n  ide ?a = (arr ?a \\<and> local.dom ?a = ?a \\<and> cod ?a = ?a)\n\ngoal (1 subgoal):\n 1. local.dom f = a", "by (metis seqE)"], ["", "lemma cod_eqI:\n    assumes \"ide b\" and \"seq b f\"\n    shows \"cod f = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cod f = b", "using assms dom_in_domains domain_unique ide_char"], ["proof (prove)\nusing this:\n  ide b\n  seq b f\n  domains ?f \\<noteq> {} \\<Longrightarrow> local.dom ?f \\<in> domains ?f\n  \\<lbrakk>?a \\<in> domains ?f; ?a' \\<in> domains ?f\\<rbrakk>\n  \\<Longrightarrow> ?a = ?a'\n  ide ?a = (arr ?a \\<and> local.dom ?a = ?a \\<and> cod ?a = ?a)\n\ngoal (1 subgoal):\n 1. cod f = b", "by (metis seqE)"], ["", "lemma dom_eqI':\n    assumes \"a \\<in> domains f\"\n    shows \"a = dom f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = local.dom f", "using assms dom_in_domains domain_unique"], ["proof (prove)\nusing this:\n  a \\<in> domains f\n  domains ?f \\<noteq> {} \\<Longrightarrow> local.dom ?f \\<in> domains ?f\n  \\<lbrakk>?a \\<in> domains ?f; ?a' \\<in> domains ?f\\<rbrakk>\n  \\<Longrightarrow> ?a = ?a'\n\ngoal (1 subgoal):\n 1. a = local.dom f", "by blast"], ["", "lemma cod_eqI':\n    assumes \"a \\<in> codomains f\"\n    shows \"a = cod f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = cod f", "using assms cod_in_codomains codomain_unique"], ["proof (prove)\nusing this:\n  a \\<in> codomains f\n  codomains ?f \\<noteq> {} \\<Longrightarrow> cod ?f \\<in> codomains ?f\n  \\<lbrakk>?b \\<in> codomains ?f; ?b' \\<in> codomains ?f\\<rbrakk>\n  \\<Longrightarrow> ?b = ?b'\n\ngoal (1 subgoal):\n 1. a = cod f", "by blast"], ["", "lemma ide_char':\n    shows \"ide a \\<longleftrightarrow> arr a \\<and> (dom a = a \\<or> cod a = a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide a = (arr a \\<and> (local.dom a = a \\<or> cod a = a))", "using ide_dom ide_cod ide_char"], ["proof (prove)\nusing this:\n  arr ?f \\<Longrightarrow> ide (local.dom ?f)\n  arr ?f \\<Longrightarrow> ide (cod ?f)\n  ide ?a = (arr ?a \\<and> local.dom ?a = ?a \\<and> cod ?a = ?a)\n\ngoal (1 subgoal):\n 1. ide a = (arr a \\<and> (local.dom a = a \\<or> cod a = a))", "by metis"], ["", "lemma dom_dom:\n    assumes \"arr f\"\n    shows \"dom (dom f) = dom f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dom (local.dom f) = local.dom f", "using assms"], ["proof (prove)\nusing this:\n  arr f\n\ngoal (1 subgoal):\n 1. local.dom (local.dom f) = local.dom f", "by simp"], ["", "lemma cod_cod:\n    assumes \"arr f\"\n    shows \"cod (cod f) = cod f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cod (cod f) = cod f", "using assms"], ["proof (prove)\nusing this:\n  arr f\n\ngoal (1 subgoal):\n 1. cod (cod f) = cod f", "by simp"], ["", "lemma dom_cod:\n    assumes \"arr f\"\n    shows \"dom (cod f) = cod f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dom (cod f) = cod f", "using assms"], ["proof (prove)\nusing this:\n  arr f\n\ngoal (1 subgoal):\n 1. local.dom (cod f) = cod f", "by simp"], ["", "lemma cod_dom:\n    assumes \"arr f\"\n    shows \"cod (dom f) = dom f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cod (local.dom f) = local.dom f", "using assms"], ["proof (prove)\nusing this:\n  arr f\n\ngoal (1 subgoal):\n 1. cod (local.dom f) = local.dom f", "by simp"], ["", "lemma dom_comp [simp]:\n    assumes \"seq g f\"\n    shows \"dom (g \\<cdot> f) = dom f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dom (g \\<cdot> f) = local.dom f", "using assms"], ["proof (prove)\nusing this:\n  seq g f\n\ngoal (1 subgoal):\n 1. local.dom (g \\<cdot> f) = local.dom f", "by (simp add: dom_def domains_comp)"], ["", "lemma cod_comp [simp]:\n    assumes \"seq g f\"\n    shows \"cod (g \\<cdot> f) = cod g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cod (g \\<cdot> f) = cod g", "using assms"], ["proof (prove)\nusing this:\n  seq g f\n\ngoal (1 subgoal):\n 1. cod (g \\<cdot> f) = cod g", "by (simp add: cod_def codomains_comp)"], ["", "lemma comp_ide_self [simp]:\n    assumes \"ide a\"\n    shows \"a \\<cdot> a = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<cdot> a = a", "using assms comp_arr_ide arrI"], ["proof (prove)\nusing this:\n  ide a\n  \\<lbrakk>ide ?a; seq ?f ?a\\<rbrakk> \\<Longrightarrow> ?f \\<cdot> ?a = ?f\n  \\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright> \\<Longrightarrow>\n  arr ?f\n\ngoal (1 subgoal):\n 1. a \\<cdot> a = a", "by auto"], ["", "lemma ide_compE [elim]:\n    assumes \"ide (g \\<cdot> f)\"\n    and \"seq g f \\<Longrightarrow> seq f g \\<Longrightarrow> g \\<cdot> f = dom f \\<Longrightarrow> g \\<cdot> f = cod g \\<Longrightarrow> T\"\n    shows \"T\""], ["proof (prove)\ngoal (1 subgoal):\n 1. T", "using assms dom_comp cod_comp ide_char ide_in_hom"], ["proof (prove)\nusing this:\n  ide (g \\<cdot> f)\n  \\<lbrakk>seq g f; seq f g; g \\<cdot> f = local.dom f;\n   g \\<cdot> f = cod g\\<rbrakk>\n  \\<Longrightarrow> T\n  seq ?g ?f \\<Longrightarrow> local.dom (?g \\<cdot> ?f) = local.dom ?f\n  seq ?g ?f \\<Longrightarrow> cod (?g \\<cdot> ?f) = cod ?g\n  ide ?a = (arr ?a \\<and> local.dom ?a = ?a \\<and> cod ?a = ?a)\n  ide ?a = \\<guillemotleft>?a : ?a \\<rightarrow> ?a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. T", "by (metis seqE seqI)"], ["", "text \\<open>\n      The next two results are sometimes useful for performing manipulations at the\n      head of a chain of composed arrows.  I have adopted the convention that such\n      chains are canonically represented in right-associated form.  This makes it\n      easy to perform manipulations at the ``tail'' of a chain, but more difficult\n      to perform them at the ``head''.  These results take care of the rote manipulations\n      using associativity that are needed to either permute or combine arrows at the\n      head of a chain.\n\\<close>"], ["", "lemma comp_permute:\n    assumes \"f \\<cdot> g = k \\<cdot> l\" and \"seq f g\" and \"seq g h\"\n    shows \"f \\<cdot> g \\<cdot> h = k \\<cdot> l \\<cdot> h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<cdot> g \\<cdot> h = k \\<cdot> l \\<cdot> h", "using assms"], ["proof (prove)\nusing this:\n  f \\<cdot> g = k \\<cdot> l\n  seq f g\n  seq g h\n\ngoal (1 subgoal):\n 1. f \\<cdot> g \\<cdot> h = k \\<cdot> l \\<cdot> h", "by (metis comp_assoc)"], ["", "lemma comp_reduce:\n    assumes \"f \\<cdot> g = k\" and \"seq f g\" and \"seq g h\"\n    shows \"f \\<cdot> g \\<cdot> h = k \\<cdot> h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<cdot> g \\<cdot> h = k \\<cdot> h", "using assms comp_assoc"], ["proof (prove)\nusing this:\n  f \\<cdot> g = k\n  seq f g\n  seq g h\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. f \\<cdot> g \\<cdot> h = k \\<cdot> h", "by auto"], ["", "text\\<open>\n      Here we define some common configurations of arrows.\n      These are defined as abbreviations, because we want all ``diagrammatic'' assumptions\n      in a theorem to reduce readily to a conjunction of assertions of the basic forms\n      @{term \"arr f\"}, @{term \"dom f = X\"}, @{term \"cod f = Y\"}, and @{term \"in_hom f a b\"}.\n\\<close>"], ["", "abbreviation endo\n    where \"endo f \\<equiv> seq f f\""], ["", "abbreviation antipar\n    where \"antipar f g \\<equiv> seq g f \\<and> seq f g\""], ["", "abbreviation span\n    where \"span f g \\<equiv> arr f \\<and> arr g \\<and> dom f = dom g\""], ["", "abbreviation cospan\n    where \"cospan f g \\<equiv> arr f \\<and> arr g \\<and> cod f = cod g\""], ["", "abbreviation par\n    where \"par f g \\<equiv> arr f \\<and> arr g \\<and> dom f = dom g \\<and> cod f = cod g\""], ["", "end"], ["", "end"]]}