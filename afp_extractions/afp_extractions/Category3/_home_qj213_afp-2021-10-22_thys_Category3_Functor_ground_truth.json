{"file_name": "/home/qj213/afp-2021-10-22/thys/Category3/Functor.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Category3", "problem_names": ["lemma preserves_hom [intro]:\n    assumes \"\\<guillemotleft>f : a \\<rightarrow>\\<^sub>A b\\<guillemotright>\"\n    shows \"\\<guillemotleft>F f : F a \\<rightarrow>\\<^sub>B F b\\<guillemotright>\"", "lemma preserves_reflects_arr [iff]:\n    shows \"B.arr (F f) \\<longleftrightarrow> A.arr f\"", "lemma preserves_seq [intro]:\n    assumes \"A.seq g f\"\n    shows \"B.seq (F g) (F f)\"", "lemma preserves_ide [simp]:\n    assumes \"A.ide a\"\n    shows \"B.ide (F a)\"", "lemma preserves_iso [simp]:\n    assumes \"A.iso f\"\n    shows \"B.iso (F f)\"", "lemma preserves_section_retraction:\n    assumes \"A.ide (A e m)\"\n    shows \"B.ide (B (F e) (F m))\"", "lemma preserves_section:\n    assumes \"A.section m\"\n    shows \"B.section (F m)\"", "lemma preserves_retraction:\n    assumes \"A.retraction e\"\n    shows \"B.retraction (F e)\"", "lemma preserves_inverse_arrows:\n    assumes \"A.inverse_arrows f g\"\n    shows \"B.inverse_arrows (F f) (F g)\"", "lemma preserves_inv:\n    assumes \"A.iso f\"\n    shows \"F (A.inv f) = B.inv (F f)\"", "lemma preserves_iso_in_hom [intro]:\n    assumes \"A.iso_in_hom f a b\"\n    shows \"B.iso_in_hom (F f) (F a) (F b)\"", "lemma locally_reflects_ide:\n    assumes \"\\<guillemotleft>f : a \\<rightarrow>\\<^sub>A a\\<guillemotright>\" and \"B.ide (F f)\"\n    shows \"A.ide f\"", "lemma reflects_iso:\n    assumes \"\\<guillemotleft>f : a' \\<rightarrow>\\<^sub>A a\\<guillemotright>\" and \"B.iso (F f)\"\n    shows \"A.iso f\"", "lemma reflects_isomorphic:\n    assumes \"A.ide f\" and \"A.ide f'\" and \"B.isomorphic (F f) (F f')\"\n    shows \"A.isomorphic f f'\"", "lemma reflects_ide:\n    assumes \"B.ide (F f)\"\n    shows \"A.ide f\"", "lemma map_simp [simp]:\n    assumes \"A.arr f\"\n    shows \"map f = b\"", "lemma is_functor:\n    shows \"functor A B map\"", "lemma map_simp [simp]:\n    assumes \"C.arr f\"\n    shows \"map f = f\"", "lemma is_functor:\n    shows \"functor C C map\"", "lemma functor_comp:\n  assumes \"functor A B F\" and \"functor B C G\"\n  shows \"functor A C (G o F)\"", "lemma comp_functor_identity [simp]:\n  assumes \"functor A B F\"\n  shows \"F o identity_functor.map A = F\"", "lemma comp_identity_functor [simp]:\n  assumes \"functor A B F\"\n  shows \"identity_functor.map B o F = F\"", "lemma faithful_functors_compose:\n  assumes \"faithful_functor A B F\" and \"faithful_functor B C G\"\n  shows \"faithful_functor A C (G o F)\"", "lemma full_functors_compose:\n  assumes \"full_functor A B F\" and \"full_functor B C G\"\n  shows \"full_functor A C (G o F)\"", "lemma fully_faithful_functors_compose:\n  assumes \"fully_faithful_functor A B F\" and \"fully_faithful_functor B C G\"\n  shows \"full_functor A C (G o F)\"", "lemma embedding_functors_compose:\n  assumes \"embedding_functor A B F\" and \"embedding_functor B C G\"\n  shows \"embedding_functor A C (G o F)\"", "lemma full_embedding_functors_compose:\n  assumes \"full_embedding_functor A B F\" and \"full_embedding_functor B C G\"\n  shows \"full_embedding_functor A C (G o F)\"", "lemma essentially_surjective_functors_compose:\n  assumes \"essentially_surjective_functor A B F\" and \"essentially_surjective_functor B C G\"\n  shows \"essentially_surjective_functor A C (G o F)\"", "lemma bij_betw_arr_sets:\n    shows \"bij_betw F (Collect B.arr) (Collect A.arr)\"", "lemma inverse_functors_sym:\n  assumes \"inverse_functors A B F G\"\n  shows \"inverse_functors B A G F\"", "lemma inverse_functor_unique:\n  assumes \"inverse_functors C D F G\" and \"inverse_functors C D F G'\"\n  shows \"G = G'\"", "lemma inverse_functor_unique':\n  assumes \"inverse_functors C D F G\" and \"inverse_functors C D F' G\"\n  shows \"F = F'\"", "lemma has_unique_inverse:\n    shows \"\\<exists>!F. inverse_functors A B F G\"", "lemma inv_is_inverse:\n    shows \"inverse_functors A B inv G\"", "lemma preserves_terminal:\n    assumes \"A.terminal a\"\n    shows \"B.terminal (G a)\"", "lemma bij_induces_invertible_functor:\n    assumes \"bij_betw \\<phi> S (Collect arr)\" and \"n \\<notin> S\"\n    shows \"\\<exists>C'. Collect (partial_magma.arr C') = S \\<and>\n                invertible_functor C' C (\\<lambda>i. if partial_magma.arr C' i then \\<phi> i else null)\"", "theorem is_isomorphic_to_concrete_category:\n    shows \"isomorphic_categories C CC.COMP\"", "lemma map_simp [simp]:\n    shows \"map f = F f\"", "lemma is_functor:\n    shows \"functor Aop.comp Bop.comp map\""], "translations": [["", "lemma preserves_hom [intro]:\n    assumes \"\\<guillemotleft>f : a \\<rightarrow>\\<^sub>A b\\<guillemotright>\"\n    shows \"\\<guillemotleft>F f : F a \\<rightarrow>\\<^sub>B F b\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>F f : F a \\<rightarrow>\\<^sub>B F b\\<guillemotright>", "using assms B.in_homI"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f : a \\<rightarrow>\\<^sub>A b\\<guillemotright>\n  \\<lbrakk>B.arr ?f; B.dom ?f = ?a; B.cod ?f = ?b\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>?f : ?a \\<rightarrow>\\<^sub>B ?b\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>F f : F a \\<rightarrow>\\<^sub>B F b\\<guillemotright>", "by (metis A.in_homE preserves_arr preserves_cod preserves_dom)"], ["", "text\\<open>\n      The following, which is made possible through the presence of \\<open>null\\<close>,\n      allows us to infer that the subterm @{term f} denotes an arrow if the\n      term @{term \"F f\"} denotes an arrow.  This is very useful, because otherwise\n      doing anything with @{term f} would require a separate proof that it is an arrow\n      by some other means.\n\\<close>"], ["", "lemma preserves_reflects_arr [iff]:\n    shows \"B.arr (F f) \\<longleftrightarrow> A.arr f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B.arr (F f) = A.arr f", "using preserves_arr is_extensional B.not_arr_null"], ["proof (prove)\nusing this:\n  A.arr ?f \\<Longrightarrow> B.arr (F ?f)\n  \\<not> A.arr ?f \\<Longrightarrow> F ?f = B.null\n  \\<not> B.arr B.null\n\ngoal (1 subgoal):\n 1. B.arr (F f) = A.arr f", "by metis"], ["", "lemma preserves_seq [intro]:\n    assumes \"A.seq g f\"\n    shows \"B.seq (F g) (F f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B.seq (F g) (F f)", "using assms"], ["proof (prove)\nusing this:\n  A.seq g f\n\ngoal (1 subgoal):\n 1. B.seq (F g) (F f)", "by auto"], ["", "lemma preserves_ide [simp]:\n    assumes \"A.ide a\"\n    shows \"B.ide (F a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B.ide (F a)", "using assms A.ide_in_hom B.ide_in_hom"], ["proof (prove)\nusing this:\n  A.ide a\n  A.ide ?a =\n  \\<guillemotleft>?a : ?a \\<rightarrow>\\<^sub>A ?a\\<guillemotright>\n  B.ide ?a =\n  \\<guillemotleft>?a : ?a \\<rightarrow>\\<^sub>B ?a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. B.ide (F a)", "by auto"], ["", "lemma preserves_iso [simp]:\n    assumes \"A.iso f\"\n    shows \"B.iso (F f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B.iso (F f)", "using assms A.inverse_arrowsE"], ["proof (prove)\nusing this:\n  A.iso f\n  \\<lbrakk>A.inverse_arrows ?f ?g;\n   \\<lbrakk>A.ide (?g \\<cdot>\\<^sub>A ?f);\n    A.ide (?f \\<cdot>\\<^sub>A ?g)\\<rbrakk>\n   \\<Longrightarrow> ?T\\<rbrakk>\n  \\<Longrightarrow> ?T\n\ngoal (1 subgoal):\n 1. B.iso (F f)", "apply (elim A.isoE A.inverse_arrowsE A.seqE A.ide_compE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g.\n       \\<lbrakk>\\<And>f g T.\n                   \\<lbrakk>A.inverse_arrows f g;\n                    \\<lbrakk>A.ide (g \\<cdot>\\<^sub>A f);\n                     A.ide (f \\<cdot>\\<^sub>A g)\\<rbrakk>\n                    \\<Longrightarrow> T\\<rbrakk>\n                   \\<Longrightarrow> T;\n        g \\<cdot>\\<^sub>A f = A.dom f; g \\<cdot>\\<^sub>A f = A.cod g;\n        A.arr f; A.arr g; A.dom g = A.cod f; A.arr g; A.arr f;\n        A.dom f = A.cod g; f \\<cdot>\\<^sub>A g = A.dom g;\n        f \\<cdot>\\<^sub>A g = A.cod f; A.arr g; A.arr f; A.dom f = A.cod g;\n        A.arr f; A.arr g; A.dom g = A.cod f\\<rbrakk>\n       \\<Longrightarrow> B.iso (F f)", "by (metis A.arr_dom_iff_arr B.ide_dom B.inverse_arrows_def B.isoI preserves_arr\n                preserves_comp preserves_dom)"], ["", "lemma preserves_section_retraction:\n    assumes \"A.ide (A e m)\"\n    shows \"B.ide (B (F e) (F m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B.ide (F e \\<cdot>\\<^sub>B F m)", "using assms"], ["proof (prove)\nusing this:\n  A.ide (e \\<cdot>\\<^sub>A m)\n\ngoal (1 subgoal):\n 1. B.ide (F e \\<cdot>\\<^sub>B F m)", "by (metis A.ide_compE preserves_comp preserves_ide)"], ["", "lemma preserves_section:\n    assumes \"A.section m\"\n    shows \"B.section (F m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B.section (F m)", "using assms preserves_section_retraction"], ["proof (prove)\nusing this:\n  A.section m\n  A.ide (?e \\<cdot>\\<^sub>A ?m) \\<Longrightarrow>\n  B.ide (F ?e \\<cdot>\\<^sub>B F ?m)\n\ngoal (1 subgoal):\n 1. B.section (F m)", "by blast"], ["", "lemma preserves_retraction:\n    assumes \"A.retraction e\"\n    shows \"B.retraction (F e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B.retraction (F e)", "using assms preserves_section_retraction"], ["proof (prove)\nusing this:\n  A.retraction e\n  A.ide (?e \\<cdot>\\<^sub>A ?m) \\<Longrightarrow>\n  B.ide (F ?e \\<cdot>\\<^sub>B F ?m)\n\ngoal (1 subgoal):\n 1. B.retraction (F e)", "by blast"], ["", "lemma preserves_inverse_arrows:\n    assumes \"A.inverse_arrows f g\"\n    shows \"B.inverse_arrows (F f) (F g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B.inverse_arrows (F f) (F g)", "using assms A.inverse_arrows_def B.inverse_arrows_def preserves_section_retraction"], ["proof (prove)\nusing this:\n  A.inverse_arrows f g\n  A.inverse_arrows ?f ?g \\<equiv>\n  A.ide (?g \\<cdot>\\<^sub>A ?f) \\<and> A.ide (?f \\<cdot>\\<^sub>A ?g)\n  B.inverse_arrows ?f ?g \\<equiv>\n  B.ide (?g \\<cdot>\\<^sub>B ?f) \\<and> B.ide (?f \\<cdot>\\<^sub>B ?g)\n  A.ide (?e \\<cdot>\\<^sub>A ?m) \\<Longrightarrow>\n  B.ide (F ?e \\<cdot>\\<^sub>B F ?m)\n\ngoal (1 subgoal):\n 1. B.inverse_arrows (F f) (F g)", "by simp"], ["", "lemma preserves_inv:\n    assumes \"A.iso f\"\n    shows \"F (A.inv f) = B.inv (F f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F (A.inv f) = B.inv (F f)", "using assms preserves_inverse_arrows A.inv_is_inverse B.inv_is_inverse\n            B.inverse_arrow_unique"], ["proof (prove)\nusing this:\n  A.iso f\n  A.inverse_arrows ?f ?g \\<Longrightarrow> B.inverse_arrows (F ?f) (F ?g)\n  A.iso ?f \\<Longrightarrow> A.inverse_arrows ?f (A.inv ?f)\n  B.iso ?f \\<Longrightarrow> B.inverse_arrows ?f (B.inv ?f)\n  \\<lbrakk>B.inverse_arrows ?f ?g; B.inverse_arrows ?f ?g'\\<rbrakk>\n  \\<Longrightarrow> ?g = ?g'\n\ngoal (1 subgoal):\n 1. F (A.inv f) = B.inv (F f)", "by blast"], ["", "lemma preserves_iso_in_hom [intro]:\n    assumes \"A.iso_in_hom f a b\"\n    shows \"B.iso_in_hom (F f) (F a) (F b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B.iso_in_hom (F f) (F a) (F b)", "using assms preserves_hom preserves_iso"], ["proof (prove)\nusing this:\n  A.iso_in_hom f a b\n  \\<guillemotleft>?f : ?a \\<rightarrow>\\<^sub>A ?b\\<guillemotright> \\<Longrightarrow>\n  \\<guillemotleft>F ?f : F ?a \\<rightarrow>\\<^sub>B F ?b\\<guillemotright>\n  A.iso ?f \\<Longrightarrow> B.iso (F ?f)\n\ngoal (1 subgoal):\n 1. B.iso_in_hom (F f) (F a) (F b)", "by blast"], ["", "end"], ["", "locale endofunctor =\n    \"functor\" A A F\n  for A :: \"'a comp\"     (infixr \"\\<cdot>\" 55)\n  and F :: \"'a \\<Rightarrow> 'a\""], ["", "locale faithful_functor = \"functor\" A B F\n  for A :: \"'a comp\"\n  and B :: \"'b comp\"\n  and F :: \"'a \\<Rightarrow> 'b\" +\n  assumes is_faithful: \"\\<lbrakk> A.par f f'; F f = F f' \\<rbrakk> \\<Longrightarrow> f = f'\"\n  begin"], ["", "lemma locally_reflects_ide:\n    assumes \"\\<guillemotleft>f : a \\<rightarrow>\\<^sub>A a\\<guillemotright>\" and \"B.ide (F f)\"\n    shows \"A.ide f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A.ide f", "using assms is_faithful"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f : a \\<rightarrow>\\<^sub>A a\\<guillemotright>\n  B.ide (F f)\n  \\<lbrakk>A.par ?f ?f'; F ?f = F ?f'\\<rbrakk> \\<Longrightarrow> ?f = ?f'\n\ngoal (1 subgoal):\n 1. A.ide f", "by (metis A.arr_dom_iff_arr A.cod_dom A.dom_dom A.in_homE B.comp_ide_self\n          B.ide_self_inverse B.comp_arr_inv A.ide_cod preserves_dom)"], ["", "end"], ["", "locale full_functor = \"functor\" A B F\n  for A :: \"'a comp\"\n  and B :: \"'b comp\"\n  and F :: \"'a \\<Rightarrow> 'b\" +\n  assumes is_full: \"\\<lbrakk> A.ide a; A.ide a'; \\<guillemotleft>g : F a' \\<rightarrow>\\<^sub>B F a\\<guillemotright> \\<rbrakk> \\<Longrightarrow> \\<exists>f. \\<guillemotleft>f : a' \\<rightarrow>\\<^sub>A a\\<guillemotright> \\<and> F f = g\""], ["", "locale fully_faithful_functor =\n    faithful_functor A B F +\n    full_functor A B F\n  for A :: \"'a comp\"\n  and B :: \"'b comp\"\n  and F :: \"'a \\<Rightarrow> 'b\"\n  begin"], ["", "lemma reflects_iso:\n    assumes \"\\<guillemotleft>f : a' \\<rightarrow>\\<^sub>A a\\<guillemotright>\" and \"B.iso (F f)\"\n    shows \"A.iso f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A.iso f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A.iso f", "from assms"], ["proof (chain)\npicking this:\n  \\<guillemotleft>f : a' \\<rightarrow>\\<^sub>A a\\<guillemotright>\n  B.iso (F f)", "obtain g' where g': \"B.inverse_arrows (F f) g'\""], ["proof (prove)\nusing this:\n  \\<guillemotleft>f : a' \\<rightarrow>\\<^sub>A a\\<guillemotright>\n  B.iso (F f)\n\ngoal (1 subgoal):\n 1. (\\<And>g'.\n        B.inverse_arrows (F f) g' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  B.inverse_arrows (F f) g'\n\ngoal (1 subgoal):\n 1. A.iso f", "have 1: \"\\<guillemotleft>g' : F a \\<rightarrow>\\<^sub>B F a'\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>g' : F a \\<rightarrow>\\<^sub>B F a'\\<guillemotright>", "using assms g'"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f : a' \\<rightarrow>\\<^sub>A a\\<guillemotright>\n  B.iso (F f)\n  B.inverse_arrows (F f) g'\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>g' : F a \\<rightarrow>\\<^sub>B F a'\\<guillemotright>", "by (metis B.inv_in_hom B.inverse_unique preserves_hom)"], ["proof (state)\nthis:\n  \\<guillemotleft>g' : F a \\<rightarrow>\\<^sub>B F a'\\<guillemotright>\n\ngoal (1 subgoal):\n 1. A.iso f", "from this"], ["proof (chain)\npicking this:\n  \\<guillemotleft>g' : F a \\<rightarrow>\\<^sub>B F a'\\<guillemotright>", "obtain g where g: \"\\<guillemotleft>g : a \\<rightarrow>\\<^sub>A a'\\<guillemotright> \\<and> F g = g'\""], ["proof (prove)\nusing this:\n  \\<guillemotleft>g' : F a \\<rightarrow>\\<^sub>B F a'\\<guillemotright>\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<guillemotleft>g : a \\<rightarrow>\\<^sub>A a'\\<guillemotright> \\<and>\n        F g = g' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms(1) is_full"], ["proof (prove)\nusing this:\n  \\<guillemotleft>g' : F a \\<rightarrow>\\<^sub>B F a'\\<guillemotright>\n  \\<guillemotleft>f : a' \\<rightarrow>\\<^sub>A a\\<guillemotright>\n  \\<lbrakk>A.ide ?a; A.ide ?a';\n   \\<guillemotleft>?g : F ?a' \\<rightarrow>\\<^sub>B F\n               ?a\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>f.\n                       \\<guillemotleft>f : ?a' \\<rightarrow>\\<^sub>A ?a\\<guillemotright> \\<and>\n                       F f = ?g\n\ngoal (1 subgoal):\n 1. (\\<And>g.\n        \\<guillemotleft>g : a \\<rightarrow>\\<^sub>A a'\\<guillemotright> \\<and>\n        F g = g' \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (metis A.arrI A.ide_cod A.ide_dom A.in_homE)"], ["proof (state)\nthis:\n  \\<guillemotleft>g : a \\<rightarrow>\\<^sub>A a'\\<guillemotright> \\<and>\n  F g = g'\n\ngoal (1 subgoal):\n 1. A.iso f", "have \"A.inverse_arrows f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A.inverse_arrows f g", "using assms 1 g g' A.inverse_arrowsI"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f : a' \\<rightarrow>\\<^sub>A a\\<guillemotright>\n  B.iso (F f)\n  \\<guillemotleft>g' : F a \\<rightarrow>\\<^sub>B F a'\\<guillemotright>\n  \\<guillemotleft>g : a \\<rightarrow>\\<^sub>A a'\\<guillemotright> \\<and>\n  F g = g'\n  B.inverse_arrows (F f) g'\n  \\<lbrakk>A.ide (A ?g ?f); A.ide (A ?f ?g)\\<rbrakk>\n  \\<Longrightarrow> A.inverse_arrows ?f ?g\n\ngoal (1 subgoal):\n 1. A.inverse_arrows f g", "by (metis A.arr_iff_in_hom A.dom_comp A.in_homE A.seqI' B.inverse_arrowsE\n            A.cod_comp locally_reflects_ide preserves_comp)"], ["proof (state)\nthis:\n  A.inverse_arrows f g\n\ngoal (1 subgoal):\n 1. A.iso f", "thus ?thesis"], ["proof (prove)\nusing this:\n  A.inverse_arrows f g\n\ngoal (1 subgoal):\n 1. A.iso f", "by auto"], ["proof (state)\nthis:\n  A.iso f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma reflects_isomorphic:\n    assumes \"A.ide f\" and \"A.ide f'\" and \"B.isomorphic (F f) (F f')\"\n    shows \"A.isomorphic f f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A.isomorphic f f'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. A.isomorphic f f'", "obtain \\<psi> where \\<psi>: \"B.in_hom \\<psi> (F f) (F f') \\<and> B.iso \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<psi>.\n        \\<guillemotleft>\\<psi> : F f \\<rightarrow>\\<^sub>B F\n                      f'\\<guillemotright> \\<and>\n        B.iso \\<psi> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms B.isomorphic_def"], ["proof (prove)\nusing this:\n  A.ide f\n  A.ide f'\n  B.isomorphic (F f) (F f')\n  B.isomorphic ?a ?a' =\n  (\\<exists>f.\n      \\<guillemotleft>f : ?a \\<rightarrow>\\<^sub>B ?a'\\<guillemotright> \\<and>\n      B.iso f)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<psi>.\n        \\<guillemotleft>\\<psi> : F f \\<rightarrow>\\<^sub>B F\n                      f'\\<guillemotright> \\<and>\n        B.iso \\<psi> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  \\<guillemotleft>\\<psi> : F f \\<rightarrow>\\<^sub>B F\n                f'\\<guillemotright> \\<and>\n  B.iso \\<psi>\n\ngoal (1 subgoal):\n 1. A.isomorphic f f'", "obtain \\<phi> where \\<phi>: \"A.in_hom \\<phi> f f' \\<and> F \\<phi> = \\<psi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<phi>.\n        \\<guillemotleft>\\<phi> : f \\<rightarrow>\\<^sub>A f'\\<guillemotright> \\<and>\n        F \\<phi> = \\<psi> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms \\<psi> is_full"], ["proof (prove)\nusing this:\n  A.ide f\n  A.ide f'\n  B.isomorphic (F f) (F f')\n  \\<guillemotleft>\\<psi> : F f \\<rightarrow>\\<^sub>B F\n                f'\\<guillemotright> \\<and>\n  B.iso \\<psi>\n  \\<lbrakk>A.ide ?a; A.ide ?a';\n   \\<guillemotleft>?g : F ?a' \\<rightarrow>\\<^sub>B F\n               ?a\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>f.\n                       \\<guillemotleft>f : ?a' \\<rightarrow>\\<^sub>A ?a\\<guillemotright> \\<and>\n                       F f = ?g\n\ngoal (1 subgoal):\n 1. (\\<And>\\<phi>.\n        \\<guillemotleft>\\<phi> : f \\<rightarrow>\\<^sub>A f'\\<guillemotright> \\<and>\n        F \\<phi> = \\<psi> \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<guillemotleft>\\<phi> : f \\<rightarrow>\\<^sub>A f'\\<guillemotright> \\<and>\n  F \\<phi> = \\<psi>\n\ngoal (1 subgoal):\n 1. A.isomorphic f f'", "have \"A.iso \\<phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A.iso \\<phi>", "using \\<phi> \\<psi> reflects_iso"], ["proof (prove)\nusing this:\n  \\<guillemotleft>\\<phi> : f \\<rightarrow>\\<^sub>A f'\\<guillemotright> \\<and>\n  F \\<phi> = \\<psi>\n  \\<guillemotleft>\\<psi> : F f \\<rightarrow>\\<^sub>B F\n                f'\\<guillemotright> \\<and>\n  B.iso \\<psi>\n  \\<lbrakk>\\<guillemotleft>?f : ?a' \\<rightarrow>\\<^sub>A ?a\\<guillemotright>;\n   B.iso (F ?f)\\<rbrakk>\n  \\<Longrightarrow> A.iso ?f\n\ngoal (1 subgoal):\n 1. A.iso \\<phi>", "by auto"], ["proof (state)\nthis:\n  A.iso \\<phi>\n\ngoal (1 subgoal):\n 1. A.isomorphic f f'", "thus ?thesis"], ["proof (prove)\nusing this:\n  A.iso \\<phi>\n\ngoal (1 subgoal):\n 1. A.isomorphic f f'", "using \\<phi> A.isomorphic_def"], ["proof (prove)\nusing this:\n  A.iso \\<phi>\n  \\<guillemotleft>\\<phi> : f \\<rightarrow>\\<^sub>A f'\\<guillemotright> \\<and>\n  F \\<phi> = \\<psi>\n  A.isomorphic ?a ?a' =\n  (\\<exists>f.\n      \\<guillemotleft>f : ?a \\<rightarrow>\\<^sub>A ?a'\\<guillemotright> \\<and>\n      A.iso f)\n\ngoal (1 subgoal):\n 1. A.isomorphic f f'", "by auto"], ["proof (state)\nthis:\n  A.isomorphic f f'\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale embedding_functor = \"functor\" A B F\n  for A :: \"'a comp\"\n  and B :: \"'b comp\"\n  and F :: \"'a \\<Rightarrow> 'b\" +\n  assumes is_embedding: \"\\<lbrakk> A.arr f; A.arr f'; F f = F f' \\<rbrakk> \\<Longrightarrow> f = f'\""], ["", "sublocale embedding_functor \\<subseteq> faithful_functor"], ["proof (prove)\ngoal (1 subgoal):\n 1. faithful_functor A B F", "using is_embedding"], ["proof (prove)\nusing this:\n  \\<lbrakk>A.arr ?f; A.arr ?f'; F ?f = F ?f'\\<rbrakk>\n  \\<Longrightarrow> ?f = ?f'\n\ngoal (1 subgoal):\n 1. faithful_functor A B F", "by (unfold_locales, blast)"], ["", "context embedding_functor\n  begin"], ["", "lemma reflects_ide:\n    assumes \"B.ide (F f)\"\n    shows \"A.ide f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A.ide f", "using assms is_embedding A.ide_in_hom B.ide_in_hom"], ["proof (prove)\nusing this:\n  B.ide (F f)\n  \\<lbrakk>A.arr ?f; A.arr ?f'; F ?f = F ?f'\\<rbrakk>\n  \\<Longrightarrow> ?f = ?f'\n  A.ide ?a =\n  \\<guillemotleft>?a : ?a \\<rightarrow>\\<^sub>A ?a\\<guillemotright>\n  B.ide ?a =\n  \\<guillemotleft>?a : ?a \\<rightarrow>\\<^sub>B ?a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. A.ide f", "by (metis A.in_homE B.in_homE A.ide_cod preserves_cod preserves_reflects_arr)"], ["", "end"], ["", "locale full_embedding_functor =\n    embedding_functor A B F +\n    full_functor A B F\n  for A :: \"'a comp\"\n  and B :: \"'b comp\"\n  and F :: \"'a \\<Rightarrow> 'b\""], ["", "locale essentially_surjective_functor = \"functor\" +\n  assumes essentially_surjective: \"\\<And>b. B.ide b \\<Longrightarrow> \\<exists>a. A.ide a \\<and> B.isomorphic (F a) b\""], ["", "locale constant_functor =\n    A: category A +\n    B: category B\n  for A :: \"'a comp\"\n  and B :: \"'b comp\"\n  and b :: 'b +\n  assumes value_is_ide: \"B.ide b\"\n  begin"], ["", "definition map\n    where \"map f = (if A.arr f then b else B.null)\""], ["", "lemma map_simp [simp]:\n    assumes \"A.arr f\"\n    shows \"map f = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.map f = b", "using assms map_def"], ["proof (prove)\nusing this:\n  A.arr f\n  local.map ?f = (if A.arr ?f then b else B.null)\n\ngoal (1 subgoal):\n 1. local.map f = b", "by auto"], ["", "lemma is_functor:\n    shows \"functor A B map\""], ["proof (prove)\ngoal (1 subgoal):\n 1. functor A B local.map", "using map_def value_is_ide"], ["proof (prove)\nusing this:\n  local.map ?f = (if A.arr ?f then b else B.null)\n  B.ide b\n\ngoal (1 subgoal):\n 1. functor A B local.map", "by (unfold_locales, auto)"], ["", "end"], ["", "sublocale constant_functor \\<subseteq> \"functor\" A B map"], ["proof (prove)\ngoal (1 subgoal):\n 1. functor A B local.map", "using is_functor"], ["proof (prove)\nusing this:\n  functor A B local.map\n\ngoal (1 subgoal):\n 1. functor A B local.map", "by auto"], ["", "locale identity_functor =\n    C: category C\n    for C :: \"'a comp\"\n  begin"], ["", "definition map :: \"'a \\<Rightarrow> 'a\"\n    where \"map f = (if C.arr f then f else C.null)\""], ["", "lemma map_simp [simp]:\n    assumes \"C.arr f\"\n    shows \"map f = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.map f = f", "using assms map_def"], ["proof (prove)\nusing this:\n  C.arr f\n  local.map ?f = (if C.arr ?f then ?f else C.null)\n\ngoal (1 subgoal):\n 1. local.map f = f", "by simp"], ["", "lemma is_functor:\n    shows \"functor C C map\""], ["proof (prove)\ngoal (1 subgoal):\n 1. functor C C local.map", "using C.arr_dom_iff_arr C.arr_cod_iff_arr"], ["proof (prove)\nusing this:\n  C.arr (C.dom ?f) = C.arr ?f\n  C.arr (C.cod ?f) = C.arr ?f\n\ngoal (1 subgoal):\n 1. functor C C local.map", "by (unfold_locales; auto simp add: map_def)"], ["", "end"], ["", "sublocale identity_functor \\<subseteq> \"functor\" C C map"], ["proof (prove)\ngoal (1 subgoal):\n 1. functor C C local.map", "using is_functor"], ["proof (prove)\nusing this:\n  functor C C local.map\n\ngoal (1 subgoal):\n 1. functor C C local.map", "by auto"], ["", "text \\<open>\n    It is convenient to have an easy way to obtain from a category the identity functor\n    on that category. The following declaration causes the definitions and facts from the\n    @{locale identity_functor} locale to be inherited by the @{locale category} locale,\n    including the function @{term map} on arrows that represents the identity functor.\n    This makes it generally unnecessary to give explicit interpretations of\n    @{locale identity_functor}.\n\\<close>"], ["", "sublocale category \\<subseteq> identity_functor C"], ["proof (prove)\ngoal (1 subgoal):\n 1. identity_functor (\\<cdot>)", ".."], ["", "text\\<open>\n    Composition of functors coincides with function composition, thanks to the\n    magic of \\<open>null\\<close>.\n\\<close>"], ["", "lemma functor_comp:\n  assumes \"functor A B F\" and \"functor B C G\"\n  shows \"functor A C (G o F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. functor A C (G \\<circ> F)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. functor A C (G \\<circ> F)", "interpret F: \"functor\" A B F"], ["proof (prove)\ngoal (1 subgoal):\n 1. functor A B F", "using assms(1)"], ["proof (prove)\nusing this:\n  functor A B F\n\ngoal (1 subgoal):\n 1. functor A B F", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. functor A C (G \\<circ> F)", "interpret G: \"functor\" B C G"], ["proof (prove)\ngoal (1 subgoal):\n 1. functor B C G", "using assms(2)"], ["proof (prove)\nusing this:\n  functor B C G\n\ngoal (1 subgoal):\n 1. functor B C G", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. functor A C (G \\<circ> F)", "show \"functor A C (G o F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. functor A C (G \\<circ> F)", "using F.preserves_arr F.is_extensional G.is_extensional"], ["proof (prove)\nusing this:\n  F.A.arr ?f \\<Longrightarrow> F.B.arr (F ?f)\n  \\<not> F.A.arr ?f \\<Longrightarrow> F ?f = F.B.null\n  \\<not> F.B.arr ?f \\<Longrightarrow> G ?f = G.B.null\n\ngoal (1 subgoal):\n 1. functor A C (G \\<circ> F)", "by (unfold_locales, auto)"], ["proof (state)\nthis:\n  functor A C (G \\<circ> F)\n\ngoal:\nNo subgoals!", "qed"], ["", "locale composite_functor =\n    F: \"functor\" A B F +\n    G: \"functor\" B C G\n  for A :: \"'a comp\"\n  and B :: \"'b comp\"\n  and C :: \"'c comp\"\n  and F :: \"'a \\<Rightarrow> 'b\"\n  and G :: \"'b \\<Rightarrow> 'c\"\n  begin"], ["", "abbreviation map\n    where \"map \\<equiv> G o F\""], ["", "end"], ["", "sublocale composite_functor \\<subseteq> \"functor\" A C \\<open>G o F\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. functor A C local.map", "using functor_comp F.functor_axioms G.functor_axioms"], ["proof (prove)\nusing this:\n  \\<lbrakk>functor ?A ?B ?F; functor ?B ?C ?G\\<rbrakk>\n  \\<Longrightarrow> functor ?A ?C (?G \\<circ> ?F)\n  functor A B F\n  functor B C G\n\ngoal (1 subgoal):\n 1. functor A C local.map", "by blast"], ["", "lemma comp_functor_identity [simp]:\n  assumes \"functor A B F\"\n  shows \"F o identity_functor.map A = F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F \\<circ> identity_functor.map A = F", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (F \\<circ> identity_functor.map A) x = F x", "interpret \"functor\" A B F"], ["proof (prove)\ngoal (1 subgoal):\n 1. functor A B F", "using assms"], ["proof (prove)\nusing this:\n  functor A B F\n\ngoal (1 subgoal):\n 1. functor A B F", "by blast"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (F \\<circ> A.map) x = F x", "show \"\\<And>x. (F o A.map) x = F x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (F \\<circ> A.map) x = F x", "using A.map_def is_extensional"], ["proof (prove)\nusing this:\n  A.map ?f = (if A.arr ?f then ?f else A.null)\n  \\<not> A.arr ?f \\<Longrightarrow> F ?f = B.null\n\ngoal (1 subgoal):\n 1. \\<And>x. (F \\<circ> A.map) x = F x", "by simp"], ["proof (state)\nthis:\n  (F \\<circ> A.map) ?x = F ?x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma comp_identity_functor [simp]:\n  assumes \"functor A B F\"\n  shows \"identity_functor.map B o F = F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. identity_functor.map B \\<circ> F = F", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (identity_functor.map B \\<circ> F) x = F x", "interpret \"functor\" A B F"], ["proof (prove)\ngoal (1 subgoal):\n 1. functor A B F", "using assms"], ["proof (prove)\nusing this:\n  functor A B F\n\ngoal (1 subgoal):\n 1. functor A B F", "by blast"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. (B.map \\<circ> F) x = F x", "show \"\\<And>x. (B.map o F) x = F x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (B.map \\<circ> F) x = F x", "using B.map_def"], ["proof (prove)\nusing this:\n  B.map ?f = (if B.arr ?f then ?f else B.null)\n\ngoal (1 subgoal):\n 1. \\<And>x. (B.map \\<circ> F) x = F x", "by (metis comp_apply is_extensional preserves_arr)"], ["proof (state)\nthis:\n  (B.map \\<circ> F) ?x = F ?x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma faithful_functors_compose:\n  assumes \"faithful_functor A B F\" and \"faithful_functor B C G\"\n  shows \"faithful_functor A C (G o F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. faithful_functor A C (G \\<circ> F)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. faithful_functor A C (G \\<circ> F)", "interpret F: faithful_functor A B F"], ["proof (prove)\ngoal (1 subgoal):\n 1. faithful_functor A B F", "using assms(1)"], ["proof (prove)\nusing this:\n  faithful_functor A B F\n\ngoal (1 subgoal):\n 1. faithful_functor A B F", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. faithful_functor A C (G \\<circ> F)", "interpret G: faithful_functor B C G"], ["proof (prove)\ngoal (1 subgoal):\n 1. faithful_functor B C G", "using assms(2)"], ["proof (prove)\nusing this:\n  faithful_functor B C G\n\ngoal (1 subgoal):\n 1. faithful_functor B C G", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. faithful_functor A C (G \\<circ> F)", "interpret composite_functor A B C F G"], ["proof (prove)\ngoal (1 subgoal):\n 1. composite_functor A B C F G", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. faithful_functor A C local.map", "show \"faithful_functor A C (G o F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. faithful_functor A C local.map", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f f'.\n       \\<lbrakk>F.A.par f f'; local.map f = local.map f'\\<rbrakk>\n       \\<Longrightarrow> f = f'", "show \"\\<And>f f'. \\<lbrakk>F.A.par f f'; map f = map f'\\<rbrakk> \\<Longrightarrow> f = f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f f'.\n       \\<lbrakk>F.A.par f f'; local.map f = local.map f'\\<rbrakk>\n       \\<Longrightarrow> f = f'", "using F.is_faithful G.is_faithful"], ["proof (prove)\nusing this:\n  \\<lbrakk>F.A.par ?f ?f'; F ?f = F ?f'\\<rbrakk> \\<Longrightarrow> ?f = ?f'\n  \\<lbrakk>F.B.par ?f ?f'; G ?f = G ?f'\\<rbrakk> \\<Longrightarrow> ?f = ?f'\n\ngoal (1 subgoal):\n 1. \\<And>f f'.\n       \\<lbrakk>F.A.par f f'; local.map f = local.map f'\\<rbrakk>\n       \\<Longrightarrow> f = f'", "by (metis (mono_tags, lifting) F.preserves_arr F.preserves_cod F.preserves_dom o_apply)"], ["proof (state)\nthis:\n  \\<lbrakk>F.A.par ?f ?f'; local.map ?f = local.map ?f'\\<rbrakk>\n  \\<Longrightarrow> ?f = ?f'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  faithful_functor A C local.map\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma full_functors_compose:\n  assumes \"full_functor A B F\" and \"full_functor B C G\"\n  shows \"full_functor A C (G o F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. full_functor A C (G \\<circ> F)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. full_functor A C (G \\<circ> F)", "interpret F: full_functor A B F"], ["proof (prove)\ngoal (1 subgoal):\n 1. full_functor A B F", "using assms(1)"], ["proof (prove)\nusing this:\n  full_functor A B F\n\ngoal (1 subgoal):\n 1. full_functor A B F", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. full_functor A C (G \\<circ> F)", "interpret G: full_functor B C G"], ["proof (prove)\ngoal (1 subgoal):\n 1. full_functor B C G", "using assms(2)"], ["proof (prove)\nusing this:\n  full_functor B C G\n\ngoal (1 subgoal):\n 1. full_functor B C G", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. full_functor A C (G \\<circ> F)", "interpret composite_functor A B C F G"], ["proof (prove)\ngoal (1 subgoal):\n 1. composite_functor A B C F G", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. full_functor A C local.map", "show \"full_functor A C (G o F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. full_functor A C local.map", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a a' g.\n       \\<lbrakk>F.A.ide a; F.A.ide a';\n        \\<guillemotleft>g : local.map\n                             a' \\<rightarrow> local.map\n         a\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            F.A.in_hom f a' a \\<and> local.map f = g", "show \"\\<And>a a' g. \\<lbrakk>F.A.ide a; F.A.ide a'; \\<guillemotleft>g : map a' \\<rightarrow> map a\\<guillemotright>\\<rbrakk>\n                        \\<Longrightarrow> \\<exists>f. F.A.in_hom f a' a \\<and> map f = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a a' g.\n       \\<lbrakk>F.A.ide a; F.A.ide a';\n        \\<guillemotleft>g : local.map\n                             a' \\<rightarrow> local.map\n         a\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            F.A.in_hom f a' a \\<and> local.map f = g", "using F.is_full G.is_full"], ["proof (prove)\nusing this:\n  \\<lbrakk>F.A.ide ?a; F.A.ide ?a'; F.B.in_hom ?g (F ?a') (F ?a)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>f. F.A.in_hom f ?a' ?a \\<and> F f = ?g\n  \\<lbrakk>F.B.ide ?a; F.B.ide ?a';\n   \\<guillemotleft>?g : G ?a' \\<rightarrow> G ?a\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>f. F.B.in_hom f ?a' ?a \\<and> G f = ?g\n\ngoal (1 subgoal):\n 1. \\<And>a a' g.\n       \\<lbrakk>F.A.ide a; F.A.ide a';\n        \\<guillemotleft>g : local.map\n                             a' \\<rightarrow> local.map\n         a\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            F.A.in_hom f a' a \\<and> local.map f = g", "by (metis F.preserves_ide o_apply)"], ["proof (state)\nthis:\n  \\<lbrakk>F.A.ide ?a; F.A.ide ?a';\n   \\<guillemotleft>?g : local.map\n                         ?a' \\<rightarrow> local.map\n      ?a\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>f. F.A.in_hom f ?a' ?a \\<and> local.map f = ?g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  full_functor A C local.map\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma fully_faithful_functors_compose:\n  assumes \"fully_faithful_functor A B F\" and \"fully_faithful_functor B C G\"\n  shows \"full_functor A C (G o F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. full_functor A C (G \\<circ> F)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. full_functor A C (G \\<circ> F)", "interpret F: fully_faithful_functor A B F"], ["proof (prove)\ngoal (1 subgoal):\n 1. fully_faithful_functor A B F", "using assms(1)"], ["proof (prove)\nusing this:\n  fully_faithful_functor A B F\n\ngoal (1 subgoal):\n 1. fully_faithful_functor A B F", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. full_functor A C (G \\<circ> F)", "interpret G: fully_faithful_functor B C G"], ["proof (prove)\ngoal (1 subgoal):\n 1. fully_faithful_functor B C G", "using assms(2)"], ["proof (prove)\nusing this:\n  fully_faithful_functor B C G\n\ngoal (1 subgoal):\n 1. fully_faithful_functor B C G", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. full_functor A C (G \\<circ> F)", "interpret composite_functor A B C F G"], ["proof (prove)\ngoal (1 subgoal):\n 1. composite_functor A B C F G", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. full_functor A C local.map", "interpret faithful_functor A C \\<open>G o F\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. faithful_functor A C local.map", "using F.faithful_functor_axioms G.faithful_functor_axioms faithful_functors_compose"], ["proof (prove)\nusing this:\n  faithful_functor A B F\n  faithful_functor B C G\n  \\<lbrakk>faithful_functor ?A ?B ?F; faithful_functor ?B ?C ?G\\<rbrakk>\n  \\<Longrightarrow> faithful_functor ?A ?C (?G \\<circ> ?F)\n\ngoal (1 subgoal):\n 1. faithful_functor A C local.map", "by blast"], ["proof (state)\ngoal (1 subgoal):\n 1. full_functor A C local.map", "interpret full_functor A C \\<open>G o F\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. full_functor A C local.map", "using F.full_functor_axioms G.full_functor_axioms full_functors_compose"], ["proof (prove)\nusing this:\n  full_functor A B F\n  full_functor B C G\n  \\<lbrakk>full_functor ?A ?B ?F; full_functor ?B ?C ?G\\<rbrakk>\n  \\<Longrightarrow> full_functor ?A ?C (?G \\<circ> ?F)\n\ngoal (1 subgoal):\n 1. full_functor A C local.map", "by blast"], ["proof (state)\ngoal (1 subgoal):\n 1. full_functor A C local.map", "show \"full_functor A C (G o F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. full_functor A C local.map", ".."], ["proof (state)\nthis:\n  full_functor A C local.map\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma embedding_functors_compose:\n  assumes \"embedding_functor A B F\" and \"embedding_functor B C G\"\n  shows \"embedding_functor A C (G o F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. embedding_functor A C (G \\<circ> F)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. embedding_functor A C (G \\<circ> F)", "interpret F: embedding_functor A B F"], ["proof (prove)\ngoal (1 subgoal):\n 1. embedding_functor A B F", "using assms(1)"], ["proof (prove)\nusing this:\n  embedding_functor A B F\n\ngoal (1 subgoal):\n 1. embedding_functor A B F", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. embedding_functor A C (G \\<circ> F)", "interpret G: embedding_functor B C G"], ["proof (prove)\ngoal (1 subgoal):\n 1. embedding_functor B C G", "using assms(2)"], ["proof (prove)\nusing this:\n  embedding_functor B C G\n\ngoal (1 subgoal):\n 1. embedding_functor B C G", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. embedding_functor A C (G \\<circ> F)", "interpret composite_functor A B C F G"], ["proof (prove)\ngoal (1 subgoal):\n 1. composite_functor A B C F G", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. embedding_functor A C local.map", "show \"embedding_functor A C (G o F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. embedding_functor A C local.map", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f f'.\n       \\<lbrakk>F.A.arr f; F.A.arr f'; local.map f = local.map f'\\<rbrakk>\n       \\<Longrightarrow> f = f'", "show \"\\<And>f f'. \\<lbrakk>F.A.arr f; F.A.arr f'; map f = map f'\\<rbrakk> \\<Longrightarrow> f = f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f f'.\n       \\<lbrakk>F.A.arr f; F.A.arr f'; local.map f = local.map f'\\<rbrakk>\n       \\<Longrightarrow> f = f'", "by (simp add: F.is_embedding G.is_embedding)"], ["proof (state)\nthis:\n  \\<lbrakk>F.A.arr ?f; F.A.arr ?f'; local.map ?f = local.map ?f'\\<rbrakk>\n  \\<Longrightarrow> ?f = ?f'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  embedding_functor A C local.map\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma full_embedding_functors_compose:\n  assumes \"full_embedding_functor A B F\" and \"full_embedding_functor B C G\"\n  shows \"full_embedding_functor A C (G o F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. full_embedding_functor A C (G \\<circ> F)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. full_embedding_functor A C (G \\<circ> F)", "interpret F: full_embedding_functor A B F"], ["proof (prove)\ngoal (1 subgoal):\n 1. full_embedding_functor A B F", "using assms(1)"], ["proof (prove)\nusing this:\n  full_embedding_functor A B F\n\ngoal (1 subgoal):\n 1. full_embedding_functor A B F", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. full_embedding_functor A C (G \\<circ> F)", "interpret G: full_embedding_functor B C G"], ["proof (prove)\ngoal (1 subgoal):\n 1. full_embedding_functor B C G", "using assms(2)"], ["proof (prove)\nusing this:\n  full_embedding_functor B C G\n\ngoal (1 subgoal):\n 1. full_embedding_functor B C G", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. full_embedding_functor A C (G \\<circ> F)", "interpret composite_functor A B C F G"], ["proof (prove)\ngoal (1 subgoal):\n 1. composite_functor A B C F G", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. full_embedding_functor A C local.map", "interpret embedding_functor A C \\<open>G o F\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. embedding_functor A C local.map", "using F.embedding_functor_axioms G.embedding_functor_axioms embedding_functors_compose"], ["proof (prove)\nusing this:\n  embedding_functor A B F\n  embedding_functor B C G\n  \\<lbrakk>embedding_functor ?A ?B ?F; embedding_functor ?B ?C ?G\\<rbrakk>\n  \\<Longrightarrow> embedding_functor ?A ?C (?G \\<circ> ?F)\n\ngoal (1 subgoal):\n 1. embedding_functor A C local.map", "by blast"], ["proof (state)\ngoal (1 subgoal):\n 1. full_embedding_functor A C local.map", "interpret full_functor A C \\<open>G o F\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. full_functor A C local.map", "using F.full_functor_axioms G.full_functor_axioms full_functors_compose"], ["proof (prove)\nusing this:\n  full_functor A B F\n  full_functor B C G\n  \\<lbrakk>full_functor ?A ?B ?F; full_functor ?B ?C ?G\\<rbrakk>\n  \\<Longrightarrow> full_functor ?A ?C (?G \\<circ> ?F)\n\ngoal (1 subgoal):\n 1. full_functor A C local.map", "by blast"], ["proof (state)\ngoal (1 subgoal):\n 1. full_embedding_functor A C local.map", "show \"full_embedding_functor A C (G o F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. full_embedding_functor A C local.map", ".."], ["proof (state)\nthis:\n  full_embedding_functor A C local.map\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma essentially_surjective_functors_compose:\n  assumes \"essentially_surjective_functor A B F\" and \"essentially_surjective_functor B C G\"\n  shows \"essentially_surjective_functor A C (G o F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. essentially_surjective_functor A C (G \\<circ> F)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. essentially_surjective_functor A C (G \\<circ> F)", "interpret F: essentially_surjective_functor A B F"], ["proof (prove)\ngoal (1 subgoal):\n 1. essentially_surjective_functor A B F", "using assms(1)"], ["proof (prove)\nusing this:\n  essentially_surjective_functor A B F\n\ngoal (1 subgoal):\n 1. essentially_surjective_functor A B F", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. essentially_surjective_functor A C (G \\<circ> F)", "interpret G: essentially_surjective_functor B C G"], ["proof (prove)\ngoal (1 subgoal):\n 1. essentially_surjective_functor B C G", "using assms(2)"], ["proof (prove)\nusing this:\n  essentially_surjective_functor B C G\n\ngoal (1 subgoal):\n 1. essentially_surjective_functor B C G", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. essentially_surjective_functor A C (G \\<circ> F)", "interpret composite_functor A B C F G"], ["proof (prove)\ngoal (1 subgoal):\n 1. composite_functor A B C F G", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. essentially_surjective_functor A C local.map", "show \"essentially_surjective_functor A C (G o F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. essentially_surjective_functor A C local.map", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       G.B.ide b \\<Longrightarrow>\n       \\<exists>a. F.A.ide a \\<and> G.B.isomorphic (local.map a) b", "show \"\\<And>c. G.B.ide c \\<Longrightarrow> \\<exists>a. F.A.ide a \\<and> G.B.isomorphic (map a) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       G.B.ide c \\<Longrightarrow>\n       \\<exists>a. F.A.ide a \\<and> G.B.isomorphic (local.map a) c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c.\n       G.B.ide c \\<Longrightarrow>\n       \\<exists>a. F.A.ide a \\<and> G.B.isomorphic (local.map a) c", "fix c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c.\n       G.B.ide c \\<Longrightarrow>\n       \\<exists>a. F.A.ide a \\<and> G.B.isomorphic (local.map a) c", "assume c: \"G.B.ide c\""], ["proof (state)\nthis:\n  G.B.ide c\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       G.B.ide c \\<Longrightarrow>\n       \\<exists>a. F.A.ide a \\<and> G.B.isomorphic (local.map a) c", "obtain b where b: \"F.B.ide b \\<and> G.B.isomorphic (G b) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>b.\n        F.B.ide b \\<and> G.B.isomorphic (G b) c \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using c G.essentially_surjective"], ["proof (prove)\nusing this:\n  G.B.ide c\n  G.B.ide ?b \\<Longrightarrow>\n  \\<exists>a. F.B.ide a \\<and> G.B.isomorphic (G a) ?b\n\ngoal (1 subgoal):\n 1. (\\<And>b.\n        F.B.ide b \\<and> G.B.isomorphic (G b) c \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  F.B.ide b \\<and> G.B.isomorphic (G b) c\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       G.B.ide c \\<Longrightarrow>\n       \\<exists>a. F.A.ide a \\<and> G.B.isomorphic (local.map a) c", "obtain a where a: \"F.A.ide a \\<and> F.B.isomorphic (F a) b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a.\n        F.A.ide a \\<and> F.B.isomorphic (F a) b \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using b F.essentially_surjective"], ["proof (prove)\nusing this:\n  F.B.ide b \\<and> G.B.isomorphic (G b) c\n  F.B.ide ?b \\<Longrightarrow>\n  \\<exists>a. F.A.ide a \\<and> F.B.isomorphic (F a) ?b\n\ngoal (1 subgoal):\n 1. (\\<And>a.\n        F.A.ide a \\<and> F.B.isomorphic (F a) b \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  F.A.ide a \\<and> F.B.isomorphic (F a) b\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       G.B.ide c \\<Longrightarrow>\n       \\<exists>a. F.A.ide a \\<and> G.B.isomorphic (local.map a) c", "have \"G.B.isomorphic (map a) c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G.B.isomorphic (local.map a) c", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. G.B.isomorphic (local.map a) c", "have \"G.B.isomorphic (G (F a)) (G b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G.B.isomorphic (G (F a)) (G b)", "using a G.preserves_iso G.B.isomorphic_def"], ["proof (prove)\nusing this:\n  F.A.ide a \\<and> F.B.isomorphic (F a) b\n  F.B.iso ?f \\<Longrightarrow> G.B.iso (G ?f)\n  G.B.isomorphic ?a ?a' =\n  (\\<exists>f.\n      \\<guillemotleft>f : ?a \\<rightarrow> ?a'\\<guillemotright> \\<and>\n      G.B.iso f)\n\ngoal (1 subgoal):\n 1. G.B.isomorphic (G (F a)) (G b)", "by blast"], ["proof (state)\nthis:\n  G.B.isomorphic (G (F a)) (G b)\n\ngoal (1 subgoal):\n 1. G.B.isomorphic (local.map a) c", "thus ?thesis"], ["proof (prove)\nusing this:\n  G.B.isomorphic (G (F a)) (G b)\n\ngoal (1 subgoal):\n 1. G.B.isomorphic (local.map a) c", "using b G.B.isomorphic_transitive"], ["proof (prove)\nusing this:\n  G.B.isomorphic (G (F a)) (G b)\n  F.B.ide b \\<and> G.B.isomorphic (G b) c\n  \\<lbrakk>G.B.isomorphic ?f ?g; G.B.isomorphic ?g ?h\\<rbrakk>\n  \\<Longrightarrow> G.B.isomorphic ?f ?h\n\ngoal (1 subgoal):\n 1. G.B.isomorphic (local.map a) c", "by auto"], ["proof (state)\nthis:\n  G.B.isomorphic (local.map a) c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  G.B.isomorphic (local.map a) c\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       G.B.ide c \\<Longrightarrow>\n       \\<exists>a. F.A.ide a \\<and> G.B.isomorphic (local.map a) c", "thus \"\\<exists>a. F.A.ide a \\<and> G.B.isomorphic (map a) c\""], ["proof (prove)\nusing this:\n  G.B.isomorphic (local.map a) c\n\ngoal (1 subgoal):\n 1. \\<exists>a. F.A.ide a \\<and> G.B.isomorphic (local.map a) c", "using a"], ["proof (prove)\nusing this:\n  G.B.isomorphic (local.map a) c\n  F.A.ide a \\<and> F.B.isomorphic (F a) b\n\ngoal (1 subgoal):\n 1. \\<exists>a. F.A.ide a \\<and> G.B.isomorphic (local.map a) c", "by auto"], ["proof (state)\nthis:\n  \\<exists>a. F.A.ide a \\<and> G.B.isomorphic (local.map a) c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  G.B.ide ?c \\<Longrightarrow>\n  \\<exists>a. F.A.ide a \\<and> G.B.isomorphic (local.map a) ?c\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  essentially_surjective_functor A C local.map\n\ngoal:\nNo subgoals!", "qed"], ["", "locale inverse_functors =\n    A: category A +\n    B: category B +\n    F: \"functor\" B A F +\n    G: \"functor\" A B G\n  for A :: \"'a comp\"      (infixr \"\\<cdot>\\<^sub>A\" 55)\n  and B :: \"'b comp\"      (infixr \"\\<cdot>\\<^sub>B\" 55)\n  and F :: \"'b \\<Rightarrow> 'a\"\n  and G :: \"'a \\<Rightarrow> 'b\" +\n  assumes inv: \"G o F = identity_functor.map B\"\n  and inv': \"F o G = identity_functor.map A\"\n  begin"], ["", "lemma bij_betw_arr_sets:\n    shows \"bij_betw F (Collect B.arr) (Collect A.arr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw F (Collect B.arr) (Collect A.arr)", "using inv inv'"], ["proof (prove)\nusing this:\n  G \\<circ> F = B.map\n  F \\<circ> G = A.map\n\ngoal (1 subgoal):\n 1. bij_betw F (Collect B.arr) (Collect A.arr)", "apply (intro bij_betwI)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>G \\<circ> F = B.map; F \\<circ> G = A.map\\<rbrakk>\n    \\<Longrightarrow> F \\<in> Collect B.arr \\<rightarrow> Collect A.arr\n 2. \\<lbrakk>G \\<circ> F = B.map; F \\<circ> G = A.map\\<rbrakk>\n    \\<Longrightarrow> ?g2 \\<in> Collect A.arr \\<rightarrow> Collect B.arr\n 3. \\<And>x.\n       \\<lbrakk>G \\<circ> F = B.map; F \\<circ> G = A.map;\n        x \\<in> Collect B.arr\\<rbrakk>\n       \\<Longrightarrow> ?g2 (F x) = x\n 4. \\<And>y.\n       \\<lbrakk>G \\<circ> F = B.map; F \\<circ> G = A.map;\n        y \\<in> Collect A.arr\\<rbrakk>\n       \\<Longrightarrow> F (?g2 y) = y", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>G \\<circ> F = B.map; F \\<circ> G = A.map; B.arr x\\<rbrakk>\n       \\<Longrightarrow> G (F x) = x\n 2. \\<And>y.\n       \\<lbrakk>G \\<circ> F = B.map; F \\<circ> G = A.map; A.arr y\\<rbrakk>\n       \\<Longrightarrow> F (G y) = y", "using comp_eq_dest_lhs"], ["proof (prove)\nusing this:\n  ?a \\<circ> ?b = ?c \\<Longrightarrow> ?a (?b ?v) = ?c ?v\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       \\<lbrakk>G \\<circ> F = B.map; F \\<circ> G = A.map; B.arr x\\<rbrakk>\n       \\<Longrightarrow> G (F x) = x\n 2. \\<And>y.\n       \\<lbrakk>G \\<circ> F = B.map; F \\<circ> G = A.map; A.arr y\\<rbrakk>\n       \\<Longrightarrow> F (G y) = y", "by force+"], ["", "end"], ["", "locale isomorphic_categories =\n    A: category A +\n    B: category B\n  for A :: \"'a comp\"      (infixr \"\\<cdot>\\<^sub>A\" 55)\n  and B :: \"'b comp\"      (infixr \"\\<cdot>\\<^sub>B\" 55) +\n  assumes iso: \"\\<exists>F G. inverse_functors A B F G\""], ["", "sublocale inverse_functors \\<subseteq> isomorphic_categories A B"], ["proof (prove)\ngoal (1 subgoal):\n 1. isomorphic_categories (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B)", "using inverse_functors_axioms"], ["proof (prove)\nusing this:\n  inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G\n\ngoal (1 subgoal):\n 1. isomorphic_categories (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B)", "by (unfold_locales, auto)"], ["", "lemma inverse_functors_sym:\n  assumes \"inverse_functors A B F G\"\n  shows \"inverse_functors B A G F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_functors B A G F", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inverse_functors B A G F", "interpret inverse_functors A B F G"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_functors A B F G", "using assms"], ["proof (prove)\nusing this:\n  inverse_functors A B F G\n\ngoal (1 subgoal):\n 1. inverse_functors A B F G", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. inverse_functors B A G F", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_functors B A G F", "using inv inv'"], ["proof (prove)\nusing this:\n  G \\<circ> F = B.map\n  F \\<circ> G = A.map\n\ngoal (1 subgoal):\n 1. inverse_functors B A G F", "by (unfold_locales, auto)"], ["proof (state)\nthis:\n  inverse_functors B A G F\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n    Inverse functors uniquely determine each other.\n\\<close>"], ["", "lemma inverse_functor_unique:\n  assumes \"inverse_functors C D F G\" and \"inverse_functors C D F G'\"\n  shows \"G = G'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G = G'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. G = G'", "interpret FG: inverse_functors C D F G"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_functors C D F G", "using assms(1)"], ["proof (prove)\nusing this:\n  inverse_functors C D F G\n\ngoal (1 subgoal):\n 1. inverse_functors C D F G", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. G = G'", "interpret FG': inverse_functors C D F G'"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_functors C D F G'", "using assms(2)"], ["proof (prove)\nusing this:\n  inverse_functors C D F G'\n\ngoal (1 subgoal):\n 1. inverse_functors C D F G'", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. G = G'", "show \"G = G'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G = G'", "using FG.G.is_extensional FG'.G.is_extensional FG'.inv FG.inv'"], ["proof (prove)\nusing this:\n  \\<not> FG.A.arr ?f \\<Longrightarrow> G ?f = FG.B.null\n  \\<not> FG.A.arr ?f \\<Longrightarrow> G' ?f = FG.B.null\n  G' \\<circ> F = FG.B.map\n  F \\<circ> G = FG.A.map\n\ngoal (1 subgoal):\n 1. G = G'", "by (metis FG'.G.functor_axioms FG.G.functor_axioms comp_assoc comp_identity_functor\n                comp_functor_identity)"], ["proof (state)\nthis:\n  G = G'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inverse_functor_unique':\n  assumes \"inverse_functors C D F G\" and \"inverse_functors C D F' G\"\n  shows \"F = F'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F = F'", "using assms inverse_functors_sym inverse_functor_unique"], ["proof (prove)\nusing this:\n  inverse_functors C D F G\n  inverse_functors C D F' G\n  inverse_functors ?A ?B ?F ?G \\<Longrightarrow>\n  inverse_functors ?B ?A ?G ?F\n  \\<lbrakk>inverse_functors ?C ?D ?F ?G;\n   inverse_functors ?C ?D ?F ?G'\\<rbrakk>\n  \\<Longrightarrow> ?G = ?G'\n\ngoal (1 subgoal):\n 1. F = F'", "by blast"], ["", "locale invertible_functor =\n    A: category A +\n    B: category B +\n    G: \"functor\" A B G\n  for A :: \"'a comp\"      (infixr \"\\<cdot>\\<^sub>A\" 55)\n  and B :: \"'b comp\"      (infixr \"\\<cdot>\\<^sub>B\" 55)\n  and G :: \"'a \\<Rightarrow> 'b\" +\n  assumes invertible: \"\\<exists>F. inverse_functors A B F G\"\n  begin"], ["", "lemma has_unique_inverse:\n    shows \"\\<exists>!F. inverse_functors A B F G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!F. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G", "using invertible inverse_functor_unique'"], ["proof (prove)\nusing this:\n  \\<exists>F. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G\n  \\<lbrakk>inverse_functors ?C ?D ?F ?G;\n   inverse_functors ?C ?D ?F' ?G\\<rbrakk>\n  \\<Longrightarrow> ?F = ?F'\n\ngoal (1 subgoal):\n 1. \\<exists>!F. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G", "by blast"], ["", "definition inv\n    where \"inv \\<equiv> THE F. inverse_functors A B F G\""], ["", "interpretation inverse_functors A B inv G"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) local.inv G", "using inv_def has_unique_inverse theI' [of \"\\<lambda>F. inverse_functors A B F G\"]"], ["proof (prove)\nusing this:\n  local.inv \\<equiv>\n  THE F. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G\n  \\<exists>!F. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G\n  \\<exists>!x.\n     inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) x\n      G \\<Longrightarrow>\n  inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B)\n   (THE x. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) x G) G\n\ngoal (1 subgoal):\n 1. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) local.inv G", "by simp"], ["", "lemma inv_is_inverse:\n    shows \"inverse_functors A B inv G\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) local.inv G", ".."], ["", "lemma preserves_terminal:\n    assumes \"A.terminal a\"\n    shows \"B.terminal (G a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B.terminal (G a)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. B.ide (G a)\n 2. \\<And>aa.\n       B.ide aa \\<Longrightarrow>\n       \\<exists>!f.\n          \\<guillemotleft>f : aa \\<rightarrow>\\<^sub>B G a\\<guillemotright>", "show 0: \"B.ide (G a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. B.ide (G a)", "using assms G.preserves_ide A.terminal_def"], ["proof (prove)\nusing this:\n  A.terminal a\n  A.ide ?a \\<Longrightarrow> B.ide (G ?a)\n  A.terminal ?b \\<equiv>\n  A.ide ?b \\<and>\n  (\\<forall>a.\n      A.ide a \\<longrightarrow>\n      (\\<exists>!f.\n          \\<guillemotleft>f : a \\<rightarrow>\\<^sub>A ?b\\<guillemotright>))\n\ngoal (1 subgoal):\n 1. B.ide (G a)", "by blast"], ["proof (state)\nthis:\n  B.ide (G a)\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       B.ide aa \\<Longrightarrow>\n       \\<exists>!f.\n          \\<guillemotleft>f : aa \\<rightarrow>\\<^sub>B G a\\<guillemotright>", "fix b :: 'b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>aa.\n       B.ide aa \\<Longrightarrow>\n       \\<exists>!f.\n          \\<guillemotleft>f : aa \\<rightarrow>\\<^sub>B G a\\<guillemotright>", "assume b: \"B.ide b\""], ["proof (state)\nthis:\n  B.ide b\n\ngoal (1 subgoal):\n 1. \\<And>aa.\n       B.ide aa \\<Longrightarrow>\n       \\<exists>!f.\n          \\<guillemotleft>f : aa \\<rightarrow>\\<^sub>B G a\\<guillemotright>", "show \"\\<exists>!g. \\<guillemotleft>g : b \\<rightarrow>\\<^sub>B G a\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!g.\n       \\<guillemotleft>g : b \\<rightarrow>\\<^sub>B G a\\<guillemotright>", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : b \\<rightarrow>\\<^sub>B G a\\<guillemotright>\n 2. \\<And>g.\n       \\<guillemotleft>g : b \\<rightarrow>\\<^sub>B G\n              a\\<guillemotright> \\<Longrightarrow>\n       g = ?a", "let ?F = \"SOME F. inverse_functors A B F G\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : b \\<rightarrow>\\<^sub>B G a\\<guillemotright>\n 2. \\<And>g.\n       \\<guillemotleft>g : b \\<rightarrow>\\<^sub>B G\n              a\\<guillemotright> \\<Longrightarrow>\n       g = ?a", "from invertible"], ["proof (chain)\npicking this:\n  \\<exists>F. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G", "have F: \"inverse_functors A B ?F G\""], ["proof (prove)\nusing this:\n  \\<exists>F. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G\n\ngoal (1 subgoal):\n 1. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B)\n     (SOME F. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G) G", "using someI_ex [of \"\\<lambda>F. inverse_functors A B F G\"]"], ["proof (prove)\nusing this:\n  \\<exists>F. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G\n  \\<exists>x.\n     inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) x\n      G \\<Longrightarrow>\n  inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B)\n   (SOME x. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) x G) G\n\ngoal (1 subgoal):\n 1. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B)\n     (SOME F. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G) G", "by fast"], ["proof (state)\nthis:\n  inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B)\n   (SOME F. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G) G\n\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : b \\<rightarrow>\\<^sub>B G a\\<guillemotright>\n 2. \\<And>g.\n       \\<guillemotleft>g : b \\<rightarrow>\\<^sub>B G\n              a\\<guillemotright> \\<Longrightarrow>\n       g = ?a", "interpret inverse_functors A B ?F G"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B)\n     (SOME F. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G) G", "using F"], ["proof (prove)\nusing this:\n  inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B)\n   (SOME F. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G) G\n\ngoal (1 subgoal):\n 1. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B)\n     (SOME F. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G) G", "by auto"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : b \\<rightarrow>\\<^sub>B G a\\<guillemotright>\n 2. \\<And>g.\n       \\<guillemotleft>g : b \\<rightarrow>\\<^sub>B G\n              a\\<guillemotright> \\<Longrightarrow>\n       g = ?a", "let ?P = \"\\<lambda>f. \\<guillemotleft>f : ?F b \\<rightarrow>\\<^sub>A a\\<guillemotright>\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : b \\<rightarrow>\\<^sub>B G a\\<guillemotright>\n 2. \\<And>g.\n       \\<guillemotleft>g : b \\<rightarrow>\\<^sub>B G\n              a\\<guillemotright> \\<Longrightarrow>\n       g = ?a", "have 1: \"\\<exists>!f. ?P f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!f.\n       \\<guillemotleft>f : (SOME F.\n                               inverse_functors (\\<cdot>\\<^sub>A)\n                                (\\<cdot>\\<^sub>B) F G)\n                            b \\<rightarrow>\\<^sub>A a\\<guillemotright>", "using assms b A.terminal_def"], ["proof (prove)\nusing this:\n  A.terminal a\n  B.ide b\n  A.terminal ?b \\<equiv>\n  A.ide ?b \\<and>\n  (\\<forall>a.\n      A.ide a \\<longrightarrow>\n      (\\<exists>!f.\n          \\<guillemotleft>f : a \\<rightarrow>\\<^sub>A ?b\\<guillemotright>))\n\ngoal (1 subgoal):\n 1. \\<exists>!f.\n       \\<guillemotleft>f : (SOME F.\n                               inverse_functors (\\<cdot>\\<^sub>A)\n                                (\\<cdot>\\<^sub>B) F G)\n                            b \\<rightarrow>\\<^sub>A a\\<guillemotright>", "by simp"], ["proof (state)\nthis:\n  \\<exists>!f.\n     \\<guillemotleft>f : (SOME F.\n                             inverse_functors (\\<cdot>\\<^sub>A)\n                              (\\<cdot>\\<^sub>B) F G)\n                          b \\<rightarrow>\\<^sub>A a\\<guillemotright>\n\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : b \\<rightarrow>\\<^sub>B G a\\<guillemotright>\n 2. \\<And>g.\n       \\<guillemotleft>g : b \\<rightarrow>\\<^sub>B G\n              a\\<guillemotright> \\<Longrightarrow>\n       g = ?a", "hence 2: \"?P (THE f. ?P f)\""], ["proof (prove)\nusing this:\n  \\<exists>!f.\n     \\<guillemotleft>f : (SOME F.\n                             inverse_functors (\\<cdot>\\<^sub>A)\n                              (\\<cdot>\\<^sub>B) F G)\n                          b \\<rightarrow>\\<^sub>A a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>THE f.\n                       \\<guillemotleft>f : (SOME F.\n         inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G)\n      b \\<rightarrow>\\<^sub>A a\\<guillemotright> : (SOME F.\n                 inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G)\n              b \\<rightarrow>\\<^sub>A a\\<guillemotright>", "by (metis (no_types, lifting) theI')"], ["proof (state)\nthis:\n  \\<guillemotleft>THE f.\n                     \\<guillemotleft>f : (SOME F.\n       inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G)\n    b \\<rightarrow>\\<^sub>A a\\<guillemotright> : (SOME F.\n               inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G)\n            b \\<rightarrow>\\<^sub>A a\\<guillemotright>\n\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : b \\<rightarrow>\\<^sub>B G a\\<guillemotright>\n 2. \\<And>g.\n       \\<guillemotleft>g : b \\<rightarrow>\\<^sub>B G\n              a\\<guillemotright> \\<Longrightarrow>\n       g = ?a", "thus \"\\<guillemotleft>G (THE f. ?P f) : b \\<rightarrow>\\<^sub>B G a\\<guillemotright>\""], ["proof (prove)\nusing this:\n  \\<guillemotleft>THE f.\n                     \\<guillemotleft>f : (SOME F.\n       inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G)\n    b \\<rightarrow>\\<^sub>A a\\<guillemotright> : (SOME F.\n               inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G)\n            b \\<rightarrow>\\<^sub>A a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>G (THE f.\n                          \\<guillemotleft>f : (SOME F.\n            inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G)\n         b \\<rightarrow>\\<^sub>A a\\<guillemotright>) : b \\<rightarrow>\\<^sub>B G\n    a\\<guillemotright>", "using b"], ["proof (prove)\nusing this:\n  \\<guillemotleft>THE f.\n                     \\<guillemotleft>f : (SOME F.\n       inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G)\n    b \\<rightarrow>\\<^sub>A a\\<guillemotright> : (SOME F.\n               inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G)\n            b \\<rightarrow>\\<^sub>A a\\<guillemotright>\n  B.ide b\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>G (THE f.\n                          \\<guillemotleft>f : (SOME F.\n            inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G)\n         b \\<rightarrow>\\<^sub>A a\\<guillemotright>) : b \\<rightarrow>\\<^sub>B G\n    a\\<guillemotright>", "apply (elim A.in_homE, intro B.in_homI, auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>A.arr\n              (THE f.\n                  \\<guillemotleft>f : (SOME F.\n    inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G)\n b \\<rightarrow>\\<^sub>A a\\<guillemotright>);\n     A.dom\n      (THE f.\n          \\<guillemotleft>f : (SOME F.\n                                  inverse_functors (\\<cdot>\\<^sub>A)\n                                   (\\<cdot>\\<^sub>B) F G)\n                               b \\<rightarrow>\\<^sub>A a\\<guillemotright>) =\n     (SOME F. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G) b;\n     A.cod\n      (THE f.\n          \\<guillemotleft>f : (SOME F.\n                                  inverse_functors (\\<cdot>\\<^sub>A)\n                                   (\\<cdot>\\<^sub>B) F G)\n                               b \\<rightarrow>\\<^sub>A a\\<guillemotright>) =\n     a;\n     \\<guillemotleft>THE f.\n                        \\<guillemotleft>f : (SOME F.\n          inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G)\n       b \\<rightarrow>\\<^sub>A a\\<guillemotright> : (SOME F.\n                  inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G)\n               b \\<rightarrow>\\<^sub>A a\\<guillemotright>;\n     B.ide b\\<rbrakk>\n    \\<Longrightarrow> G ((SOME F.\n                             inverse_functors (\\<cdot>\\<^sub>A)\n                              (\\<cdot>\\<^sub>B) F G)\n                          b) =\n                      b", "using B.ideD(1) B.map_simp comp_def inv"], ["proof (prove)\nusing this:\n  B.ide ?a \\<Longrightarrow> B.arr ?a\n  B.arr ?f \\<Longrightarrow> B.map ?f = ?f\n  ?f \\<circ> ?g = (\\<lambda>x. ?f (?g x))\n  G \\<circ>\n  (SOME F. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G) =\n  B.map\n\ngoal (1 subgoal):\n 1. \\<lbrakk>A.arr\n              (THE f.\n                  \\<guillemotleft>f : (SOME F.\n    inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G)\n b \\<rightarrow>\\<^sub>A a\\<guillemotright>);\n     A.dom\n      (THE f.\n          \\<guillemotleft>f : (SOME F.\n                                  inverse_functors (\\<cdot>\\<^sub>A)\n                                   (\\<cdot>\\<^sub>B) F G)\n                               b \\<rightarrow>\\<^sub>A a\\<guillemotright>) =\n     (SOME F. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G) b;\n     A.cod\n      (THE f.\n          \\<guillemotleft>f : (SOME F.\n                                  inverse_functors (\\<cdot>\\<^sub>A)\n                                   (\\<cdot>\\<^sub>B) F G)\n                               b \\<rightarrow>\\<^sub>A a\\<guillemotright>) =\n     a;\n     \\<guillemotleft>THE f.\n                        \\<guillemotleft>f : (SOME F.\n          inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G)\n       b \\<rightarrow>\\<^sub>A a\\<guillemotright> : (SOME F.\n                  inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G)\n               b \\<rightarrow>\\<^sub>A a\\<guillemotright>;\n     B.ide b\\<rbrakk>\n    \\<Longrightarrow> G ((SOME F.\n                             inverse_functors (\\<cdot>\\<^sub>A)\n                              (\\<cdot>\\<^sub>B) F G)\n                          b) =\n                      b", "by metis"], ["proof (state)\nthis:\n  \\<guillemotleft>G (THE f.\n                        \\<guillemotleft>f : (SOME F.\n          inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G)\n       b \\<rightarrow>\\<^sub>A a\\<guillemotright>) : b \\<rightarrow>\\<^sub>B G\n  a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       \\<guillemotleft>g : b \\<rightarrow>\\<^sub>B G\n              a\\<guillemotright> \\<Longrightarrow>\n       g =\n       G (THE f.\n             \\<guillemotleft>f : (SOME F.\n                                     inverse_functors (\\<cdot>\\<^sub>A)\n(\\<cdot>\\<^sub>B) F G)\n                                  b \\<rightarrow>\\<^sub>A a\\<guillemotright>)", "hence 3: \"\\<guillemotleft>(THE f. ?P f) : ?F b \\<rightarrow>\\<^sub>A a\\<guillemotright>\""], ["proof (prove)\nusing this:\n  \\<guillemotleft>G (THE f.\n                        \\<guillemotleft>f : (SOME F.\n          inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G)\n       b \\<rightarrow>\\<^sub>A a\\<guillemotright>) : b \\<rightarrow>\\<^sub>B G\n  a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>THE f.\n                       \\<guillemotleft>f : (SOME F.\n         inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G)\n      b \\<rightarrow>\\<^sub>A a\\<guillemotright> : (SOME F.\n                 inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G)\n              b \\<rightarrow>\\<^sub>A a\\<guillemotright>", "using assms 2 b F"], ["proof (prove)\nusing this:\n  \\<guillemotleft>G (THE f.\n                        \\<guillemotleft>f : (SOME F.\n          inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G)\n       b \\<rightarrow>\\<^sub>A a\\<guillemotright>) : b \\<rightarrow>\\<^sub>B G\n  a\\<guillemotright>\n  A.terminal a\n  \\<guillemotleft>THE f.\n                     \\<guillemotleft>f : (SOME F.\n       inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G)\n    b \\<rightarrow>\\<^sub>A a\\<guillemotright> : (SOME F.\n               inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G)\n            b \\<rightarrow>\\<^sub>A a\\<guillemotright>\n  B.ide b\n  inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B)\n   (SOME F. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G) G\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>THE f.\n                       \\<guillemotleft>f : (SOME F.\n         inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G)\n      b \\<rightarrow>\\<^sub>A a\\<guillemotright> : (SOME F.\n                 inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G)\n              b \\<rightarrow>\\<^sub>A a\\<guillemotright>", "by simp"], ["proof (state)\nthis:\n  \\<guillemotleft>THE f.\n                     \\<guillemotleft>f : (SOME F.\n       inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G)\n    b \\<rightarrow>\\<^sub>A a\\<guillemotright> : (SOME F.\n               inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G)\n            b \\<rightarrow>\\<^sub>A a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       \\<guillemotleft>g : b \\<rightarrow>\\<^sub>B G\n              a\\<guillemotright> \\<Longrightarrow>\n       g =\n       G (THE f.\n             \\<guillemotleft>f : (SOME F.\n                                     inverse_functors (\\<cdot>\\<^sub>A)\n(\\<cdot>\\<^sub>B) F G)\n                                  b \\<rightarrow>\\<^sub>A a\\<guillemotright>)", "fix g :: 'b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g.\n       \\<guillemotleft>g : b \\<rightarrow>\\<^sub>B G\n              a\\<guillemotright> \\<Longrightarrow>\n       g =\n       G (THE f.\n             \\<guillemotleft>f : (SOME F.\n                                     inverse_functors (\\<cdot>\\<^sub>A)\n(\\<cdot>\\<^sub>B) F G)\n                                  b \\<rightarrow>\\<^sub>A a\\<guillemotright>)", "assume g: \"\\<guillemotleft>g : b \\<rightarrow>\\<^sub>B G a\\<guillemotright>\""], ["proof (state)\nthis:\n  \\<guillemotleft>g : b \\<rightarrow>\\<^sub>B G a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       \\<guillemotleft>g : b \\<rightarrow>\\<^sub>B G\n              a\\<guillemotright> \\<Longrightarrow>\n       g =\n       G (THE f.\n             \\<guillemotleft>f : (SOME F.\n                                     inverse_functors (\\<cdot>\\<^sub>A)\n(\\<cdot>\\<^sub>B) F G)\n                                  b \\<rightarrow>\\<^sub>A a\\<guillemotright>)", "have \"?F (G a) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (SOME F. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G)\n     (G a) =\n    a", "using assms(1) A.terminal_def inv' A.map_simp"], ["proof (prove)\nusing this:\n  A.terminal a\n  A.terminal ?b \\<equiv>\n  A.ide ?b \\<and>\n  (\\<forall>a.\n      A.ide a \\<longrightarrow>\n      (\\<exists>!f.\n          \\<guillemotleft>f : a \\<rightarrow>\\<^sub>A ?b\\<guillemotright>))\n  (SOME F. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G) \\<circ>\n  G =\n  A.map\n  A.arr ?f \\<Longrightarrow> A.map ?f = ?f\n\ngoal (1 subgoal):\n 1. (SOME F. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G)\n     (G a) =\n    a", "by (metis 0 B.ideD(1) G.preserves_reflects_arr comp_eq_dest_lhs)"], ["proof (state)\nthis:\n  (SOME F. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G) (G a) =\n  a\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       \\<guillemotleft>g : b \\<rightarrow>\\<^sub>B G\n              a\\<guillemotright> \\<Longrightarrow>\n       g =\n       G (THE f.\n             \\<guillemotleft>f : (SOME F.\n                                     inverse_functors (\\<cdot>\\<^sub>A)\n(\\<cdot>\\<^sub>B) F G)\n                                  b \\<rightarrow>\\<^sub>A a\\<guillemotright>)", "hence \"\\<guillemotleft>?F g : ?F b \\<rightarrow>\\<^sub>A a\\<guillemotright>\""], ["proof (prove)\nusing this:\n  (SOME F. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G) (G a) =\n  a\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>(SOME F.\n                        inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B)\n                         F G)\n                     g : (SOME F.\n                             inverse_functors (\\<cdot>\\<^sub>A)\n                              (\\<cdot>\\<^sub>B) F G)\n                          b \\<rightarrow>\\<^sub>A a\\<guillemotright>", "using assms(1) g A.terminal_def inv"], ["proof (prove)\nusing this:\n  (SOME F. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G) (G a) =\n  a\n  A.terminal a\n  \\<guillemotleft>g : b \\<rightarrow>\\<^sub>B G a\\<guillemotright>\n  A.terminal ?b \\<equiv>\n  A.ide ?b \\<and>\n  (\\<forall>a.\n      A.ide a \\<longrightarrow>\n      (\\<exists>!f.\n          \\<guillemotleft>f : a \\<rightarrow>\\<^sub>A ?b\\<guillemotright>))\n  G \\<circ>\n  (SOME F. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G) =\n  B.map\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>(SOME F.\n                        inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B)\n                         F G)\n                     g : (SOME F.\n                             inverse_functors (\\<cdot>\\<^sub>A)\n                              (\\<cdot>\\<^sub>B) F G)\n                          b \\<rightarrow>\\<^sub>A a\\<guillemotright>", "by (elim B.in_homE, auto)"], ["proof (state)\nthis:\n  \\<guillemotleft>(SOME F.\n                      inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F\n                       G)\n                   g : (SOME F.\n                           inverse_functors (\\<cdot>\\<^sub>A)\n                            (\\<cdot>\\<^sub>B) F G)\n                        b \\<rightarrow>\\<^sub>A a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       \\<guillemotleft>g : b \\<rightarrow>\\<^sub>B G\n              a\\<guillemotright> \\<Longrightarrow>\n       g =\n       G (THE f.\n             \\<guillemotleft>f : (SOME F.\n                                     inverse_functors (\\<cdot>\\<^sub>A)\n(\\<cdot>\\<^sub>B) F G)\n                                  b \\<rightarrow>\\<^sub>A a\\<guillemotright>)", "hence \"?F g = (THE f. ?P f)\""], ["proof (prove)\nusing this:\n  \\<guillemotleft>(SOME F.\n                      inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F\n                       G)\n                   g : (SOME F.\n                           inverse_functors (\\<cdot>\\<^sub>A)\n                            (\\<cdot>\\<^sub>B) F G)\n                        b \\<rightarrow>\\<^sub>A a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. (SOME F. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G) g =\n    (THE f.\n        \\<guillemotleft>f : (SOME F.\n                                inverse_functors (\\<cdot>\\<^sub>A)\n                                 (\\<cdot>\\<^sub>B) F G)\n                             b \\<rightarrow>\\<^sub>A a\\<guillemotright>)", "using assms 1 3 A.terminal_def"], ["proof (prove)\nusing this:\n  \\<guillemotleft>(SOME F.\n                      inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F\n                       G)\n                   g : (SOME F.\n                           inverse_functors (\\<cdot>\\<^sub>A)\n                            (\\<cdot>\\<^sub>B) F G)\n                        b \\<rightarrow>\\<^sub>A a\\<guillemotright>\n  A.terminal a\n  \\<exists>!f.\n     \\<guillemotleft>f : (SOME F.\n                             inverse_functors (\\<cdot>\\<^sub>A)\n                              (\\<cdot>\\<^sub>B) F G)\n                          b \\<rightarrow>\\<^sub>A a\\<guillemotright>\n  \\<guillemotleft>THE f.\n                     \\<guillemotleft>f : (SOME F.\n       inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G)\n    b \\<rightarrow>\\<^sub>A a\\<guillemotright> : (SOME F.\n               inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G)\n            b \\<rightarrow>\\<^sub>A a\\<guillemotright>\n  A.terminal ?b \\<equiv>\n  A.ide ?b \\<and>\n  (\\<forall>a.\n      A.ide a \\<longrightarrow>\n      (\\<exists>!f.\n          \\<guillemotleft>f : a \\<rightarrow>\\<^sub>A ?b\\<guillemotright>))\n\ngoal (1 subgoal):\n 1. (SOME F. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G) g =\n    (THE f.\n        \\<guillemotleft>f : (SOME F.\n                                inverse_functors (\\<cdot>\\<^sub>A)\n                                 (\\<cdot>\\<^sub>B) F G)\n                             b \\<rightarrow>\\<^sub>A a\\<guillemotright>)", "by blast"], ["proof (state)\nthis:\n  (SOME F. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G) g =\n  (THE f.\n      \\<guillemotleft>f : (SOME F.\n                              inverse_functors (\\<cdot>\\<^sub>A)\n                               (\\<cdot>\\<^sub>B) F G)\n                           b \\<rightarrow>\\<^sub>A a\\<guillemotright>)\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       \\<guillemotleft>g : b \\<rightarrow>\\<^sub>B G\n              a\\<guillemotright> \\<Longrightarrow>\n       g =\n       G (THE f.\n             \\<guillemotleft>f : (SOME F.\n                                     inverse_functors (\\<cdot>\\<^sub>A)\n(\\<cdot>\\<^sub>B) F G)\n                                  b \\<rightarrow>\\<^sub>A a\\<guillemotright>)", "thus \"g = G (THE f. ?P f)\""], ["proof (prove)\nusing this:\n  (SOME F. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G) g =\n  (THE f.\n      \\<guillemotleft>f : (SOME F.\n                              inverse_functors (\\<cdot>\\<^sub>A)\n                               (\\<cdot>\\<^sub>B) F G)\n                           b \\<rightarrow>\\<^sub>A a\\<guillemotright>)\n\ngoal (1 subgoal):\n 1. g =\n    G (THE f.\n          \\<guillemotleft>f : (SOME F.\n                                  inverse_functors (\\<cdot>\\<^sub>A)\n                                   (\\<cdot>\\<^sub>B) F G)\n                               b \\<rightarrow>\\<^sub>A a\\<guillemotright>)", "using inv g"], ["proof (prove)\nusing this:\n  (SOME F. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G) g =\n  (THE f.\n      \\<guillemotleft>f : (SOME F.\n                              inverse_functors (\\<cdot>\\<^sub>A)\n                               (\\<cdot>\\<^sub>B) F G)\n                           b \\<rightarrow>\\<^sub>A a\\<guillemotright>)\n  G \\<circ>\n  (SOME F. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) F G) =\n  B.map\n  \\<guillemotleft>g : b \\<rightarrow>\\<^sub>B G a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. g =\n    G (THE f.\n          \\<guillemotleft>f : (SOME F.\n                                  inverse_functors (\\<cdot>\\<^sub>A)\n                                   (\\<cdot>\\<^sub>B) F G)\n                               b \\<rightarrow>\\<^sub>A a\\<guillemotright>)", "by (metis B.in_homE B.map_simp comp_def)"], ["proof (state)\nthis:\n  g =\n  G (THE f.\n        \\<guillemotleft>f : (SOME F.\n                                inverse_functors (\\<cdot>\\<^sub>A)\n                                 (\\<cdot>\\<^sub>B) F G)\n                             b \\<rightarrow>\\<^sub>A a\\<guillemotright>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!g.\n     \\<guillemotleft>g : b \\<rightarrow>\\<^sub>B G a\\<guillemotright>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "sublocale invertible_functor \\<subseteq> inverse_functors A B inv G"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) local.inv G", "using inv_is_inverse"], ["proof (prove)\nusing this:\n  inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) local.inv G\n\ngoal (1 subgoal):\n 1. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) local.inv G", "by simp"], ["", "text \\<open>\n    A bijection from a set \\<open>S\\<close> to the set of arrows of a category \\<open>C\\<close> induces an isomorphic\n    copy of \\<open>C\\<close> having \\<open>S\\<close> as its set of arrows, assuming that there exists some \\<open>n \\<notin> S\\<close>\n    to serve as the null.\n  \\<close>"], ["", "context category\n  begin"], ["", "lemma bij_induces_invertible_functor:\n    assumes \"bij_betw \\<phi> S (Collect arr)\" and \"n \\<notin> S\"\n    shows \"\\<exists>C'. Collect (partial_magma.arr C') = S \\<and>\n                invertible_functor C' C (\\<lambda>i. if partial_magma.arr C' i then \\<phi> i else null)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C'.\n       Collect (partial_magma.arr C') = S \\<and>\n       invertible_functor C' (\\<cdot>)\n        (\\<lambda>i. if partial_magma.arr C' i then \\<phi> i else null)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>C'.\n       Collect (partial_magma.arr C') = S \\<and>\n       invertible_functor C' (\\<cdot>)\n        (\\<lambda>i. if partial_magma.arr C' i then \\<phi> i else null)", "define \\<psi> where \"\\<psi> = (\\<lambda>f. if arr f then inv_into S \\<phi> f else n)\""], ["proof (state)\nthis:\n  \\<psi> = (\\<lambda>f. if arr f then inv_into S \\<phi> f else n)\n\ngoal (1 subgoal):\n 1. \\<exists>C'.\n       Collect (partial_magma.arr C') = S \\<and>\n       invertible_functor C' (\\<cdot>)\n        (\\<lambda>i. if partial_magma.arr C' i then \\<phi> i else null)", "have \\<psi>: \"bij_betw \\<psi> (Collect arr) S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw \\<psi> (Collect arr) S", "using assms(1) \\<psi>_def bij_betw_inv_into"], ["proof (prove)\nusing this:\n  bij_betw \\<phi> S (Collect arr)\n  \\<psi> = (\\<lambda>f. if arr f then inv_into S \\<phi> f else n)\n  bij_betw ?f ?A ?B \\<Longrightarrow> bij_betw (inv_into ?A ?f) ?B ?A\n\ngoal (1 subgoal):\n 1. bij_betw \\<psi> (Collect arr) S", "by (metis (no_types, lifting) bij_betw_cong mem_Collect_eq)"], ["proof (state)\nthis:\n  bij_betw \\<psi> (Collect arr) S\n\ngoal (1 subgoal):\n 1. \\<exists>C'.\n       Collect (partial_magma.arr C') = S \\<and>\n       invertible_functor C' (\\<cdot>)\n        (\\<lambda>i. if partial_magma.arr C' i then \\<phi> i else null)", "have \\<phi>_\\<psi> [simp]: \"\\<And>f. arr f \\<Longrightarrow> \\<phi> (\\<psi> f) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f. arr f \\<Longrightarrow> \\<phi> (\\<psi> f) = f", "using assms(1) \\<psi> \\<psi>_def bij_betw_inv_into_right"], ["proof (prove)\nusing this:\n  bij_betw \\<phi> S (Collect arr)\n  bij_betw \\<psi> (Collect arr) S\n  \\<psi> = (\\<lambda>f. if arr f then inv_into S \\<phi> f else n)\n  \\<lbrakk>bij_betw ?f ?A ?A'; ?a' \\<in> ?A'\\<rbrakk>\n  \\<Longrightarrow> ?f (inv_into ?A ?f ?a') = ?a'\n\ngoal (1 subgoal):\n 1. \\<And>f. arr f \\<Longrightarrow> \\<phi> (\\<psi> f) = f", "by fastforce"], ["proof (state)\nthis:\n  arr ?f \\<Longrightarrow> \\<phi> (\\<psi> ?f) = ?f\n\ngoal (1 subgoal):\n 1. \\<exists>C'.\n       Collect (partial_magma.arr C') = S \\<and>\n       invertible_functor C' (\\<cdot>)\n        (\\<lambda>i. if partial_magma.arr C' i then \\<phi> i else null)", "have \\<psi>_\\<phi> [simp]: \"\\<And>i. i \\<in> S \\<Longrightarrow> \\<psi> (\\<phi> i) = i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> S \\<Longrightarrow> \\<psi> (\\<phi> i) = i", "unfolding \\<psi>_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> S \\<Longrightarrow>\n       (if arr (\\<phi> i) then inv_into S \\<phi> (\\<phi> i) else n) = i", "using assms(1) \\<psi> bij_betw_inv_into_left [of \\<phi> S \"Collect arr\"]"], ["proof (prove)\nusing this:\n  bij_betw \\<phi> S (Collect arr)\n  bij_betw \\<psi> (Collect arr) S\n  \\<lbrakk>bij_betw \\<phi> S (Collect arr); ?a \\<in> S\\<rbrakk>\n  \\<Longrightarrow> inv_into S \\<phi> (\\<phi> ?a) = ?a\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> S \\<Longrightarrow>\n       (if arr (\\<phi> i) then inv_into S \\<phi> (\\<phi> i) else n) = i", "by (metis bij_betw_def image_eqI mem_Collect_eq)"], ["proof (state)\nthis:\n  ?i \\<in> S \\<Longrightarrow> \\<psi> (\\<phi> ?i) = ?i\n\ngoal (1 subgoal):\n 1. \\<exists>C'.\n       Collect (partial_magma.arr C') = S \\<and>\n       invertible_functor C' (\\<cdot>)\n        (\\<lambda>i. if partial_magma.arr C' i then \\<phi> i else null)", "define C' where \"C' = (\\<lambda>i j. if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j) then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\""], ["proof (state)\nthis:\n  C' =\n  (\\<lambda>i j.\n      if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n      then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n\ngoal (1 subgoal):\n 1. \\<exists>C'.\n       Collect (partial_magma.arr C') = S \\<and>\n       invertible_functor C' (\\<cdot>)\n        (\\<lambda>i. if partial_magma.arr C' i then \\<phi> i else null)", "interpret C': partial_magma C'"], ["proof (prove)\ngoal (1 subgoal):\n 1. partial_magma C'", "using assms(1-2) C'_def \\<psi>_def"], ["proof (prove)\nusing this:\n  bij_betw \\<phi> S (Collect arr)\n  n \\<notin> S\n  C' =\n  (\\<lambda>i j.\n      if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n      then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n  \\<psi> = (\\<lambda>f. if arr f then inv_into S \\<phi> f else n)\n\ngoal (1 subgoal):\n 1. partial_magma C'", "by unfold_locales metis"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>C'.\n       Collect (partial_magma.arr C') = S \\<and>\n       invertible_functor C' (\\<cdot>)\n        (\\<lambda>i. if partial_magma.arr C' i then \\<phi> i else null)", "have null_char: \"C'.null = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C'.null = n", "using assms(1-2) C'_def \\<psi>_def C'.null_eqI"], ["proof (prove)\nusing this:\n  bij_betw \\<phi> S (Collect arr)\n  n \\<notin> S\n  C' =\n  (\\<lambda>i j.\n      if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n      then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n  \\<psi> = (\\<lambda>f. if arr f then inv_into S \\<phi> f else n)\n  (\\<And>f. C' ?n f = ?n \\<and> C' f ?n = ?n) \\<Longrightarrow> ?n = C'.null\n\ngoal (1 subgoal):\n 1. C'.null = n", "by metis"], ["proof (state)\nthis:\n  C'.null = n\n\ngoal (1 subgoal):\n 1. \\<exists>C'.\n       Collect (partial_magma.arr C') = S \\<and>\n       invertible_functor C' (\\<cdot>)\n        (\\<lambda>i. if partial_magma.arr C' i then \\<phi> i else null)", "have ide_char: \"\\<And>i. C'.ide i \\<longleftrightarrow> i \\<in> S \\<and> ide (\\<phi> i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. C'.ide i = (i \\<in> S \\<and> ide (\\<phi> i))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i. C'.ide i \\<Longrightarrow> i \\<in> S \\<and> ide (\\<phi> i)\n 2. \\<And>i. i \\<in> S \\<and> ide (\\<phi> i) \\<Longrightarrow> C'.ide i", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i. C'.ide i \\<Longrightarrow> i \\<in> S \\<and> ide (\\<phi> i)\n 2. \\<And>i. i \\<in> S \\<and> ide (\\<phi> i) \\<Longrightarrow> C'.ide i", "assume i: \"C'.ide i\""], ["proof (state)\nthis:\n  C'.ide i\n\ngoal (2 subgoals):\n 1. \\<And>i. C'.ide i \\<Longrightarrow> i \\<in> S \\<and> ide (\\<phi> i)\n 2. \\<And>i. i \\<in> S \\<and> ide (\\<phi> i) \\<Longrightarrow> C'.ide i", "show \"i \\<in> S \\<and> ide (\\<phi> i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> S \\<and> ide (\\<phi> i)", "proof (unfold ide_def, intro conjI)"], ["proof (state)\ngoal (3 subgoals):\n 1. i \\<in> S\n 2. \\<phi> i \\<cdot> \\<phi> i \\<noteq> null\n 3. \\<forall>f.\n       (f \\<cdot> \\<phi> i \\<noteq> null \\<longrightarrow>\n        f \\<cdot> \\<phi> i = f) \\<and>\n       (\\<phi> i \\<cdot> f \\<noteq> null \\<longrightarrow>\n        \\<phi> i \\<cdot> f = f)", "show 1: \"\\<phi> i \\<cdot> \\<phi> i \\<noteq> null\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> i \\<cdot> \\<phi> i \\<noteq> null", "using i assms(1) C'.ide_def C'_def null_char"], ["proof (prove)\nusing this:\n  C'.ide i\n  bij_betw \\<phi> S (Collect arr)\n  C'.ide ?a \\<equiv>\n  C' ?a ?a \\<noteq> C'.null \\<and>\n  (\\<forall>f.\n      (C' f ?a \\<noteq> C'.null \\<longrightarrow> C' f ?a = f) \\<and>\n      (C' ?a f \\<noteq> C'.null \\<longrightarrow> C' ?a f = f))\n  C' =\n  (\\<lambda>i j.\n      if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n      then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n  C'.null = n\n\ngoal (1 subgoal):\n 1. \\<phi> i \\<cdot> \\<phi> i \\<noteq> null", "by auto"], ["proof (state)\nthis:\n  \\<phi> i \\<cdot> \\<phi> i \\<noteq> null\n\ngoal (2 subgoals):\n 1. i \\<in> S\n 2. \\<forall>f.\n       (f \\<cdot> \\<phi> i \\<noteq> null \\<longrightarrow>\n        f \\<cdot> \\<phi> i = f) \\<and>\n       (\\<phi> i \\<cdot> f \\<noteq> null \\<longrightarrow>\n        \\<phi> i \\<cdot> f = f)", "show 2: \"i \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> S", "using 1 assms(1)"], ["proof (prove)\nusing this:\n  \\<phi> i \\<cdot> \\<phi> i \\<noteq> null\n  bij_betw \\<phi> S (Collect arr)\n\ngoal (1 subgoal):\n 1. i \\<in> S", "by (metis C'.ide_def C'_def i)"], ["proof (state)\nthis:\n  i \\<in> S\n\ngoal (1 subgoal):\n 1. \\<forall>f.\n       (f \\<cdot> \\<phi> i \\<noteq> null \\<longrightarrow>\n        f \\<cdot> \\<phi> i = f) \\<and>\n       (\\<phi> i \\<cdot> f \\<noteq> null \\<longrightarrow>\n        \\<phi> i \\<cdot> f = f)", "show \"\\<forall>f. (f \\<cdot> \\<phi> i \\<noteq> null \\<longrightarrow> f \\<cdot> \\<phi> i = f) \\<and> (\\<phi> i \\<cdot> f \\<noteq> null \\<longrightarrow> \\<phi> i \\<cdot> f = f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>f.\n       (f \\<cdot> \\<phi> i \\<noteq> null \\<longrightarrow>\n        f \\<cdot> \\<phi> i = f) \\<and>\n       (\\<phi> i \\<cdot> f \\<noteq> null \\<longrightarrow>\n        \\<phi> i \\<cdot> f = f)", "proof (intro allI conjI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f.\n       f \\<cdot> \\<phi> i \\<noteq> null \\<Longrightarrow>\n       f \\<cdot> \\<phi> i = f\n 2. \\<And>f.\n       \\<phi> i \\<cdot> f \\<noteq> null \\<Longrightarrow>\n       \\<phi> i \\<cdot> f = f", "show \"\\<And>f. f \\<cdot> \\<phi> i \\<noteq> null \\<Longrightarrow> f \\<cdot> \\<phi> i = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<cdot> \\<phi> i \\<noteq> null \\<Longrightarrow>\n       f \\<cdot> \\<phi> i = f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<cdot> \\<phi> i \\<noteq> null \\<Longrightarrow>\n       f \\<cdot> \\<phi> i = f", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<cdot> \\<phi> i \\<noteq> null \\<Longrightarrow>\n       f \\<cdot> \\<phi> i = f", "assume f: \"f \\<cdot> \\<phi> i \\<noteq> null\""], ["proof (state)\nthis:\n  f \\<cdot> \\<phi> i \\<noteq> null\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<cdot> \\<phi> i \\<noteq> null \\<Longrightarrow>\n       f \\<cdot> \\<phi> i = f", "hence 1: \"arr f \\<and> arr (\\<phi> i) \\<and> seq f (\\<phi> i)\""], ["proof (prove)\nusing this:\n  f \\<cdot> \\<phi> i \\<noteq> null\n\ngoal (1 subgoal):\n 1. arr f \\<and> arr (\\<phi> i) \\<and> seq f (\\<phi> i)", "by (meson seqE ext)"], ["proof (state)\nthis:\n  arr f \\<and> arr (\\<phi> i) \\<and> seq f (\\<phi> i)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<cdot> \\<phi> i \\<noteq> null \\<Longrightarrow>\n       f \\<cdot> \\<phi> i = f", "have \"f \\<cdot> \\<phi> i = \\<phi> (C' (\\<psi> f) i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<cdot> \\<phi> i = \\<phi> (C' (\\<psi> f) i)", "using 1 2 C'_def null_char"], ["proof (prove)\nusing this:\n  arr f \\<and> arr (\\<phi> i) \\<and> seq f (\\<phi> i)\n  i \\<in> S\n  C' =\n  (\\<lambda>i j.\n      if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n      then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n  C'.null = n\n\ngoal (1 subgoal):\n 1. f \\<cdot> \\<phi> i = \\<phi> (C' (\\<psi> f) i)", "by (metis (no_types, lifting) \\<phi>_\\<psi> \\<psi> bij_betw_def image_eqI mem_Collect_eq)"], ["proof (state)\nthis:\n  f \\<cdot> \\<phi> i = \\<phi> (C' (\\<psi> f) i)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<cdot> \\<phi> i \\<noteq> null \\<Longrightarrow>\n       f \\<cdot> \\<phi> i = f", "also"], ["proof (state)\nthis:\n  f \\<cdot> \\<phi> i = \\<phi> (C' (\\<psi> f) i)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<cdot> \\<phi> i \\<noteq> null \\<Longrightarrow>\n       f \\<cdot> \\<phi> i = f", "have \"... = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> (C' (\\<psi> f) i) = f", "by (metis 1 C'.ide_def C'_def \\<phi>_\\<psi> \\<psi> assms(2) bij_betw_def i image_eqI\n                    mem_Collect_eq null_char)"], ["proof (state)\nthis:\n  \\<phi> (C' (\\<psi> f) i) = f\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<cdot> \\<phi> i \\<noteq> null \\<Longrightarrow>\n       f \\<cdot> \\<phi> i = f", "finally"], ["proof (chain)\npicking this:\n  f \\<cdot> \\<phi> i = f", "show \"f \\<cdot> \\<phi> i = f\""], ["proof (prove)\nusing this:\n  f \\<cdot> \\<phi> i = f\n\ngoal (1 subgoal):\n 1. f \\<cdot> \\<phi> i = f", "by simp"], ["proof (state)\nthis:\n  f \\<cdot> \\<phi> i = f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?f \\<cdot> \\<phi> i \\<noteq> null \\<Longrightarrow>\n  ?f \\<cdot> \\<phi> i = ?f\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<phi> i \\<cdot> f \\<noteq> null \\<Longrightarrow>\n       \\<phi> i \\<cdot> f = f", "show \"\\<And>f. \\<phi> i \\<cdot> f \\<noteq> null \\<Longrightarrow> \\<phi> i \\<cdot> f = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<phi> i \\<cdot> f \\<noteq> null \\<Longrightarrow>\n       \\<phi> i \\<cdot> f = f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<phi> i \\<cdot> f \\<noteq> null \\<Longrightarrow>\n       \\<phi> i \\<cdot> f = f", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<phi> i \\<cdot> f \\<noteq> null \\<Longrightarrow>\n       \\<phi> i \\<cdot> f = f", "assume f: \"\\<phi> i \\<cdot> f \\<noteq> null\""], ["proof (state)\nthis:\n  \\<phi> i \\<cdot> f \\<noteq> null\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<phi> i \\<cdot> f \\<noteq> null \\<Longrightarrow>\n       \\<phi> i \\<cdot> f = f", "hence 1: \"arr f \\<and> arr (\\<phi> i) \\<and> seq (\\<phi> i) f\""], ["proof (prove)\nusing this:\n  \\<phi> i \\<cdot> f \\<noteq> null\n\ngoal (1 subgoal):\n 1. arr f \\<and> arr (\\<phi> i) \\<and> seq (\\<phi> i) f", "by (meson seqE ext)"], ["proof (state)\nthis:\n  arr f \\<and> arr (\\<phi> i) \\<and> seq (\\<phi> i) f\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<phi> i \\<cdot> f \\<noteq> null \\<Longrightarrow>\n       \\<phi> i \\<cdot> f = f", "show \"\\<phi> i \\<cdot> f = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> i \\<cdot> f = f", "using 1 2 C'_def null_char \\<psi>"], ["proof (prove)\nusing this:\n  arr f \\<and> arr (\\<phi> i) \\<and> seq (\\<phi> i) f\n  i \\<in> S\n  C' =\n  (\\<lambda>i j.\n      if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n      then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n  C'.null = n\n  bij_betw \\<psi> (Collect arr) S\n\ngoal (1 subgoal):\n 1. \\<phi> i \\<cdot> f = f", "by (metis (no_types, lifting) \\<open>\\<And>f. f \\<cdot> \\<phi> i \\<noteq> null \\<Longrightarrow> f \\<cdot> \\<phi> i = f\\<close>\n                    ide_char' codomains_null comp_cod_arr has_codomain_iff_arr\n                    comp_ide_arr)"], ["proof (state)\nthis:\n  \\<phi> i \\<cdot> f = f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<phi> i \\<cdot> ?f \\<noteq> null \\<Longrightarrow>\n  \\<phi> i \\<cdot> ?f = ?f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>f.\n     (f \\<cdot> \\<phi> i \\<noteq> null \\<longrightarrow>\n      f \\<cdot> \\<phi> i = f) \\<and>\n     (\\<phi> i \\<cdot> f \\<noteq> null \\<longrightarrow>\n      \\<phi> i \\<cdot> f = f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  i \\<in> S \\<and> ide (\\<phi> i)\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> S \\<and> ide (\\<phi> i) \\<Longrightarrow> C'.ide i", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> S \\<and> ide (\\<phi> i) \\<Longrightarrow> C'.ide i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> S \\<and> ide (\\<phi> i) \\<Longrightarrow> C'.ide i", "assume i: \"i \\<in> S \\<and> ide (\\<phi> i)\""], ["proof (state)\nthis:\n  i \\<in> S \\<and> ide (\\<phi> i)\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> S \\<and> ide (\\<phi> i) \\<Longrightarrow> C'.ide i", "have \"\\<psi> (\\<phi> i) \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> (\\<phi> i) \\<in> S", "using i assms(1)"], ["proof (prove)\nusing this:\n  i \\<in> S \\<and> ide (\\<phi> i)\n  bij_betw \\<phi> S (Collect arr)\n\ngoal (1 subgoal):\n 1. \\<psi> (\\<phi> i) \\<in> S", "by (metis \\<psi> bij_betw_def ideD(1) image_eqI mem_Collect_eq)"], ["proof (state)\nthis:\n  \\<psi> (\\<phi> i) \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<in> S \\<and> ide (\\<phi> i) \\<Longrightarrow> C'.ide i", "show \"C'.ide i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C'.ide i", "using assms(2) i C'_def null_char comp_arr_ide comp_ide_arr"], ["proof (prove)\nusing this:\n  n \\<notin> S\n  i \\<in> S \\<and> ide (\\<phi> i)\n  C' =\n  (\\<lambda>i j.\n      if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n      then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n  C'.null = n\n  \\<lbrakk>ide ?a; seq ?f ?a\\<rbrakk> \\<Longrightarrow> ?f \\<cdot> ?a = ?f\n  \\<lbrakk>ide ?b; seq ?b ?f\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n\ngoal (1 subgoal):\n 1. C'.ide i", "apply (unfold C'.ide_def, intro conjI allI impI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>n \\<notin> S; i \\<in> S \\<and> ide (\\<phi> i);\n     C' =\n     (\\<lambda>i j.\n         if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n         then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n);\n     C'.null = n;\n     \\<And>a f.\n        \\<lbrakk>ide a; seq f a\\<rbrakk> \\<Longrightarrow> f \\<cdot> a = f;\n     \\<And>b f.\n        \\<lbrakk>ide b; seq b f\\<rbrakk> \\<Longrightarrow> b \\<cdot> f = f;\n     n \\<notin> S; i \\<in> S \\<and> ide (\\<phi> i);\n     C' =\n     (\\<lambda>i j.\n         if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n         then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n);\n     C'.null = n;\n     \\<And>a f.\n        \\<lbrakk>ide a; seq f a\\<rbrakk> \\<Longrightarrow> f \\<cdot> a = f;\n     \\<And>b f.\n        \\<lbrakk>ide b; seq b f\\<rbrakk>\n        \\<Longrightarrow> b \\<cdot> f = f\\<rbrakk>\n    \\<Longrightarrow> C' i i \\<noteq> C'.null\n 2. \\<And>f.\n       \\<lbrakk>n \\<notin> S; i \\<in> S \\<and> ide (\\<phi> i);\n        C' =\n        (\\<lambda>i j.\n            if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n            then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n);\n        C'.null = n;\n        \\<And>a f.\n           \\<lbrakk>ide a; seq f a\\<rbrakk>\n           \\<Longrightarrow> f \\<cdot> a = f;\n        \\<And>b f.\n           \\<lbrakk>ide b; seq b f\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        n \\<notin> S; i \\<in> S \\<and> ide (\\<phi> i);\n        C' =\n        (\\<lambda>i j.\n            if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n            then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n);\n        C'.null = n;\n        \\<And>a f.\n           \\<lbrakk>ide a; seq f a\\<rbrakk>\n           \\<Longrightarrow> f \\<cdot> a = f;\n        \\<And>b f.\n           \\<lbrakk>ide b; seq b f\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        C' f i \\<noteq> C'.null\\<rbrakk>\n       \\<Longrightarrow> C' f i = f\n 3. \\<And>f.\n       \\<lbrakk>n \\<notin> S; i \\<in> S \\<and> ide (\\<phi> i);\n        C' =\n        (\\<lambda>i j.\n            if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n            then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n);\n        C'.null = n;\n        \\<And>a f.\n           \\<lbrakk>ide a; seq f a\\<rbrakk>\n           \\<Longrightarrow> f \\<cdot> a = f;\n        \\<And>b f.\n           \\<lbrakk>ide b; seq b f\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        n \\<notin> S; i \\<in> S \\<and> ide (\\<phi> i);\n        C' =\n        (\\<lambda>i j.\n            if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n            then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n);\n        C'.null = n;\n        \\<And>a f.\n           \\<lbrakk>ide a; seq f a\\<rbrakk>\n           \\<Longrightarrow> f \\<cdot> a = f;\n        \\<And>b f.\n           \\<lbrakk>ide b; seq b f\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        C' i f \\<noteq> C'.null\\<rbrakk>\n       \\<Longrightarrow> C' i f = f", "apply auto[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>n \\<notin> S; i \\<in> S \\<and> ide (\\<phi> i);\n        C' =\n        (\\<lambda>i j.\n            if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n            then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n);\n        C'.null = n;\n        \\<And>a f.\n           \\<lbrakk>ide a; seq f a\\<rbrakk>\n           \\<Longrightarrow> f \\<cdot> a = f;\n        \\<And>b f.\n           \\<lbrakk>ide b; seq b f\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        n \\<notin> S; i \\<in> S \\<and> ide (\\<phi> i);\n        C' =\n        (\\<lambda>i j.\n            if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n            then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n);\n        C'.null = n;\n        \\<And>a f.\n           \\<lbrakk>ide a; seq f a\\<rbrakk>\n           \\<Longrightarrow> f \\<cdot> a = f;\n        \\<And>b f.\n           \\<lbrakk>ide b; seq b f\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        C' f i \\<noteq> C'.null\\<rbrakk>\n       \\<Longrightarrow> C' f i = f\n 2. \\<And>f.\n       \\<lbrakk>n \\<notin> S; i \\<in> S \\<and> ide (\\<phi> i);\n        C' =\n        (\\<lambda>i j.\n            if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n            then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n);\n        C'.null = n;\n        \\<And>a f.\n           \\<lbrakk>ide a; seq f a\\<rbrakk>\n           \\<Longrightarrow> f \\<cdot> a = f;\n        \\<And>b f.\n           \\<lbrakk>ide b; seq b f\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        n \\<notin> S; i \\<in> S \\<and> ide (\\<phi> i);\n        C' =\n        (\\<lambda>i j.\n            if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n            then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n);\n        C'.null = n;\n        \\<And>a f.\n           \\<lbrakk>ide a; seq f a\\<rbrakk>\n           \\<Longrightarrow> f \\<cdot> a = f;\n        \\<And>b f.\n           \\<lbrakk>ide b; seq b f\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        C' i f \\<noteq> C'.null\\<rbrakk>\n       \\<Longrightarrow> C' i f = f", "by force+"], ["proof (state)\nthis:\n  C'.ide i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  C'.ide ?i = (?i \\<in> S \\<and> ide (\\<phi> ?i))\n\ngoal (1 subgoal):\n 1. \\<exists>C'.\n       Collect (partial_magma.arr C') = S \\<and>\n       invertible_functor C' (\\<cdot>)\n        (\\<lambda>i. if partial_magma.arr C' i then \\<phi> i else null)", "have dom: \"\\<And>i. i \\<in> S \\<Longrightarrow> \\<psi> (dom (\\<phi> i)) \\<in> C'.domains i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> S \\<Longrightarrow>\n       \\<psi> (local.dom (\\<phi> i)) \\<in> C'.domains i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> S \\<Longrightarrow>\n       \\<psi> (local.dom (\\<phi> i)) \\<in> C'.domains i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> S \\<Longrightarrow>\n       \\<psi> (local.dom (\\<phi> i)) \\<in> C'.domains i", "assume i: \"i \\<in> S\""], ["proof (state)\nthis:\n  i \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> S \\<Longrightarrow>\n       \\<psi> (local.dom (\\<phi> i)) \\<in> C'.domains i", "have 1: \"C'.ide (\\<psi> (dom (\\<phi> i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C'.ide (\\<psi> (local.dom (\\<phi> i)))", "proof (unfold C'.ide_def, intro conjI allI impI)"], ["proof (state)\ngoal (3 subgoals):\n 1. C' (\\<psi> (local.dom (\\<phi> i)))\n     (\\<psi> (local.dom (\\<phi> i))) \\<noteq>\n    C'.null\n 2. \\<And>f.\n       C' f (\\<psi> (local.dom (\\<phi> i))) \\<noteq>\n       C'.null \\<Longrightarrow>\n       C' f (\\<psi> (local.dom (\\<phi> i))) = f\n 3. \\<And>f.\n       C' (\\<psi> (local.dom (\\<phi> i))) f \\<noteq>\n       C'.null \\<Longrightarrow>\n       C' (\\<psi> (local.dom (\\<phi> i))) f = f", "show \"C' (\\<psi> (dom (\\<phi> i))) (\\<psi> (dom (\\<phi> i))) \\<noteq> C'.null\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C' (\\<psi> (local.dom (\\<phi> i)))\n     (\\<psi> (local.dom (\\<phi> i))) \\<noteq>\n    C'.null", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. C' (\\<psi> (local.dom (\\<phi> i)))\n     (\\<psi> (local.dom (\\<phi> i))) \\<noteq>\n    C'.null", "have \"C' (\\<psi> (dom (\\<phi> i))) (\\<psi> (dom (\\<phi> i))) = \\<psi> (dom (\\<phi> i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C' (\\<psi> (local.dom (\\<phi> i))) (\\<psi> (local.dom (\\<phi> i))) =\n    \\<psi> (local.dom (\\<phi> i))", "using C'_def i assms(1-2) \\<psi> \\<psi>_\\<phi> \\<psi>_def bij_betw_def"], ["proof (prove)\nusing this:\n  C' =\n  (\\<lambda>i j.\n      if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n      then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n  i \\<in> S\n  bij_betw \\<phi> S (Collect arr)\n  n \\<notin> S\n  bij_betw \\<psi> (Collect arr) S\n  ?i \\<in> S \\<Longrightarrow> \\<psi> (\\<phi> ?i) = ?i\n  \\<psi> = (\\<lambda>f. if arr f then inv_into S \\<phi> f else n)\n  bij_betw ?f ?A ?B = (inj_on ?f ?A \\<and> ?f ` ?A = ?B)\n\ngoal (1 subgoal):\n 1. C' (\\<psi> (local.dom (\\<phi> i))) (\\<psi> (local.dom (\\<phi> i))) =\n    \\<psi> (local.dom (\\<phi> i))", "by (metis (no_types, lifting) C'.ide_def \\<phi>_\\<psi> ide_char ide_dom image_eqI\n                  mem_Collect_eq)"], ["proof (state)\nthis:\n  C' (\\<psi> (local.dom (\\<phi> i))) (\\<psi> (local.dom (\\<phi> i))) =\n  \\<psi> (local.dom (\\<phi> i))\n\ngoal (1 subgoal):\n 1. C' (\\<psi> (local.dom (\\<phi> i)))\n     (\\<psi> (local.dom (\\<phi> i))) \\<noteq>\n    C'.null", "moreover"], ["proof (state)\nthis:\n  C' (\\<psi> (local.dom (\\<phi> i))) (\\<psi> (local.dom (\\<phi> i))) =\n  \\<psi> (local.dom (\\<phi> i))\n\ngoal (1 subgoal):\n 1. C' (\\<psi> (local.dom (\\<phi> i)))\n     (\\<psi> (local.dom (\\<phi> i))) \\<noteq>\n    C'.null", "have \"\\<psi> (dom (\\<phi> i)) \\<noteq> C'.null\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> (local.dom (\\<phi> i)) \\<noteq> C'.null", "using i null_char assms(1-2) bij_betw_def"], ["proof (prove)\nusing this:\n  i \\<in> S\n  C'.null = n\n  bij_betw \\<phi> S (Collect arr)\n  n \\<notin> S\n  bij_betw ?f ?A ?B = (inj_on ?f ?A \\<and> ?f ` ?A = ?B)\n\ngoal (1 subgoal):\n 1. \\<psi> (local.dom (\\<phi> i)) \\<noteq> C'.null", "by (metis \\<psi> arr_dom_iff_arr image_iff mem_Collect_eq)"], ["proof (state)\nthis:\n  \\<psi> (local.dom (\\<phi> i)) \\<noteq> C'.null\n\ngoal (1 subgoal):\n 1. C' (\\<psi> (local.dom (\\<phi> i)))\n     (\\<psi> (local.dom (\\<phi> i))) \\<noteq>\n    C'.null", "ultimately"], ["proof (chain)\npicking this:\n  C' (\\<psi> (local.dom (\\<phi> i))) (\\<psi> (local.dom (\\<phi> i))) =\n  \\<psi> (local.dom (\\<phi> i))\n  \\<psi> (local.dom (\\<phi> i)) \\<noteq> C'.null", "show ?thesis"], ["proof (prove)\nusing this:\n  C' (\\<psi> (local.dom (\\<phi> i))) (\\<psi> (local.dom (\\<phi> i))) =\n  \\<psi> (local.dom (\\<phi> i))\n  \\<psi> (local.dom (\\<phi> i)) \\<noteq> C'.null\n\ngoal (1 subgoal):\n 1. C' (\\<psi> (local.dom (\\<phi> i)))\n     (\\<psi> (local.dom (\\<phi> i))) \\<noteq>\n    C'.null", "by simp"], ["proof (state)\nthis:\n  C' (\\<psi> (local.dom (\\<phi> i)))\n   (\\<psi> (local.dom (\\<phi> i))) \\<noteq>\n  C'.null\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  C' (\\<psi> (local.dom (\\<phi> i)))\n   (\\<psi> (local.dom (\\<phi> i))) \\<noteq>\n  C'.null\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       C' f (\\<psi> (local.dom (\\<phi> i))) \\<noteq>\n       C'.null \\<Longrightarrow>\n       C' f (\\<psi> (local.dom (\\<phi> i))) = f\n 2. \\<And>f.\n       C' (\\<psi> (local.dom (\\<phi> i))) f \\<noteq>\n       C'.null \\<Longrightarrow>\n       C' (\\<psi> (local.dom (\\<phi> i))) f = f", "show \"\\<And>j. C' j (\\<psi> (dom (\\<phi> i))) \\<noteq> C'.null \\<Longrightarrow> C' j (\\<psi> (dom (\\<phi> i))) = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       C' j (\\<psi> (local.dom (\\<phi> i))) \\<noteq>\n       C'.null \\<Longrightarrow>\n       C' j (\\<psi> (local.dom (\\<phi> i))) = j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       C' j (\\<psi> (local.dom (\\<phi> i))) \\<noteq>\n       C'.null \\<Longrightarrow>\n       C' j (\\<psi> (local.dom (\\<phi> i))) = j", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       C' j (\\<psi> (local.dom (\\<phi> i))) \\<noteq>\n       C'.null \\<Longrightarrow>\n       C' j (\\<psi> (local.dom (\\<phi> i))) = j", "assume j: \"C' j (\\<psi> (dom (\\<phi> i))) \\<noteq> C'.null\""], ["proof (state)\nthis:\n  C' j (\\<psi> (local.dom (\\<phi> i))) \\<noteq> C'.null\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       C' j (\\<psi> (local.dom (\\<phi> i))) \\<noteq>\n       C'.null \\<Longrightarrow>\n       C' j (\\<psi> (local.dom (\\<phi> i))) = j", "show \"C' j (\\<psi> (dom (\\<phi> i))) = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C' j (\\<psi> (local.dom (\\<phi> i))) = j", "using j \\<phi>_\\<psi> \\<psi>_def ide_char null_char"], ["proof (prove)\nusing this:\n  C' j (\\<psi> (local.dom (\\<phi> i))) \\<noteq> C'.null\n  arr ?f \\<Longrightarrow> \\<phi> (\\<psi> ?f) = ?f\n  \\<psi> = (\\<lambda>f. if arr f then inv_into S \\<phi> f else n)\n  C'.ide ?i = (?i \\<in> S \\<and> ide (\\<phi> ?i))\n  C'.null = n\n\ngoal (1 subgoal):\n 1. C' j (\\<psi> (local.dom (\\<phi> i))) = j", "by (metis C'.comp_null(2) C'.ide_def C'_def\n                  \\<open>C' (\\<psi> (dom (\\<phi> i))) (\\<psi> (dom (\\<phi> i))) \\<noteq> C'.null\\<close>\n                  arr_dom_iff_arr ide_dom)"], ["proof (state)\nthis:\n  C' j (\\<psi> (local.dom (\\<phi> i))) = j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  C' ?j (\\<psi> (local.dom (\\<phi> i))) \\<noteq> C'.null \\<Longrightarrow>\n  C' ?j (\\<psi> (local.dom (\\<phi> i))) = ?j\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       C' (\\<psi> (local.dom (\\<phi> i))) f \\<noteq>\n       C'.null \\<Longrightarrow>\n       C' (\\<psi> (local.dom (\\<phi> i))) f = f", "show \"\\<And>j. C' (\\<psi> (dom (\\<phi> i))) j \\<noteq> C'.null \\<Longrightarrow> C' (\\<psi> (dom (\\<phi> i))) j = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       C' (\\<psi> (local.dom (\\<phi> i))) j \\<noteq>\n       C'.null \\<Longrightarrow>\n       C' (\\<psi> (local.dom (\\<phi> i))) j = j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       C' (\\<psi> (local.dom (\\<phi> i))) j \\<noteq>\n       C'.null \\<Longrightarrow>\n       C' (\\<psi> (local.dom (\\<phi> i))) j = j", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       C' (\\<psi> (local.dom (\\<phi> i))) j \\<noteq>\n       C'.null \\<Longrightarrow>\n       C' (\\<psi> (local.dom (\\<phi> i))) j = j", "assume j: \"C' (\\<psi> (dom (\\<phi> i))) j \\<noteq> C'.null\""], ["proof (state)\nthis:\n  C' (\\<psi> (local.dom (\\<phi> i))) j \\<noteq> C'.null\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       C' (\\<psi> (local.dom (\\<phi> i))) j \\<noteq>\n       C'.null \\<Longrightarrow>\n       C' (\\<psi> (local.dom (\\<phi> i))) j = j", "show \"C' (\\<psi> (dom (\\<phi> i))) j = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C' (\\<psi> (local.dom (\\<phi> i))) j = j", "using j"], ["proof (prove)\nusing this:\n  C' (\\<psi> (local.dom (\\<phi> i))) j \\<noteq> C'.null\n\ngoal (1 subgoal):\n 1. C' (\\<psi> (local.dom (\\<phi> i))) j = j", "by (metis C'.ide_def C'_def\n                  \\<open>C' (\\<psi> (dom (\\<phi> i))) (\\<psi> (dom (\\<phi> i))) \\<noteq> C'.null\\<close>\n                  \\<open>\\<And>j. C' j (\\<psi> (dom (\\<phi> i))) \\<noteq> C'.null \\<Longrightarrow> C' j (\\<psi> (dom (\\<phi> i))) = j\\<close>\n                  \\<phi>_\\<psi> \\<psi>_def arr_dom_iff_arr ide_char ide_dom null_char)"], ["proof (state)\nthis:\n  C' (\\<psi> (local.dom (\\<phi> i))) j = j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  C' (\\<psi> (local.dom (\\<phi> i))) ?j \\<noteq> C'.null \\<Longrightarrow>\n  C' (\\<psi> (local.dom (\\<phi> i))) ?j = ?j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  C'.ide (\\<psi> (local.dom (\\<phi> i)))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> S \\<Longrightarrow>\n       \\<psi> (local.dom (\\<phi> i)) \\<in> C'.domains i", "moreover"], ["proof (state)\nthis:\n  C'.ide (\\<psi> (local.dom (\\<phi> i)))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> S \\<Longrightarrow>\n       \\<psi> (local.dom (\\<phi> i)) \\<in> C'.domains i", "have \"C' i (\\<psi> (dom (\\<phi> i))) \\<noteq> C'.null\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C' i (\\<psi> (local.dom (\\<phi> i))) \\<noteq> C'.null", "using i 1 assms(1-2) C'_def null_char ide_char \\<phi>_\\<psi> \\<psi>_\\<phi> \\<psi>_def comp_arr_dom"], ["proof (prove)\nusing this:\n  i \\<in> S\n  C'.ide (\\<psi> (local.dom (\\<phi> i)))\n  bij_betw \\<phi> S (Collect arr)\n  n \\<notin> S\n  C' =\n  (\\<lambda>i j.\n      if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n      then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n  C'.null = n\n  C'.ide ?i = (?i \\<in> S \\<and> ide (\\<phi> ?i))\n  arr ?f \\<Longrightarrow> \\<phi> (\\<psi> ?f) = ?f\n  ?i \\<in> S \\<Longrightarrow> \\<psi> (\\<phi> ?i) = ?i\n  \\<psi> = (\\<lambda>f. if arr f then inv_into S \\<phi> f else n)\n  \\<lbrakk>arr ?f; local.dom ?f = ?a\\<rbrakk>\n  \\<Longrightarrow> ?f \\<cdot> ?a = ?f\n\ngoal (1 subgoal):\n 1. C' i (\\<psi> (local.dom (\\<phi> i))) \\<noteq> C'.null", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<in> S;\n     (if arr (local.dom (\\<phi> i))\n      then inv_into S \\<phi> (local.dom (\\<phi> i)) else n)\n     \\<in> S \\<and>\n     ide (\\<phi>\n           (if arr (local.dom (\\<phi> i))\n            then inv_into S \\<phi> (local.dom (\\<phi> i)) else n));\n     bij_betw \\<phi> S (Collect arr); n \\<notin> S;\n     C' =\n     (\\<lambda>i j.\n         if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n         then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n);\n     partial_magma.null\n      (\\<lambda>i j.\n          if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n          then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n) =\n     n;\n     \\<And>i.\n        partial_magma.ide\n         (\\<lambda>i j.\n             if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n         i =\n        (i \\<in> S \\<and> ide (\\<phi> i));\n     \\<And>f. arr f \\<Longrightarrow> \\<phi> (inv_into S \\<phi> f) = f;\n     \\<And>i.\n        i \\<in> S \\<Longrightarrow>\n        (if arr (\\<phi> i) then inv_into S \\<phi> (\\<phi> i) else n) = i;\n     \\<psi> = (\\<lambda>f. if arr f then inv_into S \\<phi> f else n);\n     \\<And>f a.\n        \\<lbrakk>arr f; local.dom f = a\\<rbrakk>\n        \\<Longrightarrow> f \\<cdot> a = f\\<rbrakk>\n    \\<Longrightarrow> (arr (local.dom (\\<phi> i)) \\<longrightarrow>\n                       (seq (\\<phi> i)\n                         (local.dom (\\<phi> i)) \\<longrightarrow>\n                        inv_into S \\<phi>\n                         (\\<phi> i \\<cdot> local.dom (\\<phi> i)) \\<noteq>\n                        n) \\<and>\n                       seq (\\<phi> i) (local.dom (\\<phi> i))) \\<and>\n                      (\\<not> arr (local.dom (\\<phi> i)) \\<longrightarrow>\n                       (seq (\\<phi> i) (\\<phi> n) \\<longrightarrow>\n                        inv_into S \\<phi>\n                         (\\<phi> i \\<cdot> \\<phi> n) \\<noteq>\n                        n) \\<and>\n                       seq (\\<phi> i) (\\<phi> n))", "by (metis (no_types, lifting))"], ["proof (state)\nthis:\n  C' i (\\<psi> (local.dom (\\<phi> i))) \\<noteq> C'.null\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> S \\<Longrightarrow>\n       \\<psi> (local.dom (\\<phi> i)) \\<in> C'.domains i", "ultimately"], ["proof (chain)\npicking this:\n  C'.ide (\\<psi> (local.dom (\\<phi> i)))\n  C' i (\\<psi> (local.dom (\\<phi> i))) \\<noteq> C'.null", "show \"\\<psi> (dom (\\<phi> i)) \\<in> C'.domains i\""], ["proof (prove)\nusing this:\n  C'.ide (\\<psi> (local.dom (\\<phi> i)))\n  C' i (\\<psi> (local.dom (\\<phi> i))) \\<noteq> C'.null\n\ngoal (1 subgoal):\n 1. \\<psi> (local.dom (\\<phi> i)) \\<in> C'.domains i", "using C'.domains_def"], ["proof (prove)\nusing this:\n  C'.ide (\\<psi> (local.dom (\\<phi> i)))\n  C' i (\\<psi> (local.dom (\\<phi> i))) \\<noteq> C'.null\n  C'.domains ?f \\<equiv> {a. C'.ide a \\<and> C' ?f a \\<noteq> C'.null}\n\ngoal (1 subgoal):\n 1. \\<psi> (local.dom (\\<phi> i)) \\<in> C'.domains i", "by simp"], ["proof (state)\nthis:\n  \\<psi> (local.dom (\\<phi> i)) \\<in> C'.domains i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i \\<in> S \\<Longrightarrow>\n  \\<psi> (local.dom (\\<phi> ?i)) \\<in> C'.domains ?i\n\ngoal (1 subgoal):\n 1. \\<exists>C'.\n       Collect (partial_magma.arr C') = S \\<and>\n       invertible_functor C' (\\<cdot>)\n        (\\<lambda>i. if partial_magma.arr C' i then \\<phi> i else null)", "have cod: \"\\<And>i. i \\<in> S \\<Longrightarrow> \\<psi> (cod (\\<phi> i)) \\<in> C'.codomains i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> S \\<Longrightarrow>\n       \\<psi> (cod (\\<phi> i)) \\<in> C'.codomains i", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> S \\<Longrightarrow>\n       \\<psi> (cod (\\<phi> i)) \\<in> C'.codomains i", "fix i"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> S \\<Longrightarrow>\n       \\<psi> (cod (\\<phi> i)) \\<in> C'.codomains i", "assume i: \"i \\<in> S\""], ["proof (state)\nthis:\n  i \\<in> S\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> S \\<Longrightarrow>\n       \\<psi> (cod (\\<phi> i)) \\<in> C'.codomains i", "have 1: \"C'.ide (\\<psi> (cod (\\<phi> i)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C'.ide (\\<psi> (cod (\\<phi> i)))", "proof (unfold C'.ide_def, intro conjI allI impI)"], ["proof (state)\ngoal (3 subgoals):\n 1. C' (\\<psi> (cod (\\<phi> i))) (\\<psi> (cod (\\<phi> i))) \\<noteq> C'.null\n 2. \\<And>f.\n       C' f (\\<psi> (cod (\\<phi> i))) \\<noteq> C'.null \\<Longrightarrow>\n       C' f (\\<psi> (cod (\\<phi> i))) = f\n 3. \\<And>f.\n       C' (\\<psi> (cod (\\<phi> i))) f \\<noteq> C'.null \\<Longrightarrow>\n       C' (\\<psi> (cod (\\<phi> i))) f = f", "show \"C' (\\<psi> (cod (\\<phi> i))) (\\<psi> (cod (\\<phi> i))) \\<noteq> C'.null\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C' (\\<psi> (cod (\\<phi> i))) (\\<psi> (cod (\\<phi> i))) \\<noteq> C'.null", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. C' (\\<psi> (cod (\\<phi> i))) (\\<psi> (cod (\\<phi> i))) \\<noteq> C'.null", "have \"C' (\\<psi> (cod (\\<phi> i))) (\\<psi> (cod (\\<phi> i))) = \\<psi> (cod (\\<phi> i))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C' (\\<psi> (cod (\\<phi> i))) (\\<psi> (cod (\\<phi> i))) =\n    \\<psi> (cod (\\<phi> i))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. C' (\\<psi> (cod (\\<phi> i))) (\\<psi> (cod (\\<phi> i))) =\n    \\<psi> (cod (\\<phi> i))", "have \"\\<phi> (\\<psi> (cod (\\<phi> i))) = cod (\\<phi> i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> (\\<psi> (cod (\\<phi> i))) = cod (\\<phi> i)", "using i assms(1-2) \\<phi>_\\<psi> \\<psi>_\\<phi> \\<psi>_def arr_cod_iff_arr"], ["proof (prove)\nusing this:\n  i \\<in> S\n  bij_betw \\<phi> S (Collect arr)\n  n \\<notin> S\n  arr ?f \\<Longrightarrow> \\<phi> (\\<psi> ?f) = ?f\n  ?i \\<in> S \\<Longrightarrow> \\<psi> (\\<phi> ?i) = ?i\n  \\<psi> = (\\<lambda>f. if arr f then inv_into S \\<phi> f else n)\n  arr (cod ?f) = arr ?f\n\ngoal (1 subgoal):\n 1. \\<phi> (\\<psi> (cod (\\<phi> i))) = cod (\\<phi> i)", "by force"], ["proof (state)\nthis:\n  \\<phi> (\\<psi> (cod (\\<phi> i))) = cod (\\<phi> i)\n\ngoal (1 subgoal):\n 1. C' (\\<psi> (cod (\\<phi> i))) (\\<psi> (cod (\\<phi> i))) =\n    \\<psi> (cod (\\<phi> i))", "moreover"], ["proof (state)\nthis:\n  \\<phi> (\\<psi> (cod (\\<phi> i))) = cod (\\<phi> i)\n\ngoal (1 subgoal):\n 1. C' (\\<psi> (cod (\\<phi> i))) (\\<psi> (cod (\\<phi> i))) =\n    \\<psi> (cod (\\<phi> i))", "have \"cod (\\<phi> i) \\<cdot> cod (\\<phi> i) = cod (\\<phi> i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cod (\\<phi> i) \\<cdot> cod (\\<phi> i) = cod (\\<phi> i)", "using i assms(1-2) comp_ide_self ide_cod [of \"\\<phi> i\"] \\<psi>_\\<phi> \\<psi>_def"], ["proof (prove)\nusing this:\n  i \\<in> S\n  bij_betw \\<phi> S (Collect arr)\n  n \\<notin> S\n  ide ?a \\<Longrightarrow> ?a \\<cdot> ?a = ?a\n  arr (\\<phi> i) \\<Longrightarrow> ide (cod (\\<phi> i))\n  ?i \\<in> S \\<Longrightarrow> \\<psi> (\\<phi> ?i) = ?i\n  \\<psi> = (\\<lambda>f. if arr f then inv_into S \\<phi> f else n)\n\ngoal (1 subgoal):\n 1. cod (\\<phi> i) \\<cdot> cod (\\<phi> i) = cod (\\<phi> i)", "by fastforce"], ["proof (state)\nthis:\n  cod (\\<phi> i) \\<cdot> cod (\\<phi> i) = cod (\\<phi> i)\n\ngoal (1 subgoal):\n 1. C' (\\<psi> (cod (\\<phi> i))) (\\<psi> (cod (\\<phi> i))) =\n    \\<psi> (cod (\\<phi> i))", "ultimately"], ["proof (chain)\npicking this:\n  \\<phi> (\\<psi> (cod (\\<phi> i))) = cod (\\<phi> i)\n  cod (\\<phi> i) \\<cdot> cod (\\<phi> i) = cod (\\<phi> i)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<phi> (\\<psi> (cod (\\<phi> i))) = cod (\\<phi> i)\n  cod (\\<phi> i) \\<cdot> cod (\\<phi> i) = cod (\\<phi> i)\n\ngoal (1 subgoal):\n 1. C' (\\<psi> (cod (\\<phi> i))) (\\<psi> (cod (\\<phi> i))) =\n    \\<psi> (cod (\\<phi> i))", "using C'_def i assms(1)"], ["proof (prove)\nusing this:\n  \\<phi> (\\<psi> (cod (\\<phi> i))) = cod (\\<phi> i)\n  cod (\\<phi> i) \\<cdot> cod (\\<phi> i) = cod (\\<phi> i)\n  C' =\n  (\\<lambda>i j.\n      if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n      then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n  i \\<in> S\n  bij_betw \\<phi> S (Collect arr)\n\ngoal (1 subgoal):\n 1. C' (\\<psi> (cod (\\<phi> i))) (\\<psi> (cod (\\<phi> i))) =\n    \\<psi> (cod (\\<phi> i))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<phi> (\\<psi> (cod (\\<phi> i))) = cod (\\<phi> i);\n     cod (\\<phi> i) \\<cdot> cod (\\<phi> i) = cod (\\<phi> i);\n     C' =\n     (\\<lambda>i j.\n         if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n         then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n);\n     i \\<in> S; bij_betw \\<phi> S (Collect arr)\\<rbrakk>\n    \\<Longrightarrow> (\\<psi> (cod (\\<phi> i)) \\<in> S \\<longrightarrow>\n                       \\<not> arr (cod (\\<phi> i))) \\<longrightarrow>\n                      n = \\<psi> (cod (\\<phi> i))", "by (metis (no_types, lifting) \\<psi> \\<psi>_def bij_betw_def image_eqI mem_Collect_eq)"], ["proof (state)\nthis:\n  C' (\\<psi> (cod (\\<phi> i))) (\\<psi> (cod (\\<phi> i))) =\n  \\<psi> (cod (\\<phi> i))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  C' (\\<psi> (cod (\\<phi> i))) (\\<psi> (cod (\\<phi> i))) =\n  \\<psi> (cod (\\<phi> i))\n\ngoal (1 subgoal):\n 1. C' (\\<psi> (cod (\\<phi> i))) (\\<psi> (cod (\\<phi> i))) \\<noteq> C'.null", "moreover"], ["proof (state)\nthis:\n  C' (\\<psi> (cod (\\<phi> i))) (\\<psi> (cod (\\<phi> i))) =\n  \\<psi> (cod (\\<phi> i))\n\ngoal (1 subgoal):\n 1. C' (\\<psi> (cod (\\<phi> i))) (\\<psi> (cod (\\<phi> i))) \\<noteq> C'.null", "have \"\\<psi> (cod (\\<phi> i)) \\<noteq> C'.null\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> (cod (\\<phi> i)) \\<noteq> C'.null", "using i null_char assms(1-2)"], ["proof (prove)\nusing this:\n  i \\<in> S\n  C'.null = n\n  bij_betw \\<phi> S (Collect arr)\n  n \\<notin> S\n\ngoal (1 subgoal):\n 1. \\<psi> (cod (\\<phi> i)) \\<noteq> C'.null", "by (metis \\<psi> bij_betw_def category.arr_cod_iff_arr category_axioms\n                  image_eqI mem_Collect_eq)"], ["proof (state)\nthis:\n  \\<psi> (cod (\\<phi> i)) \\<noteq> C'.null\n\ngoal (1 subgoal):\n 1. C' (\\<psi> (cod (\\<phi> i))) (\\<psi> (cod (\\<phi> i))) \\<noteq> C'.null", "ultimately"], ["proof (chain)\npicking this:\n  C' (\\<psi> (cod (\\<phi> i))) (\\<psi> (cod (\\<phi> i))) =\n  \\<psi> (cod (\\<phi> i))\n  \\<psi> (cod (\\<phi> i)) \\<noteq> C'.null", "show ?thesis"], ["proof (prove)\nusing this:\n  C' (\\<psi> (cod (\\<phi> i))) (\\<psi> (cod (\\<phi> i))) =\n  \\<psi> (cod (\\<phi> i))\n  \\<psi> (cod (\\<phi> i)) \\<noteq> C'.null\n\ngoal (1 subgoal):\n 1. C' (\\<psi> (cod (\\<phi> i))) (\\<psi> (cod (\\<phi> i))) \\<noteq> C'.null", "by simp"], ["proof (state)\nthis:\n  C' (\\<psi> (cod (\\<phi> i))) (\\<psi> (cod (\\<phi> i))) \\<noteq> C'.null\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  C' (\\<psi> (cod (\\<phi> i))) (\\<psi> (cod (\\<phi> i))) \\<noteq> C'.null\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       C' f (\\<psi> (cod (\\<phi> i))) \\<noteq> C'.null \\<Longrightarrow>\n       C' f (\\<psi> (cod (\\<phi> i))) = f\n 2. \\<And>f.\n       C' (\\<psi> (cod (\\<phi> i))) f \\<noteq> C'.null \\<Longrightarrow>\n       C' (\\<psi> (cod (\\<phi> i))) f = f", "show \"\\<And>j. C' (\\<psi> (cod (\\<phi> i))) j \\<noteq> C'.null \\<Longrightarrow> C' (\\<psi> (cod (\\<phi> i))) j = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       C' (\\<psi> (cod (\\<phi> i))) j \\<noteq> C'.null \\<Longrightarrow>\n       C' (\\<psi> (cod (\\<phi> i))) j = j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       C' (\\<psi> (cod (\\<phi> i))) j \\<noteq> C'.null \\<Longrightarrow>\n       C' (\\<psi> (cod (\\<phi> i))) j = j", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       C' (\\<psi> (cod (\\<phi> i))) j \\<noteq> C'.null \\<Longrightarrow>\n       C' (\\<psi> (cod (\\<phi> i))) j = j", "assume j: \"C' (\\<psi> (cod (\\<phi> i))) j \\<noteq> C'.null\""], ["proof (state)\nthis:\n  C' (\\<psi> (cod (\\<phi> i))) j \\<noteq> C'.null\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       C' (\\<psi> (cod (\\<phi> i))) j \\<noteq> C'.null \\<Longrightarrow>\n       C' (\\<psi> (cod (\\<phi> i))) j = j", "show \"C' (\\<psi> (cod (\\<phi> i))) j = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C' (\\<psi> (cod (\\<phi> i))) j = j", "using j"], ["proof (prove)\nusing this:\n  C' (\\<psi> (cod (\\<phi> i))) j \\<noteq> C'.null\n\ngoal (1 subgoal):\n 1. C' (\\<psi> (cod (\\<phi> i))) j = j", "by (metis C'.comp_null(2) C'.ide_def C'_def\n                  \\<open>C' (\\<psi> (cod (\\<phi> i))) (\\<psi> (cod (\\<phi> i))) \\<noteq> C'.null\\<close>\n                  \\<phi>_\\<psi> \\<psi>_def arr_cod_iff_arr category.ide_cod category_axioms ide_char null_char)"], ["proof (state)\nthis:\n  C' (\\<psi> (cod (\\<phi> i))) j = j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  C' (\\<psi> (cod (\\<phi> i))) ?j \\<noteq> C'.null \\<Longrightarrow>\n  C' (\\<psi> (cod (\\<phi> i))) ?j = ?j\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       C' f (\\<psi> (cod (\\<phi> i))) \\<noteq> C'.null \\<Longrightarrow>\n       C' f (\\<psi> (cod (\\<phi> i))) = f", "show \"\\<And>j. C' j (\\<psi> (cod (\\<phi> i))) \\<noteq> C'.null \\<Longrightarrow> C' j (\\<psi> (cod (\\<phi> i))) = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       C' j (\\<psi> (cod (\\<phi> i))) \\<noteq> C'.null \\<Longrightarrow>\n       C' j (\\<psi> (cod (\\<phi> i))) = j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       C' j (\\<psi> (cod (\\<phi> i))) \\<noteq> C'.null \\<Longrightarrow>\n       C' j (\\<psi> (cod (\\<phi> i))) = j", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       C' j (\\<psi> (cod (\\<phi> i))) \\<noteq> C'.null \\<Longrightarrow>\n       C' j (\\<psi> (cod (\\<phi> i))) = j", "assume j: \"C' j (\\<psi> (cod (\\<phi> i))) \\<noteq> C'.null\""], ["proof (state)\nthis:\n  C' j (\\<psi> (cod (\\<phi> i))) \\<noteq> C'.null\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       C' j (\\<psi> (cod (\\<phi> i))) \\<noteq> C'.null \\<Longrightarrow>\n       C' j (\\<psi> (cod (\\<phi> i))) = j", "show \"C' j (\\<psi> (cod (\\<phi> i))) = j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C' j (\\<psi> (cod (\\<phi> i))) = j", "using j"], ["proof (prove)\nusing this:\n  C' j (\\<psi> (cod (\\<phi> i))) \\<noteq> C'.null\n\ngoal (1 subgoal):\n 1. C' j (\\<psi> (cod (\\<phi> i))) = j", "by (metis C'.ide_def C'_def \\<open>C' (\\<psi> (cod (\\<phi> i))) (\\<psi> (cod (\\<phi> i))) \\<noteq> C'.null\\<close>\n                  \\<open>\\<And>j. C' (\\<psi> (cod (\\<phi> i))) j \\<noteq> C'.null \\<Longrightarrow> C' (\\<psi> (cod (\\<phi> i))) j = j\\<close>\n                  \\<phi>_\\<psi> \\<psi>_def arr_cod_iff_arr category.ide_cod category_axioms ide_char null_char)"], ["proof (state)\nthis:\n  C' j (\\<psi> (cod (\\<phi> i))) = j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  C' ?j (\\<psi> (cod (\\<phi> i))) \\<noteq> C'.null \\<Longrightarrow>\n  C' ?j (\\<psi> (cod (\\<phi> i))) = ?j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  C'.ide (\\<psi> (cod (\\<phi> i)))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> S \\<Longrightarrow>\n       \\<psi> (cod (\\<phi> i)) \\<in> C'.codomains i", "moreover"], ["proof (state)\nthis:\n  C'.ide (\\<psi> (cod (\\<phi> i)))\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> S \\<Longrightarrow>\n       \\<psi> (cod (\\<phi> i)) \\<in> C'.codomains i", "have \"C' (\\<psi> (cod (\\<phi> i))) i \\<noteq> C'.null\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C' (\\<psi> (cod (\\<phi> i))) i \\<noteq> C'.null", "using i assms(1-2) C'_def null_char \\<phi>_\\<psi> \\<psi>_\\<phi> \\<psi>_def comp_cod_arr ide_char"], ["proof (prove)\nusing this:\n  i \\<in> S\n  bij_betw \\<phi> S (Collect arr)\n  n \\<notin> S\n  C' =\n  (\\<lambda>i j.\n      if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n      then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n  C'.null = n\n  arr ?f \\<Longrightarrow> \\<phi> (\\<psi> ?f) = ?f\n  ?i \\<in> S \\<Longrightarrow> \\<psi> (\\<phi> ?i) = ?i\n  \\<psi> = (\\<lambda>f. if arr f then inv_into S \\<phi> f else n)\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n  C'.ide ?i = (?i \\<in> S \\<and> ide (\\<phi> ?i))\n\ngoal (1 subgoal):\n 1. C' (\\<psi> (cod (\\<phi> i))) i \\<noteq> C'.null", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<in> S; bij_betw \\<phi> S (Collect arr); n \\<notin> S;\n     C' =\n     (\\<lambda>i j.\n         if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n         then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n);\n     partial_magma.null\n      (\\<lambda>i j.\n          if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n          then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n) =\n     n;\n     \\<And>f. arr f \\<Longrightarrow> \\<phi> (inv_into S \\<phi> f) = f;\n     \\<And>i.\n        i \\<in> S \\<Longrightarrow>\n        (if arr (\\<phi> i) then inv_into S \\<phi> (\\<phi> i) else n) = i;\n     \\<psi> = (\\<lambda>f. if arr f then inv_into S \\<phi> f else n);\n     \\<And>f b.\n        \\<lbrakk>arr f; cod f = b\\<rbrakk>\n        \\<Longrightarrow> b \\<cdot> f = f;\n     \\<And>i.\n        partial_magma.ide\n         (\\<lambda>i j.\n             if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n         i =\n        (i \\<in> S \\<and> ide (\\<phi> i))\\<rbrakk>\n    \\<Longrightarrow> (arr (cod (\\<phi> i)) \\<longrightarrow>\n                       (inv_into S \\<phi> (cod (\\<phi> i)) \\<in> S \\<and>\n                        seq (cod (\\<phi> i)) (\\<phi> i) \\<longrightarrow>\n                        inv_into S \\<phi>\n                         (cod (\\<phi> i) \\<cdot> \\<phi> i) \\<noteq>\n                        n) \\<and>\n                       inv_into S \\<phi> (cod (\\<phi> i)) \\<in> S \\<and>\n                       seq (cod (\\<phi> i)) (\\<phi> i)) \\<and>\n                      arr (cod (\\<phi> i))", "by (metis (no_types, lifting) \\<psi>_def 1)"], ["proof (state)\nthis:\n  C' (\\<psi> (cod (\\<phi> i))) i \\<noteq> C'.null\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> S \\<Longrightarrow>\n       \\<psi> (cod (\\<phi> i)) \\<in> C'.codomains i", "ultimately"], ["proof (chain)\npicking this:\n  C'.ide (\\<psi> (cod (\\<phi> i)))\n  C' (\\<psi> (cod (\\<phi> i))) i \\<noteq> C'.null", "show \"\\<psi> (cod (\\<phi> i)) \\<in> C'.codomains i\""], ["proof (prove)\nusing this:\n  C'.ide (\\<psi> (cod (\\<phi> i)))\n  C' (\\<psi> (cod (\\<phi> i))) i \\<noteq> C'.null\n\ngoal (1 subgoal):\n 1. \\<psi> (cod (\\<phi> i)) \\<in> C'.codomains i", "using C'.codomains_def"], ["proof (prove)\nusing this:\n  C'.ide (\\<psi> (cod (\\<phi> i)))\n  C' (\\<psi> (cod (\\<phi> i))) i \\<noteq> C'.null\n  C'.codomains ?f \\<equiv> {b. C'.ide b \\<and> C' b ?f \\<noteq> C'.null}\n\ngoal (1 subgoal):\n 1. \\<psi> (cod (\\<phi> i)) \\<in> C'.codomains i", "by simp"], ["proof (state)\nthis:\n  \\<psi> (cod (\\<phi> i)) \\<in> C'.codomains i\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?i \\<in> S \\<Longrightarrow>\n  \\<psi> (cod (\\<phi> ?i)) \\<in> C'.codomains ?i\n\ngoal (1 subgoal):\n 1. \\<exists>C'.\n       Collect (partial_magma.arr C') = S \\<and>\n       invertible_functor C' (\\<cdot>)\n        (\\<lambda>i. if partial_magma.arr C' i then \\<phi> i else null)", "have arr_char: \"\\<And>i. C'.arr i \\<longleftrightarrow> i \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i. C'.arr i = (i \\<in> S)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i. C'.arr i \\<Longrightarrow> i \\<in> S\n 2. \\<And>i. i \\<in> S \\<Longrightarrow> C'.arr i", "fix i"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i. C'.arr i \\<Longrightarrow> i \\<in> S\n 2. \\<And>i. i \\<in> S \\<Longrightarrow> C'.arr i", "show \"i \\<in> S \\<Longrightarrow> C'.arr i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<in> S \\<Longrightarrow> C'.arr i", "using dom cod C'.arr_def"], ["proof (prove)\nusing this:\n  ?i \\<in> S \\<Longrightarrow>\n  \\<psi> (local.dom (\\<phi> ?i)) \\<in> C'.domains ?i\n  ?i \\<in> S \\<Longrightarrow>\n  \\<psi> (cod (\\<phi> ?i)) \\<in> C'.codomains ?i\n  C'.arr ?f \\<equiv>\n  C'.domains ?f \\<noteq> {} \\<or> C'.codomains ?f \\<noteq> {}\n\ngoal (1 subgoal):\n 1. i \\<in> S \\<Longrightarrow> C'.arr i", "by auto"], ["proof (state)\nthis:\n  i \\<in> S \\<Longrightarrow> C'.arr i\n\ngoal (1 subgoal):\n 1. \\<And>i. C'.arr i \\<Longrightarrow> i \\<in> S", "show \"C'.arr i \\<Longrightarrow> i \\<in> S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C'.arr i \\<Longrightarrow> i \\<in> S", "using C'_def C'.arr_def C'.domains_def C'.codomains_def null_char"], ["proof (prove)\nusing this:\n  C' =\n  (\\<lambda>i j.\n      if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n      then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n  C'.arr ?f \\<equiv>\n  C'.domains ?f \\<noteq> {} \\<or> C'.codomains ?f \\<noteq> {}\n  C'.domains ?f \\<equiv> {a. C'.ide a \\<and> C' ?f a \\<noteq> C'.null}\n  C'.codomains ?f \\<equiv> {b. C'.ide b \\<and> C' b ?f \\<noteq> C'.null}\n  C'.null = n\n\ngoal (1 subgoal):\n 1. C'.arr i \\<Longrightarrow> i \\<in> S", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>(\\<forall>x.\n                 partial_magma.ide\n                  (\\<lambda>i j.\n                      if i \\<in> S \\<and>\n                         j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n                      then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n                  x \\<longrightarrow>\n                 (if i \\<in> S \\<and>\n                     x \\<in> S \\<and> seq (\\<phi> i) (\\<phi> x)\n                  then \\<psi> (\\<phi> i \\<cdot> \\<phi> x) else n) =\n                 n) \\<longrightarrow>\n             (\\<exists>x.\n                 partial_magma.ide\n                  (\\<lambda>i j.\n                      if i \\<in> S \\<and>\n                         j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n                      then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n                  x \\<and>\n                 (if x \\<in> S \\<and>\n                     i \\<in> S \\<and> seq (\\<phi> x) (\\<phi> i)\n                  then \\<psi> (\\<phi> x \\<cdot> \\<phi> i) else n) \\<noteq>\n                 n);\n     C' =\n     (\\<lambda>i j.\n         if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n         then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n);\n     \\<And>f.\n        partial_magma.arr\n         (\\<lambda>i j.\n             if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n         f \\<equiv>\n        (\\<forall>x.\n            partial_magma.ide\n             (\\<lambda>i j.\n                 if i \\<in> S \\<and>\n                    j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n                 then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n             x \\<longrightarrow>\n            (if f \\<in> S \\<and> x \\<in> S \\<and> seq (\\<phi> f) (\\<phi> x)\n             then \\<psi> (\\<phi> f \\<cdot> \\<phi> x) else n) =\n            n) \\<longrightarrow>\n        (\\<exists>x.\n            partial_magma.ide\n             (\\<lambda>i j.\n                 if i \\<in> S \\<and>\n                    j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n                 then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n             x \\<and>\n            (if x \\<in> S \\<and> f \\<in> S \\<and> seq (\\<phi> x) (\\<phi> f)\n             then \\<psi> (\\<phi> x \\<cdot> \\<phi> f) else n) \\<noteq>\n            n);\n     \\<And>f.\n        partial_magma.domains\n         (\\<lambda>i j.\n             if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n         f \\<equiv>\n        {a. partial_magma.ide\n             (\\<lambda>i j.\n                 if i \\<in> S \\<and>\n                    j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n                 then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n             a \\<and>\n            (if f \\<in> S \\<and> a \\<in> S \\<and> seq (\\<phi> f) (\\<phi> a)\n             then \\<psi> (\\<phi> f \\<cdot> \\<phi> a) else n) \\<noteq>\n            n};\n     \\<And>f.\n        partial_magma.codomains\n         (\\<lambda>i j.\n             if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n         f \\<equiv>\n        {b. partial_magma.ide\n             (\\<lambda>i j.\n                 if i \\<in> S \\<and>\n                    j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n                 then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n             b \\<and>\n            (if b \\<in> S \\<and> f \\<in> S \\<and> seq (\\<phi> b) (\\<phi> f)\n             then \\<psi> (\\<phi> b \\<cdot> \\<phi> f) else n) \\<noteq>\n            n};\n     partial_magma.null\n      (\\<lambda>i j.\n          if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n          then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n) =\n     n\\<rbrakk>\n    \\<Longrightarrow> i \\<in> S", "by metis"], ["proof (state)\nthis:\n  C'.arr i \\<Longrightarrow> i \\<in> S\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  C'.arr ?i = (?i \\<in> S)\n\ngoal (1 subgoal):\n 1. \\<exists>C'.\n       Collect (partial_magma.arr C') = S \\<and>\n       invertible_functor C' (\\<cdot>)\n        (\\<lambda>i. if partial_magma.arr C' i then \\<phi> i else null)", "have seq_char: \"\\<And>i j. C'.seq i j \\<longleftrightarrow> i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       C'.seq i j =\n       (i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j))", "using assms(1-2) C'_def arr_char null_char"], ["proof (prove)\nusing this:\n  bij_betw \\<phi> S (Collect arr)\n  n \\<notin> S\n  C' =\n  (\\<lambda>i j.\n      if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n      then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n  C'.arr ?i = (?i \\<in> S)\n  C'.null = n\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       C'.seq i j =\n       (i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>bij_betw \\<phi> S (Collect arr); n \\<notin> S;\n        C' =\n        (\\<lambda>i j.\n            if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n            then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n);\n        \\<And>i.\n           partial_magma.arr\n            (\\<lambda>i j.\n                if i \\<in> S \\<and>\n                   j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n                then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n            i =\n           (i \\<in> S);\n        partial_magma.null\n         (\\<lambda>i j.\n             if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n) =\n        n\\<rbrakk>\n       \\<Longrightarrow> i \\<in> S \\<and>\n                         j \\<in> S \\<and>\n                         seq (\\<phi> i) (\\<phi> j) \\<longrightarrow>\n                         \\<psi> (\\<phi> i \\<cdot> \\<phi> j) \\<in> S", "using \\<psi> bij_betw_apply"], ["proof (prove)\nusing this:\n  bij_betw \\<psi> (Collect arr) S\n  \\<lbrakk>bij_betw ?f ?A ?B; ?a \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> ?f ?a \\<in> ?B\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       \\<lbrakk>bij_betw \\<phi> S (Collect arr); n \\<notin> S;\n        C' =\n        (\\<lambda>i j.\n            if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n            then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n);\n        \\<And>i.\n           partial_magma.arr\n            (\\<lambda>i j.\n                if i \\<in> S \\<and>\n                   j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n                then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n            i =\n           (i \\<in> S);\n        partial_magma.null\n         (\\<lambda>i j.\n             if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n) =\n        n\\<rbrakk>\n       \\<Longrightarrow> i \\<in> S \\<and>\n                         j \\<in> S \\<and>\n                         seq (\\<phi> i) (\\<phi> j) \\<longrightarrow>\n                         \\<psi> (\\<phi> i \\<cdot> \\<phi> j) \\<in> S", "by fastforce"], ["proof (state)\nthis:\n  C'.seq ?i ?j =\n  (?i \\<in> S \\<and> ?j \\<in> S \\<and> seq (\\<phi> ?i) (\\<phi> ?j))\n\ngoal (1 subgoal):\n 1. \\<exists>C'.\n       Collect (partial_magma.arr C') = S \\<and>\n       invertible_functor C' (\\<cdot>)\n        (\\<lambda>i. if partial_magma.arr C' i then \\<phi> i else null)", "interpret C': category C'"], ["proof (prove)\ngoal (1 subgoal):\n 1. category C'", "proof"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>g f. C' g f \\<noteq> C'.null \\<Longrightarrow> C'.seq g f\n 2. \\<And>f. (C'.domains f \\<noteq> {}) = (C'.codomains f \\<noteq> {})\n 3. \\<And>h g f.\n       \\<lbrakk>C'.seq h g; C'.seq (C' h g) f\\<rbrakk>\n       \\<Longrightarrow> C'.seq g f\n 4. \\<And>h g f.\n       \\<lbrakk>C'.seq h (C' g f); C'.seq g f\\<rbrakk>\n       \\<Longrightarrow> C'.seq h g\n 5. \\<And>g f h.\n       \\<lbrakk>C'.seq g f; C'.seq h g\\<rbrakk>\n       \\<Longrightarrow> C'.seq (C' h g) f\n 6. \\<And>g f h.\n       \\<lbrakk>C'.seq g f; C'.seq h g\\<rbrakk>\n       \\<Longrightarrow> C' (C' h g) f = C' h (C' g f)", "show \"\\<And>g f. C' g f \\<noteq> C'.null \\<Longrightarrow> C'.seq g f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g f. C' g f \\<noteq> C'.null \\<Longrightarrow> C'.seq g f", "using C'_def null_char seq_char"], ["proof (prove)\nusing this:\n  C' =\n  (\\<lambda>i j.\n      if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n      then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n  C'.null = n\n  C'.seq ?i ?j =\n  (?i \\<in> S \\<and> ?j \\<in> S \\<and> seq (\\<phi> ?i) (\\<phi> ?j))\n\ngoal (1 subgoal):\n 1. \\<And>g f. C' g f \\<noteq> C'.null \\<Longrightarrow> C'.seq g f", "by fastforce"], ["proof (state)\nthis:\n  C' ?g ?f \\<noteq> C'.null \\<Longrightarrow> C'.seq ?g ?f\n\ngoal (5 subgoals):\n 1. \\<And>f. (C'.domains f \\<noteq> {}) = (C'.codomains f \\<noteq> {})\n 2. \\<And>h g f.\n       \\<lbrakk>C'.seq h g; C'.seq (C' h g) f\\<rbrakk>\n       \\<Longrightarrow> C'.seq g f\n 3. \\<And>h g f.\n       \\<lbrakk>C'.seq h (C' g f); C'.seq g f\\<rbrakk>\n       \\<Longrightarrow> C'.seq h g\n 4. \\<And>g f h.\n       \\<lbrakk>C'.seq g f; C'.seq h g\\<rbrakk>\n       \\<Longrightarrow> C'.seq (C' h g) f\n 5. \\<And>g f h.\n       \\<lbrakk>C'.seq g f; C'.seq h g\\<rbrakk>\n       \\<Longrightarrow> C' (C' h g) f = C' h (C' g f)", "show \"\\<And>f. (C'.domains f \\<noteq> {}) = (C'.codomains f \\<noteq> {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f. (C'.domains f \\<noteq> {}) = (C'.codomains f \\<noteq> {})", "using dom cod null_char arr_char C'.arr_def"], ["proof (prove)\nusing this:\n  ?i \\<in> S \\<Longrightarrow>\n  \\<psi> (local.dom (\\<phi> ?i)) \\<in> C'.domains ?i\n  ?i \\<in> S \\<Longrightarrow>\n  \\<psi> (cod (\\<phi> ?i)) \\<in> C'.codomains ?i\n  C'.null = n\n  C'.arr ?i = (?i \\<in> S)\n  C'.arr ?f \\<equiv>\n  C'.domains ?f \\<noteq> {} \\<or> C'.codomains ?f \\<noteq> {}\n\ngoal (1 subgoal):\n 1. \\<And>f. (C'.domains f \\<noteq> {}) = (C'.codomains f \\<noteq> {})", "by blast"], ["proof (state)\nthis:\n  (C'.domains ?f \\<noteq> {}) = (C'.codomains ?f \\<noteq> {})\n\ngoal (4 subgoals):\n 1. \\<And>h g f.\n       \\<lbrakk>C'.seq h g; C'.seq (C' h g) f\\<rbrakk>\n       \\<Longrightarrow> C'.seq g f\n 2. \\<And>h g f.\n       \\<lbrakk>C'.seq h (C' g f); C'.seq g f\\<rbrakk>\n       \\<Longrightarrow> C'.seq h g\n 3. \\<And>g f h.\n       \\<lbrakk>C'.seq g f; C'.seq h g\\<rbrakk>\n       \\<Longrightarrow> C'.seq (C' h g) f\n 4. \\<And>g f h.\n       \\<lbrakk>C'.seq g f; C'.seq h g\\<rbrakk>\n       \\<Longrightarrow> C' (C' h g) f = C' h (C' g f)", "show \"\\<And>h g f. \\<lbrakk>C'.seq h g; C'.seq (C' h g) f\\<rbrakk> \\<Longrightarrow> C'.seq g f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h g f.\n       \\<lbrakk>C'.seq h g; C'.seq (C' h g) f\\<rbrakk>\n       \\<Longrightarrow> C'.seq g f", "using seq_char"], ["proof (prove)\nusing this:\n  C'.seq ?i ?j =\n  (?i \\<in> S \\<and> ?j \\<in> S \\<and> seq (\\<phi> ?i) (\\<phi> ?j))\n\ngoal (1 subgoal):\n 1. \\<And>h g f.\n       \\<lbrakk>C'.seq h g; C'.seq (C' h g) f\\<rbrakk>\n       \\<Longrightarrow> C'.seq g f", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h g f.\n       \\<lbrakk>h \\<in> S \\<and> g \\<in> S \\<and> seq (\\<phi> h) (\\<phi> g);\n        C' h g \\<in> S \\<and>\n        f \\<in> S \\<and> seq (\\<phi> (C' h g)) (\\<phi> f);\n        \\<And>i j.\n           C'.seq i j =\n           (i \\<in> S \\<and>\n            j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j))\\<rbrakk>\n       \\<Longrightarrow> seq (\\<phi> g) (\\<phi> f)", "using C'_def"], ["proof (prove)\nusing this:\n  C' =\n  (\\<lambda>i j.\n      if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n      then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n\ngoal (1 subgoal):\n 1. \\<And>h g f.\n       \\<lbrakk>h \\<in> S \\<and> g \\<in> S \\<and> seq (\\<phi> h) (\\<phi> g);\n        C' h g \\<in> S \\<and>\n        f \\<in> S \\<and> seq (\\<phi> (C' h g)) (\\<phi> f);\n        \\<And>i j.\n           C'.seq i j =\n           (i \\<in> S \\<and>\n            j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j))\\<rbrakk>\n       \\<Longrightarrow> seq (\\<phi> g) (\\<phi> f)", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>C'.seq ?h ?g; C'.seq (C' ?h ?g) ?f\\<rbrakk>\n  \\<Longrightarrow> C'.seq ?g ?f\n\ngoal (3 subgoals):\n 1. \\<And>h g f.\n       \\<lbrakk>C'.seq h (C' g f); C'.seq g f\\<rbrakk>\n       \\<Longrightarrow> C'.seq h g\n 2. \\<And>g f h.\n       \\<lbrakk>C'.seq g f; C'.seq h g\\<rbrakk>\n       \\<Longrightarrow> C'.seq (C' h g) f\n 3. \\<And>g f h.\n       \\<lbrakk>C'.seq g f; C'.seq h g\\<rbrakk>\n       \\<Longrightarrow> C' (C' h g) f = C' h (C' g f)", "show \"\\<And>h g f. \\<lbrakk>C'.seq h (C' g f); C'.seq g f\\<rbrakk> \\<Longrightarrow> C'.seq h g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h g f.\n       \\<lbrakk>C'.seq h (C' g f); C'.seq g f\\<rbrakk>\n       \\<Longrightarrow> C'.seq h g", "using seq_char"], ["proof (prove)\nusing this:\n  C'.seq ?i ?j =\n  (?i \\<in> S \\<and> ?j \\<in> S \\<and> seq (\\<phi> ?i) (\\<phi> ?j))\n\ngoal (1 subgoal):\n 1. \\<And>h g f.\n       \\<lbrakk>C'.seq h (C' g f); C'.seq g f\\<rbrakk>\n       \\<Longrightarrow> C'.seq h g", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h g f.\n       \\<lbrakk>h \\<in> S \\<and>\n                C' g f \\<in> S \\<and> seq (\\<phi> h) (\\<phi> (C' g f));\n        g \\<in> S \\<and> f \\<in> S \\<and> seq (\\<phi> g) (\\<phi> f);\n        \\<And>i j.\n           C'.seq i j =\n           (i \\<in> S \\<and>\n            j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j))\\<rbrakk>\n       \\<Longrightarrow> seq (\\<phi> h) (\\<phi> g)", "using C'_def"], ["proof (prove)\nusing this:\n  C' =\n  (\\<lambda>i j.\n      if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n      then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n\ngoal (1 subgoal):\n 1. \\<And>h g f.\n       \\<lbrakk>h \\<in> S \\<and>\n                C' g f \\<in> S \\<and> seq (\\<phi> h) (\\<phi> (C' g f));\n        g \\<in> S \\<and> f \\<in> S \\<and> seq (\\<phi> g) (\\<phi> f);\n        \\<And>i j.\n           C'.seq i j =\n           (i \\<in> S \\<and>\n            j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j))\\<rbrakk>\n       \\<Longrightarrow> seq (\\<phi> h) (\\<phi> g)", "by fastforce"], ["proof (state)\nthis:\n  \\<lbrakk>C'.seq ?h (C' ?g ?f); C'.seq ?g ?f\\<rbrakk>\n  \\<Longrightarrow> C'.seq ?h ?g\n\ngoal (2 subgoals):\n 1. \\<And>g f h.\n       \\<lbrakk>C'.seq g f; C'.seq h g\\<rbrakk>\n       \\<Longrightarrow> C'.seq (C' h g) f\n 2. \\<And>g f h.\n       \\<lbrakk>C'.seq g f; C'.seq h g\\<rbrakk>\n       \\<Longrightarrow> C' (C' h g) f = C' h (C' g f)", "show \"\\<And>g f h. \\<lbrakk>C'.seq g f; C'.seq h g\\<rbrakk> \\<Longrightarrow> C'.seq (C' h g) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g f h.\n       \\<lbrakk>C'.seq g f; C'.seq h g\\<rbrakk>\n       \\<Longrightarrow> C'.seq (C' h g) f", "using seq_char arr_char"], ["proof (prove)\nusing this:\n  C'.seq ?i ?j =\n  (?i \\<in> S \\<and> ?j \\<in> S \\<and> seq (\\<phi> ?i) (\\<phi> ?j))\n  C'.arr ?i = (?i \\<in> S)\n\ngoal (1 subgoal):\n 1. \\<And>g f h.\n       \\<lbrakk>C'.seq g f; C'.seq h g\\<rbrakk>\n       \\<Longrightarrow> C'.seq (C' h g) f", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g f h.\n       \\<lbrakk>g \\<in> S \\<and> f \\<in> S \\<and> seq (\\<phi> g) (\\<phi> f);\n        h \\<in> S \\<and> seq (\\<phi> h) (\\<phi> g);\n        \\<And>i j.\n           (C' i j \\<in> S) =\n           (i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j));\n        \\<And>i. C'.arr i = (i \\<in> S)\\<rbrakk>\n       \\<Longrightarrow> seq (\\<phi> (C' h g)) (\\<phi> f)", "using C'_def"], ["proof (prove)\nusing this:\n  C' =\n  (\\<lambda>i j.\n      if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n      then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n\ngoal (1 subgoal):\n 1. \\<And>g f h.\n       \\<lbrakk>g \\<in> S \\<and> f \\<in> S \\<and> seq (\\<phi> g) (\\<phi> f);\n        h \\<in> S \\<and> seq (\\<phi> h) (\\<phi> g);\n        \\<And>i j.\n           (C' i j \\<in> S) =\n           (i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j));\n        \\<And>i. C'.arr i = (i \\<in> S)\\<rbrakk>\n       \\<Longrightarrow> seq (\\<phi> (C' h g)) (\\<phi> f)", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>C'.seq ?g ?f; C'.seq ?h ?g\\<rbrakk>\n  \\<Longrightarrow> C'.seq (C' ?h ?g) ?f\n\ngoal (1 subgoal):\n 1. \\<And>g f h.\n       \\<lbrakk>C'.seq g f; C'.seq h g\\<rbrakk>\n       \\<Longrightarrow> C' (C' h g) f = C' h (C' g f)", "show \"\\<And>g f h. \\<lbrakk>C'.seq g f; C'.seq h g\\<rbrakk> \\<Longrightarrow> C' (C' h g) f = C' h (C' g f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g f h.\n       \\<lbrakk>C'.seq g f; C'.seq h g\\<rbrakk>\n       \\<Longrightarrow> C' (C' h g) f = C' h (C' g f)", "using seq_char arr_char C'_def comp_assoc assms(2)"], ["proof (prove)\nusing this:\n  C'.seq ?i ?j =\n  (?i \\<in> S \\<and> ?j \\<in> S \\<and> seq (\\<phi> ?i) (\\<phi> ?j))\n  C'.arr ?i = (?i \\<in> S)\n  C' =\n  (\\<lambda>i j.\n      if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n      then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n  n \\<notin> S\n\ngoal (1 subgoal):\n 1. \\<And>g f h.\n       \\<lbrakk>C'.seq g f; C'.seq h g\\<rbrakk>\n       \\<Longrightarrow> C' (C' h g) f = C' h (C' g f)", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g f h.\n       \\<lbrakk>g \\<in> S \\<and> f \\<in> S \\<and> seq (\\<phi> g) (\\<phi> f);\n        (if h \\<in> S \\<and> seq (\\<phi> h) (\\<phi> g)\n         then \\<psi> (\\<phi> h \\<cdot> \\<phi> g) else n)\n        \\<in> S;\n        \\<And>i j.\n           ((if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n            \\<in> S) =\n           (i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j));\n        \\<And>i.\n           partial_magma.arr\n            (\\<lambda>i j.\n                if i \\<in> S \\<and>\n                   j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n                then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n            i =\n           (i \\<in> S);\n        C' =\n        (\\<lambda>i j.\n            if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n            then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n);\n        \\<And>h g f. (h \\<cdot> g) \\<cdot> f = h \\<cdot> g \\<cdot> f;\n        n \\<notin> S\\<rbrakk>\n       \\<Longrightarrow> (h \\<in> S \\<longrightarrow>\n                          (seq (\\<phi> h) (\\<phi> g) \\<longrightarrow>\n                           seq (\\<phi> h)\n                            (\\<phi> g \\<cdot> \\<phi> f) \\<longrightarrow>\n                           \\<psi> (\\<phi> g \\<cdot> \\<phi> f)\n                           \\<notin> S \\<longrightarrow>\n                           \\<psi>\n                            (\\<phi> h \\<cdot> \\<phi> g \\<cdot> \\<phi> f) =\n                           n) \\<and>\n                          (\\<not> seq (\\<phi> h)\n                                   (\\<phi> g) \\<longrightarrow>\n                           (seq (\\<phi> n) (\\<phi> f) \\<longrightarrow>\n                            (\\<psi> (\\<phi> g \\<cdot> \\<phi> f)\n                             \\<in> S \\<and>\n                             seq (\\<phi> h)\n                              (\\<phi> g \\<cdot> \\<phi> f) \\<longrightarrow>\n                             \\<psi> (\\<phi> n \\<cdot> \\<phi> f) =\n                             \\<psi>\n                              (\\<phi> h \\<cdot>\n                               \\<phi> g \\<cdot> \\<phi> f)) \\<and>\n                            ((\\<psi> (\\<phi> g \\<cdot> \\<phi> f)\n                              \\<in> S \\<longrightarrow>\n                              \\<not> seq (\\<phi> h)\n(\\<phi> g \\<cdot> \\<phi> f)) \\<longrightarrow>\n                             \\<psi> (\\<phi> n \\<cdot> \\<phi> f) = n)) \\<and>\n                           (\\<not> seq (\\<phi> n)\n                                    (\\<phi> f) \\<longrightarrow>\n                            \\<psi> (\\<phi> g \\<cdot> \\<phi> f)\n                            \\<in> S \\<and>\n                            seq (\\<phi> h)\n                             (\\<phi> g \\<cdot> \\<phi> f) \\<longrightarrow>\n                            n =\n                            \\<psi>\n                             (\\<phi> h \\<cdot>\n                              \\<phi> g \\<cdot> \\<phi> f)))) \\<and>\n                         (h \\<notin> S \\<longrightarrow>\n                          seq (\\<phi> n) (\\<phi> f) \\<longrightarrow>\n                          \\<psi> (\\<phi> n \\<cdot> \\<phi> f) = n)", "by presburger"], ["proof (state)\nthis:\n  \\<lbrakk>C'.seq ?g ?f; C'.seq ?h ?g\\<rbrakk>\n  \\<Longrightarrow> C' (C' ?h ?g) ?f = C' ?h (C' ?g ?f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>C'.\n       Collect (partial_magma.arr C') = S \\<and>\n       invertible_functor C' (\\<cdot>)\n        (\\<lambda>i. if partial_magma.arr C' i then \\<phi> i else null)", "have dom_char: \"C'.dom = (\\<lambda>i. if i \\<in> S then \\<psi> (dom (\\<phi> i)) else n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C'.dom =\n    (\\<lambda>i. if i \\<in> S then \\<psi> (local.dom (\\<phi> i)) else n)", "using dom arr_char null_char C'.dom_eqI' C'.arr_def C'.dom_def"], ["proof (prove)\nusing this:\n  ?i \\<in> S \\<Longrightarrow>\n  \\<psi> (local.dom (\\<phi> ?i)) \\<in> C'.domains ?i\n  C'.arr ?i = (?i \\<in> S)\n  C'.null = n\n  ?a \\<in> C'.domains ?f \\<Longrightarrow> ?a = C'.dom ?f\n  C'.arr ?f \\<equiv>\n  C'.domains ?f \\<noteq> {} \\<or> C'.codomains ?f \\<noteq> {}\n  C'.dom ?f =\n  (if C'.domains ?f \\<noteq> {} then SOME a. a \\<in> C'.domains ?f\n   else C'.null)\n\ngoal (1 subgoal):\n 1. C'.dom =\n    (\\<lambda>i. if i \\<in> S then \\<psi> (local.dom (\\<phi> i)) else n)", "by metis"], ["proof (state)\nthis:\n  C'.dom =\n  (\\<lambda>i. if i \\<in> S then \\<psi> (local.dom (\\<phi> i)) else n)\n\ngoal (1 subgoal):\n 1. \\<exists>C'.\n       Collect (partial_magma.arr C') = S \\<and>\n       invertible_functor C' (\\<cdot>)\n        (\\<lambda>i. if partial_magma.arr C' i then \\<phi> i else null)", "have cod_char: \"C'.cod = (\\<lambda>i. if i \\<in> S then \\<psi> (cod (\\<phi> i)) else n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C'.cod = (\\<lambda>i. if i \\<in> S then \\<psi> (cod (\\<phi> i)) else n)", "using cod arr_char null_char C'.cod_eqI' C'.arr_def C'.cod_def"], ["proof (prove)\nusing this:\n  ?i \\<in> S \\<Longrightarrow>\n  \\<psi> (cod (\\<phi> ?i)) \\<in> C'.codomains ?i\n  C'.arr ?i = (?i \\<in> S)\n  C'.null = n\n  ?a \\<in> C'.codomains ?f \\<Longrightarrow> ?a = C'.cod ?f\n  C'.arr ?f \\<equiv>\n  C'.domains ?f \\<noteq> {} \\<or> C'.codomains ?f \\<noteq> {}\n  C'.cod ?f =\n  (if C'.codomains ?f \\<noteq> {} then SOME b. b \\<in> C'.codomains ?f\n   else C'.null)\n\ngoal (1 subgoal):\n 1. C'.cod = (\\<lambda>i. if i \\<in> S then \\<psi> (cod (\\<phi> i)) else n)", "by metis"], ["proof (state)\nthis:\n  C'.cod = (\\<lambda>i. if i \\<in> S then \\<psi> (cod (\\<phi> i)) else n)\n\ngoal (1 subgoal):\n 1. \\<exists>C'.\n       Collect (partial_magma.arr C') = S \\<and>\n       invertible_functor C' (\\<cdot>)\n        (\\<lambda>i. if partial_magma.arr C' i then \\<phi> i else null)", "interpret \\<phi>: \"functor\" C' C \\<open>\\<lambda>i. if C'.arr i then \\<phi> i else null\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. functor C' (\\<cdot>) (\\<lambda>i. if C'.arr i then \\<phi> i else null)", "using arr_char null_char dom_char cod_char seq_char \\<phi>_\\<psi> \\<psi>_\\<phi> \\<psi>_def C'.not_arr_null C'_def\n              C'.arr_dom C'.arr_cod"], ["proof (prove)\nusing this:\n  C'.arr ?i = (?i \\<in> S)\n  C'.null = n\n  C'.dom =\n  (\\<lambda>i. if i \\<in> S then \\<psi> (local.dom (\\<phi> i)) else n)\n  C'.cod = (\\<lambda>i. if i \\<in> S then \\<psi> (cod (\\<phi> i)) else n)\n  C'.seq ?i ?j =\n  (?i \\<in> S \\<and> ?j \\<in> S \\<and> seq (\\<phi> ?i) (\\<phi> ?j))\n  arr ?f \\<Longrightarrow> \\<phi> (\\<psi> ?f) = ?f\n  ?i \\<in> S \\<Longrightarrow> \\<psi> (\\<phi> ?i) = ?i\n  \\<psi> = (\\<lambda>f. if arr f then inv_into S \\<phi> f else n)\n  \\<not> C'.arr C'.null\n  C' =\n  (\\<lambda>i j.\n      if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n      then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n  C'.arr ?f \\<Longrightarrow> C'.arr (C'.dom ?f)\n  C'.arr ?f \\<Longrightarrow> C'.arr (C'.cod ?f)\n\ngoal (1 subgoal):\n 1. functor C' (\\<cdot>) (\\<lambda>i. if C'.arr i then \\<phi> i else null)", "apply unfold_locales"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>\\<And>i. C'.arr i = (i \\<in> S); C'.null = n;\n        C'.dom =\n        (\\<lambda>i.\n            if i \\<in> S then \\<psi> (local.dom (\\<phi> i)) else n);\n        C'.cod =\n        (\\<lambda>i. if i \\<in> S then \\<psi> (cod (\\<phi> i)) else n);\n        \\<And>i j.\n           C'.seq i j =\n           (i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j));\n        \\<And>f. arr f \\<Longrightarrow> \\<phi> (\\<psi> f) = f;\n        \\<And>i. i \\<in> S \\<Longrightarrow> \\<psi> (\\<phi> i) = i;\n        \\<psi> = (\\<lambda>f. if arr f then inv_into S \\<phi> f else n);\n        \\<not> C'.arr C'.null;\n        C' =\n        (\\<lambda>i j.\n            if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n            then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n);\n        \\<And>f. C'.arr f \\<Longrightarrow> C'.arr (C'.dom f);\n        \\<And>f. C'.arr f \\<Longrightarrow> C'.arr (C'.cod f);\n        \\<not> C'.arr f\\<rbrakk>\n       \\<Longrightarrow> (if C'.arr f then \\<phi> f else null) = null\n 2. \\<And>f.\n       \\<lbrakk>\\<And>i. C'.arr i = (i \\<in> S); C'.null = n;\n        C'.dom =\n        (\\<lambda>i.\n            if i \\<in> S then \\<psi> (local.dom (\\<phi> i)) else n);\n        C'.cod =\n        (\\<lambda>i. if i \\<in> S then \\<psi> (cod (\\<phi> i)) else n);\n        \\<And>i j.\n           C'.seq i j =\n           (i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j));\n        \\<And>f. arr f \\<Longrightarrow> \\<phi> (\\<psi> f) = f;\n        \\<And>i. i \\<in> S \\<Longrightarrow> \\<psi> (\\<phi> i) = i;\n        \\<psi> = (\\<lambda>f. if arr f then inv_into S \\<phi> f else n);\n        \\<not> C'.arr C'.null;\n        C' =\n        (\\<lambda>i j.\n            if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n            then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n);\n        \\<And>f. C'.arr f \\<Longrightarrow> C'.arr (C'.dom f);\n        \\<And>f. C'.arr f \\<Longrightarrow> C'.arr (C'.cod f);\n        C'.arr f\\<rbrakk>\n       \\<Longrightarrow> arr (if C'.arr f then \\<phi> f else null)\n 3. \\<And>f.\n       \\<lbrakk>\\<And>i. C'.arr i = (i \\<in> S); C'.null = n;\n        C'.dom =\n        (\\<lambda>i.\n            if i \\<in> S then \\<psi> (local.dom (\\<phi> i)) else n);\n        C'.cod =\n        (\\<lambda>i. if i \\<in> S then \\<psi> (cod (\\<phi> i)) else n);\n        \\<And>i j.\n           C'.seq i j =\n           (i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j));\n        \\<And>f. arr f \\<Longrightarrow> \\<phi> (\\<psi> f) = f;\n        \\<And>i. i \\<in> S \\<Longrightarrow> \\<psi> (\\<phi> i) = i;\n        \\<psi> = (\\<lambda>f. if arr f then inv_into S \\<phi> f else n);\n        \\<not> C'.arr C'.null;\n        C' =\n        (\\<lambda>i j.\n            if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n            then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n);\n        \\<And>f. C'.arr f \\<Longrightarrow> C'.arr (C'.dom f);\n        \\<And>f. C'.arr f \\<Longrightarrow> C'.arr (C'.cod f);\n        C'.arr f\\<rbrakk>\n       \\<Longrightarrow> local.dom (if C'.arr f then \\<phi> f else null) =\n                         (if C'.arr (C'.dom f) then \\<phi> (C'.dom f)\n                          else null)\n 4. \\<And>f.\n       \\<lbrakk>\\<And>i. C'.arr i = (i \\<in> S); C'.null = n;\n        C'.dom =\n        (\\<lambda>i.\n            if i \\<in> S then \\<psi> (local.dom (\\<phi> i)) else n);\n        C'.cod =\n        (\\<lambda>i. if i \\<in> S then \\<psi> (cod (\\<phi> i)) else n);\n        \\<And>i j.\n           C'.seq i j =\n           (i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j));\n        \\<And>f. arr f \\<Longrightarrow> \\<phi> (\\<psi> f) = f;\n        \\<And>i. i \\<in> S \\<Longrightarrow> \\<psi> (\\<phi> i) = i;\n        \\<psi> = (\\<lambda>f. if arr f then inv_into S \\<phi> f else n);\n        \\<not> C'.arr C'.null;\n        C' =\n        (\\<lambda>i j.\n            if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n            then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n);\n        \\<And>f. C'.arr f \\<Longrightarrow> C'.arr (C'.dom f);\n        \\<And>f. C'.arr f \\<Longrightarrow> C'.arr (C'.cod f);\n        C'.arr f\\<rbrakk>\n       \\<Longrightarrow> cod (if C'.arr f then \\<phi> f else null) =\n                         (if C'.arr (C'.cod f) then \\<phi> (C'.cod f)\n                          else null)\n 5. \\<And>g f.\n       \\<lbrakk>\\<And>i. C'.arr i = (i \\<in> S); C'.null = n;\n        C'.dom =\n        (\\<lambda>i.\n            if i \\<in> S then \\<psi> (local.dom (\\<phi> i)) else n);\n        C'.cod =\n        (\\<lambda>i. if i \\<in> S then \\<psi> (cod (\\<phi> i)) else n);\n        \\<And>i j.\n           C'.seq i j =\n           (i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j));\n        \\<And>f. arr f \\<Longrightarrow> \\<phi> (\\<psi> f) = f;\n        \\<And>i. i \\<in> S \\<Longrightarrow> \\<psi> (\\<phi> i) = i;\n        \\<psi> = (\\<lambda>f. if arr f then inv_into S \\<phi> f else n);\n        \\<not> C'.arr C'.null;\n        C' =\n        (\\<lambda>i j.\n            if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n            then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n);\n        \\<And>f. C'.arr f \\<Longrightarrow> C'.arr (C'.dom f);\n        \\<And>f. C'.arr f \\<Longrightarrow> C'.arr (C'.cod f);\n        C'.seq g f\\<rbrakk>\n       \\<Longrightarrow> (if C'.seq g f then \\<phi> (C' g f) else null) =\n                         (if C'.arr g then \\<phi> g else null) \\<cdot>\n                         (if C'.arr f then \\<phi> f else null)", "apply simp_all"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>\\<And>i.\n                   partial_magma.arr\n                    (\\<lambda>i j.\n                        if i \\<in> S \\<and>\n                           j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n                        then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n                    i =\n                   (i \\<in> S);\n        partial_magma.null\n         (\\<lambda>i j.\n             if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n) =\n        n;\n        partial_magma.dom\n         (\\<lambda>i j.\n             if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n) =\n        (\\<lambda>i.\n            if i \\<in> S then \\<psi> (local.dom (\\<phi> i)) else n);\n        partial_magma.cod\n         (\\<lambda>i j.\n             if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n) =\n        (\\<lambda>i. if i \\<in> S then \\<psi> (cod (\\<phi> i)) else n);\n        \\<And>i j.\n           ((if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n            \\<in> S) =\n           (i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j));\n        \\<And>f. arr f \\<Longrightarrow> \\<phi> (inv_into S \\<phi> f) = f;\n        \\<And>i.\n           i \\<in> S \\<Longrightarrow>\n           (if arr (\\<phi> i) then inv_into S \\<phi> (\\<phi> i) else n) = i;\n        \\<psi> = (\\<lambda>f. if arr f then inv_into S \\<phi> f else n);\n        n \\<notin> S;\n        C' =\n        (\\<lambda>i j.\n            if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n            then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n);\n        \\<And>f.\n           f \\<in> S \\<Longrightarrow>\n           (if arr (local.dom (\\<phi> f))\n            then inv_into S \\<phi> (local.dom (\\<phi> f)) else n)\n           \\<in> S;\n        \\<And>f.\n           f \\<in> S \\<Longrightarrow>\n           (if arr (cod (\\<phi> f)) then inv_into S \\<phi> (cod (\\<phi> f))\n            else n)\n           \\<in> S;\n        f \\<in> S\\<rbrakk>\n       \\<Longrightarrow> arr (\\<phi> f)\n 2. \\<And>f.\n       \\<lbrakk>\\<And>i.\n                   partial_magma.arr\n                    (\\<lambda>i j.\n                        if i \\<in> S \\<and>\n                           j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n                        then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n                    i =\n                   (i \\<in> S);\n        partial_magma.null\n         (\\<lambda>i j.\n             if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n) =\n        n;\n        partial_magma.dom\n         (\\<lambda>i j.\n             if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n) =\n        (\\<lambda>i.\n            if i \\<in> S then \\<psi> (local.dom (\\<phi> i)) else n);\n        partial_magma.cod\n         (\\<lambda>i j.\n             if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n) =\n        (\\<lambda>i. if i \\<in> S then \\<psi> (cod (\\<phi> i)) else n);\n        \\<And>i j.\n           ((if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n            \\<in> S) =\n           (i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j));\n        \\<And>f. arr f \\<Longrightarrow> \\<phi> (inv_into S \\<phi> f) = f;\n        \\<And>i.\n           i \\<in> S \\<Longrightarrow>\n           (if arr (\\<phi> i) then inv_into S \\<phi> (\\<phi> i) else n) = i;\n        \\<psi> = (\\<lambda>f. if arr f then inv_into S \\<phi> f else n);\n        n \\<notin> S;\n        C' =\n        (\\<lambda>i j.\n            if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n            then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n);\n        \\<And>f.\n           f \\<in> S \\<Longrightarrow>\n           (if arr (local.dom (\\<phi> f))\n            then inv_into S \\<phi> (local.dom (\\<phi> f)) else n)\n           \\<in> S;\n        \\<And>f.\n           f \\<in> S \\<Longrightarrow>\n           (if arr (cod (\\<phi> f)) then inv_into S \\<phi> (cod (\\<phi> f))\n            else n)\n           \\<in> S;\n        f \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<not> arr (local.dom (\\<phi> f)) \\<longrightarrow>\n                         local.dom (\\<phi> f) = \\<phi> n\n 3. \\<And>f.\n       \\<lbrakk>\\<And>i.\n                   partial_magma.arr\n                    (\\<lambda>i j.\n                        if i \\<in> S \\<and>\n                           j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n                        then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n                    i =\n                   (i \\<in> S);\n        partial_magma.null\n         (\\<lambda>i j.\n             if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n) =\n        n;\n        partial_magma.dom\n         (\\<lambda>i j.\n             if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n) =\n        (\\<lambda>i.\n            if i \\<in> S then \\<psi> (local.dom (\\<phi> i)) else n);\n        partial_magma.cod\n         (\\<lambda>i j.\n             if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n) =\n        (\\<lambda>i. if i \\<in> S then \\<psi> (cod (\\<phi> i)) else n);\n        \\<And>i j.\n           ((if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n            \\<in> S) =\n           (i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j));\n        \\<And>f. arr f \\<Longrightarrow> \\<phi> (inv_into S \\<phi> f) = f;\n        \\<And>i.\n           i \\<in> S \\<Longrightarrow>\n           (if arr (\\<phi> i) then inv_into S \\<phi> (\\<phi> i) else n) = i;\n        \\<psi> = (\\<lambda>f. if arr f then inv_into S \\<phi> f else n);\n        n \\<notin> S;\n        C' =\n        (\\<lambda>i j.\n            if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n            then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n);\n        \\<And>f.\n           f \\<in> S \\<Longrightarrow>\n           (if arr (local.dom (\\<phi> f))\n            then inv_into S \\<phi> (local.dom (\\<phi> f)) else n)\n           \\<in> S;\n        \\<And>f.\n           f \\<in> S \\<Longrightarrow>\n           (if arr (cod (\\<phi> f)) then inv_into S \\<phi> (cod (\\<phi> f))\n            else n)\n           \\<in> S;\n        f \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<not> arr (cod (\\<phi> f)) \\<longrightarrow>\n                         cod (\\<phi> f) = \\<phi> n\n 4. \\<And>g f.\n       \\<lbrakk>\\<And>i.\n                   partial_magma.arr\n                    (\\<lambda>i j.\n                        if i \\<in> S \\<and>\n                           j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n                        then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n                    i =\n                   (i \\<in> S);\n        partial_magma.null\n         (\\<lambda>i j.\n             if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n) =\n        n;\n        partial_magma.dom\n         (\\<lambda>i j.\n             if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n) =\n        (\\<lambda>i.\n            if i \\<in> S then \\<psi> (local.dom (\\<phi> i)) else n);\n        partial_magma.cod\n         (\\<lambda>i j.\n             if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n) =\n        (\\<lambda>i. if i \\<in> S then \\<psi> (cod (\\<phi> i)) else n);\n        \\<And>i j.\n           ((if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n            \\<in> S) =\n           (i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j));\n        \\<And>f. arr f \\<Longrightarrow> \\<phi> (inv_into S \\<phi> f) = f;\n        \\<And>i.\n           i \\<in> S \\<Longrightarrow>\n           (if arr (\\<phi> i) then inv_into S \\<phi> (\\<phi> i) else n) = i;\n        \\<psi> = (\\<lambda>f. if arr f then inv_into S \\<phi> f else n);\n        n \\<notin> S;\n        C' =\n        (\\<lambda>i j.\n            if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n            then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n);\n        \\<And>f.\n           f \\<in> S \\<Longrightarrow>\n           (if arr (local.dom (\\<phi> f))\n            then inv_into S \\<phi> (local.dom (\\<phi> f)) else n)\n           \\<in> S;\n        \\<And>f.\n           f \\<in> S \\<Longrightarrow>\n           (if arr (cod (\\<phi> f)) then inv_into S \\<phi> (cod (\\<phi> f))\n            else n)\n           \\<in> S;\n        g \\<in> S \\<and> f \\<in> S \\<and> seq (\\<phi> g) (\\<phi> f)\\<rbrakk>\n       \\<Longrightarrow> inv_into S \\<phi> (\\<phi> g \\<cdot> \\<phi> f)\n                         \\<notin> S \\<longrightarrow>\n                         null = \\<phi> g \\<cdot> \\<phi> f", "apply (metis (full_types))"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>\\<And>i.\n                   partial_magma.arr\n                    (\\<lambda>i j.\n                        if i \\<in> S \\<and>\n                           j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n                        then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n                    i =\n                   (i \\<in> S);\n        partial_magma.null\n         (\\<lambda>i j.\n             if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n) =\n        n;\n        partial_magma.dom\n         (\\<lambda>i j.\n             if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n) =\n        (\\<lambda>i.\n            if i \\<in> S then \\<psi> (local.dom (\\<phi> i)) else n);\n        partial_magma.cod\n         (\\<lambda>i j.\n             if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n) =\n        (\\<lambda>i. if i \\<in> S then \\<psi> (cod (\\<phi> i)) else n);\n        \\<And>i j.\n           ((if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n            \\<in> S) =\n           (i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j));\n        \\<And>f. arr f \\<Longrightarrow> \\<phi> (inv_into S \\<phi> f) = f;\n        \\<And>i.\n           i \\<in> S \\<Longrightarrow>\n           (if arr (\\<phi> i) then inv_into S \\<phi> (\\<phi> i) else n) = i;\n        \\<psi> = (\\<lambda>f. if arr f then inv_into S \\<phi> f else n);\n        n \\<notin> S;\n        C' =\n        (\\<lambda>i j.\n            if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n            then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n);\n        \\<And>f.\n           f \\<in> S \\<Longrightarrow>\n           (if arr (local.dom (\\<phi> f))\n            then inv_into S \\<phi> (local.dom (\\<phi> f)) else n)\n           \\<in> S;\n        \\<And>f.\n           f \\<in> S \\<Longrightarrow>\n           (if arr (cod (\\<phi> f)) then inv_into S \\<phi> (cod (\\<phi> f))\n            else n)\n           \\<in> S;\n        f \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<not> arr (local.dom (\\<phi> f)) \\<longrightarrow>\n                         local.dom (\\<phi> f) = \\<phi> n\n 2. \\<And>f.\n       \\<lbrakk>\\<And>i.\n                   partial_magma.arr\n                    (\\<lambda>i j.\n                        if i \\<in> S \\<and>\n                           j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n                        then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n                    i =\n                   (i \\<in> S);\n        partial_magma.null\n         (\\<lambda>i j.\n             if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n) =\n        n;\n        partial_magma.dom\n         (\\<lambda>i j.\n             if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n) =\n        (\\<lambda>i.\n            if i \\<in> S then \\<psi> (local.dom (\\<phi> i)) else n);\n        partial_magma.cod\n         (\\<lambda>i j.\n             if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n) =\n        (\\<lambda>i. if i \\<in> S then \\<psi> (cod (\\<phi> i)) else n);\n        \\<And>i j.\n           ((if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n            \\<in> S) =\n           (i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j));\n        \\<And>f. arr f \\<Longrightarrow> \\<phi> (inv_into S \\<phi> f) = f;\n        \\<And>i.\n           i \\<in> S \\<Longrightarrow>\n           (if arr (\\<phi> i) then inv_into S \\<phi> (\\<phi> i) else n) = i;\n        \\<psi> = (\\<lambda>f. if arr f then inv_into S \\<phi> f else n);\n        n \\<notin> S;\n        C' =\n        (\\<lambda>i j.\n            if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n            then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n);\n        \\<And>f.\n           f \\<in> S \\<Longrightarrow>\n           (if arr (local.dom (\\<phi> f))\n            then inv_into S \\<phi> (local.dom (\\<phi> f)) else n)\n           \\<in> S;\n        \\<And>f.\n           f \\<in> S \\<Longrightarrow>\n           (if arr (cod (\\<phi> f)) then inv_into S \\<phi> (cod (\\<phi> f))\n            else n)\n           \\<in> S;\n        f \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<not> arr (cod (\\<phi> f)) \\<longrightarrow>\n                         cod (\\<phi> f) = \\<phi> n\n 3. \\<And>g f.\n       \\<lbrakk>\\<And>i.\n                   partial_magma.arr\n                    (\\<lambda>i j.\n                        if i \\<in> S \\<and>\n                           j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n                        then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n                    i =\n                   (i \\<in> S);\n        partial_magma.null\n         (\\<lambda>i j.\n             if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n) =\n        n;\n        partial_magma.dom\n         (\\<lambda>i j.\n             if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n) =\n        (\\<lambda>i.\n            if i \\<in> S then \\<psi> (local.dom (\\<phi> i)) else n);\n        partial_magma.cod\n         (\\<lambda>i j.\n             if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n) =\n        (\\<lambda>i. if i \\<in> S then \\<psi> (cod (\\<phi> i)) else n);\n        \\<And>i j.\n           ((if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n            \\<in> S) =\n           (i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j));\n        \\<And>f. arr f \\<Longrightarrow> \\<phi> (inv_into S \\<phi> f) = f;\n        \\<And>i.\n           i \\<in> S \\<Longrightarrow>\n           (if arr (\\<phi> i) then inv_into S \\<phi> (\\<phi> i) else n) = i;\n        \\<psi> = (\\<lambda>f. if arr f then inv_into S \\<phi> f else n);\n        n \\<notin> S;\n        C' =\n        (\\<lambda>i j.\n            if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n            then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n);\n        \\<And>f.\n           f \\<in> S \\<Longrightarrow>\n           (if arr (local.dom (\\<phi> f))\n            then inv_into S \\<phi> (local.dom (\\<phi> f)) else n)\n           \\<in> S;\n        \\<And>f.\n           f \\<in> S \\<Longrightarrow>\n           (if arr (cod (\\<phi> f)) then inv_into S \\<phi> (cod (\\<phi> f))\n            else n)\n           \\<in> S;\n        g \\<in> S \\<and> f \\<in> S \\<and> seq (\\<phi> g) (\\<phi> f)\\<rbrakk>\n       \\<Longrightarrow> inv_into S \\<phi> (\\<phi> g \\<cdot> \\<phi> f)\n                         \\<notin> S \\<longrightarrow>\n                         null = \\<phi> g \\<cdot> \\<phi> f", "apply force"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>\\<And>i.\n                   partial_magma.arr\n                    (\\<lambda>i j.\n                        if i \\<in> S \\<and>\n                           j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n                        then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n                    i =\n                   (i \\<in> S);\n        partial_magma.null\n         (\\<lambda>i j.\n             if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n) =\n        n;\n        partial_magma.dom\n         (\\<lambda>i j.\n             if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n) =\n        (\\<lambda>i.\n            if i \\<in> S then \\<psi> (local.dom (\\<phi> i)) else n);\n        partial_magma.cod\n         (\\<lambda>i j.\n             if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n) =\n        (\\<lambda>i. if i \\<in> S then \\<psi> (cod (\\<phi> i)) else n);\n        \\<And>i j.\n           ((if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n            \\<in> S) =\n           (i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j));\n        \\<And>f. arr f \\<Longrightarrow> \\<phi> (inv_into S \\<phi> f) = f;\n        \\<And>i.\n           i \\<in> S \\<Longrightarrow>\n           (if arr (\\<phi> i) then inv_into S \\<phi> (\\<phi> i) else n) = i;\n        \\<psi> = (\\<lambda>f. if arr f then inv_into S \\<phi> f else n);\n        n \\<notin> S;\n        C' =\n        (\\<lambda>i j.\n            if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n            then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n);\n        \\<And>f.\n           f \\<in> S \\<Longrightarrow>\n           (if arr (local.dom (\\<phi> f))\n            then inv_into S \\<phi> (local.dom (\\<phi> f)) else n)\n           \\<in> S;\n        \\<And>f.\n           f \\<in> S \\<Longrightarrow>\n           (if arr (cod (\\<phi> f)) then inv_into S \\<phi> (cod (\\<phi> f))\n            else n)\n           \\<in> S;\n        f \\<in> S\\<rbrakk>\n       \\<Longrightarrow> \\<not> arr (cod (\\<phi> f)) \\<longrightarrow>\n                         cod (\\<phi> f) = \\<phi> n\n 2. \\<And>g f.\n       \\<lbrakk>\\<And>i.\n                   partial_magma.arr\n                    (\\<lambda>i j.\n                        if i \\<in> S \\<and>\n                           j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n                        then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n                    i =\n                   (i \\<in> S);\n        partial_magma.null\n         (\\<lambda>i j.\n             if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n) =\n        n;\n        partial_magma.dom\n         (\\<lambda>i j.\n             if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n) =\n        (\\<lambda>i.\n            if i \\<in> S then \\<psi> (local.dom (\\<phi> i)) else n);\n        partial_magma.cod\n         (\\<lambda>i j.\n             if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n) =\n        (\\<lambda>i. if i \\<in> S then \\<psi> (cod (\\<phi> i)) else n);\n        \\<And>i j.\n           ((if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n            \\<in> S) =\n           (i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j));\n        \\<And>f. arr f \\<Longrightarrow> \\<phi> (inv_into S \\<phi> f) = f;\n        \\<And>i.\n           i \\<in> S \\<Longrightarrow>\n           (if arr (\\<phi> i) then inv_into S \\<phi> (\\<phi> i) else n) = i;\n        \\<psi> = (\\<lambda>f. if arr f then inv_into S \\<phi> f else n);\n        n \\<notin> S;\n        C' =\n        (\\<lambda>i j.\n            if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n            then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n);\n        \\<And>f.\n           f \\<in> S \\<Longrightarrow>\n           (if arr (local.dom (\\<phi> f))\n            then inv_into S \\<phi> (local.dom (\\<phi> f)) else n)\n           \\<in> S;\n        \\<And>f.\n           f \\<in> S \\<Longrightarrow>\n           (if arr (cod (\\<phi> f)) then inv_into S \\<phi> (cod (\\<phi> f))\n            else n)\n           \\<in> S;\n        g \\<in> S \\<and> f \\<in> S \\<and> seq (\\<phi> g) (\\<phi> f)\\<rbrakk>\n       \\<Longrightarrow> inv_into S \\<phi> (\\<phi> g \\<cdot> \\<phi> f)\n                         \\<notin> S \\<longrightarrow>\n                         null = \\<phi> g \\<cdot> \\<phi> f", "apply force"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g f.\n       \\<lbrakk>\\<And>i.\n                   partial_magma.arr\n                    (\\<lambda>i j.\n                        if i \\<in> S \\<and>\n                           j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n                        then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n                    i =\n                   (i \\<in> S);\n        partial_magma.null\n         (\\<lambda>i j.\n             if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n) =\n        n;\n        partial_magma.dom\n         (\\<lambda>i j.\n             if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n) =\n        (\\<lambda>i.\n            if i \\<in> S then \\<psi> (local.dom (\\<phi> i)) else n);\n        partial_magma.cod\n         (\\<lambda>i j.\n             if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n) =\n        (\\<lambda>i. if i \\<in> S then \\<psi> (cod (\\<phi> i)) else n);\n        \\<And>i j.\n           ((if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n             then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n)\n            \\<in> S) =\n           (i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j));\n        \\<And>f. arr f \\<Longrightarrow> \\<phi> (inv_into S \\<phi> f) = f;\n        \\<And>i.\n           i \\<in> S \\<Longrightarrow>\n           (if arr (\\<phi> i) then inv_into S \\<phi> (\\<phi> i) else n) = i;\n        \\<psi> = (\\<lambda>f. if arr f then inv_into S \\<phi> f else n);\n        n \\<notin> S;\n        C' =\n        (\\<lambda>i j.\n            if i \\<in> S \\<and> j \\<in> S \\<and> seq (\\<phi> i) (\\<phi> j)\n            then \\<psi> (\\<phi> i \\<cdot> \\<phi> j) else n);\n        \\<And>f.\n           f \\<in> S \\<Longrightarrow>\n           (if arr (local.dom (\\<phi> f))\n            then inv_into S \\<phi> (local.dom (\\<phi> f)) else n)\n           \\<in> S;\n        \\<And>f.\n           f \\<in> S \\<Longrightarrow>\n           (if arr (cod (\\<phi> f)) then inv_into S \\<phi> (cod (\\<phi> f))\n            else n)\n           \\<in> S;\n        g \\<in> S \\<and> f \\<in> S \\<and> seq (\\<phi> g) (\\<phi> f)\\<rbrakk>\n       \\<Longrightarrow> inv_into S \\<phi> (\\<phi> g \\<cdot> \\<phi> f)\n                         \\<notin> S \\<longrightarrow>\n                         null = \\<phi> g \\<cdot> \\<phi> f", "by metis"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>C'.\n       Collect (partial_magma.arr C') = S \\<and>\n       invertible_functor C' (\\<cdot>)\n        (\\<lambda>i. if partial_magma.arr C' i then \\<phi> i else null)", "interpret \\<psi>: \"functor\" C C' \\<psi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. functor (\\<cdot>) C' \\<psi>", "using \\<psi>_def null_char arr_char"], ["proof (prove)\nusing this:\n  \\<psi> = (\\<lambda>f. if arr f then inv_into S \\<phi> f else n)\n  C'.null = n\n  C'.arr ?i = (?i \\<in> S)\n\ngoal (1 subgoal):\n 1. functor (\\<cdot>) C' \\<psi>", "apply unfold_locales"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>\\<psi> =\n                (\\<lambda>f. if arr f then inv_into S \\<phi> f else n);\n        C'.null = n; \\<And>i. C'.arr i = (i \\<in> S); \\<not> arr f\\<rbrakk>\n       \\<Longrightarrow> \\<psi> f = C'.null\n 2. \\<And>f.\n       \\<lbrakk>\\<psi> =\n                (\\<lambda>f. if arr f then inv_into S \\<phi> f else n);\n        C'.null = n; \\<And>i. C'.arr i = (i \\<in> S); arr f\\<rbrakk>\n       \\<Longrightarrow> C'.arr (\\<psi> f)\n 3. \\<And>f.\n       \\<lbrakk>\\<psi> =\n                (\\<lambda>f. if arr f then inv_into S \\<phi> f else n);\n        C'.null = n; \\<And>i. C'.arr i = (i \\<in> S); arr f\\<rbrakk>\n       \\<Longrightarrow> C'.dom (\\<psi> f) = \\<psi> (local.dom f)\n 4. \\<And>f.\n       \\<lbrakk>\\<psi> =\n                (\\<lambda>f. if arr f then inv_into S \\<phi> f else n);\n        C'.null = n; \\<And>i. C'.arr i = (i \\<in> S); arr f\\<rbrakk>\n       \\<Longrightarrow> C'.cod (\\<psi> f) = \\<psi> (cod f)\n 5. \\<And>g f.\n       \\<lbrakk>\\<psi> =\n                (\\<lambda>f. if arr f then inv_into S \\<phi> f else n);\n        C'.null = n; \\<And>i. C'.arr i = (i \\<in> S); seq g f\\<rbrakk>\n       \\<Longrightarrow> \\<psi> (g \\<cdot> f) = C' (\\<psi> g) (\\<psi> f)", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>\\<psi> =\n                (\\<lambda>f. if arr f then inv_into S \\<phi> f else n);\n        C'.null = n; \\<And>i. C'.arr i = (i \\<in> S); arr f\\<rbrakk>\n       \\<Longrightarrow> C'.arr (\\<psi> f)\n 2. \\<And>f.\n       \\<lbrakk>\\<psi> =\n                (\\<lambda>f. if arr f then inv_into S \\<phi> f else n);\n        C'.null = n; \\<And>i. C'.arr i = (i \\<in> S); arr f\\<rbrakk>\n       \\<Longrightarrow> C'.dom (\\<psi> f) = \\<psi> (local.dom f)\n 3. \\<And>f.\n       \\<lbrakk>\\<psi> =\n                (\\<lambda>f. if arr f then inv_into S \\<phi> f else n);\n        C'.null = n; \\<And>i. C'.arr i = (i \\<in> S); arr f\\<rbrakk>\n       \\<Longrightarrow> C'.cod (\\<psi> f) = \\<psi> (cod f)\n 4. \\<And>g f.\n       \\<lbrakk>\\<psi> =\n                (\\<lambda>f. if arr f then inv_into S \\<phi> f else n);\n        C'.null = n; \\<And>i. C'.arr i = (i \\<in> S); seq g f\\<rbrakk>\n       \\<Longrightarrow> \\<psi> (g \\<cdot> f) = C' (\\<psi> g) (\\<psi> f)", "apply (metis (no_types, lifting) \\<psi> bij_betw_def image_eqI mem_Collect_eq)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>\\<psi> =\n                (\\<lambda>f. if arr f then inv_into S \\<phi> f else n);\n        C'.null = n; \\<And>i. C'.arr i = (i \\<in> S); arr f\\<rbrakk>\n       \\<Longrightarrow> C'.dom (\\<psi> f) = \\<psi> (local.dom f)\n 2. \\<And>f.\n       \\<lbrakk>\\<psi> =\n                (\\<lambda>f. if arr f then inv_into S \\<phi> f else n);\n        C'.null = n; \\<And>i. C'.arr i = (i \\<in> S); arr f\\<rbrakk>\n       \\<Longrightarrow> C'.cod (\\<psi> f) = \\<psi> (cod f)\n 3. \\<And>g f.\n       \\<lbrakk>\\<psi> =\n                (\\<lambda>f. if arr f then inv_into S \\<phi> f else n);\n        C'.null = n; \\<And>i. C'.arr i = (i \\<in> S); seq g f\\<rbrakk>\n       \\<Longrightarrow> \\<psi> (g \\<cdot> f) = C' (\\<psi> g) (\\<psi> f)", "apply (metis (no_types, lifting) \\<phi>_\\<psi> \\<psi> bij_betw_def dom_char image_eqI mem_Collect_eq)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>\\<psi> =\n                (\\<lambda>f. if arr f then inv_into S \\<phi> f else n);\n        C'.null = n; \\<And>i. C'.arr i = (i \\<in> S); arr f\\<rbrakk>\n       \\<Longrightarrow> C'.cod (\\<psi> f) = \\<psi> (cod f)\n 2. \\<And>g f.\n       \\<lbrakk>\\<psi> =\n                (\\<lambda>f. if arr f then inv_into S \\<phi> f else n);\n        C'.null = n; \\<And>i. C'.arr i = (i \\<in> S); seq g f\\<rbrakk>\n       \\<Longrightarrow> \\<psi> (g \\<cdot> f) = C' (\\<psi> g) (\\<psi> f)", "apply (metis (no_types, lifting) \\<phi>_\\<psi> \\<psi> bij_betw_def cod_char image_eqI mem_Collect_eq)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g f.\n       \\<lbrakk>\\<psi> =\n                (\\<lambda>f. if arr f then inv_into S \\<phi> f else n);\n        C'.null = n; \\<And>i. C'.arr i = (i \\<in> S); seq g f\\<rbrakk>\n       \\<Longrightarrow> \\<psi> (g \\<cdot> f) = C' (\\<psi> g) (\\<psi> f)", "by (metis (no_types, lifting) C'_def \\<phi>_\\<psi> \\<psi> bij_betw_def seqE image_eqI mem_Collect_eq)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>C'.\n       Collect (partial_magma.arr C') = S \\<and>\n       invertible_functor C' (\\<cdot>)\n        (\\<lambda>i. if partial_magma.arr C' i then \\<phi> i else null)", "interpret \\<phi>\\<psi>: inverse_functors C' C \\<psi> \\<open>\\<lambda>i. if C'.arr i then \\<phi> i else null\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_functors C' (\\<cdot>) \\<psi>\n     (\\<lambda>i. if C'.arr i then \\<phi> i else null)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<lambda>i. if C'.arr i then \\<phi> i else null) \\<circ> \\<psi> =\n    local.map\n 2. \\<psi> \\<circ> (\\<lambda>i. if C'.arr i then \\<phi> i else null) =\n    C'.map", "show \"\\<psi> \\<circ> (\\<lambda>i. if C'.arr i then \\<phi> i else null) = C'.map\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> \\<circ> (\\<lambda>i. if C'.arr i then \\<phi> i else null) =\n    C'.map", "by (auto simp add: C'.is_extensional \\<psi>.is_extensional arr_char)"], ["proof (state)\nthis:\n  \\<psi> \\<circ> (\\<lambda>i. if C'.arr i then \\<phi> i else null) = C'.map\n\ngoal (1 subgoal):\n 1. (\\<lambda>i. if C'.arr i then \\<phi> i else null) \\<circ> \\<psi> =\n    local.map", "show \"(\\<lambda>i. if C'.arr i then \\<phi> i else null) \\<circ> \\<psi> = map\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>i. if C'.arr i then \\<phi> i else null) \\<circ> \\<psi> =\n    local.map", "by (auto simp add: is_extensional)"], ["proof (state)\nthis:\n  (\\<lambda>i. if C'.arr i then \\<phi> i else null) \\<circ> \\<psi> =\n  local.map\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>C'.\n       Collect (partial_magma.arr C') = S \\<and>\n       invertible_functor C' (\\<cdot>)\n        (\\<lambda>i. if partial_magma.arr C' i then \\<phi> i else null)", "have \"invertible_functor C' C (\\<lambda>i. if C'.arr i then \\<phi> i else null)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible_functor C' (\\<cdot>)\n     (\\<lambda>i. if C'.arr i then \\<phi> i else null)", "using \\<phi>\\<psi>.inverse_functors_axioms"], ["proof (prove)\nusing this:\n  inverse_functors C' (\\<cdot>) \\<psi>\n   (\\<lambda>i. if C'.arr i then \\<phi> i else null)\n\ngoal (1 subgoal):\n 1. invertible_functor C' (\\<cdot>)\n     (\\<lambda>i. if C'.arr i then \\<phi> i else null)", "by unfold_locales auto"], ["proof (state)\nthis:\n  invertible_functor C' (\\<cdot>)\n   (\\<lambda>i. if C'.arr i then \\<phi> i else null)\n\ngoal (1 subgoal):\n 1. \\<exists>C'.\n       Collect (partial_magma.arr C') = S \\<and>\n       invertible_functor C' (\\<cdot>)\n        (\\<lambda>i. if partial_magma.arr C' i then \\<phi> i else null)", "thus ?thesis"], ["proof (prove)\nusing this:\n  invertible_functor C' (\\<cdot>)\n   (\\<lambda>i. if C'.arr i then \\<phi> i else null)\n\ngoal (1 subgoal):\n 1. \\<exists>C'.\n       Collect (partial_magma.arr C') = S \\<and>\n       invertible_functor C' (\\<cdot>)\n        (\\<lambda>i. if partial_magma.arr C' i then \\<phi> i else null)", "using arr_char"], ["proof (prove)\nusing this:\n  invertible_functor C' (\\<cdot>)\n   (\\<lambda>i. if C'.arr i then \\<phi> i else null)\n  C'.arr ?i = (?i \\<in> S)\n\ngoal (1 subgoal):\n 1. \\<exists>C'.\n       Collect (partial_magma.arr C') = S \\<and>\n       invertible_functor C' (\\<cdot>)\n        (\\<lambda>i. if partial_magma.arr C' i then \\<phi> i else null)", "by blast"], ["proof (state)\nthis:\n  \\<exists>C'.\n     Collect (partial_magma.arr C') = S \\<and>\n     invertible_functor C' (\\<cdot>)\n      (\\<lambda>i. if partial_magma.arr C' i then \\<phi> i else null)\n\ngoal:\nNo subgoals!", "qed"], ["", "corollary (in category) finite_imp_ex_iso_nat_comp:\n    assumes \"finite (Collect arr)\"\n    shows \"\\<exists>C' :: nat comp. isomorphic_categories C' C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C'. isomorphic_categories C' (\\<cdot>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>C'. isomorphic_categories C' (\\<cdot>)", "obtain n :: nat and \\<phi> where \\<phi>: \"bij_betw \\<phi> {0..<n} (Collect arr)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<phi> n.\n        bij_betw \\<phi> {0..<n} (Collect arr) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms ex_bij_betw_nat_finite"], ["proof (prove)\nusing this:\n  finite (Collect arr)\n  finite ?M \\<Longrightarrow> \\<exists>h. bij_betw h {0..<card ?M} ?M\n\ngoal (1 subgoal):\n 1. (\\<And>\\<phi> n.\n        bij_betw \\<phi> {0..<n} (Collect arr) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  bij_betw \\<phi> {0..<n} (Collect arr)\n\ngoal (1 subgoal):\n 1. \\<exists>C'. isomorphic_categories C' (\\<cdot>)", "obtain C' where C': \"Collect (partial_magma.arr C') = {0..<n} \\<and>\n                           invertible_functor C' (\\<cdot>)\n                             (\\<lambda>i. if partial_magma.arr C' i then \\<phi> i else null)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>C'.\n        Collect (partial_magma.arr C') = {0..<n} \\<and>\n        invertible_functor C' (\\<cdot>)\n         (\\<lambda>i.\n             if partial_magma.arr C' i then \\<phi> i\n             else null) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using \\<phi> bij_induces_invertible_functor [of \\<phi> \"{0..<n}\"]"], ["proof (prove)\nusing this:\n  bij_betw \\<phi> {0..<n} (Collect arr)\n  \\<lbrakk>bij_betw \\<phi> {0..<n} (Collect arr);\n   ?n \\<notin> {0..<n}\\<rbrakk>\n  \\<Longrightarrow> \\<exists>C'.\n                       Collect (partial_magma.arr C') = {0..<n} \\<and>\n                       invertible_functor C' (\\<cdot>)\n                        (\\<lambda>i.\n                            if partial_magma.arr C' i then \\<phi> i\n                            else null)\n\ngoal (1 subgoal):\n 1. (\\<And>C'.\n        Collect (partial_magma.arr C') = {0..<n} \\<and>\n        invertible_functor C' (\\<cdot>)\n         (\\<lambda>i.\n             if partial_magma.arr C' i then \\<phi> i\n             else null) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  Collect (partial_magma.arr C') = {0..<n} \\<and>\n  invertible_functor C' (\\<cdot>)\n   (\\<lambda>i. if partial_magma.arr C' i then \\<phi> i else null)\n\ngoal (1 subgoal):\n 1. \\<exists>C'. isomorphic_categories C' (\\<cdot>)", "interpret \\<phi>: invertible_functor C' C \\<open>\\<lambda>i. if partial_magma.arr C' i then \\<phi> i else null\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible_functor C' (\\<cdot>)\n     (\\<lambda>i. if partial_magma.arr C' i then \\<phi> i else null)", "using C'"], ["proof (prove)\nusing this:\n  Collect (partial_magma.arr C') = {0..<n} \\<and>\n  invertible_functor C' (\\<cdot>)\n   (\\<lambda>i. if partial_magma.arr C' i then \\<phi> i else null)\n\ngoal (1 subgoal):\n 1. invertible_functor C' (\\<cdot>)\n     (\\<lambda>i. if partial_magma.arr C' i then \\<phi> i else null)", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>C'. isomorphic_categories C' (\\<cdot>)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>C'. isomorphic_categories C' (\\<cdot>)", "using \\<phi>.isomorphic_categories_axioms"], ["proof (prove)\nusing this:\n  isomorphic_categories C' (\\<cdot>)\n\ngoal (1 subgoal):\n 1. \\<exists>C'. isomorphic_categories C' (\\<cdot>)", "by blast"], ["proof (state)\nthis:\n  \\<exists>C'. isomorphic_categories C' (\\<cdot>)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text \\<open>\n    We now prove the result, advertised earlier in theory \\<open>ConcreteCategory\\<close>,\n    that any category is in fact isomorphic to the concrete category formed from it in\n    the obvious way.\n  \\<close>"], ["", "context category\n  begin"], ["", "interpretation CC: concrete_category \\<open>Collect ide\\<close> hom id \\<open>\\<lambda>C B A g f. g \\<cdot> f\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. concrete_category (Collect ide) hom id (\\<lambda>C B A. (\\<cdot>))", "using comp_arr_dom comp_cod_arr comp_assoc"], ["proof (prove)\nusing this:\n  \\<lbrakk>arr ?f; local.dom ?f = ?a\\<rbrakk>\n  \\<Longrightarrow> ?f \\<cdot> ?a = ?f\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. concrete_category (Collect ide) hom id (\\<lambda>C B A. (\\<cdot>))", "by (unfold_locales, auto)"], ["", "interpretation F: \"functor\" C CC.COMP\n                       \\<open>\\<lambda>f. if arr f then CC.MkArr (dom f) (cod f) f else CC.null\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. functor (\\<cdot>) CC.COMP\n     (\\<lambda>f.\n         if arr f then CC.MkArr (local.dom f) (cod f) f else CC.null)", "by (unfold_locales, auto simp add: in_homI)"], ["", "interpretation G: \"functor\" CC.COMP C \\<open>\\<lambda>F. if CC.arr F then CC.Map F else null\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. functor CC.COMP (\\<cdot>)\n     (\\<lambda>F. if CC.arr F then CC.Map F else null)", "using CC.Map_in_Hom CC.seq_char"], ["proof (prove)\nusing this:\n  CC.arr ?f \\<Longrightarrow> CC.Map ?f \\<in> hom (CC.Dom ?f) (CC.Cod ?f)\n  CC.seq ?g ?f = (CC.arr ?f \\<and> CC.arr ?g \\<and> CC.Dom ?g = CC.Cod ?f)\n\ngoal (1 subgoal):\n 1. functor CC.COMP (\\<cdot>)\n     (\\<lambda>F. if CC.arr F then CC.Map F else null)", "by (unfold_locales, auto)"], ["", "interpretation FG: inverse_functors C CC.COMP\n                       \\<open>\\<lambda>F. if CC.arr F then CC.Map F else null\\<close>\n                       \\<open>\\<lambda>f. if arr f then CC.MkArr (dom f) (cod f) f else CC.null\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_functors (\\<cdot>) CC.COMP\n     (\\<lambda>F. if CC.arr F then CC.Map F else null)\n     (\\<lambda>f.\n         if arr f then CC.MkArr (local.dom f) (cod f) f else CC.null)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<lambda>f.\n        if arr f then CC.MkArr (local.dom f) (cod f) f else CC.null) \\<circ>\n    (\\<lambda>F. if CC.arr F then CC.Map F else null) =\n    CC.map\n 2. (\\<lambda>F. if CC.arr F then CC.Map F else null) \\<circ>\n    (\\<lambda>f.\n        if arr f then CC.MkArr (local.dom f) (cod f) f else CC.null) =\n    local.map", "show \"(\\<lambda>F. if CC.arr F then CC.Map F else null) \\<circ>\n              (\\<lambda>f. if arr f then CC.MkArr (dom f) (cod f) f else CC.null) =\n            map\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>F. if CC.arr F then CC.Map F else null) \\<circ>\n    (\\<lambda>f.\n        if arr f then CC.MkArr (local.dom f) (cod f) f else CC.null) =\n    local.map", "using CC.arr_char map_def"], ["proof (prove)\nusing this:\n  CC.arr ?f =\n  (?f \\<noteq> CC.Null \\<and>\n   CC.Dom ?f \\<in> Collect ide \\<and>\n   CC.Cod ?f \\<in> Collect ide \\<and>\n   CC.Map ?f \\<in> hom (CC.Dom ?f) (CC.Cod ?f))\n  local.map ?f = (if arr ?f then ?f else null)\n\ngoal (1 subgoal):\n 1. (\\<lambda>F. if CC.arr F then CC.Map F else null) \\<circ>\n    (\\<lambda>f.\n        if arr f then CC.MkArr (local.dom f) (cod f) f else CC.null) =\n    local.map", "by fastforce"], ["proof (state)\nthis:\n  (\\<lambda>F. if CC.arr F then CC.Map F else null) \\<circ>\n  (\\<lambda>f.\n      if arr f then CC.MkArr (local.dom f) (cod f) f else CC.null) =\n  local.map\n\ngoal (1 subgoal):\n 1. (\\<lambda>f.\n        if arr f then CC.MkArr (local.dom f) (cod f) f else CC.null) \\<circ>\n    (\\<lambda>F. if CC.arr F then CC.Map F else null) =\n    CC.map", "show \"(\\<lambda>f. if arr f then CC.MkArr (dom f) (cod f) f else CC.null) \\<circ>\n              (\\<lambda>F. if CC.arr F then CC.Map F else null) =\n            CC.map\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>f.\n        if arr f then CC.MkArr (local.dom f) (cod f) f else CC.null) \\<circ>\n    (\\<lambda>F. if CC.arr F then CC.Map F else null) =\n    CC.map", "using CC.MkArr_Map G.preserves_arr G.preserves_cod G.preserves_dom\n              CC.is_extensional"], ["proof (prove)\nusing this:\n  CC.arr ?f \\<Longrightarrow>\n  CC.MkArr (CC.Dom ?f) (CC.Cod ?f) (CC.Map ?f) = ?f\n  CC.arr ?f \\<Longrightarrow> arr (if CC.arr ?f then CC.Map ?f else null)\n  CC.arr ?f \\<Longrightarrow>\n  cod (if CC.arr ?f then CC.Map ?f else null) =\n  (if CC.arr (CC.cod ?f) then CC.Map (CC.cod ?f) else null)\n  CC.arr ?f \\<Longrightarrow>\n  local.dom (if CC.arr ?f then CC.Map ?f else null) =\n  (if CC.arr (CC.dom ?f) then CC.Map (CC.dom ?f) else null)\n  \\<not> CC.arr ?f \\<Longrightarrow> CC.map ?f = CC.null\n\ngoal (1 subgoal):\n 1. (\\<lambda>f.\n        if arr f then CC.MkArr (local.dom f) (cod f) f else CC.null) \\<circ>\n    (\\<lambda>F. if CC.arr F then CC.Map F else null) =\n    CC.map", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>f.\n      if arr f then CC.MkArr (local.dom f) (cod f) f else CC.null) \\<circ>\n  (\\<lambda>F. if CC.arr F then CC.Map F else null) =\n  CC.map\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation isomorphic_categories C CC.COMP"], ["proof (prove)\ngoal (1 subgoal):\n 1. isomorphic_categories (\\<cdot>) CC.COMP", ".."], ["", "theorem is_isomorphic_to_concrete_category:\n    shows \"isomorphic_categories C CC.COMP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. isomorphic_categories (\\<cdot>) CC.COMP", ".."], ["", "end"], ["", "locale dual_functor =\n    F: \"functor\" A B F +\n    Aop: dual_category A +\n    Bop: dual_category B\n  for A :: \"'a comp\"      (infixr \"\\<cdot>\\<^sub>A\" 55)\n  and B :: \"'b comp\"      (infixr \"\\<cdot>\\<^sub>B\" 55)\n  and F :: \"'a \\<Rightarrow> 'b\"\n  begin"], ["", "notation Aop.comp     (infixr \"\\<cdot>\\<^sub>A\\<^sup>o\\<^sup>p\" 55)"], ["", "notation Bop.comp     (infixr \"\\<cdot>\\<^sub>B\\<^sup>o\\<^sup>p\" 55)"], ["", "definition map\n    where \"map \\<equiv> F\""], ["", "lemma map_simp [simp]:\n    shows \"map f = F f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.map f = F f", "by (simp add: map_def)"], ["", "lemma is_functor:\n    shows \"functor Aop.comp Bop.comp map\""], ["proof (prove)\ngoal (1 subgoal):\n 1. functor (\\<cdot>\\<^sub>A\\<^sup>o\\<^sup>p)\n     (\\<cdot>\\<^sub>B\\<^sup>o\\<^sup>p) local.map", "using F.is_extensional"], ["proof (prove)\nusing this:\n  \\<not> F.A.arr ?f \\<Longrightarrow> F ?f = F.B.null\n\ngoal (1 subgoal):\n 1. functor (\\<cdot>\\<^sub>A\\<^sup>o\\<^sup>p)\n     (\\<cdot>\\<^sub>B\\<^sup>o\\<^sup>p) local.map", "by (unfold_locales, auto)"], ["", "end"], ["", "sublocale invertible_functor \\<subseteq> inverse_functors A B inv G"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) local.inv G", "using inv_is_inverse"], ["proof (prove)\nusing this:\n  inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) local.inv G\n\ngoal (1 subgoal):\n 1. inverse_functors (\\<cdot>\\<^sub>A) (\\<cdot>\\<^sub>B) local.inv G", "by simp"], ["", "sublocale dual_functor \\<subseteq> \"functor\" Aop.comp Bop.comp map"], ["proof (prove)\ngoal (1 subgoal):\n 1. functor (\\<cdot>\\<^sub>A\\<^sup>o\\<^sup>p)\n     (\\<cdot>\\<^sub>B\\<^sup>o\\<^sup>p) local.map", "using is_functor"], ["proof (prove)\nusing this:\n  functor (\\<cdot>\\<^sub>A\\<^sup>o\\<^sup>p)\n   (\\<cdot>\\<^sub>B\\<^sup>o\\<^sup>p) local.map\n\ngoal (1 subgoal):\n 1. functor (\\<cdot>\\<^sub>A\\<^sup>o\\<^sup>p)\n     (\\<cdot>\\<^sub>B\\<^sup>o\\<^sup>p) local.map", "by auto"], ["", "end"]]}