{"file_name": "/home/qj213/afp-2021-10-22/thys/Category3/CartesianCategory.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Category3", "problem_names": ["lemma arr_char:\n    shows \"arr f \\<longleftrightarrow> f = FF \\<or> f = TT\"", "lemma ide_char:\n    shows \"ide f \\<longleftrightarrow> f = FF \\<or> f = TT\"", "lemma is_discrete:\n    shows \"ide f \\<longleftrightarrow> arr f\"", "lemma dom_simp [simp]:\n    assumes \"arr f\"\n    shows \"dom f = f\"", "lemma cod_simp [simp]:\n    assumes \"arr f\"\n    shows \"cod f = f\"", "lemma seq_char:\n    shows \"seq f g \\<longleftrightarrow> arr f \\<and> f = g\"", "lemma comp_simp [simp]:\n    assumes \"seq f g\"\n    shows \"comp f g = f\"", "lemma cone_mkCone:\n    assumes \"is_rendered_commutative_by p0 p1\"\n    shows \"cone (C.dom p0) (mkCone p0 p1)\"", "lemma is_rendered_commutative_by_cone:\n    assumes \"cone a \\<chi>\"\n    shows \"is_rendered_commutative_by (\\<chi> J.FF) (\\<chi> J.TT)\"", "lemma mkCone_cone:\n    assumes \"cone a \\<chi>\"\n    shows \"mkCone (\\<chi> J.FF) (\\<chi> J.TT) = \\<chi>\"", "lemma renders_commutative:\n    shows \"D.is_rendered_commutative_by p0 p1\"", "lemma is_universal':\n    assumes \"D.is_rendered_commutative_by p0' p1'\"\n    shows \"\\<exists>!h. \\<guillemotleft>h : C.dom p0' \\<rightarrow> C.dom p0\\<guillemotright> \\<and> p0 \\<cdot> h = p0' \\<and> p1 \\<cdot> h = p1'\"", "lemma induced_arrowI':\n    assumes \"D.is_rendered_commutative_by p0' p1'\"\n    shows \"\\<guillemotleft>induced_arrow (C.dom p0') (D.mkCone p0' p1') : C.dom p0' \\<rightarrow> C.dom p0\\<guillemotright>\"\n    and \"p0 \\<cdot> induced_arrow (C.dom p0') (D.mkCone p0' p1') = p0'\"\n    and \"p1 \\<cdot> induced_arrow (C.dom p1') (D.mkCone p0' p1') = p1'\"", "lemma pr0_in_hom':\n    assumes \"ide a\" and \"ide b\"\n    shows \"\\<guillemotleft>\\<pp>\\<^sub>0[a, b] : dom \\<pp>\\<^sub>0[a, b] \\<rightarrow> b\\<guillemotright>\"", "lemma pr1_in_hom':\n    assumes \"ide a\" and \"ide b\"\n    shows \"\\<guillemotleft>\\<pp>\\<^sub>1[a, b] : dom \\<pp>\\<^sub>0[a, b] \\<rightarrow> a\\<guillemotright>\"", "lemma seq_pr_tuple:\n    assumes \"span f g\"\n    shows \"seq \\<pp>\\<^sub>0[cod f, cod g] \\<langle>f, g\\<rangle>\"", "lemma tuple_pr_arr:\n    assumes \"ide a\" and \"ide b\" and \"seq \\<pp>\\<^sub>0[a, b] h\"\n    shows \"\\<langle>\\<pp>\\<^sub>1[a, b] \\<cdot> h, \\<pp>\\<^sub>0[a, b] \\<cdot> h\\<rangle> = h\"", "lemma pr_tuple [simp]:\n    assumes \"span f g\" and \"cod f = a\" and \"cod g = b\"\n    shows \"\\<pp>\\<^sub>1[a, b] \\<cdot> \\<langle>f, g\\<rangle> = f\" and \"\\<pp>\\<^sub>0[a, b] \\<cdot> \\<langle>f, g\\<rangle> = g\"", "lemma cod_tuple:\n    assumes \"span f g\"\n    shows \"cod \\<langle>f, g\\<rangle> = cod f \\<otimes> cod g\"", "lemma tuple_in_hom [intro]:\n    assumes \"\\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>\" and \"\\<guillemotleft>g : a \\<rightarrow> c\\<guillemotright>\"\n    shows \"\\<guillemotleft>\\<langle>f, g\\<rangle> : a \\<rightarrow> b \\<otimes> c\\<guillemotright>\"", "lemma tuple_in_hom' [simp]:\n    assumes \"arr f\" and \"dom f = a\" and \"cod f = b\"\n    and \"arr g\" and \"dom g = a\" and \"cod g = c\"\n    shows \"\\<guillemotleft>\\<langle>f, g\\<rangle> : a \\<rightarrow> b \\<otimes> c\\<guillemotright>\"", "lemma tuple_ext:\n    assumes \"\\<not> span f g\"\n    shows \"\\<langle>f, g\\<rangle> = null\"", "lemma tuple_simps [simp]:\n    assumes \"span f g\"\n    shows \"arr \\<langle>f, g\\<rangle>\" and \"dom \\<langle>f, g\\<rangle> = dom f\" and \"cod \\<langle>f, g\\<rangle> = cod f \\<otimes> cod g\"", "lemma tuple_pr [simp]:\n    assumes \"ide a\" and \"ide b\"\n    shows \"\\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle> = a \\<otimes> b\"", "lemma pr_in_hom [intro, simp]:\n    assumes \"ide a\" and \"ide b\"\n    shows \"\\<guillemotleft>\\<pp>\\<^sub>0[a, b] : a \\<otimes> b \\<rightarrow> b\\<guillemotright>\" and \"\\<guillemotleft>\\<pp>\\<^sub>1[a, b] : a \\<otimes> b \\<rightarrow> a\\<guillemotright>\"", "lemma pr_simps [simp]:\n    assumes \"ide a\" and \"ide b\"\n    shows \"arr \\<pp>\\<^sub>0[a, b]\" and \"dom \\<pp>\\<^sub>0[a, b] = a \\<otimes> b\" and \"cod \\<pp>\\<^sub>0[a, b] = b\"\n    and \"arr \\<pp>\\<^sub>1[a, b]\" and \"dom \\<pp>\\<^sub>1[a, b] = a \\<otimes> b\" and \"cod \\<pp>\\<^sub>1[a, b] = a\"", "lemma arr_pr0_iff [iff]:\n    shows \"arr \\<pp>\\<^sub>0[a, b] \\<longleftrightarrow> ide a \\<and> ide b\"", "lemma arr_pr1_iff [iff]:\n    shows \"arr \\<pp>\\<^sub>1[a, b] \\<longleftrightarrow> ide a \\<and> ide b\"", "lemma pr_joint_monic:\n    assumes \"seq \\<pp>\\<^sub>0[a, b] h\"\n    and \"\\<pp>\\<^sub>0[a, b] \\<cdot> h = \\<pp>\\<^sub>0[a, b] \\<cdot> h'\" and \"\\<pp>\\<^sub>1[a, b] \\<cdot> h = \\<pp>\\<^sub>1[a, b] \\<cdot> h'\"\n    shows \"h = h'\"", "lemma comp_tuple_arr [simp]:\n    assumes \"span f g\" and \"arr h\" and \"dom f = cod h\"\n    shows \"\\<langle>f, g\\<rangle> \\<cdot> h = \\<langle>f \\<cdot> h, g \\<cdot> h\\<rangle>\"", "lemma ide_prod [intro, simp]:\n    assumes \"ide a\" and \"ide b\"\n    shows \"ide (a \\<otimes> b)\"", "lemma prod_in_hom [intro]:\n    assumes \"\\<guillemotleft>f : a \\<rightarrow> c\\<guillemotright>\" and \"\\<guillemotleft>g : b \\<rightarrow> d\\<guillemotright>\"\n    shows \"\\<guillemotleft>f \\<otimes> g : a \\<otimes> b \\<rightarrow> c \\<otimes> d\\<guillemotright>\"", "lemma prod_in_hom' [simp]:\n    assumes \"arr f\" and \"dom f = a\" and \"cod f = c\"\n    and \"arr g\" and \"dom g = b\" and \"cod g = d\"\n    shows \"\\<guillemotleft>f \\<otimes> g : a \\<otimes> b \\<rightarrow> c \\<otimes> d\\<guillemotright>\"", "lemma prod_simps [simp]:\n    assumes \"arr f0\" and \"arr f1\"\n    shows \"arr (f0 \\<otimes> f1)\"\n    and \"dom (f0 \\<otimes> f1) = dom f0 \\<otimes> dom f1\"\n    and \"cod (f0 \\<otimes> f1) = cod f0 \\<otimes> cod f1\"", "lemma pr_yields_binary_product:\n    assumes \"ide a\" and \"ide b\"\n    shows \"has_as_binary_product a b (pr1 a b) (pr0 a b)\"", "lemma interchange:\n    assumes \"seq h f\" and \"seq k g\"\n    shows \"(h \\<otimes> k) \\<cdot> (f \\<otimes> g) = h \\<cdot> f \\<otimes> k \\<cdot> g\"", "lemma pr_naturality [simp]:\n    assumes \"arr g\" and \"dom g = b\" and \"cod g = d\"\n        and \"arr f\" and \"dom f = a\" and \"cod f = c\"\n    shows \"\\<pp>\\<^sub>0[c, d] \\<cdot> (f \\<otimes> g) = g \\<cdot> \\<pp>\\<^sub>0[a, b]\"\n    and \"\\<pp>\\<^sub>1[c, d] \\<cdot> (f \\<otimes> g) = f \\<cdot> \\<pp>\\<^sub>1[a, b]\"", "lemma dup_in_hom [intro, simp]:\n    assumes \"\\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>\"\n    shows \"\\<guillemotleft>\\<d>[f] : a \\<rightarrow> b \\<otimes> b\\<guillemotright>\"", "lemma dup_simps [simp]:\n    assumes \"arr f\"\n    shows \"arr \\<d>[f]\" and \"dom \\<d>[f] = dom f\" and \"cod \\<d>[f] = cod f \\<otimes> cod f\"", "lemma dup_naturality:\n    assumes \"\\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>\"\n    shows \"\\<d>[b] \\<cdot> f = (f \\<otimes> f) \\<cdot> \\<d>[a]\"", "lemma pr_dup [simp]:\n    assumes \"ide a\"\n    shows \"\\<pp>\\<^sub>0[a, a] \\<cdot> \\<d>[a] = a\" and \"\\<pp>\\<^sub>1[a, a] \\<cdot> \\<d>[a] = a\"", "lemma prod_tuple:\n    assumes \"span f g\" and \"seq h f\" and \"seq k g\"\n    shows \"(h \\<otimes> k) \\<cdot> \\<langle>f, g\\<rangle> = \\<langle>h \\<cdot> f, k \\<cdot> g\\<rangle>\"", "lemma tuple_eqI:\n    assumes \"seq \\<pp>\\<^sub>0[b, c] f\" and \"seq \\<pp>\\<^sub>1[b, c] f\"\n    and \"\\<pp>\\<^sub>0[b, c] \\<cdot> f = f0\" and \"\\<pp>\\<^sub>1[b, c] \\<cdot> f = f1\"\n    shows \"f = \\<langle>f1, f0\\<rangle>\"", "lemma assoc_in_hom [intro]:\n    assumes \"ide a\" and \"ide b\" and \"ide c\"\n    shows \"\\<guillemotleft>\\<a>[a, b, c] : (a \\<otimes> b) \\<otimes> c \\<rightarrow> a \\<otimes> (b \\<otimes> c)\\<guillemotright>\"", "lemma assoc_simps [simp]:\n    assumes \"ide a\" and \"ide b\" and \"ide c\"\n    shows \"arr \\<a>[a, b, c]\"\n    and \"dom \\<a>[a, b, c] = (a \\<otimes> b) \\<otimes> c\"\n    and \"cod \\<a>[a, b, c] = a \\<otimes> (b \\<otimes> c)\"", "lemma assoc'_in_hom [intro]:\n    assumes \"ide a\" and \"ide b\" and \"ide c\"\n    shows \"\\<guillemotleft>\\<a>\\<^sup>-\\<^sup>1[a, b, c] : a \\<otimes> (b \\<otimes> c) \\<rightarrow> (a \\<otimes> b) \\<otimes> c\\<guillemotright>\"", "lemma assoc'_simps [simp]:\n    assumes \"ide a\" and \"ide b\" and \"ide c\"\n    shows \"arr \\<a>\\<^sup>-\\<^sup>1[a, b, c]\"\n    and \"dom \\<a>\\<^sup>-\\<^sup>1[a, b, c] = a \\<otimes> (b \\<otimes> c)\"\n    and \"cod \\<a>\\<^sup>-\\<^sup>1[a, b, c] = (a \\<otimes> b) \\<otimes> c\"", "lemma assoc_naturality:\n    assumes \"\\<guillemotleft>f0 : a0 \\<rightarrow> b0\\<guillemotright>\" and \"\\<guillemotleft>f1 : a1 \\<rightarrow> b1\\<guillemotright>\" and \"\\<guillemotleft>f2 : a2 \\<rightarrow> b2\\<guillemotright>\"\n    shows \"\\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) = (f0 \\<otimes> (f1 \\<otimes> f2)) \\<cdot> \\<a>[a0, a1, a2]\"", "lemma pentagon:\n    assumes \"ide a\" and \"ide b\" and \"ide c\" and \"ide d\"\n    shows \"((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot> (\\<a>[a, b, c] \\<otimes> d) = \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]\"", "lemma inverse_arrows_assoc:\n    assumes \"ide a\" and \"ide b\" and \"ide c\"\n    shows \"inverse_arrows \\<a>[a, b, c] \\<a>\\<^sup>-\\<^sup>1[a, b, c]\"", "lemma binary_functor_Prod:\n    shows \"binary_functor C C C Prod\" and \"binary_functor C C C Prod'\"", "lemma sym_in_hom [intro]:\n    assumes \"ide a\" and \"ide b\"\n    shows \"\\<guillemotleft>\\<s>[a, b] : a \\<otimes> b \\<rightarrow> b \\<otimes> a\\<guillemotright>\"", "lemma sym_simps [simp]:\n    assumes \"ide a\" and \"ide b\"\n    shows \"arr \\<s>[a, b]\" and \"dom \\<s>[a, b] = a \\<otimes> b\" and \"cod \\<s>[a, b] = b \\<otimes> a\"", "lemma comp_sym_tuple [simp]:\n    assumes \"\\<guillemotleft>f0 : a \\<rightarrow> b0\\<guillemotright>\" and \"\\<guillemotleft>f1 : a \\<rightarrow> b1\\<guillemotright>\"\n    shows \"\\<s>[b0, b1] \\<cdot> \\<langle>f0, f1\\<rangle> = \\<langle>f1, f0\\<rangle>\"", "lemma prj_sym [simp]:\n    assumes \"ide a0\" and \"ide a1\"\n    shows \"\\<pp>\\<^sub>0[a1, a0] \\<cdot> \\<s>[a0, a1] = \\<pp>\\<^sub>1[a0, a1]\"\n    and \"\\<pp>\\<^sub>1[a1, a0] \\<cdot> \\<s>[a0, a1] = \\<pp>\\<^sub>0[a0, a1]\"", "lemma comp_sym_sym [simp]:\n    assumes \"ide a0\" and \"ide a1\"\n    shows \"\\<s>[a1, a0] \\<cdot> \\<s>[a0, a1] = (a0 \\<otimes> a1)\"", "lemma sym_inverse_arrows:\n    assumes \"ide a0\" and \"ide a1\"\n    shows \"inverse_arrows \\<s>[a0, a1] \\<s>[a1, a0]\"", "lemma sym_assoc_coherence:\n    assumes \"ide a\" and \"ide b\" and \"ide c\"\n    shows \"\\<a>[b, c, a] \\<cdot> \\<s>[a, b \\<otimes> c] \\<cdot> \\<a>[a, b, c] = (b \\<otimes> \\<s>[a, c]) \\<cdot> \\<a>[b, a, c] \\<cdot> (\\<s>[a, b] \\<otimes> c)\"", "lemma sym_naturality:\n    assumes \"\\<guillemotleft>f0 : a0 \\<rightarrow> b0\\<guillemotright>\" and \"\\<guillemotleft>f1 : a1 \\<rightarrow> b1\\<guillemotright>\"\n    shows \"\\<s>[b0, b1] \\<cdot> (f0 \\<otimes> f1) = (f1 \\<otimes> f0) \\<cdot> \\<s>[a0, a1]\"", "lemma \\<sigma>_is_natural_transformation:\n    shows \"natural_transformation CC.comp C Prod Prod' \\<sigma>\"", "lemma functor_Diag:\n    shows \"functor C CC.comp Diag\"", "lemma \\<pi>_is_natural_transformation:\n    shows \"natural_transformation CC.comp CC.comp \\<Delta>o\\<Pi>.map CC.map \\<pi>\"", "lemma dup_is_natural_transformation:\n    shows \"natural_transformation C C map \\<Pi>o\\<Delta>.map dup\"", "lemma trm_simps:\n    assumes \"ide a\"\n    shows \"arr \\<t>[a]\" and \"dom \\<t>[a] = a\" and \"cod \\<t>[a] = \\<one>\"", "lemma trm_one:\n    shows \"\\<t>[\\<one>] = \\<one>\"", "lemma terminal_one:\n    shows \"terminal \\<one>\"", "lemma trm_naturality:\n    assumes \"arr f\"\n    shows \"\\<t>[cod f] \\<cdot> f = \\<t>[dom f]\"", "lemma terminal_some_terminal [intro]:\n    shows \"terminal \\<one>\"", "lemma ide_some_terminal:\n    shows \"ide \\<one>\"", "lemma trm_in_hom [intro]:\n    assumes \"arr f\"\n    shows \"\\<guillemotleft>\\<t>[f] : dom f \\<rightarrow> \\<one>\\<guillemotright>\"", "lemma trm_simps [simp]:\n    assumes \"arr f\"\n    shows \"arr \\<t>[f]\" and \"dom \\<t>[f] = dom f\" and \"cod \\<t>[f] = \\<one>\"", "lemma trm_eqI:\n    assumes \"\\<guillemotleft>t : dom f \\<rightarrow> \\<one>\\<guillemotright>\"\n    shows \"t = \\<t>[f]\"", "lemma pr_coincidence:\n    shows \"\\<iota> = \\<pp>\\<^sub>1[\\<one>, \\<one>]\"", "lemma \\<iota>_is_terminal_arr:\n    shows \"terminal_arr \\<iota>\"", "lemma inverse_arrows_\\<iota>:\n    shows \"inverse_arrows \\<iota> \\<langle>\\<one>, \\<one>\\<rangle>\"", "lemma \\<iota>_is_iso:\n    shows \"iso \\<iota>\"", "lemma trm_tensor:\n    assumes \"ide a\" and \"ide b\"\n    shows \"\\<t>[a \\<otimes> b] = \\<iota> \\<cdot> (\\<t>[a] \\<otimes> \\<t>[b])\"", "lemma runit_in_hom:\n    assumes \"ide a\"\n    shows \"\\<guillemotleft>\\<r>[a] : a \\<otimes> \\<one> \\<rightarrow> a\\<guillemotright>\"", "lemma runit'_in_hom:\n    assumes \"ide a\"\n    shows \"\\<guillemotleft>\\<r>\\<^sup>-\\<^sup>1[a] : a \\<rightarrow> a \\<otimes> \\<one>\\<guillemotright>\"", "lemma lunit_in_hom:\n    assumes \"ide a\"\n    shows \"\\<guillemotleft>\\<l>[a] : \\<one> \\<otimes> a \\<rightarrow> a\\<guillemotright>\"", "lemma lunit'_in_hom:\n    assumes \"ide a\"\n    shows \"\\<guillemotleft>\\<l>\\<^sup>-\\<^sup>1[a] : a \\<rightarrow> \\<one> \\<otimes> a\\<guillemotright>\"", "lemma runit_naturality:\n    assumes \"ide a\"\n    shows \"\\<r>[cod a] \\<cdot> (a \\<otimes> \\<one>) = a \\<cdot> \\<r>[dom a]\"", "lemma inverse_arrows_runit:\n    assumes \"ide a\"\n    shows \"inverse_arrows \\<r>[a] \\<r>\\<^sup>-\\<^sup>1[a]\"", "lemma lunit_naturality:\n    assumes \"arr f\"\n    shows \"C \\<l>[cod f] (\\<one> \\<otimes> f) = C f \\<l>[dom f]\"", "lemma inverse_arrows_lunit:\n    assumes \"ide a\"\n    shows \"inverse_arrows \\<l>[a] \\<l>\\<^sup>-\\<^sup>1[a]\"", "lemma comp_lunit_term_dup:\n    assumes \"ide a\"\n    shows \"\\<l>[a] \\<cdot> (\\<t>[a] \\<otimes> a) \\<cdot> \\<d>[a] = a\"", "lemma comp_runit_term_dup:\n    assumes \"ide a\"\n    shows \"\\<r>[a] \\<cdot> (a \\<otimes> \\<t>[a]) \\<cdot> \\<d>[a] = a\"", "lemma comp_proj_assoc:\n    assumes \"ide a0\" and \"ide a1\" and \"ide a2\"\n    shows \"\\<pp>\\<^sub>1[a0, a1 \\<otimes> a2] \\<cdot> \\<a>[a0, a1, a2] = \\<pp>\\<^sub>1[a0, a1] \\<cdot> \\<pp>\\<^sub>1[a0 \\<otimes> a1, a2]\"\n    and \"\\<pp>\\<^sub>0[a0, a1 \\<otimes> a2] \\<cdot> \\<a>[a0, a1, a2] = \\<langle>\\<pp>\\<^sub>0[a0, a1] \\<cdot> \\<pp>\\<^sub>1[a0 \\<otimes> a1, a2], \\<pp>\\<^sub>0[a0 \\<otimes> a1, a2]\\<rangle>\"", "lemma dup_coassoc:\n    assumes \"ide a\"\n    shows \"\\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] = (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]\"", "lemma comp_assoc_tuple:\n    assumes \"\\<guillemotleft>f0 : a \\<rightarrow> b0\\<guillemotright>\" and \"\\<guillemotleft>f1 : a \\<rightarrow> b1\\<guillemotright>\" and \"\\<guillemotleft>f2 : a \\<rightarrow> b2\\<guillemotright>\"\n    shows \"\\<a>[b0, b1, b2] \\<cdot> \\<langle>\\<langle>f0, f1\\<rangle>, f2\\<rangle> = \\<langle>f0, \\<langle>f1, f2\\<rangle>\\<rangle>\"\n    and \"\\<a>\\<^sup>-\\<^sup>1[b0, b1, b2] \\<cdot> \\<langle>f0, \\<langle>f1, f2\\<rangle>\\<rangle> = \\<langle>\\<langle>f0, f1\\<rangle>, f2\\<rangle>\"", "lemma dup_tensor:\n    assumes \"ide a\" and \"ide b\"\n    shows \"\\<d>[a \\<otimes> b] = \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot> (a \\<otimes> \\<a>[b, a, b]) \\<cdot> (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n                        (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot> \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b])\"", "lemma \\<iota>_eq_trm:\n    shows \"\\<iota> = \\<t>[\\<one> \\<otimes> \\<one>]\"", "lemma terminal_tensor_one_one:\n    shows \"terminal (\\<one> \\<otimes> \\<one>)\"", "lemma has_finite_products':\n    assumes \"I \\<noteq> UNIV\"\n    shows \"finite I \\<Longrightarrow> has_products I\"", "lemma (in category) has_binary_products_if:\n  assumes \"has_products ({0, 1} :: nat set)\"\n  shows \"has_binary_products\"", "lemma binary_product_of_products_is_product:\n    assumes \"has_as_product J0 D0 a0\" and \"has_as_product J1 D1 a1\"\n    and \"has_as_binary_product a0 a1 p0 p1\"\n    and \"Collect (partial_magma.arr J0) \\<inter> Collect (partial_magma.arr J1) = {}\"\n    and \"partial_magma.null J0 = partial_magma.null J1\"\n    shows \"has_as_product\n             (discrete_category.comp\n                (Collect (partial_magma.arr J0) \\<union> Collect (partial_magma.arr J1))\n                (partial_magma.null J0))\n             (\\<lambda>i. if i \\<in> Collect (partial_magma.arr J0) then D0 i\n                  else if i \\<in> Collect (partial_magma.arr J1) then D1 i\n                  else null)\n             (dom p0)\""], "translations": [["", "lemma arr_char:\n    shows \"arr f \\<longleftrightarrow> f = FF \\<or> f = TT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr f = (f = MkIde False \\<or> f = MkIde True)", "using arr_char"], ["proof (prove)\nusing this:\n  arr ?f =\n  (?f \\<noteq> Null \\<and>\n   Dom ?f \\<in> UNIV \\<and>\n   Cod ?f \\<in> UNIV \\<and>\n   Map ?f \\<in> (if Dom ?f = Cod ?f then {()} else {}))\n\ngoal (1 subgoal):\n 1. arr f = (f = MkIde False \\<or> f = MkIde True)", "by (cases f, simp_all)"], ["", "lemma ide_char:\n    shows \"ide f \\<longleftrightarrow> f = FF \\<or> f = TT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide f = (f = MkIde False \\<or> f = MkIde True)", "using ide_char ide_MkIde"], ["proof (prove)\nusing this:\n  ide ?f =\n  (?f \\<noteq> Null \\<and>\n   Dom ?f \\<in> UNIV \\<and> Cod ?f = Dom ?f \\<and> Map ?f = ())\n  ?A \\<in> UNIV \\<Longrightarrow> ide (MkIde ?A)\n\ngoal (1 subgoal):\n 1. ide f = (f = MkIde False \\<or> f = MkIde True)", "by (cases f, auto)"], ["", "lemma is_discrete:\n    shows \"ide f \\<longleftrightarrow> arr f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide f = arr f", "using arr_char ide_char"], ["proof (prove)\nusing this:\n  arr ?f = (?f = MkIde False \\<or> ?f = MkIde True)\n  ide ?f = (?f = MkIde False \\<or> ?f = MkIde True)\n\ngoal (1 subgoal):\n 1. ide f = arr f", "by simp"], ["", "lemma dom_simp [simp]:\n    assumes \"arr f\"\n    shows \"dom f = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dom f = f", "using assms is_discrete"], ["proof (prove)\nusing this:\n  arr f\n  ide ?f = arr ?f\n\ngoal (1 subgoal):\n 1. local.dom f = f", "by simp"], ["", "lemma cod_simp [simp]:\n    assumes \"arr f\"\n    shows \"cod f = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cod f = f", "using assms is_discrete"], ["proof (prove)\nusing this:\n  arr f\n  ide ?f = arr ?f\n\ngoal (1 subgoal):\n 1. cod f = f", "by simp"], ["", "lemma seq_char:\n    shows \"seq f g \\<longleftrightarrow> arr f \\<and> f = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq f g = (arr f \\<and> f = g)", "by auto"], ["", "lemma comp_simp [simp]:\n    assumes \"seq f g\"\n    shows \"comp f g = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. COMP f g = f", "using assms seq_char"], ["proof (prove)\nusing this:\n  seq f g\n  seq ?f ?g = (arr ?f \\<and> ?f = ?g)\n\ngoal (1 subgoal):\n 1. COMP f g = f", "by fastforce"], ["", "end"], ["", "locale binary_product_diagram =\n    J: binary_product_shape +\n    C: category C\n  for C :: \"'c comp\"      (infixr \"\\<cdot>\" 55)\n  and a0 :: 'c\n  and a1 :: 'c +\n  assumes is_discrete: \"C.ide a0 \\<and> C.ide a1\"\n  begin"], ["", "notation J.comp      (infixr \"\\<cdot>\\<^sub>J\" 55)"], ["", "fun map\n    where \"map J.FF = a0\"\n        | \"map J.TT = a1\"\n        | \"map _ = C.null\""], ["", "sublocale diagram J.comp C map"], ["proof (prove)\ngoal (1 subgoal):\n 1. diagram J.COMP (\\<cdot>) local.map", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>f. \\<not> J.arr f \\<Longrightarrow> local.map f = C.null\n 2. \\<And>f. J.arr f \\<Longrightarrow> C.arr (local.map f)\n 3. \\<And>f.\n       J.arr f \\<Longrightarrow> C.dom (local.map f) = local.map (J.dom f)\n 4. \\<And>f.\n       J.arr f \\<Longrightarrow> C.cod (local.map f) = local.map (J.cod f)\n 5. \\<And>g f.\n       J.seq g f \\<Longrightarrow>\n       local.map (J.COMP g f) = local.map g \\<cdot> local.map f", "show \"\\<And>f. \\<not> J.arr f \\<Longrightarrow> map f = C.null\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f. \\<not> J.arr f \\<Longrightarrow> local.map f = C.null", "using J.arr_char map.elims"], ["proof (prove)\nusing this:\n  J.arr ?f = (?f = J.MkIde False \\<or> ?f = J.MkIde True)\n  \\<lbrakk>local.map ?x = ?y;\n   \\<lbrakk>?x = J.MkIde False; ?y = a0\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<lbrakk>?x = J.MkIde True; ?y = a1\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<lbrakk>?x = J.Null; ?y = C.null\\<rbrakk> \\<Longrightarrow> ?P;\n   \\<And>vb.\n      \\<lbrakk>?x = J.MkArr True False vb; ?y = C.null\\<rbrakk>\n      \\<Longrightarrow> ?P;\n   \\<And>vb.\n      \\<lbrakk>?x = J.MkArr False True vb; ?y = C.null\\<rbrakk>\n      \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n\ngoal (1 subgoal):\n 1. \\<And>f. \\<not> J.arr f \\<Longrightarrow> local.map f = C.null", "by auto"], ["proof (state)\nthis:\n  \\<not> J.arr ?f4 \\<Longrightarrow> local.map ?f4 = C.null\n\ngoal (4 subgoals):\n 1. \\<And>f. J.arr f \\<Longrightarrow> C.arr (local.map f)\n 2. \\<And>f.\n       J.arr f \\<Longrightarrow> C.dom (local.map f) = local.map (J.dom f)\n 3. \\<And>f.\n       J.arr f \\<Longrightarrow> C.cod (local.map f) = local.map (J.cod f)\n 4. \\<And>g f.\n       J.seq g f \\<Longrightarrow>\n       local.map (J.COMP g f) = local.map g \\<cdot> local.map f", "fix f"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>f. J.arr f \\<Longrightarrow> C.arr (local.map f)\n 2. \\<And>f.\n       J.arr f \\<Longrightarrow> C.dom (local.map f) = local.map (J.dom f)\n 3. \\<And>f.\n       J.arr f \\<Longrightarrow> C.cod (local.map f) = local.map (J.cod f)\n 4. \\<And>g f.\n       J.seq g f \\<Longrightarrow>\n       local.map (J.COMP g f) = local.map g \\<cdot> local.map f", "assume f: \"J.arr f\""], ["proof (state)\nthis:\n  J.arr f\n\ngoal (4 subgoals):\n 1. \\<And>f. J.arr f \\<Longrightarrow> C.arr (local.map f)\n 2. \\<And>f.\n       J.arr f \\<Longrightarrow> C.dom (local.map f) = local.map (J.dom f)\n 3. \\<And>f.\n       J.arr f \\<Longrightarrow> C.cod (local.map f) = local.map (J.cod f)\n 4. \\<And>g f.\n       J.seq g f \\<Longrightarrow>\n       local.map (J.COMP g f) = local.map g \\<cdot> local.map f", "show \"C.arr (map f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C.arr (local.map f)", "using f J.arr_char is_discrete C.ideD(1) map.simps(1-2)"], ["proof (prove)\nusing this:\n  J.arr f\n  J.arr ?f = (?f = J.MkIde False \\<or> ?f = J.MkIde True)\n  C.ide a0 \\<and> C.ide a1\n  C.ide ?a \\<Longrightarrow> C.arr ?a\n  local.map (J.MkIde False) = a0\n  local.map (J.MkIde True) = a1\n\ngoal (1 subgoal):\n 1. C.arr (local.map f)", "by metis"], ["proof (state)\nthis:\n  C.arr (local.map f)\n\ngoal (3 subgoals):\n 1. \\<And>f.\n       J.arr f \\<Longrightarrow> C.dom (local.map f) = local.map (J.dom f)\n 2. \\<And>f.\n       J.arr f \\<Longrightarrow> C.cod (local.map f) = local.map (J.cod f)\n 3. \\<And>g f.\n       J.seq g f \\<Longrightarrow>\n       local.map (J.COMP g f) = local.map g \\<cdot> local.map f", "show \"C.dom (map f) = map (J.dom f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C.dom (local.map f) = local.map (J.dom f)", "using f J.arr_char J.dom_char is_discrete"], ["proof (prove)\nusing this:\n  J.arr f\n  J.arr ?f = (?f = J.MkIde False \\<or> ?f = J.MkIde True)\n  J.dom ?f = (if J.arr ?f then J.MkIde (J.Dom ?f) else J.null)\n  C.ide a0 \\<and> C.ide a1\n\ngoal (1 subgoal):\n 1. C.dom (local.map f) = local.map (J.dom f)", "by force"], ["proof (state)\nthis:\n  C.dom (local.map f) = local.map (J.dom f)\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       J.arr f \\<Longrightarrow> C.cod (local.map f) = local.map (J.cod f)\n 2. \\<And>g f.\n       J.seq g f \\<Longrightarrow>\n       local.map (J.COMP g f) = local.map g \\<cdot> local.map f", "show \"C.cod (map f) = map (J.cod f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. C.cod (local.map f) = local.map (J.cod f)", "using f J.arr_char J.cod_char is_discrete"], ["proof (prove)\nusing this:\n  J.arr f\n  J.arr ?f = (?f = J.MkIde False \\<or> ?f = J.MkIde True)\n  J.cod ?f = (if J.arr ?f then J.MkIde (J.Cod ?f) else J.null)\n  C.ide a0 \\<and> C.ide a1\n\ngoal (1 subgoal):\n 1. C.cod (local.map f) = local.map (J.cod f)", "by force"], ["proof (state)\nthis:\n  C.cod (local.map f) = local.map (J.cod f)\n\ngoal (1 subgoal):\n 1. \\<And>g f.\n       J.seq g f \\<Longrightarrow>\n       local.map (J.COMP g f) = local.map g \\<cdot> local.map f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g f.\n       J.seq g f \\<Longrightarrow>\n       local.map (J.COMP g f) = local.map g \\<cdot> local.map f", "fix f g"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g f.\n       J.seq g f \\<Longrightarrow>\n       local.map (J.COMP g f) = local.map g \\<cdot> local.map f", "assume fg: \"J.seq g f\""], ["proof (state)\nthis:\n  J.seq g f\n\ngoal (1 subgoal):\n 1. \\<And>g f.\n       J.seq g f \\<Longrightarrow>\n       local.map (J.COMP g f) = local.map g \\<cdot> local.map f", "show \"map (g \\<cdot>\\<^sub>J f) = map g \\<cdot> map f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.map (J.COMP g f) = local.map g \\<cdot> local.map f", "using fg J.arr_char J.seq_char J.null_char J.not_arr_null is_discrete"], ["proof (prove)\nusing this:\n  J.seq g f\n  J.arr ?f = (?f = J.MkIde False \\<or> ?f = J.MkIde True)\n  J.seq ?f ?g = (J.arr ?f \\<and> ?f = ?g)\n  J.null = J.Null\n  \\<not> J.arr J.null\n  C.ide a0 \\<and> C.ide a1\n\ngoal (1 subgoal):\n 1. local.map (J.COMP g f) = local.map g \\<cdot> local.map f", "by (metis (no_types, lifting) C.comp_ide_self J.comp_simp map.simps(1-2))"], ["proof (state)\nthis:\n  local.map (J.COMP g f) = local.map g \\<cdot> local.map f\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "subsection \"Category with Binary Products\""], ["", "text \\<open>\n    A \\emph{binary product} in a category @{term C} is a limit of a binary product diagram\n    in @{term C}.\n  \\<close>"], ["", "context binary_product_diagram\n  begin"], ["", "definition mkCone\n    where \"mkCone p0 p1 \\<equiv> \\<lambda>j. if j = J.FF then p0 else if j = J.TT then p1 else C.null\""], ["", "abbreviation is_rendered_commutative_by\n    where \"is_rendered_commutative_by p0 p1 \\<equiv>\n           C.seq a0 p0 \\<and> C.seq a1 p1 \\<and> C.dom p0 = C.dom p1\""], ["", "abbreviation has_as_binary_product\n    where \"has_as_binary_product p0 p1 \\<equiv> limit_cone (C.dom p0) (mkCone p0 p1)\""], ["", "lemma cone_mkCone:\n    assumes \"is_rendered_commutative_by p0 p1\"\n    shows \"cone (C.dom p0) (mkCone p0 p1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.cone (C.dom p0) (mkCone p0 p1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.cone (C.dom p0) (mkCone p0 p1)", "interpret E: constant_functor J.comp C \\<open>C.dom p0\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. constant_functor J.COMP (\\<cdot>) (C.dom p0)", "using assms"], ["proof (prove)\nusing this:\n  is_rendered_commutative_by p0 p1\n\ngoal (1 subgoal):\n 1. constant_functor J.COMP (\\<cdot>) (C.dom p0)", "by unfold_locales auto"], ["proof (state)\ngoal (1 subgoal):\n 1. local.cone (C.dom p0) (mkCone p0 p1)", "show \"cone (C.dom p0) (mkCone p0 p1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.cone (C.dom p0) (mkCone p0 p1)", "using assms mkCone_def J.arr_char E.map_simp is_discrete C.comp_ide_arr C.comp_arr_dom"], ["proof (prove)\nusing this:\n  is_rendered_commutative_by p0 p1\n  mkCone ?p0.0 ?p1.0 \\<equiv>\n  \\<lambda>j.\n     if j = J.MkIde False then ?p0.0\n     else if j = J.MkIde True then ?p1.0 else C.null\n  J.arr ?f = (?f = J.MkIde False \\<or> ?f = J.MkIde True)\n  J.arr ?f \\<Longrightarrow> E.map ?f = C.dom p0\n  C.ide a0 \\<and> C.ide a1\n  \\<lbrakk>C.ide ?b; C.seq ?b ?f\\<rbrakk>\n  \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n  \\<lbrakk>C.arr ?f; C.dom ?f = ?a\\<rbrakk>\n  \\<Longrightarrow> ?f \\<cdot> ?a = ?f\n\ngoal (1 subgoal):\n 1. local.cone (C.dom p0) (mkCone p0 p1)", "by unfold_locales auto"], ["proof (state)\nthis:\n  local.cone (C.dom p0) (mkCone p0 p1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_rendered_commutative_by_cone:\n    assumes \"cone a \\<chi>\"\n    shows \"is_rendered_commutative_by (\\<chi> J.FF) (\\<chi> J.TT)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_rendered_commutative_by (\\<chi> (J.MkIde False))\n     (\\<chi> (J.MkIde True))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. is_rendered_commutative_by (\\<chi> (J.MkIde False))\n     (\\<chi> (J.MkIde True))", "interpret \\<chi>: cone J.comp C map a \\<chi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.cone a \\<chi>", "using assms"], ["proof (prove)\nusing this:\n  local.cone a \\<chi>\n\ngoal (1 subgoal):\n 1. local.cone a \\<chi>", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. is_rendered_commutative_by (\\<chi> (J.MkIde False))\n     (\\<chi> (J.MkIde True))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_rendered_commutative_by (\\<chi> (J.MkIde False))\n     (\\<chi> (J.MkIde True))", "using is_discrete"], ["proof (prove)\nusing this:\n  C.ide a0 \\<and> C.ide a1\n\ngoal (1 subgoal):\n 1. is_rendered_commutative_by (\\<chi> (J.MkIde False))\n     (\\<chi> (J.MkIde True))", "by simp"], ["proof (state)\nthis:\n  is_rendered_commutative_by (\\<chi> (J.MkIde False))\n   (\\<chi> (J.MkIde True))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mkCone_cone:\n    assumes \"cone a \\<chi>\"\n    shows \"mkCone (\\<chi> J.FF) (\\<chi> J.TT) = \\<chi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mkCone (\\<chi> (J.MkIde False)) (\\<chi> (J.MkIde True)) = \\<chi>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mkCone (\\<chi> (J.MkIde False)) (\\<chi> (J.MkIde True)) = \\<chi>", "interpret \\<chi>: cone J.comp C map a \\<chi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.cone a \\<chi>", "using assms"], ["proof (prove)\nusing this:\n  local.cone a \\<chi>\n\ngoal (1 subgoal):\n 1. local.cone a \\<chi>", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. mkCone (\\<chi> (J.MkIde False)) (\\<chi> (J.MkIde True)) = \\<chi>", "interpret mkCone_\\<chi>: cone J.comp C map \\<open>C.dom (\\<chi> J.FF)\\<close> \\<open>mkCone (\\<chi> J.FF) (\\<chi> J.TT)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. local.cone (C.dom (\\<chi> (J.MkIde False)))\n     (mkCone (\\<chi> (J.MkIde False)) (\\<chi> (J.MkIde True)))", "using assms is_rendered_commutative_by_cone cone_mkCone"], ["proof (prove)\nusing this:\n  local.cone a \\<chi>\n  local.cone ?a ?\\<chi> \\<Longrightarrow>\n  is_rendered_commutative_by (?\\<chi> (J.MkIde False))\n   (?\\<chi> (J.MkIde True))\n  is_rendered_commutative_by ?p0.0 ?p1.0 \\<Longrightarrow>\n  local.cone (C.dom ?p0.0) (mkCone ?p0.0 ?p1.0)\n\ngoal (1 subgoal):\n 1. local.cone (C.dom (\\<chi> (J.MkIde False)))\n     (mkCone (\\<chi> (J.MkIde False)) (\\<chi> (J.MkIde True)))", "by blast"], ["proof (state)\ngoal (1 subgoal):\n 1. mkCone (\\<chi> (J.MkIde False)) (\\<chi> (J.MkIde True)) = \\<chi>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. mkCone (\\<chi> (J.MkIde False)) (\\<chi> (J.MkIde True)) = \\<chi>", "using mkCone_def \\<chi>.is_extensional J.ide_char mkCone_def\n              NaturalTransformation.eqI [of J.comp C]\n              \\<chi>.natural_transformation_axioms mkCone_\\<chi>.natural_transformation_axioms"], ["proof (prove)\nusing this:\n  mkCone ?p0.0 ?p1.0 \\<equiv>\n  \\<lambda>j.\n     if j = J.MkIde False then ?p0.0\n     else if j = J.MkIde True then ?p1.0 else C.null\n  \\<not> J.arr ?f \\<Longrightarrow> \\<chi> ?f = C.null\n  J.ide ?f = (?f = J.MkIde False \\<or> ?f = J.MkIde True)\n  mkCone ?p0.0 ?p1.0 \\<equiv>\n  \\<lambda>j.\n     if j = J.MkIde False then ?p0.0\n     else if j = J.MkIde True then ?p1.0 else C.null\n  \\<lbrakk>natural_transformation J.COMP (\\<cdot>) ?F ?G ?\\<sigma>;\n   natural_transformation J.COMP (\\<cdot>) ?F ?G ?\\<sigma>';\n   \\<And>a. J.ide a \\<Longrightarrow> ?\\<sigma> a = ?\\<sigma>' a\\<rbrakk>\n  \\<Longrightarrow> ?\\<sigma> = ?\\<sigma>'\n  natural_transformation J.COMP (\\<cdot>) \\<chi>.A.map local.map \\<chi>\n  natural_transformation J.COMP (\\<cdot>) mkCone_\\<chi>.A.map local.map\n   (mkCone (\\<chi> (J.MkIde False)) (\\<chi> (J.MkIde True)))\n\ngoal (1 subgoal):\n 1. mkCone (\\<chi> (J.MkIde False)) (\\<chi> (J.MkIde True)) = \\<chi>", "by fastforce"], ["proof (state)\nthis:\n  mkCone (\\<chi> (J.MkIde False)) (\\<chi> (J.MkIde True)) = \\<chi>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "locale binary_product_cone =\n    J: binary_product_shape +\n    C: category C +\n    D: binary_product_diagram C f0 f1 +\n    limit_cone J.comp C D.map \\<open>C.dom p0\\<close> \\<open>D.mkCone p0 p1\\<close>\n  for C :: \"'c comp\"      (infixr \"\\<cdot>\" 55)\n  and f0 :: 'c\n  and f1 :: 'c\n  and p0 :: 'c\n  and p1 :: 'c\n  begin"], ["", "lemma renders_commutative:\n    shows \"D.is_rendered_commutative_by p0 p1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D.is_rendered_commutative_by p0 p1", "using cone_axioms D.is_rendered_commutative_by_cone D.mkCone_def \\<Phi>.Ya.Cop_S.arr.simps(1)"], ["proof (prove)\nusing this:\n  D.cone (C.dom p0) (D.mkCone p0 p1)\n  D.cone ?a ?\\<chi> \\<Longrightarrow>\n  D.is_rendered_commutative_by (?\\<chi> (J.MkIde False))\n   (?\\<chi> (J.MkIde True))\n  D.mkCone ?p0.0 ?p1.0 \\<equiv>\n  \\<lambda>j.\n     if j = J.MkIde False then ?p0.0\n     else if j = J.MkIde True then ?p1.0 else C.null\n  (\\<Phi>.Ya.Cop_S.MkArr ?x21.0 ?x22.0 ?x23.0 =\n   \\<Phi>.Ya.Cop_S.MkArr ?y21a ?y22a ?y23a) =\n  (?x21.0 = ?y21a \\<and> ?x22.0 = ?y22a \\<and> ?x23.0 = ?y23a)\n\ngoal (1 subgoal):\n 1. D.is_rendered_commutative_by p0 p1", "by (metis (no_types, lifting))"], ["", "(* TODO: pretty opaque *)"], ["", "lemma is_universal':\n    assumes \"D.is_rendered_commutative_by p0' p1'\"\n    shows \"\\<exists>!h. \\<guillemotleft>h : C.dom p0' \\<rightarrow> C.dom p0\\<guillemotright> \\<and> p0 \\<cdot> h = p0' \\<and> p1 \\<cdot> h = p1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!h.\n       \\<guillemotleft>h : C.dom\n                            p0' \\<rightarrow> C.dom\n         p0\\<guillemotright> \\<and>\n       p0 \\<cdot> h = p0' \\<and> p1 \\<cdot> h = p1'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!h.\n       \\<guillemotleft>h : C.dom\n                            p0' \\<rightarrow> C.dom\n         p0\\<guillemotright> \\<and>\n       p0 \\<cdot> h = p0' \\<and> p1 \\<cdot> h = p1'", "have \"D.cone (C.dom p0') (D.mkCone p0' p1')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D.cone (C.dom p0') (D.mkCone p0' p1')", "using assms D.cone_mkCone"], ["proof (prove)\nusing this:\n  D.is_rendered_commutative_by p0' p1'\n  D.is_rendered_commutative_by ?p0.0 ?p1.0 \\<Longrightarrow>\n  D.cone (C.dom ?p0.0) (D.mkCone ?p0.0 ?p1.0)\n\ngoal (1 subgoal):\n 1. D.cone (C.dom p0') (D.mkCone p0' p1')", "by blast"], ["proof (state)\nthis:\n  D.cone (C.dom p0') (D.mkCone p0' p1')\n\ngoal (1 subgoal):\n 1. \\<exists>!h.\n       \\<guillemotleft>h : C.dom\n                            p0' \\<rightarrow> C.dom\n         p0\\<guillemotright> \\<and>\n       p0 \\<cdot> h = p0' \\<and> p1 \\<cdot> h = p1'", "hence \"\\<exists>!h. \\<guillemotleft>h : C.dom p0' \\<rightarrow> C.dom p0\\<guillemotright> \\<and>\n                  D.cones_map h (D.mkCone p0 p1) = D.mkCone p0' p1'\""], ["proof (prove)\nusing this:\n  D.cone (C.dom p0') (D.mkCone p0' p1')\n\ngoal (1 subgoal):\n 1. \\<exists>!h.\n       \\<guillemotleft>h : C.dom\n                            p0' \\<rightarrow> C.dom\n         p0\\<guillemotright> \\<and>\n       D.cones_map h (D.mkCone p0 p1) = D.mkCone p0' p1'", "using is_universal"], ["proof (prove)\nusing this:\n  D.cone (C.dom p0') (D.mkCone p0' p1')\n  D.cone ?a' ?\\<chi>' \\<Longrightarrow>\n  \\<exists>!f.\n     \\<guillemotleft>f : ?a' \\<rightarrow> C.dom p0\\<guillemotright> \\<and>\n     D.cones_map f (D.mkCone p0 p1) = ?\\<chi>'\n\ngoal (1 subgoal):\n 1. \\<exists>!h.\n       \\<guillemotleft>h : C.dom\n                            p0' \\<rightarrow> C.dom\n         p0\\<guillemotright> \\<and>\n       D.cones_map h (D.mkCone p0 p1) = D.mkCone p0' p1'", "by simp"], ["proof (state)\nthis:\n  \\<exists>!h.\n     \\<guillemotleft>h : C.dom\n                          p0' \\<rightarrow> C.dom p0\\<guillemotright> \\<and>\n     D.cones_map h (D.mkCone p0 p1) = D.mkCone p0' p1'\n\ngoal (1 subgoal):\n 1. \\<exists>!h.\n       \\<guillemotleft>h : C.dom\n                            p0' \\<rightarrow> C.dom\n         p0\\<guillemotright> \\<and>\n       p0 \\<cdot> h = p0' \\<and> p1 \\<cdot> h = p1'", "moreover"], ["proof (state)\nthis:\n  \\<exists>!h.\n     \\<guillemotleft>h : C.dom\n                          p0' \\<rightarrow> C.dom p0\\<guillemotright> \\<and>\n     D.cones_map h (D.mkCone p0 p1) = D.mkCone p0' p1'\n\ngoal (1 subgoal):\n 1. \\<exists>!h.\n       \\<guillemotleft>h : C.dom\n                            p0' \\<rightarrow> C.dom\n         p0\\<guillemotright> \\<and>\n       p0 \\<cdot> h = p0' \\<and> p1 \\<cdot> h = p1'", "have \"\\<And>h. \\<guillemotleft>h : C.dom p0' \\<rightarrow> C.dom p0\\<guillemotright> \\<Longrightarrow>\n                           D.cones_map h (D.mkCone p0 p1) = D.mkCone p0' p1' \\<longleftrightarrow>\n                           p0 \\<cdot> h = p0' \\<and> p1 \\<cdot> h = p1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       \\<guillemotleft>h : C.dom\n                            p0' \\<rightarrow> C.dom\n         p0\\<guillemotright> \\<Longrightarrow>\n       (D.cones_map h (D.mkCone p0 p1) = D.mkCone p0' p1') =\n       (p0 \\<cdot> h = p0' \\<and> p1 \\<cdot> h = p1')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h.\n       \\<guillemotleft>h : C.dom\n                            p0' \\<rightarrow> C.dom\n         p0\\<guillemotright> \\<Longrightarrow>\n       (D.cones_map h (D.mkCone p0 p1) = D.mkCone p0' p1') =\n       (p0 \\<cdot> h = p0' \\<and> p1 \\<cdot> h = p1')", "fix h"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h.\n       \\<guillemotleft>h : C.dom\n                            p0' \\<rightarrow> C.dom\n         p0\\<guillemotright> \\<Longrightarrow>\n       (D.cones_map h (D.mkCone p0 p1) = D.mkCone p0' p1') =\n       (p0 \\<cdot> h = p0' \\<and> p1 \\<cdot> h = p1')", "assume h: \"\\<guillemotleft>h : C.dom p0' \\<rightarrow> C.dom p0\\<guillemotright>\""], ["proof (state)\nthis:\n  \\<guillemotleft>h : C.dom p0' \\<rightarrow> C.dom p0\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>h.\n       \\<guillemotleft>h : C.dom\n                            p0' \\<rightarrow> C.dom\n         p0\\<guillemotright> \\<Longrightarrow>\n       (D.cones_map h (D.mkCone p0 p1) = D.mkCone p0' p1') =\n       (p0 \\<cdot> h = p0' \\<and> p1 \\<cdot> h = p1')", "show \"D.cones_map h (D.mkCone p0 p1) = D.mkCone p0' p1' \\<longleftrightarrow>\n              p0 \\<cdot> h = p0' \\<and> p1 \\<cdot> h = p1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (D.cones_map h (D.mkCone p0 p1) = D.mkCone p0' p1') =\n    (p0 \\<cdot> h = p0' \\<and> p1 \\<cdot> h = p1')", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. D.cones_map h (D.mkCone p0 p1) = D.mkCone p0' p1' \\<Longrightarrow>\n    p0 \\<cdot> h = p0' \\<and> p1 \\<cdot> h = p1'\n 2. p0 \\<cdot> h = p0' \\<and> p1 \\<cdot> h = p1' \\<Longrightarrow>\n    D.cones_map h (D.mkCone p0 p1) = D.mkCone p0' p1'", "assume 1: \"D.cones_map h (D.mkCone p0 p1) = D.mkCone p0' p1'\""], ["proof (state)\nthis:\n  D.cones_map h (D.mkCone p0 p1) = D.mkCone p0' p1'\n\ngoal (2 subgoals):\n 1. D.cones_map h (D.mkCone p0 p1) = D.mkCone p0' p1' \\<Longrightarrow>\n    p0 \\<cdot> h = p0' \\<and> p1 \\<cdot> h = p1'\n 2. p0 \\<cdot> h = p0' \\<and> p1 \\<cdot> h = p1' \\<Longrightarrow>\n    D.cones_map h (D.mkCone p0 p1) = D.mkCone p0' p1'", "show \"p0 \\<cdot> h = p0' \\<and> p1 \\<cdot> h = p1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p0 \\<cdot> h = p0' \\<and> p1 \\<cdot> h = p1'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. p0 \\<cdot> h = p0'\n 2. p1 \\<cdot> h = p1'", "show \"p0 \\<cdot> h = p0'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p0 \\<cdot> h = p0'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p0 \\<cdot> h = p0'", "have \"p0' = D.mkCone p0' p1' J.FF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p0' = D.mkCone p0' p1' (J.MkIde False)", "using D.mkCone_def J.arr_char"], ["proof (prove)\nusing this:\n  D.mkCone ?p0.0 ?p1.0 \\<equiv>\n  \\<lambda>j.\n     if j = J.MkIde False then ?p0.0\n     else if j = J.MkIde True then ?p1.0 else C.null\n  J.arr ?f = (?f = J.MkIde False \\<or> ?f = J.MkIde True)\n\ngoal (1 subgoal):\n 1. p0' = D.mkCone p0' p1' (J.MkIde False)", "by simp"], ["proof (state)\nthis:\n  p0' = D.mkCone p0' p1' (J.MkIde False)\n\ngoal (1 subgoal):\n 1. p0 \\<cdot> h = p0'", "also"], ["proof (state)\nthis:\n  p0' = D.mkCone p0' p1' (J.MkIde False)\n\ngoal (1 subgoal):\n 1. p0 \\<cdot> h = p0'", "have \"... = D.cones_map h (D.mkCone p0 p1) J.FF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D.mkCone p0' p1' (J.MkIde False) =\n    D.cones_map h (D.mkCone p0 p1) (J.MkIde False)", "using 1"], ["proof (prove)\nusing this:\n  D.cones_map h (D.mkCone p0 p1) = D.mkCone p0' p1'\n\ngoal (1 subgoal):\n 1. D.mkCone p0' p1' (J.MkIde False) =\n    D.cones_map h (D.mkCone p0 p1) (J.MkIde False)", "by simp"], ["proof (state)\nthis:\n  D.mkCone p0' p1' (J.MkIde False) =\n  D.cones_map h (D.mkCone p0 p1) (J.MkIde False)\n\ngoal (1 subgoal):\n 1. p0 \\<cdot> h = p0'", "also"], ["proof (state)\nthis:\n  D.mkCone p0' p1' (J.MkIde False) =\n  D.cones_map h (D.mkCone p0 p1) (J.MkIde False)\n\ngoal (1 subgoal):\n 1. p0 \\<cdot> h = p0'", "have \"... = p0 \\<cdot> h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D.cones_map h (D.mkCone p0 p1) (J.MkIde False) = p0 \\<cdot> h", "using h D.mkCone_def J.arr_char cone_\\<chi>"], ["proof (prove)\nusing this:\n  \\<guillemotleft>h : C.dom p0' \\<rightarrow> C.dom p0\\<guillemotright>\n  D.mkCone ?p0.0 ?p1.0 \\<equiv>\n  \\<lambda>j.\n     if j = J.MkIde False then ?p0.0\n     else if j = J.MkIde True then ?p1.0 else C.null\n  J.arr ?f = (?f = J.MkIde False \\<or> ?f = J.MkIde True)\n  D.mkCone p0 p1 \\<in> D.cones (C.dom p0)\n\ngoal (1 subgoal):\n 1. D.cones_map h (D.mkCone p0 p1) (J.MkIde False) = p0 \\<cdot> h", "by auto"], ["proof (state)\nthis:\n  D.cones_map h (D.mkCone p0 p1) (J.MkIde False) = p0 \\<cdot> h\n\ngoal (1 subgoal):\n 1. p0 \\<cdot> h = p0'", "finally"], ["proof (chain)\npicking this:\n  p0' = p0 \\<cdot> h", "show ?thesis"], ["proof (prove)\nusing this:\n  p0' = p0 \\<cdot> h\n\ngoal (1 subgoal):\n 1. p0 \\<cdot> h = p0'", "by auto"], ["proof (state)\nthis:\n  p0 \\<cdot> h = p0'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p0 \\<cdot> h = p0'\n\ngoal (1 subgoal):\n 1. p1 \\<cdot> h = p1'", "show \"p1 \\<cdot> h = p1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p1 \\<cdot> h = p1'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p1 \\<cdot> h = p1'", "have \"p1' = D.mkCone p0' p1' J.TT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p1' = D.mkCone p0' p1' (J.MkIde True)", "using D.mkCone_def J.arr_char"], ["proof (prove)\nusing this:\n  D.mkCone ?p0.0 ?p1.0 \\<equiv>\n  \\<lambda>j.\n     if j = J.MkIde False then ?p0.0\n     else if j = J.MkIde True then ?p1.0 else C.null\n  J.arr ?f = (?f = J.MkIde False \\<or> ?f = J.MkIde True)\n\ngoal (1 subgoal):\n 1. p1' = D.mkCone p0' p1' (J.MkIde True)", "by simp"], ["proof (state)\nthis:\n  p1' = D.mkCone p0' p1' (J.MkIde True)\n\ngoal (1 subgoal):\n 1. p1 \\<cdot> h = p1'", "also"], ["proof (state)\nthis:\n  p1' = D.mkCone p0' p1' (J.MkIde True)\n\ngoal (1 subgoal):\n 1. p1 \\<cdot> h = p1'", "have \"... = D.cones_map h (D.mkCone p0 p1) J.TT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D.mkCone p0' p1' (J.MkIde True) =\n    D.cones_map h (D.mkCone p0 p1) (J.MkIde True)", "using 1"], ["proof (prove)\nusing this:\n  D.cones_map h (D.mkCone p0 p1) = D.mkCone p0' p1'\n\ngoal (1 subgoal):\n 1. D.mkCone p0' p1' (J.MkIde True) =\n    D.cones_map h (D.mkCone p0 p1) (J.MkIde True)", "by simp"], ["proof (state)\nthis:\n  D.mkCone p0' p1' (J.MkIde True) =\n  D.cones_map h (D.mkCone p0 p1) (J.MkIde True)\n\ngoal (1 subgoal):\n 1. p1 \\<cdot> h = p1'", "also"], ["proof (state)\nthis:\n  D.mkCone p0' p1' (J.MkIde True) =\n  D.cones_map h (D.mkCone p0 p1) (J.MkIde True)\n\ngoal (1 subgoal):\n 1. p1 \\<cdot> h = p1'", "have \"... = p1 \\<cdot> h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D.cones_map h (D.mkCone p0 p1) (J.MkIde True) = p1 \\<cdot> h", "using h D.mkCone_def J.arr_char cone_\\<chi>"], ["proof (prove)\nusing this:\n  \\<guillemotleft>h : C.dom p0' \\<rightarrow> C.dom p0\\<guillemotright>\n  D.mkCone ?p0.0 ?p1.0 \\<equiv>\n  \\<lambda>j.\n     if j = J.MkIde False then ?p0.0\n     else if j = J.MkIde True then ?p1.0 else C.null\n  J.arr ?f = (?f = J.MkIde False \\<or> ?f = J.MkIde True)\n  D.mkCone p0 p1 \\<in> D.cones (C.dom p0)\n\ngoal (1 subgoal):\n 1. D.cones_map h (D.mkCone p0 p1) (J.MkIde True) = p1 \\<cdot> h", "by auto"], ["proof (state)\nthis:\n  D.cones_map h (D.mkCone p0 p1) (J.MkIde True) = p1 \\<cdot> h\n\ngoal (1 subgoal):\n 1. p1 \\<cdot> h = p1'", "finally"], ["proof (chain)\npicking this:\n  p1' = p1 \\<cdot> h", "show ?thesis"], ["proof (prove)\nusing this:\n  p1' = p1 \\<cdot> h\n\ngoal (1 subgoal):\n 1. p1 \\<cdot> h = p1'", "by auto"], ["proof (state)\nthis:\n  p1 \\<cdot> h = p1'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p1 \\<cdot> h = p1'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p0 \\<cdot> h = p0' \\<and> p1 \\<cdot> h = p1'\n\ngoal (1 subgoal):\n 1. p0 \\<cdot> h = p0' \\<and> p1 \\<cdot> h = p1' \\<Longrightarrow>\n    D.cones_map h (D.mkCone p0 p1) = D.mkCone p0' p1'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. p0 \\<cdot> h = p0' \\<and> p1 \\<cdot> h = p1' \\<Longrightarrow>\n    D.cones_map h (D.mkCone p0 p1) = D.mkCone p0' p1'", "assume 1: \"p0 \\<cdot> h = p0' \\<and> p1 \\<cdot> h = p1'\""], ["proof (state)\nthis:\n  p0 \\<cdot> h = p0' \\<and> p1 \\<cdot> h = p1'\n\ngoal (1 subgoal):\n 1. p0 \\<cdot> h = p0' \\<and> p1 \\<cdot> h = p1' \\<Longrightarrow>\n    D.cones_map h (D.mkCone p0 p1) = D.mkCone p0' p1'", "show \"D.cones_map h (D.mkCone p0 p1) = D.mkCone p0' p1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D.cones_map h (D.mkCone p0 p1) = D.mkCone p0' p1'", "using h 1 cone_\\<chi> D.mkCone_def"], ["proof (prove)\nusing this:\n  \\<guillemotleft>h : C.dom p0' \\<rightarrow> C.dom p0\\<guillemotright>\n  p0 \\<cdot> h = p0' \\<and> p1 \\<cdot> h = p1'\n  D.mkCone p0 p1 \\<in> D.cones (C.dom p0)\n  D.mkCone ?p0.0 ?p1.0 \\<equiv>\n  \\<lambda>j.\n     if j = J.MkIde False then ?p0.0\n     else if j = J.MkIde True then ?p1.0 else C.null\n\ngoal (1 subgoal):\n 1. D.cones_map h (D.mkCone p0 p1) = D.mkCone p0' p1'", "by auto"], ["proof (state)\nthis:\n  D.cones_map h (D.mkCone p0 p1) = D.mkCone p0' p1'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (D.cones_map h (D.mkCone p0 p1) = D.mkCone p0' p1') =\n  (p0 \\<cdot> h = p0' \\<and> p1 \\<cdot> h = p1')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<guillemotleft>?h4 : C.dom\n                         p0' \\<rightarrow> C.dom\n      p0\\<guillemotright> \\<Longrightarrow>\n  (D.cones_map ?h4 (D.mkCone p0 p1) = D.mkCone p0' p1') =\n  (p0 \\<cdot> ?h4 = p0' \\<and> p1 \\<cdot> ?h4 = p1')\n\ngoal (1 subgoal):\n 1. \\<exists>!h.\n       \\<guillemotleft>h : C.dom\n                            p0' \\<rightarrow> C.dom\n         p0\\<guillemotright> \\<and>\n       p0 \\<cdot> h = p0' \\<and> p1 \\<cdot> h = p1'", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>!h.\n     \\<guillemotleft>h : C.dom\n                          p0' \\<rightarrow> C.dom p0\\<guillemotright> \\<and>\n     D.cones_map h (D.mkCone p0 p1) = D.mkCone p0' p1'\n  \\<guillemotleft>?h4 : C.dom\n                         p0' \\<rightarrow> C.dom\n      p0\\<guillemotright> \\<Longrightarrow>\n  (D.cones_map ?h4 (D.mkCone p0 p1) = D.mkCone p0' p1') =\n  (p0 \\<cdot> ?h4 = p0' \\<and> p1 \\<cdot> ?h4 = p1')", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>!h.\n     \\<guillemotleft>h : C.dom\n                          p0' \\<rightarrow> C.dom p0\\<guillemotright> \\<and>\n     D.cones_map h (D.mkCone p0 p1) = D.mkCone p0' p1'\n  \\<guillemotleft>?h4 : C.dom\n                         p0' \\<rightarrow> C.dom\n      p0\\<guillemotright> \\<Longrightarrow>\n  (D.cones_map ?h4 (D.mkCone p0 p1) = D.mkCone p0' p1') =\n  (p0 \\<cdot> ?h4 = p0' \\<and> p1 \\<cdot> ?h4 = p1')\n\ngoal (1 subgoal):\n 1. \\<exists>!h.\n       \\<guillemotleft>h : C.dom\n                            p0' \\<rightarrow> C.dom\n         p0\\<guillemotright> \\<and>\n       p0 \\<cdot> h = p0' \\<and> p1 \\<cdot> h = p1'", "by blast"], ["proof (state)\nthis:\n  \\<exists>!h.\n     \\<guillemotleft>h : C.dom\n                          p0' \\<rightarrow> C.dom p0\\<guillemotright> \\<and>\n     p0 \\<cdot> h = p0' \\<and> p1 \\<cdot> h = p1'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma induced_arrowI':\n    assumes \"D.is_rendered_commutative_by p0' p1'\"\n    shows \"\\<guillemotleft>induced_arrow (C.dom p0') (D.mkCone p0' p1') : C.dom p0' \\<rightarrow> C.dom p0\\<guillemotright>\"\n    and \"p0 \\<cdot> induced_arrow (C.dom p0') (D.mkCone p0' p1') = p0'\"\n    and \"p1 \\<cdot> induced_arrow (C.dom p1') (D.mkCone p0' p1') = p1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>induced_arrow (C.dom p0')\n                     (D.mkCone p0'\n                       p1') : C.dom\n                               p0' \\<rightarrow> C.dom\n            p0\\<guillemotright> &&&\n    p0 \\<cdot> induced_arrow (C.dom p0') (D.mkCone p0' p1') = p0' &&&\n    p1 \\<cdot> induced_arrow (C.dom p1') (D.mkCone p0' p1') = p1'", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<guillemotleft>induced_arrow (C.dom p0')\n                     (D.mkCone p0'\n                       p1') : C.dom\n                               p0' \\<rightarrow> C.dom p0\\<guillemotright>\n 2. p0 \\<cdot> induced_arrow (C.dom p0') (D.mkCone p0' p1') = p0'\n 3. p1 \\<cdot> induced_arrow (C.dom p1') (D.mkCone p0' p1') = p1'", "interpret A': constant_functor J.comp C \\<open>C.dom p0'\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. constant_functor J.COMP (\\<cdot>) (C.dom p0')", "using assms"], ["proof (prove)\nusing this:\n  D.is_rendered_commutative_by p0' p1'\n\ngoal (1 subgoal):\n 1. constant_functor J.COMP (\\<cdot>) (C.dom p0')", "by (unfold_locales, auto)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<guillemotleft>induced_arrow (C.dom p0')\n                     (D.mkCone p0'\n                       p1') : C.dom\n                               p0' \\<rightarrow> C.dom p0\\<guillemotright>\n 2. p0 \\<cdot> induced_arrow (C.dom p0') (D.mkCone p0' p1') = p0'\n 3. p1 \\<cdot> induced_arrow (C.dom p1') (D.mkCone p0' p1') = p1'", "have cone: \"D.cone (C.dom p0') (D.mkCone p0' p1')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D.cone (C.dom p0') (D.mkCone p0' p1')", "using assms D.cone_mkCone [of p0' p1']"], ["proof (prove)\nusing this:\n  D.is_rendered_commutative_by p0' p1'\n  D.is_rendered_commutative_by p0' p1' \\<Longrightarrow>\n  D.cone (C.dom p0') (D.mkCone p0' p1')\n\ngoal (1 subgoal):\n 1. D.cone (C.dom p0') (D.mkCone p0' p1')", "by blast"], ["proof (state)\nthis:\n  D.cone (C.dom p0') (D.mkCone p0' p1')\n\ngoal (3 subgoals):\n 1. \\<guillemotleft>induced_arrow (C.dom p0')\n                     (D.mkCone p0'\n                       p1') : C.dom\n                               p0' \\<rightarrow> C.dom p0\\<guillemotright>\n 2. p0 \\<cdot> induced_arrow (C.dom p0') (D.mkCone p0' p1') = p0'\n 3. p1 \\<cdot> induced_arrow (C.dom p1') (D.mkCone p0' p1') = p1'", "show 0: \"p0 \\<cdot> induced_arrow (C.dom p0') (D.mkCone p0' p1') = p0'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p0 \\<cdot> induced_arrow (C.dom p0') (D.mkCone p0' p1') = p0'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p0 \\<cdot> induced_arrow (C.dom p0') (D.mkCone p0' p1') = p0'", "have \"p0 \\<cdot> induced_arrow (C.dom p0') (D.mkCone p0' p1') =\n                D.cones_map (induced_arrow (C.dom p0') (D.mkCone p0' p1'))\n                            (D.mkCone p0 p1) J.FF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p0 \\<cdot> induced_arrow (C.dom p0') (D.mkCone p0' p1') =\n    D.cones_map (induced_arrow (C.dom p0') (D.mkCone p0' p1'))\n     (D.mkCone p0 p1) (J.MkIde False)", "using cone induced_arrowI(1) D.mkCone_def J.arr_char cone_\\<chi>"], ["proof (prove)\nusing this:\n  D.cone (C.dom p0') (D.mkCone p0' p1')\n  ?\\<chi>' \\<in> D.cones ?a' \\<Longrightarrow>\n  \\<guillemotleft>induced_arrow ?a'\n                   ?\\<chi>' : ?a' \\<rightarrow> C.dom p0\\<guillemotright>\n  D.mkCone ?p0.0 ?p1.0 \\<equiv>\n  \\<lambda>j.\n     if j = J.MkIde False then ?p0.0\n     else if j = J.MkIde True then ?p1.0 else C.null\n  J.arr ?f = (?f = J.MkIde False \\<or> ?f = J.MkIde True)\n  D.mkCone p0 p1 \\<in> D.cones (C.dom p0)\n\ngoal (1 subgoal):\n 1. p0 \\<cdot> induced_arrow (C.dom p0') (D.mkCone p0' p1') =\n    D.cones_map (induced_arrow (C.dom p0') (D.mkCone p0' p1'))\n     (D.mkCone p0 p1) (J.MkIde False)", "by force"], ["proof (state)\nthis:\n  p0 \\<cdot> induced_arrow (C.dom p0') (D.mkCone p0' p1') =\n  D.cones_map (induced_arrow (C.dom p0') (D.mkCone p0' p1'))\n   (D.mkCone p0 p1) (J.MkIde False)\n\ngoal (1 subgoal):\n 1. p0 \\<cdot> induced_arrow (C.dom p0') (D.mkCone p0' p1') = p0'", "also"], ["proof (state)\nthis:\n  p0 \\<cdot> induced_arrow (C.dom p0') (D.mkCone p0' p1') =\n  D.cones_map (induced_arrow (C.dom p0') (D.mkCone p0' p1'))\n   (D.mkCone p0 p1) (J.MkIde False)\n\ngoal (1 subgoal):\n 1. p0 \\<cdot> induced_arrow (C.dom p0') (D.mkCone p0' p1') = p0'", "have \"... = p0'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D.cones_map (induced_arrow (C.dom p0') (D.mkCone p0' p1'))\n     (D.mkCone p0 p1) (J.MkIde False) =\n    p0'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. D.cones_map (induced_arrow (C.dom p0') (D.mkCone p0' p1'))\n     (D.mkCone p0 p1) (J.MkIde False) =\n    p0'", "have \"D.cones_map (induced_arrow (C.dom p0') (D.mkCone p0' p1'))\n                            (D.mkCone p0 p1) =\n                D.mkCone p0' p1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D.cones_map (induced_arrow (C.dom p0') (D.mkCone p0' p1'))\n     (D.mkCone p0 p1) =\n    D.mkCone p0' p1'", "using cone induced_arrowI"], ["proof (prove)\nusing this:\n  D.cone (C.dom p0') (D.mkCone p0' p1')\n  ?\\<chi>' \\<in> D.cones ?a' \\<Longrightarrow>\n  \\<guillemotleft>induced_arrow ?a'\n                   ?\\<chi>' : ?a' \\<rightarrow> C.dom p0\\<guillemotright>\n  ?\\<chi>' \\<in> D.cones ?a' \\<Longrightarrow>\n  D.cones_map (induced_arrow ?a' ?\\<chi>') (D.mkCone p0 p1) = ?\\<chi>'\n\ngoal (1 subgoal):\n 1. D.cones_map (induced_arrow (C.dom p0') (D.mkCone p0' p1'))\n     (D.mkCone p0 p1) =\n    D.mkCone p0' p1'", "by blast"], ["proof (state)\nthis:\n  D.cones_map (induced_arrow (C.dom p0') (D.mkCone p0' p1'))\n   (D.mkCone p0 p1) =\n  D.mkCone p0' p1'\n\ngoal (1 subgoal):\n 1. D.cones_map (induced_arrow (C.dom p0') (D.mkCone p0' p1'))\n     (D.mkCone p0 p1) (J.MkIde False) =\n    p0'", "thus ?thesis"], ["proof (prove)\nusing this:\n  D.cones_map (induced_arrow (C.dom p0') (D.mkCone p0' p1'))\n   (D.mkCone p0 p1) =\n  D.mkCone p0' p1'\n\ngoal (1 subgoal):\n 1. D.cones_map (induced_arrow (C.dom p0') (D.mkCone p0' p1'))\n     (D.mkCone p0 p1) (J.MkIde False) =\n    p0'", "using J.arr_char D.mkCone_def"], ["proof (prove)\nusing this:\n  D.cones_map (induced_arrow (C.dom p0') (D.mkCone p0' p1'))\n   (D.mkCone p0 p1) =\n  D.mkCone p0' p1'\n  J.arr ?f = (?f = J.MkIde False \\<or> ?f = J.MkIde True)\n  D.mkCone ?p0.0 ?p1.0 \\<equiv>\n  \\<lambda>j.\n     if j = J.MkIde False then ?p0.0\n     else if j = J.MkIde True then ?p1.0 else C.null\n\ngoal (1 subgoal):\n 1. D.cones_map (induced_arrow (C.dom p0') (D.mkCone p0' p1'))\n     (D.mkCone p0 p1) (J.MkIde False) =\n    p0'", "by simp"], ["proof (state)\nthis:\n  D.cones_map (induced_arrow (C.dom p0') (D.mkCone p0' p1'))\n   (D.mkCone p0 p1) (J.MkIde False) =\n  p0'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  D.cones_map (induced_arrow (C.dom p0') (D.mkCone p0' p1'))\n   (D.mkCone p0 p1) (J.MkIde False) =\n  p0'\n\ngoal (1 subgoal):\n 1. p0 \\<cdot> induced_arrow (C.dom p0') (D.mkCone p0' p1') = p0'", "finally"], ["proof (chain)\npicking this:\n  p0 \\<cdot> induced_arrow (C.dom p0') (D.mkCone p0' p1') = p0'", "show ?thesis"], ["proof (prove)\nusing this:\n  p0 \\<cdot> induced_arrow (C.dom p0') (D.mkCone p0' p1') = p0'\n\ngoal (1 subgoal):\n 1. p0 \\<cdot> induced_arrow (C.dom p0') (D.mkCone p0' p1') = p0'", "by auto"], ["proof (state)\nthis:\n  p0 \\<cdot> induced_arrow (C.dom p0') (D.mkCone p0' p1') = p0'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p0 \\<cdot> induced_arrow (C.dom p0') (D.mkCone p0' p1') = p0'\n\ngoal (2 subgoals):\n 1. \\<guillemotleft>induced_arrow (C.dom p0')\n                     (D.mkCone p0'\n                       p1') : C.dom\n                               p0' \\<rightarrow> C.dom p0\\<guillemotright>\n 2. p1 \\<cdot> induced_arrow (C.dom p1') (D.mkCone p0' p1') = p1'", "show \"p1 \\<cdot> induced_arrow (C.dom p1') (D.mkCone p0' p1') = p1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p1 \\<cdot> induced_arrow (C.dom p1') (D.mkCone p0' p1') = p1'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p1 \\<cdot> induced_arrow (C.dom p1') (D.mkCone p0' p1') = p1'", "have \"p1 \\<cdot> induced_arrow (C.dom p1') (D.mkCone p0' p1') =\n                D.cones_map (induced_arrow (C.dom p0') (D.mkCone p0' p1'))\n                            (D.mkCone p0 p1) J.TT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p1 \\<cdot> induced_arrow (C.dom p1') (D.mkCone p0' p1') =\n    D.cones_map (induced_arrow (C.dom p0') (D.mkCone p0' p1'))\n     (D.mkCone p0 p1) (J.MkIde True)", "using assms cone induced_arrowI(1) D.mkCone_def J.arr_char cone_\\<chi>"], ["proof (prove)\nusing this:\n  D.is_rendered_commutative_by p0' p1'\n  D.cone (C.dom p0') (D.mkCone p0' p1')\n  ?\\<chi>' \\<in> D.cones ?a' \\<Longrightarrow>\n  \\<guillemotleft>induced_arrow ?a'\n                   ?\\<chi>' : ?a' \\<rightarrow> C.dom p0\\<guillemotright>\n  D.mkCone ?p0.0 ?p1.0 \\<equiv>\n  \\<lambda>j.\n     if j = J.MkIde False then ?p0.0\n     else if j = J.MkIde True then ?p1.0 else C.null\n  J.arr ?f = (?f = J.MkIde False \\<or> ?f = J.MkIde True)\n  D.mkCone p0 p1 \\<in> D.cones (C.dom p0)\n\ngoal (1 subgoal):\n 1. p1 \\<cdot> induced_arrow (C.dom p1') (D.mkCone p0' p1') =\n    D.cones_map (induced_arrow (C.dom p0') (D.mkCone p0' p1'))\n     (D.mkCone p0 p1) (J.MkIde True)", "by fastforce"], ["proof (state)\nthis:\n  p1 \\<cdot> induced_arrow (C.dom p1') (D.mkCone p0' p1') =\n  D.cones_map (induced_arrow (C.dom p0') (D.mkCone p0' p1'))\n   (D.mkCone p0 p1) (J.MkIde True)\n\ngoal (1 subgoal):\n 1. p1 \\<cdot> induced_arrow (C.dom p1') (D.mkCone p0' p1') = p1'", "also"], ["proof (state)\nthis:\n  p1 \\<cdot> induced_arrow (C.dom p1') (D.mkCone p0' p1') =\n  D.cones_map (induced_arrow (C.dom p0') (D.mkCone p0' p1'))\n   (D.mkCone p0 p1) (J.MkIde True)\n\ngoal (1 subgoal):\n 1. p1 \\<cdot> induced_arrow (C.dom p1') (D.mkCone p0' p1') = p1'", "have \"... = p1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D.cones_map (induced_arrow (C.dom p0') (D.mkCone p0' p1'))\n     (D.mkCone p0 p1) (J.MkIde True) =\n    p1'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. D.cones_map (induced_arrow (C.dom p0') (D.mkCone p0' p1'))\n     (D.mkCone p0 p1) (J.MkIde True) =\n    p1'", "have \"D.cones_map (induced_arrow (C.dom p0') (D.mkCone p0' p1'))\n                            (D.mkCone p0 p1) =\n                D.mkCone p0' p1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D.cones_map (induced_arrow (C.dom p0') (D.mkCone p0' p1'))\n     (D.mkCone p0 p1) =\n    D.mkCone p0' p1'", "using cone induced_arrowI"], ["proof (prove)\nusing this:\n  D.cone (C.dom p0') (D.mkCone p0' p1')\n  ?\\<chi>' \\<in> D.cones ?a' \\<Longrightarrow>\n  \\<guillemotleft>induced_arrow ?a'\n                   ?\\<chi>' : ?a' \\<rightarrow> C.dom p0\\<guillemotright>\n  ?\\<chi>' \\<in> D.cones ?a' \\<Longrightarrow>\n  D.cones_map (induced_arrow ?a' ?\\<chi>') (D.mkCone p0 p1) = ?\\<chi>'\n\ngoal (1 subgoal):\n 1. D.cones_map (induced_arrow (C.dom p0') (D.mkCone p0' p1'))\n     (D.mkCone p0 p1) =\n    D.mkCone p0' p1'", "by blast"], ["proof (state)\nthis:\n  D.cones_map (induced_arrow (C.dom p0') (D.mkCone p0' p1'))\n   (D.mkCone p0 p1) =\n  D.mkCone p0' p1'\n\ngoal (1 subgoal):\n 1. D.cones_map (induced_arrow (C.dom p0') (D.mkCone p0' p1'))\n     (D.mkCone p0 p1) (J.MkIde True) =\n    p1'", "thus ?thesis"], ["proof (prove)\nusing this:\n  D.cones_map (induced_arrow (C.dom p0') (D.mkCone p0' p1'))\n   (D.mkCone p0 p1) =\n  D.mkCone p0' p1'\n\ngoal (1 subgoal):\n 1. D.cones_map (induced_arrow (C.dom p0') (D.mkCone p0' p1'))\n     (D.mkCone p0 p1) (J.MkIde True) =\n    p1'", "using J.arr_char D.mkCone_def"], ["proof (prove)\nusing this:\n  D.cones_map (induced_arrow (C.dom p0') (D.mkCone p0' p1'))\n   (D.mkCone p0 p1) =\n  D.mkCone p0' p1'\n  J.arr ?f = (?f = J.MkIde False \\<or> ?f = J.MkIde True)\n  D.mkCone ?p0.0 ?p1.0 \\<equiv>\n  \\<lambda>j.\n     if j = J.MkIde False then ?p0.0\n     else if j = J.MkIde True then ?p1.0 else C.null\n\ngoal (1 subgoal):\n 1. D.cones_map (induced_arrow (C.dom p0') (D.mkCone p0' p1'))\n     (D.mkCone p0 p1) (J.MkIde True) =\n    p1'", "by simp"], ["proof (state)\nthis:\n  D.cones_map (induced_arrow (C.dom p0') (D.mkCone p0' p1'))\n   (D.mkCone p0 p1) (J.MkIde True) =\n  p1'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  D.cones_map (induced_arrow (C.dom p0') (D.mkCone p0' p1'))\n   (D.mkCone p0 p1) (J.MkIde True) =\n  p1'\n\ngoal (1 subgoal):\n 1. p1 \\<cdot> induced_arrow (C.dom p1') (D.mkCone p0' p1') = p1'", "finally"], ["proof (chain)\npicking this:\n  p1 \\<cdot> induced_arrow (C.dom p1') (D.mkCone p0' p1') = p1'", "show ?thesis"], ["proof (prove)\nusing this:\n  p1 \\<cdot> induced_arrow (C.dom p1') (D.mkCone p0' p1') = p1'\n\ngoal (1 subgoal):\n 1. p1 \\<cdot> induced_arrow (C.dom p1') (D.mkCone p0' p1') = p1'", "by auto"], ["proof (state)\nthis:\n  p1 \\<cdot> induced_arrow (C.dom p1') (D.mkCone p0' p1') = p1'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p1 \\<cdot> induced_arrow (C.dom p1') (D.mkCone p0' p1') = p1'\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>induced_arrow (C.dom p0')\n                     (D.mkCone p0'\n                       p1') : C.dom\n                               p0' \\<rightarrow> C.dom p0\\<guillemotright>", "show \"\\<guillemotleft>induced_arrow (C.dom p0') (D.mkCone p0' p1') : C.dom p0' \\<rightarrow> C.dom p0\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>induced_arrow (C.dom p0')\n                     (D.mkCone p0'\n                       p1') : C.dom\n                               p0' \\<rightarrow> C.dom p0\\<guillemotright>", "using 0 cone induced_arrowI"], ["proof (prove)\nusing this:\n  p0 \\<cdot> induced_arrow (C.dom p0') (D.mkCone p0' p1') = p0'\n  D.cone (C.dom p0') (D.mkCone p0' p1')\n  ?\\<chi>' \\<in> D.cones ?a' \\<Longrightarrow>\n  \\<guillemotleft>induced_arrow ?a'\n                   ?\\<chi>' : ?a' \\<rightarrow> C.dom p0\\<guillemotright>\n  ?\\<chi>' \\<in> D.cones ?a' \\<Longrightarrow>\n  D.cones_map (induced_arrow ?a' ?\\<chi>') (D.mkCone p0 p1) = ?\\<chi>'\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>induced_arrow (C.dom p0')\n                     (D.mkCone p0'\n                       p1') : C.dom\n                               p0' \\<rightarrow> C.dom p0\\<guillemotright>", "by simp"], ["proof (state)\nthis:\n  \\<guillemotleft>induced_arrow (C.dom p0')\n                   (D.mkCone p0'\n                     p1') : C.dom\n                             p0' \\<rightarrow> C.dom p0\\<guillemotright>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "context category\n  begin"], ["", "definition has_as_binary_product\n    where \"has_as_binary_product a0 a1 p0 p1 \\<equiv>\n           ide a0 \\<and> ide a1 \\<and> binary_product_diagram.has_as_binary_product C a0 a1 p0 p1\""], ["", "definition has_binary_products\n    where \"has_binary_products =\n           (\\<forall>a0 a1. ide a0 \\<and> ide a1 \\<longrightarrow> (\\<exists>p0 p1. has_as_binary_product a0 a1 p0 p1))\""], ["", "end"], ["", "locale category_with_binary_products =\n    category +\n  assumes has_binary_products: has_binary_products"], ["", "subsection \"Elementary Category with Binary Products\""], ["", "text \\<open>\n    An \\emph{elementary category with binary products} is a category equipped with a specific\n    way of mapping each pair of objects \\<open>a\\<close> and \\<open>b\\<close> to a pair of arrows \\<open>\\<pp>\\<^sub>1[a, b]\\<close> and \\<open>\\<pp>\\<^sub>0[a, b]\\<close>\n    that comprise a universal span.  It is useful to assume that the mappings that produce\n    \\<open>\\<pp>\\<^sub>1[a, b]\\<close> and \\<open>\\<pp>\\<^sub>0[a, b]\\<close> from \\<open>a\\<close> and \\<open>b\\<close> are extensional; that is, if either \\<open>a\\<close> or \\<open>b\\<close>\n    is not an identity, then \\<open>\\<pp>\\<^sub>1[a, b]\\<close> and \\<open>\\<pp>\\<^sub>0[a, b]\\<close> are \\<open>null\\<close>.\n  \\<close>"], ["", "locale elementary_category_with_binary_products =\n    category C\n  for C :: \"'a comp\"                             (infixr \"\\<cdot>\" 55)\n  and pr0 :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a\"                    (\"\\<pp>\\<^sub>0[_, _]\")\n  and pr1 :: \"'a \\<Rightarrow> 'a \\<Rightarrow> 'a\"                    (\"\\<pp>\\<^sub>1[_, _]\") +\n  assumes pr0_ext: \"\\<not> (ide a \\<and> ide b) \\<Longrightarrow> \\<pp>\\<^sub>0[a, b] = null\"\n  and pr1_ext: \"\\<not> (ide a \\<and> ide b) \\<Longrightarrow> \\<pp>\\<^sub>1[a, b] = null\"\n  and span_pr: \"\\<lbrakk> ide a; ide b \\<rbrakk> \\<Longrightarrow> span \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]\"\n  and cod_pr0: \"\\<lbrakk> ide a; ide b \\<rbrakk> \\<Longrightarrow> cod \\<pp>\\<^sub>0[a, b] = b\"\n  and cod_pr1: \"\\<lbrakk> ide a; ide b \\<rbrakk> \\<Longrightarrow> cod \\<pp>\\<^sub>1[a, b] = a\"\n  and universal: \"span f g \\<Longrightarrow> \\<exists>!l. \\<pp>\\<^sub>1[cod f, cod g] \\<cdot> l = f \\<and> \\<pp>\\<^sub>0[cod f, cod g] \\<cdot> l = g\"\n  begin"], ["", "lemma pr0_in_hom':\n    assumes \"ide a\" and \"ide b\"\n    shows \"\\<guillemotleft>\\<pp>\\<^sub>0[a, b] : dom \\<pp>\\<^sub>0[a, b] \\<rightarrow> b\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<pp>\\<^sub>0[a, b] : local.dom\n     \\<pp>\\<^sub>0[a, b] \\<rightarrow> b\\<guillemotright>", "using assms span_pr cod_pr0"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> span \\<pp>\\<^sub>1[?a, ?b] \\<pp>\\<^sub>0[?a, ?b]\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> cod \\<pp>\\<^sub>0[?a, ?b] = ?b\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<pp>\\<^sub>0[a, b] : local.dom\n     \\<pp>\\<^sub>0[a, b] \\<rightarrow> b\\<guillemotright>", "by auto"], ["", "lemma pr1_in_hom':\n    assumes \"ide a\" and \"ide b\"\n    shows \"\\<guillemotleft>\\<pp>\\<^sub>1[a, b] : dom \\<pp>\\<^sub>0[a, b] \\<rightarrow> a\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<pp>\\<^sub>1[a, b] : local.dom\n     \\<pp>\\<^sub>0[a, b] \\<rightarrow> a\\<guillemotright>", "using assms span_pr cod_pr1"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> span \\<pp>\\<^sub>1[?a, ?b] \\<pp>\\<^sub>0[?a, ?b]\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> cod \\<pp>\\<^sub>1[?a, ?b] = ?a\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<pp>\\<^sub>1[a, b] : local.dom\n     \\<pp>\\<^sub>0[a, b] \\<rightarrow> a\\<guillemotright>", "by auto"], ["", "text \\<open>\n      We introduce a notation for tupling, which denotes the arrow into a product that\n      is induced by a span.\n    \\<close>"], ["", "definition tuple         (\"\\<langle>_, _\\<rangle>\")\n    where \"\\<langle>f, g\\<rangle> \\<equiv> if span f g then\n                      THE l. \\<pp>\\<^sub>1[cod f, cod g] \\<cdot> l = f \\<and> \\<pp>\\<^sub>0[cod f, cod g] \\<cdot> l = g\n                    else null\""], ["", "text \\<open>\n      The following defines product of arrows (not just of objects).  It will take a little\n      while before we can prove that it is functorial, but for right now it is nice to have\n      it as a notation for the apex of a product cone.  We have to go through some slightly\n      unnatural contortions in the development here, though, to avoid having to introduce a\n      separate preliminary notation just for the product of objects.\n    \\<close>"], ["", "(* TODO: I want to use \\<times> but it has already been commandeered for product types. *)"], ["", "definition prod         (infixr \"\\<otimes>\" 51)\n    where \"f \\<otimes> g \\<equiv> \\<langle>f \\<cdot> \\<pp>\\<^sub>1[dom f, dom g], g \\<cdot> \\<pp>\\<^sub>0[dom f, dom g]\\<rangle>\""], ["", "lemma seq_pr_tuple:\n    assumes \"span f g\"\n    shows \"seq \\<pp>\\<^sub>0[cod f, cod g] \\<langle>f, g\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq \\<pp>\\<^sub>0[cod f, cod g] \\<langle>f, g\\<rangle>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. seq \\<pp>\\<^sub>0[cod f, cod g] \\<langle>f, g\\<rangle>", "have \"\\<pp>\\<^sub>0[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle> = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle> = g", "unfolding tuple_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[cod f, cod g] \\<cdot>\n    (if span f g\n     then THE l.\n             \\<pp>\\<^sub>1[cod f, cod g] \\<cdot> l = f \\<and>\n             \\<pp>\\<^sub>0[cod f, cod g] \\<cdot> l = g\n     else null) =\n    g", "using assms universal theI [of \"\\<lambda>l. \\<pp>\\<^sub>1[cod f, cod g] \\<cdot> l = f \\<and> \\<pp>\\<^sub>0[cod f, cod g] \\<cdot> l = g\"]"], ["proof (prove)\nusing this:\n  span f g\n  span ?f ?g \\<Longrightarrow>\n  \\<exists>!l.\n     \\<pp>\\<^sub>1[cod ?f, cod ?g] \\<cdot> l = ?f \\<and>\n     \\<pp>\\<^sub>0[cod ?f, cod ?g] \\<cdot> l = ?g\n  \\<lbrakk>\\<pp>\\<^sub>1[cod f, cod g] \\<cdot> ?a = f \\<and>\n           \\<pp>\\<^sub>0[cod f, cod g] \\<cdot> ?a = g;\n   \\<And>x.\n      \\<pp>\\<^sub>1[cod f, cod g] \\<cdot> x = f \\<and>\n      \\<pp>\\<^sub>0[cod f, cod g] \\<cdot> x = g \\<Longrightarrow>\n      x = ?a\\<rbrakk>\n  \\<Longrightarrow> \\<pp>\\<^sub>1[cod f, cod g] \\<cdot>\n                    (THE x.\n                        \\<pp>\\<^sub>1[cod f, cod g] \\<cdot> x = f \\<and>\n                        \\<pp>\\<^sub>0[cod f, cod g] \\<cdot> x = g) =\n                    f \\<and>\n                    \\<pp>\\<^sub>0[cod f, cod g] \\<cdot>\n                    (THE x.\n                        \\<pp>\\<^sub>1[cod f, cod g] \\<cdot> x = f \\<and>\n                        \\<pp>\\<^sub>0[cod f, cod g] \\<cdot> x = g) =\n                    g\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[cod f, cod g] \\<cdot>\n    (if span f g\n     then THE l.\n             \\<pp>\\<^sub>1[cod f, cod g] \\<cdot> l = f \\<and>\n             \\<pp>\\<^sub>0[cod f, cod g] \\<cdot> l = g\n     else null) =\n    g", "by simp meson"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>0[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle> = g\n\ngoal (1 subgoal):\n 1. seq \\<pp>\\<^sub>0[cod f, cod g] \\<langle>f, g\\<rangle>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<pp>\\<^sub>0[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle> = g\n\ngoal (1 subgoal):\n 1. seq \\<pp>\\<^sub>0[cod f, cod g] \\<langle>f, g\\<rangle>", "using assms"], ["proof (prove)\nusing this:\n  \\<pp>\\<^sub>0[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle> = g\n  span f g\n\ngoal (1 subgoal):\n 1. seq \\<pp>\\<^sub>0[cod f, cod g] \\<langle>f, g\\<rangle>", "by simp"], ["proof (state)\nthis:\n  seq \\<pp>\\<^sub>0[cod f, cod g] \\<langle>f, g\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tuple_pr_arr:\n    assumes \"ide a\" and \"ide b\" and \"seq \\<pp>\\<^sub>0[a, b] h\"\n    shows \"\\<langle>\\<pp>\\<^sub>1[a, b] \\<cdot> h, \\<pp>\\<^sub>0[a, b] \\<cdot> h\\<rangle> = h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<pp>\\<^sub>1[a, b] \\<cdot>\n             h, \\<pp>\\<^sub>0[a, b] \\<cdot> h\\<rangle> =\n    h", "unfolding tuple_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if span (\\<pp>\\<^sub>1[a, b] \\<cdot> h) (\\<pp>\\<^sub>0[a, b] \\<cdot> h)\n     then THE l.\n             \\<pp>\\<^sub>1[cod (\\<pp>\\<^sub>1[a, b] \\<cdot>\n                                h), cod (\\<pp>\\<^sub>0[a, b] \\<cdot>\n   h)] \\<cdot>\n             l =\n             \\<pp>\\<^sub>1[a, b] \\<cdot> h \\<and>\n             \\<pp>\\<^sub>0[cod (\\<pp>\\<^sub>1[a, b] \\<cdot>\n                                h), cod (\\<pp>\\<^sub>0[a, b] \\<cdot>\n   h)] \\<cdot>\n             l =\n             \\<pp>\\<^sub>0[a, b] \\<cdot> h\n     else null) =\n    h", "using assms span_pr cod_pr0 cod_pr1 universal [of \"\\<pp>\\<^sub>1[a, b] \\<cdot> h\" \"\\<pp>\\<^sub>0[a, b] \\<cdot> h\"]\n            theI_unique [of \"\\<lambda>l. \\<pp>\\<^sub>1[a, b] \\<cdot> l = \\<pp>\\<^sub>1[a, b] \\<cdot> h \\<and> \\<pp>\\<^sub>0[a, b] \\<cdot> l = \\<pp>\\<^sub>0[a, b] \\<cdot> h\" h]"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  seq \\<pp>\\<^sub>0[a, b] h\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> span \\<pp>\\<^sub>1[?a, ?b] \\<pp>\\<^sub>0[?a, ?b]\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> cod \\<pp>\\<^sub>0[?a, ?b] = ?b\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> cod \\<pp>\\<^sub>1[?a, ?b] = ?a\n  span (\\<pp>\\<^sub>1[a, b] \\<cdot> h)\n   (\\<pp>\\<^sub>0[a, b] \\<cdot> h) \\<Longrightarrow>\n  \\<exists>!l.\n     \\<pp>\\<^sub>1[cod (\\<pp>\\<^sub>1[a, b] \\<cdot>\n                        h), cod (\\<pp>\\<^sub>0[a, b] \\<cdot> h)] \\<cdot>\n     l =\n     \\<pp>\\<^sub>1[a, b] \\<cdot> h \\<and>\n     \\<pp>\\<^sub>0[cod (\\<pp>\\<^sub>1[a, b] \\<cdot>\n                        h), cod (\\<pp>\\<^sub>0[a, b] \\<cdot> h)] \\<cdot>\n     l =\n     \\<pp>\\<^sub>0[a, b] \\<cdot> h\n  \\<exists>!x.\n     \\<pp>\\<^sub>1[a, b] \\<cdot> x = \\<pp>\\<^sub>1[a, b] \\<cdot> h \\<and>\n     \\<pp>\\<^sub>0[a, b] \\<cdot> x =\n     \\<pp>\\<^sub>0[a, b] \\<cdot> h \\<Longrightarrow>\n  (\\<pp>\\<^sub>1[a, b] \\<cdot> h = \\<pp>\\<^sub>1[a, b] \\<cdot> h \\<and>\n   \\<pp>\\<^sub>0[a, b] \\<cdot> h = \\<pp>\\<^sub>0[a, b] \\<cdot> h) =\n  (h =\n   (THE l.\n       \\<pp>\\<^sub>1[a, b] \\<cdot> l = \\<pp>\\<^sub>1[a, b] \\<cdot> h \\<and>\n       \\<pp>\\<^sub>0[a, b] \\<cdot> l = \\<pp>\\<^sub>0[a, b] \\<cdot> h))\n\ngoal (1 subgoal):\n 1. (if span (\\<pp>\\<^sub>1[a, b] \\<cdot> h) (\\<pp>\\<^sub>0[a, b] \\<cdot> h)\n     then THE l.\n             \\<pp>\\<^sub>1[cod (\\<pp>\\<^sub>1[a, b] \\<cdot>\n                                h), cod (\\<pp>\\<^sub>0[a, b] \\<cdot>\n   h)] \\<cdot>\n             l =\n             \\<pp>\\<^sub>1[a, b] \\<cdot> h \\<and>\n             \\<pp>\\<^sub>0[cod (\\<pp>\\<^sub>1[a, b] \\<cdot>\n                                h), cod (\\<pp>\\<^sub>0[a, b] \\<cdot>\n   h)] \\<cdot>\n             l =\n             \\<pp>\\<^sub>0[a, b] \\<cdot> h\n     else null) =\n    h", "by auto"], ["", "lemma pr_tuple [simp]:\n    assumes \"span f g\" and \"cod f = a\" and \"cod g = b\"\n    shows \"\\<pp>\\<^sub>1[a, b] \\<cdot> \\<langle>f, g\\<rangle> = f\" and \"\\<pp>\\<^sub>0[a, b] \\<cdot> \\<langle>f, g\\<rangle> = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, b] \\<cdot> \\<langle>f, g\\<rangle> = f &&&\n    \\<pp>\\<^sub>0[a, b] \\<cdot> \\<langle>f, g\\<rangle> = g", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<pp>\\<^sub>1[a, b] \\<cdot> \\<langle>f, g\\<rangle> = f\n 2. \\<pp>\\<^sub>0[a, b] \\<cdot> \\<langle>f, g\\<rangle> = g", "have 1: \"\\<pp>\\<^sub>1[a, b] \\<cdot> \\<langle>f, g\\<rangle> = f \\<and> \\<pp>\\<^sub>0[a, b] \\<cdot> \\<langle>f, g\\<rangle> = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, b] \\<cdot> \\<langle>f, g\\<rangle> = f \\<and>\n    \\<pp>\\<^sub>0[a, b] \\<cdot> \\<langle>f, g\\<rangle> = g", "unfolding tuple_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, b] \\<cdot>\n    (if span f g\n     then THE l.\n             \\<pp>\\<^sub>1[cod f, cod g] \\<cdot> l = f \\<and>\n             \\<pp>\\<^sub>0[cod f, cod g] \\<cdot> l = g\n     else null) =\n    f \\<and>\n    \\<pp>\\<^sub>0[a, b] \\<cdot>\n    (if span f g\n     then THE l.\n             \\<pp>\\<^sub>1[cod f, cod g] \\<cdot> l = f \\<and>\n             \\<pp>\\<^sub>0[cod f, cod g] \\<cdot> l = g\n     else null) =\n    g", "using assms universal theI [of \"\\<lambda>l. \\<pp>\\<^sub>1[a, b] \\<cdot> l = f \\<and> \\<pp>\\<^sub>0[a, b] \\<cdot> l = g\"]"], ["proof (prove)\nusing this:\n  span f g\n  cod f = a\n  cod g = b\n  span ?f ?g \\<Longrightarrow>\n  \\<exists>!l.\n     \\<pp>\\<^sub>1[cod ?f, cod ?g] \\<cdot> l = ?f \\<and>\n     \\<pp>\\<^sub>0[cod ?f, cod ?g] \\<cdot> l = ?g\n  \\<lbrakk>\\<pp>\\<^sub>1[a, b] \\<cdot> ?a = f \\<and>\n           \\<pp>\\<^sub>0[a, b] \\<cdot> ?a = g;\n   \\<And>x.\n      \\<pp>\\<^sub>1[a, b] \\<cdot> x = f \\<and>\n      \\<pp>\\<^sub>0[a, b] \\<cdot> x = g \\<Longrightarrow>\n      x = ?a\\<rbrakk>\n  \\<Longrightarrow> \\<pp>\\<^sub>1[a, b] \\<cdot>\n                    (THE x.\n                        \\<pp>\\<^sub>1[a, b] \\<cdot> x = f \\<and>\n                        \\<pp>\\<^sub>0[a, b] \\<cdot> x = g) =\n                    f \\<and>\n                    \\<pp>\\<^sub>0[a, b] \\<cdot>\n                    (THE x.\n                        \\<pp>\\<^sub>1[a, b] \\<cdot> x = f \\<and>\n                        \\<pp>\\<^sub>0[a, b] \\<cdot> x = g) =\n                    g\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, b] \\<cdot>\n    (if span f g\n     then THE l.\n             \\<pp>\\<^sub>1[cod f, cod g] \\<cdot> l = f \\<and>\n             \\<pp>\\<^sub>0[cod f, cod g] \\<cdot> l = g\n     else null) =\n    f \\<and>\n    \\<pp>\\<^sub>0[a, b] \\<cdot>\n    (if span f g\n     then THE l.\n             \\<pp>\\<^sub>1[cod f, cod g] \\<cdot> l = f \\<and>\n             \\<pp>\\<^sub>0[cod f, cod g] \\<cdot> l = g\n     else null) =\n    g", "by simp meson"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>1[a, b] \\<cdot> \\<langle>f, g\\<rangle> = f \\<and>\n  \\<pp>\\<^sub>0[a, b] \\<cdot> \\<langle>f, g\\<rangle> = g\n\ngoal (2 subgoals):\n 1. \\<pp>\\<^sub>1[a, b] \\<cdot> \\<langle>f, g\\<rangle> = f\n 2. \\<pp>\\<^sub>0[a, b] \\<cdot> \\<langle>f, g\\<rangle> = g", "show \"\\<pp>\\<^sub>1[a, b] \\<cdot> \\<langle>f, g\\<rangle> = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, b] \\<cdot> \\<langle>f, g\\<rangle> = f", "using 1"], ["proof (prove)\nusing this:\n  \\<pp>\\<^sub>1[a, b] \\<cdot> \\<langle>f, g\\<rangle> = f \\<and>\n  \\<pp>\\<^sub>0[a, b] \\<cdot> \\<langle>f, g\\<rangle> = g\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, b] \\<cdot> \\<langle>f, g\\<rangle> = f", "by simp"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>1[a, b] \\<cdot> \\<langle>f, g\\<rangle> = f\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, b] \\<cdot> \\<langle>f, g\\<rangle> = g", "show \"\\<pp>\\<^sub>0[a, b] \\<cdot> \\<langle>f, g\\<rangle> = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, b] \\<cdot> \\<langle>f, g\\<rangle> = g", "using 1"], ["proof (prove)\nusing this:\n  \\<pp>\\<^sub>1[a, b] \\<cdot> \\<langle>f, g\\<rangle> = f \\<and>\n  \\<pp>\\<^sub>0[a, b] \\<cdot> \\<langle>f, g\\<rangle> = g\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, b] \\<cdot> \\<langle>f, g\\<rangle> = g", "by simp"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>0[a, b] \\<cdot> \\<langle>f, g\\<rangle> = g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma cod_tuple:\n    assumes \"span f g\"\n    shows \"cod \\<langle>f, g\\<rangle> = cod f \\<otimes> cod g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cod \\<langle>f, g\\<rangle> = cod f \\<otimes> cod g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. cod \\<langle>f, g\\<rangle> = cod f \\<otimes> cod g", "have \"cod f \\<otimes> cod g = \\<langle>\\<pp>\\<^sub>1[cod f, cod g], \\<pp>\\<^sub>0[cod f, cod g]\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cod f \\<otimes> cod g =\n    \\<langle>\\<pp>\\<^sub>1[cod f, cod g], \\<pp>\\<^sub>0[cod\n                   f, cod g]\\<rangle>", "unfolding prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>cod f \\<cdot>\n             \\<pp>\\<^sub>1[local.dom\n                            (cod f), local.dom\n(cod g)], cod g \\<cdot>\n          \\<pp>\\<^sub>0[local.dom (cod f), local.dom (cod g)]\\<rangle> =\n    \\<langle>\\<pp>\\<^sub>1[cod f, cod g], \\<pp>\\<^sub>0[cod\n                   f, cod g]\\<rangle>", "using assms comp_cod_arr span_pr cod_pr0 cod_pr1"], ["proof (prove)\nusing this:\n  span f g\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> span \\<pp>\\<^sub>1[?a, ?b] \\<pp>\\<^sub>0[?a, ?b]\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> cod \\<pp>\\<^sub>0[?a, ?b] = ?b\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> cod \\<pp>\\<^sub>1[?a, ?b] = ?a\n\ngoal (1 subgoal):\n 1. \\<langle>cod f \\<cdot>\n             \\<pp>\\<^sub>1[local.dom\n                            (cod f), local.dom\n(cod g)], cod g \\<cdot>\n          \\<pp>\\<^sub>0[local.dom (cod f), local.dom (cod g)]\\<rangle> =\n    \\<langle>\\<pp>\\<^sub>1[cod f, cod g], \\<pp>\\<^sub>0[cod\n                   f, cod g]\\<rangle>", "by simp"], ["proof (state)\nthis:\n  cod f \\<otimes> cod g =\n  \\<langle>\\<pp>\\<^sub>1[cod f, cod g], \\<pp>\\<^sub>0[cod f, cod g]\\<rangle>\n\ngoal (1 subgoal):\n 1. cod \\<langle>f, g\\<rangle> = cod f \\<otimes> cod g", "also"], ["proof (state)\nthis:\n  cod f \\<otimes> cod g =\n  \\<langle>\\<pp>\\<^sub>1[cod f, cod g], \\<pp>\\<^sub>0[cod f, cod g]\\<rangle>\n\ngoal (1 subgoal):\n 1. cod \\<langle>f, g\\<rangle> = cod f \\<otimes> cod g", "have \"... = \\<langle>\\<pp>\\<^sub>1[cod f, cod g] \\<cdot> dom \\<pp>\\<^sub>0[cod f, cod g],\n                        \\<pp>\\<^sub>0[cod f, cod g] \\<cdot> dom \\<pp>\\<^sub>0[cod f, cod g]\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<pp>\\<^sub>1[cod f, cod g], \\<pp>\\<^sub>0[cod\n                   f, cod g]\\<rangle> =\n    \\<langle>\\<pp>\\<^sub>1[cod f, cod g] \\<cdot>\n             local.dom\n              \\<pp>\\<^sub>0[cod f, cod g], \\<pp>\\<^sub>0[cod\n                    f, cod g] \\<cdot>\n     local.dom \\<pp>\\<^sub>0[cod f, cod g]\\<rangle>", "using assms span_pr comp_arr_dom"], ["proof (prove)\nusing this:\n  span f g\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> span \\<pp>\\<^sub>1[?a, ?b] \\<pp>\\<^sub>0[?a, ?b]\n  \\<lbrakk>arr ?f; local.dom ?f = ?a\\<rbrakk>\n  \\<Longrightarrow> ?f \\<cdot> ?a = ?f\n\ngoal (1 subgoal):\n 1. \\<langle>\\<pp>\\<^sub>1[cod f, cod g], \\<pp>\\<^sub>0[cod\n                   f, cod g]\\<rangle> =\n    \\<langle>\\<pp>\\<^sub>1[cod f, cod g] \\<cdot>\n             local.dom\n              \\<pp>\\<^sub>0[cod f, cod g], \\<pp>\\<^sub>0[cod\n                    f, cod g] \\<cdot>\n     local.dom \\<pp>\\<^sub>0[cod f, cod g]\\<rangle>", "by simp"], ["proof (state)\nthis:\n  \\<langle>\\<pp>\\<^sub>1[cod f, cod g], \\<pp>\\<^sub>0[cod\n                 f, cod g]\\<rangle> =\n  \\<langle>\\<pp>\\<^sub>1[cod f, cod g] \\<cdot>\n           local.dom\n            \\<pp>\\<^sub>0[cod f, cod g], \\<pp>\\<^sub>0[cod f, cod g] \\<cdot>\n   local.dom \\<pp>\\<^sub>0[cod f, cod g]\\<rangle>\n\ngoal (1 subgoal):\n 1. cod \\<langle>f, g\\<rangle> = cod f \\<otimes> cod g", "also"], ["proof (state)\nthis:\n  \\<langle>\\<pp>\\<^sub>1[cod f, cod g], \\<pp>\\<^sub>0[cod\n                 f, cod g]\\<rangle> =\n  \\<langle>\\<pp>\\<^sub>1[cod f, cod g] \\<cdot>\n           local.dom\n            \\<pp>\\<^sub>0[cod f, cod g], \\<pp>\\<^sub>0[cod f, cod g] \\<cdot>\n   local.dom \\<pp>\\<^sub>0[cod f, cod g]\\<rangle>\n\ngoal (1 subgoal):\n 1. cod \\<langle>f, g\\<rangle> = cod f \\<otimes> cod g", "have \"... = dom \\<pp>\\<^sub>0[cod f, cod g]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<pp>\\<^sub>1[cod f, cod g] \\<cdot>\n             local.dom\n              \\<pp>\\<^sub>0[cod f, cod g], \\<pp>\\<^sub>0[cod\n                    f, cod g] \\<cdot>\n     local.dom \\<pp>\\<^sub>0[cod f, cod g]\\<rangle> =\n    local.dom \\<pp>\\<^sub>0[cod f, cod g]", "using assms tuple_pr_arr span_pr"], ["proof (prove)\nusing this:\n  span f g\n  \\<lbrakk>ide ?a; ide ?b; seq \\<pp>\\<^sub>0[?a, ?b] ?h\\<rbrakk>\n  \\<Longrightarrow> \\<langle>\\<pp>\\<^sub>1[?a, ?b] \\<cdot>\n                             ?h, \\<pp>\\<^sub>0[?a, ?b] \\<cdot> ?h\\<rangle> =\n                    ?h\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> span \\<pp>\\<^sub>1[?a, ?b] \\<pp>\\<^sub>0[?a, ?b]\n\ngoal (1 subgoal):\n 1. \\<langle>\\<pp>\\<^sub>1[cod f, cod g] \\<cdot>\n             local.dom\n              \\<pp>\\<^sub>0[cod f, cod g], \\<pp>\\<^sub>0[cod\n                    f, cod g] \\<cdot>\n     local.dom \\<pp>\\<^sub>0[cod f, cod g]\\<rangle> =\n    local.dom \\<pp>\\<^sub>0[cod f, cod g]", "by simp"], ["proof (state)\nthis:\n  \\<langle>\\<pp>\\<^sub>1[cod f, cod g] \\<cdot>\n           local.dom\n            \\<pp>\\<^sub>0[cod f, cod g], \\<pp>\\<^sub>0[cod f, cod g] \\<cdot>\n   local.dom \\<pp>\\<^sub>0[cod f, cod g]\\<rangle> =\n  local.dom \\<pp>\\<^sub>0[cod f, cod g]\n\ngoal (1 subgoal):\n 1. cod \\<langle>f, g\\<rangle> = cod f \\<otimes> cod g", "also"], ["proof (state)\nthis:\n  \\<langle>\\<pp>\\<^sub>1[cod f, cod g] \\<cdot>\n           local.dom\n            \\<pp>\\<^sub>0[cod f, cod g], \\<pp>\\<^sub>0[cod f, cod g] \\<cdot>\n   local.dom \\<pp>\\<^sub>0[cod f, cod g]\\<rangle> =\n  local.dom \\<pp>\\<^sub>0[cod f, cod g]\n\ngoal (1 subgoal):\n 1. cod \\<langle>f, g\\<rangle> = cod f \\<otimes> cod g", "have \"... = cod \\<langle>f, g\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dom \\<pp>\\<^sub>0[cod f, cod g] = cod \\<langle>f, g\\<rangle>", "using assms seq_pr_tuple"], ["proof (prove)\nusing this:\n  span f g\n  span ?f ?g \\<Longrightarrow>\n  seq \\<pp>\\<^sub>0[cod ?f, cod ?g] \\<langle>?f, ?g\\<rangle>\n\ngoal (1 subgoal):\n 1. local.dom \\<pp>\\<^sub>0[cod f, cod g] = cod \\<langle>f, g\\<rangle>", "by blast"], ["proof (state)\nthis:\n  local.dom \\<pp>\\<^sub>0[cod f, cod g] = cod \\<langle>f, g\\<rangle>\n\ngoal (1 subgoal):\n 1. cod \\<langle>f, g\\<rangle> = cod f \\<otimes> cod g", "finally"], ["proof (chain)\npicking this:\n  cod f \\<otimes> cod g = cod \\<langle>f, g\\<rangle>", "show ?thesis"], ["proof (prove)\nusing this:\n  cod f \\<otimes> cod g = cod \\<langle>f, g\\<rangle>\n\ngoal (1 subgoal):\n 1. cod \\<langle>f, g\\<rangle> = cod f \\<otimes> cod g", "by simp"], ["proof (state)\nthis:\n  cod \\<langle>f, g\\<rangle> = cod f \\<otimes> cod g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tuple_in_hom [intro]:\n    assumes \"\\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>\" and \"\\<guillemotleft>g : a \\<rightarrow> c\\<guillemotright>\"\n    shows \"\\<guillemotleft>\\<langle>f, g\\<rangle> : a \\<rightarrow> b \\<otimes> c\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<langle>f, g\\<rangle> : a \\<rightarrow> b \\<otimes>\n                       c\\<guillemotright>", "using assms pr_tuple dom_comp cod_tuple"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>\n  \\<guillemotleft>g : a \\<rightarrow> c\\<guillemotright>\n  \\<lbrakk>span ?f ?g; cod ?f = ?a; cod ?g = ?b\\<rbrakk>\n  \\<Longrightarrow> \\<pp>\\<^sub>1[?a, ?b] \\<cdot> \\<langle>?f, ?g\\<rangle> =\n                    ?f\n  \\<lbrakk>span ?f ?g; cod ?f = ?a; cod ?g = ?b\\<rbrakk>\n  \\<Longrightarrow> \\<pp>\\<^sub>0[?a, ?b] \\<cdot> \\<langle>?f, ?g\\<rangle> =\n                    ?g\n  seq ?g ?f \\<Longrightarrow> local.dom (?g \\<cdot> ?f) = local.dom ?f\n  span ?f ?g \\<Longrightarrow>\n  cod \\<langle>?f, ?g\\<rangle> = cod ?f \\<otimes> cod ?g\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<langle>f, g\\<rangle> : a \\<rightarrow> b \\<otimes>\n                       c\\<guillemotright>", "apply (elim in_homE, intro in_homI)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<And>f g a b.\n                \\<lbrakk>span f g; cod f = a; cod g = b\\<rbrakk>\n                \\<Longrightarrow> \\<pp>\\<^sub>1[a, b] \\<cdot>\n                                  \\<langle>f, g\\<rangle> =\n                                  f;\n     \\<And>f g a b.\n        \\<lbrakk>span f g; cod f = a; cod g = b\\<rbrakk>\n        \\<Longrightarrow> \\<pp>\\<^sub>0[a, b] \\<cdot>\n                          \\<langle>f, g\\<rangle> =\n                          g;\n     \\<And>g f.\n        seq g f \\<Longrightarrow> local.dom (g \\<cdot> f) = local.dom f;\n     \\<And>f g.\n        span f g \\<Longrightarrow>\n        cod \\<langle>f, g\\<rangle> = cod f \\<otimes> cod g;\n     arr f; local.dom f = a; cod f = b; arr g; local.dom g = a; cod g = c;\n     \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>;\n     \\<guillemotleft>g : a \\<rightarrow> c\\<guillemotright>;\n     \\<And>f g a b.\n        \\<lbrakk>span f g; cod f = a; cod g = b\\<rbrakk>\n        \\<Longrightarrow> \\<pp>\\<^sub>1[a, b] \\<cdot>\n                          \\<langle>f, g\\<rangle> =\n                          f;\n     \\<And>f g a b.\n        \\<lbrakk>span f g; cod f = a; cod g = b\\<rbrakk>\n        \\<Longrightarrow> \\<pp>\\<^sub>0[a, b] \\<cdot>\n                          \\<langle>f, g\\<rangle> =\n                          g;\n     \\<And>g f.\n        seq g f \\<Longrightarrow> local.dom (g \\<cdot> f) = local.dom f;\n     \\<And>f g.\n        span f g \\<Longrightarrow>\n        cod \\<langle>f, g\\<rangle> = cod f \\<otimes> cod g\\<rbrakk>\n    \\<Longrightarrow> arr \\<langle>f, g\\<rangle>\n 2. \\<lbrakk>\\<And>f g a b.\n                \\<lbrakk>span f g; cod f = a; cod g = b\\<rbrakk>\n                \\<Longrightarrow> \\<pp>\\<^sub>1[a, b] \\<cdot>\n                                  \\<langle>f, g\\<rangle> =\n                                  f;\n     \\<And>f g a b.\n        \\<lbrakk>span f g; cod f = a; cod g = b\\<rbrakk>\n        \\<Longrightarrow> \\<pp>\\<^sub>0[a, b] \\<cdot>\n                          \\<langle>f, g\\<rangle> =\n                          g;\n     \\<And>g f.\n        seq g f \\<Longrightarrow> local.dom (g \\<cdot> f) = local.dom f;\n     \\<And>f g.\n        span f g \\<Longrightarrow>\n        cod \\<langle>f, g\\<rangle> = cod f \\<otimes> cod g;\n     arr f; local.dom f = a; cod f = b; arr g; local.dom g = a; cod g = c;\n     \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>;\n     \\<guillemotleft>g : a \\<rightarrow> c\\<guillemotright>;\n     \\<And>f g a b.\n        \\<lbrakk>span f g; cod f = a; cod g = b\\<rbrakk>\n        \\<Longrightarrow> \\<pp>\\<^sub>1[a, b] \\<cdot>\n                          \\<langle>f, g\\<rangle> =\n                          f;\n     \\<And>f g a b.\n        \\<lbrakk>span f g; cod f = a; cod g = b\\<rbrakk>\n        \\<Longrightarrow> \\<pp>\\<^sub>0[a, b] \\<cdot>\n                          \\<langle>f, g\\<rangle> =\n                          g;\n     \\<And>g f.\n        seq g f \\<Longrightarrow> local.dom (g \\<cdot> f) = local.dom f;\n     \\<And>f g.\n        span f g \\<Longrightarrow>\n        cod \\<langle>f, g\\<rangle> = cod f \\<otimes> cod g\\<rbrakk>\n    \\<Longrightarrow> local.dom \\<langle>f, g\\<rangle> = a\n 3. \\<lbrakk>\\<And>f g a b.\n                \\<lbrakk>span f g; cod f = a; cod g = b\\<rbrakk>\n                \\<Longrightarrow> \\<pp>\\<^sub>1[a, b] \\<cdot>\n                                  \\<langle>f, g\\<rangle> =\n                                  f;\n     \\<And>f g a b.\n        \\<lbrakk>span f g; cod f = a; cod g = b\\<rbrakk>\n        \\<Longrightarrow> \\<pp>\\<^sub>0[a, b] \\<cdot>\n                          \\<langle>f, g\\<rangle> =\n                          g;\n     \\<And>g f.\n        seq g f \\<Longrightarrow> local.dom (g \\<cdot> f) = local.dom f;\n     \\<And>f g.\n        span f g \\<Longrightarrow>\n        cod \\<langle>f, g\\<rangle> = cod f \\<otimes> cod g;\n     arr f; local.dom f = a; cod f = b; arr g; local.dom g = a; cod g = c;\n     \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>;\n     \\<guillemotleft>g : a \\<rightarrow> c\\<guillemotright>;\n     \\<And>f g a b.\n        \\<lbrakk>span f g; cod f = a; cod g = b\\<rbrakk>\n        \\<Longrightarrow> \\<pp>\\<^sub>1[a, b] \\<cdot>\n                          \\<langle>f, g\\<rangle> =\n                          f;\n     \\<And>f g a b.\n        \\<lbrakk>span f g; cod f = a; cod g = b\\<rbrakk>\n        \\<Longrightarrow> \\<pp>\\<^sub>0[a, b] \\<cdot>\n                          \\<langle>f, g\\<rangle> =\n                          g;\n     \\<And>g f.\n        seq g f \\<Longrightarrow> local.dom (g \\<cdot> f) = local.dom f;\n     \\<And>f g.\n        span f g \\<Longrightarrow>\n        cod \\<langle>f, g\\<rangle> = cod f \\<otimes> cod g\\<rbrakk>\n    \\<Longrightarrow> cod \\<langle>f, g\\<rangle> = b \\<otimes> c", "apply (metis seqE)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<And>f g a b.\n                \\<lbrakk>span f g; cod f = a; cod g = b\\<rbrakk>\n                \\<Longrightarrow> \\<pp>\\<^sub>1[a, b] \\<cdot>\n                                  \\<langle>f, g\\<rangle> =\n                                  f;\n     \\<And>f g a b.\n        \\<lbrakk>span f g; cod f = a; cod g = b\\<rbrakk>\n        \\<Longrightarrow> \\<pp>\\<^sub>0[a, b] \\<cdot>\n                          \\<langle>f, g\\<rangle> =\n                          g;\n     \\<And>g f.\n        seq g f \\<Longrightarrow> local.dom (g \\<cdot> f) = local.dom f;\n     \\<And>f g.\n        span f g \\<Longrightarrow>\n        cod \\<langle>f, g\\<rangle> = cod f \\<otimes> cod g;\n     arr f; local.dom f = a; cod f = b; arr g; local.dom g = a; cod g = c;\n     \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>;\n     \\<guillemotleft>g : a \\<rightarrow> c\\<guillemotright>;\n     \\<And>f g a b.\n        \\<lbrakk>span f g; cod f = a; cod g = b\\<rbrakk>\n        \\<Longrightarrow> \\<pp>\\<^sub>1[a, b] \\<cdot>\n                          \\<langle>f, g\\<rangle> =\n                          f;\n     \\<And>f g a b.\n        \\<lbrakk>span f g; cod f = a; cod g = b\\<rbrakk>\n        \\<Longrightarrow> \\<pp>\\<^sub>0[a, b] \\<cdot>\n                          \\<langle>f, g\\<rangle> =\n                          g;\n     \\<And>g f.\n        seq g f \\<Longrightarrow> local.dom (g \\<cdot> f) = local.dom f;\n     \\<And>f g.\n        span f g \\<Longrightarrow>\n        cod \\<langle>f, g\\<rangle> = cod f \\<otimes> cod g\\<rbrakk>\n    \\<Longrightarrow> local.dom \\<langle>f, g\\<rangle> = a\n 2. \\<lbrakk>\\<And>f g a b.\n                \\<lbrakk>span f g; cod f = a; cod g = b\\<rbrakk>\n                \\<Longrightarrow> \\<pp>\\<^sub>1[a, b] \\<cdot>\n                                  \\<langle>f, g\\<rangle> =\n                                  f;\n     \\<And>f g a b.\n        \\<lbrakk>span f g; cod f = a; cod g = b\\<rbrakk>\n        \\<Longrightarrow> \\<pp>\\<^sub>0[a, b] \\<cdot>\n                          \\<langle>f, g\\<rangle> =\n                          g;\n     \\<And>g f.\n        seq g f \\<Longrightarrow> local.dom (g \\<cdot> f) = local.dom f;\n     \\<And>f g.\n        span f g \\<Longrightarrow>\n        cod \\<langle>f, g\\<rangle> = cod f \\<otimes> cod g;\n     arr f; local.dom f = a; cod f = b; arr g; local.dom g = a; cod g = c;\n     \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>;\n     \\<guillemotleft>g : a \\<rightarrow> c\\<guillemotright>;\n     \\<And>f g a b.\n        \\<lbrakk>span f g; cod f = a; cod g = b\\<rbrakk>\n        \\<Longrightarrow> \\<pp>\\<^sub>1[a, b] \\<cdot>\n                          \\<langle>f, g\\<rangle> =\n                          f;\n     \\<And>f g a b.\n        \\<lbrakk>span f g; cod f = a; cod g = b\\<rbrakk>\n        \\<Longrightarrow> \\<pp>\\<^sub>0[a, b] \\<cdot>\n                          \\<langle>f, g\\<rangle> =\n                          g;\n     \\<And>g f.\n        seq g f \\<Longrightarrow> local.dom (g \\<cdot> f) = local.dom f;\n     \\<And>f g.\n        span f g \\<Longrightarrow>\n        cod \\<langle>f, g\\<rangle> = cod f \\<otimes> cod g\\<rbrakk>\n    \\<Longrightarrow> cod \\<langle>f, g\\<rangle> = b \\<otimes> c", "by metis+"], ["", "lemma tuple_in_hom' [simp]:\n    assumes \"arr f\" and \"dom f = a\" and \"cod f = b\"\n    and \"arr g\" and \"dom g = a\" and \"cod g = c\"\n    shows \"\\<guillemotleft>\\<langle>f, g\\<rangle> : a \\<rightarrow> b \\<otimes> c\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<langle>f, g\\<rangle> : a \\<rightarrow> b \\<otimes>\n                       c\\<guillemotright>", "using assms"], ["proof (prove)\nusing this:\n  arr f\n  local.dom f = a\n  cod f = b\n  arr g\n  local.dom g = a\n  cod g = c\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<langle>f, g\\<rangle> : a \\<rightarrow> b \\<otimes>\n                       c\\<guillemotright>", "by auto"], ["", "lemma tuple_ext:\n    assumes \"\\<not> span f g\"\n    shows \"\\<langle>f, g\\<rangle> = null\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>f, g\\<rangle> = null", "unfolding tuple_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if span f g\n     then THE l.\n             \\<pp>\\<^sub>1[cod f, cod g] \\<cdot> l = f \\<and>\n             \\<pp>\\<^sub>0[cod f, cod g] \\<cdot> l = g\n     else null) =\n    null", "by (simp add: assms)"], ["", "lemma tuple_simps [simp]:\n    assumes \"span f g\"\n    shows \"arr \\<langle>f, g\\<rangle>\" and \"dom \\<langle>f, g\\<rangle> = dom f\" and \"cod \\<langle>f, g\\<rangle> = cod f \\<otimes> cod g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr \\<langle>f, g\\<rangle> &&&\n    local.dom \\<langle>f, g\\<rangle> = local.dom f &&&\n    cod \\<langle>f, g\\<rangle> = cod f \\<otimes> cod g", "proof -"], ["proof (state)\ngoal (3 subgoals):\n 1. arr \\<langle>f, g\\<rangle>\n 2. local.dom \\<langle>f, g\\<rangle> = local.dom f\n 3. cod \\<langle>f, g\\<rangle> = cod f \\<otimes> cod g", "show \"arr \\<langle>f, g\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr \\<langle>f, g\\<rangle>", "using assms tuple_in_hom"], ["proof (prove)\nusing this:\n  span f g\n  \\<lbrakk>\\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright>;\n   \\<guillemotleft>?g : ?a \\<rightarrow> ?c\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>\\<langle>?f, ?g\\<rangle> : ?a \\<rightarrow> ?b \\<otimes>\n    ?c\\<guillemotright>\n\ngoal (1 subgoal):\n 1. arr \\<langle>f, g\\<rangle>", "by blast"], ["proof (state)\nthis:\n  arr \\<langle>f, g\\<rangle>\n\ngoal (2 subgoals):\n 1. local.dom \\<langle>f, g\\<rangle> = local.dom f\n 2. cod \\<langle>f, g\\<rangle> = cod f \\<otimes> cod g", "show \"dom \\<langle>f, g\\<rangle> = dom f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dom \\<langle>f, g\\<rangle> = local.dom f", "using assms tuple_in_hom"], ["proof (prove)\nusing this:\n  span f g\n  \\<lbrakk>\\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright>;\n   \\<guillemotleft>?g : ?a \\<rightarrow> ?c\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>\\<langle>?f, ?g\\<rangle> : ?a \\<rightarrow> ?b \\<otimes>\n    ?c\\<guillemotright>\n\ngoal (1 subgoal):\n 1. local.dom \\<langle>f, g\\<rangle> = local.dom f", "by (metis dom_comp pr_tuple(1))"], ["proof (state)\nthis:\n  local.dom \\<langle>f, g\\<rangle> = local.dom f\n\ngoal (1 subgoal):\n 1. cod \\<langle>f, g\\<rangle> = cod f \\<otimes> cod g", "show \"cod \\<langle>f, g\\<rangle> = cod f \\<otimes> cod g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cod \\<langle>f, g\\<rangle> = cod f \\<otimes> cod g", "using assms cod_tuple"], ["proof (prove)\nusing this:\n  span f g\n  span ?f ?g \\<Longrightarrow>\n  cod \\<langle>?f, ?g\\<rangle> = cod ?f \\<otimes> cod ?g\n\ngoal (1 subgoal):\n 1. cod \\<langle>f, g\\<rangle> = cod f \\<otimes> cod g", "by auto"], ["proof (state)\nthis:\n  cod \\<langle>f, g\\<rangle> = cod f \\<otimes> cod g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma tuple_pr [simp]:\n    assumes \"ide a\" and \"ide b\"\n    shows \"\\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle> = a \\<otimes> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle> =\n    a \\<otimes> b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle> =\n    a \\<otimes> b", "have 1: \"dom \\<pp>\\<^sub>0[a, b] = a \\<otimes> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dom \\<pp>\\<^sub>0[a, b] = a \\<otimes> b", "using assms seq_pr_tuple cod_tuple [of \"\\<pp>\\<^sub>1[a, b]\" \"\\<pp>\\<^sub>0[a, b]\"] span_pr\n              pr0_in_hom' pr1_in_hom'"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  span ?f ?g \\<Longrightarrow>\n  seq \\<pp>\\<^sub>0[cod ?f, cod ?g] \\<langle>?f, ?g\\<rangle>\n  span \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b] \\<Longrightarrow>\n  cod \\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle> =\n  cod \\<pp>\\<^sub>1[a, b] \\<otimes> cod \\<pp>\\<^sub>0[a, b]\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> span \\<pp>\\<^sub>1[?a, ?b] \\<pp>\\<^sub>0[?a, ?b]\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>\\<pp>\\<^sub>0[?a, ?b] : local.dom\n                       \\<pp>\\<^sub>0[?a, ?b] \\<rightarrow> ?b\\<guillemotright>\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>\\<pp>\\<^sub>1[?a, ?b] : local.dom\n                       \\<pp>\\<^sub>0[?a, ?b] \\<rightarrow> ?a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. local.dom \\<pp>\\<^sub>0[a, b] = a \\<otimes> b", "by (metis cod_pr0 cod_pr1 seqE)"], ["proof (state)\nthis:\n  local.dom \\<pp>\\<^sub>0[a, b] = a \\<otimes> b\n\ngoal (1 subgoal):\n 1. \\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle> =\n    a \\<otimes> b", "hence \"\\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle> = \\<langle>\\<pp>\\<^sub>1[a, b] \\<cdot> (a \\<otimes> b), \\<pp>\\<^sub>0[a, b] \\<cdot> (a \\<otimes> b)\\<rangle>\""], ["proof (prove)\nusing this:\n  local.dom \\<pp>\\<^sub>0[a, b] = a \\<otimes> b\n\ngoal (1 subgoal):\n 1. \\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle> =\n    \\<langle>\\<pp>\\<^sub>1[a, b] \\<cdot>\n             (a \\<otimes>\n              b), \\<pp>\\<^sub>0[a, b] \\<cdot> (a \\<otimes> b)\\<rangle>", "using assms pr0_in_hom' pr1_in_hom' comp_arr_dom span_pr"], ["proof (prove)\nusing this:\n  local.dom \\<pp>\\<^sub>0[a, b] = a \\<otimes> b\n  ide a\n  ide b\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>\\<pp>\\<^sub>0[?a, ?b] : local.dom\n                       \\<pp>\\<^sub>0[?a, ?b] \\<rightarrow> ?b\\<guillemotright>\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>\\<pp>\\<^sub>1[?a, ?b] : local.dom\n                       \\<pp>\\<^sub>0[?a, ?b] \\<rightarrow> ?a\\<guillemotright>\n  \\<lbrakk>arr ?f; local.dom ?f = ?a\\<rbrakk>\n  \\<Longrightarrow> ?f \\<cdot> ?a = ?f\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> span \\<pp>\\<^sub>1[?a, ?b] \\<pp>\\<^sub>0[?a, ?b]\n\ngoal (1 subgoal):\n 1. \\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle> =\n    \\<langle>\\<pp>\\<^sub>1[a, b] \\<cdot>\n             (a \\<otimes>\n              b), \\<pp>\\<^sub>0[a, b] \\<cdot> (a \\<otimes> b)\\<rangle>", "by simp"], ["proof (state)\nthis:\n  \\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle> =\n  \\<langle>\\<pp>\\<^sub>1[a, b] \\<cdot>\n           (a \\<otimes>\n            b), \\<pp>\\<^sub>0[a, b] \\<cdot> (a \\<otimes> b)\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle> =\n    a \\<otimes> b", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle> =\n  \\<langle>\\<pp>\\<^sub>1[a, b] \\<cdot>\n           (a \\<otimes>\n            b), \\<pp>\\<^sub>0[a, b] \\<cdot> (a \\<otimes> b)\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle> =\n    a \\<otimes> b", "using assms 1 tuple_pr_arr span_pr"], ["proof (prove)\nusing this:\n  \\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle> =\n  \\<langle>\\<pp>\\<^sub>1[a, b] \\<cdot>\n           (a \\<otimes>\n            b), \\<pp>\\<^sub>0[a, b] \\<cdot> (a \\<otimes> b)\\<rangle>\n  ide a\n  ide b\n  local.dom \\<pp>\\<^sub>0[a, b] = a \\<otimes> b\n  \\<lbrakk>ide ?a; ide ?b; seq \\<pp>\\<^sub>0[?a, ?b] ?h\\<rbrakk>\n  \\<Longrightarrow> \\<langle>\\<pp>\\<^sub>1[?a, ?b] \\<cdot>\n                             ?h, \\<pp>\\<^sub>0[?a, ?b] \\<cdot> ?h\\<rangle> =\n                    ?h\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> span \\<pp>\\<^sub>1[?a, ?b] \\<pp>\\<^sub>0[?a, ?b]\n\ngoal (1 subgoal):\n 1. \\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle> =\n    a \\<otimes> b", "by (metis comp_arr_dom)"], ["proof (state)\nthis:\n  \\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle> = a \\<otimes> b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pr_in_hom [intro, simp]:\n    assumes \"ide a\" and \"ide b\"\n    shows \"\\<guillemotleft>\\<pp>\\<^sub>0[a, b] : a \\<otimes> b \\<rightarrow> b\\<guillemotright>\" and \"\\<guillemotleft>\\<pp>\\<^sub>1[a, b] : a \\<otimes> b \\<rightarrow> a\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<pp>\\<^sub>0[a, b] : a \\<otimes>\n    b \\<rightarrow> b\\<guillemotright> &&&\n    \\<guillemotleft>\\<pp>\\<^sub>1[a, b] : a \\<otimes>\n    b \\<rightarrow> a\\<guillemotright>", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<guillemotleft>\\<pp>\\<^sub>0[a, b] : a \\<otimes>\n    b \\<rightarrow> b\\<guillemotright>\n 2. \\<guillemotleft>\\<pp>\\<^sub>1[a, b] : a \\<otimes>\n    b \\<rightarrow> a\\<guillemotright>", "show 0: \"\\<guillemotleft>\\<pp>\\<^sub>0[a, b] : a \\<otimes> b \\<rightarrow> b\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<pp>\\<^sub>0[a, b] : a \\<otimes>\n    b \\<rightarrow> b\\<guillemotright>", "using assms pr0_in_hom' seq_pr_tuple [of \"\\<pp>\\<^sub>1[a, b]\" \"\\<pp>\\<^sub>0[a, b]\"]\n              cod_tuple [of \"\\<pp>\\<^sub>1[a, b]\" \"\\<pp>\\<^sub>0[a, b]\"] span_pr cod_pr0 cod_pr1"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>\\<pp>\\<^sub>0[?a, ?b] : local.dom\n                       \\<pp>\\<^sub>0[?a, ?b] \\<rightarrow> ?b\\<guillemotright>\n  span \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b] \\<Longrightarrow>\n  seq \\<pp>\\<^sub>0[cod \\<pp>\\<^sub>1[a, b], cod \\<pp>\\<^sub>0[a, b]]\n   \\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>\n  span \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b] \\<Longrightarrow>\n  cod \\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle> =\n  cod \\<pp>\\<^sub>1[a, b] \\<otimes> cod \\<pp>\\<^sub>0[a, b]\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> span \\<pp>\\<^sub>1[?a, ?b] \\<pp>\\<^sub>0[?a, ?b]\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> cod \\<pp>\\<^sub>0[?a, ?b] = ?b\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> cod \\<pp>\\<^sub>1[?a, ?b] = ?a\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<pp>\\<^sub>0[a, b] : a \\<otimes>\n    b \\<rightarrow> b\\<guillemotright>", "by (intro in_homI, auto)"], ["proof (state)\nthis:\n  \\<guillemotleft>\\<pp>\\<^sub>0[a, b] : a \\<otimes>\n  b \\<rightarrow> b\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<pp>\\<^sub>1[a, b] : a \\<otimes>\n    b \\<rightarrow> a\\<guillemotright>", "show \"\\<guillemotleft>\\<pp>\\<^sub>1[a, b] : a \\<otimes> b \\<rightarrow> a\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<pp>\\<^sub>1[a, b] : a \\<otimes>\n    b \\<rightarrow> a\\<guillemotright>", "using assms 0 span_pr pr1_in_hom'"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  \\<guillemotleft>\\<pp>\\<^sub>0[a, b] : a \\<otimes>\n  b \\<rightarrow> b\\<guillemotright>\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> span \\<pp>\\<^sub>1[?a, ?b] \\<pp>\\<^sub>0[?a, ?b]\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>\\<pp>\\<^sub>1[?a, ?b] : local.dom\n                       \\<pp>\\<^sub>0[?a, ?b] \\<rightarrow> ?a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<pp>\\<^sub>1[a, b] : a \\<otimes>\n    b \\<rightarrow> a\\<guillemotright>", "by fastforce"], ["proof (state)\nthis:\n  \\<guillemotleft>\\<pp>\\<^sub>1[a, b] : a \\<otimes>\n  b \\<rightarrow> a\\<guillemotright>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pr_simps [simp]:\n    assumes \"ide a\" and \"ide b\"\n    shows \"arr \\<pp>\\<^sub>0[a, b]\" and \"dom \\<pp>\\<^sub>0[a, b] = a \\<otimes> b\" and \"cod \\<pp>\\<^sub>0[a, b] = b\"\n    and \"arr \\<pp>\\<^sub>1[a, b]\" and \"dom \\<pp>\\<^sub>1[a, b] = a \\<otimes> b\" and \"cod \\<pp>\\<^sub>1[a, b] = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (arr \\<pp>\\<^sub>0[a, b] &&&\n     local.dom \\<pp>\\<^sub>0[a, b] = a \\<otimes> b &&&\n     cod \\<pp>\\<^sub>0[a, b] = b) &&&\n    arr \\<pp>\\<^sub>1[a, b] &&&\n    local.dom \\<pp>\\<^sub>1[a, b] = a \\<otimes> b &&&\n    cod \\<pp>\\<^sub>1[a, b] = a", "using assms pr_in_hom"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>\\<pp>\\<^sub>0[?a, ?b] : ?a \\<otimes>\n                      ?b \\<rightarrow> ?b\\<guillemotright>\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>\\<pp>\\<^sub>1[?a, ?b] : ?a \\<otimes>\n                      ?b \\<rightarrow> ?a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. (arr \\<pp>\\<^sub>0[a, b] &&&\n     local.dom \\<pp>\\<^sub>0[a, b] = a \\<otimes> b &&&\n     cod \\<pp>\\<^sub>0[a, b] = b) &&&\n    arr \\<pp>\\<^sub>1[a, b] &&&\n    local.dom \\<pp>\\<^sub>1[a, b] = a \\<otimes> b &&&\n    cod \\<pp>\\<^sub>1[a, b] = a", "by blast+"], ["", "lemma arr_pr0_iff [iff]:\n    shows \"arr \\<pp>\\<^sub>0[a, b] \\<longleftrightarrow> ide a \\<and> ide b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr \\<pp>\\<^sub>0[a, b] = (ide a \\<and> ide b)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. arr \\<pp>\\<^sub>0[a, b] \\<Longrightarrow> ide a \\<and> ide b\n 2. ide a \\<and> ide b \\<Longrightarrow> arr \\<pp>\\<^sub>0[a, b]", "show \"ide a \\<and> ide b \\<Longrightarrow> arr \\<pp>\\<^sub>0[a, b]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide a \\<and> ide b \\<Longrightarrow> arr \\<pp>\\<^sub>0[a, b]", "using pr_in_hom"], ["proof (prove)\nusing this:\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>\\<pp>\\<^sub>0[?a, ?b] : ?a \\<otimes>\n                      ?b \\<rightarrow> ?b\\<guillemotright>\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>\\<pp>\\<^sub>1[?a, ?b] : ?a \\<otimes>\n                      ?b \\<rightarrow> ?a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. ide a \\<and> ide b \\<Longrightarrow> arr \\<pp>\\<^sub>0[a, b]", "by auto"], ["proof (state)\nthis:\n  ide a \\<and> ide b \\<Longrightarrow> arr \\<pp>\\<^sub>0[a, b]\n\ngoal (1 subgoal):\n 1. arr \\<pp>\\<^sub>0[a, b] \\<Longrightarrow> ide a \\<and> ide b", "show \"arr \\<pp>\\<^sub>0[a, b] \\<Longrightarrow> ide a \\<and> ide b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr \\<pp>\\<^sub>0[a, b] \\<Longrightarrow> ide a \\<and> ide b", "using pr0_ext not_arr_null"], ["proof (prove)\nusing this:\n  \\<not> (ide ?a \\<and> ide ?b) \\<Longrightarrow>\n  \\<pp>\\<^sub>0[?a, ?b] = null\n  \\<not> arr null\n\ngoal (1 subgoal):\n 1. arr \\<pp>\\<^sub>0[a, b] \\<Longrightarrow> ide a \\<and> ide b", "by metis"], ["proof (state)\nthis:\n  arr \\<pp>\\<^sub>0[a, b] \\<Longrightarrow> ide a \\<and> ide b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma arr_pr1_iff [iff]:\n    shows \"arr \\<pp>\\<^sub>1[a, b] \\<longleftrightarrow> ide a \\<and> ide b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr \\<pp>\\<^sub>1[a, b] = (ide a \\<and> ide b)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. arr \\<pp>\\<^sub>1[a, b] \\<Longrightarrow> ide a \\<and> ide b\n 2. ide a \\<and> ide b \\<Longrightarrow> arr \\<pp>\\<^sub>1[a, b]", "show \"ide a \\<and> ide b \\<Longrightarrow> arr \\<pp>\\<^sub>1[a, b]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide a \\<and> ide b \\<Longrightarrow> arr \\<pp>\\<^sub>1[a, b]", "using pr_in_hom"], ["proof (prove)\nusing this:\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>\\<pp>\\<^sub>0[?a, ?b] : ?a \\<otimes>\n                      ?b \\<rightarrow> ?b\\<guillemotright>\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>\\<pp>\\<^sub>1[?a, ?b] : ?a \\<otimes>\n                      ?b \\<rightarrow> ?a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. ide a \\<and> ide b \\<Longrightarrow> arr \\<pp>\\<^sub>1[a, b]", "by auto"], ["proof (state)\nthis:\n  ide a \\<and> ide b \\<Longrightarrow> arr \\<pp>\\<^sub>1[a, b]\n\ngoal (1 subgoal):\n 1. arr \\<pp>\\<^sub>1[a, b] \\<Longrightarrow> ide a \\<and> ide b", "show \"arr \\<pp>\\<^sub>1[a, b] \\<Longrightarrow> ide a \\<and> ide b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr \\<pp>\\<^sub>1[a, b] \\<Longrightarrow> ide a \\<and> ide b", "using pr1_ext not_arr_null"], ["proof (prove)\nusing this:\n  \\<not> (ide ?a \\<and> ide ?b) \\<Longrightarrow>\n  \\<pp>\\<^sub>1[?a, ?b] = null\n  \\<not> arr null\n\ngoal (1 subgoal):\n 1. arr \\<pp>\\<^sub>1[a, b] \\<Longrightarrow> ide a \\<and> ide b", "by metis"], ["proof (state)\nthis:\n  arr \\<pp>\\<^sub>1[a, b] \\<Longrightarrow> ide a \\<and> ide b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pr_joint_monic:\n    assumes \"seq \\<pp>\\<^sub>0[a, b] h\"\n    and \"\\<pp>\\<^sub>0[a, b] \\<cdot> h = \\<pp>\\<^sub>0[a, b] \\<cdot> h'\" and \"\\<pp>\\<^sub>1[a, b] \\<cdot> h = \\<pp>\\<^sub>1[a, b] \\<cdot> h'\"\n    shows \"h = h'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h = h'", "using assms"], ["proof (prove)\nusing this:\n  seq \\<pp>\\<^sub>0[a, b] h\n  \\<pp>\\<^sub>0[a, b] \\<cdot> h = \\<pp>\\<^sub>0[a, b] \\<cdot> h'\n  \\<pp>\\<^sub>1[a, b] \\<cdot> h = \\<pp>\\<^sub>1[a, b] \\<cdot> h'\n\ngoal (1 subgoal):\n 1. h = h'", "by (metis arr_pr0_iff seqE tuple_pr_arr)"], ["", "lemma comp_tuple_arr [simp]:\n    assumes \"span f g\" and \"arr h\" and \"dom f = cod h\"\n    shows \"\\<langle>f, g\\<rangle> \\<cdot> h = \\<langle>f \\<cdot> h, g \\<cdot> h\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>f, g\\<rangle> \\<cdot> h =\n    \\<langle>f \\<cdot> h, g \\<cdot> h\\<rangle>", "proof (intro pr_joint_monic [where h = \"\\<langle>f, g\\<rangle> \\<cdot> h\"])"], ["proof (state)\ngoal (3 subgoals):\n 1. seq \\<pp>\\<^sub>0[?a, ?b] (\\<langle>f, g\\<rangle> \\<cdot> h)\n 2. \\<pp>\\<^sub>0[?a, ?b] \\<cdot> \\<langle>f, g\\<rangle> \\<cdot> h =\n    \\<pp>\\<^sub>0[?a, ?b] \\<cdot> \\<langle>f \\<cdot> h, g \\<cdot> h\\<rangle>\n 3. \\<pp>\\<^sub>1[?a, ?b] \\<cdot> \\<langle>f, g\\<rangle> \\<cdot> h =\n    \\<pp>\\<^sub>1[?a, ?b] \\<cdot> \\<langle>f \\<cdot> h, g \\<cdot> h\\<rangle>", "show \"seq \\<pp>\\<^sub>0[cod f, cod g] (\\<langle>f, g\\<rangle> \\<cdot> h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq \\<pp>\\<^sub>0[cod f, cod g] (\\<langle>f, g\\<rangle> \\<cdot> h)", "using assms"], ["proof (prove)\nusing this:\n  span f g\n  arr h\n  local.dom f = cod h\n\ngoal (1 subgoal):\n 1. seq \\<pp>\\<^sub>0[cod f, cod g] (\\<langle>f, g\\<rangle> \\<cdot> h)", "by fastforce"], ["proof (state)\nthis:\n  seq \\<pp>\\<^sub>0[cod f, cod g] (\\<langle>f, g\\<rangle> \\<cdot> h)\n\ngoal (2 subgoals):\n 1. \\<pp>\\<^sub>0[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle> \\<cdot> h =\n    \\<pp>\\<^sub>0[cod f, cod g] \\<cdot>\n    \\<langle>f \\<cdot> h, g \\<cdot> h\\<rangle>\n 2. \\<pp>\\<^sub>1[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle> \\<cdot> h =\n    \\<pp>\\<^sub>1[cod f, cod g] \\<cdot>\n    \\<langle>f \\<cdot> h, g \\<cdot> h\\<rangle>", "show \"\\<pp>\\<^sub>0[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle> \\<cdot> h = \\<pp>\\<^sub>0[cod f, cod g] \\<cdot> \\<langle>f \\<cdot> h, g \\<cdot> h\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle> \\<cdot> h =\n    \\<pp>\\<^sub>0[cod f, cod g] \\<cdot>\n    \\<langle>f \\<cdot> h, g \\<cdot> h\\<rangle>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle> \\<cdot> h =\n    \\<pp>\\<^sub>0[cod f, cod g] \\<cdot>\n    \\<langle>f \\<cdot> h, g \\<cdot> h\\<rangle>", "have \"\\<pp>\\<^sub>0[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle> \\<cdot> h = (\\<pp>\\<^sub>0[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle>) \\<cdot> h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle> \\<cdot> h =\n    (\\<pp>\\<^sub>0[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle>) \\<cdot> h", "using comp_assoc"], ["proof (prove)\nusing this:\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle> \\<cdot> h =\n    (\\<pp>\\<^sub>0[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle>) \\<cdot> h", "by simp"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>0[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle> \\<cdot> h =\n  (\\<pp>\\<^sub>0[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle>) \\<cdot> h\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle> \\<cdot> h =\n    \\<pp>\\<^sub>0[cod f, cod g] \\<cdot>\n    \\<langle>f \\<cdot> h, g \\<cdot> h\\<rangle>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<pp>\\<^sub>0[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle> \\<cdot> h =\n  (\\<pp>\\<^sub>0[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle>) \\<cdot> h\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle> \\<cdot> h =\n    \\<pp>\\<^sub>0[cod f, cod g] \\<cdot>\n    \\<langle>f \\<cdot> h, g \\<cdot> h\\<rangle>", "using assms"], ["proof (prove)\nusing this:\n  \\<pp>\\<^sub>0[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle> \\<cdot> h =\n  (\\<pp>\\<^sub>0[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle>) \\<cdot> h\n  span f g\n  arr h\n  local.dom f = cod h\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle> \\<cdot> h =\n    \\<pp>\\<^sub>0[cod f, cod g] \\<cdot>\n    \\<langle>f \\<cdot> h, g \\<cdot> h\\<rangle>", "by simp"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>0[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle> \\<cdot> h =\n  \\<pp>\\<^sub>0[cod f, cod g] \\<cdot>\n  \\<langle>f \\<cdot> h, g \\<cdot> h\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>0[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle> \\<cdot> h =\n  \\<pp>\\<^sub>0[cod f, cod g] \\<cdot>\n  \\<langle>f \\<cdot> h, g \\<cdot> h\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle> \\<cdot> h =\n    \\<pp>\\<^sub>1[cod f, cod g] \\<cdot>\n    \\<langle>f \\<cdot> h, g \\<cdot> h\\<rangle>", "show \"\\<pp>\\<^sub>1[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle> \\<cdot> h = \\<pp>\\<^sub>1[cod f, cod g] \\<cdot> \\<langle>f \\<cdot> h, g \\<cdot> h\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle> \\<cdot> h =\n    \\<pp>\\<^sub>1[cod f, cod g] \\<cdot>\n    \\<langle>f \\<cdot> h, g \\<cdot> h\\<rangle>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle> \\<cdot> h =\n    \\<pp>\\<^sub>1[cod f, cod g] \\<cdot>\n    \\<langle>f \\<cdot> h, g \\<cdot> h\\<rangle>", "have \"\\<pp>\\<^sub>1[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle> \\<cdot> h = (\\<pp>\\<^sub>1[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle>) \\<cdot> h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle> \\<cdot> h =\n    (\\<pp>\\<^sub>1[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle>) \\<cdot> h", "using comp_assoc"], ["proof (prove)\nusing this:\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle> \\<cdot> h =\n    (\\<pp>\\<^sub>1[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle>) \\<cdot> h", "by simp"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>1[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle> \\<cdot> h =\n  (\\<pp>\\<^sub>1[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle>) \\<cdot> h\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle> \\<cdot> h =\n    \\<pp>\\<^sub>1[cod f, cod g] \\<cdot>\n    \\<langle>f \\<cdot> h, g \\<cdot> h\\<rangle>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<pp>\\<^sub>1[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle> \\<cdot> h =\n  (\\<pp>\\<^sub>1[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle>) \\<cdot> h\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle> \\<cdot> h =\n    \\<pp>\\<^sub>1[cod f, cod g] \\<cdot>\n    \\<langle>f \\<cdot> h, g \\<cdot> h\\<rangle>", "using assms"], ["proof (prove)\nusing this:\n  \\<pp>\\<^sub>1[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle> \\<cdot> h =\n  (\\<pp>\\<^sub>1[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle>) \\<cdot> h\n  span f g\n  arr h\n  local.dom f = cod h\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle> \\<cdot> h =\n    \\<pp>\\<^sub>1[cod f, cod g] \\<cdot>\n    \\<langle>f \\<cdot> h, g \\<cdot> h\\<rangle>", "by simp"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>1[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle> \\<cdot> h =\n  \\<pp>\\<^sub>1[cod f, cod g] \\<cdot>\n  \\<langle>f \\<cdot> h, g \\<cdot> h\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>1[cod f, cod g] \\<cdot> \\<langle>f, g\\<rangle> \\<cdot> h =\n  \\<pp>\\<^sub>1[cod f, cod g] \\<cdot>\n  \\<langle>f \\<cdot> h, g \\<cdot> h\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma ide_prod [intro, simp]:\n    assumes \"ide a\" and \"ide b\"\n    shows \"ide (a \\<otimes> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide (a \\<otimes> b)", "using assms pr_simps ide_dom [of \"\\<pp>\\<^sub>0[a, b]\"]"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> arr \\<pp>\\<^sub>0[?a, ?b]\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> local.dom \\<pp>\\<^sub>0[?a, ?b] = ?a \\<otimes> ?b\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> cod \\<pp>\\<^sub>0[?a, ?b] = ?b\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> arr \\<pp>\\<^sub>1[?a, ?b]\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> local.dom \\<pp>\\<^sub>1[?a, ?b] = ?a \\<otimes> ?b\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> cod \\<pp>\\<^sub>1[?a, ?b] = ?a\n  arr \\<pp>\\<^sub>0[a, b] \\<Longrightarrow>\n  ide (local.dom \\<pp>\\<^sub>0[a, b])\n\ngoal (1 subgoal):\n 1. ide (a \\<otimes> b)", "by simp"], ["", "lemma prod_in_hom [intro]:\n    assumes \"\\<guillemotleft>f : a \\<rightarrow> c\\<guillemotright>\" and \"\\<guillemotleft>g : b \\<rightarrow> d\\<guillemotright>\"\n    shows \"\\<guillemotleft>f \\<otimes> g : a \\<otimes> b \\<rightarrow> c \\<otimes> d\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>f \\<otimes>\n                    g : a \\<otimes>\n                        b \\<rightarrow> c \\<otimes> d\\<guillemotright>", "using assms prod_def"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f : a \\<rightarrow> c\\<guillemotright>\n  \\<guillemotleft>g : b \\<rightarrow> d\\<guillemotright>\n  ?f \\<otimes> ?g \\<equiv>\n  \\<langle>?f \\<cdot>\n           \\<pp>\\<^sub>1[local.dom\n                          ?f, local.dom\n                               ?g], ?g \\<cdot>\n                                    \\<pp>\\<^sub>0[local.dom\n             ?f, local.dom ?g]\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>f \\<otimes>\n                    g : a \\<otimes>\n                        b \\<rightarrow> c \\<otimes> d\\<guillemotright>", "by fastforce"], ["", "lemma prod_in_hom' [simp]:\n    assumes \"arr f\" and \"dom f = a\" and \"cod f = c\"\n    and \"arr g\" and \"dom g = b\" and \"cod g = d\"\n    shows \"\\<guillemotleft>f \\<otimes> g : a \\<otimes> b \\<rightarrow> c \\<otimes> d\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>f \\<otimes>\n                    g : a \\<otimes>\n                        b \\<rightarrow> c \\<otimes> d\\<guillemotright>", "using assms"], ["proof (prove)\nusing this:\n  arr f\n  local.dom f = a\n  cod f = c\n  arr g\n  local.dom g = b\n  cod g = d\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>f \\<otimes>\n                    g : a \\<otimes>\n                        b \\<rightarrow> c \\<otimes> d\\<guillemotright>", "by blast"], ["", "lemma prod_simps [simp]:\n    assumes \"arr f0\" and \"arr f1\"\n    shows \"arr (f0 \\<otimes> f1)\"\n    and \"dom (f0 \\<otimes> f1) = dom f0 \\<otimes> dom f1\"\n    and \"cod (f0 \\<otimes> f1) = cod f0 \\<otimes> cod f1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (f0 \\<otimes> f1) &&&\n    local.dom (f0 \\<otimes> f1) = local.dom f0 \\<otimes> local.dom f1 &&&\n    cod (f0 \\<otimes> f1) = cod f0 \\<otimes> cod f1", "using assms prod_in_hom"], ["proof (prove)\nusing this:\n  arr f0\n  arr f1\n  \\<lbrakk>\\<guillemotleft>?f : ?a \\<rightarrow> ?c\\<guillemotright>;\n   \\<guillemotleft>?g : ?b \\<rightarrow> ?d\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>?f \\<otimes>\n                                    ?g : ?a \\<otimes>\n   ?b \\<rightarrow> ?c \\<otimes> ?d\\<guillemotright>\n\ngoal (1 subgoal):\n 1. arr (f0 \\<otimes> f1) &&&\n    local.dom (f0 \\<otimes> f1) = local.dom f0 \\<otimes> local.dom f1 &&&\n    cod (f0 \\<otimes> f1) = cod f0 \\<otimes> cod f1", "by blast+"], ["", "end"], ["", "subsection \"Agreement between the Definitions\""], ["", "text \\<open>\n    We now show that a category with binary products extends (by making a choice)\n    to an elementary category with binary products, and that the underlying category\n    of an elementary category with binary products is a category with binary products.\n  \\<close>"], ["", "context category_with_binary_products\n  begin"], ["", "definition pr1\n    where \"pr1 a b \\<equiv> if ide a \\<and> ide b then\n                        fst (SOME x. has_as_binary_product a b (fst x) (snd x))\n                      else null\""], ["", "definition pr0\n    where \"pr0 a b \\<equiv> if ide a \\<and> ide b then\n                        snd (SOME x. has_as_binary_product a b (fst x) (snd x))\n                      else null\""], ["", "lemma pr_yields_binary_product:\n    assumes \"ide a\" and \"ide b\"\n    shows \"has_as_binary_product a b (pr1 a b) (pr0 a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_as_binary_product a b (pr1 a b) (pr0 a b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. has_as_binary_product a b (pr1 a b) (pr0 a b)", "have \"\\<exists>x. has_as_binary_product a b (fst x) (snd x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. has_as_binary_product a b (fst x) (snd x)", "using assms has_binary_products has_binary_products_def has_as_binary_product_def"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  has_binary_products\n  has_binary_products =\n  (\\<forall>a0 a1.\n      ide a0 \\<and> ide a1 \\<longrightarrow>\n      (\\<exists>p0 p1. has_as_binary_product a0 a1 p0 p1))\n  has_as_binary_product ?a0.0 ?a1.0 ?p0.0 ?p1.0 \\<equiv>\n  ide ?a0.0 \\<and>\n  ide ?a1.0 \\<and>\n  limit_cone\n   (concrete_category.COMP UNIV (\\<lambda>a b. if a = b then {()} else {})\n     (\\<lambda>_ _ _ _ _. ()))\n   (\\<cdot>) (binary_product_diagram.map (\\<cdot>) ?a0.0 ?a1.0)\n   (local.dom ?p0.0) (binary_product_diagram.mkCone (\\<cdot>) ?p0.0 ?p1.0)\n\ngoal (1 subgoal):\n 1. \\<exists>x. has_as_binary_product a b (fst x) (snd x)", "by simp"], ["proof (state)\nthis:\n  \\<exists>x. has_as_binary_product a b (fst x) (snd x)\n\ngoal (1 subgoal):\n 1. has_as_binary_product a b (pr1 a b) (pr0 a b)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>x. has_as_binary_product a b (fst x) (snd x)\n\ngoal (1 subgoal):\n 1. has_as_binary_product a b (pr1 a b) (pr0 a b)", "using assms has_binary_products has_binary_products_def pr0_def pr1_def\n              someI_ex [of \"\\<lambda>x. has_as_binary_product a b (fst x) (snd x)\"]"], ["proof (prove)\nusing this:\n  \\<exists>x. has_as_binary_product a b (fst x) (snd x)\n  ide a\n  ide b\n  has_binary_products\n  has_binary_products =\n  (\\<forall>a0 a1.\n      ide a0 \\<and> ide a1 \\<longrightarrow>\n      (\\<exists>p0 p1. has_as_binary_product a0 a1 p0 p1))\n  pr0 ?a ?b \\<equiv>\n  if ide ?a \\<and> ide ?b\n  then snd (SOME x. has_as_binary_product ?a ?b (fst x) (snd x)) else null\n  pr1 ?a ?b \\<equiv>\n  if ide ?a \\<and> ide ?b\n  then fst (SOME x. has_as_binary_product ?a ?b (fst x) (snd x)) else null\n  \\<exists>x. has_as_binary_product a b (fst x) (snd x) \\<Longrightarrow>\n  has_as_binary_product a b\n   (fst (SOME x. has_as_binary_product a b (fst x) (snd x)))\n   (snd (SOME x. has_as_binary_product a b (fst x) (snd x)))\n\ngoal (1 subgoal):\n 1. has_as_binary_product a b (pr1 a b) (pr0 a b)", "by simp"], ["proof (state)\nthis:\n  has_as_binary_product a b (pr1 a b) (pr0 a b)\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation elementary_category_with_binary_products C pr0 pr1"], ["proof (prove)\ngoal (1 subgoal):\n 1. elementary_category_with_binary_products (\\<cdot>) pr0 pr1", "proof"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>a b. \\<not> (ide a \\<and> ide b) \\<Longrightarrow> pr0 a b = null\n 2. \\<And>a b. \\<not> (ide a \\<and> ide b) \\<Longrightarrow> pr1 a b = null\n 3. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> span (pr1 a b) (pr0 a b)\n 4. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk> \\<Longrightarrow> cod (pr0 a b) = b\n 5. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk> \\<Longrightarrow> cod (pr1 a b) = a\n 6. \\<And>f g.\n       span f g \\<Longrightarrow>\n       \\<exists>!l.\n          pr1 (cod f) (cod g) \\<cdot> l = f \\<and>\n          pr0 (cod f) (cod g) \\<cdot> l = g", "show \"\\<And>a b. \\<not> (ide a \\<and> ide b) \\<Longrightarrow> pr0 a b = null\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b. \\<not> (ide a \\<and> ide b) \\<Longrightarrow> pr0 a b = null", "using pr0_def"], ["proof (prove)\nusing this:\n  pr0 ?a ?b \\<equiv>\n  if ide ?a \\<and> ide ?b\n  then snd (SOME x. has_as_binary_product ?a ?b (fst x) (snd x)) else null\n\ngoal (1 subgoal):\n 1. \\<And>a b. \\<not> (ide a \\<and> ide b) \\<Longrightarrow> pr0 a b = null", "by auto"], ["proof (state)\nthis:\n  \\<not> (ide ?a4 \\<and> ide ?b4) \\<Longrightarrow> pr0 ?a4 ?b4 = null\n\ngoal (5 subgoals):\n 1. \\<And>a b. \\<not> (ide a \\<and> ide b) \\<Longrightarrow> pr1 a b = null\n 2. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> span (pr1 a b) (pr0 a b)\n 3. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk> \\<Longrightarrow> cod (pr0 a b) = b\n 4. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk> \\<Longrightarrow> cod (pr1 a b) = a\n 5. \\<And>f g.\n       span f g \\<Longrightarrow>\n       \\<exists>!l.\n          pr1 (cod f) (cod g) \\<cdot> l = f \\<and>\n          pr0 (cod f) (cod g) \\<cdot> l = g", "show \"\\<And>a b. \\<not> (ide a \\<and> ide b) \\<Longrightarrow> pr1 a b = null\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b. \\<not> (ide a \\<and> ide b) \\<Longrightarrow> pr1 a b = null", "using pr1_def"], ["proof (prove)\nusing this:\n  pr1 ?a ?b \\<equiv>\n  if ide ?a \\<and> ide ?b\n  then fst (SOME x. has_as_binary_product ?a ?b (fst x) (snd x)) else null\n\ngoal (1 subgoal):\n 1. \\<And>a b. \\<not> (ide a \\<and> ide b) \\<Longrightarrow> pr1 a b = null", "by auto"], ["proof (state)\nthis:\n  \\<not> (ide ?a4 \\<and> ide ?b4) \\<Longrightarrow> pr1 ?a4 ?b4 = null\n\ngoal (4 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> span (pr1 a b) (pr0 a b)\n 2. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk> \\<Longrightarrow> cod (pr0 a b) = b\n 3. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk> \\<Longrightarrow> cod (pr1 a b) = a\n 4. \\<And>f g.\n       span f g \\<Longrightarrow>\n       \\<exists>!l.\n          pr1 (cod f) (cod g) \\<cdot> l = f \\<and>\n          pr0 (cod f) (cod g) \\<cdot> l = g", "fix a b"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> span (pr1 a b) (pr0 a b)\n 2. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk> \\<Longrightarrow> cod (pr0 a b) = b\n 3. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk> \\<Longrightarrow> cod (pr1 a b) = a\n 4. \\<And>f g.\n       span f g \\<Longrightarrow>\n       \\<exists>!l.\n          pr1 (cod f) (cod g) \\<cdot> l = f \\<and>\n          pr0 (cod f) (cod g) \\<cdot> l = g", "assume a: \"ide a\" and b: \"ide b\""], ["proof (state)\nthis:\n  ide a\n  ide b\n\ngoal (4 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> span (pr1 a b) (pr0 a b)\n 2. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk> \\<Longrightarrow> cod (pr0 a b) = b\n 3. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk> \\<Longrightarrow> cod (pr1 a b) = a\n 4. \\<And>f g.\n       span f g \\<Longrightarrow>\n       \\<exists>!l.\n          pr1 (cod f) (cod g) \\<cdot> l = f \\<and>\n          pr0 (cod f) (cod g) \\<cdot> l = g", "interpret J: binary_product_shape"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> span (pr1 a b) (pr0 a b)\n 2. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk> \\<Longrightarrow> cod (pr0 a b) = b\n 3. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk> \\<Longrightarrow> cod (pr1 a b) = a\n 4. \\<And>f g.\n       span f g \\<Longrightarrow>\n       \\<exists>!l.\n          pr1 (cod f) (cod g) \\<cdot> l = f \\<and>\n          pr0 (cod f) (cod g) \\<cdot> l = g", "interpret D: binary_product_diagram C a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. binary_product_diagram (\\<cdot>) a b", "using a b"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n\ngoal (1 subgoal):\n 1. binary_product_diagram (\\<cdot>) a b", "by unfold_locales auto"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> span (pr1 a b) (pr0 a b)\n 2. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk> \\<Longrightarrow> cod (pr0 a b) = b\n 3. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk> \\<Longrightarrow> cod (pr1 a b) = a\n 4. \\<And>f g.\n       span f g \\<Longrightarrow>\n       \\<exists>!l.\n          pr1 (cod f) (cod g) \\<cdot> l = f \\<and>\n          pr0 (cod f) (cod g) \\<cdot> l = g", "let ?\\<chi> = \"D.mkCone (pr1 a b) (pr0 a b)\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> span (pr1 a b) (pr0 a b)\n 2. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk> \\<Longrightarrow> cod (pr0 a b) = b\n 3. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk> \\<Longrightarrow> cod (pr1 a b) = a\n 4. \\<And>f g.\n       span f g \\<Longrightarrow>\n       \\<exists>!l.\n          pr1 (cod f) (cod g) \\<cdot> l = f \\<and>\n          pr0 (cod f) (cod g) \\<cdot> l = g", "interpret \\<chi>: limit_cone J.comp C D.map \\<open>dom (pr1 a b)\\<close> ?\\<chi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. D.has_as_binary_product (pr1 a b) (pr0 a b)", "using a b pr_yields_binary_product"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> has_as_binary_product ?a ?b (pr1 ?a ?b) (pr0 ?a ?b)\n\ngoal (1 subgoal):\n 1. D.has_as_binary_product (pr1 a b) (pr0 a b)", "by (simp add: has_as_binary_product_def)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> span (pr1 a b) (pr0 a b)\n 2. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk> \\<Longrightarrow> cod (pr0 a b) = b\n 3. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk> \\<Longrightarrow> cod (pr1 a b) = a\n 4. \\<And>f g.\n       span f g \\<Longrightarrow>\n       \\<exists>!l.\n          pr1 (cod f) (cod g) \\<cdot> l = f \\<and>\n          pr0 (cod f) (cod g) \\<cdot> l = g", "have 1: \"pr1 a b = ?\\<chi> J.FF \\<and> pr0 a b = ?\\<chi> J.TT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pr1 a b = D.mkCone (pr1 a b) (pr0 a b) (J.MkIde False) \\<and>\n    pr0 a b = D.mkCone (pr1 a b) (pr0 a b) (J.MkIde True)", "using D.mkCone_def"], ["proof (prove)\nusing this:\n  D.mkCone ?p0.0 ?p1.0 \\<equiv>\n  \\<lambda>j.\n     if j = J.MkIde False then ?p0.0\n     else if j = J.MkIde True then ?p1.0 else null\n\ngoal (1 subgoal):\n 1. pr1 a b = D.mkCone (pr1 a b) (pr0 a b) (J.MkIde False) \\<and>\n    pr0 a b = D.mkCone (pr1 a b) (pr0 a b) (J.MkIde True)", "by simp"], ["proof (state)\nthis:\n  pr1 a b = D.mkCone (pr1 a b) (pr0 a b) (J.MkIde False) \\<and>\n  pr0 a b = D.mkCone (pr1 a b) (pr0 a b) (J.MkIde True)\n\ngoal (4 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk>\n       \\<Longrightarrow> span (pr1 a b) (pr0 a b)\n 2. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk> \\<Longrightarrow> cod (pr0 a b) = b\n 3. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk> \\<Longrightarrow> cod (pr1 a b) = a\n 4. \\<And>f g.\n       span f g \\<Longrightarrow>\n       \\<exists>!l.\n          pr1 (cod f) (cod g) \\<cdot> l = f \\<and>\n          pr0 (cod f) (cod g) \\<cdot> l = g", "show \"span (pr1 a b) (pr0 a b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. span (pr1 a b) (pr0 a b)", "using 1 \\<chi>.preserves_reflects_arr J.seqE J.arr_char J.seq_char J.is_category\n              D.is_rendered_commutative_by_cone \\<chi>.cone_axioms"], ["proof (prove)\nusing this:\n  pr1 a b = D.mkCone (pr1 a b) (pr0 a b) (J.MkIde False) \\<and>\n  pr0 a b = D.mkCone (pr1 a b) (pr0 a b) (J.MkIde True)\n  arr (D.mkCone (pr1 a b) (pr0 a b) ?f) = J.arr ?f\n  \\<lbrakk>J.seq ?g ?f;\n   \\<lbrakk>J.arr ?f; J.arr ?g; J.dom ?g = J.cod ?f\\<rbrakk>\n   \\<Longrightarrow> ?T\\<rbrakk>\n  \\<Longrightarrow> ?T\n  J.arr ?f = (?f = J.MkIde False \\<or> ?f = J.MkIde True)\n  J.seq ?f ?g = (J.arr ?f \\<and> ?f = ?g)\n  category J.COMP\n  D.cone ?a ?\\<chi> \\<Longrightarrow>\n  D.is_rendered_commutative_by (?\\<chi> (J.MkIde False))\n   (?\\<chi> (J.MkIde True))\n  D.cone (local.dom (pr1 a b)) (D.mkCone (pr1 a b) (pr0 a b))\n\ngoal (1 subgoal):\n 1. span (pr1 a b) (pr0 a b)", "by metis"], ["proof (state)\nthis:\n  span (pr1 a b) (pr0 a b)\n\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk> \\<Longrightarrow> cod (pr0 a b) = b\n 2. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk> \\<Longrightarrow> cod (pr1 a b) = a\n 3. \\<And>f g.\n       span f g \\<Longrightarrow>\n       \\<exists>!l.\n          pr1 (cod f) (cod g) \\<cdot> l = f \\<and>\n          pr0 (cod f) (cod g) \\<cdot> l = g", "show \"cod (pr1 a b) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cod (pr1 a b) = a", "using 1 \\<chi>.preserves_cod [of J.FF] J.cod_char J.arr_char"], ["proof (prove)\nusing this:\n  pr1 a b = D.mkCone (pr1 a b) (pr0 a b) (J.MkIde False) \\<and>\n  pr0 a b = D.mkCone (pr1 a b) (pr0 a b) (J.MkIde True)\n  J.arr (J.MkIde False) \\<Longrightarrow>\n  cod (D.mkCone (pr1 a b) (pr0 a b) (J.MkIde False)) =\n  D.map (J.cod (J.MkIde False))\n  J.cod ?f =\n  (if J.arr ?f then J.MkIde (\\<chi>.\\<Phi>.Ya.Cop_S.Cod ?f) else J.null)\n  J.arr ?f = (?f = J.MkIde False \\<or> ?f = J.MkIde True)\n\ngoal (1 subgoal):\n 1. cod (pr1 a b) = a", "by auto"], ["proof (state)\nthis:\n  cod (pr1 a b) = a\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b\\<rbrakk> \\<Longrightarrow> cod (pr0 a b) = b\n 2. \\<And>f g.\n       span f g \\<Longrightarrow>\n       \\<exists>!l.\n          pr1 (cod f) (cod g) \\<cdot> l = f \\<and>\n          pr0 (cod f) (cod g) \\<cdot> l = g", "show \"cod (pr0 a b) = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cod (pr0 a b) = b", "using 1 \\<chi>.preserves_cod [of J.TT] J.cod_char J.arr_char"], ["proof (prove)\nusing this:\n  pr1 a b = D.mkCone (pr1 a b) (pr0 a b) (J.MkIde False) \\<and>\n  pr0 a b = D.mkCone (pr1 a b) (pr0 a b) (J.MkIde True)\n  J.arr (J.MkIde True) \\<Longrightarrow>\n  cod (D.mkCone (pr1 a b) (pr0 a b) (J.MkIde True)) =\n  D.map (J.cod (J.MkIde True))\n  J.cod ?f =\n  (if J.arr ?f then J.MkIde (\\<chi>.\\<Phi>.Ya.Cop_S.Cod ?f) else J.null)\n  J.arr ?f = (?f = J.MkIde False \\<or> ?f = J.MkIde True)\n\ngoal (1 subgoal):\n 1. cod (pr0 a b) = b", "by auto"], ["proof (state)\nthis:\n  cod (pr0 a b) = b\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       span f g \\<Longrightarrow>\n       \\<exists>!l.\n          pr1 (cod f) (cod g) \\<cdot> l = f \\<and>\n          pr0 (cod f) (cod g) \\<cdot> l = g", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f g.\n       span f g \\<Longrightarrow>\n       \\<exists>!l.\n          pr1 (cod f) (cod g) \\<cdot> l = f \\<and>\n          pr0 (cod f) (cod g) \\<cdot> l = g", "fix f g"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f g.\n       span f g \\<Longrightarrow>\n       \\<exists>!l.\n          pr1 (cod f) (cod g) \\<cdot> l = f \\<and>\n          pr0 (cod f) (cod g) \\<cdot> l = g", "assume fg: \"span f g\""], ["proof (state)\nthis:\n  span f g\n\ngoal (1 subgoal):\n 1. \\<And>f g.\n       span f g \\<Longrightarrow>\n       \\<exists>!l.\n          pr1 (cod f) (cod g) \\<cdot> l = f \\<and>\n          pr0 (cod f) (cod g) \\<cdot> l = g", "show \"\\<exists>!l. pr1 (cod f) (cod g) \\<cdot> l = f \\<and> pr0 (cod f) (cod g) \\<cdot> l = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!l.\n       pr1 (cod f) (cod g) \\<cdot> l = f \\<and>\n       pr0 (cod f) (cod g) \\<cdot> l = g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!l.\n       pr1 (cod f) (cod g) \\<cdot> l = f \\<and>\n       pr0 (cod f) (cod g) \\<cdot> l = g", "interpret J: binary_product_shape"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!l.\n       pr1 (cod f) (cod g) \\<cdot> l = f \\<and>\n       pr0 (cod f) (cod g) \\<cdot> l = g", "interpret D: binary_product_diagram C \\<open>cod f\\<close> \\<open>cod g\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. binary_product_diagram (\\<cdot>) (cod f) (cod g)", "using fg"], ["proof (prove)\nusing this:\n  span f g\n\ngoal (1 subgoal):\n 1. binary_product_diagram (\\<cdot>) (cod f) (cod g)", "by unfold_locales auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!l.\n       pr1 (cod f) (cod g) \\<cdot> l = f \\<and>\n       pr0 (cod f) (cod g) \\<cdot> l = g", "let ?\\<chi> = \"D.mkCone (pr1 (cod f) (cod g)) (pr0 (cod f) (cod g))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!l.\n       pr1 (cod f) (cod g) \\<cdot> l = f \\<and>\n       pr0 (cod f) (cod g) \\<cdot> l = g", "interpret \\<chi>: limit_cone J.comp C D.map \\<open>dom (pr1 (cod f) (cod g))\\<close> ?\\<chi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. D.has_as_binary_product (pr1 (cod f) (cod g)) (pr0 (cod f) (cod g))", "using fg pr_yields_binary_product [of \"cod f\" \"cod g\"] has_as_binary_product_def"], ["proof (prove)\nusing this:\n  span f g\n  \\<lbrakk>ide (cod f); ide (cod g)\\<rbrakk>\n  \\<Longrightarrow> has_as_binary_product (cod f) (cod g)\n                     (pr1 (cod f) (cod g)) (pr0 (cod f) (cod g))\n  has_as_binary_product ?a0.0 ?a1.0 ?p0.0 ?p1.0 \\<equiv>\n  ide ?a0.0 \\<and>\n  ide ?a1.0 \\<and>\n  limit_cone J.COMP (\\<cdot>)\n   (binary_product_diagram.map (\\<cdot>) ?a0.0 ?a1.0) (local.dom ?p0.0)\n   (D.mkCone ?p0.0 ?p1.0)\n\ngoal (1 subgoal):\n 1. D.has_as_binary_product (pr1 (cod f) (cod g)) (pr0 (cod f) (cod g))", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!l.\n       pr1 (cod f) (cod g) \\<cdot> l = f \\<and>\n       pr0 (cod f) (cod g) \\<cdot> l = g", "interpret \\<chi>: binary_product_cone C \\<open>cod f\\<close> \\<open>cod g\\<close>\n                       \\<open>pr1 (cod f) (cod g)\\<close> \\<open>pr0 (cod f) (cod g)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. binary_product_cone (\\<cdot>) (cod f) (cod g) (pr1 (cod f) (cod g))\n     (pr0 (cod f) (cod g))", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!l.\n       pr1 (cod f) (cod g) \\<cdot> l = f \\<and>\n       pr0 (cod f) (cod g) \\<cdot> l = g", "have 1: \"pr1 (cod f) (cod g) = ?\\<chi> J.FF \\<and> pr0 (cod f) (cod g) = ?\\<chi> J.TT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pr1 (cod f) (cod g) =\n    D.mkCone (pr1 (cod f) (cod g)) (pr0 (cod f) (cod g))\n     (J.MkIde False) \\<and>\n    pr0 (cod f) (cod g) =\n    D.mkCone (pr1 (cod f) (cod g)) (pr0 (cod f) (cod g)) (J.MkIde True)", "using D.mkCone_def"], ["proof (prove)\nusing this:\n  D.mkCone ?p0.0 ?p1.0 \\<equiv>\n  \\<lambda>j.\n     if j = J.MkIde False then ?p0.0\n     else if j = J.MkIde True then ?p1.0 else null\n\ngoal (1 subgoal):\n 1. pr1 (cod f) (cod g) =\n    D.mkCone (pr1 (cod f) (cod g)) (pr0 (cod f) (cod g))\n     (J.MkIde False) \\<and>\n    pr0 (cod f) (cod g) =\n    D.mkCone (pr1 (cod f) (cod g)) (pr0 (cod f) (cod g)) (J.MkIde True)", "by simp"], ["proof (state)\nthis:\n  pr1 (cod f) (cod g) =\n  D.mkCone (pr1 (cod f) (cod g)) (pr0 (cod f) (cod g))\n   (J.MkIde False) \\<and>\n  pr0 (cod f) (cod g) =\n  D.mkCone (pr1 (cod f) (cod g)) (pr0 (cod f) (cod g)) (J.MkIde True)\n\ngoal (1 subgoal):\n 1. \\<exists>!l.\n       pr1 (cod f) (cod g) \\<cdot> l = f \\<and>\n       pr0 (cod f) (cod g) \\<cdot> l = g", "show \"\\<exists>!l. pr1 (cod f) (cod g) \\<cdot> l = f \\<and> pr0 (cod f) (cod g) \\<cdot> l = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!l.\n       pr1 (cod f) (cod g) \\<cdot> l = f \\<and>\n       pr0 (cod f) (cod g) \\<cdot> l = g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!l.\n       pr1 (cod f) (cod g) \\<cdot> l = f \\<and>\n       pr0 (cod f) (cod g) \\<cdot> l = g", "have \"\\<exists>!l. \\<guillemotleft>l : dom f \\<rightarrow> dom (pr1 (cod f) (cod g))\\<guillemotright> \\<and>\n                     pr1 (cod f) (cod g) \\<cdot> l = f \\<and> pr0 (cod f) (cod g) \\<cdot> l = g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!l.\n       \\<guillemotleft>l : local.dom\n                            f \\<rightarrow> local.dom\n       (pr1 (cod f) (cod g))\\<guillemotright> \\<and>\n       pr1 (cod f) (cod g) \\<cdot> l = f \\<and>\n       pr0 (cod f) (cod g) \\<cdot> l = g", "using fg \\<chi>.is_universal'"], ["proof (prove)\nusing this:\n  span f g\n  D.is_rendered_commutative_by ?p0' ?p1' \\<Longrightarrow>\n  \\<exists>!h.\n     \\<guillemotleft>h : local.dom\n                          ?p0' \\<rightarrow> local.dom\n        (pr1 (cod f) (cod g))\\<guillemotright> \\<and>\n     pr1 (cod f) (cod g) \\<cdot> h = ?p0' \\<and>\n     pr0 (cod f) (cod g) \\<cdot> h = ?p1'\n\ngoal (1 subgoal):\n 1. \\<exists>!l.\n       \\<guillemotleft>l : local.dom\n                            f \\<rightarrow> local.dom\n       (pr1 (cod f) (cod g))\\<guillemotright> \\<and>\n       pr1 (cod f) (cod g) \\<cdot> l = f \\<and>\n       pr0 (cod f) (cod g) \\<cdot> l = g", "by simp"], ["proof (state)\nthis:\n  \\<exists>!l.\n     \\<guillemotleft>l : local.dom\n                          f \\<rightarrow> local.dom\n     (pr1 (cod f) (cod g))\\<guillemotright> \\<and>\n     pr1 (cod f) (cod g) \\<cdot> l = f \\<and>\n     pr0 (cod f) (cod g) \\<cdot> l = g\n\ngoal (1 subgoal):\n 1. \\<exists>!l.\n       pr1 (cod f) (cod g) \\<cdot> l = f \\<and>\n       pr0 (cod f) (cod g) \\<cdot> l = g", "moreover"], ["proof (state)\nthis:\n  \\<exists>!l.\n     \\<guillemotleft>l : local.dom\n                          f \\<rightarrow> local.dom\n     (pr1 (cod f) (cod g))\\<guillemotright> \\<and>\n     pr1 (cod f) (cod g) \\<cdot> l = f \\<and>\n     pr0 (cod f) (cod g) \\<cdot> l = g\n\ngoal (1 subgoal):\n 1. \\<exists>!l.\n       pr1 (cod f) (cod g) \\<cdot> l = f \\<and>\n       pr0 (cod f) (cod g) \\<cdot> l = g", "have \"\\<And>l. pr1 (cod f) (cod g) \\<cdot> l = f\n                                \\<Longrightarrow> \\<guillemotleft>l : dom f \\<rightarrow> dom (pr1 (cod f) (cod g))\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>l.\n       pr1 (cod f) (cod g) \\<cdot> l = f \\<Longrightarrow>\n       \\<guillemotleft>l : local.dom\n                            f \\<rightarrow> local.dom\n       (pr1 (cod f) (cod g))\\<guillemotright>", "using fg dom_comp in_homI seqE seqI"], ["proof (prove)\nusing this:\n  span f g\n  seq ?g ?f \\<Longrightarrow> local.dom (?g \\<cdot> ?f) = local.dom ?f\n  \\<lbrakk>arr ?f; local.dom ?f = ?a; cod ?f = ?b\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright>\n  \\<lbrakk>seq ?g ?f;\n   \\<lbrakk>arr ?f; arr ?g; local.dom ?g = cod ?f\\<rbrakk>\n   \\<Longrightarrow> ?T\\<rbrakk>\n  \\<Longrightarrow> ?T\n  \\<lbrakk>arr ?f; arr ?g; local.dom ?g = cod ?f\\<rbrakk>\n  \\<Longrightarrow> seq ?g ?f\n\ngoal (1 subgoal):\n 1. \\<And>l.\n       pr1 (cod f) (cod g) \\<cdot> l = f \\<Longrightarrow>\n       \\<guillemotleft>l : local.dom\n                            f \\<rightarrow> local.dom\n       (pr1 (cod f) (cod g))\\<guillemotright>", "by metis"], ["proof (state)\nthis:\n  pr1 (cod f) (cod g) \\<cdot> ?l4 = f \\<Longrightarrow>\n  \\<guillemotleft>?l4 : local.dom\n                         f \\<rightarrow> local.dom\n    (pr1 (cod f) (cod g))\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<exists>!l.\n       pr1 (cod f) (cod g) \\<cdot> l = f \\<and>\n       pr0 (cod f) (cod g) \\<cdot> l = g", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>!l.\n     \\<guillemotleft>l : local.dom\n                          f \\<rightarrow> local.dom\n     (pr1 (cod f) (cod g))\\<guillemotright> \\<and>\n     pr1 (cod f) (cod g) \\<cdot> l = f \\<and>\n     pr0 (cod f) (cod g) \\<cdot> l = g\n  pr1 (cod f) (cod g) \\<cdot> ?l4 = f \\<Longrightarrow>\n  \\<guillemotleft>?l4 : local.dom\n                         f \\<rightarrow> local.dom\n    (pr1 (cod f) (cod g))\\<guillemotright>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>!l.\n     \\<guillemotleft>l : local.dom\n                          f \\<rightarrow> local.dom\n     (pr1 (cod f) (cod g))\\<guillemotright> \\<and>\n     pr1 (cod f) (cod g) \\<cdot> l = f \\<and>\n     pr0 (cod f) (cod g) \\<cdot> l = g\n  pr1 (cod f) (cod g) \\<cdot> ?l4 = f \\<Longrightarrow>\n  \\<guillemotleft>?l4 : local.dom\n                         f \\<rightarrow> local.dom\n    (pr1 (cod f) (cod g))\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<exists>!l.\n       pr1 (cod f) (cod g) \\<cdot> l = f \\<and>\n       pr0 (cod f) (cod g) \\<cdot> l = g", "by auto"], ["proof (state)\nthis:\n  \\<exists>!l.\n     pr1 (cod f) (cod g) \\<cdot> l = f \\<and>\n     pr0 (cod f) (cod g) \\<cdot> l = g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!l.\n     pr1 (cod f) (cod g) \\<cdot> l = f \\<and>\n     pr0 (cod f) (cod g) \\<cdot> l = g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!l.\n     pr1 (cod f) (cod g) \\<cdot> l = f \\<and>\n     pr0 (cod f) (cod g) \\<cdot> l = g\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition extends_to_elementary_category_with_binary_products:\n    shows \"elementary_category_with_binary_products C pr0 pr1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elementary_category_with_binary_products (\\<cdot>) pr0 pr1", ".."], ["", "end"], ["", "context elementary_category_with_binary_products\n  begin"], ["", "interpretation category_with_binary_products C"], ["proof (prove)\ngoal (1 subgoal):\n 1. category_with_binary_products (\\<cdot>)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. has_binary_products", "show \"has_binary_products\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_binary_products", "proof (unfold has_binary_products_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>a0 a1.\n       ide a0 \\<and> ide a1 \\<longrightarrow>\n       (\\<exists>p0. Ex (has_as_binary_product a0 a1 p0))", "have \"\\<And>a b. ide a \\<and> ide b \\<Longrightarrow> \\<exists>p0 p1. has_as_binary_product a b p0 p1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       ide a \\<and> ide b \\<Longrightarrow>\n       \\<exists>p0 p1. has_as_binary_product a b p0 p1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       ide a \\<and> ide b \\<Longrightarrow>\n       \\<exists>p0 p1. has_as_binary_product a b p0 p1", "fix a b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       ide a \\<and> ide b \\<Longrightarrow>\n       \\<exists>p0 p1. has_as_binary_product a b p0 p1", "assume ab: \"ide a \\<and> ide b\""], ["proof (state)\nthis:\n  ide a \\<and> ide b\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       ide a \\<and> ide b \\<Longrightarrow>\n       \\<exists>p0 p1. has_as_binary_product a b p0 p1", "interpret J: binary_product_shape"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       ide a \\<and> ide b \\<Longrightarrow>\n       \\<exists>p0 p1. has_as_binary_product a b p0 p1", "interpret D: binary_product_diagram C a b"], ["proof (prove)\ngoal (1 subgoal):\n 1. binary_product_diagram (\\<cdot>) a b", "using ab"], ["proof (prove)\nusing this:\n  ide a \\<and> ide b\n\ngoal (1 subgoal):\n 1. binary_product_diagram (\\<cdot>) a b", "by unfold_locales auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       ide a \\<and> ide b \\<Longrightarrow>\n       \\<exists>p0 p1. has_as_binary_product a b p0 p1", "have 2: \"D.is_rendered_commutative_by \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D.is_rendered_commutative_by \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]", "using ab"], ["proof (prove)\nusing this:\n  ide a \\<and> ide b\n\ngoal (1 subgoal):\n 1. D.is_rendered_commutative_by \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]", "by simp"], ["proof (state)\nthis:\n  D.is_rendered_commutative_by \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       ide a \\<and> ide b \\<Longrightarrow>\n       \\<exists>p0 p1. has_as_binary_product a b p0 p1", "let ?\\<chi> = \"D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       ide a \\<and> ide b \\<Longrightarrow>\n       \\<exists>p0 p1. has_as_binary_product a b p0 p1", "interpret \\<chi>: cone J.comp C D.map \\<open>dom \\<pp>\\<^sub>1[a, b]\\<close> ?\\<chi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. D.cone (local.dom \\<pp>\\<^sub>1[a, b])\n     (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b])", "using D.cone_mkCone 2"], ["proof (prove)\nusing this:\n  D.is_rendered_commutative_by ?p0.0 ?p1.0 \\<Longrightarrow>\n  D.cone (local.dom ?p0.0) (D.mkCone ?p0.0 ?p1.0)\n  D.is_rendered_commutative_by \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]\n\ngoal (1 subgoal):\n 1. D.cone (local.dom \\<pp>\\<^sub>1[a, b])\n     (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b])", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       ide a \\<and> ide b \\<Longrightarrow>\n       \\<exists>p0 p1. has_as_binary_product a b p0 p1", "interpret \\<chi>: limit_cone J.comp C D.map \\<open>dom \\<pp>\\<^sub>1[a, b]\\<close> ?\\<chi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. D.has_as_binary_product \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' \\<chi>'.\n       D.cone a' \\<chi>' \\<Longrightarrow>\n       \\<exists>!f.\n          \\<guillemotleft>f : a' \\<rightarrow> local.dom\n          \\<pp>\\<^sub>1[a, b]\\<guillemotright> \\<and>\n          D.cones_map f (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) =\n          \\<chi>'", "fix a' \\<chi>'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' \\<chi>'.\n       D.cone a' \\<chi>' \\<Longrightarrow>\n       \\<exists>!f.\n          \\<guillemotleft>f : a' \\<rightarrow> local.dom\n          \\<pp>\\<^sub>1[a, b]\\<guillemotright> \\<and>\n          D.cones_map f (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) =\n          \\<chi>'", "assume \\<chi>': \"D.cone a' \\<chi>'\""], ["proof (state)\nthis:\n  D.cone a' \\<chi>'\n\ngoal (1 subgoal):\n 1. \\<And>a' \\<chi>'.\n       D.cone a' \\<chi>' \\<Longrightarrow>\n       \\<exists>!f.\n          \\<guillemotleft>f : a' \\<rightarrow> local.dom\n          \\<pp>\\<^sub>1[a, b]\\<guillemotright> \\<and>\n          D.cones_map f (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) =\n          \\<chi>'", "interpret \\<chi>': cone J.comp C D.map a' \\<chi>'"], ["proof (prove)\ngoal (1 subgoal):\n 1. D.cone a' \\<chi>'", "using \\<chi>'"], ["proof (prove)\nusing this:\n  D.cone a' \\<chi>'\n\ngoal (1 subgoal):\n 1. D.cone a' \\<chi>'", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' \\<chi>'.\n       D.cone a' \\<chi>' \\<Longrightarrow>\n       \\<exists>!f.\n          \\<guillemotleft>f : a' \\<rightarrow> local.dom\n          \\<pp>\\<^sub>1[a, b]\\<guillemotright> \\<and>\n          D.cones_map f (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) =\n          \\<chi>'", "show \"\\<exists>!h. \\<guillemotleft>h : a' \\<rightarrow> dom \\<pp>\\<^sub>1[a, b]\\<guillemotright> \\<and>\n                       D.cones_map h (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) = \\<chi>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!h.\n       \\<guillemotleft>h : a' \\<rightarrow> local.dom\n       \\<pp>\\<^sub>1[a, b]\\<guillemotright> \\<and>\n       D.cones_map h (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) =\n       \\<chi>'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : a' \\<rightarrow> local.dom\n     \\<pp>\\<^sub>1[a, b]\\<guillemotright> \\<and>\n    D.cones_map ?a (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) =\n    \\<chi>'\n 2. \\<And>h.\n       \\<guillemotleft>h : a' \\<rightarrow> local.dom\n       \\<pp>\\<^sub>1[a, b]\\<guillemotright> \\<and>\n       D.cones_map h (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) =\n       \\<chi>' \\<Longrightarrow>\n       h = ?a", "let ?h = \"\\<langle>\\<chi>' J.FF, \\<chi>' J.TT\\<rangle>\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : a' \\<rightarrow> local.dom\n     \\<pp>\\<^sub>1[a, b]\\<guillemotright> \\<and>\n    D.cones_map ?a (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) =\n    \\<chi>'\n 2. \\<And>h.\n       \\<guillemotleft>h : a' \\<rightarrow> local.dom\n       \\<pp>\\<^sub>1[a, b]\\<guillemotright> \\<and>\n       D.cones_map h (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) =\n       \\<chi>' \\<Longrightarrow>\n       h = ?a", "show h': \"\\<guillemotleft>?h : a' \\<rightarrow> dom \\<pp>\\<^sub>1[a, b]\\<guillemotright> \\<and>\n                        D.cones_map ?h (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) = \\<chi>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<langle>\\<chi>'\n                              (J.MkIde\n                                False), \\<chi>'\n   (J.MkIde\n     True)\\<rangle> : a' \\<rightarrow> local.dom\n  \\<pp>\\<^sub>1[a, b]\\<guillemotright> \\<and>\n    D.cones_map\n     \\<langle>\\<chi>' (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>\n     (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) =\n    \\<chi>'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<guillemotleft>\\<langle>\\<chi>'\n                              (J.MkIde\n                                False), \\<chi>'\n   (J.MkIde\n     True)\\<rangle> : a' \\<rightarrow> local.dom\n  \\<pp>\\<^sub>1[a, b]\\<guillemotright>\n 2. D.cones_map\n     \\<langle>\\<chi>' (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>\n     (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) =\n    \\<chi>'", "show h: \"\\<guillemotleft>?h : a' \\<rightarrow> dom \\<pp>\\<^sub>1[a, b]\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<langle>\\<chi>'\n                              (J.MkIde\n                                False), \\<chi>'\n   (J.MkIde\n     True)\\<rangle> : a' \\<rightarrow> local.dom\n  \\<pp>\\<^sub>1[a, b]\\<guillemotright>", "using ab tuple_in_hom J.ide_char"], ["proof (prove)\nusing this:\n  ide a \\<and> ide b\n  \\<lbrakk>\\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright>;\n   \\<guillemotleft>?g : ?a \\<rightarrow> ?c\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>\\<langle>?f, ?g\\<rangle> : ?a \\<rightarrow> ?b \\<otimes>\n    ?c\\<guillemotright>\n  J.ide ?f = (?f = J.MkIde False \\<or> ?f = J.MkIde True)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<langle>\\<chi>'\n                              (J.MkIde\n                                False), \\<chi>'\n   (J.MkIde\n     True)\\<rangle> : a' \\<rightarrow> local.dom\n  \\<pp>\\<^sub>1[a, b]\\<guillemotright>", "by fastforce"], ["proof (state)\nthis:\n  \\<guillemotleft>\\<langle>\\<chi>'\n                            (J.MkIde\n                              False), \\<chi>'\n (J.MkIde\n   True)\\<rangle> : a' \\<rightarrow> local.dom\n\\<pp>\\<^sub>1[a, b]\\<guillemotright>\n\ngoal (1 subgoal):\n 1. D.cones_map\n     \\<langle>\\<chi>' (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>\n     (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) =\n    \\<chi>'", "show \"D.cones_map ?h (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) = \\<chi>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D.cones_map\n     \\<langle>\\<chi>' (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>\n     (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) =\n    \\<chi>'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. D.cones_map\n     \\<langle>\\<chi>' (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>\n     (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) =\n    \\<chi>'", "interpret \\<chi>'h: cone J.comp C D.map a'\n                                   \\<open>D.cones_map ?h (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b])\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. D.cone a'\n     (D.cones_map\n       \\<langle>\\<chi>' (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>\n       (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. D.cone a'\n     (D.cones_map\n       \\<langle>\\<chi>' (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>\n       (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]))", "have \"D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b] \\<in> D.cones (cod \\<langle>\\<chi>' J.FF, \\<chi>' J.TT\\<rangle>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]\n    \\<in> D.cones\n           (cod \\<langle>\\<chi>'\n                          (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>)", "using ab h D.cone_mkCone D.is_rendered_commutative_by_cone\n                            \\<chi>.cone_axioms"], ["proof (prove)\nusing this:\n  ide a \\<and> ide b\n  \\<guillemotleft>\\<langle>\\<chi>'\n                            (J.MkIde\n                              False), \\<chi>'\n (J.MkIde\n   True)\\<rangle> : a' \\<rightarrow> local.dom\n\\<pp>\\<^sub>1[a, b]\\<guillemotright>\n  D.is_rendered_commutative_by ?p0.0 ?p1.0 \\<Longrightarrow>\n  D.cone (local.dom ?p0.0) (D.mkCone ?p0.0 ?p1.0)\n  D.cone ?a ?\\<chi> \\<Longrightarrow>\n  D.is_rendered_commutative_by (?\\<chi> (J.MkIde False))\n   (?\\<chi> (J.MkIde True))\n  D.cone (local.dom \\<pp>\\<^sub>1[a, b])\n   (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b])\n\ngoal (1 subgoal):\n 1. D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]\n    \\<in> D.cones\n           (cod \\<langle>\\<chi>'\n                          (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>)", "by auto"], ["proof (state)\nthis:\n  D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]\n  \\<in> D.cones\n         (cod \\<langle>\\<chi>'\n                        (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>)\n\ngoal (1 subgoal):\n 1. D.cone a'\n     (D.cones_map\n       \\<langle>\\<chi>' (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>\n       (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]))", "hence \"D.cones_map ?h (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) \\<in> D.cones a'\""], ["proof (prove)\nusing this:\n  D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]\n  \\<in> D.cones\n         (cod \\<langle>\\<chi>'\n                        (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>)\n\ngoal (1 subgoal):\n 1. D.cones_map\n     \\<langle>\\<chi>' (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>\n     (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b])\n    \\<in> D.cones a'", "using ab h D.cones_map_mapsto"], ["proof (prove)\nusing this:\n  D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]\n  \\<in> D.cones\n         (cod \\<langle>\\<chi>'\n                        (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>)\n  ide a \\<and> ide b\n  \\<guillemotleft>\\<langle>\\<chi>'\n                            (J.MkIde\n                              False), \\<chi>'\n (J.MkIde\n   True)\\<rangle> : a' \\<rightarrow> local.dom\n\\<pp>\\<^sub>1[a, b]\\<guillemotright>\n  arr ?f \\<Longrightarrow>\n  D.cones_map ?f\n  \\<in> extensional (D.cones (cod ?f)) \\<inter>\n        (D.cones (cod ?f) \\<rightarrow> D.cones (local.dom ?f))\n\ngoal (1 subgoal):\n 1. D.cones_map\n     \\<langle>\\<chi>' (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>\n     (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b])\n    \\<in> D.cones a'", "by blast"], ["proof (state)\nthis:\n  D.cones_map\n   \\<langle>\\<chi>' (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>\n   (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b])\n  \\<in> D.cones a'\n\ngoal (1 subgoal):\n 1. D.cone a'\n     (D.cones_map\n       \\<langle>\\<chi>' (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>\n       (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]))", "thus \"D.cone a' (D.cones_map ?h (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]))\""], ["proof (prove)\nusing this:\n  D.cones_map\n   \\<langle>\\<chi>' (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>\n   (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b])\n  \\<in> D.cones a'\n\ngoal (1 subgoal):\n 1. D.cone a'\n     (D.cones_map\n       \\<langle>\\<chi>' (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>\n       (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]))", "by simp"], ["proof (state)\nthis:\n  D.cone a'\n   (D.cones_map\n     \\<langle>\\<chi>' (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>\n     (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\ngoal (1 subgoal):\n 1. D.cones_map\n     \\<langle>\\<chi>' (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>\n     (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) =\n    \\<chi>'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. D.cones_map\n     \\<langle>\\<chi>' (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>\n     (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) =\n    \\<chi>'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. D.cones_map\n     \\<langle>\\<chi>' (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>\n     (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) =\n    \\<chi>'", "have \"\\<And>j. J.ide j \\<Longrightarrow> D.cones_map ?h (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) j = \\<chi>' j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j.\n       J.ide j \\<Longrightarrow>\n       D.cones_map\n        \\<langle>\\<chi>' (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>\n        (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) j =\n       \\<chi>' j", "using ab h J.ide_char D.mkCone_def \\<chi>.cone_axioms"], ["proof (prove)\nusing this:\n  ide a \\<and> ide b\n  \\<guillemotleft>\\<langle>\\<chi>'\n                            (J.MkIde\n                              False), \\<chi>'\n (J.MkIde\n   True)\\<rangle> : a' \\<rightarrow> local.dom\n\\<pp>\\<^sub>1[a, b]\\<guillemotright>\n  J.ide ?f = (?f = J.MkIde False \\<or> ?f = J.MkIde True)\n  D.mkCone ?p0.0 ?p1.0 \\<equiv>\n  \\<lambda>j.\n     if j = J.MkIde False then ?p0.0\n     else if j = J.MkIde True then ?p1.0 else null\n  D.cone (local.dom \\<pp>\\<^sub>1[a, b])\n   (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b])\n\ngoal (1 subgoal):\n 1. \\<And>j.\n       J.ide j \\<Longrightarrow>\n       D.cones_map\n        \\<langle>\\<chi>' (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>\n        (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) j =\n       \\<chi>' j", "by auto"], ["proof (state)\nthis:\n  J.ide ?j4 \\<Longrightarrow>\n  D.cones_map\n   \\<langle>\\<chi>' (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>\n   (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) ?j4 =\n  \\<chi>' ?j4\n\ngoal (1 subgoal):\n 1. D.cones_map\n     \\<langle>\\<chi>' (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>\n     (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) =\n    \\<chi>'", "thus ?thesis"], ["proof (prove)\nusing this:\n  J.ide ?j4 \\<Longrightarrow>\n  D.cones_map\n   \\<langle>\\<chi>' (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>\n   (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) ?j4 =\n  \\<chi>' ?j4\n\ngoal (1 subgoal):\n 1. D.cones_map\n     \\<langle>\\<chi>' (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>\n     (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) =\n    \\<chi>'", "using NaturalTransformation.eqI\n                            \\<chi>'.natural_transformation_axioms \\<chi>'h.natural_transformation_axioms"], ["proof (prove)\nusing this:\n  J.ide ?j4 \\<Longrightarrow>\n  D.cones_map\n   \\<langle>\\<chi>' (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>\n   (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) ?j4 =\n  \\<chi>' ?j4\n  \\<lbrakk>natural_transformation ?A ?B ?F ?G ?\\<sigma>;\n   natural_transformation ?A ?B ?F ?G ?\\<sigma>';\n   \\<And>a.\n      partial_magma.ide ?A a \\<Longrightarrow>\n      ?\\<sigma> a = ?\\<sigma>' a\\<rbrakk>\n  \\<Longrightarrow> ?\\<sigma> = ?\\<sigma>'\n  natural_transformation J.COMP (\\<cdot>) \\<chi>'.A.map D.map \\<chi>'\n  natural_transformation J.COMP (\\<cdot>) \\<chi>'.A.map D.map\n   (D.cones_map\n     \\<langle>\\<chi>' (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>\n     (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]))\n\ngoal (1 subgoal):\n 1. D.cones_map\n     \\<langle>\\<chi>' (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>\n     (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) =\n    \\<chi>'", "by blast"], ["proof (state)\nthis:\n  D.cones_map\n   \\<langle>\\<chi>' (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>\n   (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) =\n  \\<chi>'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  D.cones_map\n   \\<langle>\\<chi>' (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>\n   (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) =\n  \\<chi>'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  D.cones_map\n   \\<langle>\\<chi>' (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>\n   (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) =\n  \\<chi>'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<guillemotleft>\\<langle>\\<chi>'\n                            (J.MkIde\n                              False), \\<chi>'\n (J.MkIde\n   True)\\<rangle> : a' \\<rightarrow> local.dom\n\\<pp>\\<^sub>1[a, b]\\<guillemotright> \\<and>\n  D.cones_map\n   \\<langle>\\<chi>' (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>\n   (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) =\n  \\<chi>'\n\ngoal (1 subgoal):\n 1. \\<And>h.\n       \\<guillemotleft>h : a' \\<rightarrow> local.dom\n       \\<pp>\\<^sub>1[a, b]\\<guillemotright> \\<and>\n       D.cones_map h (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) =\n       \\<chi>' \\<Longrightarrow>\n       h = \\<langle>\\<chi>' (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>", "show \"\\<And>h. \\<guillemotleft>h : a' \\<rightarrow> dom \\<pp>\\<^sub>1[a, b]\\<guillemotright> \\<and>\n                        D.cones_map h (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) = \\<chi>' \\<Longrightarrow> h = ?h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>h.\n       \\<guillemotleft>h : a' \\<rightarrow> local.dom\n       \\<pp>\\<^sub>1[a, b]\\<guillemotright> \\<and>\n       D.cones_map h (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) =\n       \\<chi>' \\<Longrightarrow>\n       h = \\<langle>\\<chi>' (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h.\n       \\<guillemotleft>h : a' \\<rightarrow> local.dom\n       \\<pp>\\<^sub>1[a, b]\\<guillemotright> \\<and>\n       D.cones_map h (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) =\n       \\<chi>' \\<Longrightarrow>\n       h = \\<langle>\\<chi>' (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>", "fix h"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h.\n       \\<guillemotleft>h : a' \\<rightarrow> local.dom\n       \\<pp>\\<^sub>1[a, b]\\<guillemotright> \\<and>\n       D.cones_map h (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) =\n       \\<chi>' \\<Longrightarrow>\n       h = \\<langle>\\<chi>' (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>", "assume 1: \"\\<guillemotleft>h : a' \\<rightarrow> dom \\<pp>\\<^sub>1[a, b]\\<guillemotright> \\<and>\n                           D.cones_map h (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) = \\<chi>'\""], ["proof (state)\nthis:\n  \\<guillemotleft>h : a' \\<rightarrow> local.dom\n  \\<pp>\\<^sub>1[a, b]\\<guillemotright> \\<and>\n  D.cones_map h (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) = \\<chi>'\n\ngoal (1 subgoal):\n 1. \\<And>h.\n       \\<guillemotleft>h : a' \\<rightarrow> local.dom\n       \\<pp>\\<^sub>1[a, b]\\<guillemotright> \\<and>\n       D.cones_map h (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) =\n       \\<chi>' \\<Longrightarrow>\n       h = \\<langle>\\<chi>' (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>", "hence \"cod h = dom \\<pp>\\<^sub>1[a, b]\""], ["proof (prove)\nusing this:\n  \\<guillemotleft>h : a' \\<rightarrow> local.dom\n  \\<pp>\\<^sub>1[a, b]\\<guillemotright> \\<and>\n  D.cones_map h (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) = \\<chi>'\n\ngoal (1 subgoal):\n 1. cod h = local.dom \\<pp>\\<^sub>1[a, b]", "by auto"], ["proof (state)\nthis:\n  cod h = local.dom \\<pp>\\<^sub>1[a, b]\n\ngoal (1 subgoal):\n 1. \\<And>h.\n       \\<guillemotleft>h : a' \\<rightarrow> local.dom\n       \\<pp>\\<^sub>1[a, b]\\<guillemotright> \\<and>\n       D.cones_map h (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) =\n       \\<chi>' \\<Longrightarrow>\n       h = \\<langle>\\<chi>' (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>", "show \"h = ?h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h = \\<langle>\\<chi>' (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>", "using 1 ab \\<chi>.cone_axioms D.mkCone_def h' pr_joint_monic [of a b h ?h]"], ["proof (prove)\nusing this:\n  \\<guillemotleft>h : a' \\<rightarrow> local.dom\n  \\<pp>\\<^sub>1[a, b]\\<guillemotright> \\<and>\n  D.cones_map h (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) = \\<chi>'\n  ide a \\<and> ide b\n  D.cone (local.dom \\<pp>\\<^sub>1[a, b])\n   (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b])\n  D.mkCone ?p0.0 ?p1.0 \\<equiv>\n  \\<lambda>j.\n     if j = J.MkIde False then ?p0.0\n     else if j = J.MkIde True then ?p1.0 else null\n  \\<guillemotleft>\\<langle>\\<chi>'\n                            (J.MkIde\n                              False), \\<chi>'\n (J.MkIde\n   True)\\<rangle> : a' \\<rightarrow> local.dom\n\\<pp>\\<^sub>1[a, b]\\<guillemotright> \\<and>\n  D.cones_map\n   \\<langle>\\<chi>' (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>\n   (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) =\n  \\<chi>'\n  \\<lbrakk>seq \\<pp>\\<^sub>0[a, b] h;\n   \\<pp>\\<^sub>0[a, b] \\<cdot> h =\n   \\<pp>\\<^sub>0[a, b] \\<cdot>\n   \\<langle>\\<chi>' (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>;\n   \\<pp>\\<^sub>1[a, b] \\<cdot> h =\n   \\<pp>\\<^sub>1[a, b] \\<cdot>\n   \\<langle>\\<chi>'\n             (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>\\<rbrakk>\n  \\<Longrightarrow> h =\n                    \\<langle>\\<chi>'\n                              (J.MkIde\n                                False), \\<chi>' (J.MkIde True)\\<rangle>\n\ngoal (1 subgoal):\n 1. h = \\<langle>\\<chi>' (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>", "by auto"], ["proof (state)\nthis:\n  h = \\<langle>\\<chi>' (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<guillemotleft>?h4 : a' \\<rightarrow> local.dom\n    \\<pp>\\<^sub>1[a, b]\\<guillemotright> \\<and>\n  D.cones_map ?h4 (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) =\n  \\<chi>' \\<Longrightarrow>\n  ?h4 = \\<langle>\\<chi>' (J.MkIde False), \\<chi>' (J.MkIde True)\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!h.\n     \\<guillemotleft>h : a' \\<rightarrow> local.dom\n     \\<pp>\\<^sub>1[a, b]\\<guillemotright> \\<and>\n     D.cones_map h (D.mkCone \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]) =\n     \\<chi>'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       ide a \\<and> ide b \\<Longrightarrow>\n       \\<exists>p0 p1. has_as_binary_product a b p0 p1", "have \"has_as_binary_product a b \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_as_binary_product a b \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]", "using ab has_as_binary_product_def \\<chi>.limit_cone_axioms"], ["proof (prove)\nusing this:\n  ide a \\<and> ide b\n  has_as_binary_product ?a0.0 ?a1.0 ?p0.0 ?p1.0 \\<equiv>\n  ide ?a0.0 \\<and>\n  ide ?a1.0 \\<and>\n  limit_cone J.COMP (\\<cdot>)\n   (binary_product_diagram.map (\\<cdot>) ?a0.0 ?a1.0) (local.dom ?p0.0)\n   (D.mkCone ?p0.0 ?p1.0)\n  D.has_as_binary_product \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]\n\ngoal (1 subgoal):\n 1. has_as_binary_product a b \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]", "by blast"], ["proof (state)\nthis:\n  has_as_binary_product a b \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       ide a \\<and> ide b \\<Longrightarrow>\n       \\<exists>p0 p1. has_as_binary_product a b p0 p1", "thus \"\\<exists>p0 p1. has_as_binary_product a b p0 p1\""], ["proof (prove)\nusing this:\n  has_as_binary_product a b \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b]\n\ngoal (1 subgoal):\n 1. \\<exists>p0 p1. has_as_binary_product a b p0 p1", "by blast"], ["proof (state)\nthis:\n  \\<exists>p0 p1. has_as_binary_product a b p0 p1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ide ?a4 \\<and> ide ?b4 \\<Longrightarrow>\n  \\<exists>p0 p1. has_as_binary_product ?a4 ?b4 p0 p1\n\ngoal (1 subgoal):\n 1. \\<forall>a0 a1.\n       ide a0 \\<and> ide a1 \\<longrightarrow>\n       (\\<exists>p0. Ex (has_as_binary_product a0 a1 p0))", "thus \"\\<forall>a b. ide a \\<and> ide b \\<longrightarrow> (\\<exists>p0 p1. has_as_binary_product a b p0 p1)\""], ["proof (prove)\nusing this:\n  ide ?a4 \\<and> ide ?b4 \\<Longrightarrow>\n  \\<exists>p0 p1. has_as_binary_product ?a4 ?b4 p0 p1\n\ngoal (1 subgoal):\n 1. \\<forall>a b.\n       ide a \\<and> ide b \\<longrightarrow>\n       (\\<exists>p0 p1. has_as_binary_product a b p0 p1)", "by simp"], ["proof (state)\nthis:\n  \\<forall>a b.\n     ide a \\<and> ide b \\<longrightarrow>\n     (\\<exists>p0 p1. has_as_binary_product a b p0 p1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  has_binary_products\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition is_category_with_binary_products:\n    shows \"category_with_binary_products C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. category_with_binary_products (\\<cdot>)", ".."], ["", "end"], ["", "subsection \"Further Properties\""], ["", "context elementary_category_with_binary_products\n  begin"], ["", "lemma interchange:\n    assumes \"seq h f\" and \"seq k g\"\n    shows \"(h \\<otimes> k) \\<cdot> (f \\<otimes> g) = h \\<cdot> f \\<otimes> k \\<cdot> g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h \\<otimes> k) \\<cdot> (f \\<otimes> g) =\n    h \\<cdot> f \\<otimes> k \\<cdot> g", "using assms prod_def comp_tuple_arr comp_assoc"], ["proof (prove)\nusing this:\n  seq h f\n  seq k g\n  ?f \\<otimes> ?g \\<equiv>\n  \\<langle>?f \\<cdot>\n           \\<pp>\\<^sub>1[local.dom\n                          ?f, local.dom\n                               ?g], ?g \\<cdot>\n                                    \\<pp>\\<^sub>0[local.dom\n             ?f, local.dom ?g]\\<rangle>\n  \\<lbrakk>span ?f ?g; arr ?h; local.dom ?f = cod ?h\\<rbrakk>\n  \\<Longrightarrow> \\<langle>?f, ?g\\<rangle> \\<cdot> ?h =\n                    \\<langle>?f \\<cdot> ?h, ?g \\<cdot> ?h\\<rangle>\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. (h \\<otimes> k) \\<cdot> (f \\<otimes> g) =\n    h \\<cdot> f \\<otimes> k \\<cdot> g", "by fastforce"], ["", "lemma pr_naturality [simp]:\n    assumes \"arr g\" and \"dom g = b\" and \"cod g = d\"\n        and \"arr f\" and \"dom f = a\" and \"cod f = c\"\n    shows \"\\<pp>\\<^sub>0[c, d] \\<cdot> (f \\<otimes> g) = g \\<cdot> \\<pp>\\<^sub>0[a, b]\"\n    and \"\\<pp>\\<^sub>1[c, d] \\<cdot> (f \\<otimes> g) = f \\<cdot> \\<pp>\\<^sub>1[a, b]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[c, d] \\<cdot> (f \\<otimes> g) =\n    g \\<cdot> \\<pp>\\<^sub>0[a, b] &&&\n    \\<pp>\\<^sub>1[c, d] \\<cdot> (f \\<otimes> g) =\n    f \\<cdot> \\<pp>\\<^sub>1[a, b]", "using assms prod_def"], ["proof (prove)\nusing this:\n  arr g\n  local.dom g = b\n  cod g = d\n  arr f\n  local.dom f = a\n  cod f = c\n  ?f \\<otimes> ?g \\<equiv>\n  \\<langle>?f \\<cdot>\n           \\<pp>\\<^sub>1[local.dom\n                          ?f, local.dom\n                               ?g], ?g \\<cdot>\n                                    \\<pp>\\<^sub>0[local.dom\n             ?f, local.dom ?g]\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[c, d] \\<cdot> (f \\<otimes> g) =\n    g \\<cdot> \\<pp>\\<^sub>0[a, b] &&&\n    \\<pp>\\<^sub>1[c, d] \\<cdot> (f \\<otimes> g) =\n    f \\<cdot> \\<pp>\\<^sub>1[a, b]", "by fastforce+"], ["", "abbreviation dup (\"\\<d>[_]\")\n    where \"\\<d>[f] \\<equiv> \\<langle>f, f\\<rangle>\""], ["", "lemma dup_in_hom [intro, simp]:\n    assumes \"\\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>\"\n    shows \"\\<guillemotleft>\\<d>[f] : a \\<rightarrow> b \\<otimes> b\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<d>[f] : a \\<rightarrow> b \\<otimes> b\\<guillemotright>", "using assms"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<d>[f] : a \\<rightarrow> b \\<otimes> b\\<guillemotright>", "by fastforce"], ["", "lemma dup_simps [simp]:\n    assumes \"arr f\"\n    shows \"arr \\<d>[f]\" and \"dom \\<d>[f] = dom f\" and \"cod \\<d>[f] = cod f \\<otimes> cod f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr \\<d>[f] &&&\n    local.dom \\<d>[f] = local.dom f &&& cod \\<d>[f] = cod f \\<otimes> cod f", "using assms dup_in_hom"], ["proof (prove)\nusing this:\n  arr f\n  \\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright> \\<Longrightarrow>\n  \\<guillemotleft>\\<d>[?f] : ?a \\<rightarrow> ?b \\<otimes>\n        ?b\\<guillemotright>\n\ngoal (1 subgoal):\n 1. arr \\<d>[f] &&&\n    local.dom \\<d>[f] = local.dom f &&& cod \\<d>[f] = cod f \\<otimes> cod f", "by auto"], ["", "lemma dup_naturality:\n    assumes \"\\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>\"\n    shows \"\\<d>[b] \\<cdot> f = (f \\<otimes> f) \\<cdot> \\<d>[a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<d>[b] \\<cdot> f = (f \\<otimes> f) \\<cdot> \\<d>[a]", "using assms prod_def comp_arr_dom comp_cod_arr comp_tuple_arr comp_assoc"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>\n  ?f \\<otimes> ?g \\<equiv>\n  \\<langle>?f \\<cdot>\n           \\<pp>\\<^sub>1[local.dom\n                          ?f, local.dom\n                               ?g], ?g \\<cdot>\n                                    \\<pp>\\<^sub>0[local.dom\n             ?f, local.dom ?g]\\<rangle>\n  \\<lbrakk>arr ?f; local.dom ?f = ?a\\<rbrakk>\n  \\<Longrightarrow> ?f \\<cdot> ?a = ?f\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n  \\<lbrakk>span ?f ?g; arr ?h; local.dom ?f = cod ?h\\<rbrakk>\n  \\<Longrightarrow> \\<langle>?f, ?g\\<rangle> \\<cdot> ?h =\n                    \\<langle>?f \\<cdot> ?h, ?g \\<cdot> ?h\\<rangle>\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. \\<d>[b] \\<cdot> f = (f \\<otimes> f) \\<cdot> \\<d>[a]", "by fastforce"], ["", "lemma pr_dup [simp]:\n    assumes \"ide a\"\n    shows \"\\<pp>\\<^sub>0[a, a] \\<cdot> \\<d>[a] = a\" and \"\\<pp>\\<^sub>1[a, a] \\<cdot> \\<d>[a] = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, a] \\<cdot> \\<d>[a] = a &&&\n    \\<pp>\\<^sub>1[a, a] \\<cdot> \\<d>[a] = a", "using assms"], ["proof (prove)\nusing this:\n  ide a\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, a] \\<cdot> \\<d>[a] = a &&&\n    \\<pp>\\<^sub>1[a, a] \\<cdot> \\<d>[a] = a", "by simp_all"], ["", "lemma prod_tuple:\n    assumes \"span f g\" and \"seq h f\" and \"seq k g\"\n    shows \"(h \\<otimes> k) \\<cdot> \\<langle>f, g\\<rangle> = \\<langle>h \\<cdot> f, k \\<cdot> g\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (h \\<otimes> k) \\<cdot> \\<langle>f, g\\<rangle> =\n    \\<langle>h \\<cdot> f, k \\<cdot> g\\<rangle>", "using assms prod_def comp_assoc comp_tuple_arr"], ["proof (prove)\nusing this:\n  span f g\n  seq h f\n  seq k g\n  ?f \\<otimes> ?g \\<equiv>\n  \\<langle>?f \\<cdot>\n           \\<pp>\\<^sub>1[local.dom\n                          ?f, local.dom\n                               ?g], ?g \\<cdot>\n                                    \\<pp>\\<^sub>0[local.dom\n             ?f, local.dom ?g]\\<rangle>\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n  \\<lbrakk>span ?f ?g; arr ?h; local.dom ?f = cod ?h\\<rbrakk>\n  \\<Longrightarrow> \\<langle>?f, ?g\\<rangle> \\<cdot> ?h =\n                    \\<langle>?f \\<cdot> ?h, ?g \\<cdot> ?h\\<rangle>\n\ngoal (1 subgoal):\n 1. (h \\<otimes> k) \\<cdot> \\<langle>f, g\\<rangle> =\n    \\<langle>h \\<cdot> f, k \\<cdot> g\\<rangle>", "by fastforce"], ["", "lemma tuple_eqI:\n    assumes \"seq \\<pp>\\<^sub>0[b, c] f\" and \"seq \\<pp>\\<^sub>1[b, c] f\"\n    and \"\\<pp>\\<^sub>0[b, c] \\<cdot> f = f0\" and \"\\<pp>\\<^sub>1[b, c] \\<cdot> f = f1\"\n    shows \"f = \\<langle>f1, f0\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = \\<langle>f1, f0\\<rangle>", "using assms pr_joint_monic [of b c \"\\<langle>f1, f0\\<rangle>\" f] pr_tuple"], ["proof (prove)\nusing this:\n  seq \\<pp>\\<^sub>0[b, c] f\n  seq \\<pp>\\<^sub>1[b, c] f\n  \\<pp>\\<^sub>0[b, c] \\<cdot> f = f0\n  \\<pp>\\<^sub>1[b, c] \\<cdot> f = f1\n  \\<lbrakk>seq \\<pp>\\<^sub>0[b, c] \\<langle>f1, f0\\<rangle>;\n   \\<pp>\\<^sub>0[b, c] \\<cdot> \\<langle>f1, f0\\<rangle> =\n   \\<pp>\\<^sub>0[b, c] \\<cdot> f;\n   \\<pp>\\<^sub>1[b, c] \\<cdot> \\<langle>f1, f0\\<rangle> =\n   \\<pp>\\<^sub>1[b, c] \\<cdot> f\\<rbrakk>\n  \\<Longrightarrow> \\<langle>f1, f0\\<rangle> = f\n  \\<lbrakk>span ?f ?g; cod ?f = ?a; cod ?g = ?b\\<rbrakk>\n  \\<Longrightarrow> \\<pp>\\<^sub>1[?a, ?b] \\<cdot> \\<langle>?f, ?g\\<rangle> =\n                    ?f\n  \\<lbrakk>span ?f ?g; cod ?f = ?a; cod ?g = ?b\\<rbrakk>\n  \\<Longrightarrow> \\<pp>\\<^sub>0[?a, ?b] \\<cdot> \\<langle>?f, ?g\\<rangle> =\n                    ?g\n\ngoal (1 subgoal):\n 1. f = \\<langle>f1, f0\\<rangle>", "by auto"], ["", "definition assoc (\"\\<a>[_, _, _]\")\n    where \"\\<a>[a, b, c] \\<equiv> \\<langle>\\<pp>\\<^sub>1[a, b] \\<cdot> \\<pp>\\<^sub>1[a \\<otimes> b, c], \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot> \\<pp>\\<^sub>1[a \\<otimes> b, c], \\<pp>\\<^sub>0[a \\<otimes> b, c]\\<rangle>\\<rangle>\""], ["", "definition assoc' (\"\\<a>\\<^sup>-\\<^sup>1[_, _, _]\")\n    where \"\\<a>\\<^sup>-\\<^sup>1[a, b, c] \\<equiv> \\<langle>\\<langle>\\<pp>\\<^sub>1[a, b \\<otimes> c], \\<pp>\\<^sub>1[b, c] \\<cdot> \\<pp>\\<^sub>0[a, b \\<otimes> c]\\<rangle>, \\<pp>\\<^sub>0[b, c] \\<cdot> \\<pp>\\<^sub>0[a, b \\<otimes> c]\\<rangle>\""], ["", "lemma assoc_in_hom [intro]:\n    assumes \"ide a\" and \"ide b\" and \"ide c\"\n    shows \"\\<guillemotleft>\\<a>[a, b, c] : (a \\<otimes> b) \\<otimes> c \\<rightarrow> a \\<otimes> (b \\<otimes> c)\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<a>[a, b, c] : (a \\<otimes> b) \\<otimes>\n                                    c \\<rightarrow> a \\<otimes>\n              b \\<otimes> c\\<guillemotright>", "using assms assoc_def"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<a>[?a, ?b, ?c] \\<equiv>\n  \\<langle>\\<pp>\\<^sub>1[?a, ?b] \\<cdot>\n           \\<pp>\\<^sub>1[?a \\<otimes>\n                         ?b, ?c], \\<langle>\\<pp>\\<^sub>0[?a, ?b] \\<cdot>\n     \\<pp>\\<^sub>1[?a \\<otimes>\n                   ?b, ?c], \\<pp>\\<^sub>0[?a \\<otimes>\n    ?b, ?c]\\<rangle>\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<a>[a, b, c] : (a \\<otimes> b) \\<otimes>\n                                    c \\<rightarrow> a \\<otimes>\n              b \\<otimes> c\\<guillemotright>", "by auto"], ["", "lemma assoc_simps [simp]:\n    assumes \"ide a\" and \"ide b\" and \"ide c\"\n    shows \"arr \\<a>[a, b, c]\"\n    and \"dom \\<a>[a, b, c] = (a \\<otimes> b) \\<otimes> c\"\n    and \"cod \\<a>[a, b, c] = a \\<otimes> (b \\<otimes> c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr \\<a>[a, b, c] &&&\n    local.dom \\<a>[a, b, c] = (a \\<otimes> b) \\<otimes> c &&&\n    cod \\<a>[a, b, c] = a \\<otimes> b \\<otimes> c", "using assms assoc_in_hom"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<lbrakk>ide ?a; ide ?b; ide ?c\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>\\<a>[?a, ?b, ?c] : (?a \\<otimes>\n                  ?b) \\<otimes>\n                 ?c \\<rightarrow> ?a \\<otimes>\n                                  ?b \\<otimes> ?c\\<guillemotright>\n\ngoal (1 subgoal):\n 1. arr \\<a>[a, b, c] &&&\n    local.dom \\<a>[a, b, c] = (a \\<otimes> b) \\<otimes> c &&&\n    cod \\<a>[a, b, c] = a \\<otimes> b \\<otimes> c", "by auto"], ["", "lemma assoc'_in_hom [intro]:\n    assumes \"ide a\" and \"ide b\" and \"ide c\"\n    shows \"\\<guillemotleft>\\<a>\\<^sup>-\\<^sup>1[a, b, c] : a \\<otimes> (b \\<otimes> c) \\<rightarrow> (a \\<otimes> b) \\<otimes> c\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<a>\\<^sup>-\\<^sup>1[a, b, c] : a \\<otimes>\n              b \\<otimes>\n              c \\<rightarrow> (a \\<otimes> b) \\<otimes> c\\<guillemotright>", "using assms assoc'_def"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<a>\\<^sup>-\\<^sup>1[?a, ?b, ?c] \\<equiv>\n  \\<langle>\\<langle>\\<pp>\\<^sub>1[?a, ?b \\<otimes>\n?c], \\<pp>\\<^sub>1[?b, ?c] \\<cdot>\n     \\<pp>\\<^sub>0[?a, ?b \\<otimes>\n                       ?c]\\<rangle>, \\<pp>\\<^sub>0[?b, ?c] \\<cdot>\n                                     \\<pp>\\<^sub>0[?a, ?b \\<otimes>\n                 ?c]\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<a>\\<^sup>-\\<^sup>1[a, b, c] : a \\<otimes>\n              b \\<otimes>\n              c \\<rightarrow> (a \\<otimes> b) \\<otimes> c\\<guillemotright>", "by auto"], ["", "lemma assoc'_simps [simp]:\n    assumes \"ide a\" and \"ide b\" and \"ide c\"\n    shows \"arr \\<a>\\<^sup>-\\<^sup>1[a, b, c]\"\n    and \"dom \\<a>\\<^sup>-\\<^sup>1[a, b, c] = a \\<otimes> (b \\<otimes> c)\"\n    and \"cod \\<a>\\<^sup>-\\<^sup>1[a, b, c] = (a \\<otimes> b) \\<otimes> c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr \\<a>\\<^sup>-\\<^sup>1[a, b, c] &&&\n    local.dom \\<a>\\<^sup>-\\<^sup>1[a, b, c] = a \\<otimes> b \\<otimes> c &&&\n    cod \\<a>\\<^sup>-\\<^sup>1[a, b, c] = (a \\<otimes> b) \\<otimes> c", "using assms assoc'_in_hom"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<lbrakk>ide ?a; ide ?b; ide ?c\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>\\<a>\\<^sup>-\\<^sup>1[?a, ?b, ?c] : ?a \\<otimes>\n                                 ?b \\<otimes>\n                                 ?c \\<rightarrow> (?a \\<otimes>\n             ?b) \\<otimes>\n            ?c\\<guillemotright>\n\ngoal (1 subgoal):\n 1. arr \\<a>\\<^sup>-\\<^sup>1[a, b, c] &&&\n    local.dom \\<a>\\<^sup>-\\<^sup>1[a, b, c] = a \\<otimes> b \\<otimes> c &&&\n    cod \\<a>\\<^sup>-\\<^sup>1[a, b, c] = (a \\<otimes> b) \\<otimes> c", "by auto"], ["", "lemma assoc_naturality:\n    assumes \"\\<guillemotleft>f0 : a0 \\<rightarrow> b0\\<guillemotright>\" and \"\\<guillemotleft>f1 : a1 \\<rightarrow> b1\\<guillemotright>\" and \"\\<guillemotleft>f2 : a2 \\<rightarrow> b2\\<guillemotright>\"\n    shows \"\\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) = (f0 \\<otimes> (f1 \\<otimes> f2)) \\<cdot> \\<a>[a0, a1, a2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "have \"\\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot> \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n            \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot> (f0 \\<otimes> (f1 \\<otimes> f2)) \\<cdot> \\<a>[a0, a1, a2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n    \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n    \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n    \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n    \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "have \"\\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot> \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n              (\\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot> \\<a>[b0, b1, b2]) \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n    \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n    (\\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot> \\<a>[b0, b1, b2]) \\<cdot>\n    ((f0 \\<otimes> f1) \\<otimes> f2)", "using comp_assoc"], ["proof (prove)\nusing this:\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n    \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n    (\\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot> \\<a>[b0, b1, b2]) \\<cdot>\n    ((f0 \\<otimes> f1) \\<otimes> f2)", "by simp"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n  \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n  (\\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot> \\<a>[b0, b1, b2]) \\<cdot>\n  ((f0 \\<otimes> f1) \\<otimes> f2)\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n    \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n    \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "also"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n  \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n  (\\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot> \\<a>[b0, b1, b2]) \\<cdot>\n  ((f0 \\<otimes> f1) \\<otimes> f2)\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n    \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n    \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "have \"... = \\<langle>\\<pp>\\<^sub>0[b0, b1] \\<cdot> \\<pp>\\<^sub>1[b0 \\<otimes> b1, b2], \\<pp>\\<^sub>0[b0 \\<otimes> b1, b2]\\<rangle> \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot> \\<a>[b0, b1, b2]) \\<cdot>\n    ((f0 \\<otimes> f1) \\<otimes> f2) =\n    \\<langle>\\<pp>\\<^sub>0[b0, b1] \\<cdot>\n             \\<pp>\\<^sub>1[b0 \\<otimes>\n                           b1, b2], \\<pp>\\<^sub>0[b0 \\<otimes>\n            b1, b2]\\<rangle> \\<cdot>\n    ((f0 \\<otimes> f1) \\<otimes> f2)", "using assms assoc_def"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f0 : a0 \\<rightarrow> b0\\<guillemotright>\n  \\<guillemotleft>f1 : a1 \\<rightarrow> b1\\<guillemotright>\n  \\<guillemotleft>f2 : a2 \\<rightarrow> b2\\<guillemotright>\n  \\<a>[?a, ?b, ?c] \\<equiv>\n  \\<langle>\\<pp>\\<^sub>1[?a, ?b] \\<cdot>\n           \\<pp>\\<^sub>1[?a \\<otimes>\n                         ?b, ?c], \\<langle>\\<pp>\\<^sub>0[?a, ?b] \\<cdot>\n     \\<pp>\\<^sub>1[?a \\<otimes>\n                   ?b, ?c], \\<pp>\\<^sub>0[?a \\<otimes>\n    ?b, ?c]\\<rangle>\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot> \\<a>[b0, b1, b2]) \\<cdot>\n    ((f0 \\<otimes> f1) \\<otimes> f2) =\n    \\<langle>\\<pp>\\<^sub>0[b0, b1] \\<cdot>\n             \\<pp>\\<^sub>1[b0 \\<otimes>\n                           b1, b2], \\<pp>\\<^sub>0[b0 \\<otimes>\n            b1, b2]\\<rangle> \\<cdot>\n    ((f0 \\<otimes> f1) \\<otimes> f2)", "by fastforce"], ["proof (state)\nthis:\n  (\\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot> \\<a>[b0, b1, b2]) \\<cdot>\n  ((f0 \\<otimes> f1) \\<otimes> f2) =\n  \\<langle>\\<pp>\\<^sub>0[b0, b1] \\<cdot>\n           \\<pp>\\<^sub>1[b0 \\<otimes>\n                         b1, b2], \\<pp>\\<^sub>0[b0 \\<otimes>\n          b1, b2]\\<rangle> \\<cdot>\n  ((f0 \\<otimes> f1) \\<otimes> f2)\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n    \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n    \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "also"], ["proof (state)\nthis:\n  (\\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot> \\<a>[b0, b1, b2]) \\<cdot>\n  ((f0 \\<otimes> f1) \\<otimes> f2) =\n  \\<langle>\\<pp>\\<^sub>0[b0, b1] \\<cdot>\n           \\<pp>\\<^sub>1[b0 \\<otimes>\n                         b1, b2], \\<pp>\\<^sub>0[b0 \\<otimes>\n          b1, b2]\\<rangle> \\<cdot>\n  ((f0 \\<otimes> f1) \\<otimes> f2)\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n    \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n    \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "have \"... = \\<langle>(\\<pp>\\<^sub>0[b0, b1] \\<cdot> \\<pp>\\<^sub>1[b0 \\<otimes> b1, b2]) \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2),\n                          \\<pp>\\<^sub>0[b0 \\<otimes> b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2)\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<pp>\\<^sub>0[b0, b1] \\<cdot>\n             \\<pp>\\<^sub>1[b0 \\<otimes>\n                           b1, b2], \\<pp>\\<^sub>0[b0 \\<otimes>\n            b1, b2]\\<rangle> \\<cdot>\n    ((f0 \\<otimes> f1) \\<otimes> f2) =\n    \\<langle>(\\<pp>\\<^sub>0[b0, b1] \\<cdot>\n              \\<pp>\\<^sub>1[b0 \\<otimes> b1, b2]) \\<cdot>\n             ((f0 \\<otimes> f1) \\<otimes>\n              f2), \\<pp>\\<^sub>0[b0 \\<otimes> b1, b2] \\<cdot>\n                   ((f0 \\<otimes> f1) \\<otimes> f2)\\<rangle>", "using assms comp_tuple_arr"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f0 : a0 \\<rightarrow> b0\\<guillemotright>\n  \\<guillemotleft>f1 : a1 \\<rightarrow> b1\\<guillemotright>\n  \\<guillemotleft>f2 : a2 \\<rightarrow> b2\\<guillemotright>\n  \\<lbrakk>span ?f ?g; arr ?h; local.dom ?f = cod ?h\\<rbrakk>\n  \\<Longrightarrow> \\<langle>?f, ?g\\<rangle> \\<cdot> ?h =\n                    \\<langle>?f \\<cdot> ?h, ?g \\<cdot> ?h\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>\\<pp>\\<^sub>0[b0, b1] \\<cdot>\n             \\<pp>\\<^sub>1[b0 \\<otimes>\n                           b1, b2], \\<pp>\\<^sub>0[b0 \\<otimes>\n            b1, b2]\\<rangle> \\<cdot>\n    ((f0 \\<otimes> f1) \\<otimes> f2) =\n    \\<langle>(\\<pp>\\<^sub>0[b0, b1] \\<cdot>\n              \\<pp>\\<^sub>1[b0 \\<otimes> b1, b2]) \\<cdot>\n             ((f0 \\<otimes> f1) \\<otimes>\n              f2), \\<pp>\\<^sub>0[b0 \\<otimes> b1, b2] \\<cdot>\n                   ((f0 \\<otimes> f1) \\<otimes> f2)\\<rangle>", "by fastforce"], ["proof (state)\nthis:\n  \\<langle>\\<pp>\\<^sub>0[b0, b1] \\<cdot>\n           \\<pp>\\<^sub>1[b0 \\<otimes>\n                         b1, b2], \\<pp>\\<^sub>0[b0 \\<otimes>\n          b1, b2]\\<rangle> \\<cdot>\n  ((f0 \\<otimes> f1) \\<otimes> f2) =\n  \\<langle>(\\<pp>\\<^sub>0[b0, b1] \\<cdot>\n            \\<pp>\\<^sub>1[b0 \\<otimes> b1, b2]) \\<cdot>\n           ((f0 \\<otimes> f1) \\<otimes>\n            f2), \\<pp>\\<^sub>0[b0 \\<otimes> b1, b2] \\<cdot>\n                 ((f0 \\<otimes> f1) \\<otimes> f2)\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n    \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n    \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "also"], ["proof (state)\nthis:\n  \\<langle>\\<pp>\\<^sub>0[b0, b1] \\<cdot>\n           \\<pp>\\<^sub>1[b0 \\<otimes>\n                         b1, b2], \\<pp>\\<^sub>0[b0 \\<otimes>\n          b1, b2]\\<rangle> \\<cdot>\n  ((f0 \\<otimes> f1) \\<otimes> f2) =\n  \\<langle>(\\<pp>\\<^sub>0[b0, b1] \\<cdot>\n            \\<pp>\\<^sub>1[b0 \\<otimes> b1, b2]) \\<cdot>\n           ((f0 \\<otimes> f1) \\<otimes>\n            f2), \\<pp>\\<^sub>0[b0 \\<otimes> b1, b2] \\<cdot>\n                 ((f0 \\<otimes> f1) \\<otimes> f2)\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n    \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n    \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "have \"... = \\<langle>(\\<pp>\\<^sub>0[b0, b1] \\<cdot> (f0 \\<otimes> f1)) \\<cdot> \\<pp>\\<^sub>1[a0 \\<otimes> a1, a2], f2 \\<cdot> \\<pp>\\<^sub>0[a0 \\<otimes> a1, a2]\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>(\\<pp>\\<^sub>0[b0, b1] \\<cdot>\n              \\<pp>\\<^sub>1[b0 \\<otimes> b1, b2]) \\<cdot>\n             ((f0 \\<otimes> f1) \\<otimes>\n              f2), \\<pp>\\<^sub>0[b0 \\<otimes> b1, b2] \\<cdot>\n                   ((f0 \\<otimes> f1) \\<otimes> f2)\\<rangle> =\n    \\<langle>(\\<pp>\\<^sub>0[b0, b1] \\<cdot> (f0 \\<otimes> f1)) \\<cdot>\n             \\<pp>\\<^sub>1[a0 \\<otimes>\n                           a1, a2], f2 \\<cdot>\n                                    \\<pp>\\<^sub>0[a0 \\<otimes>\n            a1, a2]\\<rangle>", "using assms comp_assoc"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f0 : a0 \\<rightarrow> b0\\<guillemotright>\n  \\<guillemotleft>f1 : a1 \\<rightarrow> b1\\<guillemotright>\n  \\<guillemotleft>f2 : a2 \\<rightarrow> b2\\<guillemotright>\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. \\<langle>(\\<pp>\\<^sub>0[b0, b1] \\<cdot>\n              \\<pp>\\<^sub>1[b0 \\<otimes> b1, b2]) \\<cdot>\n             ((f0 \\<otimes> f1) \\<otimes>\n              f2), \\<pp>\\<^sub>0[b0 \\<otimes> b1, b2] \\<cdot>\n                   ((f0 \\<otimes> f1) \\<otimes> f2)\\<rangle> =\n    \\<langle>(\\<pp>\\<^sub>0[b0, b1] \\<cdot> (f0 \\<otimes> f1)) \\<cdot>\n             \\<pp>\\<^sub>1[a0 \\<otimes>\n                           a1, a2], f2 \\<cdot>\n                                    \\<pp>\\<^sub>0[a0 \\<otimes>\n            a1, a2]\\<rangle>", "by fastforce"], ["proof (state)\nthis:\n  \\<langle>(\\<pp>\\<^sub>0[b0, b1] \\<cdot>\n            \\<pp>\\<^sub>1[b0 \\<otimes> b1, b2]) \\<cdot>\n           ((f0 \\<otimes> f1) \\<otimes>\n            f2), \\<pp>\\<^sub>0[b0 \\<otimes> b1, b2] \\<cdot>\n                 ((f0 \\<otimes> f1) \\<otimes> f2)\\<rangle> =\n  \\<langle>(\\<pp>\\<^sub>0[b0, b1] \\<cdot> (f0 \\<otimes> f1)) \\<cdot>\n           \\<pp>\\<^sub>1[a0 \\<otimes>\n                         a1, a2], f2 \\<cdot>\n                                  \\<pp>\\<^sub>0[a0 \\<otimes>\n          a1, a2]\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n    \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n    \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "also"], ["proof (state)\nthis:\n  \\<langle>(\\<pp>\\<^sub>0[b0, b1] \\<cdot>\n            \\<pp>\\<^sub>1[b0 \\<otimes> b1, b2]) \\<cdot>\n           ((f0 \\<otimes> f1) \\<otimes>\n            f2), \\<pp>\\<^sub>0[b0 \\<otimes> b1, b2] \\<cdot>\n                 ((f0 \\<otimes> f1) \\<otimes> f2)\\<rangle> =\n  \\<langle>(\\<pp>\\<^sub>0[b0, b1] \\<cdot> (f0 \\<otimes> f1)) \\<cdot>\n           \\<pp>\\<^sub>1[a0 \\<otimes>\n                         a1, a2], f2 \\<cdot>\n                                  \\<pp>\\<^sub>0[a0 \\<otimes>\n          a1, a2]\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n    \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n    \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "have \"... = \\<langle>f1 \\<cdot> \\<pp>\\<^sub>0[a0, a1] \\<cdot> \\<pp>\\<^sub>1[a0 \\<otimes> a1, a2], f2 \\<cdot> \\<pp>\\<^sub>0[a0 \\<otimes> a1, a2]\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>(\\<pp>\\<^sub>0[b0, b1] \\<cdot> (f0 \\<otimes> f1)) \\<cdot>\n             \\<pp>\\<^sub>1[a0 \\<otimes>\n                           a1, a2], f2 \\<cdot>\n                                    \\<pp>\\<^sub>0[a0 \\<otimes>\n            a1, a2]\\<rangle> =\n    \\<langle>f1 \\<cdot>\n             \\<pp>\\<^sub>0[a0, a1] \\<cdot>\n             \\<pp>\\<^sub>1[a0 \\<otimes>\n                           a1, a2], f2 \\<cdot>\n                                    \\<pp>\\<^sub>0[a0 \\<otimes>\n            a1, a2]\\<rangle>", "using assms comp_assoc"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f0 : a0 \\<rightarrow> b0\\<guillemotright>\n  \\<guillemotleft>f1 : a1 \\<rightarrow> b1\\<guillemotright>\n  \\<guillemotleft>f2 : a2 \\<rightarrow> b2\\<guillemotright>\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. \\<langle>(\\<pp>\\<^sub>0[b0, b1] \\<cdot> (f0 \\<otimes> f1)) \\<cdot>\n             \\<pp>\\<^sub>1[a0 \\<otimes>\n                           a1, a2], f2 \\<cdot>\n                                    \\<pp>\\<^sub>0[a0 \\<otimes>\n            a1, a2]\\<rangle> =\n    \\<langle>f1 \\<cdot>\n             \\<pp>\\<^sub>0[a0, a1] \\<cdot>\n             \\<pp>\\<^sub>1[a0 \\<otimes>\n                           a1, a2], f2 \\<cdot>\n                                    \\<pp>\\<^sub>0[a0 \\<otimes>\n            a1, a2]\\<rangle>", "by (metis in_homE pr_naturality(1))"], ["proof (state)\nthis:\n  \\<langle>(\\<pp>\\<^sub>0[b0, b1] \\<cdot> (f0 \\<otimes> f1)) \\<cdot>\n           \\<pp>\\<^sub>1[a0 \\<otimes>\n                         a1, a2], f2 \\<cdot>\n                                  \\<pp>\\<^sub>0[a0 \\<otimes>\n          a1, a2]\\<rangle> =\n  \\<langle>f1 \\<cdot>\n           \\<pp>\\<^sub>0[a0, a1] \\<cdot>\n           \\<pp>\\<^sub>1[a0 \\<otimes>\n                         a1, a2], f2 \\<cdot>\n                                  \\<pp>\\<^sub>0[a0 \\<otimes>\n          a1, a2]\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n    \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n    \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "also"], ["proof (state)\nthis:\n  \\<langle>(\\<pp>\\<^sub>0[b0, b1] \\<cdot> (f0 \\<otimes> f1)) \\<cdot>\n           \\<pp>\\<^sub>1[a0 \\<otimes>\n                         a1, a2], f2 \\<cdot>\n                                  \\<pp>\\<^sub>0[a0 \\<otimes>\n          a1, a2]\\<rangle> =\n  \\<langle>f1 \\<cdot>\n           \\<pp>\\<^sub>0[a0, a1] \\<cdot>\n           \\<pp>\\<^sub>1[a0 \\<otimes>\n                         a1, a2], f2 \\<cdot>\n                                  \\<pp>\\<^sub>0[a0 \\<otimes>\n          a1, a2]\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n    \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n    \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "have \"... = \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot> (f0 \\<otimes> (f1 \\<otimes> f2)) \\<cdot> \\<a>[a0, a1, a2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>f1 \\<cdot>\n             \\<pp>\\<^sub>0[a0, a1] \\<cdot>\n             \\<pp>\\<^sub>1[a0 \\<otimes>\n                           a1, a2], f2 \\<cdot>\n                                    \\<pp>\\<^sub>0[a0 \\<otimes>\n            a1, a2]\\<rangle> =\n    \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "using assms comp_assoc assoc_def prod_tuple"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f0 : a0 \\<rightarrow> b0\\<guillemotright>\n  \\<guillemotleft>f1 : a1 \\<rightarrow> b1\\<guillemotright>\n  \\<guillemotleft>f2 : a2 \\<rightarrow> b2\\<guillemotright>\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n  \\<a>[?a, ?b, ?c] \\<equiv>\n  \\<langle>\\<pp>\\<^sub>1[?a, ?b] \\<cdot>\n           \\<pp>\\<^sub>1[?a \\<otimes>\n                         ?b, ?c], \\<langle>\\<pp>\\<^sub>0[?a, ?b] \\<cdot>\n     \\<pp>\\<^sub>1[?a \\<otimes>\n                   ?b, ?c], \\<pp>\\<^sub>0[?a \\<otimes>\n    ?b, ?c]\\<rangle>\\<rangle>\n  \\<lbrakk>span ?f ?g; seq ?h ?f; seq ?k ?g\\<rbrakk>\n  \\<Longrightarrow> (?h \\<otimes> ?k) \\<cdot> \\<langle>?f, ?g\\<rangle> =\n                    \\<langle>?h \\<cdot> ?f, ?k \\<cdot> ?g\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<langle>f1 \\<cdot>\n             \\<pp>\\<^sub>0[a0, a1] \\<cdot>\n             \\<pp>\\<^sub>1[a0 \\<otimes>\n                           a1, a2], f2 \\<cdot>\n                                    \\<pp>\\<^sub>0[a0 \\<otimes>\n            a1, a2]\\<rangle> =\n    \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "by fastforce"], ["proof (state)\nthis:\n  \\<langle>f1 \\<cdot>\n           \\<pp>\\<^sub>0[a0, a1] \\<cdot>\n           \\<pp>\\<^sub>1[a0 \\<otimes>\n                         a1, a2], f2 \\<cdot>\n                                  \\<pp>\\<^sub>0[a0 \\<otimes>\n          a1, a2]\\<rangle> =\n  \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n  (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n    \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n    \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "finally"], ["proof (chain)\npicking this:\n  \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n  \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n  \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n  (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n  \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n  \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n  (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n    \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n    \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "by blast"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n  \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n  \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n  (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n  \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n  \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n  (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]\n\ngoal (1 subgoal):\n 1. \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "moreover"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n  \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n  \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n  (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]\n\ngoal (1 subgoal):\n 1. \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "have \"\\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot> \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n                     \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot> (f0 \\<otimes> (f1 \\<otimes> f2)) \\<cdot> \\<a>[a0, a1, a2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n    \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n    \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n    \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n    \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "have \"\\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot> \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n              (\\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot> \\<a>[b0, b1, b2]) \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n    \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n    (\\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot> \\<a>[b0, b1, b2]) \\<cdot>\n    ((f0 \\<otimes> f1) \\<otimes> f2)", "using comp_assoc"], ["proof (prove)\nusing this:\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n    \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n    (\\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot> \\<a>[b0, b1, b2]) \\<cdot>\n    ((f0 \\<otimes> f1) \\<otimes> f2)", "by simp"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n  \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n  (\\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot> \\<a>[b0, b1, b2]) \\<cdot>\n  ((f0 \\<otimes> f1) \\<otimes> f2)\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n    \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n    \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "also"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n  \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n  (\\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot> \\<a>[b0, b1, b2]) \\<cdot>\n  ((f0 \\<otimes> f1) \\<otimes> f2)\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n    \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n    \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "have \"... = (\\<pp>\\<^sub>1[b0, b1] \\<cdot> \\<pp>\\<^sub>1[b0 \\<otimes> b1, b2]) \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot> \\<a>[b0, b1, b2]) \\<cdot>\n    ((f0 \\<otimes> f1) \\<otimes> f2) =\n    (\\<pp>\\<^sub>1[b0, b1] \\<cdot>\n     \\<pp>\\<^sub>1[b0 \\<otimes> b1, b2]) \\<cdot>\n    ((f0 \\<otimes> f1) \\<otimes> f2)", "using assms assoc_def"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f0 : a0 \\<rightarrow> b0\\<guillemotright>\n  \\<guillemotleft>f1 : a1 \\<rightarrow> b1\\<guillemotright>\n  \\<guillemotleft>f2 : a2 \\<rightarrow> b2\\<guillemotright>\n  \\<a>[?a, ?b, ?c] \\<equiv>\n  \\<langle>\\<pp>\\<^sub>1[?a, ?b] \\<cdot>\n           \\<pp>\\<^sub>1[?a \\<otimes>\n                         ?b, ?c], \\<langle>\\<pp>\\<^sub>0[?a, ?b] \\<cdot>\n     \\<pp>\\<^sub>1[?a \\<otimes>\n                   ?b, ?c], \\<pp>\\<^sub>0[?a \\<otimes>\n    ?b, ?c]\\<rangle>\\<rangle>\n\ngoal (1 subgoal):\n 1. (\\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot> \\<a>[b0, b1, b2]) \\<cdot>\n    ((f0 \\<otimes> f1) \\<otimes> f2) =\n    (\\<pp>\\<^sub>1[b0, b1] \\<cdot>\n     \\<pp>\\<^sub>1[b0 \\<otimes> b1, b2]) \\<cdot>\n    ((f0 \\<otimes> f1) \\<otimes> f2)", "by fastforce"], ["proof (state)\nthis:\n  (\\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot> \\<a>[b0, b1, b2]) \\<cdot>\n  ((f0 \\<otimes> f1) \\<otimes> f2) =\n  (\\<pp>\\<^sub>1[b0, b1] \\<cdot> \\<pp>\\<^sub>1[b0 \\<otimes> b1, b2]) \\<cdot>\n  ((f0 \\<otimes> f1) \\<otimes> f2)\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n    \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n    \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "also"], ["proof (state)\nthis:\n  (\\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot> \\<a>[b0, b1, b2]) \\<cdot>\n  ((f0 \\<otimes> f1) \\<otimes> f2) =\n  (\\<pp>\\<^sub>1[b0, b1] \\<cdot> \\<pp>\\<^sub>1[b0 \\<otimes> b1, b2]) \\<cdot>\n  ((f0 \\<otimes> f1) \\<otimes> f2)\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n    \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n    \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "have \"... = (\\<pp>\\<^sub>1[b0, b1] \\<cdot> (f0 \\<otimes> f1)) \\<cdot> \\<pp>\\<^sub>1[a0 \\<otimes> a1, a2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<pp>\\<^sub>1[b0, b1] \\<cdot>\n     \\<pp>\\<^sub>1[b0 \\<otimes> b1, b2]) \\<cdot>\n    ((f0 \\<otimes> f1) \\<otimes> f2) =\n    (\\<pp>\\<^sub>1[b0, b1] \\<cdot> (f0 \\<otimes> f1)) \\<cdot>\n    \\<pp>\\<^sub>1[a0 \\<otimes> a1, a2]", "using assms comp_assoc"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f0 : a0 \\<rightarrow> b0\\<guillemotright>\n  \\<guillemotleft>f1 : a1 \\<rightarrow> b1\\<guillemotright>\n  \\<guillemotleft>f2 : a2 \\<rightarrow> b2\\<guillemotright>\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. (\\<pp>\\<^sub>1[b0, b1] \\<cdot>\n     \\<pp>\\<^sub>1[b0 \\<otimes> b1, b2]) \\<cdot>\n    ((f0 \\<otimes> f1) \\<otimes> f2) =\n    (\\<pp>\\<^sub>1[b0, b1] \\<cdot> (f0 \\<otimes> f1)) \\<cdot>\n    \\<pp>\\<^sub>1[a0 \\<otimes> a1, a2]", "by fastforce"], ["proof (state)\nthis:\n  (\\<pp>\\<^sub>1[b0, b1] \\<cdot> \\<pp>\\<^sub>1[b0 \\<otimes> b1, b2]) \\<cdot>\n  ((f0 \\<otimes> f1) \\<otimes> f2) =\n  (\\<pp>\\<^sub>1[b0, b1] \\<cdot> (f0 \\<otimes> f1)) \\<cdot>\n  \\<pp>\\<^sub>1[a0 \\<otimes> a1, a2]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n    \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n    \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "also"], ["proof (state)\nthis:\n  (\\<pp>\\<^sub>1[b0, b1] \\<cdot> \\<pp>\\<^sub>1[b0 \\<otimes> b1, b2]) \\<cdot>\n  ((f0 \\<otimes> f1) \\<otimes> f2) =\n  (\\<pp>\\<^sub>1[b0, b1] \\<cdot> (f0 \\<otimes> f1)) \\<cdot>\n  \\<pp>\\<^sub>1[a0 \\<otimes> a1, a2]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n    \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n    \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "have \"... = f0 \\<cdot> \\<pp>\\<^sub>1[a0, a1] \\<cdot> \\<pp>\\<^sub>1[a0 \\<otimes> a1, a2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<pp>\\<^sub>1[b0, b1] \\<cdot> (f0 \\<otimes> f1)) \\<cdot>\n    \\<pp>\\<^sub>1[a0 \\<otimes> a1, a2] =\n    f0 \\<cdot>\n    \\<pp>\\<^sub>1[a0, a1] \\<cdot> \\<pp>\\<^sub>1[a0 \\<otimes> a1, a2]", "using assms comp_assoc"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f0 : a0 \\<rightarrow> b0\\<guillemotright>\n  \\<guillemotleft>f1 : a1 \\<rightarrow> b1\\<guillemotright>\n  \\<guillemotleft>f2 : a2 \\<rightarrow> b2\\<guillemotright>\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. (\\<pp>\\<^sub>1[b0, b1] \\<cdot> (f0 \\<otimes> f1)) \\<cdot>\n    \\<pp>\\<^sub>1[a0 \\<otimes> a1, a2] =\n    f0 \\<cdot>\n    \\<pp>\\<^sub>1[a0, a1] \\<cdot> \\<pp>\\<^sub>1[a0 \\<otimes> a1, a2]", "by (metis in_homE pr_naturality(2))"], ["proof (state)\nthis:\n  (\\<pp>\\<^sub>1[b0, b1] \\<cdot> (f0 \\<otimes> f1)) \\<cdot>\n  \\<pp>\\<^sub>1[a0 \\<otimes> a1, a2] =\n  f0 \\<cdot>\n  \\<pp>\\<^sub>1[a0, a1] \\<cdot> \\<pp>\\<^sub>1[a0 \\<otimes> a1, a2]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n    \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n    \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "also"], ["proof (state)\nthis:\n  (\\<pp>\\<^sub>1[b0, b1] \\<cdot> (f0 \\<otimes> f1)) \\<cdot>\n  \\<pp>\\<^sub>1[a0 \\<otimes> a1, a2] =\n  f0 \\<cdot>\n  \\<pp>\\<^sub>1[a0, a1] \\<cdot> \\<pp>\\<^sub>1[a0 \\<otimes> a1, a2]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n    \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n    \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "have \"... = \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot> (f0 \\<otimes> (f1 \\<otimes> f2)) \\<cdot> \\<a>[a0, a1, a2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f0 \\<cdot>\n    \\<pp>\\<^sub>1[a0, a1] \\<cdot> \\<pp>\\<^sub>1[a0 \\<otimes> a1, a2] =\n    \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f0 \\<cdot>\n    \\<pp>\\<^sub>1[a0, a1] \\<cdot> \\<pp>\\<^sub>1[a0 \\<otimes> a1, a2] =\n    \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "have \"\\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot> (f0 \\<otimes> (f1 \\<otimes> f2)) \\<cdot> \\<a>[a0, a1, a2] =\n                (\\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot> (f0 \\<otimes> (f1 \\<otimes> f2))) \\<cdot> \\<a>[a0, a1, a2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2] =\n    (\\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n     (f0 \\<otimes> f1 \\<otimes> f2)) \\<cdot>\n    \\<a>[a0, a1, a2]", "using comp_assoc"], ["proof (prove)\nusing this:\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2] =\n    (\\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n     (f0 \\<otimes> f1 \\<otimes> f2)) \\<cdot>\n    \\<a>[a0, a1, a2]", "by simp"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n  (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2] =\n  (\\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n   (f0 \\<otimes> f1 \\<otimes> f2)) \\<cdot>\n  \\<a>[a0, a1, a2]\n\ngoal (1 subgoal):\n 1. f0 \\<cdot>\n    \\<pp>\\<^sub>1[a0, a1] \\<cdot> \\<pp>\\<^sub>1[a0 \\<otimes> a1, a2] =\n    \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "also"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n  (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2] =\n  (\\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n   (f0 \\<otimes> f1 \\<otimes> f2)) \\<cdot>\n  \\<a>[a0, a1, a2]\n\ngoal (1 subgoal):\n 1. f0 \\<cdot>\n    \\<pp>\\<^sub>1[a0, a1] \\<cdot> \\<pp>\\<^sub>1[a0 \\<otimes> a1, a2] =\n    \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "have \"... = f0 \\<cdot> \\<pp>\\<^sub>1[a0, a1 \\<otimes> a2] \\<cdot> \\<a>[a0, a1, a2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n     (f0 \\<otimes> f1 \\<otimes> f2)) \\<cdot>\n    \\<a>[a0, a1, a2] =\n    f0 \\<cdot> \\<pp>\\<^sub>1[a0, a1 \\<otimes> a2] \\<cdot> \\<a>[a0, a1, a2]", "using assms comp_assoc"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f0 : a0 \\<rightarrow> b0\\<guillemotright>\n  \\<guillemotleft>f1 : a1 \\<rightarrow> b1\\<guillemotright>\n  \\<guillemotleft>f2 : a2 \\<rightarrow> b2\\<guillemotright>\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. (\\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n     (f0 \\<otimes> f1 \\<otimes> f2)) \\<cdot>\n    \\<a>[a0, a1, a2] =\n    f0 \\<cdot> \\<pp>\\<^sub>1[a0, a1 \\<otimes> a2] \\<cdot> \\<a>[a0, a1, a2]", "by fastforce"], ["proof (state)\nthis:\n  (\\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n   (f0 \\<otimes> f1 \\<otimes> f2)) \\<cdot>\n  \\<a>[a0, a1, a2] =\n  f0 \\<cdot> \\<pp>\\<^sub>1[a0, a1 \\<otimes> a2] \\<cdot> \\<a>[a0, a1, a2]\n\ngoal (1 subgoal):\n 1. f0 \\<cdot>\n    \\<pp>\\<^sub>1[a0, a1] \\<cdot> \\<pp>\\<^sub>1[a0 \\<otimes> a1, a2] =\n    \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "also"], ["proof (state)\nthis:\n  (\\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n   (f0 \\<otimes> f1 \\<otimes> f2)) \\<cdot>\n  \\<a>[a0, a1, a2] =\n  f0 \\<cdot> \\<pp>\\<^sub>1[a0, a1 \\<otimes> a2] \\<cdot> \\<a>[a0, a1, a2]\n\ngoal (1 subgoal):\n 1. f0 \\<cdot>\n    \\<pp>\\<^sub>1[a0, a1] \\<cdot> \\<pp>\\<^sub>1[a0 \\<otimes> a1, a2] =\n    \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "have \"... = f0 \\<cdot> \\<pp>\\<^sub>1[a0, a1] \\<cdot> \\<pp>\\<^sub>1[a0 \\<otimes> a1, a2]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f0 \\<cdot> \\<pp>\\<^sub>1[a0, a1 \\<otimes> a2] \\<cdot> \\<a>[a0, a1, a2] =\n    f0 \\<cdot>\n    \\<pp>\\<^sub>1[a0, a1] \\<cdot> \\<pp>\\<^sub>1[a0 \\<otimes> a1, a2]", "using assms assoc_def"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f0 : a0 \\<rightarrow> b0\\<guillemotright>\n  \\<guillemotleft>f1 : a1 \\<rightarrow> b1\\<guillemotright>\n  \\<guillemotleft>f2 : a2 \\<rightarrow> b2\\<guillemotright>\n  \\<a>[?a, ?b, ?c] \\<equiv>\n  \\<langle>\\<pp>\\<^sub>1[?a, ?b] \\<cdot>\n           \\<pp>\\<^sub>1[?a \\<otimes>\n                         ?b, ?c], \\<langle>\\<pp>\\<^sub>0[?a, ?b] \\<cdot>\n     \\<pp>\\<^sub>1[?a \\<otimes>\n                   ?b, ?c], \\<pp>\\<^sub>0[?a \\<otimes>\n    ?b, ?c]\\<rangle>\\<rangle>\n\ngoal (1 subgoal):\n 1. f0 \\<cdot> \\<pp>\\<^sub>1[a0, a1 \\<otimes> a2] \\<cdot> \\<a>[a0, a1, a2] =\n    f0 \\<cdot>\n    \\<pp>\\<^sub>1[a0, a1] \\<cdot> \\<pp>\\<^sub>1[a0 \\<otimes> a1, a2]", "by fastforce"], ["proof (state)\nthis:\n  f0 \\<cdot> \\<pp>\\<^sub>1[a0, a1 \\<otimes> a2] \\<cdot> \\<a>[a0, a1, a2] =\n  f0 \\<cdot>\n  \\<pp>\\<^sub>1[a0, a1] \\<cdot> \\<pp>\\<^sub>1[a0 \\<otimes> a1, a2]\n\ngoal (1 subgoal):\n 1. f0 \\<cdot>\n    \\<pp>\\<^sub>1[a0, a1] \\<cdot> \\<pp>\\<^sub>1[a0 \\<otimes> a1, a2] =\n    \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "finally"], ["proof (chain)\npicking this:\n  \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n  (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2] =\n  f0 \\<cdot>\n  \\<pp>\\<^sub>1[a0, a1] \\<cdot> \\<pp>\\<^sub>1[a0 \\<otimes> a1, a2]", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n  (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2] =\n  f0 \\<cdot>\n  \\<pp>\\<^sub>1[a0, a1] \\<cdot> \\<pp>\\<^sub>1[a0 \\<otimes> a1, a2]\n\ngoal (1 subgoal):\n 1. f0 \\<cdot>\n    \\<pp>\\<^sub>1[a0, a1] \\<cdot> \\<pp>\\<^sub>1[a0 \\<otimes> a1, a2] =\n    \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "by simp"], ["proof (state)\nthis:\n  f0 \\<cdot>\n  \\<pp>\\<^sub>1[a0, a1] \\<cdot> \\<pp>\\<^sub>1[a0 \\<otimes> a1, a2] =\n  \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n  (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f0 \\<cdot>\n  \\<pp>\\<^sub>1[a0, a1] \\<cdot> \\<pp>\\<^sub>1[a0 \\<otimes> a1, a2] =\n  \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n  (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n    \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n    \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "finally"], ["proof (chain)\npicking this:\n  \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n  \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n  \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n  (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n  \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n  \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n  (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n    \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n    \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "by blast"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n  \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n  \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n  (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n  \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n  \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n  (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]\n\ngoal (1 subgoal):\n 1. \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "ultimately"], ["proof (chain)\npicking this:\n  \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n  \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n  \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n  (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]\n  \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n  \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n  \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n  (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n  \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n  \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n  (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]\n  \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n  \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n  \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n  (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]\n\ngoal (1 subgoal):\n 1. \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "using assms pr_joint_monic [of b0 \"b1 \\<otimes> b2\" \"\\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2)\"\n                                       \"(f0 \\<otimes> (f1 \\<otimes> f2)) \\<cdot> \\<a>[a0, a1, a2]\"]"], ["proof (prove)\nusing this:\n  \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n  \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n  \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n  (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]\n  \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n  \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n  \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n  (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]\n  \\<guillemotleft>f0 : a0 \\<rightarrow> b0\\<guillemotright>\n  \\<guillemotleft>f1 : a1 \\<rightarrow> b1\\<guillemotright>\n  \\<guillemotleft>f2 : a2 \\<rightarrow> b2\\<guillemotright>\n  \\<lbrakk>seq \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2]\n            (\\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2));\n   \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n   \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n   \\<pp>\\<^sub>0[b0, b1 \\<otimes> b2] \\<cdot>\n   (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2];\n   \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n   \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n   \\<pp>\\<^sub>1[b0, b1 \\<otimes> b2] \\<cdot>\n   (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]\\<rbrakk>\n  \\<Longrightarrow> \\<a>[b0, b1, b2] \\<cdot>\n                    ((f0 \\<otimes> f1) \\<otimes> f2) =\n                    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]\n\ngoal (1 subgoal):\n 1. \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n    (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]", "by fastforce"], ["proof (state)\nthis:\n  \\<a>[b0, b1, b2] \\<cdot> ((f0 \\<otimes> f1) \\<otimes> f2) =\n  (f0 \\<otimes> f1 \\<otimes> f2) \\<cdot> \\<a>[a0, a1, a2]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma pentagon:\n    assumes \"ide a\" and \"ide b\" and \"ide c\" and \"ide d\"\n    shows \"((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot> (\\<a>[a, b, c] \\<otimes> d) = \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]", "proof (intro pr_joint_monic\n                   [where h = \"((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot> (\\<a>[a, b, c] \\<otimes> d)\"\n                      and h' = \"\\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]\"])"], ["proof (state)\ngoal (3 subgoals):\n 1. seq \\<pp>\\<^sub>0[?a, ?b]\n     (((a \\<otimes> \\<a>[b, c, d]) \\<cdot>\n       \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n      (\\<a>[a, b, c] \\<otimes> d))\n 2. \\<pp>\\<^sub>0[?a, ?b] \\<cdot>\n    ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    \\<pp>\\<^sub>0[?a, ?b] \\<cdot>\n    \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]\n 3. \\<pp>\\<^sub>1[?a, ?b] \\<cdot>\n    ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    \\<pp>\\<^sub>1[?a, ?b] \\<cdot>\n    \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]", "show \"seq \\<pp>\\<^sub>0[a, b \\<otimes> (c \\<otimes> d)] (((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot> (\\<a>[a, b, c] \\<otimes> d))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d]\n     (((a \\<otimes> \\<a>[b, c, d]) \\<cdot>\n       \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n      (\\<a>[a, b, c] \\<otimes> d))", "using assms"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  ide d\n\ngoal (1 subgoal):\n 1. seq \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d]\n     (((a \\<otimes> \\<a>[b, c, d]) \\<cdot>\n       \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n      (\\<a>[a, b, c] \\<otimes> d))", "by simp"], ["proof (state)\nthis:\n  seq \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d]\n   (((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d))\n\ngoal (2 subgoals):\n 1. \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]\n 2. \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]", "show \"\\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot> ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot> (\\<a>[a, b, c] \\<otimes> d) =\n            \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot> \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]", "have \"\\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot> ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot> (\\<a>[a, b, c] \\<otimes> d) =\n              ((\\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot> (a \\<otimes> \\<a>[b, c, d])) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot> (\\<a>[a, b, c] \\<otimes> d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    ((\\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n      (a \\<otimes> \\<a>[b, c, d])) \\<cdot>\n     \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d)", "using comp_assoc"], ["proof (prove)\nusing this:\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    ((\\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n      (a \\<otimes> \\<a>[b, c, d])) \\<cdot>\n     \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d)", "by simp"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n  ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n  (\\<a>[a, b, c] \\<otimes> d) =\n  ((\\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    (a \\<otimes> \\<a>[b, c, d])) \\<cdot>\n   \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n  (\\<a>[a, b, c] \\<otimes> d)\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]", "also"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n  ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n  (\\<a>[a, b, c] \\<otimes> d) =\n  ((\\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    (a \\<otimes> \\<a>[b, c, d])) \\<cdot>\n   \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n  (\\<a>[a, b, c] \\<otimes> d)\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]", "have \"... = (\\<pp>\\<^sub>1[a, (b \\<otimes> c) \\<otimes> d] \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot> (\\<a>[a, b, c] \\<otimes> d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n      (a \\<otimes> \\<a>[b, c, d])) \\<cdot>\n     \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    (\\<pp>\\<^sub>1[a, (b \\<otimes> c) \\<otimes> d] \\<cdot>\n     \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d)", "using assms pr_naturality(2) comp_cod_arr"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  ide d\n  \\<lbrakk>arr ?g; local.dom ?g = ?b; cod ?g = ?d; arr ?f;\n   local.dom ?f = ?a; cod ?f = ?c\\<rbrakk>\n  \\<Longrightarrow> \\<pp>\\<^sub>1[?c, ?d] \\<cdot> (?f \\<otimes> ?g) =\n                    ?f \\<cdot> \\<pp>\\<^sub>1[?a, ?b]\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n\ngoal (1 subgoal):\n 1. ((\\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n      (a \\<otimes> \\<a>[b, c, d])) \\<cdot>\n     \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    (\\<pp>\\<^sub>1[a, (b \\<otimes> c) \\<otimes> d] \\<cdot>\n     \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d)", "by force"], ["proof (state)\nthis:\n  ((\\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    (a \\<otimes> \\<a>[b, c, d])) \\<cdot>\n   \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n  (\\<a>[a, b, c] \\<otimes> d) =\n  (\\<pp>\\<^sub>1[a, (b \\<otimes> c) \\<otimes> d] \\<cdot>\n   \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n  (\\<a>[a, b, c] \\<otimes> d)\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]", "also"], ["proof (state)\nthis:\n  ((\\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    (a \\<otimes> \\<a>[b, c, d])) \\<cdot>\n   \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n  (\\<a>[a, b, c] \\<otimes> d) =\n  (\\<pp>\\<^sub>1[a, (b \\<otimes> c) \\<otimes> d] \\<cdot>\n   \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n  (\\<a>[a, b, c] \\<otimes> d)\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]", "have \"... = \\<pp>\\<^sub>1[a, b \\<otimes> c] \\<cdot> \\<pp>\\<^sub>1[a \\<otimes> b \\<otimes> c, d] \\<cdot> (\\<a>[a, b, c] \\<otimes> d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<pp>\\<^sub>1[a, (b \\<otimes> c) \\<otimes> d] \\<cdot>\n     \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    \\<pp>\\<^sub>1[a, b \\<otimes> c] \\<cdot>\n    \\<pp>\\<^sub>1[a \\<otimes> b \\<otimes> c, d] \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d)", "using assms assoc_def comp_assoc"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  ide d\n  \\<a>[?a, ?b, ?c] \\<equiv>\n  \\<langle>\\<pp>\\<^sub>1[?a, ?b] \\<cdot>\n           \\<pp>\\<^sub>1[?a \\<otimes>\n                         ?b, ?c], \\<langle>\\<pp>\\<^sub>0[?a, ?b] \\<cdot>\n     \\<pp>\\<^sub>1[?a \\<otimes>\n                   ?b, ?c], \\<pp>\\<^sub>0[?a \\<otimes>\n    ?b, ?c]\\<rangle>\\<rangle>\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. (\\<pp>\\<^sub>1[a, (b \\<otimes> c) \\<otimes> d] \\<cdot>\n     \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    \\<pp>\\<^sub>1[a, b \\<otimes> c] \\<cdot>\n    \\<pp>\\<^sub>1[a \\<otimes> b \\<otimes> c, d] \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d)", "by simp"], ["proof (state)\nthis:\n  (\\<pp>\\<^sub>1[a, (b \\<otimes> c) \\<otimes> d] \\<cdot>\n   \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n  (\\<a>[a, b, c] \\<otimes> d) =\n  \\<pp>\\<^sub>1[a, b \\<otimes> c] \\<cdot>\n  \\<pp>\\<^sub>1[a \\<otimes> b \\<otimes> c, d] \\<cdot>\n  (\\<a>[a, b, c] \\<otimes> d)\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]", "also"], ["proof (state)\nthis:\n  (\\<pp>\\<^sub>1[a, (b \\<otimes> c) \\<otimes> d] \\<cdot>\n   \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n  (\\<a>[a, b, c] \\<otimes> d) =\n  \\<pp>\\<^sub>1[a, b \\<otimes> c] \\<cdot>\n  \\<pp>\\<^sub>1[a \\<otimes> b \\<otimes> c, d] \\<cdot>\n  (\\<a>[a, b, c] \\<otimes> d)\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]", "have \"... = (\\<pp>\\<^sub>1[a, b \\<otimes> c] \\<cdot> \\<a>[a, b, c]) \\<cdot> \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes> c, d]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, b \\<otimes> c] \\<cdot>\n    \\<pp>\\<^sub>1[a \\<otimes> b \\<otimes> c, d] \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    (\\<pp>\\<^sub>1[a, b \\<otimes> c] \\<cdot> \\<a>[a, b, c]) \\<cdot>\n    \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes> c, d]", "using assms pr_naturality(2) comp_assoc"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  ide d\n  \\<lbrakk>arr ?g; local.dom ?g = ?b; cod ?g = ?d; arr ?f;\n   local.dom ?f = ?a; cod ?f = ?c\\<rbrakk>\n  \\<Longrightarrow> \\<pp>\\<^sub>1[?c, ?d] \\<cdot> (?f \\<otimes> ?g) =\n                    ?f \\<cdot> \\<pp>\\<^sub>1[?a, ?b]\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, b \\<otimes> c] \\<cdot>\n    \\<pp>\\<^sub>1[a \\<otimes> b \\<otimes> c, d] \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    (\\<pp>\\<^sub>1[a, b \\<otimes> c] \\<cdot> \\<a>[a, b, c]) \\<cdot>\n    \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes> c, d]", "by fastforce"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>1[a, b \\<otimes> c] \\<cdot>\n  \\<pp>\\<^sub>1[a \\<otimes> b \\<otimes> c, d] \\<cdot>\n  (\\<a>[a, b, c] \\<otimes> d) =\n  (\\<pp>\\<^sub>1[a, b \\<otimes> c] \\<cdot> \\<a>[a, b, c]) \\<cdot>\n  \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes> c, d]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]", "also"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>1[a, b \\<otimes> c] \\<cdot>\n  \\<pp>\\<^sub>1[a \\<otimes> b \\<otimes> c, d] \\<cdot>\n  (\\<a>[a, b, c] \\<otimes> d) =\n  (\\<pp>\\<^sub>1[a, b \\<otimes> c] \\<cdot> \\<a>[a, b, c]) \\<cdot>\n  \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes> c, d]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]", "have \"... = \\<pp>\\<^sub>1[a, b] \\<cdot> \\<pp>\\<^sub>1[a \\<otimes> b, c] \\<cdot> \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes> c, d]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<pp>\\<^sub>1[a, b \\<otimes> c] \\<cdot> \\<a>[a, b, c]) \\<cdot>\n    \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes> c, d] =\n    \\<pp>\\<^sub>1[a, b] \\<cdot>\n    \\<pp>\\<^sub>1[a \\<otimes> b, c] \\<cdot>\n    \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes> c, d]", "using assms assoc_def comp_assoc"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  ide d\n  \\<a>[?a, ?b, ?c] \\<equiv>\n  \\<langle>\\<pp>\\<^sub>1[?a, ?b] \\<cdot>\n           \\<pp>\\<^sub>1[?a \\<otimes>\n                         ?b, ?c], \\<langle>\\<pp>\\<^sub>0[?a, ?b] \\<cdot>\n     \\<pp>\\<^sub>1[?a \\<otimes>\n                   ?b, ?c], \\<pp>\\<^sub>0[?a \\<otimes>\n    ?b, ?c]\\<rangle>\\<rangle>\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. (\\<pp>\\<^sub>1[a, b \\<otimes> c] \\<cdot> \\<a>[a, b, c]) \\<cdot>\n    \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes> c, d] =\n    \\<pp>\\<^sub>1[a, b] \\<cdot>\n    \\<pp>\\<^sub>1[a \\<otimes> b, c] \\<cdot>\n    \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes> c, d]", "by simp"], ["proof (state)\nthis:\n  (\\<pp>\\<^sub>1[a, b \\<otimes> c] \\<cdot> \\<a>[a, b, c]) \\<cdot>\n  \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes> c, d] =\n  \\<pp>\\<^sub>1[a, b] \\<cdot>\n  \\<pp>\\<^sub>1[a \\<otimes> b, c] \\<cdot>\n  \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes> c, d]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]", "finally"], ["proof (chain)\npicking this:\n  \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n  ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n  (\\<a>[a, b, c] \\<otimes> d) =\n  \\<pp>\\<^sub>1[a, b] \\<cdot>\n  \\<pp>\\<^sub>1[a \\<otimes> b, c] \\<cdot>\n  \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes> c, d]", "have \"\\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot> ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot> (\\<a>[a, b, c] \\<otimes> d) =\n                      \\<pp>\\<^sub>1[a, b] \\<cdot> \\<pp>\\<^sub>1[a \\<otimes> b, c] \\<cdot> \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes> c, d]\""], ["proof (prove)\nusing this:\n  \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n  ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n  (\\<a>[a, b, c] \\<otimes> d) =\n  \\<pp>\\<^sub>1[a, b] \\<cdot>\n  \\<pp>\\<^sub>1[a \\<otimes> b, c] \\<cdot>\n  \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes> c, d]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    \\<pp>\\<^sub>1[a, b] \\<cdot>\n    \\<pp>\\<^sub>1[a \\<otimes> b, c] \\<cdot>\n    \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes> c, d]", "by blast"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n  ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n  (\\<a>[a, b, c] \\<otimes> d) =\n  \\<pp>\\<^sub>1[a, b] \\<cdot>\n  \\<pp>\\<^sub>1[a \\<otimes> b, c] \\<cdot>\n  \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes> c, d]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]", "also"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n  ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n  (\\<a>[a, b, c] \\<otimes> d) =\n  \\<pp>\\<^sub>1[a, b] \\<cdot>\n  \\<pp>\\<^sub>1[a \\<otimes> b, c] \\<cdot>\n  \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes> c, d]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]", "have \"... = \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot> \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, b] \\<cdot>\n    \\<pp>\\<^sub>1[a \\<otimes> b, c] \\<cdot>\n    \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes> c, d] =\n    \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]", "using assms assoc_def comp_assoc"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  ide d\n  \\<a>[?a, ?b, ?c] \\<equiv>\n  \\<langle>\\<pp>\\<^sub>1[?a, ?b] \\<cdot>\n           \\<pp>\\<^sub>1[?a \\<otimes>\n                         ?b, ?c], \\<langle>\\<pp>\\<^sub>0[?a, ?b] \\<cdot>\n     \\<pp>\\<^sub>1[?a \\<otimes>\n                   ?b, ?c], \\<pp>\\<^sub>0[?a \\<otimes>\n    ?b, ?c]\\<rangle>\\<rangle>\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, b] \\<cdot>\n    \\<pp>\\<^sub>1[a \\<otimes> b, c] \\<cdot>\n    \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes> c, d] =\n    \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]", "by auto"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>1[a, b] \\<cdot>\n  \\<pp>\\<^sub>1[a \\<otimes> b, c] \\<cdot>\n  \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes> c, d] =\n  \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n  \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]", "finally"], ["proof (chain)\npicking this:\n  \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n  ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n  (\\<a>[a, b, c] \\<otimes> d) =\n  \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n  \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n  ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n  (\\<a>[a, b, c] \\<otimes> d) =\n  \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n  \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]", "by blast"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n  ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n  (\\<a>[a, b, c] \\<otimes> d) =\n  \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n  \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n  ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n  (\\<a>[a, b, c] \\<otimes> d) =\n  \\<pp>\\<^sub>1[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n  \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]", "show \"\\<pp>\\<^sub>0[a, b \\<otimes> (c \\<otimes> d)] \\<cdot> ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot> (\\<a>[a, b, c] \\<otimes> d) =\n            \\<pp>\\<^sub>0[a, b \\<otimes> (c \\<otimes> d)] \\<cdot> \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]", "have \"\\<pp>\\<^sub>0[a, b \\<otimes> (c \\<otimes> d)] \\<cdot> ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot> (\\<a>[a, b, c] \\<otimes> d) =\n              \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n                ((a \\<otimes> \\<langle>\\<pp>\\<^sub>1[b, c] \\<cdot> \\<pp>\\<^sub>1[b \\<otimes> c, d], \\<langle>\\<pp>\\<^sub>0[b, c] \\<cdot> \\<pp>\\<^sub>1[b \\<otimes> c, d], \\<pp>\\<^sub>0[b \\<otimes> c, d]\\<rangle>\\<rangle>) \\<cdot>\n                 \\<langle>\\<pp>\\<^sub>1[a, b \\<otimes> c] \\<cdot> \\<pp>\\<^sub>1[a \\<otimes> b \\<otimes> c, d],\n                  \\<langle>\\<pp>\\<^sub>0[a, b \\<otimes> c] \\<cdot> \\<pp>\\<^sub>1[a \\<otimes> b \\<otimes> c, d], \\<pp>\\<^sub>0[a \\<otimes> b \\<otimes> c, d]\\<rangle>\\<rangle>) \\<cdot>\n                (\\<langle>\\<pp>\\<^sub>1[a, b] \\<cdot> \\<pp>\\<^sub>1[a \\<otimes> b, c], \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot> \\<pp>\\<^sub>1[a \\<otimes> b, c], \\<pp>\\<^sub>0[a \\<otimes> b, c]\\<rangle>\\<rangle> \\<otimes> d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    ((a \\<otimes>\n      \\<langle>\\<pp>\\<^sub>1[b, c] \\<cdot>\n               \\<pp>\\<^sub>1[b \\<otimes>\n                             c, d], \\<langle>\\<pp>\\<^sub>0[b, c] \\<cdot>\n       \\<pp>\\<^sub>1[b \\<otimes>\n                     c, d], \\<pp>\\<^sub>0[b \\<otimes>\n    c, d]\\<rangle>\\<rangle>) \\<cdot>\n     \\<langle>\\<pp>\\<^sub>1[a, b \\<otimes> c] \\<cdot>\n              \\<pp>\\<^sub>1[a \\<otimes>\n                            b \\<otimes>\n                            c, d], \\<langle>\\<pp>\\<^sub>0[a, b \\<otimes>\n                       c] \\<cdot>\n      \\<pp>\\<^sub>1[a \\<otimes>\n                    b \\<otimes>\n                    c, d], \\<pp>\\<^sub>0[a \\<otimes>\n   b \\<otimes> c, d]\\<rangle>\\<rangle>) \\<cdot>\n    (\\<langle>\\<pp>\\<^sub>1[a, b] \\<cdot>\n              \\<pp>\\<^sub>1[a \\<otimes>\n                            b, c], \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot>\n      \\<pp>\\<^sub>1[a \\<otimes>\n                    b, c], \\<pp>\\<^sub>0[a \\<otimes>\n   b, c]\\<rangle>\\<rangle> \\<otimes>\n     d)", "using assms assoc_def"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  ide d\n  \\<a>[?a, ?b, ?c] \\<equiv>\n  \\<langle>\\<pp>\\<^sub>1[?a, ?b] \\<cdot>\n           \\<pp>\\<^sub>1[?a \\<otimes>\n                         ?b, ?c], \\<langle>\\<pp>\\<^sub>0[?a, ?b] \\<cdot>\n     \\<pp>\\<^sub>1[?a \\<otimes>\n                   ?b, ?c], \\<pp>\\<^sub>0[?a \\<otimes>\n    ?b, ?c]\\<rangle>\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    ((a \\<otimes>\n      \\<langle>\\<pp>\\<^sub>1[b, c] \\<cdot>\n               \\<pp>\\<^sub>1[b \\<otimes>\n                             c, d], \\<langle>\\<pp>\\<^sub>0[b, c] \\<cdot>\n       \\<pp>\\<^sub>1[b \\<otimes>\n                     c, d], \\<pp>\\<^sub>0[b \\<otimes>\n    c, d]\\<rangle>\\<rangle>) \\<cdot>\n     \\<langle>\\<pp>\\<^sub>1[a, b \\<otimes> c] \\<cdot>\n              \\<pp>\\<^sub>1[a \\<otimes>\n                            b \\<otimes>\n                            c, d], \\<langle>\\<pp>\\<^sub>0[a, b \\<otimes>\n                       c] \\<cdot>\n      \\<pp>\\<^sub>1[a \\<otimes>\n                    b \\<otimes>\n                    c, d], \\<pp>\\<^sub>0[a \\<otimes>\n   b \\<otimes> c, d]\\<rangle>\\<rangle>) \\<cdot>\n    (\\<langle>\\<pp>\\<^sub>1[a, b] \\<cdot>\n              \\<pp>\\<^sub>1[a \\<otimes>\n                            b, c], \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot>\n      \\<pp>\\<^sub>1[a \\<otimes>\n                    b, c], \\<pp>\\<^sub>0[a \\<otimes>\n   b, c]\\<rangle>\\<rangle> \\<otimes>\n     d)", "by simp"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n  ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n  (\\<a>[a, b, c] \\<otimes> d) =\n  \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n  ((a \\<otimes>\n    \\<langle>\\<pp>\\<^sub>1[b, c] \\<cdot>\n             \\<pp>\\<^sub>1[b \\<otimes>\n                           c, d], \\<langle>\\<pp>\\<^sub>0[b, c] \\<cdot>\n     \\<pp>\\<^sub>1[b \\<otimes>\n                   c, d], \\<pp>\\<^sub>0[b \\<otimes>\n  c, d]\\<rangle>\\<rangle>) \\<cdot>\n   \\<langle>\\<pp>\\<^sub>1[a, b \\<otimes> c] \\<cdot>\n            \\<pp>\\<^sub>1[a \\<otimes>\n                          b \\<otimes>\n                          c, d], \\<langle>\\<pp>\\<^sub>0[a, b \\<otimes>\n                     c] \\<cdot>\n    \\<pp>\\<^sub>1[a \\<otimes>\n                  b \\<otimes>\n                  c, d], \\<pp>\\<^sub>0[a \\<otimes>\n b \\<otimes> c, d]\\<rangle>\\<rangle>) \\<cdot>\n  (\\<langle>\\<pp>\\<^sub>1[a, b] \\<cdot>\n            \\<pp>\\<^sub>1[a \\<otimes>\n                          b, c], \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot>\n    \\<pp>\\<^sub>1[a \\<otimes>\n                  b, c], \\<pp>\\<^sub>0[a \\<otimes>\n b, c]\\<rangle>\\<rangle> \\<otimes>\n   d)\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]", "also"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n  ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n  (\\<a>[a, b, c] \\<otimes> d) =\n  \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n  ((a \\<otimes>\n    \\<langle>\\<pp>\\<^sub>1[b, c] \\<cdot>\n             \\<pp>\\<^sub>1[b \\<otimes>\n                           c, d], \\<langle>\\<pp>\\<^sub>0[b, c] \\<cdot>\n     \\<pp>\\<^sub>1[b \\<otimes>\n                   c, d], \\<pp>\\<^sub>0[b \\<otimes>\n  c, d]\\<rangle>\\<rangle>) \\<cdot>\n   \\<langle>\\<pp>\\<^sub>1[a, b \\<otimes> c] \\<cdot>\n            \\<pp>\\<^sub>1[a \\<otimes>\n                          b \\<otimes>\n                          c, d], \\<langle>\\<pp>\\<^sub>0[a, b \\<otimes>\n                     c] \\<cdot>\n    \\<pp>\\<^sub>1[a \\<otimes>\n                  b \\<otimes>\n                  c, d], \\<pp>\\<^sub>0[a \\<otimes>\n b \\<otimes> c, d]\\<rangle>\\<rangle>) \\<cdot>\n  (\\<langle>\\<pp>\\<^sub>1[a, b] \\<cdot>\n            \\<pp>\\<^sub>1[a \\<otimes>\n                          b, c], \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot>\n    \\<pp>\\<^sub>1[a \\<otimes>\n                  b, c], \\<pp>\\<^sub>0[a \\<otimes>\n b, c]\\<rangle>\\<rangle> \\<otimes>\n   d)\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]", "have \"... = \\<langle>\\<pp>\\<^sub>1[b, c] \\<cdot> \\<pp>\\<^sub>1[b \\<otimes> c, d],\n                          \\<langle>\\<pp>\\<^sub>0[b, c] \\<cdot> \\<pp>\\<^sub>1[b \\<otimes> c, d], \\<pp>\\<^sub>0[b \\<otimes> c, d]\\<rangle>\\<rangle> \\<cdot> (\\<pp>\\<^sub>0[a, (b \\<otimes> c) \\<otimes> d] \\<cdot>\n                            \\<langle>\\<pp>\\<^sub>1[a, b \\<otimes> c] \\<cdot> \\<pp>\\<^sub>1[a \\<otimes> b \\<otimes> c, d],\n                             \\<langle>\\<pp>\\<^sub>0[a, b \\<otimes> c] \\<cdot> \\<pp>\\<^sub>1[a \\<otimes> b \\<otimes> c, d], \\<pp>\\<^sub>0[a \\<otimes> b \\<otimes> c, d]\\<rangle>\\<rangle>) \\<cdot>\n                            (\\<langle>\\<pp>\\<^sub>1[a, b] \\<cdot> \\<pp>\\<^sub>1[a \\<otimes> b, c],\n                              \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot> \\<pp>\\<^sub>1[a \\<otimes> b, c], \\<pp>\\<^sub>0[a \\<otimes> b, c]\\<rangle>\\<rangle> \\<otimes> d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    ((a \\<otimes>\n      \\<langle>\\<pp>\\<^sub>1[b, c] \\<cdot>\n               \\<pp>\\<^sub>1[b \\<otimes>\n                             c, d], \\<langle>\\<pp>\\<^sub>0[b, c] \\<cdot>\n       \\<pp>\\<^sub>1[b \\<otimes>\n                     c, d], \\<pp>\\<^sub>0[b \\<otimes>\n    c, d]\\<rangle>\\<rangle>) \\<cdot>\n     \\<langle>\\<pp>\\<^sub>1[a, b \\<otimes> c] \\<cdot>\n              \\<pp>\\<^sub>1[a \\<otimes>\n                            b \\<otimes>\n                            c, d], \\<langle>\\<pp>\\<^sub>0[a, b \\<otimes>\n                       c] \\<cdot>\n      \\<pp>\\<^sub>1[a \\<otimes>\n                    b \\<otimes>\n                    c, d], \\<pp>\\<^sub>0[a \\<otimes>\n   b \\<otimes> c, d]\\<rangle>\\<rangle>) \\<cdot>\n    (\\<langle>\\<pp>\\<^sub>1[a, b] \\<cdot>\n              \\<pp>\\<^sub>1[a \\<otimes>\n                            b, c], \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot>\n      \\<pp>\\<^sub>1[a \\<otimes>\n                    b, c], \\<pp>\\<^sub>0[a \\<otimes>\n   b, c]\\<rangle>\\<rangle> \\<otimes>\n     d) =\n    \\<langle>\\<pp>\\<^sub>1[b, c] \\<cdot>\n             \\<pp>\\<^sub>1[b \\<otimes>\n                           c, d], \\<langle>\\<pp>\\<^sub>0[b, c] \\<cdot>\n     \\<pp>\\<^sub>1[b \\<otimes>\n                   c, d], \\<pp>\\<^sub>0[b \\<otimes>\n  c, d]\\<rangle>\\<rangle> \\<cdot>\n    (\\<pp>\\<^sub>0[a, (b \\<otimes> c) \\<otimes> d] \\<cdot>\n     \\<langle>\\<pp>\\<^sub>1[a, b \\<otimes> c] \\<cdot>\n              \\<pp>\\<^sub>1[a \\<otimes>\n                            b \\<otimes>\n                            c, d], \\<langle>\\<pp>\\<^sub>0[a, b \\<otimes>\n                       c] \\<cdot>\n      \\<pp>\\<^sub>1[a \\<otimes>\n                    b \\<otimes>\n                    c, d], \\<pp>\\<^sub>0[a \\<otimes>\n   b \\<otimes> c, d]\\<rangle>\\<rangle>) \\<cdot>\n    (\\<langle>\\<pp>\\<^sub>1[a, b] \\<cdot>\n              \\<pp>\\<^sub>1[a \\<otimes>\n                            b, c], \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot>\n      \\<pp>\\<^sub>1[a \\<otimes>\n                    b, c], \\<pp>\\<^sub>0[a \\<otimes>\n   b, c]\\<rangle>\\<rangle> \\<otimes>\n     d)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    ((a \\<otimes>\n      \\<langle>\\<pp>\\<^sub>1[b, c] \\<cdot>\n               \\<pp>\\<^sub>1[b \\<otimes>\n                             c, d], \\<langle>\\<pp>\\<^sub>0[b, c] \\<cdot>\n       \\<pp>\\<^sub>1[b \\<otimes>\n                     c, d], \\<pp>\\<^sub>0[b \\<otimes>\n    c, d]\\<rangle>\\<rangle>) \\<cdot>\n     \\<langle>\\<pp>\\<^sub>1[a, b \\<otimes> c] \\<cdot>\n              \\<pp>\\<^sub>1[a \\<otimes>\n                            b \\<otimes>\n                            c, d], \\<langle>\\<pp>\\<^sub>0[a, b \\<otimes>\n                       c] \\<cdot>\n      \\<pp>\\<^sub>1[a \\<otimes>\n                    b \\<otimes>\n                    c, d], \\<pp>\\<^sub>0[a \\<otimes>\n   b \\<otimes> c, d]\\<rangle>\\<rangle>) \\<cdot>\n    (\\<langle>\\<pp>\\<^sub>1[a, b] \\<cdot>\n              \\<pp>\\<^sub>1[a \\<otimes>\n                            b, c], \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot>\n      \\<pp>\\<^sub>1[a \\<otimes>\n                    b, c], \\<pp>\\<^sub>0[a \\<otimes>\n   b, c]\\<rangle>\\<rangle> \\<otimes>\n     d) =\n    \\<langle>\\<pp>\\<^sub>1[b, c] \\<cdot>\n             \\<pp>\\<^sub>1[b \\<otimes>\n                           c, d], \\<langle>\\<pp>\\<^sub>0[b, c] \\<cdot>\n     \\<pp>\\<^sub>1[b \\<otimes>\n                   c, d], \\<pp>\\<^sub>0[b \\<otimes>\n  c, d]\\<rangle>\\<rangle> \\<cdot>\n    (\\<pp>\\<^sub>0[a, (b \\<otimes> c) \\<otimes> d] \\<cdot>\n     \\<langle>\\<pp>\\<^sub>1[a, b \\<otimes> c] \\<cdot>\n              \\<pp>\\<^sub>1[a \\<otimes>\n                            b \\<otimes>\n                            c, d], \\<langle>\\<pp>\\<^sub>0[a, b \\<otimes>\n                       c] \\<cdot>\n      \\<pp>\\<^sub>1[a \\<otimes>\n                    b \\<otimes>\n                    c, d], \\<pp>\\<^sub>0[a \\<otimes>\n   b \\<otimes> c, d]\\<rangle>\\<rangle>) \\<cdot>\n    (\\<langle>\\<pp>\\<^sub>1[a, b] \\<cdot>\n              \\<pp>\\<^sub>1[a \\<otimes>\n                            b, c], \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot>\n      \\<pp>\\<^sub>1[a \\<otimes>\n                    b, c], \\<pp>\\<^sub>0[a \\<otimes>\n   b, c]\\<rangle>\\<rangle> \\<otimes>\n     d)", "have \"\\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n                  (a \\<otimes> \\<langle>\\<pp>\\<^sub>1[b, c] \\<cdot> \\<pp>\\<^sub>1[b \\<otimes> c, d], \\<langle>\\<pp>\\<^sub>0[b, c] \\<cdot> \\<pp>\\<^sub>1[b \\<otimes> c, d], \\<pp>\\<^sub>0[b \\<otimes> c, d]\\<rangle>\\<rangle>) =\n                \\<langle>\\<pp>\\<^sub>1[b, c] \\<cdot> \\<pp>\\<^sub>1[b \\<otimes> c, d], \\<langle>\\<pp>\\<^sub>0[b, c] \\<cdot> \\<pp>\\<^sub>1[b \\<otimes> c, d], \\<pp>\\<^sub>0[b \\<otimes> c, d]\\<rangle>\\<rangle> \\<cdot>\n                  \\<pp>\\<^sub>0[a, (b \\<otimes> c) \\<otimes> d]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    (a \\<otimes>\n     \\<langle>\\<pp>\\<^sub>1[b, c] \\<cdot>\n              \\<pp>\\<^sub>1[b \\<otimes>\n                            c, d], \\<langle>\\<pp>\\<^sub>0[b, c] \\<cdot>\n      \\<pp>\\<^sub>1[b \\<otimes>\n                    c, d], \\<pp>\\<^sub>0[b \\<otimes>\n   c, d]\\<rangle>\\<rangle>) =\n    \\<langle>\\<pp>\\<^sub>1[b, c] \\<cdot>\n             \\<pp>\\<^sub>1[b \\<otimes>\n                           c, d], \\<langle>\\<pp>\\<^sub>0[b, c] \\<cdot>\n     \\<pp>\\<^sub>1[b \\<otimes>\n                   c, d], \\<pp>\\<^sub>0[b \\<otimes>\n  c, d]\\<rangle>\\<rangle> \\<cdot>\n    \\<pp>\\<^sub>0[a, (b \\<otimes> c) \\<otimes> d]", "using assms assoc_def ide_in_hom pr_naturality(1)"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  ide d\n  \\<a>[?a, ?b, ?c] \\<equiv>\n  \\<langle>\\<pp>\\<^sub>1[?a, ?b] \\<cdot>\n           \\<pp>\\<^sub>1[?a \\<otimes>\n                         ?b, ?c], \\<langle>\\<pp>\\<^sub>0[?a, ?b] \\<cdot>\n     \\<pp>\\<^sub>1[?a \\<otimes>\n                   ?b, ?c], \\<pp>\\<^sub>0[?a \\<otimes>\n    ?b, ?c]\\<rangle>\\<rangle>\n  ide ?a = \\<guillemotleft>?a : ?a \\<rightarrow> ?a\\<guillemotright>\n  \\<lbrakk>arr ?g; local.dom ?g = ?b; cod ?g = ?d; arr ?f;\n   local.dom ?f = ?a; cod ?f = ?c\\<rbrakk>\n  \\<Longrightarrow> \\<pp>\\<^sub>0[?c, ?d] \\<cdot> (?f \\<otimes> ?g) =\n                    ?g \\<cdot> \\<pp>\\<^sub>0[?a, ?b]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    (a \\<otimes>\n     \\<langle>\\<pp>\\<^sub>1[b, c] \\<cdot>\n              \\<pp>\\<^sub>1[b \\<otimes>\n                            c, d], \\<langle>\\<pp>\\<^sub>0[b, c] \\<cdot>\n      \\<pp>\\<^sub>1[b \\<otimes>\n                    c, d], \\<pp>\\<^sub>0[b \\<otimes>\n   c, d]\\<rangle>\\<rangle>) =\n    \\<langle>\\<pp>\\<^sub>1[b, c] \\<cdot>\n             \\<pp>\\<^sub>1[b \\<otimes>\n                           c, d], \\<langle>\\<pp>\\<^sub>0[b, c] \\<cdot>\n     \\<pp>\\<^sub>1[b \\<otimes>\n                   c, d], \\<pp>\\<^sub>0[b \\<otimes>\n  c, d]\\<rangle>\\<rangle> \\<cdot>\n    \\<pp>\\<^sub>0[a, (b \\<otimes> c) \\<otimes> d]", "by auto"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n  (a \\<otimes>\n   \\<langle>\\<pp>\\<^sub>1[b, c] \\<cdot>\n            \\<pp>\\<^sub>1[b \\<otimes>\n                          c, d], \\<langle>\\<pp>\\<^sub>0[b, c] \\<cdot>\n    \\<pp>\\<^sub>1[b \\<otimes>\n                  c, d], \\<pp>\\<^sub>0[b \\<otimes>\n c, d]\\<rangle>\\<rangle>) =\n  \\<langle>\\<pp>\\<^sub>1[b, c] \\<cdot>\n           \\<pp>\\<^sub>1[b \\<otimes>\n                         c, d], \\<langle>\\<pp>\\<^sub>0[b, c] \\<cdot>\n   \\<pp>\\<^sub>1[b \\<otimes>\n                 c, d], \\<pp>\\<^sub>0[b \\<otimes>\nc, d]\\<rangle>\\<rangle> \\<cdot>\n  \\<pp>\\<^sub>0[a, (b \\<otimes> c) \\<otimes> d]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    ((a \\<otimes>\n      \\<langle>\\<pp>\\<^sub>1[b, c] \\<cdot>\n               \\<pp>\\<^sub>1[b \\<otimes>\n                             c, d], \\<langle>\\<pp>\\<^sub>0[b, c] \\<cdot>\n       \\<pp>\\<^sub>1[b \\<otimes>\n                     c, d], \\<pp>\\<^sub>0[b \\<otimes>\n    c, d]\\<rangle>\\<rangle>) \\<cdot>\n     \\<langle>\\<pp>\\<^sub>1[a, b \\<otimes> c] \\<cdot>\n              \\<pp>\\<^sub>1[a \\<otimes>\n                            b \\<otimes>\n                            c, d], \\<langle>\\<pp>\\<^sub>0[a, b \\<otimes>\n                       c] \\<cdot>\n      \\<pp>\\<^sub>1[a \\<otimes>\n                    b \\<otimes>\n                    c, d], \\<pp>\\<^sub>0[a \\<otimes>\n   b \\<otimes> c, d]\\<rangle>\\<rangle>) \\<cdot>\n    (\\<langle>\\<pp>\\<^sub>1[a, b] \\<cdot>\n              \\<pp>\\<^sub>1[a \\<otimes>\n                            b, c], \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot>\n      \\<pp>\\<^sub>1[a \\<otimes>\n                    b, c], \\<pp>\\<^sub>0[a \\<otimes>\n   b, c]\\<rangle>\\<rangle> \\<otimes>\n     d) =\n    \\<langle>\\<pp>\\<^sub>1[b, c] \\<cdot>\n             \\<pp>\\<^sub>1[b \\<otimes>\n                           c, d], \\<langle>\\<pp>\\<^sub>0[b, c] \\<cdot>\n     \\<pp>\\<^sub>1[b \\<otimes>\n                   c, d], \\<pp>\\<^sub>0[b \\<otimes>\n  c, d]\\<rangle>\\<rangle> \\<cdot>\n    (\\<pp>\\<^sub>0[a, (b \\<otimes> c) \\<otimes> d] \\<cdot>\n     \\<langle>\\<pp>\\<^sub>1[a, b \\<otimes> c] \\<cdot>\n              \\<pp>\\<^sub>1[a \\<otimes>\n                            b \\<otimes>\n                            c, d], \\<langle>\\<pp>\\<^sub>0[a, b \\<otimes>\n                       c] \\<cdot>\n      \\<pp>\\<^sub>1[a \\<otimes>\n                    b \\<otimes>\n                    c, d], \\<pp>\\<^sub>0[a \\<otimes>\n   b \\<otimes> c, d]\\<rangle>\\<rangle>) \\<cdot>\n    (\\<langle>\\<pp>\\<^sub>1[a, b] \\<cdot>\n              \\<pp>\\<^sub>1[a \\<otimes>\n                            b, c], \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot>\n      \\<pp>\\<^sub>1[a \\<otimes>\n                    b, c], \\<pp>\\<^sub>0[a \\<otimes>\n   b, c]\\<rangle>\\<rangle> \\<otimes>\n     d)", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n  (a \\<otimes>\n   \\<langle>\\<pp>\\<^sub>1[b, c] \\<cdot>\n            \\<pp>\\<^sub>1[b \\<otimes>\n                          c, d], \\<langle>\\<pp>\\<^sub>0[b, c] \\<cdot>\n    \\<pp>\\<^sub>1[b \\<otimes>\n                  c, d], \\<pp>\\<^sub>0[b \\<otimes>\n c, d]\\<rangle>\\<rangle>) =\n  \\<langle>\\<pp>\\<^sub>1[b, c] \\<cdot>\n           \\<pp>\\<^sub>1[b \\<otimes>\n                         c, d], \\<langle>\\<pp>\\<^sub>0[b, c] \\<cdot>\n   \\<pp>\\<^sub>1[b \\<otimes>\n                 c, d], \\<pp>\\<^sub>0[b \\<otimes>\nc, d]\\<rangle>\\<rangle> \\<cdot>\n  \\<pp>\\<^sub>0[a, (b \\<otimes> c) \\<otimes> d]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    ((a \\<otimes>\n      \\<langle>\\<pp>\\<^sub>1[b, c] \\<cdot>\n               \\<pp>\\<^sub>1[b \\<otimes>\n                             c, d], \\<langle>\\<pp>\\<^sub>0[b, c] \\<cdot>\n       \\<pp>\\<^sub>1[b \\<otimes>\n                     c, d], \\<pp>\\<^sub>0[b \\<otimes>\n    c, d]\\<rangle>\\<rangle>) \\<cdot>\n     \\<langle>\\<pp>\\<^sub>1[a, b \\<otimes> c] \\<cdot>\n              \\<pp>\\<^sub>1[a \\<otimes>\n                            b \\<otimes>\n                            c, d], \\<langle>\\<pp>\\<^sub>0[a, b \\<otimes>\n                       c] \\<cdot>\n      \\<pp>\\<^sub>1[a \\<otimes>\n                    b \\<otimes>\n                    c, d], \\<pp>\\<^sub>0[a \\<otimes>\n   b \\<otimes> c, d]\\<rangle>\\<rangle>) \\<cdot>\n    (\\<langle>\\<pp>\\<^sub>1[a, b] \\<cdot>\n              \\<pp>\\<^sub>1[a \\<otimes>\n                            b, c], \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot>\n      \\<pp>\\<^sub>1[a \\<otimes>\n                    b, c], \\<pp>\\<^sub>0[a \\<otimes>\n   b, c]\\<rangle>\\<rangle> \\<otimes>\n     d) =\n    \\<langle>\\<pp>\\<^sub>1[b, c] \\<cdot>\n             \\<pp>\\<^sub>1[b \\<otimes>\n                           c, d], \\<langle>\\<pp>\\<^sub>0[b, c] \\<cdot>\n     \\<pp>\\<^sub>1[b \\<otimes>\n                   c, d], \\<pp>\\<^sub>0[b \\<otimes>\n  c, d]\\<rangle>\\<rangle> \\<cdot>\n    (\\<pp>\\<^sub>0[a, (b \\<otimes> c) \\<otimes> d] \\<cdot>\n     \\<langle>\\<pp>\\<^sub>1[a, b \\<otimes> c] \\<cdot>\n              \\<pp>\\<^sub>1[a \\<otimes>\n                            b \\<otimes>\n                            c, d], \\<langle>\\<pp>\\<^sub>0[a, b \\<otimes>\n                       c] \\<cdot>\n      \\<pp>\\<^sub>1[a \\<otimes>\n                    b \\<otimes>\n                    c, d], \\<pp>\\<^sub>0[a \\<otimes>\n   b \\<otimes> c, d]\\<rangle>\\<rangle>) \\<cdot>\n    (\\<langle>\\<pp>\\<^sub>1[a, b] \\<cdot>\n              \\<pp>\\<^sub>1[a \\<otimes>\n                            b, c], \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot>\n      \\<pp>\\<^sub>1[a \\<otimes>\n                    b, c], \\<pp>\\<^sub>0[a \\<otimes>\n   b, c]\\<rangle>\\<rangle> \\<otimes>\n     d)", "using comp_assoc"], ["proof (prove)\nusing this:\n  \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n  (a \\<otimes>\n   \\<langle>\\<pp>\\<^sub>1[b, c] \\<cdot>\n            \\<pp>\\<^sub>1[b \\<otimes>\n                          c, d], \\<langle>\\<pp>\\<^sub>0[b, c] \\<cdot>\n    \\<pp>\\<^sub>1[b \\<otimes>\n                  c, d], \\<pp>\\<^sub>0[b \\<otimes>\n c, d]\\<rangle>\\<rangle>) =\n  \\<langle>\\<pp>\\<^sub>1[b, c] \\<cdot>\n           \\<pp>\\<^sub>1[b \\<otimes>\n                         c, d], \\<langle>\\<pp>\\<^sub>0[b, c] \\<cdot>\n   \\<pp>\\<^sub>1[b \\<otimes>\n                 c, d], \\<pp>\\<^sub>0[b \\<otimes>\nc, d]\\<rangle>\\<rangle> \\<cdot>\n  \\<pp>\\<^sub>0[a, (b \\<otimes> c) \\<otimes> d]\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    ((a \\<otimes>\n      \\<langle>\\<pp>\\<^sub>1[b, c] \\<cdot>\n               \\<pp>\\<^sub>1[b \\<otimes>\n                             c, d], \\<langle>\\<pp>\\<^sub>0[b, c] \\<cdot>\n       \\<pp>\\<^sub>1[b \\<otimes>\n                     c, d], \\<pp>\\<^sub>0[b \\<otimes>\n    c, d]\\<rangle>\\<rangle>) \\<cdot>\n     \\<langle>\\<pp>\\<^sub>1[a, b \\<otimes> c] \\<cdot>\n              \\<pp>\\<^sub>1[a \\<otimes>\n                            b \\<otimes>\n                            c, d], \\<langle>\\<pp>\\<^sub>0[a, b \\<otimes>\n                       c] \\<cdot>\n      \\<pp>\\<^sub>1[a \\<otimes>\n                    b \\<otimes>\n                    c, d], \\<pp>\\<^sub>0[a \\<otimes>\n   b \\<otimes> c, d]\\<rangle>\\<rangle>) \\<cdot>\n    (\\<langle>\\<pp>\\<^sub>1[a, b] \\<cdot>\n              \\<pp>\\<^sub>1[a \\<otimes>\n                            b, c], \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot>\n      \\<pp>\\<^sub>1[a \\<otimes>\n                    b, c], \\<pp>\\<^sub>0[a \\<otimes>\n   b, c]\\<rangle>\\<rangle> \\<otimes>\n     d) =\n    \\<langle>\\<pp>\\<^sub>1[b, c] \\<cdot>\n             \\<pp>\\<^sub>1[b \\<otimes>\n                           c, d], \\<langle>\\<pp>\\<^sub>0[b, c] \\<cdot>\n     \\<pp>\\<^sub>1[b \\<otimes>\n                   c, d], \\<pp>\\<^sub>0[b \\<otimes>\n  c, d]\\<rangle>\\<rangle> \\<cdot>\n    (\\<pp>\\<^sub>0[a, (b \\<otimes> c) \\<otimes> d] \\<cdot>\n     \\<langle>\\<pp>\\<^sub>1[a, b \\<otimes> c] \\<cdot>\n              \\<pp>\\<^sub>1[a \\<otimes>\n                            b \\<otimes>\n                            c, d], \\<langle>\\<pp>\\<^sub>0[a, b \\<otimes>\n                       c] \\<cdot>\n      \\<pp>\\<^sub>1[a \\<otimes>\n                    b \\<otimes>\n                    c, d], \\<pp>\\<^sub>0[a \\<otimes>\n   b \\<otimes> c, d]\\<rangle>\\<rangle>) \\<cdot>\n    (\\<langle>\\<pp>\\<^sub>1[a, b] \\<cdot>\n              \\<pp>\\<^sub>1[a \\<otimes>\n                            b, c], \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot>\n      \\<pp>\\<^sub>1[a \\<otimes>\n                    b, c], \\<pp>\\<^sub>0[a \\<otimes>\n   b, c]\\<rangle>\\<rangle> \\<otimes>\n     d)", "by metis"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n  ((a \\<otimes>\n    \\<langle>\\<pp>\\<^sub>1[b, c] \\<cdot>\n             \\<pp>\\<^sub>1[b \\<otimes>\n                           c, d], \\<langle>\\<pp>\\<^sub>0[b, c] \\<cdot>\n     \\<pp>\\<^sub>1[b \\<otimes>\n                   c, d], \\<pp>\\<^sub>0[b \\<otimes>\n  c, d]\\<rangle>\\<rangle>) \\<cdot>\n   \\<langle>\\<pp>\\<^sub>1[a, b \\<otimes> c] \\<cdot>\n            \\<pp>\\<^sub>1[a \\<otimes>\n                          b \\<otimes>\n                          c, d], \\<langle>\\<pp>\\<^sub>0[a, b \\<otimes>\n                     c] \\<cdot>\n    \\<pp>\\<^sub>1[a \\<otimes>\n                  b \\<otimes>\n                  c, d], \\<pp>\\<^sub>0[a \\<otimes>\n b \\<otimes> c, d]\\<rangle>\\<rangle>) \\<cdot>\n  (\\<langle>\\<pp>\\<^sub>1[a, b] \\<cdot>\n            \\<pp>\\<^sub>1[a \\<otimes>\n                          b, c], \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot>\n    \\<pp>\\<^sub>1[a \\<otimes>\n                  b, c], \\<pp>\\<^sub>0[a \\<otimes>\n b, c]\\<rangle>\\<rangle> \\<otimes>\n   d) =\n  \\<langle>\\<pp>\\<^sub>1[b, c] \\<cdot>\n           \\<pp>\\<^sub>1[b \\<otimes>\n                         c, d], \\<langle>\\<pp>\\<^sub>0[b, c] \\<cdot>\n   \\<pp>\\<^sub>1[b \\<otimes>\n                 c, d], \\<pp>\\<^sub>0[b \\<otimes>\nc, d]\\<rangle>\\<rangle> \\<cdot>\n  (\\<pp>\\<^sub>0[a, (b \\<otimes> c) \\<otimes> d] \\<cdot>\n   \\<langle>\\<pp>\\<^sub>1[a, b \\<otimes> c] \\<cdot>\n            \\<pp>\\<^sub>1[a \\<otimes>\n                          b \\<otimes>\n                          c, d], \\<langle>\\<pp>\\<^sub>0[a, b \\<otimes>\n                     c] \\<cdot>\n    \\<pp>\\<^sub>1[a \\<otimes>\n                  b \\<otimes>\n                  c, d], \\<pp>\\<^sub>0[a \\<otimes>\n b \\<otimes> c, d]\\<rangle>\\<rangle>) \\<cdot>\n  (\\<langle>\\<pp>\\<^sub>1[a, b] \\<cdot>\n            \\<pp>\\<^sub>1[a \\<otimes>\n                          b, c], \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot>\n    \\<pp>\\<^sub>1[a \\<otimes>\n                  b, c], \\<pp>\\<^sub>0[a \\<otimes>\n b, c]\\<rangle>\\<rangle> \\<otimes>\n   d)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n  ((a \\<otimes>\n    \\<langle>\\<pp>\\<^sub>1[b, c] \\<cdot>\n             \\<pp>\\<^sub>1[b \\<otimes>\n                           c, d], \\<langle>\\<pp>\\<^sub>0[b, c] \\<cdot>\n     \\<pp>\\<^sub>1[b \\<otimes>\n                   c, d], \\<pp>\\<^sub>0[b \\<otimes>\n  c, d]\\<rangle>\\<rangle>) \\<cdot>\n   \\<langle>\\<pp>\\<^sub>1[a, b \\<otimes> c] \\<cdot>\n            \\<pp>\\<^sub>1[a \\<otimes>\n                          b \\<otimes>\n                          c, d], \\<langle>\\<pp>\\<^sub>0[a, b \\<otimes>\n                     c] \\<cdot>\n    \\<pp>\\<^sub>1[a \\<otimes>\n                  b \\<otimes>\n                  c, d], \\<pp>\\<^sub>0[a \\<otimes>\n b \\<otimes> c, d]\\<rangle>\\<rangle>) \\<cdot>\n  (\\<langle>\\<pp>\\<^sub>1[a, b] \\<cdot>\n            \\<pp>\\<^sub>1[a \\<otimes>\n                          b, c], \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot>\n    \\<pp>\\<^sub>1[a \\<otimes>\n                  b, c], \\<pp>\\<^sub>0[a \\<otimes>\n b, c]\\<rangle>\\<rangle> \\<otimes>\n   d) =\n  \\<langle>\\<pp>\\<^sub>1[b, c] \\<cdot>\n           \\<pp>\\<^sub>1[b \\<otimes>\n                         c, d], \\<langle>\\<pp>\\<^sub>0[b, c] \\<cdot>\n   \\<pp>\\<^sub>1[b \\<otimes>\n                 c, d], \\<pp>\\<^sub>0[b \\<otimes>\nc, d]\\<rangle>\\<rangle> \\<cdot>\n  (\\<pp>\\<^sub>0[a, (b \\<otimes> c) \\<otimes> d] \\<cdot>\n   \\<langle>\\<pp>\\<^sub>1[a, b \\<otimes> c] \\<cdot>\n            \\<pp>\\<^sub>1[a \\<otimes>\n                          b \\<otimes>\n                          c, d], \\<langle>\\<pp>\\<^sub>0[a, b \\<otimes>\n                     c] \\<cdot>\n    \\<pp>\\<^sub>1[a \\<otimes>\n                  b \\<otimes>\n                  c, d], \\<pp>\\<^sub>0[a \\<otimes>\n b \\<otimes> c, d]\\<rangle>\\<rangle>) \\<cdot>\n  (\\<langle>\\<pp>\\<^sub>1[a, b] \\<cdot>\n            \\<pp>\\<^sub>1[a \\<otimes>\n                          b, c], \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot>\n    \\<pp>\\<^sub>1[a \\<otimes>\n                  b, c], \\<pp>\\<^sub>0[a \\<otimes>\n b, c]\\<rangle>\\<rangle> \\<otimes>\n   d)\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]", "also"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n  ((a \\<otimes>\n    \\<langle>\\<pp>\\<^sub>1[b, c] \\<cdot>\n             \\<pp>\\<^sub>1[b \\<otimes>\n                           c, d], \\<langle>\\<pp>\\<^sub>0[b, c] \\<cdot>\n     \\<pp>\\<^sub>1[b \\<otimes>\n                   c, d], \\<pp>\\<^sub>0[b \\<otimes>\n  c, d]\\<rangle>\\<rangle>) \\<cdot>\n   \\<langle>\\<pp>\\<^sub>1[a, b \\<otimes> c] \\<cdot>\n            \\<pp>\\<^sub>1[a \\<otimes>\n                          b \\<otimes>\n                          c, d], \\<langle>\\<pp>\\<^sub>0[a, b \\<otimes>\n                     c] \\<cdot>\n    \\<pp>\\<^sub>1[a \\<otimes>\n                  b \\<otimes>\n                  c, d], \\<pp>\\<^sub>0[a \\<otimes>\n b \\<otimes> c, d]\\<rangle>\\<rangle>) \\<cdot>\n  (\\<langle>\\<pp>\\<^sub>1[a, b] \\<cdot>\n            \\<pp>\\<^sub>1[a \\<otimes>\n                          b, c], \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot>\n    \\<pp>\\<^sub>1[a \\<otimes>\n                  b, c], \\<pp>\\<^sub>0[a \\<otimes>\n b, c]\\<rangle>\\<rangle> \\<otimes>\n   d) =\n  \\<langle>\\<pp>\\<^sub>1[b, c] \\<cdot>\n           \\<pp>\\<^sub>1[b \\<otimes>\n                         c, d], \\<langle>\\<pp>\\<^sub>0[b, c] \\<cdot>\n   \\<pp>\\<^sub>1[b \\<otimes>\n                 c, d], \\<pp>\\<^sub>0[b \\<otimes>\nc, d]\\<rangle>\\<rangle> \\<cdot>\n  (\\<pp>\\<^sub>0[a, (b \\<otimes> c) \\<otimes> d] \\<cdot>\n   \\<langle>\\<pp>\\<^sub>1[a, b \\<otimes> c] \\<cdot>\n            \\<pp>\\<^sub>1[a \\<otimes>\n                          b \\<otimes>\n                          c, d], \\<langle>\\<pp>\\<^sub>0[a, b \\<otimes>\n                     c] \\<cdot>\n    \\<pp>\\<^sub>1[a \\<otimes>\n                  b \\<otimes>\n                  c, d], \\<pp>\\<^sub>0[a \\<otimes>\n b \\<otimes> c, d]\\<rangle>\\<rangle>) \\<cdot>\n  (\\<langle>\\<pp>\\<^sub>1[a, b] \\<cdot>\n            \\<pp>\\<^sub>1[a \\<otimes>\n                          b, c], \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot>\n    \\<pp>\\<^sub>1[a \\<otimes>\n                  b, c], \\<pp>\\<^sub>0[a \\<otimes>\n b, c]\\<rangle>\\<rangle> \\<otimes>\n   d)\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]", "have \"... = \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot> \\<pp>\\<^sub>1[a \\<otimes> b, c] \\<cdot> \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes> c, d],\n                          \\<langle>\\<pp>\\<^sub>0[a \\<otimes> b, c] \\<cdot> \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes> c, d], d \\<cdot> \\<pp>\\<^sub>0[(a \\<otimes> b) \\<otimes> c, d]\\<rangle>\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<pp>\\<^sub>1[b, c] \\<cdot>\n             \\<pp>\\<^sub>1[b \\<otimes>\n                           c, d], \\<langle>\\<pp>\\<^sub>0[b, c] \\<cdot>\n     \\<pp>\\<^sub>1[b \\<otimes>\n                   c, d], \\<pp>\\<^sub>0[b \\<otimes>\n  c, d]\\<rangle>\\<rangle> \\<cdot>\n    (\\<pp>\\<^sub>0[a, (b \\<otimes> c) \\<otimes> d] \\<cdot>\n     \\<langle>\\<pp>\\<^sub>1[a, b \\<otimes> c] \\<cdot>\n              \\<pp>\\<^sub>1[a \\<otimes>\n                            b \\<otimes>\n                            c, d], \\<langle>\\<pp>\\<^sub>0[a, b \\<otimes>\n                       c] \\<cdot>\n      \\<pp>\\<^sub>1[a \\<otimes>\n                    b \\<otimes>\n                    c, d], \\<pp>\\<^sub>0[a \\<otimes>\n   b \\<otimes> c, d]\\<rangle>\\<rangle>) \\<cdot>\n    (\\<langle>\\<pp>\\<^sub>1[a, b] \\<cdot>\n              \\<pp>\\<^sub>1[a \\<otimes>\n                            b, c], \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot>\n      \\<pp>\\<^sub>1[a \\<otimes>\n                    b, c], \\<pp>\\<^sub>0[a \\<otimes>\n   b, c]\\<rangle>\\<rangle> \\<otimes>\n     d) =\n    \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot>\n             \\<pp>\\<^sub>1[a \\<otimes> b, c] \\<cdot>\n             \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes>\n                           c, d], \\<langle>\\<pp>\\<^sub>0[a \\<otimes>\n                   b, c] \\<cdot>\n     \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes>\n                   c, d], d \\<cdot>\n                          \\<pp>\\<^sub>0[(a \\<otimes> b) \\<otimes>\n  c, d]\\<rangle>\\<rangle>", "using assms comp_assoc"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  ide d\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. \\<langle>\\<pp>\\<^sub>1[b, c] \\<cdot>\n             \\<pp>\\<^sub>1[b \\<otimes>\n                           c, d], \\<langle>\\<pp>\\<^sub>0[b, c] \\<cdot>\n     \\<pp>\\<^sub>1[b \\<otimes>\n                   c, d], \\<pp>\\<^sub>0[b \\<otimes>\n  c, d]\\<rangle>\\<rangle> \\<cdot>\n    (\\<pp>\\<^sub>0[a, (b \\<otimes> c) \\<otimes> d] \\<cdot>\n     \\<langle>\\<pp>\\<^sub>1[a, b \\<otimes> c] \\<cdot>\n              \\<pp>\\<^sub>1[a \\<otimes>\n                            b \\<otimes>\n                            c, d], \\<langle>\\<pp>\\<^sub>0[a, b \\<otimes>\n                       c] \\<cdot>\n      \\<pp>\\<^sub>1[a \\<otimes>\n                    b \\<otimes>\n                    c, d], \\<pp>\\<^sub>0[a \\<otimes>\n   b \\<otimes> c, d]\\<rangle>\\<rangle>) \\<cdot>\n    (\\<langle>\\<pp>\\<^sub>1[a, b] \\<cdot>\n              \\<pp>\\<^sub>1[a \\<otimes>\n                            b, c], \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot>\n      \\<pp>\\<^sub>1[a \\<otimes>\n                    b, c], \\<pp>\\<^sub>0[a \\<otimes>\n   b, c]\\<rangle>\\<rangle> \\<otimes>\n     d) =\n    \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot>\n             \\<pp>\\<^sub>1[a \\<otimes> b, c] \\<cdot>\n             \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes>\n                           c, d], \\<langle>\\<pp>\\<^sub>0[a \\<otimes>\n                   b, c] \\<cdot>\n     \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes>\n                   c, d], d \\<cdot>\n                          \\<pp>\\<^sub>0[(a \\<otimes> b) \\<otimes>\n  c, d]\\<rangle>\\<rangle>", "by simp"], ["proof (state)\nthis:\n  \\<langle>\\<pp>\\<^sub>1[b, c] \\<cdot>\n           \\<pp>\\<^sub>1[b \\<otimes>\n                         c, d], \\<langle>\\<pp>\\<^sub>0[b, c] \\<cdot>\n   \\<pp>\\<^sub>1[b \\<otimes>\n                 c, d], \\<pp>\\<^sub>0[b \\<otimes>\nc, d]\\<rangle>\\<rangle> \\<cdot>\n  (\\<pp>\\<^sub>0[a, (b \\<otimes> c) \\<otimes> d] \\<cdot>\n   \\<langle>\\<pp>\\<^sub>1[a, b \\<otimes> c] \\<cdot>\n            \\<pp>\\<^sub>1[a \\<otimes>\n                          b \\<otimes>\n                          c, d], \\<langle>\\<pp>\\<^sub>0[a, b \\<otimes>\n                     c] \\<cdot>\n    \\<pp>\\<^sub>1[a \\<otimes>\n                  b \\<otimes>\n                  c, d], \\<pp>\\<^sub>0[a \\<otimes>\n b \\<otimes> c, d]\\<rangle>\\<rangle>) \\<cdot>\n  (\\<langle>\\<pp>\\<^sub>1[a, b] \\<cdot>\n            \\<pp>\\<^sub>1[a \\<otimes>\n                          b, c], \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot>\n    \\<pp>\\<^sub>1[a \\<otimes>\n                  b, c], \\<pp>\\<^sub>0[a \\<otimes>\n b, c]\\<rangle>\\<rangle> \\<otimes>\n   d) =\n  \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot>\n           \\<pp>\\<^sub>1[a \\<otimes> b, c] \\<cdot>\n           \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes>\n                         c, d], \\<langle>\\<pp>\\<^sub>0[a \\<otimes>\n                 b, c] \\<cdot>\n   \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes>\n                 c, d], d \\<cdot>\n                        \\<pp>\\<^sub>0[(a \\<otimes> b) \\<otimes>\nc, d]\\<rangle>\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]", "also"], ["proof (state)\nthis:\n  \\<langle>\\<pp>\\<^sub>1[b, c] \\<cdot>\n           \\<pp>\\<^sub>1[b \\<otimes>\n                         c, d], \\<langle>\\<pp>\\<^sub>0[b, c] \\<cdot>\n   \\<pp>\\<^sub>1[b \\<otimes>\n                 c, d], \\<pp>\\<^sub>0[b \\<otimes>\nc, d]\\<rangle>\\<rangle> \\<cdot>\n  (\\<pp>\\<^sub>0[a, (b \\<otimes> c) \\<otimes> d] \\<cdot>\n   \\<langle>\\<pp>\\<^sub>1[a, b \\<otimes> c] \\<cdot>\n            \\<pp>\\<^sub>1[a \\<otimes>\n                          b \\<otimes>\n                          c, d], \\<langle>\\<pp>\\<^sub>0[a, b \\<otimes>\n                     c] \\<cdot>\n    \\<pp>\\<^sub>1[a \\<otimes>\n                  b \\<otimes>\n                  c, d], \\<pp>\\<^sub>0[a \\<otimes>\n b \\<otimes> c, d]\\<rangle>\\<rangle>) \\<cdot>\n  (\\<langle>\\<pp>\\<^sub>1[a, b] \\<cdot>\n            \\<pp>\\<^sub>1[a \\<otimes>\n                          b, c], \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot>\n    \\<pp>\\<^sub>1[a \\<otimes>\n                  b, c], \\<pp>\\<^sub>0[a \\<otimes>\n b, c]\\<rangle>\\<rangle> \\<otimes>\n   d) =\n  \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot>\n           \\<pp>\\<^sub>1[a \\<otimes> b, c] \\<cdot>\n           \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes>\n                         c, d], \\<langle>\\<pp>\\<^sub>0[a \\<otimes>\n                 b, c] \\<cdot>\n   \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes>\n                 c, d], d \\<cdot>\n                        \\<pp>\\<^sub>0[(a \\<otimes> b) \\<otimes>\nc, d]\\<rangle>\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]", "have \"... = \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot> \\<pp>\\<^sub>1[a \\<otimes> b, c] \\<cdot> \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes> c, d],\n                          \\<langle>\\<pp>\\<^sub>0[a \\<otimes> b, c] \\<cdot> \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes> c, d], \\<pp>\\<^sub>0[(a \\<otimes> b) \\<otimes> c, d]\\<rangle>\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot>\n             \\<pp>\\<^sub>1[a \\<otimes> b, c] \\<cdot>\n             \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes>\n                           c, d], \\<langle>\\<pp>\\<^sub>0[a \\<otimes>\n                   b, c] \\<cdot>\n     \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes>\n                   c, d], d \\<cdot>\n                          \\<pp>\\<^sub>0[(a \\<otimes> b) \\<otimes>\n  c, d]\\<rangle>\\<rangle> =\n    \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot>\n             \\<pp>\\<^sub>1[a \\<otimes> b, c] \\<cdot>\n             \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes>\n                           c, d], \\<langle>\\<pp>\\<^sub>0[a \\<otimes>\n                   b, c] \\<cdot>\n     \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes>\n                   c, d], \\<pp>\\<^sub>0[(a \\<otimes> b) \\<otimes>\n  c, d]\\<rangle>\\<rangle>", "using assms comp_cod_arr"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  ide d\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n\ngoal (1 subgoal):\n 1. \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot>\n             \\<pp>\\<^sub>1[a \\<otimes> b, c] \\<cdot>\n             \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes>\n                           c, d], \\<langle>\\<pp>\\<^sub>0[a \\<otimes>\n                   b, c] \\<cdot>\n     \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes>\n                   c, d], d \\<cdot>\n                          \\<pp>\\<^sub>0[(a \\<otimes> b) \\<otimes>\n  c, d]\\<rangle>\\<rangle> =\n    \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot>\n             \\<pp>\\<^sub>1[a \\<otimes> b, c] \\<cdot>\n             \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes>\n                           c, d], \\<langle>\\<pp>\\<^sub>0[a \\<otimes>\n                   b, c] \\<cdot>\n     \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes>\n                   c, d], \\<pp>\\<^sub>0[(a \\<otimes> b) \\<otimes>\n  c, d]\\<rangle>\\<rangle>", "by simp"], ["proof (state)\nthis:\n  \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot>\n           \\<pp>\\<^sub>1[a \\<otimes> b, c] \\<cdot>\n           \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes>\n                         c, d], \\<langle>\\<pp>\\<^sub>0[a \\<otimes>\n                 b, c] \\<cdot>\n   \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes>\n                 c, d], d \\<cdot>\n                        \\<pp>\\<^sub>0[(a \\<otimes> b) \\<otimes>\nc, d]\\<rangle>\\<rangle> =\n  \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot>\n           \\<pp>\\<^sub>1[a \\<otimes> b, c] \\<cdot>\n           \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes>\n                         c, d], \\<langle>\\<pp>\\<^sub>0[a \\<otimes>\n                 b, c] \\<cdot>\n   \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes>\n                 c, d], \\<pp>\\<^sub>0[(a \\<otimes> b) \\<otimes>\nc, d]\\<rangle>\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]", "also"], ["proof (state)\nthis:\n  \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot>\n           \\<pp>\\<^sub>1[a \\<otimes> b, c] \\<cdot>\n           \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes>\n                         c, d], \\<langle>\\<pp>\\<^sub>0[a \\<otimes>\n                 b, c] \\<cdot>\n   \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes>\n                 c, d], d \\<cdot>\n                        \\<pp>\\<^sub>0[(a \\<otimes> b) \\<otimes>\nc, d]\\<rangle>\\<rangle> =\n  \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot>\n           \\<pp>\\<^sub>1[a \\<otimes> b, c] \\<cdot>\n           \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes>\n                         c, d], \\<langle>\\<pp>\\<^sub>0[a \\<otimes>\n                 b, c] \\<cdot>\n   \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes>\n                 c, d], \\<pp>\\<^sub>0[(a \\<otimes> b) \\<otimes>\nc, d]\\<rangle>\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]", "have \"... = \\<pp>\\<^sub>0[a, b \\<otimes> (c \\<otimes> d)] \\<cdot> \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot>\n             \\<pp>\\<^sub>1[a \\<otimes> b, c] \\<cdot>\n             \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes>\n                           c, d], \\<langle>\\<pp>\\<^sub>0[a \\<otimes>\n                   b, c] \\<cdot>\n     \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes>\n                   c, d], \\<pp>\\<^sub>0[(a \\<otimes> b) \\<otimes>\n  c, d]\\<rangle>\\<rangle> =\n    \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]", "using assms assoc_def comp_assoc"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  ide d\n  \\<a>[?a, ?b, ?c] \\<equiv>\n  \\<langle>\\<pp>\\<^sub>1[?a, ?b] \\<cdot>\n           \\<pp>\\<^sub>1[?a \\<otimes>\n                         ?b, ?c], \\<langle>\\<pp>\\<^sub>0[?a, ?b] \\<cdot>\n     \\<pp>\\<^sub>1[?a \\<otimes>\n                   ?b, ?c], \\<pp>\\<^sub>0[?a \\<otimes>\n    ?b, ?c]\\<rangle>\\<rangle>\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot>\n             \\<pp>\\<^sub>1[a \\<otimes> b, c] \\<cdot>\n             \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes>\n                           c, d], \\<langle>\\<pp>\\<^sub>0[a \\<otimes>\n                   b, c] \\<cdot>\n     \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes>\n                   c, d], \\<pp>\\<^sub>0[(a \\<otimes> b) \\<otimes>\n  c, d]\\<rangle>\\<rangle> =\n    \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]", "by simp"], ["proof (state)\nthis:\n  \\<langle>\\<pp>\\<^sub>0[a, b] \\<cdot>\n           \\<pp>\\<^sub>1[a \\<otimes> b, c] \\<cdot>\n           \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes>\n                         c, d], \\<langle>\\<pp>\\<^sub>0[a \\<otimes>\n                 b, c] \\<cdot>\n   \\<pp>\\<^sub>1[(a \\<otimes> b) \\<otimes>\n                 c, d], \\<pp>\\<^sub>0[(a \\<otimes> b) \\<otimes>\nc, d]\\<rangle>\\<rangle> =\n  \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n  \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]", "finally"], ["proof (chain)\npicking this:\n  \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n  ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n  (\\<a>[a, b, c] \\<otimes> d) =\n  \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n  \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n  ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n  (\\<a>[a, b, c] \\<otimes> d) =\n  \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n  \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n    (\\<a>[a, b, c] \\<otimes> d) =\n    \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n    \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]", "by simp"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n  ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n  (\\<a>[a, b, c] \\<otimes> d) =\n  \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n  \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n  ((a \\<otimes> \\<a>[b, c, d]) \\<cdot> \\<a>[a, b \\<otimes> c, d]) \\<cdot>\n  (\\<a>[a, b, c] \\<otimes> d) =\n  \\<pp>\\<^sub>0[a, b \\<otimes> c \\<otimes> d] \\<cdot>\n  \\<a>[a, b, c \\<otimes> d] \\<cdot> \\<a>[a \\<otimes> b, c, d]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inverse_arrows_assoc:\n    assumes \"ide a\" and \"ide b\" and \"ide c\"\n    shows \"inverse_arrows \\<a>[a, b, c] \\<a>\\<^sup>-\\<^sup>1[a, b, c]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_arrows \\<a>[a, b, c] \\<a>\\<^sup>-\\<^sup>1[a, b, c]", "using assms assoc_def assoc'_def comp_assoc"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<a>[?a, ?b, ?c] \\<equiv>\n  \\<langle>\\<pp>\\<^sub>1[?a, ?b] \\<cdot>\n           \\<pp>\\<^sub>1[?a \\<otimes>\n                         ?b, ?c], \\<langle>\\<pp>\\<^sub>0[?a, ?b] \\<cdot>\n     \\<pp>\\<^sub>1[?a \\<otimes>\n                   ?b, ?c], \\<pp>\\<^sub>0[?a \\<otimes>\n    ?b, ?c]\\<rangle>\\<rangle>\n  \\<a>\\<^sup>-\\<^sup>1[?a, ?b, ?c] \\<equiv>\n  \\<langle>\\<langle>\\<pp>\\<^sub>1[?a, ?b \\<otimes>\n?c], \\<pp>\\<^sub>1[?b, ?c] \\<cdot>\n     \\<pp>\\<^sub>0[?a, ?b \\<otimes>\n                       ?c]\\<rangle>, \\<pp>\\<^sub>0[?b, ?c] \\<cdot>\n                                     \\<pp>\\<^sub>0[?a, ?b \\<otimes>\n                 ?c]\\<rangle>\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. inverse_arrows \\<a>[a, b, c] \\<a>\\<^sup>-\\<^sup>1[a, b, c]", "by (auto simp add: tuple_pr_arr)"], ["", "interpretation CC: product_category C C"], ["proof (prove)\ngoal (1 subgoal):\n 1. product_category (\\<cdot>) (\\<cdot>)", ".."], ["", "abbreviation Prod\n    where \"Prod fg \\<equiv> fst fg \\<otimes> snd fg\""], ["", "abbreviation Prod'\n    where \"Prod' fg \\<equiv> snd fg \\<otimes> fst fg\""], ["", "interpretation \\<Pi>: binary_functor C C C Prod"], ["proof (prove)\ngoal (1 subgoal):\n 1. binary_functor (\\<cdot>) (\\<cdot>) (\\<cdot>) local.Prod", "using tuple_ext CC.comp_char interchange"], ["proof (prove)\nusing this:\n  \\<not> span ?f ?g \\<Longrightarrow> \\<langle>?f, ?g\\<rangle> = null\n  CC.comp ?g ?f =\n  (if seq (fst ?g) (fst ?f) \\<and> seq (snd ?g) (snd ?f)\n   then (fst ?g \\<cdot> fst ?f, snd ?g \\<cdot> snd ?f) else (null, null))\n  \\<lbrakk>seq ?h ?f; seq ?k ?g\\<rbrakk>\n  \\<Longrightarrow> (?h \\<otimes> ?k) \\<cdot> (?f \\<otimes> ?g) =\n                    ?h \\<cdot> ?f \\<otimes> ?k \\<cdot> ?g\n\ngoal (1 subgoal):\n 1. binary_functor (\\<cdot>) (\\<cdot>) (\\<cdot>) local.Prod", "apply unfold_locales"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>\\<And>f g.\n                   \\<not> span f g \\<Longrightarrow>\n                   \\<langle>f, g\\<rangle> = null;\n        \\<And>g f.\n           CC.comp g f =\n           (if seq (fst g) (fst f) \\<and> seq (snd g) (snd f)\n            then (fst g \\<cdot> fst f, snd g \\<cdot> snd f)\n            else (null, null));\n        \\<And>h f k g.\n           \\<lbrakk>seq h f; seq k g\\<rbrakk>\n           \\<Longrightarrow> (h \\<otimes> k) \\<cdot> (f \\<otimes> g) =\n                             h \\<cdot> f \\<otimes> k \\<cdot> g;\n        \\<not> CC.arr f\\<rbrakk>\n       \\<Longrightarrow> local.Prod f = null\n 2. \\<And>f.\n       \\<lbrakk>\\<And>f g.\n                   \\<not> span f g \\<Longrightarrow>\n                   \\<langle>f, g\\<rangle> = null;\n        \\<And>g f.\n           CC.comp g f =\n           (if seq (fst g) (fst f) \\<and> seq (snd g) (snd f)\n            then (fst g \\<cdot> fst f, snd g \\<cdot> snd f)\n            else (null, null));\n        \\<And>h f k g.\n           \\<lbrakk>seq h f; seq k g\\<rbrakk>\n           \\<Longrightarrow> (h \\<otimes> k) \\<cdot> (f \\<otimes> g) =\n                             h \\<cdot> f \\<otimes> k \\<cdot> g;\n        CC.arr f\\<rbrakk>\n       \\<Longrightarrow> arr (local.Prod f)\n 3. \\<And>f.\n       \\<lbrakk>\\<And>f g.\n                   \\<not> span f g \\<Longrightarrow>\n                   \\<langle>f, g\\<rangle> = null;\n        \\<And>g f.\n           CC.comp g f =\n           (if seq (fst g) (fst f) \\<and> seq (snd g) (snd f)\n            then (fst g \\<cdot> fst f, snd g \\<cdot> snd f)\n            else (null, null));\n        \\<And>h f k g.\n           \\<lbrakk>seq h f; seq k g\\<rbrakk>\n           \\<Longrightarrow> (h \\<otimes> k) \\<cdot> (f \\<otimes> g) =\n                             h \\<cdot> f \\<otimes> k \\<cdot> g;\n        CC.arr f\\<rbrakk>\n       \\<Longrightarrow> local.dom (local.Prod f) = local.Prod (CC.dom f)\n 4. \\<And>f.\n       \\<lbrakk>\\<And>f g.\n                   \\<not> span f g \\<Longrightarrow>\n                   \\<langle>f, g\\<rangle> = null;\n        \\<And>g f.\n           CC.comp g f =\n           (if seq (fst g) (fst f) \\<and> seq (snd g) (snd f)\n            then (fst g \\<cdot> fst f, snd g \\<cdot> snd f)\n            else (null, null));\n        \\<And>h f k g.\n           \\<lbrakk>seq h f; seq k g\\<rbrakk>\n           \\<Longrightarrow> (h \\<otimes> k) \\<cdot> (f \\<otimes> g) =\n                             h \\<cdot> f \\<otimes> k \\<cdot> g;\n        CC.arr f\\<rbrakk>\n       \\<Longrightarrow> cod (local.Prod f) = local.Prod (CC.cod f)\n 5. \\<And>g f.\n       \\<lbrakk>\\<And>f g.\n                   \\<not> span f g \\<Longrightarrow>\n                   \\<langle>f, g\\<rangle> = null;\n        \\<And>g f.\n           CC.comp g f =\n           (if seq (fst g) (fst f) \\<and> seq (snd g) (snd f)\n            then (fst g \\<cdot> fst f, snd g \\<cdot> snd f)\n            else (null, null));\n        \\<And>h f k g.\n           \\<lbrakk>seq h f; seq k g\\<rbrakk>\n           \\<Longrightarrow> (h \\<otimes> k) \\<cdot> (f \\<otimes> g) =\n                             h \\<cdot> f \\<otimes> k \\<cdot> g;\n        CC.seq g f\\<rbrakk>\n       \\<Longrightarrow> local.Prod (CC.comp g f) =\n                         local.Prod g \\<cdot> local.Prod f", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>f g.\n                   arr g \\<longrightarrow>\n                   arr f \\<longrightarrow>\n                   local.dom f \\<noteq> local.dom g \\<Longrightarrow>\n                   \\<langle>f, g\\<rangle> = null;\n        \\<And>a b aa ba.\n           CC.comp (a, b) (aa, ba) =\n           (if seq a aa \\<and> seq b ba\n            then (fst (a, b) \\<cdot> fst (aa, ba),\n                  snd (a, b) \\<cdot> snd (aa, ba))\n            else (null, null));\n        \\<And>h f k g.\n           \\<lbrakk>seq h f; seq k g\\<rbrakk>\n           \\<Longrightarrow> (h \\<otimes> k) \\<cdot> (f \\<otimes> g) =\n                             h \\<cdot> f \\<otimes> k \\<cdot> g;\n        \\<not> arr a\\<rbrakk>\n       \\<Longrightarrow> a \\<otimes> b = null\n 2. \\<And>a b.\n       \\<lbrakk>\\<And>f g.\n                   arr g \\<longrightarrow>\n                   arr f \\<longrightarrow>\n                   local.dom f \\<noteq> local.dom g \\<Longrightarrow>\n                   \\<langle>f, g\\<rangle> = null;\n        \\<And>a b aa ba.\n           CC.comp (a, b) (aa, ba) =\n           (if seq a aa \\<and> seq b ba\n            then (fst (a, b) \\<cdot> fst (aa, ba),\n                  snd (a, b) \\<cdot> snd (aa, ba))\n            else (null, null));\n        \\<And>h f k g.\n           \\<lbrakk>seq h f; seq k g\\<rbrakk>\n           \\<Longrightarrow> (h \\<otimes> k) \\<cdot> (f \\<otimes> g) =\n                             h \\<cdot> f \\<otimes> k \\<cdot> g;\n        \\<not> arr b\\<rbrakk>\n       \\<Longrightarrow> a \\<otimes> b = null", "by (metis prod_def seqE)+"], ["", "interpretation Prod': binary_functor C C C Prod'"], ["proof (prove)\ngoal (1 subgoal):\n 1. binary_functor (\\<cdot>) (\\<cdot>) (\\<cdot>) Prod'", "using tuple_ext CC.comp_char interchange"], ["proof (prove)\nusing this:\n  \\<not> span ?f ?g \\<Longrightarrow> \\<langle>?f, ?g\\<rangle> = null\n  CC.comp ?g ?f =\n  (if seq (fst ?g) (fst ?f) \\<and> seq (snd ?g) (snd ?f)\n   then (fst ?g \\<cdot> fst ?f, snd ?g \\<cdot> snd ?f) else (null, null))\n  \\<lbrakk>seq ?h ?f; seq ?k ?g\\<rbrakk>\n  \\<Longrightarrow> (?h \\<otimes> ?k) \\<cdot> (?f \\<otimes> ?g) =\n                    ?h \\<cdot> ?f \\<otimes> ?k \\<cdot> ?g\n\ngoal (1 subgoal):\n 1. binary_functor (\\<cdot>) (\\<cdot>) (\\<cdot>) Prod'", "apply unfold_locales"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>\\<And>f g.\n                   \\<not> span f g \\<Longrightarrow>\n                   \\<langle>f, g\\<rangle> = null;\n        \\<And>g f.\n           CC.comp g f =\n           (if seq (fst g) (fst f) \\<and> seq (snd g) (snd f)\n            then (fst g \\<cdot> fst f, snd g \\<cdot> snd f)\n            else (null, null));\n        \\<And>h f k g.\n           \\<lbrakk>seq h f; seq k g\\<rbrakk>\n           \\<Longrightarrow> (h \\<otimes> k) \\<cdot> (f \\<otimes> g) =\n                             h \\<cdot> f \\<otimes> k \\<cdot> g;\n        \\<not> CC.arr f\\<rbrakk>\n       \\<Longrightarrow> Prod' f = null\n 2. \\<And>f.\n       \\<lbrakk>\\<And>f g.\n                   \\<not> span f g \\<Longrightarrow>\n                   \\<langle>f, g\\<rangle> = null;\n        \\<And>g f.\n           CC.comp g f =\n           (if seq (fst g) (fst f) \\<and> seq (snd g) (snd f)\n            then (fst g \\<cdot> fst f, snd g \\<cdot> snd f)\n            else (null, null));\n        \\<And>h f k g.\n           \\<lbrakk>seq h f; seq k g\\<rbrakk>\n           \\<Longrightarrow> (h \\<otimes> k) \\<cdot> (f \\<otimes> g) =\n                             h \\<cdot> f \\<otimes> k \\<cdot> g;\n        CC.arr f\\<rbrakk>\n       \\<Longrightarrow> arr (Prod' f)\n 3. \\<And>f.\n       \\<lbrakk>\\<And>f g.\n                   \\<not> span f g \\<Longrightarrow>\n                   \\<langle>f, g\\<rangle> = null;\n        \\<And>g f.\n           CC.comp g f =\n           (if seq (fst g) (fst f) \\<and> seq (snd g) (snd f)\n            then (fst g \\<cdot> fst f, snd g \\<cdot> snd f)\n            else (null, null));\n        \\<And>h f k g.\n           \\<lbrakk>seq h f; seq k g\\<rbrakk>\n           \\<Longrightarrow> (h \\<otimes> k) \\<cdot> (f \\<otimes> g) =\n                             h \\<cdot> f \\<otimes> k \\<cdot> g;\n        CC.arr f\\<rbrakk>\n       \\<Longrightarrow> local.dom (Prod' f) = Prod' (CC.dom f)\n 4. \\<And>f.\n       \\<lbrakk>\\<And>f g.\n                   \\<not> span f g \\<Longrightarrow>\n                   \\<langle>f, g\\<rangle> = null;\n        \\<And>g f.\n           CC.comp g f =\n           (if seq (fst g) (fst f) \\<and> seq (snd g) (snd f)\n            then (fst g \\<cdot> fst f, snd g \\<cdot> snd f)\n            else (null, null));\n        \\<And>h f k g.\n           \\<lbrakk>seq h f; seq k g\\<rbrakk>\n           \\<Longrightarrow> (h \\<otimes> k) \\<cdot> (f \\<otimes> g) =\n                             h \\<cdot> f \\<otimes> k \\<cdot> g;\n        CC.arr f\\<rbrakk>\n       \\<Longrightarrow> cod (Prod' f) = Prod' (CC.cod f)\n 5. \\<And>g f.\n       \\<lbrakk>\\<And>f g.\n                   \\<not> span f g \\<Longrightarrow>\n                   \\<langle>f, g\\<rangle> = null;\n        \\<And>g f.\n           CC.comp g f =\n           (if seq (fst g) (fst f) \\<and> seq (snd g) (snd f)\n            then (fst g \\<cdot> fst f, snd g \\<cdot> snd f)\n            else (null, null));\n        \\<And>h f k g.\n           \\<lbrakk>seq h f; seq k g\\<rbrakk>\n           \\<Longrightarrow> (h \\<otimes> k) \\<cdot> (f \\<otimes> g) =\n                             h \\<cdot> f \\<otimes> k \\<cdot> g;\n        CC.seq g f\\<rbrakk>\n       \\<Longrightarrow> Prod' (CC.comp g f) = Prod' g \\<cdot> Prod' f", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>f g.\n                   arr g \\<longrightarrow>\n                   arr f \\<longrightarrow>\n                   local.dom f \\<noteq> local.dom g \\<Longrightarrow>\n                   \\<langle>f, g\\<rangle> = null;\n        \\<And>a b aa ba.\n           CC.comp (a, b) (aa, ba) =\n           (if seq a aa \\<and> seq b ba\n            then (fst (a, b) \\<cdot> fst (aa, ba),\n                  snd (a, b) \\<cdot> snd (aa, ba))\n            else (null, null));\n        \\<And>h f k g.\n           \\<lbrakk>seq h f; seq k g\\<rbrakk>\n           \\<Longrightarrow> (h \\<otimes> k) \\<cdot> (f \\<otimes> g) =\n                             h \\<cdot> f \\<otimes> k \\<cdot> g;\n        \\<not> arr a\\<rbrakk>\n       \\<Longrightarrow> b \\<otimes> a = null\n 2. \\<And>a b.\n       \\<lbrakk>\\<And>f g.\n                   arr g \\<longrightarrow>\n                   arr f \\<longrightarrow>\n                   local.dom f \\<noteq> local.dom g \\<Longrightarrow>\n                   \\<langle>f, g\\<rangle> = null;\n        \\<And>a b aa ba.\n           CC.comp (a, b) (aa, ba) =\n           (if seq a aa \\<and> seq b ba\n            then (fst (a, b) \\<cdot> fst (aa, ba),\n                  snd (a, b) \\<cdot> snd (aa, ba))\n            else (null, null));\n        \\<And>h f k g.\n           \\<lbrakk>seq h f; seq k g\\<rbrakk>\n           \\<Longrightarrow> (h \\<otimes> k) \\<cdot> (f \\<otimes> g) =\n                             h \\<cdot> f \\<otimes> k \\<cdot> g;\n        \\<not> arr b\\<rbrakk>\n       \\<Longrightarrow> b \\<otimes> a = null", "by (metis prod_def seqE)+"], ["", "lemma binary_functor_Prod:\n    shows \"binary_functor C C C Prod\" and \"binary_functor C C C Prod'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. binary_functor (\\<cdot>) (\\<cdot>) (\\<cdot>) local.Prod &&&\n    binary_functor (\\<cdot>) (\\<cdot>) (\\<cdot>) Prod'", ".."], ["", "definition sym (\"\\<s>[_, _]\")\n    where \"\\<s>[a1, a0] \\<equiv> if ide a0 \\<and> ide a1 then \\<langle>\\<pp>\\<^sub>0[a1, a0], \\<pp>\\<^sub>1[a1, a0]\\<rangle> else null\""], ["", "lemma sym_in_hom [intro]:\n    assumes \"ide a\" and \"ide b\"\n    shows \"\\<guillemotleft>\\<s>[a, b] : a \\<otimes> b \\<rightarrow> b \\<otimes> a\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<s>[a, b] : a \\<otimes>\n                                 b \\<rightarrow> b \\<otimes>\n           a\\<guillemotright>", "using assms sym_def"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  \\<s>[?a1.0, ?a0.0] \\<equiv>\n  if ide ?a0.0 \\<and> ide ?a1.0\n  then \\<langle>\\<pp>\\<^sub>0[?a1.0, ?a0.0], \\<pp>\\<^sub>1[?a1.0, ?a0.0]\\<rangle>\n  else null\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<s>[a, b] : a \\<otimes>\n                                 b \\<rightarrow> b \\<otimes>\n           a\\<guillemotright>", "by auto"], ["", "lemma sym_simps [simp]:\n    assumes \"ide a\" and \"ide b\"\n    shows \"arr \\<s>[a, b]\" and \"dom \\<s>[a, b] = a \\<otimes> b\" and \"cod \\<s>[a, b] = b \\<otimes> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr \\<s>[a, b] &&&\n    local.dom \\<s>[a, b] = a \\<otimes> b &&& cod \\<s>[a, b] = b \\<otimes> a", "using assms sym_in_hom"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>\\<s>[?a, ?b] : ?a \\<otimes>\n             ?b \\<rightarrow> ?b \\<otimes> ?a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. arr \\<s>[a, b] &&&\n    local.dom \\<s>[a, b] = a \\<otimes> b &&& cod \\<s>[a, b] = b \\<otimes> a", "by auto"], ["", "lemma comp_sym_tuple [simp]:\n    assumes \"\\<guillemotleft>f0 : a \\<rightarrow> b0\\<guillemotright>\" and \"\\<guillemotleft>f1 : a \\<rightarrow> b1\\<guillemotright>\"\n    shows \"\\<s>[b0, b1] \\<cdot> \\<langle>f0, f1\\<rangle> = \\<langle>f1, f0\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<s>[b0, b1] \\<cdot> \\<langle>f0, f1\\<rangle> = \\<langle>f1, f0\\<rangle>", "using assms sym_def comp_tuple_arr"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f0 : a \\<rightarrow> b0\\<guillemotright>\n  \\<guillemotleft>f1 : a \\<rightarrow> b1\\<guillemotright>\n  \\<s>[?a1.0, ?a0.0] \\<equiv>\n  if ide ?a0.0 \\<and> ide ?a1.0\n  then \\<langle>\\<pp>\\<^sub>0[?a1.0, ?a0.0], \\<pp>\\<^sub>1[?a1.0, ?a0.0]\\<rangle>\n  else null\n  \\<lbrakk>span ?f ?g; arr ?h; local.dom ?f = cod ?h\\<rbrakk>\n  \\<Longrightarrow> \\<langle>?f, ?g\\<rangle> \\<cdot> ?h =\n                    \\<langle>?f \\<cdot> ?h, ?g \\<cdot> ?h\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<s>[b0, b1] \\<cdot> \\<langle>f0, f1\\<rangle> = \\<langle>f1, f0\\<rangle>", "by fastforce"], ["", "lemma prj_sym [simp]:\n    assumes \"ide a0\" and \"ide a1\"\n    shows \"\\<pp>\\<^sub>0[a1, a0] \\<cdot> \\<s>[a0, a1] = \\<pp>\\<^sub>1[a0, a1]\"\n    and \"\\<pp>\\<^sub>1[a1, a0] \\<cdot> \\<s>[a0, a1] = \\<pp>\\<^sub>0[a0, a1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a1, a0] \\<cdot> \\<s>[a0, a1] = \\<pp>\\<^sub>1[a0, a1] &&&\n    \\<pp>\\<^sub>1[a1, a0] \\<cdot> \\<s>[a0, a1] = \\<pp>\\<^sub>0[a0, a1]", "using assms sym_def"], ["proof (prove)\nusing this:\n  ide a0\n  ide a1\n  \\<s>[?a1.0, ?a0.0] \\<equiv>\n  if ide ?a0.0 \\<and> ide ?a1.0\n  then \\<langle>\\<pp>\\<^sub>0[?a1.0, ?a0.0], \\<pp>\\<^sub>1[?a1.0, ?a0.0]\\<rangle>\n  else null\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a1, a0] \\<cdot> \\<s>[a0, a1] = \\<pp>\\<^sub>1[a0, a1] &&&\n    \\<pp>\\<^sub>1[a1, a0] \\<cdot> \\<s>[a0, a1] = \\<pp>\\<^sub>0[a0, a1]", "by auto"], ["", "lemma comp_sym_sym [simp]:\n    assumes \"ide a0\" and \"ide a1\"\n    shows \"\\<s>[a1, a0] \\<cdot> \\<s>[a0, a1] = (a0 \\<otimes> a1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<s>[a1, a0] \\<cdot> \\<s>[a0, a1] = a0 \\<otimes> a1", "using assms sym_def comp_tuple_arr"], ["proof (prove)\nusing this:\n  ide a0\n  ide a1\n  \\<s>[?a1.0, ?a0.0] \\<equiv>\n  if ide ?a0.0 \\<and> ide ?a1.0\n  then \\<langle>\\<pp>\\<^sub>0[?a1.0, ?a0.0], \\<pp>\\<^sub>1[?a1.0, ?a0.0]\\<rangle>\n  else null\n  \\<lbrakk>span ?f ?g; arr ?h; local.dom ?f = cod ?h\\<rbrakk>\n  \\<Longrightarrow> \\<langle>?f, ?g\\<rangle> \\<cdot> ?h =\n                    \\<langle>?f \\<cdot> ?h, ?g \\<cdot> ?h\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<s>[a1, a0] \\<cdot> \\<s>[a0, a1] = a0 \\<otimes> a1", "by auto"], ["", "lemma sym_inverse_arrows:\n    assumes \"ide a0\" and \"ide a1\"\n    shows \"inverse_arrows \\<s>[a0, a1] \\<s>[a1, a0]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_arrows \\<s>[a0, a1] \\<s>[a1, a0]", "using assms sym_in_hom comp_sym_sym"], ["proof (prove)\nusing this:\n  ide a0\n  ide a1\n  \\<lbrakk>ide ?a; ide ?b\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>\\<s>[?a, ?b] : ?a \\<otimes>\n             ?b \\<rightarrow> ?b \\<otimes> ?a\\<guillemotright>\n  \\<lbrakk>ide ?a0.0; ide ?a1.0\\<rbrakk>\n  \\<Longrightarrow> \\<s>[?a1.0, ?a0.0] \\<cdot> \\<s>[?a0.0, ?a1.0] =\n                    ?a0.0 \\<otimes> ?a1.0\n\ngoal (1 subgoal):\n 1. inverse_arrows \\<s>[a0, a1] \\<s>[a1, a0]", "by auto"], ["", "lemma sym_assoc_coherence:\n    assumes \"ide a\" and \"ide b\" and \"ide c\"\n    shows \"\\<a>[b, c, a] \\<cdot> \\<s>[a, b \\<otimes> c] \\<cdot> \\<a>[a, b, c] = (b \\<otimes> \\<s>[a, c]) \\<cdot> \\<a>[b, a, c] \\<cdot> (\\<s>[a, b] \\<otimes> c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<a>[b, c, a] \\<cdot> \\<s>[a, b \\<otimes> c] \\<cdot> \\<a>[a, b, c] =\n    (b \\<otimes> \\<s>[a, c]) \\<cdot>\n    \\<a>[b, a, c] \\<cdot> (\\<s>[a, b] \\<otimes> c)", "using assms sym_def assoc_def comp_assoc prod_tuple comp_cod_arr"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<s>[?a1.0, ?a0.0] \\<equiv>\n  if ide ?a0.0 \\<and> ide ?a1.0\n  then \\<langle>\\<pp>\\<^sub>0[?a1.0, ?a0.0], \\<pp>\\<^sub>1[?a1.0, ?a0.0]\\<rangle>\n  else null\n  \\<a>[?a, ?b, ?c] \\<equiv>\n  \\<langle>\\<pp>\\<^sub>1[?a, ?b] \\<cdot>\n           \\<pp>\\<^sub>1[?a \\<otimes>\n                         ?b, ?c], \\<langle>\\<pp>\\<^sub>0[?a, ?b] \\<cdot>\n     \\<pp>\\<^sub>1[?a \\<otimes>\n                   ?b, ?c], \\<pp>\\<^sub>0[?a \\<otimes>\n    ?b, ?c]\\<rangle>\\<rangle>\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n  \\<lbrakk>span ?f ?g; seq ?h ?f; seq ?k ?g\\<rbrakk>\n  \\<Longrightarrow> (?h \\<otimes> ?k) \\<cdot> \\<langle>?f, ?g\\<rangle> =\n                    \\<langle>?h \\<cdot> ?f, ?k \\<cdot> ?g\\<rangle>\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n\ngoal (1 subgoal):\n 1. \\<a>[b, c, a] \\<cdot> \\<s>[a, b \\<otimes> c] \\<cdot> \\<a>[a, b, c] =\n    (b \\<otimes> \\<s>[a, c]) \\<cdot>\n    \\<a>[b, a, c] \\<cdot> (\\<s>[a, b] \\<otimes> c)", "by simp"], ["", "lemma sym_naturality:\n    assumes \"\\<guillemotleft>f0 : a0 \\<rightarrow> b0\\<guillemotright>\" and \"\\<guillemotleft>f1 : a1 \\<rightarrow> b1\\<guillemotright>\"\n    shows \"\\<s>[b0, b1] \\<cdot> (f0 \\<otimes> f1) = (f1 \\<otimes> f0) \\<cdot> \\<s>[a0, a1]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<s>[b0, b1] \\<cdot> (f0 \\<otimes> f1) =\n    (f1 \\<otimes> f0) \\<cdot> \\<s>[a0, a1]", "using assms sym_def comp_assoc prod_tuple"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f0 : a0 \\<rightarrow> b0\\<guillemotright>\n  \\<guillemotleft>f1 : a1 \\<rightarrow> b1\\<guillemotright>\n  \\<s>[?a1.0, ?a0.0] \\<equiv>\n  if ide ?a0.0 \\<and> ide ?a1.0\n  then \\<langle>\\<pp>\\<^sub>0[?a1.0, ?a0.0], \\<pp>\\<^sub>1[?a1.0, ?a0.0]\\<rangle>\n  else null\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n  \\<lbrakk>span ?f ?g; seq ?h ?f; seq ?k ?g\\<rbrakk>\n  \\<Longrightarrow> (?h \\<otimes> ?k) \\<cdot> \\<langle>?f, ?g\\<rangle> =\n                    \\<langle>?h \\<cdot> ?f, ?k \\<cdot> ?g\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<s>[b0, b1] \\<cdot> (f0 \\<otimes> f1) =\n    (f1 \\<otimes> f0) \\<cdot> \\<s>[a0, a1]", "by fastforce"], ["", "abbreviation \\<sigma>\n    where \"\\<sigma> fg \\<equiv> \\<s>[cod (fst fg), cod (snd fg)] \\<cdot> (fst fg \\<otimes> snd fg)\""], ["", "interpretation \\<sigma>: natural_transformation CC.comp C Prod Prod' \\<sigma>"], ["proof (prove)\ngoal (1 subgoal):\n 1. natural_transformation CC.comp (\\<cdot>) local.Prod Prod' \\<sigma>", "using sym_def CC.arr_char CC.null_char comp_arr_dom comp_cod_arr"], ["proof (prove)\nusing this:\n  \\<s>[?a1.0, ?a0.0] \\<equiv>\n  if ide ?a0.0 \\<and> ide ?a1.0\n  then \\<langle>\\<pp>\\<^sub>0[?a1.0, ?a0.0], \\<pp>\\<^sub>1[?a1.0, ?a0.0]\\<rangle>\n  else null\n  CC.arr ?f = (arr (fst ?f) \\<and> arr (snd ?f))\n  CC.null = (null, null)\n  \\<lbrakk>arr ?f; local.dom ?f = ?a\\<rbrakk>\n  \\<Longrightarrow> ?f \\<cdot> ?a = ?f\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n\ngoal (1 subgoal):\n 1. natural_transformation CC.comp (\\<cdot>) local.Prod Prod' \\<sigma>", "apply unfold_locales"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>f.\n       \\<lbrakk>\\<And>a1 a0.\n                   \\<s>[a1, a0] \\<equiv>\n                   if ide a0 \\<and> ide a1\n                   then \\<langle>\\<pp>\\<^sub>0[a1, a0], \\<pp>\\<^sub>1[a1, a0]\\<rangle>\n                   else null;\n        \\<And>f. CC.arr f = (arr (fst f) \\<and> arr (snd f));\n        CC.null = (null, null);\n        \\<And>f a.\n           \\<lbrakk>arr f; local.dom f = a\\<rbrakk>\n           \\<Longrightarrow> f \\<cdot> a = f;\n        \\<And>f b.\n           \\<lbrakk>arr f; cod f = b\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        \\<not> CC.arr f\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> f = null\n 2. \\<And>f.\n       \\<lbrakk>\\<And>a1 a0.\n                   \\<s>[a1, a0] \\<equiv>\n                   if ide a0 \\<and> ide a1\n                   then \\<langle>\\<pp>\\<^sub>0[a1, a0], \\<pp>\\<^sub>1[a1, a0]\\<rangle>\n                   else null;\n        \\<And>f. CC.arr f = (arr (fst f) \\<and> arr (snd f));\n        CC.null = (null, null);\n        \\<And>f a.\n           \\<lbrakk>arr f; local.dom f = a\\<rbrakk>\n           \\<Longrightarrow> f \\<cdot> a = f;\n        \\<And>f b.\n           \\<lbrakk>arr f; cod f = b\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        CC.arr f\\<rbrakk>\n       \\<Longrightarrow> local.dom (\\<sigma> f) = local.Prod (CC.dom f)\n 3. \\<And>f.\n       \\<lbrakk>\\<And>a1 a0.\n                   \\<s>[a1, a0] \\<equiv>\n                   if ide a0 \\<and> ide a1\n                   then \\<langle>\\<pp>\\<^sub>0[a1, a0], \\<pp>\\<^sub>1[a1, a0]\\<rangle>\n                   else null;\n        \\<And>f. CC.arr f = (arr (fst f) \\<and> arr (snd f));\n        CC.null = (null, null);\n        \\<And>f a.\n           \\<lbrakk>arr f; local.dom f = a\\<rbrakk>\n           \\<Longrightarrow> f \\<cdot> a = f;\n        \\<And>f b.\n           \\<lbrakk>arr f; cod f = b\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        CC.arr f\\<rbrakk>\n       \\<Longrightarrow> cod (\\<sigma> f) = Prod' (CC.cod f)\n 4. \\<And>f.\n       \\<lbrakk>\\<And>a1 a0.\n                   \\<s>[a1, a0] \\<equiv>\n                   if ide a0 \\<and> ide a1\n                   then \\<langle>\\<pp>\\<^sub>0[a1, a0], \\<pp>\\<^sub>1[a1, a0]\\<rangle>\n                   else null;\n        \\<And>f. CC.arr f = (arr (fst f) \\<and> arr (snd f));\n        CC.null = (null, null);\n        \\<And>f a.\n           \\<lbrakk>arr f; local.dom f = a\\<rbrakk>\n           \\<Longrightarrow> f \\<cdot> a = f;\n        \\<And>f b.\n           \\<lbrakk>arr f; cod f = b\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        CC.arr f\\<rbrakk>\n       \\<Longrightarrow> Prod' f \\<cdot> \\<sigma> (CC.dom f) = \\<sigma> f\n 5. \\<And>f.\n       \\<lbrakk>\\<And>a1 a0.\n                   \\<s>[a1, a0] \\<equiv>\n                   if ide a0 \\<and> ide a1\n                   then \\<langle>\\<pp>\\<^sub>0[a1, a0], \\<pp>\\<^sub>1[a1, a0]\\<rangle>\n                   else null;\n        \\<And>f. CC.arr f = (arr (fst f) \\<and> arr (snd f));\n        CC.null = (null, null);\n        \\<And>f a.\n           \\<lbrakk>arr f; local.dom f = a\\<rbrakk>\n           \\<Longrightarrow> f \\<cdot> a = f;\n        \\<And>f b.\n           \\<lbrakk>arr f; cod f = b\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        CC.arr f\\<rbrakk>\n       \\<Longrightarrow> \\<sigma> (CC.cod f) \\<cdot> local.Prod f =\n                         \\<sigma> f", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>a1 a0.\n                   \\<s>[a1, a0] \\<equiv>\n                   if ide a0 \\<and> ide a1\n                   then \\<langle>\\<pp>\\<^sub>0[a1, a0], \\<pp>\\<^sub>1[a1, a0]\\<rangle>\n                   else null;\n        \\<And>f a.\n           \\<lbrakk>arr f; local.dom f = a\\<rbrakk>\n           \\<Longrightarrow> f \\<cdot> a = f;\n        \\<And>f b.\n           \\<lbrakk>arr f; cod f = b\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        ide (cod b); ide (cod a); \\<not> arr a\\<rbrakk>\n       \\<Longrightarrow> \\<langle>\\<pp>\\<^sub>0[cod\n           a, cod b], \\<pp>\\<^sub>1[cod a, cod b]\\<rangle> \\<cdot>\n                         (a \\<otimes> b) =\n                         null\n 2. \\<And>a b.\n       \\<lbrakk>\\<And>a1 a0.\n                   \\<s>[a1, a0] \\<equiv>\n                   if ide a0 \\<and> ide a1\n                   then \\<langle>\\<pp>\\<^sub>0[a1, a0], \\<pp>\\<^sub>1[a1, a0]\\<rangle>\n                   else null;\n        \\<And>f a.\n           \\<lbrakk>arr f; local.dom f = a\\<rbrakk>\n           \\<Longrightarrow> f \\<cdot> a = f;\n        \\<And>f b.\n           \\<lbrakk>arr f; cod f = b\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        ide (cod b); ide (cod a); \\<not> arr b\\<rbrakk>\n       \\<Longrightarrow> \\<langle>\\<pp>\\<^sub>0[cod\n           a, cod b], \\<pp>\\<^sub>1[cod a, cod b]\\<rangle> \\<cdot>\n                         (a \\<otimes> b) =\n                         null\n 3. \\<And>a b.\n       \\<lbrakk>\\<And>a1 a0.\n                   \\<s>[a1, a0] \\<equiv>\n                   if ide a0 \\<and> ide a1\n                   then \\<langle>\\<pp>\\<^sub>0[a1, a0], \\<pp>\\<^sub>1[a1, a0]\\<rangle>\n                   else null;\n        \\<And>f a.\n           \\<lbrakk>arr f; local.dom f = a\\<rbrakk>\n           \\<Longrightarrow> f \\<cdot> a = f;\n        \\<And>f b.\n           \\<lbrakk>arr f; cod f = b\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        arr a; arr b\\<rbrakk>\n       \\<Longrightarrow> (b \\<otimes> a) \\<cdot>\n                         \\<langle>\\<pp>\\<^sub>0[local.dom\n           a, local.dom\n               b], \\<pp>\\<^sub>1[local.dom a, local.dom b]\\<rangle> =\n                         \\<langle>b \\<cdot>\n                                  \\<pp>\\<^sub>0[local.dom\n           a, local.dom\n               b], a \\<cdot>\n                   \\<pp>\\<^sub>1[local.dom a, local.dom b]\\<rangle>", "using arr_cod_iff_arr ideD(1)"], ["proof (prove)\nusing this:\n  arr (cod ?f) = arr ?f\n  ide ?a \\<Longrightarrow> arr ?a\n\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>a1 a0.\n                   \\<s>[a1, a0] \\<equiv>\n                   if ide a0 \\<and> ide a1\n                   then \\<langle>\\<pp>\\<^sub>0[a1, a0], \\<pp>\\<^sub>1[a1, a0]\\<rangle>\n                   else null;\n        \\<And>f a.\n           \\<lbrakk>arr f; local.dom f = a\\<rbrakk>\n           \\<Longrightarrow> f \\<cdot> a = f;\n        \\<And>f b.\n           \\<lbrakk>arr f; cod f = b\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        ide (cod b); ide (cod a); \\<not> arr a\\<rbrakk>\n       \\<Longrightarrow> \\<langle>\\<pp>\\<^sub>0[cod\n           a, cod b], \\<pp>\\<^sub>1[cod a, cod b]\\<rangle> \\<cdot>\n                         (a \\<otimes> b) =\n                         null\n 2. \\<And>a b.\n       \\<lbrakk>\\<And>a1 a0.\n                   \\<s>[a1, a0] \\<equiv>\n                   if ide a0 \\<and> ide a1\n                   then \\<langle>\\<pp>\\<^sub>0[a1, a0], \\<pp>\\<^sub>1[a1, a0]\\<rangle>\n                   else null;\n        \\<And>f a.\n           \\<lbrakk>arr f; local.dom f = a\\<rbrakk>\n           \\<Longrightarrow> f \\<cdot> a = f;\n        \\<And>f b.\n           \\<lbrakk>arr f; cod f = b\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        ide (cod b); ide (cod a); \\<not> arr b\\<rbrakk>\n       \\<Longrightarrow> \\<langle>\\<pp>\\<^sub>0[cod\n           a, cod b], \\<pp>\\<^sub>1[cod a, cod b]\\<rangle> \\<cdot>\n                         (a \\<otimes> b) =\n                         null\n 3. \\<And>a b.\n       \\<lbrakk>\\<And>a1 a0.\n                   \\<s>[a1, a0] \\<equiv>\n                   if ide a0 \\<and> ide a1\n                   then \\<langle>\\<pp>\\<^sub>0[a1, a0], \\<pp>\\<^sub>1[a1, a0]\\<rangle>\n                   else null;\n        \\<And>f a.\n           \\<lbrakk>arr f; local.dom f = a\\<rbrakk>\n           \\<Longrightarrow> f \\<cdot> a = f;\n        \\<And>f b.\n           \\<lbrakk>arr f; cod f = b\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        arr a; arr b\\<rbrakk>\n       \\<Longrightarrow> (b \\<otimes> a) \\<cdot>\n                         \\<langle>\\<pp>\\<^sub>0[local.dom\n           a, local.dom\n               b], \\<pp>\\<^sub>1[local.dom a, local.dom b]\\<rangle> =\n                         \\<langle>b \\<cdot>\n                                  \\<pp>\\<^sub>0[local.dom\n           a, local.dom\n               b], a \\<cdot>\n                   \\<pp>\\<^sub>1[local.dom a, local.dom b]\\<rangle>", "apply metis"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>a1 a0.\n                   \\<s>[a1, a0] \\<equiv>\n                   if ide a0 \\<and> ide a1\n                   then \\<langle>\\<pp>\\<^sub>0[a1, a0], \\<pp>\\<^sub>1[a1, a0]\\<rangle>\n                   else null;\n        \\<And>f a.\n           \\<lbrakk>arr f; local.dom f = a\\<rbrakk>\n           \\<Longrightarrow> f \\<cdot> a = f;\n        \\<And>f b.\n           \\<lbrakk>arr f; cod f = b\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        ide (cod b); ide (cod a); \\<not> arr b\\<rbrakk>\n       \\<Longrightarrow> \\<langle>\\<pp>\\<^sub>0[cod\n           a, cod b], \\<pp>\\<^sub>1[cod a, cod b]\\<rangle> \\<cdot>\n                         (a \\<otimes> b) =\n                         null\n 2. \\<And>a b.\n       \\<lbrakk>\\<And>a1 a0.\n                   \\<s>[a1, a0] \\<equiv>\n                   if ide a0 \\<and> ide a1\n                   then \\<langle>\\<pp>\\<^sub>0[a1, a0], \\<pp>\\<^sub>1[a1, a0]\\<rangle>\n                   else null;\n        \\<And>f a.\n           \\<lbrakk>arr f; local.dom f = a\\<rbrakk>\n           \\<Longrightarrow> f \\<cdot> a = f;\n        \\<And>f b.\n           \\<lbrakk>arr f; cod f = b\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        arr a; arr b\\<rbrakk>\n       \\<Longrightarrow> (b \\<otimes> a) \\<cdot>\n                         \\<langle>\\<pp>\\<^sub>0[local.dom\n           a, local.dom\n               b], \\<pp>\\<^sub>1[local.dom a, local.dom b]\\<rangle> =\n                         \\<langle>b \\<cdot>\n                                  \\<pp>\\<^sub>0[local.dom\n           a, local.dom\n               b], a \\<cdot>\n                   \\<pp>\\<^sub>1[local.dom a, local.dom b]\\<rangle>", "using arr_cod_iff_arr ideD(1)"], ["proof (prove)\nusing this:\n  arr (cod ?f) = arr ?f\n  ide ?a \\<Longrightarrow> arr ?a\n\ngoal (2 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>a1 a0.\n                   \\<s>[a1, a0] \\<equiv>\n                   if ide a0 \\<and> ide a1\n                   then \\<langle>\\<pp>\\<^sub>0[a1, a0], \\<pp>\\<^sub>1[a1, a0]\\<rangle>\n                   else null;\n        \\<And>f a.\n           \\<lbrakk>arr f; local.dom f = a\\<rbrakk>\n           \\<Longrightarrow> f \\<cdot> a = f;\n        \\<And>f b.\n           \\<lbrakk>arr f; cod f = b\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        ide (cod b); ide (cod a); \\<not> arr b\\<rbrakk>\n       \\<Longrightarrow> \\<langle>\\<pp>\\<^sub>0[cod\n           a, cod b], \\<pp>\\<^sub>1[cod a, cod b]\\<rangle> \\<cdot>\n                         (a \\<otimes> b) =\n                         null\n 2. \\<And>a b.\n       \\<lbrakk>\\<And>a1 a0.\n                   \\<s>[a1, a0] \\<equiv>\n                   if ide a0 \\<and> ide a1\n                   then \\<langle>\\<pp>\\<^sub>0[a1, a0], \\<pp>\\<^sub>1[a1, a0]\\<rangle>\n                   else null;\n        \\<And>f a.\n           \\<lbrakk>arr f; local.dom f = a\\<rbrakk>\n           \\<Longrightarrow> f \\<cdot> a = f;\n        \\<And>f b.\n           \\<lbrakk>arr f; cod f = b\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        arr a; arr b\\<rbrakk>\n       \\<Longrightarrow> (b \\<otimes> a) \\<cdot>\n                         \\<langle>\\<pp>\\<^sub>0[local.dom\n           a, local.dom\n               b], \\<pp>\\<^sub>1[local.dom a, local.dom b]\\<rangle> =\n                         \\<langle>b \\<cdot>\n                                  \\<pp>\\<^sub>0[local.dom\n           a, local.dom\n               b], a \\<cdot>\n                   \\<pp>\\<^sub>1[local.dom a, local.dom b]\\<rangle>", "apply metis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>a1 a0.\n                   \\<s>[a1, a0] \\<equiv>\n                   if ide a0 \\<and> ide a1\n                   then \\<langle>\\<pp>\\<^sub>0[a1, a0], \\<pp>\\<^sub>1[a1, a0]\\<rangle>\n                   else null;\n        \\<And>f a.\n           \\<lbrakk>arr f; local.dom f = a\\<rbrakk>\n           \\<Longrightarrow> f \\<cdot> a = f;\n        \\<And>f b.\n           \\<lbrakk>arr f; cod f = b\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        arr a; arr b\\<rbrakk>\n       \\<Longrightarrow> (b \\<otimes> a) \\<cdot>\n                         \\<langle>\\<pp>\\<^sub>0[local.dom\n           a, local.dom\n               b], \\<pp>\\<^sub>1[local.dom a, local.dom b]\\<rangle> =\n                         \\<langle>b \\<cdot>\n                                  \\<pp>\\<^sub>0[local.dom\n           a, local.dom\n               b], a \\<cdot>\n                   \\<pp>\\<^sub>1[local.dom a, local.dom b]\\<rangle>", "using prod_tuple"], ["proof (prove)\nusing this:\n  \\<lbrakk>span ?f ?g; seq ?h ?f; seq ?k ?g\\<rbrakk>\n  \\<Longrightarrow> (?h \\<otimes> ?k) \\<cdot> \\<langle>?f, ?g\\<rangle> =\n                    \\<langle>?h \\<cdot> ?f, ?k \\<cdot> ?g\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>a b.\n       \\<lbrakk>\\<And>a1 a0.\n                   \\<s>[a1, a0] \\<equiv>\n                   if ide a0 \\<and> ide a1\n                   then \\<langle>\\<pp>\\<^sub>0[a1, a0], \\<pp>\\<^sub>1[a1, a0]\\<rangle>\n                   else null;\n        \\<And>f a.\n           \\<lbrakk>arr f; local.dom f = a\\<rbrakk>\n           \\<Longrightarrow> f \\<cdot> a = f;\n        \\<And>f b.\n           \\<lbrakk>arr f; cod f = b\\<rbrakk>\n           \\<Longrightarrow> b \\<cdot> f = f;\n        arr a; arr b\\<rbrakk>\n       \\<Longrightarrow> (b \\<otimes> a) \\<cdot>\n                         \\<langle>\\<pp>\\<^sub>0[local.dom\n           a, local.dom\n               b], \\<pp>\\<^sub>1[local.dom a, local.dom b]\\<rangle> =\n                         \\<langle>b \\<cdot>\n                                  \\<pp>\\<^sub>0[local.dom\n           a, local.dom\n               b], a \\<cdot>\n                   \\<pp>\\<^sub>1[local.dom a, local.dom b]\\<rangle>", "by simp"], ["", "lemma \\<sigma>_is_natural_transformation:\n    shows \"natural_transformation CC.comp C Prod Prod' \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. natural_transformation CC.comp (\\<cdot>) local.Prod Prod' \\<sigma>", ".."], ["", "abbreviation Diag\n    where \"Diag f \\<equiv> if arr f then (f, f) else CC.null\""], ["", "interpretation \\<Delta>: \"functor\" C CC.comp Diag"], ["proof (prove)\ngoal (1 subgoal):\n 1. functor (\\<cdot>) CC.comp Diag", "by (unfold_locales, auto)"], ["", "lemma functor_Diag:\n    shows \"functor C CC.comp Diag\""], ["proof (prove)\ngoal (1 subgoal):\n 1. functor (\\<cdot>) CC.comp Diag", ".."], ["", "interpretation \\<Delta>o\\<Pi>: composite_functor CC.comp C CC.comp Prod Diag"], ["proof (prove)\ngoal (1 subgoal):\n 1. composite_functor CC.comp (\\<cdot>) CC.comp local.Prod Diag", ".."], ["", "interpretation \\<Pi>o\\<Delta>: composite_functor C CC.comp C Diag Prod"], ["proof (prove)\ngoal (1 subgoal):\n 1. composite_functor (\\<cdot>) CC.comp (\\<cdot>) Diag local.Prod", ".."], ["", "abbreviation \\<pi>\n    where \"\\<pi> \\<equiv> \\<lambda>(f, g). (\\<pp>\\<^sub>1[cod f, cod g] \\<cdot> (f \\<otimes> g), \\<pp>\\<^sub>0[cod f, cod g] \\<cdot> (f \\<otimes> g))\""], ["", "interpretation \\<pi>: transformation_by_components CC.comp CC.comp \\<Delta>o\\<Pi>.map CC.map \\<pi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. transformation_by_components CC.comp CC.comp \\<Delta>o\\<Pi>.map CC.map\n     \\<pi>", "using pr_naturality comp_arr_dom comp_cod_arr"], ["proof (prove)\nusing this:\n  \\<lbrakk>arr ?g; local.dom ?g = ?b; cod ?g = ?d; arr ?f;\n   local.dom ?f = ?a; cod ?f = ?c\\<rbrakk>\n  \\<Longrightarrow> \\<pp>\\<^sub>0[?c, ?d] \\<cdot> (?f \\<otimes> ?g) =\n                    ?g \\<cdot> \\<pp>\\<^sub>0[?a, ?b]\n  \\<lbrakk>arr ?g; local.dom ?g = ?b; cod ?g = ?d; arr ?f;\n   local.dom ?f = ?a; cod ?f = ?c\\<rbrakk>\n  \\<Longrightarrow> \\<pp>\\<^sub>1[?c, ?d] \\<cdot> (?f \\<otimes> ?g) =\n                    ?f \\<cdot> \\<pp>\\<^sub>1[?a, ?b]\n  \\<lbrakk>arr ?f; local.dom ?f = ?a\\<rbrakk>\n  \\<Longrightarrow> ?f \\<cdot> ?a = ?f\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n\ngoal (1 subgoal):\n 1. transformation_by_components CC.comp CC.comp \\<Delta>o\\<Pi>.map CC.map\n     \\<pi>", "by unfold_locales auto"], ["", "lemma \\<pi>_is_natural_transformation:\n    shows \"natural_transformation CC.comp CC.comp \\<Delta>o\\<Pi>.map CC.map \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. natural_transformation CC.comp CC.comp \\<Delta>o\\<Pi>.map CC.map \\<pi>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. natural_transformation CC.comp CC.comp \\<Delta>o\\<Pi>.map CC.map \\<pi>", "have \"\\<pi>.map = \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>.map = \\<pi>", "using \\<pi>.map_def ext \\<Pi>.is_extensional comp_arr_dom comp_cod_arr"], ["proof (prove)\nusing this:\n  \\<pi>.map ?f =\n  (if CC.arr ?f then CC.comp (\\<pi> (CC.cod ?f)) (\\<Delta>o\\<Pi>.map ?f)\n   else CC.null)\n  ?g \\<cdot> ?f \\<noteq> null \\<Longrightarrow> seq ?g ?f\n  \\<not> CC.arr ?f \\<Longrightarrow> local.Prod ?f = null\n  \\<lbrakk>arr ?f; local.dom ?f = ?a\\<rbrakk>\n  \\<Longrightarrow> ?f \\<cdot> ?a = ?f\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n\ngoal (1 subgoal):\n 1. \\<pi>.map = \\<pi>", "by auto"], ["proof (state)\nthis:\n  \\<pi>.map = \\<pi>\n\ngoal (1 subgoal):\n 1. natural_transformation CC.comp CC.comp \\<Delta>o\\<Pi>.map CC.map \\<pi>", "thus \"natural_transformation CC.comp CC.comp \\<Delta>o\\<Pi>.map CC.map \\<pi>\""], ["proof (prove)\nusing this:\n  \\<pi>.map = \\<pi>\n\ngoal (1 subgoal):\n 1. natural_transformation CC.comp CC.comp \\<Delta>o\\<Pi>.map CC.map \\<pi>", "using \\<pi>.natural_transformation_axioms"], ["proof (prove)\nusing this:\n  \\<pi>.map = \\<pi>\n  natural_transformation CC.comp CC.comp \\<Delta>o\\<Pi>.map CC.map \\<pi>.map\n\ngoal (1 subgoal):\n 1. natural_transformation CC.comp CC.comp \\<Delta>o\\<Pi>.map CC.map \\<pi>", "by simp"], ["proof (state)\nthis:\n  natural_transformation CC.comp CC.comp \\<Delta>o\\<Pi>.map CC.map \\<pi>\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation \\<delta>: natural_transformation C C map \\<Pi>o\\<Delta>.map dup"], ["proof (prove)\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>) (\\<cdot>) local.map \\<Pi>o\\<Delta>.map\n     dup", "using dup_naturality comp_arr_dom comp_cod_arr prod_tuple tuple_ext"], ["proof (prove)\nusing this:\n  \\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright> \\<Longrightarrow>\n  \\<d>[?b] \\<cdot> ?f = (?f \\<otimes> ?f) \\<cdot> \\<d>[?a]\n  \\<lbrakk>arr ?f; local.dom ?f = ?a\\<rbrakk>\n  \\<Longrightarrow> ?f \\<cdot> ?a = ?f\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n  \\<lbrakk>span ?f ?g; seq ?h ?f; seq ?k ?g\\<rbrakk>\n  \\<Longrightarrow> (?h \\<otimes> ?k) \\<cdot> \\<langle>?f, ?g\\<rangle> =\n                    \\<langle>?h \\<cdot> ?f, ?k \\<cdot> ?g\\<rangle>\n  \\<not> span ?f ?g \\<Longrightarrow> \\<langle>?f, ?g\\<rangle> = null\n\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>) (\\<cdot>) local.map \\<Pi>o\\<Delta>.map\n     dup", "by unfold_locales auto"], ["", "lemma dup_is_natural_transformation:\n    shows \"natural_transformation C C map \\<Pi>o\\<Delta>.map dup\""], ["proof (prove)\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>) (\\<cdot>) local.map \\<Pi>o\\<Delta>.map\n     dup", ".."], ["", "interpretation \\<Delta>o\\<Pi>o\\<Delta>: composite_functor C CC.comp CC.comp Diag \\<Delta>o\\<Pi>.map"], ["proof (prove)\ngoal (1 subgoal):\n 1. composite_functor (\\<cdot>) CC.comp CC.comp Diag \\<Delta>o\\<Pi>.map", ".."], ["", "interpretation \\<Pi>o\\<Delta>o\\<Pi>: composite_functor CC.comp C C Prod \\<Pi>o\\<Delta>.map"], ["proof (prove)\ngoal (1 subgoal):\n 1. composite_functor CC.comp (\\<cdot>) (\\<cdot>) local.Prod\n     \\<Pi>o\\<Delta>.map", ".."], ["", "interpretation \\<Delta>o\\<delta>: natural_transformation C CC.comp Diag \\<Delta>o\\<Pi>o\\<Delta>.map \\<open>Diag \\<circ> dup\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>) CC.comp Diag\n     \\<Delta>o\\<Pi>o\\<Delta>.map (Diag \\<circ> dup)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>) CC.comp Diag\n     \\<Delta>o\\<Pi>o\\<Delta>.map (Diag \\<circ> dup)", "have \"Diag \\<circ> map = Diag\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Diag \\<circ> local.map = Diag", "by auto"], ["proof (state)\nthis:\n  Diag \\<circ> local.map = Diag\n\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>) CC.comp Diag\n     \\<Delta>o\\<Pi>o\\<Delta>.map (Diag \\<circ> dup)", "thus \"natural_transformation C CC.comp Diag \\<Delta>o\\<Pi>o\\<Delta>.map (Diag \\<circ> dup)\""], ["proof (prove)\nusing this:\n  Diag \\<circ> local.map = Diag\n\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>) CC.comp Diag\n     \\<Delta>o\\<Pi>o\\<Delta>.map (Diag \\<circ> dup)", "using \\<Delta>.natural_transformation_axioms \\<delta>.natural_transformation_axioms o_assoc\n              horizontal_composite [of C C map \\<Pi>o\\<Delta>.map dup CC.comp Diag Diag Diag]"], ["proof (prove)\nusing this:\n  Diag \\<circ> local.map = Diag\n  natural_transformation (\\<cdot>) CC.comp Diag Diag Diag\n  natural_transformation (\\<cdot>) (\\<cdot>) local.map \\<Pi>o\\<Delta>.map\n   dup\n  ?f \\<circ> (?g \\<circ> ?h) = ?f \\<circ> ?g \\<circ> ?h\n  \\<lbrakk>natural_transformation (\\<cdot>) (\\<cdot>) local.map\n            \\<Pi>o\\<Delta>.map dup;\n   natural_transformation (\\<cdot>) CC.comp Diag Diag Diag\\<rbrakk>\n  \\<Longrightarrow> natural_transformation (\\<cdot>) CC.comp\n                     (Diag \\<circ> local.map)\n                     (Diag \\<circ> \\<Pi>o\\<Delta>.map) (Diag \\<circ> dup)\n\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>) CC.comp Diag\n     \\<Delta>o\\<Pi>o\\<Delta>.map (Diag \\<circ> dup)", "by metis"], ["proof (state)\nthis:\n  natural_transformation (\\<cdot>) CC.comp Diag \\<Delta>o\\<Pi>o\\<Delta>.map\n   (Diag \\<circ> dup)\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation \\<delta>o\\<Pi>: natural_transformation CC.comp C Prod \\<Pi>o\\<Delta>o\\<Pi>.map \\<open>dup \\<circ> Prod\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. natural_transformation CC.comp (\\<cdot>) local.Prod\n     \\<Pi>o\\<Delta>o\\<Pi>.map (dup \\<circ> local.Prod)", "using \\<delta>.natural_transformation_axioms \\<Pi>.natural_transformation_axioms o_assoc\n            horizontal_composite [of CC.comp C Prod Prod Prod C map \\<Pi>o\\<Delta>.map dup]"], ["proof (prove)\nusing this:\n  natural_transformation (\\<cdot>) (\\<cdot>) local.map \\<Pi>o\\<Delta>.map\n   dup\n  natural_transformation CC.comp (\\<cdot>) local.Prod local.Prod local.Prod\n  ?f \\<circ> (?g \\<circ> ?h) = ?f \\<circ> ?g \\<circ> ?h\n  \\<lbrakk>natural_transformation CC.comp (\\<cdot>) local.Prod local.Prod\n            local.Prod;\n   natural_transformation (\\<cdot>) (\\<cdot>) local.map \\<Pi>o\\<Delta>.map\n    dup\\<rbrakk>\n  \\<Longrightarrow> natural_transformation CC.comp (\\<cdot>)\n                     (local.map \\<circ> local.Prod) \\<Pi>o\\<Delta>o\\<Pi>.map\n                     (dup \\<circ> local.Prod)\n\ngoal (1 subgoal):\n 1. natural_transformation CC.comp (\\<cdot>) local.Prod\n     \\<Pi>o\\<Delta>o\\<Pi>.map (dup \\<circ> local.Prod)", "by simp"], ["", "interpretation \\<pi>o\\<Delta>: natural_transformation C CC.comp \\<Delta>o\\<Pi>o\\<Delta>.map Diag \\<open>\\<pi>.map \\<circ> Diag\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>) CC.comp \\<Delta>o\\<Pi>o\\<Delta>.map\n     Diag (\\<pi>.map \\<circ> Diag)", "using \\<pi>.natural_transformation_axioms \\<Delta>.natural_transformation_axioms\n            horizontal_composite\n              [of C CC.comp Diag Diag Diag CC.comp \\<Delta>o\\<Pi>.map CC.map \\<pi>.map]"], ["proof (prove)\nusing this:\n  natural_transformation CC.comp CC.comp \\<Delta>o\\<Pi>.map CC.map \\<pi>.map\n  natural_transformation (\\<cdot>) CC.comp Diag Diag Diag\n  \\<lbrakk>natural_transformation (\\<cdot>) CC.comp Diag Diag Diag;\n   natural_transformation CC.comp CC.comp \\<Delta>o\\<Pi>.map CC.map\n    \\<pi>.map\\<rbrakk>\n  \\<Longrightarrow> natural_transformation (\\<cdot>) CC.comp\n                     \\<Delta>o\\<Pi>o\\<Delta>.map (CC.map \\<circ> Diag)\n                     (\\<pi>.map \\<circ> Diag)\n\ngoal (1 subgoal):\n 1. natural_transformation (\\<cdot>) CC.comp \\<Delta>o\\<Pi>o\\<Delta>.map\n     Diag (\\<pi>.map \\<circ> Diag)", "by simp"], ["", "interpretation \\<Pi>o\\<pi>: natural_transformation CC.comp C \\<Pi>o\\<Delta>o\\<Pi>.map Prod \\<open>Prod \\<circ> \\<pi>.map\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. natural_transformation CC.comp (\\<cdot>) \\<Pi>o\\<Delta>o\\<Pi>.map\n     local.Prod (local.Prod \\<circ> \\<pi>.map)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. natural_transformation CC.comp (\\<cdot>) \\<Pi>o\\<Delta>o\\<Pi>.map\n     local.Prod (local.Prod \\<circ> \\<pi>.map)", "have \"Prod \\<circ> \\<Delta>o\\<Pi>.map = \\<Pi>o\\<Delta>o\\<Pi>.map\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.Prod \\<circ> \\<Delta>o\\<Pi>.map = \\<Pi>o\\<Delta>o\\<Pi>.map", "by auto"], ["proof (state)\nthis:\n  local.Prod \\<circ> \\<Delta>o\\<Pi>.map = \\<Pi>o\\<Delta>o\\<Pi>.map\n\ngoal (1 subgoal):\n 1. natural_transformation CC.comp (\\<cdot>) \\<Pi>o\\<Delta>o\\<Pi>.map\n     local.Prod (local.Prod \\<circ> \\<pi>.map)", "thus \"natural_transformation CC.comp C \\<Pi>o\\<Delta>o\\<Pi>.map Prod (Prod \\<circ> \\<pi>.map)\""], ["proof (prove)\nusing this:\n  local.Prod \\<circ> \\<Delta>o\\<Pi>.map = \\<Pi>o\\<Delta>o\\<Pi>.map\n\ngoal (1 subgoal):\n 1. natural_transformation CC.comp (\\<cdot>) \\<Pi>o\\<Delta>o\\<Pi>.map\n     local.Prod (local.Prod \\<circ> \\<pi>.map)", "using \\<pi>.natural_transformation_axioms \\<Pi>.natural_transformation_axioms o_assoc\n              horizontal_composite\n                [of CC.comp CC.comp \\<Delta>o\\<Pi>.map CC.map \\<pi>.map C Prod Prod Prod]"], ["proof (prove)\nusing this:\n  local.Prod \\<circ> \\<Delta>o\\<Pi>.map = \\<Pi>o\\<Delta>o\\<Pi>.map\n  natural_transformation CC.comp CC.comp \\<Delta>o\\<Pi>.map CC.map \\<pi>.map\n  natural_transformation CC.comp (\\<cdot>) local.Prod local.Prod local.Prod\n  ?f \\<circ> (?g \\<circ> ?h) = ?f \\<circ> ?g \\<circ> ?h\n  \\<lbrakk>natural_transformation CC.comp CC.comp \\<Delta>o\\<Pi>.map CC.map\n            \\<pi>.map;\n   natural_transformation CC.comp (\\<cdot>) local.Prod local.Prod\n    local.Prod\\<rbrakk>\n  \\<Longrightarrow> natural_transformation CC.comp (\\<cdot>)\n                     (local.Prod \\<circ> \\<Delta>o\\<Pi>.map)\n                     (local.Prod \\<circ> CC.map)\n                     (local.Prod \\<circ> \\<pi>.map)\n\ngoal (1 subgoal):\n 1. natural_transformation CC.comp (\\<cdot>) \\<Pi>o\\<Delta>o\\<Pi>.map\n     local.Prod (local.Prod \\<circ> \\<pi>.map)", "by simp"], ["proof (state)\nthis:\n  natural_transformation CC.comp (\\<cdot>) \\<Pi>o\\<Delta>o\\<Pi>.map\n   local.Prod (local.Prod \\<circ> \\<pi>.map)\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation \\<Delta>o\\<delta>_\\<pi>o\\<Delta>: vertical_composite C CC.comp Diag \\<Delta>o\\<Pi>o\\<Delta>.map Diag\n                               \\<open>Diag \\<circ> dup\\<close> \\<open>\\<pi>.map \\<circ> Diag\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. vertical_composite (\\<cdot>) CC.comp Diag \\<Delta>o\\<Pi>o\\<Delta>.map\n     Diag (Diag \\<circ> dup) (\\<pi>.map \\<circ> Diag)", ".."], ["", "interpretation \\<Pi>o\\<pi>_\\<delta>o\\<Pi>: vertical_composite CC.comp C Prod \\<Pi>o\\<Delta>o\\<Pi>.map Prod\n                               \\<open>dup \\<circ> Prod\\<close> \\<open>Prod \\<circ> \\<pi>.map\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. vertical_composite CC.comp (\\<cdot>) local.Prod \\<Pi>o\\<Delta>o\\<Pi>.map\n     local.Prod (dup \\<circ> local.Prod) (local.Prod \\<circ> \\<pi>.map)", ".."], ["", "interpretation \\<Delta>\\<Pi>: unit_counit_adjunction CC.comp C Diag Prod dup \\<pi>.map"], ["proof (prove)\ngoal (1 subgoal):\n 1. unit_counit_adjunction CC.comp (\\<cdot>) Diag local.Prod dup \\<pi>.map", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<Delta>o\\<delta>_\\<pi>o\\<Delta>.map = Diag\n 2. \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map = local.Prod", "show \"\\<Delta>o\\<delta>_\\<pi>o\\<Delta>.map = Diag\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Delta>o\\<delta>_\\<pi>o\\<Delta>.map = Diag", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f. \\<Delta>o\\<delta>_\\<pi>o\\<Delta>.map f = Diag f", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f. \\<Delta>o\\<delta>_\\<pi>o\\<Delta>.map f = Diag f", "have \"\\<not> arr f \\<Longrightarrow> \\<Delta>o\\<delta>_\\<pi>o\\<Delta>.map f = Diag f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> arr f \\<Longrightarrow>\n    \\<Delta>o\\<delta>_\\<pi>o\\<Delta>.map f = Diag f", "by (simp add: \\<Delta>o\\<delta>_\\<pi>o\\<Delta>.is_extensional)"], ["proof (state)\nthis:\n  \\<not> arr f \\<Longrightarrow>\n  \\<Delta>o\\<delta>_\\<pi>o\\<Delta>.map f = Diag f\n\ngoal (1 subgoal):\n 1. \\<And>f. \\<Delta>o\\<delta>_\\<pi>o\\<Delta>.map f = Diag f", "moreover"], ["proof (state)\nthis:\n  \\<not> arr f \\<Longrightarrow>\n  \\<Delta>o\\<delta>_\\<pi>o\\<Delta>.map f = Diag f\n\ngoal (1 subgoal):\n 1. \\<And>f. \\<Delta>o\\<delta>_\\<pi>o\\<Delta>.map f = Diag f", "have \"arr f \\<Longrightarrow> \\<Delta>o\\<delta>_\\<pi>o\\<Delta>.map f = Diag f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr f \\<Longrightarrow> \\<Delta>o\\<delta>_\\<pi>o\\<Delta>.map f = Diag f", "using comp_cod_arr comp_assoc \\<Delta>o\\<delta>_\\<pi>o\\<Delta>.map_def"], ["proof (prove)\nusing this:\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n  \\<Delta>o\\<delta>_\\<pi>o\\<Delta>.map ?f =\n  (if arr ?f\n   then CC.comp ((\\<pi>.map \\<circ> Diag) (cod ?f)) ((Diag \\<circ> dup) ?f)\n   else CC.null)\n\ngoal (1 subgoal):\n 1. arr f \\<Longrightarrow> \\<Delta>o\\<delta>_\\<pi>o\\<Delta>.map f = Diag f", "by auto"], ["proof (state)\nthis:\n  arr f \\<Longrightarrow> \\<Delta>o\\<delta>_\\<pi>o\\<Delta>.map f = Diag f\n\ngoal (1 subgoal):\n 1. \\<And>f. \\<Delta>o\\<delta>_\\<pi>o\\<Delta>.map f = Diag f", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> arr f \\<Longrightarrow>\n  \\<Delta>o\\<delta>_\\<pi>o\\<Delta>.map f = Diag f\n  arr f \\<Longrightarrow> \\<Delta>o\\<delta>_\\<pi>o\\<Delta>.map f = Diag f", "show \"\\<Delta>o\\<delta>_\\<pi>o\\<Delta>.map f = Diag f\""], ["proof (prove)\nusing this:\n  \\<not> arr f \\<Longrightarrow>\n  \\<Delta>o\\<delta>_\\<pi>o\\<Delta>.map f = Diag f\n  arr f \\<Longrightarrow> \\<Delta>o\\<delta>_\\<pi>o\\<Delta>.map f = Diag f\n\ngoal (1 subgoal):\n 1. \\<Delta>o\\<delta>_\\<pi>o\\<Delta>.map f = Diag f", "by blast"], ["proof (state)\nthis:\n  \\<Delta>o\\<delta>_\\<pi>o\\<Delta>.map f = Diag f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Delta>o\\<delta>_\\<pi>o\\<Delta>.map = Diag\n\ngoal (1 subgoal):\n 1. \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map = local.Prod", "show \"\\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map = Prod\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map = local.Prod", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fg. \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map fg = local.Prod fg", "fix fg"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>fg. \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map fg = local.Prod fg", "show \"\\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map fg = Prod fg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map fg = local.Prod fg", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map fg = local.Prod fg", "have \"\\<not> CC.arr fg \\<Longrightarrow> ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> CC.arr fg \\<Longrightarrow>\n    \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map fg = local.Prod fg", "by (simp add: \\<Pi>.is_extensional \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.is_extensional)"], ["proof (state)\nthis:\n  \\<not> CC.arr fg \\<Longrightarrow>\n  \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map fg = local.Prod fg\n\ngoal (1 subgoal):\n 1. \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map fg = local.Prod fg", "moreover"], ["proof (state)\nthis:\n  \\<not> CC.arr fg \\<Longrightarrow>\n  \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map fg = local.Prod fg\n\ngoal (1 subgoal):\n 1. \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map fg = local.Prod fg", "have \"CC.arr fg \\<Longrightarrow> ?thesis\""], ["proof (prove)\ngoal (1 subgoal):\n 1. CC.arr fg \\<Longrightarrow>\n    \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map fg = local.Prod fg", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. CC.arr fg \\<Longrightarrow>\n    \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map fg = local.Prod fg", "assume fg: \"CC.arr fg\""], ["proof (state)\nthis:\n  CC.arr fg\n\ngoal (1 subgoal):\n 1. CC.arr fg \\<Longrightarrow>\n    \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map fg = local.Prod fg", "have 1: \"dup (Prod fg) = \\<langle>cod (fst fg) \\<otimes> cod (snd fg), cod (fst fg) \\<otimes> cod (snd fg)\\<rangle> \\<cdot>\n                                        (fst fg \\<otimes> snd fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<d>[local.Prod fg] =\n    \\<d>[cod (fst fg) \\<otimes> cod (snd fg)] \\<cdot> local.Prod fg", "using fg \\<delta>.is_natural_2"], ["proof (prove)\nusing this:\n  CC.arr fg\n  arr ?f \\<Longrightarrow> \\<d>[cod ?f] \\<cdot> local.map ?f = \\<d>[?f]\n\ngoal (1 subgoal):\n 1. \\<d>[local.Prod fg] =\n    \\<d>[cod (fst fg) \\<otimes> cod (snd fg)] \\<cdot> local.Prod fg", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>arr (fst fg) \\<and> arr (snd fg);\n     \\<And>f.\n        arr f \\<Longrightarrow> \\<d>[cod f \\<cdot> f] = \\<d>[f]\\<rbrakk>\n    \\<Longrightarrow> \\<d>[local.Prod fg] =\n                      \\<d>[(cod (fst fg) \\<otimes> cod (snd fg)) \\<cdot>\n                           local.Prod fg]", "by (metis (no_types, lifting) prod_simps(1) prod_simps(3))"], ["proof (state)\nthis:\n  \\<d>[local.Prod fg] =\n  \\<d>[cod (fst fg) \\<otimes> cod (snd fg)] \\<cdot> local.Prod fg\n\ngoal (1 subgoal):\n 1. CC.arr fg \\<Longrightarrow>\n    \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map fg = local.Prod fg", "have \"\\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map fg =\n                  (\\<pp>\\<^sub>1[cod (fst fg), cod (snd fg)] \\<otimes> \\<pp>\\<^sub>0[cod (fst fg), cod (snd fg)]) \\<cdot>\n                    \\<langle>cod (fst fg) \\<otimes> cod (snd fg), cod (fst fg) \\<otimes> cod (snd fg)\\<rangle> \\<cdot>\n                    (fst fg \\<otimes> snd fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map fg =\n    (\\<pp>\\<^sub>1[cod (fst fg), cod (snd fg)] \\<otimes>\n     \\<pp>\\<^sub>0[cod (fst fg), cod (snd fg)]) \\<cdot>\n    \\<d>[cod (fst fg) \\<otimes> cod (snd fg)] \\<cdot> local.Prod fg", "using fg 1 \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map_def comp_cod_arr"], ["proof (prove)\nusing this:\n  CC.arr fg\n  \\<d>[local.Prod fg] =\n  \\<d>[cod (fst fg) \\<otimes> cod (snd fg)] \\<cdot> local.Prod fg\n  \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map ?f =\n  (if CC.arr ?f\n   then (local.Prod \\<circ> \\<pi>.map) (CC.cod ?f) \\<cdot>\n        (dup \\<circ> local.Prod) ?f\n   else null)\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n\ngoal (1 subgoal):\n 1. \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map fg =\n    (\\<pp>\\<^sub>1[cod (fst fg), cod (snd fg)] \\<otimes>\n     \\<pp>\\<^sub>0[cod (fst fg), cod (snd fg)]) \\<cdot>\n    \\<d>[cod (fst fg) \\<otimes> cod (snd fg)] \\<cdot> local.Prod fg", "by simp"], ["proof (state)\nthis:\n  \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map fg =\n  (\\<pp>\\<^sub>1[cod (fst fg), cod (snd fg)] \\<otimes>\n   \\<pp>\\<^sub>0[cod (fst fg), cod (snd fg)]) \\<cdot>\n  \\<d>[cod (fst fg) \\<otimes> cod (snd fg)] \\<cdot> local.Prod fg\n\ngoal (1 subgoal):\n 1. CC.arr fg \\<Longrightarrow>\n    \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map fg = local.Prod fg", "also"], ["proof (state)\nthis:\n  \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map fg =\n  (\\<pp>\\<^sub>1[cod (fst fg), cod (snd fg)] \\<otimes>\n   \\<pp>\\<^sub>0[cod (fst fg), cod (snd fg)]) \\<cdot>\n  \\<d>[cod (fst fg) \\<otimes> cod (snd fg)] \\<cdot> local.Prod fg\n\ngoal (1 subgoal):\n 1. CC.arr fg \\<Longrightarrow>\n    \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map fg = local.Prod fg", "have \"... = ((\\<pp>\\<^sub>1[cod (fst fg), cod (snd fg)] \\<otimes> \\<pp>\\<^sub>0[cod (fst fg), cod (snd fg)]) \\<cdot>\n                              \\<langle>cod (fst fg) \\<otimes> cod (snd fg), cod (fst fg) \\<otimes> cod (snd fg)\\<rangle>) \\<cdot>\n                             (fst fg \\<otimes> snd fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<pp>\\<^sub>1[cod (fst fg), cod (snd fg)] \\<otimes>\n     \\<pp>\\<^sub>0[cod (fst fg), cod (snd fg)]) \\<cdot>\n    \\<d>[cod (fst fg) \\<otimes> cod (snd fg)] \\<cdot> local.Prod fg =\n    ((\\<pp>\\<^sub>1[cod (fst fg), cod (snd fg)] \\<otimes>\n      \\<pp>\\<^sub>0[cod (fst fg), cod (snd fg)]) \\<cdot>\n     \\<d>[cod (fst fg) \\<otimes> cod (snd fg)]) \\<cdot>\n    local.Prod fg", "using comp_assoc"], ["proof (prove)\nusing this:\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. (\\<pp>\\<^sub>1[cod (fst fg), cod (snd fg)] \\<otimes>\n     \\<pp>\\<^sub>0[cod (fst fg), cod (snd fg)]) \\<cdot>\n    \\<d>[cod (fst fg) \\<otimes> cod (snd fg)] \\<cdot> local.Prod fg =\n    ((\\<pp>\\<^sub>1[cod (fst fg), cod (snd fg)] \\<otimes>\n      \\<pp>\\<^sub>0[cod (fst fg), cod (snd fg)]) \\<cdot>\n     \\<d>[cod (fst fg) \\<otimes> cod (snd fg)]) \\<cdot>\n    local.Prod fg", "by simp"], ["proof (state)\nthis:\n  (\\<pp>\\<^sub>1[cod (fst fg), cod (snd fg)] \\<otimes>\n   \\<pp>\\<^sub>0[cod (fst fg), cod (snd fg)]) \\<cdot>\n  \\<d>[cod (fst fg) \\<otimes> cod (snd fg)] \\<cdot> local.Prod fg =\n  ((\\<pp>\\<^sub>1[cod (fst fg), cod (snd fg)] \\<otimes>\n    \\<pp>\\<^sub>0[cod (fst fg), cod (snd fg)]) \\<cdot>\n   \\<d>[cod (fst fg) \\<otimes> cod (snd fg)]) \\<cdot>\n  local.Prod fg\n\ngoal (1 subgoal):\n 1. CC.arr fg \\<Longrightarrow>\n    \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map fg = local.Prod fg", "also"], ["proof (state)\nthis:\n  (\\<pp>\\<^sub>1[cod (fst fg), cod (snd fg)] \\<otimes>\n   \\<pp>\\<^sub>0[cod (fst fg), cod (snd fg)]) \\<cdot>\n  \\<d>[cod (fst fg) \\<otimes> cod (snd fg)] \\<cdot> local.Prod fg =\n  ((\\<pp>\\<^sub>1[cod (fst fg), cod (snd fg)] \\<otimes>\n    \\<pp>\\<^sub>0[cod (fst fg), cod (snd fg)]) \\<cdot>\n   \\<d>[cod (fst fg) \\<otimes> cod (snd fg)]) \\<cdot>\n  local.Prod fg\n\ngoal (1 subgoal):\n 1. CC.arr fg \\<Longrightarrow>\n    \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map fg = local.Prod fg", "have \"... = \\<langle>\\<pp>\\<^sub>1[cod (fst fg), cod (snd fg)] \\<cdot> (cod (fst fg) \\<otimes> cod (snd fg)),\n                              \\<pp>\\<^sub>0[cod (fst fg), cod (snd fg)] \\<cdot> (cod (fst fg) \\<otimes> cod (snd fg))\\<rangle> \\<cdot>\n                             (fst fg \\<otimes> snd fg)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<pp>\\<^sub>1[cod (fst fg), cod (snd fg)] \\<otimes>\n      \\<pp>\\<^sub>0[cod (fst fg), cod (snd fg)]) \\<cdot>\n     \\<d>[cod (fst fg) \\<otimes> cod (snd fg)]) \\<cdot>\n    local.Prod fg =\n    \\<langle>\\<pp>\\<^sub>1[cod (fst fg), cod (snd fg)] \\<cdot>\n             (cod (fst fg) \\<otimes>\n              cod (snd fg)), \\<pp>\\<^sub>0[cod\n      (fst fg), cod (snd fg)] \\<cdot>\n                             (cod (fst fg) \\<otimes>\n                              cod (snd fg))\\<rangle> \\<cdot>\n    local.Prod fg", "using fg prod_tuple"], ["proof (prove)\nusing this:\n  CC.arr fg\n  \\<lbrakk>span ?f ?g; seq ?h ?f; seq ?k ?g\\<rbrakk>\n  \\<Longrightarrow> (?h \\<otimes> ?k) \\<cdot> \\<langle>?f, ?g\\<rangle> =\n                    \\<langle>?h \\<cdot> ?f, ?k \\<cdot> ?g\\<rangle>\n\ngoal (1 subgoal):\n 1. ((\\<pp>\\<^sub>1[cod (fst fg), cod (snd fg)] \\<otimes>\n      \\<pp>\\<^sub>0[cod (fst fg), cod (snd fg)]) \\<cdot>\n     \\<d>[cod (fst fg) \\<otimes> cod (snd fg)]) \\<cdot>\n    local.Prod fg =\n    \\<langle>\\<pp>\\<^sub>1[cod (fst fg), cod (snd fg)] \\<cdot>\n             (cod (fst fg) \\<otimes>\n              cod (snd fg)), \\<pp>\\<^sub>0[cod\n      (fst fg), cod (snd fg)] \\<cdot>\n                             (cod (fst fg) \\<otimes>\n                              cod (snd fg))\\<rangle> \\<cdot>\n    local.Prod fg", "by simp"], ["proof (state)\nthis:\n  ((\\<pp>\\<^sub>1[cod (fst fg), cod (snd fg)] \\<otimes>\n    \\<pp>\\<^sub>0[cod (fst fg), cod (snd fg)]) \\<cdot>\n   \\<d>[cod (fst fg) \\<otimes> cod (snd fg)]) \\<cdot>\n  local.Prod fg =\n  \\<langle>\\<pp>\\<^sub>1[cod (fst fg), cod (snd fg)] \\<cdot>\n           (cod (fst fg) \\<otimes>\n            cod (snd fg)), \\<pp>\\<^sub>0[cod (fst fg), cod (snd fg)] \\<cdot>\n                           (cod (fst fg) \\<otimes>\n                            cod (snd fg))\\<rangle> \\<cdot>\n  local.Prod fg\n\ngoal (1 subgoal):\n 1. CC.arr fg \\<Longrightarrow>\n    \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map fg = local.Prod fg", "also"], ["proof (state)\nthis:\n  ((\\<pp>\\<^sub>1[cod (fst fg), cod (snd fg)] \\<otimes>\n    \\<pp>\\<^sub>0[cod (fst fg), cod (snd fg)]) \\<cdot>\n   \\<d>[cod (fst fg) \\<otimes> cod (snd fg)]) \\<cdot>\n  local.Prod fg =\n  \\<langle>\\<pp>\\<^sub>1[cod (fst fg), cod (snd fg)] \\<cdot>\n           (cod (fst fg) \\<otimes>\n            cod (snd fg)), \\<pp>\\<^sub>0[cod (fst fg), cod (snd fg)] \\<cdot>\n                           (cod (fst fg) \\<otimes>\n                            cod (snd fg))\\<rangle> \\<cdot>\n  local.Prod fg\n\ngoal (1 subgoal):\n 1. CC.arr fg \\<Longrightarrow>\n    \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map fg = local.Prod fg", "have \"... = Prod fg\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>\\<pp>\\<^sub>1[cod (fst fg), cod (snd fg)] \\<cdot>\n             (cod (fst fg) \\<otimes>\n              cod (snd fg)), \\<pp>\\<^sub>0[cod\n      (fst fg), cod (snd fg)] \\<cdot>\n                             (cod (fst fg) \\<otimes>\n                              cod (snd fg))\\<rangle> \\<cdot>\n    local.Prod fg =\n    local.Prod fg", "using fg comp_arr_dom \\<Pi>.is_natural_2"], ["proof (prove)\nusing this:\n  CC.arr fg\n  \\<lbrakk>arr ?f; local.dom ?f = ?a\\<rbrakk>\n  \\<Longrightarrow> ?f \\<cdot> ?a = ?f\n  CC.arr ?f \\<Longrightarrow>\n  local.Prod (CC.cod ?f) \\<cdot> local.Prod ?f = local.Prod ?f\n\ngoal (1 subgoal):\n 1. \\<langle>\\<pp>\\<^sub>1[cod (fst fg), cod (snd fg)] \\<cdot>\n             (cod (fst fg) \\<otimes>\n              cod (snd fg)), \\<pp>\\<^sub>0[cod\n      (fst fg), cod (snd fg)] \\<cdot>\n                             (cod (fst fg) \\<otimes>\n                              cod (snd fg))\\<rangle> \\<cdot>\n    local.Prod fg =\n    local.Prod fg", "by auto"], ["proof (state)\nthis:\n  \\<langle>\\<pp>\\<^sub>1[cod (fst fg), cod (snd fg)] \\<cdot>\n           (cod (fst fg) \\<otimes>\n            cod (snd fg)), \\<pp>\\<^sub>0[cod (fst fg), cod (snd fg)] \\<cdot>\n                           (cod (fst fg) \\<otimes>\n                            cod (snd fg))\\<rangle> \\<cdot>\n  local.Prod fg =\n  local.Prod fg\n\ngoal (1 subgoal):\n 1. CC.arr fg \\<Longrightarrow>\n    \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map fg = local.Prod fg", "finally"], ["proof (chain)\npicking this:\n  \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map fg = local.Prod fg", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map fg = local.Prod fg\n\ngoal (1 subgoal):\n 1. \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map fg = local.Prod fg", "by simp"], ["proof (state)\nthis:\n  \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map fg = local.Prod fg\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  CC.arr fg \\<Longrightarrow>\n  \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map fg = local.Prod fg\n\ngoal (1 subgoal):\n 1. \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map fg = local.Prod fg", "ultimately"], ["proof (chain)\npicking this:\n  \\<not> CC.arr fg \\<Longrightarrow>\n  \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map fg = local.Prod fg\n  CC.arr fg \\<Longrightarrow>\n  \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map fg = local.Prod fg", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> CC.arr fg \\<Longrightarrow>\n  \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map fg = local.Prod fg\n  CC.arr fg \\<Longrightarrow>\n  \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map fg = local.Prod fg\n\ngoal (1 subgoal):\n 1. \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map fg = local.Prod fg", "by blast"], ["proof (state)\nthis:\n  \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map fg = local.Prod fg\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map fg = local.Prod fg\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Pi>o\\<pi>_\\<delta>o\\<Pi>.map = local.Prod\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition induces_unit_counit_adjunction:\n    shows \"unit_counit_adjunction CC.comp C Diag Prod dup \\<pi>.map\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unit_counit_adjunction CC.comp (\\<cdot>) Diag local.Prod dup \\<pi>.map", "using \\<Delta>\\<Pi>.unit_counit_adjunction_axioms"], ["proof (prove)\nusing this:\n  unit_counit_adjunction CC.comp (\\<cdot>) Diag local.Prod dup \\<pi>.map\n\ngoal (1 subgoal):\n 1. unit_counit_adjunction CC.comp (\\<cdot>) Diag local.Prod dup \\<pi>.map", "by simp"], ["", "end"], ["", "section \"Category with Terminal Object\""], ["", "locale category_with_terminal_object =\n    category +\n  assumes has_terminal: \"\\<exists>t. terminal t\""], ["", "locale elementary_category_with_terminal_object =\n    category C\n  for C :: \"'a comp\"                              (infixr \"\\<cdot>\" 55)\n  and one :: \"'a\"                                 (\"\\<one>\")\n  and trm :: \"'a \\<Rightarrow> 'a\"                           (\"\\<t>[_]\") +\n  assumes ide_one: \"ide \\<one>\"\n  and trm_in_hom: \"ide a \\<Longrightarrow> \\<guillemotleft>\\<t>[a] : a \\<rightarrow> \\<one>\\<guillemotright>\"\n  and trm_eqI: \"\\<lbrakk> ide a; \\<guillemotleft>f : a \\<rightarrow> \\<one>\\<guillemotright> \\<rbrakk> \\<Longrightarrow> f = \\<t>[a]\"\n  begin"], ["", "lemma trm_simps:\n    assumes \"ide a\"\n    shows \"arr \\<t>[a]\" and \"dom \\<t>[a] = a\" and \"cod \\<t>[a] = \\<one>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr \\<t>[a] &&& local.dom \\<t>[a] = a &&& cod \\<t>[a] = \\<one>", "using assms trm_in_hom"], ["proof (prove)\nusing this:\n  ide a\n  ide ?a \\<Longrightarrow>\n  \\<guillemotleft>\\<t>[?a] : ?a \\<rightarrow> \\<one>\\<guillemotright>\n\ngoal (1 subgoal):\n 1. arr \\<t>[a] &&& local.dom \\<t>[a] = a &&& cod \\<t>[a] = \\<one>", "by auto"], ["", "lemma trm_one:\n    shows \"\\<t>[\\<one>] = \\<one>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<t>[\\<one>] = \\<one>", "using ide_one trm_in_hom trm_eqI ide_in_hom"], ["proof (prove)\nusing this:\n  ide \\<one>\n  ide ?a \\<Longrightarrow>\n  \\<guillemotleft>\\<t>[?a] : ?a \\<rightarrow> \\<one>\\<guillemotright>\n  \\<lbrakk>ide ?a;\n   \\<guillemotleft>?f : ?a \\<rightarrow> \\<one>\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> ?f = \\<t>[?a]\n  ide ?a = \\<guillemotleft>?a : ?a \\<rightarrow> ?a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<t>[\\<one>] = \\<one>", "by auto"], ["", "lemma terminal_one:\n    shows \"terminal \\<one>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminal \\<one>", "using ide_one trm_in_hom trm_eqI terminal_def"], ["proof (prove)\nusing this:\n  ide \\<one>\n  ide ?a \\<Longrightarrow>\n  \\<guillemotleft>\\<t>[?a] : ?a \\<rightarrow> \\<one>\\<guillemotright>\n  \\<lbrakk>ide ?a;\n   \\<guillemotleft>?f : ?a \\<rightarrow> \\<one>\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> ?f = \\<t>[?a]\n  terminal ?b \\<equiv>\n  ide ?b \\<and>\n  (\\<forall>a.\n      ide a \\<longrightarrow>\n      (\\<exists>!f.\n          \\<guillemotleft>f : a \\<rightarrow> ?b\\<guillemotright>))\n\ngoal (1 subgoal):\n 1. terminal \\<one>", "by metis"], ["", "lemma trm_naturality:\n    assumes \"arr f\"\n    shows \"\\<t>[cod f] \\<cdot> f = \\<t>[dom f]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<t>[cod f] \\<cdot> f = \\<t>[local.dom f]", "using assms trm_eqI"], ["proof (prove)\nusing this:\n  arr f\n  \\<lbrakk>ide ?a;\n   \\<guillemotleft>?f : ?a \\<rightarrow> \\<one>\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> ?f = \\<t>[?a]\n\ngoal (1 subgoal):\n 1. \\<t>[cod f] \\<cdot> f = \\<t>[local.dom f]", "by (metis comp_in_homI' ide_cod ide_dom in_homE trm_in_hom)"], ["", "proposition is_category_with_terminal_object:\n    shows \"category_with_terminal_object C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. category_with_terminal_object (\\<cdot>)", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. Ex terminal", "using terminal_one"], ["proof (prove)\nusing this:\n  terminal \\<one>\n\ngoal (1 subgoal):\n 1. Ex terminal", "by auto"], ["", "end"], ["", "context category_with_terminal_object\n  begin"], ["", "definition some_terminal (\"\\<one>\")\n    where \"some_terminal \\<equiv> SOME t. terminal t\""], ["", "definition \"trm\" (\"\\<t>[_]\")\n    where \"\\<t>[f] \\<equiv> if arr f then THE t. \\<guillemotleft>t : dom f \\<rightarrow> \\<one>\\<guillemotright> else null\""], ["", "lemma terminal_some_terminal [intro]:\n    shows \"terminal \\<one>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminal \\<one>", "using some_terminal_def has_terminal someI_ex [of \"\\<lambda>t. terminal t\"]"], ["proof (prove)\nusing this:\n  \\<one> \\<equiv> Eps terminal\n  Ex terminal\n  Ex terminal \\<Longrightarrow> terminal (Eps terminal)\n\ngoal (1 subgoal):\n 1. terminal \\<one>", "by presburger"], ["", "lemma ide_some_terminal:\n    shows \"ide \\<one>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide \\<one>", "using terminal_def"], ["proof (prove)\nusing this:\n  terminal ?b \\<equiv>\n  ide ?b \\<and>\n  (\\<forall>a.\n      ide a \\<longrightarrow>\n      (\\<exists>!f.\n          \\<guillemotleft>f : a \\<rightarrow> ?b\\<guillemotright>))\n\ngoal (1 subgoal):\n 1. ide \\<one>", "by blast"], ["", "lemma trm_in_hom [intro]:\n    assumes \"arr f\"\n    shows \"\\<guillemotleft>\\<t>[f] : dom f \\<rightarrow> \\<one>\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<t>[f] : local.dom\n                               f \\<rightarrow> \\<one>\\<guillemotright>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<t>[f] : local.dom\n                               f \\<rightarrow> \\<one>\\<guillemotright>", "have \"ide (dom f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide (local.dom f)", "using assms"], ["proof (prove)\nusing this:\n  arr f\n\ngoal (1 subgoal):\n 1. ide (local.dom f)", "by fastforce"], ["proof (state)\nthis:\n  ide (local.dom f)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<t>[f] : local.dom\n                               f \\<rightarrow> \\<one>\\<guillemotright>", "hence \"\\<exists>!t. \\<guillemotleft>t : dom f \\<rightarrow> \\<one>\\<guillemotright>\""], ["proof (prove)\nusing this:\n  ide (local.dom f)\n\ngoal (1 subgoal):\n 1. \\<exists>!t.\n       \\<guillemotleft>t : local.dom f \\<rightarrow> \\<one>\\<guillemotright>", "using assms trm_def terminal_def terminal_some_terminal"], ["proof (prove)\nusing this:\n  ide (local.dom f)\n  arr f\n  \\<t>[?f] \\<equiv>\n  if arr ?f\n  then THE t.\n          \\<guillemotleft>t : local.dom\n                               ?f \\<rightarrow> \\<one>\\<guillemotright>\n  else null\n  terminal ?b \\<equiv>\n  ide ?b \\<and>\n  (\\<forall>a.\n      ide a \\<longrightarrow>\n      (\\<exists>!f.\n          \\<guillemotleft>f : a \\<rightarrow> ?b\\<guillemotright>))\n  terminal \\<one>\n\ngoal (1 subgoal):\n 1. \\<exists>!t.\n       \\<guillemotleft>t : local.dom f \\<rightarrow> \\<one>\\<guillemotright>", "by simp"], ["proof (state)\nthis:\n  \\<exists>!t.\n     \\<guillemotleft>t : local.dom f \\<rightarrow> \\<one>\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<t>[f] : local.dom\n                               f \\<rightarrow> \\<one>\\<guillemotright>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>!t.\n     \\<guillemotleft>t : local.dom f \\<rightarrow> \\<one>\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<t>[f] : local.dom\n                               f \\<rightarrow> \\<one>\\<guillemotright>", "using assms trm_def [of f] theI' [of \"\\<lambda>t. \\<guillemotleft>t : dom f \\<rightarrow> \\<one>\\<guillemotright>\"]"], ["proof (prove)\nusing this:\n  \\<exists>!t.\n     \\<guillemotleft>t : local.dom f \\<rightarrow> \\<one>\\<guillemotright>\n  arr f\n  \\<t>[f] \\<equiv>\n  if arr f\n  then THE t.\n          \\<guillemotleft>t : local.dom\n                               f \\<rightarrow> \\<one>\\<guillemotright>\n  else null\n  \\<exists>!x.\n     \\<guillemotleft>x : local.dom\n                          f \\<rightarrow> \\<one>\\<guillemotright> \\<Longrightarrow>\n  \\<guillemotleft>THE x.\n                     \\<guillemotleft>x : local.dom\n    f \\<rightarrow> \\<one>\\<guillemotright> : local.dom\n         f \\<rightarrow> \\<one>\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<t>[f] : local.dom\n                               f \\<rightarrow> \\<one>\\<guillemotright>", "by auto"], ["proof (state)\nthis:\n  \\<guillemotleft>\\<t>[f] : local.dom\n                             f \\<rightarrow> \\<one>\\<guillemotright>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma trm_simps [simp]:\n    assumes \"arr f\"\n    shows \"arr \\<t>[f]\" and \"dom \\<t>[f] = dom f\" and \"cod \\<t>[f] = \\<one>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr \\<t>[f] &&& local.dom \\<t>[f] = local.dom f &&& cod \\<t>[f] = \\<one>", "using assms trm_in_hom"], ["proof (prove)\nusing this:\n  arr f\n  arr ?f \\<Longrightarrow>\n  \\<guillemotleft>\\<t>[?f] : local.dom\n                              ?f \\<rightarrow> \\<one>\\<guillemotright>\n\ngoal (1 subgoal):\n 1. arr \\<t>[f] &&& local.dom \\<t>[f] = local.dom f &&& cod \\<t>[f] = \\<one>", "by auto"], ["", "lemma trm_eqI:\n    assumes \"\\<guillemotleft>t : dom f \\<rightarrow> \\<one>\\<guillemotright>\"\n    shows \"t = \\<t>[f]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t = \\<t>[f]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t = \\<t>[f]", "have \"ide (dom f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide (local.dom f)", "using assms"], ["proof (prove)\nusing this:\n  \\<guillemotleft>t : local.dom f \\<rightarrow> \\<one>\\<guillemotright>\n\ngoal (1 subgoal):\n 1. ide (local.dom f)", "by (metis ide_dom in_homE)"], ["proof (state)\nthis:\n  ide (local.dom f)\n\ngoal (1 subgoal):\n 1. t = \\<t>[f]", "hence \"\\<exists>!t. \\<guillemotleft>t : dom f \\<rightarrow> \\<one>\\<guillemotright>\""], ["proof (prove)\nusing this:\n  ide (local.dom f)\n\ngoal (1 subgoal):\n 1. \\<exists>!t.\n       \\<guillemotleft>t : local.dom f \\<rightarrow> \\<one>\\<guillemotright>", "using terminal_def [of \\<one>] terminal_some_terminal"], ["proof (prove)\nusing this:\n  ide (local.dom f)\n  terminal \\<one> \\<equiv>\n  ide \\<one> \\<and>\n  (\\<forall>a.\n      ide a \\<longrightarrow>\n      (\\<exists>!f.\n          \\<guillemotleft>f : a \\<rightarrow> \\<one>\\<guillemotright>))\n  terminal \\<one>\n\ngoal (1 subgoal):\n 1. \\<exists>!t.\n       \\<guillemotleft>t : local.dom f \\<rightarrow> \\<one>\\<guillemotright>", "by auto"], ["proof (state)\nthis:\n  \\<exists>!t.\n     \\<guillemotleft>t : local.dom f \\<rightarrow> \\<one>\\<guillemotright>\n\ngoal (1 subgoal):\n 1. t = \\<t>[f]", "moreover"], ["proof (state)\nthis:\n  \\<exists>!t.\n     \\<guillemotleft>t : local.dom f \\<rightarrow> \\<one>\\<guillemotright>\n\ngoal (1 subgoal):\n 1. t = \\<t>[f]", "have \"\\<guillemotleft>t : dom f \\<rightarrow> \\<one>\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>t : local.dom f \\<rightarrow> \\<one>\\<guillemotright>", "using assms"], ["proof (prove)\nusing this:\n  \\<guillemotleft>t : local.dom f \\<rightarrow> \\<one>\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>t : local.dom f \\<rightarrow> \\<one>\\<guillemotright>", "by simp"], ["proof (state)\nthis:\n  \\<guillemotleft>t : local.dom f \\<rightarrow> \\<one>\\<guillemotright>\n\ngoal (1 subgoal):\n 1. t = \\<t>[f]", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>!t.\n     \\<guillemotleft>t : local.dom f \\<rightarrow> \\<one>\\<guillemotright>\n  \\<guillemotleft>t : local.dom f \\<rightarrow> \\<one>\\<guillemotright>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>!t.\n     \\<guillemotleft>t : local.dom f \\<rightarrow> \\<one>\\<guillemotright>\n  \\<guillemotleft>t : local.dom f \\<rightarrow> \\<one>\\<guillemotright>\n\ngoal (1 subgoal):\n 1. t = \\<t>[f]", "using assms trm_def the1_equality [of \"\\<lambda>t. \\<guillemotleft>t : dom f \\<rightarrow> \\<one>\\<guillemotright>\" t]\n              \\<open>ide (dom f)\\<close> arr_dom_iff_arr"], ["proof (prove)\nusing this:\n  \\<exists>!t.\n     \\<guillemotleft>t : local.dom f \\<rightarrow> \\<one>\\<guillemotright>\n  \\<guillemotleft>t : local.dom f \\<rightarrow> \\<one>\\<guillemotright>\n  \\<guillemotleft>t : local.dom f \\<rightarrow> \\<one>\\<guillemotright>\n  \\<t>[?f] \\<equiv>\n  if arr ?f\n  then THE t.\n          \\<guillemotleft>t : local.dom\n                               ?f \\<rightarrow> \\<one>\\<guillemotright>\n  else null\n  \\<lbrakk>\\<exists>!x.\n              \\<guillemotleft>x : local.dom\n                                   f \\<rightarrow> \\<one>\\<guillemotright>;\n   \\<guillemotleft>t : local.dom\n                        f \\<rightarrow> \\<one>\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> (THE x.\n                        \\<guillemotleft>x : local.dom\n       f \\<rightarrow> \\<one>\\<guillemotright>) =\n                    t\n  ide (local.dom f)\n  arr (local.dom ?f) = arr ?f\n\ngoal (1 subgoal):\n 1. t = \\<t>[f]", "by fastforce"], ["proof (state)\nthis:\n  t = \\<t>[f]\n\ngoal:\nNo subgoals!", "qed"], ["", "sublocale elementary_category_with_terminal_object C \\<one> trm"], ["proof (prove)\ngoal (1 subgoal):\n 1. elementary_category_with_terminal_object (\\<cdot>) \\<one> trm", "using ide_some_terminal trm_eqI"], ["proof (prove)\nusing this:\n  ide \\<one>\n  \\<guillemotleft>?t : local.dom\n                        ?f \\<rightarrow> \\<one>\\<guillemotright> \\<Longrightarrow>\n  ?t = \\<t>[?f]\n\ngoal (1 subgoal):\n 1. elementary_category_with_terminal_object (\\<cdot>) \\<one> trm", "by unfold_locales auto"], ["", "proposition extends_to_elementary_category_with_terminal_object:\n      shows \"elementary_category_with_terminal_object C \\<one> trm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elementary_category_with_terminal_object (\\<cdot>) \\<one> trm", ".."], ["", "end"], ["", "section \"Cartesian Category\""], ["", "locale cartesian_category =\n    category_with_binary_products +\n    category_with_terminal_object"], ["", "locale elementary_cartesian_category =\n    elementary_category_with_binary_products +\n    elementary_category_with_terminal_object\n  begin"], ["", "proposition is_cartesian_category:\n    shows \"cartesian_category C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cartesian_category (\\<cdot>)", "using cartesian_category.intro is_category_with_binary_products\n            is_category_with_terminal_object"], ["proof (prove)\nusing this:\n  \\<lbrakk>category_with_binary_products ?C;\n   category_with_terminal_object ?C\\<rbrakk>\n  \\<Longrightarrow> cartesian_category ?C\n  category_with_binary_products (\\<cdot>)\n  category_with_terminal_object (\\<cdot>)\n\ngoal (1 subgoal):\n 1. cartesian_category (\\<cdot>)", "by auto"], ["", "end"], ["", "context cartesian_category\n  begin"], ["", "proposition extends_to_elementary_cartesian_category:\n    shows \"elementary_cartesian_category C pr0 pr1 \\<one> trm\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elementary_cartesian_category (\\<cdot>) pr0 pr1 \\<one> trm", "by (simp add: elementary_cartesian_category_def\n          elementary_category_with_terminal_object_axioms\n          extends_to_elementary_category_with_binary_products)"], ["", "sublocale elementary_cartesian_category C pr0 pr1 \\<one> trm"], ["proof (prove)\ngoal (1 subgoal):\n 1. elementary_cartesian_category (\\<cdot>) pr0 pr1 \\<one> trm", "using extends_to_elementary_cartesian_category"], ["proof (prove)\nusing this:\n  elementary_cartesian_category (\\<cdot>) pr0 pr1 \\<one> trm\n\ngoal (1 subgoal):\n 1. elementary_cartesian_category (\\<cdot>) pr0 pr1 \\<one> trm", "by simp"], ["", "end"], ["", "text \\<open>\n    Here we prove some facts that will later allow us to show that an elementary cartesian\n    category is a monoidal category.\n  \\<close>"], ["", "context elementary_cartesian_category\n  begin"], ["", "abbreviation \\<iota>\n    where \"\\<iota> \\<equiv> \\<pp>\\<^sub>0[\\<one>, \\<one>]\""], ["", "lemma pr_coincidence:\n    shows \"\\<iota> = \\<pp>\\<^sub>1[\\<one>, \\<one>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<iota> = \\<pp>\\<^sub>1[\\<one>, \\<one>]", "using ide_one"], ["proof (prove)\nusing this:\n  ide \\<one>\n\ngoal (1 subgoal):\n 1. \\<iota> = \\<pp>\\<^sub>1[\\<one>, \\<one>]", "by (simp add: terminal_arr_unique terminal_one)"], ["", "lemma \\<iota>_is_terminal_arr:\n    shows \"terminal_arr \\<iota>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminal_arr \\<iota>", "using ide_one"], ["proof (prove)\nusing this:\n  ide \\<one>\n\ngoal (1 subgoal):\n 1. terminal_arr \\<iota>", "by (simp add: terminal_one)"], ["", "lemma inverse_arrows_\\<iota>:\n    shows \"inverse_arrows \\<iota> \\<langle>\\<one>, \\<one>\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_arrows \\<iota> \\<d>[\\<one>]", "using ide_one"], ["proof (prove)\nusing this:\n  ide \\<one>\n\ngoal (1 subgoal):\n 1. inverse_arrows \\<iota> \\<d>[\\<one>]", "by (metis (no_types, lifting) dup_is_natural_transformation \\<iota>_is_terminal_arr cod_pr0\n          comp_cod_arr pr_dup(1) ide_dom inverse_arrows_def map_simp\n          natural_transformation.is_natural_2 pr_simps(2) pr1_in_hom' trm_eqI trm_naturality\n          trm_one tuple_pr)"], ["", "lemma \\<iota>_is_iso:\n    shows \"iso \\<iota>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.iso \\<iota>", "using inverse_arrows_\\<iota>"], ["proof (prove)\nusing this:\n  inverse_arrows \\<iota> \\<d>[\\<one>]\n\ngoal (1 subgoal):\n 1. local.iso \\<iota>", "by auto"], ["", "lemma trm_tensor:\n    assumes \"ide a\" and \"ide b\"\n    shows \"\\<t>[a \\<otimes> b] = \\<iota> \\<cdot> (\\<t>[a] \\<otimes> \\<t>[b])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<t>[a \\<otimes> b] = \\<iota> \\<cdot> (\\<t>[a] \\<otimes> \\<t>[b])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<t>[a \\<otimes> b] = \\<iota> \\<cdot> (\\<t>[a] \\<otimes> \\<t>[b])", "have \"\\<t>[a \\<otimes> b] = \\<t>[a] \\<cdot> \\<pp>\\<^sub>1[a, b]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<t>[a \\<otimes> b] = \\<t>[a] \\<cdot> \\<pp>\\<^sub>1[a, b]", "by (metis assms(1-2) cod_pr1 pr_simps(4-6) trm_naturality)"], ["proof (state)\nthis:\n  \\<t>[a \\<otimes> b] = \\<t>[a] \\<cdot> \\<pp>\\<^sub>1[a, b]\n\ngoal (1 subgoal):\n 1. \\<t>[a \\<otimes> b] = \\<iota> \\<cdot> (\\<t>[a] \\<otimes> \\<t>[b])", "moreover"], ["proof (state)\nthis:\n  \\<t>[a \\<otimes> b] = \\<t>[a] \\<cdot> \\<pp>\\<^sub>1[a, b]\n\ngoal (1 subgoal):\n 1. \\<t>[a \\<otimes> b] = \\<iota> \\<cdot> (\\<t>[a] \\<otimes> \\<t>[b])", "have \"\\<guillemotleft>\\<t>[b] : b \\<rightarrow> \\<one>\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<t>[b] : b \\<rightarrow> \\<one>\\<guillemotright>", "using assms(2) trm_in_hom"], ["proof (prove)\nusing this:\n  ide b\n  ide ?a \\<Longrightarrow>\n  \\<guillemotleft>\\<t>[?a] : ?a \\<rightarrow> \\<one>\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<t>[b] : b \\<rightarrow> \\<one>\\<guillemotright>", "by blast"], ["proof (state)\nthis:\n  \\<guillemotleft>\\<t>[b] : b \\<rightarrow> \\<one>\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<t>[a \\<otimes> b] = \\<iota> \\<cdot> (\\<t>[a] \\<otimes> \\<t>[b])", "ultimately"], ["proof (chain)\npicking this:\n  \\<t>[a \\<otimes> b] = \\<t>[a] \\<cdot> \\<pp>\\<^sub>1[a, b]\n  \\<guillemotleft>\\<t>[b] : b \\<rightarrow> \\<one>\\<guillemotright>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<t>[a \\<otimes> b] = \\<t>[a] \\<cdot> \\<pp>\\<^sub>1[a, b]\n  \\<guillemotleft>\\<t>[b] : b \\<rightarrow> \\<one>\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<t>[a \\<otimes> b] = \\<iota> \\<cdot> (\\<t>[a] \\<otimes> \\<t>[b])", "using assms(1) pr_coincidence trm_in_hom"], ["proof (prove)\nusing this:\n  \\<t>[a \\<otimes> b] = \\<t>[a] \\<cdot> \\<pp>\\<^sub>1[a, b]\n  \\<guillemotleft>\\<t>[b] : b \\<rightarrow> \\<one>\\<guillemotright>\n  ide a\n  \\<iota> = \\<pp>\\<^sub>1[\\<one>, \\<one>]\n  ide ?a \\<Longrightarrow>\n  \\<guillemotleft>\\<t>[?a] : ?a \\<rightarrow> \\<one>\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<t>[a \\<otimes> b] = \\<iota> \\<cdot> (\\<t>[a] \\<otimes> \\<t>[b])", "by fastforce"], ["proof (state)\nthis:\n  \\<t>[a \\<otimes> b] = \\<iota> \\<cdot> (\\<t>[a] \\<otimes> \\<t>[b])\n\ngoal:\nNo subgoals!", "qed"], ["", "abbreviation runit (\"\\<r>[_]\")\n    where \"\\<r>[a] \\<equiv> \\<pp>\\<^sub>1[a, \\<one>]\""], ["", "abbreviation runit' (\"\\<r>\\<^sup>-\\<^sup>1[_]\")\n    where \"\\<r>\\<^sup>-\\<^sup>1[a] \\<equiv> \\<langle>a, \\<t>[a]\\<rangle>\""], ["", "abbreviation lunit (\"\\<l>[_]\")\n    where \"\\<l>[a] \\<equiv> \\<pp>\\<^sub>0[\\<one>, a]\""], ["", "abbreviation lunit' (\"\\<l>\\<^sup>-\\<^sup>1[_]\")\n    where \"\\<l>\\<^sup>-\\<^sup>1[a] \\<equiv> \\<langle>\\<t>[a], a\\<rangle>\""], ["", "lemma runit_in_hom:\n    assumes \"ide a\"\n    shows \"\\<guillemotleft>\\<r>[a] : a \\<otimes> \\<one> \\<rightarrow> a\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<r>[a] : a \\<otimes>\n                              \\<one> \\<rightarrow> a\\<guillemotright>", "using assms ide_one"], ["proof (prove)\nusing this:\n  ide a\n  ide \\<one>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<r>[a] : a \\<otimes>\n                              \\<one> \\<rightarrow> a\\<guillemotright>", "by simp"], ["", "lemma runit'_in_hom:\n    assumes \"ide a\"\n    shows \"\\<guillemotleft>\\<r>\\<^sup>-\\<^sup>1[a] : a \\<rightarrow> a \\<otimes> \\<one>\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<r>\\<^sup>-\\<^sup>1[a] : a \\<rightarrow> a \\<otimes>\n                        \\<one>\\<guillemotright>", "using assms ide_in_hom trm_in_hom"], ["proof (prove)\nusing this:\n  ide a\n  ide ?a = \\<guillemotleft>?a : ?a \\<rightarrow> ?a\\<guillemotright>\n  ide ?a \\<Longrightarrow>\n  \\<guillemotleft>\\<t>[?a] : ?a \\<rightarrow> \\<one>\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<r>\\<^sup>-\\<^sup>1[a] : a \\<rightarrow> a \\<otimes>\n                        \\<one>\\<guillemotright>", "by blast"], ["", "lemma lunit_in_hom:\n    assumes \"ide a\"\n    shows \"\\<guillemotleft>\\<l>[a] : \\<one> \\<otimes> a \\<rightarrow> a\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<l>[a] : \\<one> \\<otimes>\n                              a \\<rightarrow> a\\<guillemotright>", "using assms ide_one"], ["proof (prove)\nusing this:\n  ide a\n  ide \\<one>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<l>[a] : \\<one> \\<otimes>\n                              a \\<rightarrow> a\\<guillemotright>", "by simp"], ["", "lemma lunit'_in_hom:\n    assumes \"ide a\"\n    shows \"\\<guillemotleft>\\<l>\\<^sup>-\\<^sup>1[a] : a \\<rightarrow> \\<one> \\<otimes> a\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<l>\\<^sup>-\\<^sup>1[a] : a \\<rightarrow> \\<one> \\<otimes>\n                        a\\<guillemotright>", "using assms ide_in_hom trm_in_hom"], ["proof (prove)\nusing this:\n  ide a\n  ide ?a = \\<guillemotleft>?a : ?a \\<rightarrow> ?a\\<guillemotright>\n  ide ?a \\<Longrightarrow>\n  \\<guillemotleft>\\<t>[?a] : ?a \\<rightarrow> \\<one>\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<l>\\<^sup>-\\<^sup>1[a] : a \\<rightarrow> \\<one> \\<otimes>\n                        a\\<guillemotright>", "by blast"], ["", "lemma runit_naturality:\n    assumes \"ide a\"\n    shows \"\\<r>[cod a] \\<cdot> (a \\<otimes> \\<one>) = a \\<cdot> \\<r>[dom a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<r>[cod a] \\<cdot> (a \\<otimes> \\<one>) = a \\<cdot> \\<r>[local.dom a]", "using assms pr_naturality(2) ide_char ide_one"], ["proof (prove)\nusing this:\n  ide a\n  \\<lbrakk>arr ?g; local.dom ?g = ?b; cod ?g = ?d; arr ?f;\n   local.dom ?f = ?a; cod ?f = ?c\\<rbrakk>\n  \\<Longrightarrow> \\<pp>\\<^sub>1[?c, ?d] \\<cdot> (?f \\<otimes> ?g) =\n                    ?f \\<cdot> \\<pp>\\<^sub>1[?a, ?b]\n  ide ?a = (arr ?a \\<and> local.dom ?a = ?a \\<and> cod ?a = ?a)\n  ide \\<one>\n\ngoal (1 subgoal):\n 1. \\<r>[cod a] \\<cdot> (a \\<otimes> \\<one>) = a \\<cdot> \\<r>[local.dom a]", "by blast"], ["", "lemma inverse_arrows_runit:\n    assumes \"ide a\"\n    shows \"inverse_arrows \\<r>[a] \\<r>\\<^sup>-\\<^sup>1[a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_arrows \\<r>[a] \\<r>\\<^sup>-\\<^sup>1[a]", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ide (\\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a])\n 2. ide (\\<r>[a] \\<cdot> \\<r>\\<^sup>-\\<^sup>1[a])", "show \"ide (\\<r>[a] \\<cdot> \\<r>\\<^sup>-\\<^sup>1[a])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide (\\<r>[a] \\<cdot> \\<r>\\<^sup>-\\<^sup>1[a])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ide (\\<r>[a] \\<cdot> \\<r>\\<^sup>-\\<^sup>1[a])", "have \"\\<r>[a] \\<cdot> \\<r>\\<^sup>-\\<^sup>1[a] = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<r>[a] \\<cdot> \\<r>\\<^sup>-\\<^sup>1[a] = a", "using assms"], ["proof (prove)\nusing this:\n  ide a\n\ngoal (1 subgoal):\n 1. \\<r>[a] \\<cdot> \\<r>\\<^sup>-\\<^sup>1[a] = a", "by (metis in_homE ide_char pr_tuple(1) trm_in_hom)"], ["proof (state)\nthis:\n  \\<r>[a] \\<cdot> \\<r>\\<^sup>-\\<^sup>1[a] = a\n\ngoal (1 subgoal):\n 1. ide (\\<r>[a] \\<cdot> \\<r>\\<^sup>-\\<^sup>1[a])", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<r>[a] \\<cdot> \\<r>\\<^sup>-\\<^sup>1[a] = a\n\ngoal (1 subgoal):\n 1. ide (\\<r>[a] \\<cdot> \\<r>\\<^sup>-\\<^sup>1[a])", "using assms"], ["proof (prove)\nusing this:\n  \\<r>[a] \\<cdot> \\<r>\\<^sup>-\\<^sup>1[a] = a\n  ide a\n\ngoal (1 subgoal):\n 1. ide (\\<r>[a] \\<cdot> \\<r>\\<^sup>-\\<^sup>1[a])", "by presburger"], ["proof (state)\nthis:\n  ide (\\<r>[a] \\<cdot> \\<r>\\<^sup>-\\<^sup>1[a])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ide (\\<r>[a] \\<cdot> \\<r>\\<^sup>-\\<^sup>1[a])\n\ngoal (1 subgoal):\n 1. ide (\\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a])", "show \"ide (\\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide (\\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ide (\\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a])", "have \"ide (a \\<otimes> \\<one>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide (a \\<otimes> \\<one>)", "using assms ide_one"], ["proof (prove)\nusing this:\n  ide a\n  ide \\<one>\n\ngoal (1 subgoal):\n 1. ide (a \\<otimes> \\<one>)", "by blast"], ["proof (state)\nthis:\n  ide (a \\<otimes> \\<one>)\n\ngoal (1 subgoal):\n 1. ide (\\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a])", "moreover"], ["proof (state)\nthis:\n  ide (a \\<otimes> \\<one>)\n\ngoal (1 subgoal):\n 1. ide (\\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a])", "have \"\\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a] = a \\<otimes> \\<one>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a] = a \\<otimes> \\<one>", "proof (intro pr_joint_monic [of a \\<one> \"\\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a]\" \"a \\<otimes> \\<one>\"])"], ["proof (state)\ngoal (3 subgoals):\n 1. seq \\<pp>\\<^sub>0[a, \\<one>] (\\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a])\n 2. \\<pp>\\<^sub>0[a, \\<one>] \\<cdot>\n    \\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a] =\n    \\<pp>\\<^sub>0[a, \\<one>] \\<cdot> (a \\<otimes> \\<one>)\n 3. \\<r>[a] \\<cdot> \\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a] =\n    \\<r>[a] \\<cdot> (a \\<otimes> \\<one>)", "show \"seq \\<pp>\\<^sub>0[a, \\<one>] (\\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq \\<pp>\\<^sub>0[a, \\<one>] (\\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a])", "using assms ide_one runit'_in_hom [of a]"], ["proof (prove)\nusing this:\n  ide a\n  ide \\<one>\n  ide a \\<Longrightarrow>\n  \\<guillemotleft>\\<r>\\<^sup>-\\<^sup>1[a] : a \\<rightarrow> a \\<otimes>\n                      \\<one>\\<guillemotright>\n\ngoal (1 subgoal):\n 1. seq \\<pp>\\<^sub>0[a, \\<one>] (\\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a])", "by (intro seqI) auto"], ["proof (state)\nthis:\n  seq \\<pp>\\<^sub>0[a, \\<one>] (\\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a])\n\ngoal (2 subgoals):\n 1. \\<pp>\\<^sub>0[a, \\<one>] \\<cdot>\n    \\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a] =\n    \\<pp>\\<^sub>0[a, \\<one>] \\<cdot> (a \\<otimes> \\<one>)\n 2. \\<r>[a] \\<cdot> \\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a] =\n    \\<r>[a] \\<cdot> (a \\<otimes> \\<one>)", "show \"\\<pp>\\<^sub>0[a, \\<one>] \\<cdot> \\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a] = \\<pp>\\<^sub>0[a, \\<one>] \\<cdot> (a \\<otimes> \\<one>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, \\<one>] \\<cdot>\n    \\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a] =\n    \\<pp>\\<^sub>0[a, \\<one>] \\<cdot> (a \\<otimes> \\<one>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, \\<one>] \\<cdot>\n    \\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a] =\n    \\<pp>\\<^sub>0[a, \\<one>] \\<cdot> (a \\<otimes> \\<one>)", "have \"\\<pp>\\<^sub>0[a, \\<one>] \\<cdot> \\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a] = (\\<pp>\\<^sub>0[a, \\<one>] \\<cdot> \\<r>\\<^sup>-\\<^sup>1[a]) \\<cdot> \\<r>[a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, \\<one>] \\<cdot>\n    \\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a] =\n    (\\<pp>\\<^sub>0[a, \\<one>] \\<cdot> \\<r>\\<^sup>-\\<^sup>1[a]) \\<cdot>\n    \\<r>[a]", "using comp_assoc"], ["proof (prove)\nusing this:\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, \\<one>] \\<cdot>\n    \\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a] =\n    (\\<pp>\\<^sub>0[a, \\<one>] \\<cdot> \\<r>\\<^sup>-\\<^sup>1[a]) \\<cdot>\n    \\<r>[a]", "by simp"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>0[a, \\<one>] \\<cdot> \\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a] =\n  (\\<pp>\\<^sub>0[a, \\<one>] \\<cdot> \\<r>\\<^sup>-\\<^sup>1[a]) \\<cdot> \\<r>[a]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, \\<one>] \\<cdot>\n    \\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a] =\n    \\<pp>\\<^sub>0[a, \\<one>] \\<cdot> (a \\<otimes> \\<one>)", "also"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>0[a, \\<one>] \\<cdot> \\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a] =\n  (\\<pp>\\<^sub>0[a, \\<one>] \\<cdot> \\<r>\\<^sup>-\\<^sup>1[a]) \\<cdot> \\<r>[a]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, \\<one>] \\<cdot>\n    \\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a] =\n    \\<pp>\\<^sub>0[a, \\<one>] \\<cdot> (a \\<otimes> \\<one>)", "have \"... = \\<t>[a] \\<cdot> \\<r>[a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<pp>\\<^sub>0[a, \\<one>] \\<cdot> \\<r>\\<^sup>-\\<^sup>1[a]) \\<cdot>\n    \\<r>[a] =\n    \\<t>[a] \\<cdot> \\<r>[a]", "using assms ide_one"], ["proof (prove)\nusing this:\n  ide a\n  ide \\<one>\n\ngoal (1 subgoal):\n 1. (\\<pp>\\<^sub>0[a, \\<one>] \\<cdot> \\<r>\\<^sup>-\\<^sup>1[a]) \\<cdot>\n    \\<r>[a] =\n    \\<t>[a] \\<cdot> \\<r>[a]", "by (metis in_homE pr_tuple(2) ide_char trm_in_hom)"], ["proof (state)\nthis:\n  (\\<pp>\\<^sub>0[a, \\<one>] \\<cdot> \\<r>\\<^sup>-\\<^sup>1[a]) \\<cdot>\n  \\<r>[a] =\n  \\<t>[a] \\<cdot> \\<r>[a]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, \\<one>] \\<cdot>\n    \\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a] =\n    \\<pp>\\<^sub>0[a, \\<one>] \\<cdot> (a \\<otimes> \\<one>)", "also"], ["proof (state)\nthis:\n  (\\<pp>\\<^sub>0[a, \\<one>] \\<cdot> \\<r>\\<^sup>-\\<^sup>1[a]) \\<cdot>\n  \\<r>[a] =\n  \\<t>[a] \\<cdot> \\<r>[a]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, \\<one>] \\<cdot>\n    \\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a] =\n    \\<pp>\\<^sub>0[a, \\<one>] \\<cdot> (a \\<otimes> \\<one>)", "have \"... = \\<t>[a \\<otimes> \\<one>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<t>[a] \\<cdot> \\<r>[a] = \\<t>[a \\<otimes> \\<one>]", "using assms ide_one trm_naturality [of \"\\<r>[a]\"]"], ["proof (prove)\nusing this:\n  ide a\n  ide \\<one>\n  arr \\<r>[a] \\<Longrightarrow>\n  \\<t>[cod \\<r>[a]] \\<cdot> \\<r>[a] = \\<t>[local.dom \\<r>[a]]\n\ngoal (1 subgoal):\n 1. \\<t>[a] \\<cdot> \\<r>[a] = \\<t>[a \\<otimes> \\<one>]", "by simp"], ["proof (state)\nthis:\n  \\<t>[a] \\<cdot> \\<r>[a] = \\<t>[a \\<otimes> \\<one>]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, \\<one>] \\<cdot>\n    \\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a] =\n    \\<pp>\\<^sub>0[a, \\<one>] \\<cdot> (a \\<otimes> \\<one>)", "also"], ["proof (state)\nthis:\n  \\<t>[a] \\<cdot> \\<r>[a] = \\<t>[a \\<otimes> \\<one>]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, \\<one>] \\<cdot>\n    \\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a] =\n    \\<pp>\\<^sub>0[a, \\<one>] \\<cdot> (a \\<otimes> \\<one>)", "have \"... = \\<pp>\\<^sub>0[a, \\<one>] \\<cdot> (a \\<otimes> \\<one>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<t>[a \\<otimes> \\<one>] =\n    \\<pp>\\<^sub>0[a, \\<one>] \\<cdot> (a \\<otimes> \\<one>)", "using assms comp_arr_dom ide_one trm_naturality trm_one"], ["proof (prove)\nusing this:\n  ide a\n  \\<lbrakk>arr ?f; local.dom ?f = ?a\\<rbrakk>\n  \\<Longrightarrow> ?f \\<cdot> ?a = ?f\n  ide \\<one>\n  arr ?f \\<Longrightarrow> \\<t>[cod ?f] \\<cdot> ?f = \\<t>[local.dom ?f]\n  \\<t>[\\<one>] = \\<one>\n\ngoal (1 subgoal):\n 1. \\<t>[a \\<otimes> \\<one>] =\n    \\<pp>\\<^sub>0[a, \\<one>] \\<cdot> (a \\<otimes> \\<one>)", "by fastforce"], ["proof (state)\nthis:\n  \\<t>[a \\<otimes> \\<one>] =\n  \\<pp>\\<^sub>0[a, \\<one>] \\<cdot> (a \\<otimes> \\<one>)\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, \\<one>] \\<cdot>\n    \\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a] =\n    \\<pp>\\<^sub>0[a, \\<one>] \\<cdot> (a \\<otimes> \\<one>)", "finally"], ["proof (chain)\npicking this:\n  \\<pp>\\<^sub>0[a, \\<one>] \\<cdot> \\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a] =\n  \\<pp>\\<^sub>0[a, \\<one>] \\<cdot> (a \\<otimes> \\<one>)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<pp>\\<^sub>0[a, \\<one>] \\<cdot> \\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a] =\n  \\<pp>\\<^sub>0[a, \\<one>] \\<cdot> (a \\<otimes> \\<one>)\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, \\<one>] \\<cdot>\n    \\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a] =\n    \\<pp>\\<^sub>0[a, \\<one>] \\<cdot> (a \\<otimes> \\<one>)", "by blast"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>0[a, \\<one>] \\<cdot> \\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a] =\n  \\<pp>\\<^sub>0[a, \\<one>] \\<cdot> (a \\<otimes> \\<one>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>0[a, \\<one>] \\<cdot> \\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a] =\n  \\<pp>\\<^sub>0[a, \\<one>] \\<cdot> (a \\<otimes> \\<one>)\n\ngoal (1 subgoal):\n 1. \\<r>[a] \\<cdot> \\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a] =\n    \\<r>[a] \\<cdot> (a \\<otimes> \\<one>)", "show \"\\<pp>\\<^sub>1[a, \\<one>] \\<cdot> \\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a] = \\<pp>\\<^sub>1[a, \\<one>] \\<cdot> (a \\<otimes> \\<one>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<r>[a] \\<cdot> \\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a] =\n    \\<r>[a] \\<cdot> (a \\<otimes> \\<one>)", "using assms"], ["proof (prove)\nusing this:\n  ide a\n\ngoal (1 subgoal):\n 1. \\<r>[a] \\<cdot> \\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a] =\n    \\<r>[a] \\<cdot> (a \\<otimes> \\<one>)", "by (metis \\<open>ide (\\<r>[a] \\<cdot> \\<r>\\<^sup>-\\<^sup>1[a])\\<close> cod_comp cod_pr1 dom_comp ide_compE ide_one\n                comp_assoc runit_naturality)"], ["proof (state)\nthis:\n  \\<r>[a] \\<cdot> \\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a] =\n  \\<r>[a] \\<cdot> (a \\<otimes> \\<one>)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a] = a \\<otimes> \\<one>\n\ngoal (1 subgoal):\n 1. ide (\\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a])", "ultimately"], ["proof (chain)\npicking this:\n  ide (a \\<otimes> \\<one>)\n  \\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a] = a \\<otimes> \\<one>", "show ?thesis"], ["proof (prove)\nusing this:\n  ide (a \\<otimes> \\<one>)\n  \\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a] = a \\<otimes> \\<one>\n\ngoal (1 subgoal):\n 1. ide (\\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a])", "by simp"], ["proof (state)\nthis:\n  ide (\\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ide (\\<r>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<r>[a])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma lunit_naturality:\n    assumes \"arr f\"\n    shows \"C \\<l>[cod f] (\\<one> \\<otimes> f) = C f \\<l>[dom f]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<l>[cod f] \\<cdot> (\\<one> \\<otimes> f) = f \\<cdot> \\<l>[local.dom f]", "using assms pr_naturality(1) ide_char ide_one"], ["proof (prove)\nusing this:\n  arr f\n  \\<lbrakk>arr ?g; local.dom ?g = ?b; cod ?g = ?d; arr ?f;\n   local.dom ?f = ?a; cod ?f = ?c\\<rbrakk>\n  \\<Longrightarrow> \\<pp>\\<^sub>0[?c, ?d] \\<cdot> (?f \\<otimes> ?g) =\n                    ?g \\<cdot> \\<pp>\\<^sub>0[?a, ?b]\n  ide ?a = (arr ?a \\<and> local.dom ?a = ?a \\<and> cod ?a = ?a)\n  ide \\<one>\n\ngoal (1 subgoal):\n 1. \\<l>[cod f] \\<cdot> (\\<one> \\<otimes> f) = f \\<cdot> \\<l>[local.dom f]", "by blast"], ["", "lemma inverse_arrows_lunit:\n    assumes \"ide a\"\n    shows \"inverse_arrows \\<l>[a] \\<l>\\<^sup>-\\<^sup>1[a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_arrows \\<l>[a] \\<l>\\<^sup>-\\<^sup>1[a]", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ide (\\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a])\n 2. ide (\\<l>[a] \\<cdot> \\<l>\\<^sup>-\\<^sup>1[a])", "show \"ide (C \\<l>[a] \\<l>\\<^sup>-\\<^sup>1[a])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide (\\<l>[a] \\<cdot> \\<l>\\<^sup>-\\<^sup>1[a])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ide (\\<l>[a] \\<cdot> \\<l>\\<^sup>-\\<^sup>1[a])", "have \"C \\<l>[a] \\<l>\\<^sup>-\\<^sup>1[a] = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<l>[a] \\<cdot> \\<l>\\<^sup>-\\<^sup>1[a] = a", "using assms"], ["proof (prove)\nusing this:\n  ide a\n\ngoal (1 subgoal):\n 1. \\<l>[a] \\<cdot> \\<l>\\<^sup>-\\<^sup>1[a] = a", "by (metis ide_char in_homE pr_tuple(2) trm_in_hom)"], ["proof (state)\nthis:\n  \\<l>[a] \\<cdot> \\<l>\\<^sup>-\\<^sup>1[a] = a\n\ngoal (1 subgoal):\n 1. ide (\\<l>[a] \\<cdot> \\<l>\\<^sup>-\\<^sup>1[a])", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<l>[a] \\<cdot> \\<l>\\<^sup>-\\<^sup>1[a] = a\n\ngoal (1 subgoal):\n 1. ide (\\<l>[a] \\<cdot> \\<l>\\<^sup>-\\<^sup>1[a])", "using assms"], ["proof (prove)\nusing this:\n  \\<l>[a] \\<cdot> \\<l>\\<^sup>-\\<^sup>1[a] = a\n  ide a\n\ngoal (1 subgoal):\n 1. ide (\\<l>[a] \\<cdot> \\<l>\\<^sup>-\\<^sup>1[a])", "by simp"], ["proof (state)\nthis:\n  ide (\\<l>[a] \\<cdot> \\<l>\\<^sup>-\\<^sup>1[a])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ide (\\<l>[a] \\<cdot> \\<l>\\<^sup>-\\<^sup>1[a])\n\ngoal (1 subgoal):\n 1. ide (\\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a])", "show \"ide (\\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide (\\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a])", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ide (\\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a])", "have \"\\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a] = \\<one> \\<otimes> a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a] = \\<one> \\<otimes> a", "proof (intro pr_joint_monic [of \\<one> a \"\\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a]\" \"\\<one> \\<otimes> a\"])"], ["proof (state)\ngoal (3 subgoals):\n 1. seq \\<l>[a] (\\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a])\n 2. \\<l>[a] \\<cdot> \\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a] =\n    \\<l>[a] \\<cdot> (\\<one> \\<otimes> a)\n 3. \\<pp>\\<^sub>1[\\<one>, a] \\<cdot>\n    \\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a] =\n    \\<pp>\\<^sub>1[\\<one>, a] \\<cdot> (\\<one> \\<otimes> a)", "show \"seq \\<l>[a] (\\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq \\<l>[a] (\\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a])", "using assms \\<open>ide (\\<l>[a] \\<cdot> \\<l>\\<^sup>-\\<^sup>1[a])\\<close>"], ["proof (prove)\nusing this:\n  ide a\n  ide (\\<l>[a] \\<cdot> \\<l>\\<^sup>-\\<^sup>1[a])\n\ngoal (1 subgoal):\n 1. seq \\<l>[a] (\\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a])", "by blast"], ["proof (state)\nthis:\n  seq \\<l>[a] (\\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a])\n\ngoal (2 subgoals):\n 1. \\<l>[a] \\<cdot> \\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a] =\n    \\<l>[a] \\<cdot> (\\<one> \\<otimes> a)\n 2. \\<pp>\\<^sub>1[\\<one>, a] \\<cdot>\n    \\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a] =\n    \\<pp>\\<^sub>1[\\<one>, a] \\<cdot> (\\<one> \\<otimes> a)", "show \"\\<l>[a] \\<cdot> \\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a] = \\<l>[a] \\<cdot> (\\<one> \\<otimes> a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<l>[a] \\<cdot> \\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a] =\n    \\<l>[a] \\<cdot> (\\<one> \\<otimes> a)", "using assms"], ["proof (prove)\nusing this:\n  ide a\n\ngoal (1 subgoal):\n 1. \\<l>[a] \\<cdot> \\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a] =\n    \\<l>[a] \\<cdot> (\\<one> \\<otimes> a)", "by (metis \\<open>ide (\\<l>[a] \\<cdot> \\<l>\\<^sup>-\\<^sup>1[a])\\<close> cod_comp cod_pr0 dom_cod ide_compE ide_one\n                comp_assoc lunit_naturality)"], ["proof (state)\nthis:\n  \\<l>[a] \\<cdot> \\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a] =\n  \\<l>[a] \\<cdot> (\\<one> \\<otimes> a)\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[\\<one>, a] \\<cdot>\n    \\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a] =\n    \\<pp>\\<^sub>1[\\<one>, a] \\<cdot> (\\<one> \\<otimes> a)", "show \"\\<pp>\\<^sub>1[\\<one>, a] \\<cdot> \\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a] = \\<pp>\\<^sub>1[\\<one>, a] \\<cdot> (\\<one> \\<otimes> a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[\\<one>, a] \\<cdot>\n    \\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a] =\n    \\<pp>\\<^sub>1[\\<one>, a] \\<cdot> (\\<one> \\<otimes> a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[\\<one>, a] \\<cdot>\n    \\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a] =\n    \\<pp>\\<^sub>1[\\<one>, a] \\<cdot> (\\<one> \\<otimes> a)", "have \"\\<pp>\\<^sub>1[\\<one>, a] \\<cdot> \\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a] = (\\<pp>\\<^sub>1[\\<one>, a] \\<cdot> \\<l>\\<^sup>-\\<^sup>1[a]) \\<cdot> \\<l>[a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[\\<one>, a] \\<cdot>\n    \\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a] =\n    (\\<pp>\\<^sub>1[\\<one>, a] \\<cdot> \\<l>\\<^sup>-\\<^sup>1[a]) \\<cdot>\n    \\<l>[a]", "using comp_assoc"], ["proof (prove)\nusing this:\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[\\<one>, a] \\<cdot>\n    \\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a] =\n    (\\<pp>\\<^sub>1[\\<one>, a] \\<cdot> \\<l>\\<^sup>-\\<^sup>1[a]) \\<cdot>\n    \\<l>[a]", "by simp"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>1[\\<one>, a] \\<cdot> \\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a] =\n  (\\<pp>\\<^sub>1[\\<one>, a] \\<cdot> \\<l>\\<^sup>-\\<^sup>1[a]) \\<cdot> \\<l>[a]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[\\<one>, a] \\<cdot>\n    \\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a] =\n    \\<pp>\\<^sub>1[\\<one>, a] \\<cdot> (\\<one> \\<otimes> a)", "also"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>1[\\<one>, a] \\<cdot> \\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a] =\n  (\\<pp>\\<^sub>1[\\<one>, a] \\<cdot> \\<l>\\<^sup>-\\<^sup>1[a]) \\<cdot> \\<l>[a]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[\\<one>, a] \\<cdot>\n    \\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a] =\n    \\<pp>\\<^sub>1[\\<one>, a] \\<cdot> (\\<one> \\<otimes> a)", "have \"... = \\<t>[a] \\<cdot> \\<l>[a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<pp>\\<^sub>1[\\<one>, a] \\<cdot> \\<l>\\<^sup>-\\<^sup>1[a]) \\<cdot>\n    \\<l>[a] =\n    \\<t>[a] \\<cdot> \\<l>[a]", "using assms ide_one"], ["proof (prove)\nusing this:\n  ide a\n  ide \\<one>\n\ngoal (1 subgoal):\n 1. (\\<pp>\\<^sub>1[\\<one>, a] \\<cdot> \\<l>\\<^sup>-\\<^sup>1[a]) \\<cdot>\n    \\<l>[a] =\n    \\<t>[a] \\<cdot> \\<l>[a]", "by (metis pr_tuple(1) ide_char in_homE trm_in_hom)"], ["proof (state)\nthis:\n  (\\<pp>\\<^sub>1[\\<one>, a] \\<cdot> \\<l>\\<^sup>-\\<^sup>1[a]) \\<cdot>\n  \\<l>[a] =\n  \\<t>[a] \\<cdot> \\<l>[a]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[\\<one>, a] \\<cdot>\n    \\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a] =\n    \\<pp>\\<^sub>1[\\<one>, a] \\<cdot> (\\<one> \\<otimes> a)", "also"], ["proof (state)\nthis:\n  (\\<pp>\\<^sub>1[\\<one>, a] \\<cdot> \\<l>\\<^sup>-\\<^sup>1[a]) \\<cdot>\n  \\<l>[a] =\n  \\<t>[a] \\<cdot> \\<l>[a]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[\\<one>, a] \\<cdot>\n    \\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a] =\n    \\<pp>\\<^sub>1[\\<one>, a] \\<cdot> (\\<one> \\<otimes> a)", "have \"... = \\<t>[\\<one> \\<otimes> a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<t>[a] \\<cdot> \\<l>[a] = \\<t>[\\<one> \\<otimes> a]", "using assms ide_one trm_naturality [of \"\\<l>[a]\"]"], ["proof (prove)\nusing this:\n  ide a\n  ide \\<one>\n  arr \\<l>[a] \\<Longrightarrow>\n  \\<t>[cod \\<l>[a]] \\<cdot> \\<l>[a] = \\<t>[local.dom \\<l>[a]]\n\ngoal (1 subgoal):\n 1. \\<t>[a] \\<cdot> \\<l>[a] = \\<t>[\\<one> \\<otimes> a]", "by simp"], ["proof (state)\nthis:\n  \\<t>[a] \\<cdot> \\<l>[a] = \\<t>[\\<one> \\<otimes> a]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[\\<one>, a] \\<cdot>\n    \\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a] =\n    \\<pp>\\<^sub>1[\\<one>, a] \\<cdot> (\\<one> \\<otimes> a)", "also"], ["proof (state)\nthis:\n  \\<t>[a] \\<cdot> \\<l>[a] = \\<t>[\\<one> \\<otimes> a]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[\\<one>, a] \\<cdot>\n    \\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a] =\n    \\<pp>\\<^sub>1[\\<one>, a] \\<cdot> (\\<one> \\<otimes> a)", "have \"... = \\<pp>\\<^sub>1[\\<one>, a] \\<cdot> (\\<one> \\<otimes> a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<t>[\\<one> \\<otimes> a] =\n    \\<pp>\\<^sub>1[\\<one>, a] \\<cdot> (\\<one> \\<otimes> a)", "using assms comp_arr_dom ide_one trm_naturality trm_one"], ["proof (prove)\nusing this:\n  ide a\n  \\<lbrakk>arr ?f; local.dom ?f = ?a\\<rbrakk>\n  \\<Longrightarrow> ?f \\<cdot> ?a = ?f\n  ide \\<one>\n  arr ?f \\<Longrightarrow> \\<t>[cod ?f] \\<cdot> ?f = \\<t>[local.dom ?f]\n  \\<t>[\\<one>] = \\<one>\n\ngoal (1 subgoal):\n 1. \\<t>[\\<one> \\<otimes> a] =\n    \\<pp>\\<^sub>1[\\<one>, a] \\<cdot> (\\<one> \\<otimes> a)", "by fastforce"], ["proof (state)\nthis:\n  \\<t>[\\<one> \\<otimes> a] =\n  \\<pp>\\<^sub>1[\\<one>, a] \\<cdot> (\\<one> \\<otimes> a)\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[\\<one>, a] \\<cdot>\n    \\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a] =\n    \\<pp>\\<^sub>1[\\<one>, a] \\<cdot> (\\<one> \\<otimes> a)", "finally"], ["proof (chain)\npicking this:\n  \\<pp>\\<^sub>1[\\<one>, a] \\<cdot> \\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a] =\n  \\<pp>\\<^sub>1[\\<one>, a] \\<cdot> (\\<one> \\<otimes> a)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<pp>\\<^sub>1[\\<one>, a] \\<cdot> \\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a] =\n  \\<pp>\\<^sub>1[\\<one>, a] \\<cdot> (\\<one> \\<otimes> a)\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[\\<one>, a] \\<cdot>\n    \\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a] =\n    \\<pp>\\<^sub>1[\\<one>, a] \\<cdot> (\\<one> \\<otimes> a)", "by simp"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>1[\\<one>, a] \\<cdot> \\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a] =\n  \\<pp>\\<^sub>1[\\<one>, a] \\<cdot> (\\<one> \\<otimes> a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>1[\\<one>, a] \\<cdot> \\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a] =\n  \\<pp>\\<^sub>1[\\<one>, a] \\<cdot> (\\<one> \\<otimes> a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a] = \\<one> \\<otimes> a\n\ngoal (1 subgoal):\n 1. ide (\\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a])", "moreover"], ["proof (state)\nthis:\n  \\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a] = \\<one> \\<otimes> a\n\ngoal (1 subgoal):\n 1. ide (\\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a])", "have \"ide (\\<one> \\<otimes> a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide (\\<one> \\<otimes> a)", "using assms ide_one"], ["proof (prove)\nusing this:\n  ide a\n  ide \\<one>\n\ngoal (1 subgoal):\n 1. ide (\\<one> \\<otimes> a)", "by simp"], ["proof (state)\nthis:\n  ide (\\<one> \\<otimes> a)\n\ngoal (1 subgoal):\n 1. ide (\\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a])", "finally"], ["proof (chain)\npicking this:\n  ide (\\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a])", "show ?thesis"], ["proof (prove)\nusing this:\n  ide (\\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a])\n\ngoal (1 subgoal):\n 1. ide (\\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a])", "by blast"], ["proof (state)\nthis:\n  ide (\\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a])\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ide (\\<l>\\<^sup>-\\<^sup>1[a] \\<cdot> \\<l>[a])\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma comp_lunit_term_dup:\n    assumes \"ide a\"\n    shows \"\\<l>[a] \\<cdot> (\\<t>[a] \\<otimes> a) \\<cdot> \\<d>[a] = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<l>[a] \\<cdot> (\\<t>[a] \\<otimes> a) \\<cdot> \\<d>[a] = a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<l>[a] \\<cdot> (\\<t>[a] \\<otimes> a) \\<cdot> \\<d>[a] = a", "have \"\\<guillemotleft>\\<t>[a] : a \\<rightarrow> \\<one>\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<t>[a] : a \\<rightarrow> \\<one>\\<guillemotright>", "using assms trm_in_hom"], ["proof (prove)\nusing this:\n  ide a\n  ide ?a \\<Longrightarrow>\n  \\<guillemotleft>\\<t>[?a] : ?a \\<rightarrow> \\<one>\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<t>[a] : a \\<rightarrow> \\<one>\\<guillemotright>", "by blast"], ["proof (state)\nthis:\n  \\<guillemotleft>\\<t>[a] : a \\<rightarrow> \\<one>\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<l>[a] \\<cdot> (\\<t>[a] \\<otimes> a) \\<cdot> \\<d>[a] = a", "hence \"\\<l>[a] \\<cdot> (\\<t>[a] \\<otimes> a) = a \\<cdot> \\<pp>\\<^sub>0[a, a]\""], ["proof (prove)\nusing this:\n  \\<guillemotleft>\\<t>[a] : a \\<rightarrow> \\<one>\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<l>[a] \\<cdot> (\\<t>[a] \\<otimes> a) = a \\<cdot> \\<pp>\\<^sub>0[a, a]", "by (metis assms pr_naturality(1) ide_char in_homE)"], ["proof (state)\nthis:\n  \\<l>[a] \\<cdot> (\\<t>[a] \\<otimes> a) = a \\<cdot> \\<pp>\\<^sub>0[a, a]\n\ngoal (1 subgoal):\n 1. \\<l>[a] \\<cdot> (\\<t>[a] \\<otimes> a) \\<cdot> \\<d>[a] = a", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<l>[a] \\<cdot> (\\<t>[a] \\<otimes> a) = a \\<cdot> \\<pp>\\<^sub>0[a, a]\n\ngoal (1 subgoal):\n 1. \\<l>[a] \\<cdot> (\\<t>[a] \\<otimes> a) \\<cdot> \\<d>[a] = a", "by (metis (no_types) assms comp_assoc comp_ide_self pr_dup(1))"], ["proof (state)\nthis:\n  \\<l>[a] \\<cdot> (\\<t>[a] \\<otimes> a) \\<cdot> \\<d>[a] = a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma comp_runit_term_dup:\n    assumes \"ide a\"\n    shows \"\\<r>[a] \\<cdot> (a \\<otimes> \\<t>[a]) \\<cdot> \\<d>[a] = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<r>[a] \\<cdot> (a \\<otimes> \\<t>[a]) \\<cdot> \\<d>[a] = a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<r>[a] \\<cdot> (a \\<otimes> \\<t>[a]) \\<cdot> \\<d>[a] = a", "have \"\\<guillemotleft>\\<t>[a] : a \\<rightarrow> \\<one>\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<t>[a] : a \\<rightarrow> \\<one>\\<guillemotright>", "using assms trm_in_hom"], ["proof (prove)\nusing this:\n  ide a\n  ide ?a \\<Longrightarrow>\n  \\<guillemotleft>\\<t>[?a] : ?a \\<rightarrow> \\<one>\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<t>[a] : a \\<rightarrow> \\<one>\\<guillemotright>", "by blast"], ["proof (state)\nthis:\n  \\<guillemotleft>\\<t>[a] : a \\<rightarrow> \\<one>\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<r>[a] \\<cdot> (a \\<otimes> \\<t>[a]) \\<cdot> \\<d>[a] = a", "hence \"\\<r>[a] \\<cdot> (a \\<otimes> \\<t>[a]) = a \\<cdot> \\<pp>\\<^sub>1[a, a]\""], ["proof (prove)\nusing this:\n  \\<guillemotleft>\\<t>[a] : a \\<rightarrow> \\<one>\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<r>[a] \\<cdot> (a \\<otimes> \\<t>[a]) = a \\<cdot> \\<pp>\\<^sub>1[a, a]", "using assms"], ["proof (prove)\nusing this:\n  \\<guillemotleft>\\<t>[a] : a \\<rightarrow> \\<one>\\<guillemotright>\n  ide a\n\ngoal (1 subgoal):\n 1. \\<r>[a] \\<cdot> (a \\<otimes> \\<t>[a]) = a \\<cdot> \\<pp>\\<^sub>1[a, a]", "by auto"], ["proof (state)\nthis:\n  \\<r>[a] \\<cdot> (a \\<otimes> \\<t>[a]) = a \\<cdot> \\<pp>\\<^sub>1[a, a]\n\ngoal (1 subgoal):\n 1. \\<r>[a] \\<cdot> (a \\<otimes> \\<t>[a]) \\<cdot> \\<d>[a] = a", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<r>[a] \\<cdot> (a \\<otimes> \\<t>[a]) = a \\<cdot> \\<pp>\\<^sub>1[a, a]\n\ngoal (1 subgoal):\n 1. \\<r>[a] \\<cdot> (a \\<otimes> \\<t>[a]) \\<cdot> \\<d>[a] = a", "using assms"], ["proof (prove)\nusing this:\n  \\<r>[a] \\<cdot> (a \\<otimes> \\<t>[a]) = a \\<cdot> \\<pp>\\<^sub>1[a, a]\n  ide a\n\ngoal (1 subgoal):\n 1. \\<r>[a] \\<cdot> (a \\<otimes> \\<t>[a]) \\<cdot> \\<d>[a] = a", "by (metis comp_ide_arr pr_dup(2) ide_char comp_assoc seqI)"], ["proof (state)\nthis:\n  \\<r>[a] \\<cdot> (a \\<otimes> \\<t>[a]) \\<cdot> \\<d>[a] = a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma comp_proj_assoc:\n    assumes \"ide a0\" and \"ide a1\" and \"ide a2\"\n    shows \"\\<pp>\\<^sub>1[a0, a1 \\<otimes> a2] \\<cdot> \\<a>[a0, a1, a2] = \\<pp>\\<^sub>1[a0, a1] \\<cdot> \\<pp>\\<^sub>1[a0 \\<otimes> a1, a2]\"\n    and \"\\<pp>\\<^sub>0[a0, a1 \\<otimes> a2] \\<cdot> \\<a>[a0, a1, a2] = \\<langle>\\<pp>\\<^sub>0[a0, a1] \\<cdot> \\<pp>\\<^sub>1[a0 \\<otimes> a1, a2], \\<pp>\\<^sub>0[a0 \\<otimes> a1, a2]\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a0, a1 \\<otimes> a2] \\<cdot> \\<a>[a0, a1, a2] =\n    \\<pp>\\<^sub>1[a0, a1] \\<cdot> \\<pp>\\<^sub>1[a0 \\<otimes> a1, a2] &&&\n    \\<pp>\\<^sub>0[a0, a1 \\<otimes> a2] \\<cdot> \\<a>[a0, a1, a2] =\n    \\<langle>\\<pp>\\<^sub>0[a0, a1] \\<cdot>\n             \\<pp>\\<^sub>1[a0 \\<otimes>\n                           a1, a2], \\<pp>\\<^sub>0[a0 \\<otimes>\n            a1, a2]\\<rangle>", "using assms assoc_def"], ["proof (prove)\nusing this:\n  ide a0\n  ide a1\n  ide a2\n  \\<a>[?a, ?b, ?c] \\<equiv>\n  \\<langle>\\<pp>\\<^sub>1[?a, ?b] \\<cdot>\n           \\<pp>\\<^sub>1[?a \\<otimes>\n                         ?b, ?c], \\<langle>\\<pp>\\<^sub>0[?a, ?b] \\<cdot>\n     \\<pp>\\<^sub>1[?a \\<otimes>\n                   ?b, ?c], \\<pp>\\<^sub>0[?a \\<otimes>\n    ?b, ?c]\\<rangle>\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a0, a1 \\<otimes> a2] \\<cdot> \\<a>[a0, a1, a2] =\n    \\<pp>\\<^sub>1[a0, a1] \\<cdot> \\<pp>\\<^sub>1[a0 \\<otimes> a1, a2] &&&\n    \\<pp>\\<^sub>0[a0, a1 \\<otimes> a2] \\<cdot> \\<a>[a0, a1, a2] =\n    \\<langle>\\<pp>\\<^sub>0[a0, a1] \\<cdot>\n             \\<pp>\\<^sub>1[a0 \\<otimes>\n                           a1, a2], \\<pp>\\<^sub>0[a0 \\<otimes>\n            a1, a2]\\<rangle>", "by auto"], ["", "lemma dup_coassoc:\n    assumes \"ide a\"\n    shows \"\\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] = (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n    (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]", "proof (intro pr_joint_monic\n                   [of a \"a \\<otimes> a\" \"\\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a]\" \"(a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]\"])"], ["proof (state)\ngoal (3 subgoals):\n 1. seq \\<pp>\\<^sub>0[a, a \\<otimes> a]\n     (\\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a])\n 2. \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot>\n    \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n    \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot>\n    (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]\n 3. \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n    \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n    \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n    (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]", "show \"seq \\<pp>\\<^sub>0[a, a \\<otimes> a] (\\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq \\<pp>\\<^sub>0[a, a \\<otimes> a]\n     (\\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a])", "using assms"], ["proof (prove)\nusing this:\n  ide a\n\ngoal (1 subgoal):\n 1. seq \\<pp>\\<^sub>0[a, a \\<otimes> a]\n     (\\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a])", "by simp"], ["proof (state)\nthis:\n  seq \\<pp>\\<^sub>0[a, a \\<otimes> a]\n   (\\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a])\n\ngoal (2 subgoals):\n 1. \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot>\n    \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n    \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot>\n    (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]\n 2. \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n    \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n    \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n    (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]", "show \"\\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot> \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] = \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot> (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot>\n    \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n    \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot>\n    (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot>\n    \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n    \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot>\n    (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]", "have \"\\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot> \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n              ((\\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot> \\<a>[a, a, a]) \\<cdot> (\\<d>[a] \\<otimes> a)) \\<cdot> \\<d>[a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot>\n    \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n    ((\\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot> \\<a>[a, a, a]) \\<cdot>\n     (\\<d>[a] \\<otimes> a)) \\<cdot>\n    \\<d>[a]", "using comp_assoc"], ["proof (prove)\nusing this:\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot>\n    \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n    ((\\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot> \\<a>[a, a, a]) \\<cdot>\n     (\\<d>[a] \\<otimes> a)) \\<cdot>\n    \\<d>[a]", "by simp"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot>\n  \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n  ((\\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot> \\<a>[a, a, a]) \\<cdot>\n   (\\<d>[a] \\<otimes> a)) \\<cdot>\n  \\<d>[a]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot>\n    \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n    \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot>\n    (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]", "also"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot>\n  \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n  ((\\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot> \\<a>[a, a, a]) \\<cdot>\n   (\\<d>[a] \\<otimes> a)) \\<cdot>\n  \\<d>[a]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot>\n    \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n    \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot>\n    (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]", "have \"... = \\<langle>((\\<pp>\\<^sub>0[a, a] \\<cdot> \\<pp>\\<^sub>1[a \\<otimes> a, a]) \\<cdot> (\\<d>[a] \\<otimes> a)) \\<cdot> \\<d>[a], (a \\<cdot> \\<pp>\\<^sub>0[a, a]) \\<cdot> \\<d>[a]\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot> \\<a>[a, a, a]) \\<cdot>\n     (\\<d>[a] \\<otimes> a)) \\<cdot>\n    \\<d>[a] =\n    \\<langle>((\\<pp>\\<^sub>0[a, a] \\<cdot>\n               \\<pp>\\<^sub>1[a \\<otimes> a, a]) \\<cdot>\n              (\\<d>[a] \\<otimes> a)) \\<cdot>\n             \\<d>[a], (a \\<cdot> \\<pp>\\<^sub>0[a, a]) \\<cdot>\n                      \\<d>[a]\\<rangle>", "using assms assoc_def"], ["proof (prove)\nusing this:\n  ide a\n  \\<a>[?a, ?b, ?c] \\<equiv>\n  \\<langle>\\<pp>\\<^sub>1[?a, ?b] \\<cdot>\n           \\<pp>\\<^sub>1[?a \\<otimes>\n                         ?b, ?c], \\<langle>\\<pp>\\<^sub>0[?a, ?b] \\<cdot>\n     \\<pp>\\<^sub>1[?a \\<otimes>\n                   ?b, ?c], \\<pp>\\<^sub>0[?a \\<otimes>\n    ?b, ?c]\\<rangle>\\<rangle>\n\ngoal (1 subgoal):\n 1. ((\\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot> \\<a>[a, a, a]) \\<cdot>\n     (\\<d>[a] \\<otimes> a)) \\<cdot>\n    \\<d>[a] =\n    \\<langle>((\\<pp>\\<^sub>0[a, a] \\<cdot>\n               \\<pp>\\<^sub>1[a \\<otimes> a, a]) \\<cdot>\n              (\\<d>[a] \\<otimes> a)) \\<cdot>\n             \\<d>[a], (a \\<cdot> \\<pp>\\<^sub>0[a, a]) \\<cdot>\n                      \\<d>[a]\\<rangle>", "by simp"], ["proof (state)\nthis:\n  ((\\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot> \\<a>[a, a, a]) \\<cdot>\n   (\\<d>[a] \\<otimes> a)) \\<cdot>\n  \\<d>[a] =\n  \\<langle>((\\<pp>\\<^sub>0[a, a] \\<cdot>\n             \\<pp>\\<^sub>1[a \\<otimes> a, a]) \\<cdot>\n            (\\<d>[a] \\<otimes> a)) \\<cdot>\n           \\<d>[a], (a \\<cdot> \\<pp>\\<^sub>0[a, a]) \\<cdot> \\<d>[a]\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot>\n    \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n    \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot>\n    (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]", "also"], ["proof (state)\nthis:\n  ((\\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot> \\<a>[a, a, a]) \\<cdot>\n   (\\<d>[a] \\<otimes> a)) \\<cdot>\n  \\<d>[a] =\n  \\<langle>((\\<pp>\\<^sub>0[a, a] \\<cdot>\n             \\<pp>\\<^sub>1[a \\<otimes> a, a]) \\<cdot>\n            (\\<d>[a] \\<otimes> a)) \\<cdot>\n           \\<d>[a], (a \\<cdot> \\<pp>\\<^sub>0[a, a]) \\<cdot> \\<d>[a]\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot>\n    \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n    \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot>\n    (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]", "have \"... = \\<d>[a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<langle>((\\<pp>\\<^sub>0[a, a] \\<cdot>\n               \\<pp>\\<^sub>1[a \\<otimes> a, a]) \\<cdot>\n              (\\<d>[a] \\<otimes> a)) \\<cdot>\n             \\<d>[a], (a \\<cdot> \\<pp>\\<^sub>0[a, a]) \\<cdot>\n                      \\<d>[a]\\<rangle> =\n    \\<d>[a]", "using assms comp_assoc"], ["proof (prove)\nusing this:\n  ide a\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. \\<langle>((\\<pp>\\<^sub>0[a, a] \\<cdot>\n               \\<pp>\\<^sub>1[a \\<otimes> a, a]) \\<cdot>\n              (\\<d>[a] \\<otimes> a)) \\<cdot>\n             \\<d>[a], (a \\<cdot> \\<pp>\\<^sub>0[a, a]) \\<cdot>\n                      \\<d>[a]\\<rangle> =\n    \\<d>[a]", "by simp"], ["proof (state)\nthis:\n  \\<langle>((\\<pp>\\<^sub>0[a, a] \\<cdot>\n             \\<pp>\\<^sub>1[a \\<otimes> a, a]) \\<cdot>\n            (\\<d>[a] \\<otimes> a)) \\<cdot>\n           \\<d>[a], (a \\<cdot> \\<pp>\\<^sub>0[a, a]) \\<cdot>\n                    \\<d>[a]\\<rangle> =\n  \\<d>[a]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot>\n    \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n    \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot>\n    (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]", "also"], ["proof (state)\nthis:\n  \\<langle>((\\<pp>\\<^sub>0[a, a] \\<cdot>\n             \\<pp>\\<^sub>1[a \\<otimes> a, a]) \\<cdot>\n            (\\<d>[a] \\<otimes> a)) \\<cdot>\n           \\<d>[a], (a \\<cdot> \\<pp>\\<^sub>0[a, a]) \\<cdot>\n                    \\<d>[a]\\<rangle> =\n  \\<d>[a]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot>\n    \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n    \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot>\n    (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]", "have \"... = (\\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot> (a \\<otimes> \\<d>[a])) \\<cdot> \\<d>[a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<d>[a] =\n    (\\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot> (a \\<otimes> \\<d>[a])) \\<cdot>\n    \\<d>[a]", "using assms assoc_def comp_assoc"], ["proof (prove)\nusing this:\n  ide a\n  \\<a>[?a, ?b, ?c] \\<equiv>\n  \\<langle>\\<pp>\\<^sub>1[?a, ?b] \\<cdot>\n           \\<pp>\\<^sub>1[?a \\<otimes>\n                         ?b, ?c], \\<langle>\\<pp>\\<^sub>0[?a, ?b] \\<cdot>\n     \\<pp>\\<^sub>1[?a \\<otimes>\n                   ?b, ?c], \\<pp>\\<^sub>0[?a \\<otimes>\n    ?b, ?c]\\<rangle>\\<rangle>\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. \\<d>[a] =\n    (\\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot> (a \\<otimes> \\<d>[a])) \\<cdot>\n    \\<d>[a]", "by simp"], ["proof (state)\nthis:\n  \\<d>[a] =\n  (\\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot> (a \\<otimes> \\<d>[a])) \\<cdot>\n  \\<d>[a]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot>\n    \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n    \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot>\n    (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]", "also"], ["proof (state)\nthis:\n  \\<d>[a] =\n  (\\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot> (a \\<otimes> \\<d>[a])) \\<cdot>\n  \\<d>[a]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot>\n    \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n    \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot>\n    (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]", "have \"... = \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot> (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot> (a \\<otimes> \\<d>[a])) \\<cdot>\n    \\<d>[a] =\n    \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot>\n    (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]", "using comp_assoc"], ["proof (prove)\nusing this:\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. (\\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot> (a \\<otimes> \\<d>[a])) \\<cdot>\n    \\<d>[a] =\n    \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot>\n    (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]", "by simp"], ["proof (state)\nthis:\n  (\\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot> (a \\<otimes> \\<d>[a])) \\<cdot>\n  \\<d>[a] =\n  \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot>\n  (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot>\n    \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n    \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot>\n    (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]", "finally"], ["proof (chain)\npicking this:\n  \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot>\n  \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n  \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot>\n  (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot>\n  \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n  \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot>\n  (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot>\n    \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n    \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot>\n    (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]", "by blast"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot>\n  \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n  \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot>\n  (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot>\n  \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n  \\<pp>\\<^sub>0[a, a \\<otimes> a] \\<cdot>\n  (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n    \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n    \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n    (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]", "show \"\\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot> \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] = \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot> (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n    \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n    \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n    (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n    \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n    \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n    (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]", "have \"\\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot> \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n              ((\\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot> \\<a>[a, a, a]) \\<cdot> (\\<d>[a] \\<otimes> a)) \\<cdot> \\<d>[a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n    \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n    ((\\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot> \\<a>[a, a, a]) \\<cdot>\n     (\\<d>[a] \\<otimes> a)) \\<cdot>\n    \\<d>[a]", "using comp_assoc"], ["proof (prove)\nusing this:\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n    \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n    ((\\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot> \\<a>[a, a, a]) \\<cdot>\n     (\\<d>[a] \\<otimes> a)) \\<cdot>\n    \\<d>[a]", "by simp"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n  \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n  ((\\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot> \\<a>[a, a, a]) \\<cdot>\n   (\\<d>[a] \\<otimes> a)) \\<cdot>\n  \\<d>[a]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n    \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n    \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n    (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]", "also"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n  \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n  ((\\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot> \\<a>[a, a, a]) \\<cdot>\n   (\\<d>[a] \\<otimes> a)) \\<cdot>\n  \\<d>[a]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n    \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n    \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n    (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]", "have \"... = ((\\<pp>\\<^sub>1[a, a] \\<cdot> \\<pp>\\<^sub>1[a \\<otimes> a, a]) \\<cdot> (\\<d>[a] \\<otimes> a)) \\<cdot> \\<d>[a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot> \\<a>[a, a, a]) \\<cdot>\n     (\\<d>[a] \\<otimes> a)) \\<cdot>\n    \\<d>[a] =\n    ((\\<pp>\\<^sub>1[a, a] \\<cdot> \\<pp>\\<^sub>1[a \\<otimes> a, a]) \\<cdot>\n     (\\<d>[a] \\<otimes> a)) \\<cdot>\n    \\<d>[a]", "using assms assoc_def"], ["proof (prove)\nusing this:\n  ide a\n  \\<a>[?a, ?b, ?c] \\<equiv>\n  \\<langle>\\<pp>\\<^sub>1[?a, ?b] \\<cdot>\n           \\<pp>\\<^sub>1[?a \\<otimes>\n                         ?b, ?c], \\<langle>\\<pp>\\<^sub>0[?a, ?b] \\<cdot>\n     \\<pp>\\<^sub>1[?a \\<otimes>\n                   ?b, ?c], \\<pp>\\<^sub>0[?a \\<otimes>\n    ?b, ?c]\\<rangle>\\<rangle>\n\ngoal (1 subgoal):\n 1. ((\\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot> \\<a>[a, a, a]) \\<cdot>\n     (\\<d>[a] \\<otimes> a)) \\<cdot>\n    \\<d>[a] =\n    ((\\<pp>\\<^sub>1[a, a] \\<cdot> \\<pp>\\<^sub>1[a \\<otimes> a, a]) \\<cdot>\n     (\\<d>[a] \\<otimes> a)) \\<cdot>\n    \\<d>[a]", "by simp"], ["proof (state)\nthis:\n  ((\\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot> \\<a>[a, a, a]) \\<cdot>\n   (\\<d>[a] \\<otimes> a)) \\<cdot>\n  \\<d>[a] =\n  ((\\<pp>\\<^sub>1[a, a] \\<cdot> \\<pp>\\<^sub>1[a \\<otimes> a, a]) \\<cdot>\n   (\\<d>[a] \\<otimes> a)) \\<cdot>\n  \\<d>[a]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n    \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n    \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n    (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]", "also"], ["proof (state)\nthis:\n  ((\\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot> \\<a>[a, a, a]) \\<cdot>\n   (\\<d>[a] \\<otimes> a)) \\<cdot>\n  \\<d>[a] =\n  ((\\<pp>\\<^sub>1[a, a] \\<cdot> \\<pp>\\<^sub>1[a \\<otimes> a, a]) \\<cdot>\n   (\\<d>[a] \\<otimes> a)) \\<cdot>\n  \\<d>[a]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n    \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n    \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n    (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]", "have \"... = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<pp>\\<^sub>1[a, a] \\<cdot> \\<pp>\\<^sub>1[a \\<otimes> a, a]) \\<cdot>\n     (\\<d>[a] \\<otimes> a)) \\<cdot>\n    \\<d>[a] =\n    a", "using assms comp_assoc"], ["proof (prove)\nusing this:\n  ide a\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. ((\\<pp>\\<^sub>1[a, a] \\<cdot> \\<pp>\\<^sub>1[a \\<otimes> a, a]) \\<cdot>\n     (\\<d>[a] \\<otimes> a)) \\<cdot>\n    \\<d>[a] =\n    a", "by simp"], ["proof (state)\nthis:\n  ((\\<pp>\\<^sub>1[a, a] \\<cdot> \\<pp>\\<^sub>1[a \\<otimes> a, a]) \\<cdot>\n   (\\<d>[a] \\<otimes> a)) \\<cdot>\n  \\<d>[a] =\n  a\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n    \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n    \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n    (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]", "also"], ["proof (state)\nthis:\n  ((\\<pp>\\<^sub>1[a, a] \\<cdot> \\<pp>\\<^sub>1[a \\<otimes> a, a]) \\<cdot>\n   (\\<d>[a] \\<otimes> a)) \\<cdot>\n  \\<d>[a] =\n  a\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n    \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n    \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n    (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]", "have \"... = (a \\<cdot> \\<pp>\\<^sub>1[a, a]) \\<cdot> \\<d>[a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = (a \\<cdot> \\<pp>\\<^sub>1[a, a]) \\<cdot> \\<d>[a]", "using assms comp_assoc"], ["proof (prove)\nusing this:\n  ide a\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. a = (a \\<cdot> \\<pp>\\<^sub>1[a, a]) \\<cdot> \\<d>[a]", "by simp"], ["proof (state)\nthis:\n  a = (a \\<cdot> \\<pp>\\<^sub>1[a, a]) \\<cdot> \\<d>[a]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n    \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n    \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n    (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]", "also"], ["proof (state)\nthis:\n  a = (a \\<cdot> \\<pp>\\<^sub>1[a, a]) \\<cdot> \\<d>[a]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n    \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n    \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n    (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]", "have \"... = (\\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot> (a \\<otimes> \\<d>[a])) \\<cdot> \\<d>[a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (a \\<cdot> \\<pp>\\<^sub>1[a, a]) \\<cdot> \\<d>[a] =\n    (\\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot> (a \\<otimes> \\<d>[a])) \\<cdot>\n    \\<d>[a]", "using assms"], ["proof (prove)\nusing this:\n  ide a\n\ngoal (1 subgoal):\n 1. (a \\<cdot> \\<pp>\\<^sub>1[a, a]) \\<cdot> \\<d>[a] =\n    (\\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot> (a \\<otimes> \\<d>[a])) \\<cdot>\n    \\<d>[a]", "by simp"], ["proof (state)\nthis:\n  (a \\<cdot> \\<pp>\\<^sub>1[a, a]) \\<cdot> \\<d>[a] =\n  (\\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot> (a \\<otimes> \\<d>[a])) \\<cdot>\n  \\<d>[a]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n    \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n    \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n    (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]", "also"], ["proof (state)\nthis:\n  (a \\<cdot> \\<pp>\\<^sub>1[a, a]) \\<cdot> \\<d>[a] =\n  (\\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot> (a \\<otimes> \\<d>[a])) \\<cdot>\n  \\<d>[a]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n    \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n    \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n    (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]", "have \"... = \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot> (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot> (a \\<otimes> \\<d>[a])) \\<cdot>\n    \\<d>[a] =\n    \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n    (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]", "using comp_assoc"], ["proof (prove)\nusing this:\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. (\\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot> (a \\<otimes> \\<d>[a])) \\<cdot>\n    \\<d>[a] =\n    \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n    (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]", "by simp"], ["proof (state)\nthis:\n  (\\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot> (a \\<otimes> \\<d>[a])) \\<cdot>\n  \\<d>[a] =\n  \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n  (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n    \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n    \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n    (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]", "finally"], ["proof (chain)\npicking this:\n  \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n  \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n  \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n  (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n  \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n  \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n  (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n    \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n    \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n    (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]", "by blast"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n  \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n  \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n  (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n  \\<a>[a, a, a] \\<cdot> (\\<d>[a] \\<otimes> a) \\<cdot> \\<d>[a] =\n  \\<pp>\\<^sub>1[a, a \\<otimes> a] \\<cdot>\n  (a \\<otimes> \\<d>[a]) \\<cdot> \\<d>[a]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma comp_assoc_tuple:\n    assumes \"\\<guillemotleft>f0 : a \\<rightarrow> b0\\<guillemotright>\" and \"\\<guillemotleft>f1 : a \\<rightarrow> b1\\<guillemotright>\" and \"\\<guillemotleft>f2 : a \\<rightarrow> b2\\<guillemotright>\"\n    shows \"\\<a>[b0, b1, b2] \\<cdot> \\<langle>\\<langle>f0, f1\\<rangle>, f2\\<rangle> = \\<langle>f0, \\<langle>f1, f2\\<rangle>\\<rangle>\"\n    and \"\\<a>\\<^sup>-\\<^sup>1[b0, b1, b2] \\<cdot> \\<langle>f0, \\<langle>f1, f2\\<rangle>\\<rangle> = \\<langle>\\<langle>f0, f1\\<rangle>, f2\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<a>[b0, b1, b2] \\<cdot>\n    \\<langle>\\<langle>f0, f1\\<rangle>, f2\\<rangle> =\n    \\<langle>f0, \\<langle>f1, f2\\<rangle>\\<rangle> &&&\n    \\<a>\\<^sup>-\\<^sup>1[b0, b1, b2] \\<cdot>\n    \\<langle>f0, \\<langle>f1, f2\\<rangle>\\<rangle> =\n    \\<langle>\\<langle>f0, f1\\<rangle>, f2\\<rangle>", "using assms assoc_def assoc'_def comp_assoc"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f0 : a \\<rightarrow> b0\\<guillemotright>\n  \\<guillemotleft>f1 : a \\<rightarrow> b1\\<guillemotright>\n  \\<guillemotleft>f2 : a \\<rightarrow> b2\\<guillemotright>\n  \\<a>[?a, ?b, ?c] \\<equiv>\n  \\<langle>\\<pp>\\<^sub>1[?a, ?b] \\<cdot>\n           \\<pp>\\<^sub>1[?a \\<otimes>\n                         ?b, ?c], \\<langle>\\<pp>\\<^sub>0[?a, ?b] \\<cdot>\n     \\<pp>\\<^sub>1[?a \\<otimes>\n                   ?b, ?c], \\<pp>\\<^sub>0[?a \\<otimes>\n    ?b, ?c]\\<rangle>\\<rangle>\n  \\<a>\\<^sup>-\\<^sup>1[?a, ?b, ?c] \\<equiv>\n  \\<langle>\\<langle>\\<pp>\\<^sub>1[?a, ?b \\<otimes>\n?c], \\<pp>\\<^sub>1[?b, ?c] \\<cdot>\n     \\<pp>\\<^sub>0[?a, ?b \\<otimes>\n                       ?c]\\<rangle>, \\<pp>\\<^sub>0[?b, ?c] \\<cdot>\n                                     \\<pp>\\<^sub>0[?a, ?b \\<otimes>\n                 ?c]\\<rangle>\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. \\<a>[b0, b1, b2] \\<cdot>\n    \\<langle>\\<langle>f0, f1\\<rangle>, f2\\<rangle> =\n    \\<langle>f0, \\<langle>f1, f2\\<rangle>\\<rangle> &&&\n    \\<a>\\<^sup>-\\<^sup>1[b0, b1, b2] \\<cdot>\n    \\<langle>f0, \\<langle>f1, f2\\<rangle>\\<rangle> =\n    \\<langle>\\<langle>f0, f1\\<rangle>, f2\\<rangle>", "by fastforce+"], ["", "lemma dup_tensor:\n    assumes \"ide a\" and \"ide b\"\n    shows \"\\<d>[a \\<otimes> b] = \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot> (a \\<otimes> \\<a>[b, a, b]) \\<cdot> (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n                        (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot> \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<d>[a \\<otimes> b] =\n    \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n    (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n    (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n    \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b])", "proof (intro pr_joint_monic [of \"a \\<otimes> b\" \"a \\<otimes> b\" \"\\<d>[a \\<otimes> b]\"])"], ["proof (state)\ngoal (3 subgoals):\n 1. seq \\<pp>\\<^sub>0[a \\<otimes> b, a \\<otimes> b] \\<d>[a \\<otimes> b]\n 2. \\<pp>\\<^sub>0[a \\<otimes> b, a \\<otimes> b] \\<cdot>\n    \\<d>[a \\<otimes> b] =\n    \\<pp>\\<^sub>0[a \\<otimes> b, a \\<otimes> b] \\<cdot>\n    \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n    (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n    (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n    \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b])\n 3. \\<pp>\\<^sub>1[a \\<otimes> b, a \\<otimes> b] \\<cdot>\n    \\<d>[a \\<otimes> b] =\n    \\<pp>\\<^sub>1[a \\<otimes> b, a \\<otimes> b] \\<cdot>\n    \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n    (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n    (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n    \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b])", "show \"seq \\<pp>\\<^sub>0[a \\<otimes> b, a \\<otimes> b] (\\<d>[a \\<otimes> b])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq \\<pp>\\<^sub>0[a \\<otimes> b, a \\<otimes> b] \\<d>[a \\<otimes> b]", "using assms"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n\ngoal (1 subgoal):\n 1. seq \\<pp>\\<^sub>0[a \\<otimes> b, a \\<otimes> b] \\<d>[a \\<otimes> b]", "by simp"], ["proof (state)\nthis:\n  seq \\<pp>\\<^sub>0[a \\<otimes> b, a \\<otimes> b] \\<d>[a \\<otimes> b]\n\ngoal (2 subgoals):\n 1. \\<pp>\\<^sub>0[a \\<otimes> b, a \\<otimes> b] \\<cdot>\n    \\<d>[a \\<otimes> b] =\n    \\<pp>\\<^sub>0[a \\<otimes> b, a \\<otimes> b] \\<cdot>\n    \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n    (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n    (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n    \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b])\n 2. \\<pp>\\<^sub>1[a \\<otimes> b, a \\<otimes> b] \\<cdot>\n    \\<d>[a \\<otimes> b] =\n    \\<pp>\\<^sub>1[a \\<otimes> b, a \\<otimes> b] \\<cdot>\n    \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n    (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n    (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n    \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b])", "have 1: \"\\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot> (a \\<otimes> \\<a>[b, a, b]) \\<cdot> (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n                 (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot> \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b]) =\n               \\<langle>a \\<otimes> b, a \\<otimes> b\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n    (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n    (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n    \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b]) =\n    \\<d>[a \\<otimes> b]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n    (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n    (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n    \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b]) =\n    \\<d>[a \\<otimes> b]", "have \"\\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot> (a \\<otimes> \\<a>[b, a, b]) \\<cdot> (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n              (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot> \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b])\n                = \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot> (a \\<otimes> \\<a>[b, a, b]) \\<cdot> (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n                  (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot> \\<langle>\\<pp>\\<^sub>1[a, b], \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[b] \\<cdot> \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n    (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n    (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n    \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b]) =\n    \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n    (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n    (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n    \\<langle>\\<pp>\\<^sub>1[a, b], \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[b] \\<cdot>\n                          \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n    (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n    (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n    \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b]) =\n    \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n    (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n    (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n    \\<langle>\\<pp>\\<^sub>1[a, b], \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[b] \\<cdot>\n                          \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle>", "have \"\\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b]) = \\<langle>\\<pp>\\<^sub>1[a, b], \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[b] \\<cdot> \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b]) =\n    \\<langle>\\<pp>\\<^sub>1[a, b], \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[b] \\<cdot>\n                          \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle>", "using assms assoc_def comp_assoc pr_naturality comp_cod_arr"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  \\<a>[?a, ?b, ?c] \\<equiv>\n  \\<langle>\\<pp>\\<^sub>1[?a, ?b] \\<cdot>\n           \\<pp>\\<^sub>1[?a \\<otimes>\n                         ?b, ?c], \\<langle>\\<pp>\\<^sub>0[?a, ?b] \\<cdot>\n     \\<pp>\\<^sub>1[?a \\<otimes>\n                   ?b, ?c], \\<pp>\\<^sub>0[?a \\<otimes>\n    ?b, ?c]\\<rangle>\\<rangle>\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n  \\<lbrakk>arr ?g; local.dom ?g = ?b; cod ?g = ?d; arr ?f;\n   local.dom ?f = ?a; cod ?f = ?c\\<rbrakk>\n  \\<Longrightarrow> \\<pp>\\<^sub>0[?c, ?d] \\<cdot> (?f \\<otimes> ?g) =\n                    ?g \\<cdot> \\<pp>\\<^sub>0[?a, ?b]\n  \\<lbrakk>arr ?g; local.dom ?g = ?b; cod ?g = ?d; arr ?f;\n   local.dom ?f = ?a; cod ?f = ?c\\<rbrakk>\n  \\<Longrightarrow> \\<pp>\\<^sub>1[?c, ?d] \\<cdot> (?f \\<otimes> ?g) =\n                    ?f \\<cdot> \\<pp>\\<^sub>1[?a, ?b]\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n\ngoal (1 subgoal):\n 1. \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b]) =\n    \\<langle>\\<pp>\\<^sub>1[a, b], \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[b] \\<cdot>\n                          \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle>", "by simp"], ["proof (state)\nthis:\n  \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b]) =\n  \\<langle>\\<pp>\\<^sub>1[a, b], \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[b] \\<cdot>\n                        \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n    (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n    (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n    \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b]) =\n    \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n    (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n    (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n    \\<langle>\\<pp>\\<^sub>1[a, b], \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[b] \\<cdot>\n                          \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b]) =\n  \\<langle>\\<pp>\\<^sub>1[a, b], \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[b] \\<cdot>\n                        \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n    (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n    (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n    \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b]) =\n    \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n    (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n    (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n    \\<langle>\\<pp>\\<^sub>1[a, b], \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[b] \\<cdot>\n                          \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle>", "by presburger"], ["proof (state)\nthis:\n  \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n  (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n  (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n  (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n  \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b]) =\n  \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n  (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n  (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n  (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n  \\<langle>\\<pp>\\<^sub>1[a, b], \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[b] \\<cdot>\n                        \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n  (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n  (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n  (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n  \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b]) =\n  \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n  (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n  (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n  (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n  \\<langle>\\<pp>\\<^sub>1[a, b], \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[b] \\<cdot>\n                        \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n    (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n    (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n    \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b]) =\n    \\<d>[a \\<otimes> b]", "also"], ["proof (state)\nthis:\n  \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n  (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n  (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n  (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n  \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b]) =\n  \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n  (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n  (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n  (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n  \\<langle>\\<pp>\\<^sub>1[a, b], \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[b] \\<cdot>\n                        \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n    (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n    (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n    \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b]) =\n    \\<d>[a \\<otimes> b]", "have \"... = \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n        \\<langle>a \\<cdot> a \\<cdot> a \\<cdot> \\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot> (\\<s>[a, b] \\<cdot> (a \\<otimes> b) \\<otimes> b) \\<cdot>\n                               \\<a>\\<^sup>-\\<^sup>1[a, b, b] \\<cdot> \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[b \\<cdot> \\<pp>\\<^sub>0[a, b]]\\<rangle>\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n    (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n    (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n    \\<langle>\\<pp>\\<^sub>1[a, b], \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[b] \\<cdot>\n                          \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle> =\n    \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    \\<langle>a \\<cdot>\n             a \\<cdot>\n             a \\<cdot>\n             \\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                  (\\<s>[a, b] \\<cdot>\n                                   (a \\<otimes> b) \\<otimes>\n                                   b) \\<cdot>\n                                  \\<a>\\<^sup>-\\<^sup>1[a, b, b] \\<cdot>\n                                  \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[b \\<cdot>\n                               \\<pp>\\<^sub>0[a, b]]\\<rangle>\\<rangle>", "using assms prod_tuple"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  \\<lbrakk>span ?f ?g; seq ?h ?f; seq ?k ?g\\<rbrakk>\n  \\<Longrightarrow> (?h \\<otimes> ?k) \\<cdot> \\<langle>?f, ?g\\<rangle> =\n                    \\<langle>?h \\<cdot> ?f, ?k \\<cdot> ?g\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n    (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n    (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n    \\<langle>\\<pp>\\<^sub>1[a, b], \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[b] \\<cdot>\n                          \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle> =\n    \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    \\<langle>a \\<cdot>\n             a \\<cdot>\n             a \\<cdot>\n             \\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                  (\\<s>[a, b] \\<cdot>\n                                   (a \\<otimes> b) \\<otimes>\n                                   b) \\<cdot>\n                                  \\<a>\\<^sup>-\\<^sup>1[a, b, b] \\<cdot>\n                                  \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[b \\<cdot>\n                               \\<pp>\\<^sub>0[a, b]]\\<rangle>\\<rangle>", "by simp"], ["proof (state)\nthis:\n  \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n  (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n  (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n  (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n  \\<langle>\\<pp>\\<^sub>1[a, b], \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[b] \\<cdot>\n                        \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle> =\n  \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n  \\<langle>a \\<cdot>\n           a \\<cdot>\n           a \\<cdot>\n           \\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                (\\<s>[a, b] \\<cdot>\n                                 (a \\<otimes> b) \\<otimes>\n                                 b) \\<cdot>\n                                \\<a>\\<^sup>-\\<^sup>1[a, b, b] \\<cdot>\n                                \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[b \\<cdot>\n                             \\<pp>\\<^sub>0[a, b]]\\<rangle>\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n    (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n    (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n    \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b]) =\n    \\<d>[a \\<otimes> b]", "also"], ["proof (state)\nthis:\n  \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n  (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n  (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n  (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n  \\<langle>\\<pp>\\<^sub>1[a, b], \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[b] \\<cdot>\n                        \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle> =\n  \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n  \\<langle>a \\<cdot>\n           a \\<cdot>\n           a \\<cdot>\n           \\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                (\\<s>[a, b] \\<cdot>\n                                 (a \\<otimes> b) \\<otimes>\n                                 b) \\<cdot>\n                                \\<a>\\<^sup>-\\<^sup>1[a, b, b] \\<cdot>\n                                \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[b \\<cdot>\n                             \\<pp>\\<^sub>0[a, b]]\\<rangle>\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n    (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n    (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n    \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b]) =\n    \\<d>[a \\<otimes> b]", "have \"... = \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n        \\<langle>\\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot> (\\<s>[a, b] \\<otimes> b) \\<cdot> \\<a>\\<^sup>-\\<^sup>1[a, b, b] \\<cdot> \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[\\<pp>\\<^sub>0[a, b]]\\<rangle>\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    \\<langle>a \\<cdot>\n             a \\<cdot>\n             a \\<cdot>\n             \\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                  (\\<s>[a, b] \\<cdot>\n                                   (a \\<otimes> b) \\<otimes>\n                                   b) \\<cdot>\n                                  \\<a>\\<^sup>-\\<^sup>1[a, b, b] \\<cdot>\n                                  \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[b \\<cdot>\n                               \\<pp>\\<^sub>0[a, b]]\\<rangle>\\<rangle> =\n    \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    \\<langle>\\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                  (\\<s>[a, b] \\<otimes> b) \\<cdot>\n                                  \\<a>\\<^sup>-\\<^sup>1[a, b, b] \\<cdot>\n                                  \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[\\<pp>\\<^sub>0[a, b]]\\<rangle>\\<rangle>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    \\<langle>a \\<cdot>\n             a \\<cdot>\n             a \\<cdot>\n             \\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                  (\\<s>[a, b] \\<cdot>\n                                   (a \\<otimes> b) \\<otimes>\n                                   b) \\<cdot>\n                                  \\<a>\\<^sup>-\\<^sup>1[a, b, b] \\<cdot>\n                                  \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[b \\<cdot>\n                               \\<pp>\\<^sub>0[a, b]]\\<rangle>\\<rangle> =\n    \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    \\<langle>\\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                  (\\<s>[a, b] \\<otimes> b) \\<cdot>\n                                  \\<a>\\<^sup>-\\<^sup>1[a, b, b] \\<cdot>\n                                  \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[\\<pp>\\<^sub>0[a, b]]\\<rangle>\\<rangle>", "have \"a \\<cdot> a \\<cdot> a \\<cdot> \\<pp>\\<^sub>1[a, b] = \\<pp>\\<^sub>1[a, b]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a \\<cdot> a \\<cdot> a \\<cdot> \\<pp>\\<^sub>1[a, b] = \\<pp>\\<^sub>1[a, b]", "using assms comp_cod_arr"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n\ngoal (1 subgoal):\n 1. a \\<cdot> a \\<cdot> a \\<cdot> \\<pp>\\<^sub>1[a, b] = \\<pp>\\<^sub>1[a, b]", "by simp"], ["proof (state)\nthis:\n  a \\<cdot> a \\<cdot> a \\<cdot> \\<pp>\\<^sub>1[a, b] = \\<pp>\\<^sub>1[a, b]\n\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    \\<langle>a \\<cdot>\n             a \\<cdot>\n             a \\<cdot>\n             \\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                  (\\<s>[a, b] \\<cdot>\n                                   (a \\<otimes> b) \\<otimes>\n                                   b) \\<cdot>\n                                  \\<a>\\<^sup>-\\<^sup>1[a, b, b] \\<cdot>\n                                  \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[b \\<cdot>\n                               \\<pp>\\<^sub>0[a, b]]\\<rangle>\\<rangle> =\n    \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    \\<langle>\\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                  (\\<s>[a, b] \\<otimes> b) \\<cdot>\n                                  \\<a>\\<^sup>-\\<^sup>1[a, b, b] \\<cdot>\n                                  \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[\\<pp>\\<^sub>0[a, b]]\\<rangle>\\<rangle>", "moreover"], ["proof (state)\nthis:\n  a \\<cdot> a \\<cdot> a \\<cdot> \\<pp>\\<^sub>1[a, b] = \\<pp>\\<^sub>1[a, b]\n\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    \\<langle>a \\<cdot>\n             a \\<cdot>\n             a \\<cdot>\n             \\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                  (\\<s>[a, b] \\<cdot>\n                                   (a \\<otimes> b) \\<otimes>\n                                   b) \\<cdot>\n                                  \\<a>\\<^sup>-\\<^sup>1[a, b, b] \\<cdot>\n                                  \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[b \\<cdot>\n                               \\<pp>\\<^sub>0[a, b]]\\<rangle>\\<rangle> =\n    \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    \\<langle>\\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                  (\\<s>[a, b] \\<otimes> b) \\<cdot>\n                                  \\<a>\\<^sup>-\\<^sup>1[a, b, b] \\<cdot>\n                                  \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[\\<pp>\\<^sub>0[a, b]]\\<rangle>\\<rangle>", "have \"b \\<cdot> \\<pp>\\<^sub>0[a, b] = \\<pp>\\<^sub>0[a, b]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<cdot> \\<pp>\\<^sub>0[a, b] = \\<pp>\\<^sub>0[a, b]", "using assms comp_cod_arr"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n\ngoal (1 subgoal):\n 1. b \\<cdot> \\<pp>\\<^sub>0[a, b] = \\<pp>\\<^sub>0[a, b]", "by simp"], ["proof (state)\nthis:\n  b \\<cdot> \\<pp>\\<^sub>0[a, b] = \\<pp>\\<^sub>0[a, b]\n\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    \\<langle>a \\<cdot>\n             a \\<cdot>\n             a \\<cdot>\n             \\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                  (\\<s>[a, b] \\<cdot>\n                                   (a \\<otimes> b) \\<otimes>\n                                   b) \\<cdot>\n                                  \\<a>\\<^sup>-\\<^sup>1[a, b, b] \\<cdot>\n                                  \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[b \\<cdot>\n                               \\<pp>\\<^sub>0[a, b]]\\<rangle>\\<rangle> =\n    \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    \\<langle>\\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                  (\\<s>[a, b] \\<otimes> b) \\<cdot>\n                                  \\<a>\\<^sup>-\\<^sup>1[a, b, b] \\<cdot>\n                                  \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[\\<pp>\\<^sub>0[a, b]]\\<rangle>\\<rangle>", "moreover"], ["proof (state)\nthis:\n  b \\<cdot> \\<pp>\\<^sub>0[a, b] = \\<pp>\\<^sub>0[a, b]\n\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    \\<langle>a \\<cdot>\n             a \\<cdot>\n             a \\<cdot>\n             \\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                  (\\<s>[a, b] \\<cdot>\n                                   (a \\<otimes> b) \\<otimes>\n                                   b) \\<cdot>\n                                  \\<a>\\<^sup>-\\<^sup>1[a, b, b] \\<cdot>\n                                  \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[b \\<cdot>\n                               \\<pp>\\<^sub>0[a, b]]\\<rangle>\\<rangle> =\n    \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    \\<langle>\\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                  (\\<s>[a, b] \\<otimes> b) \\<cdot>\n                                  \\<a>\\<^sup>-\\<^sup>1[a, b, b] \\<cdot>\n                                  \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[\\<pp>\\<^sub>0[a, b]]\\<rangle>\\<rangle>", "have \"\\<s>[a, b] \\<cdot> (a \\<otimes> b) \\<otimes> b = \\<s>[a, b] \\<otimes> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<s>[a, b] \\<cdot> (a \\<otimes> b) \\<otimes> b = \\<s>[a, b] \\<otimes> b", "using assms comp_arr_dom"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  \\<lbrakk>arr ?f; local.dom ?f = ?a\\<rbrakk>\n  \\<Longrightarrow> ?f \\<cdot> ?a = ?f\n\ngoal (1 subgoal):\n 1. \\<s>[a, b] \\<cdot> (a \\<otimes> b) \\<otimes> b = \\<s>[a, b] \\<otimes> b", "by simp"], ["proof (state)\nthis:\n  \\<s>[a, b] \\<cdot> (a \\<otimes> b) \\<otimes> b = \\<s>[a, b] \\<otimes> b\n\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    \\<langle>a \\<cdot>\n             a \\<cdot>\n             a \\<cdot>\n             \\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                  (\\<s>[a, b] \\<cdot>\n                                   (a \\<otimes> b) \\<otimes>\n                                   b) \\<cdot>\n                                  \\<a>\\<^sup>-\\<^sup>1[a, b, b] \\<cdot>\n                                  \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[b \\<cdot>\n                               \\<pp>\\<^sub>0[a, b]]\\<rangle>\\<rangle> =\n    \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    \\<langle>\\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                  (\\<s>[a, b] \\<otimes> b) \\<cdot>\n                                  \\<a>\\<^sup>-\\<^sup>1[a, b, b] \\<cdot>\n                                  \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[\\<pp>\\<^sub>0[a, b]]\\<rangle>\\<rangle>", "ultimately"], ["proof (chain)\npicking this:\n  a \\<cdot> a \\<cdot> a \\<cdot> \\<pp>\\<^sub>1[a, b] = \\<pp>\\<^sub>1[a, b]\n  b \\<cdot> \\<pp>\\<^sub>0[a, b] = \\<pp>\\<^sub>0[a, b]\n  \\<s>[a, b] \\<cdot> (a \\<otimes> b) \\<otimes> b = \\<s>[a, b] \\<otimes> b", "show ?thesis"], ["proof (prove)\nusing this:\n  a \\<cdot> a \\<cdot> a \\<cdot> \\<pp>\\<^sub>1[a, b] = \\<pp>\\<^sub>1[a, b]\n  b \\<cdot> \\<pp>\\<^sub>0[a, b] = \\<pp>\\<^sub>0[a, b]\n  \\<s>[a, b] \\<cdot> (a \\<otimes> b) \\<otimes> b = \\<s>[a, b] \\<otimes> b\n\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    \\<langle>a \\<cdot>\n             a \\<cdot>\n             a \\<cdot>\n             \\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                  (\\<s>[a, b] \\<cdot>\n                                   (a \\<otimes> b) \\<otimes>\n                                   b) \\<cdot>\n                                  \\<a>\\<^sup>-\\<^sup>1[a, b, b] \\<cdot>\n                                  \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[b \\<cdot>\n                               \\<pp>\\<^sub>0[a, b]]\\<rangle>\\<rangle> =\n    \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    \\<langle>\\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                  (\\<s>[a, b] \\<otimes> b) \\<cdot>\n                                  \\<a>\\<^sup>-\\<^sup>1[a, b, b] \\<cdot>\n                                  \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[\\<pp>\\<^sub>0[a, b]]\\<rangle>\\<rangle>", "by simp"], ["proof (state)\nthis:\n  \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n  \\<langle>a \\<cdot>\n           a \\<cdot>\n           a \\<cdot>\n           \\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                (\\<s>[a, b] \\<cdot>\n                                 (a \\<otimes> b) \\<otimes>\n                                 b) \\<cdot>\n                                \\<a>\\<^sup>-\\<^sup>1[a, b, b] \\<cdot>\n                                \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[b \\<cdot>\n                             \\<pp>\\<^sub>0[a, b]]\\<rangle>\\<rangle> =\n  \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n  \\<langle>\\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                (\\<s>[a, b] \\<otimes> b) \\<cdot>\n                                \\<a>\\<^sup>-\\<^sup>1[a, b, b] \\<cdot>\n                                \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[\\<pp>\\<^sub>0[a, b]]\\<rangle>\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n  \\<langle>a \\<cdot>\n           a \\<cdot>\n           a \\<cdot>\n           \\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                (\\<s>[a, b] \\<cdot>\n                                 (a \\<otimes> b) \\<otimes>\n                                 b) \\<cdot>\n                                \\<a>\\<^sup>-\\<^sup>1[a, b, b] \\<cdot>\n                                \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[b \\<cdot>\n                             \\<pp>\\<^sub>0[a, b]]\\<rangle>\\<rangle> =\n  \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n  \\<langle>\\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                (\\<s>[a, b] \\<otimes> b) \\<cdot>\n                                \\<a>\\<^sup>-\\<^sup>1[a, b, b] \\<cdot>\n                                \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[\\<pp>\\<^sub>0[a, b]]\\<rangle>\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n    (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n    (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n    \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b]) =\n    \\<d>[a \\<otimes> b]", "also"], ["proof (state)\nthis:\n  \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n  \\<langle>a \\<cdot>\n           a \\<cdot>\n           a \\<cdot>\n           \\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                (\\<s>[a, b] \\<cdot>\n                                 (a \\<otimes> b) \\<otimes>\n                                 b) \\<cdot>\n                                \\<a>\\<^sup>-\\<^sup>1[a, b, b] \\<cdot>\n                                \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[b \\<cdot>\n                             \\<pp>\\<^sub>0[a, b]]\\<rangle>\\<rangle> =\n  \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n  \\<langle>\\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                (\\<s>[a, b] \\<otimes> b) \\<cdot>\n                                \\<a>\\<^sup>-\\<^sup>1[a, b, b] \\<cdot>\n                                \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[\\<pp>\\<^sub>0[a, b]]\\<rangle>\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n    (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n    (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n    \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b]) =\n    \\<d>[a \\<otimes> b]", "have \"... = \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot> \\<langle>\\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot> (\\<s>[a, b] \\<otimes> b) \\<cdot>\n                           \\<langle>\\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>, \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    \\<langle>\\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                  (\\<s>[a, b] \\<otimes> b) \\<cdot>\n                                  \\<a>\\<^sup>-\\<^sup>1[a, b, b] \\<cdot>\n                                  \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[\\<pp>\\<^sub>0[a, b]]\\<rangle>\\<rangle> =\n    \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    \\<langle>\\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                  (\\<s>[a, b] \\<otimes> b) \\<cdot>\n                                  \\<langle>\\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>, \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    \\<langle>\\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                  (\\<s>[a, b] \\<otimes> b) \\<cdot>\n                                  \\<a>\\<^sup>-\\<^sup>1[a, b, b] \\<cdot>\n                                  \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[\\<pp>\\<^sub>0[a, b]]\\<rangle>\\<rangle> =\n    \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    \\<langle>\\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                  (\\<s>[a, b] \\<otimes> b) \\<cdot>\n                                  \\<langle>\\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>, \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle>", "have \"\\<a>\\<^sup>-\\<^sup>1[a, b, b] \\<cdot> \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[\\<pp>\\<^sub>0[a, b]]\\<rangle> = \\<langle>\\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>, \\<pp>\\<^sub>0[a, b]\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, b] \\<cdot>\n    \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[\\<pp>\\<^sub>0[a, b]]\\<rangle> =\n    \\<langle>\\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>, \\<pp>\\<^sub>0[a, b]\\<rangle>", "using assms comp_assoc_tuple(2)"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  \\<lbrakk>\\<guillemotleft>?f0.0 : ?a \\<rightarrow> ?b0.0\\<guillemotright>;\n   \\<guillemotleft>?f1.0 : ?a \\<rightarrow> ?b1.0\\<guillemotright>;\n   \\<guillemotleft>?f2.0 : ?a \\<rightarrow> ?b2.0\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> \\<a>\\<^sup>-\\<^sup>1[?b0.0, ?b1.0, ?b2.0] \\<cdot>\n                    \\<langle>?f0.0, \\<langle>?f1.0, ?f2.0\\<rangle>\\<rangle> =\n                    \\<langle>\\<langle>?f0.0, ?f1.0\\<rangle>, ?f2.0\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, b] \\<cdot>\n    \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[\\<pp>\\<^sub>0[a, b]]\\<rangle> =\n    \\<langle>\\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>, \\<pp>\\<^sub>0[a, b]\\<rangle>", "by blast"], ["proof (state)\nthis:\n  \\<a>\\<^sup>-\\<^sup>1[a, b, b] \\<cdot>\n  \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[\\<pp>\\<^sub>0[a, b]]\\<rangle> =\n  \\<langle>\\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>, \\<pp>\\<^sub>0[a, b]\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    \\<langle>\\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                  (\\<s>[a, b] \\<otimes> b) \\<cdot>\n                                  \\<a>\\<^sup>-\\<^sup>1[a, b, b] \\<cdot>\n                                  \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[\\<pp>\\<^sub>0[a, b]]\\<rangle>\\<rangle> =\n    \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    \\<langle>\\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                  (\\<s>[a, b] \\<otimes> b) \\<cdot>\n                                  \\<langle>\\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>, \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<a>\\<^sup>-\\<^sup>1[a, b, b] \\<cdot>\n  \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[\\<pp>\\<^sub>0[a, b]]\\<rangle> =\n  \\<langle>\\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>, \\<pp>\\<^sub>0[a, b]\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    \\<langle>\\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                  (\\<s>[a, b] \\<otimes> b) \\<cdot>\n                                  \\<a>\\<^sup>-\\<^sup>1[a, b, b] \\<cdot>\n                                  \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[\\<pp>\\<^sub>0[a, b]]\\<rangle>\\<rangle> =\n    \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    \\<langle>\\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                  (\\<s>[a, b] \\<otimes> b) \\<cdot>\n                                  \\<langle>\\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>, \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle>", "by simp"], ["proof (state)\nthis:\n  \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n  \\<langle>\\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                (\\<s>[a, b] \\<otimes> b) \\<cdot>\n                                \\<a>\\<^sup>-\\<^sup>1[a, b, b] \\<cdot>\n                                \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[\\<pp>\\<^sub>0[a, b]]\\<rangle>\\<rangle> =\n  \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n  \\<langle>\\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                (\\<s>[a, b] \\<otimes> b) \\<cdot>\n                                \\<langle>\\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>, \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n  \\<langle>\\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                (\\<s>[a, b] \\<otimes> b) \\<cdot>\n                                \\<a>\\<^sup>-\\<^sup>1[a, b, b] \\<cdot>\n                                \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[\\<pp>\\<^sub>0[a, b]]\\<rangle>\\<rangle> =\n  \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n  \\<langle>\\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                (\\<s>[a, b] \\<otimes> b) \\<cdot>\n                                \\<langle>\\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>, \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n    (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n    (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n    \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b]) =\n    \\<d>[a \\<otimes> b]", "also"], ["proof (state)\nthis:\n  \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n  \\<langle>\\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                (\\<s>[a, b] \\<otimes> b) \\<cdot>\n                                \\<a>\\<^sup>-\\<^sup>1[a, b, b] \\<cdot>\n                                \\<langle>\\<pp>\\<^sub>1[a, b], \\<d>[\\<pp>\\<^sub>0[a, b]]\\<rangle>\\<rangle> =\n  \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n  \\<langle>\\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                (\\<s>[a, b] \\<otimes> b) \\<cdot>\n                                \\<langle>\\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>, \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n    (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n    (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n    \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b]) =\n    \\<d>[a \\<otimes> b]", "have \"... = \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot> \\<langle>\\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot> \\<langle>\\<s>[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    \\<langle>\\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                  (\\<s>[a, b] \\<otimes> b) \\<cdot>\n                                  \\<langle>\\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>, \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle> =\n    \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    \\<langle>\\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                  \\<langle>\\<s>[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle>", "using assms prod_tuple comp_arr_dom comp_cod_arr"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  \\<lbrakk>span ?f ?g; seq ?h ?f; seq ?k ?g\\<rbrakk>\n  \\<Longrightarrow> (?h \\<otimes> ?k) \\<cdot> \\<langle>?f, ?g\\<rangle> =\n                    \\<langle>?h \\<cdot> ?f, ?k \\<cdot> ?g\\<rangle>\n  \\<lbrakk>arr ?f; local.dom ?f = ?a\\<rbrakk>\n  \\<Longrightarrow> ?f \\<cdot> ?a = ?f\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    \\<langle>\\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                  (\\<s>[a, b] \\<otimes> b) \\<cdot>\n                                  \\<langle>\\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>, \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle> =\n    \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    \\<langle>\\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                  \\<langle>\\<s>[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle>", "by simp"], ["proof (state)\nthis:\n  \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n  \\<langle>\\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                (\\<s>[a, b] \\<otimes> b) \\<cdot>\n                                \\<langle>\\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>, \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle> =\n  \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n  \\<langle>\\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                \\<langle>\\<s>[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n    (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n    (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n    \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b]) =\n    \\<d>[a \\<otimes> b]", "also"], ["proof (state)\nthis:\n  \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n  \\<langle>\\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                (\\<s>[a, b] \\<otimes> b) \\<cdot>\n                                \\<langle>\\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>, \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle> =\n  \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n  \\<langle>\\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                \\<langle>\\<s>[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n    (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n    (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n    \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b]) =\n    \\<d>[a \\<otimes> b]", "have \"... = \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot> \\<langle>\\<pp>\\<^sub>1[a, b], \\<langle>\\<pp>\\<^sub>0[a, b], \\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle>\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    \\<langle>\\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                  \\<langle>\\<s>[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle> =\n    \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    \\<langle>\\<pp>\\<^sub>1[a, b], \\<langle>\\<pp>\\<^sub>0[a, b], \\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle>\\<rangle>", "using assms comp_assoc_tuple(1)"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  \\<lbrakk>\\<guillemotleft>?f0.0 : ?a \\<rightarrow> ?b0.0\\<guillemotright>;\n   \\<guillemotleft>?f1.0 : ?a \\<rightarrow> ?b1.0\\<guillemotright>;\n   \\<guillemotleft>?f2.0 : ?a \\<rightarrow> ?b2.0\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> \\<a>[?b0.0, ?b1.0, ?b2.0] \\<cdot>\n                    \\<langle>\\<langle>?f0.0, ?f1.0\\<rangle>, ?f2.0\\<rangle> =\n                    \\<langle>?f0.0, \\<langle>?f1.0, ?f2.0\\<rangle>\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    \\<langle>\\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                  \\<langle>\\<s>[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle> =\n    \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    \\<langle>\\<pp>\\<^sub>1[a, b], \\<langle>\\<pp>\\<^sub>0[a, b], \\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle>\\<rangle>", "by (metis sym_def pr_in_hom)"], ["proof (state)\nthis:\n  \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n  \\<langle>\\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                \\<langle>\\<s>[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle> =\n  \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n  \\<langle>\\<pp>\\<^sub>1[a, b], \\<langle>\\<pp>\\<^sub>0[a, b], \\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle>\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n    (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n    (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n    \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b]) =\n    \\<d>[a \\<otimes> b]", "also"], ["proof (state)\nthis:\n  \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n  \\<langle>\\<pp>\\<^sub>1[a, b], \\<a>[b, a, b] \\<cdot>\n                                \\<langle>\\<s>[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle> =\n  \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n  \\<langle>\\<pp>\\<^sub>1[a, b], \\<langle>\\<pp>\\<^sub>0[a, b], \\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle>\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n    (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n    (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n    \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b]) =\n    \\<d>[a \\<otimes> b]", "have \"... = \\<langle>\\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>, \\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    \\<langle>\\<pp>\\<^sub>1[a, b], \\<langle>\\<pp>\\<^sub>0[a, b], \\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle>\\<rangle> =\n    \\<d>[\\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>]", "using assms comp_assoc_tuple(2)"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  \\<lbrakk>\\<guillemotleft>?f0.0 : ?a \\<rightarrow> ?b0.0\\<guillemotright>;\n   \\<guillemotleft>?f1.0 : ?a \\<rightarrow> ?b1.0\\<guillemotright>;\n   \\<guillemotleft>?f2.0 : ?a \\<rightarrow> ?b2.0\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> \\<a>\\<^sup>-\\<^sup>1[?b0.0, ?b1.0, ?b2.0] \\<cdot>\n                    \\<langle>?f0.0, \\<langle>?f1.0, ?f2.0\\<rangle>\\<rangle> =\n                    \\<langle>\\<langle>?f0.0, ?f1.0\\<rangle>, ?f2.0\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    \\<langle>\\<pp>\\<^sub>1[a, b], \\<langle>\\<pp>\\<^sub>0[a, b], \\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle>\\<rangle> =\n    \\<d>[\\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>]", "by force"], ["proof (state)\nthis:\n  \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n  \\<langle>\\<pp>\\<^sub>1[a, b], \\<langle>\\<pp>\\<^sub>0[a, b], \\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle>\\<rangle> =\n  \\<d>[\\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>]\n\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n    (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n    (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n    \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b]) =\n    \\<d>[a \\<otimes> b]", "also"], ["proof (state)\nthis:\n  \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n  \\<langle>\\<pp>\\<^sub>1[a, b], \\<langle>\\<pp>\\<^sub>0[a, b], \\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>\\<rangle>\\<rangle> =\n  \\<d>[\\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>]\n\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n    (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n    (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n    \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b]) =\n    \\<d>[a \\<otimes> b]", "have \"... = \\<d>[a \\<otimes> b]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<d>[\\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>] =\n    \\<d>[a \\<otimes> b]", "using assms"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n\ngoal (1 subgoal):\n 1. \\<d>[\\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>] =\n    \\<d>[a \\<otimes> b]", "by simp"], ["proof (state)\nthis:\n  \\<d>[\\<langle>\\<pp>\\<^sub>1[a, b], \\<pp>\\<^sub>0[a, b]\\<rangle>] =\n  \\<d>[a \\<otimes> b]\n\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n    (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n    (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n    \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b]) =\n    \\<d>[a \\<otimes> b]", "finally"], ["proof (chain)\npicking this:\n  \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n  (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n  (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n  (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n  \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b]) =\n  \\<d>[a \\<otimes> b]", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n  (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n  (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n  (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n  \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b]) =\n  \\<d>[a \\<otimes> b]\n\ngoal (1 subgoal):\n 1. \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n    (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n    (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n    \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b]) =\n    \\<d>[a \\<otimes> b]", "by simp"], ["proof (state)\nthis:\n  \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n  (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n  (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n  (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n  \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b]) =\n  \\<d>[a \\<otimes> b]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n  (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n  (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n  (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n  \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b]) =\n  \\<d>[a \\<otimes> b]\n\ngoal (2 subgoals):\n 1. \\<pp>\\<^sub>0[a \\<otimes> b, a \\<otimes> b] \\<cdot>\n    \\<d>[a \\<otimes> b] =\n    \\<pp>\\<^sub>0[a \\<otimes> b, a \\<otimes> b] \\<cdot>\n    \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n    (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n    (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n    \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b])\n 2. \\<pp>\\<^sub>1[a \\<otimes> b, a \\<otimes> b] \\<cdot>\n    \\<d>[a \\<otimes> b] =\n    \\<pp>\\<^sub>1[a \\<otimes> b, a \\<otimes> b] \\<cdot>\n    \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n    (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n    (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n    \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b])", "show \"\\<pp>\\<^sub>0[a \\<otimes> b, a \\<otimes> b] \\<cdot> \\<d>[a \\<otimes> b]\n              = \\<pp>\\<^sub>0[a \\<otimes> b, a \\<otimes> b] \\<cdot>\n                \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot> (a \\<otimes> \\<a>[b, a, b]) \\<cdot> (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n                (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot> \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a \\<otimes> b, a \\<otimes> b] \\<cdot>\n    \\<d>[a \\<otimes> b] =\n    \\<pp>\\<^sub>0[a \\<otimes> b, a \\<otimes> b] \\<cdot>\n    \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n    (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n    (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n    \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b])", "using assms 1"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n  (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n  (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n  (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n  \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b]) =\n  \\<d>[a \\<otimes> b]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>0[a \\<otimes> b, a \\<otimes> b] \\<cdot>\n    \\<d>[a \\<otimes> b] =\n    \\<pp>\\<^sub>0[a \\<otimes> b, a \\<otimes> b] \\<cdot>\n    \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n    (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n    (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n    \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b])", "by force"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>0[a \\<otimes> b, a \\<otimes> b] \\<cdot> \\<d>[a \\<otimes> b] =\n  \\<pp>\\<^sub>0[a \\<otimes> b, a \\<otimes> b] \\<cdot>\n  \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n  (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n  (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n  (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n  \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b])\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a \\<otimes> b, a \\<otimes> b] \\<cdot>\n    \\<d>[a \\<otimes> b] =\n    \\<pp>\\<^sub>1[a \\<otimes> b, a \\<otimes> b] \\<cdot>\n    \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n    (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n    (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n    \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b])", "show \"\\<pp>\\<^sub>1[a \\<otimes> b, a \\<otimes> b] \\<cdot> \\<d>[a \\<otimes> b]\n              = \\<pp>\\<^sub>1[a \\<otimes> b, a \\<otimes> b] \\<cdot>\n                \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot> (a \\<otimes> \\<a>[b, a, b]) \\<cdot> (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n                (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot> \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a \\<otimes> b, a \\<otimes> b] \\<cdot>\n    \\<d>[a \\<otimes> b] =\n    \\<pp>\\<^sub>1[a \\<otimes> b, a \\<otimes> b] \\<cdot>\n    \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n    (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n    (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n    \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b])", "using assms 1"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n  (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n  (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n  (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n  \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b]) =\n  \\<d>[a \\<otimes> b]\n\ngoal (1 subgoal):\n 1. \\<pp>\\<^sub>1[a \\<otimes> b, a \\<otimes> b] \\<cdot>\n    \\<d>[a \\<otimes> b] =\n    \\<pp>\\<^sub>1[a \\<otimes> b, a \\<otimes> b] \\<cdot>\n    \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n    (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n    (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n    (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n    \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b])", "by force"], ["proof (state)\nthis:\n  \\<pp>\\<^sub>1[a \\<otimes> b, a \\<otimes> b] \\<cdot> \\<d>[a \\<otimes> b] =\n  \\<pp>\\<^sub>1[a \\<otimes> b, a \\<otimes> b] \\<cdot>\n  \\<a>\\<^sup>-\\<^sup>1[a, b, a \\<otimes> b] \\<cdot>\n  (a \\<otimes> \\<a>[b, a, b]) \\<cdot>\n  (a \\<otimes> \\<sigma> (a, b) \\<otimes> b) \\<cdot>\n  (a \\<otimes> \\<a>\\<^sup>-\\<^sup>1[a, b, b]) \\<cdot>\n  \\<a>[a, a, b \\<otimes> b] \\<cdot> (\\<d>[a] \\<otimes> \\<d>[b])\n\ngoal:\nNo subgoals!", "qed"], ["", "(* TODO: Not sure if the remaining facts are useful. *)"], ["", "lemma \\<iota>_eq_trm:\n    shows \"\\<iota> = \\<t>[\\<one> \\<otimes> \\<one>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<iota> = \\<t>[\\<one> \\<otimes> \\<one>]", "proof (intro terminal_arr_unique)"], ["proof (state)\ngoal (3 subgoals):\n 1. par \\<iota> \\<t>[\\<one> \\<otimes> \\<one>]\n 2. terminal_arr \\<iota>\n 3. terminal_arr \\<t>[\\<one> \\<otimes> \\<one>]", "show \"par \\<iota> \\<t>[\\<one> \\<otimes> \\<one>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. par \\<iota> \\<t>[\\<one> \\<otimes> \\<one>]", "by (simp add: ide_one trm_one trm_tensor)"], ["proof (state)\nthis:\n  par \\<iota> \\<t>[\\<one> \\<otimes> \\<one>]\n\ngoal (2 subgoals):\n 1. terminal_arr \\<iota>\n 2. terminal_arr \\<t>[\\<one> \\<otimes> \\<one>]", "show \"terminal_arr \\<t>[\\<one> \\<otimes> \\<one>]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminal_arr \\<t>[\\<one> \\<otimes> \\<one>]", "using ide_one \\<iota>_is_terminal_arr \\<open>par \\<iota> \\<t>[\\<one> \\<otimes> \\<one>]\\<close>"], ["proof (prove)\nusing this:\n  ide \\<one>\n  terminal_arr \\<iota>\n  par \\<iota> \\<t>[\\<one> \\<otimes> \\<one>]\n\ngoal (1 subgoal):\n 1. terminal_arr \\<t>[\\<one> \\<otimes> \\<one>]", "by auto"], ["proof (state)\nthis:\n  terminal_arr \\<t>[\\<one> \\<otimes> \\<one>]\n\ngoal (1 subgoal):\n 1. terminal_arr \\<iota>", "show \"terminal_arr \\<iota>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminal_arr \\<iota>", "using \\<iota>_is_terminal_arr"], ["proof (prove)\nusing this:\n  terminal_arr \\<iota>\n\ngoal (1 subgoal):\n 1. terminal_arr \\<iota>", "by blast"], ["proof (state)\nthis:\n  terminal_arr \\<iota>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma terminal_tensor_one_one:\n    shows \"terminal (\\<one> \\<otimes> \\<one>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminal (\\<one> \\<otimes> \\<one>)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ide (\\<one> \\<otimes> \\<one>)\n 2. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<exists>!f.\n          \\<guillemotleft>f : a \\<rightarrow> \\<one> \\<otimes>\n        \\<one>\\<guillemotright>", "show \"ide (\\<one> \\<otimes> \\<one>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide (\\<one> \\<otimes> \\<one>)", "using ide_one"], ["proof (prove)\nusing this:\n  ide \\<one>\n\ngoal (1 subgoal):\n 1. ide (\\<one> \\<otimes> \\<one>)", "by simp"], ["proof (state)\nthis:\n  ide (\\<one> \\<otimes> \\<one>)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<exists>!f.\n          \\<guillemotleft>f : a \\<rightarrow> \\<one> \\<otimes>\n        \\<one>\\<guillemotright>", "show \"\\<And>a. ide a \\<Longrightarrow> \\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> \\<one> \\<otimes> \\<one>\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<exists>!f.\n          \\<guillemotleft>f : a \\<rightarrow> \\<one> \\<otimes>\n        \\<one>\\<guillemotright>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<exists>!f.\n          \\<guillemotleft>f : a \\<rightarrow> \\<one> \\<otimes>\n        \\<one>\\<guillemotright>", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<exists>!f.\n          \\<guillemotleft>f : a \\<rightarrow> \\<one> \\<otimes>\n        \\<one>\\<guillemotright>", "assume a: \"ide a\""], ["proof (state)\nthis:\n  ide a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<exists>!f.\n          \\<guillemotleft>f : a \\<rightarrow> \\<one> \\<otimes>\n        \\<one>\\<guillemotright>", "show \"\\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> \\<one> \\<otimes> \\<one>\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!f.\n       \\<guillemotleft>f : a \\<rightarrow> \\<one> \\<otimes>\n     \\<one>\\<guillemotright>", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : a \\<rightarrow> \\<one> \\<otimes>\n   \\<one>\\<guillemotright>\n 2. \\<And>f.\n       \\<guillemotleft>f : a \\<rightarrow> \\<one> \\<otimes>\n     \\<one>\\<guillemotright> \\<Longrightarrow>\n       f = ?a", "show \"\\<guillemotleft>inv \\<iota> \\<cdot> \\<t>[a] : a \\<rightarrow> \\<one> \\<otimes> \\<one>\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>local.inv \\<iota> \\<cdot>\n                    \\<t>[a] : a \\<rightarrow> \\<one> \\<otimes>\n        \\<one>\\<guillemotright>", "using a ide_one inverse_arrows_\\<iota> inverse_unique trm_in_hom"], ["proof (prove)\nusing this:\n  ide a\n  ide \\<one>\n  inverse_arrows \\<iota> \\<d>[\\<one>]\n  inverse_arrows ?f ?g \\<Longrightarrow> local.inv ?f = ?g\n  ide ?a \\<Longrightarrow>\n  \\<guillemotleft>\\<t>[?a] : ?a \\<rightarrow> \\<one>\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>local.inv \\<iota> \\<cdot>\n                    \\<t>[a] : a \\<rightarrow> \\<one> \\<otimes>\n        \\<one>\\<guillemotright>", "by fastforce"], ["proof (state)\nthis:\n  \\<guillemotleft>local.inv \\<iota> \\<cdot>\n                  \\<t>[a] : a \\<rightarrow> \\<one> \\<otimes>\n      \\<one>\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<guillemotleft>f : a \\<rightarrow> \\<one> \\<otimes>\n     \\<one>\\<guillemotright> \\<Longrightarrow>\n       f = local.inv \\<iota> \\<cdot> \\<t>[a]", "show \"\\<And>f. \\<guillemotleft>f : a \\<rightarrow> \\<one> \\<otimes> \\<one>\\<guillemotright> \\<Longrightarrow> f = inv \\<iota> \\<cdot> \\<t>[a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<guillemotleft>f : a \\<rightarrow> \\<one> \\<otimes>\n     \\<one>\\<guillemotright> \\<Longrightarrow>\n       f = local.inv \\<iota> \\<cdot> \\<t>[a]", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<guillemotleft>f : a \\<rightarrow> \\<one> \\<otimes>\n     \\<one>\\<guillemotright> \\<Longrightarrow>\n       f = local.inv \\<iota> \\<cdot> \\<t>[a]", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<guillemotleft>f : a \\<rightarrow> \\<one> \\<otimes>\n     \\<one>\\<guillemotright> \\<Longrightarrow>\n       f = local.inv \\<iota> \\<cdot> \\<t>[a]", "assume f: \"\\<guillemotleft>f : a \\<rightarrow> \\<one> \\<otimes> \\<one>\\<guillemotright>\""], ["proof (state)\nthis:\n  \\<guillemotleft>f : a \\<rightarrow> \\<one> \\<otimes>\n\\<one>\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<guillemotleft>f : a \\<rightarrow> \\<one> \\<otimes>\n     \\<one>\\<guillemotright> \\<Longrightarrow>\n       f = local.inv \\<iota> \\<cdot> \\<t>[a]", "have \"\\<iota> \\<cdot> f = \\<t>[a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<iota> \\<cdot> f = \\<t>[a]", "proof (intro terminal_arr_unique)"], ["proof (state)\ngoal (3 subgoals):\n 1. par (\\<iota> \\<cdot> f) \\<t>[a]\n 2. terminal_arr (\\<iota> \\<cdot> f)\n 3. terminal_arr \\<t>[a]", "show \"par (\\<iota> \\<cdot> f) \\<t>[a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. par (\\<iota> \\<cdot> f) \\<t>[a]", "using a f"], ["proof (prove)\nusing this:\n  ide a\n  \\<guillemotleft>f : a \\<rightarrow> \\<one> \\<otimes>\n\\<one>\\<guillemotright>\n\ngoal (1 subgoal):\n 1. par (\\<iota> \\<cdot> f) \\<t>[a]", "by (metis \\<iota>_is_iso \\<iota>_is_terminal_arr \\<open>\\<guillemotleft>inv \\<iota> \\<cdot> \\<t>[a] : a \\<rightarrow> \\<one> \\<otimes> \\<one>\\<guillemotright>\\<close>\n                    cod_comp dom_comp dom_inv ide_one in_homE pr_simps(2-3) seqE seqI)"], ["proof (state)\nthis:\n  par (\\<iota> \\<cdot> f) \\<t>[a]\n\ngoal (2 subgoals):\n 1. terminal_arr (\\<iota> \\<cdot> f)\n 2. terminal_arr \\<t>[a]", "show \"terminal_arr (\\<iota> \\<cdot> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminal_arr (\\<iota> \\<cdot> f)", "using a f \\<iota>_is_terminal_arr cod_comp"], ["proof (prove)\nusing this:\n  ide a\n  \\<guillemotleft>f : a \\<rightarrow> \\<one> \\<otimes>\n\\<one>\\<guillemotright>\n  terminal_arr \\<iota>\n  seq ?g ?f \\<Longrightarrow> cod (?g \\<cdot> ?f) = cod ?g\n\ngoal (1 subgoal):\n 1. terminal_arr (\\<iota> \\<cdot> f)", "by force"], ["proof (state)\nthis:\n  terminal_arr (\\<iota> \\<cdot> f)\n\ngoal (1 subgoal):\n 1. terminal_arr \\<t>[a]", "show \"terminal_arr \\<t>[a]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminal_arr \\<t>[a]", "using a \\<open>par (\\<iota> \\<cdot> f) \\<t>[a]\\<close> \\<open>terminal_arr (\\<iota> \\<cdot> f)\\<close>"], ["proof (prove)\nusing this:\n  ide a\n  par (\\<iota> \\<cdot> f) \\<t>[a]\n  terminal_arr (\\<iota> \\<cdot> f)\n\ngoal (1 subgoal):\n 1. terminal_arr \\<t>[a]", "by auto"], ["proof (state)\nthis:\n  terminal_arr \\<t>[a]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<iota> \\<cdot> f = \\<t>[a]\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<guillemotleft>f : a \\<rightarrow> \\<one> \\<otimes>\n     \\<one>\\<guillemotright> \\<Longrightarrow>\n       f = local.inv \\<iota> \\<cdot> \\<t>[a]", "thus \"f = inv \\<iota> \\<cdot> \\<t>[a]\""], ["proof (prove)\nusing this:\n  \\<iota> \\<cdot> f = \\<t>[a]\n\ngoal (1 subgoal):\n 1. f = local.inv \\<iota> \\<cdot> \\<t>[a]", "using a f \\<iota>_is_iso invert_side_of_triangle(1)\n                    \\<open>\\<guillemotleft>inv \\<iota> \\<cdot> \\<t>[a] : a \\<rightarrow> \\<one> \\<otimes> \\<one>\\<guillemotright>\\<close>"], ["proof (prove)\nusing this:\n  \\<iota> \\<cdot> f = \\<t>[a]\n  ide a\n  \\<guillemotleft>f : a \\<rightarrow> \\<one> \\<otimes>\n\\<one>\\<guillemotright>\n  local.iso \\<iota>\n  \\<lbrakk>arr ?h; ?f \\<cdot> ?g = ?h; local.iso ?f\\<rbrakk>\n  \\<Longrightarrow> seq (local.inv ?f) ?h \\<and>\n                    ?g = local.inv ?f \\<cdot> ?h\n  \\<guillemotleft>local.inv \\<iota> \\<cdot>\n                  \\<t>[a] : a \\<rightarrow> \\<one> \\<otimes>\n      \\<one>\\<guillemotright>\n\ngoal (1 subgoal):\n 1. f = local.inv \\<iota> \\<cdot> \\<t>[a]", "by blast"], ["proof (state)\nthis:\n  f = local.inv \\<iota> \\<cdot> \\<t>[a]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<guillemotleft>?f4 : a \\<rightarrow> \\<one> \\<otimes>\n  \\<one>\\<guillemotright> \\<Longrightarrow>\n  ?f4 = local.inv \\<iota> \\<cdot> \\<t>[a]\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!f.\n     \\<guillemotleft>f : a \\<rightarrow> \\<one> \\<otimes>\n   \\<one>\\<guillemotright>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ide ?a4 \\<Longrightarrow>\n  \\<exists>!f.\n     \\<guillemotleft>f : ?a4 \\<rightarrow> \\<one> \\<otimes>\n     \\<one>\\<guillemotright>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "section \"Category with Finite Products\""], ["", "text \\<open>\n    In this last section, we show that the notion ``cartesian category'', which we defined\n    to be a category with binary products and terminal object, coincides with the notion\n    ``category with finite products''.  Due to the inability to quantify over types in HOL,\n    we content ourselves with defining the latter notion as \"has \\<open>I\\<close>-indexed products\n    for every finite set \\<open>I\\<close> of natural numbers.\"  We can transfer this property to finite\n    sets at other types using the fact that products are preserved under bijections of\n    the index sets.\n  \\<close>"], ["", "locale category_with_finite_products =\n    category C\n  for C :: \"'c comp\" +\n  assumes has_finite_products: \"finite (I :: nat set) \\<Longrightarrow> has_products I\"\n  begin"], ["", "lemma has_finite_products':\n    assumes \"I \\<noteq> UNIV\"\n    shows \"finite I \\<Longrightarrow> has_products I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite I \\<Longrightarrow> has_products I", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. finite I \\<Longrightarrow> has_products I", "assume I: \"finite I\""], ["proof (state)\nthis:\n  finite I\n\ngoal (1 subgoal):\n 1. finite I \\<Longrightarrow> has_products I", "obtain n \\<phi> where \\<phi>: \"bij_betw \\<phi> {k. k < (n :: nat)} I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<phi> n.\n        bij_betw \\<phi> {k. k < n} I \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using I finite_imp_nat_seg_image_inj_on inj_on_imp_bij_betw"], ["proof (prove)\nusing this:\n  finite I\n  finite ?A \\<Longrightarrow>\n  \\<exists>n f. ?A = f ` {i. i < n} \\<and> inj_on f {i. i < n}\n  inj_on ?f ?A \\<Longrightarrow> bij_betw ?f ?A (?f ` ?A)\n\ngoal (1 subgoal):\n 1. (\\<And>\\<phi> n.\n        bij_betw \\<phi> {k. k < n} I \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  bij_betw \\<phi> {k. k < n} I\n\ngoal (1 subgoal):\n 1. finite I \\<Longrightarrow> has_products I", "show \"has_products I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_products I", "using assms(1) \\<phi> has_finite_products has_products_preserved_by_bijection\n              category_with_finite_products.has_finite_products"], ["proof (prove)\nusing this:\n  I \\<noteq> UNIV\n  bij_betw \\<phi> {k. k < n} I\n  finite ?I \\<Longrightarrow> has_products ?I\n  \\<lbrakk>has_products ?I; bij_betw ?\\<phi> ?I ?I';\n   ?I' \\<noteq> UNIV\\<rbrakk>\n  \\<Longrightarrow> has_products ?I'\n  \\<lbrakk>category_with_finite_products ?C; finite ?I\\<rbrakk>\n  \\<Longrightarrow> category.has_products ?C ?I\n\ngoal (1 subgoal):\n 1. has_products I", "by blast"], ["proof (state)\nthis:\n  has_products I\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma (in category) has_binary_products_if:\n  assumes \"has_products ({0, 1} :: nat set)\"\n  shows \"has_binary_products\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_binary_products", "proof (unfold has_binary_products_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>a0 a1.\n       ide a0 \\<and> ide a1 \\<longrightarrow>\n       (\\<exists>p0. Ex (has_as_binary_product a0 a1 p0))", "show \"\\<forall>a0 a1. ide a0 \\<and> ide a1 \\<longrightarrow> (\\<exists>p0 p1. has_as_binary_product a0 a1 p0 p1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>a0 a1.\n       ide a0 \\<and> ide a1 \\<longrightarrow>\n       (\\<exists>p0 p1. has_as_binary_product a0 a1 p0 p1)", "proof (intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a0 a1.\n       ide a0 \\<and> ide a1 \\<Longrightarrow>\n       \\<exists>p0 p1. has_as_binary_product a0 a1 p0 p1", "fix a0 a1"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a0 a1.\n       ide a0 \\<and> ide a1 \\<Longrightarrow>\n       \\<exists>p0 p1. has_as_binary_product a0 a1 p0 p1", "assume 1: \"ide a0 \\<and> ide a1\""], ["proof (state)\nthis:\n  ide a0 \\<and> ide a1\n\ngoal (1 subgoal):\n 1. \\<And>a0 a1.\n       ide a0 \\<and> ide a1 \\<Longrightarrow>\n       \\<exists>p0 p1. has_as_binary_product a0 a1 p0 p1", "show \"\\<exists>p0 p1. has_as_binary_product a0 a1 p0 p1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p0 p1. has_as_binary_product a0 a1 p0 p1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p0 p1. has_as_binary_product a0 a1 p0 p1", "interpret J: binary_product_shape"], ["proof (prove)\ngoal:\nNo subgoals!", "by unfold_locales"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p0 p1. has_as_binary_product a0 a1 p0 p1", "interpret D: binary_product_diagram C a0 a1"], ["proof (prove)\ngoal (1 subgoal):\n 1. binary_product_diagram (\\<cdot>) a0 a1", "using 1"], ["proof (prove)\nusing this:\n  ide a0 \\<and> ide a1\n\ngoal (1 subgoal):\n 1. binary_product_diagram (\\<cdot>) a0 a1", "by unfold_locales auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p0 p1. has_as_binary_product a0 a1 p0 p1", "interpret discrete_diagram J.comp C D.map"], ["proof (prove)\ngoal (1 subgoal):\n 1. discrete_diagram J.COMP (\\<cdot>) D.map", "using J.is_discrete"], ["proof (prove)\nusing this:\n  J.ide ?f = J.arr ?f\n\ngoal (1 subgoal):\n 1. discrete_diagram J.COMP (\\<cdot>) D.map", "by unfold_locales auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p0 p1. has_as_binary_product a0 a1 p0 p1", "show \"\\<exists>p0 p1. has_as_binary_product a0 a1 p0 p1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p0 p1. has_as_binary_product a0 a1 p0 p1", "proof (unfold has_as_binary_product_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p0 p1.\n       ide a0 \\<and> ide a1 \\<and> D.has_as_binary_product p0 p1", "text \\<open>\n            Here we have to work around the fact that \\<open>has_finite_products\\<close> is defined\n            in terms of @{typ \"nat set\"}, whereas \\<open>has_as_binary_product\\<close> is defined\n            in terms of \\<open>J.arr set\\<close>.\n          \\<close>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p0 p1.\n       ide a0 \\<and> ide a1 \\<and> D.has_as_binary_product p0 p1", "let ?\\<phi> = \"(\\<lambda>x :: nat. if x = 0 then J.FF else J.TT)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p0 p1.\n       ide a0 \\<and> ide a1 \\<and> D.has_as_binary_product p0 p1", "let ?\\<psi> = \"\\<lambda>j. if j = J.FF then 0 else 1\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p0 p1.\n       ide a0 \\<and> ide a1 \\<and> D.has_as_binary_product p0 p1", "have \"bij_betw ?\\<phi> ({0, 1} :: nat set) {J.FF, J.TT}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (\\<lambda>x. if x = 0 then J.MkIde False else J.MkIde True)\n     {0, 1} {J.MkIde False, J.MkIde True}", "using bij_betwI [of ?\\<phi> \"{0, 1} :: nat set\" \"{J.FF, J.TT}\" ?\\<psi>]"], ["proof (prove)\nusing this:\n  \\<lbrakk>(\\<lambda>x. if x = 0 then J.MkIde False else J.MkIde True)\n           \\<in> {0, 1} \\<rightarrow> {J.MkIde False, J.MkIde True};\n   (\\<lambda>j. if j = J.MkIde False then 0 else 1)\n   \\<in> {J.MkIde False, J.MkIde True} \\<rightarrow> {0, 1};\n   \\<And>x.\n      x \\<in> {0, 1} \\<Longrightarrow>\n      (if (if x = 0 then J.MkIde False else J.MkIde True) = J.MkIde False\n       then 0 else 1) =\n      x;\n   \\<And>y.\n      y \\<in> {J.MkIde False, J.MkIde True} \\<Longrightarrow>\n      (if (if y = J.MkIde False then 0 else 1) = 0 then J.MkIde False\n       else J.MkIde True) =\n      y\\<rbrakk>\n  \\<Longrightarrow> bij_betw\n                     (\\<lambda>x.\n                         if x = 0 then J.MkIde False else J.MkIde True)\n                     {0, 1} {J.MkIde False, J.MkIde True}\n\ngoal (1 subgoal):\n 1. bij_betw (\\<lambda>x. if x = 0 then J.MkIde False else J.MkIde True)\n     {0, 1} {J.MkIde False, J.MkIde True}", "by fastforce"], ["proof (state)\nthis:\n  bij_betw (\\<lambda>x. if x = 0 then J.MkIde False else J.MkIde True)\n   {0, 1} {J.MkIde False, J.MkIde True}\n\ngoal (1 subgoal):\n 1. \\<exists>p0 p1.\n       ide a0 \\<and> ide a1 \\<and> D.has_as_binary_product p0 p1", "hence \"has_products {J.FF, J.TT}\""], ["proof (prove)\nusing this:\n  bij_betw (\\<lambda>x. if x = 0 then J.MkIde False else J.MkIde True)\n   {0, 1} {J.MkIde False, J.MkIde True}\n\ngoal (1 subgoal):\n 1. has_products {J.MkIde False, J.MkIde True}", "using assms has_products_def [of \"{J.FF, J.TT}\"]\n                  has_products_preserved_by_bijection\n                    [of \"{0, 1} :: nat set\" ?\\<phi> \"{J.FF, J.TT}\"]"], ["proof (prove)\nusing this:\n  bij_betw (\\<lambda>x. if x = 0 then J.MkIde False else J.MkIde True)\n   {0, 1} {J.MkIde False, J.MkIde True}\n  has_products {0, 1}\n  has_products {J.MkIde False, J.MkIde True} \\<equiv>\n  {J.MkIde False, J.MkIde True} \\<noteq> UNIV \\<and>\n  (\\<forall>J D.\n      discrete_diagram J (\\<cdot>) D \\<and>\n      Collect (partial_magma.arr J) =\n      {J.MkIde False, J.MkIde True} \\<longrightarrow>\n      (\\<exists>a. has_as_product J D a))\n  \\<lbrakk>has_products {0, 1};\n   bij_betw (\\<lambda>x. if x = 0 then J.MkIde False else J.MkIde True)\n    {0, 1} {J.MkIde False, J.MkIde True};\n   {J.MkIde False, J.MkIde True} \\<noteq> UNIV\\<rbrakk>\n  \\<Longrightarrow> has_products {J.MkIde False, J.MkIde True}\n\ngoal (1 subgoal):\n 1. has_products {J.MkIde False, J.MkIde True}", "by blast"], ["proof (state)\nthis:\n  has_products {J.MkIde False, J.MkIde True}\n\ngoal (1 subgoal):\n 1. \\<exists>p0 p1.\n       ide a0 \\<and> ide a1 \\<and> D.has_as_binary_product p0 p1", "hence \"\\<exists>a. has_as_product J.comp D.map a\""], ["proof (prove)\nusing this:\n  has_products {J.MkIde False, J.MkIde True}\n\ngoal (1 subgoal):\n 1. \\<exists>a. has_as_product J.COMP D.map a", "using has_products_def [of \"{J.FF, J.TT}\"]\n                  discrete_diagram_axioms J.arr_char"], ["proof (prove)\nusing this:\n  has_products {J.MkIde False, J.MkIde True}\n  has_products {J.MkIde False, J.MkIde True} \\<equiv>\n  {J.MkIde False, J.MkIde True} \\<noteq> UNIV \\<and>\n  (\\<forall>J D.\n      discrete_diagram J (\\<cdot>) D \\<and>\n      Collect (partial_magma.arr J) =\n      {J.MkIde False, J.MkIde True} \\<longrightarrow>\n      (\\<exists>a. has_as_product J D a))\n  discrete_diagram J.COMP (\\<cdot>) D.map\n  J.arr ?f = (?f = J.MkIde False \\<or> ?f = J.MkIde True)\n\ngoal (1 subgoal):\n 1. \\<exists>a. has_as_product J.COMP D.map a", "by blast"], ["proof (state)\nthis:\n  \\<exists>a. has_as_product J.COMP D.map a\n\ngoal (1 subgoal):\n 1. \\<exists>p0 p1.\n       ide a0 \\<and> ide a1 \\<and> D.has_as_binary_product p0 p1", "hence \"\\<exists>a \\<pi>. product_cone J.comp C D.map a \\<pi>\""], ["proof (prove)\nusing this:\n  \\<exists>a. has_as_product J.COMP D.map a\n\ngoal (1 subgoal):\n 1. \\<exists>a \\<pi>. product_cone J.COMP (\\<cdot>) D.map a \\<pi>", "using has_as_product_def"], ["proof (prove)\nusing this:\n  \\<exists>a. has_as_product J.COMP D.map a\n  has_as_product ?J ?D ?a \\<equiv>\n  \\<exists>\\<pi>. product_cone ?J (\\<cdot>) ?D ?a \\<pi>\n\ngoal (1 subgoal):\n 1. \\<exists>a \\<pi>. product_cone J.COMP (\\<cdot>) D.map a \\<pi>", "by blast"], ["proof (state)\nthis:\n  \\<exists>a \\<pi>. product_cone J.COMP (\\<cdot>) D.map a \\<pi>\n\ngoal (1 subgoal):\n 1. \\<exists>p0 p1.\n       ide a0 \\<and> ide a1 \\<and> D.has_as_binary_product p0 p1", "hence 2: \"\\<exists>a \\<pi>. D.limit_cone a \\<pi>\""], ["proof (prove)\nusing this:\n  \\<exists>a \\<pi>. product_cone J.COMP (\\<cdot>) D.map a \\<pi>\n\ngoal (1 subgoal):\n 1. D.has_limit", "unfolding product_cone_def"], ["proof (prove)\nusing this:\n  \\<exists>a \\<pi>.\n     (category J.COMP \\<and> category (\\<cdot>)) \\<and>\n     discrete_diagram J.COMP (\\<cdot>) D.map \\<and> D.limit_cone a \\<pi>\n\ngoal (1 subgoal):\n 1. D.has_limit", "by simp"], ["proof (state)\nthis:\n  D.has_limit\n\ngoal (1 subgoal):\n 1. \\<exists>p0 p1.\n       ide a0 \\<and> ide a1 \\<and> D.has_as_binary_product p0 p1", "obtain a \\<pi> where \\<pi>: \"D.limit_cone a \\<pi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a \\<pi>.\n        D.limit_cone a \\<pi> \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using 2"], ["proof (prove)\nusing this:\n  D.has_limit\n\ngoal (1 subgoal):\n 1. (\\<And>a \\<pi>.\n        D.limit_cone a \\<pi> \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  D.limit_cone a \\<pi>\n\ngoal (1 subgoal):\n 1. \\<exists>p0 p1.\n       ide a0 \\<and> ide a1 \\<and> D.has_as_binary_product p0 p1", "interpret \\<pi>: limit_cone J.comp C D.map a \\<pi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. D.limit_cone a \\<pi>", "using \\<pi>"], ["proof (prove)\nusing this:\n  D.limit_cone a \\<pi>\n\ngoal (1 subgoal):\n 1. D.limit_cone a \\<pi>", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p0 p1.\n       ide a0 \\<and> ide a1 \\<and> D.has_as_binary_product p0 p1", "have \"\\<pi> = D.mkCone (\\<pi> J.FF) (\\<pi> J.TT)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi> = D.mkCone (\\<pi> (J.MkIde False)) (\\<pi> (J.MkIde True))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<pi> = D.mkCone (\\<pi> (J.MkIde False)) (\\<pi> (J.MkIde True))", "have \"\\<And>a. J.ide a \\<Longrightarrow> \\<pi> a = D.mkCone (\\<pi> J.FF) (\\<pi> J.TT) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       J.ide a \\<Longrightarrow>\n       \\<pi> a = D.mkCone (\\<pi> (J.MkIde False)) (\\<pi> (J.MkIde True)) a", "using D.mkCone_def J.ide_char"], ["proof (prove)\nusing this:\n  D.mkCone ?p0.0 ?p1.0 \\<equiv>\n  \\<lambda>j.\n     if j = J.MkIde False then ?p0.0\n     else if j = J.MkIde True then ?p1.0 else null\n  J.ide ?f = (?f = J.MkIde False \\<or> ?f = J.MkIde True)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       J.ide a \\<Longrightarrow>\n       \\<pi> a = D.mkCone (\\<pi> (J.MkIde False)) (\\<pi> (J.MkIde True)) a", "by auto"], ["proof (state)\nthis:\n  J.ide ?a5 \\<Longrightarrow>\n  \\<pi> ?a5 = D.mkCone (\\<pi> (J.MkIde False)) (\\<pi> (J.MkIde True)) ?a5\n\ngoal (1 subgoal):\n 1. \\<pi> = D.mkCone (\\<pi> (J.MkIde False)) (\\<pi> (J.MkIde True))", "moreover"], ["proof (state)\nthis:\n  J.ide ?a5 \\<Longrightarrow>\n  \\<pi> ?a5 = D.mkCone (\\<pi> (J.MkIde False)) (\\<pi> (J.MkIde True)) ?a5\n\ngoal (1 subgoal):\n 1. \\<pi> = D.mkCone (\\<pi> (J.MkIde False)) (\\<pi> (J.MkIde True))", "have \"a = dom (\\<pi> J.FF)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = local.dom (\\<pi> (J.MkIde False))", "by simp"], ["proof (state)\nthis:\n  a = local.dom (\\<pi> (J.MkIde False))\n\ngoal (1 subgoal):\n 1. \\<pi> = D.mkCone (\\<pi> (J.MkIde False)) (\\<pi> (J.MkIde True))", "moreover"], ["proof (state)\nthis:\n  a = local.dom (\\<pi> (J.MkIde False))\n\ngoal (1 subgoal):\n 1. \\<pi> = D.mkCone (\\<pi> (J.MkIde False)) (\\<pi> (J.MkIde True))", "have \"D.cone a (D.mkCone (\\<pi> (J.MkIde False)) (\\<pi> (J.MkIde True)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D.cone a (D.mkCone (\\<pi> (J.MkIde False)) (\\<pi> (J.MkIde True)))", "using 1 D.cone_mkCone [of \"\\<pi> J.FF\" \"\\<pi> J.TT\"]"], ["proof (prove)\nusing this:\n  ide a0 \\<and> ide a1\n  D.is_rendered_commutative_by (\\<pi> (J.MkIde False))\n   (\\<pi> (J.MkIde True)) \\<Longrightarrow>\n  D.cone (local.dom (\\<pi> (J.MkIde False)))\n   (D.mkCone (\\<pi> (J.MkIde False)) (\\<pi> (J.MkIde True)))\n\ngoal (1 subgoal):\n 1. D.cone a (D.mkCone (\\<pi> (J.MkIde False)) (\\<pi> (J.MkIde True)))", "by auto"], ["proof (state)\nthis:\n  D.cone a (D.mkCone (\\<pi> (J.MkIde False)) (\\<pi> (J.MkIde True)))\n\ngoal (1 subgoal):\n 1. \\<pi> = D.mkCone (\\<pi> (J.MkIde False)) (\\<pi> (J.MkIde True))", "ultimately"], ["proof (chain)\npicking this:\n  J.ide ?a5 \\<Longrightarrow>\n  \\<pi> ?a5 = D.mkCone (\\<pi> (J.MkIde False)) (\\<pi> (J.MkIde True)) ?a5\n  a = local.dom (\\<pi> (J.MkIde False))\n  D.cone a (D.mkCone (\\<pi> (J.MkIde False)) (\\<pi> (J.MkIde True)))", "show ?thesis"], ["proof (prove)\nusing this:\n  J.ide ?a5 \\<Longrightarrow>\n  \\<pi> ?a5 = D.mkCone (\\<pi> (J.MkIde False)) (\\<pi> (J.MkIde True)) ?a5\n  a = local.dom (\\<pi> (J.MkIde False))\n  D.cone a (D.mkCone (\\<pi> (J.MkIde False)) (\\<pi> (J.MkIde True)))\n\ngoal (1 subgoal):\n 1. \\<pi> = D.mkCone (\\<pi> (J.MkIde False)) (\\<pi> (J.MkIde True))", "using D.mkCone_def \\<pi>.natural_transformation_axioms\n                    D.cone_mkCone [of \"\\<pi> J.FF\" \"\\<pi> J.TT\"]\n                    NaturalTransformation.eqI\n                      [of \"J.comp\" C \\<pi>.A.map \"D.map\" \\<pi> \"D.mkCone (\\<pi> J.FF) (\\<pi> J.TT)\"]\n                    cone_def [of J.comp C D.map a \"D.mkCone (\\<pi> J.FF) (\\<pi> J.TT)\"] J.ide_char"], ["proof (prove)\nusing this:\n  J.ide ?a5 \\<Longrightarrow>\n  \\<pi> ?a5 = D.mkCone (\\<pi> (J.MkIde False)) (\\<pi> (J.MkIde True)) ?a5\n  a = local.dom (\\<pi> (J.MkIde False))\n  D.cone a (D.mkCone (\\<pi> (J.MkIde False)) (\\<pi> (J.MkIde True)))\n  D.mkCone ?p0.0 ?p1.0 \\<equiv>\n  \\<lambda>j.\n     if j = J.MkIde False then ?p0.0\n     else if j = J.MkIde True then ?p1.0 else null\n  natural_transformation J.COMP (\\<cdot>) \\<pi>.A.map D.map \\<pi>\n  D.is_rendered_commutative_by (\\<pi> (J.MkIde False))\n   (\\<pi> (J.MkIde True)) \\<Longrightarrow>\n  D.cone (local.dom (\\<pi> (J.MkIde False)))\n   (D.mkCone (\\<pi> (J.MkIde False)) (\\<pi> (J.MkIde True)))\n  \\<lbrakk>natural_transformation J.COMP (\\<cdot>) \\<pi>.A.map D.map \\<pi>;\n   natural_transformation J.COMP (\\<cdot>) \\<pi>.A.map D.map\n    (D.mkCone (\\<pi> (J.MkIde False)) (\\<pi> (J.MkIde True)));\n   \\<And>a.\n      J.ide a \\<Longrightarrow>\n      \\<pi> a =\n      D.mkCone (\\<pi> (J.MkIde False)) (\\<pi> (J.MkIde True)) a\\<rbrakk>\n  \\<Longrightarrow> \\<pi> =\n                    D.mkCone (\\<pi> (J.MkIde False)) (\\<pi> (J.MkIde True))\n  D.cone a\n   (D.mkCone (\\<pi> (J.MkIde False)) (\\<pi> (J.MkIde True))) \\<equiv>\n  (category (\\<cdot>) \\<and> category J.COMP) \\<and>\n  diagram J.COMP (\\<cdot>) D.map \\<and>\n  constant_functor J.COMP (\\<cdot>) a \\<and>\n  natural_transformation J.COMP (\\<cdot>) \\<pi>.A.map D.map\n   (D.mkCone (\\<pi> (J.MkIde False)) (\\<pi> (J.MkIde True)))\n  J.ide ?f = (?f = J.MkIde False \\<or> ?f = J.MkIde True)\n\ngoal (1 subgoal):\n 1. \\<pi> = D.mkCone (\\<pi> (J.MkIde False)) (\\<pi> (J.MkIde True))", "by blast"], ["proof (state)\nthis:\n  \\<pi> = D.mkCone (\\<pi> (J.MkIde False)) (\\<pi> (J.MkIde True))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<pi> = D.mkCone (\\<pi> (J.MkIde False)) (\\<pi> (J.MkIde True))\n\ngoal (1 subgoal):\n 1. \\<exists>p0 p1.\n       ide a0 \\<and> ide a1 \\<and> D.has_as_binary_product p0 p1", "hence \"D.limit_cone (dom (\\<pi> J.FF)) (D.mkCone (\\<pi> J.FF) (\\<pi> J.TT))\""], ["proof (prove)\nusing this:\n  \\<pi> = D.mkCone (\\<pi> (J.MkIde False)) (\\<pi> (J.MkIde True))\n\ngoal (1 subgoal):\n 1. D.has_as_binary_product (\\<pi> (J.MkIde False)) (\\<pi> (J.MkIde True))", "using \\<pi>.limit_cone_axioms"], ["proof (prove)\nusing this:\n  \\<pi> = D.mkCone (\\<pi> (J.MkIde False)) (\\<pi> (J.MkIde True))\n  D.limit_cone a \\<pi>\n\ngoal (1 subgoal):\n 1. D.has_as_binary_product (\\<pi> (J.MkIde False)) (\\<pi> (J.MkIde True))", "by simp"], ["proof (state)\nthis:\n  D.has_as_binary_product (\\<pi> (J.MkIde False)) (\\<pi> (J.MkIde True))\n\ngoal (1 subgoal):\n 1. \\<exists>p0 p1.\n       ide a0 \\<and> ide a1 \\<and> D.has_as_binary_product p0 p1", "thus \"\\<exists>p0 p1. ide a0 \\<and> ide a1 \\<and> D.has_as_binary_product p0 p1\""], ["proof (prove)\nusing this:\n  D.has_as_binary_product (\\<pi> (J.MkIde False)) (\\<pi> (J.MkIde True))\n\ngoal (1 subgoal):\n 1. \\<exists>p0 p1.\n       ide a0 \\<and> ide a1 \\<and> D.has_as_binary_product p0 p1", "using 1"], ["proof (prove)\nusing this:\n  D.has_as_binary_product (\\<pi> (J.MkIde False)) (\\<pi> (J.MkIde True))\n  ide a0 \\<and> ide a1\n\ngoal (1 subgoal):\n 1. \\<exists>p0 p1.\n       ide a0 \\<and> ide a1 \\<and> D.has_as_binary_product p0 p1", "by blast"], ["proof (state)\nthis:\n  \\<exists>p0 p1. ide a0 \\<and> ide a1 \\<and> D.has_as_binary_product p0 p1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>p0 p1. has_as_binary_product a0 a1 p0 p1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>p0 p1. has_as_binary_product a0 a1 p0 p1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<forall>a0 a1.\n     ide a0 \\<and> ide a1 \\<longrightarrow>\n     (\\<exists>p0 p1. has_as_binary_product a0 a1 p0 p1)\n\ngoal:\nNo subgoals!", "qed"], ["", "sublocale category_with_finite_products \\<subseteq> category_with_binary_products C"], ["proof (prove)\ngoal (1 subgoal):\n 1. category_with_binary_products C", "using has_binary_products_if has_finite_products"], ["proof (prove)\nusing this:\n  has_products {0, 1} \\<Longrightarrow> has_binary_products\n  finite ?I \\<Longrightarrow> has_products ?I\n\ngoal (1 subgoal):\n 1. category_with_binary_products C", "by (unfold_locales, unfold has_binary_products_def) simp"], ["", "proposition (in category_with_finite_products) is_category_with_binary_products:\n  shows \"category_with_binary_products C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. category_with_binary_products C", ".."], ["", "sublocale category_with_finite_products \\<subseteq> category_with_terminal_object C"], ["proof (prove)\ngoal (1 subgoal):\n 1. category_with_terminal_object C", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. Ex terminal", "interpret J: discrete_category \"{} :: nat set\""], ["proof (prove)\ngoal (1 subgoal):\n 1. discrete_category {} Null", "by unfold_locales auto"], ["proof (state)\ngoal (1 subgoal):\n 1. Ex terminal", "interpret D: empty_diagram J.comp C \"\\<lambda>j. null\""], ["proof (prove)\ngoal (1 subgoal):\n 1. empty_diagram J.comp C (\\<lambda>j. null)", "by unfold_locales auto"], ["proof (state)\ngoal (1 subgoal):\n 1. Ex terminal", "interpret D: discrete_diagram J.comp C \"\\<lambda>j. null\""], ["proof (prove)\ngoal (1 subgoal):\n 1. discrete_diagram J.comp C (\\<lambda>j. null)", "using J.is_discrete"], ["proof (prove)\nusing this:\n  J.ide = J.arr\n\ngoal (1 subgoal):\n 1. discrete_diagram J.comp C (\\<lambda>j. null)", "by unfold_locales auto"], ["proof (state)\ngoal (1 subgoal):\n 1. Ex terminal", "have \"\\<And>a. D.has_as_limit a \\<longleftrightarrow> has_as_product J.comp (\\<lambda>j. null) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a. D.has_as_limit a = has_as_product J.comp (\\<lambda>j. null) a", "using product_cone_def J.category_axioms category_axioms D.discrete_diagram_axioms\n            has_as_product_def product_cone_def"], ["proof (prove)\nusing this:\n  product_cone ?J ?C ?D ?a ?\\<pi> \\<equiv>\n  (category ?J \\<and> category ?C) \\<and>\n  discrete_diagram ?J ?C ?D \\<and> limit_cone ?J ?C ?D ?a ?\\<pi>\n  category J.comp\n  category C\n  discrete_diagram J.comp C (\\<lambda>j. null)\n  has_as_product ?J ?D ?a \\<equiv>\n  \\<exists>\\<pi>. product_cone ?J C ?D ?a \\<pi>\n  product_cone ?J ?C ?D ?a ?\\<pi> \\<equiv>\n  (category ?J \\<and> category ?C) \\<and>\n  discrete_diagram ?J ?C ?D \\<and> limit_cone ?J ?C ?D ?a ?\\<pi>\n\ngoal (1 subgoal):\n 1. \\<And>a. D.has_as_limit a = has_as_product J.comp (\\<lambda>j. null) a", "by metis"], ["proof (state)\nthis:\n  D.has_as_limit ?a4 = has_as_product J.comp (\\<lambda>j. null) ?a4\n\ngoal (1 subgoal):\n 1. Ex terminal", "moreover"], ["proof (state)\nthis:\n  D.has_as_limit ?a4 = has_as_product J.comp (\\<lambda>j. null) ?a4\n\ngoal (1 subgoal):\n 1. Ex terminal", "have \"\\<exists>a. has_as_product J.comp (\\<lambda>j. null) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a. has_as_product J.comp (\\<lambda>j. null) a", "using has_finite_products [of \"{} :: nat set\"] has_products_def [of \"{} :: nat set\"]\n            D.discrete_diagram_axioms"], ["proof (prove)\nusing this:\n  finite {} \\<Longrightarrow> has_products {}\n  has_products {} \\<equiv>\n  {} \\<noteq> UNIV \\<and>\n  (\\<forall>J D.\n      discrete_diagram J C D \\<and>\n      Collect (partial_magma.arr J) = {} \\<longrightarrow>\n      (\\<exists>a. has_as_product J D a))\n  discrete_diagram J.comp C (\\<lambda>j. null)\n\ngoal (1 subgoal):\n 1. \\<exists>a. has_as_product J.comp (\\<lambda>j. null) a", "by blast"], ["proof (state)\nthis:\n  \\<exists>a. has_as_product J.comp (\\<lambda>j. null) a\n\ngoal (1 subgoal):\n 1. Ex terminal", "ultimately"], ["proof (chain)\npicking this:\n  D.has_as_limit ?a4 = has_as_product J.comp (\\<lambda>j. null) ?a4\n  \\<exists>a. has_as_product J.comp (\\<lambda>j. null) a", "have \"\\<exists>a. D.has_as_limit a\""], ["proof (prove)\nusing this:\n  D.has_as_limit ?a4 = has_as_product J.comp (\\<lambda>j. null) ?a4\n  \\<exists>a. has_as_product J.comp (\\<lambda>j. null) a\n\ngoal (1 subgoal):\n 1. D.has_limit", "by blast"], ["proof (state)\nthis:\n  D.has_limit\n\ngoal (1 subgoal):\n 1. Ex terminal", "thus \"\\<exists>a. terminal a\""], ["proof (prove)\nusing this:\n  D.has_limit\n\ngoal (1 subgoal):\n 1. Ex terminal", "using D.has_as_limit_iff_terminal"], ["proof (prove)\nusing this:\n  D.has_limit\n  D.has_as_limit ?a = terminal ?a\n\ngoal (1 subgoal):\n 1. Ex terminal", "by blast"], ["proof (state)\nthis:\n  Ex terminal\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition (in category_with_finite_products) is_category_with_terminal_object:\n  shows \"category_with_terminal_object C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. category_with_terminal_object C", ".."], ["", "sublocale category_with_finite_products \\<subseteq> cartesian_category"], ["proof (prove)\ngoal (1 subgoal):\n 1. cartesian_category C", ".."], ["", "proposition (in category_with_finite_products) is_cartesian_category:\n  shows \"cartesian_category C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cartesian_category C", ".."], ["", "context category\n  begin"], ["", "lemma binary_product_of_products_is_product:\n    assumes \"has_as_product J0 D0 a0\" and \"has_as_product J1 D1 a1\"\n    and \"has_as_binary_product a0 a1 p0 p1\"\n    and \"Collect (partial_magma.arr J0) \\<inter> Collect (partial_magma.arr J1) = {}\"\n    and \"partial_magma.null J0 = partial_magma.null J1\"\n    shows \"has_as_product\n             (discrete_category.comp\n                (Collect (partial_magma.arr J0) \\<union> Collect (partial_magma.arr J1))\n                (partial_magma.null J0))\n             (\\<lambda>i. if i \\<in> Collect (partial_magma.arr J0) then D0 i\n                  else if i \\<in> Collect (partial_magma.arr J1) then D1 i\n                  else null)\n             (dom p0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_as_product\n     (DiscreteCategory.discrete_category.comp\n       (Collect (partial_magma.arr J0) \\<union>\n        Collect (partial_magma.arr J1))\n       (partial_magma.null J0))\n     (\\<lambda>i.\n         if i \\<in> Collect (partial_magma.arr J0) then D0 i\n         else if i \\<in> Collect (partial_magma.arr J1) then D1 i else null)\n     (local.dom p0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. has_as_product\n     (DiscreteCategory.discrete_category.comp\n       (Collect (partial_magma.arr J0) \\<union>\n        Collect (partial_magma.arr J1))\n       (partial_magma.null J0))\n     (\\<lambda>i.\n         if i \\<in> Collect (partial_magma.arr J0) then D0 i\n         else if i \\<in> Collect (partial_magma.arr J1) then D1 i else null)\n     (local.dom p0)", "obtain \\<pi>0 where \\<pi>0: \"product_cone J0 (\\<cdot>) D0 a0 \\<pi>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>0.\n        product_cone J0 (\\<cdot>) D0 a0 \\<pi>0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms(1) has_as_product_def"], ["proof (prove)\nusing this:\n  has_as_product J0 D0 a0\n  has_as_product ?J ?D ?a \\<equiv>\n  \\<exists>\\<pi>. product_cone ?J (\\<cdot>) ?D ?a \\<pi>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>0.\n        product_cone J0 (\\<cdot>) D0 a0 \\<pi>0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  product_cone J0 (\\<cdot>) D0 a0 \\<pi>0\n\ngoal (1 subgoal):\n 1. has_as_product\n     (DiscreteCategory.discrete_category.comp\n       (Collect (partial_magma.arr J0) \\<union>\n        Collect (partial_magma.arr J1))\n       (partial_magma.null J0))\n     (\\<lambda>i.\n         if i \\<in> Collect (partial_magma.arr J0) then D0 i\n         else if i \\<in> Collect (partial_magma.arr J1) then D1 i else null)\n     (local.dom p0)", "obtain \\<pi>1 where \\<pi>1: \"product_cone J1 (\\<cdot>) D1 a1 \\<pi>1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>1.\n        product_cone J1 (\\<cdot>) D1 a1 \\<pi>1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms(2) has_as_product_def"], ["proof (prove)\nusing this:\n  has_as_product J1 D1 a1\n  has_as_product ?J ?D ?a \\<equiv>\n  \\<exists>\\<pi>. product_cone ?J (\\<cdot>) ?D ?a \\<pi>\n\ngoal (1 subgoal):\n 1. (\\<And>\\<pi>1.\n        product_cone J1 (\\<cdot>) D1 a1 \\<pi>1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  product_cone J1 (\\<cdot>) D1 a1 \\<pi>1\n\ngoal (1 subgoal):\n 1. has_as_product\n     (DiscreteCategory.discrete_category.comp\n       (Collect (partial_magma.arr J0) \\<union>\n        Collect (partial_magma.arr J1))\n       (partial_magma.null J0))\n     (\\<lambda>i.\n         if i \\<in> Collect (partial_magma.arr J0) then D0 i\n         else if i \\<in> Collect (partial_magma.arr J1) then D1 i else null)\n     (local.dom p0)", "interpret J0: category J0"], ["proof (prove)\ngoal (1 subgoal):\n 1. category J0", "using \\<pi>0 product_cone.axioms(1)"], ["proof (prove)\nusing this:\n  product_cone J0 (\\<cdot>) D0 a0 \\<pi>0\n  product_cone ?J ?C ?D ?a ?\\<pi> \\<Longrightarrow> category ?J\n\ngoal (1 subgoal):\n 1. category J0", "by metis"], ["proof (state)\ngoal (1 subgoal):\n 1. has_as_product\n     (DiscreteCategory.discrete_category.comp\n       (Collect J0.arr \\<union> Collect (partial_magma.arr J1)) J0.null)\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then D0 i\n         else if i \\<in> Collect (partial_magma.arr J1) then D1 i else null)\n     (local.dom p0)", "interpret J1: category J1"], ["proof (prove)\ngoal (1 subgoal):\n 1. category J1", "using \\<pi>1 product_cone.axioms(1)"], ["proof (prove)\nusing this:\n  product_cone J1 (\\<cdot>) D1 a1 \\<pi>1\n  product_cone ?J ?C ?D ?a ?\\<pi> \\<Longrightarrow> category ?J\n\ngoal (1 subgoal):\n 1. category J1", "by metis"], ["proof (state)\ngoal (1 subgoal):\n 1. has_as_product\n     (DiscreteCategory.discrete_category.comp\n       (Collect J0.arr \\<union> Collect J1.arr) J0.null)\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then D0 i\n         else if i \\<in> Collect J1.arr then D1 i else null)\n     (local.dom p0)", "interpret D0: discrete_diagram J0 C D0"], ["proof (prove)\ngoal (1 subgoal):\n 1. discrete_diagram J0 (\\<cdot>) D0", "using \\<pi>0 product_cone.axioms(3)"], ["proof (prove)\nusing this:\n  product_cone J0 (\\<cdot>) D0 a0 \\<pi>0\n  product_cone ?J ?C ?D ?a ?\\<pi> \\<Longrightarrow>\n  discrete_diagram ?J ?C ?D\n\ngoal (1 subgoal):\n 1. discrete_diagram J0 (\\<cdot>) D0", "by metis"], ["proof (state)\ngoal (1 subgoal):\n 1. has_as_product\n     (DiscreteCategory.discrete_category.comp\n       (Collect J0.arr \\<union> Collect J1.arr) J0.null)\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then D0 i\n         else if i \\<in> Collect J1.arr then D1 i else null)\n     (local.dom p0)", "interpret D1: discrete_diagram J1 C D1"], ["proof (prove)\ngoal (1 subgoal):\n 1. discrete_diagram J1 (\\<cdot>) D1", "using \\<pi>1 product_cone.axioms(3)"], ["proof (prove)\nusing this:\n  product_cone J1 (\\<cdot>) D1 a1 \\<pi>1\n  product_cone ?J ?C ?D ?a ?\\<pi> \\<Longrightarrow>\n  discrete_diagram ?J ?C ?D\n\ngoal (1 subgoal):\n 1. discrete_diagram J1 (\\<cdot>) D1", "by metis"], ["proof (state)\ngoal (1 subgoal):\n 1. has_as_product\n     (DiscreteCategory.discrete_category.comp\n       (Collect J0.arr \\<union> Collect J1.arr) J0.null)\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then D0 i\n         else if i \\<in> Collect J1.arr then D1 i else null)\n     (local.dom p0)", "interpret \\<pi>0: product_cone J0 C D0 a0 \\<pi>0"], ["proof (prove)\ngoal (1 subgoal):\n 1. product_cone J0 (\\<cdot>) D0 a0 \\<pi>0", "using \\<pi>0"], ["proof (prove)\nusing this:\n  product_cone J0 (\\<cdot>) D0 a0 \\<pi>0\n\ngoal (1 subgoal):\n 1. product_cone J0 (\\<cdot>) D0 a0 \\<pi>0", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. has_as_product\n     (DiscreteCategory.discrete_category.comp\n       (Collect J0.arr \\<union> Collect J1.arr) J0.null)\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then D0 i\n         else if i \\<in> Collect J1.arr then D1 i else null)\n     (local.dom p0)", "interpret \\<pi>1: product_cone J1 C D1 a1 \\<pi>1"], ["proof (prove)\ngoal (1 subgoal):\n 1. product_cone J1 (\\<cdot>) D1 a1 \\<pi>1", "using \\<pi>1"], ["proof (prove)\nusing this:\n  product_cone J1 (\\<cdot>) D1 a1 \\<pi>1\n\ngoal (1 subgoal):\n 1. product_cone J1 (\\<cdot>) D1 a1 \\<pi>1", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. has_as_product\n     (DiscreteCategory.discrete_category.comp\n       (Collect J0.arr \\<union> Collect J1.arr) J0.null)\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then D0 i\n         else if i \\<in> Collect J1.arr then D1 i else null)\n     (local.dom p0)", "interpret J: discrete_category \\<open>Collect J0.arr \\<union> Collect J1.arr\\<close> J0.null"], ["proof (prove)\ngoal (1 subgoal):\n 1. discrete_category (Collect J0.arr \\<union> Collect J1.arr) J0.null", "using J0.not_arr_null assms(5)"], ["proof (prove)\nusing this:\n  \\<not> J0.arr J0.null\n  J0.null = J1.null\n\ngoal (1 subgoal):\n 1. discrete_category (Collect J0.arr \\<union> Collect J1.arr) J0.null", "by unfold_locales auto"], ["proof (state)\ngoal (1 subgoal):\n 1. has_as_product J.comp\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then D0 i\n         else if i \\<in> Collect J1.arr then D1 i else null)\n     (local.dom p0)", "interpret X: binary_product_shape"], ["proof (prove)\ngoal:\nNo subgoals!", "."], ["proof (state)\ngoal (1 subgoal):\n 1. has_as_product J.comp\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then D0 i\n         else if i \\<in> Collect J1.arr then D1 i else null)\n     (local.dom p0)", "interpret a0xa1: binary_product_diagram C a0 a1"], ["proof (prove)\ngoal (1 subgoal):\n 1. binary_product_diagram (\\<cdot>) a0 a1", "using assms(3) has_as_binary_product_def"], ["proof (prove)\nusing this:\n  has_as_binary_product a0 a1 p0 p1\n  has_as_binary_product ?a0.0 ?a1.0 ?p0.0 ?p1.0 \\<equiv>\n  ide ?a0.0 \\<and>\n  ide ?a1.0 \\<and>\n  limit_cone X.COMP (\\<cdot>)\n   (binary_product_diagram.map (\\<cdot>) ?a0.0 ?a1.0) (local.dom ?p0.0)\n   (binary_product_diagram.mkCone (\\<cdot>) ?p0.0 ?p1.0)\n\ngoal (1 subgoal):\n 1. binary_product_diagram (\\<cdot>) a0 a1", "by (simp add: binary_product_diagram.intro binary_product_diagram_axioms.intro\n            category_axioms)"], ["proof (state)\ngoal (1 subgoal):\n 1. has_as_product J.comp\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then D0 i\n         else if i \\<in> Collect J1.arr then D1 i else null)\n     (local.dom p0)", "have p0p1: \"a0xa1.has_as_binary_product p0 p1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a0xa1.has_as_binary_product p0 p1", "using assms(3) has_as_binary_product_def [of a0 a1 p0 p1]"], ["proof (prove)\nusing this:\n  has_as_binary_product a0 a1 p0 p1\n  has_as_binary_product a0 a1 p0 p1 \\<equiv>\n  ide a0 \\<and> ide a1 \\<and> a0xa1.has_as_binary_product p0 p1\n\ngoal (1 subgoal):\n 1. a0xa1.has_as_binary_product p0 p1", "by simp"], ["proof (state)\nthis:\n  a0xa1.has_as_binary_product p0 p1\n\ngoal (1 subgoal):\n 1. has_as_product J.comp\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then D0 i\n         else if i \\<in> Collect J1.arr then D1 i else null)\n     (local.dom p0)", "let ?D = \"(\\<lambda>i. if i \\<in> Collect J0.arr then D0 i\n                     else if i \\<in> Collect J1.arr then D1 i\n                     else null)\""], ["proof (state)\ngoal (1 subgoal):\n 1. has_as_product J.comp\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then D0 i\n         else if i \\<in> Collect J1.arr then D1 i else null)\n     (local.dom p0)", "let ?a = \"dom p0\""], ["proof (state)\ngoal (1 subgoal):\n 1. has_as_product J.comp\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then D0 i\n         else if i \\<in> Collect J1.arr then D1 i else null)\n     (local.dom p0)", "let ?\\<pi> = \"\\<lambda>i. if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n                    else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                    else null\""], ["proof (state)\ngoal (1 subgoal):\n 1. has_as_product J.comp\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then D0 i\n         else if i \\<in> Collect J1.arr then D1 i else null)\n     (local.dom p0)", "let ?p0p1 = \"a0xa1.mkCone p0 p1\""], ["proof (state)\ngoal (1 subgoal):\n 1. has_as_product J.comp\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then D0 i\n         else if i \\<in> Collect J1.arr then D1 i else null)\n     (local.dom p0)", "interpret p0p1: limit_cone X.comp C a0xa1.map ?a ?p0p1"], ["proof (prove)\ngoal (1 subgoal):\n 1. a0xa1.has_as_binary_product p0 p1", "using p0p1"], ["proof (prove)\nusing this:\n  a0xa1.has_as_binary_product p0 p1\n\ngoal (1 subgoal):\n 1. a0xa1.has_as_binary_product p0 p1", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. has_as_product J.comp\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then D0 i\n         else if i \\<in> Collect J1.arr then D1 i else null)\n     (local.dom p0)", "have a: \"ide ?a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide (local.dom p0)", "using p0p1.ide_apex"], ["proof (prove)\nusing this:\n  ide (local.dom p0)\n\ngoal (1 subgoal):\n 1. ide (local.dom p0)", "by simp"], ["proof (state)\nthis:\n  ide (local.dom p0)\n\ngoal (1 subgoal):\n 1. has_as_product J.comp\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then D0 i\n         else if i \\<in> Collect J1.arr then D1 i else null)\n     (local.dom p0)", "have p0: \"\\<guillemotleft>p0 : ?a \\<rightarrow> a0\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>p0 : local.dom p0 \\<rightarrow> a0\\<guillemotright>", "using a0xa1.mkCone_def p0p1.preserves_hom [of X.FF X.FF X.FF] X.ide_char X.ide_in_hom"], ["proof (prove)\nusing this:\n  a0xa1.mkCone ?p0.0 ?p1.0 \\<equiv>\n  \\<lambda>j.\n     if j = X.MkIde False then ?p0.0\n     else if j = X.MkIde True then ?p1.0 else null\n  X.in_hom (X.MkIde False) (X.MkIde False) (X.MkIde False) \\<Longrightarrow>\n  \\<guillemotleft>a0xa1.mkCone p0 p1\n                   (X.MkIde\n                     False) : p0p1.A.map\n                               (X.MkIde\n                                 False) \\<rightarrow> a0xa1.map\n                 (X.MkIde False)\\<guillemotright>\n  X.ide ?f = (?f = X.MkIde False \\<or> ?f = X.MkIde True)\n  X.ide ?a = X.in_hom ?a ?a ?a\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>p0 : local.dom p0 \\<rightarrow> a0\\<guillemotright>", "by auto"], ["proof (state)\nthis:\n  \\<guillemotleft>p0 : local.dom p0 \\<rightarrow> a0\\<guillemotright>\n\ngoal (1 subgoal):\n 1. has_as_product J.comp\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then D0 i\n         else if i \\<in> Collect J1.arr then D1 i else null)\n     (local.dom p0)", "have p1: \"\\<guillemotleft>p1 : ?a \\<rightarrow> a1\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>p1 : local.dom p0 \\<rightarrow> a1\\<guillemotright>", "using a0xa1.mkCone_def p0p1.preserves_hom [of X.TT X.TT X.TT] X.ide_char X.ide_in_hom"], ["proof (prove)\nusing this:\n  a0xa1.mkCone ?p0.0 ?p1.0 \\<equiv>\n  \\<lambda>j.\n     if j = X.MkIde False then ?p0.0\n     else if j = X.MkIde True then ?p1.0 else null\n  X.in_hom (X.MkIde True) (X.MkIde True) (X.MkIde True) \\<Longrightarrow>\n  \\<guillemotleft>a0xa1.mkCone p0 p1\n                   (X.MkIde\n                     True) : p0p1.A.map\n                              (X.MkIde\n                                True) \\<rightarrow> a0xa1.map\n               (X.MkIde True)\\<guillemotright>\n  X.ide ?f = (?f = X.MkIde False \\<or> ?f = X.MkIde True)\n  X.ide ?a = X.in_hom ?a ?a ?a\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>p1 : local.dom p0 \\<rightarrow> a1\\<guillemotright>", "by auto"], ["proof (state)\nthis:\n  \\<guillemotleft>p1 : local.dom p0 \\<rightarrow> a1\\<guillemotright>\n\ngoal (1 subgoal):\n 1. has_as_product J.comp\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then D0 i\n         else if i \\<in> Collect J1.arr then D1 i else null)\n     (local.dom p0)", "interpret D: discrete_diagram J.comp C ?D"], ["proof (prove)\ngoal (1 subgoal):\n 1. discrete_diagram J.comp (\\<cdot>)\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then D0 i\n         else if i \\<in> Collect J1.arr then D1 i else null)", "using assms J.arr_char J.dom_char J.cod_char J.is_discrete D0.is_discrete D1.is_discrete\n              J.cod_comp J.seq_char"], ["proof (prove)\nusing this:\n  has_as_product J0 D0 a0\n  has_as_product J1 D1 a1\n  has_as_binary_product a0 a1 p0 p1\n  Collect J0.arr \\<inter> Collect J1.arr = {}\n  J0.null = J1.null\n  J.arr ?f = (?f \\<in> Collect J0.arr \\<union> Collect J1.arr)\n  J.dom ?f =\n  (if ?f \\<in> Collect J0.arr \\<union> Collect J1.arr then ?f else J.null)\n  J.cod ?f =\n  (if ?f \\<in> Collect J0.arr \\<union> Collect J1.arr then ?f else J.null)\n  J.ide = J.arr\n  J0.arr = J0.ide\n  J1.arr = J1.ide\n  J.seq ?g ?f \\<Longrightarrow> J.cod (J.comp ?g ?f) = J.cod ?g\n  J.seq ?f ?g = (J.ide ?f \\<and> ?f = ?g)\n\ngoal (1 subgoal):\n 1. discrete_diagram J.comp (\\<cdot>)\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then D0 i\n         else if i \\<in> Collect J1.arr then D1 i else null)", "by unfold_locales auto"], ["proof (state)\ngoal (1 subgoal):\n 1. has_as_product J.comp\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then D0 i\n         else if i \\<in> Collect J1.arr then D1 i else null)\n     (local.dom p0)", "interpret A: constant_functor J.comp C ?a"], ["proof (prove)\ngoal (1 subgoal):\n 1. constant_functor J.comp (\\<cdot>) (local.dom p0)", "using p0p1.ide_apex"], ["proof (prove)\nusing this:\n  ide (local.dom p0)\n\ngoal (1 subgoal):\n 1. constant_functor J.comp (\\<cdot>) (local.dom p0)", "by unfold_locales simp"], ["proof (state)\ngoal (1 subgoal):\n 1. has_as_product J.comp\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then D0 i\n         else if i \\<in> Collect J1.arr then D1 i else null)\n     (local.dom p0)", "interpret \\<pi>: natural_transformation J.comp C A.map ?D ?\\<pi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. natural_transformation J.comp (\\<cdot>) A.map\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then D0 i\n         else if i \\<in> Collect J1.arr then D1 i else null)\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n         else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null)", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>f.\n       \\<not> J.arr f \\<Longrightarrow>\n       (if f \\<in> Collect J0.arr then \\<pi>0 f \\<cdot> p0\n        else if f \\<in> Collect J1.arr then \\<pi>1 f \\<cdot> p1 else null) =\n       null\n 2. \\<And>f.\n       J.arr f \\<Longrightarrow>\n       local.dom\n        (if f \\<in> Collect J0.arr then \\<pi>0 f \\<cdot> p0\n         else if f \\<in> Collect J1.arr then \\<pi>1 f \\<cdot> p1\n              else null) =\n       A.map (J.dom f)\n 3. \\<And>f.\n       J.arr f \\<Longrightarrow>\n       cod (if f \\<in> Collect J0.arr then \\<pi>0 f \\<cdot> p0\n            else if f \\<in> Collect J1.arr then \\<pi>1 f \\<cdot> p1\n                 else null) =\n       (if J.cod f \\<in> Collect J0.arr then D0 (J.cod f)\n        else if J.cod f \\<in> Collect J1.arr then D1 (J.cod f) else null)\n 4. \\<And>f.\n       J.arr f \\<Longrightarrow>\n       (if f \\<in> Collect J0.arr then D0 f\n        else if f \\<in> Collect J1.arr then D1 f else null) \\<cdot>\n       (if J.dom f \\<in> Collect J0.arr then \\<pi>0 (J.dom f) \\<cdot> p0\n        else if J.dom f \\<in> Collect J1.arr\n             then \\<pi>1 (J.dom f) \\<cdot> p1 else null) =\n       (if f \\<in> Collect J0.arr then \\<pi>0 f \\<cdot> p0\n        else if f \\<in> Collect J1.arr then \\<pi>1 f \\<cdot> p1 else null)\n 5. \\<And>f.\n       J.arr f \\<Longrightarrow>\n       (if J.cod f \\<in> Collect J0.arr then \\<pi>0 (J.cod f) \\<cdot> p0\n        else if J.cod f \\<in> Collect J1.arr\n             then \\<pi>1 (J.cod f) \\<cdot> p1 else null) \\<cdot>\n       A.map f =\n       (if f \\<in> Collect J0.arr then \\<pi>0 f \\<cdot> p0\n        else if f \\<in> Collect J1.arr then \\<pi>1 f \\<cdot> p1 else null)", "fix j"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>f.\n       \\<not> J.arr f \\<Longrightarrow>\n       (if f \\<in> Collect J0.arr then \\<pi>0 f \\<cdot> p0\n        else if f \\<in> Collect J1.arr then \\<pi>1 f \\<cdot> p1 else null) =\n       null\n 2. \\<And>f.\n       J.arr f \\<Longrightarrow>\n       local.dom\n        (if f \\<in> Collect J0.arr then \\<pi>0 f \\<cdot> p0\n         else if f \\<in> Collect J1.arr then \\<pi>1 f \\<cdot> p1\n              else null) =\n       A.map (J.dom f)\n 3. \\<And>f.\n       J.arr f \\<Longrightarrow>\n       cod (if f \\<in> Collect J0.arr then \\<pi>0 f \\<cdot> p0\n            else if f \\<in> Collect J1.arr then \\<pi>1 f \\<cdot> p1\n                 else null) =\n       (if J.cod f \\<in> Collect J0.arr then D0 (J.cod f)\n        else if J.cod f \\<in> Collect J1.arr then D1 (J.cod f) else null)\n 4. \\<And>f.\n       J.arr f \\<Longrightarrow>\n       (if f \\<in> Collect J0.arr then D0 f\n        else if f \\<in> Collect J1.arr then D1 f else null) \\<cdot>\n       (if J.dom f \\<in> Collect J0.arr then \\<pi>0 (J.dom f) \\<cdot> p0\n        else if J.dom f \\<in> Collect J1.arr\n             then \\<pi>1 (J.dom f) \\<cdot> p1 else null) =\n       (if f \\<in> Collect J0.arr then \\<pi>0 f \\<cdot> p0\n        else if f \\<in> Collect J1.arr then \\<pi>1 f \\<cdot> p1 else null)\n 5. \\<And>f.\n       J.arr f \\<Longrightarrow>\n       (if J.cod f \\<in> Collect J0.arr then \\<pi>0 (J.cod f) \\<cdot> p0\n        else if J.cod f \\<in> Collect J1.arr\n             then \\<pi>1 (J.cod f) \\<cdot> p1 else null) \\<cdot>\n       A.map f =\n       (if f \\<in> Collect J0.arr then \\<pi>0 f \\<cdot> p0\n        else if f \\<in> Collect J1.arr then \\<pi>1 f \\<cdot> p1 else null)", "show \"\\<not> J.arr j \\<Longrightarrow> ?\\<pi> j = null\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> J.arr j \\<Longrightarrow>\n    (if j \\<in> Collect J0.arr then \\<pi>0 j \\<cdot> p0\n     else if j \\<in> Collect J1.arr then \\<pi>1 j \\<cdot> p1 else null) =\n    null", "by simp"], ["proof (state)\nthis:\n  \\<not> J.arr j \\<Longrightarrow>\n  (if j \\<in> Collect J0.arr then \\<pi>0 j \\<cdot> p0\n   else if j \\<in> Collect J1.arr then \\<pi>1 j \\<cdot> p1 else null) =\n  null\n\ngoal (4 subgoals):\n 1. \\<And>f.\n       J.arr f \\<Longrightarrow>\n       local.dom\n        (if f \\<in> Collect J0.arr then \\<pi>0 f \\<cdot> p0\n         else if f \\<in> Collect J1.arr then \\<pi>1 f \\<cdot> p1\n              else null) =\n       A.map (J.dom f)\n 2. \\<And>f.\n       J.arr f \\<Longrightarrow>\n       cod (if f \\<in> Collect J0.arr then \\<pi>0 f \\<cdot> p0\n            else if f \\<in> Collect J1.arr then \\<pi>1 f \\<cdot> p1\n                 else null) =\n       (if J.cod f \\<in> Collect J0.arr then D0 (J.cod f)\n        else if J.cod f \\<in> Collect J1.arr then D1 (J.cod f) else null)\n 3. \\<And>f.\n       J.arr f \\<Longrightarrow>\n       (if f \\<in> Collect J0.arr then D0 f\n        else if f \\<in> Collect J1.arr then D1 f else null) \\<cdot>\n       (if J.dom f \\<in> Collect J0.arr then \\<pi>0 (J.dom f) \\<cdot> p0\n        else if J.dom f \\<in> Collect J1.arr\n             then \\<pi>1 (J.dom f) \\<cdot> p1 else null) =\n       (if f \\<in> Collect J0.arr then \\<pi>0 f \\<cdot> p0\n        else if f \\<in> Collect J1.arr then \\<pi>1 f \\<cdot> p1 else null)\n 4. \\<And>f.\n       J.arr f \\<Longrightarrow>\n       (if J.cod f \\<in> Collect J0.arr then \\<pi>0 (J.cod f) \\<cdot> p0\n        else if J.cod f \\<in> Collect J1.arr\n             then \\<pi>1 (J.cod f) \\<cdot> p1 else null) \\<cdot>\n       A.map f =\n       (if f \\<in> Collect J0.arr then \\<pi>0 f \\<cdot> p0\n        else if f \\<in> Collect J1.arr then \\<pi>1 f \\<cdot> p1 else null)", "assume j: \"J.arr j\""], ["proof (state)\nthis:\n  J.arr j\n\ngoal (4 subgoals):\n 1. \\<And>f.\n       J.arr f \\<Longrightarrow>\n       local.dom\n        (if f \\<in> Collect J0.arr then \\<pi>0 f \\<cdot> p0\n         else if f \\<in> Collect J1.arr then \\<pi>1 f \\<cdot> p1\n              else null) =\n       A.map (J.dom f)\n 2. \\<And>f.\n       J.arr f \\<Longrightarrow>\n       cod (if f \\<in> Collect J0.arr then \\<pi>0 f \\<cdot> p0\n            else if f \\<in> Collect J1.arr then \\<pi>1 f \\<cdot> p1\n                 else null) =\n       (if J.cod f \\<in> Collect J0.arr then D0 (J.cod f)\n        else if J.cod f \\<in> Collect J1.arr then D1 (J.cod f) else null)\n 3. \\<And>f.\n       J.arr f \\<Longrightarrow>\n       (if f \\<in> Collect J0.arr then D0 f\n        else if f \\<in> Collect J1.arr then D1 f else null) \\<cdot>\n       (if J.dom f \\<in> Collect J0.arr then \\<pi>0 (J.dom f) \\<cdot> p0\n        else if J.dom f \\<in> Collect J1.arr\n             then \\<pi>1 (J.dom f) \\<cdot> p1 else null) =\n       (if f \\<in> Collect J0.arr then \\<pi>0 f \\<cdot> p0\n        else if f \\<in> Collect J1.arr then \\<pi>1 f \\<cdot> p1 else null)\n 4. \\<And>f.\n       J.arr f \\<Longrightarrow>\n       (if J.cod f \\<in> Collect J0.arr then \\<pi>0 (J.cod f) \\<cdot> p0\n        else if J.cod f \\<in> Collect J1.arr\n             then \\<pi>1 (J.cod f) \\<cdot> p1 else null) \\<cdot>\n       A.map f =\n       (if f \\<in> Collect J0.arr then \\<pi>0 f \\<cdot> p0\n        else if f \\<in> Collect J1.arr then \\<pi>1 f \\<cdot> p1 else null)", "have \\<pi>0j: \"J0.arr j \\<Longrightarrow> \\<guillemotleft>\\<pi>0 j : a0 \\<rightarrow> D0 j\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. J0.arr j \\<Longrightarrow>\n    \\<guillemotleft>\\<pi>0 j : a0 \\<rightarrow> D0 j\\<guillemotright>", "using D0.is_discrete"], ["proof (prove)\nusing this:\n  J0.arr = J0.ide\n\ngoal (1 subgoal):\n 1. J0.arr j \\<Longrightarrow>\n    \\<guillemotleft>\\<pi>0 j : a0 \\<rightarrow> D0 j\\<guillemotright>", "by auto"], ["proof (state)\nthis:\n  J0.arr j \\<Longrightarrow>\n  \\<guillemotleft>\\<pi>0 j : a0 \\<rightarrow> D0 j\\<guillemotright>\n\ngoal (4 subgoals):\n 1. \\<And>f.\n       J.arr f \\<Longrightarrow>\n       local.dom\n        (if f \\<in> Collect J0.arr then \\<pi>0 f \\<cdot> p0\n         else if f \\<in> Collect J1.arr then \\<pi>1 f \\<cdot> p1\n              else null) =\n       A.map (J.dom f)\n 2. \\<And>f.\n       J.arr f \\<Longrightarrow>\n       cod (if f \\<in> Collect J0.arr then \\<pi>0 f \\<cdot> p0\n            else if f \\<in> Collect J1.arr then \\<pi>1 f \\<cdot> p1\n                 else null) =\n       (if J.cod f \\<in> Collect J0.arr then D0 (J.cod f)\n        else if J.cod f \\<in> Collect J1.arr then D1 (J.cod f) else null)\n 3. \\<And>f.\n       J.arr f \\<Longrightarrow>\n       (if f \\<in> Collect J0.arr then D0 f\n        else if f \\<in> Collect J1.arr then D1 f else null) \\<cdot>\n       (if J.dom f \\<in> Collect J0.arr then \\<pi>0 (J.dom f) \\<cdot> p0\n        else if J.dom f \\<in> Collect J1.arr\n             then \\<pi>1 (J.dom f) \\<cdot> p1 else null) =\n       (if f \\<in> Collect J0.arr then \\<pi>0 f \\<cdot> p0\n        else if f \\<in> Collect J1.arr then \\<pi>1 f \\<cdot> p1 else null)\n 4. \\<And>f.\n       J.arr f \\<Longrightarrow>\n       (if J.cod f \\<in> Collect J0.arr then \\<pi>0 (J.cod f) \\<cdot> p0\n        else if J.cod f \\<in> Collect J1.arr\n             then \\<pi>1 (J.cod f) \\<cdot> p1 else null) \\<cdot>\n       A.map f =\n       (if f \\<in> Collect J0.arr then \\<pi>0 f \\<cdot> p0\n        else if f \\<in> Collect J1.arr then \\<pi>1 f \\<cdot> p1 else null)", "have \\<pi>1j: \"J1.arr j \\<Longrightarrow> \\<guillemotleft>\\<pi>1 j : a1 \\<rightarrow> D1 j\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. J1.arr j \\<Longrightarrow>\n    \\<guillemotleft>\\<pi>1 j : a1 \\<rightarrow> D1 j\\<guillemotright>", "using D1.is_discrete"], ["proof (prove)\nusing this:\n  J1.arr = J1.ide\n\ngoal (1 subgoal):\n 1. J1.arr j \\<Longrightarrow>\n    \\<guillemotleft>\\<pi>1 j : a1 \\<rightarrow> D1 j\\<guillemotright>", "by auto"], ["proof (state)\nthis:\n  J1.arr j \\<Longrightarrow>\n  \\<guillemotleft>\\<pi>1 j : a1 \\<rightarrow> D1 j\\<guillemotright>\n\ngoal (4 subgoals):\n 1. \\<And>f.\n       J.arr f \\<Longrightarrow>\n       local.dom\n        (if f \\<in> Collect J0.arr then \\<pi>0 f \\<cdot> p0\n         else if f \\<in> Collect J1.arr then \\<pi>1 f \\<cdot> p1\n              else null) =\n       A.map (J.dom f)\n 2. \\<And>f.\n       J.arr f \\<Longrightarrow>\n       cod (if f \\<in> Collect J0.arr then \\<pi>0 f \\<cdot> p0\n            else if f \\<in> Collect J1.arr then \\<pi>1 f \\<cdot> p1\n                 else null) =\n       (if J.cod f \\<in> Collect J0.arr then D0 (J.cod f)\n        else if J.cod f \\<in> Collect J1.arr then D1 (J.cod f) else null)\n 3. \\<And>f.\n       J.arr f \\<Longrightarrow>\n       (if f \\<in> Collect J0.arr then D0 f\n        else if f \\<in> Collect J1.arr then D1 f else null) \\<cdot>\n       (if J.dom f \\<in> Collect J0.arr then \\<pi>0 (J.dom f) \\<cdot> p0\n        else if J.dom f \\<in> Collect J1.arr\n             then \\<pi>1 (J.dom f) \\<cdot> p1 else null) =\n       (if f \\<in> Collect J0.arr then \\<pi>0 f \\<cdot> p0\n        else if f \\<in> Collect J1.arr then \\<pi>1 f \\<cdot> p1 else null)\n 4. \\<And>f.\n       J.arr f \\<Longrightarrow>\n       (if J.cod f \\<in> Collect J0.arr then \\<pi>0 (J.cod f) \\<cdot> p0\n        else if J.cod f \\<in> Collect J1.arr\n             then \\<pi>1 (J.cod f) \\<cdot> p1 else null) \\<cdot>\n       A.map f =\n       (if f \\<in> Collect J0.arr then \\<pi>0 f \\<cdot> p0\n        else if f \\<in> Collect J1.arr then \\<pi>1 f \\<cdot> p1 else null)", "show \"dom (?\\<pi> j) = A.map (J.dom j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dom\n     (if j \\<in> Collect J0.arr then \\<pi>0 j \\<cdot> p0\n      else if j \\<in> Collect J1.arr then \\<pi>1 j \\<cdot> p1 else null) =\n    A.map (J.dom j)", "using j J.arr_char p0 p1 \\<pi>0j \\<pi>1j"], ["proof (prove)\nusing this:\n  J.arr j\n  J.arr ?f = (?f \\<in> Collect J0.arr \\<union> Collect J1.arr)\n  \\<guillemotleft>p0 : local.dom p0 \\<rightarrow> a0\\<guillemotright>\n  \\<guillemotleft>p1 : local.dom p0 \\<rightarrow> a1\\<guillemotright>\n  J0.arr j \\<Longrightarrow>\n  \\<guillemotleft>\\<pi>0 j : a0 \\<rightarrow> D0 j\\<guillemotright>\n  J1.arr j \\<Longrightarrow>\n  \\<guillemotleft>\\<pi>1 j : a1 \\<rightarrow> D1 j\\<guillemotright>\n\ngoal (1 subgoal):\n 1. local.dom\n     (if j \\<in> Collect J0.arr then \\<pi>0 j \\<cdot> p0\n      else if j \\<in> Collect J1.arr then \\<pi>1 j \\<cdot> p1 else null) =\n    A.map (J.dom j)", "by fastforce"], ["proof (state)\nthis:\n  local.dom\n   (if j \\<in> Collect J0.arr then \\<pi>0 j \\<cdot> p0\n    else if j \\<in> Collect J1.arr then \\<pi>1 j \\<cdot> p1 else null) =\n  A.map (J.dom j)\n\ngoal (3 subgoals):\n 1. \\<And>f.\n       J.arr f \\<Longrightarrow>\n       cod (if f \\<in> Collect J0.arr then \\<pi>0 f \\<cdot> p0\n            else if f \\<in> Collect J1.arr then \\<pi>1 f \\<cdot> p1\n                 else null) =\n       (if J.cod f \\<in> Collect J0.arr then D0 (J.cod f)\n        else if J.cod f \\<in> Collect J1.arr then D1 (J.cod f) else null)\n 2. \\<And>f.\n       J.arr f \\<Longrightarrow>\n       (if f \\<in> Collect J0.arr then D0 f\n        else if f \\<in> Collect J1.arr then D1 f else null) \\<cdot>\n       (if J.dom f \\<in> Collect J0.arr then \\<pi>0 (J.dom f) \\<cdot> p0\n        else if J.dom f \\<in> Collect J1.arr\n             then \\<pi>1 (J.dom f) \\<cdot> p1 else null) =\n       (if f \\<in> Collect J0.arr then \\<pi>0 f \\<cdot> p0\n        else if f \\<in> Collect J1.arr then \\<pi>1 f \\<cdot> p1 else null)\n 3. \\<And>f.\n       J.arr f \\<Longrightarrow>\n       (if J.cod f \\<in> Collect J0.arr then \\<pi>0 (J.cod f) \\<cdot> p0\n        else if J.cod f \\<in> Collect J1.arr\n             then \\<pi>1 (J.cod f) \\<cdot> p1 else null) \\<cdot>\n       A.map f =\n       (if f \\<in> Collect J0.arr then \\<pi>0 f \\<cdot> p0\n        else if f \\<in> Collect J1.arr then \\<pi>1 f \\<cdot> p1 else null)", "show \"cod (?\\<pi> j) = ?D (J.cod j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cod (if j \\<in> Collect J0.arr then \\<pi>0 j \\<cdot> p0\n         else if j \\<in> Collect J1.arr then \\<pi>1 j \\<cdot> p1\n              else null) =\n    (if J.cod j \\<in> Collect J0.arr then D0 (J.cod j)\n     else if J.cod j \\<in> Collect J1.arr then D1 (J.cod j) else null)", "using j J.arr_char p0 p1 \\<pi>0j \\<pi>1j"], ["proof (prove)\nusing this:\n  J.arr j\n  J.arr ?f = (?f \\<in> Collect J0.arr \\<union> Collect J1.arr)\n  \\<guillemotleft>p0 : local.dom p0 \\<rightarrow> a0\\<guillemotright>\n  \\<guillemotleft>p1 : local.dom p0 \\<rightarrow> a1\\<guillemotright>\n  J0.arr j \\<Longrightarrow>\n  \\<guillemotleft>\\<pi>0 j : a0 \\<rightarrow> D0 j\\<guillemotright>\n  J1.arr j \\<Longrightarrow>\n  \\<guillemotleft>\\<pi>1 j : a1 \\<rightarrow> D1 j\\<guillemotright>\n\ngoal (1 subgoal):\n 1. cod (if j \\<in> Collect J0.arr then \\<pi>0 j \\<cdot> p0\n         else if j \\<in> Collect J1.arr then \\<pi>1 j \\<cdot> p1\n              else null) =\n    (if J.cod j \\<in> Collect J0.arr then D0 (J.cod j)\n     else if J.cod j \\<in> Collect J1.arr then D1 (J.cod j) else null)", "by fastforce"], ["proof (state)\nthis:\n  cod (if j \\<in> Collect J0.arr then \\<pi>0 j \\<cdot> p0\n       else if j \\<in> Collect J1.arr then \\<pi>1 j \\<cdot> p1 else null) =\n  (if J.cod j \\<in> Collect J0.arr then D0 (J.cod j)\n   else if J.cod j \\<in> Collect J1.arr then D1 (J.cod j) else null)\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       J.arr f \\<Longrightarrow>\n       (if f \\<in> Collect J0.arr then D0 f\n        else if f \\<in> Collect J1.arr then D1 f else null) \\<cdot>\n       (if J.dom f \\<in> Collect J0.arr then \\<pi>0 (J.dom f) \\<cdot> p0\n        else if J.dom f \\<in> Collect J1.arr\n             then \\<pi>1 (J.dom f) \\<cdot> p1 else null) =\n       (if f \\<in> Collect J0.arr then \\<pi>0 f \\<cdot> p0\n        else if f \\<in> Collect J1.arr then \\<pi>1 f \\<cdot> p1 else null)\n 2. \\<And>f.\n       J.arr f \\<Longrightarrow>\n       (if J.cod f \\<in> Collect J0.arr then \\<pi>0 (J.cod f) \\<cdot> p0\n        else if J.cod f \\<in> Collect J1.arr\n             then \\<pi>1 (J.cod f) \\<cdot> p1 else null) \\<cdot>\n       A.map f =\n       (if f \\<in> Collect J0.arr then \\<pi>0 f \\<cdot> p0\n        else if f \\<in> Collect J1.arr then \\<pi>1 f \\<cdot> p1 else null)", "show \"?D j \\<cdot> ?\\<pi> (J.dom j) = ?\\<pi> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if j \\<in> Collect J0.arr then D0 j\n     else if j \\<in> Collect J1.arr then D1 j else null) \\<cdot>\n    (if J.dom j \\<in> Collect J0.arr then \\<pi>0 (J.dom j) \\<cdot> p0\n     else if J.dom j \\<in> Collect J1.arr then \\<pi>1 (J.dom j) \\<cdot> p1\n          else null) =\n    (if j \\<in> Collect J0.arr then \\<pi>0 j \\<cdot> p0\n     else if j \\<in> Collect J1.arr then \\<pi>1 j \\<cdot> p1 else null)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (if j \\<in> Collect J0.arr then D0 j\n     else if j \\<in> Collect J1.arr then D1 j else null) \\<cdot>\n    (if J.dom j \\<in> Collect J0.arr then \\<pi>0 (J.dom j) \\<cdot> p0\n     else if J.dom j \\<in> Collect J1.arr then \\<pi>1 (J.dom j) \\<cdot> p1\n          else null) =\n    (if j \\<in> Collect J0.arr then \\<pi>0 j \\<cdot> p0\n     else if j \\<in> Collect J1.arr then \\<pi>1 j \\<cdot> p1 else null)", "have 0: \"J0.arr j \\<Longrightarrow> D0 j \\<cdot> \\<pi>0 j \\<cdot> p0 = \\<pi>0 j \\<cdot> p0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. J0.arr j \\<Longrightarrow>\n    D0 j \\<cdot> \\<pi>0 j \\<cdot> p0 = \\<pi>0 j \\<cdot> p0", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. J0.arr j \\<Longrightarrow>\n    D0 j \\<cdot> \\<pi>0 j \\<cdot> p0 = \\<pi>0 j \\<cdot> p0", "have \"J0.arr j \\<Longrightarrow> (D0 j \\<cdot> \\<pi>0 j) \\<cdot> p0 = \\<pi>0 j \\<cdot> p0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. J0.arr j \\<Longrightarrow>\n    (D0 j \\<cdot> \\<pi>0 j) \\<cdot> p0 = \\<pi>0 j \\<cdot> p0", "using p0 \\<pi>0.is_natural_1 \\<pi>0.is_natural_2 D0.is_discrete"], ["proof (prove)\nusing this:\n  \\<guillemotleft>p0 : local.dom p0 \\<rightarrow> a0\\<guillemotright>\n  J0.arr ?f \\<Longrightarrow> D0 ?f \\<cdot> \\<pi>0 (J0.dom ?f) = \\<pi>0 ?f\n  J0.arr ?f \\<Longrightarrow>\n  \\<pi>0 (J0.cod ?f) \\<cdot> \\<pi>0.A.map ?f = \\<pi>0 ?f\n  J0.arr = J0.ide\n\ngoal (1 subgoal):\n 1. J0.arr j \\<Longrightarrow>\n    (D0 j \\<cdot> \\<pi>0 j) \\<cdot> p0 = \\<pi>0 j \\<cdot> p0", "by simp"], ["proof (state)\nthis:\n  J0.arr j \\<Longrightarrow>\n  (D0 j \\<cdot> \\<pi>0 j) \\<cdot> p0 = \\<pi>0 j \\<cdot> p0\n\ngoal (1 subgoal):\n 1. J0.arr j \\<Longrightarrow>\n    D0 j \\<cdot> \\<pi>0 j \\<cdot> p0 = \\<pi>0 j \\<cdot> p0", "thus \"J0.arr j \\<Longrightarrow> D0 j \\<cdot> \\<pi>0 j \\<cdot> p0 = \\<pi>0 j \\<cdot> p0\""], ["proof (prove)\nusing this:\n  J0.arr j \\<Longrightarrow>\n  (D0 j \\<cdot> \\<pi>0 j) \\<cdot> p0 = \\<pi>0 j \\<cdot> p0\n\ngoal (1 subgoal):\n 1. J0.arr j \\<Longrightarrow>\n    D0 j \\<cdot> \\<pi>0 j \\<cdot> p0 = \\<pi>0 j \\<cdot> p0", "using comp_assoc"], ["proof (prove)\nusing this:\n  J0.arr j \\<Longrightarrow>\n  (D0 j \\<cdot> \\<pi>0 j) \\<cdot> p0 = \\<pi>0 j \\<cdot> p0\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. J0.arr j \\<Longrightarrow>\n    D0 j \\<cdot> \\<pi>0 j \\<cdot> p0 = \\<pi>0 j \\<cdot> p0", "by simp"], ["proof (state)\nthis:\n  J0.arr j \\<Longrightarrow>\n  D0 j \\<cdot> \\<pi>0 j \\<cdot> p0 = \\<pi>0 j \\<cdot> p0\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  J0.arr j \\<Longrightarrow>\n  D0 j \\<cdot> \\<pi>0 j \\<cdot> p0 = \\<pi>0 j \\<cdot> p0\n\ngoal (1 subgoal):\n 1. (if j \\<in> Collect J0.arr then D0 j\n     else if j \\<in> Collect J1.arr then D1 j else null) \\<cdot>\n    (if J.dom j \\<in> Collect J0.arr then \\<pi>0 (J.dom j) \\<cdot> p0\n     else if J.dom j \\<in> Collect J1.arr then \\<pi>1 (J.dom j) \\<cdot> p1\n          else null) =\n    (if j \\<in> Collect J0.arr then \\<pi>0 j \\<cdot> p0\n     else if j \\<in> Collect J1.arr then \\<pi>1 j \\<cdot> p1 else null)", "have 1: \"J1.arr j \\<Longrightarrow> D1 j \\<cdot> \\<pi>1 j \\<cdot> p1 = \\<pi>1 j \\<cdot> p1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. J1.arr j \\<Longrightarrow>\n    D1 j \\<cdot> \\<pi>1 j \\<cdot> p1 = \\<pi>1 j \\<cdot> p1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. J1.arr j \\<Longrightarrow>\n    D1 j \\<cdot> \\<pi>1 j \\<cdot> p1 = \\<pi>1 j \\<cdot> p1", "have \"J1.arr j \\<Longrightarrow> (D1 j \\<cdot> \\<pi>1 j) \\<cdot> p1 = \\<pi>1 j \\<cdot> p1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. J1.arr j \\<Longrightarrow>\n    (D1 j \\<cdot> \\<pi>1 j) \\<cdot> p1 = \\<pi>1 j \\<cdot> p1", "using p1 \\<pi>1.is_natural_1 \\<pi>1.is_natural_2 D1.is_discrete"], ["proof (prove)\nusing this:\n  \\<guillemotleft>p1 : local.dom p0 \\<rightarrow> a1\\<guillemotright>\n  J1.arr ?f \\<Longrightarrow> D1 ?f \\<cdot> \\<pi>1 (J1.dom ?f) = \\<pi>1 ?f\n  J1.arr ?f \\<Longrightarrow>\n  \\<pi>1 (J1.cod ?f) \\<cdot> \\<pi>1.A.map ?f = \\<pi>1 ?f\n  J1.arr = J1.ide\n\ngoal (1 subgoal):\n 1. J1.arr j \\<Longrightarrow>\n    (D1 j \\<cdot> \\<pi>1 j) \\<cdot> p1 = \\<pi>1 j \\<cdot> p1", "by simp"], ["proof (state)\nthis:\n  J1.arr j \\<Longrightarrow>\n  (D1 j \\<cdot> \\<pi>1 j) \\<cdot> p1 = \\<pi>1 j \\<cdot> p1\n\ngoal (1 subgoal):\n 1. J1.arr j \\<Longrightarrow>\n    D1 j \\<cdot> \\<pi>1 j \\<cdot> p1 = \\<pi>1 j \\<cdot> p1", "thus \"J1.arr j \\<Longrightarrow> D1 j \\<cdot> \\<pi>1 j \\<cdot> p1 = \\<pi>1 j \\<cdot> p1\""], ["proof (prove)\nusing this:\n  J1.arr j \\<Longrightarrow>\n  (D1 j \\<cdot> \\<pi>1 j) \\<cdot> p1 = \\<pi>1 j \\<cdot> p1\n\ngoal (1 subgoal):\n 1. J1.arr j \\<Longrightarrow>\n    D1 j \\<cdot> \\<pi>1 j \\<cdot> p1 = \\<pi>1 j \\<cdot> p1", "using comp_assoc"], ["proof (prove)\nusing this:\n  J1.arr j \\<Longrightarrow>\n  (D1 j \\<cdot> \\<pi>1 j) \\<cdot> p1 = \\<pi>1 j \\<cdot> p1\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. J1.arr j \\<Longrightarrow>\n    D1 j \\<cdot> \\<pi>1 j \\<cdot> p1 = \\<pi>1 j \\<cdot> p1", "by simp"], ["proof (state)\nthis:\n  J1.arr j \\<Longrightarrow>\n  D1 j \\<cdot> \\<pi>1 j \\<cdot> p1 = \\<pi>1 j \\<cdot> p1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  J1.arr j \\<Longrightarrow>\n  D1 j \\<cdot> \\<pi>1 j \\<cdot> p1 = \\<pi>1 j \\<cdot> p1\n\ngoal (1 subgoal):\n 1. (if j \\<in> Collect J0.arr then D0 j\n     else if j \\<in> Collect J1.arr then D1 j else null) \\<cdot>\n    (if J.dom j \\<in> Collect J0.arr then \\<pi>0 (J.dom j) \\<cdot> p0\n     else if J.dom j \\<in> Collect J1.arr then \\<pi>1 (J.dom j) \\<cdot> p1\n          else null) =\n    (if j \\<in> Collect J0.arr then \\<pi>0 j \\<cdot> p0\n     else if j \\<in> Collect J1.arr then \\<pi>1 j \\<cdot> p1 else null)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if j \\<in> Collect J0.arr then D0 j\n     else if j \\<in> Collect J1.arr then D1 j else null) \\<cdot>\n    (if J.dom j \\<in> Collect J0.arr then \\<pi>0 (J.dom j) \\<cdot> p0\n     else if J.dom j \\<in> Collect J1.arr then \\<pi>1 (J.dom j) \\<cdot> p1\n          else null) =\n    (if j \\<in> Collect J0.arr then \\<pi>0 j \\<cdot> p0\n     else if j \\<in> Collect J1.arr then \\<pi>1 j \\<cdot> p1 else null)", "using 0 1"], ["proof (prove)\nusing this:\n  J0.arr j \\<Longrightarrow>\n  D0 j \\<cdot> \\<pi>0 j \\<cdot> p0 = \\<pi>0 j \\<cdot> p0\n  J1.arr j \\<Longrightarrow>\n  D1 j \\<cdot> \\<pi>1 j \\<cdot> p1 = \\<pi>1 j \\<cdot> p1\n\ngoal (1 subgoal):\n 1. (if j \\<in> Collect J0.arr then D0 j\n     else if j \\<in> Collect J1.arr then D1 j else null) \\<cdot>\n    (if J.dom j \\<in> Collect J0.arr then \\<pi>0 (J.dom j) \\<cdot> p0\n     else if J.dom j \\<in> Collect J1.arr then \\<pi>1 (J.dom j) \\<cdot> p1\n          else null) =\n    (if j \\<in> Collect J0.arr then \\<pi>0 j \\<cdot> p0\n     else if j \\<in> Collect J1.arr then \\<pi>1 j \\<cdot> p1 else null)", "by auto"], ["proof (state)\nthis:\n  (if j \\<in> Collect J0.arr then D0 j\n   else if j \\<in> Collect J1.arr then D1 j else null) \\<cdot>\n  (if J.dom j \\<in> Collect J0.arr then \\<pi>0 (J.dom j) \\<cdot> p0\n   else if J.dom j \\<in> Collect J1.arr then \\<pi>1 (J.dom j) \\<cdot> p1\n        else null) =\n  (if j \\<in> Collect J0.arr then \\<pi>0 j \\<cdot> p0\n   else if j \\<in> Collect J1.arr then \\<pi>1 j \\<cdot> p1 else null)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if j \\<in> Collect J0.arr then D0 j\n   else if j \\<in> Collect J1.arr then D1 j else null) \\<cdot>\n  (if J.dom j \\<in> Collect J0.arr then \\<pi>0 (J.dom j) \\<cdot> p0\n   else if J.dom j \\<in> Collect J1.arr then \\<pi>1 (J.dom j) \\<cdot> p1\n        else null) =\n  (if j \\<in> Collect J0.arr then \\<pi>0 j \\<cdot> p0\n   else if j \\<in> Collect J1.arr then \\<pi>1 j \\<cdot> p1 else null)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       J.arr f \\<Longrightarrow>\n       (if J.cod f \\<in> Collect J0.arr then \\<pi>0 (J.cod f) \\<cdot> p0\n        else if J.cod f \\<in> Collect J1.arr\n             then \\<pi>1 (J.cod f) \\<cdot> p1 else null) \\<cdot>\n       A.map f =\n       (if f \\<in> Collect J0.arr then \\<pi>0 f \\<cdot> p0\n        else if f \\<in> Collect J1.arr then \\<pi>1 f \\<cdot> p1 else null)", "show \"?\\<pi> (J.cod j) \\<cdot> A.map j = ?\\<pi> j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if J.cod j \\<in> Collect J0.arr then \\<pi>0 (J.cod j) \\<cdot> p0\n     else if J.cod j \\<in> Collect J1.arr then \\<pi>1 (J.cod j) \\<cdot> p1\n          else null) \\<cdot>\n    A.map j =\n    (if j \\<in> Collect J0.arr then \\<pi>0 j \\<cdot> p0\n     else if j \\<in> Collect J1.arr then \\<pi>1 j \\<cdot> p1 else null)", "using j comp_arr_dom p0 p1 comp_assoc"], ["proof (prove)\nusing this:\n  J.arr j\n  \\<lbrakk>arr ?f; local.dom ?f = ?a\\<rbrakk>\n  \\<Longrightarrow> ?f \\<cdot> ?a = ?f\n  \\<guillemotleft>p0 : local.dom p0 \\<rightarrow> a0\\<guillemotright>\n  \\<guillemotleft>p1 : local.dom p0 \\<rightarrow> a1\\<guillemotright>\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. (if J.cod j \\<in> Collect J0.arr then \\<pi>0 (J.cod j) \\<cdot> p0\n     else if J.cod j \\<in> Collect J1.arr then \\<pi>1 (J.cod j) \\<cdot> p1\n          else null) \\<cdot>\n    A.map j =\n    (if j \\<in> Collect J0.arr then \\<pi>0 j \\<cdot> p0\n     else if j \\<in> Collect J1.arr then \\<pi>1 j \\<cdot> p1 else null)", "by auto"], ["proof (state)\nthis:\n  (if J.cod j \\<in> Collect J0.arr then \\<pi>0 (J.cod j) \\<cdot> p0\n   else if J.cod j \\<in> Collect J1.arr then \\<pi>1 (J.cod j) \\<cdot> p1\n        else null) \\<cdot>\n  A.map j =\n  (if j \\<in> Collect J0.arr then \\<pi>0 j \\<cdot> p0\n   else if j \\<in> Collect J1.arr then \\<pi>1 j \\<cdot> p1 else null)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\ngoal (1 subgoal):\n 1. has_as_product J.comp\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then D0 i\n         else if i \\<in> Collect J1.arr then D1 i else null)\n     (local.dom p0)", "interpret \\<pi>: cone J.comp C ?D ?a ?\\<pi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. D.cone (local.dom p0)\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n         else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null)", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. has_as_product J.comp\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then D0 i\n         else if i \\<in> Collect J1.arr then D1 i else null)\n     (local.dom p0)", "interpret \\<pi>: product_cone J.comp C ?D ?a ?\\<pi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. product_cone J.comp (\\<cdot>)\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then D0 i\n         else if i \\<in> Collect J1.arr then D1 i else null)\n     (local.dom p0)\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n         else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' \\<chi>'.\n       D.cone a' \\<chi>' \\<Longrightarrow>\n       \\<exists>!f.\n          \\<guillemotleft>f : a' \\<rightarrow> local.dom\n          p0\\<guillemotright> \\<and>\n          D.cones_map f\n           (\\<lambda>i.\n               if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n               else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                    else null) =\n          \\<chi>'", "show \"\\<And>a' \\<chi>'. D.cone a' \\<chi>' \\<Longrightarrow> \\<exists>!f. \\<guillemotleft>f : a' \\<rightarrow> ?a\\<guillemotright> \\<and> D.cones_map f ?\\<pi> = \\<chi>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a' \\<chi>'.\n       D.cone a' \\<chi>' \\<Longrightarrow>\n       \\<exists>!f.\n          \\<guillemotleft>f : a' \\<rightarrow> local.dom\n          p0\\<guillemotright> \\<and>\n          D.cones_map f\n           (\\<lambda>i.\n               if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n               else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                    else null) =\n          \\<chi>'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' \\<chi>'.\n       D.cone a' \\<chi>' \\<Longrightarrow>\n       \\<exists>!f.\n          \\<guillemotleft>f : a' \\<rightarrow> local.dom\n          p0\\<guillemotright> \\<and>\n          D.cones_map f\n           (\\<lambda>i.\n               if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n               else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                    else null) =\n          \\<chi>'", "fix a' \\<chi>'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' \\<chi>'.\n       D.cone a' \\<chi>' \\<Longrightarrow>\n       \\<exists>!f.\n          \\<guillemotleft>f : a' \\<rightarrow> local.dom\n          p0\\<guillemotright> \\<and>\n          D.cones_map f\n           (\\<lambda>i.\n               if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n               else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                    else null) =\n          \\<chi>'", "assume \\<chi>': \"D.cone a' \\<chi>'\""], ["proof (state)\nthis:\n  D.cone a' \\<chi>'\n\ngoal (1 subgoal):\n 1. \\<And>a' \\<chi>'.\n       D.cone a' \\<chi>' \\<Longrightarrow>\n       \\<exists>!f.\n          \\<guillemotleft>f : a' \\<rightarrow> local.dom\n          p0\\<guillemotright> \\<and>\n          D.cones_map f\n           (\\<lambda>i.\n               if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n               else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                    else null) =\n          \\<chi>'", "interpret \\<chi>': cone J.comp C ?D a' \\<chi>'"], ["proof (prove)\ngoal (1 subgoal):\n 1. D.cone a' \\<chi>'", "using \\<chi>'"], ["proof (prove)\nusing this:\n  D.cone a' \\<chi>'\n\ngoal (1 subgoal):\n 1. D.cone a' \\<chi>'", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a' \\<chi>'.\n       D.cone a' \\<chi>' \\<Longrightarrow>\n       \\<exists>!f.\n          \\<guillemotleft>f : a' \\<rightarrow> local.dom\n          p0\\<guillemotright> \\<and>\n          D.cones_map f\n           (\\<lambda>i.\n               if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n               else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                    else null) =\n          \\<chi>'", "show \"\\<exists>!f. \\<guillemotleft>f : a' \\<rightarrow> ?a\\<guillemotright> \\<and> D.cones_map f ?\\<pi> = \\<chi>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!f.\n       \\<guillemotleft>f : a' \\<rightarrow> local.dom\n       p0\\<guillemotright> \\<and>\n       D.cones_map f\n        (\\<lambda>i.\n            if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n            else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                 else null) =\n       \\<chi>'", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : a' \\<rightarrow> local.dom\n     p0\\<guillemotright> \\<and>\n    D.cones_map ?a\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n         else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n              else null) =\n    \\<chi>'\n 2. \\<And>f.\n       \\<guillemotleft>f : a' \\<rightarrow> local.dom\n       p0\\<guillemotright> \\<and>\n       D.cones_map f\n        (\\<lambda>i.\n            if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n            else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                 else null) =\n       \\<chi>' \\<Longrightarrow>\n       f = ?a", "let ?\\<chi>0' = \"\\<lambda>i. if i \\<in> Collect J0.arr then \\<chi>' i else null\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : a' \\<rightarrow> local.dom\n     p0\\<guillemotright> \\<and>\n    D.cones_map ?a\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n         else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n              else null) =\n    \\<chi>'\n 2. \\<And>f.\n       \\<guillemotleft>f : a' \\<rightarrow> local.dom\n       p0\\<guillemotright> \\<and>\n       D.cones_map f\n        (\\<lambda>i.\n            if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n            else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                 else null) =\n       \\<chi>' \\<Longrightarrow>\n       f = ?a", "let ?\\<chi>1' = \"\\<lambda>i. if i \\<in> Collect J1.arr then \\<chi>' i else null\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : a' \\<rightarrow> local.dom\n     p0\\<guillemotright> \\<and>\n    D.cones_map ?a\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n         else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n              else null) =\n    \\<chi>'\n 2. \\<And>f.\n       \\<guillemotleft>f : a' \\<rightarrow> local.dom\n       p0\\<guillemotright> \\<and>\n       D.cones_map f\n        (\\<lambda>i.\n            if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n            else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                 else null) =\n       \\<chi>' \\<Longrightarrow>\n       f = ?a", "have 0: \"\\<And>i. i \\<in> Collect J0.arr \\<Longrightarrow> \\<chi>' i \\<in> hom a' (D0 i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> Collect J0.arr \\<Longrightarrow>\n       \\<chi>' i \\<in> hom a' (D0 i)", "using J.arr_char"], ["proof (prove)\nusing this:\n  J.arr ?f = (?f \\<in> Collect J0.arr \\<union> Collect J1.arr)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> Collect J0.arr \\<Longrightarrow>\n       \\<chi>' i \\<in> hom a' (D0 i)", "by auto"], ["proof (state)\nthis:\n  ?i4 \\<in> Collect J0.arr \\<Longrightarrow>\n  \\<chi>' ?i4 \\<in> hom a' (D0 ?i4)\n\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : a' \\<rightarrow> local.dom\n     p0\\<guillemotright> \\<and>\n    D.cones_map ?a\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n         else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n              else null) =\n    \\<chi>'\n 2. \\<And>f.\n       \\<guillemotleft>f : a' \\<rightarrow> local.dom\n       p0\\<guillemotright> \\<and>\n       D.cones_map f\n        (\\<lambda>i.\n            if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n            else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                 else null) =\n       \\<chi>' \\<Longrightarrow>\n       f = ?a", "have 1: \"\\<And>i. i \\<in> Collect J1.arr \\<Longrightarrow> \\<chi>' i \\<in> hom a' (D1 i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> Collect J1.arr \\<Longrightarrow>\n       \\<chi>' i \\<in> hom a' (D1 i)", "using J.arr_char \\<open>Collect J0.arr \\<inter> Collect J1.arr = {}\\<close>"], ["proof (prove)\nusing this:\n  J.arr ?f = (?f \\<in> Collect J0.arr \\<union> Collect J1.arr)\n  Collect J0.arr \\<inter> Collect J1.arr = {}\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       i \\<in> Collect J1.arr \\<Longrightarrow>\n       \\<chi>' i \\<in> hom a' (D1 i)", "by force"], ["proof (state)\nthis:\n  ?i4 \\<in> Collect J1.arr \\<Longrightarrow>\n  \\<chi>' ?i4 \\<in> hom a' (D1 ?i4)\n\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : a' \\<rightarrow> local.dom\n     p0\\<guillemotright> \\<and>\n    D.cones_map ?a\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n         else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n              else null) =\n    \\<chi>'\n 2. \\<And>f.\n       \\<guillemotleft>f : a' \\<rightarrow> local.dom\n       p0\\<guillemotright> \\<and>\n       D.cones_map f\n        (\\<lambda>i.\n            if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n            else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                 else null) =\n       \\<chi>' \\<Longrightarrow>\n       f = ?a", "interpret A0': constant_functor J0 C a'"], ["proof (prove)\ngoal (1 subgoal):\n 1. constant_functor J0 (\\<cdot>) a'", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. ide a'", "using \\<chi>'.ide_apex"], ["proof (prove)\nusing this:\n  ide a'\n\ngoal (1 subgoal):\n 1. ide a'", "by auto"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : a' \\<rightarrow> local.dom\n     p0\\<guillemotright> \\<and>\n    D.cones_map ?a\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n         else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n              else null) =\n    \\<chi>'\n 2. \\<And>f.\n       \\<guillemotleft>f : a' \\<rightarrow> local.dom\n       p0\\<guillemotright> \\<and>\n       D.cones_map f\n        (\\<lambda>i.\n            if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n            else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                 else null) =\n       \\<chi>' \\<Longrightarrow>\n       f = ?a", "interpret A1': constant_functor J1 C a'"], ["proof (prove)\ngoal (1 subgoal):\n 1. constant_functor J1 (\\<cdot>) a'", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. ide a'", "using \\<chi>'.ide_apex"], ["proof (prove)\nusing this:\n  ide a'\n\ngoal (1 subgoal):\n 1. ide a'", "by auto"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : a' \\<rightarrow> local.dom\n     p0\\<guillemotright> \\<and>\n    D.cones_map ?a\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n         else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n              else null) =\n    \\<chi>'\n 2. \\<And>f.\n       \\<guillemotleft>f : a' \\<rightarrow> local.dom\n       p0\\<guillemotright> \\<and>\n       D.cones_map f\n        (\\<lambda>i.\n            if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n            else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                 else null) =\n       \\<chi>' \\<Longrightarrow>\n       f = ?a", "interpret \\<chi>0': cone J0 C D0 a' ?\\<chi>0'"], ["proof (prove)\ngoal (1 subgoal):\n 1. D0.cone a'\n     (\\<lambda>i. if i \\<in> Collect J0.arr then \\<chi>' i else null)", "proof (unfold_locales)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>f.\n       \\<not> J0.arr f \\<Longrightarrow>\n       (if f \\<in> Collect J0.arr then \\<chi>' f else null) = null\n 2. \\<And>f.\n       J0.arr f \\<Longrightarrow>\n       local.dom (if f \\<in> Collect J0.arr then \\<chi>' f else null) =\n       A0'.map (J0.dom f)\n 3. \\<And>f.\n       J0.arr f \\<Longrightarrow>\n       cod (if f \\<in> Collect J0.arr then \\<chi>' f else null) =\n       D0 (J0.cod f)\n 4. \\<And>f.\n       J0.arr f \\<Longrightarrow>\n       D0 f \\<cdot>\n       (if J0.dom f \\<in> Collect J0.arr then \\<chi>' (J0.dom f)\n        else null) =\n       (if f \\<in> Collect J0.arr then \\<chi>' f else null)\n 5. \\<And>f.\n       J0.arr f \\<Longrightarrow>\n       (if J0.cod f \\<in> Collect J0.arr then \\<chi>' (J0.cod f)\n        else null) \\<cdot>\n       A0'.map f =\n       (if f \\<in> Collect J0.arr then \\<chi>' f else null)", "fix j"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>f.\n       \\<not> J0.arr f \\<Longrightarrow>\n       (if f \\<in> Collect J0.arr then \\<chi>' f else null) = null\n 2. \\<And>f.\n       J0.arr f \\<Longrightarrow>\n       local.dom (if f \\<in> Collect J0.arr then \\<chi>' f else null) =\n       A0'.map (J0.dom f)\n 3. \\<And>f.\n       J0.arr f \\<Longrightarrow>\n       cod (if f \\<in> Collect J0.arr then \\<chi>' f else null) =\n       D0 (J0.cod f)\n 4. \\<And>f.\n       J0.arr f \\<Longrightarrow>\n       D0 f \\<cdot>\n       (if J0.dom f \\<in> Collect J0.arr then \\<chi>' (J0.dom f)\n        else null) =\n       (if f \\<in> Collect J0.arr then \\<chi>' f else null)\n 5. \\<And>f.\n       J0.arr f \\<Longrightarrow>\n       (if J0.cod f \\<in> Collect J0.arr then \\<chi>' (J0.cod f)\n        else null) \\<cdot>\n       A0'.map f =\n       (if f \\<in> Collect J0.arr then \\<chi>' f else null)", "show \"\\<not> J0.arr j \\<Longrightarrow> (if j \\<in> Collect J0.arr then \\<chi>' j else null) = null\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> J0.arr j \\<Longrightarrow>\n    (if j \\<in> Collect J0.arr then \\<chi>' j else null) = null", "by simp"], ["proof (state)\nthis:\n  \\<not> J0.arr j \\<Longrightarrow>\n  (if j \\<in> Collect J0.arr then \\<chi>' j else null) = null\n\ngoal (4 subgoals):\n 1. \\<And>f.\n       J0.arr f \\<Longrightarrow>\n       local.dom (if f \\<in> Collect J0.arr then \\<chi>' f else null) =\n       A0'.map (J0.dom f)\n 2. \\<And>f.\n       J0.arr f \\<Longrightarrow>\n       cod (if f \\<in> Collect J0.arr then \\<chi>' f else null) =\n       D0 (J0.cod f)\n 3. \\<And>f.\n       J0.arr f \\<Longrightarrow>\n       D0 f \\<cdot>\n       (if J0.dom f \\<in> Collect J0.arr then \\<chi>' (J0.dom f)\n        else null) =\n       (if f \\<in> Collect J0.arr then \\<chi>' f else null)\n 4. \\<And>f.\n       J0.arr f \\<Longrightarrow>\n       (if J0.cod f \\<in> Collect J0.arr then \\<chi>' (J0.cod f)\n        else null) \\<cdot>\n       A0'.map f =\n       (if f \\<in> Collect J0.arr then \\<chi>' f else null)", "assume j: \"J0.arr j\""], ["proof (state)\nthis:\n  J0.arr j\n\ngoal (4 subgoals):\n 1. \\<And>f.\n       J0.arr f \\<Longrightarrow>\n       local.dom (if f \\<in> Collect J0.arr then \\<chi>' f else null) =\n       A0'.map (J0.dom f)\n 2. \\<And>f.\n       J0.arr f \\<Longrightarrow>\n       cod (if f \\<in> Collect J0.arr then \\<chi>' f else null) =\n       D0 (J0.cod f)\n 3. \\<And>f.\n       J0.arr f \\<Longrightarrow>\n       D0 f \\<cdot>\n       (if J0.dom f \\<in> Collect J0.arr then \\<chi>' (J0.dom f)\n        else null) =\n       (if f \\<in> Collect J0.arr then \\<chi>' f else null)\n 4. \\<And>f.\n       J0.arr f \\<Longrightarrow>\n       (if J0.cod f \\<in> Collect J0.arr then \\<chi>' (J0.cod f)\n        else null) \\<cdot>\n       A0'.map f =\n       (if f \\<in> Collect J0.arr then \\<chi>' f else null)", "show 0: \"dom (?\\<chi>0' j) = A0'.map (J0.dom j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dom (if j \\<in> Collect J0.arr then \\<chi>' j else null) =\n    A0'.map (J0.dom j)", "using j"], ["proof (prove)\nusing this:\n  J0.arr j\n\ngoal (1 subgoal):\n 1. local.dom (if j \\<in> Collect J0.arr then \\<chi>' j else null) =\n    A0'.map (J0.dom j)", "by simp"], ["proof (state)\nthis:\n  local.dom (if j \\<in> Collect J0.arr then \\<chi>' j else null) =\n  A0'.map (J0.dom j)\n\ngoal (3 subgoals):\n 1. \\<And>f.\n       J0.arr f \\<Longrightarrow>\n       cod (if f \\<in> Collect J0.arr then \\<chi>' f else null) =\n       D0 (J0.cod f)\n 2. \\<And>f.\n       J0.arr f \\<Longrightarrow>\n       D0 f \\<cdot>\n       (if J0.dom f \\<in> Collect J0.arr then \\<chi>' (J0.dom f)\n        else null) =\n       (if f \\<in> Collect J0.arr then \\<chi>' f else null)\n 3. \\<And>f.\n       J0.arr f \\<Longrightarrow>\n       (if J0.cod f \\<in> Collect J0.arr then \\<chi>' (J0.cod f)\n        else null) \\<cdot>\n       A0'.map f =\n       (if f \\<in> Collect J0.arr then \\<chi>' f else null)", "show 1: \"cod (?\\<chi>0' j) = D0 (J0.cod j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cod (if j \\<in> Collect J0.arr then \\<chi>' j else null) = D0 (J0.cod j)", "using j J.arr_char J.cod_char D0.is_discrete"], ["proof (prove)\nusing this:\n  J0.arr j\n  J.arr ?f = (?f \\<in> Collect J0.arr \\<union> Collect J1.arr)\n  J.cod ?f =\n  (if ?f \\<in> Collect J0.arr \\<union> Collect J1.arr then ?f else J.null)\n  J0.arr = J0.ide\n\ngoal (1 subgoal):\n 1. cod (if j \\<in> Collect J0.arr then \\<chi>' j else null) = D0 (J0.cod j)", "by simp"], ["proof (state)\nthis:\n  cod (if j \\<in> Collect J0.arr then \\<chi>' j else null) = D0 (J0.cod j)\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       J0.arr f \\<Longrightarrow>\n       D0 f \\<cdot>\n       (if J0.dom f \\<in> Collect J0.arr then \\<chi>' (J0.dom f)\n        else null) =\n       (if f \\<in> Collect J0.arr then \\<chi>' f else null)\n 2. \\<And>f.\n       J0.arr f \\<Longrightarrow>\n       (if J0.cod f \\<in> Collect J0.arr then \\<chi>' (J0.cod f)\n        else null) \\<cdot>\n       A0'.map f =\n       (if f \\<in> Collect J0.arr then \\<chi>' f else null)", "show \"D0 j \\<cdot> (?\\<chi>0' (J0.dom j)) = ?\\<chi>0' j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D0 j \\<cdot>\n    (if J0.dom j \\<in> Collect J0.arr then \\<chi>' (J0.dom j) else null) =\n    (if j \\<in> Collect J0.arr then \\<chi>' j else null)", "using 1 j J.arr_char D0.is_discrete comp_cod_arr"], ["proof (prove)\nusing this:\n  cod (if j \\<in> Collect J0.arr then \\<chi>' j else null) = D0 (J0.cod j)\n  J0.arr j\n  J.arr ?f = (?f \\<in> Collect J0.arr \\<union> Collect J1.arr)\n  J0.arr = J0.ide\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n\ngoal (1 subgoal):\n 1. D0 j \\<cdot>\n    (if J0.dom j \\<in> Collect J0.arr then \\<chi>' (J0.dom j) else null) =\n    (if j \\<in> Collect J0.arr then \\<chi>' j else null)", "by simp"], ["proof (state)\nthis:\n  D0 j \\<cdot>\n  (if J0.dom j \\<in> Collect J0.arr then \\<chi>' (J0.dom j) else null) =\n  (if j \\<in> Collect J0.arr then \\<chi>' j else null)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       J0.arr f \\<Longrightarrow>\n       (if J0.cod f \\<in> Collect J0.arr then \\<chi>' (J0.cod f)\n        else null) \\<cdot>\n       A0'.map f =\n       (if f \\<in> Collect J0.arr then \\<chi>' f else null)", "show \"?\\<chi>0' (J0.cod j) \\<cdot> A0'.map j = ?\\<chi>0' j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if J0.cod j \\<in> Collect J0.arr then \\<chi>' (J0.cod j)\n     else null) \\<cdot>\n    A0'.map j =\n    (if j \\<in> Collect J0.arr then \\<chi>' j else null)", "using 0 j J.arr_char D0.is_discrete comp_arr_dom"], ["proof (prove)\nusing this:\n  local.dom (if j \\<in> Collect J0.arr then \\<chi>' j else null) =\n  A0'.map (J0.dom j)\n  J0.arr j\n  J.arr ?f = (?f \\<in> Collect J0.arr \\<union> Collect J1.arr)\n  J0.arr = J0.ide\n  \\<lbrakk>arr ?f; local.dom ?f = ?a\\<rbrakk>\n  \\<Longrightarrow> ?f \\<cdot> ?a = ?f\n\ngoal (1 subgoal):\n 1. (if J0.cod j \\<in> Collect J0.arr then \\<chi>' (J0.cod j)\n     else null) \\<cdot>\n    A0'.map j =\n    (if j \\<in> Collect J0.arr then \\<chi>' j else null)", "by simp"], ["proof (state)\nthis:\n  (if J0.cod j \\<in> Collect J0.arr then \\<chi>' (J0.cod j)\n   else null) \\<cdot>\n  A0'.map j =\n  (if j \\<in> Collect J0.arr then \\<chi>' j else null)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : a' \\<rightarrow> local.dom\n     p0\\<guillemotright> \\<and>\n    D.cones_map ?a\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n         else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n              else null) =\n    \\<chi>'\n 2. \\<And>f.\n       \\<guillemotleft>f : a' \\<rightarrow> local.dom\n       p0\\<guillemotright> \\<and>\n       D.cones_map f\n        (\\<lambda>i.\n            if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n            else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                 else null) =\n       \\<chi>' \\<Longrightarrow>\n       f = ?a", "interpret \\<chi>1': cone J1 C D1 a' ?\\<chi>1'"], ["proof (prove)\ngoal (1 subgoal):\n 1. D1.cone a'\n     (\\<lambda>i. if i \\<in> Collect J1.arr then \\<chi>' i else null)", "proof (unfold_locales)"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>f.\n       \\<not> J1.arr f \\<Longrightarrow>\n       (if f \\<in> Collect J1.arr then \\<chi>' f else null) = null\n 2. \\<And>f.\n       J1.arr f \\<Longrightarrow>\n       local.dom (if f \\<in> Collect J1.arr then \\<chi>' f else null) =\n       A1'.map (J1.dom f)\n 3. \\<And>f.\n       J1.arr f \\<Longrightarrow>\n       cod (if f \\<in> Collect J1.arr then \\<chi>' f else null) =\n       D1 (J1.cod f)\n 4. \\<And>f.\n       J1.arr f \\<Longrightarrow>\n       D1 f \\<cdot>\n       (if J1.dom f \\<in> Collect J1.arr then \\<chi>' (J1.dom f)\n        else null) =\n       (if f \\<in> Collect J1.arr then \\<chi>' f else null)\n 5. \\<And>f.\n       J1.arr f \\<Longrightarrow>\n       (if J1.cod f \\<in> Collect J1.arr then \\<chi>' (J1.cod f)\n        else null) \\<cdot>\n       A1'.map f =\n       (if f \\<in> Collect J1.arr then \\<chi>' f else null)", "fix j"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>f.\n       \\<not> J1.arr f \\<Longrightarrow>\n       (if f \\<in> Collect J1.arr then \\<chi>' f else null) = null\n 2. \\<And>f.\n       J1.arr f \\<Longrightarrow>\n       local.dom (if f \\<in> Collect J1.arr then \\<chi>' f else null) =\n       A1'.map (J1.dom f)\n 3. \\<And>f.\n       J1.arr f \\<Longrightarrow>\n       cod (if f \\<in> Collect J1.arr then \\<chi>' f else null) =\n       D1 (J1.cod f)\n 4. \\<And>f.\n       J1.arr f \\<Longrightarrow>\n       D1 f \\<cdot>\n       (if J1.dom f \\<in> Collect J1.arr then \\<chi>' (J1.dom f)\n        else null) =\n       (if f \\<in> Collect J1.arr then \\<chi>' f else null)\n 5. \\<And>f.\n       J1.arr f \\<Longrightarrow>\n       (if J1.cod f \\<in> Collect J1.arr then \\<chi>' (J1.cod f)\n        else null) \\<cdot>\n       A1'.map f =\n       (if f \\<in> Collect J1.arr then \\<chi>' f else null)", "show \"\\<not> J1.arr j \\<Longrightarrow> (if j \\<in> Collect J1.arr then \\<chi>' j else null) = null\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> J1.arr j \\<Longrightarrow>\n    (if j \\<in> Collect J1.arr then \\<chi>' j else null) = null", "by simp"], ["proof (state)\nthis:\n  \\<not> J1.arr j \\<Longrightarrow>\n  (if j \\<in> Collect J1.arr then \\<chi>' j else null) = null\n\ngoal (4 subgoals):\n 1. \\<And>f.\n       J1.arr f \\<Longrightarrow>\n       local.dom (if f \\<in> Collect J1.arr then \\<chi>' f else null) =\n       A1'.map (J1.dom f)\n 2. \\<And>f.\n       J1.arr f \\<Longrightarrow>\n       cod (if f \\<in> Collect J1.arr then \\<chi>' f else null) =\n       D1 (J1.cod f)\n 3. \\<And>f.\n       J1.arr f \\<Longrightarrow>\n       D1 f \\<cdot>\n       (if J1.dom f \\<in> Collect J1.arr then \\<chi>' (J1.dom f)\n        else null) =\n       (if f \\<in> Collect J1.arr then \\<chi>' f else null)\n 4. \\<And>f.\n       J1.arr f \\<Longrightarrow>\n       (if J1.cod f \\<in> Collect J1.arr then \\<chi>' (J1.cod f)\n        else null) \\<cdot>\n       A1'.map f =\n       (if f \\<in> Collect J1.arr then \\<chi>' f else null)", "assume j: \"J1.arr j\""], ["proof (state)\nthis:\n  J1.arr j\n\ngoal (4 subgoals):\n 1. \\<And>f.\n       J1.arr f \\<Longrightarrow>\n       local.dom (if f \\<in> Collect J1.arr then \\<chi>' f else null) =\n       A1'.map (J1.dom f)\n 2. \\<And>f.\n       J1.arr f \\<Longrightarrow>\n       cod (if f \\<in> Collect J1.arr then \\<chi>' f else null) =\n       D1 (J1.cod f)\n 3. \\<And>f.\n       J1.arr f \\<Longrightarrow>\n       D1 f \\<cdot>\n       (if J1.dom f \\<in> Collect J1.arr then \\<chi>' (J1.dom f)\n        else null) =\n       (if f \\<in> Collect J1.arr then \\<chi>' f else null)\n 4. \\<And>f.\n       J1.arr f \\<Longrightarrow>\n       (if J1.cod f \\<in> Collect J1.arr then \\<chi>' (J1.cod f)\n        else null) \\<cdot>\n       A1'.map f =\n       (if f \\<in> Collect J1.arr then \\<chi>' f else null)", "show 0: \"dom (?\\<chi>1' j) = A1'.map (J1.dom j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dom (if j \\<in> Collect J1.arr then \\<chi>' j else null) =\n    A1'.map (J1.dom j)", "using j"], ["proof (prove)\nusing this:\n  J1.arr j\n\ngoal (1 subgoal):\n 1. local.dom (if j \\<in> Collect J1.arr then \\<chi>' j else null) =\n    A1'.map (J1.dom j)", "by simp"], ["proof (state)\nthis:\n  local.dom (if j \\<in> Collect J1.arr then \\<chi>' j else null) =\n  A1'.map (J1.dom j)\n\ngoal (3 subgoals):\n 1. \\<And>f.\n       J1.arr f \\<Longrightarrow>\n       cod (if f \\<in> Collect J1.arr then \\<chi>' f else null) =\n       D1 (J1.cod f)\n 2. \\<And>f.\n       J1.arr f \\<Longrightarrow>\n       D1 f \\<cdot>\n       (if J1.dom f \\<in> Collect J1.arr then \\<chi>' (J1.dom f)\n        else null) =\n       (if f \\<in> Collect J1.arr then \\<chi>' f else null)\n 3. \\<And>f.\n       J1.arr f \\<Longrightarrow>\n       (if J1.cod f \\<in> Collect J1.arr then \\<chi>' (J1.cod f)\n        else null) \\<cdot>\n       A1'.map f =\n       (if f \\<in> Collect J1.arr then \\<chi>' f else null)", "show 1: \"cod (?\\<chi>1' j) = D1 (J1.cod j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cod (if j \\<in> Collect J1.arr then \\<chi>' j else null) = D1 (J1.cod j)", "using assms(4) j J.arr_char J.cod_char D1.is_discrete"], ["proof (prove)\nusing this:\n  Collect J0.arr \\<inter> Collect J1.arr = {}\n  J1.arr j\n  J.arr ?f = (?f \\<in> Collect J0.arr \\<union> Collect J1.arr)\n  J.cod ?f =\n  (if ?f \\<in> Collect J0.arr \\<union> Collect J1.arr then ?f else J.null)\n  J1.arr = J1.ide\n\ngoal (1 subgoal):\n 1. cod (if j \\<in> Collect J1.arr then \\<chi>' j else null) = D1 (J1.cod j)", "by auto"], ["proof (state)\nthis:\n  cod (if j \\<in> Collect J1.arr then \\<chi>' j else null) = D1 (J1.cod j)\n\ngoal (2 subgoals):\n 1. \\<And>f.\n       J1.arr f \\<Longrightarrow>\n       D1 f \\<cdot>\n       (if J1.dom f \\<in> Collect J1.arr then \\<chi>' (J1.dom f)\n        else null) =\n       (if f \\<in> Collect J1.arr then \\<chi>' f else null)\n 2. \\<And>f.\n       J1.arr f \\<Longrightarrow>\n       (if J1.cod f \\<in> Collect J1.arr then \\<chi>' (J1.cod f)\n        else null) \\<cdot>\n       A1'.map f =\n       (if f \\<in> Collect J1.arr then \\<chi>' f else null)", "show \"D1 j \\<cdot> (?\\<chi>1' (J1.dom j)) = ?\\<chi>1' j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D1 j \\<cdot>\n    (if J1.dom j \\<in> Collect J1.arr then \\<chi>' (J1.dom j) else null) =\n    (if j \\<in> Collect J1.arr then \\<chi>' j else null)", "using 1 j J.arr_char D1.is_discrete comp_cod_arr"], ["proof (prove)\nusing this:\n  cod (if j \\<in> Collect J1.arr then \\<chi>' j else null) = D1 (J1.cod j)\n  J1.arr j\n  J.arr ?f = (?f \\<in> Collect J0.arr \\<union> Collect J1.arr)\n  J1.arr = J1.ide\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n\ngoal (1 subgoal):\n 1. D1 j \\<cdot>\n    (if J1.dom j \\<in> Collect J1.arr then \\<chi>' (J1.dom j) else null) =\n    (if j \\<in> Collect J1.arr then \\<chi>' j else null)", "by simp"], ["proof (state)\nthis:\n  D1 j \\<cdot>\n  (if J1.dom j \\<in> Collect J1.arr then \\<chi>' (J1.dom j) else null) =\n  (if j \\<in> Collect J1.arr then \\<chi>' j else null)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       J1.arr f \\<Longrightarrow>\n       (if J1.cod f \\<in> Collect J1.arr then \\<chi>' (J1.cod f)\n        else null) \\<cdot>\n       A1'.map f =\n       (if f \\<in> Collect J1.arr then \\<chi>' f else null)", "show \"?\\<chi>1' (J1.cod j) \\<cdot> A1'.map j = ?\\<chi>1' j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if J1.cod j \\<in> Collect J1.arr then \\<chi>' (J1.cod j)\n     else null) \\<cdot>\n    A1'.map j =\n    (if j \\<in> Collect J1.arr then \\<chi>' j else null)", "using 0 j J.arr_char D1.is_discrete comp_arr_dom"], ["proof (prove)\nusing this:\n  local.dom (if j \\<in> Collect J1.arr then \\<chi>' j else null) =\n  A1'.map (J1.dom j)\n  J1.arr j\n  J.arr ?f = (?f \\<in> Collect J0.arr \\<union> Collect J1.arr)\n  J1.arr = J1.ide\n  \\<lbrakk>arr ?f; local.dom ?f = ?a\\<rbrakk>\n  \\<Longrightarrow> ?f \\<cdot> ?a = ?f\n\ngoal (1 subgoal):\n 1. (if J1.cod j \\<in> Collect J1.arr then \\<chi>' (J1.cod j)\n     else null) \\<cdot>\n    A1'.map j =\n    (if j \\<in> Collect J1.arr then \\<chi>' j else null)", "by simp"], ["proof (state)\nthis:\n  (if J1.cod j \\<in> Collect J1.arr then \\<chi>' (J1.cod j)\n   else null) \\<cdot>\n  A1'.map j =\n  (if j \\<in> Collect J1.arr then \\<chi>' j else null)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : a' \\<rightarrow> local.dom\n     p0\\<guillemotright> \\<and>\n    D.cones_map ?a\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n         else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n              else null) =\n    \\<chi>'\n 2. \\<And>f.\n       \\<guillemotleft>f : a' \\<rightarrow> local.dom\n       p0\\<guillemotright> \\<and>\n       D.cones_map f\n        (\\<lambda>i.\n            if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n            else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                 else null) =\n       \\<chi>' \\<Longrightarrow>\n       f = ?a", "define f0 where \"f0 = \\<pi>0.induced_arrow a' ?\\<chi>0'\""], ["proof (state)\nthis:\n  f0 =\n  \\<pi>0.induced_arrow a'\n   (\\<lambda>i. if i \\<in> Collect J0.arr then \\<chi>' i else null)\n\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : a' \\<rightarrow> local.dom\n     p0\\<guillemotright> \\<and>\n    D.cones_map ?a\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n         else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n              else null) =\n    \\<chi>'\n 2. \\<And>f.\n       \\<guillemotleft>f : a' \\<rightarrow> local.dom\n       p0\\<guillemotright> \\<and>\n       D.cones_map f\n        (\\<lambda>i.\n            if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n            else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                 else null) =\n       \\<chi>' \\<Longrightarrow>\n       f = ?a", "define f1 where \"f1 = \\<pi>1.induced_arrow a' ?\\<chi>1'\""], ["proof (state)\nthis:\n  f1 =\n  \\<pi>1.induced_arrow a'\n   (\\<lambda>i. if i \\<in> Collect J1.arr then \\<chi>' i else null)\n\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : a' \\<rightarrow> local.dom\n     p0\\<guillemotright> \\<and>\n    D.cones_map ?a\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n         else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n              else null) =\n    \\<chi>'\n 2. \\<And>f.\n       \\<guillemotleft>f : a' \\<rightarrow> local.dom\n       p0\\<guillemotright> \\<and>\n       D.cones_map f\n        (\\<lambda>i.\n            if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n            else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                 else null) =\n       \\<chi>' \\<Longrightarrow>\n       f = ?a", "have f0: \"\\<guillemotleft>f0 : a' \\<rightarrow> a0\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>f0 : a' \\<rightarrow> a0\\<guillemotright>", "using f0_def \\<pi>0.induced_arrowI \\<chi>0'.cone_axioms"], ["proof (prove)\nusing this:\n  f0 =\n  \\<pi>0.induced_arrow a'\n   (\\<lambda>i. if i \\<in> Collect J0.arr then \\<chi>' i else null)\n  ?\\<chi>' \\<in> D0.cones ?a' \\<Longrightarrow>\n  \\<guillemotleft>\\<pi>0.induced_arrow ?a'\n                   ?\\<chi>' : ?a' \\<rightarrow> a0\\<guillemotright>\n  ?\\<chi>' \\<in> D0.cones ?a' \\<Longrightarrow>\n  D0.cones_map (\\<pi>0.induced_arrow ?a' ?\\<chi>') \\<pi>0 = ?\\<chi>'\n  D0.cone a'\n   (\\<lambda>i. if i \\<in> Collect J0.arr then \\<chi>' i else null)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>f0 : a' \\<rightarrow> a0\\<guillemotright>", "by simp"], ["proof (state)\nthis:\n  \\<guillemotleft>f0 : a' \\<rightarrow> a0\\<guillemotright>\n\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : a' \\<rightarrow> local.dom\n     p0\\<guillemotright> \\<and>\n    D.cones_map ?a\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n         else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n              else null) =\n    \\<chi>'\n 2. \\<And>f.\n       \\<guillemotleft>f : a' \\<rightarrow> local.dom\n       p0\\<guillemotright> \\<and>\n       D.cones_map f\n        (\\<lambda>i.\n            if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n            else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                 else null) =\n       \\<chi>' \\<Longrightarrow>\n       f = ?a", "have f1: \"\\<guillemotleft>f1 : a' \\<rightarrow> a1\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>f1 : a' \\<rightarrow> a1\\<guillemotright>", "using f1_def \\<pi>1.induced_arrowI \\<chi>1'.cone_axioms"], ["proof (prove)\nusing this:\n  f1 =\n  \\<pi>1.induced_arrow a'\n   (\\<lambda>i. if i \\<in> Collect J1.arr then \\<chi>' i else null)\n  ?\\<chi>' \\<in> D1.cones ?a' \\<Longrightarrow>\n  \\<guillemotleft>\\<pi>1.induced_arrow ?a'\n                   ?\\<chi>' : ?a' \\<rightarrow> a1\\<guillemotright>\n  ?\\<chi>' \\<in> D1.cones ?a' \\<Longrightarrow>\n  D1.cones_map (\\<pi>1.induced_arrow ?a' ?\\<chi>') \\<pi>1 = ?\\<chi>'\n  D1.cone a'\n   (\\<lambda>i. if i \\<in> Collect J1.arr then \\<chi>' i else null)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>f1 : a' \\<rightarrow> a1\\<guillemotright>", "by simp"], ["proof (state)\nthis:\n  \\<guillemotleft>f1 : a' \\<rightarrow> a1\\<guillemotright>\n\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : a' \\<rightarrow> local.dom\n     p0\\<guillemotright> \\<and>\n    D.cones_map ?a\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n         else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n              else null) =\n    \\<chi>'\n 2. \\<And>f.\n       \\<guillemotleft>f : a' \\<rightarrow> local.dom\n       p0\\<guillemotright> \\<and>\n       D.cones_map f\n        (\\<lambda>i.\n            if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n            else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                 else null) =\n       \\<chi>' \\<Longrightarrow>\n       f = ?a", "have 2: \"a0xa1.is_rendered_commutative_by f0 f1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a0xa1.is_rendered_commutative_by f0 f1", "using f0 f1"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f0 : a' \\<rightarrow> a0\\<guillemotright>\n  \\<guillemotleft>f1 : a' \\<rightarrow> a1\\<guillemotright>\n\ngoal (1 subgoal):\n 1. a0xa1.is_rendered_commutative_by f0 f1", "by auto"], ["proof (state)\nthis:\n  a0xa1.is_rendered_commutative_by f0 f1\n\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : a' \\<rightarrow> local.dom\n     p0\\<guillemotright> \\<and>\n    D.cones_map ?a\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n         else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n              else null) =\n    \\<chi>'\n 2. \\<And>f.\n       \\<guillemotleft>f : a' \\<rightarrow> local.dom\n       p0\\<guillemotright> \\<and>\n       D.cones_map f\n        (\\<lambda>i.\n            if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n            else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                 else null) =\n       \\<chi>' \\<Longrightarrow>\n       f = ?a", "interpret p0p1: binary_product_cone C a0 a1 p0 p1"], ["proof (prove)\ngoal (1 subgoal):\n 1. binary_product_cone (\\<cdot>) a0 a1 p0 p1", ".."], ["proof (state)\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : a' \\<rightarrow> local.dom\n     p0\\<guillemotright> \\<and>\n    D.cones_map ?a\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n         else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n              else null) =\n    \\<chi>'\n 2. \\<And>f.\n       \\<guillemotleft>f : a' \\<rightarrow> local.dom\n       p0\\<guillemotright> \\<and>\n       D.cones_map f\n        (\\<lambda>i.\n            if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n            else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                 else null) =\n       \\<chi>' \\<Longrightarrow>\n       f = ?a", "interpret f0f1: cone X.comp C a0xa1.map a' \\<open>a0xa1.mkCone f0 f1\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. a0xa1.cone a' (a0xa1.mkCone f0 f1)", "using 2 f0 f1 a0xa1.cone_mkCone [of f0 f1]"], ["proof (prove)\nusing this:\n  a0xa1.is_rendered_commutative_by f0 f1\n  \\<guillemotleft>f0 : a' \\<rightarrow> a0\\<guillemotright>\n  \\<guillemotleft>f1 : a' \\<rightarrow> a1\\<guillemotright>\n  a0xa1.is_rendered_commutative_by f0 f1 \\<Longrightarrow>\n  a0xa1.cone (local.dom f0) (a0xa1.mkCone f0 f1)\n\ngoal (1 subgoal):\n 1. a0xa1.cone a' (a0xa1.mkCone f0 f1)", "by auto"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : a' \\<rightarrow> local.dom\n     p0\\<guillemotright> \\<and>\n    D.cones_map ?a\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n         else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n              else null) =\n    \\<chi>'\n 2. \\<And>f.\n       \\<guillemotleft>f : a' \\<rightarrow> local.dom\n       p0\\<guillemotright> \\<and>\n       D.cones_map f\n        (\\<lambda>i.\n            if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n            else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                 else null) =\n       \\<chi>' \\<Longrightarrow>\n       f = ?a", "define f where \"f = p0p1.induced_arrow a' (a0xa1.mkCone f0 f1)\""], ["proof (state)\nthis:\n  f = p0p1.induced_arrow a' (a0xa1.mkCone f0 f1)\n\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : a' \\<rightarrow> local.dom\n     p0\\<guillemotright> \\<and>\n    D.cones_map ?a\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n         else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n              else null) =\n    \\<chi>'\n 2. \\<And>f.\n       \\<guillemotleft>f : a' \\<rightarrow> local.dom\n       p0\\<guillemotright> \\<and>\n       D.cones_map f\n        (\\<lambda>i.\n            if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n            else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                 else null) =\n       \\<chi>' \\<Longrightarrow>\n       f = ?a", "have f: \"\\<guillemotleft>f : a' \\<rightarrow> ?a\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>f : a' \\<rightarrow> local.dom p0\\<guillemotright>", "using f_def 2 f0 f1 p0p1.induced_arrowI'(1)"], ["proof (prove)\nusing this:\n  f = p0p1.induced_arrow a' (a0xa1.mkCone f0 f1)\n  a0xa1.is_rendered_commutative_by f0 f1\n  \\<guillemotleft>f0 : a' \\<rightarrow> a0\\<guillemotright>\n  \\<guillemotleft>f1 : a' \\<rightarrow> a1\\<guillemotright>\n  a0xa1.is_rendered_commutative_by ?p0' ?p1' \\<Longrightarrow>\n  \\<guillemotleft>p0p1.induced_arrow (local.dom ?p0')\n                   (a0xa1.mkCone ?p0'\n                     ?p1') : local.dom\n                              ?p0' \\<rightarrow> local.dom\n            p0\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>f : a' \\<rightarrow> local.dom p0\\<guillemotright>", "by auto"], ["proof (state)\nthis:\n  \\<guillemotleft>f : a' \\<rightarrow> local.dom p0\\<guillemotright>\n\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : a' \\<rightarrow> local.dom\n     p0\\<guillemotright> \\<and>\n    D.cones_map ?a\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n         else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n              else null) =\n    \\<chi>'\n 2. \\<And>f.\n       \\<guillemotleft>f : a' \\<rightarrow> local.dom\n       p0\\<guillemotright> \\<and>\n       D.cones_map f\n        (\\<lambda>i.\n            if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n            else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                 else null) =\n       \\<chi>' \\<Longrightarrow>\n       f = ?a", "moreover"], ["proof (state)\nthis:\n  \\<guillemotleft>f : a' \\<rightarrow> local.dom p0\\<guillemotright>\n\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : a' \\<rightarrow> local.dom\n     p0\\<guillemotright> \\<and>\n    D.cones_map ?a\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n         else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n              else null) =\n    \\<chi>'\n 2. \\<And>f.\n       \\<guillemotleft>f : a' \\<rightarrow> local.dom\n       p0\\<guillemotright> \\<and>\n       D.cones_map f\n        (\\<lambda>i.\n            if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n            else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                 else null) =\n       \\<chi>' \\<Longrightarrow>\n       f = ?a", "have \\<chi>': \"D.cones_map f ?\\<pi> = \\<chi>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D.cones_map f\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n         else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n              else null) =\n    \\<chi>'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       D.cones_map f\n        (\\<lambda>i.\n            if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n            else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                 else null)\n        x =\n       \\<chi>' x", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       D.cones_map f\n        (\\<lambda>i.\n            if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n            else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                 else null)\n        x =\n       \\<chi>' x", "show \"D.cones_map f ?\\<pi> j = \\<chi>' j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D.cones_map f\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n         else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null)\n     j =\n    \\<chi>' j", "proof (cases \"J0.arr j\", cases \"J1.arr j\")"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>J0.arr j; J1.arr j\\<rbrakk>\n    \\<Longrightarrow> D.cones_map f\n                       (\\<lambda>i.\n                           if i \\<in> Collect J0.arr\n                           then \\<pi>0 i \\<cdot> p0\n                           else if i \\<in> Collect J1.arr\n                                then \\<pi>1 i \\<cdot> p1 else null)\n                       j =\n                      \\<chi>' j\n 2. \\<lbrakk>J0.arr j; \\<not> J1.arr j\\<rbrakk>\n    \\<Longrightarrow> D.cones_map f\n                       (\\<lambda>i.\n                           if i \\<in> Collect J0.arr\n                           then \\<pi>0 i \\<cdot> p0\n                           else if i \\<in> Collect J1.arr\n                                then \\<pi>1 i \\<cdot> p1 else null)\n                       j =\n                      \\<chi>' j\n 3. \\<not> J0.arr j \\<Longrightarrow>\n    D.cones_map f\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n         else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null)\n     j =\n    \\<chi>' j", "show \"\\<lbrakk>J0.arr j; J1.arr j\\<rbrakk> \\<Longrightarrow> D.cones_map f ?\\<pi> j = \\<chi>' j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>J0.arr j; J1.arr j\\<rbrakk>\n    \\<Longrightarrow> D.cones_map f\n                       (\\<lambda>i.\n                           if i \\<in> Collect J0.arr\n                           then \\<pi>0 i \\<cdot> p0\n                           else if i \\<in> Collect J1.arr\n                                then \\<pi>1 i \\<cdot> p1 else null)\n                       j =\n                      \\<chi>' j", "using assms(4)"], ["proof (prove)\nusing this:\n  Collect J0.arr \\<inter> Collect J1.arr = {}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>J0.arr j; J1.arr j\\<rbrakk>\n    \\<Longrightarrow> D.cones_map f\n                       (\\<lambda>i.\n                           if i \\<in> Collect J0.arr\n                           then \\<pi>0 i \\<cdot> p0\n                           else if i \\<in> Collect J1.arr\n                                then \\<pi>1 i \\<cdot> p1 else null)\n                       j =\n                      \\<chi>' j", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>J0.arr j; J1.arr j\\<rbrakk>\n  \\<Longrightarrow> D.cones_map f\n                     (\\<lambda>i.\n                         if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n                         else if i \\<in> Collect J1.arr\n                              then \\<pi>1 i \\<cdot> p1 else null)\n                     j =\n                    \\<chi>' j\n\ngoal (2 subgoals):\n 1. \\<lbrakk>J0.arr j; \\<not> J1.arr j\\<rbrakk>\n    \\<Longrightarrow> D.cones_map f\n                       (\\<lambda>i.\n                           if i \\<in> Collect J0.arr\n                           then \\<pi>0 i \\<cdot> p0\n                           else if i \\<in> Collect J1.arr\n                                then \\<pi>1 i \\<cdot> p1 else null)\n                       j =\n                      \\<chi>' j\n 2. \\<not> J0.arr j \\<Longrightarrow>\n    D.cones_map f\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n         else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null)\n     j =\n    \\<chi>' j", "show \"\\<lbrakk>J0.arr j; \\<not> J1.arr j\\<rbrakk> \\<Longrightarrow> D.cones_map f ?\\<pi> j = \\<chi>' j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>J0.arr j; \\<not> J1.arr j\\<rbrakk>\n    \\<Longrightarrow> D.cones_map f\n                       (\\<lambda>i.\n                           if i \\<in> Collect J0.arr\n                           then \\<pi>0 i \\<cdot> p0\n                           else if i \\<in> Collect J1.arr\n                                then \\<pi>1 i \\<cdot> p1 else null)\n                       j =\n                      \\<chi>' j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>J0.arr j; \\<not> J1.arr j\\<rbrakk>\n    \\<Longrightarrow> D.cones_map f\n                       (\\<lambda>i.\n                           if i \\<in> Collect J0.arr\n                           then \\<pi>0 i \\<cdot> p0\n                           else if i \\<in> Collect J1.arr\n                                then \\<pi>1 i \\<cdot> p1 else null)\n                       j =\n                      \\<chi>' j", "assume J0: \"J0.arr j\" and J1: \"\\<not> J1.arr j\""], ["proof (state)\nthis:\n  J0.arr j\n  \\<not> J1.arr j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>J0.arr j; \\<not> J1.arr j\\<rbrakk>\n    \\<Longrightarrow> D.cones_map f\n                       (\\<lambda>i.\n                           if i \\<in> Collect J0.arr\n                           then \\<pi>0 i \\<cdot> p0\n                           else if i \\<in> Collect J1.arr\n                                then \\<pi>1 i \\<cdot> p1 else null)\n                       j =\n                      \\<chi>' j", "have \"D.cones_map f ?\\<pi> j = (\\<pi>0 j \\<cdot> p0) \\<cdot> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D.cones_map f\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n         else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null)\n     j =\n    (\\<pi>0 j \\<cdot> p0) \\<cdot> f", "using f J0 J1 \\<pi>.cone_axioms"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f : a' \\<rightarrow> local.dom p0\\<guillemotright>\n  J0.arr j\n  \\<not> J1.arr j\n  D.cone (local.dom p0)\n   (\\<lambda>i.\n       if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n       else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null)\n\ngoal (1 subgoal):\n 1. D.cones_map f\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n         else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null)\n     j =\n    (\\<pi>0 j \\<cdot> p0) \\<cdot> f", "by auto"], ["proof (state)\nthis:\n  D.cones_map f\n   (\\<lambda>i.\n       if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n       else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null)\n   j =\n  (\\<pi>0 j \\<cdot> p0) \\<cdot> f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>J0.arr j; \\<not> J1.arr j\\<rbrakk>\n    \\<Longrightarrow> D.cones_map f\n                       (\\<lambda>i.\n                           if i \\<in> Collect J0.arr\n                           then \\<pi>0 i \\<cdot> p0\n                           else if i \\<in> Collect J1.arr\n                                then \\<pi>1 i \\<cdot> p1 else null)\n                       j =\n                      \\<chi>' j", "also"], ["proof (state)\nthis:\n  D.cones_map f\n   (\\<lambda>i.\n       if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n       else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null)\n   j =\n  (\\<pi>0 j \\<cdot> p0) \\<cdot> f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>J0.arr j; \\<not> J1.arr j\\<rbrakk>\n    \\<Longrightarrow> D.cones_map f\n                       (\\<lambda>i.\n                           if i \\<in> Collect J0.arr\n                           then \\<pi>0 i \\<cdot> p0\n                           else if i \\<in> Collect J1.arr\n                                then \\<pi>1 i \\<cdot> p1 else null)\n                       j =\n                      \\<chi>' j", "have \"... = \\<pi>0 j \\<cdot> p0 \\<cdot> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<pi>0 j \\<cdot> p0) \\<cdot> f = \\<pi>0 j \\<cdot> p0 \\<cdot> f", "using comp_assoc"], ["proof (prove)\nusing this:\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. (\\<pi>0 j \\<cdot> p0) \\<cdot> f = \\<pi>0 j \\<cdot> p0 \\<cdot> f", "by simp"], ["proof (state)\nthis:\n  (\\<pi>0 j \\<cdot> p0) \\<cdot> f = \\<pi>0 j \\<cdot> p0 \\<cdot> f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>J0.arr j; \\<not> J1.arr j\\<rbrakk>\n    \\<Longrightarrow> D.cones_map f\n                       (\\<lambda>i.\n                           if i \\<in> Collect J0.arr\n                           then \\<pi>0 i \\<cdot> p0\n                           else if i \\<in> Collect J1.arr\n                                then \\<pi>1 i \\<cdot> p1 else null)\n                       j =\n                      \\<chi>' j", "also"], ["proof (state)\nthis:\n  (\\<pi>0 j \\<cdot> p0) \\<cdot> f = \\<pi>0 j \\<cdot> p0 \\<cdot> f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>J0.arr j; \\<not> J1.arr j\\<rbrakk>\n    \\<Longrightarrow> D.cones_map f\n                       (\\<lambda>i.\n                           if i \\<in> Collect J0.arr\n                           then \\<pi>0 i \\<cdot> p0\n                           else if i \\<in> Collect J1.arr\n                                then \\<pi>1 i \\<cdot> p1 else null)\n                       j =\n                      \\<chi>' j", "have \"... = \\<pi>0 j \\<cdot> f0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>0 j \\<cdot> p0 \\<cdot> f = \\<pi>0 j \\<cdot> f0", "using 2 f0 f1 f_def p0p1.induced_arrowI'"], ["proof (prove)\nusing this:\n  a0xa1.is_rendered_commutative_by f0 f1\n  \\<guillemotleft>f0 : a' \\<rightarrow> a0\\<guillemotright>\n  \\<guillemotleft>f1 : a' \\<rightarrow> a1\\<guillemotright>\n  f = p0p1.induced_arrow a' (a0xa1.mkCone f0 f1)\n  a0xa1.is_rendered_commutative_by ?p0' ?p1' \\<Longrightarrow>\n  \\<guillemotleft>p0p1.induced_arrow (local.dom ?p0')\n                   (a0xa1.mkCone ?p0'\n                     ?p1') : local.dom\n                              ?p0' \\<rightarrow> local.dom\n            p0\\<guillemotright>\n  a0xa1.is_rendered_commutative_by ?p0' ?p1' \\<Longrightarrow>\n  p0 \\<cdot> p0p1.induced_arrow (local.dom ?p0') (a0xa1.mkCone ?p0' ?p1') =\n  ?p0'\n  a0xa1.is_rendered_commutative_by ?p0' ?p1' \\<Longrightarrow>\n  p1 \\<cdot> p0p1.induced_arrow (local.dom ?p1') (a0xa1.mkCone ?p0' ?p1') =\n  ?p1'\n\ngoal (1 subgoal):\n 1. \\<pi>0 j \\<cdot> p0 \\<cdot> f = \\<pi>0 j \\<cdot> f0", "by auto"], ["proof (state)\nthis:\n  \\<pi>0 j \\<cdot> p0 \\<cdot> f = \\<pi>0 j \\<cdot> f0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>J0.arr j; \\<not> J1.arr j\\<rbrakk>\n    \\<Longrightarrow> D.cones_map f\n                       (\\<lambda>i.\n                           if i \\<in> Collect J0.arr\n                           then \\<pi>0 i \\<cdot> p0\n                           else if i \\<in> Collect J1.arr\n                                then \\<pi>1 i \\<cdot> p1 else null)\n                       j =\n                      \\<chi>' j", "also"], ["proof (state)\nthis:\n  \\<pi>0 j \\<cdot> p0 \\<cdot> f = \\<pi>0 j \\<cdot> f0\n\ngoal (1 subgoal):\n 1. \\<lbrakk>J0.arr j; \\<not> J1.arr j\\<rbrakk>\n    \\<Longrightarrow> D.cones_map f\n                       (\\<lambda>i.\n                           if i \\<in> Collect J0.arr\n                           then \\<pi>0 i \\<cdot> p0\n                           else if i \\<in> Collect J1.arr\n                                then \\<pi>1 i \\<cdot> p1 else null)\n                       j =\n                      \\<chi>' j", "have \"... = \\<chi>' j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>0 j \\<cdot> f0 = \\<chi>' j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<pi>0 j \\<cdot> f0 = \\<chi>' j", "have \"\\<pi>0 j \\<cdot> f0 = \\<pi>0 j \\<cdot> \\<pi>0.induced_arrow' a' \\<chi>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>0 j \\<cdot> f0 = \\<pi>0 j \\<cdot> \\<pi>0.induced_arrow' a' \\<chi>'", "unfolding f0_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>0 j \\<cdot>\n    \\<pi>0.induced_arrow a'\n     (\\<lambda>i. if i \\<in> Collect J0.arr then \\<chi>' i else null) =\n    \\<pi>0 j \\<cdot> \\<pi>0.induced_arrow' a' \\<chi>'", "by simp"], ["proof (state)\nthis:\n  \\<pi>0 j \\<cdot> f0 = \\<pi>0 j \\<cdot> \\<pi>0.induced_arrow' a' \\<chi>'\n\ngoal (1 subgoal):\n 1. \\<pi>0 j \\<cdot> f0 = \\<chi>' j", "also"], ["proof (state)\nthis:\n  \\<pi>0 j \\<cdot> f0 = \\<pi>0 j \\<cdot> \\<pi>0.induced_arrow' a' \\<chi>'\n\ngoal (1 subgoal):\n 1. \\<pi>0 j \\<cdot> f0 = \\<chi>' j", "have \"... = (\\<lambda>j. if J0.arr j then\n                                            \\<pi>0 j \\<cdot> \\<pi>0.induced_arrow a'\n                                                    (\\<lambda>i. if i \\<in> Collect J0.arr then \\<chi>' i else null)\n                                          else null) j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>0 j \\<cdot> \\<pi>0.induced_arrow' a' \\<chi>' =\n    (if J0.arr j\n     then \\<pi>0 j \\<cdot>\n          \\<pi>0.induced_arrow a'\n           (\\<lambda>i. if i \\<in> Collect J0.arr then \\<chi>' i else null)\n     else null)", "using J0"], ["proof (prove)\nusing this:\n  J0.arr j\n\ngoal (1 subgoal):\n 1. \\<pi>0 j \\<cdot> \\<pi>0.induced_arrow' a' \\<chi>' =\n    (if J0.arr j\n     then \\<pi>0 j \\<cdot>\n          \\<pi>0.induced_arrow a'\n           (\\<lambda>i. if i \\<in> Collect J0.arr then \\<chi>' i else null)\n     else null)", "by simp"], ["proof (state)\nthis:\n  \\<pi>0 j \\<cdot> \\<pi>0.induced_arrow' a' \\<chi>' =\n  (if J0.arr j\n   then \\<pi>0 j \\<cdot>\n        \\<pi>0.induced_arrow a'\n         (\\<lambda>i. if i \\<in> Collect J0.arr then \\<chi>' i else null)\n   else null)\n\ngoal (1 subgoal):\n 1. \\<pi>0 j \\<cdot> f0 = \\<chi>' j", "also"], ["proof (state)\nthis:\n  \\<pi>0 j \\<cdot> \\<pi>0.induced_arrow' a' \\<chi>' =\n  (if J0.arr j\n   then \\<pi>0 j \\<cdot>\n        \\<pi>0.induced_arrow a'\n         (\\<lambda>i. if i \\<in> Collect J0.arr then \\<chi>' i else null)\n   else null)\n\ngoal (1 subgoal):\n 1. \\<pi>0 j \\<cdot> f0 = \\<chi>' j", "have \"... = D0.mkCone \\<chi>' j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if J0.arr j\n     then \\<pi>0 j \\<cdot>\n          \\<pi>0.induced_arrow a'\n           (\\<lambda>i. if i \\<in> Collect J0.arr then \\<chi>' i else null)\n     else null) =\n    D0.mkCone \\<chi>' j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (if J0.arr j\n     then \\<pi>0 j \\<cdot>\n          \\<pi>0.induced_arrow a'\n           (\\<lambda>i. if i \\<in> Collect J0.arr then \\<chi>' i else null)\n     else null) =\n    D0.mkCone \\<chi>' j", "have \"(\\<lambda>j. if J0.arr j then\n                                    \\<pi>0 j \\<cdot> \\<pi>0.induced_arrow a'\n                                             (\\<lambda>i. if i \\<in> Collect J0.arr then \\<chi>' i else null)\n                                 else null) =\n                            D0.mkCone \\<chi>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>j.\n        if J0.arr j\n        then \\<pi>0 j \\<cdot>\n             \\<pi>0.induced_arrow a'\n              (\\<lambda>i.\n                  if i \\<in> Collect J0.arr then \\<chi>' i else null)\n        else null) =\n    D0.mkCone \\<chi>'", "using f0 f0_def \\<pi>0.induced_arrowI(2) [of ?\\<chi>0' a'] J0\n                              D0.mkCone_cone \\<chi>0'.cone_axioms \\<pi>0.cone_axioms J0"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f0 : a' \\<rightarrow> a0\\<guillemotright>\n  f0 =\n  \\<pi>0.induced_arrow a'\n   (\\<lambda>i. if i \\<in> Collect J0.arr then \\<chi>' i else null)\n  (\\<lambda>i. if i \\<in> Collect J0.arr then \\<chi>' i else null)\n  \\<in> D0.cones a' \\<Longrightarrow>\n  D0.cones_map\n   (\\<pi>0.induced_arrow a'\n     (\\<lambda>i. if i \\<in> Collect J0.arr then \\<chi>' i else null))\n   \\<pi>0 =\n  (\\<lambda>i. if i \\<in> Collect J0.arr then \\<chi>' i else null)\n  J0.arr j\n  D0.cone ?a ?\\<pi> \\<Longrightarrow> D0.mkCone ?\\<pi> = ?\\<pi>\n  D0.cone a'\n   (\\<lambda>i. if i \\<in> Collect J0.arr then \\<chi>' i else null)\n  D0.cone a0 \\<pi>0\n  J0.arr j\n\ngoal (1 subgoal):\n 1. (\\<lambda>j.\n        if J0.arr j\n        then \\<pi>0 j \\<cdot>\n             \\<pi>0.induced_arrow a'\n              (\\<lambda>i.\n                  if i \\<in> Collect J0.arr then \\<chi>' i else null)\n        else null) =\n    D0.mkCone \\<chi>'", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>j.\n      if J0.arr j\n      then \\<pi>0 j \\<cdot>\n           \\<pi>0.induced_arrow a'\n            (\\<lambda>i. if i \\<in> Collect J0.arr then \\<chi>' i else null)\n      else null) =\n  D0.mkCone \\<chi>'\n\ngoal (1 subgoal):\n 1. (if J0.arr j\n     then \\<pi>0 j \\<cdot>\n          \\<pi>0.induced_arrow a'\n           (\\<lambda>i. if i \\<in> Collect J0.arr then \\<chi>' i else null)\n     else null) =\n    D0.mkCone \\<chi>' j", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>j.\n      if J0.arr j\n      then \\<pi>0 j \\<cdot>\n           \\<pi>0.induced_arrow a'\n            (\\<lambda>i. if i \\<in> Collect J0.arr then \\<chi>' i else null)\n      else null) =\n  D0.mkCone \\<chi>'\n\ngoal (1 subgoal):\n 1. (if J0.arr j\n     then \\<pi>0 j \\<cdot>\n          \\<pi>0.induced_arrow a'\n           (\\<lambda>i. if i \\<in> Collect J0.arr then \\<chi>' i else null)\n     else null) =\n    D0.mkCone \\<chi>' j", "by meson"], ["proof (state)\nthis:\n  (if J0.arr j\n   then \\<pi>0 j \\<cdot>\n        \\<pi>0.induced_arrow a'\n         (\\<lambda>i. if i \\<in> Collect J0.arr then \\<chi>' i else null)\n   else null) =\n  D0.mkCone \\<chi>' j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if J0.arr j\n   then \\<pi>0 j \\<cdot>\n        \\<pi>0.induced_arrow a'\n         (\\<lambda>i. if i \\<in> Collect J0.arr then \\<chi>' i else null)\n   else null) =\n  D0.mkCone \\<chi>' j\n\ngoal (1 subgoal):\n 1. \\<pi>0 j \\<cdot> f0 = \\<chi>' j", "also"], ["proof (state)\nthis:\n  (if J0.arr j\n   then \\<pi>0 j \\<cdot>\n        \\<pi>0.induced_arrow a'\n         (\\<lambda>i. if i \\<in> Collect J0.arr then \\<chi>' i else null)\n   else null) =\n  D0.mkCone \\<chi>' j\n\ngoal (1 subgoal):\n 1. \\<pi>0 j \\<cdot> f0 = \\<chi>' j", "have \"... = \\<chi>' j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D0.mkCone \\<chi>' j = \\<chi>' j", "using J0"], ["proof (prove)\nusing this:\n  J0.arr j\n\ngoal (1 subgoal):\n 1. D0.mkCone \\<chi>' j = \\<chi>' j", "by simp"], ["proof (state)\nthis:\n  D0.mkCone \\<chi>' j = \\<chi>' j\n\ngoal (1 subgoal):\n 1. \\<pi>0 j \\<cdot> f0 = \\<chi>' j", "finally"], ["proof (chain)\npicking this:\n  \\<pi>0 j \\<cdot> f0 = \\<chi>' j", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<pi>0 j \\<cdot> f0 = \\<chi>' j\n\ngoal (1 subgoal):\n 1. \\<pi>0 j \\<cdot> f0 = \\<chi>' j", "by blast"], ["proof (state)\nthis:\n  \\<pi>0 j \\<cdot> f0 = \\<chi>' j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<pi>0 j \\<cdot> f0 = \\<chi>' j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>J0.arr j; \\<not> J1.arr j\\<rbrakk>\n    \\<Longrightarrow> D.cones_map f\n                       (\\<lambda>i.\n                           if i \\<in> Collect J0.arr\n                           then \\<pi>0 i \\<cdot> p0\n                           else if i \\<in> Collect J1.arr\n                                then \\<pi>1 i \\<cdot> p1 else null)\n                       j =\n                      \\<chi>' j", "finally"], ["proof (chain)\npicking this:\n  D.cones_map f\n   (\\<lambda>i.\n       if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n       else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null)\n   j =\n  \\<chi>' j", "show ?thesis"], ["proof (prove)\nusing this:\n  D.cones_map f\n   (\\<lambda>i.\n       if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n       else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null)\n   j =\n  \\<chi>' j\n\ngoal (1 subgoal):\n 1. D.cones_map f\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n         else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null)\n     j =\n    \\<chi>' j", "by simp"], ["proof (state)\nthis:\n  D.cones_map f\n   (\\<lambda>i.\n       if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n       else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null)\n   j =\n  \\<chi>' j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>J0.arr j; \\<not> J1.arr j\\<rbrakk>\n  \\<Longrightarrow> D.cones_map f\n                     (\\<lambda>i.\n                         if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n                         else if i \\<in> Collect J1.arr\n                              then \\<pi>1 i \\<cdot> p1 else null)\n                     j =\n                    \\<chi>' j\n\ngoal (1 subgoal):\n 1. \\<not> J0.arr j \\<Longrightarrow>\n    D.cones_map f\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n         else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null)\n     j =\n    \\<chi>' j", "show \"\\<not> J0.arr j \\<Longrightarrow> D.cones_map f ?\\<pi> j = \\<chi>' j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> J0.arr j \\<Longrightarrow>\n    D.cones_map f\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n         else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null)\n     j =\n    \\<chi>' j", "proof (cases \"J1.arr j\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> J0.arr j; J1.arr j\\<rbrakk>\n    \\<Longrightarrow> D.cones_map f\n                       (\\<lambda>i.\n                           if i \\<in> Collect J0.arr\n                           then \\<pi>0 i \\<cdot> p0\n                           else if i \\<in> Collect J1.arr\n                                then \\<pi>1 i \\<cdot> p1 else null)\n                       j =\n                      \\<chi>' j\n 2. \\<lbrakk>\\<not> J0.arr j; \\<not> J1.arr j\\<rbrakk>\n    \\<Longrightarrow> D.cones_map f\n                       (\\<lambda>i.\n                           if i \\<in> Collect J0.arr\n                           then \\<pi>0 i \\<cdot> p0\n                           else if i \\<in> Collect J1.arr\n                                then \\<pi>1 i \\<cdot> p1 else null)\n                       j =\n                      \\<chi>' j", "show \"\\<lbrakk>\\<not> J0.arr j; \\<not> J1.arr j\\<rbrakk> \\<Longrightarrow> D.cones_map f ?\\<pi> j = \\<chi>' j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> J0.arr j; \\<not> J1.arr j\\<rbrakk>\n    \\<Longrightarrow> D.cones_map f\n                       (\\<lambda>i.\n                           if i \\<in> Collect J0.arr\n                           then \\<pi>0 i \\<cdot> p0\n                           else if i \\<in> Collect J1.arr\n                                then \\<pi>1 i \\<cdot> p1 else null)\n                       j =\n                      \\<chi>' j", "using f \\<pi>.cone_axioms \\<chi>'.is_extensional"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f : a' \\<rightarrow> local.dom p0\\<guillemotright>\n  D.cone (local.dom p0)\n   (\\<lambda>i.\n       if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n       else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null)\n  \\<not> J.arr ?f \\<Longrightarrow> \\<chi>' ?f = null\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> J0.arr j; \\<not> J1.arr j\\<rbrakk>\n    \\<Longrightarrow> D.cones_map f\n                       (\\<lambda>i.\n                           if i \\<in> Collect J0.arr\n                           then \\<pi>0 i \\<cdot> p0\n                           else if i \\<in> Collect J1.arr\n                                then \\<pi>1 i \\<cdot> p1 else null)\n                       j =\n                      \\<chi>' j", "by auto"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> J0.arr j; \\<not> J1.arr j\\<rbrakk>\n  \\<Longrightarrow> D.cones_map f\n                     (\\<lambda>i.\n                         if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n                         else if i \\<in> Collect J1.arr\n                              then \\<pi>1 i \\<cdot> p1 else null)\n                     j =\n                    \\<chi>' j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> J0.arr j; J1.arr j\\<rbrakk>\n    \\<Longrightarrow> D.cones_map f\n                       (\\<lambda>i.\n                           if i \\<in> Collect J0.arr\n                           then \\<pi>0 i \\<cdot> p0\n                           else if i \\<in> Collect J1.arr\n                                then \\<pi>1 i \\<cdot> p1 else null)\n                       j =\n                      \\<chi>' j", "show \"\\<lbrakk>\\<not> J0.arr j; J1.arr j\\<rbrakk> \\<Longrightarrow> D.cones_map f ?\\<pi> j = \\<chi>' j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> J0.arr j; J1.arr j\\<rbrakk>\n    \\<Longrightarrow> D.cones_map f\n                       (\\<lambda>i.\n                           if i \\<in> Collect J0.arr\n                           then \\<pi>0 i \\<cdot> p0\n                           else if i \\<in> Collect J1.arr\n                                then \\<pi>1 i \\<cdot> p1 else null)\n                       j =\n                      \\<chi>' j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> J0.arr j; J1.arr j\\<rbrakk>\n    \\<Longrightarrow> D.cones_map f\n                       (\\<lambda>i.\n                           if i \\<in> Collect J0.arr\n                           then \\<pi>0 i \\<cdot> p0\n                           else if i \\<in> Collect J1.arr\n                                then \\<pi>1 i \\<cdot> p1 else null)\n                       j =\n                      \\<chi>' j", "assume J0: \"\\<not> J0.arr j\" and J1: \"J1.arr j\""], ["proof (state)\nthis:\n  \\<not> J0.arr j\n  J1.arr j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> J0.arr j; J1.arr j\\<rbrakk>\n    \\<Longrightarrow> D.cones_map f\n                       (\\<lambda>i.\n                           if i \\<in> Collect J0.arr\n                           then \\<pi>0 i \\<cdot> p0\n                           else if i \\<in> Collect J1.arr\n                                then \\<pi>1 i \\<cdot> p1 else null)\n                       j =\n                      \\<chi>' j", "have \"D.cones_map f ?\\<pi> j = (\\<pi>1 j \\<cdot> p1) \\<cdot> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D.cones_map f\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n         else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null)\n     j =\n    (\\<pi>1 j \\<cdot> p1) \\<cdot> f", "using J0 J1 f \\<pi>.cone_axioms"], ["proof (prove)\nusing this:\n  \\<not> J0.arr j\n  J1.arr j\n  \\<guillemotleft>f : a' \\<rightarrow> local.dom p0\\<guillemotright>\n  D.cone (local.dom p0)\n   (\\<lambda>i.\n       if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n       else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null)\n\ngoal (1 subgoal):\n 1. D.cones_map f\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n         else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null)\n     j =\n    (\\<pi>1 j \\<cdot> p1) \\<cdot> f", "by auto"], ["proof (state)\nthis:\n  D.cones_map f\n   (\\<lambda>i.\n       if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n       else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null)\n   j =\n  (\\<pi>1 j \\<cdot> p1) \\<cdot> f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> J0.arr j; J1.arr j\\<rbrakk>\n    \\<Longrightarrow> D.cones_map f\n                       (\\<lambda>i.\n                           if i \\<in> Collect J0.arr\n                           then \\<pi>0 i \\<cdot> p0\n                           else if i \\<in> Collect J1.arr\n                                then \\<pi>1 i \\<cdot> p1 else null)\n                       j =\n                      \\<chi>' j", "also"], ["proof (state)\nthis:\n  D.cones_map f\n   (\\<lambda>i.\n       if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n       else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null)\n   j =\n  (\\<pi>1 j \\<cdot> p1) \\<cdot> f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> J0.arr j; J1.arr j\\<rbrakk>\n    \\<Longrightarrow> D.cones_map f\n                       (\\<lambda>i.\n                           if i \\<in> Collect J0.arr\n                           then \\<pi>0 i \\<cdot> p0\n                           else if i \\<in> Collect J1.arr\n                                then \\<pi>1 i \\<cdot> p1 else null)\n                       j =\n                      \\<chi>' j", "have \"... = \\<pi>1 j \\<cdot> p1 \\<cdot> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<pi>1 j \\<cdot> p1) \\<cdot> f = \\<pi>1 j \\<cdot> p1 \\<cdot> f", "using comp_assoc"], ["proof (prove)\nusing this:\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. (\\<pi>1 j \\<cdot> p1) \\<cdot> f = \\<pi>1 j \\<cdot> p1 \\<cdot> f", "by simp"], ["proof (state)\nthis:\n  (\\<pi>1 j \\<cdot> p1) \\<cdot> f = \\<pi>1 j \\<cdot> p1 \\<cdot> f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> J0.arr j; J1.arr j\\<rbrakk>\n    \\<Longrightarrow> D.cones_map f\n                       (\\<lambda>i.\n                           if i \\<in> Collect J0.arr\n                           then \\<pi>0 i \\<cdot> p0\n                           else if i \\<in> Collect J1.arr\n                                then \\<pi>1 i \\<cdot> p1 else null)\n                       j =\n                      \\<chi>' j", "also"], ["proof (state)\nthis:\n  (\\<pi>1 j \\<cdot> p1) \\<cdot> f = \\<pi>1 j \\<cdot> p1 \\<cdot> f\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> J0.arr j; J1.arr j\\<rbrakk>\n    \\<Longrightarrow> D.cones_map f\n                       (\\<lambda>i.\n                           if i \\<in> Collect J0.arr\n                           then \\<pi>0 i \\<cdot> p0\n                           else if i \\<in> Collect J1.arr\n                                then \\<pi>1 i \\<cdot> p1 else null)\n                       j =\n                      \\<chi>' j", "have \"... = \\<pi>1 j \\<cdot> f1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>1 j \\<cdot> p1 \\<cdot> f = \\<pi>1 j \\<cdot> f1", "using 2 f0 f1 f_def p0p1.induced_arrowI'"], ["proof (prove)\nusing this:\n  a0xa1.is_rendered_commutative_by f0 f1\n  \\<guillemotleft>f0 : a' \\<rightarrow> a0\\<guillemotright>\n  \\<guillemotleft>f1 : a' \\<rightarrow> a1\\<guillemotright>\n  f = p0p1.induced_arrow a' (a0xa1.mkCone f0 f1)\n  a0xa1.is_rendered_commutative_by ?p0' ?p1' \\<Longrightarrow>\n  \\<guillemotleft>p0p1.induced_arrow (local.dom ?p0')\n                   (a0xa1.mkCone ?p0'\n                     ?p1') : local.dom\n                              ?p0' \\<rightarrow> local.dom\n            p0\\<guillemotright>\n  a0xa1.is_rendered_commutative_by ?p0' ?p1' \\<Longrightarrow>\n  p0 \\<cdot> p0p1.induced_arrow (local.dom ?p0') (a0xa1.mkCone ?p0' ?p1') =\n  ?p0'\n  a0xa1.is_rendered_commutative_by ?p0' ?p1' \\<Longrightarrow>\n  p1 \\<cdot> p0p1.induced_arrow (local.dom ?p1') (a0xa1.mkCone ?p0' ?p1') =\n  ?p1'\n\ngoal (1 subgoal):\n 1. \\<pi>1 j \\<cdot> p1 \\<cdot> f = \\<pi>1 j \\<cdot> f1", "by auto"], ["proof (state)\nthis:\n  \\<pi>1 j \\<cdot> p1 \\<cdot> f = \\<pi>1 j \\<cdot> f1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> J0.arr j; J1.arr j\\<rbrakk>\n    \\<Longrightarrow> D.cones_map f\n                       (\\<lambda>i.\n                           if i \\<in> Collect J0.arr\n                           then \\<pi>0 i \\<cdot> p0\n                           else if i \\<in> Collect J1.arr\n                                then \\<pi>1 i \\<cdot> p1 else null)\n                       j =\n                      \\<chi>' j", "also"], ["proof (state)\nthis:\n  \\<pi>1 j \\<cdot> p1 \\<cdot> f = \\<pi>1 j \\<cdot> f1\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> J0.arr j; J1.arr j\\<rbrakk>\n    \\<Longrightarrow> D.cones_map f\n                       (\\<lambda>i.\n                           if i \\<in> Collect J0.arr\n                           then \\<pi>0 i \\<cdot> p0\n                           else if i \\<in> Collect J1.arr\n                                then \\<pi>1 i \\<cdot> p1 else null)\n                       j =\n                      \\<chi>' j", "have \"... = \\<chi>' j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>1 j \\<cdot> f1 = \\<chi>' j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<pi>1 j \\<cdot> f1 = \\<chi>' j", "have \"\\<pi>1 j \\<cdot> f1 = \\<pi>1 j \\<cdot> \\<pi>1.induced_arrow' a' \\<chi>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>1 j \\<cdot> f1 = \\<pi>1 j \\<cdot> \\<pi>1.induced_arrow' a' \\<chi>'", "unfolding f1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>1 j \\<cdot>\n    \\<pi>1.induced_arrow a'\n     (\\<lambda>i. if i \\<in> Collect J1.arr then \\<chi>' i else null) =\n    \\<pi>1 j \\<cdot> \\<pi>1.induced_arrow' a' \\<chi>'", "by simp"], ["proof (state)\nthis:\n  \\<pi>1 j \\<cdot> f1 = \\<pi>1 j \\<cdot> \\<pi>1.induced_arrow' a' \\<chi>'\n\ngoal (1 subgoal):\n 1. \\<pi>1 j \\<cdot> f1 = \\<chi>' j", "also"], ["proof (state)\nthis:\n  \\<pi>1 j \\<cdot> f1 = \\<pi>1 j \\<cdot> \\<pi>1.induced_arrow' a' \\<chi>'\n\ngoal (1 subgoal):\n 1. \\<pi>1 j \\<cdot> f1 = \\<chi>' j", "have \"... = (\\<lambda>j. if J1.arr j then\n                                              \\<pi>1 j \\<cdot> \\<pi>1.induced_arrow a'\n                                                      (\\<lambda>i. if i \\<in> Collect J1.arr\n                                                           then \\<chi>' i else null)\n                                            else null) j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<pi>1 j \\<cdot> \\<pi>1.induced_arrow' a' \\<chi>' =\n    (if J1.arr j\n     then \\<pi>1 j \\<cdot>\n          \\<pi>1.induced_arrow a'\n           (\\<lambda>i. if i \\<in> Collect J1.arr then \\<chi>' i else null)\n     else null)", "using J1"], ["proof (prove)\nusing this:\n  J1.arr j\n\ngoal (1 subgoal):\n 1. \\<pi>1 j \\<cdot> \\<pi>1.induced_arrow' a' \\<chi>' =\n    (if J1.arr j\n     then \\<pi>1 j \\<cdot>\n          \\<pi>1.induced_arrow a'\n           (\\<lambda>i. if i \\<in> Collect J1.arr then \\<chi>' i else null)\n     else null)", "by simp"], ["proof (state)\nthis:\n  \\<pi>1 j \\<cdot> \\<pi>1.induced_arrow' a' \\<chi>' =\n  (if J1.arr j\n   then \\<pi>1 j \\<cdot>\n        \\<pi>1.induced_arrow a'\n         (\\<lambda>i. if i \\<in> Collect J1.arr then \\<chi>' i else null)\n   else null)\n\ngoal (1 subgoal):\n 1. \\<pi>1 j \\<cdot> f1 = \\<chi>' j", "also"], ["proof (state)\nthis:\n  \\<pi>1 j \\<cdot> \\<pi>1.induced_arrow' a' \\<chi>' =\n  (if J1.arr j\n   then \\<pi>1 j \\<cdot>\n        \\<pi>1.induced_arrow a'\n         (\\<lambda>i. if i \\<in> Collect J1.arr then \\<chi>' i else null)\n   else null)\n\ngoal (1 subgoal):\n 1. \\<pi>1 j \\<cdot> f1 = \\<chi>' j", "have \"... = D1.mkCone \\<chi>' j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if J1.arr j\n     then \\<pi>1 j \\<cdot>\n          \\<pi>1.induced_arrow a'\n           (\\<lambda>i. if i \\<in> Collect J1.arr then \\<chi>' i else null)\n     else null) =\n    D1.mkCone \\<chi>' j", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (if J1.arr j\n     then \\<pi>1 j \\<cdot>\n          \\<pi>1.induced_arrow a'\n           (\\<lambda>i. if i \\<in> Collect J1.arr then \\<chi>' i else null)\n     else null) =\n    D1.mkCone \\<chi>' j", "have \"(\\<lambda>j. if J1.arr j then\n                                      \\<pi>1 j \\<cdot> \\<pi>1.induced_arrow a'\n                                               (\\<lambda>i. if i \\<in> Collect J1.arr then \\<chi>' i else null)\n                                   else null) =\n                              D1.mkCone \\<chi>'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>j.\n        if J1.arr j\n        then \\<pi>1 j \\<cdot>\n             \\<pi>1.induced_arrow a'\n              (\\<lambda>i.\n                  if i \\<in> Collect J1.arr then \\<chi>' i else null)\n        else null) =\n    D1.mkCone \\<chi>'", "using f1 f1_def \\<pi>1.induced_arrowI(2) [of ?\\<chi>1' a'] J1\n                                D1.mkCone_cone [of a' \\<chi>'] \\<chi>1'.cone_axioms \\<pi>1.cone_axioms J1"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f1 : a' \\<rightarrow> a1\\<guillemotright>\n  f1 =\n  \\<pi>1.induced_arrow a'\n   (\\<lambda>i. if i \\<in> Collect J1.arr then \\<chi>' i else null)\n  (\\<lambda>i. if i \\<in> Collect J1.arr then \\<chi>' i else null)\n  \\<in> D1.cones a' \\<Longrightarrow>\n  D1.cones_map\n   (\\<pi>1.induced_arrow a'\n     (\\<lambda>i. if i \\<in> Collect J1.arr then \\<chi>' i else null))\n   \\<pi>1 =\n  (\\<lambda>i. if i \\<in> Collect J1.arr then \\<chi>' i else null)\n  J1.arr j\n  D1.cone a' \\<chi>' \\<Longrightarrow> D1.mkCone \\<chi>' = \\<chi>'\n  D1.cone a'\n   (\\<lambda>i. if i \\<in> Collect J1.arr then \\<chi>' i else null)\n  D1.cone a1 \\<pi>1\n  J1.arr j\n\ngoal (1 subgoal):\n 1. (\\<lambda>j.\n        if J1.arr j\n        then \\<pi>1 j \\<cdot>\n             \\<pi>1.induced_arrow a'\n              (\\<lambda>i.\n                  if i \\<in> Collect J1.arr then \\<chi>' i else null)\n        else null) =\n    D1.mkCone \\<chi>'", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>j.\n      if J1.arr j\n      then \\<pi>1 j \\<cdot>\n           \\<pi>1.induced_arrow a'\n            (\\<lambda>i. if i \\<in> Collect J1.arr then \\<chi>' i else null)\n      else null) =\n  D1.mkCone \\<chi>'\n\ngoal (1 subgoal):\n 1. (if J1.arr j\n     then \\<pi>1 j \\<cdot>\n          \\<pi>1.induced_arrow a'\n           (\\<lambda>i. if i \\<in> Collect J1.arr then \\<chi>' i else null)\n     else null) =\n    D1.mkCone \\<chi>' j", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>j.\n      if J1.arr j\n      then \\<pi>1 j \\<cdot>\n           \\<pi>1.induced_arrow a'\n            (\\<lambda>i. if i \\<in> Collect J1.arr then \\<chi>' i else null)\n      else null) =\n  D1.mkCone \\<chi>'\n\ngoal (1 subgoal):\n 1. (if J1.arr j\n     then \\<pi>1 j \\<cdot>\n          \\<pi>1.induced_arrow a'\n           (\\<lambda>i. if i \\<in> Collect J1.arr then \\<chi>' i else null)\n     else null) =\n    D1.mkCone \\<chi>' j", "by meson"], ["proof (state)\nthis:\n  (if J1.arr j\n   then \\<pi>1 j \\<cdot>\n        \\<pi>1.induced_arrow a'\n         (\\<lambda>i. if i \\<in> Collect J1.arr then \\<chi>' i else null)\n   else null) =\n  D1.mkCone \\<chi>' j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if J1.arr j\n   then \\<pi>1 j \\<cdot>\n        \\<pi>1.induced_arrow a'\n         (\\<lambda>i. if i \\<in> Collect J1.arr then \\<chi>' i else null)\n   else null) =\n  D1.mkCone \\<chi>' j\n\ngoal (1 subgoal):\n 1. \\<pi>1 j \\<cdot> f1 = \\<chi>' j", "also"], ["proof (state)\nthis:\n  (if J1.arr j\n   then \\<pi>1 j \\<cdot>\n        \\<pi>1.induced_arrow a'\n         (\\<lambda>i. if i \\<in> Collect J1.arr then \\<chi>' i else null)\n   else null) =\n  D1.mkCone \\<chi>' j\n\ngoal (1 subgoal):\n 1. \\<pi>1 j \\<cdot> f1 = \\<chi>' j", "have \"... = \\<chi>' j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D1.mkCone \\<chi>' j = \\<chi>' j", "using J1"], ["proof (prove)\nusing this:\n  J1.arr j\n\ngoal (1 subgoal):\n 1. D1.mkCone \\<chi>' j = \\<chi>' j", "by simp"], ["proof (state)\nthis:\n  D1.mkCone \\<chi>' j = \\<chi>' j\n\ngoal (1 subgoal):\n 1. \\<pi>1 j \\<cdot> f1 = \\<chi>' j", "finally"], ["proof (chain)\npicking this:\n  \\<pi>1 j \\<cdot> f1 = \\<chi>' j", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<pi>1 j \\<cdot> f1 = \\<chi>' j\n\ngoal (1 subgoal):\n 1. \\<pi>1 j \\<cdot> f1 = \\<chi>' j", "by blast"], ["proof (state)\nthis:\n  \\<pi>1 j \\<cdot> f1 = \\<chi>' j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<pi>1 j \\<cdot> f1 = \\<chi>' j\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> J0.arr j; J1.arr j\\<rbrakk>\n    \\<Longrightarrow> D.cones_map f\n                       (\\<lambda>i.\n                           if i \\<in> Collect J0.arr\n                           then \\<pi>0 i \\<cdot> p0\n                           else if i \\<in> Collect J1.arr\n                                then \\<pi>1 i \\<cdot> p1 else null)\n                       j =\n                      \\<chi>' j", "finally"], ["proof (chain)\npicking this:\n  D.cones_map f\n   (\\<lambda>i.\n       if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n       else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null)\n   j =\n  \\<chi>' j", "show ?thesis"], ["proof (prove)\nusing this:\n  D.cones_map f\n   (\\<lambda>i.\n       if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n       else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null)\n   j =\n  \\<chi>' j\n\ngoal (1 subgoal):\n 1. D.cones_map f\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n         else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null)\n     j =\n    \\<chi>' j", "by simp"], ["proof (state)\nthis:\n  D.cones_map f\n   (\\<lambda>i.\n       if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n       else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null)\n   j =\n  \\<chi>' j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<not> J0.arr j; J1.arr j\\<rbrakk>\n  \\<Longrightarrow> D.cones_map f\n                     (\\<lambda>i.\n                         if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n                         else if i \\<in> Collect J1.arr\n                              then \\<pi>1 i \\<cdot> p1 else null)\n                     j =\n                    \\<chi>' j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> J0.arr j \\<Longrightarrow>\n  D.cones_map f\n   (\\<lambda>i.\n       if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n       else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null)\n   j =\n  \\<chi>' j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  D.cones_map f\n   (\\<lambda>i.\n       if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n       else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null)\n   j =\n  \\<chi>' j\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  D.cones_map f\n   (\\<lambda>i.\n       if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n       else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null) =\n  \\<chi>'\n\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : a' \\<rightarrow> local.dom\n     p0\\<guillemotright> \\<and>\n    D.cones_map ?a\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n         else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n              else null) =\n    \\<chi>'\n 2. \\<And>f.\n       \\<guillemotleft>f : a' \\<rightarrow> local.dom\n       p0\\<guillemotright> \\<and>\n       D.cones_map f\n        (\\<lambda>i.\n            if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n            else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                 else null) =\n       \\<chi>' \\<Longrightarrow>\n       f = ?a", "ultimately"], ["proof (chain)\npicking this:\n  \\<guillemotleft>f : a' \\<rightarrow> local.dom p0\\<guillemotright>\n  D.cones_map f\n   (\\<lambda>i.\n       if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n       else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null) =\n  \\<chi>'", "show \"\\<guillemotleft>f : a' \\<rightarrow> ?a\\<guillemotright> \\<and> D.cones_map f ?\\<pi> = \\<chi>'\""], ["proof (prove)\nusing this:\n  \\<guillemotleft>f : a' \\<rightarrow> local.dom p0\\<guillemotright>\n  D.cones_map f\n   (\\<lambda>i.\n       if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n       else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null) =\n  \\<chi>'\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>f : a' \\<rightarrow> local.dom\n    p0\\<guillemotright> \\<and>\n    D.cones_map f\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n         else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n              else null) =\n    \\<chi>'", "by blast"], ["proof (state)\nthis:\n  \\<guillemotleft>f : a' \\<rightarrow> local.dom p0\\<guillemotright> \\<and>\n  D.cones_map f\n   (\\<lambda>i.\n       if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n       else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null) =\n  \\<chi>'\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<guillemotleft>f : a' \\<rightarrow> local.dom\n       p0\\<guillemotright> \\<and>\n       D.cones_map f\n        (\\<lambda>i.\n            if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n            else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                 else null) =\n       \\<chi>' \\<Longrightarrow>\n       f =\n       p0p1.induced_arrow a'\n        (a0xa1.mkCone\n          (\\<pi>0.induced_arrow a'\n            (\\<lambda>i.\n                if i \\<in> Collect J0.arr then \\<chi>' i else null))\n          (\\<pi>1.induced_arrow a'\n            (\\<lambda>i.\n                if i \\<in> Collect J1.arr then \\<chi>' i else null)))", "show \"\\<And>f'. \\<guillemotleft>f' : a' \\<rightarrow> ?a\\<guillemotright> \\<and> D.cones_map f' ?\\<pi> = \\<chi>' \\<Longrightarrow> f' = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f'.\n       \\<guillemotleft>f' : a' \\<rightarrow> local.dom\n        p0\\<guillemotright> \\<and>\n       D.cones_map f'\n        (\\<lambda>i.\n            if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n            else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                 else null) =\n       \\<chi>' \\<Longrightarrow>\n       f' = f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f'.\n       \\<guillemotleft>f' : a' \\<rightarrow> local.dom\n        p0\\<guillemotright> \\<and>\n       D.cones_map f'\n        (\\<lambda>i.\n            if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n            else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                 else null) =\n       \\<chi>' \\<Longrightarrow>\n       f' = f", "fix f'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f'.\n       \\<guillemotleft>f' : a' \\<rightarrow> local.dom\n        p0\\<guillemotright> \\<and>\n       D.cones_map f'\n        (\\<lambda>i.\n            if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n            else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                 else null) =\n       \\<chi>' \\<Longrightarrow>\n       f' = f", "assume f': \"\\<guillemotleft>f' : a' \\<rightarrow> ?a\\<guillemotright> \\<and> D.cones_map f' ?\\<pi> = \\<chi>'\""], ["proof (state)\nthis:\n  \\<guillemotleft>f' : a' \\<rightarrow> local.dom p0\\<guillemotright> \\<and>\n  D.cones_map f'\n   (\\<lambda>i.\n       if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n       else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null) =\n  \\<chi>'\n\ngoal (1 subgoal):\n 1. \\<And>f'.\n       \\<guillemotleft>f' : a' \\<rightarrow> local.dom\n        p0\\<guillemotright> \\<and>\n       D.cones_map f'\n        (\\<lambda>i.\n            if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n            else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                 else null) =\n       \\<chi>' \\<Longrightarrow>\n       f' = f", "let ?f0' = \"p0 \\<cdot> f'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f'.\n       \\<guillemotleft>f' : a' \\<rightarrow> local.dom\n        p0\\<guillemotright> \\<and>\n       D.cones_map f'\n        (\\<lambda>i.\n            if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n            else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                 else null) =\n       \\<chi>' \\<Longrightarrow>\n       f' = f", "let ?f1' = \"p1 \\<cdot> f'\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f'.\n       \\<guillemotleft>f' : a' \\<rightarrow> local.dom\n        p0\\<guillemotright> \\<and>\n       D.cones_map f'\n        (\\<lambda>i.\n            if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n            else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                 else null) =\n       \\<chi>' \\<Longrightarrow>\n       f' = f", "have 1: \"a0xa1.is_rendered_commutative_by ?f0' ?f1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a0xa1.is_rendered_commutative_by (p0 \\<cdot> f') (p1 \\<cdot> f')", "using f' p0 p1 p0p1.renders_commutative seqI'"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f' : a' \\<rightarrow> local.dom p0\\<guillemotright> \\<and>\n  D.cones_map f'\n   (\\<lambda>i.\n       if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n       else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null) =\n  \\<chi>'\n  \\<guillemotleft>p0 : local.dom p0 \\<rightarrow> a0\\<guillemotright>\n  \\<guillemotleft>p1 : local.dom p0 \\<rightarrow> a1\\<guillemotright>\n  a0xa1.is_rendered_commutative_by p0 p1\n  \\<lbrakk>\\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright>;\n   \\<guillemotleft>?g : ?b \\<rightarrow> ?c\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> seq ?g ?f\n\ngoal (1 subgoal):\n 1. a0xa1.is_rendered_commutative_by (p0 \\<cdot> f') (p1 \\<cdot> f')", "by auto"], ["proof (state)\nthis:\n  a0xa1.is_rendered_commutative_by (p0 \\<cdot> f') (p1 \\<cdot> f')\n\ngoal (1 subgoal):\n 1. \\<And>f'.\n       \\<guillemotleft>f' : a' \\<rightarrow> local.dom\n        p0\\<guillemotright> \\<and>\n       D.cones_map f'\n        (\\<lambda>i.\n            if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n            else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                 else null) =\n       \\<chi>' \\<Longrightarrow>\n       f' = f", "have f0': \"\\<guillemotleft>?f0' : a' \\<rightarrow> a0\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>p0 \\<cdot> f' : a' \\<rightarrow> a0\\<guillemotright>", "using f' p0"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f' : a' \\<rightarrow> local.dom p0\\<guillemotright> \\<and>\n  D.cones_map f'\n   (\\<lambda>i.\n       if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n       else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null) =\n  \\<chi>'\n  \\<guillemotleft>p0 : local.dom p0 \\<rightarrow> a0\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>p0 \\<cdot> f' : a' \\<rightarrow> a0\\<guillemotright>", "by auto"], ["proof (state)\nthis:\n  \\<guillemotleft>p0 \\<cdot> f' : a' \\<rightarrow> a0\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>f'.\n       \\<guillemotleft>f' : a' \\<rightarrow> local.dom\n        p0\\<guillemotright> \\<and>\n       D.cones_map f'\n        (\\<lambda>i.\n            if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n            else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                 else null) =\n       \\<chi>' \\<Longrightarrow>\n       f' = f", "have f1': \"\\<guillemotleft>?f1' : a' \\<rightarrow> a1\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>p1 \\<cdot> f' : a' \\<rightarrow> a1\\<guillemotright>", "using f' p1"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f' : a' \\<rightarrow> local.dom p0\\<guillemotright> \\<and>\n  D.cones_map f'\n   (\\<lambda>i.\n       if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n       else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null) =\n  \\<chi>'\n  \\<guillemotleft>p1 : local.dom p0 \\<rightarrow> a1\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>p1 \\<cdot> f' : a' \\<rightarrow> a1\\<guillemotright>", "by auto"], ["proof (state)\nthis:\n  \\<guillemotleft>p1 \\<cdot> f' : a' \\<rightarrow> a1\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>f'.\n       \\<guillemotleft>f' : a' \\<rightarrow> local.dom\n        p0\\<guillemotright> \\<and>\n       D.cones_map f'\n        (\\<lambda>i.\n            if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n            else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                 else null) =\n       \\<chi>' \\<Longrightarrow>\n       f' = f", "have \"p0 \\<cdot> f = p0 \\<cdot> f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p0 \\<cdot> f = p0 \\<cdot> f'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p0 \\<cdot> f = p0 \\<cdot> f'", "have \"D0.cones_map (p0 \\<cdot> f) \\<pi>0 = ?\\<chi>0'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D0.cones_map (p0 \\<cdot> f) \\<pi>0 =\n    (\\<lambda>i. if i \\<in> Collect J0.arr then \\<chi>' i else null)", "using f p0 \\<pi>0.cone_axioms \\<chi>' \\<pi>.cone_axioms comp_assoc assms(4) seqI'"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f : a' \\<rightarrow> local.dom p0\\<guillemotright>\n  \\<guillemotleft>p0 : local.dom p0 \\<rightarrow> a0\\<guillemotright>\n  D0.cone a0 \\<pi>0\n  D.cones_map f\n   (\\<lambda>i.\n       if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n       else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null) =\n  \\<chi>'\n  D.cone (local.dom p0)\n   (\\<lambda>i.\n       if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n       else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null)\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n  Collect J0.arr \\<inter> Collect J1.arr = {}\n  \\<lbrakk>\\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright>;\n   \\<guillemotleft>?g : ?b \\<rightarrow> ?c\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> seq ?g ?f\n\ngoal (1 subgoal):\n 1. D0.cones_map (p0 \\<cdot> f) \\<pi>0 =\n    (\\<lambda>i. if i \\<in> Collect J0.arr then \\<chi>' i else null)", "by fastforce"], ["proof (state)\nthis:\n  D0.cones_map (p0 \\<cdot> f) \\<pi>0 =\n  (\\<lambda>i. if i \\<in> Collect J0.arr then \\<chi>' i else null)\n\ngoal (1 subgoal):\n 1. p0 \\<cdot> f = p0 \\<cdot> f'", "moreover"], ["proof (state)\nthis:\n  D0.cones_map (p0 \\<cdot> f) \\<pi>0 =\n  (\\<lambda>i. if i \\<in> Collect J0.arr then \\<chi>' i else null)\n\ngoal (1 subgoal):\n 1. p0 \\<cdot> f = p0 \\<cdot> f'", "have \"D0.cones_map (p0 \\<cdot> f') \\<pi>0 = ?\\<chi>0'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D0.cones_map (p0 \\<cdot> f') \\<pi>0 =\n    (\\<lambda>i. if i \\<in> Collect J0.arr then \\<chi>' i else null)", "using f' p0 \\<pi>0.cone_axioms \\<pi>.cone_axioms comp_assoc assms(4) seqI'"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f' : a' \\<rightarrow> local.dom p0\\<guillemotright> \\<and>\n  D.cones_map f'\n   (\\<lambda>i.\n       if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n       else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null) =\n  \\<chi>'\n  \\<guillemotleft>p0 : local.dom p0 \\<rightarrow> a0\\<guillemotright>\n  D0.cone a0 \\<pi>0\n  D.cone (local.dom p0)\n   (\\<lambda>i.\n       if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n       else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null)\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n  Collect J0.arr \\<inter> Collect J1.arr = {}\n  \\<lbrakk>\\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright>;\n   \\<guillemotleft>?g : ?b \\<rightarrow> ?c\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> seq ?g ?f\n\ngoal (1 subgoal):\n 1. D0.cones_map (p0 \\<cdot> f') \\<pi>0 =\n    (\\<lambda>i. if i \\<in> Collect J0.arr then \\<chi>' i else null)", "by fastforce"], ["proof (state)\nthis:\n  D0.cones_map (p0 \\<cdot> f') \\<pi>0 =\n  (\\<lambda>i. if i \\<in> Collect J0.arr then \\<chi>' i else null)\n\ngoal (1 subgoal):\n 1. p0 \\<cdot> f = p0 \\<cdot> f'", "moreover"], ["proof (state)\nthis:\n  D0.cones_map (p0 \\<cdot> f') \\<pi>0 =\n  (\\<lambda>i. if i \\<in> Collect J0.arr then \\<chi>' i else null)\n\ngoal (1 subgoal):\n 1. p0 \\<cdot> f = p0 \\<cdot> f'", "have \"p0 \\<cdot> f = f0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p0 \\<cdot> f = f0", "using 2 f0 f_def p0p1.induced_arrowI'(2)"], ["proof (prove)\nusing this:\n  a0xa1.is_rendered_commutative_by f0 f1\n  \\<guillemotleft>f0 : a' \\<rightarrow> a0\\<guillemotright>\n  f = p0p1.induced_arrow a' (a0xa1.mkCone f0 f1)\n  a0xa1.is_rendered_commutative_by ?p0' ?p1' \\<Longrightarrow>\n  p0 \\<cdot> p0p1.induced_arrow (local.dom ?p0') (a0xa1.mkCone ?p0' ?p1') =\n  ?p0'\n\ngoal (1 subgoal):\n 1. p0 \\<cdot> f = f0", "by blast"], ["proof (state)\nthis:\n  p0 \\<cdot> f = f0\n\ngoal (1 subgoal):\n 1. p0 \\<cdot> f = p0 \\<cdot> f'", "ultimately"], ["proof (chain)\npicking this:\n  D0.cones_map (p0 \\<cdot> f) \\<pi>0 =\n  (\\<lambda>i. if i \\<in> Collect J0.arr then \\<chi>' i else null)\n  D0.cones_map (p0 \\<cdot> f') \\<pi>0 =\n  (\\<lambda>i. if i \\<in> Collect J0.arr then \\<chi>' i else null)\n  p0 \\<cdot> f = f0", "show ?thesis"], ["proof (prove)\nusing this:\n  D0.cones_map (p0 \\<cdot> f) \\<pi>0 =\n  (\\<lambda>i. if i \\<in> Collect J0.arr then \\<chi>' i else null)\n  D0.cones_map (p0 \\<cdot> f') \\<pi>0 =\n  (\\<lambda>i. if i \\<in> Collect J0.arr then \\<chi>' i else null)\n  p0 \\<cdot> f = f0\n\ngoal (1 subgoal):\n 1. p0 \\<cdot> f = p0 \\<cdot> f'", "using f0 f0' \\<chi>0'.cone_axioms \\<pi>0.is_universal [of a']"], ["proof (prove)\nusing this:\n  D0.cones_map (p0 \\<cdot> f) \\<pi>0 =\n  (\\<lambda>i. if i \\<in> Collect J0.arr then \\<chi>' i else null)\n  D0.cones_map (p0 \\<cdot> f') \\<pi>0 =\n  (\\<lambda>i. if i \\<in> Collect J0.arr then \\<chi>' i else null)\n  p0 \\<cdot> f = f0\n  \\<guillemotleft>f0 : a' \\<rightarrow> a0\\<guillemotright>\n  \\<guillemotleft>p0 \\<cdot> f' : a' \\<rightarrow> a0\\<guillemotright>\n  D0.cone a'\n   (\\<lambda>i. if i \\<in> Collect J0.arr then \\<chi>' i else null)\n  D0.cone a' ?\\<chi>' \\<Longrightarrow>\n  \\<exists>!f.\n     \\<guillemotleft>f : a' \\<rightarrow> a0\\<guillemotright> \\<and>\n     D0.cones_map f \\<pi>0 = ?\\<chi>'\n\ngoal (1 subgoal):\n 1. p0 \\<cdot> f = p0 \\<cdot> f'", "by auto"], ["proof (state)\nthis:\n  p0 \\<cdot> f = p0 \\<cdot> f'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p0 \\<cdot> f = p0 \\<cdot> f'\n\ngoal (1 subgoal):\n 1. \\<And>f'.\n       \\<guillemotleft>f' : a' \\<rightarrow> local.dom\n        p0\\<guillemotright> \\<and>\n       D.cones_map f'\n        (\\<lambda>i.\n            if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n            else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                 else null) =\n       \\<chi>' \\<Longrightarrow>\n       f' = f", "moreover"], ["proof (state)\nthis:\n  p0 \\<cdot> f = p0 \\<cdot> f'\n\ngoal (1 subgoal):\n 1. \\<And>f'.\n       \\<guillemotleft>f' : a' \\<rightarrow> local.dom\n        p0\\<guillemotright> \\<and>\n       D.cones_map f'\n        (\\<lambda>i.\n            if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n            else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                 else null) =\n       \\<chi>' \\<Longrightarrow>\n       f' = f", "have \"p1 \\<cdot> f = p1 \\<cdot> f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p1 \\<cdot> f = p1 \\<cdot> f'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. p1 \\<cdot> f = p1 \\<cdot> f'", "have \"D1.cones_map (p1 \\<cdot> f) \\<pi>1 = ?\\<chi>1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D1.cones_map (p1 \\<cdot> f) \\<pi>1 =\n    (\\<lambda>i. if i \\<in> Collect J1.arr then \\<chi>' i else null)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       D1.cones_map (p1 \\<cdot> f) \\<pi>1 i =\n       (if i \\<in> Collect J1.arr then \\<chi>' i else null)", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       D1.cones_map (p1 \\<cdot> f) \\<pi>1 i =\n       (if i \\<in> Collect J1.arr then \\<chi>' i else null)", "show \"D1.cones_map (p1 \\<cdot> f) \\<pi>1 j = ?\\<chi>1' j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D1.cones_map (p1 \\<cdot> f) \\<pi>1 j =\n    (if j \\<in> Collect J1.arr then \\<chi>' j else null)", "using f p1 \\<pi>1.cone_axioms \\<chi>' \\<pi>.cone_axioms comp_assoc assms(4) seqI'"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f : a' \\<rightarrow> local.dom p0\\<guillemotright>\n  \\<guillemotleft>p1 : local.dom p0 \\<rightarrow> a1\\<guillemotright>\n  D1.cone a1 \\<pi>1\n  D.cones_map f\n   (\\<lambda>i.\n       if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n       else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null) =\n  \\<chi>'\n  D.cone (local.dom p0)\n   (\\<lambda>i.\n       if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n       else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null)\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n  Collect J0.arr \\<inter> Collect J1.arr = {}\n  \\<lbrakk>\\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright>;\n   \\<guillemotleft>?g : ?b \\<rightarrow> ?c\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> seq ?g ?f\n\ngoal (1 subgoal):\n 1. D1.cones_map (p1 \\<cdot> f) \\<pi>1 j =\n    (if j \\<in> Collect J1.arr then \\<chi>' j else null)", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<guillemotleft>f : a' \\<rightarrow> local.dom\n             p0\\<guillemotright>;\n     \\<guillemotleft>p1 : local.dom p0 \\<rightarrow> a1\\<guillemotright>;\n     D1.cone a1 \\<pi>1;\n     Limit.cone J.comp (\\<cdot>)\n      (\\<lambda>i.\n          if J0.arr i then D0 i\n          else if i \\<in> Collect J1.arr then D1 i else null)\n      (local.dom p0)\n      (\\<lambda>i.\n          if J0.arr i then \\<pi>0 i \\<cdot> p0\n          else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n               else null);\n     \\<And>h g f. (h \\<cdot> g) \\<cdot> f = h \\<cdot> g \\<cdot> f;\n     Collect J0.arr \\<inter> Collect J1.arr = {};\n     \\<And>f a b g c.\n        \\<lbrakk>\\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>;\n         \\<guillemotleft>g : b \\<rightarrow> c\\<guillemotright>\\<rbrakk>\n        \\<Longrightarrow> seq g f;\n     \\<chi>' =\n     (\\<lambda>j.\n         if J0.arr j \\<or> J1.arr j\n         then (if J0.arr j then \\<pi>0 j \\<cdot> p0\n               else if j \\<in> Collect J1.arr then \\<pi>1 j \\<cdot> p1\n                    else null) \\<cdot>\n              f\n         else null);\n     D1.cone (cod p1) \\<pi>1; J1.arr j; J0.arr j;\n     Limit.cone J.comp (\\<cdot>)\n      (\\<lambda>i.\n          if J0.arr i then D0 i\n          else if i \\<in> Collect J1.arr then D1 i else null)\n      (cod f)\n      (\\<lambda>i.\n          if J0.arr i then \\<pi>0 i \\<cdot> p0\n          else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n               else null)\\<rbrakk>\n    \\<Longrightarrow> \\<pi>1 j \\<cdot> p1 \\<cdot> f =\n                      \\<pi>0 j \\<cdot> p0 \\<cdot> f\n 2. \\<lbrakk>\\<guillemotleft>f : a' \\<rightarrow> local.dom\n             p0\\<guillemotright>;\n     \\<guillemotleft>p1 : local.dom p0 \\<rightarrow> a1\\<guillemotright>;\n     D1.cone a1 \\<pi>1;\n     Limit.cone J.comp (\\<cdot>)\n      (\\<lambda>i.\n          if J0.arr i then D0 i\n          else if i \\<in> Collect J1.arr then D1 i else null)\n      (local.dom p0)\n      (\\<lambda>i.\n          if J0.arr i then \\<pi>0 i \\<cdot> p0\n          else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n               else null);\n     \\<And>h g f. (h \\<cdot> g) \\<cdot> f = h \\<cdot> g \\<cdot> f;\n     Collect J0.arr \\<inter> Collect J1.arr = {};\n     \\<And>f a b g c.\n        \\<lbrakk>\\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>;\n         \\<guillemotleft>g : b \\<rightarrow> c\\<guillemotright>\\<rbrakk>\n        \\<Longrightarrow> seq g f;\n     \\<chi>' = undefined; D1.cone (cod p1) \\<pi>1; J1.arr j; J0.arr j;\n     \\<not> Limit.cone J.comp (\\<cdot>)\n             (\\<lambda>i.\n                 if J0.arr i then D0 i\n                 else if i \\<in> Collect J1.arr then D1 i else null)\n             (cod f)\n             (\\<lambda>i.\n                 if J0.arr i then \\<pi>0 i \\<cdot> p0\n                 else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                      else null)\\<rbrakk>\n    \\<Longrightarrow> \\<pi>1 j \\<cdot> p1 \\<cdot> f = undefined j\n 3. \\<lbrakk>\\<guillemotleft>f : a' \\<rightarrow> local.dom\n             p0\\<guillemotright>;\n     \\<guillemotleft>p1 : local.dom p0 \\<rightarrow> a1\\<guillemotright>;\n     D1.cone a1 \\<pi>1;\n     Limit.cone J.comp (\\<cdot>)\n      (\\<lambda>i.\n          if J0.arr i then D0 i\n          else if i \\<in> Collect J1.arr then D1 i else null)\n      (local.dom p0)\n      (\\<lambda>i.\n          if J0.arr i then \\<pi>0 i \\<cdot> p0\n          else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n               else null);\n     \\<And>h g f. (h \\<cdot> g) \\<cdot> f = h \\<cdot> g \\<cdot> f;\n     Collect J0.arr \\<inter> Collect J1.arr = {};\n     \\<And>f a b g c.\n        \\<lbrakk>\\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>;\n         \\<guillemotleft>g : b \\<rightarrow> c\\<guillemotright>\\<rbrakk>\n        \\<Longrightarrow> seq g f;\n     \\<chi>' = undefined; D1.cone (cod p1) \\<pi>1; J1.arr j;\n     \\<not> J0.arr j;\n     \\<not> Limit.cone J.comp (\\<cdot>)\n             (\\<lambda>i.\n                 if J0.arr i then D0 i\n                 else if i \\<in> Collect J1.arr then D1 i else null)\n             (cod f)\n             (\\<lambda>i.\n                 if J0.arr i then \\<pi>0 i \\<cdot> p0\n                 else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                      else null)\\<rbrakk>\n    \\<Longrightarrow> \\<pi>1 j \\<cdot> p1 \\<cdot> f = undefined j", "by auto"], ["proof (state)\nthis:\n  D1.cones_map (p1 \\<cdot> f) \\<pi>1 j =\n  (if j \\<in> Collect J1.arr then \\<chi>' j else null)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  D1.cones_map (p1 \\<cdot> f) \\<pi>1 =\n  (\\<lambda>i. if i \\<in> Collect J1.arr then \\<chi>' i else null)\n\ngoal (1 subgoal):\n 1. p1 \\<cdot> f = p1 \\<cdot> f'", "moreover"], ["proof (state)\nthis:\n  D1.cones_map (p1 \\<cdot> f) \\<pi>1 =\n  (\\<lambda>i. if i \\<in> Collect J1.arr then \\<chi>' i else null)\n\ngoal (1 subgoal):\n 1. p1 \\<cdot> f = p1 \\<cdot> f'", "have \"D1.cones_map (p1 \\<cdot> f') \\<pi>1 = ?\\<chi>1'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D1.cones_map (p1 \\<cdot> f') \\<pi>1 =\n    (\\<lambda>i. if i \\<in> Collect J1.arr then \\<chi>' i else null)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       D1.cones_map (p1 \\<cdot> f') \\<pi>1 i =\n       (if i \\<in> Collect J1.arr then \\<chi>' i else null)", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>i.\n       D1.cones_map (p1 \\<cdot> f') \\<pi>1 i =\n       (if i \\<in> Collect J1.arr then \\<chi>' i else null)", "show \"D1.cones_map (p1 \\<cdot> f') \\<pi>1 j = ?\\<chi>1' j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D1.cones_map (p1 \\<cdot> f') \\<pi>1 j =\n    (if j \\<in> Collect J1.arr then \\<chi>' j else null)", "using f' p1 \\<pi>1.cone_axioms \\<pi>.cone_axioms comp_assoc assms(4) seqI'"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f' : a' \\<rightarrow> local.dom p0\\<guillemotright> \\<and>\n  D.cones_map f'\n   (\\<lambda>i.\n       if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n       else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null) =\n  \\<chi>'\n  \\<guillemotleft>p1 : local.dom p0 \\<rightarrow> a1\\<guillemotright>\n  D1.cone a1 \\<pi>1\n  D.cone (local.dom p0)\n   (\\<lambda>i.\n       if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n       else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null)\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n  Collect J0.arr \\<inter> Collect J1.arr = {}\n  \\<lbrakk>\\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright>;\n   \\<guillemotleft>?g : ?b \\<rightarrow> ?c\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> seq ?g ?f\n\ngoal (1 subgoal):\n 1. D1.cones_map (p1 \\<cdot> f') \\<pi>1 j =\n    (if j \\<in> Collect J1.arr then \\<chi>' j else null)", "apply auto"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<guillemotleft>p1 : local.dom\n                                   p0 \\<rightarrow> a1\\<guillemotright>;\n     D1.cone a1 \\<pi>1;\n     Limit.cone J.comp (\\<cdot>)\n      (\\<lambda>i.\n          if J0.arr i then D0 i\n          else if i \\<in> Collect J1.arr then D1 i else null)\n      (local.dom p0)\n      (\\<lambda>i.\n          if J0.arr i then \\<pi>0 i \\<cdot> p0\n          else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n               else null);\n     \\<And>h g f. (h \\<cdot> g) \\<cdot> f = h \\<cdot> g \\<cdot> f;\n     Collect J0.arr \\<inter> Collect J1.arr = {};\n     \\<And>f a b g c.\n        \\<lbrakk>\\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>;\n         \\<guillemotleft>g : b \\<rightarrow> c\\<guillemotright>\\<rbrakk>\n        \\<Longrightarrow> seq g f;\n     \\<guillemotleft>f' : a' \\<rightarrow> local.dom p0\\<guillemotright>;\n     \\<chi>' =\n     (\\<lambda>j.\n         if J0.arr j \\<or> J1.arr j\n         then (if J0.arr j then \\<pi>0 j \\<cdot> p0\n               else if j \\<in> Collect J1.arr then \\<pi>1 j \\<cdot> p1\n                    else null) \\<cdot>\n              f'\n         else null);\n     D1.cone (cod p1) \\<pi>1; J1.arr j; J0.arr j;\n     Limit.cone J.comp (\\<cdot>)\n      (\\<lambda>i.\n          if J0.arr i then D0 i\n          else if i \\<in> Collect J1.arr then D1 i else null)\n      (cod f')\n      (\\<lambda>i.\n          if J0.arr i then \\<pi>0 i \\<cdot> p0\n          else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n               else null)\\<rbrakk>\n    \\<Longrightarrow> \\<pi>1 j \\<cdot> p1 \\<cdot> f' =\n                      \\<pi>0 j \\<cdot> p0 \\<cdot> f'\n 2. \\<lbrakk>\\<guillemotleft>p1 : local.dom\n                                   p0 \\<rightarrow> a1\\<guillemotright>;\n     D1.cone a1 \\<pi>1;\n     Limit.cone J.comp (\\<cdot>)\n      (\\<lambda>i.\n          if J0.arr i then D0 i\n          else if i \\<in> Collect J1.arr then D1 i else null)\n      (local.dom p0)\n      (\\<lambda>i.\n          if J0.arr i then \\<pi>0 i \\<cdot> p0\n          else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n               else null);\n     \\<And>h g f. (h \\<cdot> g) \\<cdot> f = h \\<cdot> g \\<cdot> f;\n     Collect J0.arr \\<inter> Collect J1.arr = {};\n     \\<And>f a b g c.\n        \\<lbrakk>\\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>;\n         \\<guillemotleft>g : b \\<rightarrow> c\\<guillemotright>\\<rbrakk>\n        \\<Longrightarrow> seq g f;\n     \\<guillemotleft>f' : a' \\<rightarrow> local.dom p0\\<guillemotright>;\n     \\<chi>' = undefined; D1.cone (cod p1) \\<pi>1; J1.arr j; J0.arr j;\n     \\<not> Limit.cone J.comp (\\<cdot>)\n             (\\<lambda>i.\n                 if J0.arr i then D0 i\n                 else if i \\<in> Collect J1.arr then D1 i else null)\n             (cod f')\n             (\\<lambda>i.\n                 if J0.arr i then \\<pi>0 i \\<cdot> p0\n                 else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                      else null)\\<rbrakk>\n    \\<Longrightarrow> \\<pi>1 j \\<cdot> p1 \\<cdot> f' = undefined j\n 3. \\<lbrakk>\\<guillemotleft>p1 : local.dom\n                                   p0 \\<rightarrow> a1\\<guillemotright>;\n     D1.cone a1 \\<pi>1;\n     Limit.cone J.comp (\\<cdot>)\n      (\\<lambda>i.\n          if J0.arr i then D0 i\n          else if i \\<in> Collect J1.arr then D1 i else null)\n      (local.dom p0)\n      (\\<lambda>i.\n          if J0.arr i then \\<pi>0 i \\<cdot> p0\n          else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n               else null);\n     \\<And>h g f. (h \\<cdot> g) \\<cdot> f = h \\<cdot> g \\<cdot> f;\n     Collect J0.arr \\<inter> Collect J1.arr = {};\n     \\<And>f a b g c.\n        \\<lbrakk>\\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright>;\n         \\<guillemotleft>g : b \\<rightarrow> c\\<guillemotright>\\<rbrakk>\n        \\<Longrightarrow> seq g f;\n     \\<guillemotleft>f' : a' \\<rightarrow> local.dom p0\\<guillemotright>;\n     \\<chi>' = undefined; D1.cone (cod p1) \\<pi>1; J1.arr j;\n     \\<not> J0.arr j;\n     \\<not> Limit.cone J.comp (\\<cdot>)\n             (\\<lambda>i.\n                 if J0.arr i then D0 i\n                 else if i \\<in> Collect J1.arr then D1 i else null)\n             (cod f')\n             (\\<lambda>i.\n                 if J0.arr i then \\<pi>0 i \\<cdot> p0\n                 else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                      else null)\\<rbrakk>\n    \\<Longrightarrow> \\<pi>1 j \\<cdot> p1 \\<cdot> f' = undefined j", "by auto"], ["proof (state)\nthis:\n  D1.cones_map (p1 \\<cdot> f') \\<pi>1 j =\n  (if j \\<in> Collect J1.arr then \\<chi>' j else null)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  D1.cones_map (p1 \\<cdot> f') \\<pi>1 =\n  (\\<lambda>i. if i \\<in> Collect J1.arr then \\<chi>' i else null)\n\ngoal (1 subgoal):\n 1. p1 \\<cdot> f = p1 \\<cdot> f'", "moreover"], ["proof (state)\nthis:\n  D1.cones_map (p1 \\<cdot> f') \\<pi>1 =\n  (\\<lambda>i. if i \\<in> Collect J1.arr then \\<chi>' i else null)\n\ngoal (1 subgoal):\n 1. p1 \\<cdot> f = p1 \\<cdot> f'", "have \"p1 \\<cdot> f = f1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. p1 \\<cdot> f = f1", "using 2 f1 f_def p0p1.induced_arrowI'(3)"], ["proof (prove)\nusing this:\n  a0xa1.is_rendered_commutative_by f0 f1\n  \\<guillemotleft>f1 : a' \\<rightarrow> a1\\<guillemotright>\n  f = p0p1.induced_arrow a' (a0xa1.mkCone f0 f1)\n  a0xa1.is_rendered_commutative_by ?p0' ?p1' \\<Longrightarrow>\n  p1 \\<cdot> p0p1.induced_arrow (local.dom ?p1') (a0xa1.mkCone ?p0' ?p1') =\n  ?p1'\n\ngoal (1 subgoal):\n 1. p1 \\<cdot> f = f1", "by blast"], ["proof (state)\nthis:\n  p1 \\<cdot> f = f1\n\ngoal (1 subgoal):\n 1. p1 \\<cdot> f = p1 \\<cdot> f'", "ultimately"], ["proof (chain)\npicking this:\n  D1.cones_map (p1 \\<cdot> f) \\<pi>1 =\n  (\\<lambda>i. if i \\<in> Collect J1.arr then \\<chi>' i else null)\n  D1.cones_map (p1 \\<cdot> f') \\<pi>1 =\n  (\\<lambda>i. if i \\<in> Collect J1.arr then \\<chi>' i else null)\n  p1 \\<cdot> f = f1", "show ?thesis"], ["proof (prove)\nusing this:\n  D1.cones_map (p1 \\<cdot> f) \\<pi>1 =\n  (\\<lambda>i. if i \\<in> Collect J1.arr then \\<chi>' i else null)\n  D1.cones_map (p1 \\<cdot> f') \\<pi>1 =\n  (\\<lambda>i. if i \\<in> Collect J1.arr then \\<chi>' i else null)\n  p1 \\<cdot> f = f1\n\ngoal (1 subgoal):\n 1. p1 \\<cdot> f = p1 \\<cdot> f'", "using f1 f1' \\<chi>1'.cone_axioms \\<pi>1.is_universal [of a']"], ["proof (prove)\nusing this:\n  D1.cones_map (p1 \\<cdot> f) \\<pi>1 =\n  (\\<lambda>i. if i \\<in> Collect J1.arr then \\<chi>' i else null)\n  D1.cones_map (p1 \\<cdot> f') \\<pi>1 =\n  (\\<lambda>i. if i \\<in> Collect J1.arr then \\<chi>' i else null)\n  p1 \\<cdot> f = f1\n  \\<guillemotleft>f1 : a' \\<rightarrow> a1\\<guillemotright>\n  \\<guillemotleft>p1 \\<cdot> f' : a' \\<rightarrow> a1\\<guillemotright>\n  D1.cone a'\n   (\\<lambda>i. if i \\<in> Collect J1.arr then \\<chi>' i else null)\n  D1.cone a' ?\\<chi>' \\<Longrightarrow>\n  \\<exists>!f.\n     \\<guillemotleft>f : a' \\<rightarrow> a1\\<guillemotright> \\<and>\n     D1.cones_map f \\<pi>1 = ?\\<chi>'\n\ngoal (1 subgoal):\n 1. p1 \\<cdot> f = p1 \\<cdot> f'", "by auto"], ["proof (state)\nthis:\n  p1 \\<cdot> f = p1 \\<cdot> f'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  p1 \\<cdot> f = p1 \\<cdot> f'\n\ngoal (1 subgoal):\n 1. \\<And>f'.\n       \\<guillemotleft>f' : a' \\<rightarrow> local.dom\n        p0\\<guillemotright> \\<and>\n       D.cones_map f'\n        (\\<lambda>i.\n            if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n            else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n                 else null) =\n       \\<chi>' \\<Longrightarrow>\n       f' = f", "ultimately"], ["proof (chain)\npicking this:\n  p0 \\<cdot> f = p0 \\<cdot> f'\n  p1 \\<cdot> f = p1 \\<cdot> f'", "show \"f' = f\""], ["proof (prove)\nusing this:\n  p0 \\<cdot> f = p0 \\<cdot> f'\n  p1 \\<cdot> f = p1 \\<cdot> f'\n\ngoal (1 subgoal):\n 1. f' = f", "using f f' p0p1.is_universal' [of a']"], ["proof (prove)\nusing this:\n  p0 \\<cdot> f = p0 \\<cdot> f'\n  p1 \\<cdot> f = p1 \\<cdot> f'\n  \\<guillemotleft>f : a' \\<rightarrow> local.dom p0\\<guillemotright>\n  \\<guillemotleft>f' : a' \\<rightarrow> local.dom p0\\<guillemotright> \\<and>\n  D.cones_map f'\n   (\\<lambda>i.\n       if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n       else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null) =\n  \\<chi>'\n  a0xa1.is_rendered_commutative_by a' ?p1' \\<Longrightarrow>\n  \\<exists>!h.\n     \\<guillemotleft>h : local.dom\n                          a' \\<rightarrow> local.dom\n      p0\\<guillemotright> \\<and>\n     p0 \\<cdot> h = a' \\<and> p1 \\<cdot> h = ?p1'\n\ngoal (1 subgoal):\n 1. f' = f", "by (metis (no_types, lifting) \"1\" dom_comp in_homE p0p1.is_universal' p1 seqI')"], ["proof (state)\nthis:\n  f' = f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<guillemotleft>?f'4 : a' \\<rightarrow> local.dom\n     p0\\<guillemotright> \\<and>\n  D.cones_map ?f'4\n   (\\<lambda>i.\n       if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n       else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null) =\n  \\<chi>' \\<Longrightarrow>\n  ?f'4 = f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!f.\n     \\<guillemotleft>f : a' \\<rightarrow> local.dom\n     p0\\<guillemotright> \\<and>\n     D.cones_map f\n      (\\<lambda>i.\n          if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n          else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n               else null) =\n     \\<chi>'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  D.cone ?a'4 ?\\<chi>'4 \\<Longrightarrow>\n  \\<exists>!f.\n     \\<guillemotleft>f : ?a'4 \\<rightarrow> local.dom\n       p0\\<guillemotright> \\<and>\n     D.cones_map f\n      (\\<lambda>i.\n          if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n          else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1\n               else null) =\n     ?\\<chi>'4\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\ngoal (1 subgoal):\n 1. has_as_product J.comp\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then D0 i\n         else if i \\<in> Collect J1.arr then D1 i else null)\n     (local.dom p0)", "show \"has_as_product J.comp ?D ?a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_as_product J.comp\n     (\\<lambda>i.\n         if i \\<in> Collect J0.arr then D0 i\n         else if i \\<in> Collect J1.arr then D1 i else null)\n     (local.dom p0)", "unfolding has_as_product_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<pi>.\n       product_cone J.comp (\\<cdot>)\n        (\\<lambda>i.\n            if i \\<in> Collect J0.arr then D0 i\n            else if i \\<in> Collect J1.arr then D1 i else null)\n        (local.dom p0) \\<pi>", "using \\<pi>.product_cone_axioms"], ["proof (prove)\nusing this:\n  product_cone J.comp (\\<cdot>)\n   (\\<lambda>i.\n       if i \\<in> Collect J0.arr then D0 i\n       else if i \\<in> Collect J1.arr then D1 i else null)\n   (local.dom p0)\n   (\\<lambda>i.\n       if i \\<in> Collect J0.arr then \\<pi>0 i \\<cdot> p0\n       else if i \\<in> Collect J1.arr then \\<pi>1 i \\<cdot> p1 else null)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<pi>.\n       product_cone J.comp (\\<cdot>)\n        (\\<lambda>i.\n            if i \\<in> Collect J0.arr then D0 i\n            else if i \\<in> Collect J1.arr then D1 i else null)\n        (local.dom p0) \\<pi>", "by auto"], ["proof (state)\nthis:\n  has_as_product J.comp\n   (\\<lambda>i.\n       if i \\<in> Collect J0.arr then D0 i\n       else if i \\<in> Collect J1.arr then D1 i else null)\n   (local.dom p0)\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "sublocale cartesian_category \\<subseteq> category_with_finite_products"], ["proof (prove)\ngoal (1 subgoal):\n 1. category_with_finite_products (\\<cdot>)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I. finite I \\<Longrightarrow> has_products I", "obtain t where t: \"terminal t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>t. terminal t \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using has_terminal"], ["proof (prove)\nusing this:\n  Ex terminal\n\ngoal (1 subgoal):\n 1. (\\<And>t. terminal t \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by blast"], ["proof (state)\nthis:\n  terminal t\n\ngoal (1 subgoal):\n 1. \\<And>I. finite I \\<Longrightarrow> has_products I", "{"], ["proof (state)\nthis:\n  terminal t\n\ngoal (1 subgoal):\n 1. \\<And>I. finite I \\<Longrightarrow> has_products I", "fix n :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I. finite I \\<Longrightarrow> has_products I", "have \"\\<And>I :: nat set. finite I \\<and> card I = n \\<Longrightarrow> has_products I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I. finite I \\<and> card I = n \\<Longrightarrow> has_products I", "proof (induct n)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>I. finite I \\<and> card I = 0 \\<Longrightarrow> has_products I\n 2. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   finite I \\<and> card I = n \\<Longrightarrow>\n                   has_products I;\n        finite I \\<and> card I = Suc n\\<rbrakk>\n       \\<Longrightarrow> has_products I", "show \"\\<And>I :: nat set. finite I \\<and> card I = 0 \\<Longrightarrow> has_products I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>I. finite I \\<and> card I = 0 \\<Longrightarrow> has_products I", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I. finite I \\<and> card I = 0 \\<Longrightarrow> has_products I", "fix I :: \"nat set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>I. finite I \\<and> card I = 0 \\<Longrightarrow> has_products I", "assume \"finite I \\<and> card I = 0\""], ["proof (state)\nthis:\n  finite I \\<and> card I = 0\n\ngoal (1 subgoal):\n 1. \\<And>I. finite I \\<and> card I = 0 \\<Longrightarrow> has_products I", "hence I: \"I = {}\""], ["proof (prove)\nusing this:\n  finite I \\<and> card I = 0\n\ngoal (1 subgoal):\n 1. I = {}", "by force"], ["proof (state)\nthis:\n  I = {}\n\ngoal (1 subgoal):\n 1. \\<And>I. finite I \\<and> card I = 0 \\<Longrightarrow> has_products I", "thus \"has_products I\""], ["proof (prove)\nusing this:\n  I = {}\n\ngoal (1 subgoal):\n 1. has_products I", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. I = {} \\<Longrightarrow> has_products I", "interpret J: discrete_category I 0"], ["proof (prove)\ngoal (1 subgoal):\n 1. discrete_category I 0", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 \\<notin> I", "using I"], ["proof (prove)\nusing this:\n  I = {}\n\ngoal (1 subgoal):\n 1. 0 \\<notin> I", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. I = {} \\<Longrightarrow> has_products I", "have \"\\<And>D. discrete_diagram J.comp C D \\<Longrightarrow> \\<exists>a. has_as_product J.comp D a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>D.\n       discrete_diagram J.comp (\\<cdot>) D \\<Longrightarrow>\n       \\<exists>a. has_as_product J.comp D a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>D.\n       discrete_diagram J.comp (\\<cdot>) D \\<Longrightarrow>\n       \\<exists>a. has_as_product J.comp D a", "fix D"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>D.\n       discrete_diagram J.comp (\\<cdot>) D \\<Longrightarrow>\n       \\<exists>a. has_as_product J.comp D a", "assume D: \"discrete_diagram J.comp C D\""], ["proof (state)\nthis:\n  discrete_diagram J.comp (\\<cdot>) D\n\ngoal (1 subgoal):\n 1. \\<And>D.\n       discrete_diagram J.comp (\\<cdot>) D \\<Longrightarrow>\n       \\<exists>a. has_as_product J.comp D a", "interpret D: discrete_diagram J.comp C D"], ["proof (prove)\ngoal (1 subgoal):\n 1. discrete_diagram J.comp (\\<cdot>) D", "using D"], ["proof (prove)\nusing this:\n  discrete_diagram J.comp (\\<cdot>) D\n\ngoal (1 subgoal):\n 1. discrete_diagram J.comp (\\<cdot>) D", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>D.\n       discrete_diagram J.comp (\\<cdot>) D \\<Longrightarrow>\n       \\<exists>a. has_as_product J.comp D a", "interpret D: empty_diagram J.comp C D"], ["proof (prove)\ngoal (1 subgoal):\n 1. empty_diagram J.comp (\\<cdot>) D", "using I J.arr_char"], ["proof (prove)\nusing this:\n  I = {}\n  J.arr ?f = (?f \\<in> I)\n\ngoal (1 subgoal):\n 1. empty_diagram J.comp (\\<cdot>) D", "by unfold_locales simp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>D.\n       discrete_diagram J.comp (\\<cdot>) D \\<Longrightarrow>\n       \\<exists>a. has_as_product J.comp D a", "have \"has_as_product J.comp D t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_as_product J.comp D t", "using t D.has_as_limit_iff_terminal has_as_product_def product_cone_def\n                      J.category_axioms category_axioms D.discrete_diagram_axioms"], ["proof (prove)\nusing this:\n  terminal t\n  D.has_as_limit ?a = terminal ?a\n  has_as_product ?J ?D ?a \\<equiv>\n  \\<exists>\\<pi>. product_cone ?J (\\<cdot>) ?D ?a \\<pi>\n  product_cone ?J ?C ?D ?a ?\\<pi> \\<equiv>\n  (category ?J \\<and> category ?C) \\<and>\n  discrete_diagram ?J ?C ?D \\<and> limit_cone ?J ?C ?D ?a ?\\<pi>\n  category J.comp\n  category (\\<cdot>)\n  discrete_diagram J.comp (\\<cdot>) D\n\ngoal (1 subgoal):\n 1. has_as_product J.comp D t", "by metis"], ["proof (state)\nthis:\n  has_as_product J.comp D t\n\ngoal (1 subgoal):\n 1. \\<And>D.\n       discrete_diagram J.comp (\\<cdot>) D \\<Longrightarrow>\n       \\<exists>a. has_as_product J.comp D a", "thus \"\\<exists>a. has_as_product J.comp D a\""], ["proof (prove)\nusing this:\n  has_as_product J.comp D t\n\ngoal (1 subgoal):\n 1. \\<exists>a. has_as_product J.comp D a", "by blast"], ["proof (state)\nthis:\n  \\<exists>a. has_as_product J.comp D a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  discrete_diagram J.comp (\\<cdot>) ?D4 \\<Longrightarrow>\n  \\<exists>a. has_as_product J.comp ?D4 a\n\ngoal (1 subgoal):\n 1. I = {} \\<Longrightarrow> has_products I", "moreover"], ["proof (state)\nthis:\n  discrete_diagram J.comp (\\<cdot>) ?D4 \\<Longrightarrow>\n  \\<exists>a. has_as_product J.comp ?D4 a\n\ngoal (1 subgoal):\n 1. I = {} \\<Longrightarrow> has_products I", "have \"I \\<noteq> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<noteq> UNIV", "using I"], ["proof (prove)\nusing this:\n  I = {}\n\ngoal (1 subgoal):\n 1. I \\<noteq> UNIV", "by blast"], ["proof (state)\nthis:\n  I \\<noteq> UNIV\n\ngoal (1 subgoal):\n 1. I = {} \\<Longrightarrow> has_products I", "ultimately"], ["proof (chain)\npicking this:\n  discrete_diagram J.comp (\\<cdot>) ?D4 \\<Longrightarrow>\n  \\<exists>a. has_as_product J.comp ?D4 a\n  I \\<noteq> UNIV", "show ?thesis"], ["proof (prove)\nusing this:\n  discrete_diagram J.comp (\\<cdot>) ?D4 \\<Longrightarrow>\n  \\<exists>a. has_as_product J.comp ?D4 a\n  I \\<noteq> UNIV\n\ngoal (1 subgoal):\n 1. has_products I", "using I has_products_def"], ["proof (prove)\nusing this:\n  discrete_diagram J.comp (\\<cdot>) ?D4 \\<Longrightarrow>\n  \\<exists>a. has_as_product J.comp ?D4 a\n  I \\<noteq> UNIV\n  I = {}\n  has_products ?I \\<equiv>\n  ?I \\<noteq> UNIV \\<and>\n  (\\<forall>J D.\n      discrete_diagram J (\\<cdot>) D \\<and>\n      Collect (partial_magma.arr J) = ?I \\<longrightarrow>\n      (\\<exists>a. has_as_product J D a))\n\ngoal (1 subgoal):\n 1. has_products I", "by (metis category_with_terminal_object.has_terminal discrete_diagram.product_coneI\n                  discrete_diagram_def empty_diagram.has_as_limit_iff_terminal empty_diagram.intro\n                  empty_diagram_axioms.intro empty_iff has_as_product_def\n                  is_category_with_terminal_object mem_Collect_eq)"], ["proof (state)\nthis:\n  has_products I\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  has_products I\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite ?I4 \\<and> card ?I4 = 0 \\<Longrightarrow> has_products ?I4\n\ngoal (1 subgoal):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   finite I \\<and> card I = n \\<Longrightarrow>\n                   has_products I;\n        finite I \\<and> card I = Suc n\\<rbrakk>\n       \\<Longrightarrow> has_products I", "show \"\\<And>n I :: nat set.\n                \\<lbrakk> (\\<And>I :: nat set. finite I \\<and> card I = n \\<Longrightarrow> has_products I);\n                  finite I \\<and> card I = Suc n \\<rbrakk>\n                    \\<Longrightarrow> has_products I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   finite I \\<and> card I = n \\<Longrightarrow>\n                   has_products I;\n        finite I \\<and> card I = Suc n\\<rbrakk>\n       \\<Longrightarrow> has_products I", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   finite I \\<and> card I = n \\<Longrightarrow>\n                   has_products I;\n        finite I \\<and> card I = Suc n\\<rbrakk>\n       \\<Longrightarrow> has_products I", "fix n :: nat"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   finite I \\<and> card I = n \\<Longrightarrow>\n                   has_products I;\n        finite I \\<and> card I = Suc n\\<rbrakk>\n       \\<Longrightarrow> has_products I", "fix I :: \"nat set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   finite I \\<and> card I = n \\<Longrightarrow>\n                   has_products I;\n        finite I \\<and> card I = Suc n\\<rbrakk>\n       \\<Longrightarrow> has_products I", "assume IH: \"\\<And>I :: nat set. finite I \\<and> card I = n \\<Longrightarrow> has_products I\""], ["proof (state)\nthis:\n  finite ?I4 \\<and> card ?I4 = n \\<Longrightarrow> has_products ?I4\n\ngoal (1 subgoal):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   finite I \\<and> card I = n \\<Longrightarrow>\n                   has_products I;\n        finite I \\<and> card I = Suc n\\<rbrakk>\n       \\<Longrightarrow> has_products I", "assume I: \"finite I \\<and> card I = Suc n\""], ["proof (state)\nthis:\n  finite I \\<and> card I = Suc n\n\ngoal (1 subgoal):\n 1. \\<And>n I.\n       \\<lbrakk>\\<And>I.\n                   finite I \\<and> card I = n \\<Longrightarrow>\n                   has_products I;\n        finite I \\<and> card I = Suc n\\<rbrakk>\n       \\<Longrightarrow> has_products I", "show \"has_products I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_products I", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. has_products I", "have \"card I = 1 \\<Longrightarrow> has_products I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card I = 1 \\<Longrightarrow> has_products I", "using I has_unary_products"], ["proof (prove)\nusing this:\n  finite I \\<and> card I = Suc n\n  \\<lbrakk>card ?I = 1; ?I \\<noteq> UNIV\\<rbrakk>\n  \\<Longrightarrow> has_products ?I\n\ngoal (1 subgoal):\n 1. card I = 1 \\<Longrightarrow> has_products I", "by blast"], ["proof (state)\nthis:\n  card I = 1 \\<Longrightarrow> has_products I\n\ngoal (1 subgoal):\n 1. has_products I", "moreover"], ["proof (state)\nthis:\n  card I = 1 \\<Longrightarrow> has_products I\n\ngoal (1 subgoal):\n 1. has_products I", "have \"card I \\<noteq> 1 \\<Longrightarrow> has_products I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. card I \\<noteq> 1 \\<Longrightarrow> has_products I", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. card I \\<noteq> 1 \\<Longrightarrow> has_products I", "assume \"card I \\<noteq> 1\""], ["proof (state)\nthis:\n  card I \\<noteq> 1\n\ngoal (1 subgoal):\n 1. card I \\<noteq> 1 \\<Longrightarrow> has_products I", "hence cardI: \"card I > 1\""], ["proof (prove)\nusing this:\n  card I \\<noteq> 1\n\ngoal (1 subgoal):\n 1. 1 < card I", "using I"], ["proof (prove)\nusing this:\n  card I \\<noteq> 1\n  finite I \\<and> card I = Suc n\n\ngoal (1 subgoal):\n 1. 1 < card I", "by simp"], ["proof (state)\nthis:\n  1 < card I\n\ngoal (1 subgoal):\n 1. card I \\<noteq> 1 \\<Longrightarrow> has_products I", "obtain i where i: \"i \\<in> I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>i. i \\<in> I \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "using cardI"], ["proof (prove)\nusing this:\n  1 < card I\n\ngoal (1 subgoal):\n 1. (\\<And>i. i \\<in> I \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by fastforce"], ["proof (state)\nthis:\n  i \\<in> I\n\ngoal (1 subgoal):\n 1. card I \\<noteq> 1 \\<Longrightarrow> has_products I", "let ?I0 = \"{i}\" and ?I1 = \"I - {i}\""], ["proof (state)\ngoal (1 subgoal):\n 1. card I \\<noteq> 1 \\<Longrightarrow> has_products I", "have 1: \"I = ?I0 \\<union> ?I1 \\<and> ?I0 \\<inter> ?I1 = {} \\<and> card ?I0 = 1 \\<and> card ?I1 = n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I = {i} \\<union> (I - {i}) \\<and>\n    {i} \\<inter> (I - {i}) = {} \\<and>\n    card {i} = 1 \\<and> card (I - {i}) = n", "using i I cardI"], ["proof (prove)\nusing this:\n  i \\<in> I\n  finite I \\<and> card I = Suc n\n  1 < card I\n\ngoal (1 subgoal):\n 1. I = {i} \\<union> (I - {i}) \\<and>\n    {i} \\<inter> (I - {i}) = {} \\<and>\n    card {i} = 1 \\<and> card (I - {i}) = n", "by auto"], ["proof (state)\nthis:\n  I = {i} \\<union> (I - {i}) \\<and>\n  {i} \\<inter> (I - {i}) = {} \\<and> card {i} = 1 \\<and> card (I - {i}) = n\n\ngoal (1 subgoal):\n 1. card I \\<noteq> 1 \\<Longrightarrow> has_products I", "show \"has_products I\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_products I", "proof (unfold has_products_def, intro conjI allI impI)"], ["proof (state)\ngoal (2 subgoals):\n 1. I \\<noteq> UNIV\n 2. \\<And>J D.\n       discrete_diagram J (\\<cdot>) D \\<and>\n       Collect (partial_magma.arr J) = I \\<Longrightarrow>\n       \\<exists>a. has_as_product J D a", "show \"I \\<noteq> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. I \\<noteq> UNIV", "using I"], ["proof (prove)\nusing this:\n  finite I \\<and> card I = Suc n\n\ngoal (1 subgoal):\n 1. I \\<noteq> UNIV", "by auto"], ["proof (state)\nthis:\n  I \\<noteq> UNIV\n\ngoal (1 subgoal):\n 1. \\<And>J D.\n       discrete_diagram J (\\<cdot>) D \\<and>\n       Collect (partial_magma.arr J) = I \\<Longrightarrow>\n       \\<exists>a. has_as_product J D a", "fix J D"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>J D.\n       discrete_diagram J (\\<cdot>) D \\<and>\n       Collect (partial_magma.arr J) = I \\<Longrightarrow>\n       \\<exists>a. has_as_product J D a", "assume D: \"discrete_diagram J C D \\<and> Collect (partial_magma.arr J) = I\""], ["proof (state)\nthis:\n  discrete_diagram J (\\<cdot>) D \\<and> Collect (partial_magma.arr J) = I\n\ngoal (1 subgoal):\n 1. \\<And>J D.\n       discrete_diagram J (\\<cdot>) D \\<and>\n       Collect (partial_magma.arr J) = I \\<Longrightarrow>\n       \\<exists>a. has_as_product J D a", "interpret D: discrete_diagram J C D"], ["proof (prove)\ngoal (1 subgoal):\n 1. discrete_diagram J (\\<cdot>) D", "using D"], ["proof (prove)\nusing this:\n  discrete_diagram J (\\<cdot>) D \\<and> Collect (partial_magma.arr J) = I\n\ngoal (1 subgoal):\n 1. discrete_diagram J (\\<cdot>) D", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>J D.\n       discrete_diagram J (\\<cdot>) D \\<and>\n       Collect (partial_magma.arr J) = I \\<Longrightarrow>\n       \\<exists>a. has_as_product J D a", "have Null: \"D.J.null \\<notin> ?I0 \\<and> D.J.null \\<notin> ?I1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D.J.null \\<notin> {i} \\<and> D.J.null \\<notin> I - {i}", "using D D.J.not_arr_null i"], ["proof (prove)\nusing this:\n  discrete_diagram J (\\<cdot>) D \\<and> Collect D.J.arr = I\n  \\<not> D.J.arr D.J.null\n  i \\<in> I\n\ngoal (1 subgoal):\n 1. D.J.null \\<notin> {i} \\<and> D.J.null \\<notin> I - {i}", "by blast"], ["proof (state)\nthis:\n  D.J.null \\<notin> {i} \\<and> D.J.null \\<notin> I - {i}\n\ngoal (1 subgoal):\n 1. \\<And>J D.\n       discrete_diagram J (\\<cdot>) D \\<and>\n       Collect (partial_magma.arr J) = I \\<Longrightarrow>\n       \\<exists>a. has_as_product J D a", "interpret J0: discrete_category ?I0 D.J.null"], ["proof (prove)\ngoal (1 subgoal):\n 1. discrete_category {i} D.J.null", "using 1 Null D"], ["proof (prove)\nusing this:\n  I = {i} \\<union> (I - {i}) \\<and>\n  {i} \\<inter> (I - {i}) = {} \\<and> card {i} = 1 \\<and> card (I - {i}) = n\n  D.J.null \\<notin> {i} \\<and> D.J.null \\<notin> I - {i}\n  discrete_diagram J (\\<cdot>) D \\<and> Collect D.J.arr = I\n\ngoal (1 subgoal):\n 1. discrete_category {i} D.J.null", "by unfold_locales auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>J D.\n       discrete_diagram J (\\<cdot>) D \\<and>\n       Collect (partial_magma.arr J) = I \\<Longrightarrow>\n       \\<exists>a. has_as_product J D a", "interpret J1: discrete_category ?I1 D.J.null"], ["proof (prove)\ngoal (1 subgoal):\n 1. discrete_category (I - {i}) D.J.null", "using Null"], ["proof (prove)\nusing this:\n  D.J.null \\<notin> {i} \\<and> D.J.null \\<notin> I - {i}\n\ngoal (1 subgoal):\n 1. discrete_category (I - {i}) D.J.null", "by unfold_locales auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>J D.\n       discrete_diagram J (\\<cdot>) D \\<and>\n       Collect (partial_magma.arr J) = I \\<Longrightarrow>\n       \\<exists>a. has_as_product J D a", "interpret J0uJ1: discrete_category \\<open>Collect J0.arr \\<union> Collect J1.arr\\<close> J0.null"], ["proof (prove)\ngoal (1 subgoal):\n 1. discrete_category (Collect J0.arr \\<union> Collect J1.arr) J0.null", "using Null 1 J0.null_char J1.null_char"], ["proof (prove)\nusing this:\n  D.J.null \\<notin> {i} \\<and> D.J.null \\<notin> I - {i}\n  I = {i} \\<union> (I - {i}) \\<and>\n  {i} \\<inter> (I - {i}) = {} \\<and> card {i} = 1 \\<and> card (I - {i}) = n\n  J0.null = D.J.null\n  J1.null = D.J.null\n\ngoal (1 subgoal):\n 1. discrete_category (Collect J0.arr \\<union> Collect J1.arr) J0.null", "by unfold_locales auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>J D.\n       discrete_diagram J (\\<cdot>) D \\<and>\n       Collect (partial_magma.arr J) = I \\<Longrightarrow>\n       \\<exists>a. has_as_product J D a", "interpret D0: discrete_diagram_from_map ?I0 C D D.J.null"], ["proof (prove)\ngoal (1 subgoal):\n 1. discrete_diagram_from_map {i} (\\<cdot>) D D.J.null", "using 1 J0.ide_char D.preserves_ide D D.is_discrete i"], ["proof (prove)\nusing this:\n  I = {i} \\<union> (I - {i}) \\<and>\n  {i} \\<inter> (I - {i}) = {} \\<and> card {i} = 1 \\<and> card (I - {i}) = n\n  J0.ide ?f = (?f \\<in> {i})\n  D.J.ide ?a \\<Longrightarrow> ide (D ?a)\n  discrete_diagram J (\\<cdot>) D \\<and> Collect D.J.arr = I\n  D.J.arr = D.J.ide\n  i \\<in> I\n\ngoal (1 subgoal):\n 1. discrete_diagram_from_map {i} (\\<cdot>) D D.J.null", "by unfold_locales auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>J D.\n       discrete_diagram J (\\<cdot>) D \\<and>\n       Collect (partial_magma.arr J) = I \\<Longrightarrow>\n       \\<exists>a. has_as_product J D a", "interpret D1: discrete_diagram_from_map ?I1 C D D.J.null"], ["proof (prove)\ngoal (1 subgoal):\n 1. discrete_diagram_from_map (I - {i}) (\\<cdot>) D D.J.null", "using 1 J1.ide_char D.preserves_ide D D.is_discrete i"], ["proof (prove)\nusing this:\n  I = {i} \\<union> (I - {i}) \\<and>\n  {i} \\<inter> (I - {i}) = {} \\<and> card {i} = 1 \\<and> card (I - {i}) = n\n  J1.ide ?f = (?f \\<in> I - {i})\n  D.J.ide ?a \\<Longrightarrow> ide (D ?a)\n  discrete_diagram J (\\<cdot>) D \\<and> Collect D.J.arr = I\n  D.J.arr = D.J.ide\n  i \\<in> I\n\ngoal (1 subgoal):\n 1. discrete_diagram_from_map (I - {i}) (\\<cdot>) D D.J.null", "by unfold_locales auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>J D.\n       discrete_diagram J (\\<cdot>) D \\<and>\n       Collect (partial_magma.arr J) = I \\<Longrightarrow>\n       \\<exists>a. has_as_product J D a", "obtain a0 where a0: \"has_as_product J0.comp D0.map a0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a0.\n        has_as_product J0.comp D0.map a0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using 1 has_unary_products [of ?I0] has_products_def [of ?I0]\n                        D0.discrete_diagram_axioms"], ["proof (prove)\nusing this:\n  I = {i} \\<union> (I - {i}) \\<and>\n  {i} \\<inter> (I - {i}) = {} \\<and> card {i} = 1 \\<and> card (I - {i}) = n\n  \\<lbrakk>card {i} = 1; {i} \\<noteq> UNIV\\<rbrakk>\n  \\<Longrightarrow> has_products {i}\n  has_products {i} \\<equiv>\n  {i} \\<noteq> UNIV \\<and>\n  (\\<forall>J D.\n      discrete_diagram J (\\<cdot>) D \\<and>\n      Collect (partial_magma.arr J) = {i} \\<longrightarrow>\n      (\\<exists>a. has_as_product J D a))\n  discrete_diagram J0.comp (\\<cdot>) D0.map\n\ngoal (1 subgoal):\n 1. (\\<And>a0.\n        has_as_product J0.comp D0.map a0 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by fastforce"], ["proof (state)\nthis:\n  has_as_product J0.comp D0.map a0\n\ngoal (1 subgoal):\n 1. \\<And>J D.\n       discrete_diagram J (\\<cdot>) D \\<and>\n       Collect (partial_magma.arr J) = I \\<Longrightarrow>\n       \\<exists>a. has_as_product J D a", "obtain a1 where a1: \"has_as_product J1.comp D1.map a1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>a1.\n        has_as_product J1.comp D1.map a1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using 1 I IH [of ?I1] has_products_def [of ?I1] D1.discrete_diagram_axioms"], ["proof (prove)\nusing this:\n  I = {i} \\<union> (I - {i}) \\<and>\n  {i} \\<inter> (I - {i}) = {} \\<and> card {i} = 1 \\<and> card (I - {i}) = n\n  finite I \\<and> card I = Suc n\n  finite (I - {i}) \\<and> card (I - {i}) = n \\<Longrightarrow>\n  has_products (I - {i})\n  has_products (I - {i}) \\<equiv>\n  I - {i} \\<noteq> UNIV \\<and>\n  (\\<forall>J D.\n      discrete_diagram J (\\<cdot>) D \\<and>\n      Collect (partial_magma.arr J) = I - {i} \\<longrightarrow>\n      (\\<exists>a. has_as_product J D a))\n  discrete_diagram J1.comp (\\<cdot>) D1.map\n\ngoal (1 subgoal):\n 1. (\\<And>a1.\n        has_as_product J1.comp D1.map a1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  has_as_product J1.comp D1.map a1\n\ngoal (1 subgoal):\n 1. \\<And>J D.\n       discrete_diagram J (\\<cdot>) D \\<and>\n       Collect (partial_magma.arr J) = I \\<Longrightarrow>\n       \\<exists>a. has_as_product J D a", "have 2: \"\\<exists>p0 p1. has_as_binary_product a0 a1 p0 p1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>p0 p1. has_as_binary_product a0 a1 p0 p1", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>p0 p1. has_as_binary_product a0 a1 p0 p1", "have \"ide a0 \\<and> ide a1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide a0 \\<and> ide a1", "using a0 a1 product_is_ide"], ["proof (prove)\nusing this:\n  has_as_product J0.comp D0.map a0\n  has_as_product J1.comp D1.map a1\n  has_as_product ?J ?D ?a \\<Longrightarrow> ide ?a\n\ngoal (1 subgoal):\n 1. ide a0 \\<and> ide a1", "by auto"], ["proof (state)\nthis:\n  ide a0 \\<and> ide a1\n\ngoal (1 subgoal):\n 1. \\<exists>p0 p1. has_as_binary_product a0 a1 p0 p1", "thus ?thesis"], ["proof (prove)\nusing this:\n  ide a0 \\<and> ide a1\n\ngoal (1 subgoal):\n 1. \\<exists>p0 p1. has_as_binary_product a0 a1 p0 p1", "using a0 a1 has_binary_products has_binary_products_def"], ["proof (prove)\nusing this:\n  ide a0 \\<and> ide a1\n  has_as_product J0.comp D0.map a0\n  has_as_product J1.comp D1.map a1\n  has_binary_products\n  has_binary_products =\n  (\\<forall>a0 a1.\n      ide a0 \\<and> ide a1 \\<longrightarrow>\n      (\\<exists>p0 p1. has_as_binary_product a0 a1 p0 p1))\n\ngoal (1 subgoal):\n 1. \\<exists>p0 p1. has_as_binary_product a0 a1 p0 p1", "by simp"], ["proof (state)\nthis:\n  \\<exists>p0 p1. has_as_binary_product a0 a1 p0 p1\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>p0 p1. has_as_binary_product a0 a1 p0 p1\n\ngoal (1 subgoal):\n 1. \\<And>J D.\n       discrete_diagram J (\\<cdot>) D \\<and>\n       Collect (partial_magma.arr J) = I \\<Longrightarrow>\n       \\<exists>a. has_as_product J D a", "obtain p0 p1 where a: \"has_as_binary_product a0 a1 p0 p1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>p0 p1.\n        has_as_binary_product a0 a1 p0 p1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using 2"], ["proof (prove)\nusing this:\n  \\<exists>p0 p1. has_as_binary_product a0 a1 p0 p1\n\ngoal (1 subgoal):\n 1. (\\<And>p0 p1.\n        has_as_binary_product a0 a1 p0 p1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  has_as_binary_product a0 a1 p0 p1\n\ngoal (1 subgoal):\n 1. \\<And>J D.\n       discrete_diagram J (\\<cdot>) D \\<and>\n       Collect (partial_magma.arr J) = I \\<Longrightarrow>\n       \\<exists>a. has_as_product J D a", "let ?a = \"dom p0\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>J D.\n       discrete_diagram J (\\<cdot>) D \\<and>\n       Collect (partial_magma.arr J) = I \\<Longrightarrow>\n       \\<exists>a. has_as_product J D a", "have \"has_as_product J D ?a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. has_as_product J D (local.dom p0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. has_as_product J D (local.dom p0)", "have \"D = (\\<lambda>j. if j \\<in> Collect J0.arr then D0.map j\n                                 else if j \\<in> Collect J1.arr then D1.map j\n                                 else null)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D =\n    (\\<lambda>j.\n        if j \\<in> Collect J0.arr then D0.map j\n        else if j \\<in> Collect J1.arr then D1.map j else null)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       D j =\n       (if j \\<in> Collect J0.arr then D0.map j\n        else if j \\<in> Collect J1.arr then D1.map j else null)", "fix j"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j.\n       D j =\n       (if j \\<in> Collect J0.arr then D0.map j\n        else if j \\<in> Collect J1.arr then D1.map j else null)", "show \"D j = (if j \\<in> Collect J0.arr then D0.map j\n                                 else if j \\<in> Collect J1.arr then D1.map j\n                                 else null)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. D j =\n    (if j \\<in> Collect J0.arr then D0.map j\n     else if j \\<in> Collect J1.arr then D1.map j else null)", "using 1 D0.map_def D1.map_def D.is_extensional D J0.arr_char J1.arr_char"], ["proof (prove)\nusing this:\n  I = {i} \\<union> (I - {i}) \\<and>\n  {i} \\<inter> (I - {i}) = {} \\<and> card {i} = 1 \\<and> card (I - {i}) = n\n  D0.map ?j \\<equiv> D0.mkCone D ?j\n  D1.map ?j \\<equiv> D1.mkCone D ?j\n  \\<not> D.J.arr ?f \\<Longrightarrow> D ?f = null\n  discrete_diagram J (\\<cdot>) D \\<and> Collect D.J.arr = I\n  J0.arr ?f = (?f \\<in> {i})\n  J1.arr ?f = (?f \\<in> I - {i})\n\ngoal (1 subgoal):\n 1. D j =\n    (if j \\<in> Collect J0.arr then D0.map j\n     else if j \\<in> Collect J1.arr then D1.map j else null)", "by auto"], ["proof (state)\nthis:\n  D j =\n  (if j \\<in> Collect J0.arr then D0.map j\n   else if j \\<in> Collect J1.arr then D1.map j else null)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  D =\n  (\\<lambda>j.\n      if j \\<in> Collect J0.arr then D0.map j\n      else if j \\<in> Collect J1.arr then D1.map j else null)\n\ngoal (1 subgoal):\n 1. has_as_product J D (local.dom p0)", "moreover"], ["proof (state)\nthis:\n  D =\n  (\\<lambda>j.\n      if j \\<in> Collect J0.arr then D0.map j\n      else if j \\<in> Collect J1.arr then D1.map j else null)\n\ngoal (1 subgoal):\n 1. has_as_product J D (local.dom p0)", "have \"J = J0uJ1.comp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. J = J0uJ1.comp", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. J = J0uJ1.comp", "have \"\\<And>j j'. J j j' = J0uJ1.comp j j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>j j'. J j j' = J0uJ1.comp j j'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j j'. J j j' = J0uJ1.comp j j'", "fix j j'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>j j'. J j j' = J0uJ1.comp j j'", "show \"J j j' = J0uJ1.comp j j'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. J j j' = J0uJ1.comp j j'", "using D J0uJ1.arr_char J0.arr_char J1.arr_char D.is_discrete i"], ["proof (prove)\nusing this:\n  discrete_diagram J (\\<cdot>) D \\<and> Collect D.J.arr = I\n  J0uJ1.arr ?f = (?f \\<in> Collect J0.arr \\<union> Collect J1.arr)\n  J0.arr ?f = (?f \\<in> {i})\n  J1.arr ?f = (?f \\<in> I - {i})\n  D.J.arr = D.J.ide\n  i \\<in> I\n\ngoal (1 subgoal):\n 1. J j j' = J0uJ1.comp j j'", "apply (cases \"j \\<in> ?I0\", cases \"j' \\<in> ?I0\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>discrete_diagram J (\\<cdot>) D \\<and> Collect D.J.arr = I;\n     \\<And>f.\n        J0uJ1.arr f = (f \\<in> Collect J0.arr \\<union> Collect J1.arr);\n     \\<And>f. J0.arr f = (f \\<in> {i});\n     \\<And>f. J1.arr f = (f \\<in> I - {i}); D.J.arr = D.J.ide; i \\<in> I;\n     j \\<in> {i}; discrete_diagram J (\\<cdot>) D \\<and> Collect D.J.arr = I;\n     \\<And>f.\n        J0uJ1.arr f = (f \\<in> Collect J0.arr \\<union> Collect J1.arr);\n     \\<And>f. J0.arr f = (f \\<in> {i});\n     \\<And>f. J1.arr f = (f \\<in> I - {i}); D.J.arr = D.J.ide; i \\<in> I;\n     j' \\<in> {i}\\<rbrakk>\n    \\<Longrightarrow> J j j' = J0uJ1.comp j j'\n 2. \\<lbrakk>discrete_diagram J (\\<cdot>) D \\<and> Collect D.J.arr = I;\n     \\<And>f.\n        J0uJ1.arr f = (f \\<in> Collect J0.arr \\<union> Collect J1.arr);\n     \\<And>f. J0.arr f = (f \\<in> {i});\n     \\<And>f. J1.arr f = (f \\<in> I - {i}); D.J.arr = D.J.ide; i \\<in> I;\n     j \\<in> {i}; discrete_diagram J (\\<cdot>) D \\<and> Collect D.J.arr = I;\n     \\<And>f.\n        J0uJ1.arr f = (f \\<in> Collect J0.arr \\<union> Collect J1.arr);\n     \\<And>f. J0.arr f = (f \\<in> {i});\n     \\<And>f. J1.arr f = (f \\<in> I - {i}); D.J.arr = D.J.ide; i \\<in> I;\n     j' \\<notin> {i}\\<rbrakk>\n    \\<Longrightarrow> J j j' = J0uJ1.comp j j'\n 3. \\<lbrakk>discrete_diagram J (\\<cdot>) D \\<and> Collect D.J.arr = I;\n     \\<And>f.\n        J0uJ1.arr f = (f \\<in> Collect J0.arr \\<union> Collect J1.arr);\n     \\<And>f. J0.arr f = (f \\<in> {i});\n     \\<And>f. J1.arr f = (f \\<in> I - {i}); D.J.arr = D.J.ide; i \\<in> I;\n     j \\<notin> {i}\\<rbrakk>\n    \\<Longrightarrow> J j j' = J0uJ1.comp j j'", "apply simp_all"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>Collect D.J.ide = I; j = i; discrete_diagram J (\\<cdot>) D;\n     D.J.arr = D.J.ide; i \\<in> I; j' = i\\<rbrakk>\n    \\<Longrightarrow> J i i = i\n 2. \\<lbrakk>Collect D.J.ide = I; j = i; discrete_diagram J (\\<cdot>) D;\n     D.J.arr = D.J.ide; i \\<in> I; j' \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> J i j' = J0uJ1.null\n 3. \\<lbrakk>discrete_diagram J (\\<cdot>) D \\<and> Collect D.J.ide = I;\n     D.J.arr = D.J.ide; i \\<in> I; j \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> ((j' = i \\<or> j' \\<in> I \\<and> j' \\<noteq> i) \\<and>\n                       j' = j \\<longrightarrow>\n                       J j j = j) \\<and>\n                      (j' \\<noteq> i \\<and>\n                       (j' \\<in> I \\<longrightarrow>\n                        j' = i) \\<longrightarrow>\n                       J j j' = J0uJ1.null) \\<and>\n                      (j' \\<noteq> j \\<longrightarrow> J j j' = J0uJ1.null)", "apply auto[1]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>Collect D.J.ide = I; j = i; discrete_diagram J (\\<cdot>) D;\n     D.J.arr = D.J.ide; i \\<in> I; j' \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> J i j' = J0uJ1.null\n 2. \\<lbrakk>discrete_diagram J (\\<cdot>) D \\<and> Collect D.J.ide = I;\n     D.J.arr = D.J.ide; i \\<in> I; j \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> ((j' = i \\<or> j' \\<in> I \\<and> j' \\<noteq> i) \\<and>\n                       j' = j \\<longrightarrow>\n                       J j j = j) \\<and>\n                      (j' \\<noteq> i \\<and>\n                       (j' \\<in> I \\<longrightarrow>\n                        j' = i) \\<longrightarrow>\n                       J j j' = J0uJ1.null) \\<and>\n                      (j' \\<noteq> j \\<longrightarrow> J j j' = J0uJ1.null)", "apply (metis D.J.comp_arr_ide D.J.comp_ide_arr D.J.ext D.J.seqE\n                            D.is_discrete J0.null_char J0uJ1.null_char)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>discrete_diagram J (\\<cdot>) D \\<and> Collect D.J.ide = I;\n     D.J.arr = D.J.ide; i \\<in> I; j \\<noteq> i\\<rbrakk>\n    \\<Longrightarrow> ((j' = i \\<or> j' \\<in> I \\<and> j' \\<noteq> i) \\<and>\n                       j' = j \\<longrightarrow>\n                       J j j = j) \\<and>\n                      (j' \\<noteq> i \\<and>\n                       (j' \\<in> I \\<longrightarrow>\n                        j' = i) \\<longrightarrow>\n                       J j j' = J0uJ1.null) \\<and>\n                      (j' \\<noteq> j \\<longrightarrow> J j j' = J0uJ1.null)", "by (metis D.J.comp_arr_ide D.J.comp_ide_arr D.J.comp_ide_self\n                            D.J.ext D.J.seqE D.is_discrete J0.null_char J0uJ1.null_char\n                            mem_Collect_eq)"], ["proof (state)\nthis:\n  J j j' = J0uJ1.comp j j'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  J ?j4 ?j'4 = J0uJ1.comp ?j4 ?j'4\n\ngoal (1 subgoal):\n 1. J = J0uJ1.comp", "thus ?thesis"], ["proof (prove)\nusing this:\n  J ?j4 ?j'4 = J0uJ1.comp ?j4 ?j'4\n\ngoal (1 subgoal):\n 1. J = J0uJ1.comp", "by blast"], ["proof (state)\nthis:\n  J = J0uJ1.comp\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  J = J0uJ1.comp\n\ngoal (1 subgoal):\n 1. has_as_product J D (local.dom p0)", "moreover"], ["proof (state)\nthis:\n  J = J0uJ1.comp\n\ngoal (1 subgoal):\n 1. has_as_product J D (local.dom p0)", "have \"Collect J0.arr \\<inter> Collect J1.arr = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Collect J0.arr \\<inter> Collect J1.arr = {}", "by auto"], ["proof (state)\nthis:\n  Collect J0.arr \\<inter> Collect J1.arr = {}\n\ngoal (1 subgoal):\n 1. has_as_product J D (local.dom p0)", "moreover"], ["proof (state)\nthis:\n  Collect J0.arr \\<inter> Collect J1.arr = {}\n\ngoal (1 subgoal):\n 1. has_as_product J D (local.dom p0)", "have \"J0.null = J1.null\""], ["proof (prove)\ngoal (1 subgoal):\n 1. J0.null = J1.null", "using J0.null_char J1.null_char"], ["proof (prove)\nusing this:\n  J0.null = D.J.null\n  J1.null = D.J.null\n\ngoal (1 subgoal):\n 1. J0.null = J1.null", "by simp"], ["proof (state)\nthis:\n  J0.null = J1.null\n\ngoal (1 subgoal):\n 1. has_as_product J D (local.dom p0)", "ultimately"], ["proof (chain)\npicking this:\n  D =\n  (\\<lambda>j.\n      if j \\<in> Collect J0.arr then D0.map j\n      else if j \\<in> Collect J1.arr then D1.map j else null)\n  J = J0uJ1.comp\n  Collect J0.arr \\<inter> Collect J1.arr = {}\n  J0.null = J1.null", "show \"has_as_product J D ?a\""], ["proof (prove)\nusing this:\n  D =\n  (\\<lambda>j.\n      if j \\<in> Collect J0.arr then D0.map j\n      else if j \\<in> Collect J1.arr then D1.map j else null)\n  J = J0uJ1.comp\n  Collect J0.arr \\<inter> Collect J1.arr = {}\n  J0.null = J1.null\n\ngoal (1 subgoal):\n 1. has_as_product J D (local.dom p0)", "using binary_product_of_products_is_product\n                            [of J0.comp D0.map a0 J1.comp D1.map a1 p0 p1]\n                          J0.arr_char J1.arr_char\n                          1 a0 a1 a"], ["proof (prove)\nusing this:\n  D =\n  (\\<lambda>j.\n      if j \\<in> Collect J0.arr then D0.map j\n      else if j \\<in> Collect J1.arr then D1.map j else null)\n  J = J0uJ1.comp\n  Collect J0.arr \\<inter> Collect J1.arr = {}\n  J0.null = J1.null\n  \\<lbrakk>has_as_product J0.comp D0.map a0;\n   has_as_product J1.comp D1.map a1; has_as_binary_product a0 a1 p0 p1;\n   Collect J0.arr \\<inter> Collect J1.arr = {}; J0.null = J1.null\\<rbrakk>\n  \\<Longrightarrow> has_as_product J0uJ1.comp\n                     (\\<lambda>i.\n                         if i \\<in> Collect J0.arr then D0.map i\n                         else if i \\<in> Collect J1.arr then D1.map i\n                              else null)\n                     (local.dom p0)\n  J0.arr ?f = (?f \\<in> {i})\n  J1.arr ?f = (?f \\<in> I - {i})\n  I = {i} \\<union> (I - {i}) \\<and>\n  {i} \\<inter> (I - {i}) = {} \\<and> card {i} = 1 \\<and> card (I - {i}) = n\n  has_as_product J0.comp D0.map a0\n  has_as_product J1.comp D1.map a1\n  has_as_binary_product a0 a1 p0 p1\n\ngoal (1 subgoal):\n 1. has_as_product J D (local.dom p0)", "by simp"], ["proof (state)\nthis:\n  has_as_product J D (local.dom p0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  has_as_product J D (local.dom p0)\n\ngoal (1 subgoal):\n 1. \\<And>J D.\n       discrete_diagram J (\\<cdot>) D \\<and>\n       Collect (partial_magma.arr J) = I \\<Longrightarrow>\n       \\<exists>a. has_as_product J D a", "thus \"\\<exists>a. has_as_product J D a\""], ["proof (prove)\nusing this:\n  has_as_product J D (local.dom p0)\n\ngoal (1 subgoal):\n 1. \\<exists>a. has_as_product J D a", "by blast"], ["proof (state)\nthis:\n  \\<exists>a. has_as_product J D a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  has_products I\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  card I \\<noteq> 1 \\<Longrightarrow> has_products I\n\ngoal (1 subgoal):\n 1. has_products I", "ultimately"], ["proof (chain)\npicking this:\n  card I = 1 \\<Longrightarrow> has_products I\n  card I \\<noteq> 1 \\<Longrightarrow> has_products I", "show \"has_products I\""], ["proof (prove)\nusing this:\n  card I = 1 \\<Longrightarrow> has_products I\n  card I \\<noteq> 1 \\<Longrightarrow> has_products I\n\ngoal (1 subgoal):\n 1. has_products I", "by blast"], ["proof (state)\nthis:\n  has_products I\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  has_products I\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>\\<And>I.\n              finite I \\<and> card I = ?n4 \\<Longrightarrow> has_products I;\n   finite ?I4 \\<and> card ?I4 = Suc ?n4\\<rbrakk>\n  \\<Longrightarrow> has_products ?I4\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  finite ?I4 \\<and> card ?I4 = n \\<Longrightarrow> has_products ?I4\n\ngoal (1 subgoal):\n 1. \\<And>I. finite I \\<Longrightarrow> has_products I", "}"], ["proof (state)\nthis:\n  finite ?I4 \\<and> card ?I4 = ?n7 \\<Longrightarrow> has_products ?I4\n\ngoal (1 subgoal):\n 1. \\<And>I. finite I \\<Longrightarrow> has_products I", "hence 1: \"\\<And>n I :: nat set. finite I \\<and> card I = n \\<Longrightarrow> has_products I\""], ["proof (prove)\nusing this:\n  finite ?I4 \\<and> card ?I4 = ?n7 \\<Longrightarrow> has_products ?I4\n\ngoal (1 subgoal):\n 1. \\<And>n I. finite I \\<and> card I = n \\<Longrightarrow> has_products I", "by simp"], ["proof (state)\nthis:\n  finite ?I4 \\<and> card ?I4 = ?n4 \\<Longrightarrow> has_products ?I4\n\ngoal (1 subgoal):\n 1. \\<And>I. finite I \\<Longrightarrow> has_products I", "thus \"\\<And>I :: nat set. finite I \\<Longrightarrow> has_products I\""], ["proof (prove)\nusing this:\n  finite ?I4 \\<and> card ?I4 = ?n4 \\<Longrightarrow> has_products ?I4\n\ngoal (1 subgoal):\n 1. \\<And>I. finite I \\<Longrightarrow> has_products I", "by blast"], ["proof (state)\nthis:\n  finite ?I4 \\<Longrightarrow> has_products ?I4\n\ngoal:\nNo subgoals!", "qed"], ["", "proposition (in cartesian_category) is_category_with_finite_products:\n  shows \"category_with_finite_products C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. category_with_finite_products (\\<cdot>)", ".."], ["", "end"]]}