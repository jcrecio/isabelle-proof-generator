{"file_name": "/home/qj213/afp-2021-10-22/thys/Category3/SetCat.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Category3", "problem_names": ["lemma finite_imp_card_less:\n    assumes \"finite A\"\n    shows \"|A| <o \\<AA>\"", "lemma MkArr_expansion:\n    assumes \"arr f\"\n    shows \"f = MkArr (Dom f) (Cod f) (\\<lambda>x \\<in> Dom f. Map f x)\"", "lemma arr_char:\n    shows \"arr f \\<longleftrightarrow> f \\<noteq> Null \\<and> |Dom f| <o \\<AA> \\<and> |Cod f| <o \\<AA> \\<and>\n                     Map f \\<in> extensional (Dom f) \\<inter> (Dom f \\<rightarrow> Cod f)\"", "lemma terminal_char:\n    shows \"terminal a \\<longleftrightarrow> (\\<exists>x. a = MkIde {x})\"", "lemma terminal_unity:\n    shows \"terminal unity\"", "lemma UP_mapsto:\n    shows \"UP \\<in> UNIV \\<rightarrow> Univ\"", "lemma DOWN_mapsto:\n    shows \"DOWN \\<in> Univ \\<rightarrow> UNIV\"", "lemma DOWN_UP [simp]:\n    shows \"DOWN (UP x) = x\"", "lemma UP_DOWN [simp]:\n    assumes \"t \\<in> Univ\"\n    shows \"UP (DOWN t) = t\"", "lemma inj_UP:\n    shows \"inj UP\"", "lemma bij_UP:\n    shows \"bij_betw UP UNIV Univ\"", "lemma Dom_terminal:\n    assumes \"terminal t\"\n    shows \"Dom t = {DOWN t}\"", "lemma IMG_point:\n    assumes \"\\<guillemotleft>p : unity \\<rightarrow> a\\<guillemotright>\"\n    shows \"IMG \\<in> hom unity a \\<rightarrow> Univ\"\n    and \"IMG p = (UP o Map p o DOWN) unity\"", "lemma MkElem_in_hom:\n    assumes \"arr f\" and \"x \\<in> Dom f\"\n    shows \"\\<guillemotleft>MkElem (UP x) (dom f) : unity \\<rightarrow> dom f\\<guillemotright>\"", "lemma MkElem_IMG:\n    assumes \"p \\<in> hom unity a\"\n    shows \"MkElem (IMG p) a = p\"", "lemma inj_IMG:\n    assumes \"ide a\"\n    shows \"inj_on IMG (hom unity a)\"", "lemma set_char:\n    assumes \"ide a\"\n    shows \"set a = UP ` Dom a\"", "lemma Map_via_comp:\n    assumes \"arr f\"\n    shows \"Map f = (\\<lambda>x \\<in> Dom f. Map (f \\<cdot> MkElem (UP x) (dom f)) U)\"", "lemma arr_eqI':\n    assumes \"par f f'\" and \"\\<And>t. \\<guillemotleft>t : unity \\<rightarrow> dom f\\<guillemotright> \\<Longrightarrow> f \\<cdot> t = f' \\<cdot> t\"\n    shows \"f = f'\"", "lemma card_points_less:\n    assumes \"ide a\"\n    shows \"|hom unity a| <o \\<AA>\"", "theorem is_set_category:\n    shows \"set_category comp \\<AA>\"", "lemma UP_mapsto:\n    shows \"UP \\<in> UNIV \\<rightarrow> Univ\"", "lemma DOWN_mapsto:\n    shows \"DOWN \\<in> Univ \\<rightarrow> UNIV\"", "lemma DOWN_UP [simp]:\n    shows \"DOWN (UP x) = x\"", "lemma UP_DOWN [simp]:\n    assumes \"t \\<in> Univ\"\n    shows \"UP (DOWN t) = t\"", "lemma inj_UP:\n    shows \"inj UP\"", "lemma bij_UP:\n    shows \"bij_betw UP UNIV Univ\""], "translations": [["", "lemma finite_imp_card_less:\n    assumes \"finite A\"\n    shows \"|A| <o \\<AA>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |A| <o \\<AA>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. |A| <o \\<AA>", "have \"finite (Field |A| )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Field |A|)", "using assms"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. finite (Field |A|)", "by simp"], ["proof (state)\nthis:\n  finite (Field |A|)\n\ngoal (1 subgoal):\n 1. |A| <o \\<AA>", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite (Field |A|)\n\ngoal (1 subgoal):\n 1. |A| <o \\<AA>", "using cardinal card_of_Well_order card_order_on_def finite_ordLess_infinite"], ["proof (prove)\nusing this:\n  finite (Field |A|)\n  Card_order \\<AA> \\<and> infinite (Field \\<AA>)\n  Well_order |?A|\n  card_order_on ?A ?r \\<equiv>\n  well_order_on ?A ?r \\<and>\n  (\\<forall>r'. well_order_on ?A r' \\<longrightarrow> ?r \\<le>o r')\n  \\<lbrakk>Well_order ?r; Well_order ?r'; finite (Field ?r);\n   infinite (Field ?r')\\<rbrakk>\n  \\<Longrightarrow> ?r <o ?r'\n\ngoal (1 subgoal):\n 1. |A| <o \\<AA>", "by blast"], ["proof (state)\nthis:\n  |A| <o \\<AA>\n\ngoal:\nNo subgoals!", "qed"], ["", "type_synonym 'b arr = \"('b set, 'b \\<Rightarrow> 'b) concrete_category.arr\""], ["", "interpretation concrete_category \\<open>{A :: 'e set. |A| <o \\<AA>}\\<close> \\<open>\\<lambda>A B. extensional A \\<inter> (A \\<rightarrow> B)\\<close>\n                     \\<open>\\<lambda>A. \\<lambda>x \\<in> A. x\\<close> \\<open>\\<lambda>C B A g f. compose A g f\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. concrete_category {A. |A| <o \\<AA>}\n     (\\<lambda>A B. extensional A \\<inter> (A \\<rightarrow> B))\n     (restrict (\\<lambda>x. x)) (\\<lambda>C B. compose)", "using compose_Id Id_compose"], ["proof (prove)\nusing this:\n  \\<lbrakk>?g \\<in> ?A \\<rightarrow> ?B; ?g \\<in> extensional ?A\\<rbrakk>\n  \\<Longrightarrow> compose ?A ?g (\\<lambda>x\\<in>?A. x) = ?g\n  \\<lbrakk>?f \\<in> ?A \\<rightarrow> ?B; ?f \\<in> extensional ?A\\<rbrakk>\n  \\<Longrightarrow> compose ?A (\\<lambda>y\\<in>?B. y) ?f = ?f\n\ngoal (1 subgoal):\n 1. concrete_category {A. |A| <o \\<AA>}\n     (\\<lambda>A B. extensional A \\<inter> (A \\<rightarrow> B))\n     (restrict (\\<lambda>x. x)) (\\<lambda>C B. compose)", "apply unfold_locales"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>A.\n       \\<lbrakk>\\<And>g A B.\n                   \\<lbrakk>g \\<in> A \\<rightarrow> B;\n                    g \\<in> extensional A\\<rbrakk>\n                   \\<Longrightarrow> compose A g (\\<lambda>x\\<in>A. x) = g;\n        \\<And>f A B.\n           \\<lbrakk>f \\<in> A \\<rightarrow> B;\n            f \\<in> extensional A\\<rbrakk>\n           \\<Longrightarrow> compose A (\\<lambda>y\\<in>B. y) f = f;\n        A \\<in> {A. |A| <o \\<AA>}\\<rbrakk>\n       \\<Longrightarrow> (\\<lambda>x\\<in>A. x)\n                         \\<in> extensional A \\<inter> (A \\<rightarrow> A)\n 2. \\<And>A B C f g.\n       \\<lbrakk>\\<And>g A B.\n                   \\<lbrakk>g \\<in> A \\<rightarrow> B;\n                    g \\<in> extensional A\\<rbrakk>\n                   \\<Longrightarrow> compose A g (\\<lambda>x\\<in>A. x) = g;\n        \\<And>f A B.\n           \\<lbrakk>f \\<in> A \\<rightarrow> B;\n            f \\<in> extensional A\\<rbrakk>\n           \\<Longrightarrow> compose A (\\<lambda>y\\<in>B. y) f = f;\n        A \\<in> {A. |A| <o \\<AA>}; B \\<in> {A. |A| <o \\<AA>};\n        C \\<in> {A. |A| <o \\<AA>};\n        f \\<in> extensional A \\<inter> (A \\<rightarrow> B);\n        g \\<in> extensional B \\<inter> (B \\<rightarrow> C)\\<rbrakk>\n       \\<Longrightarrow> compose A g f\n                         \\<in> extensional A \\<inter> (A \\<rightarrow> C)\n 3. \\<And>A f B.\n       \\<lbrakk>\\<And>g A B.\n                   \\<lbrakk>g \\<in> A \\<rightarrow> B;\n                    g \\<in> extensional A\\<rbrakk>\n                   \\<Longrightarrow> compose A g (\\<lambda>x\\<in>A. x) = g;\n        \\<And>f A B.\n           \\<lbrakk>f \\<in> A \\<rightarrow> B;\n            f \\<in> extensional A\\<rbrakk>\n           \\<Longrightarrow> compose A (\\<lambda>y\\<in>B. y) f = f;\n        A \\<in> {A. |A| <o \\<AA>};\n        f \\<in> extensional A \\<inter> (A \\<rightarrow> B)\\<rbrakk>\n       \\<Longrightarrow> compose A f (\\<lambda>x\\<in>A. x) = f\n 4. \\<And>B f A.\n       \\<lbrakk>\\<And>g A B.\n                   \\<lbrakk>g \\<in> A \\<rightarrow> B;\n                    g \\<in> extensional A\\<rbrakk>\n                   \\<Longrightarrow> compose A g (\\<lambda>x\\<in>A. x) = g;\n        \\<And>f A B.\n           \\<lbrakk>f \\<in> A \\<rightarrow> B;\n            f \\<in> extensional A\\<rbrakk>\n           \\<Longrightarrow> compose A (\\<lambda>y\\<in>B. y) f = f;\n        B \\<in> {A. |A| <o \\<AA>};\n        f \\<in> extensional A \\<inter> (A \\<rightarrow> B)\\<rbrakk>\n       \\<Longrightarrow> compose A (\\<lambda>x\\<in>B. x) f = f\n 5. \\<And>A B C D f g h.\n       \\<lbrakk>\\<And>g A B.\n                   \\<lbrakk>g \\<in> A \\<rightarrow> B;\n                    g \\<in> extensional A\\<rbrakk>\n                   \\<Longrightarrow> compose A g (\\<lambda>x\\<in>A. x) = g;\n        \\<And>f A B.\n           \\<lbrakk>f \\<in> A \\<rightarrow> B;\n            f \\<in> extensional A\\<rbrakk>\n           \\<Longrightarrow> compose A (\\<lambda>y\\<in>B. y) f = f;\n        A \\<in> {A. |A| <o \\<AA>}; B \\<in> {A. |A| <o \\<AA>};\n        C \\<in> {A. |A| <o \\<AA>}; D \\<in> {A. |A| <o \\<AA>};\n        f \\<in> extensional A \\<inter> (A \\<rightarrow> B);\n        g \\<in> extensional B \\<inter> (B \\<rightarrow> C);\n        h \\<in> extensional C \\<inter> (C \\<rightarrow> D)\\<rbrakk>\n       \\<Longrightarrow> compose A h (compose A g f) =\n                         compose A (compose B h g) f", "apply auto[3]"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>B f A.\n       \\<lbrakk>\\<And>g A B.\n                   \\<lbrakk>g \\<in> A \\<rightarrow> B;\n                    g \\<in> extensional A\\<rbrakk>\n                   \\<Longrightarrow> compose A g (\\<lambda>x\\<in>A. x) = g;\n        \\<And>f A B.\n           \\<lbrakk>f \\<in> A \\<rightarrow> B;\n            f \\<in> extensional A\\<rbrakk>\n           \\<Longrightarrow> compose A (\\<lambda>y\\<in>B. y) f = f;\n        B \\<in> {A. |A| <o \\<AA>};\n        f \\<in> extensional A \\<inter> (A \\<rightarrow> B)\\<rbrakk>\n       \\<Longrightarrow> compose A (\\<lambda>x\\<in>B. x) f = f\n 2. \\<And>A B C D f g h.\n       \\<lbrakk>\\<And>g A B.\n                   \\<lbrakk>g \\<in> A \\<rightarrow> B;\n                    g \\<in> extensional A\\<rbrakk>\n                   \\<Longrightarrow> compose A g (\\<lambda>x\\<in>A. x) = g;\n        \\<And>f A B.\n           \\<lbrakk>f \\<in> A \\<rightarrow> B;\n            f \\<in> extensional A\\<rbrakk>\n           \\<Longrightarrow> compose A (\\<lambda>y\\<in>B. y) f = f;\n        A \\<in> {A. |A| <o \\<AA>}; B \\<in> {A. |A| <o \\<AA>};\n        C \\<in> {A. |A| <o \\<AA>}; D \\<in> {A. |A| <o \\<AA>};\n        f \\<in> extensional A \\<inter> (A \\<rightarrow> B);\n        g \\<in> extensional B \\<inter> (B \\<rightarrow> C);\n        h \\<in> extensional C \\<inter> (C \\<rightarrow> D)\\<rbrakk>\n       \\<Longrightarrow> compose A h (compose A g f) =\n                         compose A (compose B h g) f", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>A B C D f g h.\n       \\<lbrakk>\\<And>g A B.\n                   \\<lbrakk>g \\<in> A \\<rightarrow> B;\n                    g \\<in> extensional A\\<rbrakk>\n                   \\<Longrightarrow> compose A g (\\<lambda>x\\<in>A. x) = g;\n        \\<And>f A B.\n           \\<lbrakk>f \\<in> A \\<rightarrow> B;\n            f \\<in> extensional A\\<rbrakk>\n           \\<Longrightarrow> compose A (\\<lambda>y\\<in>B. y) f = f;\n        A \\<in> {A. |A| <o \\<AA>}; B \\<in> {A. |A| <o \\<AA>};\n        C \\<in> {A. |A| <o \\<AA>}; D \\<in> {A. |A| <o \\<AA>};\n        f \\<in> extensional A \\<inter> (A \\<rightarrow> B);\n        g \\<in> extensional B \\<inter> (B \\<rightarrow> C);\n        h \\<in> extensional C \\<inter> (C \\<rightarrow> D)\\<rbrakk>\n       \\<Longrightarrow> compose A h (compose A g f) =\n                         compose A (compose B h g) f", "by (metis IntD2 compose_assoc)"], ["", "abbreviation comp :: \"'e setcat.arr comp\"     (infixr \"\\<cdot>\" 55)\n    where \"comp \\<equiv> COMP\""], ["", "notation in_hom                               (\"\\<guillemotleft>_ : _ \\<rightarrow> _\\<guillemotright>\")"], ["", "lemma MkArr_expansion:\n    assumes \"arr f\"\n    shows \"f = MkArr (Dom f) (Cod f) (\\<lambda>x \\<in> Dom f. Map f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = MkArr (Dom f) (Cod f) (restrict (Map f) (Dom f))", "proof (intro arr_eqI)"], ["proof (state)\ngoal (5 subgoals):\n 1. arr f\n 2. arr (MkArr (Dom f) (Cod f) (restrict (Map f) (Dom f)))\n 3. Dom f = Dom (MkArr (Dom f) (Cod f) (restrict (Map f) (Dom f)))\n 4. Cod f = Cod (MkArr (Dom f) (Cod f) (restrict (Map f) (Dom f)))\n 5. Map f = Map (MkArr (Dom f) (Cod f) (restrict (Map f) (Dom f)))", "show \"arr f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr f", "by fact"], ["proof (state)\nthis:\n  arr f\n\ngoal (4 subgoals):\n 1. arr (MkArr (Dom f) (Cod f) (restrict (Map f) (Dom f)))\n 2. Dom f = Dom (MkArr (Dom f) (Cod f) (restrict (Map f) (Dom f)))\n 3. Cod f = Cod (MkArr (Dom f) (Cod f) (restrict (Map f) (Dom f)))\n 4. Map f = Map (MkArr (Dom f) (Cod f) (restrict (Map f) (Dom f)))", "show \"arr (MkArr (Dom f) (Cod f) (\\<lambda>x \\<in> Dom f. Map f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (MkArr (Dom f) (Cod f) (restrict (Map f) (Dom f)))", "using assms arr_char"], ["proof (prove)\nusing this:\n  arr f\n  arr ?f =\n  (?f \\<noteq> Null \\<and>\n   Dom ?f \\<in> {A. |A| <o \\<AA>} \\<and>\n   Cod ?f \\<in> {A. |A| <o \\<AA>} \\<and>\n   Map ?f \\<in> extensional (Dom ?f) \\<inter> (Dom ?f \\<rightarrow> Cod ?f))\n\ngoal (1 subgoal):\n 1. arr (MkArr (Dom f) (Cod f) (restrict (Map f) (Dom f)))", "by (metis (mono_tags, lifting) Int_iff MkArr_Map extensional_restrict)"], ["proof (state)\nthis:\n  arr (MkArr (Dom f) (Cod f) (restrict (Map f) (Dom f)))\n\ngoal (3 subgoals):\n 1. Dom f = Dom (MkArr (Dom f) (Cod f) (restrict (Map f) (Dom f)))\n 2. Cod f = Cod (MkArr (Dom f) (Cod f) (restrict (Map f) (Dom f)))\n 3. Map f = Map (MkArr (Dom f) (Cod f) (restrict (Map f) (Dom f)))", "show \"Dom f = Dom (MkArr (Dom f) (Cod f) (\\<lambda>x \\<in> Dom f. Map f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dom f = Dom (MkArr (Dom f) (Cod f) (restrict (Map f) (Dom f)))", "by simp"], ["proof (state)\nthis:\n  Dom f = Dom (MkArr (Dom f) (Cod f) (restrict (Map f) (Dom f)))\n\ngoal (2 subgoals):\n 1. Cod f = Cod (MkArr (Dom f) (Cod f) (restrict (Map f) (Dom f)))\n 2. Map f = Map (MkArr (Dom f) (Cod f) (restrict (Map f) (Dom f)))", "show \"Cod f = Cod (MkArr (Dom f) (Cod f) (\\<lambda>x \\<in> Dom f. Map f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cod f = Cod (MkArr (Dom f) (Cod f) (restrict (Map f) (Dom f)))", "by simp"], ["proof (state)\nthis:\n  Cod f = Cod (MkArr (Dom f) (Cod f) (restrict (Map f) (Dom f)))\n\ngoal (1 subgoal):\n 1. Map f = Map (MkArr (Dom f) (Cod f) (restrict (Map f) (Dom f)))", "show \"Map f = Map (MkArr (Dom f) (Cod f) (\\<lambda>x \\<in> Dom f. Map f x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Map f = Map (MkArr (Dom f) (Cod f) (restrict (Map f) (Dom f)))", "using assms arr_char"], ["proof (prove)\nusing this:\n  arr f\n  arr ?f =\n  (?f \\<noteq> Null \\<and>\n   Dom ?f \\<in> {A. |A| <o \\<AA>} \\<and>\n   Cod ?f \\<in> {A. |A| <o \\<AA>} \\<and>\n   Map ?f \\<in> extensional (Dom ?f) \\<inter> (Dom ?f \\<rightarrow> Cod ?f))\n\ngoal (1 subgoal):\n 1. Map f = Map (MkArr (Dom f) (Cod f) (restrict (Map f) (Dom f)))", "by (metis (mono_tags, lifting) Int_iff MkArr_Map extensional_restrict)"], ["proof (state)\nthis:\n  Map f = Map (MkArr (Dom f) (Cod f) (restrict (Map f) (Dom f)))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma arr_char:\n    shows \"arr f \\<longleftrightarrow> f \\<noteq> Null \\<and> |Dom f| <o \\<AA> \\<and> |Cod f| <o \\<AA> \\<and>\n                     Map f \\<in> extensional (Dom f) \\<inter> (Dom f \\<rightarrow> Cod f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr f =\n    (f \\<noteq> Null \\<and>\n     |Dom f| <o \\<AA> \\<and>\n     |Cod f| <o \\<AA> \\<and>\n     Map f \\<in> extensional (Dom f) \\<inter> (Dom f \\<rightarrow> Cod f))", "using arr_char"], ["proof (prove)\nusing this:\n  arr ?f =\n  (?f \\<noteq> Null \\<and>\n   Dom ?f \\<in> {A. |A| <o \\<AA>} \\<and>\n   Cod ?f \\<in> {A. |A| <o \\<AA>} \\<and>\n   Map ?f \\<in> extensional (Dom ?f) \\<inter> (Dom ?f \\<rightarrow> Cod ?f))\n\ngoal (1 subgoal):\n 1. arr f =\n    (f \\<noteq> Null \\<and>\n     |Dom f| <o \\<AA> \\<and>\n     |Cod f| <o \\<AA> \\<and>\n     Map f \\<in> extensional (Dom f) \\<inter> (Dom f \\<rightarrow> Cod f))", "by auto"], ["", "lemma terminal_char:\n    shows \"terminal a \\<longleftrightarrow> (\\<exists>x. a = MkIde {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminal a = (\\<exists>x. a = MkIde {x})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. terminal a \\<Longrightarrow> \\<exists>x. a = MkIde {x}\n 2. \\<exists>x. a = MkIde {x} \\<Longrightarrow> terminal a", "show \"\\<exists>x. a = MkIde {x} \\<Longrightarrow> terminal a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. a = MkIde {x} \\<Longrightarrow> terminal a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x. a = MkIde {x} \\<Longrightarrow> terminal a", "assume a: \"\\<exists>x. a = MkIde {x}\""], ["proof (state)\nthis:\n  \\<exists>x. a = MkIde {x}\n\ngoal (1 subgoal):\n 1. \\<exists>x. a = MkIde {x} \\<Longrightarrow> terminal a", "from this"], ["proof (chain)\npicking this:\n  \\<exists>x. a = MkIde {x}", "obtain x where x: \"a = MkIde {x}\""], ["proof (prove)\nusing this:\n  \\<exists>x. a = MkIde {x}\n\ngoal (1 subgoal):\n 1. (\\<And>x. a = MkIde {x} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  a = MkIde {x}\n\ngoal (1 subgoal):\n 1. \\<exists>x. a = MkIde {x} \\<Longrightarrow> terminal a", "have \"terminal (MkIde {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminal (MkIde {x})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ide (MkIde {x})\n 2. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<exists>!f.\n          \\<guillemotleft>f : a \\<rightarrow> MkIde {x}\\<guillemotright>", "show 1: \"ide (MkIde {x})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide (MkIde {x})", "using finite_imp_card_less ide_MkIde"], ["proof (prove)\nusing this:\n  finite ?A \\<Longrightarrow> |?A| <o \\<AA>\n  ?A \\<in> {A. |A| <o \\<AA>} \\<Longrightarrow> ide (MkIde ?A)\n\ngoal (1 subgoal):\n 1. ide (MkIde {x})", "by auto"], ["proof (state)\nthis:\n  ide (MkIde {x})\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<exists>!f.\n          \\<guillemotleft>f : a \\<rightarrow> MkIde {x}\\<guillemotright>", "show \"\\<And>a. ide a \\<Longrightarrow> \\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> MkIde {x}\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<exists>!f.\n          \\<guillemotleft>f : a \\<rightarrow> MkIde {x}\\<guillemotright>", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<guillemotleft>?a a : a \\<rightarrow> MkIde {x}\\<guillemotright>\n 2. \\<And>a f.\n       \\<lbrakk>ide a;\n        \\<guillemotleft>f : a \\<rightarrow> MkIde\n       {x}\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> f = ?a a", "fix a :: \"'e setcat.arr\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<guillemotleft>?a a : a \\<rightarrow> MkIde {x}\\<guillemotright>\n 2. \\<And>a f.\n       \\<lbrakk>ide a;\n        \\<guillemotleft>f : a \\<rightarrow> MkIde\n       {x}\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> f = ?a a", "assume a: \"ide a\""], ["proof (state)\nthis:\n  ide a\n\ngoal (2 subgoals):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<guillemotleft>?a a : a \\<rightarrow> MkIde {x}\\<guillemotright>\n 2. \\<And>a f.\n       \\<lbrakk>ide a;\n        \\<guillemotleft>f : a \\<rightarrow> MkIde\n       {x}\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> f = ?a a", "show \"\\<guillemotleft>MkArr (Dom a) {x} (\\<lambda>_\\<in>Dom a. x) : a \\<rightarrow> MkIde {x}\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>MkArr (Dom a) {x}\n                     (\\<lambda>_\\<in>Dom a.\n                         x) : a \\<rightarrow> MkIde {x}\\<guillemotright>", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. arr (MkArr (Dom a) {x} (\\<lambda>_\\<in>Dom a. x))\n 2. local.dom (MkArr (Dom a) {x} (\\<lambda>_\\<in>Dom a. x)) = a\n 3. cod (MkArr (Dom a) {x} (\\<lambda>_\\<in>Dom a. x)) = MkIde {x}", "show 2: \"arr (MkArr (Dom a) {x} (\\<lambda>_ \\<in> Dom a. x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (MkArr (Dom a) {x} (\\<lambda>_\\<in>Dom a. x))", "using a 1 arr_MkArr [of \"Dom a\" \"{x}\"] ide_char"], ["proof (prove)\nusing this:\n  ide a\n  ide (MkIde {x})\n  \\<lbrakk>Dom a \\<in> {A. |A| <o \\<AA>}; {x} \\<in> {A. |A| <o \\<AA>};\n   ?f \\<in> extensional (Dom a) \\<inter> (Dom a \\<rightarrow> {x})\\<rbrakk>\n  \\<Longrightarrow> arr (MkArr (Dom a) {x} ?f)\n  ide ?f =\n  (?f \\<noteq> Null \\<and>\n   Dom ?f \\<in> {A. |A| <o \\<AA>} \\<and>\n   Cod ?f = Dom ?f \\<and> Map ?f = (\\<lambda>x\\<in>Dom ?f. x))\n\ngoal (1 subgoal):\n 1. arr (MkArr (Dom a) {x} (\\<lambda>_\\<in>Dom a. x))", "by force"], ["proof (state)\nthis:\n  arr (MkArr (Dom a) {x} (\\<lambda>_\\<in>Dom a. x))\n\ngoal (2 subgoals):\n 1. local.dom (MkArr (Dom a) {x} (\\<lambda>_\\<in>Dom a. x)) = a\n 2. cod (MkArr (Dom a) {x} (\\<lambda>_\\<in>Dom a. x)) = MkIde {x}", "show \"dom (MkArr (Dom a) {x} (\\<lambda>_ \\<in> Dom a. x)) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dom (MkArr (Dom a) {x} (\\<lambda>_\\<in>Dom a. x)) = a", "using a 2 dom_MkArr"], ["proof (prove)\nusing this:\n  ide a\n  arr (MkArr (Dom a) {x} (\\<lambda>_\\<in>Dom a. x))\n  arr (MkArr ?A ?B ?F) \\<Longrightarrow>\n  local.dom (MkArr ?A ?B ?F) = MkIde ?A\n\ngoal (1 subgoal):\n 1. local.dom (MkArr (Dom a) {x} (\\<lambda>_\\<in>Dom a. x)) = a", "by force"], ["proof (state)\nthis:\n  local.dom (MkArr (Dom a) {x} (\\<lambda>_\\<in>Dom a. x)) = a\n\ngoal (1 subgoal):\n 1. cod (MkArr (Dom a) {x} (\\<lambda>_\\<in>Dom a. x)) = MkIde {x}", "show \"cod (MkArr (Dom a) {x} (\\<lambda>_\\<in>Dom a. x)) = MkIde {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cod (MkArr (Dom a) {x} (\\<lambda>_\\<in>Dom a. x)) = MkIde {x}", "using 2 cod_MkArr"], ["proof (prove)\nusing this:\n  arr (MkArr (Dom a) {x} (\\<lambda>_\\<in>Dom a. x))\n  arr (MkArr ?A ?B ?F) \\<Longrightarrow> cod (MkArr ?A ?B ?F) = MkIde ?B\n\ngoal (1 subgoal):\n 1. cod (MkArr (Dom a) {x} (\\<lambda>_\\<in>Dom a. x)) = MkIde {x}", "by blast"], ["proof (state)\nthis:\n  cod (MkArr (Dom a) {x} (\\<lambda>_\\<in>Dom a. x)) = MkIde {x}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<guillemotleft>MkArr (Dom a) {x}\n                   (\\<lambda>_\\<in>Dom a.\n                       x) : a \\<rightarrow> MkIde {x}\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>a f.\n       \\<lbrakk>ide a;\n        \\<guillemotleft>f : a \\<rightarrow> MkIde\n       {x}\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> f = MkArr (Dom a) {x} (\\<lambda>_\\<in>Dom a. x)", "fix f :: \"'e setcat.arr\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a f.\n       \\<lbrakk>ide a;\n        \\<guillemotleft>f : a \\<rightarrow> MkIde\n       {x}\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> f = MkArr (Dom a) {x} (\\<lambda>_\\<in>Dom a. x)", "assume f: \"\\<guillemotleft>f : a \\<rightarrow> MkIde {x}\\<guillemotright>\""], ["proof (state)\nthis:\n  \\<guillemotleft>f : a \\<rightarrow> MkIde {x}\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>a f.\n       \\<lbrakk>ide a;\n        \\<guillemotleft>f : a \\<rightarrow> MkIde\n       {x}\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> f = MkArr (Dom a) {x} (\\<lambda>_\\<in>Dom a. x)", "show \"f = MkArr (Dom a) {x} (\\<lambda>_ \\<in> Dom a. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = MkArr (Dom a) {x} (\\<lambda>_\\<in>Dom a. x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f = MkArr (Dom a) {x} (\\<lambda>_\\<in>Dom a. x)", "have 1: \"Dom f = Dom a \\<and> Cod f = {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dom f = Dom a \\<and> Cod f = {x}", "using a f"], ["proof (prove)\nusing this:\n  ide a\n  \\<guillemotleft>f : a \\<rightarrow> MkIde {x}\\<guillemotright>\n\ngoal (1 subgoal):\n 1. Dom f = Dom a \\<and> Cod f = {x}", "by (metis (mono_tags, lifting) Dom.simps(1) in_hom_char)"], ["proof (state)\nthis:\n  Dom f = Dom a \\<and> Cod f = {x}\n\ngoal (1 subgoal):\n 1. f = MkArr (Dom a) {x} (\\<lambda>_\\<in>Dom a. x)", "moreover"], ["proof (state)\nthis:\n  Dom f = Dom a \\<and> Cod f = {x}\n\ngoal (1 subgoal):\n 1. f = MkArr (Dom a) {x} (\\<lambda>_\\<in>Dom a. x)", "have \"Map f = (\\<lambda>_ \\<in> Dom a. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Map f = (\\<lambda>_\\<in>Dom a. x)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. Map f xa = (\\<lambda>_\\<in>Dom a. x) xa", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. Map f xa = (\\<lambda>_\\<in>Dom a. x) xa", "have \"z \\<notin> Dom a \\<Longrightarrow> Map f z = (\\<lambda>_ \\<in> Dom a. x) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<notin> Dom a \\<Longrightarrow> Map f z = (\\<lambda>_\\<in>Dom a. x) z", "using f 1 MkArr_expansion"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f : a \\<rightarrow> MkIde {x}\\<guillemotright>\n  Dom f = Dom a \\<and> Cod f = {x}\n  arr ?f \\<Longrightarrow>\n  ?f = MkArr (Dom ?f) (Cod ?f) (restrict (Map ?f) (Dom ?f))\n\ngoal (1 subgoal):\n 1. z \\<notin> Dom a \\<Longrightarrow> Map f z = (\\<lambda>_\\<in>Dom a. x) z", "by (metis (mono_tags, lifting) Map.simps(1) in_homE restrict_apply)"], ["proof (state)\nthis:\n  z \\<notin> Dom a \\<Longrightarrow> Map f z = (\\<lambda>_\\<in>Dom a. x) z\n\ngoal (1 subgoal):\n 1. \\<And>xa. Map f xa = (\\<lambda>_\\<in>Dom a. x) xa", "moreover"], ["proof (state)\nthis:\n  z \\<notin> Dom a \\<Longrightarrow> Map f z = (\\<lambda>_\\<in>Dom a. x) z\n\ngoal (1 subgoal):\n 1. \\<And>xa. Map f xa = (\\<lambda>_\\<in>Dom a. x) xa", "have \"z \\<in> Dom a \\<Longrightarrow> Map f z = (\\<lambda>_ \\<in> Dom a. x) z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<in> Dom a \\<Longrightarrow> Map f z = (\\<lambda>_\\<in>Dom a. x) z", "using f 1 arr_char [of f]"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f : a \\<rightarrow> MkIde {x}\\<guillemotright>\n  Dom f = Dom a \\<and> Cod f = {x}\n  arr f =\n  (f \\<noteq> Null \\<and>\n   |Dom f| <o \\<AA> \\<and>\n   |Cod f| <o \\<AA> \\<and>\n   Map f \\<in> extensional (Dom f) \\<inter> (Dom f \\<rightarrow> Cod f))\n\ngoal (1 subgoal):\n 1. z \\<in> Dom a \\<Longrightarrow> Map f z = (\\<lambda>_\\<in>Dom a. x) z", "by fastforce"], ["proof (state)\nthis:\n  z \\<in> Dom a \\<Longrightarrow> Map f z = (\\<lambda>_\\<in>Dom a. x) z\n\ngoal (1 subgoal):\n 1. \\<And>xa. Map f xa = (\\<lambda>_\\<in>Dom a. x) xa", "ultimately"], ["proof (chain)\npicking this:\n  z \\<notin> Dom a \\<Longrightarrow> Map f z = (\\<lambda>_\\<in>Dom a. x) z\n  z \\<in> Dom a \\<Longrightarrow> Map f z = (\\<lambda>_\\<in>Dom a. x) z", "show \"Map f z = (\\<lambda>_ \\<in> Dom a. x) z\""], ["proof (prove)\nusing this:\n  z \\<notin> Dom a \\<Longrightarrow> Map f z = (\\<lambda>_\\<in>Dom a. x) z\n  z \\<in> Dom a \\<Longrightarrow> Map f z = (\\<lambda>_\\<in>Dom a. x) z\n\ngoal (1 subgoal):\n 1. Map f z = (\\<lambda>_\\<in>Dom a. x) z", "by auto"], ["proof (state)\nthis:\n  Map f z = (\\<lambda>_\\<in>Dom a. x) z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Map f = (\\<lambda>_\\<in>Dom a. x)\n\ngoal (1 subgoal):\n 1. f = MkArr (Dom a) {x} (\\<lambda>_\\<in>Dom a. x)", "ultimately"], ["proof (chain)\npicking this:\n  Dom f = Dom a \\<and> Cod f = {x}\n  Map f = (\\<lambda>_\\<in>Dom a. x)", "show ?thesis"], ["proof (prove)\nusing this:\n  Dom f = Dom a \\<and> Cod f = {x}\n  Map f = (\\<lambda>_\\<in>Dom a. x)\n\ngoal (1 subgoal):\n 1. f = MkArr (Dom a) {x} (\\<lambda>_\\<in>Dom a. x)", "using f MkArr_expansion [of f]"], ["proof (prove)\nusing this:\n  Dom f = Dom a \\<and> Cod f = {x}\n  Map f = (\\<lambda>_\\<in>Dom a. x)\n  \\<guillemotleft>f : a \\<rightarrow> MkIde {x}\\<guillemotright>\n  arr f \\<Longrightarrow>\n  f = MkArr (Dom f) (Cod f) (restrict (Map f) (Dom f))\n\ngoal (1 subgoal):\n 1. f = MkArr (Dom a) {x} (\\<lambda>_\\<in>Dom a. x)", "by fastforce"], ["proof (state)\nthis:\n  f = MkArr (Dom a) {x} (\\<lambda>_\\<in>Dom a. x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f = MkArr (Dom a) {x} (\\<lambda>_\\<in>Dom a. x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ide ?a \\<Longrightarrow>\n  \\<exists>!f.\n     \\<guillemotleft>f : ?a \\<rightarrow> MkIde {x}\\<guillemotright>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  terminal (MkIde {x})\n\ngoal (1 subgoal):\n 1. \\<exists>x. a = MkIde {x} \\<Longrightarrow> terminal a", "thus \"terminal a\""], ["proof (prove)\nusing this:\n  terminal (MkIde {x})\n\ngoal (1 subgoal):\n 1. terminal a", "using x"], ["proof (prove)\nusing this:\n  terminal (MkIde {x})\n  a = MkIde {x}\n\ngoal (1 subgoal):\n 1. terminal a", "by simp"], ["proof (state)\nthis:\n  terminal a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x. a = MkIde {x} \\<Longrightarrow> terminal a\n\ngoal (1 subgoal):\n 1. terminal a \\<Longrightarrow> \\<exists>x. a = MkIde {x}", "show \"terminal a \\<Longrightarrow> \\<exists>x. a = MkIde {x}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminal a \\<Longrightarrow> \\<exists>x. a = MkIde {x}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. terminal a \\<Longrightarrow> \\<exists>x. a = MkIde {x}", "assume a: \"terminal a\""], ["proof (state)\nthis:\n  terminal a\n\ngoal (1 subgoal):\n 1. terminal a \\<Longrightarrow> \\<exists>x. a = MkIde {x}", "hence ide_a: \"ide a\""], ["proof (prove)\nusing this:\n  terminal a\n\ngoal (1 subgoal):\n 1. ide a", "using terminal_def"], ["proof (prove)\nusing this:\n  terminal a\n  terminal ?b \\<equiv>\n  ide ?b \\<and>\n  (\\<forall>a.\n      ide a \\<longrightarrow>\n      (\\<exists>!f.\n          \\<guillemotleft>f : a \\<rightarrow> ?b\\<guillemotright>))\n\ngoal (1 subgoal):\n 1. ide a", "by auto"], ["proof (state)\nthis:\n  ide a\n\ngoal (1 subgoal):\n 1. terminal a \\<Longrightarrow> \\<exists>x. a = MkIde {x}", "have 1: \"\\<exists>!x. x \\<in> Dom a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!x. x \\<in> Dom a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!x. x \\<in> Dom a", "have \"Dom a = {} \\<Longrightarrow> \\<not>terminal a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dom a = {} \\<Longrightarrow> \\<not> terminal a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Dom a = {} \\<Longrightarrow> \\<not> terminal a", "assume \"Dom a = {}\""], ["proof (state)\nthis:\n  Dom a = {}\n\ngoal (1 subgoal):\n 1. Dom a = {} \\<Longrightarrow> \\<not> terminal a", "hence 1: \"a = MkIde {}\""], ["proof (prove)\nusing this:\n  Dom a = {}\n\ngoal (1 subgoal):\n 1. a = MkIde {}", "using MkIde_Dom' \\<open>ide a\\<close>"], ["proof (prove)\nusing this:\n  Dom a = {}\n  ide ?a \\<Longrightarrow> MkIde (Dom ?a) = ?a\n  ide a\n\ngoal (1 subgoal):\n 1. a = MkIde {}", "by fastforce"], ["proof (state)\nthis:\n  a = MkIde {}\n\ngoal (1 subgoal):\n 1. Dom a = {} \\<Longrightarrow> \\<not> terminal a", "have \"\\<And>f. f \\<in> hom (MkIde {undefined}) (MkIde ({} :: 'e set))\n                         \\<Longrightarrow> Map f \\<in> {undefined} \\<rightarrow> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> hom (MkIde {undefined}) (MkIde {}) \\<Longrightarrow>\n       Map f \\<in> {undefined} \\<rightarrow> {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> hom (MkIde {undefined}) (MkIde {}) \\<Longrightarrow>\n       Map f \\<in> {undefined} \\<rightarrow> {}", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> hom (MkIde {undefined}) (MkIde {}) \\<Longrightarrow>\n       Map f \\<in> {undefined} \\<rightarrow> {}", "assume f: \"f \\<in> hom (MkIde {undefined}) (MkIde ({} :: 'e set))\""], ["proof (state)\nthis:\n  f \\<in> hom (MkIde {undefined}) (MkIde {})\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       f \\<in> hom (MkIde {undefined}) (MkIde {}) \\<Longrightarrow>\n       Map f \\<in> {undefined} \\<rightarrow> {}", "show \"Map f \\<in> {undefined} \\<rightarrow> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Map f \\<in> {undefined} \\<rightarrow> {}", "using f MkArr_expansion arr_char [of f] in_hom_char"], ["proof (prove)\nusing this:\n  f \\<in> hom (MkIde {undefined}) (MkIde {})\n  arr ?f \\<Longrightarrow>\n  ?f = MkArr (Dom ?f) (Cod ?f) (restrict (Map ?f) (Dom ?f))\n  arr f =\n  (f \\<noteq> Null \\<and>\n   |Dom f| <o \\<AA> \\<and>\n   |Cod f| <o \\<AA> \\<and>\n   Map f \\<in> extensional (Dom f) \\<inter> (Dom f \\<rightarrow> Cod f))\n  \\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright> =\n  (arr ?f \\<and>\n   ide ?a \\<and> ide ?b \\<and> Dom ?f = Dom ?a \\<and> Cod ?f = Dom ?b)\n\ngoal (1 subgoal):\n 1. Map f \\<in> {undefined} \\<rightarrow> {}", "by auto"], ["proof (state)\nthis:\n  Map f \\<in> {undefined} \\<rightarrow> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?f \\<in> hom (MkIde {undefined}) (MkIde {}) \\<Longrightarrow>\n  Map ?f \\<in> {undefined} \\<rightarrow> {}\n\ngoal (1 subgoal):\n 1. Dom a = {} \\<Longrightarrow> \\<not> terminal a", "hence \"hom (MkIde {undefined}) a = {}\""], ["proof (prove)\nusing this:\n  ?f \\<in> hom (MkIde {undefined}) (MkIde {}) \\<Longrightarrow>\n  Map ?f \\<in> {undefined} \\<rightarrow> {}\n\ngoal (1 subgoal):\n 1. hom (MkIde {undefined}) a = {}", "using 1"], ["proof (prove)\nusing this:\n  ?f \\<in> hom (MkIde {undefined}) (MkIde {}) \\<Longrightarrow>\n  Map ?f \\<in> {undefined} \\<rightarrow> {}\n  a = MkIde {}\n\ngoal (1 subgoal):\n 1. hom (MkIde {undefined}) a = {}", "by auto"], ["proof (state)\nthis:\n  hom (MkIde {undefined}) a = {}\n\ngoal (1 subgoal):\n 1. Dom a = {} \\<Longrightarrow> \\<not> terminal a", "moreover"], ["proof (state)\nthis:\n  hom (MkIde {undefined}) a = {}\n\ngoal (1 subgoal):\n 1. Dom a = {} \\<Longrightarrow> \\<not> terminal a", "have \"ide (MkIde {undefined})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide (MkIde {undefined})", "using finite_imp_card_less"], ["proof (prove)\nusing this:\n  finite ?A \\<Longrightarrow> |?A| <o \\<AA>\n\ngoal (1 subgoal):\n 1. ide (MkIde {undefined})", "by (metis (mono_tags, lifting) finite.intros(1-2) ide_MkIde mem_Collect_eq)"], ["proof (state)\nthis:\n  ide (MkIde {undefined})\n\ngoal (1 subgoal):\n 1. Dom a = {} \\<Longrightarrow> \\<not> terminal a", "ultimately"], ["proof (chain)\npicking this:\n  hom (MkIde {undefined}) a = {}\n  ide (MkIde {undefined})", "show \"\\<not>terminal a\""], ["proof (prove)\nusing this:\n  hom (MkIde {undefined}) a = {}\n  ide (MkIde {undefined})\n\ngoal (1 subgoal):\n 1. \\<not> terminal a", "by blast"], ["proof (state)\nthis:\n  \\<not> terminal a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Dom a = {} \\<Longrightarrow> \\<not> terminal a\n\ngoal (1 subgoal):\n 1. \\<exists>!x. x \\<in> Dom a", "moreover"], ["proof (state)\nthis:\n  Dom a = {} \\<Longrightarrow> \\<not> terminal a\n\ngoal (1 subgoal):\n 1. \\<exists>!x. x \\<in> Dom a", "have \"\\<And>x x'. x \\<in> Dom a \\<and> x' \\<in> Dom a \\<and> x \\<noteq> x' \\<Longrightarrow> \\<not>terminal a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x x'.\n       x \\<in> Dom a \\<and>\n       x' \\<in> Dom a \\<and> x \\<noteq> x' \\<Longrightarrow>\n       \\<not> terminal a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x x'.\n       x \\<in> Dom a \\<and>\n       x' \\<in> Dom a \\<and> x \\<noteq> x' \\<Longrightarrow>\n       \\<not> terminal a", "fix x x'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x x'.\n       x \\<in> Dom a \\<and>\n       x' \\<in> Dom a \\<and> x \\<noteq> x' \\<Longrightarrow>\n       \\<not> terminal a", "assume 1: \"x \\<in> Dom a \\<and> x' \\<in> Dom a \\<and> x \\<noteq> x'\""], ["proof (state)\nthis:\n  x \\<in> Dom a \\<and> x' \\<in> Dom a \\<and> x \\<noteq> x'\n\ngoal (1 subgoal):\n 1. \\<And>x x'.\n       x \\<in> Dom a \\<and>\n       x' \\<in> Dom a \\<and> x \\<noteq> x' \\<Longrightarrow>\n       \\<not> terminal a", "let ?f = \"MkArr {undefined} (Dom a) (\\<lambda>_ \\<in> {undefined}. x)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x x'.\n       x \\<in> Dom a \\<and>\n       x' \\<in> Dom a \\<and> x \\<noteq> x' \\<Longrightarrow>\n       \\<not> terminal a", "let ?f' = \"MkArr {undefined} (Dom a) (\\<lambda>_ \\<in> {undefined}. x')\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x x'.\n       x \\<in> Dom a \\<and>\n       x' \\<in> Dom a \\<and> x \\<noteq> x' \\<Longrightarrow>\n       \\<not> terminal a", "have \"\\<guillemotleft>?f : MkIde {undefined} \\<rightarrow> a\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>MkArr {undefined} (Dom a)\n                     (\\<lambda>_\\<in>{undefined}.\n                         x) : MkIde\n                               {undefined} \\<rightarrow> a\\<guillemotright>", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. arr (MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x))\n 2. local.dom (MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x)) =\n    MkIde {undefined}\n 3. cod (MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x)) = a", "show 2: \"arr ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x))", "proof (intro arr_MkArr)"], ["proof (state)\ngoal (3 subgoals):\n 1. {undefined} \\<in> {A. |A| <o \\<AA>}\n 2. Dom a \\<in> {A. |A| <o \\<AA>}\n 3. (\\<lambda>_\\<in>{undefined}. x)\n    \\<in> extensional {undefined} \\<inter> ({undefined} \\<rightarrow> Dom a)", "show \"{undefined} \\<in> {A. |A| <o \\<AA>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {undefined} \\<in> {A. |A| <o \\<AA>}", "by (simp add: finite_imp_card_less)"], ["proof (state)\nthis:\n  {undefined} \\<in> {A. |A| <o \\<AA>}\n\ngoal (2 subgoals):\n 1. Dom a \\<in> {A. |A| <o \\<AA>}\n 2. (\\<lambda>_\\<in>{undefined}. x)\n    \\<in> extensional {undefined} \\<inter> ({undefined} \\<rightarrow> Dom a)", "show \"Dom a \\<in> {A. |A| <o \\<AA>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dom a \\<in> {A. |A| <o \\<AA>}", "using ide_a ide_char"], ["proof (prove)\nusing this:\n  ide a\n  ide ?f =\n  (?f \\<noteq> Null \\<and>\n   Dom ?f \\<in> {A. |A| <o \\<AA>} \\<and>\n   Cod ?f = Dom ?f \\<and> Map ?f = (\\<lambda>x\\<in>Dom ?f. x))\n\ngoal (1 subgoal):\n 1. Dom a \\<in> {A. |A| <o \\<AA>}", "by blast"], ["proof (state)\nthis:\n  Dom a \\<in> {A. |A| <o \\<AA>}\n\ngoal (1 subgoal):\n 1. (\\<lambda>_\\<in>{undefined}. x)\n    \\<in> extensional {undefined} \\<inter> ({undefined} \\<rightarrow> Dom a)", "show \"(\\<lambda>_ \\<in> {undefined}. x) \\<in> extensional {undefined} \\<inter> ({undefined} \\<rightarrow> Dom a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>_\\<in>{undefined}. x)\n    \\<in> extensional {undefined} \\<inter> ({undefined} \\<rightarrow> Dom a)", "using 1"], ["proof (prove)\nusing this:\n  x \\<in> Dom a \\<and> x' \\<in> Dom a \\<and> x \\<noteq> x'\n\ngoal (1 subgoal):\n 1. (\\<lambda>_\\<in>{undefined}. x)\n    \\<in> extensional {undefined} \\<inter> ({undefined} \\<rightarrow> Dom a)", "by blast"], ["proof (state)\nthis:\n  (\\<lambda>_\\<in>{undefined}. x)\n  \\<in> extensional {undefined} \\<inter> ({undefined} \\<rightarrow> Dom a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  arr (MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x))\n\ngoal (2 subgoals):\n 1. local.dom (MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x)) =\n    MkIde {undefined}\n 2. cod (MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x)) = a", "show \"dom ?f = MkIde {undefined}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dom (MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x)) =\n    MkIde {undefined}", "using 2 dom_MkArr"], ["proof (prove)\nusing this:\n  arr (MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x))\n  arr (MkArr ?A ?B ?F) \\<Longrightarrow>\n  local.dom (MkArr ?A ?B ?F) = MkIde ?A\n\ngoal (1 subgoal):\n 1. local.dom (MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x)) =\n    MkIde {undefined}", "by auto"], ["proof (state)\nthis:\n  local.dom (MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x)) =\n  MkIde {undefined}\n\ngoal (1 subgoal):\n 1. cod (MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x)) = a", "show \"cod ?f = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cod (MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x)) = a", "using 2 cod_MkArr ide_a"], ["proof (prove)\nusing this:\n  arr (MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x))\n  arr (MkArr ?A ?B ?F) \\<Longrightarrow> cod (MkArr ?A ?B ?F) = MkIde ?B\n  ide a\n\ngoal (1 subgoal):\n 1. cod (MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x)) = a", "by force"], ["proof (state)\nthis:\n  cod (MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x)) = a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<guillemotleft>MkArr {undefined} (Dom a)\n                   (\\<lambda>_\\<in>{undefined}.\n                       x) : MkIde\n                             {undefined} \\<rightarrow> a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>x x'.\n       x \\<in> Dom a \\<and>\n       x' \\<in> Dom a \\<and> x \\<noteq> x' \\<Longrightarrow>\n       \\<not> terminal a", "moreover"], ["proof (state)\nthis:\n  \\<guillemotleft>MkArr {undefined} (Dom a)\n                   (\\<lambda>_\\<in>{undefined}.\n                       x) : MkIde\n                             {undefined} \\<rightarrow> a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>x x'.\n       x \\<in> Dom a \\<and>\n       x' \\<in> Dom a \\<and> x \\<noteq> x' \\<Longrightarrow>\n       \\<not> terminal a", "have \"\\<guillemotleft>?f' : MkIde {undefined} \\<rightarrow> a\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>MkArr {undefined} (Dom a)\n                     (\\<lambda>_\\<in>{undefined}.\n                         x') : MkIde\n                                {undefined} \\<rightarrow> a\\<guillemotright>", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. arr (MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x'))\n 2. local.dom (MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x')) =\n    MkIde {undefined}\n 3. cod (MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x')) = a", "show 2: \"arr ?f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x'))", "using 1 ide_a ide_char arr_MkArr [of \"{undefined}\" \"Dom a\"]\n                      finite_imp_card_less"], ["proof (prove)\nusing this:\n  x \\<in> Dom a \\<and> x' \\<in> Dom a \\<and> x \\<noteq> x'\n  ide a\n  ide ?f =\n  (?f \\<noteq> Null \\<and>\n   Dom ?f \\<in> {A. |A| <o \\<AA>} \\<and>\n   Cod ?f = Dom ?f \\<and> Map ?f = (\\<lambda>x\\<in>Dom ?f. x))\n  \\<lbrakk>{undefined} \\<in> {A. |A| <o \\<AA>};\n   Dom a \\<in> {A. |A| <o \\<AA>};\n   ?f \\<in> extensional {undefined} \\<inter>\n            ({undefined} \\<rightarrow> Dom a)\\<rbrakk>\n  \\<Longrightarrow> arr (MkArr {undefined} (Dom a) ?f)\n  finite ?A \\<Longrightarrow> |?A| <o \\<AA>\n\ngoal (1 subgoal):\n 1. arr (MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x'))", "proof (intro arr_MkArr)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrakk>x \\<in> Dom a \\<and> x' \\<in> Dom a \\<and> x \\<noteq> x';\n     ide a;\n     \\<And>f.\n        ide f =\n        (f \\<noteq> Null \\<and>\n         Dom f \\<in> {A. |A| <o \\<AA>} \\<and>\n         Cod f = Dom f \\<and> Map f = (\\<lambda>x\\<in>Dom f. x));\n     \\<And>f.\n        \\<lbrakk>{undefined} \\<in> {A. |A| <o \\<AA>};\n         Dom a \\<in> {A. |A| <o \\<AA>};\n         f \\<in> extensional {undefined} \\<inter>\n                 ({undefined} \\<rightarrow> Dom a)\\<rbrakk>\n        \\<Longrightarrow> arr (MkArr {undefined} (Dom a) f);\n     \\<And>A. finite A \\<Longrightarrow> |A| <o \\<AA>\\<rbrakk>\n    \\<Longrightarrow> {undefined} \\<in> {A. |A| <o \\<AA>}\n 2. \\<lbrakk>x \\<in> Dom a \\<and> x' \\<in> Dom a \\<and> x \\<noteq> x';\n     ide a;\n     \\<And>f.\n        ide f =\n        (f \\<noteq> Null \\<and>\n         Dom f \\<in> {A. |A| <o \\<AA>} \\<and>\n         Cod f = Dom f \\<and> Map f = (\\<lambda>x\\<in>Dom f. x));\n     \\<And>f.\n        \\<lbrakk>{undefined} \\<in> {A. |A| <o \\<AA>};\n         Dom a \\<in> {A. |A| <o \\<AA>};\n         f \\<in> extensional {undefined} \\<inter>\n                 ({undefined} \\<rightarrow> Dom a)\\<rbrakk>\n        \\<Longrightarrow> arr (MkArr {undefined} (Dom a) f);\n     \\<And>A. finite A \\<Longrightarrow> |A| <o \\<AA>\\<rbrakk>\n    \\<Longrightarrow> Dom a \\<in> {A. |A| <o \\<AA>}\n 3. \\<lbrakk>x \\<in> Dom a \\<and> x' \\<in> Dom a \\<and> x \\<noteq> x';\n     ide a;\n     \\<And>f.\n        ide f =\n        (f \\<noteq> Null \\<and>\n         Dom f \\<in> {A. |A| <o \\<AA>} \\<and>\n         Cod f = Dom f \\<and> Map f = (\\<lambda>x\\<in>Dom f. x));\n     \\<And>f.\n        \\<lbrakk>{undefined} \\<in> {A. |A| <o \\<AA>};\n         Dom a \\<in> {A. |A| <o \\<AA>};\n         f \\<in> extensional {undefined} \\<inter>\n                 ({undefined} \\<rightarrow> Dom a)\\<rbrakk>\n        \\<Longrightarrow> arr (MkArr {undefined} (Dom a) f);\n     \\<And>A. finite A \\<Longrightarrow> |A| <o \\<AA>\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>_\\<in>{undefined}. x')\n                      \\<in> extensional {undefined} \\<inter>\n                            ({undefined} \\<rightarrow> Dom a)", "show \"{undefined} \\<in> {A. |A| <o \\<AA>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {undefined} \\<in> {A. |A| <o \\<AA>}", "by (simp add: finite_imp_card_less)"], ["proof (state)\nthis:\n  {undefined} \\<in> {A. |A| <o \\<AA>}\n\ngoal (2 subgoals):\n 1. \\<lbrakk>x \\<in> Dom a \\<and> x' \\<in> Dom a \\<and> x \\<noteq> x';\n     ide a;\n     \\<And>f.\n        ide f =\n        (f \\<noteq> Null \\<and>\n         Dom f \\<in> {A. |A| <o \\<AA>} \\<and>\n         Cod f = Dom f \\<and> Map f = (\\<lambda>x\\<in>Dom f. x));\n     \\<And>f.\n        \\<lbrakk>{undefined} \\<in> {A. |A| <o \\<AA>};\n         Dom a \\<in> {A. |A| <o \\<AA>};\n         f \\<in> extensional {undefined} \\<inter>\n                 ({undefined} \\<rightarrow> Dom a)\\<rbrakk>\n        \\<Longrightarrow> arr (MkArr {undefined} (Dom a) f);\n     \\<And>A. finite A \\<Longrightarrow> |A| <o \\<AA>\\<rbrakk>\n    \\<Longrightarrow> Dom a \\<in> {A. |A| <o \\<AA>}\n 2. \\<lbrakk>x \\<in> Dom a \\<and> x' \\<in> Dom a \\<and> x \\<noteq> x';\n     ide a;\n     \\<And>f.\n        ide f =\n        (f \\<noteq> Null \\<and>\n         Dom f \\<in> {A. |A| <o \\<AA>} \\<and>\n         Cod f = Dom f \\<and> Map f = (\\<lambda>x\\<in>Dom f. x));\n     \\<And>f.\n        \\<lbrakk>{undefined} \\<in> {A. |A| <o \\<AA>};\n         Dom a \\<in> {A. |A| <o \\<AA>};\n         f \\<in> extensional {undefined} \\<inter>\n                 ({undefined} \\<rightarrow> Dom a)\\<rbrakk>\n        \\<Longrightarrow> arr (MkArr {undefined} (Dom a) f);\n     \\<And>A. finite A \\<Longrightarrow> |A| <o \\<AA>\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>_\\<in>{undefined}. x')\n                      \\<in> extensional {undefined} \\<inter>\n                            ({undefined} \\<rightarrow> Dom a)", "show \"Dom a \\<in> {A. |A| <o \\<AA>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dom a \\<in> {A. |A| <o \\<AA>}", "using ide_a ide_char"], ["proof (prove)\nusing this:\n  ide a\n  ide ?f =\n  (?f \\<noteq> Null \\<and>\n   Dom ?f \\<in> {A. |A| <o \\<AA>} \\<and>\n   Cod ?f = Dom ?f \\<and> Map ?f = (\\<lambda>x\\<in>Dom ?f. x))\n\ngoal (1 subgoal):\n 1. Dom a \\<in> {A. |A| <o \\<AA>}", "by blast"], ["proof (state)\nthis:\n  Dom a \\<in> {A. |A| <o \\<AA>}\n\ngoal (1 subgoal):\n 1. \\<lbrakk>x \\<in> Dom a \\<and> x' \\<in> Dom a \\<and> x \\<noteq> x';\n     ide a;\n     \\<And>f.\n        ide f =\n        (f \\<noteq> Null \\<and>\n         Dom f \\<in> {A. |A| <o \\<AA>} \\<and>\n         Cod f = Dom f \\<and> Map f = (\\<lambda>x\\<in>Dom f. x));\n     \\<And>f.\n        \\<lbrakk>{undefined} \\<in> {A. |A| <o \\<AA>};\n         Dom a \\<in> {A. |A| <o \\<AA>};\n         f \\<in> extensional {undefined} \\<inter>\n                 ({undefined} \\<rightarrow> Dom a)\\<rbrakk>\n        \\<Longrightarrow> arr (MkArr {undefined} (Dom a) f);\n     \\<And>A. finite A \\<Longrightarrow> |A| <o \\<AA>\\<rbrakk>\n    \\<Longrightarrow> (\\<lambda>_\\<in>{undefined}. x')\n                      \\<in> extensional {undefined} \\<inter>\n                            ({undefined} \\<rightarrow> Dom a)", "show \"(\\<lambda>_ \\<in> {undefined}. x') \\<in> extensional {undefined} \\<inter> ({undefined} \\<rightarrow> Dom a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>_\\<in>{undefined}. x')\n    \\<in> extensional {undefined} \\<inter> ({undefined} \\<rightarrow> Dom a)", "using 1"], ["proof (prove)\nusing this:\n  x \\<in> Dom a \\<and> x' \\<in> Dom a \\<and> x \\<noteq> x'\n\ngoal (1 subgoal):\n 1. (\\<lambda>_\\<in>{undefined}. x')\n    \\<in> extensional {undefined} \\<inter> ({undefined} \\<rightarrow> Dom a)", "by blast"], ["proof (state)\nthis:\n  (\\<lambda>_\\<in>{undefined}. x')\n  \\<in> extensional {undefined} \\<inter> ({undefined} \\<rightarrow> Dom a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  arr (MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x'))\n\ngoal (2 subgoals):\n 1. local.dom (MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x')) =\n    MkIde {undefined}\n 2. cod (MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x')) = a", "show \"dom ?f' = MkIde {undefined}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dom (MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x')) =\n    MkIde {undefined}", "using 2 dom_MkArr"], ["proof (prove)\nusing this:\n  arr (MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x'))\n  arr (MkArr ?A ?B ?F) \\<Longrightarrow>\n  local.dom (MkArr ?A ?B ?F) = MkIde ?A\n\ngoal (1 subgoal):\n 1. local.dom (MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x')) =\n    MkIde {undefined}", "by auto"], ["proof (state)\nthis:\n  local.dom (MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x')) =\n  MkIde {undefined}\n\ngoal (1 subgoal):\n 1. cod (MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x')) = a", "show \"cod ?f' = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cod (MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x')) = a", "using 2 cod_MkArr ide_a"], ["proof (prove)\nusing this:\n  arr (MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x'))\n  arr (MkArr ?A ?B ?F) \\<Longrightarrow> cod (MkArr ?A ?B ?F) = MkIde ?B\n  ide a\n\ngoal (1 subgoal):\n 1. cod (MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x')) = a", "by force"], ["proof (state)\nthis:\n  cod (MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x')) = a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<guillemotleft>MkArr {undefined} (Dom a)\n                   (\\<lambda>_\\<in>{undefined}.\n                       x') : MkIde\n                              {undefined} \\<rightarrow> a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>x x'.\n       x \\<in> Dom a \\<and>\n       x' \\<in> Dom a \\<and> x \\<noteq> x' \\<Longrightarrow>\n       \\<not> terminal a", "moreover"], ["proof (state)\nthis:\n  \\<guillemotleft>MkArr {undefined} (Dom a)\n                   (\\<lambda>_\\<in>{undefined}.\n                       x') : MkIde\n                              {undefined} \\<rightarrow> a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>x x'.\n       x \\<in> Dom a \\<and>\n       x' \\<in> Dom a \\<and> x \\<noteq> x' \\<Longrightarrow>\n       \\<not> terminal a", "have \"?f \\<noteq> ?f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x) \\<noteq>\n    MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x')", "using 1"], ["proof (prove)\nusing this:\n  x \\<in> Dom a \\<and> x' \\<in> Dom a \\<and> x \\<noteq> x'\n\ngoal (1 subgoal):\n 1. MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x) \\<noteq>\n    MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x')", "by (metis arr.inject restrict_apply' singletonI)"], ["proof (state)\nthis:\n  MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x) \\<noteq>\n  MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x')\n\ngoal (1 subgoal):\n 1. \\<And>x x'.\n       x \\<in> Dom a \\<and>\n       x' \\<in> Dom a \\<and> x \\<noteq> x' \\<Longrightarrow>\n       \\<not> terminal a", "ultimately"], ["proof (chain)\npicking this:\n  \\<guillemotleft>MkArr {undefined} (Dom a)\n                   (\\<lambda>_\\<in>{undefined}.\n                       x) : MkIde\n                             {undefined} \\<rightarrow> a\\<guillemotright>\n  \\<guillemotleft>MkArr {undefined} (Dom a)\n                   (\\<lambda>_\\<in>{undefined}.\n                       x') : MkIde\n                              {undefined} \\<rightarrow> a\\<guillemotright>\n  MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x) \\<noteq>\n  MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x')", "show \"\\<not>terminal a\""], ["proof (prove)\nusing this:\n  \\<guillemotleft>MkArr {undefined} (Dom a)\n                   (\\<lambda>_\\<in>{undefined}.\n                       x) : MkIde\n                             {undefined} \\<rightarrow> a\\<guillemotright>\n  \\<guillemotleft>MkArr {undefined} (Dom a)\n                   (\\<lambda>_\\<in>{undefined}.\n                       x') : MkIde\n                              {undefined} \\<rightarrow> a\\<guillemotright>\n  MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x) \\<noteq>\n  MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x')\n\ngoal (1 subgoal):\n 1. \\<not> terminal a", "using terminal_arr_unique"], ["proof (prove)\nusing this:\n  \\<guillemotleft>MkArr {undefined} (Dom a)\n                   (\\<lambda>_\\<in>{undefined}.\n                       x) : MkIde\n                             {undefined} \\<rightarrow> a\\<guillemotright>\n  \\<guillemotleft>MkArr {undefined} (Dom a)\n                   (\\<lambda>_\\<in>{undefined}.\n                       x') : MkIde\n                              {undefined} \\<rightarrow> a\\<guillemotright>\n  MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x) \\<noteq>\n  MkArr {undefined} (Dom a) (\\<lambda>_\\<in>{undefined}. x')\n  \\<lbrakk>par ?f ?f'; terminal_arr ?f; terminal_arr ?f'\\<rbrakk>\n  \\<Longrightarrow> ?f = ?f'\n\ngoal (1 subgoal):\n 1. \\<not> terminal a", "by (metis (mono_tags, lifting) in_homE)"], ["proof (state)\nthis:\n  \\<not> terminal a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> Dom a \\<and>\n  ?x' \\<in> Dom a \\<and> ?x \\<noteq> ?x' \\<Longrightarrow>\n  \\<not> terminal a\n\ngoal (1 subgoal):\n 1. \\<exists>!x. x \\<in> Dom a", "ultimately"], ["proof (chain)\npicking this:\n  Dom a = {} \\<Longrightarrow> \\<not> terminal a\n  ?x \\<in> Dom a \\<and>\n  ?x' \\<in> Dom a \\<and> ?x \\<noteq> ?x' \\<Longrightarrow>\n  \\<not> terminal a", "show ?thesis"], ["proof (prove)\nusing this:\n  Dom a = {} \\<Longrightarrow> \\<not> terminal a\n  ?x \\<in> Dom a \\<and>\n  ?x' \\<in> Dom a \\<and> ?x \\<noteq> ?x' \\<Longrightarrow>\n  \\<not> terminal a\n\ngoal (1 subgoal):\n 1. \\<exists>!x. x \\<in> Dom a", "using a"], ["proof (prove)\nusing this:\n  Dom a = {} \\<Longrightarrow> \\<not> terminal a\n  ?x \\<in> Dom a \\<and>\n  ?x' \\<in> Dom a \\<and> ?x \\<noteq> ?x' \\<Longrightarrow>\n  \\<not> terminal a\n  terminal a\n\ngoal (1 subgoal):\n 1. \\<exists>!x. x \\<in> Dom a", "by auto"], ["proof (state)\nthis:\n  \\<exists>!x. x \\<in> Dom a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!x. x \\<in> Dom a\n\ngoal (1 subgoal):\n 1. terminal a \\<Longrightarrow> \\<exists>x. a = MkIde {x}", "hence \"Dom a = {THE x. x \\<in> Dom a}\""], ["proof (prove)\nusing this:\n  \\<exists>!x. x \\<in> Dom a\n\ngoal (1 subgoal):\n 1. Dom a = {THE x. x \\<in> Dom a}", "using theI [of \"\\<lambda>x. x \\<in> Dom a\"]"], ["proof (prove)\nusing this:\n  \\<exists>!x. x \\<in> Dom a\n  \\<lbrakk>?a \\<in> Dom a;\n   \\<And>x. x \\<in> Dom a \\<Longrightarrow> x = ?a\\<rbrakk>\n  \\<Longrightarrow> (THE x. x \\<in> Dom a) \\<in> Dom a\n\ngoal (1 subgoal):\n 1. Dom a = {THE x. x \\<in> Dom a}", "by auto"], ["proof (state)\nthis:\n  Dom a = {THE x. x \\<in> Dom a}\n\ngoal (1 subgoal):\n 1. terminal a \\<Longrightarrow> \\<exists>x. a = MkIde {x}", "hence \"a = MkIde {THE x. x \\<in> Dom a}\""], ["proof (prove)\nusing this:\n  Dom a = {THE x. x \\<in> Dom a}\n\ngoal (1 subgoal):\n 1. a = MkIde {THE x. x \\<in> Dom a}", "using a terminal_def"], ["proof (prove)\nusing this:\n  Dom a = {THE x. x \\<in> Dom a}\n  terminal a\n  terminal ?b \\<equiv>\n  ide ?b \\<and>\n  (\\<forall>a.\n      ide a \\<longrightarrow>\n      (\\<exists>!f.\n          \\<guillemotleft>f : a \\<rightarrow> ?b\\<guillemotright>))\n\ngoal (1 subgoal):\n 1. a = MkIde {THE x. x \\<in> Dom a}", "by (metis (mono_tags, lifting) MkIde_Dom')"], ["proof (state)\nthis:\n  a = MkIde {THE x. x \\<in> Dom a}\n\ngoal (1 subgoal):\n 1. terminal a \\<Longrightarrow> \\<exists>x. a = MkIde {x}", "thus \"\\<exists>x. a = MkIde {x}\""], ["proof (prove)\nusing this:\n  a = MkIde {THE x. x \\<in> Dom a}\n\ngoal (1 subgoal):\n 1. \\<exists>x. a = MkIde {x}", "by auto"], ["proof (state)\nthis:\n  \\<exists>x. a = MkIde {x}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  terminal a \\<Longrightarrow> \\<exists>x. a = MkIde {x}\n\ngoal:\nNo subgoals!", "qed"], ["", "definition IMG :: \"'e setcat.arr \\<Rightarrow> 'e setcat.arr\"\n    where \"IMG f = MkIde (Map f ` Dom f)\""], ["", "interpretation set_category_data comp IMG"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_category_data (\\<cdot>)", ".."], ["", "lemma terminal_unity:\n    shows \"terminal unity\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminal unity", "using terminal_char unity_def someI_ex [of terminal]"], ["proof (prove)\nusing this:\n  terminal ?a = (\\<exists>x. ?a = MkIde {x})\n  unity = Eps terminal\n  Ex terminal \\<Longrightarrow> terminal (Eps terminal)\n\ngoal (1 subgoal):\n 1. terminal unity", "by (metis (mono_tags, lifting))"], ["", "text\\<open>\n      The inverse maps @{term UP} and @{term DOWN} are used to pass back and forth between\n      the inhabitants of type @{typ 'a} and the corresponding terminal objects.\n      These are exported so that a client of the theory can relate the concrete\n      element type @{typ 'a} to the otherwise abstract arrow type.\n\\<close>"], ["", "definition UP :: \"'e \\<Rightarrow> 'e setcat.arr\"\n    where \"UP x \\<equiv> MkIde {x}\""], ["", "definition DOWN :: \"'e setcat.arr \\<Rightarrow> 'e\"\n    where \"DOWN t \\<equiv> the_elem (Dom t)\""], ["", "abbreviation U\n    where \"U \\<equiv> DOWN unity\""], ["", "lemma UP_mapsto:\n    shows \"UP \\<in> UNIV \\<rightarrow> Univ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP \\<in> UNIV \\<rightarrow> Univ", "using terminal_char UP_def"], ["proof (prove)\nusing this:\n  terminal ?a = (\\<exists>x. ?a = MkIde {x})\n  UP ?x \\<equiv> MkIde {?x}\n\ngoal (1 subgoal):\n 1. UP \\<in> UNIV \\<rightarrow> Univ", "by fast"], ["", "lemma DOWN_mapsto:\n    shows \"DOWN \\<in> Univ \\<rightarrow> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DOWN \\<in> Univ \\<rightarrow> UNIV", "by auto"], ["", "lemma DOWN_UP [simp]:\n    shows \"DOWN (UP x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DOWN (UP x) = x", "by (simp add: DOWN_def UP_def)"], ["", "lemma UP_DOWN [simp]:\n    assumes \"t \\<in> Univ\"\n    shows \"UP (DOWN t) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP (DOWN t) = t", "using assms terminal_char UP_def DOWN_def"], ["proof (prove)\nusing this:\n  t \\<in> Univ\n  terminal ?a = (\\<exists>x. ?a = MkIde {x})\n  UP ?x \\<equiv> MkIde {?x}\n  DOWN ?t \\<equiv> the_elem (Dom ?t)\n\ngoal (1 subgoal):\n 1. UP (DOWN t) = t", "by (metis (mono_tags, lifting) mem_Collect_eq DOWN_UP)"], ["", "lemma inj_UP:\n    shows \"inj UP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj UP", "by (metis DOWN_UP injI)"], ["", "lemma bij_UP:\n    shows \"bij_betw UP UNIV Univ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw UP UNIV Univ", "proof (intro bij_betwI)"], ["proof (state)\ngoal (4 subgoals):\n 1. UP \\<in> UNIV \\<rightarrow> Univ\n 2. ?g \\<in> Univ \\<rightarrow> UNIV\n 3. \\<And>x. x \\<in> UNIV \\<Longrightarrow> ?g (UP x) = x\n 4. \\<And>y. y \\<in> Univ \\<Longrightarrow> UP (?g y) = y", "interpret category comp"], ["proof (prove)\ngoal (1 subgoal):\n 1. category (\\<cdot>)", "using is_category"], ["proof (prove)\nusing this:\n  category (\\<cdot>)\n\ngoal (1 subgoal):\n 1. category (\\<cdot>)", "by auto"], ["proof (state)\ngoal (4 subgoals):\n 1. UP \\<in> UNIV \\<rightarrow> Univ\n 2. ?g \\<in> Univ \\<rightarrow> UNIV\n 3. \\<And>x. x \\<in> UNIV \\<Longrightarrow> ?g (UP x) = x\n 4. \\<And>y. y \\<in> Univ \\<Longrightarrow> UP (?g y) = y", "show DOWN_UP: \"\\<And>x :: 'e. DOWN (UP x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. DOWN (UP x) = x", "by simp"], ["proof (state)\nthis:\n  DOWN (UP ?x) = ?x\n\ngoal (3 subgoals):\n 1. UP \\<in> UNIV \\<rightarrow> Univ\n 2. DOWN \\<in> Univ \\<rightarrow> UNIV\n 3. \\<And>y. y \\<in> Univ \\<Longrightarrow> UP (DOWN y) = y", "show UP_DOWN: \"\\<And>t. t \\<in> Univ \\<Longrightarrow> UP (DOWN t) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> Univ \\<Longrightarrow> UP (DOWN t) = t", "by simp"], ["proof (state)\nthis:\n  ?t \\<in> Univ \\<Longrightarrow> UP (DOWN ?t) = ?t\n\ngoal (2 subgoals):\n 1. UP \\<in> UNIV \\<rightarrow> Univ\n 2. DOWN \\<in> Univ \\<rightarrow> UNIV", "show \"UP \\<in> UNIV \\<rightarrow> Univ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP \\<in> UNIV \\<rightarrow> Univ", "using UP_mapsto"], ["proof (prove)\nusing this:\n  UP \\<in> UNIV \\<rightarrow> Univ\n\ngoal (1 subgoal):\n 1. UP \\<in> UNIV \\<rightarrow> Univ", "by auto"], ["proof (state)\nthis:\n  UP \\<in> UNIV \\<rightarrow> Univ\n\ngoal (1 subgoal):\n 1. DOWN \\<in> Univ \\<rightarrow> UNIV", "show \"DOWN \\<in> Collect terminal \\<rightarrow> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DOWN \\<in> Univ \\<rightarrow> UNIV", "by auto"], ["proof (state)\nthis:\n  DOWN \\<in> Univ \\<rightarrow> UNIV\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Dom_terminal:\n    assumes \"terminal t\"\n    shows \"Dom t = {DOWN t}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dom t = {DOWN t}", "using assms UP_def"], ["proof (prove)\nusing this:\n  terminal t\n  UP ?x \\<equiv> MkIde {?x}\n\ngoal (1 subgoal):\n 1. Dom t = {DOWN t}", "by (metis (mono_tags, lifting) Dom.simps(1) DOWN_def terminal_char the_elem_eq)"], ["", "text\\<open>\n      The image of a point @{term \"p \\<in> hom unity a\"} is a terminal object, which is given\n      by the formula @{term \"(UP o Fun p o DOWN) unity\"}.\n\\<close>"], ["", "lemma IMG_point:\n    assumes \"\\<guillemotleft>p : unity \\<rightarrow> a\\<guillemotright>\"\n    shows \"IMG \\<in> hom unity a \\<rightarrow> Univ\"\n    and \"IMG p = (UP o Map p o DOWN) unity\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IMG \\<in> hom unity a \\<rightarrow> Univ &&&\n    IMG p = (UP \\<circ> Map p \\<circ> DOWN) unity", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. IMG \\<in> hom unity a \\<rightarrow> Univ\n 2. IMG p = (UP \\<circ> Map p \\<circ> DOWN) unity", "show \"IMG \\<in> hom unity a \\<rightarrow> Univ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IMG \\<in> hom unity a \\<rightarrow> Univ", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> hom unity a \\<Longrightarrow> IMG x \\<in> Univ", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> hom unity a \\<Longrightarrow> IMG x \\<in> Univ", "assume f: \"f \\<in> hom unity a\""], ["proof (state)\nthis:\n  f \\<in> hom unity a\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> hom unity a \\<Longrightarrow> IMG x \\<in> Univ", "have \"terminal (MkIde (Map f ` Dom unity))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminal (MkIde (Map f ` Dom unity))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. terminal (MkIde (Map f ` Dom unity))", "obtain u :: 'e where u: \"unity = MkIde {u}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>u. unity = MkIde {u} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using terminal_unity terminal_char"], ["proof (prove)\nusing this:\n  terminal unity\n  terminal ?a = (\\<exists>x. ?a = MkIde {x})\n\ngoal (1 subgoal):\n 1. (\\<And>u. unity = MkIde {u} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (metis (mono_tags, lifting))"], ["proof (state)\nthis:\n  unity = MkIde {u}\n\ngoal (1 subgoal):\n 1. terminal (MkIde (Map f ` Dom unity))", "have \"Map f ` Dom unity = {Map f u}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Map f ` Dom unity = {Map f u}", "using u"], ["proof (prove)\nusing this:\n  unity = MkIde {u}\n\ngoal (1 subgoal):\n 1. Map f ` Dom unity = {Map f u}", "by simp"], ["proof (state)\nthis:\n  Map f ` Dom unity = {Map f u}\n\ngoal (1 subgoal):\n 1. terminal (MkIde (Map f ` Dom unity))", "thus ?thesis"], ["proof (prove)\nusing this:\n  Map f ` Dom unity = {Map f u}\n\ngoal (1 subgoal):\n 1. terminal (MkIde (Map f ` Dom unity))", "using terminal_char"], ["proof (prove)\nusing this:\n  Map f ` Dom unity = {Map f u}\n  terminal ?a = (\\<exists>x. ?a = MkIde {x})\n\ngoal (1 subgoal):\n 1. terminal (MkIde (Map f ` Dom unity))", "by auto"], ["proof (state)\nthis:\n  terminal (MkIde (Map f ` Dom unity))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  terminal (MkIde (Map f ` Dom unity))\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> hom unity a \\<Longrightarrow> IMG x \\<in> Univ", "hence \"MkIde (Map f ` Dom unity) \\<in> Univ\""], ["proof (prove)\nusing this:\n  terminal (MkIde (Map f ` Dom unity))\n\ngoal (1 subgoal):\n 1. MkIde (Map f ` Dom unity) \\<in> Univ", "by simp"], ["proof (state)\nthis:\n  MkIde (Map f ` Dom unity) \\<in> Univ\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> hom unity a \\<Longrightarrow> IMG x \\<in> Univ", "moreover"], ["proof (state)\nthis:\n  MkIde (Map f ` Dom unity) \\<in> Univ\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> hom unity a \\<Longrightarrow> IMG x \\<in> Univ", "have \"MkIde (Map f ` Dom unity) = IMG f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MkIde (Map f ` Dom unity) = IMG f", "using f IMG_def in_hom_char"], ["proof (prove)\nusing this:\n  f \\<in> hom unity a\n  IMG ?f = MkIde (Map ?f ` Dom ?f)\n  \\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright> =\n  (arr ?f \\<and>\n   ide ?a \\<and> ide ?b \\<and> Dom ?f = Dom ?a \\<and> Cod ?f = Dom ?b)\n\ngoal (1 subgoal):\n 1. MkIde (Map f ` Dom unity) = IMG f", "by (metis (mono_tags, lifting) mem_Collect_eq)"], ["proof (state)\nthis:\n  MkIde (Map f ` Dom unity) = IMG f\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> hom unity a \\<Longrightarrow> IMG x \\<in> Univ", "ultimately"], ["proof (chain)\npicking this:\n  MkIde (Map f ` Dom unity) \\<in> Univ\n  MkIde (Map f ` Dom unity) = IMG f", "show \"IMG f \\<in> Univ\""], ["proof (prove)\nusing this:\n  MkIde (Map f ` Dom unity) \\<in> Univ\n  MkIde (Map f ` Dom unity) = IMG f\n\ngoal (1 subgoal):\n 1. IMG f \\<in> Univ", "by auto"], ["proof (state)\nthis:\n  IMG f \\<in> Univ\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  IMG \\<in> hom unity a \\<rightarrow> Univ\n\ngoal (1 subgoal):\n 1. IMG p = (UP \\<circ> Map p \\<circ> DOWN) unity", "have \"IMG p = MkIde (Map p ` Dom p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IMG p = MkIde (Map p ` Dom p)", "using IMG_def"], ["proof (prove)\nusing this:\n  IMG ?f = MkIde (Map ?f ` Dom ?f)\n\ngoal (1 subgoal):\n 1. IMG p = MkIde (Map p ` Dom p)", "by blast"], ["proof (state)\nthis:\n  IMG p = MkIde (Map p ` Dom p)\n\ngoal (1 subgoal):\n 1. IMG p = (UP \\<circ> Map p \\<circ> DOWN) unity", "also"], ["proof (state)\nthis:\n  IMG p = MkIde (Map p ` Dom p)\n\ngoal (1 subgoal):\n 1. IMG p = (UP \\<circ> Map p \\<circ> DOWN) unity", "have \"... = MkIde (Map p ` {U})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MkIde (Map p ` Dom p) = MkIde (Map p ` {U})", "using assms in_hom_char terminal_unity Dom_terminal"], ["proof (prove)\nusing this:\n  \\<guillemotleft>p : unity \\<rightarrow> a\\<guillemotright>\n  \\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright> =\n  (arr ?f \\<and>\n   ide ?a \\<and> ide ?b \\<and> Dom ?f = Dom ?a \\<and> Cod ?f = Dom ?b)\n  terminal unity\n  terminal ?t \\<Longrightarrow> Dom ?t = {DOWN ?t}\n\ngoal (1 subgoal):\n 1. MkIde (Map p ` Dom p) = MkIde (Map p ` {U})", "by (metis (mono_tags, lifting))"], ["proof (state)\nthis:\n  MkIde (Map p ` Dom p) = MkIde (Map p ` {U})\n\ngoal (1 subgoal):\n 1. IMG p = (UP \\<circ> Map p \\<circ> DOWN) unity", "also"], ["proof (state)\nthis:\n  MkIde (Map p ` Dom p) = MkIde (Map p ` {U})\n\ngoal (1 subgoal):\n 1. IMG p = (UP \\<circ> Map p \\<circ> DOWN) unity", "have \"... = (UP o Map p o DOWN) unity\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MkIde (Map p ` {U}) = (UP \\<circ> Map p \\<circ> DOWN) unity", "by (simp add: UP_def)"], ["proof (state)\nthis:\n  MkIde (Map p ` {U}) = (UP \\<circ> Map p \\<circ> DOWN) unity\n\ngoal (1 subgoal):\n 1. IMG p = (UP \\<circ> Map p \\<circ> DOWN) unity", "finally"], ["proof (chain)\npicking this:\n  IMG p = (UP \\<circ> Map p \\<circ> DOWN) unity", "show \"IMG p = (UP o Map p o DOWN) unity\""], ["proof (prove)\nusing this:\n  IMG p = (UP \\<circ> Map p \\<circ> DOWN) unity\n\ngoal (1 subgoal):\n 1. IMG p = (UP \\<circ> Map p \\<circ> DOWN) unity", "using assms"], ["proof (prove)\nusing this:\n  IMG p = (UP \\<circ> Map p \\<circ> DOWN) unity\n  \\<guillemotleft>p : unity \\<rightarrow> a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. IMG p = (UP \\<circ> Map p \\<circ> DOWN) unity", "by auto"], ["proof (state)\nthis:\n  IMG p = (UP \\<circ> Map p \\<circ> DOWN) unity\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n      The function @{term IMG} is injective on @{term \"hom unity a\"} and its inverse takes\n      a terminal object @{term t} to the arrow in @{term \"hom unity a\"} corresponding to the\n      constant-@{term t} function.\n\\<close>"], ["", "abbreviation MkElem :: \"'e setcat.arr => 'e setcat.arr => 'e setcat.arr\"\n    where \"MkElem t a \\<equiv> MkArr {U} (Dom a) (\\<lambda>_ \\<in> {U}. DOWN t)\""], ["", "lemma MkElem_in_hom:\n    assumes \"arr f\" and \"x \\<in> Dom f\"\n    shows \"\\<guillemotleft>MkElem (UP x) (dom f) : unity \\<rightarrow> dom f\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>MkArr {U} (Dom (local.dom f))\n                     (\\<lambda>_\\<in>{U}.\n                         DOWN\n                          (UP x)) : unity \\<rightarrow> local.dom\n                   f\\<guillemotright>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<guillemotleft>MkArr {U} (Dom (local.dom f))\n                     (\\<lambda>_\\<in>{U}.\n                         DOWN\n                          (UP x)) : unity \\<rightarrow> local.dom\n                   f\\<guillemotright>", "have \"(\\<lambda>_ \\<in> {U}. DOWN (UP x)) \\<in> {U} \\<rightarrow> Dom (dom f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>_\\<in>{U}. DOWN (UP x))\n    \\<in> {U} \\<rightarrow> Dom (local.dom f)", "using assms dom_char [of f]"], ["proof (prove)\nusing this:\n  arr f\n  x \\<in> Dom f\n  local.dom f = (if arr f then MkIde (Dom f) else null)\n\ngoal (1 subgoal):\n 1. (\\<lambda>_\\<in>{U}. DOWN (UP x))\n    \\<in> {U} \\<rightarrow> Dom (local.dom f)", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>_\\<in>{U}. DOWN (UP x))\n  \\<in> {U} \\<rightarrow> Dom (local.dom f)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>MkArr {U} (Dom (local.dom f))\n                     (\\<lambda>_\\<in>{U}.\n                         DOWN\n                          (UP x)) : unity \\<rightarrow> local.dom\n                   f\\<guillemotright>", "moreover"], ["proof (state)\nthis:\n  (\\<lambda>_\\<in>{U}. DOWN (UP x))\n  \\<in> {U} \\<rightarrow> Dom (local.dom f)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>MkArr {U} (Dom (local.dom f))\n                     (\\<lambda>_\\<in>{U}.\n                         DOWN\n                          (UP x)) : unity \\<rightarrow> local.dom\n                   f\\<guillemotright>", "have \"MkIde {U} = unity\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MkIde {U} = unity", "using terminal_char terminal_unity"], ["proof (prove)\nusing this:\n  terminal ?a = (\\<exists>x. ?a = MkIde {x})\n  terminal unity\n\ngoal (1 subgoal):\n 1. MkIde {U} = unity", "by (metis (mono_tags, lifting) DOWN_UP UP_def)"], ["proof (state)\nthis:\n  MkIde {U} = unity\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>MkArr {U} (Dom (local.dom f))\n                     (\\<lambda>_\\<in>{U}.\n                         DOWN\n                          (UP x)) : unity \\<rightarrow> local.dom\n                   f\\<guillemotright>", "moreover"], ["proof (state)\nthis:\n  MkIde {U} = unity\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>MkArr {U} (Dom (local.dom f))\n                     (\\<lambda>_\\<in>{U}.\n                         DOWN\n                          (UP x)) : unity \\<rightarrow> local.dom\n                   f\\<guillemotright>", "have \"MkIde (Dom (dom f)) = dom f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MkIde (Dom (local.dom f)) = local.dom f", "using assms dom_char MkIde_Dom' ide_dom"], ["proof (prove)\nusing this:\n  arr f\n  x \\<in> Dom f\n  local.dom ?f = (if arr ?f then MkIde (Dom ?f) else null)\n  ide ?a \\<Longrightarrow> MkIde (Dom ?a) = ?a\n  arr ?f \\<Longrightarrow> ide (local.dom ?f)\n\ngoal (1 subgoal):\n 1. MkIde (Dom (local.dom f)) = local.dom f", "by blast"], ["proof (state)\nthis:\n  MkIde (Dom (local.dom f)) = local.dom f\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>MkArr {U} (Dom (local.dom f))\n                     (\\<lambda>_\\<in>{U}.\n                         DOWN\n                          (UP x)) : unity \\<rightarrow> local.dom\n                   f\\<guillemotright>", "ultimately"], ["proof (chain)\npicking this:\n  (\\<lambda>_\\<in>{U}. DOWN (UP x))\n  \\<in> {U} \\<rightarrow> Dom (local.dom f)\n  MkIde {U} = unity\n  MkIde (Dom (local.dom f)) = local.dom f", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>_\\<in>{U}. DOWN (UP x))\n  \\<in> {U} \\<rightarrow> Dom (local.dom f)\n  MkIde {U} = unity\n  MkIde (Dom (local.dom f)) = local.dom f\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>MkArr {U} (Dom (local.dom f))\n                     (\\<lambda>_\\<in>{U}.\n                         DOWN\n                          (UP x)) : unity \\<rightarrow> local.dom\n                   f\\<guillemotright>", "using assms MkArr_in_hom [of \"{U}\" \"Dom (dom f)\" \"\\<lambda>_ \\<in> {U}. DOWN (UP x)\"]"], ["proof (prove)\nusing this:\n  (\\<lambda>_\\<in>{U}. DOWN (UP x))\n  \\<in> {U} \\<rightarrow> Dom (local.dom f)\n  MkIde {U} = unity\n  MkIde (Dom (local.dom f)) = local.dom f\n  arr f\n  x \\<in> Dom f\n  \\<lbrakk>{U} \\<in> {A. |A| <o \\<AA>};\n   Dom (local.dom f) \\<in> {A. |A| <o \\<AA>};\n   (\\<lambda>_\\<in>{U}. DOWN (UP x))\n   \\<in> extensional {U} \\<inter>\n         ({U} \\<rightarrow> Dom (local.dom f))\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>MkArr {U} (Dom (local.dom f))\n                                     (\\<lambda>_\\<in>{U}.\n   DOWN\n    (UP x)) : MkIde\n               {U} \\<rightarrow> MkIde (Dom (local.dom f))\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>MkArr {U} (Dom (local.dom f))\n                     (\\<lambda>_\\<in>{U}.\n                         DOWN\n                          (UP x)) : unity \\<rightarrow> local.dom\n                   f\\<guillemotright>", "by (metis (no_types, lifting) Dom.simps(1) Dom_in_Obj IntI arr_dom ideD(1)\n            restrict_extensional terminal_def terminal_unity)"], ["proof (state)\nthis:\n  \\<guillemotleft>MkArr {U} (Dom (local.dom f))\n                   (\\<lambda>_\\<in>{U}.\n                       DOWN\n                        (UP x)) : unity \\<rightarrow> local.dom\n                 f\\<guillemotright>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma MkElem_IMG:\n    assumes \"p \\<in> hom unity a\"\n    shows \"MkElem (IMG p) a = p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (IMG p)) = p", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (IMG p)) = p", "have 0: \"IMG p = UP (Map p U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IMG p = UP (Map p U)", "using assms IMG_point(2)"], ["proof (prove)\nusing this:\n  p \\<in> hom unity a\n  \\<guillemotleft>?p : unity \\<rightarrow> ?a\\<guillemotright> \\<Longrightarrow>\n  IMG ?p = (UP \\<circ> Map ?p \\<circ> DOWN) unity\n\ngoal (1 subgoal):\n 1. IMG p = UP (Map p U)", "by auto"], ["proof (state)\nthis:\n  IMG p = UP (Map p U)\n\ngoal (1 subgoal):\n 1. MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (IMG p)) = p", "have 1: \"Dom p = {U}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dom p = {U}", "using assms terminal_unity Dom_terminal"], ["proof (prove)\nusing this:\n  p \\<in> hom unity a\n  terminal unity\n  terminal ?t \\<Longrightarrow> Dom ?t = {DOWN ?t}\n\ngoal (1 subgoal):\n 1. Dom p = {U}", "by (metis (mono_tags, lifting) in_hom_char mem_Collect_eq)"], ["proof (state)\nthis:\n  Dom p = {U}\n\ngoal (1 subgoal):\n 1. MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (IMG p)) = p", "moreover"], ["proof (state)\nthis:\n  Dom p = {U}\n\ngoal (1 subgoal):\n 1. MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (IMG p)) = p", "have \"Cod p = Dom a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cod p = Dom a", "using assms"], ["proof (prove)\nusing this:\n  p \\<in> hom unity a\n\ngoal (1 subgoal):\n 1. Cod p = Dom a", "by (metis (mono_tags, lifting) in_hom_char mem_Collect_eq)"], ["proof (state)\nthis:\n  Cod p = Dom a\n\ngoal (1 subgoal):\n 1. MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (IMG p)) = p", "moreover"], ["proof (state)\nthis:\n  Cod p = Dom a\n\ngoal (1 subgoal):\n 1. MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (IMG p)) = p", "have \"Map p = (\\<lambda>_ \\<in> {U}. DOWN (IMG p))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Map p = (\\<lambda>_\\<in>{U}. DOWN (IMG p))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. Map p x = (\\<lambda>_\\<in>{U}. DOWN (IMG p)) x", "fix e"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. Map p x = (\\<lambda>_\\<in>{U}. DOWN (IMG p)) x", "show \"Map p e = (\\<lambda>_ \\<in> {U}. DOWN (IMG p)) e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Map p e = (\\<lambda>_\\<in>{U}. DOWN (IMG p)) e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Map p e = (\\<lambda>_\\<in>{U}. DOWN (IMG p)) e", "have \"Map p e = (\\<lambda>x \\<in> Dom p. Map p x) e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Map p e = restrict (Map p) (Dom p) e", "using assms MkArr_expansion [of p]"], ["proof (prove)\nusing this:\n  p \\<in> hom unity a\n  arr p \\<Longrightarrow>\n  p = MkArr (Dom p) (Cod p) (restrict (Map p) (Dom p))\n\ngoal (1 subgoal):\n 1. Map p e = restrict (Map p) (Dom p) e", "by (metis (mono_tags, lifting) CollectD Map.simps(1) in_homE)"], ["proof (state)\nthis:\n  Map p e = restrict (Map p) (Dom p) e\n\ngoal (1 subgoal):\n 1. Map p e = (\\<lambda>_\\<in>{U}. DOWN (IMG p)) e", "also"], ["proof (state)\nthis:\n  Map p e = restrict (Map p) (Dom p) e\n\ngoal (1 subgoal):\n 1. Map p e = (\\<lambda>_\\<in>{U}. DOWN (IMG p)) e", "have \"... = (\\<lambda>_ \\<in> {U}. DOWN (IMG p)) e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict (Map p) (Dom p) e = (\\<lambda>_\\<in>{U}. DOWN (IMG p)) e", "using assms 0 1"], ["proof (prove)\nusing this:\n  p \\<in> hom unity a\n  IMG p = UP (Map p U)\n  Dom p = {U}\n\ngoal (1 subgoal):\n 1. restrict (Map p) (Dom p) e = (\\<lambda>_\\<in>{U}. DOWN (IMG p)) e", "by simp"], ["proof (state)\nthis:\n  restrict (Map p) (Dom p) e = (\\<lambda>_\\<in>{U}. DOWN (IMG p)) e\n\ngoal (1 subgoal):\n 1. Map p e = (\\<lambda>_\\<in>{U}. DOWN (IMG p)) e", "finally"], ["proof (chain)\npicking this:\n  Map p e = (\\<lambda>_\\<in>{U}. DOWN (IMG p)) e", "show ?thesis"], ["proof (prove)\nusing this:\n  Map p e = (\\<lambda>_\\<in>{U}. DOWN (IMG p)) e\n\ngoal (1 subgoal):\n 1. Map p e = (\\<lambda>_\\<in>{U}. DOWN (IMG p)) e", "by blast"], ["proof (state)\nthis:\n  Map p e = (\\<lambda>_\\<in>{U}. DOWN (IMG p)) e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Map p e = (\\<lambda>_\\<in>{U}. DOWN (IMG p)) e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Map p = (\\<lambda>_\\<in>{U}. DOWN (IMG p))\n\ngoal (1 subgoal):\n 1. MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (IMG p)) = p", "ultimately"], ["proof (chain)\npicking this:\n  Dom p = {U}\n  Cod p = Dom a\n  Map p = (\\<lambda>_\\<in>{U}. DOWN (IMG p))", "show \"MkElem (IMG p) a = p\""], ["proof (prove)\nusing this:\n  Dom p = {U}\n  Cod p = Dom a\n  Map p = (\\<lambda>_\\<in>{U}. DOWN (IMG p))\n\ngoal (1 subgoal):\n 1. MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (IMG p)) = p", "using assms MkArr_Map CollectD"], ["proof (prove)\nusing this:\n  Dom p = {U}\n  Cod p = Dom a\n  Map p = (\\<lambda>_\\<in>{U}. DOWN (IMG p))\n  p \\<in> hom unity a\n  arr ?f \\<Longrightarrow> MkArr (Dom ?f) (Cod ?f) (Map ?f) = ?f\n  ?a \\<in> {x. ?P x} \\<Longrightarrow> ?P ?a\n\ngoal (1 subgoal):\n 1. MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (IMG p)) = p", "by (metis (mono_tags, lifting) in_homE mem_Collect_eq)"], ["proof (state)\nthis:\n  MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (IMG p)) = p\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inj_IMG:\n    assumes \"ide a\"\n    shows \"inj_on IMG (hom unity a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on IMG (hom unity a)", "proof (intro inj_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> hom unity a; y \\<in> hom unity a;\n        IMG x = IMG y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> hom unity a; y \\<in> hom unity a;\n        IMG x = IMG y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume x: \"x \\<in> hom unity a\""], ["proof (state)\nthis:\n  x \\<in> hom unity a\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> hom unity a; y \\<in> hom unity a;\n        IMG x = IMG y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume y: \"y \\<in> hom unity a\""], ["proof (state)\nthis:\n  y \\<in> hom unity a\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> hom unity a; y \\<in> hom unity a;\n        IMG x = IMG y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume eq: \"IMG x = IMG y\""], ["proof (state)\nthis:\n  IMG x = IMG y\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> hom unity a; y \\<in> hom unity a;\n        IMG x = IMG y\\<rbrakk>\n       \\<Longrightarrow> x = y", "show \"x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y", "proof (intro arr_eqI)"], ["proof (state)\ngoal (5 subgoals):\n 1. arr x\n 2. arr y\n 3. Dom x = Dom y\n 4. Cod x = Cod y\n 5. Map x = Map y", "show \"arr x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr x", "using x"], ["proof (prove)\nusing this:\n  x \\<in> hom unity a\n\ngoal (1 subgoal):\n 1. arr x", "by blast"], ["proof (state)\nthis:\n  arr x\n\ngoal (4 subgoals):\n 1. arr y\n 2. Dom x = Dom y\n 3. Cod x = Cod y\n 4. Map x = Map y", "show \"arr y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr y", "using y"], ["proof (prove)\nusing this:\n  y \\<in> hom unity a\n\ngoal (1 subgoal):\n 1. arr y", "by blast"], ["proof (state)\nthis:\n  arr y\n\ngoal (3 subgoals):\n 1. Dom x = Dom y\n 2. Cod x = Cod y\n 3. Map x = Map y", "show \"Dom x = Dom y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dom x = Dom y", "using x y in_hom_char"], ["proof (prove)\nusing this:\n  x \\<in> hom unity a\n  y \\<in> hom unity a\n  \\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright> =\n  (arr ?f \\<and>\n   ide ?a \\<and> ide ?b \\<and> Dom ?f = Dom ?a \\<and> Cod ?f = Dom ?b)\n\ngoal (1 subgoal):\n 1. Dom x = Dom y", "by (metis (mono_tags, lifting) CollectD)"], ["proof (state)\nthis:\n  Dom x = Dom y\n\ngoal (2 subgoals):\n 1. Cod x = Cod y\n 2. Map x = Map y", "show \"Cod x = Cod y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cod x = Cod y", "using x y in_hom_char"], ["proof (prove)\nusing this:\n  x \\<in> hom unity a\n  y \\<in> hom unity a\n  \\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright> =\n  (arr ?f \\<and>\n   ide ?a \\<and> ide ?b \\<and> Dom ?f = Dom ?a \\<and> Cod ?f = Dom ?b)\n\ngoal (1 subgoal):\n 1. Cod x = Cod y", "by (metis (mono_tags, lifting) CollectD)"], ["proof (state)\nthis:\n  Cod x = Cod y\n\ngoal (1 subgoal):\n 1. Map x = Map y", "show \"Map x = Map y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Map x = Map y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Map x = Map y", "have \"\\<And>a. y \\<in> hom unity a \\<Longrightarrow> MkArr {U} (Dom a) (\\<lambda>e\\<in>{U}. DOWN (IMG x)) = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       y \\<in> hom unity a \\<Longrightarrow>\n       MkArr {U} (Dom a) (\\<lambda>e\\<in>{U}. DOWN (IMG x)) = y", "using MkElem_IMG eq"], ["proof (prove)\nusing this:\n  ?p \\<in> hom unity ?a \\<Longrightarrow>\n  MkArr {U} (Dom ?a) (\\<lambda>_\\<in>{U}. DOWN (IMG ?p)) = ?p\n  IMG x = IMG y\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       y \\<in> hom unity a \\<Longrightarrow>\n       MkArr {U} (Dom a) (\\<lambda>e\\<in>{U}. DOWN (IMG x)) = y", "by presburger"], ["proof (state)\nthis:\n  y \\<in> hom unity ?a \\<Longrightarrow>\n  MkArr {U} (Dom ?a) (\\<lambda>e\\<in>{U}. DOWN (IMG x)) = y\n\ngoal (1 subgoal):\n 1. Map x = Map y", "hence \"y = x\""], ["proof (prove)\nusing this:\n  y \\<in> hom unity ?a \\<Longrightarrow>\n  MkArr {U} (Dom ?a) (\\<lambda>e\\<in>{U}. DOWN (IMG x)) = y\n\ngoal (1 subgoal):\n 1. y = x", "using MkElem_IMG x y"], ["proof (prove)\nusing this:\n  y \\<in> hom unity ?a \\<Longrightarrow>\n  MkArr {U} (Dom ?a) (\\<lambda>e\\<in>{U}. DOWN (IMG x)) = y\n  ?p \\<in> hom unity ?a \\<Longrightarrow>\n  MkArr {U} (Dom ?a) (\\<lambda>_\\<in>{U}. DOWN (IMG ?p)) = ?p\n  x \\<in> hom unity a\n  y \\<in> hom unity a\n\ngoal (1 subgoal):\n 1. y = x", "by blast"], ["proof (state)\nthis:\n  y = x\n\ngoal (1 subgoal):\n 1. Map x = Map y", "thus ?thesis"], ["proof (prove)\nusing this:\n  y = x\n\ngoal (1 subgoal):\n 1. Map x = Map y", "by meson"], ["proof (state)\nthis:\n  Map x = Map y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Map x = Map y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_char:\n    assumes \"ide a\"\n    shows \"set a = UP ` Dom a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.set a = UP ` Dom a", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. local.set a \\<subseteq> UP ` Dom a\n 2. UP ` Dom a \\<subseteq> local.set a", "show \"set a \\<subseteq> UP ` Dom a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.set a \\<subseteq> UP ` Dom a", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> local.set a \\<Longrightarrow> x \\<in> UP ` Dom a", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> local.set a \\<Longrightarrow> x \\<in> UP ` Dom a", "assume \"t \\<in> set a\""], ["proof (state)\nthis:\n  t \\<in> local.set a\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> local.set a \\<Longrightarrow> x \\<in> UP ` Dom a", "from this"], ["proof (chain)\npicking this:\n  t \\<in> local.set a", "obtain p where p: \"\\<guillemotleft>p : unity \\<rightarrow> a\\<guillemotright> \\<and> t = IMG p\""], ["proof (prove)\nusing this:\n  t \\<in> local.set a\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<guillemotleft>p : unity \\<rightarrow> a\\<guillemotright> \\<and>\n        t = IMG p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using set_def"], ["proof (prove)\nusing this:\n  t \\<in> local.set a\n  local.set ?a = IMG ` hom unity ?a\n\ngoal (1 subgoal):\n 1. (\\<And>p.\n        \\<guillemotleft>p : unity \\<rightarrow> a\\<guillemotright> \\<and>\n        t = IMG p \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<guillemotleft>p : unity \\<rightarrow> a\\<guillemotright> \\<and>\n  t = IMG p\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> local.set a \\<Longrightarrow> x \\<in> UP ` Dom a", "have \"t = (UP o Map p o DOWN) unity\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t = (UP \\<circ> Map p \\<circ> DOWN) unity", "using p IMG_point(2)"], ["proof (prove)\nusing this:\n  \\<guillemotleft>p : unity \\<rightarrow> a\\<guillemotright> \\<and>\n  t = IMG p\n  \\<guillemotleft>?p : unity \\<rightarrow> ?a\\<guillemotright> \\<Longrightarrow>\n  IMG ?p = (UP \\<circ> Map ?p \\<circ> DOWN) unity\n\ngoal (1 subgoal):\n 1. t = (UP \\<circ> Map p \\<circ> DOWN) unity", "by blast"], ["proof (state)\nthis:\n  t = (UP \\<circ> Map p \\<circ> DOWN) unity\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> local.set a \\<Longrightarrow> x \\<in> UP ` Dom a", "moreover"], ["proof (state)\nthis:\n  t = (UP \\<circ> Map p \\<circ> DOWN) unity\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> local.set a \\<Longrightarrow> x \\<in> UP ` Dom a", "have \"(Map p o DOWN) unity \\<in> Dom a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Map p \\<circ> DOWN) unity \\<in> Dom a", "using p arr_char in_hom_char Dom_terminal terminal_unity"], ["proof (prove)\nusing this:\n  \\<guillemotleft>p : unity \\<rightarrow> a\\<guillemotright> \\<and>\n  t = IMG p\n  arr ?f =\n  (?f \\<noteq> Null \\<and>\n   |Dom ?f| <o \\<AA> \\<and>\n   |Cod ?f| <o \\<AA> \\<and>\n   Map ?f \\<in> extensional (Dom ?f) \\<inter> (Dom ?f \\<rightarrow> Cod ?f))\n  \\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright> =\n  (arr ?f \\<and>\n   ide ?a \\<and> ide ?b \\<and> Dom ?f = Dom ?a \\<and> Cod ?f = Dom ?b)\n  terminal ?t \\<Longrightarrow> Dom ?t = {DOWN ?t}\n  terminal unity\n\ngoal (1 subgoal):\n 1. (Map p \\<circ> DOWN) unity \\<in> Dom a", "by (metis (mono_tags, lifting) IntD2 Pi_split_insert_domain o_apply)"], ["proof (state)\nthis:\n  (Map p \\<circ> DOWN) unity \\<in> Dom a\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> local.set a \\<Longrightarrow> x \\<in> UP ` Dom a", "ultimately"], ["proof (chain)\npicking this:\n  t = (UP \\<circ> Map p \\<circ> DOWN) unity\n  (Map p \\<circ> DOWN) unity \\<in> Dom a", "show \"t \\<in> UP ` Dom a\""], ["proof (prove)\nusing this:\n  t = (UP \\<circ> Map p \\<circ> DOWN) unity\n  (Map p \\<circ> DOWN) unity \\<in> Dom a\n\ngoal (1 subgoal):\n 1. t \\<in> UP ` Dom a", "by simp"], ["proof (state)\nthis:\n  t \\<in> UP ` Dom a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.set a \\<subseteq> UP ` Dom a\n\ngoal (1 subgoal):\n 1. UP ` Dom a \\<subseteq> local.set a", "show \"UP ` Dom a \\<subseteq> set a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP ` Dom a \\<subseteq> local.set a", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> UP ` Dom a \\<Longrightarrow> x \\<in> local.set a", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> UP ` Dom a \\<Longrightarrow> x \\<in> local.set a", "assume \"t \\<in> UP ` Dom a\""], ["proof (state)\nthis:\n  t \\<in> UP ` Dom a\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> UP ` Dom a \\<Longrightarrow> x \\<in> local.set a", "from this"], ["proof (chain)\npicking this:\n  t \\<in> UP ` Dom a", "obtain x where x: \"x \\<in> Dom a \\<and> t = UP x\""], ["proof (prove)\nusing this:\n  t \\<in> UP ` Dom a\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        x \\<in> Dom a \\<and> t = UP x \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  x \\<in> Dom a \\<and> t = UP x\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> UP ` Dom a \\<Longrightarrow> x \\<in> local.set a", "let ?p = \"MkElem (UP x) a\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> UP ` Dom a \\<Longrightarrow> x \\<in> local.set a", "have p: \"?p \\<in> hom unity a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)) \\<in> hom unity a", "using assms x MkElem_in_hom [of \"dom a\"] ideD(1-2)"], ["proof (prove)\nusing this:\n  ide a\n  x \\<in> Dom a \\<and> t = UP x\n  \\<lbrakk>arr (local.dom a); ?x \\<in> Dom (local.dom a)\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>MkArr {U}\n                                     (Dom (local.dom (local.dom a)))\n                                     (\\<lambda>_\\<in>{U}.\n   DOWN\n    (UP ?x)) : unity \\<rightarrow> local.dom (local.dom a)\\<guillemotright>\n  ide ?a \\<Longrightarrow> arr ?a\n  ide ?a \\<Longrightarrow> local.dom ?a = ?a\n\ngoal (1 subgoal):\n 1. MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)) \\<in> hom unity a", "by force"], ["proof (state)\nthis:\n  MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)) \\<in> hom unity a\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> UP ` Dom a \\<Longrightarrow> x \\<in> local.set a", "moreover"], ["proof (state)\nthis:\n  MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)) \\<in> hom unity a\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> UP ` Dom a \\<Longrightarrow> x \\<in> local.set a", "have \"IMG ?p = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IMG (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))) = t", "using p x DOWN_UP IMG_def UP_def"], ["proof (prove)\nusing this:\n  MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)) \\<in> hom unity a\n  x \\<in> Dom a \\<and> t = UP x\n  DOWN (UP ?x) = ?x\n  IMG ?f = MkIde (Map ?f ` Dom ?f)\n  UP ?x \\<equiv> MkIde {?x}\n\ngoal (1 subgoal):\n 1. IMG (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))) = t", "by (metis (no_types, lifting) Dom.simps(1) Map.simps(1) image_empty\n              image_insert image_restrict_eq)"], ["proof (state)\nthis:\n  IMG (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))) = t\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> UP ` Dom a \\<Longrightarrow> x \\<in> local.set a", "ultimately"], ["proof (chain)\npicking this:\n  MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)) \\<in> hom unity a\n  IMG (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))) = t", "show \"t \\<in> set a\""], ["proof (prove)\nusing this:\n  MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)) \\<in> hom unity a\n  IMG (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))) = t\n\ngoal (1 subgoal):\n 1. t \\<in> local.set a", "using set_def"], ["proof (prove)\nusing this:\n  MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)) \\<in> hom unity a\n  IMG (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))) = t\n  local.set ?a = IMG ` hom unity ?a\n\ngoal (1 subgoal):\n 1. t \\<in> local.set a", "by blast"], ["proof (state)\nthis:\n  t \\<in> local.set a\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  UP ` Dom a \\<subseteq> local.set a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Map_via_comp:\n    assumes \"arr f\"\n    shows \"Map f = (\\<lambda>x \\<in> Dom f. Map (f \\<cdot> MkElem (UP x) (dom f)) U)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Map f =\n    (\\<lambda>x\\<in>Dom f.\n        Map (f \\<cdot>\n             MkArr {U} (Dom (local.dom f))\n              (\\<lambda>_\\<in>{U}. DOWN (UP x)))\n         U)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       Map f x =\n       (\\<lambda>x\\<in>Dom f.\n           Map (f \\<cdot>\n                MkArr {U} (Dom (local.dom f))\n                 (\\<lambda>_\\<in>{U}. DOWN (UP x)))\n            U)\n        x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       Map f x =\n       (\\<lambda>x\\<in>Dom f.\n           Map (f \\<cdot>\n                MkArr {U} (Dom (local.dom f))\n                 (\\<lambda>_\\<in>{U}. DOWN (UP x)))\n            U)\n        x", "have \"x \\<notin> Dom f \\<Longrightarrow> Map f x = (\\<lambda>x \\<in> Dom f. Map (f \\<cdot> MkElem (UP x) (dom f)) U) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> Dom f \\<Longrightarrow>\n    Map f x =\n    (\\<lambda>x\\<in>Dom f.\n        Map (f \\<cdot>\n             MkArr {U} (Dom (local.dom f))\n              (\\<lambda>_\\<in>{U}. DOWN (UP x)))\n         U)\n     x", "using assms arr_char [of f] IntD1 extensional_arb restrict_apply"], ["proof (prove)\nusing this:\n  arr f\n  arr f =\n  (f \\<noteq> Null \\<and>\n   |Dom f| <o \\<AA> \\<and>\n   |Cod f| <o \\<AA> \\<and>\n   Map f \\<in> extensional (Dom f) \\<inter> (Dom f \\<rightarrow> Cod f))\n  ?c \\<in> ?A \\<inter> ?B \\<Longrightarrow> ?c \\<in> ?A\n  \\<lbrakk>?f \\<in> extensional ?A; ?x \\<notin> ?A\\<rbrakk>\n  \\<Longrightarrow> ?f ?x = undefined\n  restrict ?f ?A ?x = (if ?x \\<in> ?A then ?f ?x else undefined)\n\ngoal (1 subgoal):\n 1. x \\<notin> Dom f \\<Longrightarrow>\n    Map f x =\n    (\\<lambda>x\\<in>Dom f.\n        Map (f \\<cdot>\n             MkArr {U} (Dom (local.dom f))\n              (\\<lambda>_\\<in>{U}. DOWN (UP x)))\n         U)\n     x", "by fastforce"], ["proof (state)\nthis:\n  x \\<notin> Dom f \\<Longrightarrow>\n  Map f x =\n  (\\<lambda>x\\<in>Dom f.\n      Map (f \\<cdot>\n           MkArr {U} (Dom (local.dom f)) (\\<lambda>_\\<in>{U}. DOWN (UP x)))\n       U)\n   x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       Map f x =\n       (\\<lambda>x\\<in>Dom f.\n           Map (f \\<cdot>\n                MkArr {U} (Dom (local.dom f))\n                 (\\<lambda>_\\<in>{U}. DOWN (UP x)))\n            U)\n        x", "moreover"], ["proof (state)\nthis:\n  x \\<notin> Dom f \\<Longrightarrow>\n  Map f x =\n  (\\<lambda>x\\<in>Dom f.\n      Map (f \\<cdot>\n           MkArr {U} (Dom (local.dom f)) (\\<lambda>_\\<in>{U}. DOWN (UP x)))\n       U)\n   x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       Map f x =\n       (\\<lambda>x\\<in>Dom f.\n           Map (f \\<cdot>\n                MkArr {U} (Dom (local.dom f))\n                 (\\<lambda>_\\<in>{U}. DOWN (UP x)))\n            U)\n        x", "have\n           \"x \\<in> Dom f \\<Longrightarrow> Map f x = (\\<lambda>x \\<in> Dom f. Map (f \\<cdot> MkElem (UP x) (dom f)) U) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Dom f \\<Longrightarrow>\n    Map f x =\n    (\\<lambda>x\\<in>Dom f.\n        Map (f \\<cdot>\n             MkArr {U} (Dom (local.dom f))\n              (\\<lambda>_\\<in>{U}. DOWN (UP x)))\n         U)\n     x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> Dom f \\<Longrightarrow>\n    Map f x =\n    (\\<lambda>x\\<in>Dom f.\n        Map (f \\<cdot>\n             MkArr {U} (Dom (local.dom f))\n              (\\<lambda>_\\<in>{U}. DOWN (UP x)))\n         U)\n     x", "assume x: \"x \\<in> Dom f\""], ["proof (state)\nthis:\n  x \\<in> Dom f\n\ngoal (1 subgoal):\n 1. x \\<in> Dom f \\<Longrightarrow>\n    Map f x =\n    (\\<lambda>x\\<in>Dom f.\n        Map (f \\<cdot>\n             MkArr {U} (Dom (local.dom f))\n              (\\<lambda>_\\<in>{U}. DOWN (UP x)))\n         U)\n     x", "let ?X = \"MkElem (UP x) (dom f)\""], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> Dom f \\<Longrightarrow>\n    Map f x =\n    (\\<lambda>x\\<in>Dom f.\n        Map (f \\<cdot>\n             MkArr {U} (Dom (local.dom f))\n              (\\<lambda>_\\<in>{U}. DOWN (UP x)))\n         U)\n     x", "have \"\\<guillemotleft>?X : unity \\<rightarrow> dom f\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>MkArr {U} (Dom (local.dom f))\n                     (\\<lambda>_\\<in>{U}.\n                         DOWN\n                          (UP x)) : unity \\<rightarrow> local.dom\n                   f\\<guillemotright>", "using assms x MkElem_in_hom"], ["proof (prove)\nusing this:\n  arr f\n  x \\<in> Dom f\n  \\<lbrakk>arr ?f; ?x \\<in> Dom ?f\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>MkArr {U} (Dom (local.dom ?f))\n                                     (\\<lambda>_\\<in>{U}.\n   DOWN (UP ?x)) : unity \\<rightarrow> local.dom ?f\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>MkArr {U} (Dom (local.dom f))\n                     (\\<lambda>_\\<in>{U}.\n                         DOWN\n                          (UP x)) : unity \\<rightarrow> local.dom\n                   f\\<guillemotright>", "by auto"], ["proof (state)\nthis:\n  \\<guillemotleft>MkArr {U} (Dom (local.dom f))\n                   (\\<lambda>_\\<in>{U}.\n                       DOWN\n                        (UP x)) : unity \\<rightarrow> local.dom\n                 f\\<guillemotright>\n\ngoal (1 subgoal):\n 1. x \\<in> Dom f \\<Longrightarrow>\n    Map f x =\n    (\\<lambda>x\\<in>Dom f.\n        Map (f \\<cdot>\n             MkArr {U} (Dom (local.dom f))\n              (\\<lambda>_\\<in>{U}. DOWN (UP x)))\n         U)\n     x", "moreover"], ["proof (state)\nthis:\n  \\<guillemotleft>MkArr {U} (Dom (local.dom f))\n                   (\\<lambda>_\\<in>{U}.\n                       DOWN\n                        (UP x)) : unity \\<rightarrow> local.dom\n                 f\\<guillemotright>\n\ngoal (1 subgoal):\n 1. x \\<in> Dom f \\<Longrightarrow>\n    Map f x =\n    (\\<lambda>x\\<in>Dom f.\n        Map (f \\<cdot>\n             MkArr {U} (Dom (local.dom f))\n              (\\<lambda>_\\<in>{U}. DOWN (UP x)))\n         U)\n     x", "have \"Dom ?X = {U} \\<and> Map ?X = (\\<lambda>_ \\<in> {U}. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dom (MkArr {U} (Dom (local.dom f)) (\\<lambda>_\\<in>{U}. DOWN (UP x))) =\n    {U} \\<and>\n    Map (MkArr {U} (Dom (local.dom f)) (\\<lambda>_\\<in>{U}. DOWN (UP x))) =\n    (\\<lambda>_\\<in>{U}. x)", "using x"], ["proof (prove)\nusing this:\n  x \\<in> Dom f\n\ngoal (1 subgoal):\n 1. Dom (MkArr {U} (Dom (local.dom f)) (\\<lambda>_\\<in>{U}. DOWN (UP x))) =\n    {U} \\<and>\n    Map (MkArr {U} (Dom (local.dom f)) (\\<lambda>_\\<in>{U}. DOWN (UP x))) =\n    (\\<lambda>_\\<in>{U}. x)", "by simp"], ["proof (state)\nthis:\n  Dom (MkArr {U} (Dom (local.dom f)) (\\<lambda>_\\<in>{U}. DOWN (UP x))) =\n  {U} \\<and>\n  Map (MkArr {U} (Dom (local.dom f)) (\\<lambda>_\\<in>{U}. DOWN (UP x))) =\n  (\\<lambda>_\\<in>{U}. x)\n\ngoal (1 subgoal):\n 1. x \\<in> Dom f \\<Longrightarrow>\n    Map f x =\n    (\\<lambda>x\\<in>Dom f.\n        Map (f \\<cdot>\n             MkArr {U} (Dom (local.dom f))\n              (\\<lambda>_\\<in>{U}. DOWN (UP x)))\n         U)\n     x", "ultimately"], ["proof (chain)\npicking this:\n  \\<guillemotleft>MkArr {U} (Dom (local.dom f))\n                   (\\<lambda>_\\<in>{U}.\n                       DOWN\n                        (UP x)) : unity \\<rightarrow> local.dom\n                 f\\<guillemotright>\n  Dom (MkArr {U} (Dom (local.dom f)) (\\<lambda>_\\<in>{U}. DOWN (UP x))) =\n  {U} \\<and>\n  Map (MkArr {U} (Dom (local.dom f)) (\\<lambda>_\\<in>{U}. DOWN (UP x))) =\n  (\\<lambda>_\\<in>{U}. x)", "have\n          \"Map (f \\<cdot> MkElem (UP x) (dom f)) = compose {U} (Map f) (\\<lambda>_ \\<in> {U}. x)\""], ["proof (prove)\nusing this:\n  \\<guillemotleft>MkArr {U} (Dom (local.dom f))\n                   (\\<lambda>_\\<in>{U}.\n                       DOWN\n                        (UP x)) : unity \\<rightarrow> local.dom\n                 f\\<guillemotright>\n  Dom (MkArr {U} (Dom (local.dom f)) (\\<lambda>_\\<in>{U}. DOWN (UP x))) =\n  {U} \\<and>\n  Map (MkArr {U} (Dom (local.dom f)) (\\<lambda>_\\<in>{U}. DOWN (UP x))) =\n  (\\<lambda>_\\<in>{U}. x)\n\ngoal (1 subgoal):\n 1. Map (f \\<cdot>\n         MkArr {U} (Dom (local.dom f)) (\\<lambda>_\\<in>{U}. DOWN (UP x))) =\n    compose {U} (Map f) (\\<lambda>_\\<in>{U}. x)", "using assms x Map_comp [of \"MkElem (UP x) (dom f)\" f]"], ["proof (prove)\nusing this:\n  \\<guillemotleft>MkArr {U} (Dom (local.dom f))\n                   (\\<lambda>_\\<in>{U}.\n                       DOWN\n                        (UP x)) : unity \\<rightarrow> local.dom\n                 f\\<guillemotright>\n  Dom (MkArr {U} (Dom (local.dom f)) (\\<lambda>_\\<in>{U}. DOWN (UP x))) =\n  {U} \\<and>\n  Map (MkArr {U} (Dom (local.dom f)) (\\<lambda>_\\<in>{U}. DOWN (UP x))) =\n  (\\<lambda>_\\<in>{U}. x)\n  arr f\n  x \\<in> Dom f\n  \\<lbrakk>arr (MkArr {U} (Dom (local.dom f))\n                 (\\<lambda>_\\<in>{U}. DOWN (UP x)));\n   arr f;\n   Dom f =\n   Cod (MkArr {U} (Dom (local.dom f))\n         (\\<lambda>_\\<in>{U}. DOWN (UP x)))\\<rbrakk>\n  \\<Longrightarrow> Map (f \\<cdot>\n                         MkArr {U} (Dom (local.dom f))\n                          (\\<lambda>_\\<in>{U}. DOWN (UP x))) =\n                    compose\n                     (Dom (MkArr {U} (Dom (local.dom f))\n                            (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                     (Map f)\n                     (Map (MkArr {U} (Dom (local.dom f))\n                            (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n\ngoal (1 subgoal):\n 1. Map (f \\<cdot>\n         MkArr {U} (Dom (local.dom f)) (\\<lambda>_\\<in>{U}. DOWN (UP x))) =\n    compose {U} (Map f) (\\<lambda>_\\<in>{U}. x)", "by (metis (mono_tags, lifting) Cod.simps(1) Dom_dom arr_iff_in_hom seqE seqI')"], ["proof (state)\nthis:\n  Map (f \\<cdot>\n       MkArr {U} (Dom (local.dom f)) (\\<lambda>_\\<in>{U}. DOWN (UP x))) =\n  compose {U} (Map f) (\\<lambda>_\\<in>{U}. x)\n\ngoal (1 subgoal):\n 1. x \\<in> Dom f \\<Longrightarrow>\n    Map f x =\n    (\\<lambda>x\\<in>Dom f.\n        Map (f \\<cdot>\n             MkArr {U} (Dom (local.dom f))\n              (\\<lambda>_\\<in>{U}. DOWN (UP x)))\n         U)\n     x", "thus ?thesis"], ["proof (prove)\nusing this:\n  Map (f \\<cdot>\n       MkArr {U} (Dom (local.dom f)) (\\<lambda>_\\<in>{U}. DOWN (UP x))) =\n  compose {U} (Map f) (\\<lambda>_\\<in>{U}. x)\n\ngoal (1 subgoal):\n 1. Map f x =\n    (\\<lambda>x\\<in>Dom f.\n        Map (f \\<cdot>\n             MkArr {U} (Dom (local.dom f))\n              (\\<lambda>_\\<in>{U}. DOWN (UP x)))\n         U)\n     x", "using x"], ["proof (prove)\nusing this:\n  Map (f \\<cdot>\n       MkArr {U} (Dom (local.dom f)) (\\<lambda>_\\<in>{U}. DOWN (UP x))) =\n  compose {U} (Map f) (\\<lambda>_\\<in>{U}. x)\n  x \\<in> Dom f\n\ngoal (1 subgoal):\n 1. Map f x =\n    (\\<lambda>x\\<in>Dom f.\n        Map (f \\<cdot>\n             MkArr {U} (Dom (local.dom f))\n              (\\<lambda>_\\<in>{U}. DOWN (UP x)))\n         U)\n     x", "by (simp add: compose_eq restrict_apply' singletonI)"], ["proof (state)\nthis:\n  Map f x =\n  (\\<lambda>x\\<in>Dom f.\n      Map (f \\<cdot>\n           MkArr {U} (Dom (local.dom f)) (\\<lambda>_\\<in>{U}. DOWN (UP x)))\n       U)\n   x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> Dom f \\<Longrightarrow>\n  Map f x =\n  (\\<lambda>x\\<in>Dom f.\n      Map (f \\<cdot>\n           MkArr {U} (Dom (local.dom f)) (\\<lambda>_\\<in>{U}. DOWN (UP x)))\n       U)\n   x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       Map f x =\n       (\\<lambda>x\\<in>Dom f.\n           Map (f \\<cdot>\n                MkArr {U} (Dom (local.dom f))\n                 (\\<lambda>_\\<in>{U}. DOWN (UP x)))\n            U)\n        x", "ultimately"], ["proof (chain)\npicking this:\n  x \\<notin> Dom f \\<Longrightarrow>\n  Map f x =\n  (\\<lambda>x\\<in>Dom f.\n      Map (f \\<cdot>\n           MkArr {U} (Dom (local.dom f)) (\\<lambda>_\\<in>{U}. DOWN (UP x)))\n       U)\n   x\n  x \\<in> Dom f \\<Longrightarrow>\n  Map f x =\n  (\\<lambda>x\\<in>Dom f.\n      Map (f \\<cdot>\n           MkArr {U} (Dom (local.dom f)) (\\<lambda>_\\<in>{U}. DOWN (UP x)))\n       U)\n   x", "show \"Map f x = (\\<lambda>x \\<in> Dom f. Map (f \\<cdot> MkElem (UP x) (dom f)) U) x\""], ["proof (prove)\nusing this:\n  x \\<notin> Dom f \\<Longrightarrow>\n  Map f x =\n  (\\<lambda>x\\<in>Dom f.\n      Map (f \\<cdot>\n           MkArr {U} (Dom (local.dom f)) (\\<lambda>_\\<in>{U}. DOWN (UP x)))\n       U)\n   x\n  x \\<in> Dom f \\<Longrightarrow>\n  Map f x =\n  (\\<lambda>x\\<in>Dom f.\n      Map (f \\<cdot>\n           MkArr {U} (Dom (local.dom f)) (\\<lambda>_\\<in>{U}. DOWN (UP x)))\n       U)\n   x\n\ngoal (1 subgoal):\n 1. Map f x =\n    (\\<lambda>x\\<in>Dom f.\n        Map (f \\<cdot>\n             MkArr {U} (Dom (local.dom f))\n              (\\<lambda>_\\<in>{U}. DOWN (UP x)))\n         U)\n     x", "by auto"], ["proof (state)\nthis:\n  Map f x =\n  (\\<lambda>x\\<in>Dom f.\n      Map (f \\<cdot>\n           MkArr {U} (Dom (local.dom f)) (\\<lambda>_\\<in>{U}. DOWN (UP x)))\n       U)\n   x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma arr_eqI':\n    assumes \"par f f'\" and \"\\<And>t. \\<guillemotleft>t : unity \\<rightarrow> dom f\\<guillemotright> \\<Longrightarrow> f \\<cdot> t = f' \\<cdot> t\"\n    shows \"f = f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = f'", "proof (intro arr_eqI)"], ["proof (state)\ngoal (5 subgoals):\n 1. arr f\n 2. arr f'\n 3. Dom f = Dom f'\n 4. Cod f = Cod f'\n 5. Map f = Map f'", "show \"arr f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr f", "using assms"], ["proof (prove)\nusing this:\n  par f f'\n  \\<guillemotleft>?t : unity \\<rightarrow> local.dom\n      f\\<guillemotright> \\<Longrightarrow>\n  f \\<cdot> ?t = f' \\<cdot> ?t\n\ngoal (1 subgoal):\n 1. arr f", "by simp"], ["proof (state)\nthis:\n  arr f\n\ngoal (4 subgoals):\n 1. arr f'\n 2. Dom f = Dom f'\n 3. Cod f = Cod f'\n 4. Map f = Map f'", "show \"arr f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr f'", "using assms"], ["proof (prove)\nusing this:\n  par f f'\n  \\<guillemotleft>?t : unity \\<rightarrow> local.dom\n      f\\<guillemotright> \\<Longrightarrow>\n  f \\<cdot> ?t = f' \\<cdot> ?t\n\ngoal (1 subgoal):\n 1. arr f'", "by simp"], ["proof (state)\nthis:\n  arr f'\n\ngoal (3 subgoals):\n 1. Dom f = Dom f'\n 2. Cod f = Cod f'\n 3. Map f = Map f'", "show \"Dom f = Dom f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dom f = Dom f'", "using assms"], ["proof (prove)\nusing this:\n  par f f'\n  \\<guillemotleft>?t : unity \\<rightarrow> local.dom\n      f\\<guillemotright> \\<Longrightarrow>\n  f \\<cdot> ?t = f' \\<cdot> ?t\n\ngoal (1 subgoal):\n 1. Dom f = Dom f'", "by (metis (mono_tags, lifting) Dom_dom)"], ["proof (state)\nthis:\n  Dom f = Dom f'\n\ngoal (2 subgoals):\n 1. Cod f = Cod f'\n 2. Map f = Map f'", "show \"Cod f = Cod f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cod f = Cod f'", "using assms"], ["proof (prove)\nusing this:\n  par f f'\n  \\<guillemotleft>?t : unity \\<rightarrow> local.dom\n      f\\<guillemotright> \\<Longrightarrow>\n  f \\<cdot> ?t = f' \\<cdot> ?t\n\ngoal (1 subgoal):\n 1. Cod f = Cod f'", "by (metis (mono_tags, lifting) Cod_cod)"], ["proof (state)\nthis:\n  Cod f = Cod f'\n\ngoal (1 subgoal):\n 1. Map f = Map f'", "show \"Map f = Map f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Map f = Map f'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. Map f x = Map f' x", "have 1: \"\\<And>x. x \\<in> Dom f \\<Longrightarrow> \\<guillemotleft>MkElem (UP x) (dom f) : unity \\<rightarrow> dom f\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Dom f \\<Longrightarrow>\n       \\<guillemotleft>MkArr {U} (Dom (local.dom f))\n                        (\\<lambda>_\\<in>{U}.\n                            DOWN\n                             (UP x)) : unity \\<rightarrow> local.dom\n                      f\\<guillemotright>", "using MkElem_in_hom"], ["proof (prove)\nusing this:\n  \\<lbrakk>arr ?f; ?x \\<in> Dom ?f\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>MkArr {U} (Dom (local.dom ?f))\n                                     (\\<lambda>_\\<in>{U}.\n   DOWN (UP ?x)) : unity \\<rightarrow> local.dom ?f\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Dom f \\<Longrightarrow>\n       \\<guillemotleft>MkArr {U} (Dom (local.dom f))\n                        (\\<lambda>_\\<in>{U}.\n                            DOWN\n                             (UP x)) : unity \\<rightarrow> local.dom\n                      f\\<guillemotright>", "by (metis (mono_tags, lifting) assms(1))"], ["proof (state)\nthis:\n  ?x \\<in> Dom f \\<Longrightarrow>\n  \\<guillemotleft>MkArr {U} (Dom (local.dom f))\n                   (\\<lambda>_\\<in>{U}.\n                       DOWN\n                        (UP ?x)) : unity \\<rightarrow> local.dom\n                  f\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>x. Map f x = Map f' x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. Map f x = Map f' x", "show \"Map f x = Map f' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Map f x = Map f' x", "using assms 1 \\<open>Dom f = Dom f'\\<close>"], ["proof (prove)\nusing this:\n  par f f'\n  \\<guillemotleft>?t : unity \\<rightarrow> local.dom\n      f\\<guillemotright> \\<Longrightarrow>\n  f \\<cdot> ?t = f' \\<cdot> ?t\n  ?x \\<in> Dom f \\<Longrightarrow>\n  \\<guillemotleft>MkArr {U} (Dom (local.dom f))\n                   (\\<lambda>_\\<in>{U}.\n                       DOWN\n                        (UP ?x)) : unity \\<rightarrow> local.dom\n                  f\\<guillemotright>\n  Dom f = Dom f'\n\ngoal (1 subgoal):\n 1. Map f x = Map f' x", "by (simp add: Map_via_comp)"], ["proof (state)\nthis:\n  Map f x = Map f' x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Map f = Map f'\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>\n      We need to show that the cardinality constraint on the sets that determine objects\n      implies a corresponding constraint on the sets of global elements of those objects.\n    \\<close>"], ["", "lemma card_points_less:\n    assumes \"ide a\"\n    shows \"|hom unity a| <o \\<AA>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |hom unity a| <o \\<AA>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. |hom unity a| <o \\<AA>", "have \"bij_betw (\\<lambda>f. Map f U) (hom unity a) (Dom a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (\\<lambda>f. Map f U) (hom unity a) (Dom a)", "proof (intro bij_betwI')"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> hom unity a; y \\<in> hom unity a\\<rbrakk>\n       \\<Longrightarrow> (Map x U = Map y U) = (x = y)\n 2. \\<And>x. x \\<in> hom unity a \\<Longrightarrow> Map x U \\<in> Dom a\n 3. \\<And>y.\n       y \\<in> Dom a \\<Longrightarrow>\n       \\<exists>x\\<in>hom unity a. y = Map x U", "show \"\\<And>x. x \\<in> hom unity a \\<Longrightarrow> Map x (DOWN unity) \\<in> Dom a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> hom unity a \\<Longrightarrow> Map x U \\<in> Dom a", "using arr_char Dom_terminal terminal_unity in_hom_char"], ["proof (prove)\nusing this:\n  arr ?f =\n  (?f \\<noteq> Null \\<and>\n   |Dom ?f| <o \\<AA> \\<and>\n   |Cod ?f| <o \\<AA> \\<and>\n   Map ?f \\<in> extensional (Dom ?f) \\<inter> (Dom ?f \\<rightarrow> Cod ?f))\n  terminal ?t \\<Longrightarrow> Dom ?t = {DOWN ?t}\n  terminal unity\n  \\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright> =\n  (arr ?f \\<and>\n   ide ?a \\<and> ide ?b \\<and> Dom ?f = Dom ?a \\<and> Cod ?f = Dom ?b)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> hom unity a \\<Longrightarrow> Map x U \\<in> Dom a", "by auto"], ["proof (state)\nthis:\n  ?x \\<in> hom unity a \\<Longrightarrow> Map ?x U \\<in> Dom a\n\ngoal (2 subgoals):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> hom unity a; y \\<in> hom unity a\\<rbrakk>\n       \\<Longrightarrow> (Map x U = Map y U) = (x = y)\n 2. \\<And>y.\n       y \\<in> Dom a \\<Longrightarrow>\n       \\<exists>x\\<in>hom unity a. y = Map x U", "show \"\\<And>x y. \\<lbrakk>x \\<in> hom unity a; y \\<in> hom unity a\\<rbrakk> \\<Longrightarrow> Map x U = Map y U \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> hom unity a; y \\<in> hom unity a\\<rbrakk>\n       \\<Longrightarrow> (Map x U = Map y U) = (x = y)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> hom unity a; y \\<in> hom unity a\\<rbrakk>\n       \\<Longrightarrow> (Map x U = Map y U) = (x = y)", "fix x y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> hom unity a; y \\<in> hom unity a\\<rbrakk>\n       \\<Longrightarrow> (Map x U = Map y U) = (x = y)", "assume x: \"x \\<in> hom unity a\" and y: \"y \\<in> hom unity a\""], ["proof (state)\nthis:\n  x \\<in> hom unity a\n  y \\<in> hom unity a\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> hom unity a; y \\<in> hom unity a\\<rbrakk>\n       \\<Longrightarrow> (Map x U = Map y U) = (x = y)", "have 1: \"Map x \\<in> extensional {U} \\<and> Map y \\<in> extensional {U}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Map x \\<in> extensional {U} \\<and> Map y \\<in> extensional {U}", "using x y in_hom_char Dom_terminal terminal_unity"], ["proof (prove)\nusing this:\n  x \\<in> hom unity a\n  y \\<in> hom unity a\n  \\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright> =\n  (arr ?f \\<and>\n   ide ?a \\<and> ide ?b \\<and> Dom ?f = Dom ?a \\<and> Cod ?f = Dom ?b)\n  terminal ?t \\<Longrightarrow> Dom ?t = {DOWN ?t}\n  terminal unity\n\ngoal (1 subgoal):\n 1. Map x \\<in> extensional {U} \\<and> Map y \\<in> extensional {U}", "by (metis (mono_tags, lifting) Map_via_comp mem_Collect_eq restrict_extensional)"], ["proof (state)\nthis:\n  Map x \\<in> extensional {U} \\<and> Map y \\<in> extensional {U}\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> hom unity a; y \\<in> hom unity a\\<rbrakk>\n       \\<Longrightarrow> (Map x U = Map y U) = (x = y)", "show \"Map x U = Map y U \\<longleftrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Map x U = Map y U) = (x = y)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. Map x U = Map y U \\<Longrightarrow> x = y\n 2. x = y \\<Longrightarrow> Map x U = Map y U", "show \"x = y \\<Longrightarrow> Map x U = Map y U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y \\<Longrightarrow> Map x U = Map y U", "by simp"], ["proof (state)\nthis:\n  x = y \\<Longrightarrow> Map x U = Map y U\n\ngoal (1 subgoal):\n 1. Map x U = Map y U \\<Longrightarrow> x = y", "show \"Map x U = Map y U \\<Longrightarrow> x = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Map x U = Map y U \\<Longrightarrow> x = y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Map x U = Map y U \\<Longrightarrow> x = y", "assume 2: \"Map x U = Map y U\""], ["proof (state)\nthis:\n  Map x U = Map y U\n\ngoal (1 subgoal):\n 1. Map x U = Map y U \\<Longrightarrow> x = y", "have \"Map x = Map y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Map x = Map y", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. Map x xa = Map y xa", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. Map x xa = Map y xa", "show \"Map x z = Map y z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Map x z = Map y z", "using 1 2 extensional_arb [of \"Map x\"] extensional_arb [of \"Map y\"]"], ["proof (prove)\nusing this:\n  Map x \\<in> extensional {U} \\<and> Map y \\<in> extensional {U}\n  Map x U = Map y U\n  \\<lbrakk>Map x \\<in> extensional ?A; ?x \\<notin> ?A\\<rbrakk>\n  \\<Longrightarrow> Map x ?x = undefined\n  \\<lbrakk>Map y \\<in> extensional ?A; ?x \\<notin> ?A\\<rbrakk>\n  \\<Longrightarrow> Map y ?x = undefined\n\ngoal (1 subgoal):\n 1. Map x z = Map y z", "by (cases \"z = U\") auto"], ["proof (state)\nthis:\n  Map x z = Map y z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Map x = Map y\n\ngoal (1 subgoal):\n 1. Map x U = Map y U \\<Longrightarrow> x = y", "thus \"x = y\""], ["proof (prove)\nusing this:\n  Map x = Map y\n\ngoal (1 subgoal):\n 1. x = y", "using x y 1 in_hom_char"], ["proof (prove)\nusing this:\n  Map x = Map y\n  x \\<in> hom unity a\n  y \\<in> hom unity a\n  Map x \\<in> extensional {U} \\<and> Map y \\<in> extensional {U}\n  \\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright> =\n  (arr ?f \\<and>\n   ide ?a \\<and> ide ?b \\<and> Dom ?f = Dom ?a \\<and> Cod ?f = Dom ?b)\n\ngoal (1 subgoal):\n 1. x = y", "by (intro arr_eqI) auto"], ["proof (state)\nthis:\n  x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Map x U = Map y U \\<Longrightarrow> x = y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (Map x U = Map y U) = (x = y)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?x \\<in> hom unity a; ?y \\<in> hom unity a\\<rbrakk>\n  \\<Longrightarrow> (Map ?x U = Map ?y U) = (?x = ?y)\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> Dom a \\<Longrightarrow>\n       \\<exists>x\\<in>hom unity a. y = Map x U", "show \"\\<And>y. y \\<in> Dom a \\<Longrightarrow> \\<exists>x \\<in> hom unity a. y = Map x (DOWN unity)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> Dom a \\<Longrightarrow>\n       \\<exists>x\\<in>hom unity a. y = Map x U", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> Dom a \\<Longrightarrow>\n       \\<exists>x\\<in>hom unity a. y = Map x U", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> Dom a \\<Longrightarrow>\n       \\<exists>x\\<in>hom unity a. y = Map x U", "assume y: \"y \\<in> Dom a\""], ["proof (state)\nthis:\n  y \\<in> Dom a\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> Dom a \\<Longrightarrow>\n       \\<exists>x\\<in>hom unity a. y = Map x U", "let ?x = \"MkArr {DOWN unity} (Dom a) (\\<lambda>_ \\<in> {U}. y)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> Dom a \\<Longrightarrow>\n       \\<exists>x\\<in>hom unity a. y = Map x U", "have \"arr ?x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. y))", "proof (intro arr_MkArr)"], ["proof (state)\ngoal (3 subgoals):\n 1. {U} \\<in> {A. |A| <o \\<AA>}\n 2. Dom a \\<in> {A. |A| <o \\<AA>}\n 3. (\\<lambda>_\\<in>{U}. y)\n    \\<in> extensional {U} \\<inter> ({U} \\<rightarrow> Dom a)", "show \"{U} \\<in> {A. |A| <o \\<AA>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. {U} \\<in> {A. |A| <o \\<AA>}", "by (metis (mono_tags, lifting) Dom_terminal ide_char terminal_def terminal_unity)"], ["proof (state)\nthis:\n  {U} \\<in> {A. |A| <o \\<AA>}\n\ngoal (2 subgoals):\n 1. Dom a \\<in> {A. |A| <o \\<AA>}\n 2. (\\<lambda>_\\<in>{U}. y)\n    \\<in> extensional {U} \\<inter> ({U} \\<rightarrow> Dom a)", "show \"Dom a \\<in> {A. |A| <o \\<AA>}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dom a \\<in> {A. |A| <o \\<AA>}", "using assms ide_char"], ["proof (prove)\nusing this:\n  ide a\n  ide ?f =\n  (?f \\<noteq> Null \\<and>\n   Dom ?f \\<in> {A. |A| <o \\<AA>} \\<and>\n   Cod ?f = Dom ?f \\<and> Map ?f = (\\<lambda>x\\<in>Dom ?f. x))\n\ngoal (1 subgoal):\n 1. Dom a \\<in> {A. |A| <o \\<AA>}", "by blast"], ["proof (state)\nthis:\n  Dom a \\<in> {A. |A| <o \\<AA>}\n\ngoal (1 subgoal):\n 1. (\\<lambda>_\\<in>{U}. y)\n    \\<in> extensional {U} \\<inter> ({U} \\<rightarrow> Dom a)", "show \"(\\<lambda>_ \\<in> {U}. y) \\<in> extensional {U} \\<inter> ({U} \\<rightarrow> Dom a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>_\\<in>{U}. y)\n    \\<in> extensional {U} \\<inter> ({U} \\<rightarrow> Dom a)", "using assms y"], ["proof (prove)\nusing this:\n  ide a\n  y \\<in> Dom a\n\ngoal (1 subgoal):\n 1. (\\<lambda>_\\<in>{U}. y)\n    \\<in> extensional {U} \\<inter> ({U} \\<rightarrow> Dom a)", "by blast"], ["proof (state)\nthis:\n  (\\<lambda>_\\<in>{U}. y)\n  \\<in> extensional {U} \\<inter> ({U} \\<rightarrow> Dom a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  arr (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. y))\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> Dom a \\<Longrightarrow>\n       \\<exists>x\\<in>hom unity a. y = Map x U", "hence \"?x \\<in> hom unity a\""], ["proof (prove)\nusing this:\n  arr (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. y))\n\ngoal (1 subgoal):\n 1. MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. y) \\<in> hom unity a", "using UP_DOWN UP_def assms cod_MkArr dom_char in_homI terminal_unity"], ["proof (prove)\nusing this:\n  arr (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. y))\n  ?t \\<in> Univ \\<Longrightarrow> UP (DOWN ?t) = ?t\n  UP ?x \\<equiv> MkIde {?x}\n  ide a\n  arr (MkArr ?A ?B ?F) \\<Longrightarrow> cod (MkArr ?A ?B ?F) = MkIde ?B\n  local.dom ?f = (if arr ?f then MkIde (Dom ?f) else null)\n  \\<lbrakk>arr ?f; local.dom ?f = ?a; cod ?f = ?b\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright>\n  terminal unity\n\ngoal (1 subgoal):\n 1. MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. y) \\<in> hom unity a", "by simp"], ["proof (state)\nthis:\n  MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. y) \\<in> hom unity a\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> Dom a \\<Longrightarrow>\n       \\<exists>x\\<in>hom unity a. y = Map x U", "moreover"], ["proof (state)\nthis:\n  MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. y) \\<in> hom unity a\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> Dom a \\<Longrightarrow>\n       \\<exists>x\\<in>hom unity a. y = Map x U", "have \"y = Map ?x (DOWN unity)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y = Map (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. y)) U", "by simp"], ["proof (state)\nthis:\n  y = Map (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. y)) U\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> Dom a \\<Longrightarrow>\n       \\<exists>x\\<in>hom unity a. y = Map x U", "ultimately"], ["proof (chain)\npicking this:\n  MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. y) \\<in> hom unity a\n  y = Map (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. y)) U", "show \"\\<exists>x \\<in> hom unity a. y = Map x (DOWN unity)\""], ["proof (prove)\nusing this:\n  MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. y) \\<in> hom unity a\n  y = Map (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. y)) U\n\ngoal (1 subgoal):\n 1. \\<exists>x\\<in>hom unity a. y = Map x U", "by auto"], ["proof (state)\nthis:\n  \\<exists>x\\<in>hom unity a. y = Map x U\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?y \\<in> Dom a \\<Longrightarrow> \\<exists>x\\<in>hom unity a. ?y = Map x U\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bij_betw (\\<lambda>f. Map f U) (hom unity a) (Dom a)\n\ngoal (1 subgoal):\n 1. |hom unity a| <o \\<AA>", "hence \"|hom unity a| =o |Dom a|\""], ["proof (prove)\nusing this:\n  bij_betw (\\<lambda>f. Map f U) (hom unity a) (Dom a)\n\ngoal (1 subgoal):\n 1. |hom unity a| =o |Dom a|", "using card_of_ordIsoI"], ["proof (prove)\nusing this:\n  bij_betw (\\<lambda>f. Map f U) (hom unity a) (Dom a)\n  bij_betw ?f ?A ?B \\<Longrightarrow> |?A| =o |?B|\n\ngoal (1 subgoal):\n 1. |hom unity a| =o |Dom a|", "by auto"], ["proof (state)\nthis:\n  |hom unity a| =o |Dom a|\n\ngoal (1 subgoal):\n 1. |hom unity a| <o \\<AA>", "moreover"], ["proof (state)\nthis:\n  |hom unity a| =o |Dom a|\n\ngoal (1 subgoal):\n 1. |hom unity a| <o \\<AA>", "have \"|Dom a| <o \\<AA>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |Dom a| <o \\<AA>", "using assms ide_char"], ["proof (prove)\nusing this:\n  ide a\n  ide ?f =\n  (?f \\<noteq> Null \\<and>\n   Dom ?f \\<in> {A. |A| <o \\<AA>} \\<and>\n   Cod ?f = Dom ?f \\<and> Map ?f = (\\<lambda>x\\<in>Dom ?f. x))\n\ngoal (1 subgoal):\n 1. |Dom a| <o \\<AA>", "by auto"], ["proof (state)\nthis:\n  |Dom a| <o \\<AA>\n\ngoal (1 subgoal):\n 1. |hom unity a| <o \\<AA>", "ultimately"], ["proof (chain)\npicking this:\n  |hom unity a| =o |Dom a|\n  |Dom a| <o \\<AA>", "show \"|hom unity a| <o \\<AA>\""], ["proof (prove)\nusing this:\n  |hom unity a| =o |Dom a|\n  |Dom a| <o \\<AA>\n\ngoal (1 subgoal):\n 1. |hom unity a| <o \\<AA>", "using ordIso_ordLess_trans"], ["proof (prove)\nusing this:\n  |hom unity a| =o |Dom a|\n  |Dom a| <o \\<AA>\n  \\<lbrakk>?r =o ?r'; ?r' <o ?r''\\<rbrakk> \\<Longrightarrow> ?r <o ?r''\n\ngoal (1 subgoal):\n 1. |hom unity a| <o \\<AA>", "by auto"], ["proof (state)\nthis:\n  |hom unity a| <o \\<AA>\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n      The main result, which establishes the consistency of the \\<open>set_category\\<close> locale\n      and provides us with a way of obtaining ``set categories'' at arbitrary types.\n\\<close>"], ["", "theorem is_set_category:\n    shows \"set_category comp \\<AA>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_category (\\<cdot>) \\<AA>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>img. set_category_given_img (\\<cdot>) img \\<AA>", "show \"\\<exists>img :: 'e setcat.arr \\<Rightarrow> 'e setcat.arr. set_category_given_img comp img \\<AA>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>img. set_category_given_img (\\<cdot>) img \\<AA>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. set_category_given_img (\\<cdot>) ?img \\<AA>", "show \"set_category_given_img (comp :: 'e setcat.arr comp) IMG \\<AA>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. set_category_given_img (\\<cdot>) IMG \\<AA>", "proof"], ["proof (state)\ngoal (10 subgoals):\n 1. Univ \\<noteq> {}\n 2. \\<And>a.\n       ide a \\<Longrightarrow> IMG \\<in> hom unity a \\<rightarrow> Univ\n 3. \\<And>a. ide a \\<Longrightarrow> |hom unity a| <o \\<AA>\n 4. \\<And>a. ide a \\<Longrightarrow> inj_on IMG (hom unity a)\n 5. \\<And>t. terminal t \\<Longrightarrow> t \\<in> IMG ` hom unity t\n 6. \\<And>a b.\n       \\<lbrakk>ide a; ide b; local.set a = local.set b\\<rbrakk>\n       \\<Longrightarrow> a = b\n 7. \\<And>f f'.\n       \\<lbrakk>par f f';\n        \\<And>x.\n           \\<guillemotleft>x : unity \\<rightarrow> local.dom\n              f\\<guillemotright> \\<Longrightarrow>\n           f \\<cdot> x = f' \\<cdot> x\\<rbrakk>\n       \\<Longrightarrow> f = f'\n 8. \\<And>A.\n       \\<lbrakk>A \\<subseteq> Univ; |A| <o \\<AA>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a. ide a \\<and> local.set a = A\n 9. \\<And>a b F.\n       \\<lbrakk>ide a; ide b;\n        F \\<in> hom unity a \\<rightarrow> hom unity b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n                            (\\<forall>x.\n                                \\<guillemotleft>x : unity \\<rightarrow> local.dom\n                                   f\\<guillemotright> \\<longrightarrow>\n                                f \\<cdot> x = F x)\n 10. Card_order \\<AA> \\<and> infinite (Field \\<AA>)", "show \"Card_order \\<AA> \\<and> infinite (Field \\<AA> )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Card_order \\<AA> \\<and> infinite (Field \\<AA>)", "using cardinal"], ["proof (prove)\nusing this:\n  Card_order \\<AA> \\<and> infinite (Field \\<AA>)\n\ngoal (1 subgoal):\n 1. Card_order \\<AA> \\<and> infinite (Field \\<AA>)", "by simp"], ["proof (state)\nthis:\n  Card_order \\<AA> \\<and> infinite (Field \\<AA>)\n\ngoal (9 subgoals):\n 1. Univ \\<noteq> {}\n 2. \\<And>a.\n       ide a \\<Longrightarrow> IMG \\<in> hom unity a \\<rightarrow> Univ\n 3. \\<And>a. ide a \\<Longrightarrow> |hom unity a| <o \\<AA>\n 4. \\<And>a. ide a \\<Longrightarrow> inj_on IMG (hom unity a)\n 5. \\<And>t. terminal t \\<Longrightarrow> t \\<in> IMG ` hom unity t\n 6. \\<And>a b.\n       \\<lbrakk>ide a; ide b; local.set a = local.set b\\<rbrakk>\n       \\<Longrightarrow> a = b\n 7. \\<And>f f'.\n       \\<lbrakk>par f f';\n        \\<And>x.\n           \\<guillemotleft>x : unity \\<rightarrow> local.dom\n              f\\<guillemotright> \\<Longrightarrow>\n           f \\<cdot> x = f' \\<cdot> x\\<rbrakk>\n       \\<Longrightarrow> f = f'\n 8. \\<And>A.\n       \\<lbrakk>A \\<subseteq> Univ; |A| <o \\<AA>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a. ide a \\<and> local.set a = A\n 9. \\<And>a b F.\n       \\<lbrakk>ide a; ide b;\n        F \\<in> hom unity a \\<rightarrow> hom unity b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n                            (\\<forall>x.\n                                \\<guillemotleft>x : unity \\<rightarrow> local.dom\n                                   f\\<guillemotright> \\<longrightarrow>\n                                f \\<cdot> x = F x)", "show \"Univ \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Univ \\<noteq> {}", "using terminal_char"], ["proof (prove)\nusing this:\n  terminal ?a = (\\<exists>x. ?a = MkIde {x})\n\ngoal (1 subgoal):\n 1. Univ \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  Univ \\<noteq> {}\n\ngoal (8 subgoals):\n 1. \\<And>a.\n       ide a \\<Longrightarrow> IMG \\<in> hom unity a \\<rightarrow> Univ\n 2. \\<And>a. ide a \\<Longrightarrow> |hom unity a| <o \\<AA>\n 3. \\<And>a. ide a \\<Longrightarrow> inj_on IMG (hom unity a)\n 4. \\<And>t. terminal t \\<Longrightarrow> t \\<in> IMG ` hom unity t\n 5. \\<And>a b.\n       \\<lbrakk>ide a; ide b; local.set a = local.set b\\<rbrakk>\n       \\<Longrightarrow> a = b\n 6. \\<And>f f'.\n       \\<lbrakk>par f f';\n        \\<And>x.\n           \\<guillemotleft>x : unity \\<rightarrow> local.dom\n              f\\<guillemotright> \\<Longrightarrow>\n           f \\<cdot> x = f' \\<cdot> x\\<rbrakk>\n       \\<Longrightarrow> f = f'\n 7. \\<And>A.\n       \\<lbrakk>A \\<subseteq> Univ; |A| <o \\<AA>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a. ide a \\<and> local.set a = A\n 8. \\<And>a b F.\n       \\<lbrakk>ide a; ide b;\n        F \\<in> hom unity a \\<rightarrow> hom unity b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n                            (\\<forall>x.\n                                \\<guillemotleft>x : unity \\<rightarrow> local.dom\n                                   f\\<guillemotright> \\<longrightarrow>\n                                f \\<cdot> x = F x)", "fix a :: \"'e setcat.arr\""], ["proof (state)\ngoal (8 subgoals):\n 1. \\<And>a.\n       ide a \\<Longrightarrow> IMG \\<in> hom unity a \\<rightarrow> Univ\n 2. \\<And>a. ide a \\<Longrightarrow> |hom unity a| <o \\<AA>\n 3. \\<And>a. ide a \\<Longrightarrow> inj_on IMG (hom unity a)\n 4. \\<And>t. terminal t \\<Longrightarrow> t \\<in> IMG ` hom unity t\n 5. \\<And>a b.\n       \\<lbrakk>ide a; ide b; local.set a = local.set b\\<rbrakk>\n       \\<Longrightarrow> a = b\n 6. \\<And>f f'.\n       \\<lbrakk>par f f';\n        \\<And>x.\n           \\<guillemotleft>x : unity \\<rightarrow> local.dom\n              f\\<guillemotright> \\<Longrightarrow>\n           f \\<cdot> x = f' \\<cdot> x\\<rbrakk>\n       \\<Longrightarrow> f = f'\n 7. \\<And>A.\n       \\<lbrakk>A \\<subseteq> Univ; |A| <o \\<AA>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a. ide a \\<and> local.set a = A\n 8. \\<And>a b F.\n       \\<lbrakk>ide a; ide b;\n        F \\<in> hom unity a \\<rightarrow> hom unity b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n                            (\\<forall>x.\n                                \\<guillemotleft>x : unity \\<rightarrow> local.dom\n                                   f\\<guillemotright> \\<longrightarrow>\n                                f \\<cdot> x = F x)", "assume a: \"ide a\""], ["proof (state)\nthis:\n  ide a\n\ngoal (8 subgoals):\n 1. \\<And>a.\n       ide a \\<Longrightarrow> IMG \\<in> hom unity a \\<rightarrow> Univ\n 2. \\<And>a. ide a \\<Longrightarrow> |hom unity a| <o \\<AA>\n 3. \\<And>a. ide a \\<Longrightarrow> inj_on IMG (hom unity a)\n 4. \\<And>t. terminal t \\<Longrightarrow> t \\<in> IMG ` hom unity t\n 5. \\<And>a b.\n       \\<lbrakk>ide a; ide b; local.set a = local.set b\\<rbrakk>\n       \\<Longrightarrow> a = b\n 6. \\<And>f f'.\n       \\<lbrakk>par f f';\n        \\<And>x.\n           \\<guillemotleft>x : unity \\<rightarrow> local.dom\n              f\\<guillemotright> \\<Longrightarrow>\n           f \\<cdot> x = f' \\<cdot> x\\<rbrakk>\n       \\<Longrightarrow> f = f'\n 7. \\<And>A.\n       \\<lbrakk>A \\<subseteq> Univ; |A| <o \\<AA>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a. ide a \\<and> local.set a = A\n 8. \\<And>a b F.\n       \\<lbrakk>ide a; ide b;\n        F \\<in> hom unity a \\<rightarrow> hom unity b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n                            (\\<forall>x.\n                                \\<guillemotleft>x : unity \\<rightarrow> local.dom\n                                   f\\<guillemotright> \\<longrightarrow>\n                                f \\<cdot> x = F x)", "show \"IMG \\<in> hom unity a \\<rightarrow> Univ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. IMG \\<in> hom unity a \\<rightarrow> Univ", "using IMG_point terminal_unity"], ["proof (prove)\nusing this:\n  \\<guillemotleft>?p : unity \\<rightarrow> ?a\\<guillemotright> \\<Longrightarrow>\n  IMG \\<in> hom unity ?a \\<rightarrow> Univ\n  \\<guillemotleft>?p : unity \\<rightarrow> ?a\\<guillemotright> \\<Longrightarrow>\n  IMG ?p = (UP \\<circ> Map ?p \\<circ> DOWN) unity\n  terminal unity\n\ngoal (1 subgoal):\n 1. IMG \\<in> hom unity a \\<rightarrow> Univ", "by blast"], ["proof (state)\nthis:\n  IMG \\<in> hom unity a \\<rightarrow> Univ\n\ngoal (7 subgoals):\n 1. \\<And>a. ide a \\<Longrightarrow> |hom unity a| <o \\<AA>\n 2. \\<And>a. ide a \\<Longrightarrow> inj_on IMG (hom unity a)\n 3. \\<And>t. terminal t \\<Longrightarrow> t \\<in> IMG ` hom unity t\n 4. \\<And>a b.\n       \\<lbrakk>ide a; ide b; local.set a = local.set b\\<rbrakk>\n       \\<Longrightarrow> a = b\n 5. \\<And>f f'.\n       \\<lbrakk>par f f';\n        \\<And>x.\n           \\<guillemotleft>x : unity \\<rightarrow> local.dom\n              f\\<guillemotright> \\<Longrightarrow>\n           f \\<cdot> x = f' \\<cdot> x\\<rbrakk>\n       \\<Longrightarrow> f = f'\n 6. \\<And>A.\n       \\<lbrakk>A \\<subseteq> Univ; |A| <o \\<AA>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a. ide a \\<and> local.set a = A\n 7. \\<And>a b F.\n       \\<lbrakk>ide a; ide b;\n        F \\<in> hom unity a \\<rightarrow> hom unity b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n                            (\\<forall>x.\n                                \\<guillemotleft>x : unity \\<rightarrow> local.dom\n                                   f\\<guillemotright> \\<longrightarrow>\n                                f \\<cdot> x = F x)", "show \"|hom unity a| <o \\<AA>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |hom unity a| <o \\<AA>", "using a card_points_less"], ["proof (prove)\nusing this:\n  ide a\n  ide ?a \\<Longrightarrow> |hom unity ?a| <o \\<AA>\n\ngoal (1 subgoal):\n 1. |hom unity a| <o \\<AA>", "by simp"], ["proof (state)\nthis:\n  |hom unity a| <o \\<AA>\n\ngoal (6 subgoals):\n 1. \\<And>a. ide a \\<Longrightarrow> inj_on IMG (hom unity a)\n 2. \\<And>t. terminal t \\<Longrightarrow> t \\<in> IMG ` hom unity t\n 3. \\<And>a b.\n       \\<lbrakk>ide a; ide b; local.set a = local.set b\\<rbrakk>\n       \\<Longrightarrow> a = b\n 4. \\<And>f f'.\n       \\<lbrakk>par f f';\n        \\<And>x.\n           \\<guillemotleft>x : unity \\<rightarrow> local.dom\n              f\\<guillemotright> \\<Longrightarrow>\n           f \\<cdot> x = f' \\<cdot> x\\<rbrakk>\n       \\<Longrightarrow> f = f'\n 5. \\<And>A.\n       \\<lbrakk>A \\<subseteq> Univ; |A| <o \\<AA>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a. ide a \\<and> local.set a = A\n 6. \\<And>a b F.\n       \\<lbrakk>ide a; ide b;\n        F \\<in> hom unity a \\<rightarrow> hom unity b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n                            (\\<forall>x.\n                                \\<guillemotleft>x : unity \\<rightarrow> local.dom\n                                   f\\<guillemotright> \\<longrightarrow>\n                                f \\<cdot> x = F x)", "show \"inj_on IMG (hom unity a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on IMG (hom unity a)", "using a inj_IMG terminal_unity"], ["proof (prove)\nusing this:\n  ide a\n  ide ?a \\<Longrightarrow> inj_on IMG (hom unity ?a)\n  terminal unity\n\ngoal (1 subgoal):\n 1. inj_on IMG (hom unity a)", "by blast"], ["proof (state)\nthis:\n  inj_on IMG (hom unity a)\n\ngoal (5 subgoals):\n 1. \\<And>t. terminal t \\<Longrightarrow> t \\<in> IMG ` hom unity t\n 2. \\<And>a b.\n       \\<lbrakk>ide a; ide b; local.set a = local.set b\\<rbrakk>\n       \\<Longrightarrow> a = b\n 3. \\<And>f f'.\n       \\<lbrakk>par f f';\n        \\<And>x.\n           \\<guillemotleft>x : unity \\<rightarrow> local.dom\n              f\\<guillemotright> \\<Longrightarrow>\n           f \\<cdot> x = f' \\<cdot> x\\<rbrakk>\n       \\<Longrightarrow> f = f'\n 4. \\<And>A.\n       \\<lbrakk>A \\<subseteq> Univ; |A| <o \\<AA>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a. ide a \\<and> local.set a = A\n 5. \\<And>a b F.\n       \\<lbrakk>ide a; ide b;\n        F \\<in> hom unity a \\<rightarrow> hom unity b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n                            (\\<forall>x.\n                                \\<guillemotleft>x : unity \\<rightarrow> local.dom\n                                   f\\<guillemotright> \\<longrightarrow>\n                                f \\<cdot> x = F x)", "next"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>t. terminal t \\<Longrightarrow> t \\<in> IMG ` hom unity t\n 2. \\<And>a b.\n       \\<lbrakk>ide a; ide b; local.set a = local.set b\\<rbrakk>\n       \\<Longrightarrow> a = b\n 3. \\<And>f f'.\n       \\<lbrakk>par f f';\n        \\<And>x.\n           \\<guillemotleft>x : unity \\<rightarrow> local.dom\n              f\\<guillemotright> \\<Longrightarrow>\n           f \\<cdot> x = f' \\<cdot> x\\<rbrakk>\n       \\<Longrightarrow> f = f'\n 4. \\<And>A.\n       \\<lbrakk>A \\<subseteq> Univ; |A| <o \\<AA>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a. ide a \\<and> local.set a = A\n 5. \\<And>a b F.\n       \\<lbrakk>ide a; ide b;\n        F \\<in> hom unity a \\<rightarrow> hom unity b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n                            (\\<forall>x.\n                                \\<guillemotleft>x : unity \\<rightarrow> local.dom\n                                   f\\<guillemotright> \\<longrightarrow>\n                                f \\<cdot> x = F x)", "fix t :: \"'e setcat.arr\""], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>t. terminal t \\<Longrightarrow> t \\<in> IMG ` hom unity t\n 2. \\<And>a b.\n       \\<lbrakk>ide a; ide b; local.set a = local.set b\\<rbrakk>\n       \\<Longrightarrow> a = b\n 3. \\<And>f f'.\n       \\<lbrakk>par f f';\n        \\<And>x.\n           \\<guillemotleft>x : unity \\<rightarrow> local.dom\n              f\\<guillemotright> \\<Longrightarrow>\n           f \\<cdot> x = f' \\<cdot> x\\<rbrakk>\n       \\<Longrightarrow> f = f'\n 4. \\<And>A.\n       \\<lbrakk>A \\<subseteq> Univ; |A| <o \\<AA>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a. ide a \\<and> local.set a = A\n 5. \\<And>a b F.\n       \\<lbrakk>ide a; ide b;\n        F \\<in> hom unity a \\<rightarrow> hom unity b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n                            (\\<forall>x.\n                                \\<guillemotleft>x : unity \\<rightarrow> local.dom\n                                   f\\<guillemotright> \\<longrightarrow>\n                                f \\<cdot> x = F x)", "assume t: \"terminal t\""], ["proof (state)\nthis:\n  terminal t\n\ngoal (5 subgoals):\n 1. \\<And>t. terminal t \\<Longrightarrow> t \\<in> IMG ` hom unity t\n 2. \\<And>a b.\n       \\<lbrakk>ide a; ide b; local.set a = local.set b\\<rbrakk>\n       \\<Longrightarrow> a = b\n 3. \\<And>f f'.\n       \\<lbrakk>par f f';\n        \\<And>x.\n           \\<guillemotleft>x : unity \\<rightarrow> local.dom\n              f\\<guillemotright> \\<Longrightarrow>\n           f \\<cdot> x = f' \\<cdot> x\\<rbrakk>\n       \\<Longrightarrow> f = f'\n 4. \\<And>A.\n       \\<lbrakk>A \\<subseteq> Univ; |A| <o \\<AA>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a. ide a \\<and> local.set a = A\n 5. \\<And>a b F.\n       \\<lbrakk>ide a; ide b;\n        F \\<in> hom unity a \\<rightarrow> hom unity b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n                            (\\<forall>x.\n                                \\<guillemotleft>x : unity \\<rightarrow> local.dom\n                                   f\\<guillemotright> \\<longrightarrow>\n                                f \\<cdot> x = F x)", "show \"t \\<in> IMG ` hom unity t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> IMG ` hom unity t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<in> IMG ` hom unity t", "have \"t \\<in> set t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> local.set t", "using t set_char [of t]"], ["proof (prove)\nusing this:\n  terminal t\n  ide t \\<Longrightarrow> local.set t = UP ` Dom t\n\ngoal (1 subgoal):\n 1. t \\<in> local.set t", "by (metis (mono_tags, lifting) Dom.simps(1) image_insert insertI1 UP_def\n                  terminal_char terminal_def)"], ["proof (state)\nthis:\n  t \\<in> local.set t\n\ngoal (1 subgoal):\n 1. t \\<in> IMG ` hom unity t", "thus ?thesis"], ["proof (prove)\nusing this:\n  t \\<in> local.set t\n\ngoal (1 subgoal):\n 1. t \\<in> IMG ` hom unity t", "using t set_def [of t]"], ["proof (prove)\nusing this:\n  t \\<in> local.set t\n  terminal t\n  local.set t = IMG ` hom unity t\n\ngoal (1 subgoal):\n 1. t \\<in> IMG ` hom unity t", "by simp"], ["proof (state)\nthis:\n  t \\<in> IMG ` hom unity t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t \\<in> IMG ` hom unity t\n\ngoal (4 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b; local.set a = local.set b\\<rbrakk>\n       \\<Longrightarrow> a = b\n 2. \\<And>f f'.\n       \\<lbrakk>par f f';\n        \\<And>x.\n           \\<guillemotleft>x : unity \\<rightarrow> local.dom\n              f\\<guillemotright> \\<Longrightarrow>\n           f \\<cdot> x = f' \\<cdot> x\\<rbrakk>\n       \\<Longrightarrow> f = f'\n 3. \\<And>A.\n       \\<lbrakk>A \\<subseteq> Univ; |A| <o \\<AA>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a. ide a \\<and> local.set a = A\n 4. \\<And>a b F.\n       \\<lbrakk>ide a; ide b;\n        F \\<in> hom unity a \\<rightarrow> hom unity b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n                            (\\<forall>x.\n                                \\<guillemotleft>x : unity \\<rightarrow> local.dom\n                                   f\\<guillemotright> \\<longrightarrow>\n                                f \\<cdot> x = F x)", "next"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b; local.set a = local.set b\\<rbrakk>\n       \\<Longrightarrow> a = b\n 2. \\<And>f f'.\n       \\<lbrakk>par f f';\n        \\<And>x.\n           \\<guillemotleft>x : unity \\<rightarrow> local.dom\n              f\\<guillemotright> \\<Longrightarrow>\n           f \\<cdot> x = f' \\<cdot> x\\<rbrakk>\n       \\<Longrightarrow> f = f'\n 3. \\<And>A.\n       \\<lbrakk>A \\<subseteq> Univ; |A| <o \\<AA>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a. ide a \\<and> local.set a = A\n 4. \\<And>a b F.\n       \\<lbrakk>ide a; ide b;\n        F \\<in> hom unity a \\<rightarrow> hom unity b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n                            (\\<forall>x.\n                                \\<guillemotleft>x : unity \\<rightarrow> local.dom\n                                   f\\<guillemotright> \\<longrightarrow>\n                                f \\<cdot> x = F x)", "fix A :: \"'e setcat.arr set\""], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b; local.set a = local.set b\\<rbrakk>\n       \\<Longrightarrow> a = b\n 2. \\<And>f f'.\n       \\<lbrakk>par f f';\n        \\<And>x.\n           \\<guillemotleft>x : unity \\<rightarrow> local.dom\n              f\\<guillemotright> \\<Longrightarrow>\n           f \\<cdot> x = f' \\<cdot> x\\<rbrakk>\n       \\<Longrightarrow> f = f'\n 3. \\<And>A.\n       \\<lbrakk>A \\<subseteq> Univ; |A| <o \\<AA>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a. ide a \\<and> local.set a = A\n 4. \\<And>a b F.\n       \\<lbrakk>ide a; ide b;\n        F \\<in> hom unity a \\<rightarrow> hom unity b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n                            (\\<forall>x.\n                                \\<guillemotleft>x : unity \\<rightarrow> local.dom\n                                   f\\<guillemotright> \\<longrightarrow>\n                                f \\<cdot> x = F x)", "assume A: \"A \\<subseteq> Univ\" and 0: \"|A| <o \\<AA>\""], ["proof (state)\nthis:\n  A \\<subseteq> Univ\n  |A| <o \\<AA>\n\ngoal (4 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b; local.set a = local.set b\\<rbrakk>\n       \\<Longrightarrow> a = b\n 2. \\<And>f f'.\n       \\<lbrakk>par f f';\n        \\<And>x.\n           \\<guillemotleft>x : unity \\<rightarrow> local.dom\n              f\\<guillemotright> \\<Longrightarrow>\n           f \\<cdot> x = f' \\<cdot> x\\<rbrakk>\n       \\<Longrightarrow> f = f'\n 3. \\<And>A.\n       \\<lbrakk>A \\<subseteq> Univ; |A| <o \\<AA>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a. ide a \\<and> local.set a = A\n 4. \\<And>a b F.\n       \\<lbrakk>ide a; ide b;\n        F \\<in> hom unity a \\<rightarrow> hom unity b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n                            (\\<forall>x.\n                                \\<guillemotleft>x : unity \\<rightarrow> local.dom\n                                   f\\<guillemotright> \\<longrightarrow>\n                                f \\<cdot> x = F x)", "show \"\\<exists>a. ide a \\<and> set a = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a. ide a \\<and> local.set a = A", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. ide ?a \\<and> local.set ?a = A", "let ?a = \"MkArr (DOWN ` A) (DOWN ` A) (\\<lambda>x \\<in> (DOWN ` A). x)\""], ["proof (state)\ngoal (1 subgoal):\n 1. ide ?a \\<and> local.set ?a = A", "show \"ide ?a \\<and> set ?a = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide (MkIde (DOWN ` A)) \\<and> local.set (MkIde (DOWN ` A)) = A", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ide (MkIde (DOWN ` A))\n 2. local.set (MkIde (DOWN ` A)) = A", "have \"|DOWN ` A| <o \\<AA>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |DOWN ` A| <o \\<AA>", "using 0 card_of_image ordLeq_ordLess_trans"], ["proof (prove)\nusing this:\n  |A| <o \\<AA>\n  |?f ` ?A| \\<le>o |?A|\n  \\<lbrakk>?r \\<le>o ?r'; ?r' <o ?r''\\<rbrakk> \\<Longrightarrow> ?r <o ?r''\n\ngoal (1 subgoal):\n 1. |DOWN ` A| <o \\<AA>", "by blast"], ["proof (state)\nthis:\n  |DOWN ` A| <o \\<AA>\n\ngoal (2 subgoals):\n 1. ide (MkIde (DOWN ` A))\n 2. local.set (MkIde (DOWN ` A)) = A", "thus 1: \"ide ?a\""], ["proof (prove)\nusing this:\n  |DOWN ` A| <o \\<AA>\n\ngoal (1 subgoal):\n 1. ide (MkIde (DOWN ` A))", "using ide_char [of ?a]"], ["proof (prove)\nusing this:\n  |DOWN ` A| <o \\<AA>\n  ide (MkIde (DOWN ` A)) =\n  (MkIde (DOWN ` A) \\<noteq> Null \\<and>\n   Dom (MkIde (DOWN ` A)) \\<in> {A. |A| <o \\<AA>} \\<and>\n   Cod (MkIde (DOWN ` A)) = Dom (MkIde (DOWN ` A)) \\<and>\n   Map (MkIde (DOWN ` A)) = (\\<lambda>x\\<in>Dom (MkIde (DOWN ` A)). x))\n\ngoal (1 subgoal):\n 1. ide (MkIde (DOWN ` A))", "by simp"], ["proof (state)\nthis:\n  ide (MkIde (DOWN ` A))\n\ngoal (1 subgoal):\n 1. local.set (MkIde (DOWN ` A)) = A", "show \"set ?a = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.set (MkIde (DOWN ` A)) = A", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.set (MkIde (DOWN ` A)) = A", "have 2: \"\\<And>x. x \\<in> A \\<Longrightarrow> x = UP (DOWN x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A \\<Longrightarrow> x = UP (DOWN x)", "using A UP_DOWN"], ["proof (prove)\nusing this:\n  A \\<subseteq> Univ\n  ?t \\<in> Univ \\<Longrightarrow> UP (DOWN ?t) = ?t\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> A \\<Longrightarrow> x = UP (DOWN x)", "by force"], ["proof (state)\nthis:\n  ?x \\<in> A \\<Longrightarrow> ?x = UP (DOWN ?x)\n\ngoal (1 subgoal):\n 1. local.set (MkIde (DOWN ` A)) = A", "hence \"UP ` DOWN ` A = A\""], ["proof (prove)\nusing this:\n  ?x \\<in> A \\<Longrightarrow> ?x = UP (DOWN ?x)\n\ngoal (1 subgoal):\n 1. UP ` DOWN ` A = A", "using A UP_DOWN"], ["proof (prove)\nusing this:\n  ?x \\<in> A \\<Longrightarrow> ?x = UP (DOWN ?x)\n  A \\<subseteq> Univ\n  ?t \\<in> Univ \\<Longrightarrow> UP (DOWN ?t) = ?t\n\ngoal (1 subgoal):\n 1. UP ` DOWN ` A = A", "by auto"], ["proof (state)\nthis:\n  UP ` DOWN ` A = A\n\ngoal (1 subgoal):\n 1. local.set (MkIde (DOWN ` A)) = A", "thus ?thesis"], ["proof (prove)\nusing this:\n  UP ` DOWN ` A = A\n\ngoal (1 subgoal):\n 1. local.set (MkIde (DOWN ` A)) = A", "using 1 A set_char [of ?a]"], ["proof (prove)\nusing this:\n  UP ` DOWN ` A = A\n  ide (MkIde (DOWN ` A))\n  A \\<subseteq> Univ\n  ide (MkIde (DOWN ` A)) \\<Longrightarrow>\n  local.set (MkIde (DOWN ` A)) = UP ` Dom (MkIde (DOWN ` A))\n\ngoal (1 subgoal):\n 1. local.set (MkIde (DOWN ` A)) = A", "by simp"], ["proof (state)\nthis:\n  local.set (MkIde (DOWN ` A)) = A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.set (MkIde (DOWN ` A)) = A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ide (MkIde (DOWN ` A)) \\<and> local.set (MkIde (DOWN ` A)) = A\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a. ide a \\<and> local.set a = A\n\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b; local.set a = local.set b\\<rbrakk>\n       \\<Longrightarrow> a = b\n 2. \\<And>f f'.\n       \\<lbrakk>par f f';\n        \\<And>x.\n           \\<guillemotleft>x : unity \\<rightarrow> local.dom\n              f\\<guillemotright> \\<Longrightarrow>\n           f \\<cdot> x = f' \\<cdot> x\\<rbrakk>\n       \\<Longrightarrow> f = f'\n 3. \\<And>a b F.\n       \\<lbrakk>ide a; ide b;\n        F \\<in> hom unity a \\<rightarrow> hom unity b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n                            (\\<forall>x.\n                                \\<guillemotleft>x : unity \\<rightarrow> local.dom\n                                   f\\<guillemotright> \\<longrightarrow>\n                                f \\<cdot> x = F x)", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b; local.set a = local.set b\\<rbrakk>\n       \\<Longrightarrow> a = b\n 2. \\<And>f f'.\n       \\<lbrakk>par f f';\n        \\<And>x.\n           \\<guillemotleft>x : unity \\<rightarrow> local.dom\n              f\\<guillemotright> \\<Longrightarrow>\n           f \\<cdot> x = f' \\<cdot> x\\<rbrakk>\n       \\<Longrightarrow> f = f'\n 3. \\<And>a b F.\n       \\<lbrakk>ide a; ide b;\n        F \\<in> hom unity a \\<rightarrow> hom unity b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n                            (\\<forall>x.\n                                \\<guillemotleft>x : unity \\<rightarrow> local.dom\n                                   f\\<guillemotright> \\<longrightarrow>\n                                f \\<cdot> x = F x)", "fix a b :: \"'e setcat.arr\""], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b; local.set a = local.set b\\<rbrakk>\n       \\<Longrightarrow> a = b\n 2. \\<And>f f'.\n       \\<lbrakk>par f f';\n        \\<And>x.\n           \\<guillemotleft>x : unity \\<rightarrow> local.dom\n              f\\<guillemotright> \\<Longrightarrow>\n           f \\<cdot> x = f' \\<cdot> x\\<rbrakk>\n       \\<Longrightarrow> f = f'\n 3. \\<And>a b F.\n       \\<lbrakk>ide a; ide b;\n        F \\<in> hom unity a \\<rightarrow> hom unity b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n                            (\\<forall>x.\n                                \\<guillemotleft>x : unity \\<rightarrow> local.dom\n                                   f\\<guillemotright> \\<longrightarrow>\n                                f \\<cdot> x = F x)", "assume a: \"ide a\" and b: \"ide b\" and ab: \"set a = set b\""], ["proof (state)\nthis:\n  ide a\n  ide b\n  local.set a = local.set b\n\ngoal (3 subgoals):\n 1. \\<And>a b.\n       \\<lbrakk>ide a; ide b; local.set a = local.set b\\<rbrakk>\n       \\<Longrightarrow> a = b\n 2. \\<And>f f'.\n       \\<lbrakk>par f f';\n        \\<And>x.\n           \\<guillemotleft>x : unity \\<rightarrow> local.dom\n              f\\<guillemotright> \\<Longrightarrow>\n           f \\<cdot> x = f' \\<cdot> x\\<rbrakk>\n       \\<Longrightarrow> f = f'\n 3. \\<And>a b F.\n       \\<lbrakk>ide a; ide b;\n        F \\<in> hom unity a \\<rightarrow> hom unity b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n                            (\\<forall>x.\n                                \\<guillemotleft>x : unity \\<rightarrow> local.dom\n                                   f\\<guillemotright> \\<longrightarrow>\n                                f \\<cdot> x = F x)", "show \"a = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = b", "using a b ab set_char inj_UP inj_image_eq_iff dom_char in_homE ide_in_hom"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  local.set a = local.set b\n  ide ?a \\<Longrightarrow> local.set ?a = UP ` Dom ?a\n  inj UP\n  inj ?f \\<Longrightarrow> (?f ` ?A = ?f ` ?B) = (?A = ?B)\n  local.dom ?f = (if arr ?f then MkIde (Dom ?f) else null)\n  \\<lbrakk>\\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright>;\n   \\<lbrakk>arr ?f; local.dom ?f = ?a; cod ?f = ?b\\<rbrakk>\n   \\<Longrightarrow> ?T\\<rbrakk>\n  \\<Longrightarrow> ?T\n  ide ?a = \\<guillemotleft>?a : ?a \\<rightarrow> ?a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. a = b", "by (metis (mono_tags, lifting))"], ["proof (state)\nthis:\n  a = b\n\ngoal (2 subgoals):\n 1. \\<And>f f'.\n       \\<lbrakk>par f f';\n        \\<And>x.\n           \\<guillemotleft>x : unity \\<rightarrow> local.dom\n              f\\<guillemotright> \\<Longrightarrow>\n           f \\<cdot> x = f' \\<cdot> x\\<rbrakk>\n       \\<Longrightarrow> f = f'\n 2. \\<And>a b F.\n       \\<lbrakk>ide a; ide b;\n        F \\<in> hom unity a \\<rightarrow> hom unity b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n                            (\\<forall>x.\n                                \\<guillemotleft>x : unity \\<rightarrow> local.dom\n                                   f\\<guillemotright> \\<longrightarrow>\n                                f \\<cdot> x = F x)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f f'.\n       \\<lbrakk>par f f';\n        \\<And>x.\n           \\<guillemotleft>x : unity \\<rightarrow> local.dom\n              f\\<guillemotright> \\<Longrightarrow>\n           f \\<cdot> x = f' \\<cdot> x\\<rbrakk>\n       \\<Longrightarrow> f = f'\n 2. \\<And>a b F.\n       \\<lbrakk>ide a; ide b;\n        F \\<in> hom unity a \\<rightarrow> hom unity b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n                            (\\<forall>x.\n                                \\<guillemotleft>x : unity \\<rightarrow> local.dom\n                                   f\\<guillemotright> \\<longrightarrow>\n                                f \\<cdot> x = F x)", "fix f f' :: \"'e setcat.arr\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>f f'.\n       \\<lbrakk>par f f';\n        \\<And>x.\n           \\<guillemotleft>x : unity \\<rightarrow> local.dom\n              f\\<guillemotright> \\<Longrightarrow>\n           f \\<cdot> x = f' \\<cdot> x\\<rbrakk>\n       \\<Longrightarrow> f = f'\n 2. \\<And>a b F.\n       \\<lbrakk>ide a; ide b;\n        F \\<in> hom unity a \\<rightarrow> hom unity b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n                            (\\<forall>x.\n                                \\<guillemotleft>x : unity \\<rightarrow> local.dom\n                                   f\\<guillemotright> \\<longrightarrow>\n                                f \\<cdot> x = F x)", "assume par: \"par f f'\" and ff': \"\\<And>x. \\<guillemotleft>x : unity \\<rightarrow> dom f\\<guillemotright> \\<Longrightarrow> f \\<cdot> x = f' \\<cdot> x\""], ["proof (state)\nthis:\n  par f f'\n  \\<guillemotleft>?x : unity \\<rightarrow> local.dom\n      f\\<guillemotright> \\<Longrightarrow>\n  f \\<cdot> ?x = f' \\<cdot> ?x\n\ngoal (2 subgoals):\n 1. \\<And>f f'.\n       \\<lbrakk>par f f';\n        \\<And>x.\n           \\<guillemotleft>x : unity \\<rightarrow> local.dom\n              f\\<guillemotright> \\<Longrightarrow>\n           f \\<cdot> x = f' \\<cdot> x\\<rbrakk>\n       \\<Longrightarrow> f = f'\n 2. \\<And>a b F.\n       \\<lbrakk>ide a; ide b;\n        F \\<in> hom unity a \\<rightarrow> hom unity b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n                            (\\<forall>x.\n                                \\<guillemotleft>x : unity \\<rightarrow> local.dom\n                                   f\\<guillemotright> \\<longrightarrow>\n                                f \\<cdot> x = F x)", "show \"f = f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = f'", "using par ff' arr_eqI'"], ["proof (prove)\nusing this:\n  par f f'\n  \\<guillemotleft>?x : unity \\<rightarrow> local.dom\n      f\\<guillemotright> \\<Longrightarrow>\n  f \\<cdot> ?x = f' \\<cdot> ?x\n  \\<lbrakk>par ?f ?f';\n   \\<And>t.\n      \\<guillemotleft>t : unity \\<rightarrow> local.dom\n         ?f\\<guillemotright> \\<Longrightarrow>\n      ?f \\<cdot> t = ?f' \\<cdot> t\\<rbrakk>\n  \\<Longrightarrow> ?f = ?f'\n\ngoal (1 subgoal):\n 1. f = f'", "by blast"], ["proof (state)\nthis:\n  f = f'\n\ngoal (1 subgoal):\n 1. \\<And>a b F.\n       \\<lbrakk>ide a; ide b;\n        F \\<in> hom unity a \\<rightarrow> hom unity b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n                            (\\<forall>x.\n                                \\<guillemotleft>x : unity \\<rightarrow> local.dom\n                                   f\\<guillemotright> \\<longrightarrow>\n                                f \\<cdot> x = F x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b F.\n       \\<lbrakk>ide a; ide b;\n        F \\<in> hom unity a \\<rightarrow> hom unity b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n                            (\\<forall>x.\n                                \\<guillemotleft>x : unity \\<rightarrow> local.dom\n                                   f\\<guillemotright> \\<longrightarrow>\n                                f \\<cdot> x = F x)", "fix a b :: \"'e setcat.arr\" and F :: \"'e setcat.arr \\<Rightarrow> 'e setcat.arr\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a b F.\n       \\<lbrakk>ide a; ide b;\n        F \\<in> hom unity a \\<rightarrow> hom unity b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n                            (\\<forall>x.\n                                \\<guillemotleft>x : unity \\<rightarrow> local.dom\n                                   f\\<guillemotright> \\<longrightarrow>\n                                f \\<cdot> x = F x)", "assume a: \"ide a\" and b: \"ide b\" and F: \"F \\<in> hom unity a \\<rightarrow> hom unity b\""], ["proof (state)\nthis:\n  ide a\n  ide b\n  F \\<in> hom unity a \\<rightarrow> hom unity b\n\ngoal (1 subgoal):\n 1. \\<And>a b F.\n       \\<lbrakk>ide a; ide b;\n        F \\<in> hom unity a \\<rightarrow> hom unity b\\<rbrakk>\n       \\<Longrightarrow> \\<exists>f.\n                            \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n                            (\\<forall>x.\n                                \\<guillemotleft>x : unity \\<rightarrow> local.dom\n                                   f\\<guillemotright> \\<longrightarrow>\n                                f \\<cdot> x = F x)", "show \"\\<exists>f. \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and> (\\<forall>x. \\<guillemotleft>x : unity \\<rightarrow> dom f\\<guillemotright> \\<longrightarrow> f \\<cdot> x = F x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n       (\\<forall>x.\n           \\<guillemotleft>x : unity \\<rightarrow> local.dom\n              f\\<guillemotright> \\<longrightarrow>\n           f \\<cdot> x = F x)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<guillemotleft>?f : a \\<rightarrow> b\\<guillemotright> \\<and>\n    (\\<forall>x.\n        \\<guillemotleft>x : unity \\<rightarrow> local.dom\n           ?f\\<guillemotright> \\<longrightarrow>\n        ?f \\<cdot> x = F x)", "let ?f = \"MkArr (Dom a) (Dom b) (\\<lambda>x \\<in> Dom a. Map (F (MkElem (UP x) a)) U)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<guillemotleft>?f : a \\<rightarrow> b\\<guillemotright> \\<and>\n    (\\<forall>x.\n        \\<guillemotleft>x : unity \\<rightarrow> local.dom\n           ?f\\<guillemotright> \\<longrightarrow>\n        ?f \\<cdot> x = F x)", "have 1: \"\\<guillemotleft>?f : a \\<rightarrow> b\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>MkArr (Dom a) (Dom b)\n                     (\\<lambda>x\\<in>Dom a.\n                         Map (F (MkArr {U} (Dom a)\n                                  (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                          U) : a \\<rightarrow> b\\<guillemotright>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<guillemotleft>MkArr (Dom a) (Dom b)\n                     (\\<lambda>x\\<in>Dom a.\n                         Map (F (MkArr {U} (Dom a)\n                                  (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                          U) : a \\<rightarrow> b\\<guillemotright>", "have \"(\\<lambda>x \\<in> Dom a. Map (F (MkElem (UP x) a)) U)\n                      \\<in> extensional (Dom a) \\<inter> (Dom a \\<rightarrow> Dom b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<in>Dom a.\n        Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)))) U)\n    \\<in> extensional (Dom a) \\<inter> (Dom a \\<rightarrow> Dom b)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<lambda>x\\<in>Dom a.\n        Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)))) U)\n    \\<in> extensional (Dom a)\n 2. (\\<lambda>x\\<in>Dom a.\n        Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)))) U)\n    \\<in> Dom a \\<rightarrow> Dom b", "show \"(\\<lambda>x \\<in> Dom a. Map (F (MkElem (UP x) a)) U) \\<in> extensional (Dom a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<in>Dom a.\n        Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)))) U)\n    \\<in> extensional (Dom a)", "using a F"], ["proof (prove)\nusing this:\n  ide a\n  F \\<in> hom unity a \\<rightarrow> hom unity b\n\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<in>Dom a.\n        Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)))) U)\n    \\<in> extensional (Dom a)", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>x\\<in>Dom a.\n      Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)))) U)\n  \\<in> extensional (Dom a)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<in>Dom a.\n        Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)))) U)\n    \\<in> Dom a \\<rightarrow> Dom b", "show \"(\\<lambda>x \\<in> Dom a. Map (F (MkElem (UP x) a)) U) \\<in> Dom a \\<rightarrow> Dom b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<in>Dom a.\n        Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)))) U)\n    \\<in> Dom a \\<rightarrow> Dom b", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Dom a \\<Longrightarrow>\n       Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)))) U\n       \\<in> Dom b", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Dom a \\<Longrightarrow>\n       Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)))) U\n       \\<in> Dom b", "assume x: \"x \\<in> Dom a\""], ["proof (state)\nthis:\n  x \\<in> Dom a\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Dom a \\<Longrightarrow>\n       Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)))) U\n       \\<in> Dom b", "have \"MkElem (UP x) a \\<in> hom unity a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)) \\<in> hom unity a", "using x a MkElem_in_hom [of a x] ide_char ideD(1-2)"], ["proof (prove)\nusing this:\n  x \\<in> Dom a\n  ide a\n  \\<lbrakk>arr a; x \\<in> Dom a\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>MkArr {U} (Dom (local.dom a))\n                                     (\\<lambda>_\\<in>{U}.\n   DOWN (UP x)) : unity \\<rightarrow> local.dom a\\<guillemotright>\n  ide ?f =\n  (?f \\<noteq> Null \\<and>\n   Dom ?f \\<in> {A. |A| <o \\<AA>} \\<and>\n   Cod ?f = Dom ?f \\<and> Map ?f = (\\<lambda>x\\<in>Dom ?f. x))\n  ide ?a \\<Longrightarrow> arr ?a\n  ide ?a \\<Longrightarrow> local.dom ?a = ?a\n\ngoal (1 subgoal):\n 1. MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)) \\<in> hom unity a", "by force"], ["proof (state)\nthis:\n  MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)) \\<in> hom unity a\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Dom a \\<Longrightarrow>\n       Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)))) U\n       \\<in> Dom b", "hence 1: \"F (MkElem (UP x) a) \\<in> hom unity b\""], ["proof (prove)\nusing this:\n  MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)) \\<in> hom unity a\n\ngoal (1 subgoal):\n 1. F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)))\n    \\<in> hom unity b", "using F"], ["proof (prove)\nusing this:\n  MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)) \\<in> hom unity a\n  F \\<in> hom unity a \\<rightarrow> hom unity b\n\ngoal (1 subgoal):\n 1. F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)))\n    \\<in> hom unity b", "by auto"], ["proof (state)\nthis:\n  F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))) \\<in> hom unity b\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Dom a \\<Longrightarrow>\n       Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)))) U\n       \\<in> Dom b", "moreover"], ["proof (state)\nthis:\n  F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))) \\<in> hom unity b\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Dom a \\<Longrightarrow>\n       Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)))) U\n       \\<in> Dom b", "have \"Dom (F (MkElem (UP x) a)) = {U}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dom (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)))) = {U}", "using 1 MkElem_IMG"], ["proof (prove)\nusing this:\n  F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))) \\<in> hom unity b\n  ?p \\<in> hom unity ?a \\<Longrightarrow>\n  MkArr {U} (Dom ?a) (\\<lambda>_\\<in>{U}. DOWN (IMG ?p)) = ?p\n\ngoal (1 subgoal):\n 1. Dom (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)))) = {U}", "by (metis (mono_tags, lifting) Dom.simps(1))"], ["proof (state)\nthis:\n  Dom (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)))) = {U}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Dom a \\<Longrightarrow>\n       Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)))) U\n       \\<in> Dom b", "moreover"], ["proof (state)\nthis:\n  Dom (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)))) = {U}\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Dom a \\<Longrightarrow>\n       Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)))) U\n       \\<in> Dom b", "have \"Cod (F (MkElem (UP x) a)) = Dom b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cod (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)))) = Dom b", "using 1"], ["proof (prove)\nusing this:\n  F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))) \\<in> hom unity b\n\ngoal (1 subgoal):\n 1. Cod (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)))) = Dom b", "by (metis (mono_tags, lifting) CollectD in_hom_char)"], ["proof (state)\nthis:\n  Cod (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)))) = Dom b\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Dom a \\<Longrightarrow>\n       Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)))) U\n       \\<in> Dom b", "ultimately"], ["proof (chain)\npicking this:\n  F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))) \\<in> hom unity b\n  Dom (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)))) = {U}\n  Cod (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)))) = Dom b", "have \"Map (F (MkElem (UP x) a)) \\<in> {U} \\<rightarrow> Dom b\""], ["proof (prove)\nusing this:\n  F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))) \\<in> hom unity b\n  Dom (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)))) = {U}\n  Cod (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)))) = Dom b\n\ngoal (1 subgoal):\n 1. Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n    \\<in> {U} \\<rightarrow> Dom b", "using arr_char [of \"F (MkElem (UP x) a)\"]"], ["proof (prove)\nusing this:\n  F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))) \\<in> hom unity b\n  Dom (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)))) = {U}\n  Cod (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)))) = Dom b\n  arr (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)))) =\n  (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))) \\<noteq>\n   Null \\<and>\n   |Dom (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))| <o\n   \\<AA> \\<and>\n   |Cod (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))| <o\n   \\<AA> \\<and>\n   Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n   \\<in> extensional\n          (Dom (F (MkArr {U} (Dom a)\n                    (\\<lambda>_\\<in>{U}. DOWN (UP x))))) \\<inter>\n         (Dom (F (MkArr {U} (Dom a)\n                   (\\<lambda>_\\<in>{U}. DOWN (UP x)))) \\<rightarrow>\n          Cod (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))))\n\ngoal (1 subgoal):\n 1. Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n    \\<in> {U} \\<rightarrow> Dom b", "by blast"], ["proof (state)\nthis:\n  Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n  \\<in> {U} \\<rightarrow> Dom b\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Dom a \\<Longrightarrow>\n       Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)))) U\n       \\<in> Dom b", "thus \"Map (F (MkElem (UP x) a)) U \\<in> Dom b\""], ["proof (prove)\nusing this:\n  Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n  \\<in> {U} \\<rightarrow> Dom b\n\ngoal (1 subgoal):\n 1. Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)))) U\n    \\<in> Dom b", "by blast"], ["proof (state)\nthis:\n  Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)))) U\n  \\<in> Dom b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>x\\<in>Dom a.\n      Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)))) U)\n  \\<in> Dom a \\<rightarrow> Dom b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>x\\<in>Dom a.\n      Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)))) U)\n  \\<in> extensional (Dom a) \\<inter> (Dom a \\<rightarrow> Dom b)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>MkArr (Dom a) (Dom b)\n                     (\\<lambda>x\\<in>Dom a.\n                         Map (F (MkArr {U} (Dom a)\n                                  (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                          U) : a \\<rightarrow> b\\<guillemotright>", "hence \"\\<guillemotleft>?f : MkIde (Dom a) \\<rightarrow> MkIde (Dom b)\\<guillemotright>\""], ["proof (prove)\nusing this:\n  (\\<lambda>x\\<in>Dom a.\n      Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)))) U)\n  \\<in> extensional (Dom a) \\<inter> (Dom a \\<rightarrow> Dom b)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>MkArr (Dom a) (Dom b)\n                     (\\<lambda>x\\<in>Dom a.\n                         Map (F (MkArr {U} (Dom a)\n                                  (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                          U) : MkIde\n                                (Dom a) \\<rightarrow> MkIde\n                 (Dom b)\\<guillemotright>", "using a b MkArr_in_hom ide_char"], ["proof (prove)\nusing this:\n  (\\<lambda>x\\<in>Dom a.\n      Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x)))) U)\n  \\<in> extensional (Dom a) \\<inter> (Dom a \\<rightarrow> Dom b)\n  ide a\n  ide b\n  \\<lbrakk>?A \\<in> {A. |A| <o \\<AA>}; ?B \\<in> {A. |A| <o \\<AA>};\n   ?f \\<in> extensional ?A \\<inter> (?A \\<rightarrow> ?B)\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>MkArr ?A ?B\n                                     ?f : MkIde\n     ?A \\<rightarrow> MkIde ?B\\<guillemotright>\n  ide ?f =\n  (?f \\<noteq> Null \\<and>\n   Dom ?f \\<in> {A. |A| <o \\<AA>} \\<and>\n   Cod ?f = Dom ?f \\<and> Map ?f = (\\<lambda>x\\<in>Dom ?f. x))\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>MkArr (Dom a) (Dom b)\n                     (\\<lambda>x\\<in>Dom a.\n                         Map (F (MkArr {U} (Dom a)\n                                  (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                          U) : MkIde\n                                (Dom a) \\<rightarrow> MkIde\n                 (Dom b)\\<guillemotright>", "by blast"], ["proof (state)\nthis:\n  \\<guillemotleft>MkArr (Dom a) (Dom b)\n                   (\\<lambda>x\\<in>Dom a.\n                       Map (F (MkArr {U} (Dom a)\n                                (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                        U) : MkIde\n                              (Dom a) \\<rightarrow> MkIde\n               (Dom b)\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>MkArr (Dom a) (Dom b)\n                     (\\<lambda>x\\<in>Dom a.\n                         Map (F (MkArr {U} (Dom a)\n                                  (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                          U) : a \\<rightarrow> b\\<guillemotright>", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<guillemotleft>MkArr (Dom a) (Dom b)\n                   (\\<lambda>x\\<in>Dom a.\n                       Map (F (MkArr {U} (Dom a)\n                                (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                        U) : MkIde\n                              (Dom a) \\<rightarrow> MkIde\n               (Dom b)\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>MkArr (Dom a) (Dom b)\n                     (\\<lambda>x\\<in>Dom a.\n                         Map (F (MkArr {U} (Dom a)\n                                  (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                          U) : a \\<rightarrow> b\\<guillemotright>", "using a b"], ["proof (prove)\nusing this:\n  \\<guillemotleft>MkArr (Dom a) (Dom b)\n                   (\\<lambda>x\\<in>Dom a.\n                       Map (F (MkArr {U} (Dom a)\n                                (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                        U) : MkIde\n                              (Dom a) \\<rightarrow> MkIde\n               (Dom b)\\<guillemotright>\n  ide a\n  ide b\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>MkArr (Dom a) (Dom b)\n                     (\\<lambda>x\\<in>Dom a.\n                         Map (F (MkArr {U} (Dom a)\n                                  (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                          U) : a \\<rightarrow> b\\<guillemotright>", "by simp"], ["proof (state)\nthis:\n  \\<guillemotleft>MkArr (Dom a) (Dom b)\n                   (\\<lambda>x\\<in>Dom a.\n                       Map (F (MkArr {U} (Dom a)\n                                (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                        U) : a \\<rightarrow> b\\<guillemotright>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<guillemotleft>MkArr (Dom a) (Dom b)\n                   (\\<lambda>x\\<in>Dom a.\n                       Map (F (MkArr {U} (Dom a)\n                                (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                        U) : a \\<rightarrow> b\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>?f : a \\<rightarrow> b\\<guillemotright> \\<and>\n    (\\<forall>x.\n        \\<guillemotleft>x : unity \\<rightarrow> local.dom\n           ?f\\<guillemotright> \\<longrightarrow>\n        ?f \\<cdot> x = F x)", "moreover"], ["proof (state)\nthis:\n  \\<guillemotleft>MkArr (Dom a) (Dom b)\n                   (\\<lambda>x\\<in>Dom a.\n                       Map (F (MkArr {U} (Dom a)\n                                (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                        U) : a \\<rightarrow> b\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>?f : a \\<rightarrow> b\\<guillemotright> \\<and>\n    (\\<forall>x.\n        \\<guillemotleft>x : unity \\<rightarrow> local.dom\n           ?f\\<guillemotright> \\<longrightarrow>\n        ?f \\<cdot> x = F x)", "have \"\\<And>x. \\<guillemotleft>x : unity \\<rightarrow> dom ?f\\<guillemotright> \\<Longrightarrow> ?f \\<cdot> x = F x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<guillemotleft>x : unity \\<rightarrow> local.dom\n          (MkArr (Dom a) (Dom b)\n            (\\<lambda>x\\<in>Dom a.\n                Map (F (MkArr {U} (Dom a)\n                         (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                 U))\\<guillemotright> \\<Longrightarrow>\n       MkArr (Dom a) (Dom b)\n        (\\<lambda>x\\<in>Dom a.\n            Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n             U) \\<cdot>\n       x =\n       F x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<guillemotleft>x : unity \\<rightarrow> local.dom\n          (MkArr (Dom a) (Dom b)\n            (\\<lambda>x\\<in>Dom a.\n                Map (F (MkArr {U} (Dom a)\n                         (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                 U))\\<guillemotright> \\<Longrightarrow>\n       MkArr (Dom a) (Dom b)\n        (\\<lambda>x\\<in>Dom a.\n            Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n             U) \\<cdot>\n       x =\n       F x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<guillemotleft>x : unity \\<rightarrow> local.dom\n          (MkArr (Dom a) (Dom b)\n            (\\<lambda>x\\<in>Dom a.\n                Map (F (MkArr {U} (Dom a)\n                         (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                 U))\\<guillemotright> \\<Longrightarrow>\n       MkArr (Dom a) (Dom b)\n        (\\<lambda>x\\<in>Dom a.\n            Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n             U) \\<cdot>\n       x =\n       F x", "assume x: \"\\<guillemotleft>x : unity \\<rightarrow> dom ?f\\<guillemotright>\""], ["proof (state)\nthis:\n  \\<guillemotleft>x : unity \\<rightarrow> local.dom\n     (MkArr (Dom a) (Dom b)\n       (\\<lambda>x\\<in>Dom a.\n           Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n            U))\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<guillemotleft>x : unity \\<rightarrow> local.dom\n          (MkArr (Dom a) (Dom b)\n            (\\<lambda>x\\<in>Dom a.\n                Map (F (MkArr {U} (Dom a)\n                         (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                 U))\\<guillemotright> \\<Longrightarrow>\n       MkArr (Dom a) (Dom b)\n        (\\<lambda>x\\<in>Dom a.\n            Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n             U) \\<cdot>\n       x =\n       F x", "have 2: \"x = MkElem (IMG x) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (IMG x))", "using a x 1 MkElem_IMG [of x a]"], ["proof (prove)\nusing this:\n  ide a\n  \\<guillemotleft>x : unity \\<rightarrow> local.dom\n     (MkArr (Dom a) (Dom b)\n       (\\<lambda>x\\<in>Dom a.\n           Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n            U))\\<guillemotright>\n  \\<guillemotleft>MkArr (Dom a) (Dom b)\n                   (\\<lambda>x\\<in>Dom a.\n                       Map (F (MkArr {U} (Dom a)\n                                (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                        U) : a \\<rightarrow> b\\<guillemotright>\n  x \\<in> hom unity a \\<Longrightarrow>\n  MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (IMG x)) = x\n\ngoal (1 subgoal):\n 1. x = MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (IMG x))", "by (metis (mono_tags, lifting) in_homE mem_Collect_eq)"], ["proof (state)\nthis:\n  x = MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (IMG x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<guillemotleft>x : unity \\<rightarrow> local.dom\n          (MkArr (Dom a) (Dom b)\n            (\\<lambda>x\\<in>Dom a.\n                Map (F (MkArr {U} (Dom a)\n                         (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                 U))\\<guillemotright> \\<Longrightarrow>\n       MkArr (Dom a) (Dom b)\n        (\\<lambda>x\\<in>Dom a.\n            Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n             U) \\<cdot>\n       x =\n       F x", "moreover"], ["proof (state)\nthis:\n  x = MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (IMG x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<guillemotleft>x : unity \\<rightarrow> local.dom\n          (MkArr (Dom a) (Dom b)\n            (\\<lambda>x\\<in>Dom a.\n                Map (F (MkArr {U} (Dom a)\n                         (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                 U))\\<guillemotright> \\<Longrightarrow>\n       MkArr (Dom a) (Dom b)\n        (\\<lambda>x\\<in>Dom a.\n            Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n             U) \\<cdot>\n       x =\n       F x", "have 5: \"Dom x = {U} \\<and> Cod x = Dom a \\<and>\n                                Map x = (\\<lambda>_ \\<in> {U}. DOWN (IMG x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dom x = {U} \\<and>\n    Cod x = Dom a \\<and> Map x = (\\<lambda>_\\<in>{U}. DOWN (IMG x))", "using x 2"], ["proof (prove)\nusing this:\n  \\<guillemotleft>x : unity \\<rightarrow> local.dom\n     (MkArr (Dom a) (Dom b)\n       (\\<lambda>x\\<in>Dom a.\n           Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n            U))\\<guillemotright>\n  x = MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (IMG x))\n\ngoal (1 subgoal):\n 1. Dom x = {U} \\<and>\n    Cod x = Dom a \\<and> Map x = (\\<lambda>_\\<in>{U}. DOWN (IMG x))", "by (metis (no_types, lifting) Cod.simps(1) Dom.simps(1) Map.simps(1))"], ["proof (state)\nthis:\n  Dom x = {U} \\<and>\n  Cod x = Dom a \\<and> Map x = (\\<lambda>_\\<in>{U}. DOWN (IMG x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<guillemotleft>x : unity \\<rightarrow> local.dom\n          (MkArr (Dom a) (Dom b)\n            (\\<lambda>x\\<in>Dom a.\n                Map (F (MkArr {U} (Dom a)\n                         (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                 U))\\<guillemotright> \\<Longrightarrow>\n       MkArr (Dom a) (Dom b)\n        (\\<lambda>x\\<in>Dom a.\n            Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n             U) \\<cdot>\n       x =\n       F x", "moreover"], ["proof (state)\nthis:\n  Dom x = {U} \\<and>\n  Cod x = Dom a \\<and> Map x = (\\<lambda>_\\<in>{U}. DOWN (IMG x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<guillemotleft>x : unity \\<rightarrow> local.dom\n          (MkArr (Dom a) (Dom b)\n            (\\<lambda>x\\<in>Dom a.\n                Map (F (MkArr {U} (Dom a)\n                         (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                 U))\\<guillemotright> \\<Longrightarrow>\n       MkArr (Dom a) (Dom b)\n        (\\<lambda>x\\<in>Dom a.\n            Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n             U) \\<cdot>\n       x =\n       F x", "have \"Cod ?f = Dom b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cod (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U)) =\n    Dom b", "using 1"], ["proof (prove)\nusing this:\n  \\<guillemotleft>MkArr (Dom a) (Dom b)\n                   (\\<lambda>x\\<in>Dom a.\n                       Map (F (MkArr {U} (Dom a)\n                                (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                        U) : a \\<rightarrow> b\\<guillemotright>\n\ngoal (1 subgoal):\n 1. Cod (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U)) =\n    Dom b", "by simp"], ["proof (state)\nthis:\n  Cod (MkArr (Dom a) (Dom b)\n        (\\<lambda>x\\<in>Dom a.\n            Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n             U)) =\n  Dom b\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<guillemotleft>x : unity \\<rightarrow> local.dom\n          (MkArr (Dom a) (Dom b)\n            (\\<lambda>x\\<in>Dom a.\n                Map (F (MkArr {U} (Dom a)\n                         (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                 U))\\<guillemotright> \\<Longrightarrow>\n       MkArr (Dom a) (Dom b)\n        (\\<lambda>x\\<in>Dom a.\n            Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n             U) \\<cdot>\n       x =\n       F x", "ultimately"], ["proof (chain)\npicking this:\n  x = MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (IMG x))\n  Dom x = {U} \\<and>\n  Cod x = Dom a \\<and> Map x = (\\<lambda>_\\<in>{U}. DOWN (IMG x))\n  Cod (MkArr (Dom a) (Dom b)\n        (\\<lambda>x\\<in>Dom a.\n            Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n             U)) =\n  Dom b", "have\n                   3: \"?f \\<cdot> x =\n                       MkArr {U} (Dom b) (compose {U} (Map ?f) (\\<lambda>_ \\<in> {U}. DOWN (IMG x)))\""], ["proof (prove)\nusing this:\n  x = MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (IMG x))\n  Dom x = {U} \\<and>\n  Cod x = Dom a \\<and> Map x = (\\<lambda>_\\<in>{U}. DOWN (IMG x))\n  Cod (MkArr (Dom a) (Dom b)\n        (\\<lambda>x\\<in>Dom a.\n            Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n             U)) =\n  Dom b\n\ngoal (1 subgoal):\n 1. MkArr (Dom a) (Dom b)\n     (\\<lambda>x\\<in>Dom a.\n         Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n          U) \\<cdot>\n    x =\n    MkArr {U} (Dom b)\n     (compose {U}\n       (Map (MkArr (Dom a) (Dom b)\n              (\\<lambda>x\\<in>Dom a.\n                  Map (F (MkArr {U} (Dom a)\n                           (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                   U)))\n       (\\<lambda>_\\<in>{U}. DOWN (IMG x)))", "using 1 x comp_char [of ?f \"MkElem (IMG x) a\"]"], ["proof (prove)\nusing this:\n  x = MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (IMG x))\n  Dom x = {U} \\<and>\n  Cod x = Dom a \\<and> Map x = (\\<lambda>_\\<in>{U}. DOWN (IMG x))\n  Cod (MkArr (Dom a) (Dom b)\n        (\\<lambda>x\\<in>Dom a.\n            Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n             U)) =\n  Dom b\n  \\<guillemotleft>MkArr (Dom a) (Dom b)\n                   (\\<lambda>x\\<in>Dom a.\n                       Map (F (MkArr {U} (Dom a)\n                                (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                        U) : a \\<rightarrow> b\\<guillemotright>\n  \\<guillemotleft>x : unity \\<rightarrow> local.dom\n     (MkArr (Dom a) (Dom b)\n       (\\<lambda>x\\<in>Dom a.\n           Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n            U))\\<guillemotright>\n  MkArr (Dom a) (Dom b)\n   (\\<lambda>x\\<in>Dom a.\n       Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n        U) \\<cdot>\n  MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (IMG x)) =\n  (if seq (MkArr (Dom a) (Dom b)\n            (\\<lambda>x\\<in>Dom a.\n                Map (F (MkArr {U} (Dom a)\n                         (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                 U))\n       (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (IMG x)))\n   then MkArr (Dom (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (IMG x))))\n         (Cod (MkArr (Dom a) (Dom b)\n                (\\<lambda>x\\<in>Dom a.\n                    Map (F (MkArr {U} (Dom a)\n                             (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                     U)))\n         (compose\n           (Dom (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (IMG x))))\n           (Map (MkArr (Dom a) (Dom b)\n                  (\\<lambda>x\\<in>Dom a.\n                      Map (F (MkArr {U} (Dom a)\n                               (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                       U)))\n           (Map (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (IMG x)))))\n   else null)\n\ngoal (1 subgoal):\n 1. MkArr (Dom a) (Dom b)\n     (\\<lambda>x\\<in>Dom a.\n         Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n          U) \\<cdot>\n    x =\n    MkArr {U} (Dom b)\n     (compose {U}\n       (Map (MkArr (Dom a) (Dom b)\n              (\\<lambda>x\\<in>Dom a.\n                  Map (F (MkArr {U} (Dom a)\n                           (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                   U)))\n       (\\<lambda>_\\<in>{U}. DOWN (IMG x)))", "by (metis (mono_tags, lifting) in_homE seqI)"], ["proof (state)\nthis:\n  MkArr (Dom a) (Dom b)\n   (\\<lambda>x\\<in>Dom a.\n       Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n        U) \\<cdot>\n  x =\n  MkArr {U} (Dom b)\n   (compose {U}\n     (Map (MkArr (Dom a) (Dom b)\n            (\\<lambda>x\\<in>Dom a.\n                Map (F (MkArr {U} (Dom a)\n                         (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                 U)))\n     (\\<lambda>_\\<in>{U}. DOWN (IMG x)))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<guillemotleft>x : unity \\<rightarrow> local.dom\n          (MkArr (Dom a) (Dom b)\n            (\\<lambda>x\\<in>Dom a.\n                Map (F (MkArr {U} (Dom a)\n                         (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                 U))\\<guillemotright> \\<Longrightarrow>\n       MkArr (Dom a) (Dom b)\n        (\\<lambda>x\\<in>Dom a.\n            Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n             U) \\<cdot>\n       x =\n       F x", "have 4: \"compose {U} (Map ?f) (\\<lambda>_ \\<in> {U}. DOWN (IMG x)) = Map (F x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compose {U}\n     (Map (MkArr (Dom a) (Dom b)\n            (\\<lambda>x\\<in>Dom a.\n                Map (F (MkArr {U} (Dom a)\n                         (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                 U)))\n     (\\<lambda>_\\<in>{U}. DOWN (IMG x)) =\n    Map (F x)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       compose {U}\n        (Map (MkArr (Dom a) (Dom b)\n               (\\<lambda>x\\<in>Dom a.\n                   Map (F (MkArr {U} (Dom a)\n                            (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                    U)))\n        (\\<lambda>_\\<in>{U}. DOWN (IMG x)) xa =\n       Map (F x) xa", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       compose {U}\n        (Map (MkArr (Dom a) (Dom b)\n               (\\<lambda>x\\<in>Dom a.\n                   Map (F (MkArr {U} (Dom a)\n                            (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                    U)))\n        (\\<lambda>_\\<in>{U}. DOWN (IMG x)) xa =\n       Map (F x) xa", "have \"y \\<notin> {U} \\<Longrightarrow>\n                        compose {U} (Map ?f) (\\<lambda>_ \\<in> {U}. DOWN (IMG x)) y = Map (F x) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<notin> {U} \\<Longrightarrow>\n    compose {U}\n     (Map (MkArr (Dom a) (Dom b)\n            (\\<lambda>x\\<in>Dom a.\n                Map (F (MkArr {U} (Dom a)\n                         (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                 U)))\n     (\\<lambda>_\\<in>{U}. DOWN (IMG x)) y =\n    Map (F x) y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<notin> {U} \\<Longrightarrow>\n    compose {U}\n     (Map (MkArr (Dom a) (Dom b)\n            (\\<lambda>x\\<in>Dom a.\n                Map (F (MkArr {U} (Dom a)\n                         (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                 U)))\n     (\\<lambda>_\\<in>{U}. DOWN (IMG x)) y =\n    Map (F x) y", "assume y: \"y \\<notin> {U}\""], ["proof (state)\nthis:\n  y \\<notin> {U}\n\ngoal (1 subgoal):\n 1. y \\<notin> {U} \\<Longrightarrow>\n    compose {U}\n     (Map (MkArr (Dom a) (Dom b)\n            (\\<lambda>x\\<in>Dom a.\n                Map (F (MkArr {U} (Dom a)\n                         (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                 U)))\n     (\\<lambda>_\\<in>{U}. DOWN (IMG x)) y =\n    Map (F x) y", "have \"compose {U} (Map ?f) (\\<lambda>_ \\<in> {U}. DOWN (IMG x)) y = undefined\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compose {U}\n     (Map (MkArr (Dom a) (Dom b)\n            (\\<lambda>x\\<in>Dom a.\n                Map (F (MkArr {U} (Dom a)\n                         (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                 U)))\n     (\\<lambda>_\\<in>{U}. DOWN (IMG x)) y =\n    undefined", "using y compose_def extensional_arb"], ["proof (prove)\nusing this:\n  y \\<notin> {U}\n  compose ?A ?g ?f = (\\<lambda>x\\<in>?A. ?g (?f x))\n  \\<lbrakk>?f \\<in> extensional ?A; ?x \\<notin> ?A\\<rbrakk>\n  \\<Longrightarrow> ?f ?x = undefined\n\ngoal (1 subgoal):\n 1. compose {U}\n     (Map (MkArr (Dom a) (Dom b)\n            (\\<lambda>x\\<in>Dom a.\n                Map (F (MkArr {U} (Dom a)\n                         (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                 U)))\n     (\\<lambda>_\\<in>{U}. DOWN (IMG x)) y =\n    undefined", "by simp"], ["proof (state)\nthis:\n  compose {U}\n   (Map (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U)))\n   (\\<lambda>_\\<in>{U}. DOWN (IMG x)) y =\n  undefined\n\ngoal (1 subgoal):\n 1. y \\<notin> {U} \\<Longrightarrow>\n    compose {U}\n     (Map (MkArr (Dom a) (Dom b)\n            (\\<lambda>x\\<in>Dom a.\n                Map (F (MkArr {U} (Dom a)\n                         (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                 U)))\n     (\\<lambda>_\\<in>{U}. DOWN (IMG x)) y =\n    Map (F x) y", "also"], ["proof (state)\nthis:\n  compose {U}\n   (Map (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U)))\n   (\\<lambda>_\\<in>{U}. DOWN (IMG x)) y =\n  undefined\n\ngoal (1 subgoal):\n 1. y \\<notin> {U} \\<Longrightarrow>\n    compose {U}\n     (Map (MkArr (Dom a) (Dom b)\n            (\\<lambda>x\\<in>Dom a.\n                Map (F (MkArr {U} (Dom a)\n                         (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                 U)))\n     (\\<lambda>_\\<in>{U}. DOWN (IMG x)) y =\n    Map (F x) y", "have \"... = Map (F x) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. undefined = Map (F x) y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. undefined = Map (F x) y", "have 5: \"F x \\<in> hom unity b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F x \\<in> hom unity b", "using x F 1"], ["proof (prove)\nusing this:\n  \\<guillemotleft>x : unity \\<rightarrow> local.dom\n     (MkArr (Dom a) (Dom b)\n       (\\<lambda>x\\<in>Dom a.\n           Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n            U))\\<guillemotright>\n  F \\<in> hom unity a \\<rightarrow> hom unity b\n  \\<guillemotleft>MkArr (Dom a) (Dom b)\n                   (\\<lambda>x\\<in>Dom a.\n                       Map (F (MkArr {U} (Dom a)\n                                (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                        U) : a \\<rightarrow> b\\<guillemotright>\n\ngoal (1 subgoal):\n 1. F x \\<in> hom unity b", "by fastforce"], ["proof (state)\nthis:\n  F x \\<in> hom unity b\n\ngoal (1 subgoal):\n 1. undefined = Map (F x) y", "hence \"Dom (F x) = {U}\""], ["proof (prove)\nusing this:\n  F x \\<in> hom unity b\n\ngoal (1 subgoal):\n 1. Dom (F x) = {U}", "by (metis (mono_tags, lifting) \"2\" CollectD Dom.simps(1) in_hom_char x)"], ["proof (state)\nthis:\n  Dom (F x) = {U}\n\ngoal (1 subgoal):\n 1. undefined = Map (F x) y", "thus ?thesis"], ["proof (prove)\nusing this:\n  Dom (F x) = {U}\n\ngoal (1 subgoal):\n 1. undefined = Map (F x) y", "using x y F 5 arr_char [of \"F x\"] extensional_arb [of \"Map (F x)\" \"{U}\" y]"], ["proof (prove)\nusing this:\n  Dom (F x) = {U}\n  \\<guillemotleft>x : unity \\<rightarrow> local.dom\n     (MkArr (Dom a) (Dom b)\n       (\\<lambda>x\\<in>Dom a.\n           Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n            U))\\<guillemotright>\n  y \\<notin> {U}\n  F \\<in> hom unity a \\<rightarrow> hom unity b\n  F x \\<in> hom unity b\n  arr (F x) =\n  (F x \\<noteq> Null \\<and>\n   |Dom (F x)| <o \\<AA> \\<and>\n   |Cod (F x)| <o \\<AA> \\<and>\n   Map (F x)\n   \\<in> extensional (Dom (F x)) \\<inter>\n         (Dom (F x) \\<rightarrow> Cod (F x)))\n  \\<lbrakk>Map (F x) \\<in> extensional {U}; y \\<notin> {U}\\<rbrakk>\n  \\<Longrightarrow> Map (F x) y = undefined\n\ngoal (1 subgoal):\n 1. undefined = Map (F x) y", "by (metis (mono_tags, lifting) CollectD Int_iff in_hom_char)"], ["proof (state)\nthis:\n  undefined = Map (F x) y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  undefined = Map (F x) y\n\ngoal (1 subgoal):\n 1. y \\<notin> {U} \\<Longrightarrow>\n    compose {U}\n     (Map (MkArr (Dom a) (Dom b)\n            (\\<lambda>x\\<in>Dom a.\n                Map (F (MkArr {U} (Dom a)\n                         (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                 U)))\n     (\\<lambda>_\\<in>{U}. DOWN (IMG x)) y =\n    Map (F x) y", "ultimately"], ["proof (chain)\npicking this:\n  compose {U}\n   (Map (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U)))\n   (\\<lambda>_\\<in>{U}. DOWN (IMG x)) y =\n  undefined\n  undefined = Map (F x) y", "show ?thesis"], ["proof (prove)\nusing this:\n  compose {U}\n   (Map (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U)))\n   (\\<lambda>_\\<in>{U}. DOWN (IMG x)) y =\n  undefined\n  undefined = Map (F x) y\n\ngoal (1 subgoal):\n 1. compose {U}\n     (Map (MkArr (Dom a) (Dom b)\n            (\\<lambda>x\\<in>Dom a.\n                Map (F (MkArr {U} (Dom a)\n                         (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                 U)))\n     (\\<lambda>_\\<in>{U}. DOWN (IMG x)) y =\n    Map (F x) y", "by auto"], ["proof (state)\nthis:\n  compose {U}\n   (Map (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U)))\n   (\\<lambda>_\\<in>{U}. DOWN (IMG x)) y =\n  Map (F x) y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y \\<notin> {U} \\<Longrightarrow>\n  compose {U}\n   (Map (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U)))\n   (\\<lambda>_\\<in>{U}. DOWN (IMG x)) y =\n  Map (F x) y\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       compose {U}\n        (Map (MkArr (Dom a) (Dom b)\n               (\\<lambda>x\\<in>Dom a.\n                   Map (F (MkArr {U} (Dom a)\n                            (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                    U)))\n        (\\<lambda>_\\<in>{U}. DOWN (IMG x)) xa =\n       Map (F x) xa", "moreover"], ["proof (state)\nthis:\n  y \\<notin> {U} \\<Longrightarrow>\n  compose {U}\n   (Map (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U)))\n   (\\<lambda>_\\<in>{U}. DOWN (IMG x)) y =\n  Map (F x) y\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       compose {U}\n        (Map (MkArr (Dom a) (Dom b)\n               (\\<lambda>x\\<in>Dom a.\n                   Map (F (MkArr {U} (Dom a)\n                            (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                    U)))\n        (\\<lambda>_\\<in>{U}. DOWN (IMG x)) xa =\n       Map (F x) xa", "have\n                    \"y \\<in> {U} \\<Longrightarrow>\n                       compose {U} (Map ?f) (\\<lambda>_ \\<in> {U}. DOWN (IMG x)) y = Map (F x) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. y \\<in> {U} \\<Longrightarrow>\n    compose {U}\n     (Map (MkArr (Dom a) (Dom b)\n            (\\<lambda>x\\<in>Dom a.\n                Map (F (MkArr {U} (Dom a)\n                         (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                 U)))\n     (\\<lambda>_\\<in>{U}. DOWN (IMG x)) y =\n    Map (F x) y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<in> {U} \\<Longrightarrow>\n    compose {U}\n     (Map (MkArr (Dom a) (Dom b)\n            (\\<lambda>x\\<in>Dom a.\n                Map (F (MkArr {U} (Dom a)\n                         (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                 U)))\n     (\\<lambda>_\\<in>{U}. DOWN (IMG x)) y =\n    Map (F x) y", "assume y: \"y \\<in> {U}\""], ["proof (state)\nthis:\n  y \\<in> {U}\n\ngoal (1 subgoal):\n 1. y \\<in> {U} \\<Longrightarrow>\n    compose {U}\n     (Map (MkArr (Dom a) (Dom b)\n            (\\<lambda>x\\<in>Dom a.\n                Map (F (MkArr {U} (Dom a)\n                         (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                 U)))\n     (\\<lambda>_\\<in>{U}. DOWN (IMG x)) y =\n    Map (F x) y", "have \"compose {U} (Map ?f) (\\<lambda>_ \\<in> {U}. DOWN (IMG x)) y =\n                        Map ?f (DOWN (IMG x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compose {U}\n     (Map (MkArr (Dom a) (Dom b)\n            (\\<lambda>x\\<in>Dom a.\n                Map (F (MkArr {U} (Dom a)\n                         (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                 U)))\n     (\\<lambda>_\\<in>{U}. DOWN (IMG x)) y =\n    Map (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U))\n     (DOWN (IMG x))", "using y"], ["proof (prove)\nusing this:\n  y \\<in> {U}\n\ngoal (1 subgoal):\n 1. compose {U}\n     (Map (MkArr (Dom a) (Dom b)\n            (\\<lambda>x\\<in>Dom a.\n                Map (F (MkArr {U} (Dom a)\n                         (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                 U)))\n     (\\<lambda>_\\<in>{U}. DOWN (IMG x)) y =\n    Map (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U))\n     (DOWN (IMG x))", "by (simp add: compose_eq restrict_apply')"], ["proof (state)\nthis:\n  compose {U}\n   (Map (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U)))\n   (\\<lambda>_\\<in>{U}. DOWN (IMG x)) y =\n  Map (MkArr (Dom a) (Dom b)\n        (\\<lambda>x\\<in>Dom a.\n            Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n             U))\n   (DOWN (IMG x))\n\ngoal (1 subgoal):\n 1. y \\<in> {U} \\<Longrightarrow>\n    compose {U}\n     (Map (MkArr (Dom a) (Dom b)\n            (\\<lambda>x\\<in>Dom a.\n                Map (F (MkArr {U} (Dom a)\n                         (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                 U)))\n     (\\<lambda>_\\<in>{U}. DOWN (IMG x)) y =\n    Map (F x) y", "also"], ["proof (state)\nthis:\n  compose {U}\n   (Map (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U)))\n   (\\<lambda>_\\<in>{U}. DOWN (IMG x)) y =\n  Map (MkArr (Dom a) (Dom b)\n        (\\<lambda>x\\<in>Dom a.\n            Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n             U))\n   (DOWN (IMG x))\n\ngoal (1 subgoal):\n 1. y \\<in> {U} \\<Longrightarrow>\n    compose {U}\n     (Map (MkArr (Dom a) (Dom b)\n            (\\<lambda>x\\<in>Dom a.\n                Map (F (MkArr {U} (Dom a)\n                         (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                 U)))\n     (\\<lambda>_\\<in>{U}. DOWN (IMG x)) y =\n    Map (F x) y", "have \"... = (\\<lambda>x. Map (F (MkElem (UP x) a)) U) (DOWN (IMG x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Map (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U))\n     (DOWN (IMG x)) =\n    Map (F (MkArr {U} (Dom a)\n             (\\<lambda>_\\<in>{U}. DOWN (UP (DOWN (IMG x))))))\n     U", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Map (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U))\n     (DOWN (IMG x)) =\n    Map (F (MkArr {U} (Dom a)\n             (\\<lambda>_\\<in>{U}. DOWN (UP (DOWN (IMG x))))))\n     U", "have \"DOWN (IMG x) \\<in> Dom a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DOWN (IMG x) \\<in> Dom a", "using x y a 5 arr_char in_homE restrict_apply"], ["proof (prove)\nusing this:\n  \\<guillemotleft>x : unity \\<rightarrow> local.dom\n     (MkArr (Dom a) (Dom b)\n       (\\<lambda>x\\<in>Dom a.\n           Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n            U))\\<guillemotright>\n  y \\<in> {U}\n  ide a\n  Dom x = {U} \\<and>\n  Cod x = Dom a \\<and> Map x = (\\<lambda>_\\<in>{U}. DOWN (IMG x))\n  arr ?f =\n  (?f \\<noteq> Null \\<and>\n   |Dom ?f| <o \\<AA> \\<and>\n   |Cod ?f| <o \\<AA> \\<and>\n   Map ?f \\<in> extensional (Dom ?f) \\<inter> (Dom ?f \\<rightarrow> Cod ?f))\n  \\<lbrakk>\\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright>;\n   \\<lbrakk>arr ?f; local.dom ?f = ?a; cod ?f = ?b\\<rbrakk>\n   \\<Longrightarrow> ?T\\<rbrakk>\n  \\<Longrightarrow> ?T\n  restrict ?f ?A ?x = (if ?x \\<in> ?A then ?f ?x else undefined)\n\ngoal (1 subgoal):\n 1. DOWN (IMG x) \\<in> Dom a", "by force"], ["proof (state)\nthis:\n  DOWN (IMG x) \\<in> Dom a\n\ngoal (1 subgoal):\n 1. Map (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U))\n     (DOWN (IMG x)) =\n    Map (F (MkArr {U} (Dom a)\n             (\\<lambda>_\\<in>{U}. DOWN (UP (DOWN (IMG x))))))\n     U", "thus ?thesis"], ["proof (prove)\nusing this:\n  DOWN (IMG x) \\<in> Dom a\n\ngoal (1 subgoal):\n 1. Map (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U))\n     (DOWN (IMG x)) =\n    Map (F (MkArr {U} (Dom a)\n             (\\<lambda>_\\<in>{U}. DOWN (UP (DOWN (IMG x))))))\n     U", "using restrict_apply"], ["proof (prove)\nusing this:\n  DOWN (IMG x) \\<in> Dom a\n  restrict ?f ?A ?x = (if ?x \\<in> ?A then ?f ?x else undefined)\n\ngoal (1 subgoal):\n 1. Map (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U))\n     (DOWN (IMG x)) =\n    Map (F (MkArr {U} (Dom a)\n             (\\<lambda>_\\<in>{U}. DOWN (UP (DOWN (IMG x))))))\n     U", "by simp"], ["proof (state)\nthis:\n  Map (MkArr (Dom a) (Dom b)\n        (\\<lambda>x\\<in>Dom a.\n            Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n             U))\n   (DOWN (IMG x)) =\n  Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP (DOWN (IMG x))))))\n   U\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Map (MkArr (Dom a) (Dom b)\n        (\\<lambda>x\\<in>Dom a.\n            Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n             U))\n   (DOWN (IMG x)) =\n  Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP (DOWN (IMG x))))))\n   U\n\ngoal (1 subgoal):\n 1. y \\<in> {U} \\<Longrightarrow>\n    compose {U}\n     (Map (MkArr (Dom a) (Dom b)\n            (\\<lambda>x\\<in>Dom a.\n                Map (F (MkArr {U} (Dom a)\n                         (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                 U)))\n     (\\<lambda>_\\<in>{U}. DOWN (IMG x)) y =\n    Map (F x) y", "also"], ["proof (state)\nthis:\n  Map (MkArr (Dom a) (Dom b)\n        (\\<lambda>x\\<in>Dom a.\n            Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n             U))\n   (DOWN (IMG x)) =\n  Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP (DOWN (IMG x))))))\n   U\n\ngoal (1 subgoal):\n 1. y \\<in> {U} \\<Longrightarrow>\n    compose {U}\n     (Map (MkArr (Dom a) (Dom b)\n            (\\<lambda>x\\<in>Dom a.\n                Map (F (MkArr {U} (Dom a)\n                         (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                 U)))\n     (\\<lambda>_\\<in>{U}. DOWN (IMG x)) y =\n    Map (F x) y", "have \"... = Map (F x) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Map (F (MkArr {U} (Dom a)\n             (\\<lambda>_\\<in>{U}. DOWN (UP (DOWN (IMG x))))))\n     U =\n    Map (F x) y", "using x y 1 2 MkElem_IMG [of x a]"], ["proof (prove)\nusing this:\n  \\<guillemotleft>x : unity \\<rightarrow> local.dom\n     (MkArr (Dom a) (Dom b)\n       (\\<lambda>x\\<in>Dom a.\n           Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n            U))\\<guillemotright>\n  y \\<in> {U}\n  \\<guillemotleft>MkArr (Dom a) (Dom b)\n                   (\\<lambda>x\\<in>Dom a.\n                       Map (F (MkArr {U} (Dom a)\n                                (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                        U) : a \\<rightarrow> b\\<guillemotright>\n  x = MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (IMG x))\n  x \\<in> hom unity a \\<Longrightarrow>\n  MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (IMG x)) = x\n\ngoal (1 subgoal):\n 1. Map (F (MkArr {U} (Dom a)\n             (\\<lambda>_\\<in>{U}. DOWN (UP (DOWN (IMG x))))))\n     U =\n    Map (F x) y", "by simp"], ["proof (state)\nthis:\n  Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP (DOWN (IMG x))))))\n   U =\n  Map (F x) y\n\ngoal (1 subgoal):\n 1. y \\<in> {U} \\<Longrightarrow>\n    compose {U}\n     (Map (MkArr (Dom a) (Dom b)\n            (\\<lambda>x\\<in>Dom a.\n                Map (F (MkArr {U} (Dom a)\n                         (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                 U)))\n     (\\<lambda>_\\<in>{U}. DOWN (IMG x)) y =\n    Map (F x) y", "finally"], ["proof (chain)\npicking this:\n  compose {U}\n   (Map (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U)))\n   (\\<lambda>_\\<in>{U}. DOWN (IMG x)) y =\n  Map (F x) y", "show\n                      \"compose {U} (Map ?f) (\\<lambda>_ \\<in> {U}. DOWN (IMG x)) y = Map (F x) y\""], ["proof (prove)\nusing this:\n  compose {U}\n   (Map (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U)))\n   (\\<lambda>_\\<in>{U}. DOWN (IMG x)) y =\n  Map (F x) y\n\ngoal (1 subgoal):\n 1. compose {U}\n     (Map (MkArr (Dom a) (Dom b)\n            (\\<lambda>x\\<in>Dom a.\n                Map (F (MkArr {U} (Dom a)\n                         (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                 U)))\n     (\\<lambda>_\\<in>{U}. DOWN (IMG x)) y =\n    Map (F x) y", "by auto"], ["proof (state)\nthis:\n  compose {U}\n   (Map (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U)))\n   (\\<lambda>_\\<in>{U}. DOWN (IMG x)) y =\n  Map (F x) y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  y \\<in> {U} \\<Longrightarrow>\n  compose {U}\n   (Map (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U)))\n   (\\<lambda>_\\<in>{U}. DOWN (IMG x)) y =\n  Map (F x) y\n\ngoal (1 subgoal):\n 1. \\<And>xa.\n       compose {U}\n        (Map (MkArr (Dom a) (Dom b)\n               (\\<lambda>x\\<in>Dom a.\n                   Map (F (MkArr {U} (Dom a)\n                            (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                    U)))\n        (\\<lambda>_\\<in>{U}. DOWN (IMG x)) xa =\n       Map (F x) xa", "ultimately"], ["proof (chain)\npicking this:\n  y \\<notin> {U} \\<Longrightarrow>\n  compose {U}\n   (Map (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U)))\n   (\\<lambda>_\\<in>{U}. DOWN (IMG x)) y =\n  Map (F x) y\n  y \\<in> {U} \\<Longrightarrow>\n  compose {U}\n   (Map (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U)))\n   (\\<lambda>_\\<in>{U}. DOWN (IMG x)) y =\n  Map (F x) y", "show\n                    \"compose {U} (Map ?f) (\\<lambda>_ \\<in> {U}. DOWN (IMG x)) y = Map (F x) y\""], ["proof (prove)\nusing this:\n  y \\<notin> {U} \\<Longrightarrow>\n  compose {U}\n   (Map (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U)))\n   (\\<lambda>_\\<in>{U}. DOWN (IMG x)) y =\n  Map (F x) y\n  y \\<in> {U} \\<Longrightarrow>\n  compose {U}\n   (Map (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U)))\n   (\\<lambda>_\\<in>{U}. DOWN (IMG x)) y =\n  Map (F x) y\n\ngoal (1 subgoal):\n 1. compose {U}\n     (Map (MkArr (Dom a) (Dom b)\n            (\\<lambda>x\\<in>Dom a.\n                Map (F (MkArr {U} (Dom a)\n                         (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                 U)))\n     (\\<lambda>_\\<in>{U}. DOWN (IMG x)) y =\n    Map (F x) y", "by auto"], ["proof (state)\nthis:\n  compose {U}\n   (Map (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U)))\n   (\\<lambda>_\\<in>{U}. DOWN (IMG x)) y =\n  Map (F x) y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  compose {U}\n   (Map (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U)))\n   (\\<lambda>_\\<in>{U}. DOWN (IMG x)) =\n  Map (F x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<guillemotleft>x : unity \\<rightarrow> local.dom\n          (MkArr (Dom a) (Dom b)\n            (\\<lambda>x\\<in>Dom a.\n                Map (F (MkArr {U} (Dom a)\n                         (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                 U))\\<guillemotright> \\<Longrightarrow>\n       MkArr (Dom a) (Dom b)\n        (\\<lambda>x\\<in>Dom a.\n            Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n             U) \\<cdot>\n       x =\n       F x", "show \"?f \\<cdot> x = F x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MkArr (Dom a) (Dom b)\n     (\\<lambda>x\\<in>Dom a.\n         Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n          U) \\<cdot>\n    x =\n    F x", "proof (intro arr_eqI)"], ["proof (state)\ngoal (5 subgoals):\n 1. seq (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U))\n     x\n 2. arr (F x)\n 3. Dom (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U) \\<cdot>\n         x) =\n    Dom (F x)\n 4. Cod (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U) \\<cdot>\n         x) =\n    Cod (F x)\n 5. Map (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U) \\<cdot>\n         x) =\n    Map (F x)", "have 5: \"?f \\<cdot> x \\<in> hom unity b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. MkArr (Dom a) (Dom b)\n     (\\<lambda>x\\<in>Dom a.\n         Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n          U) \\<cdot>\n    x\n    \\<in> hom unity b", "using 1 x"], ["proof (prove)\nusing this:\n  \\<guillemotleft>MkArr (Dom a) (Dom b)\n                   (\\<lambda>x\\<in>Dom a.\n                       Map (F (MkArr {U} (Dom a)\n                                (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                        U) : a \\<rightarrow> b\\<guillemotright>\n  \\<guillemotleft>x : unity \\<rightarrow> local.dom\n     (MkArr (Dom a) (Dom b)\n       (\\<lambda>x\\<in>Dom a.\n           Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n            U))\\<guillemotright>\n\ngoal (1 subgoal):\n 1. MkArr (Dom a) (Dom b)\n     (\\<lambda>x\\<in>Dom a.\n         Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n          U) \\<cdot>\n    x\n    \\<in> hom unity b", "by blast"], ["proof (state)\nthis:\n  MkArr (Dom a) (Dom b)\n   (\\<lambda>x\\<in>Dom a.\n       Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n        U) \\<cdot>\n  x\n  \\<in> hom unity b\n\ngoal (5 subgoals):\n 1. seq (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U))\n     x\n 2. arr (F x)\n 3. Dom (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U) \\<cdot>\n         x) =\n    Dom (F x)\n 4. Cod (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U) \\<cdot>\n         x) =\n    Cod (F x)\n 5. Map (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U) \\<cdot>\n         x) =\n    Map (F x)", "have 6: \"F x \\<in> hom unity b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F x \\<in> hom unity b", "using x F 1"], ["proof (prove)\nusing this:\n  \\<guillemotleft>x : unity \\<rightarrow> local.dom\n     (MkArr (Dom a) (Dom b)\n       (\\<lambda>x\\<in>Dom a.\n           Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n            U))\\<guillemotright>\n  F \\<in> hom unity a \\<rightarrow> hom unity b\n  \\<guillemotleft>MkArr (Dom a) (Dom b)\n                   (\\<lambda>x\\<in>Dom a.\n                       Map (F (MkArr {U} (Dom a)\n                                (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                        U) : a \\<rightarrow> b\\<guillemotright>\n\ngoal (1 subgoal):\n 1. F x \\<in> hom unity b", "by (metis (mono_tags, lifting) PiE in_homE mem_Collect_eq)"], ["proof (state)\nthis:\n  F x \\<in> hom unity b\n\ngoal (5 subgoals):\n 1. seq (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U))\n     x\n 2. arr (F x)\n 3. Dom (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U) \\<cdot>\n         x) =\n    Dom (F x)\n 4. Cod (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U) \\<cdot>\n         x) =\n    Cod (F x)\n 5. Map (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U) \\<cdot>\n         x) =\n    Map (F x)", "show \"arr (comp ?f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U))\n     x", "using 5"], ["proof (prove)\nusing this:\n  MkArr (Dom a) (Dom b)\n   (\\<lambda>x\\<in>Dom a.\n       Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n        U) \\<cdot>\n  x\n  \\<in> hom unity b\n\ngoal (1 subgoal):\n 1. seq (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U))\n     x", "by blast"], ["proof (state)\nthis:\n  seq (MkArr (Dom a) (Dom b)\n        (\\<lambda>x\\<in>Dom a.\n            Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n             U))\n   x\n\ngoal (4 subgoals):\n 1. arr (F x)\n 2. Dom (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U) \\<cdot>\n         x) =\n    Dom (F x)\n 3. Cod (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U) \\<cdot>\n         x) =\n    Cod (F x)\n 4. Map (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U) \\<cdot>\n         x) =\n    Map (F x)", "show \"arr (F x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (F x)", "using 6"], ["proof (prove)\nusing this:\n  F x \\<in> hom unity b\n\ngoal (1 subgoal):\n 1. arr (F x)", "by blast"], ["proof (state)\nthis:\n  arr (F x)\n\ngoal (3 subgoals):\n 1. Dom (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U) \\<cdot>\n         x) =\n    Dom (F x)\n 2. Cod (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U) \\<cdot>\n         x) =\n    Cod (F x)\n 3. Map (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U) \\<cdot>\n         x) =\n    Map (F x)", "show \"Dom (comp ?f x) = Dom (F x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dom (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U) \\<cdot>\n         x) =\n    Dom (F x)", "using 5 6"], ["proof (prove)\nusing this:\n  MkArr (Dom a) (Dom b)\n   (\\<lambda>x\\<in>Dom a.\n       Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n        U) \\<cdot>\n  x\n  \\<in> hom unity b\n  F x \\<in> hom unity b\n\ngoal (1 subgoal):\n 1. Dom (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U) \\<cdot>\n         x) =\n    Dom (F x)", "by (metis (mono_tags, lifting) CollectD in_hom_char)"], ["proof (state)\nthis:\n  Dom (MkArr (Dom a) (Dom b)\n        (\\<lambda>x\\<in>Dom a.\n            Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n             U) \\<cdot>\n       x) =\n  Dom (F x)\n\ngoal (2 subgoals):\n 1. Cod (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U) \\<cdot>\n         x) =\n    Cod (F x)\n 2. Map (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U) \\<cdot>\n         x) =\n    Map (F x)", "show \"Cod (comp ?f x) = Cod (F x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cod (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U) \\<cdot>\n         x) =\n    Cod (F x)", "using 5 6"], ["proof (prove)\nusing this:\n  MkArr (Dom a) (Dom b)\n   (\\<lambda>x\\<in>Dom a.\n       Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n        U) \\<cdot>\n  x\n  \\<in> hom unity b\n  F x \\<in> hom unity b\n\ngoal (1 subgoal):\n 1. Cod (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U) \\<cdot>\n         x) =\n    Cod (F x)", "by (metis (mono_tags, lifting) CollectD in_hom_char)"], ["proof (state)\nthis:\n  Cod (MkArr (Dom a) (Dom b)\n        (\\<lambda>x\\<in>Dom a.\n            Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n             U) \\<cdot>\n       x) =\n  Cod (F x)\n\ngoal (1 subgoal):\n 1. Map (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U) \\<cdot>\n         x) =\n    Map (F x)", "show \"Map (comp ?f x) = Map (F x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Map (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U) \\<cdot>\n         x) =\n    Map (F x)", "using 3 4"], ["proof (prove)\nusing this:\n  MkArr (Dom a) (Dom b)\n   (\\<lambda>x\\<in>Dom a.\n       Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n        U) \\<cdot>\n  x =\n  MkArr {U} (Dom b)\n   (compose {U}\n     (Map (MkArr (Dom a) (Dom b)\n            (\\<lambda>x\\<in>Dom a.\n                Map (F (MkArr {U} (Dom a)\n                         (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                 U)))\n     (\\<lambda>_\\<in>{U}. DOWN (IMG x)))\n  compose {U}\n   (Map (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U)))\n   (\\<lambda>_\\<in>{U}. DOWN (IMG x)) =\n  Map (F x)\n\ngoal (1 subgoal):\n 1. Map (MkArr (Dom a) (Dom b)\n          (\\<lambda>x\\<in>Dom a.\n              Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n               U) \\<cdot>\n         x) =\n    Map (F x)", "by simp"], ["proof (state)\nthis:\n  Map (MkArr (Dom a) (Dom b)\n        (\\<lambda>x\\<in>Dom a.\n            Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n             U) \\<cdot>\n       x) =\n  Map (F x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  MkArr (Dom a) (Dom b)\n   (\\<lambda>x\\<in>Dom a.\n       Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n        U) \\<cdot>\n  x =\n  F x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<guillemotleft>?x : unity \\<rightarrow> local.dom\n      (MkArr (Dom a) (Dom b)\n        (\\<lambda>x\\<in>Dom a.\n            Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n             U))\\<guillemotright> \\<Longrightarrow>\n  MkArr (Dom a) (Dom b)\n   (\\<lambda>x\\<in>Dom a.\n       Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n        U) \\<cdot>\n  ?x =\n  F ?x\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>?f : a \\<rightarrow> b\\<guillemotright> \\<and>\n    (\\<forall>x.\n        \\<guillemotleft>x : unity \\<rightarrow> local.dom\n           ?f\\<guillemotright> \\<longrightarrow>\n        ?f \\<cdot> x = F x)", "thus \"\\<guillemotleft>?f : a \\<rightarrow> b\\<guillemotright> \\<and> (\\<forall>x. \\<guillemotleft>x : unity \\<rightarrow> dom ?f\\<guillemotright> \\<longrightarrow> comp ?f x = F x)\""], ["proof (prove)\nusing this:\n  \\<guillemotleft>?x : unity \\<rightarrow> local.dom\n      (MkArr (Dom a) (Dom b)\n        (\\<lambda>x\\<in>Dom a.\n            Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n             U))\\<guillemotright> \\<Longrightarrow>\n  MkArr (Dom a) (Dom b)\n   (\\<lambda>x\\<in>Dom a.\n       Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n        U) \\<cdot>\n  ?x =\n  F ?x\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>MkArr (Dom a) (Dom b)\n                     (\\<lambda>x\\<in>Dom a.\n                         Map (F (MkArr {U} (Dom a)\n                                  (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                          U) : a \\<rightarrow> b\\<guillemotright> \\<and>\n    (\\<forall>x.\n        \\<guillemotleft>x : unity \\<rightarrow> local.dom\n           (MkArr (Dom a) (Dom b)\n             (\\<lambda>x\\<in>Dom a.\n                 Map (F (MkArr {U} (Dom a)\n                          (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                  U))\\<guillemotright> \\<longrightarrow>\n        MkArr (Dom a) (Dom b)\n         (\\<lambda>x\\<in>Dom a.\n             Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n              U) \\<cdot>\n        x =\n        F x)", "using 1"], ["proof (prove)\nusing this:\n  \\<guillemotleft>?x : unity \\<rightarrow> local.dom\n      (MkArr (Dom a) (Dom b)\n        (\\<lambda>x\\<in>Dom a.\n            Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n             U))\\<guillemotright> \\<Longrightarrow>\n  MkArr (Dom a) (Dom b)\n   (\\<lambda>x\\<in>Dom a.\n       Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n        U) \\<cdot>\n  ?x =\n  F ?x\n  \\<guillemotleft>MkArr (Dom a) (Dom b)\n                   (\\<lambda>x\\<in>Dom a.\n                       Map (F (MkArr {U} (Dom a)\n                                (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                        U) : a \\<rightarrow> b\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>MkArr (Dom a) (Dom b)\n                     (\\<lambda>x\\<in>Dom a.\n                         Map (F (MkArr {U} (Dom a)\n                                  (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                          U) : a \\<rightarrow> b\\<guillemotright> \\<and>\n    (\\<forall>x.\n        \\<guillemotleft>x : unity \\<rightarrow> local.dom\n           (MkArr (Dom a) (Dom b)\n             (\\<lambda>x\\<in>Dom a.\n                 Map (F (MkArr {U} (Dom a)\n                          (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                  U))\\<guillemotright> \\<longrightarrow>\n        MkArr (Dom a) (Dom b)\n         (\\<lambda>x\\<in>Dom a.\n             Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n              U) \\<cdot>\n        x =\n        F x)", "by blast"], ["proof (state)\nthis:\n  \\<guillemotleft>MkArr (Dom a) (Dom b)\n                   (\\<lambda>x\\<in>Dom a.\n                       Map (F (MkArr {U} (Dom a)\n                                (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                        U) : a \\<rightarrow> b\\<guillemotright> \\<and>\n  (\\<forall>x.\n      \\<guillemotleft>x : unity \\<rightarrow> local.dom\n         (MkArr (Dom a) (Dom b)\n           (\\<lambda>x\\<in>Dom a.\n               Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n                U))\\<guillemotright> \\<longrightarrow>\n      MkArr (Dom a) (Dom b)\n       (\\<lambda>x\\<in>Dom a.\n           Map (F (MkArr {U} (Dom a) (\\<lambda>_\\<in>{U}. DOWN (UP x))))\n            U) \\<cdot>\n      x =\n      F x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>f.\n     \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n     (\\<forall>x.\n         \\<guillemotleft>x : unity \\<rightarrow> local.dom\n            f\\<guillemotright> \\<longrightarrow>\n         f \\<cdot> x = F x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  set_category_given_img (\\<cdot>) IMG \\<AA>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>img. set_category_given_img (\\<cdot>) img \\<AA>\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n      \\<open>SetCat\\<close> can be viewed as a concrete set category over its own element type\n      @{typ 'a}, using @{term UP} as the required injection from @{typ 'a} to the universe\n      of \\<open>SetCat\\<close>.\n\\<close>"], ["", "corollary is_concrete_set_category:\n    shows \"concrete_set_category comp \\<AA> UNIV UP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. concrete_set_category (\\<cdot>) \\<AA> UNIV UP", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. concrete_set_category (\\<cdot>) \\<AA> UNIV UP", "interpret S: set_category comp \\<AA>"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_category (\\<cdot>) \\<AA>", "using is_set_category"], ["proof (prove)\nusing this:\n  set_category (\\<cdot>) \\<AA>\n\ngoal (1 subgoal):\n 1. set_category (\\<cdot>) \\<AA>", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. concrete_set_category (\\<cdot>) \\<AA> UNIV UP", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. concrete_set_category (\\<cdot>) \\<AA> UNIV UP", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. UP \\<in> UNIV \\<rightarrow> S.Univ\n 2. inj UP", "show 1: \"UP \\<in> UNIV \\<rightarrow> S.Univ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP \\<in> UNIV \\<rightarrow> S.Univ", "using UP_def terminal_char"], ["proof (prove)\nusing this:\n  UP ?x \\<equiv> MkIde {?x}\n  terminal ?a = (\\<exists>x. ?a = MkIde {x})\n\ngoal (1 subgoal):\n 1. UP \\<in> UNIV \\<rightarrow> S.Univ", "by force"], ["proof (state)\nthis:\n  UP \\<in> UNIV \\<rightarrow> S.Univ\n\ngoal (1 subgoal):\n 1. inj UP", "show \"inj_on UP UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj UP", "using inj_UP"], ["proof (prove)\nusing this:\n  inj UP\n\ngoal (1 subgoal):\n 1. inj UP", "by blast"], ["proof (state)\nthis:\n  inj UP\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  concrete_set_category (\\<cdot>) \\<AA> UNIV UP\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n      As a consequence of the categoricity of the \\<open>set_category\\<close> axioms,\n      if @{term S} interprets \\<open>set_category\\<close>, and if @{term \\<phi>} is a bijection between\n      the universe of @{term S} and the elements of type @{typ 'a}, then @{term S} is isomorphic\n      to the category \\<open>setcat\\<close> of @{typ 'a} sets and functions between them constructed here.\n\\<close>"], ["", "corollary set_category_iso_SetCat:\n    fixes S :: \"'s comp\" and \\<phi> :: \"'s \\<Rightarrow> 'e\"\n    assumes \"set_category S \\<AA>\"\n    and \"bij_betw \\<phi> (Collect (category.terminal S)) UNIV\"\n    shows \"\\<exists>\\<Phi>. invertible_functor S (comp :: 'e setcat.arr comp) \\<Phi>\n                 \\<and> (\\<forall>m. set_category.incl S \\<AA> m \\<longrightarrow> set_category.incl comp \\<AA> (\\<Phi> m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<Phi>.\n       invertible_functor S (\\<cdot>) \\<Phi> \\<and>\n       (\\<forall>m.\n           set_category.incl S \\<AA> m \\<longrightarrow>\n           set_category.incl (\\<cdot>) \\<AA> (\\<Phi> m))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<Phi>.\n       invertible_functor S (\\<cdot>) \\<Phi> \\<and>\n       (\\<forall>m.\n           set_category.incl S \\<AA> m \\<longrightarrow>\n           set_category.incl (\\<cdot>) \\<AA> (\\<Phi> m))", "interpret S: set_category S"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_category S \\<AA>", "using assms"], ["proof (prove)\nusing this:\n  set_category S \\<AA>\n  bij_betw \\<phi> (Collect (category.terminal S)) UNIV\n\ngoal (1 subgoal):\n 1. set_category S \\<AA>", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<Phi>.\n       invertible_functor S (\\<cdot>) \\<Phi> \\<and>\n       (\\<forall>m.\n           S.incl m \\<longrightarrow>\n           set_category.incl (\\<cdot>) \\<AA> (\\<Phi> m))", "let ?\\<psi> = \"inv_into S.Univ \\<phi>\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<Phi>.\n       invertible_functor S (\\<cdot>) \\<Phi> \\<and>\n       (\\<forall>m.\n           S.incl m \\<longrightarrow>\n           set_category.incl (\\<cdot>) \\<AA> (\\<Phi> m))", "have \"bij_betw (UP o \\<phi>) S.Univ (Collect terminal)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw (UP \\<circ> \\<phi>) S.Univ Univ", "proof (intro bij_betwI)"], ["proof (state)\ngoal (4 subgoals):\n 1. UP \\<circ> \\<phi> \\<in> S.Univ \\<rightarrow> Univ\n 2. ?g \\<in> Univ \\<rightarrow> S.Univ\n 3. \\<And>x. x \\<in> S.Univ \\<Longrightarrow> ?g ((UP \\<circ> \\<phi>) x) = x\n 4. \\<And>y. y \\<in> Univ \\<Longrightarrow> (UP \\<circ> \\<phi>) (?g y) = y", "show \"UP o \\<phi> \\<in> S.Univ \\<rightarrow> Collect terminal\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP \\<circ> \\<phi> \\<in> S.Univ \\<rightarrow> Univ", "using assms(2) UP_mapsto"], ["proof (prove)\nusing this:\n  bij_betw \\<phi> S.Univ UNIV\n  UP \\<in> UNIV \\<rightarrow> Univ\n\ngoal (1 subgoal):\n 1. UP \\<circ> \\<phi> \\<in> S.Univ \\<rightarrow> Univ", "by auto"], ["proof (state)\nthis:\n  UP \\<circ> \\<phi> \\<in> S.Univ \\<rightarrow> Univ\n\ngoal (3 subgoals):\n 1. ?g \\<in> Univ \\<rightarrow> S.Univ\n 2. \\<And>x. x \\<in> S.Univ \\<Longrightarrow> ?g ((UP \\<circ> \\<phi>) x) = x\n 3. \\<And>y. y \\<in> Univ \\<Longrightarrow> (UP \\<circ> \\<phi>) (?g y) = y", "show \"?\\<psi> o DOWN \\<in> Collect terminal \\<rightarrow> S.Univ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_into S.Univ \\<phi> \\<circ> DOWN \\<in> Univ \\<rightarrow> S.Univ", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Univ \\<Longrightarrow>\n       (inv_into S.Univ \\<phi> \\<circ> DOWN) x \\<in> S.Univ", "fix x :: \"'e setcat.arr\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Univ \\<Longrightarrow>\n       (inv_into S.Univ \\<phi> \\<circ> DOWN) x \\<in> S.Univ", "assume x: \"x \\<in> Univ\""], ["proof (state)\nthis:\n  x \\<in> Univ\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Univ \\<Longrightarrow>\n       (inv_into S.Univ \\<phi> \\<circ> DOWN) x \\<in> S.Univ", "show \"(inv_into S.Univ \\<phi> \\<circ> DOWN) x \\<in> S.Univ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (inv_into S.Univ \\<phi> \\<circ> DOWN) x \\<in> S.Univ", "using x assms(2) bij_betw_def comp_apply inv_into_into"], ["proof (prove)\nusing this:\n  x \\<in> Univ\n  bij_betw \\<phi> S.Univ UNIV\n  bij_betw ?f ?A ?B = (inj_on ?f ?A \\<and> ?f ` ?A = ?B)\n  (?f \\<circ> ?g) ?x = ?f (?g ?x)\n  ?x \\<in> ?f ` ?A \\<Longrightarrow> inv_into ?A ?f ?x \\<in> ?A\n\ngoal (1 subgoal):\n 1. (inv_into S.Univ \\<phi> \\<circ> DOWN) x \\<in> S.Univ", "by (metis UNIV_I)"], ["proof (state)\nthis:\n  (inv_into S.Univ \\<phi> \\<circ> DOWN) x \\<in> S.Univ\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inv_into S.Univ \\<phi> \\<circ> DOWN \\<in> Univ \\<rightarrow> S.Univ\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> S.Univ \\<Longrightarrow>\n       (inv_into S.Univ \\<phi> \\<circ> DOWN) ((UP \\<circ> \\<phi>) x) = x\n 2. \\<And>y.\n       y \\<in> Univ \\<Longrightarrow>\n       (UP \\<circ> \\<phi>) ((inv_into S.Univ \\<phi> \\<circ> DOWN) y) = y", "fix t"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> S.Univ \\<Longrightarrow>\n       (inv_into S.Univ \\<phi> \\<circ> DOWN) ((UP \\<circ> \\<phi>) x) = x\n 2. \\<And>y.\n       y \\<in> Univ \\<Longrightarrow>\n       (UP \\<circ> \\<phi>) ((inv_into S.Univ \\<phi> \\<circ> DOWN) y) = y", "assume \"t \\<in> S.Univ\""], ["proof (state)\nthis:\n  t \\<in> S.Univ\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       x \\<in> S.Univ \\<Longrightarrow>\n       (inv_into S.Univ \\<phi> \\<circ> DOWN) ((UP \\<circ> \\<phi>) x) = x\n 2. \\<And>y.\n       y \\<in> Univ \\<Longrightarrow>\n       (UP \\<circ> \\<phi>) ((inv_into S.Univ \\<phi> \\<circ> DOWN) y) = y", "thus \"(?\\<psi> o DOWN) ((UP o \\<phi>) t) = t\""], ["proof (prove)\nusing this:\n  t \\<in> S.Univ\n\ngoal (1 subgoal):\n 1. (inv_into S.Univ \\<phi> \\<circ> DOWN) ((UP \\<circ> \\<phi>) t) = t", "using assms(2) bij_betw_inv_into_left"], ["proof (prove)\nusing this:\n  t \\<in> S.Univ\n  bij_betw \\<phi> S.Univ UNIV\n  \\<lbrakk>bij_betw ?f ?A ?A'; ?a \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> inv_into ?A ?f (?f ?a) = ?a\n\ngoal (1 subgoal):\n 1. (inv_into S.Univ \\<phi> \\<circ> DOWN) ((UP \\<circ> \\<phi>) t) = t", "by (metis comp_apply DOWN_UP)"], ["proof (state)\nthis:\n  (inv_into S.Univ \\<phi> \\<circ> DOWN) ((UP \\<circ> \\<phi>) t) = t\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> Univ \\<Longrightarrow>\n       (UP \\<circ> \\<phi>) ((inv_into S.Univ \\<phi> \\<circ> DOWN) y) = y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> Univ \\<Longrightarrow>\n       (UP \\<circ> \\<phi>) ((inv_into S.Univ \\<phi> \\<circ> DOWN) y) = y", "fix t' :: \"'e setcat.arr\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> Univ \\<Longrightarrow>\n       (UP \\<circ> \\<phi>) ((inv_into S.Univ \\<phi> \\<circ> DOWN) y) = y", "assume \"t' \\<in> Collect terminal\""], ["proof (state)\nthis:\n  t' \\<in> Univ\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> Univ \\<Longrightarrow>\n       (UP \\<circ> \\<phi>) ((inv_into S.Univ \\<phi> \\<circ> DOWN) y) = y", "thus \"(UP o \\<phi>) ((?\\<psi> o DOWN) t') = t'\""], ["proof (prove)\nusing this:\n  t' \\<in> Univ\n\ngoal (1 subgoal):\n 1. (UP \\<circ> \\<phi>) ((inv_into S.Univ \\<phi> \\<circ> DOWN) t') = t'", "using assms(2)"], ["proof (prove)\nusing this:\n  t' \\<in> Univ\n  bij_betw \\<phi> S.Univ UNIV\n\ngoal (1 subgoal):\n 1. (UP \\<circ> \\<phi>) ((inv_into S.Univ \\<phi> \\<circ> DOWN) t') = t'", "by (simp add: bij_betw_def f_inv_into_f)"], ["proof (state)\nthis:\n  (UP \\<circ> \\<phi>) ((inv_into S.Univ \\<phi> \\<circ> DOWN) t') = t'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  bij_betw (UP \\<circ> \\<phi>) S.Univ Univ\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Phi>.\n       invertible_functor S (\\<cdot>) \\<Phi> \\<and>\n       (\\<forall>m.\n           S.incl m \\<longrightarrow>\n           set_category.incl (\\<cdot>) \\<AA> (\\<Phi> m))", "thus ?thesis"], ["proof (prove)\nusing this:\n  bij_betw (UP \\<circ> \\<phi>) S.Univ Univ\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Phi>.\n       invertible_functor S (\\<cdot>) \\<Phi> \\<and>\n       (\\<forall>m.\n           S.incl m \\<longrightarrow>\n           set_category.incl (\\<cdot>) \\<AA> (\\<Phi> m))", "using assms(1) set_category_is_categorical [of S \\<AA> comp \"UP o \\<phi>\"] is_set_category"], ["proof (prove)\nusing this:\n  bij_betw (UP \\<circ> \\<phi>) S.Univ Univ\n  set_category S \\<AA>\n  \\<lbrakk>set_category S \\<AA>; set_category (\\<cdot>) \\<AA>;\n   bij_betw (UP \\<circ> \\<phi>) S.Univ Univ\\<rbrakk>\n  \\<Longrightarrow> \\<exists>\\<Phi>.\n                       invertible_functor S (\\<cdot>) \\<Phi> \\<and>\n                       (\\<forall>m.\n                           S.incl m \\<longrightarrow>\n                           set_category.incl (\\<cdot>) \\<AA> (\\<Phi> m))\n  set_category (\\<cdot>) \\<AA>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Phi>.\n       invertible_functor S (\\<cdot>) \\<Phi> \\<and>\n       (\\<forall>m.\n           S.incl m \\<longrightarrow>\n           set_category.incl (\\<cdot>) \\<AA> (\\<Phi> m))", "by auto"], ["proof (state)\nthis:\n  \\<exists>\\<Phi>.\n     invertible_functor S (\\<cdot>) \\<Phi> \\<and>\n     (\\<forall>m.\n         S.incl m \\<longrightarrow>\n         set_category.incl (\\<cdot>) \\<AA> (\\<Phi> m))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "sublocale setcat \\<subseteq> set_category comp \\<AA>"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_category (\\<cdot>) \\<AA>", "using is_set_category"], ["proof (prove)\nusing this:\n  set_category (\\<cdot>) \\<AA>\n\ngoal (1 subgoal):\n 1. set_category (\\<cdot>) \\<AA>", "by simp"], ["", "sublocale setcat \\<subseteq> concrete_set_category comp \\<AA> UNIV UP"], ["proof (prove)\ngoal (1 subgoal):\n 1. concrete_set_category (\\<cdot>) \\<AA> UNIV UP", "using is_concrete_set_category"], ["proof (prove)\nusing this:\n  concrete_set_category (\\<cdot>) \\<AA> UNIV UP\n\ngoal (1 subgoal):\n 1. concrete_set_category (\\<cdot>) \\<AA> UNIV UP", "by simp"], ["", "text\\<open>\n    By using a large enough cardinal, we can effectively eliminate the cardinality constraint\n    on the sets that determine objects and thereby obtain a set category that is replete.\n    This is the normal use case, which we want to streamline as much as possible,\n    so it is useful to introduce a special locale for this purpose.\n  \\<close>"], ["", "locale replete_setcat =\n  fixes dummy :: 'e\n  begin"], ["", "interpretation SC: setcat dummy\n                         \\<open>cardSuc (cmax (card_of (UNIV :: 'e setcat.arr set)) natLeq)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. setcat (cardSuc (cmax |UNIV| natLeq))", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. Card_order (cardSuc (cmax |UNIV| natLeq)) \\<and>\n    infinite (Field (cardSuc (cmax |UNIV| natLeq)))", "show \"Card_order (cardSuc (cmax (card_of (UNIV :: 'e setcat.arr set)) natLeq)) \\<and>\n            infinite (Field (cardSuc (cmax (card_of (UNIV :: 'e setcat.arr set)) natLeq)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Card_order (cardSuc (cmax |UNIV| natLeq)) \\<and>\n    infinite (Field (cardSuc (cmax |UNIV| natLeq)))", "by (metis Card_order_cmax Field_natLeq cardSuc_Card_order cardSuc_finite\n          card_of_Card_order finite_cmax infinite_UNIV_char_0 natLeq_Card_order)"], ["proof (state)\nthis:\n  Card_order (cardSuc (cmax |UNIV| natLeq)) \\<and>\n  infinite (Field (cardSuc (cmax |UNIV| natLeq)))\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n      We don't want to expose the concrete details of the construction used to obtain\n      the interpretation \\<open>SC\\<close>; instead, we want any facts proved about it to be derived\n      solely from the assumptions of the @{locale set_category} locales.\n      So we create another level of definitions here.\n    \\<close>"], ["", "definition comp\n    where \"comp \\<equiv> SC.comp\""], ["", "definition UP\n    where \"UP \\<equiv> SC.UP\""], ["", "definition DOWN\n    where \"DOWN \\<equiv> SC.DOWN\""], ["", "sublocale set_category comp \\<open>cardSuc (cmax (card_of (UNIV :: 'e setcat.arr set)) natLeq)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_category local.comp (cardSuc (cmax |UNIV| natLeq))", "using SC.is_set_category comp_def"], ["proof (prove)\nusing this:\n  set_category SC.comp (cardSuc (cmax |UNIV| natLeq))\n  local.comp \\<equiv> SC.comp\n\ngoal (1 subgoal):\n 1. set_category local.comp (cardSuc (cmax |UNIV| natLeq))", "by simp"], ["", "sublocale concrete_set_category comp\n                \\<open>cardSuc (cmax (card_of (UNIV :: 'e setcat.arr set)) natLeq)\\<close> UNIV UP"], ["proof (prove)\ngoal (1 subgoal):\n 1. concrete_set_category local.comp (cardSuc (cmax |UNIV| natLeq)) UNIV UP", "using SC.is_concrete_set_category comp_def UP_def"], ["proof (prove)\nusing this:\n  concrete_set_category SC.comp (cardSuc (cmax |UNIV| natLeq)) UNIV SC.UP\n  local.comp \\<equiv> SC.comp\n  UP \\<equiv> SC.UP\n\ngoal (1 subgoal):\n 1. concrete_set_category local.comp (cardSuc (cmax |UNIV| natLeq)) UNIV UP", "by simp"], ["", "sublocale replete_set_category comp"], ["proof (prove)\ngoal (1 subgoal):\n 1. replete_set_category local.comp", ".."], ["", "lemma UP_mapsto:\n    shows \"UP \\<in> UNIV \\<rightarrow> Univ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP \\<in> UNIV \\<rightarrow> Univ", "using SC.UP_mapsto"], ["proof (prove)\nusing this:\n  SC.UP \\<in> UNIV \\<rightarrow> SC.Univ\n\ngoal (1 subgoal):\n 1. UP \\<in> UNIV \\<rightarrow> Univ", "by (simp add: UP_def comp_def)"], ["", "lemma DOWN_mapsto:\n    shows \"DOWN \\<in> Univ \\<rightarrow> UNIV\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DOWN \\<in> Univ \\<rightarrow> UNIV", "by auto"], ["", "lemma DOWN_UP [simp]:\n    shows \"DOWN (UP x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. DOWN (UP x) = x", "by (simp add: DOWN_def UP_def)"], ["", "lemma UP_DOWN [simp]:\n    assumes \"t \\<in> Univ\"\n    shows \"UP (DOWN t) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. UP (DOWN t) = t", "using assms DOWN_def UP_def"], ["proof (prove)\nusing this:\n  t \\<in> Univ\n  DOWN \\<equiv> SC.DOWN\n  UP \\<equiv> SC.UP\n\ngoal (1 subgoal):\n 1. UP (DOWN t) = t", "by (simp add: DOWN_def UP_def comp_def)"], ["", "lemma inj_UP:\n    shows \"inj UP\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj UP", "by (metis DOWN_UP injI)"], ["", "lemma bij_UP:\n    shows \"bij_betw UP UNIV Univ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw UP UNIV Univ", "by (metis SC.bij_UP UP_def comp_def)"], ["", "end"], ["", "end"]]}