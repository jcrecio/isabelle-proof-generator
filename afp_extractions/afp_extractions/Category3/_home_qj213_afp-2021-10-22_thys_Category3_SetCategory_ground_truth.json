{"file_name": "/home/qj213/afp-2021-10-22/thys/Category3/SetCategory.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Category3", "problem_names": ["lemma restr_eqI:\n  assumes \"A = A'\" and \"\\<And>x. x \\<in> A \\<Longrightarrow> F x = F' x\"\n  shows \"restrict F A = restrict F' A'\"", "lemma restr_eqE [elim]:\n  assumes \"restrict F A = restrict F' A\" and \"x \\<in> A\"\n  shows \"F x = F' x\"", "lemma compose_eq' [simp]:\n  shows \"compose A G F = restrict (G o F) A\"", "lemma comp_arr_point:\n    assumes \"arr f\" and \"\\<guillemotleft>x : unity \\<rightarrow> dom f\\<guillemotright>\"\n    shows \"f \\<cdot> x = inv_into (hom unity (cod f)) img (Fun f (img x))\"", "lemma arr_eqI:\n    assumes \"par f f'\" and \"Fun f = Fun f'\"\n    shows \"f = f'\"", "lemma terminal_unity:\n    shows \"terminal unity\"", "lemma ide_unity [simp]:\n    shows \"ide unity\"", "lemma set_subset_Univ [simp]:\n    assumes \"ide a\"\n    shows \"set a \\<subseteq> Univ\"", "lemma inj_on_set:\n    shows \"inj_on set (Collect ide)\"", "lemma set_card:\n    assumes \"ide a\"\n    shows \"|set a| <o \\<AA>\"", "lemma mkIde_set [simp]:\n    assumes \"ide a\"\n    shows \"mkIde (set a) = a\"", "lemma set_mkIde:\n    assumes \"A \\<subseteq> Univ\" and \"|A| <o \\<AA>\"\n    shows \"set (mkIde A) = A\"", "lemma ide_mkIde:\n    assumes \"A \\<subseteq> Univ\" and \"|A| <o \\<AA>\"\n    shows \"ide (mkIde A)\"", "lemma ide_mkIde_finite:\n    assumes \"A \\<subseteq> Univ\" and \"finite A\"\n    shows \"ide (mkIde A)\"", "lemma arr_mkIde:\n    shows \"arr (mkIde A) \\<longleftrightarrow> A \\<subseteq> Univ \\<and> |A| <o \\<AA>\"", "lemma dom_mkIde:\n    assumes \"A \\<subseteq> Univ\" and \"|A| <o \\<AA>\"\n    shows \"dom (mkIde A) = mkIde A\"", "lemma cod_mkIde:\n    assumes \"A \\<subseteq> Univ\" and \"|A| <o \\<AA>\"\n    shows \"cod (mkIde A) = mkIde A\"", "lemma Fun_mapsto:\n    assumes \"arr f\"\n    shows \"Fun f \\<in> extensional (set (dom f)) \\<inter> (set (dom f) \\<rightarrow> set (cod f))\"", "lemma Fun_ide:\n    assumes \"ide a\"\n    shows \"Fun a = restrict (\\<lambda>x. x) (set a)\"", "lemma Fun_mkIde:\n    assumes \"A \\<subseteq> Univ\" and \"|A| <o \\<AA>\"\n    shows \"Fun (mkIde A) = restrict (\\<lambda>x. x) A\"", "lemma Fun_comp [simp]:\n    assumes \"seq g f\"\n    shows \"Fun (g \\<cdot> f) = restrict (Fun g o Fun f) (set (dom f))\"", "lemma fun_complete:\n    assumes \"ide a\" and \"ide b\" and \"F \\<in> set a \\<rightarrow> set b\"\n    shows \"\\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and> Fun f = restrict F (set a)\"", "lemma mkArr_in_hom:\n    assumes \"A \\<subseteq> Univ\" and \"|A| <o \\<AA>\" and \"B \\<subseteq> Univ\" and \"|B| <o \\<AA>\" and \"F \\<in> A \\<rightarrow> B\"\n    shows \"\\<guillemotleft>mkArr A B F : mkIde A \\<rightarrow> mkIde B\\<guillemotright>\"", "lemma arr_mkArr:\n    shows \"arr (mkArr A B F) \\<longleftrightarrow>\n           A \\<subseteq> Univ \\<and> |A| <o \\<AA> \\<and> B \\<subseteq> Univ \\<and> |B| <o \\<AA> \\<and> F \\<in> A \\<rightarrow> B\"", "lemma Fun_mkArr':\n    assumes \"arr (mkArr A B F)\"\n    shows \"\\<guillemotleft>mkArr A B F : mkIde A \\<rightarrow> mkIde B\\<guillemotright>\"\n    and \"Fun (mkArr A B F) = restrict F A\"", "lemma mkArr_Fun:\n    assumes \"arr f\"\n    shows \"mkArr (set (dom f)) (set (cod f)) (Fun f) = f\"", "lemma dom_mkArr [simp]:\n    assumes \"arr (mkArr A B F)\"\n    shows \"dom (mkArr A B F) = mkIde A\"", "lemma cod_mkArr [simp]:\n    assumes \"arr (mkArr A B F)\"\n    shows \"cod (mkArr A B F) = mkIde B\"", "lemma Fun_mkArr [simp]:\n    assumes \"arr (mkArr A B F)\"\n    shows \"Fun (mkArr A B F) = restrict F A\"", "lemma mkArr_eqI [intro]:\n    assumes \"arr (mkArr A B F)\"\n    and \"A = A'\" and \"B = B'\" and \"\\<And>x. x \\<in> A \\<Longrightarrow> F x = F' x\"\n    shows \"mkArr A B F = mkArr A' B' F'\"", "lemma mkArr_eqI' [intro]:\n    assumes \"arr (mkArr A B F)\" and \"\\<And>x. x \\<in> A \\<Longrightarrow> F x = F' x\"\n    shows \"mkArr A B F = mkArr A B F'\"", "lemma mkArr_restrict_eq:\n    assumes \"arr (mkArr A B F)\"\n    shows \"mkArr A B (restrict F A) = mkArr A B F\"", "lemma mkArr_restrict_eq':\n    assumes \"arr (mkArr A B (restrict F A))\"\n    shows \"mkArr A B (restrict F A) = mkArr A B F\"", "lemma mkIde_as_mkArr:\n    assumes \"A \\<subseteq> Univ\" and \"|A| <o \\<AA>\"\n    shows \"mkArr A A (\\<lambda>x. x) = mkIde A\"", "lemma comp_mkArr:\n    assumes \"arr (mkArr A B F)\" and \"arr (mkArr B C G)\"\n    shows \"mkArr B C G \\<cdot> mkArr A B F = mkArr A C (G \\<circ> F)\"", "lemma terminal_char1:\n    shows \"terminal t \\<longleftrightarrow> ide t \\<and> (\\<exists>!x. x \\<in> set t)\"", "lemma terminal_char2:\n    shows \"terminal t \\<longleftrightarrow> ide t \\<and> set t = {t}\"", "lemma card_of_leq:\n    assumes \"A \\<subseteq> Univ\"\n    shows \"|A| <o cardSuc (cmax (card_of (UNIV :: 's set)) natLeq)\"", "lemma set_mkIde [simp]:\n    assumes \"A \\<subseteq> Univ\"\n    shows \"set (mkIde A) = A\"", "lemma ide_mkIde [simp]:\n    assumes \"A \\<subseteq> Univ\"\n    shows \"ide (mkIde A)\"", "lemma arr_mkIde [iff]:\n    shows \"arr (mkIde A) \\<longleftrightarrow> A \\<subseteq> Univ\"", "lemma dom_mkIde [simp]:\n    assumes \"A \\<subseteq> Univ\"\n    shows \"dom (mkIde A) = mkIde A\"", "lemma cod_mkIde [simp]:\n    assumes \"A \\<subseteq> Univ\"\n    shows \"cod (mkIde A) = mkIde A\"", "lemma Fun_mkIde [simp]:\n    assumes \"A \\<subseteq> Univ\"\n    shows \"Fun (mkIde A) = restrict (\\<lambda>x. x) A\"", "lemma mkArr_in_hom [intro]:\n    assumes \"A \\<subseteq> Univ\" and \"B \\<subseteq> Univ\" and \"F \\<in> A \\<rightarrow> B\"\n    shows \"\\<guillemotleft>mkArr A B F : mkIde A \\<rightarrow> mkIde B\\<guillemotright>\"", "lemma arr_mkArr:\n    shows \"arr (mkArr A B F) \\<longleftrightarrow> A \\<subseteq> Univ \\<and> B \\<subseteq> Univ \\<and> F \\<in> A \\<rightarrow> B\"", "lemma mkIde_as_mkArr:\n    assumes \"A \\<subseteq> Univ\"\n    shows \"mkArr A A (\\<lambda>x. x) = mkIde A\"", "lemma Fun_incl:\n    assumes \"incl f\"\n    shows \"Fun f = (\\<lambda>x \\<in> set (dom f). x)\"", "lemma ex_incl_iff_subset:\n    assumes \"ide a\" and \"ide b\"\n    shows \"(\\<exists>f. \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and> incl f) \\<longleftrightarrow> set a \\<subseteq> set b\"", "lemma \\<psi>_\\<phi>:\n    assumes \"t \\<in> S.Univ\"\n    shows \"\\<psi> (\\<phi> t) = t\"", "lemma \\<phi>_\\<psi>:\n    assumes \"t' \\<in> S'.Univ\"\n    shows \"\\<phi> (\\<psi> t') = t'\"", "lemma \\<psi>_img_\\<phi>_img:\n    assumes \"A \\<subseteq> S.Univ\"\n    shows \"\\<psi> ` \\<phi> ` A = A\"", "lemma \\<phi>_img_\\<psi>_img:\n    assumes \"A' \\<subseteq> S'.Univ\"\n    shows \"\\<phi> ` \\<psi> ` A' = A'\"", "lemma set_\\<Phi>o:\n    assumes \"S.ide a\"\n    shows \"S'.set (\\<Phi>o a) = \\<phi> ` S.set a\"", "lemma \\<Phi>o_preserves_ide:\n    assumes \"S.ide a\"\n    shows \"S'.ide (\\<Phi>o a)\"", "lemma \\<Phi>a_mapsto:\n    assumes \"S.arr f\"\n    shows \"\\<Phi>a f \\<in> S'.set (\\<Phi>o (S.dom f)) \\<rightarrow> S'.set (\\<Phi>o (S.cod f))\"", "lemma \\<Phi>a_comp:\n    assumes gf: \"S.seq g f\"\n    shows \"\\<Phi>a (g \\<cdot> f) = restrict (\\<Phi>a g o \\<Phi>a f) (S'.set (\\<Phi>o (S.dom f)))\"", "lemma \\<Phi>_in_hom:\n    assumes \"S.arr f\"\n    shows \"\\<Phi> f \\<in> S'.hom (\\<Phi>o (S.dom f)) (\\<Phi>o (S.cod f))\"", "lemma \\<Phi>_ide [simp]:\n    assumes \"S.ide a\"\n    shows \"\\<Phi> a = \\<Phi>o a\"", "lemma set_dom_\\<Phi>:\n    assumes \"S.arr f\"\n    shows \"S'.set (S'.dom (\\<Phi> f)) = \\<phi> ` (S.set (S.dom f))\"", "lemma \\<Phi>_comp:\n    assumes \"S.seq g f\"\n    shows \"\\<Phi> (g \\<cdot> f) = \\<Phi> g \\<cdot>\\<acute> \\<Phi> f\"", "lemma \\<Phi>_is_functor:\n    shows \"functor S S' \\<Phi>\"", "lemma Fun_\\<Phi>:\n    assumes \"S.arr f\" and \"x \\<in> S.set (S.dom f)\"\n    shows \"S'.Fun (\\<Phi> f) (\\<phi> x) = \\<Phi>a f (\\<phi> x)\"", "lemma \\<Phi>_acts_elementwise:\n    assumes \"S.ide a\"\n    shows \"S'.set (\\<Phi> a) = \\<Phi> ` S.set a\"", "lemma \\<Phi>_preserves_incl:\n    assumes \"S.incl m\"\n    shows \"S'.incl (\\<Phi> m)\"", "lemma Fun_\\<Psi>:\n    assumes \"S'.arr f'\" and \"x' \\<in> S'.set (S'.dom f')\"\n    shows \"S.Fun (\\<Psi> f') (\\<psi> x') = \\<Psi>a f' (\\<psi> x')\"", "lemma \\<Psi>o_\\<Phi>o:\n    assumes \"S.ide a\"\n    shows \"\\<Psi>o (\\<Phi>o a) = a\"", "lemma \\<Phi>\\<Psi>:\n    assumes \"S.arr f\"\n    shows \"\\<Psi> (\\<Phi> f) = f\"", "lemma \\<Phi>o_\\<Psi>o:\n    assumes \"S'.ide a'\"\n    shows \"\\<Phi>o (\\<Psi>o a') = a'\"", "lemma \\<Psi>\\<Phi>:\n    assumes \"S'.arr f'\"\n    shows \"\\<Phi> (\\<Psi> f') = f'\"", "lemma inverse_functors_\\<Phi>_\\<Psi>:\n    shows \"inverse_functors S S' \\<Psi> \\<Phi>\"", "lemma are_isomorphic:\n    shows \"\\<exists>\\<Phi>. invertible_functor S S' \\<Phi> \\<and> (\\<forall>m. S.incl m \\<longrightarrow> S'.incl (\\<Phi> m))\"", "theorem set_category_is_categorical:\n  assumes \"set_category S \\<AA>\" and \"set_category S' \\<AA>\"\n  and \"bij_betw \\<phi> (set_category_data.Univ S) (set_category_data.Univ S')\"\n  shows \"\\<exists>\\<Phi>. invertible_functor S S' \\<Phi> \\<and>\n             (\\<forall>m. set_category.incl S \\<AA> m \\<longrightarrow> set_category.incl S' \\<AA> (\\<Phi> m))\"", "lemma initial_empty:\n    shows \"initial empty\"", "lemma ide_char:\n    assumes \"arr f\"\n    shows \"ide f \\<longleftrightarrow> Dom f = Cod f \\<and> Fun f = (\\<lambda>x \\<in> Dom f. x)\"", "lemma ideI:\n    assumes \"arr f\" and \"Dom f = Cod f\" and \"\\<And>x. x \\<in> Dom f \\<Longrightarrow> Fun f x = x\"\n    shows \"ide f\"", "lemma ide_implies_incl:\n    assumes \"ide a\"\n    shows \"incl a\"", "lemma elem_set_implies_set_eq_singleton:\n    assumes \"a \\<in> set b\"\n    shows \"set a = {a}\"", "lemma elem_set_implies_incl_in:\n    assumes \"a \\<in> set b\"\n    shows \"incl_in a b\"", "lemma incl_incl_of [simp]:\n    assumes \"incl_in a b\"\n    shows \"incl (incl_of a b)\"\n    and \"\\<guillemotleft>incl_of a b : a \\<rightarrow> b\\<guillemotright>\"", "lemma incls_coherent:\n    assumes \"par f f'\" and \"incl f\" and \"incl f'\"\n    shows \"f = f'\"", "lemma incl_comp [simp]:\n    assumes \"incl f\" and \"incl g\" and \"cod f = dom g\"\n    shows \"incl (g \\<cdot> f)\"", "lemma ide_img [simp]:\n    assumes \"arr f\"\n    shows \"ide (img f)\"", "lemma set_img [simp]:\n    assumes \"arr f\"\n    shows \"set (img f) = Img f\"", "lemma img_point_in_Univ:\n    assumes \"\\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright>\"\n    shows \"img x \\<in> Univ\"", "lemma incl_in_img_cod:\n    assumes \"arr f\"\n    shows \"incl_in (img f) (cod f)\"", "lemma img_point_elem_set:\n    assumes \"\\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright>\"\n    shows \"img x \\<in> set a\"", "lemma corestr_in_hom:\n    assumes \"arr f\"\n    shows \"\\<guillemotleft>corestr f : dom f \\<rightarrow> img f\\<guillemotright>\"", "lemma img_fact:\n    assumes \"arr f\"\n    shows \"S (incl_of (img f) (cod f)) (corestr f) = f\"", "lemma Fun_corestr:\n    assumes \"arr f\"\n    shows \"Fun (corestr f) = Fun f\"", "lemma mkPoint_in_hom:\n    assumes \"ide a\" and \"t \\<in> set a\"\n    shows \"\\<guillemotleft>mkPoint a t : unity \\<rightarrow> a\\<guillemotright>\"", "lemma Fun_mkPoint:\n    assumes \"ide a\" and \"t \\<in> set a\"\n    shows \"Fun (mkPoint a t) = (\\<lambda>_ \\<in> {unity}. t)\"", "lemma mkPoint_img:\n    shows \"img \\<in> hom unity a \\<rightarrow> set a\"\n    and \"\\<And>x. \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<Longrightarrow> mkPoint a (img x) = x\"", "lemma img_mkPoint:\n    assumes \"ide a\"\n    shows \"mkPoint a \\<in> set a \\<rightarrow> hom unity a\"\n    and \"\\<And>t. t \\<in> set a \\<Longrightarrow> img (mkPoint a t) = t\"", "lemma bij_betw_points_and_set:\n    assumes \"ide a\"\n    shows \"bij_betw img (hom unity a) (set a)\"", "lemma Fun_point:\n    assumes \"\\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright>\"\n    shows \"Fun x = (\\<lambda>_ \\<in> {unity}. img x)\"", "lemma comp_arr_mkPoint:\n    assumes \"arr f\" and \"t \\<in> Dom f\"\n    shows \"f \\<cdot> mkPoint (dom f) t = mkPoint (cod f) (Fun f t)\"", "lemma comp_arr_point:\n    assumes \"arr f\" and \"\\<guillemotleft>x : unity \\<rightarrow> dom f\\<guillemotright>\"\n    shows \"f \\<cdot> x = mkPoint (cod f) (Fun f (img x))\"", "lemma Fun_in_terms_of_comp:\n    assumes \"arr f\"\n    shows \"Fun f = restrict (img o S f o mkPoint (dom f)) (Dom f)\"", "lemma arr_eqI':\n    assumes \"par f f'\" and \"\\<And>x. \\<guillemotleft>x : unity \\<rightarrow> dom f\\<guillemotright> \\<Longrightarrow> f \\<cdot> x = f' \\<cdot> x\"\n    shows \"f = f'\"", "lemma mkArr'_in_hom:\n    assumes \"ide a\" and \"ide b\" and \"F \\<in> hom unity a \\<rightarrow> hom unity b\"\n    shows \"\\<guillemotleft>mkArr' a b F : a \\<rightarrow> b\\<guillemotright>\"", "lemma comp_point_mkArr':\n    assumes \"ide a\" and \"ide b\" and \"F \\<in> hom unity a \\<rightarrow> hom unity b\"\n    shows \"\\<And>x. \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<Longrightarrow> mkArr' a b F \\<cdot> x = F x\"", "lemma terminal_char3:\n    assumes \"\\<exists>!x. \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright>\"\n    shows \"terminal a\"", "lemma fun_complete':\n    assumes \"ide a\" and \"ide b\" and \"F \\<in> hom unity a \\<rightarrow> hom unity b\"\n    shows \"\\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and> (\\<forall>x. \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<longrightarrow> f \\<cdot> x = F x)\"", "lemma eq_Fun_iff_incl_joinable:\n    assumes \"span f f'\"\n    shows \"Fun f = Fun f' \\<longleftrightarrow>\n           (\\<exists>m m'. incl m \\<and> incl m' \\<and> seq m f \\<and> seq m' f' \\<and> m \\<cdot> f = m' \\<cdot> f')\"", "lemma eq_Fun_iff_eq_corestr:\n    assumes \"span f f'\"\n    shows \"Fun f = Fun f' \\<longleftrightarrow> corestr f = corestr f'\"", "lemma retraction_if_Img_eq_Cod:\n    assumes \"arr g\" and \"Img g = Cod g\"\n    shows \"retraction g\"\n    and \"ide (g \\<cdot> mkArr (Cod g) (Dom g) (inv_into (Dom g) (Fun g)))\"", "lemma retraction_char:\n    shows \"retraction g \\<longleftrightarrow> arr g \\<and> Img g = Cod g\"", "lemma retraction_corestr:\n    assumes \"arr f\"\n    shows \"retraction (corestr f)\"", "lemma section_if_inj:\n    assumes \"arr f\" and \"inj_on (Fun f) (Dom f)\" and \"Dom f = {} \\<longrightarrow> Cod f = {}\"\n    shows \"section f\"\n    and \"ide (mkArr (Cod f) (Dom f)\n                    (\\<lambda>y. if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n                         else SOME x. x \\<in> Dom f)\n                \\<cdot> f)\"", "lemma section_char:\n    shows \"section f \\<longleftrightarrow> arr f \\<and> (Dom f = {} \\<longrightarrow> Cod f = {}) \\<and> inj_on (Fun f) (Dom f)\"", "lemma section_retraction_char:\n    shows \"ide (g \\<cdot> f) \\<longleftrightarrow> antipar f g \\<and> compose (Dom f) (Fun g) (Fun f) = (\\<lambda>x \\<in> Dom f. x)\"", "lemma inverse_arrows_char:\n    shows \"inverse_arrows f g \\<longleftrightarrow>\n             antipar f g \\<and> compose (Dom f) (Fun g) (Fun f) = (\\<lambda>x \\<in> Dom f. x)\n                         \\<and> compose (Dom g) (Fun f) (Fun g) = (\\<lambda>y \\<in> Dom g. y)\"", "lemma iso_char:\n    shows \"iso f \\<longleftrightarrow> arr f \\<and> bij_betw (Fun f) (Dom f) (Cod f)\"", "lemma inv_char:\n    assumes \"iso f\"\n    shows \"inv f = mkArr (Cod f) (Dom f) (inv_into (Dom f) (Fun f))\"", "lemma Fun_inv:\n    assumes \"iso f\"\n    shows \"Fun (inv f) = restrict (inv_into (Dom f) (Fun f)) (Cod f)\"", "lemma mono_char:\n    shows \"mono f \\<longleftrightarrow> arr f \\<and> inj_on (Fun f) (Dom f)\"", "lemma mono_imp_incl:\n    assumes \"incl f\"\n    shows \"mono f\"", "lemma mono_imp_section:\n    assumes \"mono f\" and \"Dom f = {} \\<longrightarrow> Cod f = {}\"\n    shows \"section f\"", "lemma epi_char:\n    shows \"epi f \\<longleftrightarrow> arr f \\<and> (Img f = Cod f \\<or> (\\<forall>t t'. t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow> t = t'))\"", "lemma epi_imp_retraction:\n    assumes \"epi f\" and \"\\<exists>t t'. t \\<in> Univ \\<and> t' \\<in> Univ \\<and> t \\<noteq> t'\"\n    shows \"retraction f\"", "lemma unique_retr_incl_fact:\n    assumes \"seq m e\" and \"seq m' e'\" and \"m \\<cdot> e = m' \\<cdot> e'\"\n    and \"incl m\" and \"incl m'\" and \"retraction e\" and \"retraction e'\"\n    shows \"m = m'\" and \"e = e'\"", "lemma \\<o>_mapsto:\n    shows \"\\<o> \\<in> \\<iota> ` U \\<rightarrow> U\"", "lemma \\<o>_\\<iota> [simp]:\n    assumes \"x \\<in> U\"\n    shows \"\\<o> (\\<iota> x) = x\"", "lemma \\<iota>_\\<o> [simp]:\n    assumes \"t \\<in> \\<iota> ` U\"\n    shows \"\\<iota> (\\<o> t) = t\""], "translations": [["", "lemma restr_eqI:\n  assumes \"A = A'\" and \"\\<And>x. x \\<in> A \\<Longrightarrow> F x = F' x\"\n  shows \"restrict F A = restrict F' A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict F A = restrict F' A'", "using assms"], ["proof (prove)\nusing this:\n  A = A'\n  ?x \\<in> A \\<Longrightarrow> F ?x = F' ?x\n\ngoal (1 subgoal):\n 1. restrict F A = restrict F' A'", "by force"], ["", "(* This rule avoided a long proof in at least one instance\n     where FuncSet.restrict_apply did not work.\n   *)"], ["", "lemma restr_eqE [elim]:\n  assumes \"restrict F A = restrict F' A\" and \"x \\<in> A\"\n  shows \"F x = F' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F x = F' x", "using assms restrict_def"], ["proof (prove)\nusing this:\n  restrict F A = restrict F' A\n  x \\<in> A\n  restrict ?f ?A = (\\<lambda>x. if x \\<in> ?A then ?f x else undefined)\n\ngoal (1 subgoal):\n 1. F x = F' x", "by metis"], ["", "(* This seems more useful than compose_eq in FuncSet. *)"], ["", "lemma compose_eq' [simp]:\n  shows \"compose A G F = restrict (G o F) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compose A G F = restrict (G \\<circ> F) A", "unfolding compose_def restrict_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. if x \\<in> A then G (F x) else undefined) =\n    (\\<lambda>x. if x \\<in> A then (G \\<circ> F) x else undefined)", "by auto"], ["", "section \"Set Categories\""], ["", "text\\<open>\n    We first define the locale \\<open>set_category_data\\<close>, which sets out the basic\n    data and definitions for the \\<open>set_category\\<close> locale, without imposing any conditions\n    other than that @{term S} is a category and that @{term img} is a function defined\n    on the arrow type of @{term S}.  The function @{term img} should be thought of\n    as a mapping that takes a point @{term \"x \\<in> hom unity a\"} to a corresponding\n    terminal object @{term \"img x\"}.  Eventually, assumptions will be introduced so\n    that this is in fact the case.\n\\<close>"], ["", "locale set_category_data = category S\n  for S :: \"'s comp\"      (infixr \"\\<cdot>\" 55)\n  and img :: \"'s \\<Rightarrow> 's\"\n  begin"], ["", "notation in_hom       (\"\\<guillemotleft>_ : _ \\<rightarrow> _\\<guillemotright>\")"], ["", "text\\<open>\n      Call the set of all terminal objects of S the ``universe''.\n\\<close>"], ["", "abbreviation Univ :: \"'s set\"\n    where \"Univ \\<equiv> Collect terminal\""], ["", "text\\<open>\n      Choose an arbitrary element of the universe and call it @{term unity}.\n\\<close>"], ["", "definition unity :: 's\n    where \"unity = (SOME t. terminal t)\""], ["", "text\\<open>\n      Each object @{term a} determines a subset @{term \"set a\"} of the universe,\n      consisting of all those terminal objects @{term t} such that @{term \"t = img x\"}\n      for some @{term \"x \\<in> hom unity a\"}.\n\\<close>"], ["", "definition set :: \"'s \\<Rightarrow> 's set\"\n    where \"set a = img ` hom unity a\""], ["", "end"], ["", "text\\<open>\n    Next, we define a locale \\<open>set_category_given_img\\<close> that augments the\n    \\<open>set_category_data\\<close> locale with assumptions that serve to define\n    the notion of a set category with a chosen correspondence between points\n    and terminal objects.  The assumptions require that the universe be nonempty\n    (so that the definition of @{term unity} makes sense), that the map\n    @{term img} is a locally injective map taking points to terminal objects,\n    that each terminal object @{term t} belongs to @{term \"set t\"},\n    that two objects of @{term S} are equal if they determine the same set,\n    that two parallel arrows of @{term S} are equal if they determine the same\n    function, that there is an object corresponding to each subset of the universe\n    whose cardinality is less than a specified cardinal \\<open>\\<AA>\\<close>, and that for any objects\n    @{term a} and @{term b} and function @{term \"F \\<in> hom unity a \\<rightarrow> hom unity b\"}\n    there is an arrow @{term \"f \\<in> hom a b\"} whose action under the composition\n    of @{term S} coincides with the function @{term F}.\n\n    The cardinal \\<open>\\<AA>\\<close>, which is given as a parameter to the locale, has been introduced\n    because most of the familiar properties of a set category do not depend on\n    there being an object corresponding to \\emph{every} subset of the universe,\n    and we would like to consider such situations; for example, the situation in\n    which there only \\emph{finite} subsets determine objects.\n\\<close>"], ["", "locale set_category_given_img = set_category_data S img\n  for S :: \"'s comp\"      (infixr \"\\<cdot>\" 55)\n  and img :: \"'s \\<Rightarrow> 's\"\n  and \\<AA> :: \"'t rel\" +\n  assumes nonempty_Univ: \"Univ \\<noteq> {}\"\n  and img_mapsto: \"ide a \\<Longrightarrow> img \\<in> hom unity a \\<rightarrow> Univ\"\n  and card_points: \"ide a \\<Longrightarrow> |hom unity a| <o \\<AA>\"\n  and inj_img: \"ide a \\<Longrightarrow> inj_on img (hom unity a)\"\n  and stable_img: \"terminal t \\<Longrightarrow> t \\<in> img ` hom unity t\"\n  and extensional_set: \"\\<lbrakk> ide a; ide b; set a = set b \\<rbrakk> \\<Longrightarrow> a = b\"\n  and extensional_arr: \"\\<lbrakk> par f f'; \\<And>x. \\<guillemotleft>x : unity \\<rightarrow> dom f\\<guillemotright> \\<Longrightarrow> f \\<cdot> x = f' \\<cdot> x \\<rbrakk> \\<Longrightarrow> f = f'\"\n  and set_complete: \"\\<lbrakk> A \\<subseteq> Univ; |A| <o \\<AA> \\<rbrakk> \\<Longrightarrow> \\<exists>a. ide a \\<and> set a = A\"\n  and fun_complete1: \"\\<lbrakk> ide a; ide b; F \\<in> hom unity a \\<rightarrow> hom unity b \\<rbrakk>\n                          \\<Longrightarrow> \\<exists>f. \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and> (\\<forall>x. \\<guillemotleft>x : unity \\<rightarrow> dom f\\<guillemotright> \\<longrightarrow> f \\<cdot> x = F x)\"\n  and cardinal: \"Card_order \\<AA> \\<and> infinite (Field \\<AA>)\"\n  begin"], ["", "text\\<open>\n      The inverse of the map @{term set} is a map @{term mkIde} that takes each subset\n      of the universe of cardinality less than \\<open>\\<AA>\\<close> to an identity of @{term[source=true] S}.\n\\<close>"], ["", "definition mkIde :: \"'s set \\<Rightarrow> 's\"\n    where \"mkIde A = (if A \\<subseteq> Univ \\<and> |A| <o \\<AA> then inv_into (Collect ide) set A else null)\""], ["", "text\\<open>\n      Each arrow @{term \"f \\<in> hom a b\"} determines a function @{term \"Fun f \\<in> Univ \\<rightarrow> Univ\"},\n      by passing from @{term Univ} to @{term \"hom a unity\"}, composing with @{term f},\n      then passing back to @{term Univ}.\n\\<close>"], ["", "definition Fun :: \"'s \\<Rightarrow> 's \\<Rightarrow> 's\"\n    where \"Fun f = restrict (img o S f o inv_into (hom unity (dom f)) img) (set (dom f))\""], ["", "lemma comp_arr_point:\n    assumes \"arr f\" and \"\\<guillemotleft>x : unity \\<rightarrow> dom f\\<guillemotright>\"\n    shows \"f \\<cdot> x = inv_into (hom unity (cod f)) img (Fun f (img x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<cdot> x = inv_into (hom unity (cod f)) img (Fun f (img x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<cdot> x = inv_into (hom unity (cod f)) img (Fun f (img x))", "have \"\\<guillemotleft>f \\<cdot> x : unity \\<rightarrow> cod f\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>f \\<cdot> x : unity \\<rightarrow> cod f\\<guillemotright>", "using assms"], ["proof (prove)\nusing this:\n  arr f\n  \\<guillemotleft>x : unity \\<rightarrow> local.dom f\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>f \\<cdot> x : unity \\<rightarrow> cod f\\<guillemotright>", "by blast"], ["proof (state)\nthis:\n  \\<guillemotleft>f \\<cdot> x : unity \\<rightarrow> cod f\\<guillemotright>\n\ngoal (1 subgoal):\n 1. f \\<cdot> x = inv_into (hom unity (cod f)) img (Fun f (img x))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f \\<cdot> x : unity \\<rightarrow> cod f\\<guillemotright>\n\ngoal (1 subgoal):\n 1. f \\<cdot> x = inv_into (hom unity (cod f)) img (Fun f (img x))", "using assms Fun_def inj_img set_def"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f \\<cdot> x : unity \\<rightarrow> cod f\\<guillemotright>\n  arr f\n  \\<guillemotleft>x : unity \\<rightarrow> local.dom f\\<guillemotright>\n  Fun ?f =\n  restrict\n   (img \\<circ> (\\<cdot>) ?f \\<circ>\n    inv_into (hom unity (local.dom ?f)) img)\n   (local.set (local.dom ?f))\n  ide ?a \\<Longrightarrow> inj_on img (hom unity ?a)\n  local.set ?a = img ` hom unity ?a\n\ngoal (1 subgoal):\n 1. f \\<cdot> x = inv_into (hom unity (cod f)) img (Fun f (img x))", "by simp"], ["proof (state)\nthis:\n  f \\<cdot> x = inv_into (hom unity (cod f)) img (Fun f (img x))\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n      Parallel arrows that determine the same function are equal.\n\\<close>"], ["", "lemma arr_eqI:\n    assumes \"par f f'\" and \"Fun f = Fun f'\"\n    shows \"f = f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = f'", "using assms comp_arr_point extensional_arr"], ["proof (prove)\nusing this:\n  par f f'\n  Fun f = Fun f'\n  \\<lbrakk>arr ?f;\n   \\<guillemotleft>?x : unity \\<rightarrow> local.dom\n       ?f\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> ?f \\<cdot> ?x =\n                    inv_into (hom unity (cod ?f)) img (Fun ?f (img ?x))\n  \\<lbrakk>par ?f ?f';\n   \\<And>x.\n      \\<guillemotleft>x : unity \\<rightarrow> local.dom\n         ?f\\<guillemotright> \\<Longrightarrow>\n      ?f \\<cdot> x = ?f' \\<cdot> x\\<rbrakk>\n  \\<Longrightarrow> ?f = ?f'\n\ngoal (1 subgoal):\n 1. f = f'", "by metis"], ["", "lemma terminal_unity:\n    shows \"terminal unity\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminal unity", "using unity_def nonempty_Univ"], ["proof (prove)\nusing this:\n  unity = Eps terminal\n  Univ \\<noteq> {}\n\ngoal (1 subgoal):\n 1. terminal unity", "by (simp add: someI_ex)"], ["", "lemma ide_unity [simp]:\n    shows \"ide unity\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide unity", "using terminal_unity terminal_def"], ["proof (prove)\nusing this:\n  terminal unity\n  terminal ?b \\<equiv>\n  ide ?b \\<and>\n  (\\<forall>a.\n      ide a \\<longrightarrow>\n      (\\<exists>!f.\n          \\<guillemotleft>f : a \\<rightarrow> ?b\\<guillemotright>))\n\ngoal (1 subgoal):\n 1. ide unity", "by blast"], ["", "lemma set_subset_Univ [simp]:\n    assumes \"ide a\"\n    shows \"set a \\<subseteq> Univ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.set a \\<subseteq> Univ", "using assms set_def img_mapsto"], ["proof (prove)\nusing this:\n  ide a\n  local.set ?a = img ` hom unity ?a\n  ide ?a \\<Longrightarrow> img \\<in> hom unity ?a \\<rightarrow> Univ\n\ngoal (1 subgoal):\n 1. local.set a \\<subseteq> Univ", "by auto"], ["", "lemma inj_on_set:\n    shows \"inj_on set (Collect ide)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on local.set (Collect ide)", "using extensional_set"], ["proof (prove)\nusing this:\n  \\<lbrakk>ide ?a; ide ?b; local.set ?a = local.set ?b\\<rbrakk>\n  \\<Longrightarrow> ?a = ?b\n\ngoal (1 subgoal):\n 1. inj_on local.set (Collect ide)", "by (intro inj_onI, auto)"], ["", "text\\<open>\n      The mapping @{term mkIde}, which takes subsets of the universe to identities,\n      and @{term set}, which takes identities to subsets of the universe, are inverses.\n\\<close>"], ["", "lemma set_card:\n    assumes \"ide a\"\n    shows \"|set a| <o \\<AA>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |local.set a| <o \\<AA>", "using assms card_points set_def"], ["proof (prove)\nusing this:\n  ide a\n  ide ?a \\<Longrightarrow> |hom unity ?a| <o \\<AA>\n  local.set ?a = img ` hom unity ?a\n\ngoal (1 subgoal):\n 1. |local.set a| <o \\<AA>", "by (metis card_of_image ordLeq_ordLess_trans)"], ["", "lemma mkIde_set [simp]:\n    assumes \"ide a\"\n    shows \"mkIde (set a) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mkIde (local.set a) = a", "using assms mkIde_def inj_on_set inv_into_f_f set_card"], ["proof (prove)\nusing this:\n  ide a\n  mkIde ?A =\n  (if ?A \\<subseteq> Univ \\<and> |?A| <o \\<AA>\n   then inv_into (Collect ide) local.set ?A else null)\n  inj_on local.set (Collect ide)\n  \\<lbrakk>inj_on ?f ?A; ?x \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> inv_into ?A ?f (?f ?x) = ?x\n  ide ?a \\<Longrightarrow> |local.set ?a| <o \\<AA>\n\ngoal (1 subgoal):\n 1. mkIde (local.set a) = a", "by (simp add: ordLess_imp_ordLeq)"], ["", "lemma set_mkIde:\n    assumes \"A \\<subseteq> Univ\" and \"|A| <o \\<AA>\"\n    shows \"set (mkIde A) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.set (mkIde A) = A", "using assms mkIde_def set_complete someI_ex [of \"\\<lambda>a. a \\<in> Collect ide \\<and> set a = A\"]"], ["proof (prove)\nusing this:\n  A \\<subseteq> Univ\n  |A| <o \\<AA>\n  mkIde ?A =\n  (if ?A \\<subseteq> Univ \\<and> |?A| <o \\<AA>\n   then inv_into (Collect ide) local.set ?A else null)\n  \\<lbrakk>?A \\<subseteq> Univ; |?A| <o \\<AA>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a. ide a \\<and> local.set a = ?A\n  \\<exists>x. x \\<in> Collect ide \\<and> local.set x = A \\<Longrightarrow>\n  (SOME x. x \\<in> Collect ide \\<and> local.set x = A)\n  \\<in> Collect ide \\<and>\n  local.set (SOME x. x \\<in> Collect ide \\<and> local.set x = A) = A\n\ngoal (1 subgoal):\n 1. local.set (mkIde A) = A", "by (metis set_category_given_img.mkIde_set set_category_given_img_axioms)"], ["", "lemma ide_mkIde:\n    assumes \"A \\<subseteq> Univ\" and \"|A| <o \\<AA>\"\n    shows \"ide (mkIde A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide (mkIde A)", "using assms mkIde_def mkIde_set set_complete"], ["proof (prove)\nusing this:\n  A \\<subseteq> Univ\n  |A| <o \\<AA>\n  mkIde ?A =\n  (if ?A \\<subseteq> Univ \\<and> |?A| <o \\<AA>\n   then inv_into (Collect ide) local.set ?A else null)\n  ide ?a \\<Longrightarrow> mkIde (local.set ?a) = ?a\n  \\<lbrakk>?A \\<subseteq> Univ; |?A| <o \\<AA>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a. ide a \\<and> local.set a = ?A\n\ngoal (1 subgoal):\n 1. ide (mkIde A)", "by metis"], ["", "text\\<open>\n      Because we have assumed the cardinal \\<open>\\<AA>\\<close> to be infinite, there is an object corresponding\n      to every finite subset of the universe.\n    \\<close>"], ["", "lemma ide_mkIde_finite:\n    assumes \"A \\<subseteq> Univ\" and \"finite A\"\n    shows \"ide (mkIde A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide (mkIde A)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ide (mkIde A)", "have \"|A| <o \\<AA>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |A| <o \\<AA>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. |A| <o \\<AA>", "have \"finite (Field |A| )\""], ["proof (prove)\ngoal (1 subgoal):\n 1. finite (Field |A|)", "using assms(2)"], ["proof (prove)\nusing this:\n  finite A\n\ngoal (1 subgoal):\n 1. finite (Field |A|)", "by simp"], ["proof (state)\nthis:\n  finite (Field |A|)\n\ngoal (1 subgoal):\n 1. |A| <o \\<AA>", "thus ?thesis"], ["proof (prove)\nusing this:\n  finite (Field |A|)\n\ngoal (1 subgoal):\n 1. |A| <o \\<AA>", "using cardinal card_of_Well_order card_order_on_def finite_ordLess_infinite"], ["proof (prove)\nusing this:\n  finite (Field |A|)\n  Card_order \\<AA> \\<and> infinite (Field \\<AA>)\n  Well_order |?A|\n  card_order_on ?A ?r \\<equiv>\n  well_order_on ?A ?r \\<and>\n  (\\<forall>r'. well_order_on ?A r' \\<longrightarrow> ?r \\<le>o r')\n  \\<lbrakk>Well_order ?r; Well_order ?r'; finite (Field ?r);\n   infinite (Field ?r')\\<rbrakk>\n  \\<Longrightarrow> ?r <o ?r'\n\ngoal (1 subgoal):\n 1. |A| <o \\<AA>", "by blast"], ["proof (state)\nthis:\n  |A| <o \\<AA>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  |A| <o \\<AA>\n\ngoal (1 subgoal):\n 1. ide (mkIde A)", "thus ?thesis"], ["proof (prove)\nusing this:\n  |A| <o \\<AA>\n\ngoal (1 subgoal):\n 1. ide (mkIde A)", "using assms(1) ide_mkIde [of A]"], ["proof (prove)\nusing this:\n  |A| <o \\<AA>\n  A \\<subseteq> Univ\n  \\<lbrakk>A \\<subseteq> Univ; |A| <o \\<AA>\\<rbrakk>\n  \\<Longrightarrow> ide (mkIde A)\n\ngoal (1 subgoal):\n 1. ide (mkIde A)", "by simp"], ["proof (state)\nthis:\n  ide (mkIde A)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma arr_mkIde:\n    shows \"arr (mkIde A) \\<longleftrightarrow> A \\<subseteq> Univ \\<and> |A| <o \\<AA>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (mkIde A) = (A \\<subseteq> Univ \\<and> |A| <o \\<AA>)", "using ide_mkIde mkIde_def not_arr_null"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<subseteq> Univ; |?A| <o \\<AA>\\<rbrakk>\n  \\<Longrightarrow> ide (mkIde ?A)\n  mkIde ?A =\n  (if ?A \\<subseteq> Univ \\<and> |?A| <o \\<AA>\n   then inv_into (Collect ide) local.set ?A else null)\n  \\<not> arr null\n\ngoal (1 subgoal):\n 1. arr (mkIde A) = (A \\<subseteq> Univ \\<and> |A| <o \\<AA>)", "by force"], ["", "lemma dom_mkIde:\n    assumes \"A \\<subseteq> Univ\" and \"|A| <o \\<AA>\"\n    shows \"dom (mkIde A) = mkIde A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dom (mkIde A) = mkIde A", "using assms ide_mkIde"], ["proof (prove)\nusing this:\n  A \\<subseteq> Univ\n  |A| <o \\<AA>\n  \\<lbrakk>?A \\<subseteq> Univ; |?A| <o \\<AA>\\<rbrakk>\n  \\<Longrightarrow> ide (mkIde ?A)\n\ngoal (1 subgoal):\n 1. local.dom (mkIde A) = mkIde A", "by simp"], ["", "lemma cod_mkIde:\n    assumes \"A \\<subseteq> Univ\" and \"|A| <o \\<AA>\"\n    shows \"cod (mkIde A) = mkIde A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cod (mkIde A) = mkIde A", "using assms ide_mkIde"], ["proof (prove)\nusing this:\n  A \\<subseteq> Univ\n  |A| <o \\<AA>\n  \\<lbrakk>?A \\<subseteq> Univ; |?A| <o \\<AA>\\<rbrakk>\n  \\<Longrightarrow> ide (mkIde ?A)\n\ngoal (1 subgoal):\n 1. cod (mkIde A) = mkIde A", "by simp"], ["", "text\\<open>\n      Each arrow @{term f} determines an extensional function from\n      @{term \"set (dom f)\"} to @{term \"set (cod f)\"}.\n\\<close>"], ["", "lemma Fun_mapsto:\n    assumes \"arr f\"\n    shows \"Fun f \\<in> extensional (set (dom f)) \\<inter> (set (dom f) \\<rightarrow> set (cod f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun f\n    \\<in> extensional (local.set (local.dom f)) \\<inter>\n          (local.set (local.dom f) \\<rightarrow> local.set (cod f))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. Fun f \\<in> extensional (local.set (local.dom f))\n 2. Fun f \\<in> local.set (local.dom f) \\<rightarrow> local.set (cod f)", "show \"Fun f \\<in> extensional (set (dom f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun f \\<in> extensional (local.set (local.dom f))", "using Fun_def"], ["proof (prove)\nusing this:\n  Fun ?f =\n  restrict\n   (img \\<circ> (\\<cdot>) ?f \\<circ>\n    inv_into (hom unity (local.dom ?f)) img)\n   (local.set (local.dom ?f))\n\ngoal (1 subgoal):\n 1. Fun f \\<in> extensional (local.set (local.dom f))", "by fastforce"], ["proof (state)\nthis:\n  Fun f \\<in> extensional (local.set (local.dom f))\n\ngoal (1 subgoal):\n 1. Fun f \\<in> local.set (local.dom f) \\<rightarrow> local.set (cod f)", "show \"Fun f \\<in> set (dom f) \\<rightarrow> set (cod f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun f \\<in> local.set (local.dom f) \\<rightarrow> local.set (cod f)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> local.set (local.dom f) \\<Longrightarrow>\n       Fun f x \\<in> local.set (cod f)", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> local.set (local.dom f) \\<Longrightarrow>\n       Fun f x \\<in> local.set (cod f)", "assume t: \"t \\<in> set (dom f)\""], ["proof (state)\nthis:\n  t \\<in> local.set (local.dom f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> local.set (local.dom f) \\<Longrightarrow>\n       Fun f x \\<in> local.set (cod f)", "have \"Fun f t = img (f \\<cdot> inv_into (hom unity (dom f)) img t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun f t = img (f \\<cdot> inv_into (hom unity (local.dom f)) img t)", "using assms t Fun_def comp_def"], ["proof (prove)\nusing this:\n  arr f\n  t \\<in> local.set (local.dom f)\n  Fun ?f =\n  restrict\n   (img \\<circ> (\\<cdot>) ?f \\<circ>\n    inv_into (hom unity (local.dom ?f)) img)\n   (local.set (local.dom ?f))\n  ?f \\<circ> ?g = (\\<lambda>x. ?f (?g x))\n\ngoal (1 subgoal):\n 1. Fun f t = img (f \\<cdot> inv_into (hom unity (local.dom f)) img t)", "by simp"], ["proof (state)\nthis:\n  Fun f t = img (f \\<cdot> inv_into (hom unity (local.dom f)) img t)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> local.set (local.dom f) \\<Longrightarrow>\n       Fun f x \\<in> local.set (cod f)", "moreover"], ["proof (state)\nthis:\n  Fun f t = img (f \\<cdot> inv_into (hom unity (local.dom f)) img t)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> local.set (local.dom f) \\<Longrightarrow>\n       Fun f x \\<in> local.set (cod f)", "have \"... \\<in> set (cod f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. img (f \\<cdot> inv_into (hom unity (local.dom f)) img t)\n    \\<in> local.set (cod f)", "using assms t set_def inv_into_into [of t img \"hom unity (dom f)\"]"], ["proof (prove)\nusing this:\n  arr f\n  t \\<in> local.set (local.dom f)\n  local.set ?a = img ` hom unity ?a\n  t \\<in> img ` hom unity (local.dom f) \\<Longrightarrow>\n  inv_into (hom unity (local.dom f)) img t \\<in> hom unity (local.dom f)\n\ngoal (1 subgoal):\n 1. img (f \\<cdot> inv_into (hom unity (local.dom f)) img t)\n    \\<in> local.set (cod f)", "by blast"], ["proof (state)\nthis:\n  img (f \\<cdot> inv_into (hom unity (local.dom f)) img t)\n  \\<in> local.set (cod f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> local.set (local.dom f) \\<Longrightarrow>\n       Fun f x \\<in> local.set (cod f)", "ultimately"], ["proof (chain)\npicking this:\n  Fun f t = img (f \\<cdot> inv_into (hom unity (local.dom f)) img t)\n  img (f \\<cdot> inv_into (hom unity (local.dom f)) img t)\n  \\<in> local.set (cod f)", "show \"Fun f t \\<in> set (cod f)\""], ["proof (prove)\nusing this:\n  Fun f t = img (f \\<cdot> inv_into (hom unity (local.dom f)) img t)\n  img (f \\<cdot> inv_into (hom unity (local.dom f)) img t)\n  \\<in> local.set (cod f)\n\ngoal (1 subgoal):\n 1. Fun f t \\<in> local.set (cod f)", "by auto"], ["proof (state)\nthis:\n  Fun f t \\<in> local.set (cod f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Fun f \\<in> local.set (local.dom f) \\<rightarrow> local.set (cod f)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n      Identities of @{term[source=true] S} correspond to restrictions of the identity function.\n\\<close>"], ["", "lemma Fun_ide:\n    assumes \"ide a\"\n    shows \"Fun a = restrict (\\<lambda>x. x) (set a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun a = (\\<lambda>x\\<in>local.set a. x)", "using assms Fun_def inj_img set_def comp_cod_arr"], ["proof (prove)\nusing this:\n  ide a\n  Fun ?f =\n  restrict\n   (img \\<circ> (\\<cdot>) ?f \\<circ>\n    inv_into (hom unity (local.dom ?f)) img)\n   (local.set (local.dom ?f))\n  ide ?a \\<Longrightarrow> inj_on img (hom unity ?a)\n  local.set ?a = img ` hom unity ?a\n  \\<lbrakk>arr ?f; cod ?f = ?b\\<rbrakk> \\<Longrightarrow> ?b \\<cdot> ?f = ?f\n\ngoal (1 subgoal):\n 1. Fun a = (\\<lambda>x\\<in>local.set a. x)", "by fastforce"], ["", "lemma Fun_mkIde:\n    assumes \"A \\<subseteq> Univ\" and \"|A| <o \\<AA>\"\n    shows \"Fun (mkIde A) = restrict (\\<lambda>x. x) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (mkIde A) = (\\<lambda>x\\<in>A. x)", "using assms ide_mkIde set_mkIde Fun_ide"], ["proof (prove)\nusing this:\n  A \\<subseteq> Univ\n  |A| <o \\<AA>\n  \\<lbrakk>?A \\<subseteq> Univ; |?A| <o \\<AA>\\<rbrakk>\n  \\<Longrightarrow> ide (mkIde ?A)\n  \\<lbrakk>?A \\<subseteq> Univ; |?A| <o \\<AA>\\<rbrakk>\n  \\<Longrightarrow> local.set (mkIde ?A) = ?A\n  ide ?a \\<Longrightarrow> Fun ?a = (\\<lambda>x\\<in>local.set ?a. x)\n\ngoal (1 subgoal):\n 1. Fun (mkIde A) = (\\<lambda>x\\<in>A. x)", "by simp"], ["", "text\\<open>\n      Composition in @{term S} corresponds to extensional function composition.\n\\<close>"], ["", "lemma Fun_comp [simp]:\n    assumes \"seq g f\"\n    shows \"Fun (g \\<cdot> f) = restrict (Fun g o Fun f) (set (dom f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (g \\<cdot> f) =\n    restrict (Fun g \\<circ> Fun f) (local.set (local.dom f))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Fun (g \\<cdot> f) =\n    restrict (Fun g \\<circ> Fun f) (local.set (local.dom f))", "have \"restrict (img o S (g \\<cdot> f) o (inv_into (hom unity (dom (g \\<cdot> f))) img))\n                     (set (dom (g \\<cdot> f)))\n              = restrict (Fun g o Fun f) (set (dom f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict\n     (img \\<circ> (\\<cdot>) (g \\<cdot> f) \\<circ>\n      inv_into (hom unity (local.dom (g \\<cdot> f))) img)\n     (local.set (local.dom (g \\<cdot> f))) =\n    restrict (Fun g \\<circ> Fun f) (local.set (local.dom f))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. restrict\n     (img \\<circ> (\\<cdot>) (g \\<cdot> f) \\<circ>\n      inv_into (hom unity (local.dom (g \\<cdot> f))) img)\n     (local.set (local.dom (g \\<cdot> f))) =\n    restrict (Fun g \\<circ> Fun f) (local.set (local.dom f))", "have 1: \"set (dom (g \\<cdot> f)) = set (dom f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.set (local.dom (g \\<cdot> f)) = local.set (local.dom f)", "using assms"], ["proof (prove)\nusing this:\n  seq g f\n\ngoal (1 subgoal):\n 1. local.set (local.dom (g \\<cdot> f)) = local.set (local.dom f)", "by auto"], ["proof (state)\nthis:\n  local.set (local.dom (g \\<cdot> f)) = local.set (local.dom f)\n\ngoal (1 subgoal):\n 1. restrict\n     (img \\<circ> (\\<cdot>) (g \\<cdot> f) \\<circ>\n      inv_into (hom unity (local.dom (g \\<cdot> f))) img)\n     (local.set (local.dom (g \\<cdot> f))) =\n    restrict (Fun g \\<circ> Fun f) (local.set (local.dom f))", "let ?img' = \"\\<lambda>a. \\<lambda>t. inv_into (hom unity a) img t\""], ["proof (state)\ngoal (1 subgoal):\n 1. restrict\n     (img \\<circ> (\\<cdot>) (g \\<cdot> f) \\<circ>\n      inv_into (hom unity (local.dom (g \\<cdot> f))) img)\n     (local.set (local.dom (g \\<cdot> f))) =\n    restrict (Fun g \\<circ> Fun f) (local.set (local.dom f))", "have 2: \"\\<And>t. t \\<in> set (dom (g \\<cdot> f)) \\<Longrightarrow>\n                     (img o S (g \\<cdot> f) o ?img' (dom (g \\<cdot> f))) t = (Fun g o Fun f) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> local.set (local.dom (g \\<cdot> f)) \\<Longrightarrow>\n       (img \\<circ> (\\<cdot>) (g \\<cdot> f) \\<circ>\n        inv_into (hom unity (local.dom (g \\<cdot> f))) img)\n        t =\n       (Fun g \\<circ> Fun f) t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> local.set (local.dom (g \\<cdot> f)) \\<Longrightarrow>\n       (img \\<circ> (\\<cdot>) (g \\<cdot> f) \\<circ>\n        inv_into (hom unity (local.dom (g \\<cdot> f))) img)\n        t =\n       (Fun g \\<circ> Fun f) t", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> local.set (local.dom (g \\<cdot> f)) \\<Longrightarrow>\n       (img \\<circ> (\\<cdot>) (g \\<cdot> f) \\<circ>\n        inv_into (hom unity (local.dom (g \\<cdot> f))) img)\n        t =\n       (Fun g \\<circ> Fun f) t", "assume \"t \\<in> set (dom (g \\<cdot> f))\""], ["proof (state)\nthis:\n  t \\<in> local.set (local.dom (g \\<cdot> f))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> local.set (local.dom (g \\<cdot> f)) \\<Longrightarrow>\n       (img \\<circ> (\\<cdot>) (g \\<cdot> f) \\<circ>\n        inv_into (hom unity (local.dom (g \\<cdot> f))) img)\n        t =\n       (Fun g \\<circ> Fun f) t", "hence t: \"t \\<in> set (dom f)\""], ["proof (prove)\nusing this:\n  t \\<in> local.set (local.dom (g \\<cdot> f))\n\ngoal (1 subgoal):\n 1. t \\<in> local.set (local.dom f)", "by (simp add: 1)"], ["proof (state)\nthis:\n  t \\<in> local.set (local.dom f)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> local.set (local.dom (g \\<cdot> f)) \\<Longrightarrow>\n       (img \\<circ> (\\<cdot>) (g \\<cdot> f) \\<circ>\n        inv_into (hom unity (local.dom (g \\<cdot> f))) img)\n        t =\n       (Fun g \\<circ> Fun f) t", "have 3: \"\\<And>a x. x \\<in> hom unity a \\<Longrightarrow> ?img' a (img x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a x.\n       x \\<in> hom unity a \\<Longrightarrow>\n       inv_into (hom unity a) img (img x) = x", "using assms inj_img ide_cod inv_into_f_eq"], ["proof (prove)\nusing this:\n  seq g f\n  ide ?a \\<Longrightarrow> inj_on img (hom unity ?a)\n  arr ?f \\<Longrightarrow> ide (cod ?f)\n  \\<lbrakk>inj_on ?f ?A; ?x \\<in> ?A; ?f ?x = ?y\\<rbrakk>\n  \\<Longrightarrow> inv_into ?A ?f ?y = ?x\n\ngoal (1 subgoal):\n 1. \\<And>a x.\n       x \\<in> hom unity a \\<Longrightarrow>\n       inv_into (hom unity a) img (img x) = x", "by (metis arrI in_homE mem_Collect_eq)"], ["proof (state)\nthis:\n  ?x \\<in> hom unity ?a \\<Longrightarrow>\n  inv_into (hom unity ?a) img (img ?x) = ?x\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> local.set (local.dom (g \\<cdot> f)) \\<Longrightarrow>\n       (img \\<circ> (\\<cdot>) (g \\<cdot> f) \\<circ>\n        inv_into (hom unity (local.dom (g \\<cdot> f))) img)\n        t =\n       (Fun g \\<circ> Fun f) t", "have 4: \"?img' (dom f) t \\<in> hom unity (dom f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_into (hom unity (local.dom f)) img t \\<in> hom unity (local.dom f)", "using assms t inv_into_into [of t img \"hom unity (dom f)\"] set_def"], ["proof (prove)\nusing this:\n  seq g f\n  t \\<in> local.set (local.dom f)\n  t \\<in> img ` hom unity (local.dom f) \\<Longrightarrow>\n  inv_into (hom unity (local.dom f)) img t \\<in> hom unity (local.dom f)\n  local.set ?a = img ` hom unity ?a\n\ngoal (1 subgoal):\n 1. inv_into (hom unity (local.dom f)) img t \\<in> hom unity (local.dom f)", "by simp"], ["proof (state)\nthis:\n  inv_into (hom unity (local.dom f)) img t \\<in> hom unity (local.dom f)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> local.set (local.dom (g \\<cdot> f)) \\<Longrightarrow>\n       (img \\<circ> (\\<cdot>) (g \\<cdot> f) \\<circ>\n        inv_into (hom unity (local.dom (g \\<cdot> f))) img)\n        t =\n       (Fun g \\<circ> Fun f) t", "have \"(img o S (g \\<cdot> f) o ?img' (dom (g \\<cdot> f))) t = img (g \\<cdot> f \\<cdot> ?img' (dom f) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (img \\<circ> (\\<cdot>) (g \\<cdot> f) \\<circ>\n     inv_into (hom unity (local.dom (g \\<cdot> f))) img)\n     t =\n    img (g \\<cdot> f \\<cdot> inv_into (hom unity (local.dom f)) img t)", "using assms dom_comp comp_assoc"], ["proof (prove)\nusing this:\n  seq g f\n  seq ?g ?f \\<Longrightarrow> local.dom (?g \\<cdot> ?f) = local.dom ?f\n  (?h \\<cdot> ?g) \\<cdot> ?f = ?h \\<cdot> ?g \\<cdot> ?f\n\ngoal (1 subgoal):\n 1. (img \\<circ> (\\<cdot>) (g \\<cdot> f) \\<circ>\n     inv_into (hom unity (local.dom (g \\<cdot> f))) img)\n     t =\n    img (g \\<cdot> f \\<cdot> inv_into (hom unity (local.dom f)) img t)", "by simp"], ["proof (state)\nthis:\n  (img \\<circ> (\\<cdot>) (g \\<cdot> f) \\<circ>\n   inv_into (hom unity (local.dom (g \\<cdot> f))) img)\n   t =\n  img (g \\<cdot> f \\<cdot> inv_into (hom unity (local.dom f)) img t)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> local.set (local.dom (g \\<cdot> f)) \\<Longrightarrow>\n       (img \\<circ> (\\<cdot>) (g \\<cdot> f) \\<circ>\n        inv_into (hom unity (local.dom (g \\<cdot> f))) img)\n        t =\n       (Fun g \\<circ> Fun f) t", "also"], ["proof (state)\nthis:\n  (img \\<circ> (\\<cdot>) (g \\<cdot> f) \\<circ>\n   inv_into (hom unity (local.dom (g \\<cdot> f))) img)\n   t =\n  img (g \\<cdot> f \\<cdot> inv_into (hom unity (local.dom f)) img t)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> local.set (local.dom (g \\<cdot> f)) \\<Longrightarrow>\n       (img \\<circ> (\\<cdot>) (g \\<cdot> f) \\<circ>\n        inv_into (hom unity (local.dom (g \\<cdot> f))) img)\n        t =\n       (Fun g \\<circ> Fun f) t", "have \"... = img (g \\<cdot> ?img' (dom g) (Fun f t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. img (g \\<cdot> f \\<cdot> inv_into (hom unity (local.dom f)) img t) =\n    img (g \\<cdot> inv_into (hom unity (local.dom g)) img (Fun f t))", "using assms t 3 Fun_def set_def comp_arr_point"], ["proof (prove)\nusing this:\n  seq g f\n  t \\<in> local.set (local.dom f)\n  ?x \\<in> hom unity ?a \\<Longrightarrow>\n  inv_into (hom unity ?a) img (img ?x) = ?x\n  Fun ?f =\n  restrict\n   (img \\<circ> (\\<cdot>) ?f \\<circ>\n    inv_into (hom unity (local.dom ?f)) img)\n   (local.set (local.dom ?f))\n  local.set ?a = img ` hom unity ?a\n  \\<lbrakk>arr ?f;\n   \\<guillemotleft>?x : unity \\<rightarrow> local.dom\n       ?f\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> ?f \\<cdot> ?x =\n                    inv_into (hom unity (cod ?f)) img (Fun ?f (img ?x))\n\ngoal (1 subgoal):\n 1. img (g \\<cdot> f \\<cdot> inv_into (hom unity (local.dom f)) img t) =\n    img (g \\<cdot> inv_into (hom unity (local.dom g)) img (Fun f t))", "by auto"], ["proof (state)\nthis:\n  img (g \\<cdot> f \\<cdot> inv_into (hom unity (local.dom f)) img t) =\n  img (g \\<cdot> inv_into (hom unity (local.dom g)) img (Fun f t))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> local.set (local.dom (g \\<cdot> f)) \\<Longrightarrow>\n       (img \\<circ> (\\<cdot>) (g \\<cdot> f) \\<circ>\n        inv_into (hom unity (local.dom (g \\<cdot> f))) img)\n        t =\n       (Fun g \\<circ> Fun f) t", "also"], ["proof (state)\nthis:\n  img (g \\<cdot> f \\<cdot> inv_into (hom unity (local.dom f)) img t) =\n  img (g \\<cdot> inv_into (hom unity (local.dom g)) img (Fun f t))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> local.set (local.dom (g \\<cdot> f)) \\<Longrightarrow>\n       (img \\<circ> (\\<cdot>) (g \\<cdot> f) \\<circ>\n        inv_into (hom unity (local.dom (g \\<cdot> f))) img)\n        t =\n       (Fun g \\<circ> Fun f) t", "have \"... = Fun g (Fun f t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. img (g \\<cdot> inv_into (hom unity (local.dom g)) img (Fun f t)) =\n    Fun g (Fun f t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. img (g \\<cdot> inv_into (hom unity (local.dom g)) img (Fun f t)) =\n    Fun g (Fun f t)", "have \"Fun f t \\<in> img ` hom unity (cod f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun f t \\<in> img ` hom unity (cod f)", "using assms t Fun_mapsto set_def"], ["proof (prove)\nusing this:\n  seq g f\n  t \\<in> local.set (local.dom f)\n  arr ?f \\<Longrightarrow>\n  Fun ?f\n  \\<in> extensional (local.set (local.dom ?f)) \\<inter>\n        (local.set (local.dom ?f) \\<rightarrow> local.set (cod ?f))\n  local.set ?a = img ` hom unity ?a\n\ngoal (1 subgoal):\n 1. Fun f t \\<in> img ` hom unity (cod f)", "by fast"], ["proof (state)\nthis:\n  Fun f t \\<in> img ` hom unity (cod f)\n\ngoal (1 subgoal):\n 1. img (g \\<cdot> inv_into (hom unity (local.dom g)) img (Fun f t)) =\n    Fun g (Fun f t)", "thus ?thesis"], ["proof (prove)\nusing this:\n  Fun f t \\<in> img ` hom unity (cod f)\n\ngoal (1 subgoal):\n 1. img (g \\<cdot> inv_into (hom unity (local.dom g)) img (Fun f t)) =\n    Fun g (Fun f t)", "using assms"], ["proof (prove)\nusing this:\n  Fun f t \\<in> img ` hom unity (cod f)\n  seq g f\n\ngoal (1 subgoal):\n 1. img (g \\<cdot> inv_into (hom unity (local.dom g)) img (Fun f t)) =\n    Fun g (Fun f t)", "by (auto simp add: set_def Fun_def)"], ["proof (state)\nthis:\n  img (g \\<cdot> inv_into (hom unity (local.dom g)) img (Fun f t)) =\n  Fun g (Fun f t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  img (g \\<cdot> inv_into (hom unity (local.dom g)) img (Fun f t)) =\n  Fun g (Fun f t)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> local.set (local.dom (g \\<cdot> f)) \\<Longrightarrow>\n       (img \\<circ> (\\<cdot>) (g \\<cdot> f) \\<circ>\n        inv_into (hom unity (local.dom (g \\<cdot> f))) img)\n        t =\n       (Fun g \\<circ> Fun f) t", "finally"], ["proof (chain)\npicking this:\n  (img \\<circ> (\\<cdot>) (g \\<cdot> f) \\<circ>\n   inv_into (hom unity (local.dom (g \\<cdot> f))) img)\n   t =\n  Fun g (Fun f t)", "show \"(img o S (g \\<cdot> f) o ?img' (dom (g \\<cdot> f))) t = (Fun g o Fun f) t\""], ["proof (prove)\nusing this:\n  (img \\<circ> (\\<cdot>) (g \\<cdot> f) \\<circ>\n   inv_into (hom unity (local.dom (g \\<cdot> f))) img)\n   t =\n  Fun g (Fun f t)\n\ngoal (1 subgoal):\n 1. (img \\<circ> (\\<cdot>) (g \\<cdot> f) \\<circ>\n     inv_into (hom unity (local.dom (g \\<cdot> f))) img)\n     t =\n    (Fun g \\<circ> Fun f) t", "by auto"], ["proof (state)\nthis:\n  (img \\<circ> (\\<cdot>) (g \\<cdot> f) \\<circ>\n   inv_into (hom unity (local.dom (g \\<cdot> f))) img)\n   t =\n  (Fun g \\<circ> Fun f) t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?t \\<in> local.set (local.dom (g \\<cdot> f)) \\<Longrightarrow>\n  (img \\<circ> (\\<cdot>) (g \\<cdot> f) \\<circ>\n   inv_into (hom unity (local.dom (g \\<cdot> f))) img)\n   ?t =\n  (Fun g \\<circ> Fun f) ?t\n\ngoal (1 subgoal):\n 1. restrict\n     (img \\<circ> (\\<cdot>) (g \\<cdot> f) \\<circ>\n      inv_into (hom unity (local.dom (g \\<cdot> f))) img)\n     (local.set (local.dom (g \\<cdot> f))) =\n    restrict (Fun g \\<circ> Fun f) (local.set (local.dom f))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict\n     (img \\<circ> (\\<cdot>) (g \\<cdot> f) \\<circ>\n      inv_into (hom unity (local.dom (g \\<cdot> f))) img)\n     (local.set (local.dom (g \\<cdot> f))) =\n    restrict (Fun g \\<circ> Fun f) (local.set (local.dom f))", "using 1 2"], ["proof (prove)\nusing this:\n  local.set (local.dom (g \\<cdot> f)) = local.set (local.dom f)\n  ?t \\<in> local.set (local.dom (g \\<cdot> f)) \\<Longrightarrow>\n  (img \\<circ> (\\<cdot>) (g \\<cdot> f) \\<circ>\n   inv_into (hom unity (local.dom (g \\<cdot> f))) img)\n   ?t =\n  (Fun g \\<circ> Fun f) ?t\n\ngoal (1 subgoal):\n 1. restrict\n     (img \\<circ> (\\<cdot>) (g \\<cdot> f) \\<circ>\n      inv_into (hom unity (local.dom (g \\<cdot> f))) img)\n     (local.set (local.dom (g \\<cdot> f))) =\n    restrict (Fun g \\<circ> Fun f) (local.set (local.dom f))", "by auto"], ["proof (state)\nthis:\n  restrict\n   (img \\<circ> (\\<cdot>) (g \\<cdot> f) \\<circ>\n    inv_into (hom unity (local.dom (g \\<cdot> f))) img)\n   (local.set (local.dom (g \\<cdot> f))) =\n  restrict (Fun g \\<circ> Fun f) (local.set (local.dom f))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  restrict\n   (img \\<circ> (\\<cdot>) (g \\<cdot> f) \\<circ>\n    inv_into (hom unity (local.dom (g \\<cdot> f))) img)\n   (local.set (local.dom (g \\<cdot> f))) =\n  restrict (Fun g \\<circ> Fun f) (local.set (local.dom f))\n\ngoal (1 subgoal):\n 1. Fun (g \\<cdot> f) =\n    restrict (Fun g \\<circ> Fun f) (local.set (local.dom f))", "thus ?thesis"], ["proof (prove)\nusing this:\n  restrict\n   (img \\<circ> (\\<cdot>) (g \\<cdot> f) \\<circ>\n    inv_into (hom unity (local.dom (g \\<cdot> f))) img)\n   (local.set (local.dom (g \\<cdot> f))) =\n  restrict (Fun g \\<circ> Fun f) (local.set (local.dom f))\n\ngoal (1 subgoal):\n 1. Fun (g \\<cdot> f) =\n    restrict (Fun g \\<circ> Fun f) (local.set (local.dom f))", "using Fun_def"], ["proof (prove)\nusing this:\n  restrict\n   (img \\<circ> (\\<cdot>) (g \\<cdot> f) \\<circ>\n    inv_into (hom unity (local.dom (g \\<cdot> f))) img)\n   (local.set (local.dom (g \\<cdot> f))) =\n  restrict (Fun g \\<circ> Fun f) (local.set (local.dom f))\n  Fun ?f =\n  restrict\n   (img \\<circ> (\\<cdot>) ?f \\<circ>\n    inv_into (hom unity (local.dom ?f)) img)\n   (local.set (local.dom ?f))\n\ngoal (1 subgoal):\n 1. Fun (g \\<cdot> f) =\n    restrict (Fun g \\<circ> Fun f) (local.set (local.dom f))", "by auto"], ["proof (state)\nthis:\n  Fun (g \\<cdot> f) =\n  restrict (Fun g \\<circ> Fun f) (local.set (local.dom f))\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n      The constructor @{term mkArr} is used to obtain an arrow given subsets\n      @{term A} and @{term B} of the universe and a function @{term \"F \\<in> A \\<rightarrow> B\"}.\n\\<close>"], ["", "definition mkArr :: \"'s set \\<Rightarrow> 's set \\<Rightarrow> ('s \\<Rightarrow> 's) \\<Rightarrow> 's\"\n    where \"mkArr A B F = (if A \\<subseteq> Univ \\<and> |A| <o \\<AA> \\<and> B \\<subseteq> Univ \\<and> |B| <o \\<AA> \\<and> F \\<in> A \\<rightarrow> B\n                          then (THE f. f \\<in> hom (mkIde A) (mkIde B) \\<and> Fun f = restrict F A)\n                          else null)\""], ["", "text\\<open>\n      Each function @{term \"F \\<in> set a \\<rightarrow> set b\"} determines a unique arrow @{term \"f \\<in> hom a b\"},\n      such that @{term \"Fun f\"} is the restriction of @{term F} to @{term \"set a\"}.\n\\<close>"], ["", "lemma fun_complete:\n    assumes \"ide a\" and \"ide b\" and \"F \\<in> set a \\<rightarrow> set b\"\n    shows \"\\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and> Fun f = restrict F (set a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!f.\n       \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n       Fun f = restrict F (local.set a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!f.\n       \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n       Fun f = restrict F (local.set a)", "let ?P = \"\\<lambda>f. \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and> Fun f = restrict F (set a)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!f.\n       \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n       Fun f = restrict F (local.set a)", "show \"\\<exists>!f. ?P f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!f.\n       \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n       Fun f = restrict F (local.set a)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : a \\<rightarrow> b\\<guillemotright> \\<and>\n    Fun ?a = restrict F (local.set a)\n 2. \\<And>f.\n       \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n       Fun f = restrict F (local.set a) \\<Longrightarrow>\n       f = ?a", "have \"\\<exists>f. ?P f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n       Fun f = restrict F (local.set a)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n       Fun f = restrict F (local.set a)", "let ?F' = \"\\<lambda>x. inv_into (hom unity b) img (F (img x))\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n       Fun f = restrict F (local.set a)", "have \"?F' \\<in> hom unity a \\<rightarrow> hom unity b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. inv_into (hom unity b) img (F (img x)))\n    \\<in> hom unity a \\<rightarrow> hom unity b", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> hom unity a \\<Longrightarrow>\n       inv_into (hom unity b) img (F (img x)) \\<in> hom unity b", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> hom unity a \\<Longrightarrow>\n       inv_into (hom unity b) img (F (img x)) \\<in> hom unity b", "assume x: \"x \\<in> hom unity a\""], ["proof (state)\nthis:\n  x \\<in> hom unity a\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> hom unity a \\<Longrightarrow>\n       inv_into (hom unity b) img (F (img x)) \\<in> hom unity b", "have \"F (img x) \\<in> set b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F (img x) \\<in> local.set b", "using assms(3) x set_def"], ["proof (prove)\nusing this:\n  F \\<in> local.set a \\<rightarrow> local.set b\n  x \\<in> hom unity a\n  local.set ?a = img ` hom unity ?a\n\ngoal (1 subgoal):\n 1. F (img x) \\<in> local.set b", "by auto"], ["proof (state)\nthis:\n  F (img x) \\<in> local.set b\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> hom unity a \\<Longrightarrow>\n       inv_into (hom unity b) img (F (img x)) \\<in> hom unity b", "thus \"inv_into (hom unity b) img (F (img x)) \\<in> hom unity b\""], ["proof (prove)\nusing this:\n  F (img x) \\<in> local.set b\n\ngoal (1 subgoal):\n 1. inv_into (hom unity b) img (F (img x)) \\<in> hom unity b", "using assms inj_img set_def"], ["proof (prove)\nusing this:\n  F (img x) \\<in> local.set b\n  ide a\n  ide b\n  F \\<in> local.set a \\<rightarrow> local.set b\n  ide ?a \\<Longrightarrow> inj_on img (hom unity ?a)\n  local.set ?a = img ` hom unity ?a\n\ngoal (1 subgoal):\n 1. inv_into (hom unity b) img (F (img x)) \\<in> hom unity b", "by auto"], ["proof (state)\nthis:\n  inv_into (hom unity b) img (F (img x)) \\<in> hom unity b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>x. inv_into (hom unity b) img (F (img x)))\n  \\<in> hom unity a \\<rightarrow> hom unity b\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n       Fun f = restrict F (local.set a)", "hence \"\\<exists>f. \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and> (\\<forall>x. \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<longrightarrow> f \\<cdot> x = ?F' x)\""], ["proof (prove)\nusing this:\n  (\\<lambda>x. inv_into (hom unity b) img (F (img x)))\n  \\<in> hom unity a \\<rightarrow> hom unity b\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n       (\\<forall>x.\n           \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<longrightarrow>\n           f \\<cdot> x = inv_into (hom unity b) img (F (img x)))", "using assms fun_complete1 [of a b]"], ["proof (prove)\nusing this:\n  (\\<lambda>x. inv_into (hom unity b) img (F (img x)))\n  \\<in> hom unity a \\<rightarrow> hom unity b\n  ide a\n  ide b\n  F \\<in> local.set a \\<rightarrow> local.set b\n  \\<lbrakk>ide a; ide b;\n   ?F \\<in> hom unity a \\<rightarrow> hom unity b\\<rbrakk>\n  \\<Longrightarrow> \\<exists>f.\n                       \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n                       (\\<forall>x.\n                           \\<guillemotleft>x : unity \\<rightarrow> local.dom\n                              f\\<guillemotright> \\<longrightarrow>\n                           f \\<cdot> x = ?F x)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n       (\\<forall>x.\n           \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<longrightarrow>\n           f \\<cdot> x = inv_into (hom unity b) img (F (img x)))", "by force"], ["proof (state)\nthis:\n  \\<exists>f.\n     \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n     (\\<forall>x.\n         \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<longrightarrow>\n         f \\<cdot> x = inv_into (hom unity b) img (F (img x)))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n       Fun f = restrict F (local.set a)", "from this"], ["proof (chain)\npicking this:\n  \\<exists>f.\n     \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n     (\\<forall>x.\n         \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<longrightarrow>\n         f \\<cdot> x = inv_into (hom unity b) img (F (img x)))", "obtain f where f: \"\\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and> (\\<forall>x. \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<longrightarrow> f \\<cdot> x = ?F' x)\""], ["proof (prove)\nusing this:\n  \\<exists>f.\n     \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n     (\\<forall>x.\n         \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<longrightarrow>\n         f \\<cdot> x = inv_into (hom unity b) img (F (img x)))\n\ngoal (1 subgoal):\n 1. (\\<And>f.\n        \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n        (\\<forall>x.\n            \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<longrightarrow>\n            f \\<cdot> x =\n            inv_into (hom unity b) img (F (img x))) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n  (\\<forall>x.\n      \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<longrightarrow>\n      f \\<cdot> x = inv_into (hom unity b) img (F (img x)))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n       Fun f = restrict F (local.set a)", "let ?img' = \"\\<lambda>a. \\<lambda>t. inv_into (hom unity a) img t\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n       Fun f = restrict F (local.set a)", "have \"Fun f = restrict F (set a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun f = restrict F (local.set a)", "proof (unfold Fun_def, intro restr_eqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. local.set (local.dom f) = local.set a\n 2. \\<And>x.\n       x \\<in> local.set (local.dom f) \\<Longrightarrow>\n       (img \\<circ> (\\<cdot>) f \\<circ>\n        inv_into (hom unity (local.dom f)) img)\n        x =\n       F x", "show \"set (dom f) = set a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.set (local.dom f) = local.set a", "using f"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n  (\\<forall>x.\n      \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<longrightarrow>\n      f \\<cdot> x = inv_into (hom unity b) img (F (img x)))\n\ngoal (1 subgoal):\n 1. local.set (local.dom f) = local.set a", "by auto"], ["proof (state)\nthis:\n  local.set (local.dom f) = local.set a\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> local.set (local.dom f) \\<Longrightarrow>\n       (img \\<circ> (\\<cdot>) f \\<circ>\n        inv_into (hom unity (local.dom f)) img)\n        x =\n       F x", "show \"\\<And>t. t \\<in> set (dom f) \\<Longrightarrow> (img \\<circ> S f \\<circ> ?img' (dom f)) t = F t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> local.set (local.dom f) \\<Longrightarrow>\n       (img \\<circ> (\\<cdot>) f \\<circ>\n        inv_into (hom unity (local.dom f)) img)\n        t =\n       F t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> local.set (local.dom f) \\<Longrightarrow>\n       (img \\<circ> (\\<cdot>) f \\<circ>\n        inv_into (hom unity (local.dom f)) img)\n        t =\n       F t", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> local.set (local.dom f) \\<Longrightarrow>\n       (img \\<circ> (\\<cdot>) f \\<circ>\n        inv_into (hom unity (local.dom f)) img)\n        t =\n       F t", "assume t: \"t \\<in> set (dom f)\""], ["proof (state)\nthis:\n  t \\<in> local.set (local.dom f)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> local.set (local.dom f) \\<Longrightarrow>\n       (img \\<circ> (\\<cdot>) f \\<circ>\n        inv_into (hom unity (local.dom f)) img)\n        t =\n       F t", "have \"(img \\<circ> S f \\<circ> ?img' (dom f)) t = img (f \\<cdot> ?img' (dom f) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (img \\<circ> (\\<cdot>) f \\<circ> inv_into (hom unity (local.dom f)) img)\n     t =\n    img (f \\<cdot> inv_into (hom unity (local.dom f)) img t)", "by simp"], ["proof (state)\nthis:\n  (img \\<circ> (\\<cdot>) f \\<circ> inv_into (hom unity (local.dom f)) img)\n   t =\n  img (f \\<cdot> inv_into (hom unity (local.dom f)) img t)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> local.set (local.dom f) \\<Longrightarrow>\n       (img \\<circ> (\\<cdot>) f \\<circ>\n        inv_into (hom unity (local.dom f)) img)\n        t =\n       F t", "also"], ["proof (state)\nthis:\n  (img \\<circ> (\\<cdot>) f \\<circ> inv_into (hom unity (local.dom f)) img)\n   t =\n  img (f \\<cdot> inv_into (hom unity (local.dom f)) img t)\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> local.set (local.dom f) \\<Longrightarrow>\n       (img \\<circ> (\\<cdot>) f \\<circ>\n        inv_into (hom unity (local.dom f)) img)\n        t =\n       F t", "have \"... = img (?F' (?img' (dom f) t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. img (f \\<cdot> inv_into (hom unity (local.dom f)) img t) =\n    img (inv_into (hom unity b) img\n          (F (img (inv_into (hom unity (local.dom f)) img t))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. img (f \\<cdot> inv_into (hom unity (local.dom f)) img t) =\n    img (inv_into (hom unity b) img\n          (F (img (inv_into (hom unity (local.dom f)) img t))))", "have \"?img' (dom f) t \\<in> hom unity (dom f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_into (hom unity (local.dom f)) img t \\<in> hom unity (local.dom f)", "using t set_def inv_into_into"], ["proof (prove)\nusing this:\n  t \\<in> local.set (local.dom f)\n  local.set ?a = img ` hom unity ?a\n  ?x \\<in> ?f ` ?A \\<Longrightarrow> inv_into ?A ?f ?x \\<in> ?A\n\ngoal (1 subgoal):\n 1. inv_into (hom unity (local.dom f)) img t \\<in> hom unity (local.dom f)", "by metis"], ["proof (state)\nthis:\n  inv_into (hom unity (local.dom f)) img t \\<in> hom unity (local.dom f)\n\ngoal (1 subgoal):\n 1. img (f \\<cdot> inv_into (hom unity (local.dom f)) img t) =\n    img (inv_into (hom unity b) img\n          (F (img (inv_into (hom unity (local.dom f)) img t))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  inv_into (hom unity (local.dom f)) img t \\<in> hom unity (local.dom f)\n\ngoal (1 subgoal):\n 1. img (f \\<cdot> inv_into (hom unity (local.dom f)) img t) =\n    img (inv_into (hom unity b) img\n          (F (img (inv_into (hom unity (local.dom f)) img t))))", "using f"], ["proof (prove)\nusing this:\n  inv_into (hom unity (local.dom f)) img t \\<in> hom unity (local.dom f)\n  \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n  (\\<forall>x.\n      \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<longrightarrow>\n      f \\<cdot> x = inv_into (hom unity b) img (F (img x)))\n\ngoal (1 subgoal):\n 1. img (f \\<cdot> inv_into (hom unity (local.dom f)) img t) =\n    img (inv_into (hom unity b) img\n          (F (img (inv_into (hom unity (local.dom f)) img t))))", "by auto"], ["proof (state)\nthis:\n  img (f \\<cdot> inv_into (hom unity (local.dom f)) img t) =\n  img (inv_into (hom unity b) img\n        (F (img (inv_into (hom unity (local.dom f)) img t))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  img (f \\<cdot> inv_into (hom unity (local.dom f)) img t) =\n  img (inv_into (hom unity b) img\n        (F (img (inv_into (hom unity (local.dom f)) img t))))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> local.set (local.dom f) \\<Longrightarrow>\n       (img \\<circ> (\\<cdot>) f \\<circ>\n        inv_into (hom unity (local.dom f)) img)\n        t =\n       F t", "also"], ["proof (state)\nthis:\n  img (f \\<cdot> inv_into (hom unity (local.dom f)) img t) =\n  img (inv_into (hom unity b) img\n        (F (img (inv_into (hom unity (local.dom f)) img t))))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> local.set (local.dom f) \\<Longrightarrow>\n       (img \\<circ> (\\<cdot>) f \\<circ>\n        inv_into (hom unity (local.dom f)) img)\n        t =\n       F t", "have \"... = img (?img' (cod f) (F t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. img (inv_into (hom unity b) img\n          (F (img (inv_into (hom unity (local.dom f)) img t)))) =\n    img (inv_into (hom unity (cod f)) img (F t))", "using f t set_def inj_img"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n  (\\<forall>x.\n      \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<longrightarrow>\n      f \\<cdot> x = inv_into (hom unity b) img (F (img x)))\n  t \\<in> local.set (local.dom f)\n  local.set ?a = img ` hom unity ?a\n  ide ?a \\<Longrightarrow> inj_on img (hom unity ?a)\n\ngoal (1 subgoal):\n 1. img (inv_into (hom unity b) img\n          (F (img (inv_into (hom unity (local.dom f)) img t)))) =\n    img (inv_into (hom unity (cod f)) img (F t))", "by auto"], ["proof (state)\nthis:\n  img (inv_into (hom unity b) img\n        (F (img (inv_into (hom unity (local.dom f)) img t)))) =\n  img (inv_into (hom unity (cod f)) img (F t))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> local.set (local.dom f) \\<Longrightarrow>\n       (img \\<circ> (\\<cdot>) f \\<circ>\n        inv_into (hom unity (local.dom f)) img)\n        t =\n       F t", "also"], ["proof (state)\nthis:\n  img (inv_into (hom unity b) img\n        (F (img (inv_into (hom unity (local.dom f)) img t)))) =\n  img (inv_into (hom unity (cod f)) img (F t))\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> local.set (local.dom f) \\<Longrightarrow>\n       (img \\<circ> (\\<cdot>) f \\<circ>\n        inv_into (hom unity (local.dom f)) img)\n        t =\n       F t", "have \"... = F t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. img (inv_into (hom unity (cod f)) img (F t)) = F t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. img (inv_into (hom unity (cod f)) img (F t)) = F t", "have \"F t \\<in> set (cod f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. F t \\<in> local.set (cod f)", "using assms f t"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  F \\<in> local.set a \\<rightarrow> local.set b\n  \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n  (\\<forall>x.\n      \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<longrightarrow>\n      f \\<cdot> x = inv_into (hom unity b) img (F (img x)))\n  t \\<in> local.set (local.dom f)\n\ngoal (1 subgoal):\n 1. F t \\<in> local.set (cod f)", "by auto"], ["proof (state)\nthis:\n  F t \\<in> local.set (cod f)\n\ngoal (1 subgoal):\n 1. img (inv_into (hom unity (cod f)) img (F t)) = F t", "thus ?thesis"], ["proof (prove)\nusing this:\n  F t \\<in> local.set (cod f)\n\ngoal (1 subgoal):\n 1. img (inv_into (hom unity (cod f)) img (F t)) = F t", "using f t set_def inj_img"], ["proof (prove)\nusing this:\n  F t \\<in> local.set (cod f)\n  \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n  (\\<forall>x.\n      \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<longrightarrow>\n      f \\<cdot> x = inv_into (hom unity b) img (F (img x)))\n  t \\<in> local.set (local.dom f)\n  local.set ?a = img ` hom unity ?a\n  ide ?a \\<Longrightarrow> inj_on img (hom unity ?a)\n\ngoal (1 subgoal):\n 1. img (inv_into (hom unity (cod f)) img (F t)) = F t", "by auto"], ["proof (state)\nthis:\n  img (inv_into (hom unity (cod f)) img (F t)) = F t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  img (inv_into (hom unity (cod f)) img (F t)) = F t\n\ngoal (1 subgoal):\n 1. \\<And>t.\n       t \\<in> local.set (local.dom f) \\<Longrightarrow>\n       (img \\<circ> (\\<cdot>) f \\<circ>\n        inv_into (hom unity (local.dom f)) img)\n        t =\n       F t", "finally"], ["proof (chain)\npicking this:\n  (img \\<circ> (\\<cdot>) f \\<circ> inv_into (hom unity (local.dom f)) img)\n   t =\n  F t", "show \"(img \\<circ> S f \\<circ> ?img' (dom f)) t = F t\""], ["proof (prove)\nusing this:\n  (img \\<circ> (\\<cdot>) f \\<circ> inv_into (hom unity (local.dom f)) img)\n   t =\n  F t\n\ngoal (1 subgoal):\n 1. (img \\<circ> (\\<cdot>) f \\<circ> inv_into (hom unity (local.dom f)) img)\n     t =\n    F t", "by auto"], ["proof (state)\nthis:\n  (img \\<circ> (\\<cdot>) f \\<circ> inv_into (hom unity (local.dom f)) img)\n   t =\n  F t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?t \\<in> local.set (local.dom f) \\<Longrightarrow>\n  (img \\<circ> (\\<cdot>) f \\<circ> inv_into (hom unity (local.dom f)) img)\n   ?t =\n  F ?t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Fun f = restrict F (local.set a)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n       Fun f = restrict F (local.set a)", "thus ?thesis"], ["proof (prove)\nusing this:\n  Fun f = restrict F (local.set a)\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n       Fun f = restrict F (local.set a)", "using f"], ["proof (prove)\nusing this:\n  Fun f = restrict F (local.set a)\n  \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n  (\\<forall>x.\n      \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<longrightarrow>\n      f \\<cdot> x = inv_into (hom unity b) img (F (img x)))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n       Fun f = restrict F (local.set a)", "by blast"], ["proof (state)\nthis:\n  \\<exists>f.\n     \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n     Fun f = restrict F (local.set a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>f.\n     \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n     Fun f = restrict F (local.set a)\n\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : a \\<rightarrow> b\\<guillemotright> \\<and>\n    Fun ?a = restrict F (local.set a)\n 2. \\<And>f.\n       \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n       Fun f = restrict F (local.set a) \\<Longrightarrow>\n       f = ?a", "thus F: \"?P (SOME f. ?P f)\""], ["proof (prove)\nusing this:\n  \\<exists>f.\n     \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n     Fun f = restrict F (local.set a)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>SOME f.\n                       \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n                       Fun f =\n                       restrict F\n                        (local.set\n                          a) : a \\<rightarrow> b\\<guillemotright> \\<and>\n    Fun (SOME f.\n            \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n            Fun f = restrict F (local.set a)) =\n    restrict F (local.set a)", "using someI_ex [of ?P]"], ["proof (prove)\nusing this:\n  \\<exists>f.\n     \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n     Fun f = restrict F (local.set a)\n  \\<exists>x.\n     \\<guillemotleft>x : a \\<rightarrow> b\\<guillemotright> \\<and>\n     Fun x = restrict F (local.set a) \\<Longrightarrow>\n  \\<guillemotleft>SOME x.\n                     \\<guillemotleft>x : a \\<rightarrow> b\\<guillemotright> \\<and>\n                     Fun x =\n                     restrict F\n                      (local.set\n                        a) : a \\<rightarrow> b\\<guillemotright> \\<and>\n  Fun (SOME x.\n          \\<guillemotleft>x : a \\<rightarrow> b\\<guillemotright> \\<and>\n          Fun x = restrict F (local.set a)) =\n  restrict F (local.set a)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>SOME f.\n                       \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n                       Fun f =\n                       restrict F\n                        (local.set\n                          a) : a \\<rightarrow> b\\<guillemotright> \\<and>\n    Fun (SOME f.\n            \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n            Fun f = restrict F (local.set a)) =\n    restrict F (local.set a)", "by fast"], ["proof (state)\nthis:\n  \\<guillemotleft>SOME f.\n                     \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n                     Fun f =\n                     restrict F\n                      (local.set\n                        a) : a \\<rightarrow> b\\<guillemotright> \\<and>\n  Fun (SOME f.\n          \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n          Fun f = restrict F (local.set a)) =\n  restrict F (local.set a)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n       Fun f = restrict F (local.set a) \\<Longrightarrow>\n       f =\n       (SOME f.\n           \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n           Fun f = restrict F (local.set a))", "show \"\\<And>f'. ?P f' \\<Longrightarrow> f' = (SOME f. ?P f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f'.\n       \\<guillemotleft>f' : a \\<rightarrow> b\\<guillemotright> \\<and>\n       Fun f' = restrict F (local.set a) \\<Longrightarrow>\n       f' =\n       (SOME f.\n           \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n           Fun f = restrict F (local.set a))", "using F arr_eqI"], ["proof (prove)\nusing this:\n  \\<guillemotleft>SOME f.\n                     \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n                     Fun f =\n                     restrict F\n                      (local.set\n                        a) : a \\<rightarrow> b\\<guillemotright> \\<and>\n  Fun (SOME f.\n          \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n          Fun f = restrict F (local.set a)) =\n  restrict F (local.set a)\n  \\<lbrakk>par ?f ?f'; Fun ?f = Fun ?f'\\<rbrakk> \\<Longrightarrow> ?f = ?f'\n\ngoal (1 subgoal):\n 1. \\<And>f'.\n       \\<guillemotleft>f' : a \\<rightarrow> b\\<guillemotright> \\<and>\n       Fun f' = restrict F (local.set a) \\<Longrightarrow>\n       f' =\n       (SOME f.\n           \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n           Fun f = restrict F (local.set a))", "by (metis (no_types, lifting) in_homE)"], ["proof (state)\nthis:\n  \\<guillemotleft>?f' : a \\<rightarrow> b\\<guillemotright> \\<and>\n  Fun ?f' = restrict F (local.set a) \\<Longrightarrow>\n  ?f' =\n  (SOME f.\n      \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n      Fun f = restrict F (local.set a))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!f.\n     \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n     Fun f = restrict F (local.set a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mkArr_in_hom:\n    assumes \"A \\<subseteq> Univ\" and \"|A| <o \\<AA>\" and \"B \\<subseteq> Univ\" and \"|B| <o \\<AA>\" and \"F \\<in> A \\<rightarrow> B\"\n    shows \"\\<guillemotleft>mkArr A B F : mkIde A \\<rightarrow> mkIde B\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>mkArr A B\n                     F : mkIde A \\<rightarrow> mkIde B\\<guillemotright>", "using assms mkArr_def fun_complete [of \"mkIde A\" \"mkIde B\" F] ide_mkIde set_mkIde\n            theI' [of \"\\<lambda>f. f \\<in> hom (mkIde A) (mkIde B) \\<and> Fun f = restrict F A\"]"], ["proof (prove)\nusing this:\n  A \\<subseteq> Univ\n  |A| <o \\<AA>\n  B \\<subseteq> Univ\n  |B| <o \\<AA>\n  F \\<in> A \\<rightarrow> B\n  mkArr ?A ?B ?F =\n  (if ?A \\<subseteq> Univ \\<and>\n      |?A| <o \\<AA> \\<and>\n      ?B \\<subseteq> Univ \\<and>\n      |?B| <o \\<AA> \\<and> ?F \\<in> ?A \\<rightarrow> ?B\n   then THE f.\n           f \\<in> hom (mkIde ?A) (mkIde ?B) \\<and> Fun f = restrict ?F ?A\n   else null)\n  \\<lbrakk>ide (mkIde A); ide (mkIde B);\n   F \\<in> local.set (mkIde A) \\<rightarrow> local.set (mkIde B)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!f.\n                       \\<guillemotleft>f : mkIde\n      A \\<rightarrow> mkIde B\\<guillemotright> \\<and>\n                       Fun f = restrict F (local.set (mkIde A))\n  \\<lbrakk>?A \\<subseteq> Univ; |?A| <o \\<AA>\\<rbrakk>\n  \\<Longrightarrow> ide (mkIde ?A)\n  \\<lbrakk>?A \\<subseteq> Univ; |?A| <o \\<AA>\\<rbrakk>\n  \\<Longrightarrow> local.set (mkIde ?A) = ?A\n  \\<exists>!x.\n     x \\<in> hom (mkIde A) (mkIde B) \\<and>\n     Fun x = restrict F A \\<Longrightarrow>\n  (THE x. x \\<in> hom (mkIde A) (mkIde B) \\<and> Fun x = restrict F A)\n  \\<in> hom (mkIde A) (mkIde B) \\<and>\n  Fun (THE x. x \\<in> hom (mkIde A) (mkIde B) \\<and> Fun x = restrict F A) =\n  restrict F A\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>mkArr A B\n                     F : mkIde A \\<rightarrow> mkIde B\\<guillemotright>", "by simp"], ["", "text\\<open>\n      The ``only if'' direction of the next lemma can be achieved only if there exists a\n      non-arrow element of type @{typ 's}, which can be used as the value of @{term \"mkArr A B F\"}\n      in cases where @{term \"F \\<notin> A \\<rightarrow> B\"}.  Nevertheless, it is essential to have this,\n      because without the ``only if'' direction, we can't derive any useful\n      consequences from an assumption of the form @{term \"arr (mkArr A B F)\"};\n      instead we have to obtain @{term \"F \\<in> A \\<rightarrow> B\"} some other way.\n      This is is usually highly inconvenient and it makes the theory very weak and almost\n      unusable in practice.  The observation that having a non-arrow value of type @{typ 's}\n      solves this problem is ultimately what led me to incorporate @{term null} first into the\n      definition of the \\<open>set_category\\<close> locale and then, ultimately, into the definition\n      of the \\<open>category\\<close> locale.  I believe this idea is critical to the usability of the\n      entire development.\n\\<close>"], ["", "(* TODO: This gets used as an introduction rule, but the conjunction on the right-hand side\n       is not very convenient. *)"], ["", "lemma arr_mkArr:\n    shows \"arr (mkArr A B F) \\<longleftrightarrow>\n           A \\<subseteq> Univ \\<and> |A| <o \\<AA> \\<and> B \\<subseteq> Univ \\<and> |B| <o \\<AA> \\<and> F \\<in> A \\<rightarrow> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (mkArr A B F) =\n    (A \\<subseteq> Univ \\<and>\n     |A| <o \\<AA> \\<and>\n     B \\<subseteq> Univ \\<and>\n     |B| <o \\<AA> \\<and> F \\<in> A \\<rightarrow> B)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. arr (mkArr A B F) \\<Longrightarrow>\n    A \\<subseteq> Univ \\<and>\n    |A| <o \\<AA> \\<and>\n    B \\<subseteq> Univ \\<and> |B| <o \\<AA> \\<and> F \\<in> A \\<rightarrow> B\n 2. A \\<subseteq> Univ \\<and>\n    |A| <o \\<AA> \\<and>\n    B \\<subseteq> Univ \\<and>\n    |B| <o \\<AA> \\<and> F \\<in> A \\<rightarrow> B \\<Longrightarrow>\n    arr (mkArr A B F)", "show \"arr (mkArr A B F) \\<Longrightarrow>\n              A \\<subseteq> Univ \\<and> |A| <o \\<AA> \\<and> B \\<subseteq> Univ \\<and> |B| <o \\<AA> \\<and> F \\<in> A \\<rightarrow> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (mkArr A B F) \\<Longrightarrow>\n    A \\<subseteq> Univ \\<and>\n    |A| <o \\<AA> \\<and>\n    B \\<subseteq> Univ \\<and> |B| <o \\<AA> \\<and> F \\<in> A \\<rightarrow> B", "using mkArr_def domains_null codomains_null has_domain_iff_arr has_codomain_iff_arr\n              not_arr_null"], ["proof (prove)\nusing this:\n  mkArr ?A ?B ?F =\n  (if ?A \\<subseteq> Univ \\<and>\n      |?A| <o \\<AA> \\<and>\n      ?B \\<subseteq> Univ \\<and>\n      |?B| <o \\<AA> \\<and> ?F \\<in> ?A \\<rightarrow> ?B\n   then THE f.\n           f \\<in> hom (mkIde ?A) (mkIde ?B) \\<and> Fun f = restrict ?F ?A\n   else null)\n  domains null = {}\n  codomains null = {}\n  (domains ?f \\<noteq> {}) = arr ?f\n  (codomains ?f \\<noteq> {}) = arr ?f\n  \\<not> arr null\n\ngoal (1 subgoal):\n 1. arr (mkArr A B F) \\<Longrightarrow>\n    A \\<subseteq> Univ \\<and>\n    |A| <o \\<AA> \\<and>\n    B \\<subseteq> Univ \\<and> |B| <o \\<AA> \\<and> F \\<in> A \\<rightarrow> B", "by (intro conjI) metis+"], ["proof (state)\nthis:\n  arr (mkArr A B F) \\<Longrightarrow>\n  A \\<subseteq> Univ \\<and>\n  |A| <o \\<AA> \\<and>\n  B \\<subseteq> Univ \\<and> |B| <o \\<AA> \\<and> F \\<in> A \\<rightarrow> B\n\ngoal (1 subgoal):\n 1. A \\<subseteq> Univ \\<and>\n    |A| <o \\<AA> \\<and>\n    B \\<subseteq> Univ \\<and>\n    |B| <o \\<AA> \\<and> F \\<in> A \\<rightarrow> B \\<Longrightarrow>\n    arr (mkArr A B F)", "show \"A \\<subseteq> Univ \\<and> |A| <o \\<AA> \\<and> B \\<subseteq> Univ \\<and> |B| <o \\<AA> \\<and> F \\<in> A \\<rightarrow> B\n               \\<Longrightarrow> arr (mkArr A B F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> Univ \\<and>\n    |A| <o \\<AA> \\<and>\n    B \\<subseteq> Univ \\<and>\n    |B| <o \\<AA> \\<and> F \\<in> A \\<rightarrow> B \\<Longrightarrow>\n    arr (mkArr A B F)", "using mkArr_in_hom"], ["proof (prove)\nusing this:\n  \\<lbrakk>?A \\<subseteq> Univ; |?A| <o \\<AA>; ?B \\<subseteq> Univ;\n   |?B| <o \\<AA>; ?F \\<in> ?A \\<rightarrow> ?B\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>mkArr ?A ?B\n                                     ?F : mkIde\n     ?A \\<rightarrow> mkIde ?B\\<guillemotright>\n\ngoal (1 subgoal):\n 1. A \\<subseteq> Univ \\<and>\n    |A| <o \\<AA> \\<and>\n    B \\<subseteq> Univ \\<and>\n    |B| <o \\<AA> \\<and> F \\<in> A \\<rightarrow> B \\<Longrightarrow>\n    arr (mkArr A B F)", "by auto"], ["proof (state)\nthis:\n  A \\<subseteq> Univ \\<and>\n  |A| <o \\<AA> \\<and>\n  B \\<subseteq> Univ \\<and>\n  |B| <o \\<AA> \\<and> F \\<in> A \\<rightarrow> B \\<Longrightarrow>\n  arr (mkArr A B F)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Fun_mkArr':\n    assumes \"arr (mkArr A B F)\"\n    shows \"\\<guillemotleft>mkArr A B F : mkIde A \\<rightarrow> mkIde B\\<guillemotright>\"\n    and \"Fun (mkArr A B F) = restrict F A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>mkArr A B\n                     F : mkIde A \\<rightarrow> mkIde B\\<guillemotright> &&&\n    Fun (mkArr A B F) = restrict F A", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<guillemotleft>mkArr A B\n                     F : mkIde A \\<rightarrow> mkIde B\\<guillemotright>\n 2. Fun (mkArr A B F) = restrict F A", "have 1: \"A \\<subseteq> Univ \\<and> |A| <o \\<AA> \\<and> B \\<subseteq> Univ \\<and> |B| <o \\<AA> \\<and> F \\<in> A \\<rightarrow> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. A \\<subseteq> Univ \\<and>\n    |A| <o \\<AA> \\<and>\n    B \\<subseteq> Univ \\<and> |B| <o \\<AA> \\<and> F \\<in> A \\<rightarrow> B", "using assms arr_mkArr"], ["proof (prove)\nusing this:\n  arr (mkArr A B F)\n  arr (mkArr ?A ?B ?F) =\n  (?A \\<subseteq> Univ \\<and>\n   |?A| <o \\<AA> \\<and>\n   ?B \\<subseteq> Univ \\<and>\n   |?B| <o \\<AA> \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n\ngoal (1 subgoal):\n 1. A \\<subseteq> Univ \\<and>\n    |A| <o \\<AA> \\<and>\n    B \\<subseteq> Univ \\<and> |B| <o \\<AA> \\<and> F \\<in> A \\<rightarrow> B", "by simp"], ["proof (state)\nthis:\n  A \\<subseteq> Univ \\<and>\n  |A| <o \\<AA> \\<and>\n  B \\<subseteq> Univ \\<and> |B| <o \\<AA> \\<and> F \\<in> A \\<rightarrow> B\n\ngoal (2 subgoals):\n 1. \\<guillemotleft>mkArr A B\n                     F : mkIde A \\<rightarrow> mkIde B\\<guillemotright>\n 2. Fun (mkArr A B F) = restrict F A", "have 2: \"mkArr A B F \\<in> hom (mkIde A) (mkIde B) \\<and>\n                     Fun (mkArr A B F) = restrict F (set (mkIde A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mkArr A B F \\<in> hom (mkIde A) (mkIde B) \\<and>\n    Fun (mkArr A B F) = restrict F (local.set (mkIde A))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mkArr A B F \\<in> hom (mkIde A) (mkIde B) \\<and>\n    Fun (mkArr A B F) = restrict F (local.set (mkIde A))", "have \"\\<exists>!f. f \\<in> hom (mkIde A) (mkIde B) \\<and> Fun f = restrict F (set (mkIde A))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!f.\n       f \\<in> hom (mkIde A) (mkIde B) \\<and>\n       Fun f = restrict F (local.set (mkIde A))", "using 1 fun_complete [of \"mkIde A\" \"mkIde B\" F] ide_mkIde set_mkIde"], ["proof (prove)\nusing this:\n  A \\<subseteq> Univ \\<and>\n  |A| <o \\<AA> \\<and>\n  B \\<subseteq> Univ \\<and> |B| <o \\<AA> \\<and> F \\<in> A \\<rightarrow> B\n  \\<lbrakk>ide (mkIde A); ide (mkIde B);\n   F \\<in> local.set (mkIde A) \\<rightarrow> local.set (mkIde B)\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!f.\n                       \\<guillemotleft>f : mkIde\n      A \\<rightarrow> mkIde B\\<guillemotright> \\<and>\n                       Fun f = restrict F (local.set (mkIde A))\n  \\<lbrakk>?A \\<subseteq> Univ; |?A| <o \\<AA>\\<rbrakk>\n  \\<Longrightarrow> ide (mkIde ?A)\n  \\<lbrakk>?A \\<subseteq> Univ; |?A| <o \\<AA>\\<rbrakk>\n  \\<Longrightarrow> local.set (mkIde ?A) = ?A\n\ngoal (1 subgoal):\n 1. \\<exists>!f.\n       f \\<in> hom (mkIde A) (mkIde B) \\<and>\n       Fun f = restrict F (local.set (mkIde A))", "by simp"], ["proof (state)\nthis:\n  \\<exists>!f.\n     f \\<in> hom (mkIde A) (mkIde B) \\<and>\n     Fun f = restrict F (local.set (mkIde A))\n\ngoal (1 subgoal):\n 1. mkArr A B F \\<in> hom (mkIde A) (mkIde B) \\<and>\n    Fun (mkArr A B F) = restrict F (local.set (mkIde A))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>!f.\n     f \\<in> hom (mkIde A) (mkIde B) \\<and>\n     Fun f = restrict F (local.set (mkIde A))\n\ngoal (1 subgoal):\n 1. mkArr A B F \\<in> hom (mkIde A) (mkIde B) \\<and>\n    Fun (mkArr A B F) = restrict F (local.set (mkIde A))", "using 1 mkArr_def theI' set_mkIde"], ["proof (prove)\nusing this:\n  \\<exists>!f.\n     f \\<in> hom (mkIde A) (mkIde B) \\<and>\n     Fun f = restrict F (local.set (mkIde A))\n  A \\<subseteq> Univ \\<and>\n  |A| <o \\<AA> \\<and>\n  B \\<subseteq> Univ \\<and> |B| <o \\<AA> \\<and> F \\<in> A \\<rightarrow> B\n  mkArr ?A ?B ?F =\n  (if ?A \\<subseteq> Univ \\<and>\n      |?A| <o \\<AA> \\<and>\n      ?B \\<subseteq> Univ \\<and>\n      |?B| <o \\<AA> \\<and> ?F \\<in> ?A \\<rightarrow> ?B\n   then THE f.\n           f \\<in> hom (mkIde ?A) (mkIde ?B) \\<and> Fun f = restrict ?F ?A\n   else null)\n  \\<exists>!x. ?P x \\<Longrightarrow> ?P (THE x. ?P x)\n  \\<lbrakk>?A \\<subseteq> Univ; |?A| <o \\<AA>\\<rbrakk>\n  \\<Longrightarrow> local.set (mkIde ?A) = ?A\n\ngoal (1 subgoal):\n 1. mkArr A B F \\<in> hom (mkIde A) (mkIde B) \\<and>\n    Fun (mkArr A B F) = restrict F (local.set (mkIde A))", "by simp"], ["proof (state)\nthis:\n  mkArr A B F \\<in> hom (mkIde A) (mkIde B) \\<and>\n  Fun (mkArr A B F) = restrict F (local.set (mkIde A))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mkArr A B F \\<in> hom (mkIde A) (mkIde B) \\<and>\n  Fun (mkArr A B F) = restrict F (local.set (mkIde A))\n\ngoal (2 subgoals):\n 1. \\<guillemotleft>mkArr A B\n                     F : mkIde A \\<rightarrow> mkIde B\\<guillemotright>\n 2. Fun (mkArr A B F) = restrict F A", "show \"\\<guillemotleft>mkArr A B F : mkIde A \\<rightarrow> mkIde B\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>mkArr A B\n                     F : mkIde A \\<rightarrow> mkIde B\\<guillemotright>", "using 1 2"], ["proof (prove)\nusing this:\n  A \\<subseteq> Univ \\<and>\n  |A| <o \\<AA> \\<and>\n  B \\<subseteq> Univ \\<and> |B| <o \\<AA> \\<and> F \\<in> A \\<rightarrow> B\n  mkArr A B F \\<in> hom (mkIde A) (mkIde B) \\<and>\n  Fun (mkArr A B F) = restrict F (local.set (mkIde A))\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>mkArr A B\n                     F : mkIde A \\<rightarrow> mkIde B\\<guillemotright>", "by auto"], ["proof (state)\nthis:\n  \\<guillemotleft>mkArr A B\n                   F : mkIde A \\<rightarrow> mkIde B\\<guillemotright>\n\ngoal (1 subgoal):\n 1. Fun (mkArr A B F) = restrict F A", "show \"Fun (mkArr A B F) = restrict F A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (mkArr A B F) = restrict F A", "using 1 2 set_mkIde"], ["proof (prove)\nusing this:\n  A \\<subseteq> Univ \\<and>\n  |A| <o \\<AA> \\<and>\n  B \\<subseteq> Univ \\<and> |B| <o \\<AA> \\<and> F \\<in> A \\<rightarrow> B\n  mkArr A B F \\<in> hom (mkIde A) (mkIde B) \\<and>\n  Fun (mkArr A B F) = restrict F (local.set (mkIde A))\n  \\<lbrakk>?A \\<subseteq> Univ; |?A| <o \\<AA>\\<rbrakk>\n  \\<Longrightarrow> local.set (mkIde ?A) = ?A\n\ngoal (1 subgoal):\n 1. Fun (mkArr A B F) = restrict F A", "by auto"], ["proof (state)\nthis:\n  Fun (mkArr A B F) = restrict F A\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma mkArr_Fun:\n    assumes \"arr f\"\n    shows \"mkArr (set (dom f)) (set (cod f)) (Fun f) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mkArr (local.set (local.dom f)) (local.set (cod f)) (Fun f) = f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mkArr (local.set (local.dom f)) (local.set (cod f)) (Fun f) = f", "have 1: \"set (dom f) \\<subseteq> Univ \\<and> |set (dom f)| <o \\<AA> \\<and>\n               set (cod f) \\<subseteq> Univ \\<and> |set (cod f)| <o \\<AA> \\<and>\n               ide (dom f) \\<and> ide (cod f) \\<and>\n               Fun f \\<in> extensional (set (dom f)) \\<inter> (set (dom f) \\<rightarrow> set (cod f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.set (local.dom f) \\<subseteq> Univ \\<and>\n    |local.set (local.dom f)| <o \\<AA> \\<and>\n    local.set (cod f) \\<subseteq> Univ \\<and>\n    |local.set (cod f)| <o \\<AA> \\<and>\n    ide (local.dom f) \\<and>\n    ide (cod f) \\<and>\n    Fun f\n    \\<in> extensional (local.set (local.dom f)) \\<inter>\n          (local.set (local.dom f) \\<rightarrow> local.set (cod f))", "using assms Fun_mapsto set_def set_card set_subset_Univ"], ["proof (prove)\nusing this:\n  arr f\n  arr ?f \\<Longrightarrow>\n  Fun ?f\n  \\<in> extensional (local.set (local.dom ?f)) \\<inter>\n        (local.set (local.dom ?f) \\<rightarrow> local.set (cod ?f))\n  local.set ?a = img ` hom unity ?a\n  ide ?a \\<Longrightarrow> |local.set ?a| <o \\<AA>\n  ide ?a \\<Longrightarrow> local.set ?a \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. local.set (local.dom f) \\<subseteq> Univ \\<and>\n    |local.set (local.dom f)| <o \\<AA> \\<and>\n    local.set (cod f) \\<subseteq> Univ \\<and>\n    |local.set (cod f)| <o \\<AA> \\<and>\n    ide (local.dom f) \\<and>\n    ide (cod f) \\<and>\n    Fun f\n    \\<in> extensional (local.set (local.dom f)) \\<inter>\n          (local.set (local.dom f) \\<rightarrow> local.set (cod f))", "by auto"], ["proof (state)\nthis:\n  local.set (local.dom f) \\<subseteq> Univ \\<and>\n  |local.set (local.dom f)| <o \\<AA> \\<and>\n  local.set (cod f) \\<subseteq> Univ \\<and>\n  |local.set (cod f)| <o \\<AA> \\<and>\n  ide (local.dom f) \\<and>\n  ide (cod f) \\<and>\n  Fun f\n  \\<in> extensional (local.set (local.dom f)) \\<inter>\n        (local.set (local.dom f) \\<rightarrow> local.set (cod f))\n\ngoal (1 subgoal):\n 1. mkArr (local.set (local.dom f)) (local.set (cod f)) (Fun f) = f", "hence \"\\<exists>!f'. f' \\<in> hom (dom f) (cod f) \\<and> Fun f' = restrict (Fun f) (set (dom f))\""], ["proof (prove)\nusing this:\n  local.set (local.dom f) \\<subseteq> Univ \\<and>\n  |local.set (local.dom f)| <o \\<AA> \\<and>\n  local.set (cod f) \\<subseteq> Univ \\<and>\n  |local.set (cod f)| <o \\<AA> \\<and>\n  ide (local.dom f) \\<and>\n  ide (cod f) \\<and>\n  Fun f\n  \\<in> extensional (local.set (local.dom f)) \\<inter>\n        (local.set (local.dom f) \\<rightarrow> local.set (cod f))\n\ngoal (1 subgoal):\n 1. \\<exists>!f'.\n       f' \\<in> hom (local.dom f) (cod f) \\<and>\n       Fun f' = restrict (Fun f) (local.set (local.dom f))", "using fun_complete"], ["proof (prove)\nusing this:\n  local.set (local.dom f) \\<subseteq> Univ \\<and>\n  |local.set (local.dom f)| <o \\<AA> \\<and>\n  local.set (cod f) \\<subseteq> Univ \\<and>\n  |local.set (cod f)| <o \\<AA> \\<and>\n  ide (local.dom f) \\<and>\n  ide (cod f) \\<and>\n  Fun f\n  \\<in> extensional (local.set (local.dom f)) \\<inter>\n        (local.set (local.dom f) \\<rightarrow> local.set (cod f))\n  \\<lbrakk>ide ?a; ide ?b;\n   ?F \\<in> local.set ?a \\<rightarrow> local.set ?b\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!f.\n                       \\<guillemotleft>f : ?a \\<rightarrow> ?b\\<guillemotright> \\<and>\n                       Fun f = restrict ?F (local.set ?a)\n\ngoal (1 subgoal):\n 1. \\<exists>!f'.\n       f' \\<in> hom (local.dom f) (cod f) \\<and>\n       Fun f' = restrict (Fun f) (local.set (local.dom f))", "by force"], ["proof (state)\nthis:\n  \\<exists>!f'.\n     f' \\<in> hom (local.dom f) (cod f) \\<and>\n     Fun f' = restrict (Fun f) (local.set (local.dom f))\n\ngoal (1 subgoal):\n 1. mkArr (local.set (local.dom f)) (local.set (cod f)) (Fun f) = f", "moreover"], ["proof (state)\nthis:\n  \\<exists>!f'.\n     f' \\<in> hom (local.dom f) (cod f) \\<and>\n     Fun f' = restrict (Fun f) (local.set (local.dom f))\n\ngoal (1 subgoal):\n 1. mkArr (local.set (local.dom f)) (local.set (cod f)) (Fun f) = f", "have \"f \\<in> hom (dom f) (cod f) \\<and> Fun f = restrict (Fun f) (set (dom f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<in> hom (local.dom f) (cod f) \\<and>\n    Fun f = restrict (Fun f) (local.set (local.dom f))", "using assms 1 extensional_restrict"], ["proof (prove)\nusing this:\n  arr f\n  local.set (local.dom f) \\<subseteq> Univ \\<and>\n  |local.set (local.dom f)| <o \\<AA> \\<and>\n  local.set (cod f) \\<subseteq> Univ \\<and>\n  |local.set (cod f)| <o \\<AA> \\<and>\n  ide (local.dom f) \\<and>\n  ide (cod f) \\<and>\n  Fun f\n  \\<in> extensional (local.set (local.dom f)) \\<inter>\n        (local.set (local.dom f) \\<rightarrow> local.set (cod f))\n  ?f \\<in> extensional ?A \\<Longrightarrow> restrict ?f ?A = ?f\n\ngoal (1 subgoal):\n 1. f \\<in> hom (local.dom f) (cod f) \\<and>\n    Fun f = restrict (Fun f) (local.set (local.dom f))", "by force"], ["proof (state)\nthis:\n  f \\<in> hom (local.dom f) (cod f) \\<and>\n  Fun f = restrict (Fun f) (local.set (local.dom f))\n\ngoal (1 subgoal):\n 1. mkArr (local.set (local.dom f)) (local.set (cod f)) (Fun f) = f", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>!f'.\n     f' \\<in> hom (local.dom f) (cod f) \\<and>\n     Fun f' = restrict (Fun f) (local.set (local.dom f))\n  f \\<in> hom (local.dom f) (cod f) \\<and>\n  Fun f = restrict (Fun f) (local.set (local.dom f))", "have \"f = (THE f'. f' \\<in> hom (dom f) (cod f) \\<and>\n                                    Fun f' = restrict (Fun f) (set (dom f)))\""], ["proof (prove)\nusing this:\n  \\<exists>!f'.\n     f' \\<in> hom (local.dom f) (cod f) \\<and>\n     Fun f' = restrict (Fun f) (local.set (local.dom f))\n  f \\<in> hom (local.dom f) (cod f) \\<and>\n  Fun f = restrict (Fun f) (local.set (local.dom f))\n\ngoal (1 subgoal):\n 1. f =\n    (THE f'.\n        f' \\<in> hom (local.dom f) (cod f) \\<and>\n        Fun f' = restrict (Fun f) (local.set (local.dom f)))", "using theI' [of \"\\<lambda>f'. f' \\<in> hom (dom f) (cod f) \\<and> Fun f' = restrict (Fun f) (set (dom f))\"]"], ["proof (prove)\nusing this:\n  \\<exists>!f'.\n     f' \\<in> hom (local.dom f) (cod f) \\<and>\n     Fun f' = restrict (Fun f) (local.set (local.dom f))\n  f \\<in> hom (local.dom f) (cod f) \\<and>\n  Fun f = restrict (Fun f) (local.set (local.dom f))\n  \\<exists>!x.\n     x \\<in> hom (local.dom f) (cod f) \\<and>\n     Fun x = restrict (Fun f) (local.set (local.dom f)) \\<Longrightarrow>\n  (THE x.\n      x \\<in> hom (local.dom f) (cod f) \\<and>\n      Fun x = restrict (Fun f) (local.set (local.dom f)))\n  \\<in> hom (local.dom f) (cod f) \\<and>\n  Fun (THE x.\n          x \\<in> hom (local.dom f) (cod f) \\<and>\n          Fun x = restrict (Fun f) (local.set (local.dom f))) =\n  restrict (Fun f) (local.set (local.dom f))\n\ngoal (1 subgoal):\n 1. f =\n    (THE f'.\n        f' \\<in> hom (local.dom f) (cod f) \\<and>\n        Fun f' = restrict (Fun f) (local.set (local.dom f)))", "by blast"], ["proof (state)\nthis:\n  f =\n  (THE f'.\n      f' \\<in> hom (local.dom f) (cod f) \\<and>\n      Fun f' = restrict (Fun f) (local.set (local.dom f)))\n\ngoal (1 subgoal):\n 1. mkArr (local.set (local.dom f)) (local.set (cod f)) (Fun f) = f", "also"], ["proof (state)\nthis:\n  f =\n  (THE f'.\n      f' \\<in> hom (local.dom f) (cod f) \\<and>\n      Fun f' = restrict (Fun f) (local.set (local.dom f)))\n\ngoal (1 subgoal):\n 1. mkArr (local.set (local.dom f)) (local.set (cod f)) (Fun f) = f", "have \"... = mkArr (set (dom f)) (set (cod f)) (Fun f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (THE f'.\n        f' \\<in> hom (local.dom f) (cod f) \\<and>\n        Fun f' = restrict (Fun f) (local.set (local.dom f))) =\n    mkArr (local.set (local.dom f)) (local.set (cod f)) (Fun f)", "using assms 1 mkArr_def mkIde_set"], ["proof (prove)\nusing this:\n  arr f\n  local.set (local.dom f) \\<subseteq> Univ \\<and>\n  |local.set (local.dom f)| <o \\<AA> \\<and>\n  local.set (cod f) \\<subseteq> Univ \\<and>\n  |local.set (cod f)| <o \\<AA> \\<and>\n  ide (local.dom f) \\<and>\n  ide (cod f) \\<and>\n  Fun f\n  \\<in> extensional (local.set (local.dom f)) \\<inter>\n        (local.set (local.dom f) \\<rightarrow> local.set (cod f))\n  mkArr ?A ?B ?F =\n  (if ?A \\<subseteq> Univ \\<and>\n      |?A| <o \\<AA> \\<and>\n      ?B \\<subseteq> Univ \\<and>\n      |?B| <o \\<AA> \\<and> ?F \\<in> ?A \\<rightarrow> ?B\n   then THE f.\n           f \\<in> hom (mkIde ?A) (mkIde ?B) \\<and> Fun f = restrict ?F ?A\n   else null)\n  ide ?a \\<Longrightarrow> mkIde (local.set ?a) = ?a\n\ngoal (1 subgoal):\n 1. (THE f'.\n        f' \\<in> hom (local.dom f) (cod f) \\<and>\n        Fun f' = restrict (Fun f) (local.set (local.dom f))) =\n    mkArr (local.set (local.dom f)) (local.set (cod f)) (Fun f)", "by simp"], ["proof (state)\nthis:\n  (THE f'.\n      f' \\<in> hom (local.dom f) (cod f) \\<and>\n      Fun f' = restrict (Fun f) (local.set (local.dom f))) =\n  mkArr (local.set (local.dom f)) (local.set (cod f)) (Fun f)\n\ngoal (1 subgoal):\n 1. mkArr (local.set (local.dom f)) (local.set (cod f)) (Fun f) = f", "finally"], ["proof (chain)\npicking this:\n  f = mkArr (local.set (local.dom f)) (local.set (cod f)) (Fun f)", "show ?thesis"], ["proof (prove)\nusing this:\n  f = mkArr (local.set (local.dom f)) (local.set (cod f)) (Fun f)\n\ngoal (1 subgoal):\n 1. mkArr (local.set (local.dom f)) (local.set (cod f)) (Fun f) = f", "by auto"], ["proof (state)\nthis:\n  mkArr (local.set (local.dom f)) (local.set (cod f)) (Fun f) = f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma dom_mkArr [simp]:\n    assumes \"arr (mkArr A B F)\"\n    shows \"dom (mkArr A B F) = mkIde A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dom (mkArr A B F) = mkIde A", "using assms Fun_mkArr'"], ["proof (prove)\nusing this:\n  arr (mkArr A B F)\n  arr (mkArr ?A ?B ?F) \\<Longrightarrow>\n  \\<guillemotleft>mkArr ?A ?B\n                   ?F : mkIde ?A \\<rightarrow> mkIde ?B\\<guillemotright>\n  arr (mkArr ?A ?B ?F) \\<Longrightarrow>\n  Fun (mkArr ?A ?B ?F) = restrict ?F ?A\n\ngoal (1 subgoal):\n 1. local.dom (mkArr A B F) = mkIde A", "by auto"], ["", "lemma cod_mkArr [simp]:\n    assumes \"arr (mkArr A B F)\"\n    shows \"cod (mkArr A B F) = mkIde B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cod (mkArr A B F) = mkIde B", "using assms Fun_mkArr'"], ["proof (prove)\nusing this:\n  arr (mkArr A B F)\n  arr (mkArr ?A ?B ?F) \\<Longrightarrow>\n  \\<guillemotleft>mkArr ?A ?B\n                   ?F : mkIde ?A \\<rightarrow> mkIde ?B\\<guillemotright>\n  arr (mkArr ?A ?B ?F) \\<Longrightarrow>\n  Fun (mkArr ?A ?B ?F) = restrict ?F ?A\n\ngoal (1 subgoal):\n 1. cod (mkArr A B F) = mkIde B", "by auto"], ["", "lemma Fun_mkArr [simp]:\n    assumes \"arr (mkArr A B F)\"\n    shows \"Fun (mkArr A B F) = restrict F A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (mkArr A B F) = restrict F A", "using assms Fun_mkArr'"], ["proof (prove)\nusing this:\n  arr (mkArr A B F)\n  arr (mkArr ?A ?B ?F) \\<Longrightarrow>\n  \\<guillemotleft>mkArr ?A ?B\n                   ?F : mkIde ?A \\<rightarrow> mkIde ?B\\<guillemotright>\n  arr (mkArr ?A ?B ?F) \\<Longrightarrow>\n  Fun (mkArr ?A ?B ?F) = restrict ?F ?A\n\ngoal (1 subgoal):\n 1. Fun (mkArr A B F) = restrict F A", "by auto"], ["", "text\\<open>\n      The following provides the basic technique for showing that arrows\n      constructed using @{term mkArr} are equal.\n\\<close>"], ["", "lemma mkArr_eqI [intro]:\n    assumes \"arr (mkArr A B F)\"\n    and \"A = A'\" and \"B = B'\" and \"\\<And>x. x \\<in> A \\<Longrightarrow> F x = F' x\"\n    shows \"mkArr A B F = mkArr A' B' F'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mkArr A B F = mkArr A' B' F'", "using assms arr_mkArr Fun_mkArr"], ["proof (prove)\nusing this:\n  arr (mkArr A B F)\n  A = A'\n  B = B'\n  ?x \\<in> A \\<Longrightarrow> F ?x = F' ?x\n  arr (mkArr ?A ?B ?F) =\n  (?A \\<subseteq> Univ \\<and>\n   |?A| <o \\<AA> \\<and>\n   ?B \\<subseteq> Univ \\<and>\n   |?B| <o \\<AA> \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n  arr (mkArr ?A ?B ?F) \\<Longrightarrow>\n  Fun (mkArr ?A ?B ?F) = restrict ?F ?A\n\ngoal (1 subgoal):\n 1. mkArr A B F = mkArr A' B' F'", "by (intro arr_eqI, auto simp add: Pi_iff)"], ["", "text\\<open>\n      This version avoids trivial proof obligations when the domain and codomain\n      sets are identical from the context.\n\\<close>"], ["", "lemma mkArr_eqI' [intro]:\n    assumes \"arr (mkArr A B F)\" and \"\\<And>x. x \\<in> A \\<Longrightarrow> F x = F' x\"\n    shows \"mkArr A B F = mkArr A B F'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mkArr A B F = mkArr A B F'", "using assms mkArr_eqI arr_mkArr"], ["proof (prove)\nusing this:\n  arr (mkArr A B F)\n  ?x \\<in> A \\<Longrightarrow> F ?x = F' ?x\n  \\<lbrakk>arr (mkArr ?A ?B ?F); ?A = ?A'; ?B = ?B';\n   \\<And>x. x \\<in> ?A \\<Longrightarrow> ?F x = ?F' x\\<rbrakk>\n  \\<Longrightarrow> mkArr ?A ?B ?F = mkArr ?A' ?B' ?F'\n  arr (mkArr ?A ?B ?F) =\n  (?A \\<subseteq> Univ \\<and>\n   |?A| <o \\<AA> \\<and>\n   ?B \\<subseteq> Univ \\<and>\n   |?B| <o \\<AA> \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n\ngoal (1 subgoal):\n 1. mkArr A B F = mkArr A B F'", "by simp"], ["", "lemma mkArr_restrict_eq:\n    assumes \"arr (mkArr A B F)\"\n    shows \"mkArr A B (restrict F A) = mkArr A B F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mkArr A B (restrict F A) = mkArr A B F", "using assms arr_mkArr"], ["proof (prove)\nusing this:\n  arr (mkArr A B F)\n  arr (mkArr ?A ?B ?F) =\n  (?A \\<subseteq> Univ \\<and>\n   |?A| <o \\<AA> \\<and>\n   ?B \\<subseteq> Univ \\<and>\n   |?B| <o \\<AA> \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n\ngoal (1 subgoal):\n 1. mkArr A B (restrict F A) = mkArr A B F", "by (intro mkArr_eqI', auto)"], ["", "lemma mkArr_restrict_eq':\n    assumes \"arr (mkArr A B (restrict F A))\"\n    shows \"mkArr A B (restrict F A) = mkArr A B F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mkArr A B (restrict F A) = mkArr A B F", "using assms"], ["proof (prove)\nusing this:\n  arr (mkArr A B (restrict F A))\n\ngoal (1 subgoal):\n 1. mkArr A B (restrict F A) = mkArr A B F", "by (intro mkArr_eqI', auto)"], ["", "lemma mkIde_as_mkArr:\n    assumes \"A \\<subseteq> Univ\" and \"|A| <o \\<AA>\"\n    shows \"mkArr A A (\\<lambda>x. x) = mkIde A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mkArr A A (\\<lambda>x. x) = mkIde A", "using assms arr_mkIde arr_mkArr dom_mkIde cod_mkIde Fun_mkIde"], ["proof (prove)\nusing this:\n  A \\<subseteq> Univ\n  |A| <o \\<AA>\n  arr (mkIde ?A) = (?A \\<subseteq> Univ \\<and> |?A| <o \\<AA>)\n  arr (mkArr ?A ?B ?F) =\n  (?A \\<subseteq> Univ \\<and>\n   |?A| <o \\<AA> \\<and>\n   ?B \\<subseteq> Univ \\<and>\n   |?B| <o \\<AA> \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n  \\<lbrakk>?A \\<subseteq> Univ; |?A| <o \\<AA>\\<rbrakk>\n  \\<Longrightarrow> local.dom (mkIde ?A) = mkIde ?A\n  \\<lbrakk>?A \\<subseteq> Univ; |?A| <o \\<AA>\\<rbrakk>\n  \\<Longrightarrow> cod (mkIde ?A) = mkIde ?A\n  \\<lbrakk>?A \\<subseteq> Univ; |?A| <o \\<AA>\\<rbrakk>\n  \\<Longrightarrow> Fun (mkIde ?A) = (\\<lambda>x\\<in>?A. x)\n\ngoal (1 subgoal):\n 1. mkArr A A (\\<lambda>x. x) = mkIde A", "by (intro arr_eqI, auto)"], ["", "lemma comp_mkArr:\n    assumes \"arr (mkArr A B F)\" and \"arr (mkArr B C G)\"\n    shows \"mkArr B C G \\<cdot> mkArr A B F = mkArr A C (G \\<circ> F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mkArr B C G \\<cdot> mkArr A B F = mkArr A C (G \\<circ> F)", "proof (intro arr_eqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. par (mkArr B C G \\<cdot> mkArr A B F) (mkArr A C (G \\<circ> F))\n 2. Fun (mkArr B C G \\<cdot> mkArr A B F) = Fun (mkArr A C (G \\<circ> F))", "have 1: \"seq (mkArr B C G) (mkArr A B F)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq (mkArr B C G) (mkArr A B F)", "using assms"], ["proof (prove)\nusing this:\n  arr (mkArr A B F)\n  arr (mkArr B C G)\n\ngoal (1 subgoal):\n 1. seq (mkArr B C G) (mkArr A B F)", "by force"], ["proof (state)\nthis:\n  seq (mkArr B C G) (mkArr A B F)\n\ngoal (2 subgoals):\n 1. par (mkArr B C G \\<cdot> mkArr A B F) (mkArr A C (G \\<circ> F))\n 2. Fun (mkArr B C G \\<cdot> mkArr A B F) = Fun (mkArr A C (G \\<circ> F))", "have 2: \"G o F \\<in> A \\<rightarrow> C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. G \\<circ> F \\<in> A \\<rightarrow> C", "using assms arr_mkArr"], ["proof (prove)\nusing this:\n  arr (mkArr A B F)\n  arr (mkArr B C G)\n  arr (mkArr ?A ?B ?F) =\n  (?A \\<subseteq> Univ \\<and>\n   |?A| <o \\<AA> \\<and>\n   ?B \\<subseteq> Univ \\<and>\n   |?B| <o \\<AA> \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n\ngoal (1 subgoal):\n 1. G \\<circ> F \\<in> A \\<rightarrow> C", "by auto"], ["proof (state)\nthis:\n  G \\<circ> F \\<in> A \\<rightarrow> C\n\ngoal (2 subgoals):\n 1. par (mkArr B C G \\<cdot> mkArr A B F) (mkArr A C (G \\<circ> F))\n 2. Fun (mkArr B C G \\<cdot> mkArr A B F) = Fun (mkArr A C (G \\<circ> F))", "show \"par (mkArr B C G \\<cdot> mkArr A B F) (mkArr A C (G \\<circ> F))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. par (mkArr B C G \\<cdot> mkArr A B F) (mkArr A C (G \\<circ> F))", "using assms 1 2 arr_mkArr"], ["proof (prove)\nusing this:\n  arr (mkArr A B F)\n  arr (mkArr B C G)\n  seq (mkArr B C G) (mkArr A B F)\n  G \\<circ> F \\<in> A \\<rightarrow> C\n  arr (mkArr ?A ?B ?F) =\n  (?A \\<subseteq> Univ \\<and>\n   |?A| <o \\<AA> \\<and>\n   ?B \\<subseteq> Univ \\<and>\n   |?B| <o \\<AA> \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n\ngoal (1 subgoal):\n 1. par (mkArr B C G \\<cdot> mkArr A B F) (mkArr A C (G \\<circ> F))", "by (intro conjI) simp_all"], ["proof (state)\nthis:\n  par (mkArr B C G \\<cdot> mkArr A B F) (mkArr A C (G \\<circ> F))\n\ngoal (1 subgoal):\n 1. Fun (mkArr B C G \\<cdot> mkArr A B F) = Fun (mkArr A C (G \\<circ> F))", "show \"Fun (mkArr B C G \\<cdot> mkArr A B F) = Fun (mkArr A C (G \\<circ> F))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (mkArr B C G \\<cdot> mkArr A B F) = Fun (mkArr A C (G \\<circ> F))", "using 1 2 arr_mkArr set_mkIde"], ["proof (prove)\nusing this:\n  seq (mkArr B C G) (mkArr A B F)\n  G \\<circ> F \\<in> A \\<rightarrow> C\n  arr (mkArr ?A ?B ?F) =\n  (?A \\<subseteq> Univ \\<and>\n   |?A| <o \\<AA> \\<and>\n   ?B \\<subseteq> Univ \\<and>\n   |?B| <o \\<AA> \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n  \\<lbrakk>?A \\<subseteq> Univ; |?A| <o \\<AA>\\<rbrakk>\n  \\<Longrightarrow> local.set (mkIde ?A) = ?A\n\ngoal (1 subgoal):\n 1. Fun (mkArr B C G \\<cdot> mkArr A B F) = Fun (mkArr A C (G \\<circ> F))", "by fastforce"], ["proof (state)\nthis:\n  Fun (mkArr B C G \\<cdot> mkArr A B F) = Fun (mkArr A C (G \\<circ> F))\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n      The locale assumption @{prop stable_img} forces @{term \"t \\<in> set t\"} in case\n      @{term t} is a terminal object.  This is very convenient, as it results in the\n      characterization of terminal objects as identities @{term t} for which\n      @{term \"set t = {t}\"}.  However, it is not absolutely necessary to have this.\n      The following weaker characterization of terminal objects can be proved without\n      the @{prop stable_img} assumption.\n\\<close>"], ["", "lemma terminal_char1:\n    shows \"terminal t \\<longleftrightarrow> ide t \\<and> (\\<exists>!x. x \\<in> set t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminal t = (ide t \\<and> (\\<exists>!x. x \\<in> local.set t))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. terminal t = (ide t \\<and> (\\<exists>!x. x \\<in> local.set t))", "have \"terminal t \\<Longrightarrow> ide t \\<and> (\\<exists>!x. x \\<in> set t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminal t \\<Longrightarrow>\n    ide t \\<and> (\\<exists>!x. x \\<in> local.set t)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. terminal t \\<Longrightarrow>\n    ide t \\<and> (\\<exists>!x. x \\<in> local.set t)", "assume t: \"terminal t\""], ["proof (state)\nthis:\n  terminal t\n\ngoal (1 subgoal):\n 1. terminal t \\<Longrightarrow>\n    ide t \\<and> (\\<exists>!x. x \\<in> local.set t)", "have \"ide t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide t", "using t terminal_def"], ["proof (prove)\nusing this:\n  terminal t\n  terminal ?b \\<equiv>\n  ide ?b \\<and>\n  (\\<forall>a.\n      ide a \\<longrightarrow>\n      (\\<exists>!f.\n          \\<guillemotleft>f : a \\<rightarrow> ?b\\<guillemotright>))\n\ngoal (1 subgoal):\n 1. ide t", "by auto"], ["proof (state)\nthis:\n  ide t\n\ngoal (1 subgoal):\n 1. terminal t \\<Longrightarrow>\n    ide t \\<and> (\\<exists>!x. x \\<in> local.set t)", "moreover"], ["proof (state)\nthis:\n  ide t\n\ngoal (1 subgoal):\n 1. terminal t \\<Longrightarrow>\n    ide t \\<and> (\\<exists>!x. x \\<in> local.set t)", "have \"\\<exists>!x. x \\<in> set t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!x. x \\<in> local.set t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!x. x \\<in> local.set t", "have \"\\<exists>!x. x \\<in> hom unity t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!x. x \\<in> hom unity t", "using t terminal_unity terminal_def"], ["proof (prove)\nusing this:\n  terminal t\n  terminal unity\n  terminal ?b \\<equiv>\n  ide ?b \\<and>\n  (\\<forall>a.\n      ide a \\<longrightarrow>\n      (\\<exists>!f.\n          \\<guillemotleft>f : a \\<rightarrow> ?b\\<guillemotright>))\n\ngoal (1 subgoal):\n 1. \\<exists>!x. x \\<in> hom unity t", "by auto"], ["proof (state)\nthis:\n  \\<exists>!x. x \\<in> hom unity t\n\ngoal (1 subgoal):\n 1. \\<exists>!x. x \\<in> local.set t", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>!x. x \\<in> hom unity t\n\ngoal (1 subgoal):\n 1. \\<exists>!x. x \\<in> local.set t", "using set_def"], ["proof (prove)\nusing this:\n  \\<exists>!x. x \\<in> hom unity t\n  local.set ?a = img ` hom unity ?a\n\ngoal (1 subgoal):\n 1. \\<exists>!x. x \\<in> local.set t", "by auto"], ["proof (state)\nthis:\n  \\<exists>!x. x \\<in> local.set t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!x. x \\<in> local.set t\n\ngoal (1 subgoal):\n 1. terminal t \\<Longrightarrow>\n    ide t \\<and> (\\<exists>!x. x \\<in> local.set t)", "ultimately"], ["proof (chain)\npicking this:\n  ide t\n  \\<exists>!x. x \\<in> local.set t", "show \"ide t \\<and> (\\<exists>!x. x \\<in> set t)\""], ["proof (prove)\nusing this:\n  ide t\n  \\<exists>!x. x \\<in> local.set t\n\ngoal (1 subgoal):\n 1. ide t \\<and> (\\<exists>!x. x \\<in> local.set t)", "by auto"], ["proof (state)\nthis:\n  ide t \\<and> (\\<exists>!x. x \\<in> local.set t)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  terminal t \\<Longrightarrow>\n  ide t \\<and> (\\<exists>!x. x \\<in> local.set t)\n\ngoal (1 subgoal):\n 1. terminal t = (ide t \\<and> (\\<exists>!x. x \\<in> local.set t))", "moreover"], ["proof (state)\nthis:\n  terminal t \\<Longrightarrow>\n  ide t \\<and> (\\<exists>!x. x \\<in> local.set t)\n\ngoal (1 subgoal):\n 1. terminal t = (ide t \\<and> (\\<exists>!x. x \\<in> local.set t))", "have \"ide t \\<and> (\\<exists>!x. x \\<in> set t) \\<Longrightarrow> terminal t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide t \\<and> (\\<exists>!x. x \\<in> local.set t) \\<Longrightarrow>\n    terminal t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ide t \\<and> (\\<exists>!x. x \\<in> local.set t) \\<Longrightarrow>\n    terminal t", "assume t: \"ide t \\<and> (\\<exists>!x. x \\<in> set t)\""], ["proof (state)\nthis:\n  ide t \\<and> (\\<exists>!x. x \\<in> local.set t)\n\ngoal (1 subgoal):\n 1. ide t \\<and> (\\<exists>!x. x \\<in> local.set t) \\<Longrightarrow>\n    terminal t", "from this"], ["proof (chain)\npicking this:\n  ide t \\<and> (\\<exists>!x. x \\<in> local.set t)", "obtain t' where \"set t = {t'}\""], ["proof (prove)\nusing this:\n  ide t \\<and> (\\<exists>!x. x \\<in> local.set t)\n\ngoal (1 subgoal):\n 1. (\\<And>t'.\n        local.set t = {t'} \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  local.set t = {t'}\n\ngoal (1 subgoal):\n 1. ide t \\<and> (\\<exists>!x. x \\<in> local.set t) \\<Longrightarrow>\n    terminal t", "hence t': \"set t = {t'} \\<and> {t'} \\<subseteq> Univ \\<and> t = mkIde {t'}\""], ["proof (prove)\nusing this:\n  local.set t = {t'}\n\ngoal (1 subgoal):\n 1. local.set t = {t'} \\<and> {t'} \\<subseteq> Univ \\<and> t = mkIde {t'}", "using t set_subset_Univ mkIde_set"], ["proof (prove)\nusing this:\n  local.set t = {t'}\n  ide t \\<and> (\\<exists>!x. x \\<in> local.set t)\n  ide ?a \\<Longrightarrow> local.set ?a \\<subseteq> Univ\n  ide ?a \\<Longrightarrow> mkIde (local.set ?a) = ?a\n\ngoal (1 subgoal):\n 1. local.set t = {t'} \\<and> {t'} \\<subseteq> Univ \\<and> t = mkIde {t'}", "by metis"], ["proof (state)\nthis:\n  local.set t = {t'} \\<and> {t'} \\<subseteq> Univ \\<and> t = mkIde {t'}\n\ngoal (1 subgoal):\n 1. ide t \\<and> (\\<exists>!x. x \\<in> local.set t) \\<Longrightarrow>\n    terminal t", "show \"terminal t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminal t", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ide t\n 2. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright>", "show \"ide t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide t", "using t"], ["proof (prove)\nusing this:\n  ide t \\<and> (\\<exists>!x. x \\<in> local.set t)\n\ngoal (1 subgoal):\n 1. ide t", "by simp"], ["proof (state)\nthis:\n  ide t\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright>", "show \"\\<And>a. ide a \\<Longrightarrow> \\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright>", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright>", "assume a: \"ide a\""], ["proof (state)\nthis:\n  ide a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       ide a \\<Longrightarrow>\n       \\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright>", "show \"\\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright>", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : a \\<rightarrow> t\\<guillemotright>\n 2. \\<And>f.\n       \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright> \\<Longrightarrow>\n       f = ?a", "show 1: \"\\<guillemotleft>mkArr (set a) {t'} (\\<lambda>x. t') : a \\<rightarrow> t\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>mkArr (local.set a) {t'}\n                     (\\<lambda>x. t') : a \\<rightarrow> t\\<guillemotright>", "proof"], ["proof (state)\ngoal (3 subgoals):\n 1. arr (mkArr (local.set a) {t'} (\\<lambda>x. t'))\n 2. local.dom (mkArr (local.set a) {t'} (\\<lambda>x. t')) = a\n 3. cod (mkArr (local.set a) {t'} (\\<lambda>x. t')) = t", "show 2: \"arr (mkArr (set a) {t'} (\\<lambda>x. t'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (mkArr (local.set a) {t'} (\\<lambda>x. t'))", "using a t t' cardinal set_card mkIde_set set_subset_Univ arr_mkArr"], ["proof (prove)\nusing this:\n  ide a\n  ide t \\<and> (\\<exists>!x. x \\<in> local.set t)\n  local.set t = {t'} \\<and> {t'} \\<subseteq> Univ \\<and> t = mkIde {t'}\n  Card_order \\<AA> \\<and> infinite (Field \\<AA>)\n  ide ?a \\<Longrightarrow> |local.set ?a| <o \\<AA>\n  ide ?a \\<Longrightarrow> mkIde (local.set ?a) = ?a\n  ide ?a \\<Longrightarrow> local.set ?a \\<subseteq> Univ\n  arr (mkArr ?A ?B ?F) =\n  (?A \\<subseteq> Univ \\<and>\n   |?A| <o \\<AA> \\<and>\n   ?B \\<subseteq> Univ \\<and>\n   |?B| <o \\<AA> \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n\ngoal (1 subgoal):\n 1. arr (mkArr (local.set a) {t'} (\\<lambda>x. t'))", "by force"], ["proof (state)\nthis:\n  arr (mkArr (local.set a) {t'} (\\<lambda>x. t'))\n\ngoal (2 subgoals):\n 1. local.dom (mkArr (local.set a) {t'} (\\<lambda>x. t')) = a\n 2. cod (mkArr (local.set a) {t'} (\\<lambda>x. t')) = t", "show \"dom (mkArr (set a) {t'} (\\<lambda>x. t')) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dom (mkArr (local.set a) {t'} (\\<lambda>x. t')) = a", "using a 2 mkIde_set"], ["proof (prove)\nusing this:\n  ide a\n  arr (mkArr (local.set a) {t'} (\\<lambda>x. t'))\n  ide ?a \\<Longrightarrow> mkIde (local.set ?a) = ?a\n\ngoal (1 subgoal):\n 1. local.dom (mkArr (local.set a) {t'} (\\<lambda>x. t')) = a", "by simp"], ["proof (state)\nthis:\n  local.dom (mkArr (local.set a) {t'} (\\<lambda>x. t')) = a\n\ngoal (1 subgoal):\n 1. cod (mkArr (local.set a) {t'} (\\<lambda>x. t')) = t", "show \"cod (mkArr (set a) {t'} (\\<lambda>x. t')) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cod (mkArr (local.set a) {t'} (\\<lambda>x. t')) = t", "using t t' 2"], ["proof (prove)\nusing this:\n  ide t \\<and> (\\<exists>!x. x \\<in> local.set t)\n  local.set t = {t'} \\<and> {t'} \\<subseteq> Univ \\<and> t = mkIde {t'}\n  arr (mkArr (local.set a) {t'} (\\<lambda>x. t'))\n\ngoal (1 subgoal):\n 1. cod (mkArr (local.set a) {t'} (\\<lambda>x. t')) = t", "by simp"], ["proof (state)\nthis:\n  cod (mkArr (local.set a) {t'} (\\<lambda>x. t')) = t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<guillemotleft>mkArr (local.set a) {t'}\n                   (\\<lambda>x. t') : a \\<rightarrow> t\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright> \\<Longrightarrow>\n       f = mkArr (local.set a) {t'} (\\<lambda>x. t')", "show \"\\<And>f. \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright> \\<Longrightarrow> f = mkArr (set a) {t'} (\\<lambda>x. t')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright> \\<Longrightarrow>\n       f = mkArr (local.set a) {t'} (\\<lambda>x. t')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright> \\<Longrightarrow>\n       f = mkArr (local.set a) {t'} (\\<lambda>x. t')", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright> \\<Longrightarrow>\n       f = mkArr (local.set a) {t'} (\\<lambda>x. t')", "assume f: \"\\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright>\""], ["proof (state)\nthis:\n  \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright> \\<Longrightarrow>\n       f = mkArr (local.set a) {t'} (\\<lambda>x. t')", "show \"f = mkArr (set a) {t'} (\\<lambda>x. t')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = mkArr (local.set a) {t'} (\\<lambda>x. t')", "proof (intro arr_eqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. par f (mkArr (local.set a) {t'} (\\<lambda>x. t'))\n 2. Fun f = Fun (mkArr (local.set a) {t'} (\\<lambda>x. t'))", "show 1: \"par f (mkArr (set a) {t'} (\\<lambda>x. t'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. par f (mkArr (local.set a) {t'} (\\<lambda>x. t'))", "using 1 f in_homE"], ["proof (prove)\nusing this:\n  \\<guillemotleft>mkArr (local.set a) {t'}\n                   (\\<lambda>x. t') : a \\<rightarrow> t\\<guillemotright>\n  \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright>\n  \\<lbrakk>\\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright>;\n   \\<lbrakk>arr ?f; local.dom ?f = ?a; cod ?f = ?b\\<rbrakk>\n   \\<Longrightarrow> ?T\\<rbrakk>\n  \\<Longrightarrow> ?T\n\ngoal (1 subgoal):\n 1. par f (mkArr (local.set a) {t'} (\\<lambda>x. t'))", "by metis"], ["proof (state)\nthis:\n  par f (mkArr (local.set a) {t'} (\\<lambda>x. t'))\n\ngoal (1 subgoal):\n 1. Fun f = Fun (mkArr (local.set a) {t'} (\\<lambda>x. t'))", "show \"Fun f = Fun (mkArr (set a) {t'} (\\<lambda>x. t'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun f = Fun (mkArr (local.set a) {t'} (\\<lambda>x. t'))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Fun f = Fun (mkArr (local.set a) {t'} (\\<lambda>x. t'))", "have \"Fun (mkArr (set a) {t'} (\\<lambda>x. t')) = (\\<lambda>x\\<in>set a. t')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (mkArr (local.set a) {t'} (\\<lambda>x. t')) =\n    (\\<lambda>x\\<in>local.set a. t')", "using 1 Fun_mkArr"], ["proof (prove)\nusing this:\n  par f (mkArr (local.set a) {t'} (\\<lambda>x. t'))\n  arr (mkArr ?A ?B ?F) \\<Longrightarrow>\n  Fun (mkArr ?A ?B ?F) = restrict ?F ?A\n\ngoal (1 subgoal):\n 1. Fun (mkArr (local.set a) {t'} (\\<lambda>x. t')) =\n    (\\<lambda>x\\<in>local.set a. t')", "by simp"], ["proof (state)\nthis:\n  Fun (mkArr (local.set a) {t'} (\\<lambda>x. t')) =\n  (\\<lambda>x\\<in>local.set a. t')\n\ngoal (1 subgoal):\n 1. Fun f = Fun (mkArr (local.set a) {t'} (\\<lambda>x. t'))", "also"], ["proof (state)\nthis:\n  Fun (mkArr (local.set a) {t'} (\\<lambda>x. t')) =\n  (\\<lambda>x\\<in>local.set a. t')\n\ngoal (1 subgoal):\n 1. Fun f = Fun (mkArr (local.set a) {t'} (\\<lambda>x. t'))", "have \"... = Fun f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<in>local.set a. t') = Fun f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<in>local.set a. t') = Fun f", "have \"\\<And>x. x \\<in> set a \\<Longrightarrow> Fun f x = t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> local.set a \\<Longrightarrow> Fun f x = t'", "using f t' Fun_def mkArr_Fun arr_mkArr"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright>\n  local.set t = {t'} \\<and> {t'} \\<subseteq> Univ \\<and> t = mkIde {t'}\n  Fun ?f =\n  restrict\n   (img \\<circ> (\\<cdot>) ?f \\<circ>\n    inv_into (hom unity (local.dom ?f)) img)\n   (local.set (local.dom ?f))\n  arr ?f \\<Longrightarrow>\n  mkArr (local.set (local.dom ?f)) (local.set (cod ?f)) (Fun ?f) = ?f\n  arr (mkArr ?A ?B ?F) =\n  (?A \\<subseteq> Univ \\<and>\n   |?A| <o \\<AA> \\<and>\n   ?B \\<subseteq> Univ \\<and>\n   |?B| <o \\<AA> \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> local.set a \\<Longrightarrow> Fun f x = t'", "by (metis PiE in_homE singletonD)"], ["proof (state)\nthis:\n  ?x \\<in> local.set a \\<Longrightarrow> Fun f ?x = t'\n\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<in>local.set a. t') = Fun f", "moreover"], ["proof (state)\nthis:\n  ?x \\<in> local.set a \\<Longrightarrow> Fun f ?x = t'\n\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<in>local.set a. t') = Fun f", "have \"\\<And>x. x \\<notin> set a \\<Longrightarrow> Fun f x = undefined\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<notin> local.set a \\<Longrightarrow> Fun f x = undefined", "using f Fun_def"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright>\n  Fun ?f =\n  restrict\n   (img \\<circ> (\\<cdot>) ?f \\<circ>\n    inv_into (hom unity (local.dom ?f)) img)\n   (local.set (local.dom ?f))\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<notin> local.set a \\<Longrightarrow> Fun f x = undefined", "by auto"], ["proof (state)\nthis:\n  ?x \\<notin> local.set a \\<Longrightarrow> Fun f ?x = undefined\n\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<in>local.set a. t') = Fun f", "ultimately"], ["proof (chain)\npicking this:\n  ?x \\<in> local.set a \\<Longrightarrow> Fun f ?x = t'\n  ?x \\<notin> local.set a \\<Longrightarrow> Fun f ?x = undefined", "show ?thesis"], ["proof (prove)\nusing this:\n  ?x \\<in> local.set a \\<Longrightarrow> Fun f ?x = t'\n  ?x \\<notin> local.set a \\<Longrightarrow> Fun f ?x = undefined\n\ngoal (1 subgoal):\n 1. (\\<lambda>x\\<in>local.set a. t') = Fun f", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x\\<in>local.set a. t') = Fun f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>x\\<in>local.set a. t') = Fun f\n\ngoal (1 subgoal):\n 1. Fun f = Fun (mkArr (local.set a) {t'} (\\<lambda>x. t'))", "finally"], ["proof (chain)\npicking this:\n  Fun (mkArr (local.set a) {t'} (\\<lambda>x. t')) = Fun f", "show ?thesis"], ["proof (prove)\nusing this:\n  Fun (mkArr (local.set a) {t'} (\\<lambda>x. t')) = Fun f\n\ngoal (1 subgoal):\n 1. Fun f = Fun (mkArr (local.set a) {t'} (\\<lambda>x. t'))", "by force"], ["proof (state)\nthis:\n  Fun f = Fun (mkArr (local.set a) {t'} (\\<lambda>x. t'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Fun f = Fun (mkArr (local.set a) {t'} (\\<lambda>x. t'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f = mkArr (local.set a) {t'} (\\<lambda>x. t')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<guillemotleft>?f : a \\<rightarrow> t\\<guillemotright> \\<Longrightarrow>\n  ?f = mkArr (local.set a) {t'} (\\<lambda>x. t')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> t\\<guillemotright>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ide ?a \\<Longrightarrow>\n  \\<exists>!f. \\<guillemotleft>f : ?a \\<rightarrow> t\\<guillemotright>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  terminal t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ide t \\<and> (\\<exists>!x. x \\<in> local.set t) \\<Longrightarrow>\n  terminal t\n\ngoal (1 subgoal):\n 1. terminal t = (ide t \\<and> (\\<exists>!x. x \\<in> local.set t))", "ultimately"], ["proof (chain)\npicking this:\n  terminal t \\<Longrightarrow>\n  ide t \\<and> (\\<exists>!x. x \\<in> local.set t)\n  ide t \\<and> (\\<exists>!x. x \\<in> local.set t) \\<Longrightarrow>\n  terminal t", "show ?thesis"], ["proof (prove)\nusing this:\n  terminal t \\<Longrightarrow>\n  ide t \\<and> (\\<exists>!x. x \\<in> local.set t)\n  ide t \\<and> (\\<exists>!x. x \\<in> local.set t) \\<Longrightarrow>\n  terminal t\n\ngoal (1 subgoal):\n 1. terminal t = (ide t \\<and> (\\<exists>!x. x \\<in> local.set t))", "by blast"], ["proof (state)\nthis:\n  terminal t = (ide t \\<and> (\\<exists>!x. x \\<in> local.set t))\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n      As stated above, in the presence of the @{prop stable_img} assumption we have\n      the following stronger characterization of terminal objects.\n\\<close>"], ["", "lemma terminal_char2:\n    shows \"terminal t \\<longleftrightarrow> ide t \\<and> set t = {t}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminal t = (ide t \\<and> local.set t = {t})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. terminal t \\<Longrightarrow> ide t \\<and> local.set t = {t}\n 2. ide t \\<and> local.set t = {t} \\<Longrightarrow> terminal t", "assume t: \"terminal t\""], ["proof (state)\nthis:\n  terminal t\n\ngoal (2 subgoals):\n 1. terminal t \\<Longrightarrow> ide t \\<and> local.set t = {t}\n 2. ide t \\<and> local.set t = {t} \\<Longrightarrow> terminal t", "show \"ide t \\<and> set t = {t}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide t \\<and> local.set t = {t}", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ide t\n 2. local.set t = {t}", "show \"ide t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide t", "using t terminal_char1"], ["proof (prove)\nusing this:\n  terminal t\n  terminal ?t = (ide ?t \\<and> (\\<exists>!x. x \\<in> local.set ?t))\n\ngoal (1 subgoal):\n 1. ide t", "by auto"], ["proof (state)\nthis:\n  ide t\n\ngoal (1 subgoal):\n 1. local.set t = {t}", "show \"set t = {t}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.set t = {t}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.set t = {t}", "have \"\\<exists>!x. x \\<in> hom unity t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!x. x \\<in> hom unity t", "using t terminal_def terminal_unity"], ["proof (prove)\nusing this:\n  terminal t\n  terminal ?b \\<equiv>\n  ide ?b \\<and>\n  (\\<forall>a.\n      ide a \\<longrightarrow>\n      (\\<exists>!f.\n          \\<guillemotleft>f : a \\<rightarrow> ?b\\<guillemotright>))\n  terminal unity\n\ngoal (1 subgoal):\n 1. \\<exists>!x. x \\<in> hom unity t", "by force"], ["proof (state)\nthis:\n  \\<exists>!x. x \\<in> hom unity t\n\ngoal (1 subgoal):\n 1. local.set t = {t}", "moreover"], ["proof (state)\nthis:\n  \\<exists>!x. x \\<in> hom unity t\n\ngoal (1 subgoal):\n 1. local.set t = {t}", "have \"t \\<in> img ` hom unity t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> img ` hom unity t", "using t stable_img set_def"], ["proof (prove)\nusing this:\n  terminal t\n  terminal ?t \\<Longrightarrow> ?t \\<in> img ` hom unity ?t\n  local.set ?a = img ` hom unity ?a\n\ngoal (1 subgoal):\n 1. t \\<in> img ` hom unity t", "by simp"], ["proof (state)\nthis:\n  t \\<in> img ` hom unity t\n\ngoal (1 subgoal):\n 1. local.set t = {t}", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>!x. x \\<in> hom unity t\n  t \\<in> img ` hom unity t", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>!x. x \\<in> hom unity t\n  t \\<in> img ` hom unity t\n\ngoal (1 subgoal):\n 1. local.set t = {t}", "using set_def"], ["proof (prove)\nusing this:\n  \\<exists>!x. x \\<in> hom unity t\n  t \\<in> img ` hom unity t\n  local.set ?a = img ` hom unity ?a\n\ngoal (1 subgoal):\n 1. local.set t = {t}", "by auto"], ["proof (state)\nthis:\n  local.set t = {t}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.set t = {t}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ide t \\<and> local.set t = {t}\n\ngoal (1 subgoal):\n 1. ide t \\<and> local.set t = {t} \\<Longrightarrow> terminal t", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. ide t \\<and> local.set t = {t} \\<Longrightarrow> terminal t", "assume \"ide t \\<and> set t = {t}\""], ["proof (state)\nthis:\n  ide t \\<and> local.set t = {t}\n\ngoal (1 subgoal):\n 1. ide t \\<and> local.set t = {t} \\<Longrightarrow> terminal t", "thus \"terminal t\""], ["proof (prove)\nusing this:\n  ide t \\<and> local.set t = {t}\n\ngoal (1 subgoal):\n 1. terminal t", "using terminal_char1"], ["proof (prove)\nusing this:\n  ide t \\<and> local.set t = {t}\n  terminal ?t = (ide ?t \\<and> (\\<exists>!x. x \\<in> local.set ?t))\n\ngoal (1 subgoal):\n 1. terminal t", "by force"], ["proof (state)\nthis:\n  terminal t\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text\\<open>\n    At last, we define the \\<open>set_category\\<close> locale by existentially quantifying\n    out the choice of a particular @{term img} map.  We need to know that such a map\n    exists, but it does not matter which one we choose.\n\\<close>"], ["", "locale set_category = category S\n  for S :: \"'s comp\"      (infixr \"\\<cdot>\" 55)\n  and \\<AA> :: \"'t rel\" +\n  assumes ex_img: \"\\<exists>img. set_category_given_img S img \\<AA>\"\n  begin"], ["", "notation in_hom (\"\\<guillemotleft>_ : _ \\<rightarrow> _\\<guillemotright>\")"], ["", "definition some_img\n    where \"some_img = (SOME img. set_category_given_img S img \\<AA>)\""], ["", "end"], ["", "sublocale set_category \\<subseteq> set_category_given_img S some_img \\<AA>"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_category_given_img (\\<cdot>) some_img \\<AA>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. set_category_given_img (\\<cdot>) some_img \\<AA>", "have \"\\<exists>img. set_category_given_img S img \\<AA>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>img. set_category_given_img (\\<cdot>) img \\<AA>", "using ex_img"], ["proof (prove)\nusing this:\n  \\<exists>img. set_category_given_img (\\<cdot>) img \\<AA>\n\ngoal (1 subgoal):\n 1. \\<exists>img. set_category_given_img (\\<cdot>) img \\<AA>", "by auto"], ["proof (state)\nthis:\n  \\<exists>img. set_category_given_img (\\<cdot>) img \\<AA>\n\ngoal (1 subgoal):\n 1. set_category_given_img (\\<cdot>) some_img \\<AA>", "thus \"set_category_given_img S some_img \\<AA>\""], ["proof (prove)\nusing this:\n  \\<exists>img. set_category_given_img (\\<cdot>) img \\<AA>\n\ngoal (1 subgoal):\n 1. set_category_given_img (\\<cdot>) some_img \\<AA>", "using someI_ex [of \"\\<lambda>img. set_category_given_img S img \\<AA>\"] some_img_def"], ["proof (prove)\nusing this:\n  \\<exists>img. set_category_given_img (\\<cdot>) img \\<AA>\n  \\<exists>x. set_category_given_img (\\<cdot>) x \\<AA> \\<Longrightarrow>\n  set_category_given_img (\\<cdot>)\n   (SOME x. set_category_given_img (\\<cdot>) x \\<AA>) \\<AA>\n  some_img = (SOME img. set_category_given_img (\\<cdot>) img \\<AA>)\n\ngoal (1 subgoal):\n 1. set_category_given_img (\\<cdot>) some_img \\<AA>", "by metis"], ["proof (state)\nthis:\n  set_category_given_img (\\<cdot>) some_img \\<AA>\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n    For a set category, if the cardinal \\<open>\\<AA>\\<close> is large enough, then it imposes no constraint\n    on what subsets of the universe determine objects.  In this case, we call the set category\n    \\emph{replete} and we can eliminate the cardinality assumptions from various facts.\n  \\<close>"], ["", "locale replete_set_category =\n    set_category S \\<open>cardSuc (cmax (card_of (UNIV :: 's set)) natLeq)\\<close>\n  for S :: \"'s comp\"      (infixr \"\\<cdot>\" 55)\n  begin"], ["", "lemma card_of_leq:\n    assumes \"A \\<subseteq> Univ\"\n    shows \"|A| <o cardSuc (cmax (card_of (UNIV :: 's set)) natLeq)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |A| <o cardSuc (cmax |UNIV| natLeq)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. |A| <o cardSuc (cmax |UNIV| natLeq)", "have \"|A| \\<le>o cmax (card_of (UNIV :: 's set)) natLeq\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |A| \\<le>o cmax |UNIV| natLeq", "using assms card_of_Card_order natLeq_Card_order ordLeq_cmax1\n              ordLeq_transitive"], ["proof (prove)\nusing this:\n  A \\<subseteq> Univ\n  Card_order |?A|\n  Card_order natLeq\n  \\<lbrakk>Card_order ?r; Card_order ?s\\<rbrakk>\n  \\<Longrightarrow> ?r \\<le>o cmax ?r ?s\n  \\<lbrakk>?r \\<le>o ?r'; ?r' \\<le>o ?r''\\<rbrakk>\n  \\<Longrightarrow> ?r \\<le>o ?r''\n\ngoal (1 subgoal):\n 1. |A| \\<le>o cmax |UNIV| natLeq", "by (metis card_of_UNIV)"], ["proof (state)\nthis:\n  |A| \\<le>o cmax |UNIV| natLeq\n\ngoal (1 subgoal):\n 1. |A| <o cardSuc (cmax |UNIV| natLeq)", "thus ?thesis"], ["proof (prove)\nusing this:\n  |A| \\<le>o cmax |UNIV| natLeq\n\ngoal (1 subgoal):\n 1. |A| <o cardSuc (cmax |UNIV| natLeq)", "by (simp add: Card_order_cmax natLeq_Card_order)"], ["proof (state)\nthis:\n  |A| <o cardSuc (cmax |UNIV| natLeq)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_mkIde [simp]:\n    assumes \"A \\<subseteq> Univ\"\n    shows \"set (mkIde A) = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.set (mkIde A) = A", "using assms card_of_leq set_mkIde"], ["proof (prove)\nusing this:\n  A \\<subseteq> Univ\n  ?A \\<subseteq> Univ \\<Longrightarrow> |?A| <o cardSuc (cmax |UNIV| natLeq)\n  \\<lbrakk>?A \\<subseteq> Univ;\n   |?A| <o cardSuc (cmax |UNIV| natLeq)\\<rbrakk>\n  \\<Longrightarrow> local.set (mkIde ?A) = ?A\n\ngoal (1 subgoal):\n 1. local.set (mkIde A) = A", "by simp"], ["", "lemma ide_mkIde [simp]:\n    assumes \"A \\<subseteq> Univ\"\n    shows \"ide (mkIde A)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide (mkIde A)", "using assms card_of_leq ide_mkIde"], ["proof (prove)\nusing this:\n  A \\<subseteq> Univ\n  ?A \\<subseteq> Univ \\<Longrightarrow> |?A| <o cardSuc (cmax |UNIV| natLeq)\n  \\<lbrakk>?A \\<subseteq> Univ;\n   |?A| <o cardSuc (cmax |UNIV| natLeq)\\<rbrakk>\n  \\<Longrightarrow> ide (mkIde ?A)\n\ngoal (1 subgoal):\n 1. ide (mkIde A)", "by simp"], ["", "lemma arr_mkIde [iff]:\n    shows \"arr (mkIde A) \\<longleftrightarrow> A \\<subseteq> Univ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (mkIde A) = (A \\<subseteq> Univ)", "using card_of_leq arr_mkIde"], ["proof (prove)\nusing this:\n  ?A \\<subseteq> Univ \\<Longrightarrow> |?A| <o cardSuc (cmax |UNIV| natLeq)\n  arr (mkIde ?A) =\n  (?A \\<subseteq> Univ \\<and> |?A| <o cardSuc (cmax |UNIV| natLeq))\n\ngoal (1 subgoal):\n 1. arr (mkIde A) = (A \\<subseteq> Univ)", "by auto"], ["", "lemma dom_mkIde [simp]:\n    assumes \"A \\<subseteq> Univ\"\n    shows \"dom (mkIde A) = mkIde A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.dom (mkIde A) = mkIde A", "using assms ide_mkIde"], ["proof (prove)\nusing this:\n  A \\<subseteq> Univ\n  ?A \\<subseteq> Univ \\<Longrightarrow> ide (mkIde ?A)\n\ngoal (1 subgoal):\n 1. local.dom (mkIde A) = mkIde A", "by simp"], ["", "lemma cod_mkIde [simp]:\n    assumes \"A \\<subseteq> Univ\"\n    shows \"cod (mkIde A) = mkIde A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cod (mkIde A) = mkIde A", "using assms ide_mkIde"], ["proof (prove)\nusing this:\n  A \\<subseteq> Univ\n  ?A \\<subseteq> Univ \\<Longrightarrow> ide (mkIde ?A)\n\ngoal (1 subgoal):\n 1. cod (mkIde A) = mkIde A", "by simp"], ["", "lemma Fun_mkIde [simp]:\n    assumes \"A \\<subseteq> Univ\"\n    shows \"Fun (mkIde A) = restrict (\\<lambda>x. x) A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (mkIde A) = (\\<lambda>x\\<in>A. x)", "using assms set_mkIde ide_mkIde Fun_ide"], ["proof (prove)\nusing this:\n  A \\<subseteq> Univ\n  ?A \\<subseteq> Univ \\<Longrightarrow> local.set (mkIde ?A) = ?A\n  ?A \\<subseteq> Univ \\<Longrightarrow> ide (mkIde ?A)\n  ide ?a \\<Longrightarrow> Fun ?a = (\\<lambda>x\\<in>local.set ?a. x)\n\ngoal (1 subgoal):\n 1. Fun (mkIde A) = (\\<lambda>x\\<in>A. x)", "by simp"], ["", "lemma mkArr_in_hom [intro]:\n    assumes \"A \\<subseteq> Univ\" and \"B \\<subseteq> Univ\" and \"F \\<in> A \\<rightarrow> B\"\n    shows \"\\<guillemotleft>mkArr A B F : mkIde A \\<rightarrow> mkIde B\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>mkArr A B\n                     F : mkIde A \\<rightarrow> mkIde B\\<guillemotright>", "using assms card_of_leq arr_mkArr"], ["proof (prove)\nusing this:\n  A \\<subseteq> Univ\n  B \\<subseteq> Univ\n  F \\<in> A \\<rightarrow> B\n  ?A \\<subseteq> Univ \\<Longrightarrow> |?A| <o cardSuc (cmax |UNIV| natLeq)\n  arr (mkArr ?A ?B ?F) =\n  (?A \\<subseteq> Univ \\<and>\n   |?A| <o cardSuc (cmax |UNIV| natLeq) \\<and>\n   ?B \\<subseteq> Univ \\<and>\n   |?B| <o cardSuc (cmax |UNIV| natLeq) \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>mkArr A B\n                     F : mkIde A \\<rightarrow> mkIde B\\<guillemotright>", "by auto"], ["", "lemma arr_mkArr:\n    shows \"arr (mkArr A B F) \\<longleftrightarrow> A \\<subseteq> Univ \\<and> B \\<subseteq> Univ \\<and> F \\<in> A \\<rightarrow> B\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (mkArr A B F) =\n    (A \\<subseteq> Univ \\<and>\n     B \\<subseteq> Univ \\<and> F \\<in> A \\<rightarrow> B)", "using card_of_leq arr_mkArr"], ["proof (prove)\nusing this:\n  ?A \\<subseteq> Univ \\<Longrightarrow> |?A| <o cardSuc (cmax |UNIV| natLeq)\n  arr (mkArr ?A ?B ?F) =\n  (?A \\<subseteq> Univ \\<and>\n   |?A| <o cardSuc (cmax |UNIV| natLeq) \\<and>\n   ?B \\<subseteq> Univ \\<and>\n   |?B| <o cardSuc (cmax |UNIV| natLeq) \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n\ngoal (1 subgoal):\n 1. arr (mkArr A B F) =\n    (A \\<subseteq> Univ \\<and>\n     B \\<subseteq> Univ \\<and> F \\<in> A \\<rightarrow> B)", "by auto"], ["", "lemma mkIde_as_mkArr:\n    assumes \"A \\<subseteq> Univ\"\n    shows \"mkArr A A (\\<lambda>x. x) = mkIde A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mkArr A A (\\<lambda>x. x) = mkIde A", "using assms card_of_leq set_mkIde arr_mkIde arr_mkArr dom_mkIde cod_mkIde Fun_mkIde"], ["proof (prove)\nusing this:\n  A \\<subseteq> Univ\n  ?A \\<subseteq> Univ \\<Longrightarrow> |?A| <o cardSuc (cmax |UNIV| natLeq)\n  ?A \\<subseteq> Univ \\<Longrightarrow> local.set (mkIde ?A) = ?A\n  arr (mkIde ?A) = (?A \\<subseteq> Univ)\n  arr (mkArr ?A ?B ?F) =\n  (?A \\<subseteq> Univ \\<and>\n   ?B \\<subseteq> Univ \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n  ?A \\<subseteq> Univ \\<Longrightarrow> local.dom (mkIde ?A) = mkIde ?A\n  ?A \\<subseteq> Univ \\<Longrightarrow> cod (mkIde ?A) = mkIde ?A\n  ?A \\<subseteq> Univ \\<Longrightarrow>\n  Fun (mkIde ?A) = (\\<lambda>x\\<in>?A. x)\n\ngoal (1 subgoal):\n 1. mkArr A A (\\<lambda>x. x) = mkIde A", "by (intro arr_eqI, auto)"], ["", "end"], ["", "context set_category\n  begin"], ["", "text\\<open>\n      The arbitrary choice of @{term img} induces a system of arrows corresponding\n      to inclusions of subsets.\n\\<close>"], ["", "definition incl :: \"'s \\<Rightarrow> bool\"\n    where \"incl f = (arr f \\<and> set (dom f) \\<subseteq> set (cod f) \\<and>\n                     f = mkArr (set (dom f)) (set (cod f)) (\\<lambda>x. x))\""], ["", "lemma Fun_incl:\n    assumes \"incl f\"\n    shows \"Fun f = (\\<lambda>x \\<in> set (dom f). x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun f = (\\<lambda>x\\<in>local.set (local.dom f). x)", "using assms incl_def"], ["proof (prove)\nusing this:\n  incl f\n  incl ?f =\n  (arr ?f \\<and>\n   local.set (local.dom ?f) \\<subseteq> local.set (cod ?f) \\<and>\n   ?f =\n   mkArr (local.set (local.dom ?f)) (local.set (cod ?f)) (\\<lambda>x. x))\n\ngoal (1 subgoal):\n 1. Fun f = (\\<lambda>x\\<in>local.set (local.dom f). x)", "by (metis Fun_mkArr)"], ["", "lemma ex_incl_iff_subset:\n    assumes \"ide a\" and \"ide b\"\n    shows \"(\\<exists>f. \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and> incl f) \\<longleftrightarrow> set a \\<subseteq> set b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<exists>f.\n        \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n        incl f) =\n    (local.set a \\<subseteq> local.set b)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<exists>f.\n       \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n       incl f \\<Longrightarrow>\n    local.set a \\<subseteq> local.set b\n 2. local.set a \\<subseteq> local.set b \\<Longrightarrow>\n    \\<exists>f.\n       \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and> incl f", "show \"\\<exists>f. \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and> incl f \\<Longrightarrow> set a \\<subseteq> set b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>f.\n       \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n       incl f \\<Longrightarrow>\n    local.set a \\<subseteq> local.set b", "using incl_def"], ["proof (prove)\nusing this:\n  incl ?f =\n  (arr ?f \\<and>\n   local.set (local.dom ?f) \\<subseteq> local.set (cod ?f) \\<and>\n   ?f =\n   mkArr (local.set (local.dom ?f)) (local.set (cod ?f)) (\\<lambda>x. x))\n\ngoal (1 subgoal):\n 1. \\<exists>f.\n       \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n       incl f \\<Longrightarrow>\n    local.set a \\<subseteq> local.set b", "by auto"], ["proof (state)\nthis:\n  \\<exists>f.\n     \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n     incl f \\<Longrightarrow>\n  local.set a \\<subseteq> local.set b\n\ngoal (1 subgoal):\n 1. local.set a \\<subseteq> local.set b \\<Longrightarrow>\n    \\<exists>f.\n       \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and> incl f", "show \"set a \\<subseteq> set b \\<Longrightarrow> \\<exists>f. \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and> incl f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.set a \\<subseteq> local.set b \\<Longrightarrow>\n    \\<exists>f.\n       \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and> incl f", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. local.set a \\<subseteq> local.set b \\<Longrightarrow>\n    \\<guillemotleft>?f : a \\<rightarrow> b\\<guillemotright> \\<and> incl ?f", "assume 1: \"set a \\<subseteq> set b\""], ["proof (state)\nthis:\n  local.set a \\<subseteq> local.set b\n\ngoal (1 subgoal):\n 1. local.set a \\<subseteq> local.set b \\<Longrightarrow>\n    \\<guillemotleft>?f : a \\<rightarrow> b\\<guillemotright> \\<and> incl ?f", "show \"\\<guillemotleft>mkArr (set a) (set b) (\\<lambda>x. x) : a \\<rightarrow> b\\<guillemotright> \\<and> incl (mkArr (set a) (set b) (\\<lambda>x. x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>mkArr (local.set a) (local.set b)\n                     (\\<lambda>x.\n                         x) : a \\<rightarrow> b\\<guillemotright> \\<and>\n    incl (mkArr (local.set a) (local.set b) (\\<lambda>x. x))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<guillemotleft>mkArr (local.set a) (local.set b)\n                     (\\<lambda>x. x) : a \\<rightarrow> b\\<guillemotright>\n 2. incl (mkArr (local.set a) (local.set b) (\\<lambda>x. x))", "show \"\\<guillemotleft>mkArr (set a) (set b) (\\<lambda>x. x) : a \\<rightarrow> b\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>mkArr (local.set a) (local.set b)\n                     (\\<lambda>x. x) : a \\<rightarrow> b\\<guillemotright>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<guillemotleft>mkArr (local.set a) (local.set b)\n                     (\\<lambda>x. x) : a \\<rightarrow> b\\<guillemotright>", "have \"(\\<lambda>x. x) \\<in> set a \\<rightarrow> set b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x. x) \\<in> local.set a \\<rightarrow> local.set b", "using 1"], ["proof (prove)\nusing this:\n  local.set a \\<subseteq> local.set b\n\ngoal (1 subgoal):\n 1. (\\<lambda>x. x) \\<in> local.set a \\<rightarrow> local.set b", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x. x) \\<in> local.set a \\<rightarrow> local.set b\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>mkArr (local.set a) (local.set b)\n                     (\\<lambda>x. x) : a \\<rightarrow> b\\<guillemotright>", "thus ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>x. x) \\<in> local.set a \\<rightarrow> local.set b\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>mkArr (local.set a) (local.set b)\n                     (\\<lambda>x. x) : a \\<rightarrow> b\\<guillemotright>", "using assms mkArr_in_hom set_subset_Univ in_homI set_card arr_mkArr mkIde_set"], ["proof (prove)\nusing this:\n  (\\<lambda>x. x) \\<in> local.set a \\<rightarrow> local.set b\n  ide a\n  ide b\n  \\<lbrakk>?A \\<subseteq> Univ; |?A| <o \\<AA>; ?B \\<subseteq> Univ;\n   |?B| <o \\<AA>; ?F \\<in> ?A \\<rightarrow> ?B\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>mkArr ?A ?B\n                                     ?F : mkIde\n     ?A \\<rightarrow> mkIde ?B\\<guillemotright>\n  ide ?a \\<Longrightarrow> local.set ?a \\<subseteq> Univ\n  \\<lbrakk>arr ?f; local.dom ?f = ?a; cod ?f = ?b\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright>\n  ide ?a \\<Longrightarrow> |local.set ?a| <o \\<AA>\n  arr (mkArr ?A ?B ?F) =\n  (?A \\<subseteq> Univ \\<and>\n   |?A| <o \\<AA> \\<and>\n   ?B \\<subseteq> Univ \\<and>\n   |?B| <o \\<AA> \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n  ide ?a \\<Longrightarrow> mkIde (local.set ?a) = ?a\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>mkArr (local.set a) (local.set b)\n                     (\\<lambda>x. x) : a \\<rightarrow> b\\<guillemotright>", "by auto"], ["proof (state)\nthis:\n  \\<guillemotleft>mkArr (local.set a) (local.set b)\n                   (\\<lambda>x. x) : a \\<rightarrow> b\\<guillemotright>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<guillemotleft>mkArr (local.set a) (local.set b)\n                   (\\<lambda>x. x) : a \\<rightarrow> b\\<guillemotright>\n\ngoal (1 subgoal):\n 1. incl (mkArr (local.set a) (local.set b) (\\<lambda>x. x))", "thus \"incl (mkArr (set a) (set b) (\\<lambda>x. x))\""], ["proof (prove)\nusing this:\n  \\<guillemotleft>mkArr (local.set a) (local.set b)\n                   (\\<lambda>x. x) : a \\<rightarrow> b\\<guillemotright>\n\ngoal (1 subgoal):\n 1. incl (mkArr (local.set a) (local.set b) (\\<lambda>x. x))", "using 1 incl_def"], ["proof (prove)\nusing this:\n  \\<guillemotleft>mkArr (local.set a) (local.set b)\n                   (\\<lambda>x. x) : a \\<rightarrow> b\\<guillemotright>\n  local.set a \\<subseteq> local.set b\n  incl ?f =\n  (arr ?f \\<and>\n   local.set (local.dom ?f) \\<subseteq> local.set (cod ?f) \\<and>\n   ?f =\n   mkArr (local.set (local.dom ?f)) (local.set (cod ?f)) (\\<lambda>x. x))\n\ngoal (1 subgoal):\n 1. incl (mkArr (local.set a) (local.set b) (\\<lambda>x. x))", "by force"], ["proof (state)\nthis:\n  incl (mkArr (local.set a) (local.set b) (\\<lambda>x. x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<guillemotleft>mkArr (local.set a) (local.set b)\n                   (\\<lambda>x.\n                       x) : a \\<rightarrow> b\\<guillemotright> \\<and>\n  incl (mkArr (local.set a) (local.set b) (\\<lambda>x. x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.set a \\<subseteq> local.set b \\<Longrightarrow>\n  \\<exists>f.\n     \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and> incl f\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "section \"Categoricity\""], ["", "text\\<open>\n    In this section we show that the \\<open>set_category\\<close> locale completely characterizes\n    the structure of its interpretations as categories, in the sense that for any two\n    interpretations @{term S} and @{term S'} for the same cardinal \\<open>\\<AA>\\<close>,\n    a bijection between the universe of @{term S} and the universe of @{term S'} extends\n    to an isomorphism of @{term S} and @{term S'}.\n\\<close>"], ["", "locale two_set_categories_bij_betw_Univ =\n    S: set_category S \\<AA> +\n    S': set_category S' \\<AA>\n  for S :: \"'s comp\"      (infixr \"\\<cdot>\" 55)\n  and S' :: \"'t comp\"     (infixr \"\\<cdot>\\<acute>\" 55)\n  and \\<AA> :: \"'u rel\"\n  and \\<phi> :: \"'s \\<Rightarrow> 't\" +\n  assumes bij_\\<phi>: \"bij_betw \\<phi> S.Univ S'.Univ\"\n  begin"], ["", "notation S.in_hom     (\"\\<guillemotleft>_ : _ \\<rightarrow> _\\<guillemotright>\")"], ["", "notation S'.in_hom    (\"\\<guillemotleft>_ : _ \\<rightarrow>'' _\\<guillemotright>\")"], ["", "abbreviation \\<psi>\n    where \"\\<psi> \\<equiv> inv_into S.Univ \\<phi>\""], ["", "lemma \\<psi>_\\<phi>:\n    assumes \"t \\<in> S.Univ\"\n    shows \"\\<psi> (\\<phi> t) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> (\\<phi> t) = t", "using assms bij_\\<phi> bij_betw_inv_into_left"], ["proof (prove)\nusing this:\n  t \\<in> S.Univ\n  bij_betw \\<phi> S.Univ S'.Univ\n  \\<lbrakk>bij_betw ?f ?A ?A'; ?a \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> inv_into ?A ?f (?f ?a) = ?a\n\ngoal (1 subgoal):\n 1. \\<psi> (\\<phi> t) = t", "by metis"], ["", "lemma \\<phi>_\\<psi>:\n    assumes \"t' \\<in> S'.Univ\"\n    shows \"\\<phi> (\\<psi> t') = t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> (\\<psi> t') = t'", "using assms bij_\\<phi> bij_betw_inv_into_right"], ["proof (prove)\nusing this:\n  t' \\<in> S'.Univ\n  bij_betw \\<phi> S.Univ S'.Univ\n  \\<lbrakk>bij_betw ?f ?A ?A'; ?a' \\<in> ?A'\\<rbrakk>\n  \\<Longrightarrow> ?f (inv_into ?A ?f ?a') = ?a'\n\ngoal (1 subgoal):\n 1. \\<phi> (\\<psi> t') = t'", "by metis"], ["", "lemma \\<psi>_img_\\<phi>_img:\n    assumes \"A \\<subseteq> S.Univ\"\n    shows \"\\<psi> ` \\<phi> ` A = A\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> ` \\<phi> ` A = A", "using assms bij_\\<phi>"], ["proof (prove)\nusing this:\n  A \\<subseteq> S.Univ\n  bij_betw \\<phi> S.Univ S'.Univ\n\ngoal (1 subgoal):\n 1. \\<psi> ` \\<phi> ` A = A", "by (simp add: bij_betw_def)"], ["", "lemma \\<phi>_img_\\<psi>_img:\n    assumes \"A' \\<subseteq> S'.Univ\"\n    shows \"\\<phi> ` \\<psi> ` A' = A'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> ` \\<psi> ` A' = A'", "using assms bij_\\<phi>"], ["proof (prove)\nusing this:\n  A' \\<subseteq> S'.Univ\n  bij_betw \\<phi> S.Univ S'.Univ\n\ngoal (1 subgoal):\n 1. \\<phi> ` \\<psi> ` A' = A'", "by (simp add: bij_betw_def image_inv_into_cancel)"], ["", "text\\<open>\n      We define the object map @{term \\<Phi>o} of a functor from @{term[source=true] S}\n      to @{term[source=true] S'}.\n\\<close>"], ["", "definition \\<Phi>o\n    where \"\\<Phi>o = (\\<lambda>a \\<in> Collect S.ide. S'.mkIde (\\<phi> ` S.set a))\""], ["", "lemma set_\\<Phi>o:\n    assumes \"S.ide a\"\n    shows \"S'.set (\\<Phi>o a) = \\<phi> ` S.set a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S'.set (\\<Phi>o a) = \\<phi> ` S.set a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. S'.set (\\<Phi>o a) = \\<phi> ` S.set a", "from assms"], ["proof (chain)\npicking this:\n  S.ide a", "have \"S.set a \\<subseteq> S.Univ \\<and> |S.set a| <o \\<AA>\""], ["proof (prove)\nusing this:\n  S.ide a\n\ngoal (1 subgoal):\n 1. S.set a \\<subseteq> S.Univ \\<and> |S.set a| <o \\<AA>", "by (simp add: S.set_card)"], ["proof (state)\nthis:\n  S.set a \\<subseteq> S.Univ \\<and> |S.set a| <o \\<AA>\n\ngoal (1 subgoal):\n 1. S'.set (\\<Phi>o a) = \\<phi> ` S.set a", "moreover"], ["proof (state)\nthis:\n  S.set a \\<subseteq> S.Univ \\<and> |S.set a| <o \\<AA>\n\ngoal (1 subgoal):\n 1. S'.set (\\<Phi>o a) = \\<phi> ` S.set a", "have \"|\\<phi> ` S.set a| <o \\<AA>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |\\<phi> ` S.set a| <o \\<AA>", "by (meson calculation card_of_image ordLeq_ordLess_trans)"], ["proof (state)\nthis:\n  |\\<phi> ` S.set a| <o \\<AA>\n\ngoal (1 subgoal):\n 1. S'.set (\\<Phi>o a) = \\<phi> ` S.set a", "ultimately"], ["proof (chain)\npicking this:\n  S.set a \\<subseteq> S.Univ \\<and> |S.set a| <o \\<AA>\n  |\\<phi> ` S.set a| <o \\<AA>", "show ?thesis"], ["proof (prove)\nusing this:\n  S.set a \\<subseteq> S.Univ \\<and> |S.set a| <o \\<AA>\n  |\\<phi> ` S.set a| <o \\<AA>\n\ngoal (1 subgoal):\n 1. S'.set (\\<Phi>o a) = \\<phi> ` S.set a", "using S'.set_mkIde \\<Phi>o_def assms bij_\\<phi> bij_betw_def image_mono mem_Collect_eq restrict_def"], ["proof (prove)\nusing this:\n  S.set a \\<subseteq> S.Univ \\<and> |S.set a| <o \\<AA>\n  |\\<phi> ` S.set a| <o \\<AA>\n  \\<lbrakk>?A \\<subseteq> S'.Univ; |?A| <o \\<AA>\\<rbrakk>\n  \\<Longrightarrow> S'.set (S'.mkIde ?A) = ?A\n  \\<Phi>o = (\\<lambda>a\\<in>Collect S.ide. S'.mkIde (\\<phi> ` S.set a))\n  S.ide a\n  bij_betw \\<phi> S.Univ S'.Univ\n  bij_betw ?f ?A ?B = (inj_on ?f ?A \\<and> ?f ` ?A = ?B)\n  ?A \\<subseteq> ?B \\<Longrightarrow> ?f ` ?A \\<subseteq> ?f ` ?B\n  (?a \\<in> Collect ?P) = ?P ?a\n  restrict ?f ?A = (\\<lambda>x. if x \\<in> ?A then ?f x else undefined)\n\ngoal (1 subgoal):\n 1. S'.set (\\<Phi>o a) = \\<phi> ` S.set a", "by (metis (no_types, lifting))"], ["proof (state)\nthis:\n  S'.set (\\<Phi>o a) = \\<phi> ` S.set a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<Phi>o_preserves_ide:\n    assumes \"S.ide a\"\n    shows \"S'.ide (\\<Phi>o a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S'.ide (\\<Phi>o a)", "using assms S'.ide_mkIde S.set_subset_Univ bij_\\<phi> bij_betw_def image_mono restrict_apply'"], ["proof (prove)\nusing this:\n  S.ide a\n  \\<lbrakk>?A \\<subseteq> S'.Univ; |?A| <o \\<AA>\\<rbrakk>\n  \\<Longrightarrow> S'.ide (S'.mkIde ?A)\n  S.ide ?a \\<Longrightarrow> S.set ?a \\<subseteq> S.Univ\n  bij_betw \\<phi> S.Univ S'.Univ\n  bij_betw ?f ?A ?B = (inj_on ?f ?A \\<and> ?f ` ?A = ?B)\n  ?A \\<subseteq> ?B \\<Longrightarrow> ?f ` ?A \\<subseteq> ?f ` ?B\n  ?x \\<in> ?A \\<Longrightarrow> restrict ?f ?A ?x = ?f ?x\n\ngoal (1 subgoal):\n 1. S'.ide (\\<Phi>o a)", "unfolding \\<Phi>o_def"], ["proof (prove)\nusing this:\n  S.ide a\n  \\<lbrakk>?A \\<subseteq> S'.Univ; |?A| <o \\<AA>\\<rbrakk>\n  \\<Longrightarrow> S'.ide (S'.mkIde ?A)\n  S.ide ?a \\<Longrightarrow> S.set ?a \\<subseteq> S.Univ\n  bij_betw \\<phi> S.Univ S'.Univ\n  bij_betw ?f ?A ?B = (inj_on ?f ?A \\<and> ?f ` ?A = ?B)\n  ?A \\<subseteq> ?B \\<Longrightarrow> ?f ` ?A \\<subseteq> ?f ` ?B\n  ?x \\<in> ?A \\<Longrightarrow> restrict ?f ?A ?x = ?f ?x\n\ngoal (1 subgoal):\n 1. S'.ide ((\\<lambda>a\\<in>Collect S.ide. S'.mkIde (\\<phi> ` S.set a)) a)", "by (metis (no_types, lifting) S.set_card card_of_image mem_Collect_eq ordLeq_ordLess_trans)"], ["", "text\\<open>\n      The map @{term \\<Phi>a} assigns to each arrow @{term f} of @{term[source=true] S} the function on\n      the universe of @{term[source=true] S'} that is the same as the function induced by @{term f}\n      on the universe of @{term[source=true] S}, up to the bijection @{term \\<phi>} between the two\n      universes.\n\\<close>"], ["", "definition \\<Phi>a\n    where \"\\<Phi>a = (\\<lambda>f. \\<lambda>x' \\<in> \\<phi> ` S.set (S.dom f). \\<phi> (S.Fun f (\\<psi> x')))\""], ["", "lemma \\<Phi>a_mapsto:\n    assumes \"S.arr f\"\n    shows \"\\<Phi>a f \\<in> S'.set (\\<Phi>o (S.dom f)) \\<rightarrow> S'.set (\\<Phi>o (S.cod f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi>a f\n    \\<in> S'.set (\\<Phi>o (S.dom f)) \\<rightarrow>\n          S'.set (\\<Phi>o (S.cod f))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi>a f\n    \\<in> S'.set (\\<Phi>o (S.dom f)) \\<rightarrow>\n          S'.set (\\<Phi>o (S.cod f))", "have \"\\<Phi>a f \\<in> \\<phi> ` S.set (S.dom f) \\<rightarrow> \\<phi> ` S.set (S.cod f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi>a f\n    \\<in> \\<phi> ` S.set (S.dom f) \\<rightarrow> \\<phi> ` S.set (S.cod f)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<phi> ` S.set (S.dom f) \\<Longrightarrow>\n       \\<Phi>a f x \\<in> \\<phi> ` S.set (S.cod f)", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<phi> ` S.set (S.dom f) \\<Longrightarrow>\n       \\<Phi>a f x \\<in> \\<phi> ` S.set (S.cod f)", "assume x: \"x \\<in> \\<phi> ` S.set (S.dom f)\""], ["proof (state)\nthis:\n  x \\<in> \\<phi> ` S.set (S.dom f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<phi> ` S.set (S.dom f) \\<Longrightarrow>\n       \\<Phi>a f x \\<in> \\<phi> ` S.set (S.cod f)", "have \"\\<psi> x \\<in> S.set (S.dom f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> x \\<in> S.set (S.dom f)", "using assms x \\<psi>_img_\\<phi>_img [of \"S.set (S.dom f)\"] S.set_subset_Univ"], ["proof (prove)\nusing this:\n  S.arr f\n  x \\<in> \\<phi> ` S.set (S.dom f)\n  S.set (S.dom f) \\<subseteq> S.Univ \\<Longrightarrow>\n  \\<psi> ` \\<phi> ` S.set (S.dom f) = S.set (S.dom f)\n  S.ide ?a \\<Longrightarrow> S.set ?a \\<subseteq> S.Univ\n\ngoal (1 subgoal):\n 1. \\<psi> x \\<in> S.set (S.dom f)", "by auto"], ["proof (state)\nthis:\n  \\<psi> x \\<in> S.set (S.dom f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<phi> ` S.set (S.dom f) \\<Longrightarrow>\n       \\<Phi>a f x \\<in> \\<phi> ` S.set (S.cod f)", "hence \"S.Fun f (\\<psi> x) \\<in> S.set (S.cod f)\""], ["proof (prove)\nusing this:\n  \\<psi> x \\<in> S.set (S.dom f)\n\ngoal (1 subgoal):\n 1. S.Fun f (\\<psi> x) \\<in> S.set (S.cod f)", "using assms S.Fun_mapsto"], ["proof (prove)\nusing this:\n  \\<psi> x \\<in> S.set (S.dom f)\n  S.arr f\n  S.arr ?f \\<Longrightarrow>\n  S.Fun ?f\n  \\<in> extensional (S.set (S.dom ?f)) \\<inter>\n        (S.set (S.dom ?f) \\<rightarrow> S.set (S.cod ?f))\n\ngoal (1 subgoal):\n 1. S.Fun f (\\<psi> x) \\<in> S.set (S.cod f)", "by auto"], ["proof (state)\nthis:\n  S.Fun f (\\<psi> x) \\<in> S.set (S.cod f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<phi> ` S.set (S.dom f) \\<Longrightarrow>\n       \\<Phi>a f x \\<in> \\<phi> ` S.set (S.cod f)", "hence \"\\<phi> (S.Fun f (\\<psi> x)) \\<in> \\<phi> ` S.set (S.cod f)\""], ["proof (prove)\nusing this:\n  S.Fun f (\\<psi> x) \\<in> S.set (S.cod f)\n\ngoal (1 subgoal):\n 1. \\<phi> (S.Fun f (\\<psi> x)) \\<in> \\<phi> ` S.set (S.cod f)", "by simp"], ["proof (state)\nthis:\n  \\<phi> (S.Fun f (\\<psi> x)) \\<in> \\<phi> ` S.set (S.cod f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<phi> ` S.set (S.dom f) \\<Longrightarrow>\n       \\<Phi>a f x \\<in> \\<phi> ` S.set (S.cod f)", "thus \"\\<Phi>a f x \\<in> \\<phi> ` S.set (S.cod f)\""], ["proof (prove)\nusing this:\n  \\<phi> (S.Fun f (\\<psi> x)) \\<in> \\<phi> ` S.set (S.cod f)\n\ngoal (1 subgoal):\n 1. \\<Phi>a f x \\<in> \\<phi> ` S.set (S.cod f)", "using x \\<Phi>a_def"], ["proof (prove)\nusing this:\n  \\<phi> (S.Fun f (\\<psi> x)) \\<in> \\<phi> ` S.set (S.cod f)\n  x \\<in> \\<phi> ` S.set (S.dom f)\n  \\<Phi>a =\n  (\\<lambda>f.\n      \\<lambda>x'\\<in>\\<phi> ` S.set (S.dom f).\n         \\<phi> (S.Fun f (\\<psi> x')))\n\ngoal (1 subgoal):\n 1. \\<Phi>a f x \\<in> \\<phi> ` S.set (S.cod f)", "by auto"], ["proof (state)\nthis:\n  \\<Phi>a f x \\<in> \\<phi> ` S.set (S.cod f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Phi>a f\n  \\<in> \\<phi> ` S.set (S.dom f) \\<rightarrow> \\<phi> ` S.set (S.cod f)\n\ngoal (1 subgoal):\n 1. \\<Phi>a f\n    \\<in> S'.set (\\<Phi>o (S.dom f)) \\<rightarrow>\n          S'.set (\\<Phi>o (S.cod f))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<Phi>a f\n  \\<in> \\<phi> ` S.set (S.dom f) \\<rightarrow> \\<phi> ` S.set (S.cod f)\n\ngoal (1 subgoal):\n 1. \\<Phi>a f\n    \\<in> S'.set (\\<Phi>o (S.dom f)) \\<rightarrow>\n          S'.set (\\<Phi>o (S.cod f))", "using assms set_\\<Phi>o \\<Phi>o_preserves_ide"], ["proof (prove)\nusing this:\n  \\<Phi>a f\n  \\<in> \\<phi> ` S.set (S.dom f) \\<rightarrow> \\<phi> ` S.set (S.cod f)\n  S.arr f\n  S.ide ?a \\<Longrightarrow> S'.set (\\<Phi>o ?a) = \\<phi> ` S.set ?a\n  S.ide ?a \\<Longrightarrow> S'.ide (\\<Phi>o ?a)\n\ngoal (1 subgoal):\n 1. \\<Phi>a f\n    \\<in> S'.set (\\<Phi>o (S.dom f)) \\<rightarrow>\n          S'.set (\\<Phi>o (S.cod f))", "by auto"], ["proof (state)\nthis:\n  \\<Phi>a f\n  \\<in> S'.set (\\<Phi>o (S.dom f)) \\<rightarrow> S'.set (\\<Phi>o (S.cod f))\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n      The map @{term \\<Phi>a} takes composition of arrows to extensional\n      composition of functions.\n\\<close>"], ["", "lemma \\<Phi>a_comp:\n    assumes gf: \"S.seq g f\"\n    shows \"\\<Phi>a (g \\<cdot> f) = restrict (\\<Phi>a g o \\<Phi>a f) (S'.set (\\<Phi>o (S.dom f)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi>a (g \\<cdot> f) =\n    restrict (\\<Phi>a g \\<circ> \\<Phi>a f) (S'.set (\\<Phi>o (S.dom f)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi>a (g \\<cdot> f) =\n    restrict (\\<Phi>a g \\<circ> \\<Phi>a f) (S'.set (\\<Phi>o (S.dom f)))", "have \"\\<Phi>a (g \\<cdot> f) = (\\<lambda>x' \\<in> \\<phi> ` S.set (S.dom f). \\<phi> (S.Fun (S g f) (\\<psi> x')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi>a (g \\<cdot> f) =\n    (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom f).\n        \\<phi> (S.Fun (g \\<cdot> f) (\\<psi> x')))", "using gf \\<Phi>a_def"], ["proof (prove)\nusing this:\n  S.seq g f\n  \\<Phi>a =\n  (\\<lambda>f.\n      \\<lambda>x'\\<in>\\<phi> ` S.set (S.dom f).\n         \\<phi> (S.Fun f (\\<psi> x')))\n\ngoal (1 subgoal):\n 1. \\<Phi>a (g \\<cdot> f) =\n    (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom f).\n        \\<phi> (S.Fun (g \\<cdot> f) (\\<psi> x')))", "by auto"], ["proof (state)\nthis:\n  \\<Phi>a (g \\<cdot> f) =\n  (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom f).\n      \\<phi> (S.Fun (g \\<cdot> f) (\\<psi> x')))\n\ngoal (1 subgoal):\n 1. \\<Phi>a (g \\<cdot> f) =\n    restrict (\\<Phi>a g \\<circ> \\<Phi>a f) (S'.set (\\<Phi>o (S.dom f)))", "also"], ["proof (state)\nthis:\n  \\<Phi>a (g \\<cdot> f) =\n  (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom f).\n      \\<phi> (S.Fun (g \\<cdot> f) (\\<psi> x')))\n\ngoal (1 subgoal):\n 1. \\<Phi>a (g \\<cdot> f) =\n    restrict (\\<Phi>a g \\<circ> \\<Phi>a f) (S'.set (\\<Phi>o (S.dom f)))", "have \"... = (\\<lambda>x' \\<in> \\<phi> ` S.set (S.dom f).\n                           \\<phi> (restrict (S.Fun g o S.Fun f) (S.set (S.dom f)) (\\<psi> x')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom f).\n        \\<phi> (S.Fun (g \\<cdot> f) (\\<psi> x'))) =\n    (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom f).\n        \\<phi>\n         (restrict (S.Fun g \\<circ> S.Fun f) (S.set (S.dom f)) (\\<psi> x')))", "using gf set_\\<Phi>o S.Fun_comp"], ["proof (prove)\nusing this:\n  S.seq g f\n  S.ide ?a \\<Longrightarrow> S'.set (\\<Phi>o ?a) = \\<phi> ` S.set ?a\n  S.seq ?g ?f \\<Longrightarrow>\n  S.Fun (?g \\<cdot> ?f) =\n  restrict (S.Fun ?g \\<circ> S.Fun ?f) (S.set (S.dom ?f))\n\ngoal (1 subgoal):\n 1. (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom f).\n        \\<phi> (S.Fun (g \\<cdot> f) (\\<psi> x'))) =\n    (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom f).\n        \\<phi>\n         (restrict (S.Fun g \\<circ> S.Fun f) (S.set (S.dom f)) (\\<psi> x')))", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom f).\n      \\<phi> (S.Fun (g \\<cdot> f) (\\<psi> x'))) =\n  (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom f).\n      \\<phi>\n       (restrict (S.Fun g \\<circ> S.Fun f) (S.set (S.dom f)) (\\<psi> x')))\n\ngoal (1 subgoal):\n 1. \\<Phi>a (g \\<cdot> f) =\n    restrict (\\<Phi>a g \\<circ> \\<Phi>a f) (S'.set (\\<Phi>o (S.dom f)))", "also"], ["proof (state)\nthis:\n  (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom f).\n      \\<phi> (S.Fun (g \\<cdot> f) (\\<psi> x'))) =\n  (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom f).\n      \\<phi>\n       (restrict (S.Fun g \\<circ> S.Fun f) (S.set (S.dom f)) (\\<psi> x')))\n\ngoal (1 subgoal):\n 1. \\<Phi>a (g \\<cdot> f) =\n    restrict (\\<Phi>a g \\<circ> \\<Phi>a f) (S'.set (\\<Phi>o (S.dom f)))", "have \"... = restrict (\\<Phi>a g o \\<Phi>a f) (S'.set (\\<Phi>o (S.dom f)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom f).\n        \\<phi>\n         (restrict (S.Fun g \\<circ> S.Fun f) (S.set (S.dom f))\n           (\\<psi> x'))) =\n    restrict (\\<Phi>a g \\<circ> \\<Phi>a f) (S'.set (\\<Phi>o (S.dom f)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom f).\n        \\<phi>\n         (restrict (S.Fun g \\<circ> S.Fun f) (S.set (S.dom f))\n           (\\<psi> x'))) =\n    restrict (\\<Phi>a g \\<circ> \\<Phi>a f) (S'.set (\\<Phi>o (S.dom f)))", "have \"\\<And>x'. x' \\<in> \\<phi> ` S.set (S.dom f)\n                 \\<Longrightarrow> \\<phi> (restrict (S.Fun g o S.Fun f) (S.set (S.dom f)) (\\<psi> x')) = \\<Phi>a g (\\<Phi>a f x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x'.\n       x' \\<in> \\<phi> ` S.set (S.dom f) \\<Longrightarrow>\n       \\<phi>\n        (restrict (S.Fun g \\<circ> S.Fun f) (S.set (S.dom f)) (\\<psi> x')) =\n       \\<Phi>a g (\\<Phi>a f x')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x'.\n       x' \\<in> \\<phi> ` S.set (S.dom f) \\<Longrightarrow>\n       \\<phi>\n        (restrict (S.Fun g \\<circ> S.Fun f) (S.set (S.dom f)) (\\<psi> x')) =\n       \\<Phi>a g (\\<Phi>a f x')", "fix x'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x'.\n       x' \\<in> \\<phi> ` S.set (S.dom f) \\<Longrightarrow>\n       \\<phi>\n        (restrict (S.Fun g \\<circ> S.Fun f) (S.set (S.dom f)) (\\<psi> x')) =\n       \\<Phi>a g (\\<Phi>a f x')", "assume X': \"x' \\<in> \\<phi> ` S.set (S.dom f)\""], ["proof (state)\nthis:\n  x' \\<in> \\<phi> ` S.set (S.dom f)\n\ngoal (1 subgoal):\n 1. \\<And>x'.\n       x' \\<in> \\<phi> ` S.set (S.dom f) \\<Longrightarrow>\n       \\<phi>\n        (restrict (S.Fun g \\<circ> S.Fun f) (S.set (S.dom f)) (\\<psi> x')) =\n       \\<Phi>a g (\\<Phi>a f x')", "hence 1: \"\\<psi> x' \\<in> S.set (S.dom f)\""], ["proof (prove)\nusing this:\n  x' \\<in> \\<phi> ` S.set (S.dom f)\n\ngoal (1 subgoal):\n 1. \\<psi> x' \\<in> S.set (S.dom f)", "using gf \\<psi>_img_\\<phi>_img [of \"S.set (S.dom f)\"] S.set_subset_Univ S.ide_dom"], ["proof (prove)\nusing this:\n  x' \\<in> \\<phi> ` S.set (S.dom f)\n  S.seq g f\n  S.set (S.dom f) \\<subseteq> S.Univ \\<Longrightarrow>\n  \\<psi> ` \\<phi> ` S.set (S.dom f) = S.set (S.dom f)\n  S.ide ?a \\<Longrightarrow> S.set ?a \\<subseteq> S.Univ\n  S.arr ?f \\<Longrightarrow> S.ide (S.dom ?f)\n\ngoal (1 subgoal):\n 1. \\<psi> x' \\<in> S.set (S.dom f)", "by blast"], ["proof (state)\nthis:\n  \\<psi> x' \\<in> S.set (S.dom f)\n\ngoal (1 subgoal):\n 1. \\<And>x'.\n       x' \\<in> \\<phi> ` S.set (S.dom f) \\<Longrightarrow>\n       \\<phi>\n        (restrict (S.Fun g \\<circ> S.Fun f) (S.set (S.dom f)) (\\<psi> x')) =\n       \\<Phi>a g (\\<Phi>a f x')", "hence \"\\<phi> (restrict (S.Fun g o S.Fun f) (S.set (S.dom f)) (\\<psi> x'))\n                   = \\<phi> (S.Fun g (S.Fun f (\\<psi> x')))\""], ["proof (prove)\nusing this:\n  \\<psi> x' \\<in> S.set (S.dom f)\n\ngoal (1 subgoal):\n 1. \\<phi>\n     (restrict (S.Fun g \\<circ> S.Fun f) (S.set (S.dom f)) (\\<psi> x')) =\n    \\<phi> (S.Fun g (S.Fun f (\\<psi> x')))", "using restrict_apply"], ["proof (prove)\nusing this:\n  \\<psi> x' \\<in> S.set (S.dom f)\n  restrict ?f ?A ?x = (if ?x \\<in> ?A then ?f ?x else undefined)\n\ngoal (1 subgoal):\n 1. \\<phi>\n     (restrict (S.Fun g \\<circ> S.Fun f) (S.set (S.dom f)) (\\<psi> x')) =\n    \\<phi> (S.Fun g (S.Fun f (\\<psi> x')))", "by auto"], ["proof (state)\nthis:\n  \\<phi>\n   (restrict (S.Fun g \\<circ> S.Fun f) (S.set (S.dom f)) (\\<psi> x')) =\n  \\<phi> (S.Fun g (S.Fun f (\\<psi> x')))\n\ngoal (1 subgoal):\n 1. \\<And>x'.\n       x' \\<in> \\<phi> ` S.set (S.dom f) \\<Longrightarrow>\n       \\<phi>\n        (restrict (S.Fun g \\<circ> S.Fun f) (S.set (S.dom f)) (\\<psi> x')) =\n       \\<Phi>a g (\\<Phi>a f x')", "also"], ["proof (state)\nthis:\n  \\<phi>\n   (restrict (S.Fun g \\<circ> S.Fun f) (S.set (S.dom f)) (\\<psi> x')) =\n  \\<phi> (S.Fun g (S.Fun f (\\<psi> x')))\n\ngoal (1 subgoal):\n 1. \\<And>x'.\n       x' \\<in> \\<phi> ` S.set (S.dom f) \\<Longrightarrow>\n       \\<phi>\n        (restrict (S.Fun g \\<circ> S.Fun f) (S.set (S.dom f)) (\\<psi> x')) =\n       \\<Phi>a g (\\<Phi>a f x')", "have \"... = \\<phi> (S.Fun g (\\<psi> (\\<phi> (S.Fun f (\\<psi> x')))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> (S.Fun g (S.Fun f (\\<psi> x'))) =\n    \\<phi> (S.Fun g (\\<psi> (\\<phi> (S.Fun f (\\<psi> x')))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<phi> (S.Fun g (S.Fun f (\\<psi> x'))) =\n    \\<phi> (S.Fun g (\\<psi> (\\<phi> (S.Fun f (\\<psi> x')))))", "have \"S.Fun f (\\<psi> x') \\<in> S.set (S.cod f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.Fun f (\\<psi> x') \\<in> S.set (S.cod f)", "using gf 1 S.Fun_mapsto"], ["proof (prove)\nusing this:\n  S.seq g f\n  \\<psi> x' \\<in> S.set (S.dom f)\n  S.arr ?f \\<Longrightarrow>\n  S.Fun ?f\n  \\<in> extensional (S.set (S.dom ?f)) \\<inter>\n        (S.set (S.dom ?f) \\<rightarrow> S.set (S.cod ?f))\n\ngoal (1 subgoal):\n 1. S.Fun f (\\<psi> x') \\<in> S.set (S.cod f)", "by fast"], ["proof (state)\nthis:\n  S.Fun f (\\<psi> x') \\<in> S.set (S.cod f)\n\ngoal (1 subgoal):\n 1. \\<phi> (S.Fun g (S.Fun f (\\<psi> x'))) =\n    \\<phi> (S.Fun g (\\<psi> (\\<phi> (S.Fun f (\\<psi> x')))))", "hence \"\\<psi> (\\<phi> (S.Fun f (\\<psi> x'))) = S.Fun f (\\<psi> x')\""], ["proof (prove)\nusing this:\n  S.Fun f (\\<psi> x') \\<in> S.set (S.cod f)\n\ngoal (1 subgoal):\n 1. \\<psi> (\\<phi> (S.Fun f (\\<psi> x'))) = S.Fun f (\\<psi> x')", "using assms bij_\\<phi> S.set_subset_Univ bij_betw_def inv_into_f_f subsetCE S.ide_cod"], ["proof (prove)\nusing this:\n  S.Fun f (\\<psi> x') \\<in> S.set (S.cod f)\n  S.seq g f\n  bij_betw \\<phi> S.Univ S'.Univ\n  S.ide ?a \\<Longrightarrow> S.set ?a \\<subseteq> S.Univ\n  bij_betw ?f ?A ?B = (inj_on ?f ?A \\<and> ?f ` ?A = ?B)\n  \\<lbrakk>inj_on ?f ?A; ?x \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> inv_into ?A ?f (?f ?x) = ?x\n  \\<lbrakk>?A \\<subseteq> ?B; ?c \\<notin> ?A \\<Longrightarrow> ?P;\n   ?c \\<in> ?B \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  S.arr ?f \\<Longrightarrow> S.ide (S.cod ?f)\n\ngoal (1 subgoal):\n 1. \\<psi> (\\<phi> (S.Fun f (\\<psi> x'))) = S.Fun f (\\<psi> x')", "by (metis S.seqE)"], ["proof (state)\nthis:\n  \\<psi> (\\<phi> (S.Fun f (\\<psi> x'))) = S.Fun f (\\<psi> x')\n\ngoal (1 subgoal):\n 1. \\<phi> (S.Fun g (S.Fun f (\\<psi> x'))) =\n    \\<phi> (S.Fun g (\\<psi> (\\<phi> (S.Fun f (\\<psi> x')))))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<psi> (\\<phi> (S.Fun f (\\<psi> x'))) = S.Fun f (\\<psi> x')\n\ngoal (1 subgoal):\n 1. \\<phi> (S.Fun g (S.Fun f (\\<psi> x'))) =\n    \\<phi> (S.Fun g (\\<psi> (\\<phi> (S.Fun f (\\<psi> x')))))", "by auto"], ["proof (state)\nthis:\n  \\<phi> (S.Fun g (S.Fun f (\\<psi> x'))) =\n  \\<phi> (S.Fun g (\\<psi> (\\<phi> (S.Fun f (\\<psi> x')))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<phi> (S.Fun g (S.Fun f (\\<psi> x'))) =\n  \\<phi> (S.Fun g (\\<psi> (\\<phi> (S.Fun f (\\<psi> x')))))\n\ngoal (1 subgoal):\n 1. \\<And>x'.\n       x' \\<in> \\<phi> ` S.set (S.dom f) \\<Longrightarrow>\n       \\<phi>\n        (restrict (S.Fun g \\<circ> S.Fun f) (S.set (S.dom f)) (\\<psi> x')) =\n       \\<Phi>a g (\\<Phi>a f x')", "also"], ["proof (state)\nthis:\n  \\<phi> (S.Fun g (S.Fun f (\\<psi> x'))) =\n  \\<phi> (S.Fun g (\\<psi> (\\<phi> (S.Fun f (\\<psi> x')))))\n\ngoal (1 subgoal):\n 1. \\<And>x'.\n       x' \\<in> \\<phi> ` S.set (S.dom f) \\<Longrightarrow>\n       \\<phi>\n        (restrict (S.Fun g \\<circ> S.Fun f) (S.set (S.dom f)) (\\<psi> x')) =\n       \\<Phi>a g (\\<Phi>a f x')", "have \"... = \\<Phi>a g (\\<Phi>a f x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> (S.Fun g (\\<psi> (\\<phi> (S.Fun f (\\<psi> x'))))) =\n    \\<Phi>a g (\\<Phi>a f x')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<phi> (S.Fun g (\\<psi> (\\<phi> (S.Fun f (\\<psi> x'))))) =\n    \\<Phi>a g (\\<Phi>a f x')", "have \"\\<Phi>a f x' \\<in> \\<phi> ` S.set (S.cod f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi>a f x' \\<in> \\<phi> ` S.set (S.cod f)", "using gf S.ide_dom S.ide_cod X' \\<Phi>a_mapsto [of f] set_\\<Phi>o [of \"S.dom f\"]\n                    set_\\<Phi>o [of \"S.cod f\"]"], ["proof (prove)\nusing this:\n  S.seq g f\n  S.arr ?f \\<Longrightarrow> S.ide (S.dom ?f)\n  S.arr ?f \\<Longrightarrow> S.ide (S.cod ?f)\n  x' \\<in> \\<phi> ` S.set (S.dom f)\n  S.arr f \\<Longrightarrow>\n  \\<Phi>a f\n  \\<in> S'.set (\\<Phi>o (S.dom f)) \\<rightarrow> S'.set (\\<Phi>o (S.cod f))\n  S.ide (S.dom f) \\<Longrightarrow>\n  S'.set (\\<Phi>o (S.dom f)) = \\<phi> ` S.set (S.dom f)\n  S.ide (S.cod f) \\<Longrightarrow>\n  S'.set (\\<Phi>o (S.cod f)) = \\<phi> ` S.set (S.cod f)\n\ngoal (1 subgoal):\n 1. \\<Phi>a f x' \\<in> \\<phi> ` S.set (S.cod f)", "by blast"], ["proof (state)\nthis:\n  \\<Phi>a f x' \\<in> \\<phi> ` S.set (S.cod f)\n\ngoal (1 subgoal):\n 1. \\<phi> (S.Fun g (\\<psi> (\\<phi> (S.Fun f (\\<psi> x'))))) =\n    \\<Phi>a g (\\<Phi>a f x')", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<Phi>a f x' \\<in> \\<phi> ` S.set (S.cod f)\n\ngoal (1 subgoal):\n 1. \\<phi> (S.Fun g (\\<psi> (\\<phi> (S.Fun f (\\<psi> x'))))) =\n    \\<Phi>a g (\\<Phi>a f x')", "using gf X' \\<Phi>a_def"], ["proof (prove)\nusing this:\n  \\<Phi>a f x' \\<in> \\<phi> ` S.set (S.cod f)\n  S.seq g f\n  x' \\<in> \\<phi> ` S.set (S.dom f)\n  \\<Phi>a =\n  (\\<lambda>f.\n      \\<lambda>x'\\<in>\\<phi> ` S.set (S.dom f).\n         \\<phi> (S.Fun f (\\<psi> x')))\n\ngoal (1 subgoal):\n 1. \\<phi> (S.Fun g (\\<psi> (\\<phi> (S.Fun f (\\<psi> x'))))) =\n    \\<Phi>a g (\\<Phi>a f x')", "by auto"], ["proof (state)\nthis:\n  \\<phi> (S.Fun g (\\<psi> (\\<phi> (S.Fun f (\\<psi> x'))))) =\n  \\<Phi>a g (\\<Phi>a f x')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<phi> (S.Fun g (\\<psi> (\\<phi> (S.Fun f (\\<psi> x'))))) =\n  \\<Phi>a g (\\<Phi>a f x')\n\ngoal (1 subgoal):\n 1. \\<And>x'.\n       x' \\<in> \\<phi> ` S.set (S.dom f) \\<Longrightarrow>\n       \\<phi>\n        (restrict (S.Fun g \\<circ> S.Fun f) (S.set (S.dom f)) (\\<psi> x')) =\n       \\<Phi>a g (\\<Phi>a f x')", "finally"], ["proof (chain)\npicking this:\n  \\<phi>\n   (restrict (S.Fun g \\<circ> S.Fun f) (S.set (S.dom f)) (\\<psi> x')) =\n  \\<Phi>a g (\\<Phi>a f x')", "show \"\\<phi> (restrict (S.Fun g o S.Fun f) (S.set (S.dom f)) (\\<psi> x')) =\n                        \\<Phi>a g (\\<Phi>a f x')\""], ["proof (prove)\nusing this:\n  \\<phi>\n   (restrict (S.Fun g \\<circ> S.Fun f) (S.set (S.dom f)) (\\<psi> x')) =\n  \\<Phi>a g (\\<Phi>a f x')\n\ngoal (1 subgoal):\n 1. \\<phi>\n     (restrict (S.Fun g \\<circ> S.Fun f) (S.set (S.dom f)) (\\<psi> x')) =\n    \\<Phi>a g (\\<Phi>a f x')", "by auto"], ["proof (state)\nthis:\n  \\<phi>\n   (restrict (S.Fun g \\<circ> S.Fun f) (S.set (S.dom f)) (\\<psi> x')) =\n  \\<Phi>a g (\\<Phi>a f x')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x' \\<in> \\<phi> ` S.set (S.dom f) \\<Longrightarrow>\n  \\<phi>\n   (restrict (S.Fun g \\<circ> S.Fun f) (S.set (S.dom f)) (\\<psi> ?x')) =\n  \\<Phi>a g (\\<Phi>a f ?x')\n\ngoal (1 subgoal):\n 1. (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom f).\n        \\<phi>\n         (restrict (S.Fun g \\<circ> S.Fun f) (S.set (S.dom f))\n           (\\<psi> x'))) =\n    restrict (\\<Phi>a g \\<circ> \\<Phi>a f) (S'.set (\\<Phi>o (S.dom f)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?x' \\<in> \\<phi> ` S.set (S.dom f) \\<Longrightarrow>\n  \\<phi>\n   (restrict (S.Fun g \\<circ> S.Fun f) (S.set (S.dom f)) (\\<psi> ?x')) =\n  \\<Phi>a g (\\<Phi>a f ?x')\n\ngoal (1 subgoal):\n 1. (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom f).\n        \\<phi>\n         (restrict (S.Fun g \\<circ> S.Fun f) (S.set (S.dom f))\n           (\\<psi> x'))) =\n    restrict (\\<Phi>a g \\<circ> \\<Phi>a f) (S'.set (\\<Phi>o (S.dom f)))", "using assms set_\\<Phi>o"], ["proof (prove)\nusing this:\n  ?x' \\<in> \\<phi> ` S.set (S.dom f) \\<Longrightarrow>\n  \\<phi>\n   (restrict (S.Fun g \\<circ> S.Fun f) (S.set (S.dom f)) (\\<psi> ?x')) =\n  \\<Phi>a g (\\<Phi>a f ?x')\n  S.seq g f\n  S.ide ?a \\<Longrightarrow> S'.set (\\<Phi>o ?a) = \\<phi> ` S.set ?a\n\ngoal (1 subgoal):\n 1. (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom f).\n        \\<phi>\n         (restrict (S.Fun g \\<circ> S.Fun f) (S.set (S.dom f))\n           (\\<psi> x'))) =\n    restrict (\\<Phi>a g \\<circ> \\<Phi>a f) (S'.set (\\<Phi>o (S.dom f)))", "by fastforce"], ["proof (state)\nthis:\n  (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom f).\n      \\<phi>\n       (restrict (S.Fun g \\<circ> S.Fun f) (S.set (S.dom f)) (\\<psi> x'))) =\n  restrict (\\<Phi>a g \\<circ> \\<Phi>a f) (S'.set (\\<Phi>o (S.dom f)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom f).\n      \\<phi>\n       (restrict (S.Fun g \\<circ> S.Fun f) (S.set (S.dom f)) (\\<psi> x'))) =\n  restrict (\\<Phi>a g \\<circ> \\<Phi>a f) (S'.set (\\<Phi>o (S.dom f)))\n\ngoal (1 subgoal):\n 1. \\<Phi>a (g \\<cdot> f) =\n    restrict (\\<Phi>a g \\<circ> \\<Phi>a f) (S'.set (\\<Phi>o (S.dom f)))", "finally"], ["proof (chain)\npicking this:\n  \\<Phi>a (g \\<cdot> f) =\n  restrict (\\<Phi>a g \\<circ> \\<Phi>a f) (S'.set (\\<Phi>o (S.dom f)))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Phi>a (g \\<cdot> f) =\n  restrict (\\<Phi>a g \\<circ> \\<Phi>a f) (S'.set (\\<Phi>o (S.dom f)))\n\ngoal (1 subgoal):\n 1. \\<Phi>a (g \\<cdot> f) =\n    restrict (\\<Phi>a g \\<circ> \\<Phi>a f) (S'.set (\\<Phi>o (S.dom f)))", "by auto"], ["proof (state)\nthis:\n  \\<Phi>a (g \\<cdot> f) =\n  restrict (\\<Phi>a g \\<circ> \\<Phi>a f) (S'.set (\\<Phi>o (S.dom f)))\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n      Finally, we use @{term \\<Phi>o} and @{term \\<Phi>a} to define a functor @{term \\<Phi>}.\n\\<close>"], ["", "definition \\<Phi>\n    where \"\\<Phi> f = (if S.arr f then\n                     S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod f))) (\\<Phi>a f)\n                   else S'.null)\""], ["", "lemma \\<Phi>_in_hom:\n    assumes \"S.arr f\"\n    shows \"\\<Phi> f \\<in> S'.hom (\\<Phi>o (S.dom f)) (\\<Phi>o (S.cod f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> f \\<in> S'.hom (\\<Phi>o (S.dom f)) (\\<Phi>o (S.cod f))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi> f \\<in> S'.hom (\\<Phi>o (S.dom f)) (\\<Phi>o (S.cod f))", "have \"\\<guillemotleft>\\<Phi> f : S'.dom (\\<Phi> f) \\<rightarrow>' S'.cod (\\<Phi> f)\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<Phi>\n                     f : S'.dom\n                          (\\<Phi>\n                            f) \\<rightarrow>' S'.cod\n         (\\<Phi> f)\\<guillemotright>", "using assms \\<Phi>_def [of f] \\<Phi>a_mapsto [of f] \\<Phi>o_preserves_ide S'.set_card S'.arr_mkArr"], ["proof (prove)\nusing this:\n  S.arr f\n  \\<Phi> f =\n  (if S.arr f\n   then S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod f)))\n         (\\<Phi>a f)\n   else S'.null)\n  S.arr f \\<Longrightarrow>\n  \\<Phi>a f\n  \\<in> S'.set (\\<Phi>o (S.dom f)) \\<rightarrow> S'.set (\\<Phi>o (S.cod f))\n  S.ide ?a \\<Longrightarrow> S'.ide (\\<Phi>o ?a)\n  S'.ide ?a \\<Longrightarrow> |S'.set ?a| <o \\<AA>\n  S'.arr (S'.mkArr ?A ?B ?F) =\n  (?A \\<subseteq> S'.Univ \\<and>\n   |?A| <o \\<AA> \\<and>\n   ?B \\<subseteq> S'.Univ \\<and>\n   |?B| <o \\<AA> \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<Phi>\n                     f : S'.dom\n                          (\\<Phi>\n                            f) \\<rightarrow>' S'.cod\n         (\\<Phi> f)\\<guillemotright>", "by (intro S'.in_homI) auto"], ["proof (state)\nthis:\n  \\<guillemotleft>\\<Phi>\n                   f : S'.dom\n                        (\\<Phi>\n                          f) \\<rightarrow>' S'.cod\n       (\\<Phi> f)\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<Phi> f \\<in> S'.hom (\\<Phi>o (S.dom f)) (\\<Phi>o (S.cod f))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<guillemotleft>\\<Phi>\n                   f : S'.dom\n                        (\\<Phi>\n                          f) \\<rightarrow>' S'.cod\n       (\\<Phi> f)\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<Phi> f \\<in> S'.hom (\\<Phi>o (S.dom f)) (\\<Phi>o (S.cod f))", "using assms \\<Phi>_def \\<Phi>a_mapsto \\<Phi>o_preserves_ide S'.set_card S'.arr_mkArr S'.mkIde_set"], ["proof (prove)\nusing this:\n  \\<guillemotleft>\\<Phi>\n                   f : S'.dom\n                        (\\<Phi>\n                          f) \\<rightarrow>' S'.cod\n       (\\<Phi> f)\\<guillemotright>\n  S.arr f\n  \\<Phi> ?f =\n  (if S.arr ?f\n   then S'.mkArr (S'.set (\\<Phi>o (S.dom ?f))) (S'.set (\\<Phi>o (S.cod ?f)))\n         (\\<Phi>a ?f)\n   else S'.null)\n  S.arr ?f \\<Longrightarrow>\n  \\<Phi>a ?f\n  \\<in> S'.set (\\<Phi>o (S.dom ?f)) \\<rightarrow>\n        S'.set (\\<Phi>o (S.cod ?f))\n  S.ide ?a \\<Longrightarrow> S'.ide (\\<Phi>o ?a)\n  S'.ide ?a \\<Longrightarrow> |S'.set ?a| <o \\<AA>\n  S'.arr (S'.mkArr ?A ?B ?F) =\n  (?A \\<subseteq> S'.Univ \\<and>\n   |?A| <o \\<AA> \\<and>\n   ?B \\<subseteq> S'.Univ \\<and>\n   |?B| <o \\<AA> \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n  S'.ide ?a \\<Longrightarrow> S'.mkIde (S'.set ?a) = ?a\n\ngoal (1 subgoal):\n 1. \\<Phi> f \\<in> S'.hom (\\<Phi>o (S.dom f)) (\\<Phi>o (S.cod f))", "by auto"], ["proof (state)\nthis:\n  \\<Phi> f \\<in> S'.hom (\\<Phi>o (S.dom f)) (\\<Phi>o (S.cod f))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<Phi>_ide [simp]:\n    assumes \"S.ide a\"\n    shows \"\\<Phi> a = \\<Phi>o a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> a = \\<Phi>o a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi> a = \\<Phi>o a", "have \"\\<Phi> a = S'.mkArr (S'.set (\\<Phi>o a)) (S'.set (\\<Phi>o a)) (\\<lambda>x'. x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> a =\n    S'.mkArr (S'.set (\\<Phi>o a)) (S'.set (\\<Phi>o a)) (\\<lambda>x'. x')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi> a =\n    S'.mkArr (S'.set (\\<Phi>o a)) (S'.set (\\<Phi>o a)) (\\<lambda>x'. x')", "have \"\\<guillemotleft>\\<Phi> a : \\<Phi>o a \\<rightarrow>' \\<Phi>o a\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<Phi>\n                     a : \\<Phi>o a \\<rightarrow>' \\<Phi>o a\\<guillemotright>", "using assms \\<Phi>_in_hom S.ide_in_hom"], ["proof (prove)\nusing this:\n  S.ide a\n  S.arr ?f \\<Longrightarrow>\n  \\<Phi> ?f \\<in> S'.hom (\\<Phi>o (S.dom ?f)) (\\<Phi>o (S.cod ?f))\n  S.ide ?a = \\<guillemotleft>?a : ?a \\<rightarrow> ?a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<Phi>\n                     a : \\<Phi>o a \\<rightarrow>' \\<Phi>o a\\<guillemotright>", "by fastforce"], ["proof (state)\nthis:\n  \\<guillemotleft>\\<Phi>\n                   a : \\<Phi>o a \\<rightarrow>' \\<Phi>o a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<Phi> a =\n    S'.mkArr (S'.set (\\<Phi>o a)) (S'.set (\\<Phi>o a)) (\\<lambda>x'. x')", "moreover"], ["proof (state)\nthis:\n  \\<guillemotleft>\\<Phi>\n                   a : \\<Phi>o a \\<rightarrow>' \\<Phi>o a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<Phi> a =\n    S'.mkArr (S'.set (\\<Phi>o a)) (S'.set (\\<Phi>o a)) (\\<lambda>x'. x')", "have \"\\<Phi>a a = restrict (\\<lambda>x'. x') (S'.set (\\<Phi>o a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi>a a = (\\<lambda>x'\\<in>S'.set (\\<Phi>o a). x')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi>a a = (\\<lambda>x'\\<in>S'.set (\\<Phi>o a). x')", "have \"\\<Phi>a a = (\\<lambda>x' \\<in> \\<phi> ` S.set a. \\<phi> (S.Fun a (\\<psi> x')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi>a a =\n    (\\<lambda>x'\\<in>\\<phi> ` S.set a. \\<phi> (S.Fun a (\\<psi> x')))", "using assms \\<Phi>a_def restrict_apply"], ["proof (prove)\nusing this:\n  S.ide a\n  \\<Phi>a =\n  (\\<lambda>f.\n      \\<lambda>x'\\<in>\\<phi> ` S.set (S.dom f).\n         \\<phi> (S.Fun f (\\<psi> x')))\n  restrict ?f ?A ?x = (if ?x \\<in> ?A then ?f ?x else undefined)\n\ngoal (1 subgoal):\n 1. \\<Phi>a a =\n    (\\<lambda>x'\\<in>\\<phi> ` S.set a. \\<phi> (S.Fun a (\\<psi> x')))", "by auto"], ["proof (state)\nthis:\n  \\<Phi>a a =\n  (\\<lambda>x'\\<in>\\<phi> ` S.set a. \\<phi> (S.Fun a (\\<psi> x')))\n\ngoal (1 subgoal):\n 1. \\<Phi>a a = (\\<lambda>x'\\<in>S'.set (\\<Phi>o a). x')", "also"], ["proof (state)\nthis:\n  \\<Phi>a a =\n  (\\<lambda>x'\\<in>\\<phi> ` S.set a. \\<phi> (S.Fun a (\\<psi> x')))\n\ngoal (1 subgoal):\n 1. \\<Phi>a a = (\\<lambda>x'\\<in>S'.set (\\<Phi>o a). x')", "have \"... = (\\<lambda>x' \\<in> S'.set (\\<Phi>o a). \\<phi> (\\<psi> x'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x'\\<in>\\<phi> ` S.set a. \\<phi> (S.Fun a (\\<psi> x'))) =\n    (\\<lambda>x'\\<in>S'.set (\\<Phi>o a). \\<phi> (\\<psi> x'))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>x'\\<in>\\<phi> ` S.set a. \\<phi> (S.Fun a (\\<psi> x'))) =\n    (\\<lambda>x'\\<in>S'.set (\\<Phi>o a). \\<phi> (\\<psi> x'))", "have \"S.Fun a = (\\<lambda>x \\<in> S.set a. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.Fun a = (\\<lambda>x\\<in>S.set a. x)", "using assms S.Fun_ide"], ["proof (prove)\nusing this:\n  S.ide a\n  S.ide ?a \\<Longrightarrow> S.Fun ?a = (\\<lambda>x\\<in>S.set ?a. x)\n\ngoal (1 subgoal):\n 1. S.Fun a = (\\<lambda>x\\<in>S.set a. x)", "by simp"], ["proof (state)\nthis:\n  S.Fun a = (\\<lambda>x\\<in>S.set a. x)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x'\\<in>\\<phi> ` S.set a. \\<phi> (S.Fun a (\\<psi> x'))) =\n    (\\<lambda>x'\\<in>S'.set (\\<Phi>o a). \\<phi> (\\<psi> x'))", "moreover"], ["proof (state)\nthis:\n  S.Fun a = (\\<lambda>x\\<in>S.set a. x)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x'\\<in>\\<phi> ` S.set a. \\<phi> (S.Fun a (\\<psi> x'))) =\n    (\\<lambda>x'\\<in>S'.set (\\<Phi>o a). \\<phi> (\\<psi> x'))", "have \"\\<And>x'. x' \\<in> \\<phi> ` S.set a \\<Longrightarrow> \\<psi> x' \\<in> S.set a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x'.\n       x' \\<in> \\<phi> ` S.set a \\<Longrightarrow> \\<psi> x' \\<in> S.set a", "using assms bij_\\<phi> S.set_subset_Univ image_iff"], ["proof (prove)\nusing this:\n  S.ide a\n  bij_betw \\<phi> S.Univ S'.Univ\n  S.ide ?a \\<Longrightarrow> S.set ?a \\<subseteq> S.Univ\n  (?z \\<in> ?f ` ?A) = (\\<exists>x\\<in>?A. ?z = ?f x)\n\ngoal (1 subgoal):\n 1. \\<And>x'.\n       x' \\<in> \\<phi> ` S.set a \\<Longrightarrow> \\<psi> x' \\<in> S.set a", "by (metis \\<psi>_img_\\<phi>_img)"], ["proof (state)\nthis:\n  ?x' \\<in> \\<phi> ` S.set a \\<Longrightarrow> \\<psi> ?x' \\<in> S.set a\n\ngoal (1 subgoal):\n 1. (\\<lambda>x'\\<in>\\<phi> ` S.set a. \\<phi> (S.Fun a (\\<psi> x'))) =\n    (\\<lambda>x'\\<in>S'.set (\\<Phi>o a). \\<phi> (\\<psi> x'))", "ultimately"], ["proof (chain)\npicking this:\n  S.Fun a = (\\<lambda>x\\<in>S.set a. x)\n  ?x' \\<in> \\<phi> ` S.set a \\<Longrightarrow> \\<psi> ?x' \\<in> S.set a", "show ?thesis"], ["proof (prove)\nusing this:\n  S.Fun a = (\\<lambda>x\\<in>S.set a. x)\n  ?x' \\<in> \\<phi> ` S.set a \\<Longrightarrow> \\<psi> ?x' \\<in> S.set a\n\ngoal (1 subgoal):\n 1. (\\<lambda>x'\\<in>\\<phi> ` S.set a. \\<phi> (S.Fun a (\\<psi> x'))) =\n    (\\<lambda>x'\\<in>S'.set (\\<Phi>o a). \\<phi> (\\<psi> x'))", "using assms set_\\<Phi>o"], ["proof (prove)\nusing this:\n  S.Fun a = (\\<lambda>x\\<in>S.set a. x)\n  ?x' \\<in> \\<phi> ` S.set a \\<Longrightarrow> \\<psi> ?x' \\<in> S.set a\n  S.ide a\n  S.ide ?a \\<Longrightarrow> S'.set (\\<Phi>o ?a) = \\<phi> ` S.set ?a\n\ngoal (1 subgoal):\n 1. (\\<lambda>x'\\<in>\\<phi> ` S.set a. \\<phi> (S.Fun a (\\<psi> x'))) =\n    (\\<lambda>x'\\<in>S'.set (\\<Phi>o a). \\<phi> (\\<psi> x'))", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x'\\<in>\\<phi> ` S.set a. \\<phi> (S.Fun a (\\<psi> x'))) =\n  (\\<lambda>x'\\<in>S'.set (\\<Phi>o a). \\<phi> (\\<psi> x'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>x'\\<in>\\<phi> ` S.set a. \\<phi> (S.Fun a (\\<psi> x'))) =\n  (\\<lambda>x'\\<in>S'.set (\\<Phi>o a). \\<phi> (\\<psi> x'))\n\ngoal (1 subgoal):\n 1. \\<Phi>a a = (\\<lambda>x'\\<in>S'.set (\\<Phi>o a). x')", "also"], ["proof (state)\nthis:\n  (\\<lambda>x'\\<in>\\<phi> ` S.set a. \\<phi> (S.Fun a (\\<psi> x'))) =\n  (\\<lambda>x'\\<in>S'.set (\\<Phi>o a). \\<phi> (\\<psi> x'))\n\ngoal (1 subgoal):\n 1. \\<Phi>a a = (\\<lambda>x'\\<in>S'.set (\\<Phi>o a). x')", "have \"... = restrict (\\<lambda>x'. x') (S'.set (\\<Phi>o a))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x'\\<in>S'.set (\\<Phi>o a). \\<phi> (\\<psi> x')) =\n    (\\<lambda>x'\\<in>S'.set (\\<Phi>o a). x')", "using assms S'.set_subset_Univ \\<Phi>o_preserves_ide \\<phi>_\\<psi>"], ["proof (prove)\nusing this:\n  S.ide a\n  S'.ide ?a \\<Longrightarrow> S'.set ?a \\<subseteq> S'.Univ\n  S.ide ?a \\<Longrightarrow> S'.ide (\\<Phi>o ?a)\n  ?t' \\<in> S'.Univ \\<Longrightarrow> \\<phi> (\\<psi> ?t') = ?t'\n\ngoal (1 subgoal):\n 1. (\\<lambda>x'\\<in>S'.set (\\<Phi>o a). \\<phi> (\\<psi> x')) =\n    (\\<lambda>x'\\<in>S'.set (\\<Phi>o a). x')", "by (meson restr_eqI subsetCE)"], ["proof (state)\nthis:\n  (\\<lambda>x'\\<in>S'.set (\\<Phi>o a). \\<phi> (\\<psi> x')) =\n  (\\<lambda>x'\\<in>S'.set (\\<Phi>o a). x')\n\ngoal (1 subgoal):\n 1. \\<Phi>a a = (\\<lambda>x'\\<in>S'.set (\\<Phi>o a). x')", "ultimately"], ["proof (chain)\npicking this:\n  \\<Phi>a a = (\\<lambda>x'\\<in>S'.set (\\<Phi>o a). \\<phi> (\\<psi> x'))\n  (\\<lambda>x'\\<in>S'.set (\\<Phi>o a). \\<phi> (\\<psi> x')) =\n  (\\<lambda>x'\\<in>S'.set (\\<Phi>o a). x')", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Phi>a a = (\\<lambda>x'\\<in>S'.set (\\<Phi>o a). \\<phi> (\\<psi> x'))\n  (\\<lambda>x'\\<in>S'.set (\\<Phi>o a). \\<phi> (\\<psi> x')) =\n  (\\<lambda>x'\\<in>S'.set (\\<Phi>o a). x')\n\ngoal (1 subgoal):\n 1. \\<Phi>a a = (\\<lambda>x'\\<in>S'.set (\\<Phi>o a). x')", "by auto"], ["proof (state)\nthis:\n  \\<Phi>a a = (\\<lambda>x'\\<in>S'.set (\\<Phi>o a). x')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Phi>a a = (\\<lambda>x'\\<in>S'.set (\\<Phi>o a). x')\n\ngoal (1 subgoal):\n 1. \\<Phi> a =\n    S'.mkArr (S'.set (\\<Phi>o a)) (S'.set (\\<Phi>o a)) (\\<lambda>x'. x')", "ultimately"], ["proof (chain)\npicking this:\n  \\<guillemotleft>\\<Phi>\n                   a : \\<Phi>o a \\<rightarrow>' \\<Phi>o a\\<guillemotright>\n  \\<Phi>a a = (\\<lambda>x'\\<in>S'.set (\\<Phi>o a). x')", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<guillemotleft>\\<Phi>\n                   a : \\<Phi>o a \\<rightarrow>' \\<Phi>o a\\<guillemotright>\n  \\<Phi>a a = (\\<lambda>x'\\<in>S'.set (\\<Phi>o a). x')\n\ngoal (1 subgoal):\n 1. \\<Phi> a =\n    S'.mkArr (S'.set (\\<Phi>o a)) (S'.set (\\<Phi>o a)) (\\<lambda>x'. x')", "using assms \\<Phi>_def \\<Phi>o_preserves_ide S'.mkArr_restrict_eq'"], ["proof (prove)\nusing this:\n  \\<guillemotleft>\\<Phi>\n                   a : \\<Phi>o a \\<rightarrow>' \\<Phi>o a\\<guillemotright>\n  \\<Phi>a a = (\\<lambda>x'\\<in>S'.set (\\<Phi>o a). x')\n  S.ide a\n  \\<Phi> ?f =\n  (if S.arr ?f\n   then S'.mkArr (S'.set (\\<Phi>o (S.dom ?f))) (S'.set (\\<Phi>o (S.cod ?f)))\n         (\\<Phi>a ?f)\n   else S'.null)\n  S.ide ?a \\<Longrightarrow> S'.ide (\\<Phi>o ?a)\n  S'.arr (S'.mkArr ?A ?B (restrict ?F ?A)) \\<Longrightarrow>\n  S'.mkArr ?A ?B (restrict ?F ?A) = S'.mkArr ?A ?B ?F\n\ngoal (1 subgoal):\n 1. \\<Phi> a =\n    S'.mkArr (S'.set (\\<Phi>o a)) (S'.set (\\<Phi>o a)) (\\<lambda>x'. x')", "by (metis S'.arrI S.ide_char)"], ["proof (state)\nthis:\n  \\<Phi> a =\n  S'.mkArr (S'.set (\\<Phi>o a)) (S'.set (\\<Phi>o a)) (\\<lambda>x'. x')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Phi> a =\n  S'.mkArr (S'.set (\\<Phi>o a)) (S'.set (\\<Phi>o a)) (\\<lambda>x'. x')\n\ngoal (1 subgoal):\n 1. \\<Phi> a = \\<Phi>o a", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<Phi> a =\n  S'.mkArr (S'.set (\\<Phi>o a)) (S'.set (\\<Phi>o a)) (\\<lambda>x'. x')\n\ngoal (1 subgoal):\n 1. \\<Phi> a = \\<Phi>o a", "using assms S'.mkIde_as_mkArr \\<Phi>o_preserves_ide \\<Phi>_in_hom S'.set_card S'.mkIde_set"], ["proof (prove)\nusing this:\n  \\<Phi> a =\n  S'.mkArr (S'.set (\\<Phi>o a)) (S'.set (\\<Phi>o a)) (\\<lambda>x'. x')\n  S.ide a\n  \\<lbrakk>?A \\<subseteq> S'.Univ; |?A| <o \\<AA>\\<rbrakk>\n  \\<Longrightarrow> S'.mkArr ?A ?A (\\<lambda>x. x) = S'.mkIde ?A\n  S.ide ?a \\<Longrightarrow> S'.ide (\\<Phi>o ?a)\n  S.arr ?f \\<Longrightarrow>\n  \\<Phi> ?f \\<in> S'.hom (\\<Phi>o (S.dom ?f)) (\\<Phi>o (S.cod ?f))\n  S'.ide ?a \\<Longrightarrow> |S'.set ?a| <o \\<AA>\n  S'.ide ?a \\<Longrightarrow> S'.mkIde (S'.set ?a) = ?a\n\ngoal (1 subgoal):\n 1. \\<Phi> a = \\<Phi>o a", "by simp"], ["proof (state)\nthis:\n  \\<Phi> a = \\<Phi>o a\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_dom_\\<Phi>:\n    assumes \"S.arr f\"\n    shows \"S'.set (S'.dom (\\<Phi> f)) = \\<phi> ` (S.set (S.dom f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S'.set (S'.dom (\\<Phi> f)) = \\<phi> ` S.set (S.dom f)", "using assms S.ide_dom \\<Phi>_in_hom \\<Phi>_ide set_\\<Phi>o"], ["proof (prove)\nusing this:\n  S.arr f\n  S.arr ?f \\<Longrightarrow> S.ide (S.dom ?f)\n  S.arr ?f \\<Longrightarrow>\n  \\<Phi> ?f \\<in> S'.hom (\\<Phi>o (S.dom ?f)) (\\<Phi>o (S.cod ?f))\n  S.ide ?a \\<Longrightarrow> \\<Phi> ?a = \\<Phi>o ?a\n  S.ide ?a \\<Longrightarrow> S'.set (\\<Phi>o ?a) = \\<phi> ` S.set ?a\n\ngoal (1 subgoal):\n 1. S'.set (S'.dom (\\<Phi> f)) = \\<phi> ` S.set (S.dom f)", "by fastforce"], ["", "lemma \\<Phi>_comp:\n    assumes \"S.seq g f\"\n    shows \"\\<Phi> (g \\<cdot> f) = \\<Phi> g \\<cdot>\\<acute> \\<Phi> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> (g \\<cdot> f) = \\<Phi> g \\<cdot>\\<acute> \\<Phi> f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi> (g \\<cdot> f) = \\<Phi> g \\<cdot>\\<acute> \\<Phi> f", "have \"\\<Phi> (g \\<cdot> f) = S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g))) (\\<Phi>a (S g f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> (g \\<cdot> f) =\n    S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n     (\\<Phi>a (g \\<cdot> f))", "using \\<Phi>_def assms"], ["proof (prove)\nusing this:\n  \\<Phi> ?f =\n  (if S.arr ?f\n   then S'.mkArr (S'.set (\\<Phi>o (S.dom ?f))) (S'.set (\\<Phi>o (S.cod ?f)))\n         (\\<Phi>a ?f)\n   else S'.null)\n  S.seq g f\n\ngoal (1 subgoal):\n 1. \\<Phi> (g \\<cdot> f) =\n    S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n     (\\<Phi>a (g \\<cdot> f))", "by auto"], ["proof (state)\nthis:\n  \\<Phi> (g \\<cdot> f) =\n  S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n   (\\<Phi>a (g \\<cdot> f))\n\ngoal (1 subgoal):\n 1. \\<Phi> (g \\<cdot> f) = \\<Phi> g \\<cdot>\\<acute> \\<Phi> f", "also"], ["proof (state)\nthis:\n  \\<Phi> (g \\<cdot> f) =\n  S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n   (\\<Phi>a (g \\<cdot> f))\n\ngoal (1 subgoal):\n 1. \\<Phi> (g \\<cdot> f) = \\<Phi> g \\<cdot>\\<acute> \\<Phi> f", "have \"... = S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n                                (restrict (\\<Phi>a g o \\<Phi>a f) (S'.set (\\<Phi>o (S.dom f))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n     (\\<Phi>a (g \\<cdot> f)) =\n    S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n     (restrict (\\<Phi>a g \\<circ> \\<Phi>a f) (S'.set (\\<Phi>o (S.dom f))))", "using assms \\<Phi>a_comp set_\\<Phi>o"], ["proof (prove)\nusing this:\n  S.seq g f\n  S.seq ?g ?f \\<Longrightarrow>\n  \\<Phi>a (?g \\<cdot> ?f) =\n  restrict (\\<Phi>a ?g \\<circ> \\<Phi>a ?f) (S'.set (\\<Phi>o (S.dom ?f)))\n  S.ide ?a \\<Longrightarrow> S'.set (\\<Phi>o ?a) = \\<phi> ` S.set ?a\n\ngoal (1 subgoal):\n 1. S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n     (\\<Phi>a (g \\<cdot> f)) =\n    S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n     (restrict (\\<Phi>a g \\<circ> \\<Phi>a f) (S'.set (\\<Phi>o (S.dom f))))", "by force"], ["proof (state)\nthis:\n  S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n   (\\<Phi>a (g \\<cdot> f)) =\n  S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n   (restrict (\\<Phi>a g \\<circ> \\<Phi>a f) (S'.set (\\<Phi>o (S.dom f))))\n\ngoal (1 subgoal):\n 1. \\<Phi> (g \\<cdot> f) = \\<Phi> g \\<cdot>\\<acute> \\<Phi> f", "also"], ["proof (state)\nthis:\n  S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n   (\\<Phi>a (g \\<cdot> f)) =\n  S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n   (restrict (\\<Phi>a g \\<circ> \\<Phi>a f) (S'.set (\\<Phi>o (S.dom f))))\n\ngoal (1 subgoal):\n 1. \\<Phi> (g \\<cdot> f) = \\<Phi> g \\<cdot>\\<acute> \\<Phi> f", "have \"... = S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g))) (\\<Phi>a g o \\<Phi>a f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n     (restrict (\\<Phi>a g \\<circ> \\<Phi>a f) (S'.set (\\<Phi>o (S.dom f)))) =\n    S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n     (\\<Phi>a g \\<circ> \\<Phi>a f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n     (restrict (\\<Phi>a g \\<circ> \\<Phi>a f) (S'.set (\\<Phi>o (S.dom f)))) =\n    S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n     (\\<Phi>a g \\<circ> \\<Phi>a f)", "have \"S'.arr (S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g))) (\\<Phi>a g o \\<Phi>a f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S'.arr\n     (S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n       (\\<Phi>a g \\<circ> \\<Phi>a f))", "using assms \\<Phi>a_mapsto [of f] \\<Phi>a_mapsto [of g] \\<Phi>o_preserves_ide S'.arr_mkArr S'.set_card"], ["proof (prove)\nusing this:\n  S.seq g f\n  S.arr f \\<Longrightarrow>\n  \\<Phi>a f\n  \\<in> S'.set (\\<Phi>o (S.dom f)) \\<rightarrow> S'.set (\\<Phi>o (S.cod f))\n  S.arr g \\<Longrightarrow>\n  \\<Phi>a g\n  \\<in> S'.set (\\<Phi>o (S.dom g)) \\<rightarrow> S'.set (\\<Phi>o (S.cod g))\n  S.ide ?a \\<Longrightarrow> S'.ide (\\<Phi>o ?a)\n  S'.arr (S'.mkArr ?A ?B ?F) =\n  (?A \\<subseteq> S'.Univ \\<and>\n   |?A| <o \\<AA> \\<and>\n   ?B \\<subseteq> S'.Univ \\<and>\n   |?B| <o \\<AA> \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n  S'.ide ?a \\<Longrightarrow> |S'.set ?a| <o \\<AA>\n\ngoal (1 subgoal):\n 1. S'.arr\n     (S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n       (\\<Phi>a g \\<circ> \\<Phi>a f))", "by (elim S.seqE, auto)"], ["proof (state)\nthis:\n  S'.arr\n   (S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n     (\\<Phi>a g \\<circ> \\<Phi>a f))\n\ngoal (1 subgoal):\n 1. S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n     (restrict (\\<Phi>a g \\<circ> \\<Phi>a f) (S'.set (\\<Phi>o (S.dom f)))) =\n    S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n     (\\<Phi>a g \\<circ> \\<Phi>a f)", "thus ?thesis"], ["proof (prove)\nusing this:\n  S'.arr\n   (S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n     (\\<Phi>a g \\<circ> \\<Phi>a f))\n\ngoal (1 subgoal):\n 1. S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n     (restrict (\\<Phi>a g \\<circ> \\<Phi>a f) (S'.set (\\<Phi>o (S.dom f)))) =\n    S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n     (\\<Phi>a g \\<circ> \\<Phi>a f)", "using assms S'.mkArr_restrict_eq"], ["proof (prove)\nusing this:\n  S'.arr\n   (S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n     (\\<Phi>a g \\<circ> \\<Phi>a f))\n  S.seq g f\n  S'.arr (S'.mkArr ?A ?B ?F) \\<Longrightarrow>\n  S'.mkArr ?A ?B (restrict ?F ?A) = S'.mkArr ?A ?B ?F\n\ngoal (1 subgoal):\n 1. S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n     (restrict (\\<Phi>a g \\<circ> \\<Phi>a f) (S'.set (\\<Phi>o (S.dom f)))) =\n    S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n     (\\<Phi>a g \\<circ> \\<Phi>a f)", "by auto"], ["proof (state)\nthis:\n  S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n   (restrict (\\<Phi>a g \\<circ> \\<Phi>a f) (S'.set (\\<Phi>o (S.dom f)))) =\n  S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n   (\\<Phi>a g \\<circ> \\<Phi>a f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n   (restrict (\\<Phi>a g \\<circ> \\<Phi>a f) (S'.set (\\<Phi>o (S.dom f)))) =\n  S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n   (\\<Phi>a g \\<circ> \\<Phi>a f)\n\ngoal (1 subgoal):\n 1. \\<Phi> (g \\<cdot> f) = \\<Phi> g \\<cdot>\\<acute> \\<Phi> f", "also"], ["proof (state)\nthis:\n  S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n   (restrict (\\<Phi>a g \\<circ> \\<Phi>a f) (S'.set (\\<Phi>o (S.dom f)))) =\n  S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n   (\\<Phi>a g \\<circ> \\<Phi>a f)\n\ngoal (1 subgoal):\n 1. \\<Phi> (g \\<cdot> f) = \\<Phi> g \\<cdot>\\<acute> \\<Phi> f", "have \"... = S' (S'.mkArr (S'.set (\\<Phi>o (S.dom g))) (S'.set (\\<Phi>o (S.cod g))) (\\<Phi>a g))\n                          (S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod f))) (\\<Phi>a f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n     (\\<Phi>a g \\<circ> \\<Phi>a f) =\n    S'.mkArr (S'.set (\\<Phi>o (S.dom g))) (S'.set (\\<Phi>o (S.cod g)))\n     (\\<Phi>a g) \\<cdot>\\<acute>\n    S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod f)))\n     (\\<Phi>a f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n     (\\<Phi>a g \\<circ> \\<Phi>a f) =\n    S'.mkArr (S'.set (\\<Phi>o (S.dom g))) (S'.set (\\<Phi>o (S.cod g)))\n     (\\<Phi>a g) \\<cdot>\\<acute>\n    S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod f)))\n     (\\<Phi>a f)", "have \"S'.arr (S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod f))) (\\<Phi>a f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S'.arr\n     (S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod f)))\n       (\\<Phi>a f))", "using assms \\<Phi>a_mapsto set_\\<Phi>o S.ide_dom S.ide_cod \\<Phi>o_preserves_ide\n                S'.arr_mkArr S'.set_subset_Univ S.seqE S'.set_card"], ["proof (prove)\nusing this:\n  S.seq g f\n  S.arr ?f \\<Longrightarrow>\n  \\<Phi>a ?f\n  \\<in> S'.set (\\<Phi>o (S.dom ?f)) \\<rightarrow>\n        S'.set (\\<Phi>o (S.cod ?f))\n  S.ide ?a \\<Longrightarrow> S'.set (\\<Phi>o ?a) = \\<phi> ` S.set ?a\n  S.arr ?f \\<Longrightarrow> S.ide (S.dom ?f)\n  S.arr ?f \\<Longrightarrow> S.ide (S.cod ?f)\n  S.ide ?a \\<Longrightarrow> S'.ide (\\<Phi>o ?a)\n  S'.arr (S'.mkArr ?A ?B ?F) =\n  (?A \\<subseteq> S'.Univ \\<and>\n   |?A| <o \\<AA> \\<and>\n   ?B \\<subseteq> S'.Univ \\<and>\n   |?B| <o \\<AA> \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n  S'.ide ?a \\<Longrightarrow> S'.set ?a \\<subseteq> S'.Univ\n  \\<lbrakk>S.seq ?g ?f;\n   \\<lbrakk>S.arr ?f; S.arr ?g; S.dom ?g = S.cod ?f\\<rbrakk>\n   \\<Longrightarrow> ?T\\<rbrakk>\n  \\<Longrightarrow> ?T\n  S'.ide ?a \\<Longrightarrow> |S'.set ?a| <o \\<AA>\n\ngoal (1 subgoal):\n 1. S'.arr\n     (S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod f)))\n       (\\<Phi>a f))", "by metis"], ["proof (state)\nthis:\n  S'.arr\n   (S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod f)))\n     (\\<Phi>a f))\n\ngoal (1 subgoal):\n 1. S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n     (\\<Phi>a g \\<circ> \\<Phi>a f) =\n    S'.mkArr (S'.set (\\<Phi>o (S.dom g))) (S'.set (\\<Phi>o (S.cod g)))\n     (\\<Phi>a g) \\<cdot>\\<acute>\n    S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod f)))\n     (\\<Phi>a f)", "moreover"], ["proof (state)\nthis:\n  S'.arr\n   (S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod f)))\n     (\\<Phi>a f))\n\ngoal (1 subgoal):\n 1. S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n     (\\<Phi>a g \\<circ> \\<Phi>a f) =\n    S'.mkArr (S'.set (\\<Phi>o (S.dom g))) (S'.set (\\<Phi>o (S.cod g)))\n     (\\<Phi>a g) \\<cdot>\\<acute>\n    S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod f)))\n     (\\<Phi>a f)", "have \"S'.arr (S'.mkArr (S'.set (\\<Phi>o (S.dom g))) (S'.set (\\<Phi>o (S.cod g)))\n                              (\\<Phi>a g))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S'.arr\n     (S'.mkArr (S'.set (\\<Phi>o (S.dom g))) (S'.set (\\<Phi>o (S.cod g)))\n       (\\<Phi>a g))", "using assms \\<Phi>a_mapsto set_\\<Phi>o S.ide_dom S.ide_cod \\<Phi>o_preserves_ide S'.arr_mkArr\n                S'.set_subset_Univ S.seqE S'.set_card"], ["proof (prove)\nusing this:\n  S.seq g f\n  S.arr ?f \\<Longrightarrow>\n  \\<Phi>a ?f\n  \\<in> S'.set (\\<Phi>o (S.dom ?f)) \\<rightarrow>\n        S'.set (\\<Phi>o (S.cod ?f))\n  S.ide ?a \\<Longrightarrow> S'.set (\\<Phi>o ?a) = \\<phi> ` S.set ?a\n  S.arr ?f \\<Longrightarrow> S.ide (S.dom ?f)\n  S.arr ?f \\<Longrightarrow> S.ide (S.cod ?f)\n  S.ide ?a \\<Longrightarrow> S'.ide (\\<Phi>o ?a)\n  S'.arr (S'.mkArr ?A ?B ?F) =\n  (?A \\<subseteq> S'.Univ \\<and>\n   |?A| <o \\<AA> \\<and>\n   ?B \\<subseteq> S'.Univ \\<and>\n   |?B| <o \\<AA> \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n  S'.ide ?a \\<Longrightarrow> S'.set ?a \\<subseteq> S'.Univ\n  \\<lbrakk>S.seq ?g ?f;\n   \\<lbrakk>S.arr ?f; S.arr ?g; S.dom ?g = S.cod ?f\\<rbrakk>\n   \\<Longrightarrow> ?T\\<rbrakk>\n  \\<Longrightarrow> ?T\n  S'.ide ?a \\<Longrightarrow> |S'.set ?a| <o \\<AA>\n\ngoal (1 subgoal):\n 1. S'.arr\n     (S'.mkArr (S'.set (\\<Phi>o (S.dom g))) (S'.set (\\<Phi>o (S.cod g)))\n       (\\<Phi>a g))", "by metis"], ["proof (state)\nthis:\n  S'.arr\n   (S'.mkArr (S'.set (\\<Phi>o (S.dom g))) (S'.set (\\<Phi>o (S.cod g)))\n     (\\<Phi>a g))\n\ngoal (1 subgoal):\n 1. S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n     (\\<Phi>a g \\<circ> \\<Phi>a f) =\n    S'.mkArr (S'.set (\\<Phi>o (S.dom g))) (S'.set (\\<Phi>o (S.cod g)))\n     (\\<Phi>a g) \\<cdot>\\<acute>\n    S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod f)))\n     (\\<Phi>a f)", "ultimately"], ["proof (chain)\npicking this:\n  S'.arr\n   (S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod f)))\n     (\\<Phi>a f))\n  S'.arr\n   (S'.mkArr (S'.set (\\<Phi>o (S.dom g))) (S'.set (\\<Phi>o (S.cod g)))\n     (\\<Phi>a g))", "show ?thesis"], ["proof (prove)\nusing this:\n  S'.arr\n   (S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod f)))\n     (\\<Phi>a f))\n  S'.arr\n   (S'.mkArr (S'.set (\\<Phi>o (S.dom g))) (S'.set (\\<Phi>o (S.cod g)))\n     (\\<Phi>a g))\n\ngoal (1 subgoal):\n 1. S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n     (\\<Phi>a g \\<circ> \\<Phi>a f) =\n    S'.mkArr (S'.set (\\<Phi>o (S.dom g))) (S'.set (\\<Phi>o (S.cod g)))\n     (\\<Phi>a g) \\<cdot>\\<acute>\n    S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod f)))\n     (\\<Phi>a f)", "using assms S'.comp_mkArr"], ["proof (prove)\nusing this:\n  S'.arr\n   (S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod f)))\n     (\\<Phi>a f))\n  S'.arr\n   (S'.mkArr (S'.set (\\<Phi>o (S.dom g))) (S'.set (\\<Phi>o (S.cod g)))\n     (\\<Phi>a g))\n  S.seq g f\n  \\<lbrakk>S'.arr (S'.mkArr ?A ?B ?F); S'.arr (S'.mkArr ?B ?C ?G)\\<rbrakk>\n  \\<Longrightarrow> S'.mkArr ?B ?C ?G \\<cdot>\\<acute> S'.mkArr ?A ?B ?F =\n                    S'.mkArr ?A ?C (?G \\<circ> ?F)\n\ngoal (1 subgoal):\n 1. S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n     (\\<Phi>a g \\<circ> \\<Phi>a f) =\n    S'.mkArr (S'.set (\\<Phi>o (S.dom g))) (S'.set (\\<Phi>o (S.cod g)))\n     (\\<Phi>a g) \\<cdot>\\<acute>\n    S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod f)))\n     (\\<Phi>a f)", "by force"], ["proof (state)\nthis:\n  S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n   (\\<Phi>a g \\<circ> \\<Phi>a f) =\n  S'.mkArr (S'.set (\\<Phi>o (S.dom g))) (S'.set (\\<Phi>o (S.cod g)))\n   (\\<Phi>a g) \\<cdot>\\<acute>\n  S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod f)))\n   (\\<Phi>a f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n   (\\<Phi>a g \\<circ> \\<Phi>a f) =\n  S'.mkArr (S'.set (\\<Phi>o (S.dom g))) (S'.set (\\<Phi>o (S.cod g)))\n   (\\<Phi>a g) \\<cdot>\\<acute>\n  S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod f)))\n   (\\<Phi>a f)\n\ngoal (1 subgoal):\n 1. \\<Phi> (g \\<cdot> f) = \\<Phi> g \\<cdot>\\<acute> \\<Phi> f", "also"], ["proof (state)\nthis:\n  S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod g)))\n   (\\<Phi>a g \\<circ> \\<Phi>a f) =\n  S'.mkArr (S'.set (\\<Phi>o (S.dom g))) (S'.set (\\<Phi>o (S.cod g)))\n   (\\<Phi>a g) \\<cdot>\\<acute>\n  S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod f)))\n   (\\<Phi>a f)\n\ngoal (1 subgoal):\n 1. \\<Phi> (g \\<cdot> f) = \\<Phi> g \\<cdot>\\<acute> \\<Phi> f", "have \"... = \\<Phi> g \\<cdot>\\<acute> \\<Phi> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S'.mkArr (S'.set (\\<Phi>o (S.dom g))) (S'.set (\\<Phi>o (S.cod g)))\n     (\\<Phi>a g) \\<cdot>\\<acute>\n    S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod f)))\n     (\\<Phi>a f) =\n    \\<Phi> g \\<cdot>\\<acute> \\<Phi> f", "using assms \\<Phi>_def"], ["proof (prove)\nusing this:\n  S.seq g f\n  \\<Phi> ?f =\n  (if S.arr ?f\n   then S'.mkArr (S'.set (\\<Phi>o (S.dom ?f))) (S'.set (\\<Phi>o (S.cod ?f)))\n         (\\<Phi>a ?f)\n   else S'.null)\n\ngoal (1 subgoal):\n 1. S'.mkArr (S'.set (\\<Phi>o (S.dom g))) (S'.set (\\<Phi>o (S.cod g)))\n     (\\<Phi>a g) \\<cdot>\\<acute>\n    S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod f)))\n     (\\<Phi>a f) =\n    \\<Phi> g \\<cdot>\\<acute> \\<Phi> f", "by force"], ["proof (state)\nthis:\n  S'.mkArr (S'.set (\\<Phi>o (S.dom g))) (S'.set (\\<Phi>o (S.cod g)))\n   (\\<Phi>a g) \\<cdot>\\<acute>\n  S'.mkArr (S'.set (\\<Phi>o (S.dom f))) (S'.set (\\<Phi>o (S.cod f)))\n   (\\<Phi>a f) =\n  \\<Phi> g \\<cdot>\\<acute> \\<Phi> f\n\ngoal (1 subgoal):\n 1. \\<Phi> (g \\<cdot> f) = \\<Phi> g \\<cdot>\\<acute> \\<Phi> f", "finally"], ["proof (chain)\npicking this:\n  \\<Phi> (g \\<cdot> f) = \\<Phi> g \\<cdot>\\<acute> \\<Phi> f", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Phi> (g \\<cdot> f) = \\<Phi> g \\<cdot>\\<acute> \\<Phi> f\n\ngoal (1 subgoal):\n 1. \\<Phi> (g \\<cdot> f) = \\<Phi> g \\<cdot>\\<acute> \\<Phi> f", "by fast"], ["proof (state)\nthis:\n  \\<Phi> (g \\<cdot> f) = \\<Phi> g \\<cdot>\\<acute> \\<Phi> f\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation \\<Phi>: \"functor\" S S' \\<Phi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. functor (\\<cdot>) (\\<cdot>\\<acute>) \\<Phi>", "apply unfold_locales"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>f. \\<not> S.arr f \\<Longrightarrow> \\<Phi> f = S'.null\n 2. \\<And>f. S.arr f \\<Longrightarrow> S'.arr (\\<Phi> f)\n 3. \\<And>f. S.arr f \\<Longrightarrow> S'.dom (\\<Phi> f) = \\<Phi> (S.dom f)\n 4. \\<And>f. S.arr f \\<Longrightarrow> S'.cod (\\<Phi> f) = \\<Phi> (S.cod f)\n 5. \\<And>g f.\n       S.seq g f \\<Longrightarrow>\n       \\<Phi> (g \\<cdot> f) = \\<Phi> g \\<cdot>\\<acute> \\<Phi> f", "using \\<Phi>_def"], ["proof (prove)\nusing this:\n  \\<Phi> ?f =\n  (if S.arr ?f\n   then S'.mkArr (S'.set (\\<Phi>o (S.dom ?f))) (S'.set (\\<Phi>o (S.cod ?f)))\n         (\\<Phi>a ?f)\n   else S'.null)\n\ngoal (5 subgoals):\n 1. \\<And>f. \\<not> S.arr f \\<Longrightarrow> \\<Phi> f = S'.null\n 2. \\<And>f. S.arr f \\<Longrightarrow> S'.arr (\\<Phi> f)\n 3. \\<And>f. S.arr f \\<Longrightarrow> S'.dom (\\<Phi> f) = \\<Phi> (S.dom f)\n 4. \\<And>f. S.arr f \\<Longrightarrow> S'.cod (\\<Phi> f) = \\<Phi> (S.cod f)\n 5. \\<And>g f.\n       S.seq g f \\<Longrightarrow>\n       \\<Phi> (g \\<cdot> f) = \\<Phi> g \\<cdot>\\<acute> \\<Phi> f", "apply simp"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>f. S.arr f \\<Longrightarrow> S'.arr (\\<Phi> f)\n 2. \\<And>f. S.arr f \\<Longrightarrow> S'.dom (\\<Phi> f) = \\<Phi> (S.dom f)\n 3. \\<And>f. S.arr f \\<Longrightarrow> S'.cod (\\<Phi> f) = \\<Phi> (S.cod f)\n 4. \\<And>g f.\n       S.seq g f \\<Longrightarrow>\n       \\<Phi> (g \\<cdot> f) = \\<Phi> g \\<cdot>\\<acute> \\<Phi> f", "using \\<Phi>_in_hom \\<Phi>_comp"], ["proof (prove)\nusing this:\n  S.arr ?f \\<Longrightarrow>\n  \\<Phi> ?f \\<in> S'.hom (\\<Phi>o (S.dom ?f)) (\\<Phi>o (S.cod ?f))\n  S.seq ?g ?f \\<Longrightarrow>\n  \\<Phi> (?g \\<cdot> ?f) = \\<Phi> ?g \\<cdot>\\<acute> \\<Phi> ?f\n\ngoal (4 subgoals):\n 1. \\<And>f. S.arr f \\<Longrightarrow> S'.arr (\\<Phi> f)\n 2. \\<And>f. S.arr f \\<Longrightarrow> S'.dom (\\<Phi> f) = \\<Phi> (S.dom f)\n 3. \\<And>f. S.arr f \\<Longrightarrow> S'.cod (\\<Phi> f) = \\<Phi> (S.cod f)\n 4. \\<And>g f.\n       S.seq g f \\<Longrightarrow>\n       \\<Phi> (g \\<cdot> f) = \\<Phi> g \\<cdot>\\<acute> \\<Phi> f", "by auto"], ["", "lemma \\<Phi>_is_functor:\n    shows \"functor S S' \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. functor (\\<cdot>) (\\<cdot>\\<acute>) \\<Phi>", ".."], ["", "lemma Fun_\\<Phi>:\n    assumes \"S.arr f\" and \"x \\<in> S.set (S.dom f)\"\n    shows \"S'.Fun (\\<Phi> f) (\\<phi> x) = \\<Phi>a f (\\<phi> x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S'.Fun (\\<Phi> f) (\\<phi> x) = \\<Phi>a f (\\<phi> x)", "using assms \\<Phi>_def \\<Phi>.preserves_arr set_\\<Phi>o"], ["proof (prove)\nusing this:\n  S.arr f\n  x \\<in> S.set (S.dom f)\n  \\<Phi> ?f =\n  (if S.arr ?f\n   then S'.mkArr (S'.set (\\<Phi>o (S.dom ?f))) (S'.set (\\<Phi>o (S.cod ?f)))\n         (\\<Phi>a ?f)\n   else S'.null)\n  S.arr ?f \\<Longrightarrow> S'.arr (\\<Phi> ?f)\n  S.ide ?a \\<Longrightarrow> S'.set (\\<Phi>o ?a) = \\<phi> ` S.set ?a\n\ngoal (1 subgoal):\n 1. S'.Fun (\\<Phi> f) (\\<phi> x) = \\<Phi>a f (\\<phi> x)", "by auto"], ["", "lemma \\<Phi>_acts_elementwise:\n    assumes \"S.ide a\"\n    shows \"S'.set (\\<Phi> a) = \\<Phi> ` S.set a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S'.set (\\<Phi> a) = \\<Phi> ` S.set a", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. S'.set (\\<Phi> a) \\<subseteq> \\<Phi> ` S.set a\n 2. \\<Phi> ` S.set a \\<subseteq> S'.set (\\<Phi> a)", "have 0: \"S'.set (\\<Phi> a) = \\<phi> ` S.set a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S'.set (\\<Phi> a) = \\<phi> ` S.set a", "using assms \\<Phi>_ide set_\\<Phi>o"], ["proof (prove)\nusing this:\n  S.ide a\n  S.ide ?a \\<Longrightarrow> \\<Phi> ?a = \\<Phi>o ?a\n  S.ide ?a \\<Longrightarrow> S'.set (\\<Phi>o ?a) = \\<phi> ` S.set ?a\n\ngoal (1 subgoal):\n 1. S'.set (\\<Phi> a) = \\<phi> ` S.set a", "by simp"], ["proof (state)\nthis:\n  S'.set (\\<Phi> a) = \\<phi> ` S.set a\n\ngoal (2 subgoals):\n 1. S'.set (\\<Phi> a) \\<subseteq> \\<Phi> ` S.set a\n 2. \\<Phi> ` S.set a \\<subseteq> S'.set (\\<Phi> a)", "have 1: \"\\<And>x. x \\<in> S.set a \\<Longrightarrow> \\<Phi> x = \\<phi> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S.set a \\<Longrightarrow> \\<Phi> x = \\<phi> x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S.set a \\<Longrightarrow> \\<Phi> x = \\<phi> x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S.set a \\<Longrightarrow> \\<Phi> x = \\<phi> x", "assume x: \"x \\<in> S.set a\""], ["proof (state)\nthis:\n  x \\<in> S.set a\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S.set a \\<Longrightarrow> \\<Phi> x = \\<phi> x", "have 1: \"S.terminal x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.terminal x", "using assms x S.set_subset_Univ"], ["proof (prove)\nusing this:\n  S.ide a\n  x \\<in> S.set a\n  S.ide ?a \\<Longrightarrow> S.set ?a \\<subseteq> S.Univ\n\ngoal (1 subgoal):\n 1. S.terminal x", "by blast"], ["proof (state)\nthis:\n  S.terminal x\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S.set a \\<Longrightarrow> \\<Phi> x = \\<phi> x", "hence 2: \"S'.terminal (\\<phi> x)\""], ["proof (prove)\nusing this:\n  S.terminal x\n\ngoal (1 subgoal):\n 1. S'.terminal (\\<phi> x)", "by (metis CollectD CollectI bij_\\<phi> bij_betw_def image_iff)"], ["proof (state)\nthis:\n  S'.terminal (\\<phi> x)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S.set a \\<Longrightarrow> \\<Phi> x = \\<phi> x", "have \"\\<Phi> x = \\<Phi>o x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> x = \\<Phi>o x", "using assms x 1 \\<Phi>_ide S.terminal_def"], ["proof (prove)\nusing this:\n  S.ide a\n  x \\<in> S.set a\n  S.terminal x\n  S.ide ?a \\<Longrightarrow> \\<Phi> ?a = \\<Phi>o ?a\n  S.terminal ?b \\<equiv>\n  S.ide ?b \\<and>\n  (\\<forall>a.\n      S.ide a \\<longrightarrow>\n      (\\<exists>!f.\n          \\<guillemotleft>f : a \\<rightarrow> ?b\\<guillemotright>))\n\ngoal (1 subgoal):\n 1. \\<Phi> x = \\<Phi>o x", "by auto"], ["proof (state)\nthis:\n  \\<Phi> x = \\<Phi>o x\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S.set a \\<Longrightarrow> \\<Phi> x = \\<phi> x", "also"], ["proof (state)\nthis:\n  \\<Phi> x = \\<Phi>o x\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S.set a \\<Longrightarrow> \\<Phi> x = \\<phi> x", "have \"... = \\<phi> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi>o x = \\<phi> x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi>o x = \\<phi> x", "have \"\\<Phi>o x = S'.mkIde (\\<phi> ` S.set x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi>o x = S'.mkIde (\\<phi> ` S.set x)", "using assms 1 x \\<Phi>o_def S.terminal_def"], ["proof (prove)\nusing this:\n  S.ide a\n  S.terminal x\n  x \\<in> S.set a\n  \\<Phi>o = (\\<lambda>a\\<in>Collect S.ide. S'.mkIde (\\<phi> ` S.set a))\n  S.terminal ?b \\<equiv>\n  S.ide ?b \\<and>\n  (\\<forall>a.\n      S.ide a \\<longrightarrow>\n      (\\<exists>!f.\n          \\<guillemotleft>f : a \\<rightarrow> ?b\\<guillemotright>))\n\ngoal (1 subgoal):\n 1. \\<Phi>o x = S'.mkIde (\\<phi> ` S.set x)", "by auto"], ["proof (state)\nthis:\n  \\<Phi>o x = S'.mkIde (\\<phi> ` S.set x)\n\ngoal (1 subgoal):\n 1. \\<Phi>o x = \\<phi> x", "moreover"], ["proof (state)\nthis:\n  \\<Phi>o x = S'.mkIde (\\<phi> ` S.set x)\n\ngoal (1 subgoal):\n 1. \\<Phi>o x = \\<phi> x", "have \"S'.mkIde (\\<phi> ` S.set x) = \\<phi> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S'.mkIde (\\<phi> ` S.set x) = \\<phi> x", "using assms x 1 2 S.terminal_char2 S'.terminal_char2 S'.mkIde_set bij_\\<phi>"], ["proof (prove)\nusing this:\n  S.ide a\n  x \\<in> S.set a\n  S.terminal x\n  S'.terminal (\\<phi> x)\n  S.terminal ?t = (S.ide ?t \\<and> S.set ?t = {?t})\n  S'.terminal ?t = (S'.ide ?t \\<and> S'.set ?t = {?t})\n  S'.ide ?a \\<Longrightarrow> S'.mkIde (S'.set ?a) = ?a\n  bij_betw \\<phi> S.Univ S'.Univ\n\ngoal (1 subgoal):\n 1. S'.mkIde (\\<phi> ` S.set x) = \\<phi> x", "by (metis image_empty image_insert)"], ["proof (state)\nthis:\n  S'.mkIde (\\<phi> ` S.set x) = \\<phi> x\n\ngoal (1 subgoal):\n 1. \\<Phi>o x = \\<phi> x", "ultimately"], ["proof (chain)\npicking this:\n  \\<Phi>o x = S'.mkIde (\\<phi> ` S.set x)\n  S'.mkIde (\\<phi> ` S.set x) = \\<phi> x", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Phi>o x = S'.mkIde (\\<phi> ` S.set x)\n  S'.mkIde (\\<phi> ` S.set x) = \\<phi> x\n\ngoal (1 subgoal):\n 1. \\<Phi>o x = \\<phi> x", "by auto"], ["proof (state)\nthis:\n  \\<Phi>o x = \\<phi> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Phi>o x = \\<phi> x\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S.set a \\<Longrightarrow> \\<Phi> x = \\<phi> x", "finally"], ["proof (chain)\npicking this:\n  \\<Phi> x = \\<phi> x", "show \"\\<Phi> x = \\<phi> x\""], ["proof (prove)\nusing this:\n  \\<Phi> x = \\<phi> x\n\ngoal (1 subgoal):\n 1. \\<Phi> x = \\<phi> x", "by auto"], ["proof (state)\nthis:\n  \\<Phi> x = \\<phi> x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> S.set a \\<Longrightarrow> \\<Phi> ?x = \\<phi> ?x\n\ngoal (2 subgoals):\n 1. S'.set (\\<Phi> a) \\<subseteq> \\<Phi> ` S.set a\n 2. \\<Phi> ` S.set a \\<subseteq> S'.set (\\<Phi> a)", "show \"S'.set (\\<Phi> a) \\<subseteq> \\<Phi> ` S.set a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S'.set (\\<Phi> a) \\<subseteq> \\<Phi> ` S.set a", "using 0 1"], ["proof (prove)\nusing this:\n  S'.set (\\<Phi> a) = \\<phi> ` S.set a\n  ?x \\<in> S.set a \\<Longrightarrow> \\<Phi> ?x = \\<phi> ?x\n\ngoal (1 subgoal):\n 1. S'.set (\\<Phi> a) \\<subseteq> \\<Phi> ` S.set a", "by force"], ["proof (state)\nthis:\n  S'.set (\\<Phi> a) \\<subseteq> \\<Phi> ` S.set a\n\ngoal (1 subgoal):\n 1. \\<Phi> ` S.set a \\<subseteq> S'.set (\\<Phi> a)", "show \"\\<Phi> ` S.set a \\<subseteq> S'.set (\\<Phi> a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> ` S.set a \\<subseteq> S'.set (\\<Phi> a)", "using 0 1"], ["proof (prove)\nusing this:\n  S'.set (\\<Phi> a) = \\<phi> ` S.set a\n  ?x \\<in> S.set a \\<Longrightarrow> \\<Phi> ?x = \\<phi> ?x\n\ngoal (1 subgoal):\n 1. \\<Phi> ` S.set a \\<subseteq> S'.set (\\<Phi> a)", "by force"], ["proof (state)\nthis:\n  \\<Phi> ` S.set a \\<subseteq> S'.set (\\<Phi> a)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<Phi>_preserves_incl:\n    assumes \"S.incl m\"\n    shows \"S'.incl (\\<Phi> m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S'.incl (\\<Phi> m)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. S'.incl (\\<Phi> m)", "have 1: \"S.arr m \\<and> S.set (S.dom m) \\<subseteq> S.set (S.cod m) \\<and>\n               m = S.mkArr (S.set (S.dom m)) (S.set (S.cod m)) (\\<lambda>x. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.arr m \\<and>\n    S.set (S.dom m) \\<subseteq> S.set (S.cod m) \\<and>\n    m = S.mkArr (S.set (S.dom m)) (S.set (S.cod m)) (\\<lambda>x. x)", "using assms S.incl_def"], ["proof (prove)\nusing this:\n  S.incl m\n  S.incl ?f =\n  (S.arr ?f \\<and>\n   S.set (S.dom ?f) \\<subseteq> S.set (S.cod ?f) \\<and>\n   ?f = S.mkArr (S.set (S.dom ?f)) (S.set (S.cod ?f)) (\\<lambda>x. x))\n\ngoal (1 subgoal):\n 1. S.arr m \\<and>\n    S.set (S.dom m) \\<subseteq> S.set (S.cod m) \\<and>\n    m = S.mkArr (S.set (S.dom m)) (S.set (S.cod m)) (\\<lambda>x. x)", "by blast"], ["proof (state)\nthis:\n  S.arr m \\<and>\n  S.set (S.dom m) \\<subseteq> S.set (S.cod m) \\<and>\n  m = S.mkArr (S.set (S.dom m)) (S.set (S.cod m)) (\\<lambda>x. x)\n\ngoal (1 subgoal):\n 1. S'.incl (\\<Phi> m)", "have \"S'.arr (\\<Phi> m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S'.arr (\\<Phi> m)", "using 1"], ["proof (prove)\nusing this:\n  S.arr m \\<and>\n  S.set (S.dom m) \\<subseteq> S.set (S.cod m) \\<and>\n  m = S.mkArr (S.set (S.dom m)) (S.set (S.cod m)) (\\<lambda>x. x)\n\ngoal (1 subgoal):\n 1. S'.arr (\\<Phi> m)", "by auto"], ["proof (state)\nthis:\n  S'.arr (\\<Phi> m)\n\ngoal (1 subgoal):\n 1. S'.incl (\\<Phi> m)", "moreover"], ["proof (state)\nthis:\n  S'.arr (\\<Phi> m)\n\ngoal (1 subgoal):\n 1. S'.incl (\\<Phi> m)", "have 2: \"S'.set (S'.dom (\\<Phi> m)) \\<subseteq> S'.set (S'.cod (\\<Phi> m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S'.set (S'.dom (\\<Phi> m)) \\<subseteq> S'.set (S'.cod (\\<Phi> m))", "using 1 \\<Phi>.preserves_dom \\<Phi>.preserves_cod \\<Phi>_acts_elementwise"], ["proof (prove)\nusing this:\n  S.arr m \\<and>\n  S.set (S.dom m) \\<subseteq> S.set (S.cod m) \\<and>\n  m = S.mkArr (S.set (S.dom m)) (S.set (S.cod m)) (\\<lambda>x. x)\n  S.arr ?f \\<Longrightarrow> S'.dom (\\<Phi> ?f) = \\<Phi> (S.dom ?f)\n  S.arr ?f \\<Longrightarrow> S'.cod (\\<Phi> ?f) = \\<Phi> (S.cod ?f)\n  S.ide ?a \\<Longrightarrow> S'.set (\\<Phi> ?a) = \\<Phi> ` S.set ?a\n\ngoal (1 subgoal):\n 1. S'.set (S'.dom (\\<Phi> m)) \\<subseteq> S'.set (S'.cod (\\<Phi> m))", "by (metis (full_types) S.ide_cod S.ide_dom image_mono)"], ["proof (state)\nthis:\n  S'.set (S'.dom (\\<Phi> m)) \\<subseteq> S'.set (S'.cod (\\<Phi> m))\n\ngoal (1 subgoal):\n 1. S'.incl (\\<Phi> m)", "moreover"], ["proof (state)\nthis:\n  S'.set (S'.dom (\\<Phi> m)) \\<subseteq> S'.set (S'.cod (\\<Phi> m))\n\ngoal (1 subgoal):\n 1. S'.incl (\\<Phi> m)", "have \"\\<Phi> m =\n                     S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m))) (\\<lambda>x'. x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> m =\n    S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m)))\n     (\\<lambda>x'. x')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Phi> m =\n    S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m)))\n     (\\<lambda>x'. x')", "have \"\\<Phi> m = S'.mkArr (S'.set (\\<Phi>o (S.dom m))) (S'.set (\\<Phi>o (S.cod m))) (\\<Phi>a m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> m =\n    S'.mkArr (S'.set (\\<Phi>o (S.dom m))) (S'.set (\\<Phi>o (S.cod m)))\n     (\\<Phi>a m)", "using 1 \\<Phi>_def"], ["proof (prove)\nusing this:\n  S.arr m \\<and>\n  S.set (S.dom m) \\<subseteq> S.set (S.cod m) \\<and>\n  m = S.mkArr (S.set (S.dom m)) (S.set (S.cod m)) (\\<lambda>x. x)\n  \\<Phi> ?f =\n  (if S.arr ?f\n   then S'.mkArr (S'.set (\\<Phi>o (S.dom ?f))) (S'.set (\\<Phi>o (S.cod ?f)))\n         (\\<Phi>a ?f)\n   else S'.null)\n\ngoal (1 subgoal):\n 1. \\<Phi> m =\n    S'.mkArr (S'.set (\\<Phi>o (S.dom m))) (S'.set (\\<Phi>o (S.cod m)))\n     (\\<Phi>a m)", "by simp"], ["proof (state)\nthis:\n  \\<Phi> m =\n  S'.mkArr (S'.set (\\<Phi>o (S.dom m))) (S'.set (\\<Phi>o (S.cod m)))\n   (\\<Phi>a m)\n\ngoal (1 subgoal):\n 1. \\<Phi> m =\n    S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m)))\n     (\\<lambda>x'. x')", "also"], ["proof (state)\nthis:\n  \\<Phi> m =\n  S'.mkArr (S'.set (\\<Phi>o (S.dom m))) (S'.set (\\<Phi>o (S.cod m)))\n   (\\<Phi>a m)\n\ngoal (1 subgoal):\n 1. \\<Phi> m =\n    S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m)))\n     (\\<lambda>x'. x')", "have \"... = S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m))) (\\<Phi>a m)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S'.mkArr (S'.set (\\<Phi>o (S.dom m))) (S'.set (\\<Phi>o (S.cod m)))\n     (\\<Phi>a m) =\n    S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m)))\n     (\\<Phi>a m)", "using 1 \\<Phi>_ide"], ["proof (prove)\nusing this:\n  S.arr m \\<and>\n  S.set (S.dom m) \\<subseteq> S.set (S.cod m) \\<and>\n  m = S.mkArr (S.set (S.dom m)) (S.set (S.cod m)) (\\<lambda>x. x)\n  S.ide ?a \\<Longrightarrow> \\<Phi> ?a = \\<Phi>o ?a\n\ngoal (1 subgoal):\n 1. S'.mkArr (S'.set (\\<Phi>o (S.dom m))) (S'.set (\\<Phi>o (S.cod m)))\n     (\\<Phi>a m) =\n    S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m)))\n     (\\<Phi>a m)", "by auto"], ["proof (state)\nthis:\n  S'.mkArr (S'.set (\\<Phi>o (S.dom m))) (S'.set (\\<Phi>o (S.cod m)))\n   (\\<Phi>a m) =\n  S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m)))\n   (\\<Phi>a m)\n\ngoal (1 subgoal):\n 1. \\<Phi> m =\n    S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m)))\n     (\\<lambda>x'. x')", "finally"], ["proof (chain)\npicking this:\n  \\<Phi> m =\n  S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m)))\n   (\\<Phi>a m)", "have 3: \"\\<Phi> m =\n                         S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m))) (\\<Phi>a m)\""], ["proof (prove)\nusing this:\n  \\<Phi> m =\n  S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m)))\n   (\\<Phi>a m)\n\ngoal (1 subgoal):\n 1. \\<Phi> m =\n    S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m)))\n     (\\<Phi>a m)", "by auto"], ["proof (state)\nthis:\n  \\<Phi> m =\n  S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m)))\n   (\\<Phi>a m)\n\ngoal (1 subgoal):\n 1. \\<Phi> m =\n    S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m)))\n     (\\<lambda>x'. x')", "also"], ["proof (state)\nthis:\n  \\<Phi> m =\n  S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m)))\n   (\\<Phi>a m)\n\ngoal (1 subgoal):\n 1. \\<Phi> m =\n    S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m)))\n     (\\<lambda>x'. x')", "have \"... = S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m))) (\\<lambda>x'. x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m)))\n     (\\<Phi>a m) =\n    S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m)))\n     (\\<lambda>x'. x')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m)))\n     (\\<Phi>a m) =\n    S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m)))\n     (\\<lambda>x'. x')", "have 4: \"S.Fun m = restrict (\\<lambda>x. x) (S.set (S.dom m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.Fun m = (\\<lambda>x\\<in>S.set (S.dom m). x)", "using assms S.incl_def"], ["proof (prove)\nusing this:\n  S.incl m\n  S.incl ?f =\n  (S.arr ?f \\<and>\n   S.set (S.dom ?f) \\<subseteq> S.set (S.cod ?f) \\<and>\n   ?f = S.mkArr (S.set (S.dom ?f)) (S.set (S.cod ?f)) (\\<lambda>x. x))\n\ngoal (1 subgoal):\n 1. S.Fun m = (\\<lambda>x\\<in>S.set (S.dom m). x)", "by (metis (full_types) S.Fun_mkArr)"], ["proof (state)\nthis:\n  S.Fun m = (\\<lambda>x\\<in>S.set (S.dom m). x)\n\ngoal (1 subgoal):\n 1. S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m)))\n     (\\<Phi>a m) =\n    S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m)))\n     (\\<lambda>x'. x')", "hence \"\\<Phi>a m = restrict (\\<lambda>x'. x') (\\<phi> ` (S.set (S.dom m)))\""], ["proof (prove)\nusing this:\n  S.Fun m = (\\<lambda>x\\<in>S.set (S.dom m). x)\n\ngoal (1 subgoal):\n 1. \\<Phi>a m = (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom m). x')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. S.Fun m = (\\<lambda>x\\<in>S.set (S.dom m). x) \\<Longrightarrow>\n    \\<Phi>a m = (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom m). x')", "have 5: \"\\<And>x'. x' \\<in> \\<phi> ` S.set (S.dom m) \\<Longrightarrow> \\<phi> (\\<psi> x') = x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x'.\n       x' \\<in> \\<phi> ` S.set (S.dom m) \\<Longrightarrow>\n       \\<phi> (\\<psi> x') = x'", "by (metis 1 S'.set_subset_Univ S.ide_dom \\<Phi>o_preserves_ide \\<phi>_\\<psi> set_\\<Phi>o subsetD)"], ["proof (state)\nthis:\n  ?x' \\<in> \\<phi> ` S.set (S.dom m) \\<Longrightarrow>\n  \\<phi> (\\<psi> ?x') = ?x'\n\ngoal (1 subgoal):\n 1. S.Fun m = (\\<lambda>x\\<in>S.set (S.dom m). x) \\<Longrightarrow>\n    \\<Phi>a m = (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom m). x')", "have \"\\<Phi>a m = restrict (\\<lambda>x'. \\<phi> (S.Fun m (\\<psi> x'))) (\\<phi> ` S.set (S.dom m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi>a m =\n    (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom m). \\<phi> (S.Fun m (\\<psi> x')))", "using \\<Phi>a_def"], ["proof (prove)\nusing this:\n  \\<Phi>a =\n  (\\<lambda>f.\n      \\<lambda>x'\\<in>\\<phi> ` S.set (S.dom f).\n         \\<phi> (S.Fun f (\\<psi> x')))\n\ngoal (1 subgoal):\n 1. \\<Phi>a m =\n    (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom m). \\<phi> (S.Fun m (\\<psi> x')))", "by simp"], ["proof (state)\nthis:\n  \\<Phi>a m =\n  (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom m). \\<phi> (S.Fun m (\\<psi> x')))\n\ngoal (1 subgoal):\n 1. S.Fun m = (\\<lambda>x\\<in>S.set (S.dom m). x) \\<Longrightarrow>\n    \\<Phi>a m = (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom m). x')", "also"], ["proof (state)\nthis:\n  \\<Phi>a m =\n  (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom m). \\<phi> (S.Fun m (\\<psi> x')))\n\ngoal (1 subgoal):\n 1. S.Fun m = (\\<lambda>x\\<in>S.set (S.dom m). x) \\<Longrightarrow>\n    \\<Phi>a m = (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom m). x')", "have \"... = restrict (\\<lambda>x'. x') (\\<phi> ` S.set (S.dom m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom m).\n        \\<phi> (S.Fun m (\\<psi> x'))) =\n    (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom m). x')", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom m).\n        \\<phi> (S.Fun m (\\<psi> x'))) =\n    (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom m). x')", "have \"\\<And>x. x \\<in> \\<phi> ` (S.set (S.dom m)) \\<Longrightarrow> \\<phi> (S.Fun m (\\<psi> x)) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<phi> ` S.set (S.dom m) \\<Longrightarrow>\n       \\<phi> (S.Fun m (\\<psi> x)) = x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<phi> ` S.set (S.dom m) \\<Longrightarrow>\n       \\<phi> (S.Fun m (\\<psi> x)) = x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<phi> ` S.set (S.dom m) \\<Longrightarrow>\n       \\<phi> (S.Fun m (\\<psi> x)) = x", "assume x: \"x \\<in> \\<phi> ` (S.set (S.dom m))\""], ["proof (state)\nthis:\n  x \\<in> \\<phi> ` S.set (S.dom m)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<phi> ` S.set (S.dom m) \\<Longrightarrow>\n       \\<phi> (S.Fun m (\\<psi> x)) = x", "hence \"\\<psi> x \\<in> S.set (S.dom m)\""], ["proof (prove)\nusing this:\n  x \\<in> \\<phi> ` S.set (S.dom m)\n\ngoal (1 subgoal):\n 1. \\<psi> x \\<in> S.set (S.dom m)", "using 1 S.ide_dom S.set_subset_Univ \\<psi>_img_\\<phi>_img image_eqI"], ["proof (prove)\nusing this:\n  x \\<in> \\<phi> ` S.set (S.dom m)\n  S.arr m \\<and>\n  S.set (S.dom m) \\<subseteq> S.set (S.cod m) \\<and>\n  m = S.mkArr (S.set (S.dom m)) (S.set (S.cod m)) (\\<lambda>x. x)\n  S.arr ?f \\<Longrightarrow> S.ide (S.dom ?f)\n  S.ide ?a \\<Longrightarrow> S.set ?a \\<subseteq> S.Univ\n  ?A \\<subseteq> S.Univ \\<Longrightarrow> \\<psi> ` \\<phi> ` ?A = ?A\n  \\<lbrakk>?b = ?f ?x; ?x \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> ?b \\<in> ?f ` ?A\n\ngoal (1 subgoal):\n 1. \\<psi> x \\<in> S.set (S.dom m)", "by metis"], ["proof (state)\nthis:\n  \\<psi> x \\<in> S.set (S.dom m)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<phi> ` S.set (S.dom m) \\<Longrightarrow>\n       \\<phi> (S.Fun m (\\<psi> x)) = x", "thus \"\\<phi> (S.Fun m (\\<psi> x)) = x\""], ["proof (prove)\nusing this:\n  \\<psi> x \\<in> S.set (S.dom m)\n\ngoal (1 subgoal):\n 1. \\<phi> (S.Fun m (\\<psi> x)) = x", "using 1 4 5 x"], ["proof (prove)\nusing this:\n  \\<psi> x \\<in> S.set (S.dom m)\n  S.arr m \\<and>\n  S.set (S.dom m) \\<subseteq> S.set (S.cod m) \\<and>\n  m = S.mkArr (S.set (S.dom m)) (S.set (S.cod m)) (\\<lambda>x. x)\n  S.Fun m = (\\<lambda>x\\<in>S.set (S.dom m). x)\n  ?x' \\<in> \\<phi> ` S.set (S.dom m) \\<Longrightarrow>\n  \\<phi> (\\<psi> ?x') = ?x'\n  x \\<in> \\<phi> ` S.set (S.dom m)\n\ngoal (1 subgoal):\n 1. \\<phi> (S.Fun m (\\<psi> x)) = x", "by simp"], ["proof (state)\nthis:\n  \\<phi> (S.Fun m (\\<psi> x)) = x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> \\<phi> ` S.set (S.dom m) \\<Longrightarrow>\n  \\<phi> (S.Fun m (\\<psi> ?x)) = ?x\n\ngoal (1 subgoal):\n 1. (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom m).\n        \\<phi> (S.Fun m (\\<psi> x'))) =\n    (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom m). x')", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?x \\<in> \\<phi> ` S.set (S.dom m) \\<Longrightarrow>\n  \\<phi> (S.Fun m (\\<psi> ?x)) = ?x\n\ngoal (1 subgoal):\n 1. (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom m).\n        \\<phi> (S.Fun m (\\<psi> x'))) =\n    (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom m). x')", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom m). \\<phi> (S.Fun m (\\<psi> x'))) =\n  (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom m). x')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom m). \\<phi> (S.Fun m (\\<psi> x'))) =\n  (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom m). x')\n\ngoal (1 subgoal):\n 1. S.Fun m = (\\<lambda>x\\<in>S.set (S.dom m). x) \\<Longrightarrow>\n    \\<Phi>a m = (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom m). x')", "finally"], ["proof (chain)\npicking this:\n  \\<Phi>a m = (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom m). x')", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Phi>a m = (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom m). x')\n\ngoal (1 subgoal):\n 1. \\<Phi>a m = (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom m). x')", "by auto"], ["proof (state)\nthis:\n  \\<Phi>a m = (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom m). x')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Phi>a m = (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom m). x')\n\ngoal (1 subgoal):\n 1. S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m)))\n     (\\<Phi>a m) =\n    S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m)))\n     (\\<lambda>x'. x')", "hence \"\\<Phi>a m = restrict (\\<lambda>x'. x') (S'.set (S'.dom (\\<Phi> m)))\""], ["proof (prove)\nusing this:\n  \\<Phi>a m = (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom m). x')\n\ngoal (1 subgoal):\n 1. \\<Phi>a m = (\\<lambda>x'\\<in>S'.set (S'.dom (\\<Phi> m)). x')", "using 1 set_dom_\\<Phi>"], ["proof (prove)\nusing this:\n  \\<Phi>a m = (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom m). x')\n  S.arr m \\<and>\n  S.set (S.dom m) \\<subseteq> S.set (S.cod m) \\<and>\n  m = S.mkArr (S.set (S.dom m)) (S.set (S.cod m)) (\\<lambda>x. x)\n  S.arr ?f \\<Longrightarrow>\n  S'.set (S'.dom (\\<Phi> ?f)) = \\<phi> ` S.set (S.dom ?f)\n\ngoal (1 subgoal):\n 1. \\<Phi>a m = (\\<lambda>x'\\<in>S'.set (S'.dom (\\<Phi> m)). x')", "by auto"], ["proof (state)\nthis:\n  \\<Phi>a m = (\\<lambda>x'\\<in>S'.set (S'.dom (\\<Phi> m)). x')\n\ngoal (1 subgoal):\n 1. S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m)))\n     (\\<Phi>a m) =\n    S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m)))\n     (\\<lambda>x'. x')", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<Phi>a m = (\\<lambda>x'\\<in>S'.set (S'.dom (\\<Phi> m)). x')\n\ngoal (1 subgoal):\n 1. S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m)))\n     (\\<Phi>a m) =\n    S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m)))\n     (\\<lambda>x'. x')", "using 2 3 \\<open>S'.arr (\\<Phi> m)\\<close> S'.mkArr_restrict_eq S'.ide_cod S'.ide_dom S'.incl_def"], ["proof (prove)\nusing this:\n  \\<Phi>a m = (\\<lambda>x'\\<in>S'.set (S'.dom (\\<Phi> m)). x')\n  S'.set (S'.dom (\\<Phi> m)) \\<subseteq> S'.set (S'.cod (\\<Phi> m))\n  \\<Phi> m =\n  S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m)))\n   (\\<Phi>a m)\n  S'.arr (\\<Phi> m)\n  S'.arr (S'.mkArr ?A ?B ?F) \\<Longrightarrow>\n  S'.mkArr ?A ?B (restrict ?F ?A) = S'.mkArr ?A ?B ?F\n  S'.arr ?f \\<Longrightarrow> S'.ide (S'.cod ?f)\n  S'.arr ?f \\<Longrightarrow> S'.ide (S'.dom ?f)\n  S'.incl ?f =\n  (S'.arr ?f \\<and>\n   S'.set (S'.dom ?f) \\<subseteq> S'.set (S'.cod ?f) \\<and>\n   ?f = S'.mkArr (S'.set (S'.dom ?f)) (S'.set (S'.cod ?f)) (\\<lambda>x. x))\n\ngoal (1 subgoal):\n 1. S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m)))\n     (\\<Phi>a m) =\n    S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m)))\n     (\\<lambda>x'. x')", "by (metis S'.arr_mkArr image_restrict_eq image_subset_iff_funcset)"], ["proof (state)\nthis:\n  S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m)))\n   (\\<Phi>a m) =\n  S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m)))\n   (\\<lambda>x'. x')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m)))\n   (\\<Phi>a m) =\n  S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m)))\n   (\\<lambda>x'. x')\n\ngoal (1 subgoal):\n 1. \\<Phi> m =\n    S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m)))\n     (\\<lambda>x'. x')", "finally"], ["proof (chain)\npicking this:\n  \\<Phi> m =\n  S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m)))\n   (\\<lambda>x'. x')", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Phi> m =\n  S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m)))\n   (\\<lambda>x'. x')\n\ngoal (1 subgoal):\n 1. \\<Phi> m =\n    S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m)))\n     (\\<lambda>x'. x')", "by auto"], ["proof (state)\nthis:\n  \\<Phi> m =\n  S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m)))\n   (\\<lambda>x'. x')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Phi> m =\n  S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m)))\n   (\\<lambda>x'. x')\n\ngoal (1 subgoal):\n 1. S'.incl (\\<Phi> m)", "ultimately"], ["proof (chain)\npicking this:\n  S'.arr (\\<Phi> m)\n  S'.set (S'.dom (\\<Phi> m)) \\<subseteq> S'.set (S'.cod (\\<Phi> m))\n  \\<Phi> m =\n  S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m)))\n   (\\<lambda>x'. x')", "show ?thesis"], ["proof (prove)\nusing this:\n  S'.arr (\\<Phi> m)\n  S'.set (S'.dom (\\<Phi> m)) \\<subseteq> S'.set (S'.cod (\\<Phi> m))\n  \\<Phi> m =\n  S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m)))\n   (\\<lambda>x'. x')\n\ngoal (1 subgoal):\n 1. S'.incl (\\<Phi> m)", "using S'.incl_def"], ["proof (prove)\nusing this:\n  S'.arr (\\<Phi> m)\n  S'.set (S'.dom (\\<Phi> m)) \\<subseteq> S'.set (S'.cod (\\<Phi> m))\n  \\<Phi> m =\n  S'.mkArr (S'.set (S'.dom (\\<Phi> m))) (S'.set (S'.cod (\\<Phi> m)))\n   (\\<lambda>x'. x')\n  S'.incl ?f =\n  (S'.arr ?f \\<and>\n   S'.set (S'.dom ?f) \\<subseteq> S'.set (S'.cod ?f) \\<and>\n   ?f = S'.mkArr (S'.set (S'.dom ?f)) (S'.set (S'.cod ?f)) (\\<lambda>x. x))\n\ngoal (1 subgoal):\n 1. S'.incl (\\<Phi> m)", "by blast"], ["proof (state)\nthis:\n  S'.incl (\\<Phi> m)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n      Interchange the role of @{term \\<phi>} and @{term \\<psi>} to obtain a functor \\<open>\\<Psi>\\<close>\n      from @{term[source=true] S'} to @{term[source=true] S}.\n\\<close>"], ["", "interpretation INV: two_set_categories_bij_betw_Univ S' S \\<AA> \\<psi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. two_set_categories_bij_betw_Univ (\\<cdot>\\<acute>) (\\<cdot>) \\<AA>\n     \\<psi>", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw \\<psi> S'.Univ S.Univ", "by (simp add: bij_\\<phi> bij_betw_inv_into)"], ["", "abbreviation \\<Psi>o\n    where \"\\<Psi>o \\<equiv> INV.\\<Phi>o\""], ["", "abbreviation \\<Psi>a\n    where \"\\<Psi>a \\<equiv> INV.\\<Phi>a\""], ["", "abbreviation \\<Psi>\n    where \"\\<Psi> \\<equiv> INV.\\<Phi>\""], ["", "interpretation \\<Psi>: \"functor\" S' S \\<Psi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. functor (\\<cdot>\\<acute>) (\\<cdot>) \\<Psi>", "using INV.\\<Phi>_is_functor"], ["proof (prove)\nusing this:\n  functor (\\<cdot>\\<acute>) (\\<cdot>) \\<Psi>\n\ngoal (1 subgoal):\n 1. functor (\\<cdot>\\<acute>) (\\<cdot>) \\<Psi>", "by auto"], ["", "text\\<open>\n      The functors @{term \\<Phi>} and @{term \\<Psi>} are inverses.\n\\<close>"], ["", "lemma Fun_\\<Psi>:\n    assumes \"S'.arr f'\" and \"x' \\<in> S'.set (S'.dom f')\"\n    shows \"S.Fun (\\<Psi> f') (\\<psi> x') = \\<Psi>a f' (\\<psi> x')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.Fun (\\<Psi> f') (\\<psi> x') = \\<Psi>a f' (\\<psi> x')", "using assms INV.Fun_\\<Phi>"], ["proof (prove)\nusing this:\n  S'.arr f'\n  x' \\<in> S'.set (S'.dom f')\n  \\<lbrakk>S'.arr ?f; ?x \\<in> S'.set (S'.dom ?f)\\<rbrakk>\n  \\<Longrightarrow> S.Fun (\\<Psi> ?f) (\\<psi> ?x) = \\<Psi>a ?f (\\<psi> ?x)\n\ngoal (1 subgoal):\n 1. S.Fun (\\<Psi> f') (\\<psi> x') = \\<Psi>a f' (\\<psi> x')", "by blast"], ["", "lemma \\<Psi>o_\\<Phi>o:\n    assumes \"S.ide a\"\n    shows \"\\<Psi>o (\\<Phi>o a) = a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi>o (\\<Phi>o a) = a", "using assms \\<Phi>o_def INV.\\<Phi>o_def \\<psi>_img_\\<phi>_img \\<Phi>o_preserves_ide set_\\<Phi>o S.mkIde_set"], ["proof (prove)\nusing this:\n  S.ide a\n  \\<Phi>o = (\\<lambda>a\\<in>Collect S.ide. S'.mkIde (\\<phi> ` S.set a))\n  \\<Psi>o = (\\<lambda>a\\<in>Collect S'.ide. S.mkIde (\\<psi> ` S'.set a))\n  ?A \\<subseteq> S.Univ \\<Longrightarrow> \\<psi> ` \\<phi> ` ?A = ?A\n  S.ide ?a \\<Longrightarrow> S'.ide (\\<Phi>o ?a)\n  S.ide ?a \\<Longrightarrow> S'.set (\\<Phi>o ?a) = \\<phi> ` S.set ?a\n  S.ide ?a \\<Longrightarrow> S.mkIde (S.set ?a) = ?a\n\ngoal (1 subgoal):\n 1. \\<Psi>o (\\<Phi>o a) = a", "by force"], ["", "lemma \\<Phi>\\<Psi>:\n    assumes \"S.arr f\"\n    shows \"\\<Psi> (\\<Phi> f) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi> (\\<Phi> f) = f", "proof (intro S.arr_eqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. S.par (\\<Psi> (\\<Phi> f)) f\n 2. S.Fun (\\<Psi> (\\<Phi> f)) = S.Fun f", "show par: \"S.par (\\<Psi> (\\<Phi> f)) f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.par (\\<Psi> (\\<Phi> f)) f", "using assms \\<Phi>o_preserves_ide \\<Psi>o_\\<Phi>o"], ["proof (prove)\nusing this:\n  S.arr f\n  S.ide ?a \\<Longrightarrow> S'.ide (\\<Phi>o ?a)\n  S.ide ?a \\<Longrightarrow> \\<Psi>o (\\<Phi>o ?a) = ?a\n\ngoal (1 subgoal):\n 1. S.par (\\<Psi> (\\<Phi> f)) f", "by auto"], ["proof (state)\nthis:\n  S.par (\\<Psi> (\\<Phi> f)) f\n\ngoal (1 subgoal):\n 1. S.Fun (\\<Psi> (\\<Phi> f)) = S.Fun f", "show \"S.Fun (\\<Psi> (\\<Phi> f)) = S.Fun f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.Fun (\\<Psi> (\\<Phi> f)) = S.Fun f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. S.Fun (\\<Psi> (\\<Phi> f)) = S.Fun f", "have \"S.arr (\\<Psi> (\\<Phi> f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.arr (\\<Psi> (\\<Phi> f))", "using assms"], ["proof (prove)\nusing this:\n  S.arr f\n\ngoal (1 subgoal):\n 1. S.arr (\\<Psi> (\\<Phi> f))", "by auto"], ["proof (state)\nthis:\n  S.arr (\\<Psi> (\\<Phi> f))\n\ngoal (1 subgoal):\n 1. S.Fun (\\<Psi> (\\<Phi> f)) = S.Fun f", "moreover"], ["proof (state)\nthis:\n  S.arr (\\<Psi> (\\<Phi> f))\n\ngoal (1 subgoal):\n 1. S.Fun (\\<Psi> (\\<Phi> f)) = S.Fun f", "have \"\\<Psi> (\\<Phi> f) = S.mkArr (S.set (S.dom f)) (S.set (S.cod f)) (\\<Psi>a (\\<Phi> f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi> (\\<Phi> f) =\n    S.mkArr (S.set (S.dom f)) (S.set (S.cod f)) (\\<Psi>a (\\<Phi> f))", "using assms INV.\\<Phi>_def \\<Phi>_in_hom \\<Psi>o_\\<Phi>o"], ["proof (prove)\nusing this:\n  S.arr f\n  \\<Psi> ?f =\n  (if S'.arr ?f\n   then S.mkArr (S.set (\\<Psi>o (S'.dom ?f))) (S.set (\\<Psi>o (S'.cod ?f)))\n         (\\<Psi>a ?f)\n   else S.null)\n  S.arr ?f \\<Longrightarrow>\n  \\<Phi> ?f \\<in> S'.hom (\\<Phi>o (S.dom ?f)) (\\<Phi>o (S.cod ?f))\n  S.ide ?a \\<Longrightarrow> \\<Psi>o (\\<Phi>o ?a) = ?a\n\ngoal (1 subgoal):\n 1. \\<Psi> (\\<Phi> f) =\n    S.mkArr (S.set (S.dom f)) (S.set (S.cod f)) (\\<Psi>a (\\<Phi> f))", "by auto"], ["proof (state)\nthis:\n  \\<Psi> (\\<Phi> f) =\n  S.mkArr (S.set (S.dom f)) (S.set (S.cod f)) (\\<Psi>a (\\<Phi> f))\n\ngoal (1 subgoal):\n 1. S.Fun (\\<Psi> (\\<Phi> f)) = S.Fun f", "moreover"], ["proof (state)\nthis:\n  \\<Psi> (\\<Phi> f) =\n  S.mkArr (S.set (S.dom f)) (S.set (S.cod f)) (\\<Psi>a (\\<Phi> f))\n\ngoal (1 subgoal):\n 1. S.Fun (\\<Psi> (\\<Phi> f)) = S.Fun f", "have \"\\<Psi>a (\\<Phi> f) = (\\<lambda>x \\<in> S.set (S.dom f). \\<psi> (S'.Fun (\\<Phi> f) (\\<phi> x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi>a (\\<Phi> f) =\n    (\\<lambda>x\\<in>S.set (S.dom f). \\<psi> (S'.Fun (\\<Phi> f) (\\<phi> x)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Psi>a (\\<Phi> f) =\n    (\\<lambda>x\\<in>S.set (S.dom f). \\<psi> (S'.Fun (\\<Phi> f) (\\<phi> x)))", "have \"\\<Psi>a (\\<Phi> f) = (\\<lambda>x \\<in> \\<psi> ` S'.set (S'.dom (\\<Phi> f)). \\<psi> (S'.Fun (\\<Phi> f) (\\<phi> x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi>a (\\<Phi> f) =\n    (\\<lambda>x\\<in>\\<psi> ` S'.set (S'.dom (\\<Phi> f)).\n        \\<psi> (S'.Fun (\\<Phi> f) (\\<phi> x)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Psi>a (\\<Phi> f) =\n    (\\<lambda>x\\<in>\\<psi> ` S'.set (S'.dom (\\<Phi> f)).\n        \\<psi> (S'.Fun (\\<Phi> f) (\\<phi> x)))", "have \"\\<And>x. x \\<in> \\<psi> ` S'.set (S'.dom (\\<Phi> f)) \\<Longrightarrow> INV.\\<psi> x = \\<phi> x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<psi> ` S'.set (S'.dom (\\<Phi> f)) \\<Longrightarrow>\n       INV.\\<psi> x = \\<phi> x", "using assms S.ide_dom S.set_subset_Univ \\<Psi>.preserves_reflects_arr par bij_\\<phi>\n                    inv_into_inv_into_eq subsetCE INV.set_dom_\\<Phi>"], ["proof (prove)\nusing this:\n  S.arr f\n  S.arr ?f \\<Longrightarrow> S.ide (S.dom ?f)\n  S.ide ?a \\<Longrightarrow> S.set ?a \\<subseteq> S.Univ\n  S.arr (\\<Psi> ?f) = S'.arr ?f\n  S.par (\\<Psi> (\\<Phi> f)) f\n  bij_betw \\<phi> S.Univ S'.Univ\n  \\<lbrakk>bij_betw ?f ?A ?A'; ?a \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> inv_into ?A' (inv_into ?A ?f) ?a = ?f ?a\n  \\<lbrakk>?A \\<subseteq> ?B; ?c \\<notin> ?A \\<Longrightarrow> ?P;\n   ?c \\<in> ?B \\<Longrightarrow> ?P\\<rbrakk>\n  \\<Longrightarrow> ?P\n  S'.arr ?f \\<Longrightarrow>\n  S.set (S.dom (\\<Psi> ?f)) = \\<psi> ` S'.set (S'.dom ?f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> \\<psi> ` S'.set (S'.dom (\\<Phi> f)) \\<Longrightarrow>\n       INV.\\<psi> x = \\<phi> x", "by metis"], ["proof (state)\nthis:\n  ?x \\<in> \\<psi> ` S'.set (S'.dom (\\<Phi> f)) \\<Longrightarrow>\n  INV.\\<psi> ?x = \\<phi> ?x\n\ngoal (1 subgoal):\n 1. \\<Psi>a (\\<Phi> f) =\n    (\\<lambda>x\\<in>\\<psi> ` S'.set (S'.dom (\\<Phi> f)).\n        \\<psi> (S'.Fun (\\<Phi> f) (\\<phi> x)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  ?x \\<in> \\<psi> ` S'.set (S'.dom (\\<Phi> f)) \\<Longrightarrow>\n  INV.\\<psi> ?x = \\<phi> ?x\n\ngoal (1 subgoal):\n 1. \\<Psi>a (\\<Phi> f) =\n    (\\<lambda>x\\<in>\\<psi> ` S'.set (S'.dom (\\<Phi> f)).\n        \\<psi> (S'.Fun (\\<Phi> f) (\\<phi> x)))", "using INV.\\<Phi>a_def"], ["proof (prove)\nusing this:\n  ?x \\<in> \\<psi> ` S'.set (S'.dom (\\<Phi> f)) \\<Longrightarrow>\n  INV.\\<psi> ?x = \\<phi> ?x\n  \\<Psi>a =\n  (\\<lambda>f.\n      \\<lambda>x'\\<in>\\<psi> ` S'.set (S'.dom f).\n         \\<psi> (S'.Fun f (INV.\\<psi> x')))\n\ngoal (1 subgoal):\n 1. \\<Psi>a (\\<Phi> f) =\n    (\\<lambda>x\\<in>\\<psi> ` S'.set (S'.dom (\\<Phi> f)).\n        \\<psi> (S'.Fun (\\<Phi> f) (\\<phi> x)))", "by auto"], ["proof (state)\nthis:\n  \\<Psi>a (\\<Phi> f) =\n  (\\<lambda>x\\<in>\\<psi> ` S'.set (S'.dom (\\<Phi> f)).\n      \\<psi> (S'.Fun (\\<Phi> f) (\\<phi> x)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Psi>a (\\<Phi> f) =\n  (\\<lambda>x\\<in>\\<psi> ` S'.set (S'.dom (\\<Phi> f)).\n      \\<psi> (S'.Fun (\\<Phi> f) (\\<phi> x)))\n\ngoal (1 subgoal):\n 1. \\<Psi>a (\\<Phi> f) =\n    (\\<lambda>x\\<in>S.set (S.dom f). \\<psi> (S'.Fun (\\<Phi> f) (\\<phi> x)))", "moreover"], ["proof (state)\nthis:\n  \\<Psi>a (\\<Phi> f) =\n  (\\<lambda>x\\<in>\\<psi> ` S'.set (S'.dom (\\<Phi> f)).\n      \\<psi> (S'.Fun (\\<Phi> f) (\\<phi> x)))\n\ngoal (1 subgoal):\n 1. \\<Psi>a (\\<Phi> f) =\n    (\\<lambda>x\\<in>S.set (S.dom f). \\<psi> (S'.Fun (\\<Phi> f) (\\<phi> x)))", "have \"\\<psi> ` S'.set (S'.dom (\\<Phi> f)) = S.set (S.dom f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> ` S'.set (S'.dom (\\<Phi> f)) = S.set (S.dom f)", "using assms"], ["proof (prove)\nusing this:\n  S.arr f\n\ngoal (1 subgoal):\n 1. \\<psi> ` S'.set (S'.dom (\\<Phi> f)) = S.set (S.dom f)", "by (metis par \\<Psi>.preserves_reflects_arr INV.set_dom_\\<Phi>)"], ["proof (state)\nthis:\n  \\<psi> ` S'.set (S'.dom (\\<Phi> f)) = S.set (S.dom f)\n\ngoal (1 subgoal):\n 1. \\<Psi>a (\\<Phi> f) =\n    (\\<lambda>x\\<in>S.set (S.dom f). \\<psi> (S'.Fun (\\<Phi> f) (\\<phi> x)))", "ultimately"], ["proof (chain)\npicking this:\n  \\<Psi>a (\\<Phi> f) =\n  (\\<lambda>x\\<in>\\<psi> ` S'.set (S'.dom (\\<Phi> f)).\n      \\<psi> (S'.Fun (\\<Phi> f) (\\<phi> x)))\n  \\<psi> ` S'.set (S'.dom (\\<Phi> f)) = S.set (S.dom f)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<Psi>a (\\<Phi> f) =\n  (\\<lambda>x\\<in>\\<psi> ` S'.set (S'.dom (\\<Phi> f)).\n      \\<psi> (S'.Fun (\\<Phi> f) (\\<phi> x)))\n  \\<psi> ` S'.set (S'.dom (\\<Phi> f)) = S.set (S.dom f)\n\ngoal (1 subgoal):\n 1. \\<Psi>a (\\<Phi> f) =\n    (\\<lambda>x\\<in>S.set (S.dom f). \\<psi> (S'.Fun (\\<Phi> f) (\\<phi> x)))", "by auto"], ["proof (state)\nthis:\n  \\<Psi>a (\\<Phi> f) =\n  (\\<lambda>x\\<in>S.set (S.dom f). \\<psi> (S'.Fun (\\<Phi> f) (\\<phi> x)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<Psi>a (\\<Phi> f) =\n  (\\<lambda>x\\<in>S.set (S.dom f). \\<psi> (S'.Fun (\\<Phi> f) (\\<phi> x)))\n\ngoal (1 subgoal):\n 1. S.Fun (\\<Psi> (\\<Phi> f)) = S.Fun f", "ultimately"], ["proof (chain)\npicking this:\n  S.arr (\\<Psi> (\\<Phi> f))\n  \\<Psi> (\\<Phi> f) =\n  S.mkArr (S.set (S.dom f)) (S.set (S.cod f)) (\\<Psi>a (\\<Phi> f))\n  \\<Psi>a (\\<Phi> f) =\n  (\\<lambda>x\\<in>S.set (S.dom f). \\<psi> (S'.Fun (\\<Phi> f) (\\<phi> x)))", "have 1: \"S.Fun (\\<Psi> (\\<Phi> f)) = (\\<lambda>x \\<in> S.set (S.dom f). \\<psi> (S'.Fun (\\<Phi> f) (\\<phi> x)))\""], ["proof (prove)\nusing this:\n  S.arr (\\<Psi> (\\<Phi> f))\n  \\<Psi> (\\<Phi> f) =\n  S.mkArr (S.set (S.dom f)) (S.set (S.cod f)) (\\<Psi>a (\\<Phi> f))\n  \\<Psi>a (\\<Phi> f) =\n  (\\<lambda>x\\<in>S.set (S.dom f). \\<psi> (S'.Fun (\\<Phi> f) (\\<phi> x)))\n\ngoal (1 subgoal):\n 1. S.Fun (\\<Psi> (\\<Phi> f)) =\n    (\\<lambda>x\\<in>S.set (S.dom f). \\<psi> (S'.Fun (\\<Phi> f) (\\<phi> x)))", "using S'.Fun_mkArr"], ["proof (prove)\nusing this:\n  S.arr (\\<Psi> (\\<Phi> f))\n  \\<Psi> (\\<Phi> f) =\n  S.mkArr (S.set (S.dom f)) (S.set (S.cod f)) (\\<Psi>a (\\<Phi> f))\n  \\<Psi>a (\\<Phi> f) =\n  (\\<lambda>x\\<in>S.set (S.dom f). \\<psi> (S'.Fun (\\<Phi> f) (\\<phi> x)))\n  S'.arr (S'.mkArr ?A ?B ?F) \\<Longrightarrow>\n  S'.Fun (S'.mkArr ?A ?B ?F) = restrict ?F ?A\n\ngoal (1 subgoal):\n 1. S.Fun (\\<Psi> (\\<Phi> f)) =\n    (\\<lambda>x\\<in>S.set (S.dom f). \\<psi> (S'.Fun (\\<Phi> f) (\\<phi> x)))", "by simp"], ["proof (state)\nthis:\n  S.Fun (\\<Psi> (\\<Phi> f)) =\n  (\\<lambda>x\\<in>S.set (S.dom f). \\<psi> (S'.Fun (\\<Phi> f) (\\<phi> x)))\n\ngoal (1 subgoal):\n 1. S.Fun (\\<Psi> (\\<Phi> f)) = S.Fun f", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. S.Fun (\\<Psi> (\\<Phi> f)) = S.Fun f", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. S.Fun (\\<Psi> (\\<Phi> f)) x = S.Fun f x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. S.Fun (\\<Psi> (\\<Phi> f)) x = S.Fun f x", "have \"x \\<notin> S.set (S.dom f) \\<Longrightarrow> S.Fun (\\<Psi> (\\<Phi> f)) x = S.Fun f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> S.set (S.dom f) \\<Longrightarrow>\n    S.Fun (\\<Psi> (\\<Phi> f)) x = S.Fun f x", "using 1 assms extensional_def S.Fun_mapsto S.Fun_def"], ["proof (prove)\nusing this:\n  S.Fun (\\<Psi> (\\<Phi> f)) =\n  (\\<lambda>x\\<in>S.set (S.dom f). \\<psi> (S'.Fun (\\<Phi> f) (\\<phi> x)))\n  S.arr f\n  extensional ?A =\n  {f. \\<forall>x. x \\<notin> ?A \\<longrightarrow> f x = undefined}\n  S.arr ?f \\<Longrightarrow>\n  S.Fun ?f\n  \\<in> extensional (S.set (S.dom ?f)) \\<inter>\n        (S.set (S.dom ?f) \\<rightarrow> S.set (S.cod ?f))\n  S.Fun ?f =\n  restrict\n   (S.some_img \\<circ> (\\<cdot>) ?f \\<circ>\n    inv_into (S.hom S.unity (S.dom ?f)) S.some_img)\n   (S.set (S.dom ?f))\n\ngoal (1 subgoal):\n 1. x \\<notin> S.set (S.dom f) \\<Longrightarrow>\n    S.Fun (\\<Psi> (\\<Phi> f)) x = S.Fun f x", "by auto"], ["proof (state)\nthis:\n  x \\<notin> S.set (S.dom f) \\<Longrightarrow>\n  S.Fun (\\<Psi> (\\<Phi> f)) x = S.Fun f x\n\ngoal (1 subgoal):\n 1. \\<And>x. S.Fun (\\<Psi> (\\<Phi> f)) x = S.Fun f x", "moreover"], ["proof (state)\nthis:\n  x \\<notin> S.set (S.dom f) \\<Longrightarrow>\n  S.Fun (\\<Psi> (\\<Phi> f)) x = S.Fun f x\n\ngoal (1 subgoal):\n 1. \\<And>x. S.Fun (\\<Psi> (\\<Phi> f)) x = S.Fun f x", "have \"x \\<in> S.set (S.dom f) \\<Longrightarrow> S.Fun (\\<Psi> (\\<Phi> f)) x = S.Fun f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> S.set (S.dom f) \\<Longrightarrow>\n    S.Fun (\\<Psi> (\\<Phi> f)) x = S.Fun f x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> S.set (S.dom f) \\<Longrightarrow>\n    S.Fun (\\<Psi> (\\<Phi> f)) x = S.Fun f x", "assume x: \"x \\<in> S.set (S.dom f)\""], ["proof (state)\nthis:\n  x \\<in> S.set (S.dom f)\n\ngoal (1 subgoal):\n 1. x \\<in> S.set (S.dom f) \\<Longrightarrow>\n    S.Fun (\\<Psi> (\\<Phi> f)) x = S.Fun f x", "have \"S.Fun (\\<Psi> (\\<Phi> f)) x = \\<psi> (\\<phi> (S.Fun f (\\<psi> (\\<phi> x))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.Fun (\\<Psi> (\\<Phi> f)) x =\n    \\<psi> (\\<phi> (S.Fun f (\\<psi> (\\<phi> x))))", "using assms x 1 Fun_\\<Phi> bij_\\<phi> \\<Phi>a_def"], ["proof (prove)\nusing this:\n  S.arr f\n  x \\<in> S.set (S.dom f)\n  S.Fun (\\<Psi> (\\<Phi> f)) =\n  (\\<lambda>x\\<in>S.set (S.dom f). \\<psi> (S'.Fun (\\<Phi> f) (\\<phi> x)))\n  \\<lbrakk>S.arr ?f; ?x \\<in> S.set (S.dom ?f)\\<rbrakk>\n  \\<Longrightarrow> S'.Fun (\\<Phi> ?f) (\\<phi> ?x) = \\<Phi>a ?f (\\<phi> ?x)\n  bij_betw \\<phi> S.Univ S'.Univ\n  \\<Phi>a =\n  (\\<lambda>f.\n      \\<lambda>x'\\<in>\\<phi> ` S.set (S.dom f).\n         \\<phi> (S.Fun f (\\<psi> x')))\n\ngoal (1 subgoal):\n 1. S.Fun (\\<Psi> (\\<Phi> f)) x =\n    \\<psi> (\\<phi> (S.Fun f (\\<psi> (\\<phi> x))))", "by auto"], ["proof (state)\nthis:\n  S.Fun (\\<Psi> (\\<Phi> f)) x =\n  \\<psi> (\\<phi> (S.Fun f (\\<psi> (\\<phi> x))))\n\ngoal (1 subgoal):\n 1. x \\<in> S.set (S.dom f) \\<Longrightarrow>\n    S.Fun (\\<Psi> (\\<Phi> f)) x = S.Fun f x", "also"], ["proof (state)\nthis:\n  S.Fun (\\<Psi> (\\<Phi> f)) x =\n  \\<psi> (\\<phi> (S.Fun f (\\<psi> (\\<phi> x))))\n\ngoal (1 subgoal):\n 1. x \\<in> S.set (S.dom f) \\<Longrightarrow>\n    S.Fun (\\<Psi> (\\<Phi> f)) x = S.Fun f x", "have \"... = S.Fun f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<psi> (\\<phi> (S.Fun f (\\<psi> (\\<phi> x)))) = S.Fun f x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<psi> (\\<phi> (S.Fun f (\\<psi> (\\<phi> x)))) = S.Fun f x", "have 2: \"\\<And>x. x \\<in> S.Univ \\<Longrightarrow> \\<psi> (\\<phi> x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S.Univ \\<Longrightarrow> \\<psi> (\\<phi> x) = x", "using bij_\\<phi> bij_betw_inv_into_left"], ["proof (prove)\nusing this:\n  bij_betw \\<phi> S.Univ S'.Univ\n  \\<lbrakk>bij_betw ?f ?A ?A'; ?a \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> inv_into ?A ?f (?f ?a) = ?a\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> S.Univ \\<Longrightarrow> \\<psi> (\\<phi> x) = x", "by fast"], ["proof (state)\nthis:\n  ?x \\<in> S.Univ \\<Longrightarrow> \\<psi> (\\<phi> ?x) = ?x\n\ngoal (1 subgoal):\n 1. \\<psi> (\\<phi> (S.Fun f (\\<psi> (\\<phi> x)))) = S.Fun f x", "have \"S.Fun f (\\<psi> (\\<phi> x)) = S.Fun f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.Fun f (\\<psi> (\\<phi> x)) = S.Fun f x", "using assms x 2"], ["proof (prove)\nusing this:\n  S.arr f\n  x \\<in> S.set (S.dom f)\n  ?x \\<in> S.Univ \\<Longrightarrow> \\<psi> (\\<phi> ?x) = ?x\n\ngoal (1 subgoal):\n 1. S.Fun f (\\<psi> (\\<phi> x)) = S.Fun f x", "by (metis S.ide_dom S.set_subset_Univ subsetCE)"], ["proof (state)\nthis:\n  S.Fun f (\\<psi> (\\<phi> x)) = S.Fun f x\n\ngoal (1 subgoal):\n 1. \\<psi> (\\<phi> (S.Fun f (\\<psi> (\\<phi> x)))) = S.Fun f x", "moreover"], ["proof (state)\nthis:\n  S.Fun f (\\<psi> (\\<phi> x)) = S.Fun f x\n\ngoal (1 subgoal):\n 1. \\<psi> (\\<phi> (S.Fun f (\\<psi> (\\<phi> x)))) = S.Fun f x", "have \"S.Fun f x \\<in> S.Univ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S.Fun f x \\<in> S.Univ", "using x assms S.Fun_mapsto S.set_subset_Univ S.ide_cod"], ["proof (prove)\nusing this:\n  x \\<in> S.set (S.dom f)\n  S.arr f\n  S.arr ?f \\<Longrightarrow>\n  S.Fun ?f\n  \\<in> extensional (S.set (S.dom ?f)) \\<inter>\n        (S.set (S.dom ?f) \\<rightarrow> S.set (S.cod ?f))\n  S.ide ?a \\<Longrightarrow> S.set ?a \\<subseteq> S.Univ\n  S.arr ?f \\<Longrightarrow> S.ide (S.cod ?f)\n\ngoal (1 subgoal):\n 1. S.Fun f x \\<in> S.Univ", "by blast"], ["proof (state)\nthis:\n  S.Fun f x \\<in> S.Univ\n\ngoal (1 subgoal):\n 1. \\<psi> (\\<phi> (S.Fun f (\\<psi> (\\<phi> x)))) = S.Fun f x", "ultimately"], ["proof (chain)\npicking this:\n  S.Fun f (\\<psi> (\\<phi> x)) = S.Fun f x\n  S.Fun f x \\<in> S.Univ", "show ?thesis"], ["proof (prove)\nusing this:\n  S.Fun f (\\<psi> (\\<phi> x)) = S.Fun f x\n  S.Fun f x \\<in> S.Univ\n\ngoal (1 subgoal):\n 1. \\<psi> (\\<phi> (S.Fun f (\\<psi> (\\<phi> x)))) = S.Fun f x", "using 2"], ["proof (prove)\nusing this:\n  S.Fun f (\\<psi> (\\<phi> x)) = S.Fun f x\n  S.Fun f x \\<in> S.Univ\n  ?x \\<in> S.Univ \\<Longrightarrow> \\<psi> (\\<phi> ?x) = ?x\n\ngoal (1 subgoal):\n 1. \\<psi> (\\<phi> (S.Fun f (\\<psi> (\\<phi> x)))) = S.Fun f x", "by auto"], ["proof (state)\nthis:\n  \\<psi> (\\<phi> (S.Fun f (\\<psi> (\\<phi> x)))) = S.Fun f x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<psi> (\\<phi> (S.Fun f (\\<psi> (\\<phi> x)))) = S.Fun f x\n\ngoal (1 subgoal):\n 1. x \\<in> S.set (S.dom f) \\<Longrightarrow>\n    S.Fun (\\<Psi> (\\<Phi> f)) x = S.Fun f x", "finally"], ["proof (chain)\npicking this:\n  S.Fun (\\<Psi> (\\<Phi> f)) x = S.Fun f x", "show ?thesis"], ["proof (prove)\nusing this:\n  S.Fun (\\<Psi> (\\<Phi> f)) x = S.Fun f x\n\ngoal (1 subgoal):\n 1. S.Fun (\\<Psi> (\\<Phi> f)) x = S.Fun f x", "by auto"], ["proof (state)\nthis:\n  S.Fun (\\<Psi> (\\<Phi> f)) x = S.Fun f x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> S.set (S.dom f) \\<Longrightarrow>\n  S.Fun (\\<Psi> (\\<Phi> f)) x = S.Fun f x\n\ngoal (1 subgoal):\n 1. \\<And>x. S.Fun (\\<Psi> (\\<Phi> f)) x = S.Fun f x", "ultimately"], ["proof (chain)\npicking this:\n  x \\<notin> S.set (S.dom f) \\<Longrightarrow>\n  S.Fun (\\<Psi> (\\<Phi> f)) x = S.Fun f x\n  x \\<in> S.set (S.dom f) \\<Longrightarrow>\n  S.Fun (\\<Psi> (\\<Phi> f)) x = S.Fun f x", "show \"S.Fun (\\<Psi> (\\<Phi> f)) x = S.Fun f x\""], ["proof (prove)\nusing this:\n  x \\<notin> S.set (S.dom f) \\<Longrightarrow>\n  S.Fun (\\<Psi> (\\<Phi> f)) x = S.Fun f x\n  x \\<in> S.set (S.dom f) \\<Longrightarrow>\n  S.Fun (\\<Psi> (\\<Phi> f)) x = S.Fun f x\n\ngoal (1 subgoal):\n 1. S.Fun (\\<Psi> (\\<Phi> f)) x = S.Fun f x", "by auto"], ["proof (state)\nthis:\n  S.Fun (\\<Psi> (\\<Phi> f)) x = S.Fun f x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S.Fun (\\<Psi> (\\<Phi> f)) = S.Fun f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S.Fun (\\<Psi> (\\<Phi> f)) = S.Fun f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma \\<Phi>o_\\<Psi>o:\n    assumes \"S'.ide a'\"\n    shows \"\\<Phi>o (\\<Psi>o a') = a'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi>o (\\<Psi>o a') = a'", "using assms \\<Phi>o_def INV.\\<Phi>o_def \\<phi>_img_\\<psi>_img INV.\\<Phi>o_preserves_ide \\<psi>_\\<phi> INV.set_\\<Phi>o\n            S'.mkIde_set"], ["proof (prove)\nusing this:\n  S'.ide a'\n  \\<Phi>o = (\\<lambda>a\\<in>Collect S.ide. S'.mkIde (\\<phi> ` S.set a))\n  \\<Psi>o = (\\<lambda>a\\<in>Collect S'.ide. S.mkIde (\\<psi> ` S'.set a))\n  ?A' \\<subseteq> S'.Univ \\<Longrightarrow> \\<phi> ` \\<psi> ` ?A' = ?A'\n  S'.ide ?a \\<Longrightarrow> S.ide (\\<Psi>o ?a)\n  ?t \\<in> S.Univ \\<Longrightarrow> \\<psi> (\\<phi> ?t) = ?t\n  S'.ide ?a \\<Longrightarrow> S.set (\\<Psi>o ?a) = \\<psi> ` S'.set ?a\n  S'.ide ?a \\<Longrightarrow> S'.mkIde (S'.set ?a) = ?a\n\ngoal (1 subgoal):\n 1. \\<Phi>o (\\<Psi>o a') = a'", "by force"], ["", "lemma \\<Psi>\\<Phi>:\n    assumes \"S'.arr f'\"\n    shows \"\\<Phi> (\\<Psi> f') = f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> (\\<Psi> f') = f'", "proof (intro S'.arr_eqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. S'.par (\\<Phi> (\\<Psi> f')) f'\n 2. S'.Fun (\\<Phi> (\\<Psi> f')) = S'.Fun f'", "show par: \"S'.par (\\<Phi> (\\<Psi> f')) f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S'.par (\\<Phi> (\\<Psi> f')) f'", "using assms \\<Phi>.preserves_ide \\<Psi>.preserves_ide \\<Phi>_ide INV.\\<Phi>_ide \\<Phi>o_\\<Psi>o"], ["proof (prove)\nusing this:\n  S'.arr f'\n  S.ide ?a \\<Longrightarrow> S'.ide (\\<Phi> ?a)\n  S'.ide ?a \\<Longrightarrow> S.ide (\\<Psi> ?a)\n  S.ide ?a \\<Longrightarrow> \\<Phi> ?a = \\<Phi>o ?a\n  S'.ide ?a \\<Longrightarrow> \\<Psi> ?a = \\<Psi>o ?a\n  S'.ide ?a' \\<Longrightarrow> \\<Phi>o (\\<Psi>o ?a') = ?a'\n\ngoal (1 subgoal):\n 1. S'.par (\\<Phi> (\\<Psi> f')) f'", "by auto"], ["proof (state)\nthis:\n  S'.par (\\<Phi> (\\<Psi> f')) f'\n\ngoal (1 subgoal):\n 1. S'.Fun (\\<Phi> (\\<Psi> f')) = S'.Fun f'", "show \"S'.Fun (\\<Phi> (\\<Psi> f')) = S'.Fun f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S'.Fun (\\<Phi> (\\<Psi> f')) = S'.Fun f'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. S'.Fun (\\<Phi> (\\<Psi> f')) = S'.Fun f'", "have \"S'.arr (\\<Phi> (\\<Psi> f'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S'.arr (\\<Phi> (\\<Psi> f'))", "using assms"], ["proof (prove)\nusing this:\n  S'.arr f'\n\ngoal (1 subgoal):\n 1. S'.arr (\\<Phi> (\\<Psi> f'))", "by blast"], ["proof (state)\nthis:\n  S'.arr (\\<Phi> (\\<Psi> f'))\n\ngoal (1 subgoal):\n 1. S'.Fun (\\<Phi> (\\<Psi> f')) = S'.Fun f'", "moreover"], ["proof (state)\nthis:\n  S'.arr (\\<Phi> (\\<Psi> f'))\n\ngoal (1 subgoal):\n 1. S'.Fun (\\<Phi> (\\<Psi> f')) = S'.Fun f'", "have \"\\<Phi> (\\<Psi> f') =\n                       S'.mkArr (S'.set (S'.dom f')) (S'.set (S'.cod f')) (\\<Phi>a (\\<Psi> f'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi> (\\<Psi> f') =\n    S'.mkArr (S'.set (S'.dom f')) (S'.set (S'.cod f')) (\\<Phi>a (\\<Psi> f'))", "using assms \\<Phi>_def INV.\\<Phi>_in_hom \\<Phi>o_\\<Psi>o"], ["proof (prove)\nusing this:\n  S'.arr f'\n  \\<Phi> ?f =\n  (if S.arr ?f\n   then S'.mkArr (S'.set (\\<Phi>o (S.dom ?f))) (S'.set (\\<Phi>o (S.cod ?f)))\n         (\\<Phi>a ?f)\n   else S'.null)\n  S'.arr ?f \\<Longrightarrow>\n  \\<Psi> ?f \\<in> S.hom (\\<Psi>o (S'.dom ?f)) (\\<Psi>o (S'.cod ?f))\n  S'.ide ?a' \\<Longrightarrow> \\<Phi>o (\\<Psi>o ?a') = ?a'\n\ngoal (1 subgoal):\n 1. \\<Phi> (\\<Psi> f') =\n    S'.mkArr (S'.set (S'.dom f')) (S'.set (S'.cod f')) (\\<Phi>a (\\<Psi> f'))", "by simp"], ["proof (state)\nthis:\n  \\<Phi> (\\<Psi> f') =\n  S'.mkArr (S'.set (S'.dom f')) (S'.set (S'.cod f')) (\\<Phi>a (\\<Psi> f'))\n\ngoal (1 subgoal):\n 1. S'.Fun (\\<Phi> (\\<Psi> f')) = S'.Fun f'", "moreover"], ["proof (state)\nthis:\n  \\<Phi> (\\<Psi> f') =\n  S'.mkArr (S'.set (S'.dom f')) (S'.set (S'.cod f')) (\\<Phi>a (\\<Psi> f'))\n\ngoal (1 subgoal):\n 1. S'.Fun (\\<Phi> (\\<Psi> f')) = S'.Fun f'", "have \"\\<Phi>a (\\<Psi> f') = (\\<lambda>x' \\<in> S'.set (S'.dom f'). \\<phi> (S.Fun (\\<Psi> f') (\\<psi> x')))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi>a (\\<Psi> f') =\n    (\\<lambda>x'\\<in>S'.set (S'.dom f').\n        \\<phi> (S.Fun (\\<Psi> f') (\\<psi> x')))", "unfolding \\<Phi>a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom (\\<Psi> f')).\n        \\<phi> (S.Fun (\\<Psi> f') (\\<psi> x'))) =\n    (\\<lambda>x'\\<in>S'.set (S'.dom f').\n        \\<phi> (S.Fun (\\<Psi> f') (\\<psi> x')))", "using assms par \\<Psi>.preserves_arr set_dom_\\<Phi>"], ["proof (prove)\nusing this:\n  S'.arr f'\n  S'.par (\\<Phi> (\\<Psi> f')) f'\n  S'.arr ?f \\<Longrightarrow> S.arr (\\<Psi> ?f)\n  S.arr ?f \\<Longrightarrow>\n  S'.set (S'.dom (\\<Phi> ?f)) = \\<phi> ` S.set (S.dom ?f)\n\ngoal (1 subgoal):\n 1. (\\<lambda>x'\\<in>\\<phi> ` S.set (S.dom (\\<Psi> f')).\n        \\<phi> (S.Fun (\\<Psi> f') (\\<psi> x'))) =\n    (\\<lambda>x'\\<in>S'.set (S'.dom f').\n        \\<phi> (S.Fun (\\<Psi> f') (\\<psi> x')))", "by metis"], ["proof (state)\nthis:\n  \\<Phi>a (\\<Psi> f') =\n  (\\<lambda>x'\\<in>S'.set (S'.dom f').\n      \\<phi> (S.Fun (\\<Psi> f') (\\<psi> x')))\n\ngoal (1 subgoal):\n 1. S'.Fun (\\<Phi> (\\<Psi> f')) = S'.Fun f'", "ultimately"], ["proof (chain)\npicking this:\n  S'.arr (\\<Phi> (\\<Psi> f'))\n  \\<Phi> (\\<Psi> f') =\n  S'.mkArr (S'.set (S'.dom f')) (S'.set (S'.cod f')) (\\<Phi>a (\\<Psi> f'))\n  \\<Phi>a (\\<Psi> f') =\n  (\\<lambda>x'\\<in>S'.set (S'.dom f').\n      \\<phi> (S.Fun (\\<Psi> f') (\\<psi> x')))", "have 1: \"S'.Fun (\\<Phi> (\\<Psi> f')) =\n                            (\\<lambda>x' \\<in> S'.set (S'.dom f'). \\<phi> (S.Fun (\\<Psi> f') (\\<psi> x')))\""], ["proof (prove)\nusing this:\n  S'.arr (\\<Phi> (\\<Psi> f'))\n  \\<Phi> (\\<Psi> f') =\n  S'.mkArr (S'.set (S'.dom f')) (S'.set (S'.cod f')) (\\<Phi>a (\\<Psi> f'))\n  \\<Phi>a (\\<Psi> f') =\n  (\\<lambda>x'\\<in>S'.set (S'.dom f').\n      \\<phi> (S.Fun (\\<Psi> f') (\\<psi> x')))\n\ngoal (1 subgoal):\n 1. S'.Fun (\\<Phi> (\\<Psi> f')) =\n    (\\<lambda>x'\\<in>S'.set (S'.dom f').\n        \\<phi> (S.Fun (\\<Psi> f') (\\<psi> x')))", "using S'.Fun_mkArr"], ["proof (prove)\nusing this:\n  S'.arr (\\<Phi> (\\<Psi> f'))\n  \\<Phi> (\\<Psi> f') =\n  S'.mkArr (S'.set (S'.dom f')) (S'.set (S'.cod f')) (\\<Phi>a (\\<Psi> f'))\n  \\<Phi>a (\\<Psi> f') =\n  (\\<lambda>x'\\<in>S'.set (S'.dom f').\n      \\<phi> (S.Fun (\\<Psi> f') (\\<psi> x')))\n  S'.arr (S'.mkArr ?A ?B ?F) \\<Longrightarrow>\n  S'.Fun (S'.mkArr ?A ?B ?F) = restrict ?F ?A\n\ngoal (1 subgoal):\n 1. S'.Fun (\\<Phi> (\\<Psi> f')) =\n    (\\<lambda>x'\\<in>S'.set (S'.dom f').\n        \\<phi> (S.Fun (\\<Psi> f') (\\<psi> x')))", "by simp"], ["proof (state)\nthis:\n  S'.Fun (\\<Phi> (\\<Psi> f')) =\n  (\\<lambda>x'\\<in>S'.set (S'.dom f').\n      \\<phi> (S.Fun (\\<Psi> f') (\\<psi> x')))\n\ngoal (1 subgoal):\n 1. S'.Fun (\\<Phi> (\\<Psi> f')) = S'.Fun f'", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. S'.Fun (\\<Phi> (\\<Psi> f')) = S'.Fun f'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. S'.Fun (\\<Phi> (\\<Psi> f')) x = S'.Fun f' x", "fix x'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. S'.Fun (\\<Phi> (\\<Psi> f')) x = S'.Fun f' x", "have \"x' \\<notin> S'.set (S'.dom f') \\<Longrightarrow> S'.Fun (\\<Phi> (\\<Psi> f')) x' = S'.Fun f' x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x' \\<notin> S'.set (S'.dom f') \\<Longrightarrow>\n    S'.Fun (\\<Phi> (\\<Psi> f')) x' = S'.Fun f' x'", "using 1 assms S'.Fun_mapsto extensional_def"], ["proof (prove)\nusing this:\n  S'.Fun (\\<Phi> (\\<Psi> f')) =\n  (\\<lambda>x'\\<in>S'.set (S'.dom f').\n      \\<phi> (S.Fun (\\<Psi> f') (\\<psi> x')))\n  S'.arr f'\n  S'.arr ?f \\<Longrightarrow>\n  S'.Fun ?f\n  \\<in> extensional (S'.set (S'.dom ?f)) \\<inter>\n        (S'.set (S'.dom ?f) \\<rightarrow> S'.set (S'.cod ?f))\n  extensional ?A =\n  {f. \\<forall>x. x \\<notin> ?A \\<longrightarrow> f x = undefined}\n\ngoal (1 subgoal):\n 1. x' \\<notin> S'.set (S'.dom f') \\<Longrightarrow>\n    S'.Fun (\\<Phi> (\\<Psi> f')) x' = S'.Fun f' x'", "by (simp add: S'.Fun_def)"], ["proof (state)\nthis:\n  x' \\<notin> S'.set (S'.dom f') \\<Longrightarrow>\n  S'.Fun (\\<Phi> (\\<Psi> f')) x' = S'.Fun f' x'\n\ngoal (1 subgoal):\n 1. \\<And>x. S'.Fun (\\<Phi> (\\<Psi> f')) x = S'.Fun f' x", "moreover"], ["proof (state)\nthis:\n  x' \\<notin> S'.set (S'.dom f') \\<Longrightarrow>\n  S'.Fun (\\<Phi> (\\<Psi> f')) x' = S'.Fun f' x'\n\ngoal (1 subgoal):\n 1. \\<And>x. S'.Fun (\\<Phi> (\\<Psi> f')) x = S'.Fun f' x", "have \"x' \\<in> S'.set (S'.dom f') \\<Longrightarrow> S'.Fun (\\<Phi> (\\<Psi> f')) x' = S'.Fun f' x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x' \\<in> S'.set (S'.dom f') \\<Longrightarrow>\n    S'.Fun (\\<Phi> (\\<Psi> f')) x' = S'.Fun f' x'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x' \\<in> S'.set (S'.dom f') \\<Longrightarrow>\n    S'.Fun (\\<Phi> (\\<Psi> f')) x' = S'.Fun f' x'", "assume x': \"x' \\<in> S'.set (S'.dom f')\""], ["proof (state)\nthis:\n  x' \\<in> S'.set (S'.dom f')\n\ngoal (1 subgoal):\n 1. x' \\<in> S'.set (S'.dom f') \\<Longrightarrow>\n    S'.Fun (\\<Phi> (\\<Psi> f')) x' = S'.Fun f' x'", "have \"S'.Fun (\\<Phi> (\\<Psi> f')) x' = \\<phi> (S.Fun (\\<Psi> f') (\\<psi> x'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S'.Fun (\\<Phi> (\\<Psi> f')) x' = \\<phi> (S.Fun (\\<Psi> f') (\\<psi> x'))", "using x' 1"], ["proof (prove)\nusing this:\n  x' \\<in> S'.set (S'.dom f')\n  S'.Fun (\\<Phi> (\\<Psi> f')) =\n  (\\<lambda>x'\\<in>S'.set (S'.dom f').\n      \\<phi> (S.Fun (\\<Psi> f') (\\<psi> x')))\n\ngoal (1 subgoal):\n 1. S'.Fun (\\<Phi> (\\<Psi> f')) x' = \\<phi> (S.Fun (\\<Psi> f') (\\<psi> x'))", "by auto"], ["proof (state)\nthis:\n  S'.Fun (\\<Phi> (\\<Psi> f')) x' = \\<phi> (S.Fun (\\<Psi> f') (\\<psi> x'))\n\ngoal (1 subgoal):\n 1. x' \\<in> S'.set (S'.dom f') \\<Longrightarrow>\n    S'.Fun (\\<Phi> (\\<Psi> f')) x' = S'.Fun f' x'", "also"], ["proof (state)\nthis:\n  S'.Fun (\\<Phi> (\\<Psi> f')) x' = \\<phi> (S.Fun (\\<Psi> f') (\\<psi> x'))\n\ngoal (1 subgoal):\n 1. x' \\<in> S'.set (S'.dom f') \\<Longrightarrow>\n    S'.Fun (\\<Phi> (\\<Psi> f')) x' = S'.Fun f' x'", "have \"... = \\<phi> (\\<Psi>a f' (\\<psi> x'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> (S.Fun (\\<Psi> f') (\\<psi> x')) = \\<phi> (\\<Psi>a f' (\\<psi> x'))", "using Fun_\\<Psi> x' assms S'.set_subset_Univ bij_\\<phi>"], ["proof (prove)\nusing this:\n  \\<lbrakk>S'.arr ?f'; ?x' \\<in> S'.set (S'.dom ?f')\\<rbrakk>\n  \\<Longrightarrow> S.Fun (\\<Psi> ?f') (\\<psi> ?x') =\n                    \\<Psi>a ?f' (\\<psi> ?x')\n  x' \\<in> S'.set (S'.dom f')\n  S'.arr f'\n  S'.ide ?a \\<Longrightarrow> S'.set ?a \\<subseteq> S'.Univ\n  bij_betw \\<phi> S.Univ S'.Univ\n\ngoal (1 subgoal):\n 1. \\<phi> (S.Fun (\\<Psi> f') (\\<psi> x')) = \\<phi> (\\<Psi>a f' (\\<psi> x'))", "by metis"], ["proof (state)\nthis:\n  \\<phi> (S.Fun (\\<Psi> f') (\\<psi> x')) = \\<phi> (\\<Psi>a f' (\\<psi> x'))\n\ngoal (1 subgoal):\n 1. x' \\<in> S'.set (S'.dom f') \\<Longrightarrow>\n    S'.Fun (\\<Phi> (\\<Psi> f')) x' = S'.Fun f' x'", "also"], ["proof (state)\nthis:\n  \\<phi> (S.Fun (\\<Psi> f') (\\<psi> x')) = \\<phi> (\\<Psi>a f' (\\<psi> x'))\n\ngoal (1 subgoal):\n 1. x' \\<in> S'.set (S'.dom f') \\<Longrightarrow>\n    S'.Fun (\\<Phi> (\\<Psi> f')) x' = S'.Fun f' x'", "have \"... = \\<phi> (\\<psi> (S'.Fun f' (\\<phi> (\\<psi> x'))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> (\\<Psi>a f' (\\<psi> x')) =\n    \\<phi> (\\<psi> (S'.Fun f' (\\<phi> (\\<psi> x'))))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<phi> (\\<Psi>a f' (\\<psi> x')) =\n    \\<phi> (\\<psi> (S'.Fun f' (\\<phi> (\\<psi> x'))))", "have \"\\<phi> (\\<Psi>a f' (\\<psi> x')) = \\<phi> (\\<psi> (S'.Fun f' x'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> (\\<Psi>a f' (\\<psi> x')) = \\<phi> (\\<psi> (S'.Fun f' x'))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<phi> (\\<Psi>a f' (\\<psi> x')) = \\<phi> (\\<psi> (S'.Fun f' x'))", "have \"x' \\<in> S'.Univ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x' \\<in> S'.Univ", "by (meson S'.ide_dom S'.set_subset_Univ assms subsetCE x')"], ["proof (state)\nthis:\n  x' \\<in> S'.Univ\n\ngoal (1 subgoal):\n 1. \\<phi> (\\<Psi>a f' (\\<psi> x')) = \\<phi> (\\<psi> (S'.Fun f' x'))", "thus ?thesis"], ["proof (prove)\nusing this:\n  x' \\<in> S'.Univ\n\ngoal (1 subgoal):\n 1. \\<phi> (\\<Psi>a f' (\\<psi> x')) = \\<phi> (\\<psi> (S'.Fun f' x'))", "by (simp add: INV.\\<Phi>a_def INV.\\<psi>_\\<phi> x')"], ["proof (state)\nthis:\n  \\<phi> (\\<Psi>a f' (\\<psi> x')) = \\<phi> (\\<psi> (S'.Fun f' x'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<phi> (\\<Psi>a f' (\\<psi> x')) = \\<phi> (\\<psi> (S'.Fun f' x'))\n\ngoal (1 subgoal):\n 1. \\<phi> (\\<Psi>a f' (\\<psi> x')) =\n    \\<phi> (\\<psi> (S'.Fun f' (\\<phi> (\\<psi> x'))))", "also"], ["proof (state)\nthis:\n  \\<phi> (\\<Psi>a f' (\\<psi> x')) = \\<phi> (\\<psi> (S'.Fun f' x'))\n\ngoal (1 subgoal):\n 1. \\<phi> (\\<Psi>a f' (\\<psi> x')) =\n    \\<phi> (\\<psi> (S'.Fun f' (\\<phi> (\\<psi> x'))))", "have \"... = \\<phi> (\\<psi> (S'.Fun f' (\\<phi> (\\<psi> x'))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> (\\<psi> (S'.Fun f' x')) =\n    \\<phi> (\\<psi> (S'.Fun f' (\\<phi> (\\<psi> x'))))", "using assms x' \\<phi>_\\<psi> S'.set_subset_Univ S'.ide_dom"], ["proof (prove)\nusing this:\n  S'.arr f'\n  x' \\<in> S'.set (S'.dom f')\n  ?t' \\<in> S'.Univ \\<Longrightarrow> \\<phi> (\\<psi> ?t') = ?t'\n  S'.ide ?a \\<Longrightarrow> S'.set ?a \\<subseteq> S'.Univ\n  S'.arr ?f \\<Longrightarrow> S'.ide (S'.dom ?f)\n\ngoal (1 subgoal):\n 1. \\<phi> (\\<psi> (S'.Fun f' x')) =\n    \\<phi> (\\<psi> (S'.Fun f' (\\<phi> (\\<psi> x'))))", "by (metis subsetCE)"], ["proof (state)\nthis:\n  \\<phi> (\\<psi> (S'.Fun f' x')) =\n  \\<phi> (\\<psi> (S'.Fun f' (\\<phi> (\\<psi> x'))))\n\ngoal (1 subgoal):\n 1. \\<phi> (\\<Psi>a f' (\\<psi> x')) =\n    \\<phi> (\\<psi> (S'.Fun f' (\\<phi> (\\<psi> x'))))", "finally"], ["proof (chain)\npicking this:\n  \\<phi> (\\<Psi>a f' (\\<psi> x')) =\n  \\<phi> (\\<psi> (S'.Fun f' (\\<phi> (\\<psi> x'))))", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<phi> (\\<Psi>a f' (\\<psi> x')) =\n  \\<phi> (\\<psi> (S'.Fun f' (\\<phi> (\\<psi> x'))))\n\ngoal (1 subgoal):\n 1. \\<phi> (\\<Psi>a f' (\\<psi> x')) =\n    \\<phi> (\\<psi> (S'.Fun f' (\\<phi> (\\<psi> x'))))", "by auto"], ["proof (state)\nthis:\n  \\<phi> (\\<Psi>a f' (\\<psi> x')) =\n  \\<phi> (\\<psi> (S'.Fun f' (\\<phi> (\\<psi> x'))))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<phi> (\\<Psi>a f' (\\<psi> x')) =\n  \\<phi> (\\<psi> (S'.Fun f' (\\<phi> (\\<psi> x'))))\n\ngoal (1 subgoal):\n 1. x' \\<in> S'.set (S'.dom f') \\<Longrightarrow>\n    S'.Fun (\\<Phi> (\\<Psi> f')) x' = S'.Fun f' x'", "also"], ["proof (state)\nthis:\n  \\<phi> (\\<Psi>a f' (\\<psi> x')) =\n  \\<phi> (\\<psi> (S'.Fun f' (\\<phi> (\\<psi> x'))))\n\ngoal (1 subgoal):\n 1. x' \\<in> S'.set (S'.dom f') \\<Longrightarrow>\n    S'.Fun (\\<Phi> (\\<Psi> f')) x' = S'.Fun f' x'", "have \"... = S'.Fun f' x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<phi> (\\<psi> (S'.Fun f' (\\<phi> (\\<psi> x')))) = S'.Fun f' x'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<phi> (\\<psi> (S'.Fun f' (\\<phi> (\\<psi> x')))) = S'.Fun f' x'", "have 2: \"\\<And>x'. x' \\<in> S'.Univ \\<Longrightarrow> \\<phi> (\\<psi> x') = x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x'. x' \\<in> S'.Univ \\<Longrightarrow> \\<phi> (\\<psi> x') = x'", "using bij_\\<phi> bij_betw_inv_into_right"], ["proof (prove)\nusing this:\n  bij_betw \\<phi> S.Univ S'.Univ\n  \\<lbrakk>bij_betw ?f ?A ?A'; ?a' \\<in> ?A'\\<rbrakk>\n  \\<Longrightarrow> ?f (inv_into ?A ?f ?a') = ?a'\n\ngoal (1 subgoal):\n 1. \\<And>x'. x' \\<in> S'.Univ \\<Longrightarrow> \\<phi> (\\<psi> x') = x'", "by fast"], ["proof (state)\nthis:\n  ?x' \\<in> S'.Univ \\<Longrightarrow> \\<phi> (\\<psi> ?x') = ?x'\n\ngoal (1 subgoal):\n 1. \\<phi> (\\<psi> (S'.Fun f' (\\<phi> (\\<psi> x')))) = S'.Fun f' x'", "have \"S'.Fun f' (\\<phi> (\\<psi> x')) = S'.Fun f' x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S'.Fun f' (\\<phi> (\\<psi> x')) = S'.Fun f' x'", "using assms x' 2 S'.set_subset_Univ S'.ide_dom"], ["proof (prove)\nusing this:\n  S'.arr f'\n  x' \\<in> S'.set (S'.dom f')\n  ?x' \\<in> S'.Univ \\<Longrightarrow> \\<phi> (\\<psi> ?x') = ?x'\n  S'.ide ?a \\<Longrightarrow> S'.set ?a \\<subseteq> S'.Univ\n  S'.arr ?f \\<Longrightarrow> S'.ide (S'.dom ?f)\n\ngoal (1 subgoal):\n 1. S'.Fun f' (\\<phi> (\\<psi> x')) = S'.Fun f' x'", "by (metis subsetCE)"], ["proof (state)\nthis:\n  S'.Fun f' (\\<phi> (\\<psi> x')) = S'.Fun f' x'\n\ngoal (1 subgoal):\n 1. \\<phi> (\\<psi> (S'.Fun f' (\\<phi> (\\<psi> x')))) = S'.Fun f' x'", "moreover"], ["proof (state)\nthis:\n  S'.Fun f' (\\<phi> (\\<psi> x')) = S'.Fun f' x'\n\ngoal (1 subgoal):\n 1. \\<phi> (\\<psi> (S'.Fun f' (\\<phi> (\\<psi> x')))) = S'.Fun f' x'", "have \"S'.Fun f' x' \\<in> S'.Univ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. S'.Fun f' x' \\<in> S'.Univ", "using x' assms S'.Fun_mapsto S'.set_subset_Univ S'.ide_cod"], ["proof (prove)\nusing this:\n  x' \\<in> S'.set (S'.dom f')\n  S'.arr f'\n  S'.arr ?f \\<Longrightarrow>\n  S'.Fun ?f\n  \\<in> extensional (S'.set (S'.dom ?f)) \\<inter>\n        (S'.set (S'.dom ?f) \\<rightarrow> S'.set (S'.cod ?f))\n  S'.ide ?a \\<Longrightarrow> S'.set ?a \\<subseteq> S'.Univ\n  S'.arr ?f \\<Longrightarrow> S'.ide (S'.cod ?f)\n\ngoal (1 subgoal):\n 1. S'.Fun f' x' \\<in> S'.Univ", "by blast"], ["proof (state)\nthis:\n  S'.Fun f' x' \\<in> S'.Univ\n\ngoal (1 subgoal):\n 1. \\<phi> (\\<psi> (S'.Fun f' (\\<phi> (\\<psi> x')))) = S'.Fun f' x'", "ultimately"], ["proof (chain)\npicking this:\n  S'.Fun f' (\\<phi> (\\<psi> x')) = S'.Fun f' x'\n  S'.Fun f' x' \\<in> S'.Univ", "show ?thesis"], ["proof (prove)\nusing this:\n  S'.Fun f' (\\<phi> (\\<psi> x')) = S'.Fun f' x'\n  S'.Fun f' x' \\<in> S'.Univ\n\ngoal (1 subgoal):\n 1. \\<phi> (\\<psi> (S'.Fun f' (\\<phi> (\\<psi> x')))) = S'.Fun f' x'", "using 2"], ["proof (prove)\nusing this:\n  S'.Fun f' (\\<phi> (\\<psi> x')) = S'.Fun f' x'\n  S'.Fun f' x' \\<in> S'.Univ\n  ?x' \\<in> S'.Univ \\<Longrightarrow> \\<phi> (\\<psi> ?x') = ?x'\n\ngoal (1 subgoal):\n 1. \\<phi> (\\<psi> (S'.Fun f' (\\<phi> (\\<psi> x')))) = S'.Fun f' x'", "by auto"], ["proof (state)\nthis:\n  \\<phi> (\\<psi> (S'.Fun f' (\\<phi> (\\<psi> x')))) = S'.Fun f' x'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<phi> (\\<psi> (S'.Fun f' (\\<phi> (\\<psi> x')))) = S'.Fun f' x'\n\ngoal (1 subgoal):\n 1. x' \\<in> S'.set (S'.dom f') \\<Longrightarrow>\n    S'.Fun (\\<Phi> (\\<Psi> f')) x' = S'.Fun f' x'", "finally"], ["proof (chain)\npicking this:\n  S'.Fun (\\<Phi> (\\<Psi> f')) x' = S'.Fun f' x'", "show ?thesis"], ["proof (prove)\nusing this:\n  S'.Fun (\\<Phi> (\\<Psi> f')) x' = S'.Fun f' x'\n\ngoal (1 subgoal):\n 1. S'.Fun (\\<Phi> (\\<Psi> f')) x' = S'.Fun f' x'", "by auto"], ["proof (state)\nthis:\n  S'.Fun (\\<Phi> (\\<Psi> f')) x' = S'.Fun f' x'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x' \\<in> S'.set (S'.dom f') \\<Longrightarrow>\n  S'.Fun (\\<Phi> (\\<Psi> f')) x' = S'.Fun f' x'\n\ngoal (1 subgoal):\n 1. \\<And>x. S'.Fun (\\<Phi> (\\<Psi> f')) x = S'.Fun f' x", "ultimately"], ["proof (chain)\npicking this:\n  x' \\<notin> S'.set (S'.dom f') \\<Longrightarrow>\n  S'.Fun (\\<Phi> (\\<Psi> f')) x' = S'.Fun f' x'\n  x' \\<in> S'.set (S'.dom f') \\<Longrightarrow>\n  S'.Fun (\\<Phi> (\\<Psi> f')) x' = S'.Fun f' x'", "show \"S'.Fun (\\<Phi> (\\<Psi> f')) x' = S'.Fun f' x'\""], ["proof (prove)\nusing this:\n  x' \\<notin> S'.set (S'.dom f') \\<Longrightarrow>\n  S'.Fun (\\<Phi> (\\<Psi> f')) x' = S'.Fun f' x'\n  x' \\<in> S'.set (S'.dom f') \\<Longrightarrow>\n  S'.Fun (\\<Phi> (\\<Psi> f')) x' = S'.Fun f' x'\n\ngoal (1 subgoal):\n 1. S'.Fun (\\<Phi> (\\<Psi> f')) x' = S'.Fun f' x'", "by auto"], ["proof (state)\nthis:\n  S'.Fun (\\<Phi> (\\<Psi> f')) x' = S'.Fun f' x'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S'.Fun (\\<Phi> (\\<Psi> f')) = S'.Fun f'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  S'.Fun (\\<Phi> (\\<Psi> f')) = S'.Fun f'\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma inverse_functors_\\<Phi>_\\<Psi>:\n    shows \"inverse_functors S S' \\<Psi> \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_functors (\\<cdot>) (\\<cdot>\\<acute>) \\<Psi> \\<Phi>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inverse_functors (\\<cdot>) (\\<cdot>\\<acute>) \\<Psi> \\<Phi>", "interpret \\<Phi>\\<Psi>: composite_functor S S' S \\<Phi> \\<Psi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. composite_functor (\\<cdot>) (\\<cdot>\\<acute>) (\\<cdot>) \\<Phi> \\<Psi>", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. inverse_functors (\\<cdot>) (\\<cdot>\\<acute>) \\<Psi> \\<Phi>", "have inv: \"\\<Psi> o \\<Phi> = S.map\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Phi>\\<Psi>.map = S.map", "using \\<Phi>\\<Psi> S.map_def \\<Phi>\\<Psi>.is_extensional"], ["proof (prove)\nusing this:\n  S.arr ?f \\<Longrightarrow> \\<Psi> (\\<Phi> ?f) = ?f\n  S.map ?f = (if S.arr ?f then ?f else S.null)\n  \\<not> S.arr ?f \\<Longrightarrow> \\<Phi>\\<Psi>.map ?f = S.null\n\ngoal (1 subgoal):\n 1. \\<Phi>\\<Psi>.map = S.map", "by auto"], ["proof (state)\nthis:\n  \\<Phi>\\<Psi>.map = S.map\n\ngoal (1 subgoal):\n 1. inverse_functors (\\<cdot>) (\\<cdot>\\<acute>) \\<Psi> \\<Phi>", "interpret \\<Psi>\\<Phi>: composite_functor S' S S' \\<Psi> \\<Phi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. composite_functor (\\<cdot>\\<acute>) (\\<cdot>) (\\<cdot>\\<acute>) \\<Psi>\n     \\<Phi>", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. inverse_functors (\\<cdot>) (\\<cdot>\\<acute>) \\<Psi> \\<Phi>", "have inv': \"\\<Phi> o \\<Psi> = S'.map\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Psi>\\<Phi>.map = S'.map", "using \\<Psi>\\<Phi> S'.map_def \\<Psi>\\<Phi>.is_extensional"], ["proof (prove)\nusing this:\n  S'.arr ?f' \\<Longrightarrow> \\<Phi> (\\<Psi> ?f') = ?f'\n  S'.map ?f = (if S'.arr ?f then ?f else S'.null)\n  \\<not> S'.arr ?f \\<Longrightarrow> \\<Psi>\\<Phi>.map ?f = S'.null\n\ngoal (1 subgoal):\n 1. \\<Psi>\\<Phi>.map = S'.map", "by auto"], ["proof (state)\nthis:\n  \\<Psi>\\<Phi>.map = S'.map\n\ngoal (1 subgoal):\n 1. inverse_functors (\\<cdot>) (\\<cdot>\\<acute>) \\<Psi> \\<Phi>", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_functors (\\<cdot>) (\\<cdot>\\<acute>) \\<Psi> \\<Phi>", "using inv inv'"], ["proof (prove)\nusing this:\n  \\<Phi>\\<Psi>.map = S.map\n  \\<Psi>\\<Phi>.map = S'.map\n\ngoal (1 subgoal):\n 1. inverse_functors (\\<cdot>) (\\<cdot>\\<acute>) \\<Psi> \\<Phi>", "by (unfold_locales, auto)"], ["proof (state)\nthis:\n  inverse_functors (\\<cdot>) (\\<cdot>\\<acute>) \\<Psi> \\<Phi>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma are_isomorphic:\n    shows \"\\<exists>\\<Phi>. invertible_functor S S' \\<Phi> \\<and> (\\<forall>m. S.incl m \\<longrightarrow> S'.incl (\\<Phi> m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<Phi>.\n       invertible_functor (\\<cdot>) (\\<cdot>\\<acute>) \\<Phi> \\<and>\n       (\\<forall>m. S.incl m \\<longrightarrow> S'.incl (\\<Phi> m))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<Phi>.\n       invertible_functor (\\<cdot>) (\\<cdot>\\<acute>) \\<Phi> \\<and>\n       (\\<forall>m. S.incl m \\<longrightarrow> S'.incl (\\<Phi> m))", "interpret inverse_functors S S' \\<Psi> \\<Phi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_functors (\\<cdot>) (\\<cdot>\\<acute>) \\<Psi> \\<Phi>", "using inverse_functors_\\<Phi>_\\<Psi>"], ["proof (prove)\nusing this:\n  inverse_functors (\\<cdot>) (\\<cdot>\\<acute>) \\<Psi> \\<Phi>\n\ngoal (1 subgoal):\n 1. inverse_functors (\\<cdot>) (\\<cdot>\\<acute>) \\<Psi> \\<Phi>", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<Phi>.\n       invertible_functor (\\<cdot>) (\\<cdot>\\<acute>) \\<Phi> \\<and>\n       (\\<forall>m. S.incl m \\<longrightarrow> S'.incl (\\<Phi> m))", "have 1: \"inverse_functors S S' \\<Psi> \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_functors (\\<cdot>) (\\<cdot>\\<acute>) \\<Psi> \\<Phi>", ".."], ["proof (state)\nthis:\n  inverse_functors (\\<cdot>) (\\<cdot>\\<acute>) \\<Psi> \\<Phi>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Phi>.\n       invertible_functor (\\<cdot>) (\\<cdot>\\<acute>) \\<Phi> \\<and>\n       (\\<forall>m. S.incl m \\<longrightarrow> S'.incl (\\<Phi> m))", "interpret invertible_functor S S' \\<Phi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible_functor (\\<cdot>) (\\<cdot>\\<acute>) \\<Phi>", "apply unfold_locales"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>F. inverse_functors (\\<cdot>) (\\<cdot>\\<acute>) F \\<Phi>", "using 1"], ["proof (prove)\nusing this:\n  inverse_functors (\\<cdot>) (\\<cdot>\\<acute>) \\<Psi> \\<Phi>\n\ngoal (1 subgoal):\n 1. \\<exists>F. inverse_functors (\\<cdot>) (\\<cdot>\\<acute>) F \\<Phi>", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<Phi>.\n       invertible_functor (\\<cdot>) (\\<cdot>\\<acute>) \\<Phi> \\<and>\n       (\\<forall>m. S.incl m \\<longrightarrow> S'.incl (\\<Phi> m))", "have \"invertible_functor S S' \\<Phi>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. invertible_functor (\\<cdot>) (\\<cdot>\\<acute>) \\<Phi>", ".."], ["proof (state)\nthis:\n  invertible_functor (\\<cdot>) (\\<cdot>\\<acute>) \\<Phi>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Phi>.\n       invertible_functor (\\<cdot>) (\\<cdot>\\<acute>) \\<Phi> \\<and>\n       (\\<forall>m. S.incl m \\<longrightarrow> S'.incl (\\<Phi> m))", "thus ?thesis"], ["proof (prove)\nusing this:\n  invertible_functor (\\<cdot>) (\\<cdot>\\<acute>) \\<Phi>\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Phi>.\n       invertible_functor (\\<cdot>) (\\<cdot>\\<acute>) \\<Phi> \\<and>\n       (\\<forall>m. S.incl m \\<longrightarrow> S'.incl (\\<Phi> m))", "using \\<Phi>_preserves_incl"], ["proof (prove)\nusing this:\n  invertible_functor (\\<cdot>) (\\<cdot>\\<acute>) \\<Phi>\n  S.incl ?m \\<Longrightarrow> S'.incl (\\<Phi> ?m)\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Phi>.\n       invertible_functor (\\<cdot>) (\\<cdot>\\<acute>) \\<Phi> \\<and>\n       (\\<forall>m. S.incl m \\<longrightarrow> S'.incl (\\<Phi> m))", "by auto"], ["proof (state)\nthis:\n  \\<exists>\\<Phi>.\n     invertible_functor (\\<cdot>) (\\<cdot>\\<acute>) \\<Phi> \\<and>\n     (\\<forall>m. S.incl m \\<longrightarrow> S'.incl (\\<Phi> m))\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "text\\<open>\n    The main result: @{locale set_category} is categorical, in the following (logical) sense:\n    If \\<open>S\\<close> and \\<open>S'\\<close> are two ``set categories'' for the same cardinal \\<open>\\<AA>\\<close>,\n    and if the sets of terminal objects of \\<open>S\\<close> and \\<open>S'\\<close> are in bijective correspondence,\n    then \\<open>S\\<close> and \\<open>S'\\<close> are isomorphic as categories, via a functor that preserves inclusion maps,\n    hence the inclusion relation between sets.\n  \\<close>"], ["", "theorem set_category_is_categorical:\n  assumes \"set_category S \\<AA>\" and \"set_category S' \\<AA>\"\n  and \"bij_betw \\<phi> (set_category_data.Univ S) (set_category_data.Univ S')\"\n  shows \"\\<exists>\\<Phi>. invertible_functor S S' \\<Phi> \\<and>\n             (\\<forall>m. set_category.incl S \\<AA> m \\<longrightarrow> set_category.incl S' \\<AA> (\\<Phi> m))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<Phi>.\n       invertible_functor S S' \\<Phi> \\<and>\n       (\\<forall>m.\n           set_category.incl S \\<AA> m \\<longrightarrow>\n           set_category.incl S' \\<AA> (\\<Phi> m))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<Phi>.\n       invertible_functor S S' \\<Phi> \\<and>\n       (\\<forall>m.\n           set_category.incl S \\<AA> m \\<longrightarrow>\n           set_category.incl S' \\<AA> (\\<Phi> m))", "interpret S: set_category S"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_category S \\<AA>", "using assms(1)"], ["proof (prove)\nusing this:\n  set_category S \\<AA>\n\ngoal (1 subgoal):\n 1. set_category S \\<AA>", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<Phi>.\n       invertible_functor S S' \\<Phi> \\<and>\n       (\\<forall>m.\n           S.incl m \\<longrightarrow> set_category.incl S' \\<AA> (\\<Phi> m))", "interpret S': set_category S'"], ["proof (prove)\ngoal (1 subgoal):\n 1. set_category S' \\<AA>", "using assms(2)"], ["proof (prove)\nusing this:\n  set_category S' \\<AA>\n\ngoal (1 subgoal):\n 1. set_category S' \\<AA>", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<Phi>.\n       invertible_functor S S' \\<Phi> \\<and>\n       (\\<forall>m. S.incl m \\<longrightarrow> S'.incl (\\<Phi> m))", "interpret two_set_categories_bij_betw_Univ S S' \\<AA> \\<phi>"], ["proof (prove)\ngoal (1 subgoal):\n 1. two_set_categories_bij_betw_Univ S S' \\<AA> \\<phi>", "apply (unfold_locales)"], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw \\<phi> S.Univ S'.Univ", "using assms(3)"], ["proof (prove)\nusing this:\n  bij_betw \\<phi> S.Univ S'.Univ\n\ngoal (1 subgoal):\n 1. bij_betw \\<phi> S.Univ S'.Univ", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>\\<Phi>.\n       invertible_functor S S' \\<Phi> \\<and>\n       (\\<forall>m. S.incl m \\<longrightarrow> S'.incl (\\<Phi> m))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>\\<Phi>.\n       invertible_functor S S' \\<Phi> \\<and>\n       (\\<forall>m. S.incl m \\<longrightarrow> S'.incl (\\<Phi> m))", "using are_isomorphic"], ["proof (prove)\nusing this:\n  \\<exists>\\<Phi>.\n     invertible_functor S S' \\<Phi> \\<and>\n     (\\<forall>m. S.incl m \\<longrightarrow> S'.incl (\\<Phi> m))\n\ngoal (1 subgoal):\n 1. \\<exists>\\<Phi>.\n       invertible_functor S S' \\<Phi> \\<and>\n       (\\<forall>m. S.incl m \\<longrightarrow> S'.incl (\\<Phi> m))", "by auto"], ["proof (state)\nthis:\n  \\<exists>\\<Phi>.\n     invertible_functor S S' \\<Phi> \\<and>\n     (\\<forall>m. S.incl m \\<longrightarrow> S'.incl (\\<Phi> m))\n\ngoal:\nNo subgoals!", "qed"], ["", "section \"Further Properties of Set Categories\""], ["", "text\\<open>\n    In this section we further develop the consequences of the \\<open>set_category\\<close>\n    axioms, and establish characterizations of a number of standard category-theoretic\n    notions for a \\<open>set_category\\<close>.\n\\<close>"], ["", "context set_category\n  begin"], ["", "abbreviation Dom\n    where \"Dom f \\<equiv> set (dom f)\""], ["", "abbreviation Cod\n    where \"Cod f \\<equiv> set (cod f)\""], ["", "subsection \"Initial Object\""], ["", "text\\<open>\n      The object corresponding to the empty set is an initial object.\n\\<close>"], ["", "definition empty\n    where \"empty = mkIde {}\""], ["", "lemma initial_empty:\n    shows \"initial empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. initial local.empty", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ide local.empty\n 2. \\<And>b.\n       ide b \\<Longrightarrow>\n       \\<exists>!f.\n          \\<guillemotleft>f : local.empty \\<rightarrow> b\\<guillemotright>", "show 0: \"ide empty\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide local.empty", "using empty_def ide_mkIde"], ["proof (prove)\nusing this:\n  local.empty = mkIde {}\n  \\<lbrakk>?A \\<subseteq> Univ; |?A| <o \\<AA>\\<rbrakk>\n  \\<Longrightarrow> ide (mkIde ?A)\n\ngoal (1 subgoal):\n 1. ide local.empty", "by (simp add: ide_mkIde_finite)"], ["proof (state)\nthis:\n  ide local.empty\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       ide b \\<Longrightarrow>\n       \\<exists>!f.\n          \\<guillemotleft>f : local.empty \\<rightarrow> b\\<guillemotright>", "show \"\\<And>b. ide b \\<Longrightarrow> \\<exists>!f. \\<guillemotleft>f : empty \\<rightarrow> b\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>b.\n       ide b \\<Longrightarrow>\n       \\<exists>!f.\n          \\<guillemotleft>f : local.empty \\<rightarrow> b\\<guillemotright>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       ide b \\<Longrightarrow>\n       \\<exists>!f.\n          \\<guillemotleft>f : local.empty \\<rightarrow> b\\<guillemotright>", "fix b"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>b.\n       ide b \\<Longrightarrow>\n       \\<exists>!f.\n          \\<guillemotleft>f : local.empty \\<rightarrow> b\\<guillemotright>", "assume b: \"ide b\""], ["proof (state)\nthis:\n  ide b\n\ngoal (1 subgoal):\n 1. \\<And>b.\n       ide b \\<Longrightarrow>\n       \\<exists>!f.\n          \\<guillemotleft>f : local.empty \\<rightarrow> b\\<guillemotright>", "show \"\\<exists>!f. \\<guillemotleft>f : empty \\<rightarrow> b\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!f.\n       \\<guillemotleft>f : local.empty \\<rightarrow> b\\<guillemotright>", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : local.empty \\<rightarrow> b\\<guillemotright>\n 2. \\<And>f.\n       \\<guillemotleft>f : local.empty \\<rightarrow> b\\<guillemotright> \\<Longrightarrow>\n       f = ?a", "show 1: \"\\<guillemotleft>mkArr {} (set b) (\\<lambda>x. x) : empty \\<rightarrow> b\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>mkArr {} (local.set b)\n                     (\\<lambda>x.\n                         x) : local.empty \\<rightarrow> b\\<guillemotright>", "using 0 b empty_def mkArr_in_hom mkIde_set set_subset_Univ arr_mkIde"], ["proof (prove)\nusing this:\n  ide local.empty\n  ide b\n  local.empty = mkIde {}\n  \\<lbrakk>?A \\<subseteq> Univ; |?A| <o \\<AA>; ?B \\<subseteq> Univ;\n   |?B| <o \\<AA>; ?F \\<in> ?A \\<rightarrow> ?B\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>mkArr ?A ?B\n                                     ?F : mkIde\n     ?A \\<rightarrow> mkIde ?B\\<guillemotright>\n  ide ?a \\<Longrightarrow> mkIde (local.set ?a) = ?a\n  ide ?a \\<Longrightarrow> local.set ?a \\<subseteq> Univ\n  arr (mkIde ?A) = (?A \\<subseteq> Univ \\<and> |?A| <o \\<AA>)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>mkArr {} (local.set b)\n                     (\\<lambda>x.\n                         x) : local.empty \\<rightarrow> b\\<guillemotright>", "by (metis (no_types, lifting) Pi_I empty_iff ide_def mkIde_def)"], ["proof (state)\nthis:\n  \\<guillemotleft>mkArr {} (local.set b)\n                   (\\<lambda>x.\n                       x) : local.empty \\<rightarrow> b\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<guillemotleft>f : local.empty \\<rightarrow> b\\<guillemotright> \\<Longrightarrow>\n       f = mkArr {} (local.set b) (\\<lambda>x. x)", "show \"\\<And>f. \\<guillemotleft>f : empty \\<rightarrow> b\\<guillemotright> \\<Longrightarrow> f = mkArr {} (set b) (\\<lambda>x. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<guillemotleft>f : local.empty \\<rightarrow> b\\<guillemotright> \\<Longrightarrow>\n       f = mkArr {} (local.set b) (\\<lambda>x. x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<guillemotleft>f : local.empty \\<rightarrow> b\\<guillemotright> \\<Longrightarrow>\n       f = mkArr {} (local.set b) (\\<lambda>x. x)", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<guillemotleft>f : local.empty \\<rightarrow> b\\<guillemotright> \\<Longrightarrow>\n       f = mkArr {} (local.set b) (\\<lambda>x. x)", "assume f: \"\\<guillemotleft>f : empty \\<rightarrow> b\\<guillemotright>\""], ["proof (state)\nthis:\n  \\<guillemotleft>f : local.empty \\<rightarrow> b\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<guillemotleft>f : local.empty \\<rightarrow> b\\<guillemotright> \\<Longrightarrow>\n       f = mkArr {} (local.set b) (\\<lambda>x. x)", "show \"f = mkArr {} (set b) (\\<lambda>x. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = mkArr {} (local.set b) (\\<lambda>x. x)", "proof (intro arr_eqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. par f (mkArr {} (local.set b) (\\<lambda>x. x))\n 2. Fun f = Fun (mkArr {} (local.set b) (\\<lambda>x. x))", "show 1: \"par f (mkArr {} (set b) (\\<lambda>x. x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. par f (mkArr {} (local.set b) (\\<lambda>x. x))", "using 1 f"], ["proof (prove)\nusing this:\n  \\<guillemotleft>mkArr {} (local.set b)\n                   (\\<lambda>x.\n                       x) : local.empty \\<rightarrow> b\\<guillemotright>\n  \\<guillemotleft>f : local.empty \\<rightarrow> b\\<guillemotright>\n\ngoal (1 subgoal):\n 1. par f (mkArr {} (local.set b) (\\<lambda>x. x))", "by force"], ["proof (state)\nthis:\n  par f (mkArr {} (local.set b) (\\<lambda>x. x))\n\ngoal (1 subgoal):\n 1. Fun f = Fun (mkArr {} (local.set b) (\\<lambda>x. x))", "show \"Fun f = Fun (mkArr {} (set b) (\\<lambda>x. x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun f = Fun (mkArr {} (local.set b) (\\<lambda>x. x))", "using empty_def 1 f Fun_mapsto arr_mkArr set_mkIde"], ["proof (prove)\nusing this:\n  local.empty = mkIde {}\n  par f (mkArr {} (local.set b) (\\<lambda>x. x))\n  \\<guillemotleft>f : local.empty \\<rightarrow> b\\<guillemotright>\n  arr ?f \\<Longrightarrow>\n  Fun ?f \\<in> extensional (Dom ?f) \\<inter> (Dom ?f \\<rightarrow> Cod ?f)\n  arr (mkArr ?A ?B ?F) =\n  (?A \\<subseteq> Univ \\<and>\n   |?A| <o \\<AA> \\<and>\n   ?B \\<subseteq> Univ \\<and>\n   |?B| <o \\<AA> \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n  \\<lbrakk>?A \\<subseteq> Univ; |?A| <o \\<AA>\\<rbrakk>\n  \\<Longrightarrow> local.set (mkIde ?A) = ?A\n\ngoal (1 subgoal):\n 1. Fun f = Fun (mkArr {} (local.set b) (\\<lambda>x. x))", "by fastforce"], ["proof (state)\nthis:\n  Fun f = Fun (mkArr {} (local.set b) (\\<lambda>x. x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f = mkArr {} (local.set b) (\\<lambda>x. x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<guillemotleft>?f : local.empty \\<rightarrow> b\\<guillemotright> \\<Longrightarrow>\n  ?f = mkArr {} (local.set b) (\\<lambda>x. x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!f.\n     \\<guillemotleft>f : local.empty \\<rightarrow> b\\<guillemotright>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ide ?b \\<Longrightarrow>\n  \\<exists>!f.\n     \\<guillemotleft>f : local.empty \\<rightarrow> ?b\\<guillemotright>\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Identity Arrows\""], ["", "text\\<open>\n      Identity arrows correspond to restrictions of the identity function.\n\\<close>"], ["", "lemma ide_char:\n    assumes \"arr f\"\n    shows \"ide f \\<longleftrightarrow> Dom f = Cod f \\<and> Fun f = (\\<lambda>x \\<in> Dom f. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide f = (Dom f = Cod f \\<and> Fun f = (\\<lambda>x\\<in>Dom f. x))", "using assms mkIde_as_mkArr mkArr_Fun Fun_ide in_homE ide_cod mkArr_Fun mkIde_set"], ["proof (prove)\nusing this:\n  arr f\n  \\<lbrakk>?A \\<subseteq> Univ; |?A| <o \\<AA>\\<rbrakk>\n  \\<Longrightarrow> mkArr ?A ?A (\\<lambda>x. x) = mkIde ?A\n  arr ?f \\<Longrightarrow> mkArr (Dom ?f) (Cod ?f) (Fun ?f) = ?f\n  ide ?a \\<Longrightarrow> Fun ?a = (\\<lambda>x\\<in>local.set ?a. x)\n  \\<lbrakk>\\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright>;\n   \\<lbrakk>arr ?f; local.dom ?f = ?a; cod ?f = ?b\\<rbrakk>\n   \\<Longrightarrow> ?T\\<rbrakk>\n  \\<Longrightarrow> ?T\n  arr ?f \\<Longrightarrow> ide (cod ?f)\n  arr ?f \\<Longrightarrow> mkArr (Dom ?f) (Cod ?f) (Fun ?f) = ?f\n  ide ?a \\<Longrightarrow> mkIde (local.set ?a) = ?a\n\ngoal (1 subgoal):\n 1. ide f = (Dom f = Cod f \\<and> Fun f = (\\<lambda>x\\<in>Dom f. x))", "by (metis ide_char)"], ["", "lemma ideI:\n    assumes \"arr f\" and \"Dom f = Cod f\" and \"\\<And>x. x \\<in> Dom f \\<Longrightarrow> Fun f x = x\"\n    shows \"ide f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ide f", "have \"Fun f = (\\<lambda>x \\<in> Dom f. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun f = (\\<lambda>x\\<in>Dom f. x)", "using assms Fun_def"], ["proof (prove)\nusing this:\n  arr f\n  Dom f = Cod f\n  ?x \\<in> Dom f \\<Longrightarrow> Fun f ?x = ?x\n  Fun ?f =\n  restrict\n   (some_img \\<circ> (\\<cdot>) ?f \\<circ>\n    inv_into (hom unity (local.dom ?f)) some_img)\n   (Dom ?f)\n\ngoal (1 subgoal):\n 1. Fun f = (\\<lambda>x\\<in>Dom f. x)", "by auto"], ["proof (state)\nthis:\n  Fun f = (\\<lambda>x\\<in>Dom f. x)\n\ngoal (1 subgoal):\n 1. ide f", "thus ?thesis"], ["proof (prove)\nusing this:\n  Fun f = (\\<lambda>x\\<in>Dom f. x)\n\ngoal (1 subgoal):\n 1. ide f", "using assms ide_char"], ["proof (prove)\nusing this:\n  Fun f = (\\<lambda>x\\<in>Dom f. x)\n  arr f\n  Dom f = Cod f\n  ?x \\<in> Dom f \\<Longrightarrow> Fun f ?x = ?x\n  arr ?f \\<Longrightarrow>\n  ide ?f = (Dom ?f = Cod ?f \\<and> Fun ?f = (\\<lambda>x\\<in>Dom ?f. x))\n\ngoal (1 subgoal):\n 1. ide f", "by blast"], ["proof (state)\nthis:\n  ide f\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Inclusions\""], ["", "lemma ide_implies_incl:\n    assumes \"ide a\"\n    shows \"incl a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incl a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. incl a", "have \"arr a \\<and> Dom a \\<subseteq> Cod a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr a \\<and> Dom a \\<subseteq> Cod a", "using assms"], ["proof (prove)\nusing this:\n  ide a\n\ngoal (1 subgoal):\n 1. arr a \\<and> Dom a \\<subseteq> Cod a", "by auto"], ["proof (state)\nthis:\n  arr a \\<and> Dom a \\<subseteq> Cod a\n\ngoal (1 subgoal):\n 1. incl a", "moreover"], ["proof (state)\nthis:\n  arr a \\<and> Dom a \\<subseteq> Cod a\n\ngoal (1 subgoal):\n 1. incl a", "have \"a = mkArr (Dom a) (Cod a) (\\<lambda>x. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. a = mkArr (Dom a) (Cod a) (\\<lambda>x. x)", "using assms mkIde_as_mkArr mkIde_set set_card"], ["proof (prove)\nusing this:\n  ide a\n  \\<lbrakk>?A \\<subseteq> Univ; |?A| <o \\<AA>\\<rbrakk>\n  \\<Longrightarrow> mkArr ?A ?A (\\<lambda>x. x) = mkIde ?A\n  ide ?a \\<Longrightarrow> mkIde (local.set ?a) = ?a\n  ide ?a \\<Longrightarrow> |local.set ?a| <o \\<AA>\n\ngoal (1 subgoal):\n 1. a = mkArr (Dom a) (Cod a) (\\<lambda>x. x)", "by simp"], ["proof (state)\nthis:\n  a = mkArr (Dom a) (Cod a) (\\<lambda>x. x)\n\ngoal (1 subgoal):\n 1. incl a", "ultimately"], ["proof (chain)\npicking this:\n  arr a \\<and> Dom a \\<subseteq> Cod a\n  a = mkArr (Dom a) (Cod a) (\\<lambda>x. x)", "show ?thesis"], ["proof (prove)\nusing this:\n  arr a \\<and> Dom a \\<subseteq> Cod a\n  a = mkArr (Dom a) (Cod a) (\\<lambda>x. x)\n\ngoal (1 subgoal):\n 1. incl a", "using incl_def"], ["proof (prove)\nusing this:\n  arr a \\<and> Dom a \\<subseteq> Cod a\n  a = mkArr (Dom a) (Cod a) (\\<lambda>x. x)\n  incl ?f =\n  (arr ?f \\<and>\n   Dom ?f \\<subseteq> Cod ?f \\<and>\n   ?f = mkArr (Dom ?f) (Cod ?f) (\\<lambda>x. x))\n\ngoal (1 subgoal):\n 1. incl a", "by simp"], ["proof (state)\nthis:\n  incl a\n\ngoal:\nNo subgoals!", "qed"], ["", "definition incl_in :: \"'s \\<Rightarrow> 's \\<Rightarrow> bool\"\n    where \"incl_in a b = (ide a \\<and> ide b \\<and> set a \\<subseteq> set b)\""], ["", "abbreviation incl_of\n    where \"incl_of a b \\<equiv> mkArr (set a) (set b) (\\<lambda>x. x)\""], ["", "lemma elem_set_implies_set_eq_singleton:\n    assumes \"a \\<in> set b\"\n    shows \"set a = {a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.set a = {a}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.set a = {a}", "have \"ide b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide b", "using assms set_def"], ["proof (prove)\nusing this:\n  a \\<in> local.set b\n  local.set ?a = some_img ` hom unity ?a\n\ngoal (1 subgoal):\n 1. ide b", "by auto"], ["proof (state)\nthis:\n  ide b\n\ngoal (1 subgoal):\n 1. local.set a = {a}", "thus ?thesis"], ["proof (prove)\nusing this:\n  ide b\n\ngoal (1 subgoal):\n 1. local.set a = {a}", "using assms set_subset_Univ terminal_char2"], ["proof (prove)\nusing this:\n  ide b\n  a \\<in> local.set b\n  ide ?a \\<Longrightarrow> local.set ?a \\<subseteq> Univ\n  terminal ?t = (ide ?t \\<and> local.set ?t = {?t})\n\ngoal (1 subgoal):\n 1. local.set a = {a}", "by (metis mem_Collect_eq subsetCE)"], ["proof (state)\nthis:\n  local.set a = {a}\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma elem_set_implies_incl_in:\n    assumes \"a \\<in> set b\"\n    shows \"incl_in a b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incl_in a b", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. incl_in a b", "have b: \"ide b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide b", "using assms set_def"], ["proof (prove)\nusing this:\n  a \\<in> local.set b\n  local.set ?a = some_img ` hom unity ?a\n\ngoal (1 subgoal):\n 1. ide b", "by auto"], ["proof (state)\nthis:\n  ide b\n\ngoal (1 subgoal):\n 1. incl_in a b", "hence \"set b \\<subseteq> Univ\""], ["proof (prove)\nusing this:\n  ide b\n\ngoal (1 subgoal):\n 1. local.set b \\<subseteq> Univ", "by simp"], ["proof (state)\nthis:\n  local.set b \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. incl_in a b", "hence \"a \\<in> Univ \\<and> set a \\<subseteq> set b\""], ["proof (prove)\nusing this:\n  local.set b \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. a \\<in> Univ \\<and> local.set a \\<subseteq> local.set b", "using assms elem_set_implies_set_eq_singleton"], ["proof (prove)\nusing this:\n  local.set b \\<subseteq> Univ\n  a \\<in> local.set b\n  ?a \\<in> local.set ?b \\<Longrightarrow> local.set ?a = {?a}\n\ngoal (1 subgoal):\n 1. a \\<in> Univ \\<and> local.set a \\<subseteq> local.set b", "by auto"], ["proof (state)\nthis:\n  a \\<in> Univ \\<and> local.set a \\<subseteq> local.set b\n\ngoal (1 subgoal):\n 1. incl_in a b", "hence \"ide a \\<and> set a \\<subseteq> set b\""], ["proof (prove)\nusing this:\n  a \\<in> Univ \\<and> local.set a \\<subseteq> local.set b\n\ngoal (1 subgoal):\n 1. ide a \\<and> local.set a \\<subseteq> local.set b", "using b terminal_char1"], ["proof (prove)\nusing this:\n  a \\<in> Univ \\<and> local.set a \\<subseteq> local.set b\n  ide b\n  terminal ?t = (ide ?t \\<and> (\\<exists>!x. x \\<in> local.set ?t))\n\ngoal (1 subgoal):\n 1. ide a \\<and> local.set a \\<subseteq> local.set b", "by simp"], ["proof (state)\nthis:\n  ide a \\<and> local.set a \\<subseteq> local.set b\n\ngoal (1 subgoal):\n 1. incl_in a b", "thus ?thesis"], ["proof (prove)\nusing this:\n  ide a \\<and> local.set a \\<subseteq> local.set b\n\ngoal (1 subgoal):\n 1. incl_in a b", "using b incl_in_def"], ["proof (prove)\nusing this:\n  ide a \\<and> local.set a \\<subseteq> local.set b\n  ide b\n  incl_in ?a ?b =\n  (ide ?a \\<and> ide ?b \\<and> local.set ?a \\<subseteq> local.set ?b)\n\ngoal (1 subgoal):\n 1. incl_in a b", "by simp"], ["proof (state)\nthis:\n  incl_in a b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma incl_incl_of [simp]:\n    assumes \"incl_in a b\"\n    shows \"incl (incl_of a b)\"\n    and \"\\<guillemotleft>incl_of a b : a \\<rightarrow> b\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incl (incl_of a b) &&&\n    \\<guillemotleft>incl_of a b : a \\<rightarrow> b\\<guillemotright>", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. incl (incl_of a b)\n 2. \\<guillemotleft>incl_of a b : a \\<rightarrow> b\\<guillemotright>", "show \"\\<guillemotleft>incl_of a b : a \\<rightarrow> b\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>incl_of a b : a \\<rightarrow> b\\<guillemotright>", "using assms incl_in_def mkArr_in_hom mkIde_set set_subset_Univ"], ["proof (prove)\nusing this:\n  incl_in a b\n  incl_in ?a ?b =\n  (ide ?a \\<and> ide ?b \\<and> local.set ?a \\<subseteq> local.set ?b)\n  \\<lbrakk>?A \\<subseteq> Univ; |?A| <o \\<AA>; ?B \\<subseteq> Univ;\n   |?B| <o \\<AA>; ?F \\<in> ?A \\<rightarrow> ?B\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>mkArr ?A ?B\n                                     ?F : mkIde\n     ?A \\<rightarrow> mkIde ?B\\<guillemotright>\n  ide ?a \\<Longrightarrow> mkIde (local.set ?a) = ?a\n  ide ?a \\<Longrightarrow> local.set ?a \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>incl_of a b : a \\<rightarrow> b\\<guillemotright>", "by (metis image_ident image_subset_iff_funcset set_card)"], ["proof (state)\nthis:\n  \\<guillemotleft>incl_of a b : a \\<rightarrow> b\\<guillemotright>\n\ngoal (1 subgoal):\n 1. incl (incl_of a b)", "thus \"incl (incl_of a b)\""], ["proof (prove)\nusing this:\n  \\<guillemotleft>incl_of a b : a \\<rightarrow> b\\<guillemotright>\n\ngoal (1 subgoal):\n 1. incl (incl_of a b)", "using assms incl_def incl_in_def"], ["proof (prove)\nusing this:\n  \\<guillemotleft>incl_of a b : a \\<rightarrow> b\\<guillemotright>\n  incl_in a b\n  incl ?f =\n  (arr ?f \\<and>\n   Dom ?f \\<subseteq> Cod ?f \\<and> ?f = incl_of (local.dom ?f) (cod ?f))\n  incl_in ?a ?b =\n  (ide ?a \\<and> ide ?b \\<and> local.set ?a \\<subseteq> local.set ?b)\n\ngoal (1 subgoal):\n 1. incl (incl_of a b)", "by fastforce"], ["proof (state)\nthis:\n  incl (incl_of a b)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n      There is at most one inclusion between any pair of objects.\n\\<close>"], ["", "lemma incls_coherent:\n    assumes \"par f f'\" and \"incl f\" and \"incl f'\"\n    shows \"f = f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = f'", "using assms incl_def fun_complete"], ["proof (prove)\nusing this:\n  par f f'\n  incl f\n  incl f'\n  incl ?f =\n  (arr ?f \\<and>\n   Dom ?f \\<subseteq> Cod ?f \\<and> ?f = incl_of (local.dom ?f) (cod ?f))\n  \\<lbrakk>ide ?a; ide ?b;\n   ?F \\<in> local.set ?a \\<rightarrow> local.set ?b\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!f.\n                       \\<guillemotleft>f : ?a \\<rightarrow> ?b\\<guillemotright> \\<and>\n                       Fun f = restrict ?F (local.set ?a)\n\ngoal (1 subgoal):\n 1. f = f'", "by auto"], ["", "text\\<open>\n      The set of inclusions is closed under composition.\n\\<close>"], ["", "lemma incl_comp [simp]:\n    assumes \"incl f\" and \"incl g\" and \"cod f = dom g\"\n    shows \"incl (g \\<cdot> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incl (g \\<cdot> f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. incl (g \\<cdot> f)", "have 1: \"seq g f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq g f", "using assms incl_def"], ["proof (prove)\nusing this:\n  incl f\n  incl g\n  cod f = local.dom g\n  incl ?f =\n  (arr ?f \\<and>\n   Dom ?f \\<subseteq> Cod ?f \\<and> ?f = incl_of (local.dom ?f) (cod ?f))\n\ngoal (1 subgoal):\n 1. seq g f", "by auto"], ["proof (state)\nthis:\n  seq g f\n\ngoal (1 subgoal):\n 1. incl (g \\<cdot> f)", "moreover"], ["proof (state)\nthis:\n  seq g f\n\ngoal (1 subgoal):\n 1. incl (g \\<cdot> f)", "have 2: \"Dom (g \\<cdot> f) \\<subseteq> Cod (g \\<cdot> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dom (g \\<cdot> f) \\<subseteq> Cod (g \\<cdot> f)", "using assms 1 incl_def"], ["proof (prove)\nusing this:\n  incl f\n  incl g\n  cod f = local.dom g\n  seq g f\n  incl ?f =\n  (arr ?f \\<and>\n   Dom ?f \\<subseteq> Cod ?f \\<and> ?f = incl_of (local.dom ?f) (cod ?f))\n\ngoal (1 subgoal):\n 1. Dom (g \\<cdot> f) \\<subseteq> Cod (g \\<cdot> f)", "by auto"], ["proof (state)\nthis:\n  Dom (g \\<cdot> f) \\<subseteq> Cod (g \\<cdot> f)\n\ngoal (1 subgoal):\n 1. incl (g \\<cdot> f)", "moreover"], ["proof (state)\nthis:\n  Dom (g \\<cdot> f) \\<subseteq> Cod (g \\<cdot> f)\n\ngoal (1 subgoal):\n 1. incl (g \\<cdot> f)", "have \"g \\<cdot> f = mkArr (Dom f) (Cod g) (restrict (\\<lambda>x. x) (Dom f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g \\<cdot> f = mkArr (Dom f) (Cod g) (\\<lambda>x\\<in>Dom f. x)", "proof (intro arr_eqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. par (g \\<cdot> f) (mkArr (Dom f) (Cod g) (\\<lambda>x\\<in>Dom f. x))\n 2. Fun (g \\<cdot> f) =\n    Fun (mkArr (Dom f) (Cod g) (\\<lambda>x\\<in>Dom f. x))", "have 3: \"arr (mkArr (Dom f) (Cod g) (\\<lambda>x\\<in>Dom f. x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (mkArr (Dom f) (Cod g) (\\<lambda>x\\<in>Dom f. x))", "using assms 1 2"], ["proof (prove)\nusing this:\n  incl f\n  incl g\n  cod f = local.dom g\n  seq g f\n  Dom (g \\<cdot> f) \\<subseteq> Cod (g \\<cdot> f)\n\ngoal (1 subgoal):\n 1. arr (mkArr (Dom f) (Cod g) (\\<lambda>x\\<in>Dom f. x))", "by (metis cod_comp dom_comp ex_incl_iff_subset ide_cod ide_dom\n              in_homE incl_def mkArr_restrict_eq)"], ["proof (state)\nthis:\n  arr (mkArr (Dom f) (Cod g) (\\<lambda>x\\<in>Dom f. x))\n\ngoal (2 subgoals):\n 1. par (g \\<cdot> f) (mkArr (Dom f) (Cod g) (\\<lambda>x\\<in>Dom f. x))\n 2. Fun (g \\<cdot> f) =\n    Fun (mkArr (Dom f) (Cod g) (\\<lambda>x\\<in>Dom f. x))", "show 4: \"par (g \\<cdot> f) (mkArr (Dom f) (Cod g) (\\<lambda>x\\<in>Dom f. x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. par (g \\<cdot> f) (mkArr (Dom f) (Cod g) (\\<lambda>x\\<in>Dom f. x))", "using assms 1 3 mkIde_set"], ["proof (prove)\nusing this:\n  incl f\n  incl g\n  cod f = local.dom g\n  seq g f\n  arr (mkArr (Dom f) (Cod g) (\\<lambda>x\\<in>Dom f. x))\n  ide ?a \\<Longrightarrow> mkIde (local.set ?a) = ?a\n\ngoal (1 subgoal):\n 1. par (g \\<cdot> f) (mkArr (Dom f) (Cod g) (\\<lambda>x\\<in>Dom f. x))", "by auto"], ["proof (state)\nthis:\n  par (g \\<cdot> f) (mkArr (Dom f) (Cod g) (\\<lambda>x\\<in>Dom f. x))\n\ngoal (1 subgoal):\n 1. Fun (g \\<cdot> f) =\n    Fun (mkArr (Dom f) (Cod g) (\\<lambda>x\\<in>Dom f. x))", "show \"Fun (g \\<cdot> f) = Fun (mkArr (Dom f) (Cod g) (\\<lambda>x\\<in>Dom f. x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (g \\<cdot> f) =\n    Fun (mkArr (Dom f) (Cod g) (\\<lambda>x\\<in>Dom f. x))", "using assms 3 4 Fun_comp Fun_mkArr"], ["proof (prove)\nusing this:\n  incl f\n  incl g\n  cod f = local.dom g\n  arr (mkArr (Dom f) (Cod g) (\\<lambda>x\\<in>Dom f. x))\n  par (g \\<cdot> f) (mkArr (Dom f) (Cod g) (\\<lambda>x\\<in>Dom f. x))\n  seq ?g ?f \\<Longrightarrow>\n  Fun (?g \\<cdot> ?f) = restrict (Fun ?g \\<circ> Fun ?f) (Dom ?f)\n  arr (mkArr ?A ?B ?F) \\<Longrightarrow>\n  Fun (mkArr ?A ?B ?F) = restrict ?F ?A\n\ngoal (1 subgoal):\n 1. Fun (g \\<cdot> f) =\n    Fun (mkArr (Dom f) (Cod g) (\\<lambda>x\\<in>Dom f. x))", "by (metis Fun_ide comp_cod_arr ide_cod mkArr_restrict_eq' incl_def)"], ["proof (state)\nthis:\n  Fun (g \\<cdot> f) = Fun (mkArr (Dom f) (Cod g) (\\<lambda>x\\<in>Dom f. x))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  g \\<cdot> f = mkArr (Dom f) (Cod g) (\\<lambda>x\\<in>Dom f. x)\n\ngoal (1 subgoal):\n 1. incl (g \\<cdot> f)", "ultimately"], ["proof (chain)\npicking this:\n  seq g f\n  Dom (g \\<cdot> f) \\<subseteq> Cod (g \\<cdot> f)\n  g \\<cdot> f = mkArr (Dom f) (Cod g) (\\<lambda>x\\<in>Dom f. x)", "show ?thesis"], ["proof (prove)\nusing this:\n  seq g f\n  Dom (g \\<cdot> f) \\<subseteq> Cod (g \\<cdot> f)\n  g \\<cdot> f = mkArr (Dom f) (Cod g) (\\<lambda>x\\<in>Dom f. x)\n\ngoal (1 subgoal):\n 1. incl (g \\<cdot> f)", "using incl_def arr_mkArr set_mkIde"], ["proof (prove)\nusing this:\n  seq g f\n  Dom (g \\<cdot> f) \\<subseteq> Cod (g \\<cdot> f)\n  g \\<cdot> f = mkArr (Dom f) (Cod g) (\\<lambda>x\\<in>Dom f. x)\n  incl ?f =\n  (arr ?f \\<and>\n   Dom ?f \\<subseteq> Cod ?f \\<and> ?f = incl_of (local.dom ?f) (cod ?f))\n  arr (mkArr ?A ?B ?F) =\n  (?A \\<subseteq> Univ \\<and>\n   |?A| <o \\<AA> \\<and>\n   ?B \\<subseteq> Univ \\<and>\n   |?B| <o \\<AA> \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n  \\<lbrakk>?A \\<subseteq> Univ; |?A| <o \\<AA>\\<rbrakk>\n  \\<Longrightarrow> local.set (mkIde ?A) = ?A\n\ngoal (1 subgoal):\n 1. incl (g \\<cdot> f)", "by force"], ["proof (state)\nthis:\n  incl (g \\<cdot> f)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Image Factorization\""], ["", "text\\<open>\n      The image of an arrow is the object that corresponds to the set-theoretic\n      image of the domain set under the function induced by the arrow.\n\\<close>"], ["", "abbreviation Img\n    where \"Img f \\<equiv> Fun f ` Dom f\""], ["", "definition img\n    where \"img f = mkIde (Img f)\""], ["", "lemma ide_img [simp]:\n    assumes \"arr f\"\n    shows \"ide (img f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide (img f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ide (img f)", "have \"Fun f ` Dom f \\<subseteq> Cod f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Img f \\<subseteq> Cod f", "using assms Fun_mapsto"], ["proof (prove)\nusing this:\n  arr f\n  arr ?f \\<Longrightarrow>\n  Fun ?f \\<in> extensional (Dom ?f) \\<inter> (Dom ?f \\<rightarrow> Cod ?f)\n\ngoal (1 subgoal):\n 1. Img f \\<subseteq> Cod f", "by blast"], ["proof (state)\nthis:\n  Img f \\<subseteq> Cod f\n\ngoal (1 subgoal):\n 1. ide (img f)", "moreover"], ["proof (state)\nthis:\n  Img f \\<subseteq> Cod f\n\ngoal (1 subgoal):\n 1. ide (img f)", "have \"Cod f \\<subseteq> Univ \\<and> |Cod f| <o \\<AA>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cod f \\<subseteq> Univ \\<and> |Cod f| <o \\<AA>", "using assms"], ["proof (prove)\nusing this:\n  arr f\n\ngoal (1 subgoal):\n 1. Cod f \\<subseteq> Univ \\<and> |Cod f| <o \\<AA>", "by (simp add: set_card)"], ["proof (state)\nthis:\n  Cod f \\<subseteq> Univ \\<and> |Cod f| <o \\<AA>\n\ngoal (1 subgoal):\n 1. ide (img f)", "ultimately"], ["proof (chain)\npicking this:\n  Img f \\<subseteq> Cod f\n  Cod f \\<subseteq> Univ \\<and> |Cod f| <o \\<AA>", "have \"Fun f ` Dom f \\<subseteq> Univ \\<and> |Fun f ` Dom f| <o \\<AA>\""], ["proof (prove)\nusing this:\n  Img f \\<subseteq> Cod f\n  Cod f \\<subseteq> Univ \\<and> |Cod f| <o \\<AA>\n\ngoal (1 subgoal):\n 1. Img f \\<subseteq> Univ \\<and> |Img f| <o \\<AA>", "by (meson assms card_of_image ide_dom ordLeq_ordLess_trans set_card subset_eq)"], ["proof (state)\nthis:\n  Img f \\<subseteq> Univ \\<and> |Img f| <o \\<AA>\n\ngoal (1 subgoal):\n 1. ide (img f)", "thus ?thesis"], ["proof (prove)\nusing this:\n  Img f \\<subseteq> Univ \\<and> |Img f| <o \\<AA>\n\ngoal (1 subgoal):\n 1. ide (img f)", "using img_def ide_mkIde"], ["proof (prove)\nusing this:\n  Img f \\<subseteq> Univ \\<and> |Img f| <o \\<AA>\n  img ?f = mkIde (Img ?f)\n  \\<lbrakk>?A \\<subseteq> Univ; |?A| <o \\<AA>\\<rbrakk>\n  \\<Longrightarrow> ide (mkIde ?A)\n\ngoal (1 subgoal):\n 1. ide (img f)", "by simp"], ["proof (state)\nthis:\n  ide (img f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma set_img [simp]:\n    assumes \"arr f\"\n    shows \"set (img f) = Img f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.set (img f) = Img f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.set (img f) = Img f", "have \"Fun f ` set (dom f) \\<subseteq> set (cod f) \\<and> set (cod f) \\<subseteq> Univ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Img f \\<subseteq> Cod f \\<and> Cod f \\<subseteq> Univ", "using assms Fun_mapsto"], ["proof (prove)\nusing this:\n  arr f\n  arr ?f \\<Longrightarrow>\n  Fun ?f \\<in> extensional (Dom ?f) \\<inter> (Dom ?f \\<rightarrow> Cod ?f)\n\ngoal (1 subgoal):\n 1. Img f \\<subseteq> Cod f \\<and> Cod f \\<subseteq> Univ", "by auto"], ["proof (state)\nthis:\n  Img f \\<subseteq> Cod f \\<and> Cod f \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. local.set (img f) = Img f", "hence \"Fun f ` set (dom f) \\<subseteq> Univ \\<and> |Fun f ` Dom f| <o \\<AA>\""], ["proof (prove)\nusing this:\n  Img f \\<subseteq> Cod f \\<and> Cod f \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. Img f \\<subseteq> Univ \\<and> |Img f| <o \\<AA>", "by (metis assms ide_def ide_img img_def mkIde_def)"], ["proof (state)\nthis:\n  Img f \\<subseteq> Univ \\<and> |Img f| <o \\<AA>\n\ngoal (1 subgoal):\n 1. local.set (img f) = Img f", "thus ?thesis"], ["proof (prove)\nusing this:\n  Img f \\<subseteq> Univ \\<and> |Img f| <o \\<AA>\n\ngoal (1 subgoal):\n 1. local.set (img f) = Img f", "using assms img_def set_mkIde"], ["proof (prove)\nusing this:\n  Img f \\<subseteq> Univ \\<and> |Img f| <o \\<AA>\n  arr f\n  img ?f = mkIde (Img ?f)\n  \\<lbrakk>?A \\<subseteq> Univ; |?A| <o \\<AA>\\<rbrakk>\n  \\<Longrightarrow> local.set (mkIde ?A) = ?A\n\ngoal (1 subgoal):\n 1. local.set (img f) = Img f", "by auto"], ["proof (state)\nthis:\n  local.set (img f) = Img f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma img_point_in_Univ:\n    assumes \"\\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright>\"\n    shows \"img x \\<in> Univ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. img x \\<in> Univ", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. img x \\<in> Univ", "have \"set (img x) = {Fun x unity}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.set (img x) = {Fun x unity}", "using assms img_def terminal_unity terminal_char2\n              image_empty image_insert mem_Collect_eq set_img"], ["proof (prove)\nusing this:\n  \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright>\n  img ?f = mkIde (Img ?f)\n  terminal unity\n  terminal ?t = (ide ?t \\<and> local.set ?t = {?t})\n  ?f ` {} = {}\n  ?f ` insert ?a ?B = insert (?f ?a) (?f ` ?B)\n  (?a \\<in> Collect ?P) = ?P ?a\n  arr ?f \\<Longrightarrow> local.set (img ?f) = Img ?f\n\ngoal (1 subgoal):\n 1. local.set (img x) = {Fun x unity}", "by force"], ["proof (state)\nthis:\n  local.set (img x) = {Fun x unity}\n\ngoal (1 subgoal):\n 1. img x \\<in> Univ", "thus \"img x \\<in> Univ\""], ["proof (prove)\nusing this:\n  local.set (img x) = {Fun x unity}\n\ngoal (1 subgoal):\n 1. img x \\<in> Univ", "using assms terminal_char1"], ["proof (prove)\nusing this:\n  local.set (img x) = {Fun x unity}\n  \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright>\n  terminal ?t = (ide ?t \\<and> (\\<exists>!x. x \\<in> local.set ?t))\n\ngoal (1 subgoal):\n 1. img x \\<in> Univ", "by auto"], ["proof (state)\nthis:\n  img x \\<in> Univ\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma incl_in_img_cod:\n    assumes \"arr f\"\n    shows \"incl_in (img f) (cod f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incl_in (img f) (cod f)", "proof (unfold img_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. incl_in (mkIde (Img f)) (cod f)", "have 1: \"Img f \\<subseteq> Cod f \\<and> Cod f \\<subseteq> Univ \\<and> |Cod f| <o \\<AA>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Img f \\<subseteq> Cod f \\<and>\n    Cod f \\<subseteq> Univ \\<and> |Cod f| <o \\<AA>", "using assms Fun_mapsto"], ["proof (prove)\nusing this:\n  arr f\n  arr ?f \\<Longrightarrow>\n  Fun ?f \\<in> extensional (Dom ?f) \\<inter> (Dom ?f \\<rightarrow> Cod ?f)\n\ngoal (1 subgoal):\n 1. Img f \\<subseteq> Cod f \\<and>\n    Cod f \\<subseteq> Univ \\<and> |Cod f| <o \\<AA>", "by (metis arr_mkArr image_subset_iff_funcset mkArr_Fun)"], ["proof (state)\nthis:\n  Img f \\<subseteq> Cod f \\<and>\n  Cod f \\<subseteq> Univ \\<and> |Cod f| <o \\<AA>\n\ngoal (1 subgoal):\n 1. incl_in (mkIde (Img f)) (cod f)", "hence 2: \"ide (mkIde (Img f))\""], ["proof (prove)\nusing this:\n  Img f \\<subseteq> Cod f \\<and>\n  Cod f \\<subseteq> Univ \\<and> |Cod f| <o \\<AA>\n\ngoal (1 subgoal):\n 1. ide (mkIde (Img f))", "using assms ide_img img_def"], ["proof (prove)\nusing this:\n  Img f \\<subseteq> Cod f \\<and>\n  Cod f \\<subseteq> Univ \\<and> |Cod f| <o \\<AA>\n  arr f\n  arr ?f \\<Longrightarrow> ide (img ?f)\n  img ?f = mkIde (Img ?f)\n\ngoal (1 subgoal):\n 1. ide (mkIde (Img f))", "by auto"], ["proof (state)\nthis:\n  ide (mkIde (Img f))\n\ngoal (1 subgoal):\n 1. incl_in (mkIde (Img f)) (cod f)", "moreover"], ["proof (state)\nthis:\n  ide (mkIde (Img f))\n\ngoal (1 subgoal):\n 1. incl_in (mkIde (Img f)) (cod f)", "have \"set (mkIde (Img f)) \\<subseteq> Cod f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.set (mkIde (Img f)) \\<subseteq> Cod f", "using 1 2"], ["proof (prove)\nusing this:\n  Img f \\<subseteq> Cod f \\<and>\n  Cod f \\<subseteq> Univ \\<and> |Cod f| <o \\<AA>\n  ide (mkIde (Img f))\n\ngoal (1 subgoal):\n 1. local.set (mkIde (Img f)) \\<subseteq> Cod f", "by (metis ideD(1) arr_mkIde set_mkIde)"], ["proof (state)\nthis:\n  local.set (mkIde (Img f)) \\<subseteq> Cod f\n\ngoal (1 subgoal):\n 1. incl_in (mkIde (Img f)) (cod f)", "ultimately"], ["proof (chain)\npicking this:\n  ide (mkIde (Img f))\n  local.set (mkIde (Img f)) \\<subseteq> Cod f", "show \"incl_in (mkIde (Img f)) (cod f)\""], ["proof (prove)\nusing this:\n  ide (mkIde (Img f))\n  local.set (mkIde (Img f)) \\<subseteq> Cod f\n\ngoal (1 subgoal):\n 1. incl_in (mkIde (Img f)) (cod f)", "using assms incl_in_def ide_cod"], ["proof (prove)\nusing this:\n  ide (mkIde (Img f))\n  local.set (mkIde (Img f)) \\<subseteq> Cod f\n  arr f\n  incl_in ?a ?b =\n  (ide ?a \\<and> ide ?b \\<and> local.set ?a \\<subseteq> local.set ?b)\n  arr ?f \\<Longrightarrow> ide (cod ?f)\n\ngoal (1 subgoal):\n 1. incl_in (mkIde (Img f)) (cod f)", "by blast"], ["proof (state)\nthis:\n  incl_in (mkIde (Img f)) (cod f)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma img_point_elem_set:\n    assumes \"\\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright>\"\n    shows \"img x \\<in> set a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. img x \\<in> local.set a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. img x \\<in> local.set a", "have \"incl_in (img x) a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incl_in (img x) a", "using assms incl_in_img_cod"], ["proof (prove)\nusing this:\n  \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright>\n  arr ?f \\<Longrightarrow> incl_in (img ?f) (cod ?f)\n\ngoal (1 subgoal):\n 1. incl_in (img x) a", "by auto"], ["proof (state)\nthis:\n  incl_in (img x) a\n\ngoal (1 subgoal):\n 1. img x \\<in> local.set a", "hence \"set (img x) \\<subseteq> set a\""], ["proof (prove)\nusing this:\n  incl_in (img x) a\n\ngoal (1 subgoal):\n 1. local.set (img x) \\<subseteq> local.set a", "using incl_in_def"], ["proof (prove)\nusing this:\n  incl_in (img x) a\n  incl_in ?a ?b =\n  (ide ?a \\<and> ide ?b \\<and> local.set ?a \\<subseteq> local.set ?b)\n\ngoal (1 subgoal):\n 1. local.set (img x) \\<subseteq> local.set a", "by blast"], ["proof (state)\nthis:\n  local.set (img x) \\<subseteq> local.set a\n\ngoal (1 subgoal):\n 1. img x \\<in> local.set a", "moreover"], ["proof (state)\nthis:\n  local.set (img x) \\<subseteq> local.set a\n\ngoal (1 subgoal):\n 1. img x \\<in> local.set a", "have \"img x \\<in> set (img x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. img x \\<in> local.set (img x)", "using assms img_point_in_Univ terminal_char2"], ["proof (prove)\nusing this:\n  \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright>\n  \\<guillemotleft>?x : unity \\<rightarrow> ?a\\<guillemotright> \\<Longrightarrow>\n  img ?x \\<in> Univ\n  terminal ?t = (ide ?t \\<and> local.set ?t = {?t})\n\ngoal (1 subgoal):\n 1. img x \\<in> local.set (img x)", "by simp"], ["proof (state)\nthis:\n  img x \\<in> local.set (img x)\n\ngoal (1 subgoal):\n 1. img x \\<in> local.set a", "ultimately"], ["proof (chain)\npicking this:\n  local.set (img x) \\<subseteq> local.set a\n  img x \\<in> local.set (img x)", "show ?thesis"], ["proof (prove)\nusing this:\n  local.set (img x) \\<subseteq> local.set a\n  img x \\<in> local.set (img x)\n\ngoal (1 subgoal):\n 1. img x \\<in> local.set a", "by auto"], ["proof (state)\nthis:\n  img x \\<in> local.set a\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n      The corestriction of an arrow @{term f} is the arrow\n      @{term \"corestr f \\<in> hom (dom f) (img f)\"} that induces the same function\n      on the universe as @{term f}.\n\\<close>"], ["", "definition corestr\n    where \"corestr f = mkArr (Dom f) (Img f) (Fun f)\""], ["", "lemma corestr_in_hom:\n    assumes \"arr f\"\n    shows \"\\<guillemotleft>corestr f : dom f \\<rightarrow> img f\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>corestr\n                     f : local.dom f \\<rightarrow> img f\\<guillemotright>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<guillemotleft>corestr\n                     f : local.dom f \\<rightarrow> img f\\<guillemotright>", "have \"Fun f \\<in> Dom f \\<rightarrow> Fun f ` Dom f \\<and> Dom f \\<subseteq> Univ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun f \\<in> Dom f \\<rightarrow> Img f \\<and> Dom f \\<subseteq> Univ", "using assms"], ["proof (prove)\nusing this:\n  arr f\n\ngoal (1 subgoal):\n 1. Fun f \\<in> Dom f \\<rightarrow> Img f \\<and> Dom f \\<subseteq> Univ", "by auto"], ["proof (state)\nthis:\n  Fun f \\<in> Dom f \\<rightarrow> Img f \\<and> Dom f \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>corestr\n                     f : local.dom f \\<rightarrow> img f\\<guillemotright>", "moreover"], ["proof (state)\nthis:\n  Fun f \\<in> Dom f \\<rightarrow> Img f \\<and> Dom f \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>corestr\n                     f : local.dom f \\<rightarrow> img f\\<guillemotright>", "have \"Fun f ` Dom f \\<subseteq> Univ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Img f \\<subseteq> Univ", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Img f \\<subseteq> Univ", "have \"Fun f ` Dom f \\<subseteq> Cod f \\<and> Cod f \\<subseteq> Univ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Img f \\<subseteq> Cod f \\<and> Cod f \\<subseteq> Univ", "using assms Fun_mapsto"], ["proof (prove)\nusing this:\n  arr f\n  arr ?f \\<Longrightarrow>\n  Fun ?f \\<in> extensional (Dom ?f) \\<inter> (Dom ?f \\<rightarrow> Cod ?f)\n\ngoal (1 subgoal):\n 1. Img f \\<subseteq> Cod f \\<and> Cod f \\<subseteq> Univ", "by auto"], ["proof (state)\nthis:\n  Img f \\<subseteq> Cod f \\<and> Cod f \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. Img f \\<subseteq> Univ", "thus ?thesis"], ["proof (prove)\nusing this:\n  Img f \\<subseteq> Cod f \\<and> Cod f \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. Img f \\<subseteq> Univ", "by blast"], ["proof (state)\nthis:\n  Img f \\<subseteq> Univ\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Img f \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>corestr\n                     f : local.dom f \\<rightarrow> img f\\<guillemotright>", "moreover"], ["proof (state)\nthis:\n  Img f \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>corestr\n                     f : local.dom f \\<rightarrow> img f\\<guillemotright>", "have \"|Fun f ` Dom f| <o \\<AA>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |Img f| <o \\<AA>", "using assms"], ["proof (prove)\nusing this:\n  arr f\n\ngoal (1 subgoal):\n 1. |Img f| <o \\<AA>", "by (metis ide_img set_card set_img)"], ["proof (state)\nthis:\n  |Img f| <o \\<AA>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>corestr\n                     f : local.dom f \\<rightarrow> img f\\<guillemotright>", "ultimately"], ["proof (chain)\npicking this:\n  Fun f \\<in> Dom f \\<rightarrow> Img f \\<and> Dom f \\<subseteq> Univ\n  Img f \\<subseteq> Univ\n  |Img f| <o \\<AA>", "have \"mkArr (Dom f) (Fun f ` Dom f) (Fun f) \\<in> hom (dom f) (img f)\""], ["proof (prove)\nusing this:\n  Fun f \\<in> Dom f \\<rightarrow> Img f \\<and> Dom f \\<subseteq> Univ\n  Img f \\<subseteq> Univ\n  |Img f| <o \\<AA>\n\ngoal (1 subgoal):\n 1. mkArr (Dom f) (Img f) (Fun f) \\<in> hom (local.dom f) (img f)", "using assms img_def mkArr_in_hom [of \"Dom f\" \"Fun f ` Dom f\" \"Fun f\"] mkIde_set"], ["proof (prove)\nusing this:\n  Fun f \\<in> Dom f \\<rightarrow> Img f \\<and> Dom f \\<subseteq> Univ\n  Img f \\<subseteq> Univ\n  |Img f| <o \\<AA>\n  arr f\n  img ?f = mkIde (Img ?f)\n  \\<lbrakk>Dom f \\<subseteq> Univ; |Dom f| <o \\<AA>; Img f \\<subseteq> Univ;\n   |Img f| <o \\<AA>; Fun f \\<in> Dom f \\<rightarrow> Img f\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>mkArr (Dom f) (Img f)\n                                     (Fun\n f) : mkIde (Dom f) \\<rightarrow> mkIde (Img f)\\<guillemotright>\n  ide ?a \\<Longrightarrow> mkIde (local.set ?a) = ?a\n\ngoal (1 subgoal):\n 1. mkArr (Dom f) (Img f) (Fun f) \\<in> hom (local.dom f) (img f)", "by (simp add: set_card)"], ["proof (state)\nthis:\n  mkArr (Dom f) (Img f) (Fun f) \\<in> hom (local.dom f) (img f)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>corestr\n                     f : local.dom f \\<rightarrow> img f\\<guillemotright>", "thus ?thesis"], ["proof (prove)\nusing this:\n  mkArr (Dom f) (Img f) (Fun f) \\<in> hom (local.dom f) (img f)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>corestr\n                     f : local.dom f \\<rightarrow> img f\\<guillemotright>", "using corestr_def"], ["proof (prove)\nusing this:\n  mkArr (Dom f) (Img f) (Fun f) \\<in> hom (local.dom f) (img f)\n  corestr ?f = mkArr (Dom ?f) (Img ?f) (Fun ?f)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>corestr\n                     f : local.dom f \\<rightarrow> img f\\<guillemotright>", "by fastforce"], ["proof (state)\nthis:\n  \\<guillemotleft>corestr\n                   f : local.dom f \\<rightarrow> img f\\<guillemotright>\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n      Every arrow factors as a corestriction followed by an inclusion.\n\\<close>"], ["", "lemma img_fact:\n    assumes \"arr f\"\n    shows \"S (incl_of (img f) (cod f)) (corestr f) = f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incl_of (img f) (cod f) \\<cdot> corestr f = f", "proof (intro arr_eqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. par (incl_of (img f) (cod f) \\<cdot> corestr f) f\n 2. Fun (incl_of (img f) (cod f) \\<cdot> corestr f) = Fun f", "have 1: \"\\<guillemotleft>corestr f : dom f \\<rightarrow> img f\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>corestr\n                     f : local.dom f \\<rightarrow> img f\\<guillemotright>", "using assms corestr_in_hom"], ["proof (prove)\nusing this:\n  arr f\n  arr ?f \\<Longrightarrow>\n  \\<guillemotleft>corestr\n                   ?f : local.dom ?f \\<rightarrow> img ?f\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>corestr\n                     f : local.dom f \\<rightarrow> img f\\<guillemotright>", "by blast"], ["proof (state)\nthis:\n  \\<guillemotleft>corestr\n                   f : local.dom f \\<rightarrow> img f\\<guillemotright>\n\ngoal (2 subgoals):\n 1. par (incl_of (img f) (cod f) \\<cdot> corestr f) f\n 2. Fun (incl_of (img f) (cod f) \\<cdot> corestr f) = Fun f", "moreover"], ["proof (state)\nthis:\n  \\<guillemotleft>corestr\n                   f : local.dom f \\<rightarrow> img f\\<guillemotright>\n\ngoal (2 subgoals):\n 1. par (incl_of (img f) (cod f) \\<cdot> corestr f) f\n 2. Fun (incl_of (img f) (cod f) \\<cdot> corestr f) = Fun f", "have 2: \"\\<guillemotleft>incl_of (img f) (cod f) : img f \\<rightarrow> cod f\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>incl_of (img f)\n                     (cod f) : img f \\<rightarrow> cod f\\<guillemotright>", "using assms incl_in_img_cod incl_incl_of"], ["proof (prove)\nusing this:\n  arr f\n  arr ?f \\<Longrightarrow> incl_in (img ?f) (cod ?f)\n  incl_in ?a ?b \\<Longrightarrow> incl (incl_of ?a ?b)\n  incl_in ?a ?b \\<Longrightarrow>\n  \\<guillemotleft>incl_of ?a ?b : ?a \\<rightarrow> ?b\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>incl_of (img f)\n                     (cod f) : img f \\<rightarrow> cod f\\<guillemotright>", "by fast"], ["proof (state)\nthis:\n  \\<guillemotleft>incl_of (img f)\n                   (cod f) : img f \\<rightarrow> cod f\\<guillemotright>\n\ngoal (2 subgoals):\n 1. par (incl_of (img f) (cod f) \\<cdot> corestr f) f\n 2. Fun (incl_of (img f) (cod f) \\<cdot> corestr f) = Fun f", "ultimately"], ["proof (chain)\npicking this:\n  \\<guillemotleft>corestr\n                   f : local.dom f \\<rightarrow> img f\\<guillemotright>\n  \\<guillemotleft>incl_of (img f)\n                   (cod f) : img f \\<rightarrow> cod f\\<guillemotright>", "show P: \"par (incl_of (img f) (cod f) \\<cdot> corestr f) f\""], ["proof (prove)\nusing this:\n  \\<guillemotleft>corestr\n                   f : local.dom f \\<rightarrow> img f\\<guillemotright>\n  \\<guillemotleft>incl_of (img f)\n                   (cod f) : img f \\<rightarrow> cod f\\<guillemotright>\n\ngoal (1 subgoal):\n 1. par (incl_of (img f) (cod f) \\<cdot> corestr f) f", "using assms in_homE"], ["proof (prove)\nusing this:\n  \\<guillemotleft>corestr\n                   f : local.dom f \\<rightarrow> img f\\<guillemotright>\n  \\<guillemotleft>incl_of (img f)\n                   (cod f) : img f \\<rightarrow> cod f\\<guillemotright>\n  arr f\n  \\<lbrakk>\\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright>;\n   \\<lbrakk>arr ?f; local.dom ?f = ?a; cod ?f = ?b\\<rbrakk>\n   \\<Longrightarrow> ?T\\<rbrakk>\n  \\<Longrightarrow> ?T\n\ngoal (1 subgoal):\n 1. par (incl_of (img f) (cod f) \\<cdot> corestr f) f", "by blast"], ["proof (state)\nthis:\n  par (incl_of (img f) (cod f) \\<cdot> corestr f) f\n\ngoal (1 subgoal):\n 1. Fun (incl_of (img f) (cod f) \\<cdot> corestr f) = Fun f", "show \"Fun (incl_of (img f) (cod f) \\<cdot> corestr f) = Fun f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (incl_of (img f) (cod f) \\<cdot> corestr f) = Fun f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Fun (incl_of (img f) (cod f) \\<cdot> corestr f) = Fun f", "have \"Fun (incl_of (img f) (cod f) \\<cdot> corestr f)\n                 = restrict (Fun (incl_of (img f) (cod f)) o Fun (corestr f)) (Dom f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (incl_of (img f) (cod f) \\<cdot> corestr f) =\n    restrict (Fun (incl_of (img f) (cod f)) \\<circ> Fun (corestr f)) (Dom f)", "using Fun_comp 1 2 P"], ["proof (prove)\nusing this:\n  seq ?g ?f \\<Longrightarrow>\n  Fun (?g \\<cdot> ?f) = restrict (Fun ?g \\<circ> Fun ?f) (Dom ?f)\n  \\<guillemotleft>corestr\n                   f : local.dom f \\<rightarrow> img f\\<guillemotright>\n  \\<guillemotleft>incl_of (img f)\n                   (cod f) : img f \\<rightarrow> cod f\\<guillemotright>\n  par (incl_of (img f) (cod f) \\<cdot> corestr f) f\n\ngoal (1 subgoal):\n 1. Fun (incl_of (img f) (cod f) \\<cdot> corestr f) =\n    restrict (Fun (incl_of (img f) (cod f)) \\<circ> Fun (corestr f)) (Dom f)", "by auto"], ["proof (state)\nthis:\n  Fun (incl_of (img f) (cod f) \\<cdot> corestr f) =\n  restrict (Fun (incl_of (img f) (cod f)) \\<circ> Fun (corestr f)) (Dom f)\n\ngoal (1 subgoal):\n 1. Fun (incl_of (img f) (cod f) \\<cdot> corestr f) = Fun f", "also"], ["proof (state)\nthis:\n  Fun (incl_of (img f) (cod f) \\<cdot> corestr f) =\n  restrict (Fun (incl_of (img f) (cod f)) \\<circ> Fun (corestr f)) (Dom f)\n\ngoal (1 subgoal):\n 1. Fun (incl_of (img f) (cod f) \\<cdot> corestr f) = Fun f", "have\n           \"... = restrict (restrict (\\<lambda>x. x) (Img f) o restrict (Fun f) (Dom f)) (Dom f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict (Fun (incl_of (img f) (cod f)) \\<circ> Fun (corestr f))\n     (Dom f) =\n    restrict ((\\<lambda>x\\<in>Img f. x) \\<circ> restrict (Fun f) (Dom f))\n     (Dom f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. restrict (Fun (incl_of (img f) (cod f)) \\<circ> Fun (corestr f))\n     (Dom f) =\n    restrict ((\\<lambda>x\\<in>Img f. x) \\<circ> restrict (Fun f) (Dom f))\n     (Dom f)", "have \"Fun (corestr f) = restrict (Fun f) (Dom f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (corestr f) = restrict (Fun f) (Dom f)", "using assms corestr_def Fun_mkArr corestr_in_hom"], ["proof (prove)\nusing this:\n  arr f\n  corestr ?f = mkArr (Dom ?f) (Img ?f) (Fun ?f)\n  arr (mkArr ?A ?B ?F) \\<Longrightarrow>\n  Fun (mkArr ?A ?B ?F) = restrict ?F ?A\n  arr ?f \\<Longrightarrow>\n  \\<guillemotleft>corestr\n                   ?f : local.dom ?f \\<rightarrow> img ?f\\<guillemotright>\n\ngoal (1 subgoal):\n 1. Fun (corestr f) = restrict (Fun f) (Dom f)", "by force"], ["proof (state)\nthis:\n  Fun (corestr f) = restrict (Fun f) (Dom f)\n\ngoal (1 subgoal):\n 1. restrict (Fun (incl_of (img f) (cod f)) \\<circ> Fun (corestr f))\n     (Dom f) =\n    restrict ((\\<lambda>x\\<in>Img f. x) \\<circ> restrict (Fun f) (Dom f))\n     (Dom f)", "moreover"], ["proof (state)\nthis:\n  Fun (corestr f) = restrict (Fun f) (Dom f)\n\ngoal (1 subgoal):\n 1. restrict (Fun (incl_of (img f) (cod f)) \\<circ> Fun (corestr f))\n     (Dom f) =\n    restrict ((\\<lambda>x\\<in>Img f. x) \\<circ> restrict (Fun f) (Dom f))\n     (Dom f)", "have \"Fun (incl_of (img f) (cod f)) = restrict (\\<lambda>x. x) (Img f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (incl_of (img f) (cod f)) = (\\<lambda>x\\<in>Img f. x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Fun (incl_of (img f) (cod f)) = (\\<lambda>x\\<in>Img f. x)", "have \"arr (incl_of (img f) (cod f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (incl_of (img f) (cod f))", "using incl_incl_of P"], ["proof (prove)\nusing this:\n  incl_in ?a ?b \\<Longrightarrow> incl (incl_of ?a ?b)\n  incl_in ?a ?b \\<Longrightarrow>\n  \\<guillemotleft>incl_of ?a ?b : ?a \\<rightarrow> ?b\\<guillemotright>\n  par (incl_of (img f) (cod f) \\<cdot> corestr f) f\n\ngoal (1 subgoal):\n 1. arr (incl_of (img f) (cod f))", "by blast"], ["proof (state)\nthis:\n  arr (incl_of (img f) (cod f))\n\ngoal (1 subgoal):\n 1. Fun (incl_of (img f) (cod f)) = (\\<lambda>x\\<in>Img f. x)", "moreover"], ["proof (state)\nthis:\n  arr (incl_of (img f) (cod f))\n\ngoal (1 subgoal):\n 1. Fun (incl_of (img f) (cod f)) = (\\<lambda>x\\<in>Img f. x)", "have \"incl_of (img f) (cod f) = mkArr (Img f) (Cod f) (\\<lambda>x. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incl_of (img f) (cod f) = mkArr (Img f) (Cod f) (\\<lambda>x. x)", "using assms"], ["proof (prove)\nusing this:\n  arr f\n\ngoal (1 subgoal):\n 1. incl_of (img f) (cod f) = mkArr (Img f) (Cod f) (\\<lambda>x. x)", "by fastforce"], ["proof (state)\nthis:\n  incl_of (img f) (cod f) = mkArr (Img f) (Cod f) (\\<lambda>x. x)\n\ngoal (1 subgoal):\n 1. Fun (incl_of (img f) (cod f)) = (\\<lambda>x\\<in>Img f. x)", "ultimately"], ["proof (chain)\npicking this:\n  arr (incl_of (img f) (cod f))\n  incl_of (img f) (cod f) = mkArr (Img f) (Cod f) (\\<lambda>x. x)", "show ?thesis"], ["proof (prove)\nusing this:\n  arr (incl_of (img f) (cod f))\n  incl_of (img f) (cod f) = mkArr (Img f) (Cod f) (\\<lambda>x. x)\n\ngoal (1 subgoal):\n 1. Fun (incl_of (img f) (cod f)) = (\\<lambda>x\\<in>Img f. x)", "using assms img_def Fun_mkArr"], ["proof (prove)\nusing this:\n  arr (incl_of (img f) (cod f))\n  incl_of (img f) (cod f) = mkArr (Img f) (Cod f) (\\<lambda>x. x)\n  arr f\n  img ?f = mkIde (Img ?f)\n  arr (mkArr ?A ?B ?F) \\<Longrightarrow>\n  Fun (mkArr ?A ?B ?F) = restrict ?F ?A\n\ngoal (1 subgoal):\n 1. Fun (incl_of (img f) (cod f)) = (\\<lambda>x\\<in>Img f. x)", "by metis"], ["proof (state)\nthis:\n  Fun (incl_of (img f) (cod f)) = (\\<lambda>x\\<in>Img f. x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Fun (incl_of (img f) (cod f)) = (\\<lambda>x\\<in>Img f. x)\n\ngoal (1 subgoal):\n 1. restrict (Fun (incl_of (img f) (cod f)) \\<circ> Fun (corestr f))\n     (Dom f) =\n    restrict ((\\<lambda>x\\<in>Img f. x) \\<circ> restrict (Fun f) (Dom f))\n     (Dom f)", "ultimately"], ["proof (chain)\npicking this:\n  Fun (corestr f) = restrict (Fun f) (Dom f)\n  Fun (incl_of (img f) (cod f)) = (\\<lambda>x\\<in>Img f. x)", "show ?thesis"], ["proof (prove)\nusing this:\n  Fun (corestr f) = restrict (Fun f) (Dom f)\n  Fun (incl_of (img f) (cod f)) = (\\<lambda>x\\<in>Img f. x)\n\ngoal (1 subgoal):\n 1. restrict (Fun (incl_of (img f) (cod f)) \\<circ> Fun (corestr f))\n     (Dom f) =\n    restrict ((\\<lambda>x\\<in>Img f. x) \\<circ> restrict (Fun f) (Dom f))\n     (Dom f)", "by argo"], ["proof (state)\nthis:\n  restrict (Fun (incl_of (img f) (cod f)) \\<circ> Fun (corestr f)) (Dom f) =\n  restrict ((\\<lambda>x\\<in>Img f. x) \\<circ> restrict (Fun f) (Dom f))\n   (Dom f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  restrict (Fun (incl_of (img f) (cod f)) \\<circ> Fun (corestr f)) (Dom f) =\n  restrict ((\\<lambda>x\\<in>Img f. x) \\<circ> restrict (Fun f) (Dom f))\n   (Dom f)\n\ngoal (1 subgoal):\n 1. Fun (incl_of (img f) (cod f) \\<cdot> corestr f) = Fun f", "also"], ["proof (state)\nthis:\n  restrict (Fun (incl_of (img f) (cod f)) \\<circ> Fun (corestr f)) (Dom f) =\n  restrict ((\\<lambda>x\\<in>Img f. x) \\<circ> restrict (Fun f) (Dom f))\n   (Dom f)\n\ngoal (1 subgoal):\n 1. Fun (incl_of (img f) (cod f) \\<cdot> corestr f) = Fun f", "have \"... = Fun f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict ((\\<lambda>x\\<in>Img f. x) \\<circ> restrict (Fun f) (Dom f))\n     (Dom f) =\n    Fun f", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       restrict ((\\<lambda>x\\<in>Img f. x) \\<circ> restrict (Fun f) (Dom f))\n        (Dom f) x =\n       Fun f x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       restrict ((\\<lambda>x\\<in>Img f. x) \\<circ> restrict (Fun f) (Dom f))\n        (Dom f) x =\n       Fun f x", "show \"restrict (restrict (\\<lambda>x. x) (Img f) o restrict (Fun f) (Dom f)) (Dom f) x = Fun f x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict ((\\<lambda>x\\<in>Img f. x) \\<circ> restrict (Fun f) (Dom f))\n     (Dom f) x =\n    Fun f x", "using assms extensional_restrict Fun_mapsto extensional_arb [of \"Fun f\" \"Dom f\" x]"], ["proof (prove)\nusing this:\n  arr f\n  ?f \\<in> extensional ?A \\<Longrightarrow> restrict ?f ?A = ?f\n  arr ?f \\<Longrightarrow>\n  Fun ?f \\<in> extensional (Dom ?f) \\<inter> (Dom ?f \\<rightarrow> Cod ?f)\n  \\<lbrakk>Fun f \\<in> extensional (Dom f); x \\<notin> Dom f\\<rbrakk>\n  \\<Longrightarrow> Fun f x = undefined\n\ngoal (1 subgoal):\n 1. restrict ((\\<lambda>x\\<in>Img f. x) \\<circ> restrict (Fun f) (Dom f))\n     (Dom f) x =\n    Fun f x", "by (cases \"x \\<in> Dom f\", auto)"], ["proof (state)\nthis:\n  restrict ((\\<lambda>x\\<in>Img f. x) \\<circ> restrict (Fun f) (Dom f))\n   (Dom f) x =\n  Fun f x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  restrict ((\\<lambda>x\\<in>Img f. x) \\<circ> restrict (Fun f) (Dom f))\n   (Dom f) =\n  Fun f\n\ngoal (1 subgoal):\n 1. Fun (incl_of (img f) (cod f) \\<cdot> corestr f) = Fun f", "finally"], ["proof (chain)\npicking this:\n  Fun (incl_of (img f) (cod f) \\<cdot> corestr f) = Fun f", "show ?thesis"], ["proof (prove)\nusing this:\n  Fun (incl_of (img f) (cod f) \\<cdot> corestr f) = Fun f\n\ngoal (1 subgoal):\n 1. Fun (incl_of (img f) (cod f) \\<cdot> corestr f) = Fun f", "by auto"], ["proof (state)\nthis:\n  Fun (incl_of (img f) (cod f) \\<cdot> corestr f) = Fun f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Fun (incl_of (img f) (cod f) \\<cdot> corestr f) = Fun f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Fun_corestr:\n    assumes \"arr f\"\n    shows \"Fun (corestr f) = Fun f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (corestr f) = Fun f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Fun (corestr f) = Fun f", "have 1: \"f = incl_of (img f) (cod f) \\<cdot> corestr f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = incl_of (img f) (cod f) \\<cdot> corestr f", "using assms img_fact"], ["proof (prove)\nusing this:\n  arr f\n  arr ?f \\<Longrightarrow> incl_of (img ?f) (cod ?f) \\<cdot> corestr ?f = ?f\n\ngoal (1 subgoal):\n 1. f = incl_of (img f) (cod f) \\<cdot> corestr f", "by auto"], ["proof (state)\nthis:\n  f = incl_of (img f) (cod f) \\<cdot> corestr f\n\ngoal (1 subgoal):\n 1. Fun (corestr f) = Fun f", "hence 2: \"Fun f = restrict (Fun (incl_of (img f) (cod f)) o Fun (corestr f)) (Dom f)\""], ["proof (prove)\nusing this:\n  f = incl_of (img f) (cod f) \\<cdot> corestr f\n\ngoal (1 subgoal):\n 1. Fun f =\n    restrict (Fun (incl_of (img f) (cod f)) \\<circ> Fun (corestr f)) (Dom f)", "using assms"], ["proof (prove)\nusing this:\n  f = incl_of (img f) (cod f) \\<cdot> corestr f\n  arr f\n\ngoal (1 subgoal):\n 1. Fun f =\n    restrict (Fun (incl_of (img f) (cod f)) \\<circ> Fun (corestr f)) (Dom f)", "by (metis Fun_comp dom_comp)"], ["proof (state)\nthis:\n  Fun f =\n  restrict (Fun (incl_of (img f) (cod f)) \\<circ> Fun (corestr f)) (Dom f)\n\ngoal (1 subgoal):\n 1. Fun (corestr f) = Fun f", "also"], ["proof (state)\nthis:\n  Fun f =\n  restrict (Fun (incl_of (img f) (cod f)) \\<circ> Fun (corestr f)) (Dom f)\n\ngoal (1 subgoal):\n 1. Fun (corestr f) = Fun f", "have \"... = restrict (Fun (corestr f)) (Dom f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict (Fun (incl_of (img f) (cod f)) \\<circ> Fun (corestr f))\n     (Dom f) =\n    restrict (Fun (corestr f)) (Dom f)", "using assms"], ["proof (prove)\nusing this:\n  arr f\n\ngoal (1 subgoal):\n 1. restrict (Fun (incl_of (img f) (cod f)) \\<circ> Fun (corestr f))\n     (Dom f) =\n    restrict (Fun (corestr f)) (Dom f)", "by (metis 1 2 Fun_mkArr seqE mkArr_Fun corestr_def)"], ["proof (state)\nthis:\n  restrict (Fun (incl_of (img f) (cod f)) \\<circ> Fun (corestr f)) (Dom f) =\n  restrict (Fun (corestr f)) (Dom f)\n\ngoal (1 subgoal):\n 1. Fun (corestr f) = Fun f", "also"], ["proof (state)\nthis:\n  restrict (Fun (incl_of (img f) (cod f)) \\<circ> Fun (corestr f)) (Dom f) =\n  restrict (Fun (corestr f)) (Dom f)\n\ngoal (1 subgoal):\n 1. Fun (corestr f) = Fun f", "have \"... = Fun (corestr f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict (Fun (corestr f)) (Dom f) = Fun (corestr f)", "using assms 1"], ["proof (prove)\nusing this:\n  arr f\n  f = incl_of (img f) (cod f) \\<cdot> corestr f\n\ngoal (1 subgoal):\n 1. restrict (Fun (corestr f)) (Dom f) = Fun (corestr f)", "by (metis Fun_def dom_comp extensional_restrict restrict_extensional)"], ["proof (state)\nthis:\n  restrict (Fun (corestr f)) (Dom f) = Fun (corestr f)\n\ngoal (1 subgoal):\n 1. Fun (corestr f) = Fun f", "finally"], ["proof (chain)\npicking this:\n  Fun f = Fun (corestr f)", "show ?thesis"], ["proof (prove)\nusing this:\n  Fun f = Fun (corestr f)\n\ngoal (1 subgoal):\n 1. Fun (corestr f) = Fun f", "by auto"], ["proof (state)\nthis:\n  Fun (corestr f) = Fun f\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"Points and Terminal Objects\""], ["", "text\\<open>\n      To each element @{term t} of @{term \"set a\"} is associated a point\n      @{term \"mkPoint a t \\<in> hom unity a\"}.  The function induced by such\n      a point is the constant-@{term t} function on the set @{term \"{unity}\"}.\n\\<close>"], ["", "definition mkPoint\n    where \"mkPoint a t \\<equiv> mkArr {unity} (set a) (\\<lambda>_. t)\""], ["", "lemma mkPoint_in_hom:\n    assumes \"ide a\" and \"t \\<in> set a\"\n    shows \"\\<guillemotleft>mkPoint a t : unity \\<rightarrow> a\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>mkPoint a t : unity \\<rightarrow> a\\<guillemotright>", "using assms mkArr_in_hom mkIde_set set_subset_Univ terminal_char2 terminal_unity\n            mkPoint_def set_card"], ["proof (prove)\nusing this:\n  ide a\n  t \\<in> local.set a\n  \\<lbrakk>?A \\<subseteq> Univ; |?A| <o \\<AA>; ?B \\<subseteq> Univ;\n   |?B| <o \\<AA>; ?F \\<in> ?A \\<rightarrow> ?B\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>mkArr ?A ?B\n                                     ?F : mkIde\n     ?A \\<rightarrow> mkIde ?B\\<guillemotright>\n  ide ?a \\<Longrightarrow> mkIde (local.set ?a) = ?a\n  ide ?a \\<Longrightarrow> local.set ?a \\<subseteq> Univ\n  terminal ?t = (ide ?t \\<and> local.set ?t = {?t})\n  terminal unity\n  mkPoint ?a ?t \\<equiv> mkArr {unity} (local.set ?a) (\\<lambda>_. ?t)\n  ide ?a \\<Longrightarrow> |local.set ?a| <o \\<AA>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>mkPoint a t : unity \\<rightarrow> a\\<guillemotright>", "by (metis Pi_I)"], ["", "lemma Fun_mkPoint:\n    assumes \"ide a\" and \"t \\<in> set a\"\n    shows \"Fun (mkPoint a t) = (\\<lambda>_ \\<in> {unity}. t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (mkPoint a t) = (\\<lambda>_\\<in>{unity}. t)", "using assms mkPoint_def mkPoint_in_hom Fun_mkArr"], ["proof (prove)\nusing this:\n  ide a\n  t \\<in> local.set a\n  mkPoint ?a ?t \\<equiv> mkArr {unity} (local.set ?a) (\\<lambda>_. ?t)\n  \\<lbrakk>ide ?a; ?t \\<in> local.set ?a\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>mkPoint ?a\n                                     ?t : unity \\<rightarrow> ?a\\<guillemotright>\n  arr (mkArr ?A ?B ?F) \\<Longrightarrow>\n  Fun (mkArr ?A ?B ?F) = restrict ?F ?A\n\ngoal (1 subgoal):\n 1. Fun (mkPoint a t) = (\\<lambda>_\\<in>{unity}. t)", "by force"], ["", "text\\<open>\n      For each object @{term a} the function @{term \"mkPoint a\"} has as its inverse\n      the restriction of the function @{term img} to @{term \"hom unity a\"}\n\\<close>"], ["", "lemma mkPoint_img:\n    shows \"img \\<in> hom unity a \\<rightarrow> set a\"\n    and \"\\<And>x. \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<Longrightarrow> mkPoint a (img x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. img \\<in> hom unity a \\<rightarrow> local.set a &&&\n    (\\<And>x.\n        \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<Longrightarrow>\n        mkPoint a (img x) = x)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. img \\<in> hom unity a \\<rightarrow> local.set a\n 2. \\<And>x.\n       \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<Longrightarrow>\n       mkPoint a (img x) = x", "show \"img \\<in> hom unity a \\<rightarrow> set a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. img \\<in> hom unity a \\<rightarrow> local.set a", "using img_point_elem_set"], ["proof (prove)\nusing this:\n  \\<guillemotleft>?x : unity \\<rightarrow> ?a\\<guillemotright> \\<Longrightarrow>\n  img ?x \\<in> local.set ?a\n\ngoal (1 subgoal):\n 1. img \\<in> hom unity a \\<rightarrow> local.set a", "by simp"], ["proof (state)\nthis:\n  img \\<in> hom unity a \\<rightarrow> local.set a\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<Longrightarrow>\n       mkPoint a (img x) = x", "show \"\\<And>x. \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<Longrightarrow> mkPoint a (img x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<Longrightarrow>\n       mkPoint a (img x) = x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<Longrightarrow>\n       mkPoint a (img x) = x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<Longrightarrow>\n       mkPoint a (img x) = x", "assume x: \"\\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright>\""], ["proof (state)\nthis:\n  \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<Longrightarrow>\n       mkPoint a (img x) = x", "show \"mkPoint a (img x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mkPoint a (img x) = x", "proof (intro arr_eqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. par (mkPoint a (img x)) x\n 2. Fun (mkPoint a (img x)) = Fun x", "have 0: \"img x \\<in> set a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. img x \\<in> local.set a", "using x img_point_elem_set"], ["proof (prove)\nusing this:\n  \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright>\n  \\<guillemotleft>?x : unity \\<rightarrow> ?a\\<guillemotright> \\<Longrightarrow>\n  img ?x \\<in> local.set ?a\n\ngoal (1 subgoal):\n 1. img x \\<in> local.set a", "by metis"], ["proof (state)\nthis:\n  img x \\<in> local.set a\n\ngoal (2 subgoals):\n 1. par (mkPoint a (img x)) x\n 2. Fun (mkPoint a (img x)) = Fun x", "hence 1: \"mkPoint a (img x) \\<in> hom unity a\""], ["proof (prove)\nusing this:\n  img x \\<in> local.set a\n\ngoal (1 subgoal):\n 1. mkPoint a (img x) \\<in> hom unity a", "using x mkPoint_in_hom"], ["proof (prove)\nusing this:\n  img x \\<in> local.set a\n  \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright>\n  \\<lbrakk>ide ?a; ?t \\<in> local.set ?a\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>mkPoint ?a\n                                     ?t : unity \\<rightarrow> ?a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. mkPoint a (img x) \\<in> hom unity a", "by force"], ["proof (state)\nthis:\n  mkPoint a (img x) \\<in> hom unity a\n\ngoal (2 subgoals):\n 1. par (mkPoint a (img x)) x\n 2. Fun (mkPoint a (img x)) = Fun x", "thus 2: \"par (mkPoint a (img x)) x\""], ["proof (prove)\nusing this:\n  mkPoint a (img x) \\<in> hom unity a\n\ngoal (1 subgoal):\n 1. par (mkPoint a (img x)) x", "using x"], ["proof (prove)\nusing this:\n  mkPoint a (img x) \\<in> hom unity a\n  \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. par (mkPoint a (img x)) x", "by fastforce"], ["proof (state)\nthis:\n  par (mkPoint a (img x)) x\n\ngoal (1 subgoal):\n 1. Fun (mkPoint a (img x)) = Fun x", "have \"Fun (mkPoint a (img x)) = (\\<lambda>_ \\<in> {unity}. img x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (mkPoint a (img x)) = (\\<lambda>_\\<in>{unity}. img x)", "using 1 mkPoint_def"], ["proof (prove)\nusing this:\n  mkPoint a (img x) \\<in> hom unity a\n  mkPoint ?a ?t \\<equiv> mkArr {unity} (local.set ?a) (\\<lambda>_. ?t)\n\ngoal (1 subgoal):\n 1. Fun (mkPoint a (img x)) = (\\<lambda>_\\<in>{unity}. img x)", "by auto"], ["proof (state)\nthis:\n  Fun (mkPoint a (img x)) = (\\<lambda>_\\<in>{unity}. img x)\n\ngoal (1 subgoal):\n 1. Fun (mkPoint a (img x)) = Fun x", "also"], ["proof (state)\nthis:\n  Fun (mkPoint a (img x)) = (\\<lambda>_\\<in>{unity}. img x)\n\ngoal (1 subgoal):\n 1. Fun (mkPoint a (img x)) = Fun x", "have \"... = Fun x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>_\\<in>{unity}. img x) = Fun x", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. (\\<lambda>_\\<in>{unity}. img x) xa = Fun x xa", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>xa. (\\<lambda>_\\<in>{unity}. img x) xa = Fun x xa", "have \"z \\<noteq> unity \\<Longrightarrow> (\\<lambda>_ \\<in> {unity}. img x) z = Fun x z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. z \\<noteq> unity \\<Longrightarrow>\n    (\\<lambda>_\\<in>{unity}. img x) z = Fun x z", "using x Fun_mapsto Fun_def restrict_apply singletonD terminal_char2 terminal_unity"], ["proof (prove)\nusing this:\n  \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright>\n  arr ?f \\<Longrightarrow>\n  Fun ?f \\<in> extensional (Dom ?f) \\<inter> (Dom ?f \\<rightarrow> Cod ?f)\n  Fun ?f =\n  restrict\n   (some_img \\<circ> (\\<cdot>) ?f \\<circ>\n    inv_into (hom unity (local.dom ?f)) some_img)\n   (Dom ?f)\n  restrict ?f ?A ?x = (if ?x \\<in> ?A then ?f ?x else undefined)\n  ?b \\<in> {?a} \\<Longrightarrow> ?b = ?a\n  terminal ?t = (ide ?t \\<and> local.set ?t = {?t})\n  terminal unity\n\ngoal (1 subgoal):\n 1. z \\<noteq> unity \\<Longrightarrow>\n    (\\<lambda>_\\<in>{unity}. img x) z = Fun x z", "by auto"], ["proof (state)\nthis:\n  z \\<noteq> unity \\<Longrightarrow>\n  (\\<lambda>_\\<in>{unity}. img x) z = Fun x z\n\ngoal (1 subgoal):\n 1. \\<And>xa. (\\<lambda>_\\<in>{unity}. img x) xa = Fun x xa", "moreover"], ["proof (state)\nthis:\n  z \\<noteq> unity \\<Longrightarrow>\n  (\\<lambda>_\\<in>{unity}. img x) z = Fun x z\n\ngoal (1 subgoal):\n 1. \\<And>xa. (\\<lambda>_\\<in>{unity}. img x) xa = Fun x xa", "have \"(\\<lambda>_ \\<in> {unity}. img x) unity = Fun x unity\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>_\\<in>{unity}. img x) unity = Fun x unity", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<lambda>_\\<in>{unity}. img x) unity = Fun x unity", "have \"(\\<lambda>_ \\<in> {unity}. img x) unity = img x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>_\\<in>{unity}. img x) unity = img x", "by simp"], ["proof (state)\nthis:\n  (\\<lambda>_\\<in>{unity}. img x) unity = img x\n\ngoal (1 subgoal):\n 1. (\\<lambda>_\\<in>{unity}. img x) unity = Fun x unity", "also"], ["proof (state)\nthis:\n  (\\<lambda>_\\<in>{unity}. img x) unity = img x\n\ngoal (1 subgoal):\n 1. (\\<lambda>_\\<in>{unity}. img x) unity = Fun x unity", "have \"... = Fun x unity\""], ["proof (prove)\ngoal (1 subgoal):\n 1. img x = Fun x unity", "using x 0 elem_set_implies_set_eq_singleton set_img terminal_char2 terminal_unity"], ["proof (prove)\nusing this:\n  \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright>\n  img x \\<in> local.set a\n  ?a \\<in> local.set ?b \\<Longrightarrow> local.set ?a = {?a}\n  arr ?f \\<Longrightarrow> local.set (img ?f) = Img ?f\n  terminal ?t = (ide ?t \\<and> local.set ?t = {?t})\n  terminal unity\n\ngoal (1 subgoal):\n 1. img x = Fun x unity", "by (metis (no_types, lifting) image_insert in_homE singleton_insert_inj_eq')"], ["proof (state)\nthis:\n  img x = Fun x unity\n\ngoal (1 subgoal):\n 1. (\\<lambda>_\\<in>{unity}. img x) unity = Fun x unity", "finally"], ["proof (chain)\npicking this:\n  (\\<lambda>_\\<in>{unity}. img x) unity = Fun x unity", "show ?thesis"], ["proof (prove)\nusing this:\n  (\\<lambda>_\\<in>{unity}. img x) unity = Fun x unity\n\ngoal (1 subgoal):\n 1. (\\<lambda>_\\<in>{unity}. img x) unity = Fun x unity", "by blast"], ["proof (state)\nthis:\n  (\\<lambda>_\\<in>{unity}. img x) unity = Fun x unity\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>_\\<in>{unity}. img x) unity = Fun x unity\n\ngoal (1 subgoal):\n 1. \\<And>xa. (\\<lambda>_\\<in>{unity}. img x) xa = Fun x xa", "ultimately"], ["proof (chain)\npicking this:\n  z \\<noteq> unity \\<Longrightarrow>\n  (\\<lambda>_\\<in>{unity}. img x) z = Fun x z\n  (\\<lambda>_\\<in>{unity}. img x) unity = Fun x unity", "show \"(\\<lambda>_ \\<in> {unity}. img x) z = Fun x z\""], ["proof (prove)\nusing this:\n  z \\<noteq> unity \\<Longrightarrow>\n  (\\<lambda>_\\<in>{unity}. img x) z = Fun x z\n  (\\<lambda>_\\<in>{unity}. img x) unity = Fun x unity\n\ngoal (1 subgoal):\n 1. (\\<lambda>_\\<in>{unity}. img x) z = Fun x z", "by auto"], ["proof (state)\nthis:\n  (\\<lambda>_\\<in>{unity}. img x) z = Fun x z\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>_\\<in>{unity}. img x) = Fun x\n\ngoal (1 subgoal):\n 1. Fun (mkPoint a (img x)) = Fun x", "finally"], ["proof (chain)\npicking this:\n  Fun (mkPoint a (img x)) = Fun x", "show \"Fun (mkPoint a (img x)) = Fun x\""], ["proof (prove)\nusing this:\n  Fun (mkPoint a (img x)) = Fun x\n\ngoal (1 subgoal):\n 1. Fun (mkPoint a (img x)) = Fun x", "by auto"], ["proof (state)\nthis:\n  Fun (mkPoint a (img x)) = Fun x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mkPoint a (img x) = x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<guillemotleft>?x : unity \\<rightarrow> a\\<guillemotright> \\<Longrightarrow>\n  mkPoint a (img ?x) = ?x\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma img_mkPoint:\n    assumes \"ide a\"\n    shows \"mkPoint a \\<in> set a \\<rightarrow> hom unity a\"\n    and \"\\<And>t. t \\<in> set a \\<Longrightarrow> img (mkPoint a t) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mkPoint a \\<in> local.set a \\<rightarrow> hom unity a &&&\n    (\\<And>t. t \\<in> local.set a \\<Longrightarrow> img (mkPoint a t) = t)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. mkPoint a \\<in> local.set a \\<rightarrow> hom unity a\n 2. \\<And>t. t \\<in> local.set a \\<Longrightarrow> img (mkPoint a t) = t", "show \"mkPoint a \\<in> set a \\<rightarrow> hom unity a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mkPoint a \\<in> local.set a \\<rightarrow> hom unity a", "using assms(1) mkPoint_in_hom"], ["proof (prove)\nusing this:\n  ide a\n  \\<lbrakk>ide ?a; ?t \\<in> local.set ?a\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>mkPoint ?a\n                                     ?t : unity \\<rightarrow> ?a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. mkPoint a \\<in> local.set a \\<rightarrow> hom unity a", "by simp"], ["proof (state)\nthis:\n  mkPoint a \\<in> local.set a \\<rightarrow> hom unity a\n\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> local.set a \\<Longrightarrow> img (mkPoint a t) = t", "show \"\\<And>t. t \\<in> set a \\<Longrightarrow> img (mkPoint a t) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> local.set a \\<Longrightarrow> img (mkPoint a t) = t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> local.set a \\<Longrightarrow> img (mkPoint a t) = t", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> local.set a \\<Longrightarrow> img (mkPoint a t) = t", "assume t: \"t \\<in> set a\""], ["proof (state)\nthis:\n  t \\<in> local.set a\n\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> local.set a \\<Longrightarrow> img (mkPoint a t) = t", "show \"img (mkPoint a t) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. img (mkPoint a t) = t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. img (mkPoint a t) = t", "have 1: \"arr (mkPoint a t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (mkPoint a t)", "using assms t mkPoint_in_hom"], ["proof (prove)\nusing this:\n  ide a\n  t \\<in> local.set a\n  \\<lbrakk>ide ?a; ?t \\<in> local.set ?a\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>mkPoint ?a\n                                     ?t : unity \\<rightarrow> ?a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. arr (mkPoint a t)", "by auto"], ["proof (state)\nthis:\n  arr (mkPoint a t)\n\ngoal (1 subgoal):\n 1. img (mkPoint a t) = t", "have \"Fun (mkPoint a t) ` {unity} = {t}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (mkPoint a t) ` {unity} = {t}", "using 1 mkPoint_def"], ["proof (prove)\nusing this:\n  arr (mkPoint a t)\n  mkPoint ?a ?t \\<equiv> mkArr {unity} (local.set ?a) (\\<lambda>_. ?t)\n\ngoal (1 subgoal):\n 1. Fun (mkPoint a t) ` {unity} = {t}", "by simp"], ["proof (state)\nthis:\n  Fun (mkPoint a t) ` {unity} = {t}\n\ngoal (1 subgoal):\n 1. img (mkPoint a t) = t", "thus ?thesis"], ["proof (prove)\nusing this:\n  Fun (mkPoint a t) ` {unity} = {t}\n\ngoal (1 subgoal):\n 1. img (mkPoint a t) = t", "by (metis 1 t elem_set_implies_incl_in elem_set_implies_set_eq_singleton img_def\n                      incl_in_def dom_mkArr mkIde_set terminal_char2 terminal_unity mkPoint_def)"], ["proof (state)\nthis:\n  img (mkPoint a t) = t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  img (mkPoint a t) = t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?t \\<in> local.set a \\<Longrightarrow> img (mkPoint a ?t) = ?t\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n      For each object @{term a} the elements of @{term \"hom unity a\"} are therefore in\n      bijective correspondence with @{term \"set a\"}.\n\\<close>"], ["", "lemma bij_betw_points_and_set:\n    assumes \"ide a\"\n    shows \"bij_betw img (hom unity a) (set a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bij_betw img (hom unity a) (local.set a)", "proof (intro bij_betwI)"], ["proof (state)\ngoal (4 subgoals):\n 1. img \\<in> hom unity a \\<rightarrow> local.set a\n 2. ?g \\<in> local.set a \\<rightarrow> hom unity a\n 3. \\<And>x. x \\<in> hom unity a \\<Longrightarrow> ?g (img x) = x\n 4. \\<And>y. y \\<in> local.set a \\<Longrightarrow> img (?g y) = y", "show \"img \\<in> hom unity a \\<rightarrow> set a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. img \\<in> hom unity a \\<rightarrow> local.set a", "using assms mkPoint_img"], ["proof (prove)\nusing this:\n  ide a\n  img \\<in> hom unity ?a \\<rightarrow> local.set ?a\n  \\<guillemotleft>?x : unity \\<rightarrow> ?a\\<guillemotright> \\<Longrightarrow>\n  mkPoint ?a (img ?x) = ?x\n\ngoal (1 subgoal):\n 1. img \\<in> hom unity a \\<rightarrow> local.set a", "by auto"], ["proof (state)\nthis:\n  img \\<in> hom unity a \\<rightarrow> local.set a\n\ngoal (3 subgoals):\n 1. ?g \\<in> local.set a \\<rightarrow> hom unity a\n 2. \\<And>x. x \\<in> hom unity a \\<Longrightarrow> ?g (img x) = x\n 3. \\<And>y. y \\<in> local.set a \\<Longrightarrow> img (?g y) = y", "show \"mkPoint a \\<in> set a \\<rightarrow> hom unity a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mkPoint a \\<in> local.set a \\<rightarrow> hom unity a", "using assms img_mkPoint"], ["proof (prove)\nusing this:\n  ide a\n  ide ?a \\<Longrightarrow>\n  mkPoint ?a \\<in> local.set ?a \\<rightarrow> hom unity ?a\n  \\<lbrakk>ide ?a; ?t \\<in> local.set ?a\\<rbrakk>\n  \\<Longrightarrow> img (mkPoint ?a ?t) = ?t\n\ngoal (1 subgoal):\n 1. mkPoint a \\<in> local.set a \\<rightarrow> hom unity a", "by auto"], ["proof (state)\nthis:\n  mkPoint a \\<in> local.set a \\<rightarrow> hom unity a\n\ngoal (2 subgoals):\n 1. \\<And>x. x \\<in> hom unity a \\<Longrightarrow> mkPoint a (img x) = x\n 2. \\<And>y. y \\<in> local.set a \\<Longrightarrow> img (mkPoint a y) = y", "show \"\\<And>x. x \\<in> hom unity a \\<Longrightarrow> mkPoint a (img x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> hom unity a \\<Longrightarrow> mkPoint a (img x) = x", "using assms mkPoint_img"], ["proof (prove)\nusing this:\n  ide a\n  img \\<in> hom unity ?a \\<rightarrow> local.set ?a\n  \\<guillemotleft>?x : unity \\<rightarrow> ?a\\<guillemotright> \\<Longrightarrow>\n  mkPoint ?a (img ?x) = ?x\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> hom unity a \\<Longrightarrow> mkPoint a (img x) = x", "by auto"], ["proof (state)\nthis:\n  ?x \\<in> hom unity a \\<Longrightarrow> mkPoint a (img ?x) = ?x\n\ngoal (1 subgoal):\n 1. \\<And>y. y \\<in> local.set a \\<Longrightarrow> img (mkPoint a y) = y", "show \"\\<And>t. t \\<in> set a \\<Longrightarrow> img (mkPoint a t) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> local.set a \\<Longrightarrow> img (mkPoint a t) = t", "using assms img_mkPoint"], ["proof (prove)\nusing this:\n  ide a\n  ide ?a \\<Longrightarrow>\n  mkPoint ?a \\<in> local.set ?a \\<rightarrow> hom unity ?a\n  \\<lbrakk>ide ?a; ?t \\<in> local.set ?a\\<rbrakk>\n  \\<Longrightarrow> img (mkPoint ?a ?t) = ?t\n\ngoal (1 subgoal):\n 1. \\<And>t. t \\<in> local.set a \\<Longrightarrow> img (mkPoint a t) = t", "by auto"], ["proof (state)\nthis:\n  ?t \\<in> local.set a \\<Longrightarrow> img (mkPoint a ?t) = ?t\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n      The function on the universe induced by an arrow @{term f} agrees, under the bijection\n      between @{term \"hom unity (dom f)\"} and @{term \"Dom f\"}, with the action of @{term f}\n      by composition on @{term \"hom unity (dom f)\"}.\n\\<close>"], ["", "lemma Fun_point:\n    assumes \"\\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright>\"\n    shows \"Fun x = (\\<lambda>_ \\<in> {unity}. img x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun x = (\\<lambda>_\\<in>{unity}. img x)", "using assms mkPoint_img img_mkPoint Fun_mkPoint [of a \"img x\"] img_point_elem_set"], ["proof (prove)\nusing this:\n  \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright>\n  img \\<in> hom unity ?a \\<rightarrow> local.set ?a\n  \\<guillemotleft>?x : unity \\<rightarrow> ?a\\<guillemotright> \\<Longrightarrow>\n  mkPoint ?a (img ?x) = ?x\n  ide ?a \\<Longrightarrow>\n  mkPoint ?a \\<in> local.set ?a \\<rightarrow> hom unity ?a\n  \\<lbrakk>ide ?a; ?t \\<in> local.set ?a\\<rbrakk>\n  \\<Longrightarrow> img (mkPoint ?a ?t) = ?t\n  \\<lbrakk>ide a; img x \\<in> local.set a\\<rbrakk>\n  \\<Longrightarrow> Fun (mkPoint a (img x)) =\n                    (\\<lambda>_\\<in>{unity}. img x)\n  \\<guillemotleft>?x : unity \\<rightarrow> ?a\\<guillemotright> \\<Longrightarrow>\n  img ?x \\<in> local.set ?a\n\ngoal (1 subgoal):\n 1. Fun x = (\\<lambda>_\\<in>{unity}. img x)", "by auto"], ["", "lemma comp_arr_mkPoint:\n    assumes \"arr f\" and \"t \\<in> Dom f\"\n    shows \"f \\<cdot> mkPoint (dom f) t = mkPoint (cod f) (Fun f t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<cdot> mkPoint (local.dom f) t = mkPoint (cod f) (Fun f t)", "proof (intro arr_eqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. par (f \\<cdot> mkPoint (local.dom f) t) (mkPoint (cod f) (Fun f t))\n 2. Fun (f \\<cdot> mkPoint (local.dom f) t) =\n    Fun (mkPoint (cod f) (Fun f t))", "have 0: \"seq f (mkPoint (dom f) t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq f (mkPoint (local.dom f) t)", "using assms mkPoint_in_hom [of \"dom f\" t]"], ["proof (prove)\nusing this:\n  arr f\n  t \\<in> Dom f\n  \\<lbrakk>ide (local.dom f); t \\<in> Dom f\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>mkPoint (local.dom f)\n                                     t : unity \\<rightarrow> local.dom\n                        f\\<guillemotright>\n\ngoal (1 subgoal):\n 1. seq f (mkPoint (local.dom f) t)", "by auto"], ["proof (state)\nthis:\n  seq f (mkPoint (local.dom f) t)\n\ngoal (2 subgoals):\n 1. par (f \\<cdot> mkPoint (local.dom f) t) (mkPoint (cod f) (Fun f t))\n 2. Fun (f \\<cdot> mkPoint (local.dom f) t) =\n    Fun (mkPoint (cod f) (Fun f t))", "have 1: \"\\<guillemotleft>f \\<cdot> mkPoint (dom f) t : unity \\<rightarrow> cod f\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>f \\<cdot>\n                    mkPoint (local.dom f)\n                     t : unity \\<rightarrow> cod f\\<guillemotright>", "using assms mkPoint_in_hom [of \"dom f\" t]"], ["proof (prove)\nusing this:\n  arr f\n  t \\<in> Dom f\n  \\<lbrakk>ide (local.dom f); t \\<in> Dom f\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>mkPoint (local.dom f)\n                                     t : unity \\<rightarrow> local.dom\n                        f\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>f \\<cdot>\n                    mkPoint (local.dom f)\n                     t : unity \\<rightarrow> cod f\\<guillemotright>", "by auto"], ["proof (state)\nthis:\n  \\<guillemotleft>f \\<cdot>\n                  mkPoint (local.dom f)\n                   t : unity \\<rightarrow> cod f\\<guillemotright>\n\ngoal (2 subgoals):\n 1. par (f \\<cdot> mkPoint (local.dom f) t) (mkPoint (cod f) (Fun f t))\n 2. Fun (f \\<cdot> mkPoint (local.dom f) t) =\n    Fun (mkPoint (cod f) (Fun f t))", "show \"par (f \\<cdot> mkPoint (dom f) t) (mkPoint (cod f) (Fun f t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. par (f \\<cdot> mkPoint (local.dom f) t) (mkPoint (cod f) (Fun f t))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. par (f \\<cdot> mkPoint (local.dom f) t) (mkPoint (cod f) (Fun f t))", "have \"\\<guillemotleft>mkPoint (cod f) (Fun f t) : unity \\<rightarrow> cod f\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>mkPoint (cod f)\n                     (Fun f t) : unity \\<rightarrow> cod f\\<guillemotright>", "using assms Fun_mapsto mkPoint_in_hom [of \"cod f\" \"Fun f t\"]"], ["proof (prove)\nusing this:\n  arr f\n  t \\<in> Dom f\n  arr ?f \\<Longrightarrow>\n  Fun ?f \\<in> extensional (Dom ?f) \\<inter> (Dom ?f \\<rightarrow> Cod ?f)\n  \\<lbrakk>ide (cod f); Fun f t \\<in> Cod f\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>mkPoint (cod f)\n                                     (Fun f\n t) : unity \\<rightarrow> cod f\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>mkPoint (cod f)\n                     (Fun f t) : unity \\<rightarrow> cod f\\<guillemotright>", "by auto"], ["proof (state)\nthis:\n  \\<guillemotleft>mkPoint (cod f)\n                   (Fun f t) : unity \\<rightarrow> cod f\\<guillemotright>\n\ngoal (1 subgoal):\n 1. par (f \\<cdot> mkPoint (local.dom f) t) (mkPoint (cod f) (Fun f t))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<guillemotleft>mkPoint (cod f)\n                   (Fun f t) : unity \\<rightarrow> cod f\\<guillemotright>\n\ngoal (1 subgoal):\n 1. par (f \\<cdot> mkPoint (local.dom f) t) (mkPoint (cod f) (Fun f t))", "using 1"], ["proof (prove)\nusing this:\n  \\<guillemotleft>mkPoint (cod f)\n                   (Fun f t) : unity \\<rightarrow> cod f\\<guillemotright>\n  \\<guillemotleft>f \\<cdot>\n                  mkPoint (local.dom f)\n                   t : unity \\<rightarrow> cod f\\<guillemotright>\n\ngoal (1 subgoal):\n 1. par (f \\<cdot> mkPoint (local.dom f) t) (mkPoint (cod f) (Fun f t))", "by fastforce"], ["proof (state)\nthis:\n  par (f \\<cdot> mkPoint (local.dom f) t) (mkPoint (cod f) (Fun f t))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  par (f \\<cdot> mkPoint (local.dom f) t) (mkPoint (cod f) (Fun f t))\n\ngoal (1 subgoal):\n 1. Fun (f \\<cdot> mkPoint (local.dom f) t) =\n    Fun (mkPoint (cod f) (Fun f t))", "show \"Fun (f \\<cdot> mkPoint (dom f) t) = Fun (mkPoint (cod f) (Fun f t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (f \\<cdot> mkPoint (local.dom f) t) =\n    Fun (mkPoint (cod f) (Fun f t))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Fun (f \\<cdot> mkPoint (local.dom f) t) =\n    Fun (mkPoint (cod f) (Fun f t))", "have \"Fun (f \\<cdot> mkPoint (dom f) t) = restrict (Fun f o Fun (mkPoint (dom f) t)) {unity}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (f \\<cdot> mkPoint (local.dom f) t) =\n    restrict (Fun f \\<circ> Fun (mkPoint (local.dom f) t)) {unity}", "using assms 0 1 Fun_comp terminal_char2 terminal_unity"], ["proof (prove)\nusing this:\n  arr f\n  t \\<in> Dom f\n  seq f (mkPoint (local.dom f) t)\n  \\<guillemotleft>f \\<cdot>\n                  mkPoint (local.dom f)\n                   t : unity \\<rightarrow> cod f\\<guillemotright>\n  seq ?g ?f \\<Longrightarrow>\n  Fun (?g \\<cdot> ?f) = restrict (Fun ?g \\<circ> Fun ?f) (Dom ?f)\n  terminal ?t = (ide ?t \\<and> local.set ?t = {?t})\n  terminal unity\n\ngoal (1 subgoal):\n 1. Fun (f \\<cdot> mkPoint (local.dom f) t) =\n    restrict (Fun f \\<circ> Fun (mkPoint (local.dom f) t)) {unity}", "by auto"], ["proof (state)\nthis:\n  Fun (f \\<cdot> mkPoint (local.dom f) t) =\n  restrict (Fun f \\<circ> Fun (mkPoint (local.dom f) t)) {unity}\n\ngoal (1 subgoal):\n 1. Fun (f \\<cdot> mkPoint (local.dom f) t) =\n    Fun (mkPoint (cod f) (Fun f t))", "also"], ["proof (state)\nthis:\n  Fun (f \\<cdot> mkPoint (local.dom f) t) =\n  restrict (Fun f \\<circ> Fun (mkPoint (local.dom f) t)) {unity}\n\ngoal (1 subgoal):\n 1. Fun (f \\<cdot> mkPoint (local.dom f) t) =\n    Fun (mkPoint (cod f) (Fun f t))", "have \"... = (\\<lambda>_ \\<in> {unity}. Fun f t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict (Fun f \\<circ> Fun (mkPoint (local.dom f) t)) {unity} =\n    (\\<lambda>_\\<in>{unity}. Fun f t)", "using assms Fun_mkPoint"], ["proof (prove)\nusing this:\n  arr f\n  t \\<in> Dom f\n  \\<lbrakk>ide ?a; ?t \\<in> local.set ?a\\<rbrakk>\n  \\<Longrightarrow> Fun (mkPoint ?a ?t) = (\\<lambda>_\\<in>{unity}. ?t)\n\ngoal (1 subgoal):\n 1. restrict (Fun f \\<circ> Fun (mkPoint (local.dom f) t)) {unity} =\n    (\\<lambda>_\\<in>{unity}. Fun f t)", "by auto"], ["proof (state)\nthis:\n  restrict (Fun f \\<circ> Fun (mkPoint (local.dom f) t)) {unity} =\n  (\\<lambda>_\\<in>{unity}. Fun f t)\n\ngoal (1 subgoal):\n 1. Fun (f \\<cdot> mkPoint (local.dom f) t) =\n    Fun (mkPoint (cod f) (Fun f t))", "also"], ["proof (state)\nthis:\n  restrict (Fun f \\<circ> Fun (mkPoint (local.dom f) t)) {unity} =\n  (\\<lambda>_\\<in>{unity}. Fun f t)\n\ngoal (1 subgoal):\n 1. Fun (f \\<cdot> mkPoint (local.dom f) t) =\n    Fun (mkPoint (cod f) (Fun f t))", "have \"... = Fun (mkPoint (cod f) (Fun f t))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>_\\<in>{unity}. Fun f t) = Fun (mkPoint (cod f) (Fun f t))", "using assms Fun_mkPoint [of \"cod f\" \"Fun f t\"] Fun_mapsto"], ["proof (prove)\nusing this:\n  arr f\n  t \\<in> Dom f\n  \\<lbrakk>ide (cod f); Fun f t \\<in> Cod f\\<rbrakk>\n  \\<Longrightarrow> Fun (mkPoint (cod f) (Fun f t)) =\n                    (\\<lambda>_\\<in>{unity}. Fun f t)\n  arr ?f \\<Longrightarrow>\n  Fun ?f \\<in> extensional (Dom ?f) \\<inter> (Dom ?f \\<rightarrow> Cod ?f)\n\ngoal (1 subgoal):\n 1. (\\<lambda>_\\<in>{unity}. Fun f t) = Fun (mkPoint (cod f) (Fun f t))", "by fastforce"], ["proof (state)\nthis:\n  (\\<lambda>_\\<in>{unity}. Fun f t) = Fun (mkPoint (cod f) (Fun f t))\n\ngoal (1 subgoal):\n 1. Fun (f \\<cdot> mkPoint (local.dom f) t) =\n    Fun (mkPoint (cod f) (Fun f t))", "finally"], ["proof (chain)\npicking this:\n  Fun (f \\<cdot> mkPoint (local.dom f) t) = Fun (mkPoint (cod f) (Fun f t))", "show ?thesis"], ["proof (prove)\nusing this:\n  Fun (f \\<cdot> mkPoint (local.dom f) t) = Fun (mkPoint (cod f) (Fun f t))\n\ngoal (1 subgoal):\n 1. Fun (f \\<cdot> mkPoint (local.dom f) t) =\n    Fun (mkPoint (cod f) (Fun f t))", "by auto"], ["proof (state)\nthis:\n  Fun (f \\<cdot> mkPoint (local.dom f) t) = Fun (mkPoint (cod f) (Fun f t))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Fun (f \\<cdot> mkPoint (local.dom f) t) = Fun (mkPoint (cod f) (Fun f t))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma comp_arr_point:\n    assumes \"arr f\" and \"\\<guillemotleft>x : unity \\<rightarrow> dom f\\<guillemotright>\"\n    shows \"f \\<cdot> x = mkPoint (cod f) (Fun f (img x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<cdot> x = mkPoint (cod f) (Fun f (img x))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. f \\<cdot> x = mkPoint (cod f) (Fun f (img x))", "have \"x = mkPoint (dom f) (img x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = mkPoint (local.dom f) (img x)", "using assms mkPoint_img"], ["proof (prove)\nusing this:\n  arr f\n  \\<guillemotleft>x : unity \\<rightarrow> local.dom f\\<guillemotright>\n  img \\<in> hom unity ?a \\<rightarrow> local.set ?a\n  \\<guillemotleft>?x : unity \\<rightarrow> ?a\\<guillemotright> \\<Longrightarrow>\n  mkPoint ?a (img ?x) = ?x\n\ngoal (1 subgoal):\n 1. x = mkPoint (local.dom f) (img x)", "by simp"], ["proof (state)\nthis:\n  x = mkPoint (local.dom f) (img x)\n\ngoal (1 subgoal):\n 1. f \\<cdot> x = mkPoint (cod f) (Fun f (img x))", "thus ?thesis"], ["proof (prove)\nusing this:\n  x = mkPoint (local.dom f) (img x)\n\ngoal (1 subgoal):\n 1. f \\<cdot> x = mkPoint (cod f) (Fun f (img x))", "using assms comp_arr_mkPoint [of f \"img x\"]"], ["proof (prove)\nusing this:\n  x = mkPoint (local.dom f) (img x)\n  arr f\n  \\<guillemotleft>x : unity \\<rightarrow> local.dom f\\<guillemotright>\n  \\<lbrakk>arr f; img x \\<in> Dom f\\<rbrakk>\n  \\<Longrightarrow> f \\<cdot> mkPoint (local.dom f) (img x) =\n                    mkPoint (cod f) (Fun f (img x))\n\ngoal (1 subgoal):\n 1. f \\<cdot> x = mkPoint (cod f) (Fun f (img x))", "by (simp add: img_point_elem_set)"], ["proof (state)\nthis:\n  f \\<cdot> x = mkPoint (cod f) (Fun f (img x))\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n      This agreement allows us to express @{term \"Fun f\"} in terms of composition.\n\\<close>"], ["", "lemma Fun_in_terms_of_comp:\n    assumes \"arr f\"\n    shows \"Fun f = restrict (img o S f o mkPoint (dom f)) (Dom f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun f =\n    restrict (img \\<circ> (\\<cdot>) f \\<circ> mkPoint (local.dom f)) (Dom f)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       Fun f x =\n       restrict (img \\<circ> (\\<cdot>) f \\<circ> mkPoint (local.dom f))\n        (Dom f) x", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       Fun f x =\n       restrict (img \\<circ> (\\<cdot>) f \\<circ> mkPoint (local.dom f))\n        (Dom f) x", "have \"t \\<notin> Dom f \\<Longrightarrow> Fun f t = restrict (img o S f o mkPoint (dom f)) (Dom f) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<notin> Dom f \\<Longrightarrow>\n    Fun f t =\n    restrict (img \\<circ> (\\<cdot>) f \\<circ> mkPoint (local.dom f)) (Dom f)\n     t", "using assms"], ["proof (prove)\nusing this:\n  arr f\n\ngoal (1 subgoal):\n 1. t \\<notin> Dom f \\<Longrightarrow>\n    Fun f t =\n    restrict (img \\<circ> (\\<cdot>) f \\<circ> mkPoint (local.dom f)) (Dom f)\n     t", "by (simp add: Fun_def)"], ["proof (state)\nthis:\n  t \\<notin> Dom f \\<Longrightarrow>\n  Fun f t =\n  restrict (img \\<circ> (\\<cdot>) f \\<circ> mkPoint (local.dom f)) (Dom f) t\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       Fun f x =\n       restrict (img \\<circ> (\\<cdot>) f \\<circ> mkPoint (local.dom f))\n        (Dom f) x", "moreover"], ["proof (state)\nthis:\n  t \\<notin> Dom f \\<Longrightarrow>\n  Fun f t =\n  restrict (img \\<circ> (\\<cdot>) f \\<circ> mkPoint (local.dom f)) (Dom f) t\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       Fun f x =\n       restrict (img \\<circ> (\\<cdot>) f \\<circ> mkPoint (local.dom f))\n        (Dom f) x", "have \"t \\<in> Dom f \\<Longrightarrow>\n                     Fun f t = restrict (img o S f o mkPoint (dom f)) (Dom f) t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. t \\<in> Dom f \\<Longrightarrow>\n    Fun f t =\n    restrict (img \\<circ> (\\<cdot>) f \\<circ> mkPoint (local.dom f)) (Dom f)\n     t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. t \\<in> Dom f \\<Longrightarrow>\n    Fun f t =\n    restrict (img \\<circ> (\\<cdot>) f \\<circ> mkPoint (local.dom f)) (Dom f)\n     t", "assume t: \"t \\<in> Dom f\""], ["proof (state)\nthis:\n  t \\<in> Dom f\n\ngoal (1 subgoal):\n 1. t \\<in> Dom f \\<Longrightarrow>\n    Fun f t =\n    restrict (img \\<circ> (\\<cdot>) f \\<circ> mkPoint (local.dom f)) (Dom f)\n     t", "have 1: \"f \\<cdot> mkPoint (dom f) t = mkPoint (cod f) (Fun f t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<cdot> mkPoint (local.dom f) t = mkPoint (cod f) (Fun f t)", "using assms t comp_arr_mkPoint"], ["proof (prove)\nusing this:\n  arr f\n  t \\<in> Dom f\n  \\<lbrakk>arr ?f; ?t \\<in> Dom ?f\\<rbrakk>\n  \\<Longrightarrow> ?f \\<cdot> mkPoint (local.dom ?f) ?t =\n                    mkPoint (cod ?f) (Fun ?f ?t)\n\ngoal (1 subgoal):\n 1. f \\<cdot> mkPoint (local.dom f) t = mkPoint (cod f) (Fun f t)", "by simp"], ["proof (state)\nthis:\n  f \\<cdot> mkPoint (local.dom f) t = mkPoint (cod f) (Fun f t)\n\ngoal (1 subgoal):\n 1. t \\<in> Dom f \\<Longrightarrow>\n    Fun f t =\n    restrict (img \\<circ> (\\<cdot>) f \\<circ> mkPoint (local.dom f)) (Dom f)\n     t", "hence \"img (f \\<cdot> mkPoint (dom f) t) = img (mkPoint (cod f) (Fun f t))\""], ["proof (prove)\nusing this:\n  f \\<cdot> mkPoint (local.dom f) t = mkPoint (cod f) (Fun f t)\n\ngoal (1 subgoal):\n 1. img (f \\<cdot> mkPoint (local.dom f) t) =\n    img (mkPoint (cod f) (Fun f t))", "by simp"], ["proof (state)\nthis:\n  img (f \\<cdot> mkPoint (local.dom f) t) = img (mkPoint (cod f) (Fun f t))\n\ngoal (1 subgoal):\n 1. t \\<in> Dom f \\<Longrightarrow>\n    Fun f t =\n    restrict (img \\<circ> (\\<cdot>) f \\<circ> mkPoint (local.dom f)) (Dom f)\n     t", "thus ?thesis"], ["proof (prove)\nusing this:\n  img (f \\<cdot> mkPoint (local.dom f) t) = img (mkPoint (cod f) (Fun f t))\n\ngoal (1 subgoal):\n 1. Fun f t =\n    restrict (img \\<circ> (\\<cdot>) f \\<circ> mkPoint (local.dom f)) (Dom f)\n     t", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. img (f \\<cdot> mkPoint (local.dom f) t) =\n    img (mkPoint (cod f) (Fun f t)) \\<Longrightarrow>\n    Fun f t =\n    restrict (img \\<circ> (\\<cdot>) f \\<circ> mkPoint (local.dom f)) (Dom f)\n     t", "have \"Fun f t \\<in> Cod f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun f t \\<in> Cod f", "using assms t Fun_mapsto"], ["proof (prove)\nusing this:\n  arr f\n  t \\<in> Dom f\n  arr ?f \\<Longrightarrow>\n  Fun ?f \\<in> extensional (Dom ?f) \\<inter> (Dom ?f \\<rightarrow> Cod ?f)\n\ngoal (1 subgoal):\n 1. Fun f t \\<in> Cod f", "by auto"], ["proof (state)\nthis:\n  Fun f t \\<in> Cod f\n\ngoal (1 subgoal):\n 1. img (f \\<cdot> mkPoint (local.dom f) t) =\n    img (mkPoint (cod f) (Fun f t)) \\<Longrightarrow>\n    Fun f t =\n    restrict (img \\<circ> (\\<cdot>) f \\<circ> mkPoint (local.dom f)) (Dom f)\n     t", "thus ?thesis"], ["proof (prove)\nusing this:\n  Fun f t \\<in> Cod f\n\ngoal (1 subgoal):\n 1. Fun f t =\n    restrict (img \\<circ> (\\<cdot>) f \\<circ> mkPoint (local.dom f)) (Dom f)\n     t", "using assms t 1 img_mkPoint"], ["proof (prove)\nusing this:\n  Fun f t \\<in> Cod f\n  arr f\n  t \\<in> Dom f\n  f \\<cdot> mkPoint (local.dom f) t = mkPoint (cod f) (Fun f t)\n  ide ?a \\<Longrightarrow>\n  mkPoint ?a \\<in> local.set ?a \\<rightarrow> hom unity ?a\n  \\<lbrakk>ide ?a; ?t \\<in> local.set ?a\\<rbrakk>\n  \\<Longrightarrow> img (mkPoint ?a ?t) = ?t\n\ngoal (1 subgoal):\n 1. Fun f t =\n    restrict (img \\<circ> (\\<cdot>) f \\<circ> mkPoint (local.dom f)) (Dom f)\n     t", "by auto"], ["proof (state)\nthis:\n  Fun f t =\n  restrict (img \\<circ> (\\<cdot>) f \\<circ> mkPoint (local.dom f)) (Dom f) t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Fun f t =\n  restrict (img \\<circ> (\\<cdot>) f \\<circ> mkPoint (local.dom f)) (Dom f) t\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  t \\<in> Dom f \\<Longrightarrow>\n  Fun f t =\n  restrict (img \\<circ> (\\<cdot>) f \\<circ> mkPoint (local.dom f)) (Dom f) t\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       Fun f x =\n       restrict (img \\<circ> (\\<cdot>) f \\<circ> mkPoint (local.dom f))\n        (Dom f) x", "ultimately"], ["proof (chain)\npicking this:\n  t \\<notin> Dom f \\<Longrightarrow>\n  Fun f t =\n  restrict (img \\<circ> (\\<cdot>) f \\<circ> mkPoint (local.dom f)) (Dom f) t\n  t \\<in> Dom f \\<Longrightarrow>\n  Fun f t =\n  restrict (img \\<circ> (\\<cdot>) f \\<circ> mkPoint (local.dom f)) (Dom f) t", "show \"Fun f t = restrict (img o S f o mkPoint (dom f)) (Dom f) t\""], ["proof (prove)\nusing this:\n  t \\<notin> Dom f \\<Longrightarrow>\n  Fun f t =\n  restrict (img \\<circ> (\\<cdot>) f \\<circ> mkPoint (local.dom f)) (Dom f) t\n  t \\<in> Dom f \\<Longrightarrow>\n  Fun f t =\n  restrict (img \\<circ> (\\<cdot>) f \\<circ> mkPoint (local.dom f)) (Dom f) t\n\ngoal (1 subgoal):\n 1. Fun f t =\n    restrict (img \\<circ> (\\<cdot>) f \\<circ> mkPoint (local.dom f)) (Dom f)\n     t", "by auto"], ["proof (state)\nthis:\n  Fun f t =\n  restrict (img \\<circ> (\\<cdot>) f \\<circ> mkPoint (local.dom f)) (Dom f) t\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n      We therefore obtain a rule for proving parallel arrows equal by showing\n      that they have the same action by composition on points.\n\\<close>"], ["", "(*\n     * TODO: Find out why attempts to use this as the main rule for a proof loop\n     * unless the specific instance is given.\n     *)"], ["", "lemma arr_eqI':\n    assumes \"par f f'\" and \"\\<And>x. \\<guillemotleft>x : unity \\<rightarrow> dom f\\<guillemotright> \\<Longrightarrow> f \\<cdot> x = f' \\<cdot> x\"\n    shows \"f = f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = f'", "using assms Fun_in_terms_of_comp mkPoint_in_hom"], ["proof (prove)\nusing this:\n  par f f'\n  \\<guillemotleft>?x : unity \\<rightarrow> local.dom\n      f\\<guillemotright> \\<Longrightarrow>\n  f \\<cdot> ?x = f' \\<cdot> ?x\n  arr ?f \\<Longrightarrow>\n  Fun ?f =\n  restrict (img \\<circ> (\\<cdot>) ?f \\<circ> mkPoint (local.dom ?f))\n   (Dom ?f)\n  \\<lbrakk>ide ?a; ?t \\<in> local.set ?a\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>mkPoint ?a\n                                     ?t : unity \\<rightarrow> ?a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. f = f'", "by (intro arr_eqI, auto)"], ["", "text\\<open>\n      An arrow can therefore be specified by giving its action by composition on points.\n      In many situations, this is more natural than specifying it as a function on the universe.\n\\<close>"], ["", "definition mkArr'\n    where \"mkArr' a b F = mkArr (set a) (set b) (img o F o mkPoint a)\""], ["", "lemma mkArr'_in_hom:\n    assumes \"ide a\" and \"ide b\" and \"F \\<in> hom unity a \\<rightarrow> hom unity b\"\n    shows \"\\<guillemotleft>mkArr' a b F : a \\<rightarrow> b\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>mkArr' a b F : a \\<rightarrow> b\\<guillemotright>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<guillemotleft>mkArr' a b F : a \\<rightarrow> b\\<guillemotright>", "have \"img o F o mkPoint a \\<in> set a \\<rightarrow> set b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. img \\<circ> F \\<circ> mkPoint a\n    \\<in> local.set a \\<rightarrow> local.set b", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> local.set a \\<Longrightarrow>\n       (img \\<circ> F \\<circ> mkPoint a) x \\<in> local.set b", "fix t"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> local.set a \\<Longrightarrow>\n       (img \\<circ> F \\<circ> mkPoint a) x \\<in> local.set b", "assume t: \"t \\<in> set a\""], ["proof (state)\nthis:\n  t \\<in> local.set a\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> local.set a \\<Longrightarrow>\n       (img \\<circ> F \\<circ> mkPoint a) x \\<in> local.set b", "thus \"(img o F o mkPoint a) t \\<in> set b\""], ["proof (prove)\nusing this:\n  t \\<in> local.set a\n\ngoal (1 subgoal):\n 1. (img \\<circ> F \\<circ> mkPoint a) t \\<in> local.set b", "using assms mkPoint_in_hom img_point_elem_set [of \"F (mkPoint a t)\" b]"], ["proof (prove)\nusing this:\n  t \\<in> local.set a\n  ide a\n  ide b\n  F \\<in> hom unity a \\<rightarrow> hom unity b\n  \\<lbrakk>ide ?a; ?t \\<in> local.set ?a\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>mkPoint ?a\n                                     ?t : unity \\<rightarrow> ?a\\<guillemotright>\n  \\<guillemotleft>F (mkPoint a\n                      t) : unity \\<rightarrow> b\\<guillemotright> \\<Longrightarrow>\n  img (F (mkPoint a t)) \\<in> local.set b\n\ngoal (1 subgoal):\n 1. (img \\<circ> F \\<circ> mkPoint a) t \\<in> local.set b", "by auto"], ["proof (state)\nthis:\n  (img \\<circ> F \\<circ> mkPoint a) t \\<in> local.set b\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  img \\<circ> F \\<circ> mkPoint a\n  \\<in> local.set a \\<rightarrow> local.set b\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>mkArr' a b F : a \\<rightarrow> b\\<guillemotright>", "thus ?thesis"], ["proof (prove)\nusing this:\n  img \\<circ> F \\<circ> mkPoint a\n  \\<in> local.set a \\<rightarrow> local.set b\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>mkArr' a b F : a \\<rightarrow> b\\<guillemotright>", "using assms mkArr'_def mkArr_in_hom [of \"set a\" \"set b\"] set_card mkIde_set"], ["proof (prove)\nusing this:\n  img \\<circ> F \\<circ> mkPoint a\n  \\<in> local.set a \\<rightarrow> local.set b\n  ide a\n  ide b\n  F \\<in> hom unity a \\<rightarrow> hom unity b\n  mkArr' ?a ?b ?F =\n  mkArr (local.set ?a) (local.set ?b) (img \\<circ> ?F \\<circ> mkPoint ?a)\n  \\<lbrakk>local.set a \\<subseteq> Univ; |local.set a| <o \\<AA>;\n   local.set b \\<subseteq> Univ; |local.set b| <o \\<AA>;\n   ?F \\<in> local.set a \\<rightarrow> local.set b\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>mkArr (local.set a) (local.set b)\n                                     ?F : mkIde\n     (local.set a) \\<rightarrow> mkIde (local.set b)\\<guillemotright>\n  ide ?a \\<Longrightarrow> |local.set ?a| <o \\<AA>\n  ide ?a \\<Longrightarrow> mkIde (local.set ?a) = ?a\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>mkArr' a b F : a \\<rightarrow> b\\<guillemotright>", "by simp"], ["proof (state)\nthis:\n  \\<guillemotleft>mkArr' a b F : a \\<rightarrow> b\\<guillemotright>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma comp_point_mkArr':\n    assumes \"ide a\" and \"ide b\" and \"F \\<in> hom unity a \\<rightarrow> hom unity b\"\n    shows \"\\<And>x. \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<Longrightarrow> mkArr' a b F \\<cdot> x = F x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<Longrightarrow>\n       mkArr' a b F \\<cdot> x = F x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<Longrightarrow>\n       mkArr' a b F \\<cdot> x = F x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<Longrightarrow>\n       mkArr' a b F \\<cdot> x = F x", "assume x: \"\\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright>\""], ["proof (state)\nthis:\n  \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<Longrightarrow>\n       mkArr' a b F \\<cdot> x = F x", "have \"Fun (mkArr' a b F) (img x) = img (F x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (mkArr' a b F) (img x) = img (F x)", "unfolding mkArr'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (mkArr (local.set a) (local.set b)\n          (img \\<circ> F \\<circ> mkPoint a))\n     (img x) =\n    img (F x)", "using assms x Fun_mkArr arr_mkArr img_point_elem_set mkPoint_img mkPoint_in_hom"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  F \\<in> hom unity a \\<rightarrow> hom unity b\n  \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright>\n  arr (mkArr ?A ?B ?F) \\<Longrightarrow>\n  Fun (mkArr ?A ?B ?F) = restrict ?F ?A\n  arr (mkArr ?A ?B ?F) =\n  (?A \\<subseteq> Univ \\<and>\n   |?A| <o \\<AA> \\<and>\n   ?B \\<subseteq> Univ \\<and>\n   |?B| <o \\<AA> \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n  \\<guillemotleft>?x : unity \\<rightarrow> ?a\\<guillemotright> \\<Longrightarrow>\n  img ?x \\<in> local.set ?a\n  img \\<in> hom unity ?a \\<rightarrow> local.set ?a\n  \\<guillemotleft>?x : unity \\<rightarrow> ?a\\<guillemotright> \\<Longrightarrow>\n  mkPoint ?a (img ?x) = ?x\n  \\<lbrakk>ide ?a; ?t \\<in> local.set ?a\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>mkPoint ?a\n                                     ?t : unity \\<rightarrow> ?a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. Fun (mkArr (local.set a) (local.set b)\n          (img \\<circ> F \\<circ> mkPoint a))\n     (img x) =\n    img (F x)", "by (simp add: set_card Pi_iff)"], ["proof (state)\nthis:\n  Fun (mkArr' a b F) (img x) = img (F x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<Longrightarrow>\n       mkArr' a b F \\<cdot> x = F x", "hence \"mkArr' a b F \\<cdot> x = mkPoint b (img (F x))\""], ["proof (prove)\nusing this:\n  Fun (mkArr' a b F) (img x) = img (F x)\n\ngoal (1 subgoal):\n 1. mkArr' a b F \\<cdot> x = mkPoint b (img (F x))", "using assms x mkArr'_in_hom [of a b F] comp_arr_point"], ["proof (prove)\nusing this:\n  Fun (mkArr' a b F) (img x) = img (F x)\n  ide a\n  ide b\n  F \\<in> hom unity a \\<rightarrow> hom unity b\n  \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright>\n  \\<lbrakk>ide a; ide b;\n   F \\<in> hom unity a \\<rightarrow> hom unity b\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>mkArr' a b\n                                     F : a \\<rightarrow> b\\<guillemotright>\n  \\<lbrakk>arr ?f;\n   \\<guillemotleft>?x : unity \\<rightarrow> local.dom\n       ?f\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> ?f \\<cdot> ?x = mkPoint (cod ?f) (Fun ?f (img ?x))\n\ngoal (1 subgoal):\n 1. mkArr' a b F \\<cdot> x = mkPoint b (img (F x))", "by auto"], ["proof (state)\nthis:\n  mkArr' a b F \\<cdot> x = mkPoint b (img (F x))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<Longrightarrow>\n       mkArr' a b F \\<cdot> x = F x", "thus \"mkArr' a b F \\<cdot> x = F x\""], ["proof (prove)\nusing this:\n  mkArr' a b F \\<cdot> x = mkPoint b (img (F x))\n\ngoal (1 subgoal):\n 1. mkArr' a b F \\<cdot> x = F x", "using assms x mkPoint_img(2)"], ["proof (prove)\nusing this:\n  mkArr' a b F \\<cdot> x = mkPoint b (img (F x))\n  ide a\n  ide b\n  F \\<in> hom unity a \\<rightarrow> hom unity b\n  \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright>\n  \\<guillemotleft>?x : unity \\<rightarrow> ?a\\<guillemotright> \\<Longrightarrow>\n  mkPoint ?a (img ?x) = ?x\n\ngoal (1 subgoal):\n 1. mkArr' a b F \\<cdot> x = F x", "by auto"], ["proof (state)\nthis:\n  mkArr' a b F \\<cdot> x = F x\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n      A third characterization of terminal objects is as those objects whose set of\n      points is a singleton.\n\\<close>"], ["", "lemma terminal_char3:\n    assumes \"\\<exists>!x. \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright>\"\n    shows \"terminal a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminal a", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. terminal a", "have a: \"ide a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide a", "using assms ide_cod mem_Collect_eq"], ["proof (prove)\nusing this:\n  \\<exists>!x. \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright>\n  arr ?f \\<Longrightarrow> ide (cod ?f)\n  (?a \\<in> Collect ?P) = ?P ?a\n\ngoal (1 subgoal):\n 1. ide a", "by blast"], ["proof (state)\nthis:\n  ide a\n\ngoal (1 subgoal):\n 1. terminal a", "hence 1: \"bij_betw img (hom unity a) (set a)\""], ["proof (prove)\nusing this:\n  ide a\n\ngoal (1 subgoal):\n 1. bij_betw img (hom unity a) (local.set a)", "using assms bij_betw_points_and_set"], ["proof (prove)\nusing this:\n  ide a\n  \\<exists>!x. \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright>\n  ide ?a \\<Longrightarrow> bij_betw img (hom unity ?a) (local.set ?a)\n\ngoal (1 subgoal):\n 1. bij_betw img (hom unity a) (local.set a)", "by auto"], ["proof (state)\nthis:\n  bij_betw img (hom unity a) (local.set a)\n\ngoal (1 subgoal):\n 1. terminal a", "hence \"img ` (hom unity a) = set a\""], ["proof (prove)\nusing this:\n  bij_betw img (hom unity a) (local.set a)\n\ngoal (1 subgoal):\n 1. img ` hom unity a = local.set a", "by (simp add: bij_betw_def)"], ["proof (state)\nthis:\n  img ` hom unity a = local.set a\n\ngoal (1 subgoal):\n 1. terminal a", "moreover"], ["proof (state)\nthis:\n  img ` hom unity a = local.set a\n\ngoal (1 subgoal):\n 1. terminal a", "have \"hom unity a = {THE x. x \\<in> hom unity a}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom unity a = {THE x. x \\<in> hom unity a}", "using assms theI' [of \"\\<lambda>x. x \\<in> hom unity a\"]"], ["proof (prove)\nusing this:\n  \\<exists>!x. \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright>\n  \\<exists>!x. x \\<in> hom unity a \\<Longrightarrow>\n  (THE x. x \\<in> hom unity a) \\<in> hom unity a\n\ngoal (1 subgoal):\n 1. hom unity a = {THE x. x \\<in> hom unity a}", "by auto"], ["proof (state)\nthis:\n  hom unity a = {THE x. x \\<in> hom unity a}\n\ngoal (1 subgoal):\n 1. terminal a", "ultimately"], ["proof (chain)\npicking this:\n  img ` hom unity a = local.set a\n  hom unity a = {THE x. x \\<in> hom unity a}", "have \"set a = {img (THE x. x \\<in> hom unity a)}\""], ["proof (prove)\nusing this:\n  img ` hom unity a = local.set a\n  hom unity a = {THE x. x \\<in> hom unity a}\n\ngoal (1 subgoal):\n 1. local.set a = {img (THE x. x \\<in> hom unity a)}", "by (metis image_empty image_insert)"], ["proof (state)\nthis:\n  local.set a = {img (THE x. x \\<in> hom unity a)}\n\ngoal (1 subgoal):\n 1. terminal a", "thus ?thesis"], ["proof (prove)\nusing this:\n  local.set a = {img (THE x. x \\<in> hom unity a)}\n\ngoal (1 subgoal):\n 1. terminal a", "using a terminal_char1"], ["proof (prove)\nusing this:\n  local.set a = {img (THE x. x \\<in> hom unity a)}\n  ide a\n  terminal ?t = (ide ?t \\<and> (\\<exists>!x. x \\<in> local.set ?t))\n\ngoal (1 subgoal):\n 1. terminal a", "by simp"], ["proof (state)\nthis:\n  terminal a\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n      The following is an alternative formulation of functional completeness, which says that\n      any function on points uniquely determines an arrow.\n\\<close>"], ["", "lemma fun_complete':\n    assumes \"ide a\" and \"ide b\" and \"F \\<in> hom unity a \\<rightarrow> hom unity b\"\n    shows \"\\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and> (\\<forall>x. \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<longrightarrow> f \\<cdot> x = F x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!f.\n       \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n       (\\<forall>x.\n           \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<longrightarrow>\n           f \\<cdot> x = F x)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : a \\<rightarrow> b\\<guillemotright> \\<and>\n    (\\<forall>x.\n        \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<longrightarrow>\n        ?a \\<cdot> x = F x)\n 2. \\<And>f.\n       \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n       (\\<forall>x.\n           \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<longrightarrow>\n           f \\<cdot> x = F x) \\<Longrightarrow>\n       f = ?a", "have 1: \"\\<guillemotleft>mkArr' a b F : a \\<rightarrow> b\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>mkArr' a b F : a \\<rightarrow> b\\<guillemotright>", "using assms mkArr'_in_hom"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  F \\<in> hom unity a \\<rightarrow> hom unity b\n  \\<lbrakk>ide ?a; ide ?b;\n   ?F \\<in> hom unity ?a \\<rightarrow> hom unity ?b\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>mkArr' ?a ?b\n                                     ?F : ?a \\<rightarrow> ?b\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>mkArr' a b F : a \\<rightarrow> b\\<guillemotright>", "by auto"], ["proof (state)\nthis:\n  \\<guillemotleft>mkArr' a b F : a \\<rightarrow> b\\<guillemotright>\n\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : a \\<rightarrow> b\\<guillemotright> \\<and>\n    (\\<forall>x.\n        \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<longrightarrow>\n        ?a \\<cdot> x = F x)\n 2. \\<And>f.\n       \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n       (\\<forall>x.\n           \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<longrightarrow>\n           f \\<cdot> x = F x) \\<Longrightarrow>\n       f = ?a", "moreover"], ["proof (state)\nthis:\n  \\<guillemotleft>mkArr' a b F : a \\<rightarrow> b\\<guillemotright>\n\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : a \\<rightarrow> b\\<guillemotright> \\<and>\n    (\\<forall>x.\n        \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<longrightarrow>\n        ?a \\<cdot> x = F x)\n 2. \\<And>f.\n       \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n       (\\<forall>x.\n           \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<longrightarrow>\n           f \\<cdot> x = F x) \\<Longrightarrow>\n       f = ?a", "have 2: \"\\<And>x. \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<Longrightarrow> mkArr' a b F \\<cdot> x = F x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<Longrightarrow>\n       mkArr' a b F \\<cdot> x = F x", "using assms comp_point_mkArr'"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  F \\<in> hom unity a \\<rightarrow> hom unity b\n  \\<lbrakk>ide ?a; ide ?b; ?F \\<in> hom unity ?a \\<rightarrow> hom unity ?b;\n   \\<guillemotleft>?x : unity \\<rightarrow> ?a\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> mkArr' ?a ?b ?F \\<cdot> ?x = ?F ?x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<Longrightarrow>\n       mkArr' a b F \\<cdot> x = F x", "by auto"], ["proof (state)\nthis:\n  \\<guillemotleft>?x : unity \\<rightarrow> a\\<guillemotright> \\<Longrightarrow>\n  mkArr' a b F \\<cdot> ?x = F ?x\n\ngoal (2 subgoals):\n 1. \\<guillemotleft>?a : a \\<rightarrow> b\\<guillemotright> \\<and>\n    (\\<forall>x.\n        \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<longrightarrow>\n        ?a \\<cdot> x = F x)\n 2. \\<And>f.\n       \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n       (\\<forall>x.\n           \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<longrightarrow>\n           f \\<cdot> x = F x) \\<Longrightarrow>\n       f = ?a", "ultimately"], ["proof (chain)\npicking this:\n  \\<guillemotleft>mkArr' a b F : a \\<rightarrow> b\\<guillemotright>\n  \\<guillemotleft>?x : unity \\<rightarrow> a\\<guillemotright> \\<Longrightarrow>\n  mkArr' a b F \\<cdot> ?x = F ?x", "show \"\\<guillemotleft>mkArr' a b F : a \\<rightarrow> b\\<guillemotright> \\<and>\n                       (\\<forall>x. \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<longrightarrow> mkArr' a b F \\<cdot> x = F x)\""], ["proof (prove)\nusing this:\n  \\<guillemotleft>mkArr' a b F : a \\<rightarrow> b\\<guillemotright>\n  \\<guillemotleft>?x : unity \\<rightarrow> a\\<guillemotright> \\<Longrightarrow>\n  mkArr' a b F \\<cdot> ?x = F ?x\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>mkArr' a b F : a \\<rightarrow> b\\<guillemotright> \\<and>\n    (\\<forall>x.\n        \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<longrightarrow>\n        mkArr' a b F \\<cdot> x = F x)", "by blast"], ["proof (state)\nthis:\n  \\<guillemotleft>mkArr' a b F : a \\<rightarrow> b\\<guillemotright> \\<and>\n  (\\<forall>x.\n      \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<longrightarrow>\n      mkArr' a b F \\<cdot> x = F x)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n       (\\<forall>x.\n           \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<longrightarrow>\n           f \\<cdot> x = F x) \\<Longrightarrow>\n       f = mkArr' a b F", "fix f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n       (\\<forall>x.\n           \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<longrightarrow>\n           f \\<cdot> x = F x) \\<Longrightarrow>\n       f = mkArr' a b F", "assume f: \"\\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and> (\\<forall>x. \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<longrightarrow> f \\<cdot> x = F x)\""], ["proof (state)\nthis:\n  \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n  (\\<forall>x.\n      \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<longrightarrow>\n      f \\<cdot> x = F x)\n\ngoal (1 subgoal):\n 1. \\<And>f.\n       \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n       (\\<forall>x.\n           \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<longrightarrow>\n           f \\<cdot> x = F x) \\<Longrightarrow>\n       f = mkArr' a b F", "show \"f = mkArr' a b F\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = mkArr' a b F", "using f 1 2"], ["proof (prove)\nusing this:\n  \\<guillemotleft>f : a \\<rightarrow> b\\<guillemotright> \\<and>\n  (\\<forall>x.\n      \\<guillemotleft>x : unity \\<rightarrow> a\\<guillemotright> \\<longrightarrow>\n      f \\<cdot> x = F x)\n  \\<guillemotleft>mkArr' a b F : a \\<rightarrow> b\\<guillemotright>\n  \\<guillemotleft>?x : unity \\<rightarrow> a\\<guillemotright> \\<Longrightarrow>\n  mkArr' a b F \\<cdot> ?x = F ?x\n\ngoal (1 subgoal):\n 1. f = mkArr' a b F", "by (intro arr_eqI' [of f \"mkArr' a b F\"], fastforce, auto)"], ["proof (state)\nthis:\n  f = mkArr' a b F\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \"The `Determines Same Function' Relation on Arrows\""], ["", "text\\<open>\n      An important part of understanding the structure of a category of sets and functions\n      is to characterize when it is that two arrows ``determine the same function''.\n      The following result provides one answer to this: two arrows with a common domain\n      determine the same function if and only if they can be rendered equal by composing with\n      a cospan of inclusions.\n\\<close>"], ["", "lemma eq_Fun_iff_incl_joinable:\n    assumes \"span f f'\"\n    shows \"Fun f = Fun f' \\<longleftrightarrow>\n           (\\<exists>m m'. incl m \\<and> incl m' \\<and> seq m f \\<and> seq m' f' \\<and> m \\<cdot> f = m' \\<cdot> f')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Fun f = Fun f') =\n    (\\<exists>m m'.\n        incl m \\<and>\n        incl m' \\<and>\n        seq m f \\<and> seq m' f' \\<and> m \\<cdot> f = m' \\<cdot> f')", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. Fun f = Fun f' \\<Longrightarrow>\n    \\<exists>m m'.\n       incl m \\<and>\n       incl m' \\<and>\n       seq m f \\<and> seq m' f' \\<and> m \\<cdot> f = m' \\<cdot> f'\n 2. \\<exists>m m'.\n       incl m \\<and>\n       incl m' \\<and>\n       seq m f \\<and>\n       seq m' f' \\<and> m \\<cdot> f = m' \\<cdot> f' \\<Longrightarrow>\n    Fun f = Fun f'", "assume ff': \"Fun f = Fun f'\""], ["proof (state)\nthis:\n  Fun f = Fun f'\n\ngoal (2 subgoals):\n 1. Fun f = Fun f' \\<Longrightarrow>\n    \\<exists>m m'.\n       incl m \\<and>\n       incl m' \\<and>\n       seq m f \\<and> seq m' f' \\<and> m \\<cdot> f = m' \\<cdot> f'\n 2. \\<exists>m m'.\n       incl m \\<and>\n       incl m' \\<and>\n       seq m f \\<and>\n       seq m' f' \\<and> m \\<cdot> f = m' \\<cdot> f' \\<Longrightarrow>\n    Fun f = Fun f'", "let ?b = \"mkIde (Cod f \\<union> Cod f')\""], ["proof (state)\ngoal (2 subgoals):\n 1. Fun f = Fun f' \\<Longrightarrow>\n    \\<exists>m m'.\n       incl m \\<and>\n       incl m' \\<and>\n       seq m f \\<and> seq m' f' \\<and> m \\<cdot> f = m' \\<cdot> f'\n 2. \\<exists>m m'.\n       incl m \\<and>\n       incl m' \\<and>\n       seq m f \\<and>\n       seq m' f' \\<and> m \\<cdot> f = m' \\<cdot> f' \\<Longrightarrow>\n    Fun f = Fun f'", "let ?m = \"incl_of (cod f) ?b\""], ["proof (state)\ngoal (2 subgoals):\n 1. Fun f = Fun f' \\<Longrightarrow>\n    \\<exists>m m'.\n       incl m \\<and>\n       incl m' \\<and>\n       seq m f \\<and> seq m' f' \\<and> m \\<cdot> f = m' \\<cdot> f'\n 2. \\<exists>m m'.\n       incl m \\<and>\n       incl m' \\<and>\n       seq m f \\<and>\n       seq m' f' \\<and> m \\<cdot> f = m' \\<cdot> f' \\<Longrightarrow>\n    Fun f = Fun f'", "let ?m' = \"incl_of (cod f') ?b\""], ["proof (state)\ngoal (2 subgoals):\n 1. Fun f = Fun f' \\<Longrightarrow>\n    \\<exists>m m'.\n       incl m \\<and>\n       incl m' \\<and>\n       seq m f \\<and> seq m' f' \\<and> m \\<cdot> f = m' \\<cdot> f'\n 2. \\<exists>m m'.\n       incl m \\<and>\n       incl m' \\<and>\n       seq m f \\<and>\n       seq m' f' \\<and> m \\<cdot> f = m' \\<cdot> f' \\<Longrightarrow>\n    Fun f = Fun f'", "have 1: \"|Cod f \\<union> Cod f'| <o \\<AA>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |Cod f \\<union> Cod f'| <o \\<AA>", "using assms set_card cardinal card_order_infinite_isLimOrd"], ["proof (prove)\nusing this:\n  span f f'\n  ide ?a \\<Longrightarrow> |local.set ?a| <o \\<AA>\n  Card_order \\<AA> \\<and> infinite (Field \\<AA>)\n  \\<lbrakk>Card_order ?r; infinite (Field ?r)\\<rbrakk>\n  \\<Longrightarrow> isLimOrd ?r\n\ngoal (1 subgoal):\n 1. |Cod f \\<union> Cod f'| <o \\<AA>", "by simp"], ["proof (state)\nthis:\n  |Cod f \\<union> Cod f'| <o \\<AA>\n\ngoal (2 subgoals):\n 1. Fun f = Fun f' \\<Longrightarrow>\n    \\<exists>m m'.\n       incl m \\<and>\n       incl m' \\<and>\n       seq m f \\<and> seq m' f' \\<and> m \\<cdot> f = m' \\<cdot> f'\n 2. \\<exists>m m'.\n       incl m \\<and>\n       incl m' \\<and>\n       seq m f \\<and>\n       seq m' f' \\<and> m \\<cdot> f = m' \\<cdot> f' \\<Longrightarrow>\n    Fun f = Fun f'", "have incl_m: \"incl ?m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incl (incl_of (cod f) (mkIde (Cod f \\<union> Cod f')))", "using assms 1 incl_incl_of [of \"cod f\" ?b] incl_in_def ide_mkIde set_mkIde"], ["proof (prove)\nusing this:\n  span f f'\n  |Cod f \\<union> Cod f'| <o \\<AA>\n  incl_in (cod f) (mkIde (Cod f \\<union> Cod f')) \\<Longrightarrow>\n  incl (incl_of (cod f) (mkIde (Cod f \\<union> Cod f')))\n  incl_in (cod f) (mkIde (Cod f \\<union> Cod f')) \\<Longrightarrow>\n  \\<guillemotleft>incl_of (cod f)\n                   (mkIde\n                     (Cod f \\<union>\n                      Cod f')) : cod f \\<rightarrow> mkIde\n                (Cod f \\<union> Cod f')\\<guillemotright>\n  incl_in ?a ?b =\n  (ide ?a \\<and> ide ?b \\<and> local.set ?a \\<subseteq> local.set ?b)\n  \\<lbrakk>?A \\<subseteq> Univ; |?A| <o \\<AA>\\<rbrakk>\n  \\<Longrightarrow> ide (mkIde ?A)\n  \\<lbrakk>?A \\<subseteq> Univ; |?A| <o \\<AA>\\<rbrakk>\n  \\<Longrightarrow> local.set (mkIde ?A) = ?A\n\ngoal (1 subgoal):\n 1. incl (incl_of (cod f) (mkIde (Cod f \\<union> Cod f')))", "by simp"], ["proof (state)\nthis:\n  incl (incl_of (cod f) (mkIde (Cod f \\<union> Cod f')))\n\ngoal (2 subgoals):\n 1. Fun f = Fun f' \\<Longrightarrow>\n    \\<exists>m m'.\n       incl m \\<and>\n       incl m' \\<and>\n       seq m f \\<and> seq m' f' \\<and> m \\<cdot> f = m' \\<cdot> f'\n 2. \\<exists>m m'.\n       incl m \\<and>\n       incl m' \\<and>\n       seq m f \\<and>\n       seq m' f' \\<and> m \\<cdot> f = m' \\<cdot> f' \\<Longrightarrow>\n    Fun f = Fun f'", "have incl_m': \"incl ?m'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incl (incl_of (cod f') (mkIde (Cod f \\<union> Cod f')))", "using assms 1 incl_incl_of [of \"cod f'\" ?b] incl_in_def ide_mkIde set_mkIde"], ["proof (prove)\nusing this:\n  span f f'\n  |Cod f \\<union> Cod f'| <o \\<AA>\n  incl_in (cod f') (mkIde (Cod f \\<union> Cod f')) \\<Longrightarrow>\n  incl (incl_of (cod f') (mkIde (Cod f \\<union> Cod f')))\n  incl_in (cod f') (mkIde (Cod f \\<union> Cod f')) \\<Longrightarrow>\n  \\<guillemotleft>incl_of (cod f')\n                   (mkIde\n                     (Cod f \\<union>\n                      Cod f')) : cod f' \\<rightarrow> mkIde\n                 (Cod f \\<union> Cod f')\\<guillemotright>\n  incl_in ?a ?b =\n  (ide ?a \\<and> ide ?b \\<and> local.set ?a \\<subseteq> local.set ?b)\n  \\<lbrakk>?A \\<subseteq> Univ; |?A| <o \\<AA>\\<rbrakk>\n  \\<Longrightarrow> ide (mkIde ?A)\n  \\<lbrakk>?A \\<subseteq> Univ; |?A| <o \\<AA>\\<rbrakk>\n  \\<Longrightarrow> local.set (mkIde ?A) = ?A\n\ngoal (1 subgoal):\n 1. incl (incl_of (cod f') (mkIde (Cod f \\<union> Cod f')))", "by simp"], ["proof (state)\nthis:\n  incl (incl_of (cod f') (mkIde (Cod f \\<union> Cod f')))\n\ngoal (2 subgoals):\n 1. Fun f = Fun f' \\<Longrightarrow>\n    \\<exists>m m'.\n       incl m \\<and>\n       incl m' \\<and>\n       seq m f \\<and> seq m' f' \\<and> m \\<cdot> f = m' \\<cdot> f'\n 2. \\<exists>m m'.\n       incl m \\<and>\n       incl m' \\<and>\n       seq m f \\<and>\n       seq m' f' \\<and> m \\<cdot> f = m' \\<cdot> f' \\<Longrightarrow>\n    Fun f = Fun f'", "have m: \"?m = mkArr (Cod f) (Cod f \\<union> Cod f') (\\<lambda>x. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incl_of (cod f) (mkIde (Cod f \\<union> Cod f')) =\n    mkArr (Cod f) (Cod f \\<union> Cod f') (\\<lambda>x. x)", "by (simp add: assms 1 set_mkIde)"], ["proof (state)\nthis:\n  incl_of (cod f) (mkIde (Cod f \\<union> Cod f')) =\n  mkArr (Cod f) (Cod f \\<union> Cod f') (\\<lambda>x. x)\n\ngoal (2 subgoals):\n 1. Fun f = Fun f' \\<Longrightarrow>\n    \\<exists>m m'.\n       incl m \\<and>\n       incl m' \\<and>\n       seq m f \\<and> seq m' f' \\<and> m \\<cdot> f = m' \\<cdot> f'\n 2. \\<exists>m m'.\n       incl m \\<and>\n       incl m' \\<and>\n       seq m f \\<and>\n       seq m' f' \\<and> m \\<cdot> f = m' \\<cdot> f' \\<Longrightarrow>\n    Fun f = Fun f'", "have m': \"?m' = mkArr (Cod f') (Cod f \\<union> Cod f') (\\<lambda>x. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incl_of (cod f') (mkIde (Cod f \\<union> Cod f')) =\n    mkArr (Cod f') (Cod f \\<union> Cod f') (\\<lambda>x. x)", "by (simp add: assms 1 set_mkIde)"], ["proof (state)\nthis:\n  incl_of (cod f') (mkIde (Cod f \\<union> Cod f')) =\n  mkArr (Cod f') (Cod f \\<union> Cod f') (\\<lambda>x. x)\n\ngoal (2 subgoals):\n 1. Fun f = Fun f' \\<Longrightarrow>\n    \\<exists>m m'.\n       incl m \\<and>\n       incl m' \\<and>\n       seq m f \\<and> seq m' f' \\<and> m \\<cdot> f = m' \\<cdot> f'\n 2. \\<exists>m m'.\n       incl m \\<and>\n       incl m' \\<and>\n       seq m f \\<and>\n       seq m' f' \\<and> m \\<cdot> f = m' \\<cdot> f' \\<Longrightarrow>\n    Fun f = Fun f'", "have seq: \"seq ?m f \\<and> seq ?m' f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq (incl_of (cod f) (mkIde (Cod f \\<union> Cod f'))) f \\<and>\n    seq (incl_of (cod f') (mkIde (Cod f \\<union> Cod f'))) f'", "using assms m m'"], ["proof (prove)\nusing this:\n  span f f'\n  incl_of (cod f) (mkIde (Cod f \\<union> Cod f')) =\n  mkArr (Cod f) (Cod f \\<union> Cod f') (\\<lambda>x. x)\n  incl_of (cod f') (mkIde (Cod f \\<union> Cod f')) =\n  mkArr (Cod f') (Cod f \\<union> Cod f') (\\<lambda>x. x)\n\ngoal (1 subgoal):\n 1. seq (incl_of (cod f) (mkIde (Cod f \\<union> Cod f'))) f \\<and>\n    seq (incl_of (cod f') (mkIde (Cod f \\<union> Cod f'))) f'", "by (metis ide_cod incl_m incl_m' mkIde_set seqI incl_def dom_mkArr)"], ["proof (state)\nthis:\n  seq (incl_of (cod f) (mkIde (Cod f \\<union> Cod f'))) f \\<and>\n  seq (incl_of (cod f') (mkIde (Cod f \\<union> Cod f'))) f'\n\ngoal (2 subgoals):\n 1. Fun f = Fun f' \\<Longrightarrow>\n    \\<exists>m m'.\n       incl m \\<and>\n       incl m' \\<and>\n       seq m f \\<and> seq m' f' \\<and> m \\<cdot> f = m' \\<cdot> f'\n 2. \\<exists>m m'.\n       incl m \\<and>\n       incl m' \\<and>\n       seq m f \\<and>\n       seq m' f' \\<and> m \\<cdot> f = m' \\<cdot> f' \\<Longrightarrow>\n    Fun f = Fun f'", "have \"?m \\<cdot> f = ?m' \\<cdot> f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incl_of (cod f) (mkIde (Cod f \\<union> Cod f')) \\<cdot> f =\n    incl_of (cod f') (mkIde (Cod f \\<union> Cod f')) \\<cdot> f'", "proof (intro arr_eqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. par (incl_of (cod f) (mkIde (Cod f \\<union> Cod f')) \\<cdot> f)\n     (incl_of (cod f') (mkIde (Cod f \\<union> Cod f')) \\<cdot> f')\n 2. Fun (incl_of (cod f) (mkIde (Cod f \\<union> Cod f')) \\<cdot> f) =\n    Fun (incl_of (cod f') (mkIde (Cod f \\<union> Cod f')) \\<cdot> f')", "show par: \"par (?m \\<cdot> f) (?m' \\<cdot> f')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. par (incl_of (cod f) (mkIde (Cod f \\<union> Cod f')) \\<cdot> f)\n     (incl_of (cod f') (mkIde (Cod f \\<union> Cod f')) \\<cdot> f')", "using assms m m'"], ["proof (prove)\nusing this:\n  span f f'\n  incl_of (cod f) (mkIde (Cod f \\<union> Cod f')) =\n  mkArr (Cod f) (Cod f \\<union> Cod f') (\\<lambda>x. x)\n  incl_of (cod f') (mkIde (Cod f \\<union> Cod f')) =\n  mkArr (Cod f') (Cod f \\<union> Cod f') (\\<lambda>x. x)\n\ngoal (1 subgoal):\n 1. par (incl_of (cod f) (mkIde (Cod f \\<union> Cod f')) \\<cdot> f)\n     (incl_of (cod f') (mkIde (Cod f \\<union> Cod f')) \\<cdot> f')", "by (metis cod_comp cod_mkArr dom_comp seq seqE)"], ["proof (state)\nthis:\n  par (incl_of (cod f) (mkIde (Cod f \\<union> Cod f')) \\<cdot> f)\n   (incl_of (cod f') (mkIde (Cod f \\<union> Cod f')) \\<cdot> f')\n\ngoal (1 subgoal):\n 1. Fun (incl_of (cod f) (mkIde (Cod f \\<union> Cod f')) \\<cdot> f) =\n    Fun (incl_of (cod f') (mkIde (Cod f \\<union> Cod f')) \\<cdot> f')", "show \"Fun (?m \\<cdot> f) = Fun (?m' \\<cdot> f')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (incl_of (cod f) (mkIde (Cod f \\<union> Cod f')) \\<cdot> f) =\n    Fun (incl_of (cod f') (mkIde (Cod f \\<union> Cod f')) \\<cdot> f')", "using assms ff'"], ["proof (prove)\nusing this:\n  span f f'\n  Fun f = Fun f'\n\ngoal (1 subgoal):\n 1. Fun (incl_of (cod f) (mkIde (Cod f \\<union> Cod f')) \\<cdot> f) =\n    Fun (incl_of (cod f') (mkIde (Cod f \\<union> Cod f')) \\<cdot> f')", "by (metis incl_m incl_m' comp_mkArr incl_def mkArr_Fun)"], ["proof (state)\nthis:\n  Fun (incl_of (cod f) (mkIde (Cod f \\<union> Cod f')) \\<cdot> f) =\n  Fun (incl_of (cod f') (mkIde (Cod f \\<union> Cod f')) \\<cdot> f')\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  incl_of (cod f) (mkIde (Cod f \\<union> Cod f')) \\<cdot> f =\n  incl_of (cod f') (mkIde (Cod f \\<union> Cod f')) \\<cdot> f'\n\ngoal (2 subgoals):\n 1. Fun f = Fun f' \\<Longrightarrow>\n    \\<exists>m m'.\n       incl m \\<and>\n       incl m' \\<and>\n       seq m f \\<and> seq m' f' \\<and> m \\<cdot> f = m' \\<cdot> f'\n 2. \\<exists>m m'.\n       incl m \\<and>\n       incl m' \\<and>\n       seq m f \\<and>\n       seq m' f' \\<and> m \\<cdot> f = m' \\<cdot> f' \\<Longrightarrow>\n    Fun f = Fun f'", "hence \"incl ?m \\<and> incl ?m' \\<and> seq ?m f \\<and> seq ?m' f' \\<and> ?m \\<cdot> f = ?m' \\<cdot> f'\""], ["proof (prove)\nusing this:\n  incl_of (cod f) (mkIde (Cod f \\<union> Cod f')) \\<cdot> f =\n  incl_of (cod f') (mkIde (Cod f \\<union> Cod f')) \\<cdot> f'\n\ngoal (1 subgoal):\n 1. incl (incl_of (cod f) (mkIde (Cod f \\<union> Cod f'))) \\<and>\n    incl (incl_of (cod f') (mkIde (Cod f \\<union> Cod f'))) \\<and>\n    seq (incl_of (cod f) (mkIde (Cod f \\<union> Cod f'))) f \\<and>\n    seq (incl_of (cod f') (mkIde (Cod f \\<union> Cod f'))) f' \\<and>\n    incl_of (cod f) (mkIde (Cod f \\<union> Cod f')) \\<cdot> f =\n    incl_of (cod f') (mkIde (Cod f \\<union> Cod f')) \\<cdot> f'", "using seq \\<open>incl ?m\\<close> \\<open>incl ?m'\\<close>"], ["proof (prove)\nusing this:\n  incl_of (cod f) (mkIde (Cod f \\<union> Cod f')) \\<cdot> f =\n  incl_of (cod f') (mkIde (Cod f \\<union> Cod f')) \\<cdot> f'\n  seq (incl_of (cod f) (mkIde (Cod f \\<union> Cod f'))) f \\<and>\n  seq (incl_of (cod f') (mkIde (Cod f \\<union> Cod f'))) f'\n  incl (incl_of (cod f) (mkIde (Cod f \\<union> Cod f')))\n  incl (incl_of (cod f') (mkIde (Cod f \\<union> Cod f')))\n\ngoal (1 subgoal):\n 1. incl (incl_of (cod f) (mkIde (Cod f \\<union> Cod f'))) \\<and>\n    incl (incl_of (cod f') (mkIde (Cod f \\<union> Cod f'))) \\<and>\n    seq (incl_of (cod f) (mkIde (Cod f \\<union> Cod f'))) f \\<and>\n    seq (incl_of (cod f') (mkIde (Cod f \\<union> Cod f'))) f' \\<and>\n    incl_of (cod f) (mkIde (Cod f \\<union> Cod f')) \\<cdot> f =\n    incl_of (cod f') (mkIde (Cod f \\<union> Cod f')) \\<cdot> f'", "by simp"], ["proof (state)\nthis:\n  incl (incl_of (cod f) (mkIde (Cod f \\<union> Cod f'))) \\<and>\n  incl (incl_of (cod f') (mkIde (Cod f \\<union> Cod f'))) \\<and>\n  seq (incl_of (cod f) (mkIde (Cod f \\<union> Cod f'))) f \\<and>\n  seq (incl_of (cod f') (mkIde (Cod f \\<union> Cod f'))) f' \\<and>\n  incl_of (cod f) (mkIde (Cod f \\<union> Cod f')) \\<cdot> f =\n  incl_of (cod f') (mkIde (Cod f \\<union> Cod f')) \\<cdot> f'\n\ngoal (2 subgoals):\n 1. Fun f = Fun f' \\<Longrightarrow>\n    \\<exists>m m'.\n       incl m \\<and>\n       incl m' \\<and>\n       seq m f \\<and> seq m' f' \\<and> m \\<cdot> f = m' \\<cdot> f'\n 2. \\<exists>m m'.\n       incl m \\<and>\n       incl m' \\<and>\n       seq m f \\<and>\n       seq m' f' \\<and> m \\<cdot> f = m' \\<cdot> f' \\<Longrightarrow>\n    Fun f = Fun f'", "thus \"\\<exists>m m'. incl m \\<and> incl m' \\<and> seq m f \\<and> seq m' f' \\<and> m \\<cdot> f = m' \\<cdot> f'\""], ["proof (prove)\nusing this:\n  incl (incl_of (cod f) (mkIde (Cod f \\<union> Cod f'))) \\<and>\n  incl (incl_of (cod f') (mkIde (Cod f \\<union> Cod f'))) \\<and>\n  seq (incl_of (cod f) (mkIde (Cod f \\<union> Cod f'))) f \\<and>\n  seq (incl_of (cod f') (mkIde (Cod f \\<union> Cod f'))) f' \\<and>\n  incl_of (cod f) (mkIde (Cod f \\<union> Cod f')) \\<cdot> f =\n  incl_of (cod f') (mkIde (Cod f \\<union> Cod f')) \\<cdot> f'\n\ngoal (1 subgoal):\n 1. \\<exists>m m'.\n       incl m \\<and>\n       incl m' \\<and>\n       seq m f \\<and> seq m' f' \\<and> m \\<cdot> f = m' \\<cdot> f'", "by auto"], ["proof (state)\nthis:\n  \\<exists>m m'.\n     incl m \\<and>\n     incl m' \\<and>\n     seq m f \\<and> seq m' f' \\<and> m \\<cdot> f = m' \\<cdot> f'\n\ngoal (1 subgoal):\n 1. \\<exists>m m'.\n       incl m \\<and>\n       incl m' \\<and>\n       seq m f \\<and>\n       seq m' f' \\<and> m \\<cdot> f = m' \\<cdot> f' \\<Longrightarrow>\n    Fun f = Fun f'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>m m'.\n       incl m \\<and>\n       incl m' \\<and>\n       seq m f \\<and>\n       seq m' f' \\<and> m \\<cdot> f = m' \\<cdot> f' \\<Longrightarrow>\n    Fun f = Fun f'", "assume ff': \"\\<exists>m m'. incl m \\<and> incl m' \\<and> seq m f \\<and> seq m' f' \\<and> m \\<cdot> f = m' \\<cdot> f'\""], ["proof (state)\nthis:\n  \\<exists>m m'.\n     incl m \\<and>\n     incl m' \\<and>\n     seq m f \\<and> seq m' f' \\<and> m \\<cdot> f = m' \\<cdot> f'\n\ngoal (1 subgoal):\n 1. \\<exists>m m'.\n       incl m \\<and>\n       incl m' \\<and>\n       seq m f \\<and>\n       seq m' f' \\<and> m \\<cdot> f = m' \\<cdot> f' \\<Longrightarrow>\n    Fun f = Fun f'", "show \"Fun f = Fun f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun f = Fun f'", "using ff'"], ["proof (prove)\nusing this:\n  \\<exists>m m'.\n     incl m \\<and>\n     incl m' \\<and>\n     seq m f \\<and> seq m' f' \\<and> m \\<cdot> f = m' \\<cdot> f'\n\ngoal (1 subgoal):\n 1. Fun f = Fun f'", "by (metis Fun_comp Fun_ide comp_cod_arr ide_cod seqE Fun_incl)"], ["proof (state)\nthis:\n  Fun f = Fun f'\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n      Another answer to the same question: two arrows with a common domain determine the\n      same function if and only if their corestrictions are equal.\n\\<close>"], ["", "lemma eq_Fun_iff_eq_corestr:\n    assumes \"span f f'\"\n    shows \"Fun f = Fun f' \\<longleftrightarrow> corestr f = corestr f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Fun f = Fun f') = (corestr f = corestr f')", "using assms corestr_def Fun_corestr"], ["proof (prove)\nusing this:\n  span f f'\n  corestr ?f = mkArr (Dom ?f) (Img ?f) (Fun ?f)\n  arr ?f \\<Longrightarrow> Fun (corestr ?f) = Fun ?f\n\ngoal (1 subgoal):\n 1. (Fun f = Fun f') = (corestr f = corestr f')", "by metis"], ["", "subsection \"Retractions, Sections, and Isomorphisms\""], ["", "text\\<open>\n      An arrow is a retraction if and only if its image coincides with its codomain.\n\\<close>"], ["", "lemma retraction_if_Img_eq_Cod:\n    assumes \"arr g\" and \"Img g = Cod g\"\n    shows \"retraction g\"\n    and \"ide (g \\<cdot> mkArr (Cod g) (Dom g) (inv_into (Dom g) (Fun g)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. retraction g &&&\n    ide (g \\<cdot> mkArr (Cod g) (Dom g) (inv_into (Dom g) (Fun g)))", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. retraction g\n 2. ide (g \\<cdot> mkArr (Cod g) (Dom g) (inv_into (Dom g) (Fun g)))", "let ?F = \"inv_into (Dom g) (Fun g)\""], ["proof (state)\ngoal (2 subgoals):\n 1. retraction g\n 2. ide (g \\<cdot> mkArr (Cod g) (Dom g) (inv_into (Dom g) (Fun g)))", "let ?f = \"mkArr (Cod g) (Dom g) ?F\""], ["proof (state)\ngoal (2 subgoals):\n 1. retraction g\n 2. ide (g \\<cdot> mkArr (Cod g) (Dom g) (inv_into (Dom g) (Fun g)))", "have f: \"arr ?f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (mkArr (Cod g) (Dom g) (inv_into (Dom g) (Fun g)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. arr (mkArr (Cod g) (Dom g) (inv_into (Dom g) (Fun g)))", "have \"Cod g \\<subseteq> Univ \\<and> Dom g \\<subseteq> Univ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cod g \\<subseteq> Univ \\<and> Dom g \\<subseteq> Univ", "using assms"], ["proof (prove)\nusing this:\n  arr g\n  Img g = Cod g\n\ngoal (1 subgoal):\n 1. Cod g \\<subseteq> Univ \\<and> Dom g \\<subseteq> Univ", "by auto"], ["proof (state)\nthis:\n  Cod g \\<subseteq> Univ \\<and> Dom g \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. arr (mkArr (Cod g) (Dom g) (inv_into (Dom g) (Fun g)))", "moreover"], ["proof (state)\nthis:\n  Cod g \\<subseteq> Univ \\<and> Dom g \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. arr (mkArr (Cod g) (Dom g) (inv_into (Dom g) (Fun g)))", "have \"|Cod g| <o \\<AA> \\<and> |Dom g| <o \\<AA>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |Cod g| <o \\<AA> \\<and> |Dom g| <o \\<AA>", "using assms"], ["proof (prove)\nusing this:\n  arr g\n  Img g = Cod g\n\ngoal (1 subgoal):\n 1. |Cod g| <o \\<AA> \\<and> |Dom g| <o \\<AA>", "by (simp add: set_card)"], ["proof (state)\nthis:\n  |Cod g| <o \\<AA> \\<and> |Dom g| <o \\<AA>\n\ngoal (1 subgoal):\n 1. arr (mkArr (Cod g) (Dom g) (inv_into (Dom g) (Fun g)))", "moreover"], ["proof (state)\nthis:\n  |Cod g| <o \\<AA> \\<and> |Dom g| <o \\<AA>\n\ngoal (1 subgoal):\n 1. arr (mkArr (Cod g) (Dom g) (inv_into (Dom g) (Fun g)))", "have \"?F \\<in> Cod g \\<rightarrow> Dom g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inv_into (Dom g) (Fun g) \\<in> Cod g \\<rightarrow> Dom g", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Cod g \\<Longrightarrow>\n       inv_into (Dom g) (Fun g) x \\<in> Dom g", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Cod g \\<Longrightarrow>\n       inv_into (Dom g) (Fun g) x \\<in> Dom g", "assume y: \"y \\<in> Cod g\""], ["proof (state)\nthis:\n  y \\<in> Cod g\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Cod g \\<Longrightarrow>\n       inv_into (Dom g) (Fun g) x \\<in> Dom g", "let ?P = \"\\<lambda>x. x \\<in> Dom g \\<and> Fun g x = y\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Cod g \\<Longrightarrow>\n       inv_into (Dom g) (Fun g) x \\<in> Dom g", "have \"\\<exists>x. ?P x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> Dom g \\<and> Fun g x = y", "using y assms"], ["proof (prove)\nusing this:\n  y \\<in> Cod g\n  arr g\n  Img g = Cod g\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> Dom g \\<and> Fun g x = y", "by force"], ["proof (state)\nthis:\n  \\<exists>x. x \\<in> Dom g \\<and> Fun g x = y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Cod g \\<Longrightarrow>\n       inv_into (Dom g) (Fun g) x \\<in> Dom g", "hence \"?P (SOME x. ?P x)\""], ["proof (prove)\nusing this:\n  \\<exists>x. x \\<in> Dom g \\<and> Fun g x = y\n\ngoal (1 subgoal):\n 1. (SOME x. x \\<in> Dom g \\<and> Fun g x = y) \\<in> Dom g \\<and>\n    Fun g (SOME x. x \\<in> Dom g \\<and> Fun g x = y) = y", "using someI_ex [of ?P]"], ["proof (prove)\nusing this:\n  \\<exists>x. x \\<in> Dom g \\<and> Fun g x = y\n  \\<exists>x. x \\<in> Dom g \\<and> Fun g x = y \\<Longrightarrow>\n  (SOME x. x \\<in> Dom g \\<and> Fun g x = y) \\<in> Dom g \\<and>\n  Fun g (SOME x. x \\<in> Dom g \\<and> Fun g x = y) = y\n\ngoal (1 subgoal):\n 1. (SOME x. x \\<in> Dom g \\<and> Fun g x = y) \\<in> Dom g \\<and>\n    Fun g (SOME x. x \\<in> Dom g \\<and> Fun g x = y) = y", "by fast"], ["proof (state)\nthis:\n  (SOME x. x \\<in> Dom g \\<and> Fun g x = y) \\<in> Dom g \\<and>\n  Fun g (SOME x. x \\<in> Dom g \\<and> Fun g x = y) = y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Cod g \\<Longrightarrow>\n       inv_into (Dom g) (Fun g) x \\<in> Dom g", "hence \"?P (?F y)\""], ["proof (prove)\nusing this:\n  (SOME x. x \\<in> Dom g \\<and> Fun g x = y) \\<in> Dom g \\<and>\n  Fun g (SOME x. x \\<in> Dom g \\<and> Fun g x = y) = y\n\ngoal (1 subgoal):\n 1. inv_into (Dom g) (Fun g) y \\<in> Dom g \\<and>\n    Fun g (inv_into (Dom g) (Fun g) y) = y", "using Hilbert_Choice.inv_into_def"], ["proof (prove)\nusing this:\n  (SOME x. x \\<in> Dom g \\<and> Fun g x = y) \\<in> Dom g \\<and>\n  Fun g (SOME x. x \\<in> Dom g \\<and> Fun g x = y) = y\n  inv_into ?A ?f = (\\<lambda>x. SOME y. y \\<in> ?A \\<and> ?f y = x)\n\ngoal (1 subgoal):\n 1. inv_into (Dom g) (Fun g) y \\<in> Dom g \\<and>\n    Fun g (inv_into (Dom g) (Fun g) y) = y", "by metis"], ["proof (state)\nthis:\n  inv_into (Dom g) (Fun g) y \\<in> Dom g \\<and>\n  Fun g (inv_into (Dom g) (Fun g) y) = y\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Cod g \\<Longrightarrow>\n       inv_into (Dom g) (Fun g) x \\<in> Dom g", "thus \"?F y \\<in> Dom g\""], ["proof (prove)\nusing this:\n  inv_into (Dom g) (Fun g) y \\<in> Dom g \\<and>\n  Fun g (inv_into (Dom g) (Fun g) y) = y\n\ngoal (1 subgoal):\n 1. inv_into (Dom g) (Fun g) y \\<in> Dom g", "by auto"], ["proof (state)\nthis:\n  inv_into (Dom g) (Fun g) y \\<in> Dom g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inv_into (Dom g) (Fun g) \\<in> Cod g \\<rightarrow> Dom g\n\ngoal (1 subgoal):\n 1. arr (mkArr (Cod g) (Dom g) (inv_into (Dom g) (Fun g)))", "ultimately"], ["proof (chain)\npicking this:\n  Cod g \\<subseteq> Univ \\<and> Dom g \\<subseteq> Univ\n  |Cod g| <o \\<AA> \\<and> |Dom g| <o \\<AA>\n  inv_into (Dom g) (Fun g) \\<in> Cod g \\<rightarrow> Dom g", "show ?thesis"], ["proof (prove)\nusing this:\n  Cod g \\<subseteq> Univ \\<and> Dom g \\<subseteq> Univ\n  |Cod g| <o \\<AA> \\<and> |Dom g| <o \\<AA>\n  inv_into (Dom g) (Fun g) \\<in> Cod g \\<rightarrow> Dom g\n\ngoal (1 subgoal):\n 1. arr (mkArr (Cod g) (Dom g) (inv_into (Dom g) (Fun g)))", "using arr_mkArr"], ["proof (prove)\nusing this:\n  Cod g \\<subseteq> Univ \\<and> Dom g \\<subseteq> Univ\n  |Cod g| <o \\<AA> \\<and> |Dom g| <o \\<AA>\n  inv_into (Dom g) (Fun g) \\<in> Cod g \\<rightarrow> Dom g\n  arr (mkArr ?A ?B ?F) =\n  (?A \\<subseteq> Univ \\<and>\n   |?A| <o \\<AA> \\<and>\n   ?B \\<subseteq> Univ \\<and>\n   |?B| <o \\<AA> \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n\ngoal (1 subgoal):\n 1. arr (mkArr (Cod g) (Dom g) (inv_into (Dom g) (Fun g)))", "by auto"], ["proof (state)\nthis:\n  arr (mkArr (Cod g) (Dom g) (inv_into (Dom g) (Fun g)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  arr (mkArr (Cod g) (Dom g) (inv_into (Dom g) (Fun g)))\n\ngoal (2 subgoals):\n 1. retraction g\n 2. ide (g \\<cdot> mkArr (Cod g) (Dom g) (inv_into (Dom g) (Fun g)))", "show \"ide (g \\<cdot> ?f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide (g \\<cdot> mkArr (Cod g) (Dom g) (inv_into (Dom g) (Fun g)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ide (g \\<cdot> mkArr (Cod g) (Dom g) (inv_into (Dom g) (Fun g)))", "have \"g = mkArr (Dom g) (Cod g) (Fun g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g = mkArr (Dom g) (Cod g) (Fun g)", "using assms mkArr_Fun"], ["proof (prove)\nusing this:\n  arr g\n  Img g = Cod g\n  arr ?f \\<Longrightarrow> mkArr (Dom ?f) (Cod ?f) (Fun ?f) = ?f\n\ngoal (1 subgoal):\n 1. g = mkArr (Dom g) (Cod g) (Fun g)", "by auto"], ["proof (state)\nthis:\n  g = mkArr (Dom g) (Cod g) (Fun g)\n\ngoal (1 subgoal):\n 1. ide (g \\<cdot> mkArr (Cod g) (Dom g) (inv_into (Dom g) (Fun g)))", "hence \"g \\<cdot> ?f = mkArr (Cod g) (Cod g) (Fun g o ?F)\""], ["proof (prove)\nusing this:\n  g = mkArr (Dom g) (Cod g) (Fun g)\n\ngoal (1 subgoal):\n 1. g \\<cdot> mkArr (Cod g) (Dom g) (inv_into (Dom g) (Fun g)) =\n    mkArr (Cod g) (Cod g) (Fun g \\<circ> inv_into (Dom g) (Fun g))", "using assms(1) f comp_mkArr"], ["proof (prove)\nusing this:\n  g = mkArr (Dom g) (Cod g) (Fun g)\n  arr g\n  arr (mkArr (Cod g) (Dom g) (inv_into (Dom g) (Fun g)))\n  \\<lbrakk>arr (mkArr ?A ?B ?F); arr (mkArr ?B ?C ?G)\\<rbrakk>\n  \\<Longrightarrow> mkArr ?B ?C ?G \\<cdot> mkArr ?A ?B ?F =\n                    mkArr ?A ?C (?G \\<circ> ?F)\n\ngoal (1 subgoal):\n 1. g \\<cdot> mkArr (Cod g) (Dom g) (inv_into (Dom g) (Fun g)) =\n    mkArr (Cod g) (Cod g) (Fun g \\<circ> inv_into (Dom g) (Fun g))", "by metis"], ["proof (state)\nthis:\n  g \\<cdot> mkArr (Cod g) (Dom g) (inv_into (Dom g) (Fun g)) =\n  mkArr (Cod g) (Cod g) (Fun g \\<circ> inv_into (Dom g) (Fun g))\n\ngoal (1 subgoal):\n 1. ide (g \\<cdot> mkArr (Cod g) (Dom g) (inv_into (Dom g) (Fun g)))", "moreover"], ["proof (state)\nthis:\n  g \\<cdot> mkArr (Cod g) (Dom g) (inv_into (Dom g) (Fun g)) =\n  mkArr (Cod g) (Cod g) (Fun g \\<circ> inv_into (Dom g) (Fun g))\n\ngoal (1 subgoal):\n 1. ide (g \\<cdot> mkArr (Cod g) (Dom g) (inv_into (Dom g) (Fun g)))", "have \"mkArr (Cod g) (Cod g) (\\<lambda>y. y) = ...\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incl_of (cod g) (cod g) =\n    mkArr (Cod g) (Cod g) (Fun g \\<circ> inv_into (Dom g) (Fun g))", "proof (intro mkArr_eqI')"], ["proof (state)\ngoal (2 subgoals):\n 1. arr (incl_of (cod g) (cod g))\n 2. \\<And>x.\n       x \\<in> Cod g \\<Longrightarrow>\n       x = (Fun g \\<circ> inv_into (Dom g) (Fun g)) x", "show \"arr (mkArr (Cod g) (Cod g) (\\<lambda>y. y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (incl_of (cod g) (cod g))", "using assms arr_cod_iff_arr set_card arr_mkArr"], ["proof (prove)\nusing this:\n  arr g\n  Img g = Cod g\n  arr (cod ?f) = arr ?f\n  ide ?a \\<Longrightarrow> |local.set ?a| <o \\<AA>\n  arr (mkArr ?A ?B ?F) =\n  (?A \\<subseteq> Univ \\<and>\n   |?A| <o \\<AA> \\<and>\n   ?B \\<subseteq> Univ \\<and>\n   |?B| <o \\<AA> \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n\ngoal (1 subgoal):\n 1. arr (incl_of (cod g) (cod g))", "by auto"], ["proof (state)\nthis:\n  arr (incl_of (cod g) (cod g))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Cod g \\<Longrightarrow>\n       x = (Fun g \\<circ> inv_into (Dom g) (Fun g)) x", "show \"\\<And>y. y \\<in> Cod g \\<Longrightarrow> y = (Fun g o ?F) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> Cod g \\<Longrightarrow>\n       y = (Fun g \\<circ> inv_into (Dom g) (Fun g)) y", "using assms"], ["proof (prove)\nusing this:\n  arr g\n  Img g = Cod g\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> Cod g \\<Longrightarrow>\n       y = (Fun g \\<circ> inv_into (Dom g) (Fun g)) y", "by (simp add: f_inv_into_f)"], ["proof (state)\nthis:\n  ?y \\<in> Cod g \\<Longrightarrow>\n  ?y = (Fun g \\<circ> inv_into (Dom g) (Fun g)) ?y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  incl_of (cod g) (cod g) =\n  mkArr (Cod g) (Cod g) (Fun g \\<circ> inv_into (Dom g) (Fun g))\n\ngoal (1 subgoal):\n 1. ide (g \\<cdot> mkArr (Cod g) (Dom g) (inv_into (Dom g) (Fun g)))", "ultimately"], ["proof (chain)\npicking this:\n  g \\<cdot> mkArr (Cod g) (Dom g) (inv_into (Dom g) (Fun g)) =\n  mkArr (Cod g) (Cod g) (Fun g \\<circ> inv_into (Dom g) (Fun g))\n  incl_of (cod g) (cod g) =\n  mkArr (Cod g) (Cod g) (Fun g \\<circ> inv_into (Dom g) (Fun g))", "show ?thesis"], ["proof (prove)\nusing this:\n  g \\<cdot> mkArr (Cod g) (Dom g) (inv_into (Dom g) (Fun g)) =\n  mkArr (Cod g) (Cod g) (Fun g \\<circ> inv_into (Dom g) (Fun g))\n  incl_of (cod g) (cod g) =\n  mkArr (Cod g) (Cod g) (Fun g \\<circ> inv_into (Dom g) (Fun g))\n\ngoal (1 subgoal):\n 1. ide (g \\<cdot> mkArr (Cod g) (Dom g) (inv_into (Dom g) (Fun g)))", "using assms f mkIde_as_mkArr arr_mkArr mkIde_set"], ["proof (prove)\nusing this:\n  g \\<cdot> mkArr (Cod g) (Dom g) (inv_into (Dom g) (Fun g)) =\n  mkArr (Cod g) (Cod g) (Fun g \\<circ> inv_into (Dom g) (Fun g))\n  incl_of (cod g) (cod g) =\n  mkArr (Cod g) (Cod g) (Fun g \\<circ> inv_into (Dom g) (Fun g))\n  arr g\n  Img g = Cod g\n  arr (mkArr (Cod g) (Dom g) (inv_into (Dom g) (Fun g)))\n  \\<lbrakk>?A \\<subseteq> Univ; |?A| <o \\<AA>\\<rbrakk>\n  \\<Longrightarrow> mkArr ?A ?A (\\<lambda>x. x) = mkIde ?A\n  arr (mkArr ?A ?B ?F) =\n  (?A \\<subseteq> Univ \\<and>\n   |?A| <o \\<AA> \\<and>\n   ?B \\<subseteq> Univ \\<and>\n   |?B| <o \\<AA> \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n  ide ?a \\<Longrightarrow> mkIde (local.set ?a) = ?a\n\ngoal (1 subgoal):\n 1. ide (g \\<cdot> mkArr (Cod g) (Dom g) (inv_into (Dom g) (Fun g)))", "by auto"], ["proof (state)\nthis:\n  ide (g \\<cdot> mkArr (Cod g) (Dom g) (inv_into (Dom g) (Fun g)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ide (g \\<cdot> mkArr (Cod g) (Dom g) (inv_into (Dom g) (Fun g)))\n\ngoal (1 subgoal):\n 1. retraction g", "thus \"retraction g\""], ["proof (prove)\nusing this:\n  ide (g \\<cdot> mkArr (Cod g) (Dom g) (inv_into (Dom g) (Fun g)))\n\ngoal (1 subgoal):\n 1. retraction g", "by auto"], ["proof (state)\nthis:\n  retraction g\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma retraction_char:\n    shows \"retraction g \\<longleftrightarrow> arr g \\<and> Img g = Cod g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. retraction g = (arr g \\<and> Img g = Cod g)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. retraction g \\<Longrightarrow> arr g \\<and> Img g = Cod g\n 2. arr g \\<and> Img g = Cod g \\<Longrightarrow> retraction g", "assume G: \"retraction g\""], ["proof (state)\nthis:\n  retraction g\n\ngoal (2 subgoals):\n 1. retraction g \\<Longrightarrow> arr g \\<and> Img g = Cod g\n 2. arr g \\<and> Img g = Cod g \\<Longrightarrow> retraction g", "show \"arr g \\<and> Img g = Cod g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr g \\<and> Img g = Cod g", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. arr g\n 2. Img g = Cod g", "show \"arr g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr g", "using G"], ["proof (prove)\nusing this:\n  retraction g\n\ngoal (1 subgoal):\n 1. arr g", "by blast"], ["proof (state)\nthis:\n  arr g\n\ngoal (1 subgoal):\n 1. Img g = Cod g", "show \"Img g = Cod g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Img g = Cod g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Img g = Cod g", "from G"], ["proof (chain)\npicking this:\n  retraction g", "obtain f where f: \"ide (g \\<cdot> f)\""], ["proof (prove)\nusing this:\n  retraction g\n\ngoal (1 subgoal):\n 1. (\\<And>f. ide (g \\<cdot> f) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ide (g \\<cdot> f)\n\ngoal (1 subgoal):\n 1. Img g = Cod g", "have \"restrict (Fun g o Fun f) (Cod g) = restrict (\\<lambda>x. x) (Cod g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict (Fun g \\<circ> Fun f) (Cod g) = (\\<lambda>x\\<in>Cod g. x)", "using f Fun_comp Fun_ide ide_compE"], ["proof (prove)\nusing this:\n  ide (g \\<cdot> f)\n  seq ?g ?f \\<Longrightarrow>\n  Fun (?g \\<cdot> ?f) = restrict (Fun ?g \\<circ> Fun ?f) (Dom ?f)\n  ide ?a \\<Longrightarrow> Fun ?a = (\\<lambda>x\\<in>local.set ?a. x)\n  \\<lbrakk>ide (?g \\<cdot> ?f);\n   \\<lbrakk>seq ?g ?f; seq ?f ?g; ?g \\<cdot> ?f = local.dom ?f;\n    ?g \\<cdot> ?f = cod ?g\\<rbrakk>\n   \\<Longrightarrow> ?T\\<rbrakk>\n  \\<Longrightarrow> ?T\n\ngoal (1 subgoal):\n 1. restrict (Fun g \\<circ> Fun f) (Cod g) = (\\<lambda>x\\<in>Cod g. x)", "by metis"], ["proof (state)\nthis:\n  restrict (Fun g \\<circ> Fun f) (Cod g) = (\\<lambda>x\\<in>Cod g. x)\n\ngoal (1 subgoal):\n 1. Img g = Cod g", "hence \"Fun g ` Fun f ` Cod g = Cod g\""], ["proof (prove)\nusing this:\n  restrict (Fun g \\<circ> Fun f) (Cod g) = (\\<lambda>x\\<in>Cod g. x)\n\ngoal (1 subgoal):\n 1. Fun g ` Fun f ` Cod g = Cod g", "by (metis image_comp image_ident image_restrict_eq)"], ["proof (state)\nthis:\n  Fun g ` Fun f ` Cod g = Cod g\n\ngoal (1 subgoal):\n 1. Img g = Cod g", "moreover"], ["proof (state)\nthis:\n  Fun g ` Fun f ` Cod g = Cod g\n\ngoal (1 subgoal):\n 1. Img g = Cod g", "have \"Fun f ` Cod g \\<subseteq> Dom g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun f ` Cod g \\<subseteq> Dom g", "using f Fun_mapsto arr_mkArr mkArr_Fun funcset_image"], ["proof (prove)\nusing this:\n  ide (g \\<cdot> f)\n  arr ?f \\<Longrightarrow>\n  Fun ?f \\<in> extensional (Dom ?f) \\<inter> (Dom ?f \\<rightarrow> Cod ?f)\n  arr (mkArr ?A ?B ?F) =\n  (?A \\<subseteq> Univ \\<and>\n   |?A| <o \\<AA> \\<and>\n   ?B \\<subseteq> Univ \\<and>\n   |?B| <o \\<AA> \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n  arr ?f \\<Longrightarrow> mkArr (Dom ?f) (Cod ?f) (Fun ?f) = ?f\n  ?f \\<in> ?A \\<rightarrow> ?B \\<Longrightarrow> ?f ` ?A \\<subseteq> ?B\n\ngoal (1 subgoal):\n 1. Fun f ` Cod g \\<subseteq> Dom g", "by (metis seqE ide_compE ide_compE)"], ["proof (state)\nthis:\n  Fun f ` Cod g \\<subseteq> Dom g\n\ngoal (1 subgoal):\n 1. Img g = Cod g", "moreover"], ["proof (state)\nthis:\n  Fun f ` Cod g \\<subseteq> Dom g\n\ngoal (1 subgoal):\n 1. Img g = Cod g", "have \"Img g \\<subseteq> Cod g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Img g \\<subseteq> Cod g", "using f Fun_mapsto"], ["proof (prove)\nusing this:\n  ide (g \\<cdot> f)\n  arr ?f \\<Longrightarrow>\n  Fun ?f \\<in> extensional (Dom ?f) \\<inter> (Dom ?f \\<rightarrow> Cod ?f)\n\ngoal (1 subgoal):\n 1. Img g \\<subseteq> Cod g", "by blast"], ["proof (state)\nthis:\n  Img g \\<subseteq> Cod g\n\ngoal (1 subgoal):\n 1. Img g = Cod g", "ultimately"], ["proof (chain)\npicking this:\n  Fun g ` Fun f ` Cod g = Cod g\n  Fun f ` Cod g \\<subseteq> Dom g\n  Img g \\<subseteq> Cod g", "show ?thesis"], ["proof (prove)\nusing this:\n  Fun g ` Fun f ` Cod g = Cod g\n  Fun f ` Cod g \\<subseteq> Dom g\n  Img g \\<subseteq> Cod g\n\ngoal (1 subgoal):\n 1. Img g = Cod g", "by blast"], ["proof (state)\nthis:\n  Img g = Cod g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Img g = Cod g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  arr g \\<and> Img g = Cod g\n\ngoal (1 subgoal):\n 1. arr g \\<and> Img g = Cod g \\<Longrightarrow> retraction g", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. arr g \\<and> Img g = Cod g \\<Longrightarrow> retraction g", "assume \"arr g \\<and> Img g = Cod g\""], ["proof (state)\nthis:\n  arr g \\<and> Img g = Cod g\n\ngoal (1 subgoal):\n 1. arr g \\<and> Img g = Cod g \\<Longrightarrow> retraction g", "thus \"retraction g\""], ["proof (prove)\nusing this:\n  arr g \\<and> Img g = Cod g\n\ngoal (1 subgoal):\n 1. retraction g", "using retraction_if_Img_eq_Cod"], ["proof (prove)\nusing this:\n  arr g \\<and> Img g = Cod g\n  \\<lbrakk>arr ?g; Img ?g = Cod ?g\\<rbrakk> \\<Longrightarrow> retraction ?g\n  \\<lbrakk>arr ?g; Img ?g = Cod ?g\\<rbrakk>\n  \\<Longrightarrow> ide (?g \\<cdot>\n                         mkArr (Cod ?g) (Dom ?g)\n                          (inv_into (Dom ?g) (Fun ?g)))\n\ngoal (1 subgoal):\n 1. retraction g", "by blast"], ["proof (state)\nthis:\n  retraction g\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n      Every corestriction is a retraction.\n\\<close>"], ["", "lemma retraction_corestr:\n    assumes \"arr f\"\n    shows \"retraction (corestr f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. retraction (corestr f)", "using assms retraction_char Fun_corestr corestr_in_hom arr_mkArr"], ["proof (prove)\nusing this:\n  arr f\n  retraction ?g = (arr ?g \\<and> Img ?g = Cod ?g)\n  arr ?f \\<Longrightarrow> Fun (corestr ?f) = Fun ?f\n  arr ?f \\<Longrightarrow>\n  \\<guillemotleft>corestr\n                   ?f : local.dom ?f \\<rightarrow> img ?f\\<guillemotright>\n  arr (mkArr ?A ?B ?F) =\n  (?A \\<subseteq> Univ \\<and>\n   |?A| <o \\<AA> \\<and>\n   ?B \\<subseteq> Univ \\<and>\n   |?B| <o \\<AA> \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n\ngoal (1 subgoal):\n 1. retraction (corestr f)", "by force"], ["", "text\\<open>\n      An arrow is a section if and only if it induces an injective function on its\n      domain, except in the special case that it has an empty domain set and a\n      nonempty codomain set.\n\\<close>"], ["", "lemma section_if_inj:\n    assumes \"arr f\" and \"inj_on (Fun f) (Dom f)\" and \"Dom f = {} \\<longrightarrow> Cod f = {}\"\n    shows \"section f\"\n    and \"ide (mkArr (Cod f) (Dom f)\n                    (\\<lambda>y. if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n                         else SOME x. x \\<in> Dom f)\n                \\<cdot> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. section f &&&\n    ide (mkArr (Cod f) (Dom f)\n          (\\<lambda>y.\n              if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n              else SOME x. x \\<in> Dom f) \\<cdot>\n         f)", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. section f\n 2. ide (mkArr (Cod f) (Dom f)\n          (\\<lambda>y.\n              if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n              else SOME x. x \\<in> Dom f) \\<cdot>\n         f)", "let ?P= \"\\<lambda>y. \\<lambda>x. x \\<in> Dom f \\<and> Fun f x = y\""], ["proof (state)\ngoal (2 subgoals):\n 1. section f\n 2. ide (mkArr (Cod f) (Dom f)\n          (\\<lambda>y.\n              if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n              else SOME x. x \\<in> Dom f) \\<cdot>\n         f)", "let ?G = \"\\<lambda>y. if y \\<in> Img f then SOME x. ?P y x else SOME x. x \\<in> Dom f\""], ["proof (state)\ngoal (2 subgoals):\n 1. section f\n 2. ide (mkArr (Cod f) (Dom f)\n          (\\<lambda>y.\n              if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n              else SOME x. x \\<in> Dom f) \\<cdot>\n         f)", "let ?g = \"mkArr (Cod f) (Dom f) ?G\""], ["proof (state)\ngoal (2 subgoals):\n 1. section f\n 2. ide (mkArr (Cod f) (Dom f)\n          (\\<lambda>y.\n              if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n              else SOME x. x \\<in> Dom f) \\<cdot>\n         f)", "have g: \"arr ?g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (mkArr (Cod f) (Dom f)\n          (\\<lambda>y.\n              if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n              else SOME x. x \\<in> Dom f))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. arr (mkArr (Cod f) (Dom f)\n          (\\<lambda>y.\n              if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n              else SOME x. x \\<in> Dom f))", "have 1: \"Cod f \\<subseteq> Univ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cod f \\<subseteq> Univ", "using assms"], ["proof (prove)\nusing this:\n  arr f\n  inj_on (Fun f) (Dom f)\n  Dom f = {} \\<longrightarrow> Cod f = {}\n\ngoal (1 subgoal):\n 1. Cod f \\<subseteq> Univ", "by simp"], ["proof (state)\nthis:\n  Cod f \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. arr (mkArr (Cod f) (Dom f)\n          (\\<lambda>y.\n              if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n              else SOME x. x \\<in> Dom f))", "have 2: \"Dom f \\<subseteq> Univ\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dom f \\<subseteq> Univ", "using assms"], ["proof (prove)\nusing this:\n  arr f\n  inj_on (Fun f) (Dom f)\n  Dom f = {} \\<longrightarrow> Cod f = {}\n\ngoal (1 subgoal):\n 1. Dom f \\<subseteq> Univ", "by simp"], ["proof (state)\nthis:\n  Dom f \\<subseteq> Univ\n\ngoal (1 subgoal):\n 1. arr (mkArr (Cod f) (Dom f)\n          (\\<lambda>y.\n              if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n              else SOME x. x \\<in> Dom f))", "have 3: \"|Cod f| <o \\<AA> \\<and> |Dom f| <o \\<AA>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. |Cod f| <o \\<AA> \\<and> |Dom f| <o \\<AA>", "using assms set_card"], ["proof (prove)\nusing this:\n  arr f\n  inj_on (Fun f) (Dom f)\n  Dom f = {} \\<longrightarrow> Cod f = {}\n  ide ?a \\<Longrightarrow> |local.set ?a| <o \\<AA>\n\ngoal (1 subgoal):\n 1. |Cod f| <o \\<AA> \\<and> |Dom f| <o \\<AA>", "by simp"], ["proof (state)\nthis:\n  |Cod f| <o \\<AA> \\<and> |Dom f| <o \\<AA>\n\ngoal (1 subgoal):\n 1. arr (mkArr (Cod f) (Dom f)\n          (\\<lambda>y.\n              if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n              else SOME x. x \\<in> Dom f))", "have 4: \"?G \\<in> Cod f \\<rightarrow> Dom f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>y.\n        if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n        else SOME x. x \\<in> Dom f)\n    \\<in> Cod f \\<rightarrow> Dom f", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Cod f \\<Longrightarrow>\n       (if x \\<in> Img f then SOME xa. xa \\<in> Dom f \\<and> Fun f xa = x\n        else SOME x. x \\<in> Dom f)\n       \\<in> Dom f", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Cod f \\<Longrightarrow>\n       (if x \\<in> Img f then SOME xa. xa \\<in> Dom f \\<and> Fun f xa = x\n        else SOME x. x \\<in> Dom f)\n       \\<in> Dom f", "assume Y: \"y \\<in> Cod f\""], ["proof (state)\nthis:\n  y \\<in> Cod f\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Cod f \\<Longrightarrow>\n       (if x \\<in> Img f then SOME xa. xa \\<in> Dom f \\<and> Fun f xa = x\n        else SOME x. x \\<in> Dom f)\n       \\<in> Dom f", "show \"?G y \\<in> Dom f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n     else SOME x. x \\<in> Dom f)\n    \\<in> Dom f", "proof (cases \"y \\<in> Img f\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y \\<in> Img f \\<Longrightarrow>\n    (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n     else SOME x. x \\<in> Dom f)\n    \\<in> Dom f\n 2. y \\<notin> Img f \\<Longrightarrow>\n    (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n     else SOME x. x \\<in> Dom f)\n    \\<in> Dom f", "assume \"y \\<in> Img f\""], ["proof (state)\nthis:\n  y \\<in> Img f\n\ngoal (2 subgoals):\n 1. y \\<in> Img f \\<Longrightarrow>\n    (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n     else SOME x. x \\<in> Dom f)\n    \\<in> Dom f\n 2. y \\<notin> Img f \\<Longrightarrow>\n    (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n     else SOME x. x \\<in> Dom f)\n    \\<in> Dom f", "hence \"(\\<exists>x. ?P y x) \\<and> ?G y = (SOME x. ?P y x)\""], ["proof (prove)\nusing this:\n  y \\<in> Img f\n\ngoal (1 subgoal):\n 1. (\\<exists>x. x \\<in> Dom f \\<and> Fun f x = y) \\<and>\n    (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n     else SOME x. x \\<in> Dom f) =\n    (SOME x. x \\<in> Dom f \\<and> Fun f x = y)", "using Y"], ["proof (prove)\nusing this:\n  y \\<in> Img f\n  y \\<in> Cod f\n\ngoal (1 subgoal):\n 1. (\\<exists>x. x \\<in> Dom f \\<and> Fun f x = y) \\<and>\n    (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n     else SOME x. x \\<in> Dom f) =\n    (SOME x. x \\<in> Dom f \\<and> Fun f x = y)", "by auto"], ["proof (state)\nthis:\n  (\\<exists>x. x \\<in> Dom f \\<and> Fun f x = y) \\<and>\n  (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n   else SOME x. x \\<in> Dom f) =\n  (SOME x. x \\<in> Dom f \\<and> Fun f x = y)\n\ngoal (2 subgoals):\n 1. y \\<in> Img f \\<Longrightarrow>\n    (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n     else SOME x. x \\<in> Dom f)\n    \\<in> Dom f\n 2. y \\<notin> Img f \\<Longrightarrow>\n    (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n     else SOME x. x \\<in> Dom f)\n    \\<in> Dom f", "hence \"?P y (?G y)\""], ["proof (prove)\nusing this:\n  (\\<exists>x. x \\<in> Dom f \\<and> Fun f x = y) \\<and>\n  (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n   else SOME x. x \\<in> Dom f) =\n  (SOME x. x \\<in> Dom f \\<and> Fun f x = y)\n\ngoal (1 subgoal):\n 1. (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n     else SOME x. x \\<in> Dom f)\n    \\<in> Dom f \\<and>\n    Fun f\n     (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n      else SOME x. x \\<in> Dom f) =\n    y", "using someI_ex [of \"?P y\"]"], ["proof (prove)\nusing this:\n  (\\<exists>x. x \\<in> Dom f \\<and> Fun f x = y) \\<and>\n  (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n   else SOME x. x \\<in> Dom f) =\n  (SOME x. x \\<in> Dom f \\<and> Fun f x = y)\n  \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y \\<Longrightarrow>\n  (SOME x. x \\<in> Dom f \\<and> Fun f x = y) \\<in> Dom f \\<and>\n  Fun f (SOME x. x \\<in> Dom f \\<and> Fun f x = y) = y\n\ngoal (1 subgoal):\n 1. (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n     else SOME x. x \\<in> Dom f)\n    \\<in> Dom f \\<and>\n    Fun f\n     (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n      else SOME x. x \\<in> Dom f) =\n    y", "by argo"], ["proof (state)\nthis:\n  (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n   else SOME x. x \\<in> Dom f)\n  \\<in> Dom f \\<and>\n  Fun f\n   (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n    else SOME x. x \\<in> Dom f) =\n  y\n\ngoal (2 subgoals):\n 1. y \\<in> Img f \\<Longrightarrow>\n    (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n     else SOME x. x \\<in> Dom f)\n    \\<in> Dom f\n 2. y \\<notin> Img f \\<Longrightarrow>\n    (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n     else SOME x. x \\<in> Dom f)\n    \\<in> Dom f", "thus \"?G y \\<in> Dom f\""], ["proof (prove)\nusing this:\n  (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n   else SOME x. x \\<in> Dom f)\n  \\<in> Dom f \\<and>\n  Fun f\n   (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n    else SOME x. x \\<in> Dom f) =\n  y\n\ngoal (1 subgoal):\n 1. (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n     else SOME x. x \\<in> Dom f)\n    \\<in> Dom f", "by auto"], ["proof (state)\nthis:\n  (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n   else SOME x. x \\<in> Dom f)\n  \\<in> Dom f\n\ngoal (1 subgoal):\n 1. y \\<notin> Img f \\<Longrightarrow>\n    (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n     else SOME x. x \\<in> Dom f)\n    \\<in> Dom f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y \\<notin> Img f \\<Longrightarrow>\n    (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n     else SOME x. x \\<in> Dom f)\n    \\<in> Dom f", "assume \"y \\<notin> Img f\""], ["proof (state)\nthis:\n  y \\<notin> Img f\n\ngoal (1 subgoal):\n 1. y \\<notin> Img f \\<Longrightarrow>\n    (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n     else SOME x. x \\<in> Dom f)\n    \\<in> Dom f", "hence \"(\\<exists>x. x \\<in> Dom f) \\<and> ?G y = (SOME x. x \\<in> Dom f)\""], ["proof (prove)\nusing this:\n  y \\<notin> Img f\n\ngoal (1 subgoal):\n 1. (\\<exists>x. x \\<in> Dom f) \\<and>\n    (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n     else SOME x. x \\<in> Dom f) =\n    (SOME x. x \\<in> Dom f)", "using assms Y"], ["proof (prove)\nusing this:\n  y \\<notin> Img f\n  arr f\n  inj_on (Fun f) (Dom f)\n  Dom f = {} \\<longrightarrow> Cod f = {}\n  y \\<in> Cod f\n\ngoal (1 subgoal):\n 1. (\\<exists>x. x \\<in> Dom f) \\<and>\n    (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n     else SOME x. x \\<in> Dom f) =\n    (SOME x. x \\<in> Dom f)", "by auto"], ["proof (state)\nthis:\n  (\\<exists>x. x \\<in> Dom f) \\<and>\n  (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n   else SOME x. x \\<in> Dom f) =\n  (SOME x. x \\<in> Dom f)\n\ngoal (1 subgoal):\n 1. y \\<notin> Img f \\<Longrightarrow>\n    (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n     else SOME x. x \\<in> Dom f)\n    \\<in> Dom f", "thus \"?G y \\<in> Dom f\""], ["proof (prove)\nusing this:\n  (\\<exists>x. x \\<in> Dom f) \\<and>\n  (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n   else SOME x. x \\<in> Dom f) =\n  (SOME x. x \\<in> Dom f)\n\ngoal (1 subgoal):\n 1. (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n     else SOME x. x \\<in> Dom f)\n    \\<in> Dom f", "using someI_ex [of \"\\<lambda>x. x \\<in> Dom f\"]"], ["proof (prove)\nusing this:\n  (\\<exists>x. x \\<in> Dom f) \\<and>\n  (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n   else SOME x. x \\<in> Dom f) =\n  (SOME x. x \\<in> Dom f)\n  \\<exists>x. x \\<in> Dom f \\<Longrightarrow>\n  (SOME x. x \\<in> Dom f) \\<in> Dom f\n\ngoal (1 subgoal):\n 1. (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n     else SOME x. x \\<in> Dom f)\n    \\<in> Dom f", "by argo"], ["proof (state)\nthis:\n  (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n   else SOME x. x \\<in> Dom f)\n  \\<in> Dom f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n   else SOME x. x \\<in> Dom f)\n  \\<in> Dom f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<lambda>y.\n      if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n      else SOME x. x \\<in> Dom f)\n  \\<in> Cod f \\<rightarrow> Dom f\n\ngoal (1 subgoal):\n 1. arr (mkArr (Cod f) (Dom f)\n          (\\<lambda>y.\n              if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n              else SOME x. x \\<in> Dom f))", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (mkArr (Cod f) (Dom f)\n          (\\<lambda>y.\n              if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n              else SOME x. x \\<in> Dom f))", "using 1 2 3 4 arr_mkArr"], ["proof (prove)\nusing this:\n  Cod f \\<subseteq> Univ\n  Dom f \\<subseteq> Univ\n  |Cod f| <o \\<AA> \\<and> |Dom f| <o \\<AA>\n  (\\<lambda>y.\n      if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n      else SOME x. x \\<in> Dom f)\n  \\<in> Cod f \\<rightarrow> Dom f\n  arr (mkArr ?A ?B ?F) =\n  (?A \\<subseteq> Univ \\<and>\n   |?A| <o \\<AA> \\<and>\n   ?B \\<subseteq> Univ \\<and>\n   |?B| <o \\<AA> \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n\ngoal (1 subgoal):\n 1. arr (mkArr (Cod f) (Dom f)\n          (\\<lambda>y.\n              if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n              else SOME x. x \\<in> Dom f))", "by simp"], ["proof (state)\nthis:\n  arr (mkArr (Cod f) (Dom f)\n        (\\<lambda>y.\n            if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n            else SOME x. x \\<in> Dom f))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  arr (mkArr (Cod f) (Dom f)\n        (\\<lambda>y.\n            if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n            else SOME x. x \\<in> Dom f))\n\ngoal (2 subgoals):\n 1. section f\n 2. ide (mkArr (Cod f) (Dom f)\n          (\\<lambda>y.\n              if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n              else SOME x. x \\<in> Dom f) \\<cdot>\n         f)", "show \"ide (?g \\<cdot> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide (mkArr (Cod f) (Dom f)\n          (\\<lambda>y.\n              if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n              else SOME x. x \\<in> Dom f) \\<cdot>\n         f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ide (mkArr (Cod f) (Dom f)\n          (\\<lambda>y.\n              if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n              else SOME x. x \\<in> Dom f) \\<cdot>\n         f)", "have \"f = mkArr (Dom f) (Cod f) (Fun f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = mkArr (Dom f) (Cod f) (Fun f)", "using assms mkArr_Fun"], ["proof (prove)\nusing this:\n  arr f\n  inj_on (Fun f) (Dom f)\n  Dom f = {} \\<longrightarrow> Cod f = {}\n  arr ?f \\<Longrightarrow> mkArr (Dom ?f) (Cod ?f) (Fun ?f) = ?f\n\ngoal (1 subgoal):\n 1. f = mkArr (Dom f) (Cod f) (Fun f)", "by auto"], ["proof (state)\nthis:\n  f = mkArr (Dom f) (Cod f) (Fun f)\n\ngoal (1 subgoal):\n 1. ide (mkArr (Cod f) (Dom f)\n          (\\<lambda>y.\n              if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n              else SOME x. x \\<in> Dom f) \\<cdot>\n         f)", "hence \"?g \\<cdot> f = mkArr (Dom f) (Dom f) (?G o Fun f)\""], ["proof (prove)\nusing this:\n  f = mkArr (Dom f) (Cod f) (Fun f)\n\ngoal (1 subgoal):\n 1. mkArr (Cod f) (Dom f)\n     (\\<lambda>y.\n         if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n         else SOME x. x \\<in> Dom f) \\<cdot>\n    f =\n    mkArr (Dom f) (Dom f)\n     ((\\<lambda>y.\n          if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n          else SOME x. x \\<in> Dom f) \\<circ>\n      Fun f)", "using assms(1) g comp_mkArr [of \"Dom f\" \"Cod f\" \"Fun f\" \"Dom f\" ?G]"], ["proof (prove)\nusing this:\n  f = mkArr (Dom f) (Cod f) (Fun f)\n  arr f\n  arr (mkArr (Cod f) (Dom f)\n        (\\<lambda>y.\n            if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n            else SOME x. x \\<in> Dom f))\n  \\<lbrakk>arr (mkArr (Dom f) (Cod f) (Fun f));\n   arr (mkArr (Cod f) (Dom f)\n         (\\<lambda>y.\n             if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n             else SOME x. x \\<in> Dom f))\\<rbrakk>\n  \\<Longrightarrow> mkArr (Cod f) (Dom f)\n                     (\\<lambda>y.\n                         if y \\<in> Img f\n                         then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n                         else SOME x. x \\<in> Dom f) \\<cdot>\n                    mkArr (Dom f) (Cod f) (Fun f) =\n                    mkArr (Dom f) (Dom f)\n                     ((\\<lambda>y.\n                          if y \\<in> Img f\n                          then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n                          else SOME x. x \\<in> Dom f) \\<circ>\n                      Fun f)\n\ngoal (1 subgoal):\n 1. mkArr (Cod f) (Dom f)\n     (\\<lambda>y.\n         if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n         else SOME x. x \\<in> Dom f) \\<cdot>\n    f =\n    mkArr (Dom f) (Dom f)\n     ((\\<lambda>y.\n          if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n          else SOME x. x \\<in> Dom f) \\<circ>\n      Fun f)", "by argo"], ["proof (state)\nthis:\n  mkArr (Cod f) (Dom f)\n   (\\<lambda>y.\n       if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n       else SOME x. x \\<in> Dom f) \\<cdot>\n  f =\n  mkArr (Dom f) (Dom f)\n   ((\\<lambda>y.\n        if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n        else SOME x. x \\<in> Dom f) \\<circ>\n    Fun f)\n\ngoal (1 subgoal):\n 1. ide (mkArr (Cod f) (Dom f)\n          (\\<lambda>y.\n              if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n              else SOME x. x \\<in> Dom f) \\<cdot>\n         f)", "moreover"], ["proof (state)\nthis:\n  mkArr (Cod f) (Dom f)\n   (\\<lambda>y.\n       if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n       else SOME x. x \\<in> Dom f) \\<cdot>\n  f =\n  mkArr (Dom f) (Dom f)\n   ((\\<lambda>y.\n        if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n        else SOME x. x \\<in> Dom f) \\<circ>\n    Fun f)\n\ngoal (1 subgoal):\n 1. ide (mkArr (Cod f) (Dom f)\n          (\\<lambda>y.\n              if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n              else SOME x. x \\<in> Dom f) \\<cdot>\n         f)", "have \"mkArr (Dom f) (Dom f) (\\<lambda>x. x) = ...\""], ["proof (prove)\ngoal (1 subgoal):\n 1. incl_of (local.dom f) (local.dom f) =\n    mkArr (Dom f) (Dom f)\n     ((\\<lambda>y.\n          if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n          else SOME x. x \\<in> Dom f) \\<circ>\n      Fun f)", "proof (intro mkArr_eqI')"], ["proof (state)\ngoal (2 subgoals):\n 1. arr (incl_of (local.dom f) (local.dom f))\n 2. \\<And>x.\n       x \\<in> Dom f \\<Longrightarrow>\n       x =\n       ((\\<lambda>y.\n            if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n            else SOME x. x \\<in> Dom f) \\<circ>\n        Fun f)\n        x", "show \"arr (mkArr (Dom f) (Dom f) (\\<lambda>x. x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (incl_of (local.dom f) (local.dom f))", "using assms set_card arr_mkArr"], ["proof (prove)\nusing this:\n  arr f\n  inj_on (Fun f) (Dom f)\n  Dom f = {} \\<longrightarrow> Cod f = {}\n  ide ?a \\<Longrightarrow> |local.set ?a| <o \\<AA>\n  arr (mkArr ?A ?B ?F) =\n  (?A \\<subseteq> Univ \\<and>\n   |?A| <o \\<AA> \\<and>\n   ?B \\<subseteq> Univ \\<and>\n   |?B| <o \\<AA> \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n\ngoal (1 subgoal):\n 1. arr (incl_of (local.dom f) (local.dom f))", "by auto"], ["proof (state)\nthis:\n  arr (incl_of (local.dom f) (local.dom f))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Dom f \\<Longrightarrow>\n       x =\n       ((\\<lambda>y.\n            if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n            else SOME x. x \\<in> Dom f) \\<circ>\n        Fun f)\n        x", "show \"\\<And>x. x \\<in> Dom f \\<Longrightarrow> x = (?G o Fun f) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Dom f \\<Longrightarrow>\n       x =\n       ((\\<lambda>y.\n            if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n            else SOME x. x \\<in> Dom f) \\<circ>\n        Fun f)\n        x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Dom f \\<Longrightarrow>\n       x =\n       ((\\<lambda>y.\n            if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n            else SOME x. x \\<in> Dom f) \\<circ>\n        Fun f)\n        x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Dom f \\<Longrightarrow>\n       x =\n       ((\\<lambda>y.\n            if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n            else SOME x. x \\<in> Dom f) \\<circ>\n        Fun f)\n        x", "assume x: \"x \\<in> Dom f\""], ["proof (state)\nthis:\n  x \\<in> Dom f\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Dom f \\<Longrightarrow>\n       x =\n       ((\\<lambda>y.\n            if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n            else SOME x. x \\<in> Dom f) \\<circ>\n        Fun f)\n        x", "have \"Fun f x \\<in> Img f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun f x \\<in> Img f", "using x"], ["proof (prove)\nusing this:\n  x \\<in> Dom f\n\ngoal (1 subgoal):\n 1. Fun f x \\<in> Img f", "by blast"], ["proof (state)\nthis:\n  Fun f x \\<in> Img f\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Dom f \\<Longrightarrow>\n       x =\n       ((\\<lambda>y.\n            if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n            else SOME x. x \\<in> Dom f) \\<circ>\n        Fun f)\n        x", "hence *: \"(\\<exists>x'. ?P (Fun f x) x') \\<and> ?G (Fun f x) = (SOME x'. ?P (Fun f x) x')\""], ["proof (prove)\nusing this:\n  Fun f x \\<in> Img f\n\ngoal (1 subgoal):\n 1. (\\<exists>x'. x' \\<in> Dom f \\<and> Fun f x' = Fun f x) \\<and>\n    (if Fun f x \\<in> Img f\n     then SOME xa. xa \\<in> Dom f \\<and> Fun f xa = Fun f x\n     else SOME x. x \\<in> Dom f) =\n    (SOME x'. x' \\<in> Dom f \\<and> Fun f x' = Fun f x)", "by auto"], ["proof (state)\nthis:\n  (\\<exists>x'. x' \\<in> Dom f \\<and> Fun f x' = Fun f x) \\<and>\n  (if Fun f x \\<in> Img f\n   then SOME xa. xa \\<in> Dom f \\<and> Fun f xa = Fun f x\n   else SOME x. x \\<in> Dom f) =\n  (SOME x'. x' \\<in> Dom f \\<and> Fun f x' = Fun f x)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Dom f \\<Longrightarrow>\n       x =\n       ((\\<lambda>y.\n            if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n            else SOME x. x \\<in> Dom f) \\<circ>\n        Fun f)\n        x", "then"], ["proof (chain)\npicking this:\n  (\\<exists>x'. x' \\<in> Dom f \\<and> Fun f x' = Fun f x) \\<and>\n  (if Fun f x \\<in> Img f\n   then SOME xa. xa \\<in> Dom f \\<and> Fun f xa = Fun f x\n   else SOME x. x \\<in> Dom f) =\n  (SOME x'. x' \\<in> Dom f \\<and> Fun f x' = Fun f x)", "have \"?P (Fun f x) (?G (Fun f x))\""], ["proof (prove)\nusing this:\n  (\\<exists>x'. x' \\<in> Dom f \\<and> Fun f x' = Fun f x) \\<and>\n  (if Fun f x \\<in> Img f\n   then SOME xa. xa \\<in> Dom f \\<and> Fun f xa = Fun f x\n   else SOME x. x \\<in> Dom f) =\n  (SOME x'. x' \\<in> Dom f \\<and> Fun f x' = Fun f x)\n\ngoal (1 subgoal):\n 1. (if Fun f x \\<in> Img f\n     then SOME xa. xa \\<in> Dom f \\<and> Fun f xa = Fun f x\n     else SOME x. x \\<in> Dom f)\n    \\<in> Dom f \\<and>\n    Fun f\n     (if Fun f x \\<in> Img f\n      then SOME xa. xa \\<in> Dom f \\<and> Fun f xa = Fun f x\n      else SOME x. x \\<in> Dom f) =\n    Fun f x", "using someI_ex [of \"?P (Fun f x)\"]"], ["proof (prove)\nusing this:\n  (\\<exists>x'. x' \\<in> Dom f \\<and> Fun f x' = Fun f x) \\<and>\n  (if Fun f x \\<in> Img f\n   then SOME xa. xa \\<in> Dom f \\<and> Fun f xa = Fun f x\n   else SOME x. x \\<in> Dom f) =\n  (SOME x'. x' \\<in> Dom f \\<and> Fun f x' = Fun f x)\n  \\<exists>xa. xa \\<in> Dom f \\<and> Fun f xa = Fun f x \\<Longrightarrow>\n  (SOME xa. xa \\<in> Dom f \\<and> Fun f xa = Fun f x) \\<in> Dom f \\<and>\n  Fun f (SOME xa. xa \\<in> Dom f \\<and> Fun f xa = Fun f x) = Fun f x\n\ngoal (1 subgoal):\n 1. (if Fun f x \\<in> Img f\n     then SOME xa. xa \\<in> Dom f \\<and> Fun f xa = Fun f x\n     else SOME x. x \\<in> Dom f)\n    \\<in> Dom f \\<and>\n    Fun f\n     (if Fun f x \\<in> Img f\n      then SOME xa. xa \\<in> Dom f \\<and> Fun f xa = Fun f x\n      else SOME x. x \\<in> Dom f) =\n    Fun f x", "by argo"], ["proof (state)\nthis:\n  (if Fun f x \\<in> Img f\n   then SOME xa. xa \\<in> Dom f \\<and> Fun f xa = Fun f x\n   else SOME x. x \\<in> Dom f)\n  \\<in> Dom f \\<and>\n  Fun f\n   (if Fun f x \\<in> Img f\n    then SOME xa. xa \\<in> Dom f \\<and> Fun f xa = Fun f x\n    else SOME x. x \\<in> Dom f) =\n  Fun f x\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Dom f \\<Longrightarrow>\n       x =\n       ((\\<lambda>y.\n            if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n            else SOME x. x \\<in> Dom f) \\<circ>\n        Fun f)\n        x", "with *"], ["proof (chain)\npicking this:\n  (\\<exists>x'. x' \\<in> Dom f \\<and> Fun f x' = Fun f x) \\<and>\n  (if Fun f x \\<in> Img f\n   then SOME xa. xa \\<in> Dom f \\<and> Fun f xa = Fun f x\n   else SOME x. x \\<in> Dom f) =\n  (SOME x'. x' \\<in> Dom f \\<and> Fun f x' = Fun f x)\n  (if Fun f x \\<in> Img f\n   then SOME xa. xa \\<in> Dom f \\<and> Fun f xa = Fun f x\n   else SOME x. x \\<in> Dom f)\n  \\<in> Dom f \\<and>\n  Fun f\n   (if Fun f x \\<in> Img f\n    then SOME xa. xa \\<in> Dom f \\<and> Fun f xa = Fun f x\n    else SOME x. x \\<in> Dom f) =\n  Fun f x", "have \"x = ?G (Fun f x)\""], ["proof (prove)\nusing this:\n  (\\<exists>x'. x' \\<in> Dom f \\<and> Fun f x' = Fun f x) \\<and>\n  (if Fun f x \\<in> Img f\n   then SOME xa. xa \\<in> Dom f \\<and> Fun f xa = Fun f x\n   else SOME x. x \\<in> Dom f) =\n  (SOME x'. x' \\<in> Dom f \\<and> Fun f x' = Fun f x)\n  (if Fun f x \\<in> Img f\n   then SOME xa. xa \\<in> Dom f \\<and> Fun f xa = Fun f x\n   else SOME x. x \\<in> Dom f)\n  \\<in> Dom f \\<and>\n  Fun f\n   (if Fun f x \\<in> Img f\n    then SOME xa. xa \\<in> Dom f \\<and> Fun f xa = Fun f x\n    else SOME x. x \\<in> Dom f) =\n  Fun f x\n\ngoal (1 subgoal):\n 1. x =\n    (if Fun f x \\<in> Img f\n     then SOME xa. xa \\<in> Dom f \\<and> Fun f xa = Fun f x\n     else SOME x. x \\<in> Dom f)", "using assms x inj_on_def [of \"Fun f\" \"Dom f\"]"], ["proof (prove)\nusing this:\n  (\\<exists>x'. x' \\<in> Dom f \\<and> Fun f x' = Fun f x) \\<and>\n  (if Fun f x \\<in> Img f\n   then SOME xa. xa \\<in> Dom f \\<and> Fun f xa = Fun f x\n   else SOME x. x \\<in> Dom f) =\n  (SOME x'. x' \\<in> Dom f \\<and> Fun f x' = Fun f x)\n  (if Fun f x \\<in> Img f\n   then SOME xa. xa \\<in> Dom f \\<and> Fun f xa = Fun f x\n   else SOME x. x \\<in> Dom f)\n  \\<in> Dom f \\<and>\n  Fun f\n   (if Fun f x \\<in> Img f\n    then SOME xa. xa \\<in> Dom f \\<and> Fun f xa = Fun f x\n    else SOME x. x \\<in> Dom f) =\n  Fun f x\n  arr f\n  inj_on (Fun f) (Dom f)\n  Dom f = {} \\<longrightarrow> Cod f = {}\n  x \\<in> Dom f\n  inj_on (Fun f) (Dom f) =\n  (\\<forall>x\\<in>Dom f.\n      \\<forall>y\\<in>Dom f. Fun f x = Fun f y \\<longrightarrow> x = y)\n\ngoal (1 subgoal):\n 1. x =\n    (if Fun f x \\<in> Img f\n     then SOME xa. xa \\<in> Dom f \\<and> Fun f xa = Fun f x\n     else SOME x. x \\<in> Dom f)", "by simp"], ["proof (state)\nthis:\n  x =\n  (if Fun f x \\<in> Img f\n   then SOME xa. xa \\<in> Dom f \\<and> Fun f xa = Fun f x\n   else SOME x. x \\<in> Dom f)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Dom f \\<Longrightarrow>\n       x =\n       ((\\<lambda>y.\n            if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n            else SOME x. x \\<in> Dom f) \\<circ>\n        Fun f)\n        x", "thus \"x = (?G o Fun f) x\""], ["proof (prove)\nusing this:\n  x =\n  (if Fun f x \\<in> Img f\n   then SOME xa. xa \\<in> Dom f \\<and> Fun f xa = Fun f x\n   else SOME x. x \\<in> Dom f)\n\ngoal (1 subgoal):\n 1. x =\n    ((\\<lambda>y.\n         if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n         else SOME x. x \\<in> Dom f) \\<circ>\n     Fun f)\n     x", "by simp"], ["proof (state)\nthis:\n  x =\n  ((\\<lambda>y.\n       if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n       else SOME x. x \\<in> Dom f) \\<circ>\n   Fun f)\n   x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?x \\<in> Dom f \\<Longrightarrow>\n  ?x =\n  ((\\<lambda>y.\n       if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n       else SOME x. x \\<in> Dom f) \\<circ>\n   Fun f)\n   ?x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  incl_of (local.dom f) (local.dom f) =\n  mkArr (Dom f) (Dom f)\n   ((\\<lambda>y.\n        if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n        else SOME x. x \\<in> Dom f) \\<circ>\n    Fun f)\n\ngoal (1 subgoal):\n 1. ide (mkArr (Cod f) (Dom f)\n          (\\<lambda>y.\n              if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n              else SOME x. x \\<in> Dom f) \\<cdot>\n         f)", "ultimately"], ["proof (chain)\npicking this:\n  mkArr (Cod f) (Dom f)\n   (\\<lambda>y.\n       if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n       else SOME x. x \\<in> Dom f) \\<cdot>\n  f =\n  mkArr (Dom f) (Dom f)\n   ((\\<lambda>y.\n        if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n        else SOME x. x \\<in> Dom f) \\<circ>\n    Fun f)\n  incl_of (local.dom f) (local.dom f) =\n  mkArr (Dom f) (Dom f)\n   ((\\<lambda>y.\n        if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n        else SOME x. x \\<in> Dom f) \\<circ>\n    Fun f)", "show ?thesis"], ["proof (prove)\nusing this:\n  mkArr (Cod f) (Dom f)\n   (\\<lambda>y.\n       if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n       else SOME x. x \\<in> Dom f) \\<cdot>\n  f =\n  mkArr (Dom f) (Dom f)\n   ((\\<lambda>y.\n        if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n        else SOME x. x \\<in> Dom f) \\<circ>\n    Fun f)\n  incl_of (local.dom f) (local.dom f) =\n  mkArr (Dom f) (Dom f)\n   ((\\<lambda>y.\n        if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n        else SOME x. x \\<in> Dom f) \\<circ>\n    Fun f)\n\ngoal (1 subgoal):\n 1. ide (mkArr (Cod f) (Dom f)\n          (\\<lambda>y.\n              if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n              else SOME x. x \\<in> Dom f) \\<cdot>\n         f)", "using assms set_card mkIde_as_mkArr mkIde_set"], ["proof (prove)\nusing this:\n  mkArr (Cod f) (Dom f)\n   (\\<lambda>y.\n       if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n       else SOME x. x \\<in> Dom f) \\<cdot>\n  f =\n  mkArr (Dom f) (Dom f)\n   ((\\<lambda>y.\n        if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n        else SOME x. x \\<in> Dom f) \\<circ>\n    Fun f)\n  incl_of (local.dom f) (local.dom f) =\n  mkArr (Dom f) (Dom f)\n   ((\\<lambda>y.\n        if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n        else SOME x. x \\<in> Dom f) \\<circ>\n    Fun f)\n  arr f\n  inj_on (Fun f) (Dom f)\n  Dom f = {} \\<longrightarrow> Cod f = {}\n  ide ?a \\<Longrightarrow> |local.set ?a| <o \\<AA>\n  \\<lbrakk>?A \\<subseteq> Univ; |?A| <o \\<AA>\\<rbrakk>\n  \\<Longrightarrow> mkArr ?A ?A (\\<lambda>x. x) = mkIde ?A\n  ide ?a \\<Longrightarrow> mkIde (local.set ?a) = ?a\n\ngoal (1 subgoal):\n 1. ide (mkArr (Cod f) (Dom f)\n          (\\<lambda>y.\n              if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n              else SOME x. x \\<in> Dom f) \\<cdot>\n         f)", "by auto"], ["proof (state)\nthis:\n  ide (mkArr (Cod f) (Dom f)\n        (\\<lambda>y.\n            if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n            else SOME x. x \\<in> Dom f) \\<cdot>\n       f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ide (mkArr (Cod f) (Dom f)\n        (\\<lambda>y.\n            if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n            else SOME x. x \\<in> Dom f) \\<cdot>\n       f)\n\ngoal (1 subgoal):\n 1. section f", "thus \"section f\""], ["proof (prove)\nusing this:\n  ide (mkArr (Cod f) (Dom f)\n        (\\<lambda>y.\n            if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n            else SOME x. x \\<in> Dom f) \\<cdot>\n       f)\n\ngoal (1 subgoal):\n 1. section f", "by auto"], ["proof (state)\nthis:\n  section f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma section_char:\n    shows \"section f \\<longleftrightarrow> arr f \\<and> (Dom f = {} \\<longrightarrow> Cod f = {}) \\<and> inj_on (Fun f) (Dom f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. section f =\n    (arr f \\<and>\n     (Dom f = {} \\<longrightarrow> Cod f = {}) \\<and>\n     inj_on (Fun f) (Dom f))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. section f \\<Longrightarrow>\n    arr f \\<and>\n    (Dom f = {} \\<longrightarrow> Cod f = {}) \\<and> inj_on (Fun f) (Dom f)\n 2. arr f \\<and>\n    (Dom f = {} \\<longrightarrow> Cod f = {}) \\<and>\n    inj_on (Fun f) (Dom f) \\<Longrightarrow>\n    section f", "assume f: \"section f\""], ["proof (state)\nthis:\n  section f\n\ngoal (2 subgoals):\n 1. section f \\<Longrightarrow>\n    arr f \\<and>\n    (Dom f = {} \\<longrightarrow> Cod f = {}) \\<and> inj_on (Fun f) (Dom f)\n 2. arr f \\<and>\n    (Dom f = {} \\<longrightarrow> Cod f = {}) \\<and>\n    inj_on (Fun f) (Dom f) \\<Longrightarrow>\n    section f", "from f"], ["proof (chain)\npicking this:\n  section f", "obtain g where g: \"ide (g \\<cdot> f)\""], ["proof (prove)\nusing this:\n  section f\n\ngoal (1 subgoal):\n 1. (\\<And>g. ide (g \\<cdot> f) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using section_def"], ["proof (prove)\nusing this:\n  section f\n  section ?f \\<equiv> \\<exists>g. ide (g \\<cdot> ?f)\n\ngoal (1 subgoal):\n 1. (\\<And>g. ide (g \\<cdot> f) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  ide (g \\<cdot> f)\n\ngoal (2 subgoals):\n 1. section f \\<Longrightarrow>\n    arr f \\<and>\n    (Dom f = {} \\<longrightarrow> Cod f = {}) \\<and> inj_on (Fun f) (Dom f)\n 2. arr f \\<and>\n    (Dom f = {} \\<longrightarrow> Cod f = {}) \\<and>\n    inj_on (Fun f) (Dom f) \\<Longrightarrow>\n    section f", "show \"arr f \\<and> (Dom f = {} \\<longrightarrow> Cod f = {}) \\<and> inj_on (Fun f) (Dom f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr f \\<and>\n    (Dom f = {} \\<longrightarrow> Cod f = {}) \\<and> inj_on (Fun f) (Dom f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. arr f \\<and>\n    (Dom f = {} \\<longrightarrow> Cod f = {}) \\<and> inj_on (Fun f) (Dom f)", "have \"arr f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr f", "using f"], ["proof (prove)\nusing this:\n  section f\n\ngoal (1 subgoal):\n 1. arr f", "by blast"], ["proof (state)\nthis:\n  arr f\n\ngoal (1 subgoal):\n 1. arr f \\<and>\n    (Dom f = {} \\<longrightarrow> Cod f = {}) \\<and> inj_on (Fun f) (Dom f)", "moreover"], ["proof (state)\nthis:\n  arr f\n\ngoal (1 subgoal):\n 1. arr f \\<and>\n    (Dom f = {} \\<longrightarrow> Cod f = {}) \\<and> inj_on (Fun f) (Dom f)", "have \"Dom f = {} \\<longrightarrow> Cod f = {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dom f = {} \\<longrightarrow> Cod f = {}", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Dom f = {} \\<longrightarrow> Cod f = {}", "have \"Cod f \\<noteq> {} \\<longrightarrow> Dom f \\<noteq> {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cod f \\<noteq> {} \\<longrightarrow> Dom f \\<noteq> {}", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. Cod f \\<noteq> {} \\<Longrightarrow> Dom f \\<noteq> {}", "assume \"Cod f \\<noteq> {}\""], ["proof (state)\nthis:\n  Cod f \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Cod f \\<noteq> {} \\<Longrightarrow> Dom f \\<noteq> {}", "from this"], ["proof (chain)\npicking this:\n  Cod f \\<noteq> {}", "obtain y where \"y \\<in> Cod f\""], ["proof (prove)\nusing this:\n  Cod f \\<noteq> {}\n\ngoal (1 subgoal):\n 1. (\\<And>y. y \\<in> Cod f \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  y \\<in> Cod f\n\ngoal (1 subgoal):\n 1. Cod f \\<noteq> {} \\<Longrightarrow> Dom f \\<noteq> {}", "hence \"Fun g y \\<in> Dom f\""], ["proof (prove)\nusing this:\n  y \\<in> Cod f\n\ngoal (1 subgoal):\n 1. Fun g y \\<in> Dom f", "using g Fun_mapsto"], ["proof (prove)\nusing this:\n  y \\<in> Cod f\n  ide (g \\<cdot> f)\n  arr ?f \\<Longrightarrow>\n  Fun ?f \\<in> extensional (Dom ?f) \\<inter> (Dom ?f \\<rightarrow> Cod ?f)\n\ngoal (1 subgoal):\n 1. Fun g y \\<in> Dom f", "by (metis seqE ide_compE image_eqI retractionI retraction_char)"], ["proof (state)\nthis:\n  Fun g y \\<in> Dom f\n\ngoal (1 subgoal):\n 1. Cod f \\<noteq> {} \\<Longrightarrow> Dom f \\<noteq> {}", "thus \"Dom f \\<noteq> {}\""], ["proof (prove)\nusing this:\n  Fun g y \\<in> Dom f\n\ngoal (1 subgoal):\n 1. Dom f \\<noteq> {}", "by blast"], ["proof (state)\nthis:\n  Dom f \\<noteq> {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Cod f \\<noteq> {} \\<longrightarrow> Dom f \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Dom f = {} \\<longrightarrow> Cod f = {}", "thus ?thesis"], ["proof (prove)\nusing this:\n  Cod f \\<noteq> {} \\<longrightarrow> Dom f \\<noteq> {}\n\ngoal (1 subgoal):\n 1. Dom f = {} \\<longrightarrow> Cod f = {}", "by auto"], ["proof (state)\nthis:\n  Dom f = {} \\<longrightarrow> Cod f = {}\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Dom f = {} \\<longrightarrow> Cod f = {}\n\ngoal (1 subgoal):\n 1. arr f \\<and>\n    (Dom f = {} \\<longrightarrow> Cod f = {}) \\<and> inj_on (Fun f) (Dom f)", "moreover"], ["proof (state)\nthis:\n  Dom f = {} \\<longrightarrow> Cod f = {}\n\ngoal (1 subgoal):\n 1. arr f \\<and>\n    (Dom f = {} \\<longrightarrow> Cod f = {}) \\<and> inj_on (Fun f) (Dom f)", "have \"inj_on (Fun f) (Dom f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (Fun f) (Dom f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on (Fun f) (Dom f)", "have \"restrict (Fun g o Fun f) (Dom f) = Fun (g \\<cdot> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. restrict (Fun g \\<circ> Fun f) (Dom f) = Fun (g \\<cdot> f)", "using g Fun_comp"], ["proof (prove)\nusing this:\n  ide (g \\<cdot> f)\n  seq ?g ?f \\<Longrightarrow>\n  Fun (?g \\<cdot> ?f) = restrict (Fun ?g \\<circ> Fun ?f) (Dom ?f)\n\ngoal (1 subgoal):\n 1. restrict (Fun g \\<circ> Fun f) (Dom f) = Fun (g \\<cdot> f)", "by (metis Fun_comp ide_compE)"], ["proof (state)\nthis:\n  restrict (Fun g \\<circ> Fun f) (Dom f) = Fun (g \\<cdot> f)\n\ngoal (1 subgoal):\n 1. inj_on (Fun f) (Dom f)", "also"], ["proof (state)\nthis:\n  restrict (Fun g \\<circ> Fun f) (Dom f) = Fun (g \\<cdot> f)\n\ngoal (1 subgoal):\n 1. inj_on (Fun f) (Dom f)", "have \"... = restrict (\\<lambda>x. x) (Dom f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (g \\<cdot> f) = (\\<lambda>x\\<in>Dom f. x)", "using g Fun_ide"], ["proof (prove)\nusing this:\n  ide (g \\<cdot> f)\n  ide ?a \\<Longrightarrow> Fun ?a = (\\<lambda>x\\<in>local.set ?a. x)\n\ngoal (1 subgoal):\n 1. Fun (g \\<cdot> f) = (\\<lambda>x\\<in>Dom f. x)", "by auto"], ["proof (state)\nthis:\n  Fun (g \\<cdot> f) = (\\<lambda>x\\<in>Dom f. x)\n\ngoal (1 subgoal):\n 1. inj_on (Fun f) (Dom f)", "finally"], ["proof (chain)\npicking this:\n  restrict (Fun g \\<circ> Fun f) (Dom f) = (\\<lambda>x\\<in>Dom f. x)", "have \"restrict (Fun g o Fun f) (Dom f) = restrict (\\<lambda>x. x) (Dom f)\""], ["proof (prove)\nusing this:\n  restrict (Fun g \\<circ> Fun f) (Dom f) = (\\<lambda>x\\<in>Dom f. x)\n\ngoal (1 subgoal):\n 1. restrict (Fun g \\<circ> Fun f) (Dom f) = (\\<lambda>x\\<in>Dom f. x)", "by auto"], ["proof (state)\nthis:\n  restrict (Fun g \\<circ> Fun f) (Dom f) = (\\<lambda>x\\<in>Dom f. x)\n\ngoal (1 subgoal):\n 1. inj_on (Fun f) (Dom f)", "thus ?thesis"], ["proof (prove)\nusing this:\n  restrict (Fun g \\<circ> Fun f) (Dom f) = (\\<lambda>x\\<in>Dom f. x)\n\ngoal (1 subgoal):\n 1. inj_on (Fun f) (Dom f)", "using inj_onI inj_on_imageI2 inj_on_restrict_eq"], ["proof (prove)\nusing this:\n  restrict (Fun g \\<circ> Fun f) (Dom f) = (\\<lambda>x\\<in>Dom f. x)\n  (\\<And>x y.\n      \\<lbrakk>x \\<in> ?A; y \\<in> ?A; ?f x = ?f y\\<rbrakk>\n      \\<Longrightarrow> x = y) \\<Longrightarrow>\n  inj_on ?f ?A\n  inj_on (?f' \\<circ> ?f) ?A \\<Longrightarrow> inj_on ?f ?A\n  inj_on (restrict ?f ?A) ?A = inj_on ?f ?A\n\ngoal (1 subgoal):\n 1. inj_on (Fun f) (Dom f)", "by metis"], ["proof (state)\nthis:\n  inj_on (Fun f) (Dom f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on (Fun f) (Dom f)\n\ngoal (1 subgoal):\n 1. arr f \\<and>\n    (Dom f = {} \\<longrightarrow> Cod f = {}) \\<and> inj_on (Fun f) (Dom f)", "ultimately"], ["proof (chain)\npicking this:\n  arr f\n  Dom f = {} \\<longrightarrow> Cod f = {}\n  inj_on (Fun f) (Dom f)", "show ?thesis"], ["proof (prove)\nusing this:\n  arr f\n  Dom f = {} \\<longrightarrow> Cod f = {}\n  inj_on (Fun f) (Dom f)\n\ngoal (1 subgoal):\n 1. arr f \\<and>\n    (Dom f = {} \\<longrightarrow> Cod f = {}) \\<and> inj_on (Fun f) (Dom f)", "by auto"], ["proof (state)\nthis:\n  arr f \\<and>\n  (Dom f = {} \\<longrightarrow> Cod f = {}) \\<and> inj_on (Fun f) (Dom f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  arr f \\<and>\n  (Dom f = {} \\<longrightarrow> Cod f = {}) \\<and> inj_on (Fun f) (Dom f)\n\ngoal (1 subgoal):\n 1. arr f \\<and>\n    (Dom f = {} \\<longrightarrow> Cod f = {}) \\<and>\n    inj_on (Fun f) (Dom f) \\<Longrightarrow>\n    section f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. arr f \\<and>\n    (Dom f = {} \\<longrightarrow> Cod f = {}) \\<and>\n    inj_on (Fun f) (Dom f) \\<Longrightarrow>\n    section f", "assume F: \"arr f \\<and> (Dom f = {} \\<longrightarrow> Cod f = {}) \\<and> inj_on (Fun f) (Dom f)\""], ["proof (state)\nthis:\n  arr f \\<and>\n  (Dom f = {} \\<longrightarrow> Cod f = {}) \\<and> inj_on (Fun f) (Dom f)\n\ngoal (1 subgoal):\n 1. arr f \\<and>\n    (Dom f = {} \\<longrightarrow> Cod f = {}) \\<and>\n    inj_on (Fun f) (Dom f) \\<Longrightarrow>\n    section f", "thus \"section f\""], ["proof (prove)\nusing this:\n  arr f \\<and>\n  (Dom f = {} \\<longrightarrow> Cod f = {}) \\<and> inj_on (Fun f) (Dom f)\n\ngoal (1 subgoal):\n 1. section f", "using section_if_inj"], ["proof (prove)\nusing this:\n  arr f \\<and>\n  (Dom f = {} \\<longrightarrow> Cod f = {}) \\<and> inj_on (Fun f) (Dom f)\n  \\<lbrakk>arr ?f; inj_on (Fun ?f) (Dom ?f);\n   Dom ?f = {} \\<longrightarrow> Cod ?f = {}\\<rbrakk>\n  \\<Longrightarrow> section ?f\n  \\<lbrakk>arr ?f; inj_on (Fun ?f) (Dom ?f);\n   Dom ?f = {} \\<longrightarrow> Cod ?f = {}\\<rbrakk>\n  \\<Longrightarrow> ide (mkArr (Cod ?f) (Dom ?f)\n                          (\\<lambda>y.\n                              if y \\<in> Img ?f\n                              then SOME x.\nx \\<in> Dom ?f \\<and> Fun ?f x = y\n                              else SOME x. x \\<in> Dom ?f) \\<cdot>\n                         ?f)\n\ngoal (1 subgoal):\n 1. section f", "by auto"], ["proof (state)\nthis:\n  section f\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n      Section-retraction pairs can also be characterized by an inverse relationship\n      between the functions they induce.\n\\<close>"], ["", "lemma section_retraction_char:\n    shows \"ide (g \\<cdot> f) \\<longleftrightarrow> antipar f g \\<and> compose (Dom f) (Fun g) (Fun f) = (\\<lambda>x \\<in> Dom f. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide (g \\<cdot> f) =\n    (antipar f g \\<and>\n     compose (Dom f) (Fun g) (Fun f) = (\\<lambda>x\\<in>Dom f. x))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. ide (g \\<cdot> f) \\<Longrightarrow>\n    antipar f g \\<and>\n    compose (Dom f) (Fun g) (Fun f) = (\\<lambda>x\\<in>Dom f. x)\n 2. antipar f g \\<and>\n    compose (Dom f) (Fun g) (Fun f) =\n    (\\<lambda>x\\<in>Dom f. x) \\<Longrightarrow>\n    ide (g \\<cdot> f)", "show \"ide (g \\<cdot> f) \\<Longrightarrow> antipar f g \\<and> compose (Dom f) (Fun g) (Fun f) = (\\<lambda>x \\<in> Dom f. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide (g \\<cdot> f) \\<Longrightarrow>\n    antipar f g \\<and>\n    compose (Dom f) (Fun g) (Fun f) = (\\<lambda>x\\<in>Dom f. x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ide (g \\<cdot> f) \\<Longrightarrow>\n    antipar f g \\<and>\n    compose (Dom f) (Fun g) (Fun f) = (\\<lambda>x\\<in>Dom f. x)", "assume fg: \"ide (g \\<cdot> f)\""], ["proof (state)\nthis:\n  ide (g \\<cdot> f)\n\ngoal (1 subgoal):\n 1. ide (g \\<cdot> f) \\<Longrightarrow>\n    antipar f g \\<and>\n    compose (Dom f) (Fun g) (Fun f) = (\\<lambda>x\\<in>Dom f. x)", "have 1: \"antipar f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. antipar f g", "using fg"], ["proof (prove)\nusing this:\n  ide (g \\<cdot> f)\n\ngoal (1 subgoal):\n 1. antipar f g", "by force"], ["proof (state)\nthis:\n  antipar f g\n\ngoal (1 subgoal):\n 1. ide (g \\<cdot> f) \\<Longrightarrow>\n    antipar f g \\<and>\n    compose (Dom f) (Fun g) (Fun f) = (\\<lambda>x\\<in>Dom f. x)", "moreover"], ["proof (state)\nthis:\n  antipar f g\n\ngoal (1 subgoal):\n 1. ide (g \\<cdot> f) \\<Longrightarrow>\n    antipar f g \\<and>\n    compose (Dom f) (Fun g) (Fun f) = (\\<lambda>x\\<in>Dom f. x)", "have \"compose (Dom f) (Fun g) (Fun f) = (\\<lambda>x \\<in> Dom f. x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. compose (Dom f) (Fun g) (Fun f) = (\\<lambda>x\\<in>Dom f. x)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. compose (Dom f) (Fun g) (Fun f) x = (\\<lambda>x\\<in>Dom f. x) x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. compose (Dom f) (Fun g) (Fun f) x = (\\<lambda>x\\<in>Dom f. x) x", "have \"x \\<notin> Dom f \\<Longrightarrow> compose (Dom f) (Fun g) (Fun f) x = (\\<lambda>x \\<in> Dom f. x) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> Dom f \\<Longrightarrow>\n    compose (Dom f) (Fun g) (Fun f) x = (\\<lambda>x\\<in>Dom f. x) x", "by (simp add: compose_def)"], ["proof (state)\nthis:\n  x \\<notin> Dom f \\<Longrightarrow>\n  compose (Dom f) (Fun g) (Fun f) x = (\\<lambda>x\\<in>Dom f. x) x\n\ngoal (1 subgoal):\n 1. \\<And>x. compose (Dom f) (Fun g) (Fun f) x = (\\<lambda>x\\<in>Dom f. x) x", "moreover"], ["proof (state)\nthis:\n  x \\<notin> Dom f \\<Longrightarrow>\n  compose (Dom f) (Fun g) (Fun f) x = (\\<lambda>x\\<in>Dom f. x) x\n\ngoal (1 subgoal):\n 1. \\<And>x. compose (Dom f) (Fun g) (Fun f) x = (\\<lambda>x\\<in>Dom f. x) x", "have \"x \\<in> Dom f \\<Longrightarrow>\n                         compose (Dom f) (Fun g) (Fun f) x = (\\<lambda>x \\<in> Dom f. x) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Dom f \\<Longrightarrow>\n    compose (Dom f) (Fun g) (Fun f) x = (\\<lambda>x\\<in>Dom f. x) x", "using fg 1 Fun_comp"], ["proof (prove)\nusing this:\n  ide (g \\<cdot> f)\n  antipar f g\n  seq ?g ?f \\<Longrightarrow>\n  Fun (?g \\<cdot> ?f) = restrict (Fun ?g \\<circ> Fun ?f) (Dom ?f)\n\ngoal (1 subgoal):\n 1. x \\<in> Dom f \\<Longrightarrow>\n    compose (Dom f) (Fun g) (Fun f) x = (\\<lambda>x\\<in>Dom f. x) x", "by (metis Fun_comp Fun_ide compose_eq' ide_compE)"], ["proof (state)\nthis:\n  x \\<in> Dom f \\<Longrightarrow>\n  compose (Dom f) (Fun g) (Fun f) x = (\\<lambda>x\\<in>Dom f. x) x\n\ngoal (1 subgoal):\n 1. \\<And>x. compose (Dom f) (Fun g) (Fun f) x = (\\<lambda>x\\<in>Dom f. x) x", "ultimately"], ["proof (chain)\npicking this:\n  x \\<notin> Dom f \\<Longrightarrow>\n  compose (Dom f) (Fun g) (Fun f) x = (\\<lambda>x\\<in>Dom f. x) x\n  x \\<in> Dom f \\<Longrightarrow>\n  compose (Dom f) (Fun g) (Fun f) x = (\\<lambda>x\\<in>Dom f. x) x", "show \"compose (Dom f) (Fun g) (Fun f) x = (\\<lambda>x \\<in> Dom f. x) x\""], ["proof (prove)\nusing this:\n  x \\<notin> Dom f \\<Longrightarrow>\n  compose (Dom f) (Fun g) (Fun f) x = (\\<lambda>x\\<in>Dom f. x) x\n  x \\<in> Dom f \\<Longrightarrow>\n  compose (Dom f) (Fun g) (Fun f) x = (\\<lambda>x\\<in>Dom f. x) x\n\ngoal (1 subgoal):\n 1. compose (Dom f) (Fun g) (Fun f) x = (\\<lambda>x\\<in>Dom f. x) x", "by auto"], ["proof (state)\nthis:\n  compose (Dom f) (Fun g) (Fun f) x = (\\<lambda>x\\<in>Dom f. x) x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  compose (Dom f) (Fun g) (Fun f) = (\\<lambda>x\\<in>Dom f. x)\n\ngoal (1 subgoal):\n 1. ide (g \\<cdot> f) \\<Longrightarrow>\n    antipar f g \\<and>\n    compose (Dom f) (Fun g) (Fun f) = (\\<lambda>x\\<in>Dom f. x)", "ultimately"], ["proof (chain)\npicking this:\n  antipar f g\n  compose (Dom f) (Fun g) (Fun f) = (\\<lambda>x\\<in>Dom f. x)", "show ?thesis"], ["proof (prove)\nusing this:\n  antipar f g\n  compose (Dom f) (Fun g) (Fun f) = (\\<lambda>x\\<in>Dom f. x)\n\ngoal (1 subgoal):\n 1. antipar f g \\<and>\n    compose (Dom f) (Fun g) (Fun f) = (\\<lambda>x\\<in>Dom f. x)", "by auto"], ["proof (state)\nthis:\n  antipar f g \\<and>\n  compose (Dom f) (Fun g) (Fun f) = (\\<lambda>x\\<in>Dom f. x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ide (g \\<cdot> f) \\<Longrightarrow>\n  antipar f g \\<and>\n  compose (Dom f) (Fun g) (Fun f) = (\\<lambda>x\\<in>Dom f. x)\n\ngoal (1 subgoal):\n 1. antipar f g \\<and>\n    compose (Dom f) (Fun g) (Fun f) =\n    (\\<lambda>x\\<in>Dom f. x) \\<Longrightarrow>\n    ide (g \\<cdot> f)", "show \"antipar f g \\<and> compose (Dom f) (Fun g) (Fun f) = (\\<lambda>x \\<in> Dom f. x) \\<Longrightarrow> ide (g \\<cdot> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. antipar f g \\<and>\n    compose (Dom f) (Fun g) (Fun f) =\n    (\\<lambda>x\\<in>Dom f. x) \\<Longrightarrow>\n    ide (g \\<cdot> f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. antipar f g \\<and>\n    compose (Dom f) (Fun g) (Fun f) =\n    (\\<lambda>x\\<in>Dom f. x) \\<Longrightarrow>\n    ide (g \\<cdot> f)", "assume fg: \"antipar f g \\<and> compose (Dom f) (Fun g) (Fun f) = (\\<lambda>x \\<in> Dom f. x)\""], ["proof (state)\nthis:\n  antipar f g \\<and>\n  compose (Dom f) (Fun g) (Fun f) = (\\<lambda>x\\<in>Dom f. x)\n\ngoal (1 subgoal):\n 1. antipar f g \\<and>\n    compose (Dom f) (Fun g) (Fun f) =\n    (\\<lambda>x\\<in>Dom f. x) \\<Longrightarrow>\n    ide (g \\<cdot> f)", "show \"ide (g \\<cdot> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide (g \\<cdot> f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ide (g \\<cdot> f)", "have 1: \"arr (g \\<cdot> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq g f", "using fg"], ["proof (prove)\nusing this:\n  antipar f g \\<and>\n  compose (Dom f) (Fun g) (Fun f) = (\\<lambda>x\\<in>Dom f. x)\n\ngoal (1 subgoal):\n 1. seq g f", "by auto"], ["proof (state)\nthis:\n  seq g f\n\ngoal (1 subgoal):\n 1. ide (g \\<cdot> f)", "moreover"], ["proof (state)\nthis:\n  seq g f\n\ngoal (1 subgoal):\n 1. ide (g \\<cdot> f)", "have \"Dom (g \\<cdot> f) = Cod (S g f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Dom (g \\<cdot> f) = Cod (g \\<cdot> f)", "using fg 1"], ["proof (prove)\nusing this:\n  antipar f g \\<and>\n  compose (Dom f) (Fun g) (Fun f) = (\\<lambda>x\\<in>Dom f. x)\n  seq g f\n\ngoal (1 subgoal):\n 1. Dom (g \\<cdot> f) = Cod (g \\<cdot> f)", "by force"], ["proof (state)\nthis:\n  Dom (g \\<cdot> f) = Cod (g \\<cdot> f)\n\ngoal (1 subgoal):\n 1. ide (g \\<cdot> f)", "moreover"], ["proof (state)\nthis:\n  Dom (g \\<cdot> f) = Cod (g \\<cdot> f)\n\ngoal (1 subgoal):\n 1. ide (g \\<cdot> f)", "have \"Fun (g \\<cdot> f) = (\\<lambda>x \\<in> Dom (g \\<cdot> f). x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (g \\<cdot> f) = (\\<lambda>x\\<in>Dom (g \\<cdot> f). x)", "using fg 1"], ["proof (prove)\nusing this:\n  antipar f g \\<and>\n  compose (Dom f) (Fun g) (Fun f) = (\\<lambda>x\\<in>Dom f. x)\n  seq g f\n\ngoal (1 subgoal):\n 1. Fun (g \\<cdot> f) = (\\<lambda>x\\<in>Dom (g \\<cdot> f). x)", "by force"], ["proof (state)\nthis:\n  Fun (g \\<cdot> f) = (\\<lambda>x\\<in>Dom (g \\<cdot> f). x)\n\ngoal (1 subgoal):\n 1. ide (g \\<cdot> f)", "ultimately"], ["proof (chain)\npicking this:\n  seq g f\n  Dom (g \\<cdot> f) = Cod (g \\<cdot> f)\n  Fun (g \\<cdot> f) = (\\<lambda>x\\<in>Dom (g \\<cdot> f). x)", "show ?thesis"], ["proof (prove)\nusing this:\n  seq g f\n  Dom (g \\<cdot> f) = Cod (g \\<cdot> f)\n  Fun (g \\<cdot> f) = (\\<lambda>x\\<in>Dom (g \\<cdot> f). x)\n\ngoal (1 subgoal):\n 1. ide (g \\<cdot> f)", "using 1 ide_char"], ["proof (prove)\nusing this:\n  seq g f\n  Dom (g \\<cdot> f) = Cod (g \\<cdot> f)\n  Fun (g \\<cdot> f) = (\\<lambda>x\\<in>Dom (g \\<cdot> f). x)\n  seq g f\n  arr ?f \\<Longrightarrow>\n  ide ?f = (Dom ?f = Cod ?f \\<and> Fun ?f = (\\<lambda>x\\<in>Dom ?f. x))\n\ngoal (1 subgoal):\n 1. ide (g \\<cdot> f)", "by blast"], ["proof (state)\nthis:\n  ide (g \\<cdot> f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ide (g \\<cdot> f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  antipar f g \\<and>\n  compose (Dom f) (Fun g) (Fun f) =\n  (\\<lambda>x\\<in>Dom f. x) \\<Longrightarrow>\n  ide (g \\<cdot> f)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n      Antiparallel arrows @{term f} and @{term g} are inverses if the functions\n      they induce are inverses.\n\\<close>"], ["", "lemma inverse_arrows_char:\n    shows \"inverse_arrows f g \\<longleftrightarrow>\n             antipar f g \\<and> compose (Dom f) (Fun g) (Fun f) = (\\<lambda>x \\<in> Dom f. x)\n                         \\<and> compose (Dom g) (Fun f) (Fun g) = (\\<lambda>y \\<in> Dom g. y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_arrows f g =\n    (antipar f g \\<and>\n     compose (Dom f) (Fun g) (Fun f) = (\\<lambda>x\\<in>Dom f. x) \\<and>\n     compose (Dom g) (Fun f) (Fun g) = (\\<lambda>y\\<in>Dom g. y))", "using section_retraction_char"], ["proof (prove)\nusing this:\n  ide (?g \\<cdot> ?f) =\n  (antipar ?f ?g \\<and>\n   compose (Dom ?f) (Fun ?g) (Fun ?f) = (\\<lambda>x\\<in>Dom ?f. x))\n\ngoal (1 subgoal):\n 1. inverse_arrows f g =\n    (antipar f g \\<and>\n     compose (Dom f) (Fun g) (Fun f) = (\\<lambda>x\\<in>Dom f. x) \\<and>\n     compose (Dom g) (Fun f) (Fun g) = (\\<lambda>y\\<in>Dom g. y))", "by blast"], ["", "text\\<open>\n      An arrow is an isomorphism if and only if the function it induces is a bijection.\n\\<close>"], ["", "lemma iso_char:\n    shows \"iso f \\<longleftrightarrow> arr f \\<and> bij_betw (Fun f) (Dom f) (Cod f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.iso f = (arr f \\<and> bij_betw (Fun f) (Dom f) (Cod f))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.iso f = (arr f \\<and> bij_betw (Fun f) (Dom f) (Cod f))", "have \"iso f \\<longleftrightarrow> section f \\<and> retraction f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.iso f = (section f \\<and> retraction f)", "using iso_iff_section_and_retraction"], ["proof (prove)\nusing this:\n  local.iso ?f = (section ?f \\<and> retraction ?f)\n\ngoal (1 subgoal):\n 1. local.iso f = (section f \\<and> retraction f)", "by auto"], ["proof (state)\nthis:\n  local.iso f = (section f \\<and> retraction f)\n\ngoal (1 subgoal):\n 1. local.iso f = (arr f \\<and> bij_betw (Fun f) (Dom f) (Cod f))", "also"], ["proof (state)\nthis:\n  local.iso f = (section f \\<and> retraction f)\n\ngoal (1 subgoal):\n 1. local.iso f = (arr f \\<and> bij_betw (Fun f) (Dom f) (Cod f))", "have \"... \\<longleftrightarrow> arr f \\<and> inj_on (Fun f) (Dom f) \\<and> Img f = Cod f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (section f \\<and> retraction f) =\n    (arr f \\<and> inj_on (Fun f) (Dom f) \\<and> Img f = Cod f)", "using section_char retraction_char"], ["proof (prove)\nusing this:\n  section ?f =\n  (arr ?f \\<and>\n   (Dom ?f = {} \\<longrightarrow> Cod ?f = {}) \\<and>\n   inj_on (Fun ?f) (Dom ?f))\n  retraction ?g = (arr ?g \\<and> Img ?g = Cod ?g)\n\ngoal (1 subgoal):\n 1. (section f \\<and> retraction f) =\n    (arr f \\<and> inj_on (Fun f) (Dom f) \\<and> Img f = Cod f)", "by force"], ["proof (state)\nthis:\n  (section f \\<and> retraction f) =\n  (arr f \\<and> inj_on (Fun f) (Dom f) \\<and> Img f = Cod f)\n\ngoal (1 subgoal):\n 1. local.iso f = (arr f \\<and> bij_betw (Fun f) (Dom f) (Cod f))", "also"], ["proof (state)\nthis:\n  (section f \\<and> retraction f) =\n  (arr f \\<and> inj_on (Fun f) (Dom f) \\<and> Img f = Cod f)\n\ngoal (1 subgoal):\n 1. local.iso f = (arr f \\<and> bij_betw (Fun f) (Dom f) (Cod f))", "have \"... \\<longleftrightarrow> arr f \\<and> bij_betw (Fun f) (Dom f) (Cod f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (arr f \\<and> inj_on (Fun f) (Dom f) \\<and> Img f = Cod f) =\n    (arr f \\<and> bij_betw (Fun f) (Dom f) (Cod f))", "using inj_on_def bij_betw_def [of \"Fun f\" \"Dom f\" \"Cod f\"]"], ["proof (prove)\nusing this:\n  inj_on ?f ?A =\n  (\\<forall>x\\<in>?A.\n      \\<forall>y\\<in>?A. ?f x = ?f y \\<longrightarrow> x = y)\n  bij_betw (Fun f) (Dom f) (Cod f) =\n  (inj_on (Fun f) (Dom f) \\<and> Img f = Cod f)\n\ngoal (1 subgoal):\n 1. (arr f \\<and> inj_on (Fun f) (Dom f) \\<and> Img f = Cod f) =\n    (arr f \\<and> bij_betw (Fun f) (Dom f) (Cod f))", "by meson"], ["proof (state)\nthis:\n  (arr f \\<and> inj_on (Fun f) (Dom f) \\<and> Img f = Cod f) =\n  (arr f \\<and> bij_betw (Fun f) (Dom f) (Cod f))\n\ngoal (1 subgoal):\n 1. local.iso f = (arr f \\<and> bij_betw (Fun f) (Dom f) (Cod f))", "finally"], ["proof (chain)\npicking this:\n  local.iso f = (arr f \\<and> bij_betw (Fun f) (Dom f) (Cod f))", "show ?thesis"], ["proof (prove)\nusing this:\n  local.iso f = (arr f \\<and> bij_betw (Fun f) (Dom f) (Cod f))\n\ngoal (1 subgoal):\n 1. local.iso f = (arr f \\<and> bij_betw (Fun f) (Dom f) (Cod f))", "by auto"], ["proof (state)\nthis:\n  local.iso f = (arr f \\<and> bij_betw (Fun f) (Dom f) (Cod f))\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n      The inverse of an isomorphism is constructed by inverting the induced function.\n\\<close>"], ["", "lemma inv_char:\n    assumes \"iso f\"\n    shows \"inv f = mkArr (Cod f) (Dom f) (inv_into (Dom f) (Fun f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.inv f = mkArr (Cod f) (Dom f) (inv_into (Dom f) (Fun f))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. local.inv f = mkArr (Cod f) (Dom f) (inv_into (Dom f) (Fun f))", "let ?g = \"mkArr (Cod f) (Dom f) (inv_into (Dom f) (Fun f))\""], ["proof (state)\ngoal (1 subgoal):\n 1. local.inv f = mkArr (Cod f) (Dom f) (inv_into (Dom f) (Fun f))", "have \"ide (f \\<cdot> ?g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide (f \\<cdot> mkArr (Cod f) (Dom f) (inv_into (Dom f) (Fun f)))", "using assms iso_is_retraction retraction_char retraction_if_Img_eq_Cod"], ["proof (prove)\nusing this:\n  local.iso f\n  local.iso ?f \\<Longrightarrow> retraction ?f\n  retraction ?g = (arr ?g \\<and> Img ?g = Cod ?g)\n  \\<lbrakk>arr ?g; Img ?g = Cod ?g\\<rbrakk> \\<Longrightarrow> retraction ?g\n  \\<lbrakk>arr ?g; Img ?g = Cod ?g\\<rbrakk>\n  \\<Longrightarrow> ide (?g \\<cdot>\n                         mkArr (Cod ?g) (Dom ?g)\n                          (inv_into (Dom ?g) (Fun ?g)))\n\ngoal (1 subgoal):\n 1. ide (f \\<cdot> mkArr (Cod f) (Dom f) (inv_into (Dom f) (Fun f)))", "by simp"], ["proof (state)\nthis:\n  ide (f \\<cdot> mkArr (Cod f) (Dom f) (inv_into (Dom f) (Fun f)))\n\ngoal (1 subgoal):\n 1. local.inv f = mkArr (Cod f) (Dom f) (inv_into (Dom f) (Fun f))", "moreover"], ["proof (state)\nthis:\n  ide (f \\<cdot> mkArr (Cod f) (Dom f) (inv_into (Dom f) (Fun f)))\n\ngoal (1 subgoal):\n 1. local.inv f = mkArr (Cod f) (Dom f) (inv_into (Dom f) (Fun f))", "have \"ide (?g \\<cdot> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide (mkArr (Cod f) (Dom f) (inv_into (Dom f) (Fun f)) \\<cdot> f)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. ide (mkArr (Cod f) (Dom f) (inv_into (Dom f) (Fun f)) \\<cdot> f)", "let ?g' = \"mkArr (Cod f) (Dom f)\n                         (\\<lambda>y. if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n                              else SOME x. x \\<in> Dom f)\""], ["proof (state)\ngoal (1 subgoal):\n 1. ide (mkArr (Cod f) (Dom f) (inv_into (Dom f) (Fun f)) \\<cdot> f)", "have 1: \"ide (?g' \\<cdot> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide (mkArr (Cod f) (Dom f)\n          (\\<lambda>y.\n              if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n              else SOME x. x \\<in> Dom f) \\<cdot>\n         f)", "using assms iso_is_section section_char section_if_inj"], ["proof (prove)\nusing this:\n  local.iso f\n  local.iso ?f \\<Longrightarrow> section ?f\n  section ?f =\n  (arr ?f \\<and>\n   (Dom ?f = {} \\<longrightarrow> Cod ?f = {}) \\<and>\n   inj_on (Fun ?f) (Dom ?f))\n  \\<lbrakk>arr ?f; inj_on (Fun ?f) (Dom ?f);\n   Dom ?f = {} \\<longrightarrow> Cod ?f = {}\\<rbrakk>\n  \\<Longrightarrow> section ?f\n  \\<lbrakk>arr ?f; inj_on (Fun ?f) (Dom ?f);\n   Dom ?f = {} \\<longrightarrow> Cod ?f = {}\\<rbrakk>\n  \\<Longrightarrow> ide (mkArr (Cod ?f) (Dom ?f)\n                          (\\<lambda>y.\n                              if y \\<in> Img ?f\n                              then SOME x.\nx \\<in> Dom ?f \\<and> Fun ?f x = y\n                              else SOME x. x \\<in> Dom ?f) \\<cdot>\n                         ?f)\n\ngoal (1 subgoal):\n 1. ide (mkArr (Cod f) (Dom f)\n          (\\<lambda>y.\n              if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n              else SOME x. x \\<in> Dom f) \\<cdot>\n         f)", "by simp"], ["proof (state)\nthis:\n  ide (mkArr (Cod f) (Dom f)\n        (\\<lambda>y.\n            if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n            else SOME x. x \\<in> Dom f) \\<cdot>\n       f)\n\ngoal (1 subgoal):\n 1. ide (mkArr (Cod f) (Dom f) (inv_into (Dom f) (Fun f)) \\<cdot> f)", "moreover"], ["proof (state)\nthis:\n  ide (mkArr (Cod f) (Dom f)\n        (\\<lambda>y.\n            if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n            else SOME x. x \\<in> Dom f) \\<cdot>\n       f)\n\ngoal (1 subgoal):\n 1. ide (mkArr (Cod f) (Dom f) (inv_into (Dom f) (Fun f)) \\<cdot> f)", "have \"?g' = ?g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mkArr (Cod f) (Dom f)\n     (\\<lambda>y.\n         if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n         else SOME x. x \\<in> Dom f) =\n    mkArr (Cod f) (Dom f) (inv_into (Dom f) (Fun f))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. arr (mkArr (Cod f) (Dom f)\n          (\\<lambda>y.\n              if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n              else SOME x. x \\<in> Dom f))\n 2. \\<And>x.\n       x \\<in> Cod f \\<Longrightarrow>\n       (if x \\<in> Img f then SOME xa. xa \\<in> Dom f \\<and> Fun f xa = x\n        else SOME x. x \\<in> Dom f) =\n       inv_into (Dom f) (Fun f) x", "show \"arr ?g'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (mkArr (Cod f) (Dom f)\n          (\\<lambda>y.\n              if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n              else SOME x. x \\<in> Dom f))", "using 1 ide_compE"], ["proof (prove)\nusing this:\n  ide (mkArr (Cod f) (Dom f)\n        (\\<lambda>y.\n            if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n            else SOME x. x \\<in> Dom f) \\<cdot>\n       f)\n  \\<lbrakk>ide (?g \\<cdot> ?f);\n   \\<lbrakk>seq ?g ?f; seq ?f ?g; ?g \\<cdot> ?f = local.dom ?f;\n    ?g \\<cdot> ?f = cod ?g\\<rbrakk>\n   \\<Longrightarrow> ?T\\<rbrakk>\n  \\<Longrightarrow> ?T\n\ngoal (1 subgoal):\n 1. arr (mkArr (Cod f) (Dom f)\n          (\\<lambda>y.\n              if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n              else SOME x. x \\<in> Dom f))", "by blast"], ["proof (state)\nthis:\n  arr (mkArr (Cod f) (Dom f)\n        (\\<lambda>y.\n            if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n            else SOME x. x \\<in> Dom f))\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       x \\<in> Cod f \\<Longrightarrow>\n       (if x \\<in> Img f then SOME xa. xa \\<in> Dom f \\<and> Fun f xa = x\n        else SOME x. x \\<in> Dom f) =\n       inv_into (Dom f) (Fun f) x", "show \"\\<And>y. y \\<in> Cod f \\<Longrightarrow> (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n                                                  else SOME x. x \\<in> Dom f)\n                                     = inv_into (Dom f) (Fun f) y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> Cod f \\<Longrightarrow>\n       (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n        else SOME x. x \\<in> Dom f) =\n       inv_into (Dom f) (Fun f) y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> Cod f \\<Longrightarrow>\n       (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n        else SOME x. x \\<in> Dom f) =\n       inv_into (Dom f) (Fun f) y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> Cod f \\<Longrightarrow>\n       (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n        else SOME x. x \\<in> Dom f) =\n       inv_into (Dom f) (Fun f) y", "assume \"y \\<in> Cod f\""], ["proof (state)\nthis:\n  y \\<in> Cod f\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> Cod f \\<Longrightarrow>\n       (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n        else SOME x. x \\<in> Dom f) =\n       inv_into (Dom f) (Fun f) y", "hence \"y \\<in> Img f\""], ["proof (prove)\nusing this:\n  y \\<in> Cod f\n\ngoal (1 subgoal):\n 1. y \\<in> Img f", "using assms iso_is_retraction retraction_char"], ["proof (prove)\nusing this:\n  y \\<in> Cod f\n  local.iso f\n  local.iso ?f \\<Longrightarrow> retraction ?f\n  retraction ?g = (arr ?g \\<and> Img ?g = Cod ?g)\n\ngoal (1 subgoal):\n 1. y \\<in> Img f", "by metis"], ["proof (state)\nthis:\n  y \\<in> Img f\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       y \\<in> Cod f \\<Longrightarrow>\n       (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n        else SOME x. x \\<in> Dom f) =\n       inv_into (Dom f) (Fun f) y", "thus \"(if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n                   else SOME x. x \\<in> Dom f)\n                     = inv_into (Dom f) (Fun f) y\""], ["proof (prove)\nusing this:\n  y \\<in> Img f\n\ngoal (1 subgoal):\n 1. (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n     else SOME x. x \\<in> Dom f) =\n    inv_into (Dom f) (Fun f) y", "using inv_into_def"], ["proof (prove)\nusing this:\n  y \\<in> Img f\n  inv_into ?A ?f = (\\<lambda>x. SOME y. y \\<in> ?A \\<and> ?f y = x)\n\ngoal (1 subgoal):\n 1. (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n     else SOME x. x \\<in> Dom f) =\n    inv_into (Dom f) (Fun f) y", "by metis"], ["proof (state)\nthis:\n  (if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n   else SOME x. x \\<in> Dom f) =\n  inv_into (Dom f) (Fun f) y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ?y \\<in> Cod f \\<Longrightarrow>\n  (if ?y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = ?y\n   else SOME x. x \\<in> Dom f) =\n  inv_into (Dom f) (Fun f) ?y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mkArr (Cod f) (Dom f)\n   (\\<lambda>y.\n       if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n       else SOME x. x \\<in> Dom f) =\n  mkArr (Cod f) (Dom f) (inv_into (Dom f) (Fun f))\n\ngoal (1 subgoal):\n 1. ide (mkArr (Cod f) (Dom f) (inv_into (Dom f) (Fun f)) \\<cdot> f)", "ultimately"], ["proof (chain)\npicking this:\n  ide (mkArr (Cod f) (Dom f)\n        (\\<lambda>y.\n            if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n            else SOME x. x \\<in> Dom f) \\<cdot>\n       f)\n  mkArr (Cod f) (Dom f)\n   (\\<lambda>y.\n       if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n       else SOME x. x \\<in> Dom f) =\n  mkArr (Cod f) (Dom f) (inv_into (Dom f) (Fun f))", "show ?thesis"], ["proof (prove)\nusing this:\n  ide (mkArr (Cod f) (Dom f)\n        (\\<lambda>y.\n            if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n            else SOME x. x \\<in> Dom f) \\<cdot>\n       f)\n  mkArr (Cod f) (Dom f)\n   (\\<lambda>y.\n       if y \\<in> Img f then SOME x. x \\<in> Dom f \\<and> Fun f x = y\n       else SOME x. x \\<in> Dom f) =\n  mkArr (Cod f) (Dom f) (inv_into (Dom f) (Fun f))\n\ngoal (1 subgoal):\n 1. ide (mkArr (Cod f) (Dom f) (inv_into (Dom f) (Fun f)) \\<cdot> f)", "by auto"], ["proof (state)\nthis:\n  ide (mkArr (Cod f) (Dom f) (inv_into (Dom f) (Fun f)) \\<cdot> f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ide (mkArr (Cod f) (Dom f) (inv_into (Dom f) (Fun f)) \\<cdot> f)\n\ngoal (1 subgoal):\n 1. local.inv f = mkArr (Cod f) (Dom f) (inv_into (Dom f) (Fun f))", "ultimately"], ["proof (chain)\npicking this:\n  ide (f \\<cdot> mkArr (Cod f) (Dom f) (inv_into (Dom f) (Fun f)))\n  ide (mkArr (Cod f) (Dom f) (inv_into (Dom f) (Fun f)) \\<cdot> f)", "have \"inverse_arrows f ?g\""], ["proof (prove)\nusing this:\n  ide (f \\<cdot> mkArr (Cod f) (Dom f) (inv_into (Dom f) (Fun f)))\n  ide (mkArr (Cod f) (Dom f) (inv_into (Dom f) (Fun f)) \\<cdot> f)\n\ngoal (1 subgoal):\n 1. inverse_arrows f (mkArr (Cod f) (Dom f) (inv_into (Dom f) (Fun f)))", "by auto"], ["proof (state)\nthis:\n  inverse_arrows f (mkArr (Cod f) (Dom f) (inv_into (Dom f) (Fun f)))\n\ngoal (1 subgoal):\n 1. local.inv f = mkArr (Cod f) (Dom f) (inv_into (Dom f) (Fun f))", "thus ?thesis"], ["proof (prove)\nusing this:\n  inverse_arrows f (mkArr (Cod f) (Dom f) (inv_into (Dom f) (Fun f)))\n\ngoal (1 subgoal):\n 1. local.inv f = mkArr (Cod f) (Dom f) (inv_into (Dom f) (Fun f))", "using inverse_unique"], ["proof (prove)\nusing this:\n  inverse_arrows f (mkArr (Cod f) (Dom f) (inv_into (Dom f) (Fun f)))\n  inverse_arrows ?f ?g \\<Longrightarrow> local.inv ?f = ?g\n\ngoal (1 subgoal):\n 1. local.inv f = mkArr (Cod f) (Dom f) (inv_into (Dom f) (Fun f))", "by blast"], ["proof (state)\nthis:\n  local.inv f = mkArr (Cod f) (Dom f) (inv_into (Dom f) (Fun f))\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma Fun_inv:\n    assumes \"iso f\"\n    shows \"Fun (inv f) = restrict (inv_into (Dom f) (Fun f)) (Cod f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (local.inv f) = restrict (inv_into (Dom f) (Fun f)) (Cod f)", "using assms inv_in_hom inv_char iso_inv_iso iso_is_arr Fun_mkArr"], ["proof (prove)\nusing this:\n  local.iso f\n  \\<lbrakk>local.iso ?f;\n   \\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>local.inv\n                                     ?f : ?b \\<rightarrow> ?a\\<guillemotright>\n  local.iso ?f \\<Longrightarrow>\n  local.inv ?f = mkArr (Cod ?f) (Dom ?f) (inv_into (Dom ?f) (Fun ?f))\n  local.iso ?f \\<Longrightarrow> local.iso (local.inv ?f)\n  local.iso ?f \\<Longrightarrow> arr ?f\n  arr (mkArr ?A ?B ?F) \\<Longrightarrow>\n  Fun (mkArr ?A ?B ?F) = restrict ?F ?A\n\ngoal (1 subgoal):\n 1. Fun (local.inv f) = restrict (inv_into (Dom f) (Fun f)) (Cod f)", "by metis"], ["", "subsection \"Monomorphisms and Epimorphisms\""], ["", "text\\<open>\n      An arrow is a monomorphism if and only if the function it induces is injective.\n\\<close>"], ["", "lemma mono_char:\n    shows \"mono f \\<longleftrightarrow> arr f \\<and> inj_on (Fun f) (Dom f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.mono f = (arr f \\<and> inj_on (Fun f) (Dom f))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. local.mono f \\<Longrightarrow> arr f \\<and> inj_on (Fun f) (Dom f)\n 2. arr f \\<and> inj_on (Fun f) (Dom f) \\<Longrightarrow> local.mono f", "assume f: \"mono f\""], ["proof (state)\nthis:\n  local.mono f\n\ngoal (2 subgoals):\n 1. local.mono f \\<Longrightarrow> arr f \\<and> inj_on (Fun f) (Dom f)\n 2. arr f \\<and> inj_on (Fun f) (Dom f) \\<Longrightarrow> local.mono f", "hence \"arr f\""], ["proof (prove)\nusing this:\n  local.mono f\n\ngoal (1 subgoal):\n 1. arr f", "using mono_def"], ["proof (prove)\nusing this:\n  local.mono f\n  local.mono ?f = (arr ?f \\<and> inj_on ((\\<cdot>) ?f) {g. seq ?f g})\n\ngoal (1 subgoal):\n 1. arr f", "by auto"], ["proof (state)\nthis:\n  arr f\n\ngoal (2 subgoals):\n 1. local.mono f \\<Longrightarrow> arr f \\<and> inj_on (Fun f) (Dom f)\n 2. arr f \\<and> inj_on (Fun f) (Dom f) \\<Longrightarrow> local.mono f", "moreover"], ["proof (state)\nthis:\n  arr f\n\ngoal (2 subgoals):\n 1. local.mono f \\<Longrightarrow> arr f \\<and> inj_on (Fun f) (Dom f)\n 2. arr f \\<and> inj_on (Fun f) (Dom f) \\<Longrightarrow> local.mono f", "have \"inj_on (Fun f) (Dom f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on (Fun f) (Dom f)", "proof (intro inj_onI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> Dom f; y \\<in> Dom f; Fun f x = Fun f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "have 0: \"inj_on (S f) (hom unity (dom f))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inj_on ((\\<cdot>) f) (hom unity (local.dom f))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. inj_on ((\\<cdot>) f) (hom unity (local.dom f))", "have \"hom unity (dom f) \\<subseteq> {g. seq f g}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. hom unity (local.dom f) \\<subseteq> {g. seq f g}", "using f mono_def arrI"], ["proof (prove)\nusing this:\n  local.mono f\n  local.mono ?f = (arr ?f \\<and> inj_on ((\\<cdot>) ?f) {g. seq ?f g})\n  \\<guillemotleft>?f : ?a \\<rightarrow> ?b\\<guillemotright> \\<Longrightarrow>\n  arr ?f\n\ngoal (1 subgoal):\n 1. hom unity (local.dom f) \\<subseteq> {g. seq f g}", "by auto"], ["proof (state)\nthis:\n  hom unity (local.dom f) \\<subseteq> {g. seq f g}\n\ngoal (1 subgoal):\n 1. inj_on ((\\<cdot>) f) (hom unity (local.dom f))", "hence \"\\<exists>A. hom unity (dom f) \\<subseteq> A \\<and> inj_on (S f) A\""], ["proof (prove)\nusing this:\n  hom unity (local.dom f) \\<subseteq> {g. seq f g}\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       hom unity (local.dom f) \\<subseteq> A \\<and> inj_on ((\\<cdot>) f) A", "using f mono_def"], ["proof (prove)\nusing this:\n  hom unity (local.dom f) \\<subseteq> {g. seq f g}\n  local.mono f\n  local.mono ?f = (arr ?f \\<and> inj_on ((\\<cdot>) ?f) {g. seq ?f g})\n\ngoal (1 subgoal):\n 1. \\<exists>A.\n       hom unity (local.dom f) \\<subseteq> A \\<and> inj_on ((\\<cdot>) f) A", "by auto"], ["proof (state)\nthis:\n  \\<exists>A.\n     hom unity (local.dom f) \\<subseteq> A \\<and> inj_on ((\\<cdot>) f) A\n\ngoal (1 subgoal):\n 1. inj_on ((\\<cdot>) f) (hom unity (local.dom f))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>A.\n     hom unity (local.dom f) \\<subseteq> A \\<and> inj_on ((\\<cdot>) f) A\n\ngoal (1 subgoal):\n 1. inj_on ((\\<cdot>) f) (hom unity (local.dom f))", "by (meson subset_inj_on)"], ["proof (state)\nthis:\n  inj_on ((\\<cdot>) f) (hom unity (local.dom f))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on ((\\<cdot>) f) (hom unity (local.dom f))\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> Dom f; y \\<in> Dom f; Fun f x = Fun f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "fix x x'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> Dom f; y \\<in> Dom f; Fun f x = Fun f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "assume x: \"x \\<in> Dom f\" and x': \"x' \\<in> Dom f\" and xx': \"Fun f x = Fun f x'\""], ["proof (state)\nthis:\n  x \\<in> Dom f\n  x' \\<in> Dom f\n  Fun f x = Fun f x'\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> Dom f; y \\<in> Dom f; Fun f x = Fun f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "have 1: \"mkPoint (dom f) x \\<in> hom unity (dom f) \\<and>\n                 mkPoint (dom f) x' \\<in> hom unity (dom f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mkPoint (local.dom f) x \\<in> hom unity (local.dom f) \\<and>\n    mkPoint (local.dom f) x' \\<in> hom unity (local.dom f)", "using x x' \\<open>arr f\\<close> mkPoint_in_hom"], ["proof (prove)\nusing this:\n  x \\<in> Dom f\n  x' \\<in> Dom f\n  arr f\n  \\<lbrakk>ide ?a; ?t \\<in> local.set ?a\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>mkPoint ?a\n                                     ?t : unity \\<rightarrow> ?a\\<guillemotright>\n\ngoal (1 subgoal):\n 1. mkPoint (local.dom f) x \\<in> hom unity (local.dom f) \\<and>\n    mkPoint (local.dom f) x' \\<in> hom unity (local.dom f)", "by simp"], ["proof (state)\nthis:\n  mkPoint (local.dom f) x \\<in> hom unity (local.dom f) \\<and>\n  mkPoint (local.dom f) x' \\<in> hom unity (local.dom f)\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> Dom f; y \\<in> Dom f; Fun f x = Fun f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "have \"f \\<cdot> mkPoint (dom f) x = f \\<cdot> mkPoint (dom f) x'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<cdot> mkPoint (local.dom f) x = f \\<cdot> mkPoint (local.dom f) x'", "using \\<open>arr f\\<close> x x' xx' comp_arr_mkPoint"], ["proof (prove)\nusing this:\n  arr f\n  x \\<in> Dom f\n  x' \\<in> Dom f\n  Fun f x = Fun f x'\n  \\<lbrakk>arr ?f; ?t \\<in> Dom ?f\\<rbrakk>\n  \\<Longrightarrow> ?f \\<cdot> mkPoint (local.dom ?f) ?t =\n                    mkPoint (cod ?f) (Fun ?f ?t)\n\ngoal (1 subgoal):\n 1. f \\<cdot> mkPoint (local.dom f) x = f \\<cdot> mkPoint (local.dom f) x'", "by simp"], ["proof (state)\nthis:\n  f \\<cdot> mkPoint (local.dom f) x = f \\<cdot> mkPoint (local.dom f) x'\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> Dom f; y \\<in> Dom f; Fun f x = Fun f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "hence \"mkPoint (dom f) x = mkPoint (dom f) x'\""], ["proof (prove)\nusing this:\n  f \\<cdot> mkPoint (local.dom f) x = f \\<cdot> mkPoint (local.dom f) x'\n\ngoal (1 subgoal):\n 1. mkPoint (local.dom f) x = mkPoint (local.dom f) x'", "using 0 1 inj_onD [of \"S f\" \"hom unity (dom f)\" \"mkPoint (dom f) x\"]"], ["proof (prove)\nusing this:\n  f \\<cdot> mkPoint (local.dom f) x = f \\<cdot> mkPoint (local.dom f) x'\n  inj_on ((\\<cdot>) f) (hom unity (local.dom f))\n  mkPoint (local.dom f) x \\<in> hom unity (local.dom f) \\<and>\n  mkPoint (local.dom f) x' \\<in> hom unity (local.dom f)\n  \\<lbrakk>inj_on ((\\<cdot>) f) (hom unity (local.dom f));\n   f \\<cdot> mkPoint (local.dom f) x = f \\<cdot> ?y;\n   mkPoint (local.dom f) x \\<in> hom unity (local.dom f);\n   ?y \\<in> hom unity (local.dom f)\\<rbrakk>\n  \\<Longrightarrow> mkPoint (local.dom f) x = ?y\n\ngoal (1 subgoal):\n 1. mkPoint (local.dom f) x = mkPoint (local.dom f) x'", "by simp"], ["proof (state)\nthis:\n  mkPoint (local.dom f) x = mkPoint (local.dom f) x'\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<in> Dom f; y \\<in> Dom f; Fun f x = Fun f y\\<rbrakk>\n       \\<Longrightarrow> x = y", "thus \"x = x'\""], ["proof (prove)\nusing this:\n  mkPoint (local.dom f) x = mkPoint (local.dom f) x'\n\ngoal (1 subgoal):\n 1. x = x'", "using \\<open>arr f\\<close> x x' img_mkPoint(2) img_mkPoint(2) ide_dom"], ["proof (prove)\nusing this:\n  mkPoint (local.dom f) x = mkPoint (local.dom f) x'\n  arr f\n  x \\<in> Dom f\n  x' \\<in> Dom f\n  \\<lbrakk>ide ?a; ?t \\<in> local.set ?a\\<rbrakk>\n  \\<Longrightarrow> img (mkPoint ?a ?t) = ?t\n  \\<lbrakk>ide ?a; ?t \\<in> local.set ?a\\<rbrakk>\n  \\<Longrightarrow> img (mkPoint ?a ?t) = ?t\n  arr ?f \\<Longrightarrow> ide (local.dom ?f)\n\ngoal (1 subgoal):\n 1. x = x'", "by metis"], ["proof (state)\nthis:\n  x = x'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  inj_on (Fun f) (Dom f)\n\ngoal (2 subgoals):\n 1. local.mono f \\<Longrightarrow> arr f \\<and> inj_on (Fun f) (Dom f)\n 2. arr f \\<and> inj_on (Fun f) (Dom f) \\<Longrightarrow> local.mono f", "ultimately"], ["proof (chain)\npicking this:\n  arr f\n  inj_on (Fun f) (Dom f)", "show \"arr f \\<and> inj_on (Fun f) (Dom f)\""], ["proof (prove)\nusing this:\n  arr f\n  inj_on (Fun f) (Dom f)\n\ngoal (1 subgoal):\n 1. arr f \\<and> inj_on (Fun f) (Dom f)", "by auto"], ["proof (state)\nthis:\n  arr f \\<and> inj_on (Fun f) (Dom f)\n\ngoal (1 subgoal):\n 1. arr f \\<and> inj_on (Fun f) (Dom f) \\<Longrightarrow> local.mono f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. arr f \\<and> inj_on (Fun f) (Dom f) \\<Longrightarrow> local.mono f", "assume f: \"arr f \\<and> inj_on (Fun f) (Dom f)\""], ["proof (state)\nthis:\n  arr f \\<and> inj_on (Fun f) (Dom f)\n\ngoal (1 subgoal):\n 1. arr f \\<and> inj_on (Fun f) (Dom f) \\<Longrightarrow> local.mono f", "show \"mono f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.mono f", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. arr f\n 2. \\<And>fa f'.\n       seq f fa \\<and>\n       seq f f' \\<and> f \\<cdot> fa = f \\<cdot> f' \\<Longrightarrow>\n       fa = f'", "show \"arr f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr f", "using f"], ["proof (prove)\nusing this:\n  arr f \\<and> inj_on (Fun f) (Dom f)\n\ngoal (1 subgoal):\n 1. arr f", "by auto"], ["proof (state)\nthis:\n  arr f\n\ngoal (1 subgoal):\n 1. \\<And>fa f'.\n       seq f fa \\<and>\n       seq f f' \\<and> f \\<cdot> fa = f \\<cdot> f' \\<Longrightarrow>\n       fa = f'", "show \"\\<And>g g'. seq f g \\<and> seq f g' \\<and> f \\<cdot> g = f \\<cdot> g' \\<Longrightarrow> g = g'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g g'.\n       seq f g \\<and>\n       seq f g' \\<and> f \\<cdot> g = f \\<cdot> g' \\<Longrightarrow>\n       g = g'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g g'.\n       seq f g \\<and>\n       seq f g' \\<and> f \\<cdot> g = f \\<cdot> g' \\<Longrightarrow>\n       g = g'", "fix g g'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g g'.\n       seq f g \\<and>\n       seq f g' \\<and> f \\<cdot> g = f \\<cdot> g' \\<Longrightarrow>\n       g = g'", "assume gg': \"seq f g \\<and> seq f g' \\<and> f \\<cdot> g = f \\<cdot> g'\""], ["proof (state)\nthis:\n  seq f g \\<and> seq f g' \\<and> f \\<cdot> g = f \\<cdot> g'\n\ngoal (1 subgoal):\n 1. \\<And>g g'.\n       seq f g \\<and>\n       seq f g' \\<and> f \\<cdot> g = f \\<cdot> g' \\<Longrightarrow>\n       g = g'", "show \"g = g'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g = g'", "proof (intro arr_eqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. par g g'\n 2. Fun g = Fun g'", "show par: \"par g g'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. par g g'", "using gg' dom_comp"], ["proof (prove)\nusing this:\n  seq f g \\<and> seq f g' \\<and> f \\<cdot> g = f \\<cdot> g'\n  seq ?g ?f \\<Longrightarrow> local.dom (?g \\<cdot> ?f) = local.dom ?f\n\ngoal (1 subgoal):\n 1. par g g'", "by (metis seqE)"], ["proof (state)\nthis:\n  par g g'\n\ngoal (1 subgoal):\n 1. Fun g = Fun g'", "show \"Fun g = Fun g'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun g = Fun g'", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. Fun g x = Fun g' x", "fix x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. Fun g x = Fun g' x", "have \"x \\<notin> Dom g \\<Longrightarrow> Fun g x = Fun g' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<notin> Dom g \\<Longrightarrow> Fun g x = Fun g' x", "using gg'"], ["proof (prove)\nusing this:\n  seq f g \\<and> seq f g' \\<and> f \\<cdot> g = f \\<cdot> g'\n\ngoal (1 subgoal):\n 1. x \\<notin> Dom g \\<Longrightarrow> Fun g x = Fun g' x", "by (simp add: par Fun_def)"], ["proof (state)\nthis:\n  x \\<notin> Dom g \\<Longrightarrow> Fun g x = Fun g' x\n\ngoal (1 subgoal):\n 1. \\<And>x. Fun g x = Fun g' x", "moreover"], ["proof (state)\nthis:\n  x \\<notin> Dom g \\<Longrightarrow> Fun g x = Fun g' x\n\ngoal (1 subgoal):\n 1. \\<And>x. Fun g x = Fun g' x", "have \"x \\<in> Dom g \\<Longrightarrow> Fun g x = Fun g' x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<in> Dom g \\<Longrightarrow> Fun g x = Fun g' x", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<in> Dom g \\<Longrightarrow> Fun g x = Fun g' x", "assume x: \"x \\<in> Dom g\""], ["proof (state)\nthis:\n  x \\<in> Dom g\n\ngoal (1 subgoal):\n 1. x \\<in> Dom g \\<Longrightarrow> Fun g x = Fun g' x", "have \"Fun f (Fun g x) = Fun (f \\<cdot> g) x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun f (Fun g x) = Fun (f \\<cdot> g) x", "using gg' x Fun_comp [of f g]"], ["proof (prove)\nusing this:\n  seq f g \\<and> seq f g' \\<and> f \\<cdot> g = f \\<cdot> g'\n  x \\<in> Dom g\n  seq f g \\<Longrightarrow>\n  Fun (f \\<cdot> g) = restrict (Fun f \\<circ> Fun g) (Dom g)\n\ngoal (1 subgoal):\n 1. Fun f (Fun g x) = Fun (f \\<cdot> g) x", "by auto"], ["proof (state)\nthis:\n  Fun f (Fun g x) = Fun (f \\<cdot> g) x\n\ngoal (1 subgoal):\n 1. x \\<in> Dom g \\<Longrightarrow> Fun g x = Fun g' x", "also"], ["proof (state)\nthis:\n  Fun f (Fun g x) = Fun (f \\<cdot> g) x\n\ngoal (1 subgoal):\n 1. x \\<in> Dom g \\<Longrightarrow> Fun g x = Fun g' x", "have \"... = Fun f (Fun g' x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (f \\<cdot> g) x = Fun f (Fun g' x)", "using par f gg' x monoE"], ["proof (prove)\nusing this:\n  par g g'\n  arr f \\<and> inj_on (Fun f) (Dom f)\n  seq f g \\<and> seq f g' \\<and> f \\<cdot> g = f \\<cdot> g'\n  x \\<in> Dom g\n  \\<lbrakk>local.mono ?g; seq ?g ?f; seq ?g ?f';\n   ?g \\<cdot> ?f = ?g \\<cdot> ?f'\\<rbrakk>\n  \\<Longrightarrow> ?f' = ?f\n\ngoal (1 subgoal):\n 1. Fun (f \\<cdot> g) x = Fun f (Fun g' x)", "by simp"], ["proof (state)\nthis:\n  Fun (f \\<cdot> g) x = Fun f (Fun g' x)\n\ngoal (1 subgoal):\n 1. x \\<in> Dom g \\<Longrightarrow> Fun g x = Fun g' x", "finally"], ["proof (chain)\npicking this:\n  Fun f (Fun g x) = Fun f (Fun g' x)", "have \"Fun f (Fun g x) = Fun f (Fun g' x)\""], ["proof (prove)\nusing this:\n  Fun f (Fun g x) = Fun f (Fun g' x)\n\ngoal (1 subgoal):\n 1. Fun f (Fun g x) = Fun f (Fun g' x)", "by auto"], ["proof (state)\nthis:\n  Fun f (Fun g x) = Fun f (Fun g' x)\n\ngoal (1 subgoal):\n 1. x \\<in> Dom g \\<Longrightarrow> Fun g x = Fun g' x", "moreover"], ["proof (state)\nthis:\n  Fun f (Fun g x) = Fun f (Fun g' x)\n\ngoal (1 subgoal):\n 1. x \\<in> Dom g \\<Longrightarrow> Fun g x = Fun g' x", "have \"Fun g x \\<in> Dom f \\<and> Fun g' x \\<in> Dom f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun g x \\<in> Dom f \\<and> Fun g' x \\<in> Dom f", "using par gg' x Fun_mapsto"], ["proof (prove)\nusing this:\n  par g g'\n  seq f g \\<and> seq f g' \\<and> f \\<cdot> g = f \\<cdot> g'\n  x \\<in> Dom g\n  arr ?f \\<Longrightarrow>\n  Fun ?f \\<in> extensional (Dom ?f) \\<inter> (Dom ?f \\<rightarrow> Cod ?f)\n\ngoal (1 subgoal):\n 1. Fun g x \\<in> Dom f \\<and> Fun g' x \\<in> Dom f", "by fastforce"], ["proof (state)\nthis:\n  Fun g x \\<in> Dom f \\<and> Fun g' x \\<in> Dom f\n\ngoal (1 subgoal):\n 1. x \\<in> Dom g \\<Longrightarrow> Fun g x = Fun g' x", "ultimately"], ["proof (chain)\npicking this:\n  Fun f (Fun g x) = Fun f (Fun g' x)\n  Fun g x \\<in> Dom f \\<and> Fun g' x \\<in> Dom f", "show \"Fun g x = Fun g' x\""], ["proof (prove)\nusing this:\n  Fun f (Fun g x) = Fun f (Fun g' x)\n  Fun g x \\<in> Dom f \\<and> Fun g' x \\<in> Dom f\n\ngoal (1 subgoal):\n 1. Fun g x = Fun g' x", "using f gg' inj_onD [of \"Fun f\" \"Dom f\" \"Fun g x\" \"Fun g' x\"]"], ["proof (prove)\nusing this:\n  Fun f (Fun g x) = Fun f (Fun g' x)\n  Fun g x \\<in> Dom f \\<and> Fun g' x \\<in> Dom f\n  arr f \\<and> inj_on (Fun f) (Dom f)\n  seq f g \\<and> seq f g' \\<and> f \\<cdot> g = f \\<cdot> g'\n  \\<lbrakk>inj_on (Fun f) (Dom f); Fun f (Fun g x) = Fun f (Fun g' x);\n   Fun g x \\<in> Dom f; Fun g' x \\<in> Dom f\\<rbrakk>\n  \\<Longrightarrow> Fun g x = Fun g' x\n\ngoal (1 subgoal):\n 1. Fun g x = Fun g' x", "by simp"], ["proof (state)\nthis:\n  Fun g x = Fun g' x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  x \\<in> Dom g \\<Longrightarrow> Fun g x = Fun g' x\n\ngoal (1 subgoal):\n 1. \\<And>x. Fun g x = Fun g' x", "ultimately"], ["proof (chain)\npicking this:\n  x \\<notin> Dom g \\<Longrightarrow> Fun g x = Fun g' x\n  x \\<in> Dom g \\<Longrightarrow> Fun g x = Fun g' x", "show \"Fun g x = Fun g' x\""], ["proof (prove)\nusing this:\n  x \\<notin> Dom g \\<Longrightarrow> Fun g x = Fun g' x\n  x \\<in> Dom g \\<Longrightarrow> Fun g x = Fun g' x\n\ngoal (1 subgoal):\n 1. Fun g x = Fun g' x", "by auto"], ["proof (state)\nthis:\n  Fun g x = Fun g' x\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Fun g = Fun g'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  g = g'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  seq f ?g \\<and>\n  seq f ?g' \\<and> f \\<cdot> ?g = f \\<cdot> ?g' \\<Longrightarrow>\n  ?g = ?g'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.mono f\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n      Inclusions are monomorphisms.\n\\<close>"], ["", "lemma mono_imp_incl:\n    assumes \"incl f\"\n    shows \"mono f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.mono f", "using assms incl_def Fun_incl mono_char"], ["proof (prove)\nusing this:\n  incl f\n  incl ?f =\n  (arr ?f \\<and>\n   Dom ?f \\<subseteq> Cod ?f \\<and> ?f = incl_of (local.dom ?f) (cod ?f))\n  incl ?f \\<Longrightarrow> Fun ?f = (\\<lambda>x\\<in>Dom ?f. x)\n  local.mono ?f = (arr ?f \\<and> inj_on (Fun ?f) (Dom ?f))\n\ngoal (1 subgoal):\n 1. local.mono f", "by auto"], ["", "text\\<open>\n      A monomorphism is a section, except in case it has an empty domain set and\n      a nonempty codomain set.\n\\<close>"], ["", "lemma mono_imp_section:\n    assumes \"mono f\" and \"Dom f = {} \\<longrightarrow> Cod f = {}\"\n    shows \"section f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. section f", "using assms mono_char section_char"], ["proof (prove)\nusing this:\n  local.mono f\n  Dom f = {} \\<longrightarrow> Cod f = {}\n  local.mono ?f = (arr ?f \\<and> inj_on (Fun ?f) (Dom ?f))\n  section ?f =\n  (arr ?f \\<and>\n   (Dom ?f = {} \\<longrightarrow> Cod ?f = {}) \\<and>\n   inj_on (Fun ?f) (Dom ?f))\n\ngoal (1 subgoal):\n 1. section f", "by auto"], ["", "text\\<open>\n      An arrow is an epimorphism if and only if either its image coincides with its\n      codomain, or else the universe has only a single element (in which case all arrows\n      are epimorphisms).\n\\<close>"], ["", "lemma epi_char:\n    shows \"epi f \\<longleftrightarrow> arr f \\<and> (Img f = Cod f \\<or> (\\<forall>t t'. t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow> t = t'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. epi f =\n    (arr f \\<and>\n     (Img f = Cod f \\<or>\n      (\\<forall>t t'.\n          t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow> t = t')))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. epi f \\<Longrightarrow>\n    arr f \\<and>\n    (Img f = Cod f \\<or>\n     (\\<forall>t t'.\n         t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow> t = t'))\n 2. arr f \\<and>\n    (Img f = Cod f \\<or>\n     (\\<forall>t t'.\n         t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow>\n         t = t')) \\<Longrightarrow>\n    epi f", "assume epi: \"epi f\""], ["proof (state)\nthis:\n  epi f\n\ngoal (2 subgoals):\n 1. epi f \\<Longrightarrow>\n    arr f \\<and>\n    (Img f = Cod f \\<or>\n     (\\<forall>t t'.\n         t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow> t = t'))\n 2. arr f \\<and>\n    (Img f = Cod f \\<or>\n     (\\<forall>t t'.\n         t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow>\n         t = t')) \\<Longrightarrow>\n    epi f", "show \"arr f \\<and> (Img f = Cod f \\<or> (\\<forall>t t'. t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow> t = t'))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr f \\<and>\n    (Img f = Cod f \\<or>\n     (\\<forall>t t'.\n         t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow> t = t'))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. arr f \\<and>\n    (Img f = Cod f \\<or>\n     (\\<forall>t t'.\n         t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow> t = t'))", "have f: \"arr f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr f", "using epi epi_implies_arr"], ["proof (prove)\nusing this:\n  epi f\n  epi ?f \\<Longrightarrow> arr ?f\n\ngoal (1 subgoal):\n 1. arr f", "by auto"], ["proof (state)\nthis:\n  arr f\n\ngoal (1 subgoal):\n 1. arr f \\<and>\n    (Img f = Cod f \\<or>\n     (\\<forall>t t'.\n         t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow> t = t'))", "moreover"], ["proof (state)\nthis:\n  arr f\n\ngoal (1 subgoal):\n 1. arr f \\<and>\n    (Img f = Cod f \\<or>\n     (\\<forall>t t'.\n         t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow> t = t'))", "have \"\\<not>(\\<forall>t t'. t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow> t = t') \\<Longrightarrow> Img f = Cod f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t t'.\n               t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow>\n               t = t') \\<Longrightarrow>\n    Img f = Cod f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t t'.\n               t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow>\n               t = t') \\<Longrightarrow>\n    Img f = Cod f", "assume \"\\<not>(\\<forall>t t'. t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow> t = t')\""], ["proof (state)\nthis:\n  \\<not> (\\<forall>t t'.\n             t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow> t = t')\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t t'.\n               t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow>\n               t = t') \\<Longrightarrow>\n    Img f = Cod f", "from this"], ["proof (chain)\npicking this:\n  \\<not> (\\<forall>t t'.\n             t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow> t = t')", "obtain tt and ff\n            where B: \"tt \\<in> Univ \\<and> ff \\<in> Univ \\<and> tt \\<noteq> ff\""], ["proof (prove)\nusing this:\n  \\<not> (\\<forall>t t'.\n             t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow> t = t')\n\ngoal (1 subgoal):\n 1. (\\<And>tt ff.\n        tt \\<in> Univ \\<and>\n        ff \\<in> Univ \\<and> tt \\<noteq> ff \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by blast"], ["proof (state)\nthis:\n  tt \\<in> Univ \\<and> ff \\<in> Univ \\<and> tt \\<noteq> ff\n\ngoal (1 subgoal):\n 1. \\<not> (\\<forall>t t'.\n               t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow>\n               t = t') \\<Longrightarrow>\n    Img f = Cod f", "show \"Img f = Cod f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Img f = Cod f", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. Img f \\<subseteq> Cod f\n 2. Cod f \\<subseteq> Img f", "show \"Img f \\<subseteq> Cod f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Img f \\<subseteq> Cod f", "using f Fun_mapsto"], ["proof (prove)\nusing this:\n  arr f\n  arr ?f \\<Longrightarrow>\n  Fun ?f \\<in> extensional (Dom ?f) \\<inter> (Dom ?f \\<rightarrow> Cod ?f)\n\ngoal (1 subgoal):\n 1. Img f \\<subseteq> Cod f", "by auto"], ["proof (state)\nthis:\n  Img f \\<subseteq> Cod f\n\ngoal (1 subgoal):\n 1. Cod f \\<subseteq> Img f", "show \"Cod f \\<subseteq> Img f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Cod f \\<subseteq> Img f", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Cod f \\<Longrightarrow> x \\<in> Img f", "let ?g = \"mkArr (Cod f) {ff, tt} (\\<lambda>y. tt)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Cod f \\<Longrightarrow> x \\<in> Img f", "let ?g' = \"mkArr (Cod f) {ff, tt} (\\<lambda>y. if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y\n                                                     then tt else ff)\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Cod f \\<Longrightarrow> x \\<in> Img f", "let ?b = \"mkIde {ff, tt}\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Cod f \\<Longrightarrow> x \\<in> Img f", "have b: \"ide ?b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide (mkIde {ff, tt})", "using B ide_mkIde_finite"], ["proof (prove)\nusing this:\n  tt \\<in> Univ \\<and> ff \\<in> Univ \\<and> tt \\<noteq> ff\n  \\<lbrakk>?A \\<subseteq> Univ; finite ?A\\<rbrakk>\n  \\<Longrightarrow> ide (mkIde ?A)\n\ngoal (1 subgoal):\n 1. ide (mkIde {ff, tt})", "by simp"], ["proof (state)\nthis:\n  ide (mkIde {ff, tt})\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Cod f \\<Longrightarrow> x \\<in> Img f", "have g: \"\\<guillemotleft>?g : cod f \\<rightarrow> ?b\\<guillemotright> \\<and> Fun ?g = (\\<lambda>y \\<in> Cod f. tt)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>mkArr (Cod f) {ff, tt}\n                     (\\<lambda>y.\n                         tt) : cod f \\<rightarrow> mkIde\n              {ff, tt}\\<guillemotright> \\<and>\n    Fun (mkArr (Cod f) {ff, tt} (\\<lambda>y. tt)) =\n    (\\<lambda>y\\<in>Cod f. tt)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<guillemotleft>mkArr (Cod f) {ff, tt}\n                     (\\<lambda>y.\n                         tt) : cod f \\<rightarrow> mkIde\n              {ff, tt}\\<guillemotright> \\<and>\n    Fun (mkArr (Cod f) {ff, tt} (\\<lambda>y. tt)) =\n    (\\<lambda>y\\<in>Cod f. tt)", "have \"arr ?g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (mkArr (Cod f) {ff, tt} (\\<lambda>y. tt))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. arr (mkArr (Cod f) {ff, tt} (\\<lambda>y. tt))", "have \"arr (mkIde {ff, tt})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (mkIde {ff, tt})", "using b ideD(1)"], ["proof (prove)\nusing this:\n  ide (mkIde {ff, tt})\n  ide ?a \\<Longrightarrow> arr ?a\n\ngoal (1 subgoal):\n 1. arr (mkIde {ff, tt})", "by presburger"], ["proof (state)\nthis:\n  arr (mkIde {ff, tt})\n\ngoal (1 subgoal):\n 1. arr (mkArr (Cod f) {ff, tt} (\\<lambda>y. tt))", "thus ?thesis"], ["proof (prove)\nusing this:\n  arr (mkIde {ff, tt})\n\ngoal (1 subgoal):\n 1. arr (mkArr (Cod f) {ff, tt} (\\<lambda>y. tt))", "by (simp add: f set_card arr_mkIde arr_mkArr)"], ["proof (state)\nthis:\n  arr (mkArr (Cod f) {ff, tt} (\\<lambda>y. tt))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  arr (mkArr (Cod f) {ff, tt} (\\<lambda>y. tt))\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>mkArr (Cod f) {ff, tt}\n                     (\\<lambda>y.\n                         tt) : cod f \\<rightarrow> mkIde\n              {ff, tt}\\<guillemotright> \\<and>\n    Fun (mkArr (Cod f) {ff, tt} (\\<lambda>y. tt)) =\n    (\\<lambda>y\\<in>Cod f. tt)", "thus ?thesis"], ["proof (prove)\nusing this:\n  arr (mkArr (Cod f) {ff, tt} (\\<lambda>y. tt))\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>mkArr (Cod f) {ff, tt}\n                     (\\<lambda>y.\n                         tt) : cod f \\<rightarrow> mkIde\n              {ff, tt}\\<guillemotright> \\<and>\n    Fun (mkArr (Cod f) {ff, tt} (\\<lambda>y. tt)) =\n    (\\<lambda>y\\<in>Cod f. tt)", "using f b B in_homI [of ?g] mkIde_set"], ["proof (prove)\nusing this:\n  arr (mkArr (Cod f) {ff, tt} (\\<lambda>y. tt))\n  arr f\n  ide (mkIde {ff, tt})\n  tt \\<in> Univ \\<and> ff \\<in> Univ \\<and> tt \\<noteq> ff\n  \\<lbrakk>arr (mkArr (Cod f) {ff, tt} (\\<lambda>y. tt));\n   local.dom (mkArr (Cod f) {ff, tt} (\\<lambda>y. tt)) = ?a;\n   cod (mkArr (Cod f) {ff, tt} (\\<lambda>y. tt)) = ?b\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>mkArr (Cod f) {ff, tt}\n                                     (\\<lambda>y.\n   tt) : ?a \\<rightarrow> ?b\\<guillemotright>\n  ide ?a \\<Longrightarrow> mkIde (local.set ?a) = ?a\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>mkArr (Cod f) {ff, tt}\n                     (\\<lambda>y.\n                         tt) : cod f \\<rightarrow> mkIde\n              {ff, tt}\\<guillemotright> \\<and>\n    Fun (mkArr (Cod f) {ff, tt} (\\<lambda>y. tt)) =\n    (\\<lambda>y\\<in>Cod f. tt)", "by simp"], ["proof (state)\nthis:\n  \\<guillemotleft>mkArr (Cod f) {ff, tt}\n                   (\\<lambda>y.\n                       tt) : cod f \\<rightarrow> mkIde\n            {ff, tt}\\<guillemotright> \\<and>\n  Fun (mkArr (Cod f) {ff, tt} (\\<lambda>y. tt)) = (\\<lambda>y\\<in>Cod f. tt)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<guillemotleft>mkArr (Cod f) {ff, tt}\n                   (\\<lambda>y.\n                       tt) : cod f \\<rightarrow> mkIde\n            {ff, tt}\\<guillemotright> \\<and>\n  Fun (mkArr (Cod f) {ff, tt} (\\<lambda>y. tt)) = (\\<lambda>y\\<in>Cod f. tt)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Cod f \\<Longrightarrow> x \\<in> Img f", "have g': \"?g' \\<in> hom (cod f) ?b \\<and>\n                        Fun ?g' = (\\<lambda>y \\<in> Cod f. if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt else ff)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mkArr (Cod f) {ff, tt}\n     (\\<lambda>y.\n         if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt else ff)\n    \\<in> hom (cod f) (mkIde {ff, tt}) \\<and>\n    Fun (mkArr (Cod f) {ff, tt}\n          (\\<lambda>y.\n              if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt\n              else ff)) =\n    (\\<lambda>y\\<in>Cod f.\n        if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt else ff)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. mkArr (Cod f) {ff, tt}\n     (\\<lambda>y.\n         if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt else ff)\n    \\<in> hom (cod f) (mkIde {ff, tt}) \\<and>\n    Fun (mkArr (Cod f) {ff, tt}\n          (\\<lambda>y.\n              if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt\n              else ff)) =\n    (\\<lambda>y\\<in>Cod f.\n        if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt else ff)", "have \"arr ?g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (mkArr (Cod f) {ff, tt} (\\<lambda>y. tt))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. arr (mkArr (Cod f) {ff, tt} (\\<lambda>y. tt))", "have \"arr (mkIde {ff, tt})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr (mkIde {ff, tt})", "using b ideD(1)"], ["proof (prove)\nusing this:\n  ide (mkIde {ff, tt})\n  ide ?a \\<Longrightarrow> arr ?a\n\ngoal (1 subgoal):\n 1. arr (mkIde {ff, tt})", "by presburger"], ["proof (state)\nthis:\n  arr (mkIde {ff, tt})\n\ngoal (1 subgoal):\n 1. arr (mkArr (Cod f) {ff, tt} (\\<lambda>y. tt))", "thus ?thesis"], ["proof (prove)\nusing this:\n  arr (mkIde {ff, tt})\n\ngoal (1 subgoal):\n 1. arr (mkArr (Cod f) {ff, tt} (\\<lambda>y. tt))", "by (simp add: f set_card arr_mkIde arr_mkArr)"], ["proof (state)\nthis:\n  arr (mkArr (Cod f) {ff, tt} (\\<lambda>y. tt))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  arr (mkArr (Cod f) {ff, tt} (\\<lambda>y. tt))\n\ngoal (1 subgoal):\n 1. mkArr (Cod f) {ff, tt}\n     (\\<lambda>y.\n         if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt else ff)\n    \\<in> hom (cod f) (mkIde {ff, tt}) \\<and>\n    Fun (mkArr (Cod f) {ff, tt}\n          (\\<lambda>y.\n              if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt\n              else ff)) =\n    (\\<lambda>y\\<in>Cod f.\n        if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt else ff)", "thus ?thesis"], ["proof (prove)\nusing this:\n  arr (mkArr (Cod f) {ff, tt} (\\<lambda>y. tt))\n\ngoal (1 subgoal):\n 1. mkArr (Cod f) {ff, tt}\n     (\\<lambda>y.\n         if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt else ff)\n    \\<in> hom (cod f) (mkIde {ff, tt}) \\<and>\n    Fun (mkArr (Cod f) {ff, tt}\n          (\\<lambda>y.\n              if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt\n              else ff)) =\n    (\\<lambda>y\\<in>Cod f.\n        if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt else ff)", "using f b B in_homI [of ?g'] arr_mkArr mkIde_set"], ["proof (prove)\nusing this:\n  arr (mkArr (Cod f) {ff, tt} (\\<lambda>y. tt))\n  arr f\n  ide (mkIde {ff, tt})\n  tt \\<in> Univ \\<and> ff \\<in> Univ \\<and> tt \\<noteq> ff\n  \\<lbrakk>arr (mkArr (Cod f) {ff, tt}\n                 (\\<lambda>y.\n                     if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt\n                     else ff));\n   local.dom\n    (mkArr (Cod f) {ff, tt}\n      (\\<lambda>y.\n          if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt\n          else ff)) =\n   ?a;\n   cod (mkArr (Cod f) {ff, tt}\n         (\\<lambda>y.\n             if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt\n             else ff)) =\n   ?b\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>mkArr (Cod f) {ff, tt}\n                                     (\\<lambda>y.\n   if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt\n   else ff) : ?a \\<rightarrow> ?b\\<guillemotright>\n  arr (mkArr ?A ?B ?F) =\n  (?A \\<subseteq> Univ \\<and>\n   |?A| <o \\<AA> \\<and>\n   ?B \\<subseteq> Univ \\<and>\n   |?B| <o \\<AA> \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n  ide ?a \\<Longrightarrow> mkIde (local.set ?a) = ?a\n\ngoal (1 subgoal):\n 1. mkArr (Cod f) {ff, tt}\n     (\\<lambda>y.\n         if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt else ff)\n    \\<in> hom (cod f) (mkIde {ff, tt}) \\<and>\n    Fun (mkArr (Cod f) {ff, tt}\n          (\\<lambda>y.\n              if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt\n              else ff)) =\n    (\\<lambda>y\\<in>Cod f.\n        if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt else ff)", "by simp"], ["proof (state)\nthis:\n  mkArr (Cod f) {ff, tt}\n   (\\<lambda>y.\n       if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt else ff)\n  \\<in> hom (cod f) (mkIde {ff, tt}) \\<and>\n  Fun (mkArr (Cod f) {ff, tt}\n        (\\<lambda>y.\n            if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt\n            else ff)) =\n  (\\<lambda>y\\<in>Cod f.\n      if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt else ff)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mkArr (Cod f) {ff, tt}\n   (\\<lambda>y.\n       if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt else ff)\n  \\<in> hom (cod f) (mkIde {ff, tt}) \\<and>\n  Fun (mkArr (Cod f) {ff, tt}\n        (\\<lambda>y.\n            if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt\n            else ff)) =\n  (\\<lambda>y\\<in>Cod f.\n      if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt else ff)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Cod f \\<Longrightarrow> x \\<in> Img f", "have \"?g \\<cdot> f = ?g' \\<cdot> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mkArr (Cod f) {ff, tt} (\\<lambda>y. tt) \\<cdot> f =\n    mkArr (Cod f) {ff, tt}\n     (\\<lambda>y.\n         if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt\n         else ff) \\<cdot>\n    f", "proof (intro arr_eqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. par (mkArr (Cod f) {ff, tt} (\\<lambda>y. tt) \\<cdot> f)\n     (mkArr (Cod f) {ff, tt}\n       (\\<lambda>y.\n           if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt\n           else ff) \\<cdot>\n      f)\n 2. Fun (mkArr (Cod f) {ff, tt} (\\<lambda>y. tt) \\<cdot> f) =\n    Fun (mkArr (Cod f) {ff, tt}\n          (\\<lambda>y.\n              if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt\n              else ff) \\<cdot>\n         f)", "show \"par (?g \\<cdot> f) (?g' \\<cdot> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. par (mkArr (Cod f) {ff, tt} (\\<lambda>y. tt) \\<cdot> f)\n     (mkArr (Cod f) {ff, tt}\n       (\\<lambda>y.\n           if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt\n           else ff) \\<cdot>\n      f)", "using f g g' arr_mkArr"], ["proof (prove)\nusing this:\n  arr f\n  \\<guillemotleft>mkArr (Cod f) {ff, tt}\n                   (\\<lambda>y.\n                       tt) : cod f \\<rightarrow> mkIde\n            {ff, tt}\\<guillemotright> \\<and>\n  Fun (mkArr (Cod f) {ff, tt} (\\<lambda>y. tt)) = (\\<lambda>y\\<in>Cod f. tt)\n  mkArr (Cod f) {ff, tt}\n   (\\<lambda>y.\n       if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt else ff)\n  \\<in> hom (cod f) (mkIde {ff, tt}) \\<and>\n  Fun (mkArr (Cod f) {ff, tt}\n        (\\<lambda>y.\n            if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt\n            else ff)) =\n  (\\<lambda>y\\<in>Cod f.\n      if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt else ff)\n  arr (mkArr ?A ?B ?F) =\n  (?A \\<subseteq> Univ \\<and>\n   |?A| <o \\<AA> \\<and>\n   ?B \\<subseteq> Univ \\<and>\n   |?B| <o \\<AA> \\<and> ?F \\<in> ?A \\<rightarrow> ?B)\n\ngoal (1 subgoal):\n 1. par (mkArr (Cod f) {ff, tt} (\\<lambda>y. tt) \\<cdot> f)\n     (mkArr (Cod f) {ff, tt}\n       (\\<lambda>y.\n           if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt\n           else ff) \\<cdot>\n      f)", "by auto"], ["proof (state)\nthis:\n  par (mkArr (Cod f) {ff, tt} (\\<lambda>y. tt) \\<cdot> f)\n   (mkArr (Cod f) {ff, tt}\n     (\\<lambda>y.\n         if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt\n         else ff) \\<cdot>\n    f)\n\ngoal (1 subgoal):\n 1. Fun (mkArr (Cod f) {ff, tt} (\\<lambda>y. tt) \\<cdot> f) =\n    Fun (mkArr (Cod f) {ff, tt}\n          (\\<lambda>y.\n              if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt\n              else ff) \\<cdot>\n         f)", "show \"Fun (?g \\<cdot> f) = Fun (?g' \\<cdot> f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (mkArr (Cod f) {ff, tt} (\\<lambda>y. tt) \\<cdot> f) =\n    Fun (mkArr (Cod f) {ff, tt}\n          (\\<lambda>y.\n              if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt\n              else ff) \\<cdot>\n         f)", "using f g g' Fun_comp comp_mkArr"], ["proof (prove)\nusing this:\n  arr f\n  \\<guillemotleft>mkArr (Cod f) {ff, tt}\n                   (\\<lambda>y.\n                       tt) : cod f \\<rightarrow> mkIde\n            {ff, tt}\\<guillemotright> \\<and>\n  Fun (mkArr (Cod f) {ff, tt} (\\<lambda>y. tt)) = (\\<lambda>y\\<in>Cod f. tt)\n  mkArr (Cod f) {ff, tt}\n   (\\<lambda>y.\n       if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt else ff)\n  \\<in> hom (cod f) (mkIde {ff, tt}) \\<and>\n  Fun (mkArr (Cod f) {ff, tt}\n        (\\<lambda>y.\n            if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt\n            else ff)) =\n  (\\<lambda>y\\<in>Cod f.\n      if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt else ff)\n  seq ?g ?f \\<Longrightarrow>\n  Fun (?g \\<cdot> ?f) = restrict (Fun ?g \\<circ> Fun ?f) (Dom ?f)\n  \\<lbrakk>arr (mkArr ?A ?B ?F); arr (mkArr ?B ?C ?G)\\<rbrakk>\n  \\<Longrightarrow> mkArr ?B ?C ?G \\<cdot> mkArr ?A ?B ?F =\n                    mkArr ?A ?C (?G \\<circ> ?F)\n\ngoal (1 subgoal):\n 1. Fun (mkArr (Cod f) {ff, tt} (\\<lambda>y. tt) \\<cdot> f) =\n    Fun (mkArr (Cod f) {ff, tt}\n          (\\<lambda>y.\n              if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt\n              else ff) \\<cdot>\n         f)", "by fastforce"], ["proof (state)\nthis:\n  Fun (mkArr (Cod f) {ff, tt} (\\<lambda>y. tt) \\<cdot> f) =\n  Fun (mkArr (Cod f) {ff, tt}\n        (\\<lambda>y.\n            if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt\n            else ff) \\<cdot>\n       f)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  mkArr (Cod f) {ff, tt} (\\<lambda>y. tt) \\<cdot> f =\n  mkArr (Cod f) {ff, tt}\n   (\\<lambda>y.\n       if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt\n       else ff) \\<cdot>\n  f\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Cod f \\<Longrightarrow> x \\<in> Img f", "hence gg': \"?g = ?g'\""], ["proof (prove)\nusing this:\n  mkArr (Cod f) {ff, tt} (\\<lambda>y. tt) \\<cdot> f =\n  mkArr (Cod f) {ff, tt}\n   (\\<lambda>y.\n       if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt\n       else ff) \\<cdot>\n  f\n\ngoal (1 subgoal):\n 1. mkArr (Cod f) {ff, tt} (\\<lambda>y. tt) =\n    mkArr (Cod f) {ff, tt}\n     (\\<lambda>y.\n         if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt else ff)", "using epi f g g' epiE [of f ?g ?g']"], ["proof (prove)\nusing this:\n  mkArr (Cod f) {ff, tt} (\\<lambda>y. tt) \\<cdot> f =\n  mkArr (Cod f) {ff, tt}\n   (\\<lambda>y.\n       if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt\n       else ff) \\<cdot>\n  f\n  epi f\n  arr f\n  \\<guillemotleft>mkArr (Cod f) {ff, tt}\n                   (\\<lambda>y.\n                       tt) : cod f \\<rightarrow> mkIde\n            {ff, tt}\\<guillemotright> \\<and>\n  Fun (mkArr (Cod f) {ff, tt} (\\<lambda>y. tt)) = (\\<lambda>y\\<in>Cod f. tt)\n  mkArr (Cod f) {ff, tt}\n   (\\<lambda>y.\n       if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt else ff)\n  \\<in> hom (cod f) (mkIde {ff, tt}) \\<and>\n  Fun (mkArr (Cod f) {ff, tt}\n        (\\<lambda>y.\n            if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt\n            else ff)) =\n  (\\<lambda>y\\<in>Cod f.\n      if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt else ff)\n  \\<lbrakk>epi f; seq (mkArr (Cod f) {ff, tt} (\\<lambda>y. tt)) f;\n   seq (mkArr (Cod f) {ff, tt}\n         (\\<lambda>y.\n             if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt\n             else ff))\n    f;\n   mkArr (Cod f) {ff, tt} (\\<lambda>y. tt) \\<cdot> f =\n   mkArr (Cod f) {ff, tt}\n    (\\<lambda>y.\n        if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt\n        else ff) \\<cdot>\n   f\\<rbrakk>\n  \\<Longrightarrow> mkArr (Cod f) {ff, tt} (\\<lambda>y. tt) =\n                    mkArr (Cod f) {ff, tt}\n                     (\\<lambda>y.\n                         if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y\n                         then tt else ff)\n\ngoal (1 subgoal):\n 1. mkArr (Cod f) {ff, tt} (\\<lambda>y. tt) =\n    mkArr (Cod f) {ff, tt}\n     (\\<lambda>y.\n         if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt else ff)", "by fastforce"], ["proof (state)\nthis:\n  mkArr (Cod f) {ff, tt} (\\<lambda>y. tt) =\n  mkArr (Cod f) {ff, tt}\n   (\\<lambda>y.\n       if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt else ff)\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Cod f \\<Longrightarrow> x \\<in> Img f", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Cod f \\<Longrightarrow> x \\<in> Img f", "assume y: \"y \\<in> Cod f\""], ["proof (state)\nthis:\n  y \\<in> Cod f\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Cod f \\<Longrightarrow> x \\<in> Img f", "have \"Fun ?g' y = tt\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Fun (mkArr (Cod f) {ff, tt}\n          (\\<lambda>y.\n              if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt\n              else ff))\n     y =\n    tt", "using gg' g y"], ["proof (prove)\nusing this:\n  mkArr (Cod f) {ff, tt} (\\<lambda>y. tt) =\n  mkArr (Cod f) {ff, tt}\n   (\\<lambda>y.\n       if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt else ff)\n  \\<guillemotleft>mkArr (Cod f) {ff, tt}\n                   (\\<lambda>y.\n                       tt) : cod f \\<rightarrow> mkIde\n            {ff, tt}\\<guillemotright> \\<and>\n  Fun (mkArr (Cod f) {ff, tt} (\\<lambda>y. tt)) = (\\<lambda>y\\<in>Cod f. tt)\n  y \\<in> Cod f\n\ngoal (1 subgoal):\n 1. Fun (mkArr (Cod f) {ff, tt}\n          (\\<lambda>y.\n              if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt\n              else ff))\n     y =\n    tt", "by simp"], ["proof (state)\nthis:\n  Fun (mkArr (Cod f) {ff, tt}\n        (\\<lambda>y.\n            if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt\n            else ff))\n   y =\n  tt\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Cod f \\<Longrightarrow> x \\<in> Img f", "hence \"(if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt else ff) = tt\""], ["proof (prove)\nusing this:\n  Fun (mkArr (Cod f) {ff, tt}\n        (\\<lambda>y.\n            if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt\n            else ff))\n   y =\n  tt\n\ngoal (1 subgoal):\n 1. (if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt else ff) = tt", "using g' y"], ["proof (prove)\nusing this:\n  Fun (mkArr (Cod f) {ff, tt}\n        (\\<lambda>y.\n            if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt\n            else ff))\n   y =\n  tt\n  mkArr (Cod f) {ff, tt}\n   (\\<lambda>y.\n       if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt else ff)\n  \\<in> hom (cod f) (mkIde {ff, tt}) \\<and>\n  Fun (mkArr (Cod f) {ff, tt}\n        (\\<lambda>y.\n            if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt\n            else ff)) =\n  (\\<lambda>y\\<in>Cod f.\n      if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt else ff)\n  y \\<in> Cod f\n\ngoal (1 subgoal):\n 1. (if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt else ff) = tt", "by simp"], ["proof (state)\nthis:\n  (if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt else ff) = tt\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Cod f \\<Longrightarrow> x \\<in> Img f", "hence \"\\<exists>x. x \\<in> Dom f \\<and> Fun f x = y\""], ["proof (prove)\nusing this:\n  (if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt else ff) = tt\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y", "using B"], ["proof (prove)\nusing this:\n  (if \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y then tt else ff) = tt\n  tt \\<in> Univ \\<and> ff \\<in> Univ \\<and> tt \\<noteq> ff\n\ngoal (1 subgoal):\n 1. \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y", "by argo"], ["proof (state)\nthis:\n  \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y\n\ngoal (1 subgoal):\n 1. \\<And>x. x \\<in> Cod f \\<Longrightarrow> x \\<in> Img f", "thus \"y \\<in> Img f\""], ["proof (prove)\nusing this:\n  \\<exists>x. x \\<in> Dom f \\<and> Fun f x = y\n\ngoal (1 subgoal):\n 1. y \\<in> Img f", "by blast"], ["proof (state)\nthis:\n  y \\<in> Img f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Cod f \\<subseteq> Img f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  Img f = Cod f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<not> (\\<forall>t t'.\n             t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow>\n             t = t') \\<Longrightarrow>\n  Img f = Cod f\n\ngoal (1 subgoal):\n 1. arr f \\<and>\n    (Img f = Cod f \\<or>\n     (\\<forall>t t'.\n         t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow> t = t'))", "ultimately"], ["proof (chain)\npicking this:\n  arr f\n  \\<not> (\\<forall>t t'.\n             t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow>\n             t = t') \\<Longrightarrow>\n  Img f = Cod f", "show \"arr f \\<and> (Img f = Cod f \\<or> (\\<forall>t t'. t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow> t = t'))\""], ["proof (prove)\nusing this:\n  arr f\n  \\<not> (\\<forall>t t'.\n             t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow>\n             t = t') \\<Longrightarrow>\n  Img f = Cod f\n\ngoal (1 subgoal):\n 1. arr f \\<and>\n    (Img f = Cod f \\<or>\n     (\\<forall>t t'.\n         t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow> t = t'))", "by fast"], ["proof (state)\nthis:\n  arr f \\<and>\n  (Img f = Cod f \\<or>\n   (\\<forall>t t'.\n       t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow> t = t'))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  arr f \\<and>\n  (Img f = Cod f \\<or>\n   (\\<forall>t t'.\n       t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow> t = t'))\n\ngoal (1 subgoal):\n 1. arr f \\<and>\n    (Img f = Cod f \\<or>\n     (\\<forall>t t'.\n         t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow>\n         t = t')) \\<Longrightarrow>\n    epi f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. arr f \\<and>\n    (Img f = Cod f \\<or>\n     (\\<forall>t t'.\n         t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow>\n         t = t')) \\<Longrightarrow>\n    epi f", "show \"arr f \\<and> (Img f = Cod f \\<or> (\\<forall>t t'. t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow> t = t')) \\<Longrightarrow> epi f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr f \\<and>\n    (Img f = Cod f \\<or>\n     (\\<forall>t t'.\n         t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow>\n         t = t')) \\<Longrightarrow>\n    epi f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. arr f \\<and>\n    (Img f = Cod f \\<or>\n     (\\<forall>t t'.\n         t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow>\n         t = t')) \\<Longrightarrow>\n    epi f", "have \"arr f \\<and> Img f = Cod f \\<Longrightarrow> epi f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr f \\<and> Img f = Cod f \\<Longrightarrow> epi f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. arr f \\<and> Img f = Cod f \\<Longrightarrow> epi f", "assume f: \"arr f \\<and> Img f = Cod f\""], ["proof (state)\nthis:\n  arr f \\<and> Img f = Cod f\n\ngoal (1 subgoal):\n 1. arr f \\<and> Img f = Cod f \\<Longrightarrow> epi f", "show \"epi f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. epi f", "using f arr_eqI' epiE retractionI retraction_if_Img_eq_Cod retraction_is_epi"], ["proof (prove)\nusing this:\n  arr f \\<and> Img f = Cod f\n  \\<lbrakk>par ?f ?f';\n   \\<And>x.\n      \\<guillemotleft>x : unity \\<rightarrow> local.dom\n         ?f\\<guillemotright> \\<Longrightarrow>\n      ?f \\<cdot> x = ?f' \\<cdot> x\\<rbrakk>\n  \\<Longrightarrow> ?f = ?f'\n  \\<lbrakk>epi ?f; seq ?g ?f; seq ?g' ?f;\n   ?g \\<cdot> ?f = ?g' \\<cdot> ?f\\<rbrakk>\n  \\<Longrightarrow> ?g = ?g'\n  ide (?g \\<cdot> ?f) \\<Longrightarrow> retraction ?g\n  \\<lbrakk>arr ?g; Img ?g = Cod ?g\\<rbrakk> \\<Longrightarrow> retraction ?g\n  \\<lbrakk>arr ?g; Img ?g = Cod ?g\\<rbrakk>\n  \\<Longrightarrow> ide (?g \\<cdot>\n                         mkArr (Cod ?g) (Dom ?g)\n                          (inv_into (Dom ?g) (Fun ?g)))\n  retraction ?g \\<Longrightarrow> epi ?g\n\ngoal (1 subgoal):\n 1. epi f", "by meson"], ["proof (state)\nthis:\n  epi f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  arr f \\<and> Img f = Cod f \\<Longrightarrow> epi f\n\ngoal (1 subgoal):\n 1. arr f \\<and>\n    (Img f = Cod f \\<or>\n     (\\<forall>t t'.\n         t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow>\n         t = t')) \\<Longrightarrow>\n    epi f", "moreover"], ["proof (state)\nthis:\n  arr f \\<and> Img f = Cod f \\<Longrightarrow> epi f\n\ngoal (1 subgoal):\n 1. arr f \\<and>\n    (Img f = Cod f \\<or>\n     (\\<forall>t t'.\n         t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow>\n         t = t')) \\<Longrightarrow>\n    epi f", "have \"arr f \\<and> (\\<forall>t t'. t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow> t = t') \\<Longrightarrow> epi f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr f \\<and>\n    (\\<forall>t t'.\n        t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow>\n        t = t') \\<Longrightarrow>\n    epi f", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. arr f \\<and>\n    (\\<forall>t t'.\n        t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow>\n        t = t') \\<Longrightarrow>\n    epi f", "assume f: \"arr f \\<and> (\\<forall>t t'. t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow> t = t')\""], ["proof (state)\nthis:\n  arr f \\<and>\n  (\\<forall>t t'.\n      t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow> t = t')\n\ngoal (1 subgoal):\n 1. arr f \\<and>\n    (\\<forall>t t'.\n        t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow>\n        t = t') \\<Longrightarrow>\n    epi f", "have \"\\<And>f f'. par f f' \\<Longrightarrow> f = f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f f'. par f f' \\<Longrightarrow> f = f'", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f f'. par f f' \\<Longrightarrow> f = f'", "fix f f'"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>f f'. par f f' \\<Longrightarrow> f = f'", "assume ff': \"par f f'\""], ["proof (state)\nthis:\n  par f f'\n\ngoal (1 subgoal):\n 1. \\<And>f f'. par f f' \\<Longrightarrow> f = f'", "show \"f = f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f = f'", "proof (intro arr_eqI)"], ["proof (state)\ngoal (2 subgoals):\n 1. par f f'\n 2. Fun f = Fun f'", "show \"par f f'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. par f f'", "using ff'"], ["proof (prove)\nusing this:\n  par f f'\n\ngoal (1 subgoal):\n 1. par f f'", "by simp"], ["proof (state)\nthis:\n  par f f'\n\ngoal (1 subgoal):\n 1. Fun f = Fun f'", "have \"\\<And>t t'. t \\<in> Cod f \\<and> t' \\<in> Cod f \\<Longrightarrow> t = t'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>t t'. t \\<in> Cod f \\<and> t' \\<in> Cod f \\<Longrightarrow> t = t'", "using f ff' set_subset_Univ ide_cod subsetD"], ["proof (prove)\nusing this:\n  arr f \\<and>\n  (\\<forall>t t'.\n      t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow> t = t')\n  par f f'\n  ide ?a \\<Longrightarrow> local.set ?a \\<subseteq> Univ\n  arr ?f \\<Longrightarrow> ide (cod ?f)\n  \\<lbrakk>?A \\<subseteq> ?B; ?c \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> ?c \\<in> ?B\n\ngoal (1 subgoal):\n 1. \\<And>t t'. t \\<in> Cod f \\<and> t' \\<in> Cod f \\<Longrightarrow> t = t'", "by blast"], ["proof (state)\nthis:\n  ?t \\<in> Cod f \\<and> ?t' \\<in> Cod f \\<Longrightarrow> ?t = ?t'\n\ngoal (1 subgoal):\n 1. Fun f = Fun f'", "thus \"Fun f = Fun f'\""], ["proof (prove)\nusing this:\n  ?t \\<in> Cod f \\<and> ?t' \\<in> Cod f \\<Longrightarrow> ?t = ?t'\n\ngoal (1 subgoal):\n 1. Fun f = Fun f'", "using ff' Fun_mapsto [of f] Fun_mapsto [of f']\n                      extensional_arb [of \"Fun f\" \"Dom f\"] extensional_arb [of \"Fun f'\" \"Dom f\"]"], ["proof (prove)\nusing this:\n  ?t \\<in> Cod f \\<and> ?t' \\<in> Cod f \\<Longrightarrow> ?t = ?t'\n  par f f'\n  arr f \\<Longrightarrow>\n  Fun f \\<in> extensional (Dom f) \\<inter> (Dom f \\<rightarrow> Cod f)\n  arr f' \\<Longrightarrow>\n  Fun f' \\<in> extensional (Dom f') \\<inter> (Dom f' \\<rightarrow> Cod f')\n  \\<lbrakk>Fun f \\<in> extensional (Dom f); ?x \\<notin> Dom f\\<rbrakk>\n  \\<Longrightarrow> Fun f ?x = undefined\n  \\<lbrakk>Fun f' \\<in> extensional (Dom f); ?x \\<notin> Dom f\\<rbrakk>\n  \\<Longrightarrow> Fun f' ?x = undefined\n\ngoal (1 subgoal):\n 1. Fun f = Fun f'", "by fastforce"], ["proof (state)\nthis:\n  Fun f = Fun f'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  f = f'\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  par ?f ?f' \\<Longrightarrow> ?f = ?f'\n\ngoal (1 subgoal):\n 1. arr f \\<and>\n    (\\<forall>t t'.\n        t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow>\n        t = t') \\<Longrightarrow>\n    epi f", "moreover"], ["proof (state)\nthis:\n  par ?f ?f' \\<Longrightarrow> ?f = ?f'\n\ngoal (1 subgoal):\n 1. arr f \\<and>\n    (\\<forall>t t'.\n        t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow>\n        t = t') \\<Longrightarrow>\n    epi f", "have \"\\<And>g g'. par (g \\<cdot> f) (g' \\<cdot> f) \\<Longrightarrow> par g g'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g g'. par (g \\<cdot> f) (g' \\<cdot> f) \\<Longrightarrow> par g g'", "by force"], ["proof (state)\nthis:\n  par (?g \\<cdot> f) (?g' \\<cdot> f) \\<Longrightarrow> par ?g ?g'\n\ngoal (1 subgoal):\n 1. arr f \\<and>\n    (\\<forall>t t'.\n        t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow>\n        t = t') \\<Longrightarrow>\n    epi f", "ultimately"], ["proof (chain)\npicking this:\n  par ?f ?f' \\<Longrightarrow> ?f = ?f'\n  par (?g \\<cdot> f) (?g' \\<cdot> f) \\<Longrightarrow> par ?g ?g'", "show \"epi f\""], ["proof (prove)\nusing this:\n  par ?f ?f' \\<Longrightarrow> ?f = ?f'\n  par (?g \\<cdot> f) (?g' \\<cdot> f) \\<Longrightarrow> par ?g ?g'\n\ngoal (1 subgoal):\n 1. epi f", "using f"], ["proof (prove)\nusing this:\n  par ?f ?f' \\<Longrightarrow> ?f = ?f'\n  par (?g \\<cdot> f) (?g' \\<cdot> f) \\<Longrightarrow> par ?g ?g'\n  arr f \\<and>\n  (\\<forall>t t'.\n      t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow> t = t')\n\ngoal (1 subgoal):\n 1. epi f", "by (intro epiI; metis)"], ["proof (state)\nthis:\n  epi f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  arr f \\<and>\n  (\\<forall>t t'.\n      t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow>\n      t = t') \\<Longrightarrow>\n  epi f\n\ngoal (1 subgoal):\n 1. arr f \\<and>\n    (Img f = Cod f \\<or>\n     (\\<forall>t t'.\n         t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow>\n         t = t')) \\<Longrightarrow>\n    epi f", "ultimately"], ["proof (chain)\npicking this:\n  arr f \\<and> Img f = Cod f \\<Longrightarrow> epi f\n  arr f \\<and>\n  (\\<forall>t t'.\n      t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow>\n      t = t') \\<Longrightarrow>\n  epi f", "show \"arr f \\<and> (Img f = Cod f \\<or>  (\\<forall>t t'. t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow> t = t'))\n                           \\<Longrightarrow> epi f\""], ["proof (prove)\nusing this:\n  arr f \\<and> Img f = Cod f \\<Longrightarrow> epi f\n  arr f \\<and>\n  (\\<forall>t t'.\n      t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow>\n      t = t') \\<Longrightarrow>\n  epi f\n\ngoal (1 subgoal):\n 1. arr f \\<and>\n    (Img f = Cod f \\<or>\n     (\\<forall>t t'.\n         t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow>\n         t = t')) \\<Longrightarrow>\n    epi f", "by auto"], ["proof (state)\nthis:\n  arr f \\<and>\n  (Img f = Cod f \\<or>\n   (\\<forall>t t'.\n       t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow>\n       t = t')) \\<Longrightarrow>\n  epi f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  arr f \\<and>\n  (Img f = Cod f \\<or>\n   (\\<forall>t t'.\n       t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow>\n       t = t')) \\<Longrightarrow>\n  epi f\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>\n      An epimorphism is a retraction, except in the case of a degenerate universe with only\n      a single element.\n\\<close>"], ["", "lemma epi_imp_retraction:\n    assumes \"epi f\" and \"\\<exists>t t'. t \\<in> Univ \\<and> t' \\<in> Univ \\<and> t \\<noteq> t'\"\n    shows \"retraction f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. retraction f", "using assms epi_char retraction_char"], ["proof (prove)\nusing this:\n  epi f\n  \\<exists>t t'. t \\<in> Univ \\<and> t' \\<in> Univ \\<and> t \\<noteq> t'\n  epi ?f =\n  (arr ?f \\<and>\n   (Img ?f = Cod ?f \\<or>\n    (\\<forall>t t'.\n        t \\<in> Univ \\<and> t' \\<in> Univ \\<longrightarrow> t = t')))\n  retraction ?g = (arr ?g \\<and> Img ?g = Cod ?g)\n\ngoal (1 subgoal):\n 1. retraction f", "by auto"], ["", "text\\<open>\n      Retraction/inclusion factorization is unique (not just up to isomorphism -- remember\n      that the notion of inclusion is not categorical but depends on the arbitrarily chosen\n      @{term img}).\n\\<close>"], ["", "lemma unique_retr_incl_fact:\n    assumes \"seq m e\" and \"seq m' e'\" and \"m \\<cdot> e = m' \\<cdot> e'\"\n    and \"incl m\" and \"incl m'\" and \"retraction e\" and \"retraction e'\"\n    shows \"m = m'\" and \"e = e'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m = m' &&& e = e'", "proof -"], ["proof (state)\ngoal (2 subgoals):\n 1. m = m'\n 2. e = e'", "have 1: \"cod m = cod m' \\<and> dom e = dom e'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cod m = cod m' \\<and> local.dom e = local.dom e'", "using assms(1-3)"], ["proof (prove)\nusing this:\n  seq m e\n  seq m' e'\n  m \\<cdot> e = m' \\<cdot> e'\n\ngoal (1 subgoal):\n 1. cod m = cod m' \\<and> local.dom e = local.dom e'", "by (metis dom_comp cod_comp)"], ["proof (state)\nthis:\n  cod m = cod m' \\<and> local.dom e = local.dom e'\n\ngoal (2 subgoals):\n 1. m = m'\n 2. e = e'", "hence 2: \"span e e'\""], ["proof (prove)\nusing this:\n  cod m = cod m' \\<and> local.dom e = local.dom e'\n\ngoal (1 subgoal):\n 1. span e e'", "using assms(1-2)"], ["proof (prove)\nusing this:\n  cod m = cod m' \\<and> local.dom e = local.dom e'\n  seq m e\n  seq m' e'\n\ngoal (1 subgoal):\n 1. span e e'", "by blast"], ["proof (state)\nthis:\n  span e e'\n\ngoal (2 subgoals):\n 1. m = m'\n 2. e = e'", "hence 3: \"Fun e = Fun e'\""], ["proof (prove)\nusing this:\n  span e e'\n\ngoal (1 subgoal):\n 1. Fun e = Fun e'", "using assms eq_Fun_iff_incl_joinable"], ["proof (prove)\nusing this:\n  span e e'\n  seq m e\n  seq m' e'\n  m \\<cdot> e = m' \\<cdot> e'\n  incl m\n  incl m'\n  retraction e\n  retraction e'\n  span ?f ?f' \\<Longrightarrow>\n  (Fun ?f = Fun ?f') =\n  (\\<exists>m m'.\n      incl m \\<and>\n      incl m' \\<and>\n      seq m ?f \\<and> seq m' ?f' \\<and> m \\<cdot> ?f = m' \\<cdot> ?f')\n\ngoal (1 subgoal):\n 1. Fun e = Fun e'", "by meson"], ["proof (state)\nthis:\n  Fun e = Fun e'\n\ngoal (2 subgoals):\n 1. m = m'\n 2. e = e'", "hence \"img e = img e'\""], ["proof (prove)\nusing this:\n  Fun e = Fun e'\n\ngoal (1 subgoal):\n 1. img e = img e'", "using assms 1 img_def"], ["proof (prove)\nusing this:\n  Fun e = Fun e'\n  seq m e\n  seq m' e'\n  m \\<cdot> e = m' \\<cdot> e'\n  incl m\n  incl m'\n  retraction e\n  retraction e'\n  cod m = cod m' \\<and> local.dom e = local.dom e'\n  img ?f = mkIde (Img ?f)\n\ngoal (1 subgoal):\n 1. img e = img e'", "by auto"], ["proof (state)\nthis:\n  img e = img e'\n\ngoal (2 subgoals):\n 1. m = m'\n 2. e = e'", "moreover"], ["proof (state)\nthis:\n  img e = img e'\n\ngoal (2 subgoals):\n 1. m = m'\n 2. e = e'", "have \"img e = cod e \\<and> img e' = cod e'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. img e = cod e \\<and> img e' = cod e'", "using assms(6-7) retraction_char img_def mkIde_set"], ["proof (prove)\nusing this:\n  retraction e\n  retraction e'\n  retraction ?g = (arr ?g \\<and> Img ?g = Cod ?g)\n  img ?f = mkIde (Img ?f)\n  ide ?a \\<Longrightarrow> mkIde (local.set ?a) = ?a\n\ngoal (1 subgoal):\n 1. img e = cod e \\<and> img e' = cod e'", "by simp"], ["proof (state)\nthis:\n  img e = cod e \\<and> img e' = cod e'\n\ngoal (2 subgoals):\n 1. m = m'\n 2. e = e'", "ultimately"], ["proof (chain)\npicking this:\n  img e = img e'\n  img e = cod e \\<and> img e' = cod e'", "have \"par e e'\""], ["proof (prove)\nusing this:\n  img e = img e'\n  img e = cod e \\<and> img e' = cod e'\n\ngoal (1 subgoal):\n 1. par e e'", "using 2"], ["proof (prove)\nusing this:\n  img e = img e'\n  img e = cod e \\<and> img e' = cod e'\n  span e e'\n\ngoal (1 subgoal):\n 1. par e e'", "by simp"], ["proof (state)\nthis:\n  par e e'\n\ngoal (2 subgoals):\n 1. m = m'\n 2. e = e'", "thus \"e = e'\""], ["proof (prove)\nusing this:\n  par e e'\n\ngoal (1 subgoal):\n 1. e = e'", "using 3 arr_eqI"], ["proof (prove)\nusing this:\n  par e e'\n  Fun e = Fun e'\n  \\<lbrakk>par ?f ?f'; Fun ?f = Fun ?f'\\<rbrakk> \\<Longrightarrow> ?f = ?f'\n\ngoal (1 subgoal):\n 1. e = e'", "by blast"], ["proof (state)\nthis:\n  e = e'\n\ngoal (1 subgoal):\n 1. m = m'", "hence \"par m m'\""], ["proof (prove)\nusing this:\n  e = e'\n\ngoal (1 subgoal):\n 1. par m m'", "using assms(1) assms(2) 1"], ["proof (prove)\nusing this:\n  e = e'\n  seq m e\n  seq m' e'\n  cod m = cod m' \\<and> local.dom e = local.dom e'\n\ngoal (1 subgoal):\n 1. par m m'", "by fastforce"], ["proof (state)\nthis:\n  par m m'\n\ngoal (1 subgoal):\n 1. m = m'", "thus \"m = m'\""], ["proof (prove)\nusing this:\n  par m m'\n\ngoal (1 subgoal):\n 1. m = m'", "using assms(4) assms(5) incls_coherent"], ["proof (prove)\nusing this:\n  par m m'\n  incl m\n  incl m'\n  \\<lbrakk>par ?f ?f'; incl ?f; incl ?f'\\<rbrakk> \\<Longrightarrow> ?f = ?f'\n\ngoal (1 subgoal):\n 1. m = m'", "by blast"], ["proof (state)\nthis:\n  m = m'\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "section \"Concrete Set Categories\""], ["", "text\\<open>\n    The \\<open>set_category\\<close> locale is useful for stating results that depend on a\n    category of @{typ 'a}-sets and functions, without having to commit to a particular\n    element type @{typ 'a}.  However, in applications we often need to work with a\n    category of sets and functions that is guaranteed to contain sets corresponding\n    to the subsets of some extrinsically given type @{typ 'a}.\n    A \\emph{concrete set category} is a set category \\<open>S\\<close> that is equipped\n    with an injective function @{term \\<iota>} from type @{typ 'a} to \\<open>S.Univ\\<close>.\n    The following locale serves to facilitate some of the technical aspects of passing\n    back and forth between elements of type @{typ 'a} and the elements of \\<open>S.Univ\\<close>.\n\\<close>"], ["", "locale concrete_set_category = set_category S \\<AA>\n    for S :: \"'s comp\"      (infixr \"\\<cdot>\\<^sub>S\" 55)\n    and \\<AA> :: \"'t rel\"\n    and U :: \"'a set\"\n    and \\<iota> :: \"'a \\<Rightarrow> 's\" +\n    assumes \\<iota>_mapsto: \"\\<iota> \\<in> U \\<rightarrow> Univ\"\n    and inj_\\<iota>: \"inj_on \\<iota> U\"\n  begin"], ["", "abbreviation \\<o>\n    where \"\\<o> \\<equiv> inv_into U \\<iota>\""], ["", "lemma \\<o>_mapsto:\n    shows \"\\<o> \\<in> \\<iota> ` U \\<rightarrow> U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<o> \\<in> \\<iota> ` U \\<rightarrow> U", "by (simp add: inv_into_into)"], ["", "lemma \\<o>_\\<iota> [simp]:\n    assumes \"x \\<in> U\"\n    shows \"\\<o> (\\<iota> x) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<o> (\\<iota> x) = x", "using assms inj_\\<iota> inv_into_f_f"], ["proof (prove)\nusing this:\n  x \\<in> U\n  inj_on \\<iota> U\n  \\<lbrakk>inj_on ?f ?A; ?x \\<in> ?A\\<rbrakk>\n  \\<Longrightarrow> inv_into ?A ?f (?f ?x) = ?x\n\ngoal (1 subgoal):\n 1. \\<o> (\\<iota> x) = x", "by simp"], ["", "lemma \\<iota>_\\<o> [simp]:\n    assumes \"t \\<in> \\<iota> ` U\"\n    shows \"\\<iota> (\\<o> t) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<iota> (\\<o> t) = t", "using assms o_def inj_\\<iota>"], ["proof (prove)\nusing this:\n  t \\<in> \\<iota> ` U\n  ?f \\<circ> ?g = (\\<lambda>x. ?f (?g x))\n  inj_on \\<iota> U\n\ngoal (1 subgoal):\n 1. \\<iota> (\\<o> t) = t", "by auto"], ["", "end"], ["", "locale replete_concrete_set_category =\n    replete_set_category S +\n    concrete_set_category S \\<open>cardSuc (cmax (card_of (UNIV :: 's set)) natLeq)\\<close> U \\<iota>\n    for S :: \"'s comp\"      (infixr \"\\<cdot>\\<^sub>S\" 55)\n    and U :: \"'a set\"\n    and \\<iota> :: \"'a \\<Rightarrow> 's\""], ["", "end"]]}