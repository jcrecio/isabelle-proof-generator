{"file_name": "/home/qj213/afp-2021-10-22/thys/Category3/CartesianClosedCategory.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Category3", "problem_names": ["lemma has_exponentials:\n    assumes \"ide b\" and \"ide c\"\n    shows \"\\<exists>x e. ide x \\<and> \\<guillemotleft>e : prod x b \\<rightarrow> c\\<guillemotright> \\<and>\n                 (\\<forall>a g. ide a \\<and> \\<guillemotleft>g : prod a b \\<rightarrow> c\\<guillemotright> \\<longrightarrow> (\\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> x\\<guillemotright> \\<and> g = C e (prod f b)))\"", "lemma ex_un_lam:\n    assumes \"ide b\" and \"ide c\"\n    shows \"ide (exp b c)\" and \"\\<guillemotleft>eval b c : prod (exp b c) b \\<rightarrow> c\\<guillemotright>\"\n    and \"\\<lbrakk> ide a; \\<guillemotleft>g : prod a b \\<rightarrow> c\\<guillemotright> \\<rbrakk> \\<Longrightarrow> \\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> exp b c\\<guillemotright> \\<and> g = C (eval b c) (prod f b)\"", "lemma eval_in_hom [intro]:\n    assumes \"ide b\" and \"ide c\"\n    shows \"\\<guillemotleft>eval b c : prod (exp b c) b \\<rightarrow> c\\<guillemotright>\"", "lemma eval_prod_lam:\n    assumes \"ide a\" and \"ide b\" and \"ide c\" and \"\\<guillemotleft>g : prod a b \\<rightarrow> c\\<guillemotright>\"\n    shows \"\\<guillemotleft>\\<Lambda> a b c g : a \\<rightarrow> exp b c\\<guillemotright> \\<and> g = C (eval b c) (prod (\\<Lambda> a b c g) b)\"", "lemma lam_eval_prod:\n    assumes \"ide a\" and \"ide b\" and \"ide c\" and \"\\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\"\n    shows \"\\<Lambda> a b c (C (eval b c) (prod h b)) = h\"", "lemma induces_elementary_cartesian_closed_category:\n    shows \"elementary_cartesian_closed_category C pr0 pr1 \\<one> trm exp eval \\<Lambda>\"", "lemma left_adjoint_prod:\n    assumes \"ide b\"\n    shows \"left_adjoint_functor C C (\\<lambda>x. x \\<otimes> b)\"", "lemma is_cartesian_closed_category:\n    shows \"cartesian_closed_category C\""], "translations": [["", "lemma has_exponentials:\n    assumes \"ide b\" and \"ide c\"\n    shows \"\\<exists>x e. ide x \\<and> \\<guillemotleft>e : prod x b \\<rightarrow> c\\<guillemotright> \\<and>\n                 (\\<forall>a g. ide a \\<and> \\<guillemotleft>g : prod a b \\<rightarrow> c\\<guillemotright> \\<longrightarrow> (\\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> x\\<guillemotright> \\<and> g = C e (prod f b)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x e.\n       ide x \\<and>\n       \\<guillemotleft>e : local.prod x\n                            b \\<rightarrow> c\\<guillemotright> \\<and>\n       (\\<forall>a g.\n           ide a \\<and>\n           \\<guillemotleft>g : local.prod a\n                                b \\<rightarrow> c\\<guillemotright> \\<longrightarrow>\n           (\\<exists>!f.\n               \\<guillemotleft>f : a \\<rightarrow> x\\<guillemotright> \\<and>\n               g = C e (local.prod f b)))", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x e.\n       ide x \\<and>\n       \\<guillemotleft>e : local.prod x\n                            b \\<rightarrow> c\\<guillemotright> \\<and>\n       (\\<forall>a g.\n           ide a \\<and>\n           \\<guillemotleft>g : local.prod a\n                                b \\<rightarrow> c\\<guillemotright> \\<longrightarrow>\n           (\\<exists>!f.\n               \\<guillemotleft>f : a \\<rightarrow> x\\<guillemotright> \\<and>\n               g = C e (local.prod f b)))", "interpret F: left_adjoint_functor C C \\<open>\\<lambda>x. prod x b\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. left_adjoint_functor C C (\\<lambda>x. local.prod x b)", "using assms(1) left_adjoint_prod"], ["proof (prove)\nusing this:\n  ide b\n  ide ?b \\<Longrightarrow>\n  left_adjoint_functor C C (\\<lambda>x. local.prod x ?b)\n\ngoal (1 subgoal):\n 1. left_adjoint_functor C C (\\<lambda>x. local.prod x b)", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x e.\n       ide x \\<and>\n       \\<guillemotleft>e : local.prod x\n                            b \\<rightarrow> c\\<guillemotright> \\<and>\n       (\\<forall>a g.\n           ide a \\<and>\n           \\<guillemotleft>g : local.prod a\n                                b \\<rightarrow> c\\<guillemotright> \\<longrightarrow>\n           (\\<exists>!f.\n               \\<guillemotleft>f : a \\<rightarrow> x\\<guillemotright> \\<and>\n               g = C e (local.prod f b)))", "obtain x e where e: \"terminal_arrow_from_functor C C (\\<lambda>x. prod x b) x c e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x e.\n        terminal_arrow_from_functor C C (\\<lambda>x. local.prod x b) x c\n         e \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using assms F.ex_terminal_arrow [of c]"], ["proof (prove)\nusing this:\n  ide b\n  ide c\n  ide c \\<Longrightarrow>\n  \\<exists>x e.\n     terminal_arrow_from_functor C C (\\<lambda>x. local.prod x b) x c e\n\ngoal (1 subgoal):\n 1. (\\<And>x e.\n        terminal_arrow_from_functor C C (\\<lambda>x. local.prod x b) x c\n         e \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  terminal_arrow_from_functor C C (\\<lambda>x. local.prod x b) x c e\n\ngoal (1 subgoal):\n 1. \\<exists>x e.\n       ide x \\<and>\n       \\<guillemotleft>e : local.prod x\n                            b \\<rightarrow> c\\<guillemotright> \\<and>\n       (\\<forall>a g.\n           ide a \\<and>\n           \\<guillemotleft>g : local.prod a\n                                b \\<rightarrow> c\\<guillemotright> \\<longrightarrow>\n           (\\<exists>!f.\n               \\<guillemotleft>f : a \\<rightarrow> x\\<guillemotright> \\<and>\n               g = C e (local.prod f b)))", "interpret e: terminal_arrow_from_functor C C \\<open>\\<lambda>x. prod x b\\<close> x c e"], ["proof (prove)\ngoal (1 subgoal):\n 1. terminal_arrow_from_functor C C (\\<lambda>x. local.prod x b) x c e", "using e"], ["proof (prove)\nusing this:\n  terminal_arrow_from_functor C C (\\<lambda>x. local.prod x b) x c e\n\ngoal (1 subgoal):\n 1. terminal_arrow_from_functor C C (\\<lambda>x. local.prod x b) x c e", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>x e.\n       ide x \\<and>\n       \\<guillemotleft>e : local.prod x\n                            b \\<rightarrow> c\\<guillemotright> \\<and>\n       (\\<forall>a g.\n           ide a \\<and>\n           \\<guillemotleft>g : local.prod a\n                                b \\<rightarrow> c\\<guillemotright> \\<longrightarrow>\n           (\\<exists>!f.\n               \\<guillemotleft>f : a \\<rightarrow> x\\<guillemotright> \\<and>\n               g = C e (local.prod f b)))", "have \"\\<And>a g. \\<lbrakk> ide a; \\<guillemotleft>g : prod a b \\<rightarrow> c\\<guillemotright> \\<rbrakk> \\<Longrightarrow> \\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> x\\<guillemotright> \\<and> g = C e (prod f b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a g.\n       \\<lbrakk>ide a;\n        \\<guillemotleft>g : local.prod a\n                             b \\<rightarrow> c\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!f.\n                            \\<guillemotleft>f : a \\<rightarrow> x\\<guillemotright> \\<and>\n                            g = C e (local.prod f b)", "using e.is_terminal category_axioms F.functor_axioms"], ["proof (prove)\nusing this:\n  arrow_from_functor C C (\\<lambda>x. local.prod x b) ?x' c\n   ?f \\<Longrightarrow>\n  \\<exists>!g. e.is_coext ?x' ?f g\n  category C\n  functor C C (\\<lambda>x. local.prod x b)\n\ngoal (1 subgoal):\n 1. \\<And>a g.\n       \\<lbrakk>ide a;\n        \\<guillemotleft>g : local.prod a\n                             b \\<rightarrow> c\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!f.\n                            \\<guillemotleft>f : a \\<rightarrow> x\\<guillemotright> \\<and>\n                            g = C e (local.prod f b)", "unfolding e.is_coext_def arrow_from_functor_def arrow_from_functor_axioms_def"], ["proof (prove)\nusing this:\n  (category C \\<and> category C) \\<and>\n  functor C C (\\<lambda>x. local.prod x b) \\<and>\n  ide ?x' \\<and>\n  \\<guillemotleft>?f : local.prod ?x'\n                        b \\<rightarrow> c\\<guillemotright> \\<Longrightarrow>\n  \\<exists>!g.\n     \\<guillemotleft>g : ?x' \\<rightarrow> x\\<guillemotright> \\<and>\n     ?f = C e (local.prod g b)\n  category C\n  functor C C (\\<lambda>x. local.prod x b)\n\ngoal (1 subgoal):\n 1. \\<And>a g.\n       \\<lbrakk>ide a;\n        \\<guillemotleft>g : local.prod a\n                             b \\<rightarrow> c\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<exists>!f.\n                            \\<guillemotleft>f : a \\<rightarrow> x\\<guillemotright> \\<and>\n                            g = C e (local.prod f b)", "by simp"], ["proof (state)\nthis:\n  \\<lbrakk>ide ?a4;\n   \\<guillemotleft>?g4 : local.prod ?a4\n                          b \\<rightarrow> c\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!f.\n                       \\<guillemotleft>f : ?a4 \\<rightarrow> x\\<guillemotright> \\<and>\n                       ?g4 = C e (local.prod f b)\n\ngoal (1 subgoal):\n 1. \\<exists>x e.\n       ide x \\<and>\n       \\<guillemotleft>e : local.prod x\n                            b \\<rightarrow> c\\<guillemotright> \\<and>\n       (\\<forall>a g.\n           ide a \\<and>\n           \\<guillemotleft>g : local.prod a\n                                b \\<rightarrow> c\\<guillemotright> \\<longrightarrow>\n           (\\<exists>!f.\n               \\<guillemotleft>f : a \\<rightarrow> x\\<guillemotright> \\<and>\n               g = C e (local.prod f b)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  \\<lbrakk>ide ?a4;\n   \\<guillemotleft>?g4 : local.prod ?a4\n                          b \\<rightarrow> c\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!f.\n                       \\<guillemotleft>f : ?a4 \\<rightarrow> x\\<guillemotright> \\<and>\n                       ?g4 = C e (local.prod f b)\n\ngoal (1 subgoal):\n 1. \\<exists>x e.\n       ide x \\<and>\n       \\<guillemotleft>e : local.prod x\n                            b \\<rightarrow> c\\<guillemotright> \\<and>\n       (\\<forall>a g.\n           ide a \\<and>\n           \\<guillemotleft>g : local.prod a\n                                b \\<rightarrow> c\\<guillemotright> \\<longrightarrow>\n           (\\<exists>!f.\n               \\<guillemotleft>f : a \\<rightarrow> x\\<guillemotright> \\<and>\n               g = C e (local.prod f b)))", "using e.arrow"], ["proof (prove)\nusing this:\n  \\<lbrakk>ide ?a4;\n   \\<guillemotleft>?g4 : local.prod ?a4\n                          b \\<rightarrow> c\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!f.\n                       \\<guillemotleft>f : ?a4 \\<rightarrow> x\\<guillemotright> \\<and>\n                       ?g4 = C e (local.prod f b)\n  ide x \\<and>\n  \\<guillemotleft>e : local.prod x b \\<rightarrow> c\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<exists>x e.\n       ide x \\<and>\n       \\<guillemotleft>e : local.prod x\n                            b \\<rightarrow> c\\<guillemotright> \\<and>\n       (\\<forall>a g.\n           ide a \\<and>\n           \\<guillemotleft>g : local.prod a\n                                b \\<rightarrow> c\\<guillemotright> \\<longrightarrow>\n           (\\<exists>!f.\n               \\<guillemotleft>f : a \\<rightarrow> x\\<guillemotright> \\<and>\n               g = C e (local.prod f b)))", "by metis"], ["proof (state)\nthis:\n  \\<exists>x e.\n     ide x \\<and>\n     \\<guillemotleft>e : local.prod x\n                          b \\<rightarrow> c\\<guillemotright> \\<and>\n     (\\<forall>a g.\n         ide a \\<and>\n         \\<guillemotleft>g : local.prod a\n                              b \\<rightarrow> c\\<guillemotright> \\<longrightarrow>\n         (\\<exists>!f.\n             \\<guillemotleft>f : a \\<rightarrow> x\\<guillemotright> \\<and>\n             g = C e (local.prod f b)))\n\ngoal:\nNo subgoals!", "qed"], ["", "definition exp\n    where \"exp b c \\<equiv> SOME x. ide x \\<and>\n                              (\\<exists>e. \\<guillemotleft>e : prod x b \\<rightarrow> c\\<guillemotright> \\<and>\n                                   (\\<forall>a g. ide a \\<and> \\<guillemotleft>g : prod a b \\<rightarrow> c\\<guillemotright>\n                                           \\<longrightarrow> (\\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> x\\<guillemotright> \\<and> g = C e (prod f b))))\""], ["", "definition eval\n    where \"eval b c \\<equiv> SOME e. \\<guillemotleft>e : prod (exp b c) b \\<rightarrow> c\\<guillemotright> \\<and>\n                              (\\<forall>a g. ide a \\<and> \\<guillemotleft>g : prod a b \\<rightarrow> c\\<guillemotright>\n                                       \\<longrightarrow> (\\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> exp b c\\<guillemotright> \\<and> g = C e (prod f b)))\""], ["", "definition \\<Lambda>\n    where \"\\<Lambda> a b c g \\<equiv> THE f. \\<guillemotleft>f : a \\<rightarrow> exp b c\\<guillemotright> \\<and> g = C (eval b c) (prod f b)\""], ["", "lemma ex_un_lam:\n    assumes \"ide b\" and \"ide c\"\n    shows \"ide (exp b c)\" and \"\\<guillemotleft>eval b c : prod (exp b c) b \\<rightarrow> c\\<guillemotright>\"\n    and \"\\<lbrakk> ide a; \\<guillemotleft>g : prod a b \\<rightarrow> c\\<guillemotright> \\<rbrakk> \\<Longrightarrow> \\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> exp b c\\<guillemotright> \\<and> g = C (eval b c) (prod f b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide (exp b c) &&&\n    \\<guillemotleft>eval b\n                     c : local.prod (exp b c)\n                          b \\<rightarrow> c\\<guillemotright> &&&\n    (\\<lbrakk>ide a;\n      \\<guillemotleft>g : local.prod a\n                           b \\<rightarrow> c\\<guillemotright>\\<rbrakk>\n     \\<Longrightarrow> \\<exists>!f.\n                          \\<guillemotleft>f : a \\<rightarrow> exp b\n                         c\\<guillemotright> \\<and>\n                          g = C (eval b c) (local.prod f b))", "using assms exp_def eval_def has_exponentials\n            someI_ex [of \"\\<lambda>x. ide x \\<and> (\\<exists>e. \\<guillemotleft>e : prod x b \\<rightarrow> c\\<guillemotright> \\<and>\n                                           (\\<forall>a g. ide a \\<and> \\<guillemotleft>g : prod a b \\<rightarrow> c\\<guillemotright>\n                                              \\<longrightarrow> (\\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> x\\<guillemotright> \\<and> g = C e (prod f b))))\"]\n            someI_ex [of \"\\<lambda>e. \\<guillemotleft>e : prod (exp b c) b \\<rightarrow> c\\<guillemotright> \\<and>\n                              (\\<forall>a g. ide a \\<and> \\<guillemotleft>g : prod a b \\<rightarrow> c\\<guillemotright>\n                                           \\<longrightarrow> (\\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> exp b c\\<guillemotright> \\<and> g = C e (prod f b)))\"]"], ["proof (prove)\nusing this:\n  ide b\n  ide c\n  exp ?b ?c \\<equiv>\n  SOME x.\n     ide x \\<and>\n     (\\<exists>e.\n         \\<guillemotleft>e : local.prod x\n                              ?b \\<rightarrow> ?c\\<guillemotright> \\<and>\n         (\\<forall>a g.\n             ide a \\<and>\n             \\<guillemotleft>g : local.prod a\n                                  ?b \\<rightarrow> ?c\\<guillemotright> \\<longrightarrow>\n             (\\<exists>!f.\n                 \\<guillemotleft>f : a \\<rightarrow> x\\<guillemotright> \\<and>\n                 g = C e (local.prod f ?b))))\n  eval ?b ?c \\<equiv>\n  SOME e.\n     \\<guillemotleft>e : local.prod (exp ?b ?c)\n                          ?b \\<rightarrow> ?c\\<guillemotright> \\<and>\n     (\\<forall>a g.\n         ide a \\<and>\n         \\<guillemotleft>g : local.prod a\n                              ?b \\<rightarrow> ?c\\<guillemotright> \\<longrightarrow>\n         (\\<exists>!f.\n             \\<guillemotleft>f : a \\<rightarrow> exp ?b\n            ?c\\<guillemotright> \\<and>\n             g = C e (local.prod f ?b)))\n  \\<lbrakk>ide ?b; ide ?c\\<rbrakk>\n  \\<Longrightarrow> \\<exists>x e.\n                       ide x \\<and>\n                       \\<guillemotleft>e : local.prod x\n      ?b \\<rightarrow> ?c\\<guillemotright> \\<and>\n                       (\\<forall>a g.\n                           ide a \\<and>\n                           \\<guillemotleft>g : local.prod a\n          ?b \\<rightarrow> ?c\\<guillemotright> \\<longrightarrow>\n                           (\\<exists>!f.\n                               \\<guillemotleft>f : a \\<rightarrow> x\\<guillemotright> \\<and>\n                               g = C e (local.prod f ?b)))\n  \\<exists>x.\n     ide x \\<and>\n     (\\<exists>e.\n         \\<guillemotleft>e : local.prod x\n                              b \\<rightarrow> c\\<guillemotright> \\<and>\n         (\\<forall>a g.\n             ide a \\<and>\n             \\<guillemotleft>g : local.prod a\n                                  b \\<rightarrow> c\\<guillemotright> \\<longrightarrow>\n             (\\<exists>!f.\n                 \\<guillemotleft>f : a \\<rightarrow> x\\<guillemotright> \\<and>\n                 g = C e (local.prod f b)))) \\<Longrightarrow>\n  ide (SOME x.\n          ide x \\<and>\n          (\\<exists>e.\n              \\<guillemotleft>e : local.prod x\n                                   b \\<rightarrow> c\\<guillemotright> \\<and>\n              (\\<forall>a g.\n                  ide a \\<and>\n                  \\<guillemotleft>g : local.prod a\n b \\<rightarrow> c\\<guillemotright> \\<longrightarrow>\n                  (\\<exists>!f.\n                      \\<guillemotleft>f : a \\<rightarrow> x\\<guillemotright> \\<and>\n                      g = C e (local.prod f b))))) \\<and>\n  (\\<exists>e.\n      \\<guillemotleft>e : local.prod\n                           (SOME x.\n                               ide x \\<and>\n                               (\\<exists>e.\n                                   \\<guillemotleft>e : local.prod x\n                  b \\<rightarrow> c\\<guillemotright> \\<and>\n                                   (\\<forall>a g.\n ide a \\<and>\n \\<guillemotleft>g : local.prod a\n                      b \\<rightarrow> c\\<guillemotright> \\<longrightarrow>\n (\\<exists>!f.\n     \\<guillemotleft>f : a \\<rightarrow> x\\<guillemotright> \\<and>\n     g = C e (local.prod f b)))))\n                           b \\<rightarrow> c\\<guillemotright> \\<and>\n      (\\<forall>a g.\n          ide a \\<and>\n          \\<guillemotleft>g : local.prod a\n                               b \\<rightarrow> c\\<guillemotright> \\<longrightarrow>\n          (\\<exists>!f.\n              \\<guillemotleft>f : a \\<rightarrow> SOME x.\n               ide x \\<and>\n               (\\<exists>e.\n                   \\<guillemotleft>e : local.prod x\n  b \\<rightarrow> c\\<guillemotright> \\<and>\n                   (\\<forall>a g.\n                       ide a \\<and>\n                       \\<guillemotleft>g : local.prod a\n      b \\<rightarrow> c\\<guillemotright> \\<longrightarrow>\n                       (\\<exists>!f.\n                           \\<guillemotleft>f : a \\<rightarrow> x\\<guillemotright> \\<and>\n                           g =\n                           C e (local.prod f b))))\\<guillemotright> \\<and>\n              g = C e (local.prod f b))))\n  \\<exists>x.\n     \\<guillemotleft>x : local.prod (exp b c)\n                          b \\<rightarrow> c\\<guillemotright> \\<and>\n     (\\<forall>a g.\n         ide a \\<and>\n         \\<guillemotleft>g : local.prod a\n                              b \\<rightarrow> c\\<guillemotright> \\<longrightarrow>\n         (\\<exists>!f.\n             \\<guillemotleft>f : a \\<rightarrow> exp b\n            c\\<guillemotright> \\<and>\n             g = C x (local.prod f b))) \\<Longrightarrow>\n  \\<guillemotleft>SOME x.\n                     \\<guillemotleft>x : local.prod (exp b c)\n    b \\<rightarrow> c\\<guillemotright> \\<and>\n                     (\\<forall>a g.\n                         ide a \\<and>\n                         \\<guillemotleft>g : local.prod a\n        b \\<rightarrow> c\\<guillemotright> \\<longrightarrow>\n                         (\\<exists>!f.\n                             \\<guillemotleft>f : a \\<rightarrow> exp b\n                            c\\<guillemotright> \\<and>\n                             g =\n                             C x (local.prod f\n                                   b))) : local.prod (exp b c)\n     b \\<rightarrow> c\\<guillemotright> \\<and>\n  (\\<forall>a g.\n      ide a \\<and>\n      \\<guillemotleft>g : local.prod a\n                           b \\<rightarrow> c\\<guillemotright> \\<longrightarrow>\n      (\\<exists>!f.\n          \\<guillemotleft>f : a \\<rightarrow> exp b\n         c\\<guillemotright> \\<and>\n          g =\n          C (SOME x.\n                \\<guillemotleft>x : local.prod (exp b c)\n                                     b \\<rightarrow> c\\<guillemotright> \\<and>\n                (\\<forall>a g.\n                    ide a \\<and>\n                    \\<guillemotleft>g : local.prod a\n   b \\<rightarrow> c\\<guillemotright> \\<longrightarrow>\n                    (\\<exists>!f.\n                        \\<guillemotleft>f : a \\<rightarrow> exp b\n                       c\\<guillemotright> \\<and>\n                        g = C x (local.prod f b))))\n           (local.prod f b)))\n\ngoal (1 subgoal):\n 1. ide (exp b c) &&&\n    \\<guillemotleft>eval b\n                     c : local.prod (exp b c)\n                          b \\<rightarrow> c\\<guillemotright> &&&\n    (\\<lbrakk>ide a;\n      \\<guillemotleft>g : local.prod a\n                           b \\<rightarrow> c\\<guillemotright>\\<rbrakk>\n     \\<Longrightarrow> \\<exists>!f.\n                          \\<guillemotleft>f : a \\<rightarrow> exp b\n                         c\\<guillemotright> \\<and>\n                          g = C (eval b c) (local.prod f b))", "by auto"], ["", "lemma eval_in_hom [intro]:\n    assumes \"ide b\" and \"ide c\"\n    shows \"\\<guillemotleft>eval b c : prod (exp b c) b \\<rightarrow> c\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>eval b\n                     c : local.prod (exp b c)\n                          b \\<rightarrow> c\\<guillemotright>", "using assms ex_un_lam"], ["proof (prove)\nusing this:\n  ide b\n  ide c\n  \\<lbrakk>ide ?b; ide ?c\\<rbrakk> \\<Longrightarrow> ide (exp ?b ?c)\n  \\<lbrakk>ide ?b; ide ?c\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>eval ?b\n                                     ?c : local.prod (exp ?b ?c)\n     ?b \\<rightarrow> ?c\\<guillemotright>\n  \\<lbrakk>ide ?b; ide ?c; ide ?a;\n   \\<guillemotleft>?g : local.prod ?a\n                         ?b \\<rightarrow> ?c\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!f.\n                       \\<guillemotleft>f : ?a \\<rightarrow> exp ?b\n                       ?c\\<guillemotright> \\<and>\n                       ?g = C (eval ?b ?c) (local.prod f ?b)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>eval b\n                     c : local.prod (exp b c)\n                          b \\<rightarrow> c\\<guillemotright>", "by simp"], ["", "lemma eval_prod_lam:\n    assumes \"ide a\" and \"ide b\" and \"ide c\" and \"\\<guillemotleft>g : prod a b \\<rightarrow> c\\<guillemotright>\"\n    shows \"\\<guillemotleft>\\<Lambda> a b c g : a \\<rightarrow> exp b c\\<guillemotright> \\<and> g = C (eval b c) (prod (\\<Lambda> a b c g) b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<Lambda> a b c\n                     g : a \\<rightarrow> exp b c\\<guillemotright> \\<and>\n    g = C (eval b c) (local.prod (\\<Lambda> a b c g) b)", "using assms \\<Lambda>_def ex_un_lam\n            theI' [of \"\\<lambda>f. \\<guillemotleft>f : a \\<rightarrow> exp b c\\<guillemotright> \\<and> g = C (eval b c) (prod f b)\"]"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>g : local.prod a b \\<rightarrow> c\\<guillemotright>\n  \\<Lambda> ?a ?b ?c ?g \\<equiv>\n  THE f.\n     \\<guillemotleft>f : ?a \\<rightarrow> exp ?b ?c\\<guillemotright> \\<and>\n     ?g = C (eval ?b ?c) (local.prod f ?b)\n  \\<lbrakk>ide ?b; ide ?c\\<rbrakk> \\<Longrightarrow> ide (exp ?b ?c)\n  \\<lbrakk>ide ?b; ide ?c\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>eval ?b\n                                     ?c : local.prod (exp ?b ?c)\n     ?b \\<rightarrow> ?c\\<guillemotright>\n  \\<lbrakk>ide ?b; ide ?c; ide ?a;\n   \\<guillemotleft>?g : local.prod ?a\n                         ?b \\<rightarrow> ?c\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!f.\n                       \\<guillemotleft>f : ?a \\<rightarrow> exp ?b\n                       ?c\\<guillemotright> \\<and>\n                       ?g = C (eval ?b ?c) (local.prod f ?b)\n  \\<exists>!x.\n     \\<guillemotleft>x : a \\<rightarrow> exp b c\\<guillemotright> \\<and>\n     g = C (eval b c) (local.prod x b) \\<Longrightarrow>\n  \\<guillemotleft>THE x.\n                     \\<guillemotleft>x : a \\<rightarrow> exp b\n                    c\\<guillemotright> \\<and>\n                     g =\n                     C (eval b c)\n                      (local.prod x\n                        b) : a \\<rightarrow> exp b c\\<guillemotright> \\<and>\n  g =\n  C (eval b c)\n   (local.prod\n     (THE x.\n         \\<guillemotleft>x : a \\<rightarrow> exp b c\\<guillemotright> \\<and>\n         g = C (eval b c) (local.prod x b))\n     b)\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<Lambda> a b c\n                     g : a \\<rightarrow> exp b c\\<guillemotright> \\<and>\n    g = C (eval b c) (local.prod (\\<Lambda> a b c g) b)", "by simp"], ["", "lemma lam_eval_prod:\n    assumes \"ide a\" and \"ide b\" and \"ide c\" and \"\\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\"\n    shows \"\\<Lambda> a b c (C (eval b c) (prod h b)) = h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Lambda> a b c (C (eval b c) (local.prod h b)) = h", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<Lambda> a b c (C (eval b c) (local.prod h b)) = h", "have \"\\<exists>!f. \\<guillemotleft>f : a \\<rightarrow> exp b c\\<guillemotright> \\<and> C (eval b c) (prod h b) = C (eval b c) (prod f b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!f.\n       \\<guillemotleft>f : a \\<rightarrow> exp b c\\<guillemotright> \\<and>\n       C (eval b c) (local.prod h b) = C (eval b c) (local.prod f b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>!f.\n       \\<guillemotleft>f : a \\<rightarrow> exp b c\\<guillemotright> \\<and>\n       C (eval b c) (local.prod h b) = C (eval b c) (local.prod f b)", "have \"ide a \\<and> \\<guillemotleft>C (eval b c) (prod h b) : prod a b \\<rightarrow> c\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide a \\<and>\n    \\<guillemotleft>C (eval b c)\n                     (local.prod h\n                       b) : local.prod a b \\<rightarrow> c\\<guillemotright>", "proof (intro conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. ide a\n 2. \\<guillemotleft>C (eval b c)\n                     (local.prod h\n                       b) : local.prod a b \\<rightarrow> c\\<guillemotright>", "show \"ide a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide a", "by fact"], ["proof (state)\nthis:\n  ide a\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>C (eval b c)\n                     (local.prod h\n                       b) : local.prod a b \\<rightarrow> c\\<guillemotright>", "show \"\\<guillemotleft>C (eval b c) (prod h b) : prod a b \\<rightarrow> c\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>C (eval b c)\n                     (local.prod h\n                       b) : local.prod a b \\<rightarrow> c\\<guillemotright>", "using assms"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>C (eval b c)\n                     (local.prod h\n                       b) : local.prod a b \\<rightarrow> c\\<guillemotright>", "by (intro comp_in_homI) auto"], ["proof (state)\nthis:\n  \\<guillemotleft>C (eval b c)\n                   (local.prod h\n                     b) : local.prod a b \\<rightarrow> c\\<guillemotright>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ide a \\<and>\n  \\<guillemotleft>C (eval b c)\n                   (local.prod h\n                     b) : local.prod a b \\<rightarrow> c\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<exists>!f.\n       \\<guillemotleft>f : a \\<rightarrow> exp b c\\<guillemotright> \\<and>\n       C (eval b c) (local.prod h b) = C (eval b c) (local.prod f b)", "thus ?thesis"], ["proof (prove)\nusing this:\n  ide a \\<and>\n  \\<guillemotleft>C (eval b c)\n                   (local.prod h\n                     b) : local.prod a b \\<rightarrow> c\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<exists>!f.\n       \\<guillemotleft>f : a \\<rightarrow> exp b c\\<guillemotright> \\<and>\n       C (eval b c) (local.prod h b) = C (eval b c) (local.prod f b)", "using assms ex_un_lam"], ["proof (prove)\nusing this:\n  ide a \\<and>\n  \\<guillemotleft>C (eval b c)\n                   (local.prod h\n                     b) : local.prod a b \\<rightarrow> c\\<guillemotright>\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  \\<lbrakk>ide ?b; ide ?c\\<rbrakk> \\<Longrightarrow> ide (exp ?b ?c)\n  \\<lbrakk>ide ?b; ide ?c\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>eval ?b\n                                     ?c : local.prod (exp ?b ?c)\n     ?b \\<rightarrow> ?c\\<guillemotright>\n  \\<lbrakk>ide ?b; ide ?c; ide ?a;\n   \\<guillemotleft>?g : local.prod ?a\n                         ?b \\<rightarrow> ?c\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!f.\n                       \\<guillemotleft>f : ?a \\<rightarrow> exp ?b\n                       ?c\\<guillemotright> \\<and>\n                       ?g = C (eval ?b ?c) (local.prod f ?b)\n\ngoal (1 subgoal):\n 1. \\<exists>!f.\n       \\<guillemotleft>f : a \\<rightarrow> exp b c\\<guillemotright> \\<and>\n       C (eval b c) (local.prod h b) = C (eval b c) (local.prod f b)", "by simp"], ["proof (state)\nthis:\n  \\<exists>!f.\n     \\<guillemotleft>f : a \\<rightarrow> exp b c\\<guillemotright> \\<and>\n     C (eval b c) (local.prod h b) = C (eval b c) (local.prod f b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!f.\n     \\<guillemotleft>f : a \\<rightarrow> exp b c\\<guillemotright> \\<and>\n     C (eval b c) (local.prod h b) = C (eval b c) (local.prod f b)\n\ngoal (1 subgoal):\n 1. \\<Lambda> a b c (C (eval b c) (local.prod h b)) = h", "moreover"], ["proof (state)\nthis:\n  \\<exists>!f.\n     \\<guillemotleft>f : a \\<rightarrow> exp b c\\<guillemotright> \\<and>\n     C (eval b c) (local.prod h b) = C (eval b c) (local.prod f b)\n\ngoal (1 subgoal):\n 1. \\<Lambda> a b c (C (eval b c) (local.prod h b)) = h", "have \"\\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright> \\<and> C (eval b c) (prod h b) = C (eval b c) (prod h b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright> \\<and>\n    C (eval b c) (local.prod h b) = C (eval b c) (local.prod h b)", "using assms"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright> \\<and>\n    C (eval b c) (local.prod h b) = C (eval b c) (local.prod h b)", "by simp"], ["proof (state)\nthis:\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright> \\<and>\n  C (eval b c) (local.prod h b) = C (eval b c) (local.prod h b)\n\ngoal (1 subgoal):\n 1. \\<Lambda> a b c (C (eval b c) (local.prod h b)) = h", "ultimately"], ["proof (chain)\npicking this:\n  \\<exists>!f.\n     \\<guillemotleft>f : a \\<rightarrow> exp b c\\<guillemotright> \\<and>\n     C (eval b c) (local.prod h b) = C (eval b c) (local.prod f b)\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright> \\<and>\n  C (eval b c) (local.prod h b) = C (eval b c) (local.prod h b)", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<exists>!f.\n     \\<guillemotleft>f : a \\<rightarrow> exp b c\\<guillemotright> \\<and>\n     C (eval b c) (local.prod h b) = C (eval b c) (local.prod f b)\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright> \\<and>\n  C (eval b c) (local.prod h b) = C (eval b c) (local.prod h b)\n\ngoal (1 subgoal):\n 1. \\<Lambda> a b c (C (eval b c) (local.prod h b)) = h", "using assms \\<Lambda>_def ex_un_lam eval_prod_lam\n              the1_equality [of \"\\<lambda>f. \\<guillemotleft>f : a \\<rightarrow> exp b c\\<guillemotright> \\<and>\n                                     C (eval b c) (prod h b) = C (eval b c) (prod f b)\"]"], ["proof (prove)\nusing this:\n  \\<exists>!f.\n     \\<guillemotleft>f : a \\<rightarrow> exp b c\\<guillemotright> \\<and>\n     C (eval b c) (local.prod h b) = C (eval b c) (local.prod f b)\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright> \\<and>\n  C (eval b c) (local.prod h b) = C (eval b c) (local.prod h b)\n  ide a\n  ide b\n  ide c\n  \\<guillemotleft>h : a \\<rightarrow> exp b c\\<guillemotright>\n  \\<Lambda> ?a ?b ?c ?g \\<equiv>\n  THE f.\n     \\<guillemotleft>f : ?a \\<rightarrow> exp ?b ?c\\<guillemotright> \\<and>\n     ?g = C (eval ?b ?c) (local.prod f ?b)\n  \\<lbrakk>ide ?b; ide ?c\\<rbrakk> \\<Longrightarrow> ide (exp ?b ?c)\n  \\<lbrakk>ide ?b; ide ?c\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>eval ?b\n                                     ?c : local.prod (exp ?b ?c)\n     ?b \\<rightarrow> ?c\\<guillemotright>\n  \\<lbrakk>ide ?b; ide ?c; ide ?a;\n   \\<guillemotleft>?g : local.prod ?a\n                         ?b \\<rightarrow> ?c\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!f.\n                       \\<guillemotleft>f : ?a \\<rightarrow> exp ?b\n                       ?c\\<guillemotright> \\<and>\n                       ?g = C (eval ?b ?c) (local.prod f ?b)\n  \\<lbrakk>ide ?a; ide ?b; ide ?c;\n   \\<guillemotleft>?g : local.prod ?a\n                         ?b \\<rightarrow> ?c\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>\\<Lambda> ?a ?b ?c\n                                     ?g : ?a \\<rightarrow> exp ?b\n                      ?c\\<guillemotright> \\<and>\n                    ?g =\n                    C (eval ?b ?c) (local.prod (\\<Lambda> ?a ?b ?c ?g) ?b)\n  \\<lbrakk>\\<exists>!x.\n              \\<guillemotleft>x : a \\<rightarrow> exp b\n             c\\<guillemotright> \\<and>\n              C (eval b c) (local.prod h b) = C (eval b c) (local.prod x b);\n   \\<guillemotleft>?a : a \\<rightarrow> exp b c\\<guillemotright> \\<and>\n   C (eval b c) (local.prod h b) = C (eval b c) (local.prod ?a b)\\<rbrakk>\n  \\<Longrightarrow> (THE x.\n                        \\<guillemotleft>x : a \\<rightarrow> exp b\n                       c\\<guillemotright> \\<and>\n                        C (eval b c) (local.prod h b) =\n                        C (eval b c) (local.prod x b)) =\n                    ?a\n\ngoal (1 subgoal):\n 1. \\<Lambda> a b c (C (eval b c) (local.prod h b)) = h", "by simp"], ["proof (state)\nthis:\n  \\<Lambda> a b c (C (eval b c) (local.prod h b)) = h\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation elementary_cartesian_closed_category C pr0 pr1 \\<one> trm exp eval \\<Lambda>"], ["proof (prove)\ngoal (1 subgoal):\n 1. elementary_cartesian_closed_category C pr0 pr1 \\<one> trm exp eval\n     \\<Lambda>", "using eval_in_hom ex_un_lam eval_prod_lam lam_eval_prod"], ["proof (prove)\nusing this:\n  \\<lbrakk>ide ?b; ide ?c\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>eval ?b\n                                     ?c : local.prod (exp ?b ?c)\n     ?b \\<rightarrow> ?c\\<guillemotright>\n  \\<lbrakk>ide ?b; ide ?c\\<rbrakk> \\<Longrightarrow> ide (exp ?b ?c)\n  \\<lbrakk>ide ?b; ide ?c\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>eval ?b\n                                     ?c : local.prod (exp ?b ?c)\n     ?b \\<rightarrow> ?c\\<guillemotright>\n  \\<lbrakk>ide ?b; ide ?c; ide ?a;\n   \\<guillemotleft>?g : local.prod ?a\n                         ?b \\<rightarrow> ?c\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> \\<exists>!f.\n                       \\<guillemotleft>f : ?a \\<rightarrow> exp ?b\n                       ?c\\<guillemotright> \\<and>\n                       ?g = C (eval ?b ?c) (local.prod f ?b)\n  \\<lbrakk>ide ?a; ide ?b; ide ?c;\n   \\<guillemotleft>?g : local.prod ?a\n                         ?b \\<rightarrow> ?c\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>\\<Lambda> ?a ?b ?c\n                                     ?g : ?a \\<rightarrow> exp ?b\n                      ?c\\<guillemotright> \\<and>\n                    ?g =\n                    C (eval ?b ?c) (local.prod (\\<Lambda> ?a ?b ?c ?g) ?b)\n  \\<lbrakk>ide ?a; ide ?b; ide ?c;\n   \\<guillemotleft>?h : ?a \\<rightarrow> exp ?b ?c\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> \\<Lambda> ?a ?b ?c (C (eval ?b ?c) (local.prod ?h ?b)) =\n                    ?h\n\ngoal (1 subgoal):\n 1. elementary_cartesian_closed_category C pr0 pr1 \\<one> trm exp eval\n     \\<Lambda>", "apply unfold_locales"], ["proof (prove)\ngoal (5 subgoals):\n 1. \\<And>b c.\n       \\<lbrakk>\\<And>b c.\n                   \\<lbrakk>ide b; ide c\\<rbrakk>\n                   \\<Longrightarrow> \\<guillemotleft>eval b\n                c : local.prod (exp b c) b \\<rightarrow> c\\<guillemotright>;\n        \\<And>b c.\n           \\<lbrakk>ide b; ide c\\<rbrakk> \\<Longrightarrow> ide (exp b c);\n        \\<And>b c.\n           \\<lbrakk>ide b; ide c\\<rbrakk>\n           \\<Longrightarrow> \\<guillemotleft>eval b\n        c : local.prod (exp b c) b \\<rightarrow> c\\<guillemotright>;\n        \\<And>b c a g.\n           \\<lbrakk>ide b; ide c; ide a;\n            \\<guillemotleft>g : local.prod a\n                                 b \\<rightarrow> c\\<guillemotright>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>!f.\n                                \\<guillemotleft>f : a \\<rightarrow> exp b\n                               c\\<guillemotright> \\<and>\n                                g = C (eval b c) (local.prod f b);\n        \\<And>a b c g.\n           \\<lbrakk>ide a; ide b; ide c;\n            \\<guillemotleft>g : local.prod a\n                                 b \\<rightarrow> c\\<guillemotright>\\<rbrakk>\n           \\<Longrightarrow> \\<guillemotleft>\\<Lambda> a b c\n        g : a \\<rightarrow> exp b c\\<guillemotright> \\<and>\n                             g =\n                             C (eval b c)\n                              (local.prod (\\<Lambda> a b c g) b);\n        \\<And>a b c h.\n           \\<lbrakk>ide a; ide b; ide c;\n            \\<guillemotleft>h : a \\<rightarrow> exp b\n           c\\<guillemotright>\\<rbrakk>\n           \\<Longrightarrow> \\<Lambda> a b c\n                              (C (eval b c) (local.prod h b)) =\n                             h;\n        ide b; ide c\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>eval b\n    c : local.prod (exp b c) b \\<rightarrow> c\\<guillemotright>\n 2. \\<And>b c.\n       \\<lbrakk>\\<And>b c.\n                   \\<lbrakk>ide b; ide c\\<rbrakk>\n                   \\<Longrightarrow> \\<guillemotleft>eval b\n                c : local.prod (exp b c) b \\<rightarrow> c\\<guillemotright>;\n        \\<And>b c.\n           \\<lbrakk>ide b; ide c\\<rbrakk> \\<Longrightarrow> ide (exp b c);\n        \\<And>b c.\n           \\<lbrakk>ide b; ide c\\<rbrakk>\n           \\<Longrightarrow> \\<guillemotleft>eval b\n        c : local.prod (exp b c) b \\<rightarrow> c\\<guillemotright>;\n        \\<And>b c a g.\n           \\<lbrakk>ide b; ide c; ide a;\n            \\<guillemotleft>g : local.prod a\n                                 b \\<rightarrow> c\\<guillemotright>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>!f.\n                                \\<guillemotleft>f : a \\<rightarrow> exp b\n                               c\\<guillemotright> \\<and>\n                                g = C (eval b c) (local.prod f b);\n        \\<And>a b c g.\n           \\<lbrakk>ide a; ide b; ide c;\n            \\<guillemotleft>g : local.prod a\n                                 b \\<rightarrow> c\\<guillemotright>\\<rbrakk>\n           \\<Longrightarrow> \\<guillemotleft>\\<Lambda> a b c\n        g : a \\<rightarrow> exp b c\\<guillemotright> \\<and>\n                             g =\n                             C (eval b c)\n                              (local.prod (\\<Lambda> a b c g) b);\n        \\<And>a b c h.\n           \\<lbrakk>ide a; ide b; ide c;\n            \\<guillemotleft>h : a \\<rightarrow> exp b\n           c\\<guillemotright>\\<rbrakk>\n           \\<Longrightarrow> \\<Lambda> a b c\n                              (C (eval b c) (local.prod h b)) =\n                             h;\n        ide b; ide c\\<rbrakk>\n       \\<Longrightarrow> ide (exp b c)\n 3. \\<And>a b c g.\n       \\<lbrakk>\\<And>b c.\n                   \\<lbrakk>ide b; ide c\\<rbrakk>\n                   \\<Longrightarrow> \\<guillemotleft>eval b\n                c : local.prod (exp b c) b \\<rightarrow> c\\<guillemotright>;\n        \\<And>b c.\n           \\<lbrakk>ide b; ide c\\<rbrakk> \\<Longrightarrow> ide (exp b c);\n        \\<And>b c.\n           \\<lbrakk>ide b; ide c\\<rbrakk>\n           \\<Longrightarrow> \\<guillemotleft>eval b\n        c : local.prod (exp b c) b \\<rightarrow> c\\<guillemotright>;\n        \\<And>b c a g.\n           \\<lbrakk>ide b; ide c; ide a;\n            \\<guillemotleft>g : local.prod a\n                                 b \\<rightarrow> c\\<guillemotright>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>!f.\n                                \\<guillemotleft>f : a \\<rightarrow> exp b\n                               c\\<guillemotright> \\<and>\n                                g = C (eval b c) (local.prod f b);\n        \\<And>a b c g.\n           \\<lbrakk>ide a; ide b; ide c;\n            \\<guillemotleft>g : local.prod a\n                                 b \\<rightarrow> c\\<guillemotright>\\<rbrakk>\n           \\<Longrightarrow> \\<guillemotleft>\\<Lambda> a b c\n        g : a \\<rightarrow> exp b c\\<guillemotright> \\<and>\n                             g =\n                             C (eval b c)\n                              (local.prod (\\<Lambda> a b c g) b);\n        \\<And>a b c h.\n           \\<lbrakk>ide a; ide b; ide c;\n            \\<guillemotleft>h : a \\<rightarrow> exp b\n           c\\<guillemotright>\\<rbrakk>\n           \\<Longrightarrow> \\<Lambda> a b c\n                              (C (eval b c) (local.prod h b)) =\n                             h;\n        ide a; ide b; ide c;\n        \\<guillemotleft>g : local.prod a\n                             b \\<rightarrow> c\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<guillemotleft>\\<Lambda> a b c\n    g : a \\<rightarrow> exp b c\\<guillemotright>\n 4. \\<And>a b c g.\n       \\<lbrakk>\\<And>b c.\n                   \\<lbrakk>ide b; ide c\\<rbrakk>\n                   \\<Longrightarrow> \\<guillemotleft>eval b\n                c : local.prod (exp b c) b \\<rightarrow> c\\<guillemotright>;\n        \\<And>b c.\n           \\<lbrakk>ide b; ide c\\<rbrakk> \\<Longrightarrow> ide (exp b c);\n        \\<And>b c.\n           \\<lbrakk>ide b; ide c\\<rbrakk>\n           \\<Longrightarrow> \\<guillemotleft>eval b\n        c : local.prod (exp b c) b \\<rightarrow> c\\<guillemotright>;\n        \\<And>b c a g.\n           \\<lbrakk>ide b; ide c; ide a;\n            \\<guillemotleft>g : local.prod a\n                                 b \\<rightarrow> c\\<guillemotright>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>!f.\n                                \\<guillemotleft>f : a \\<rightarrow> exp b\n                               c\\<guillemotright> \\<and>\n                                g = C (eval b c) (local.prod f b);\n        \\<And>a b c g.\n           \\<lbrakk>ide a; ide b; ide c;\n            \\<guillemotleft>g : local.prod a\n                                 b \\<rightarrow> c\\<guillemotright>\\<rbrakk>\n           \\<Longrightarrow> \\<guillemotleft>\\<Lambda> a b c\n        g : a \\<rightarrow> exp b c\\<guillemotright> \\<and>\n                             g =\n                             C (eval b c)\n                              (local.prod (\\<Lambda> a b c g) b);\n        \\<And>a b c h.\n           \\<lbrakk>ide a; ide b; ide c;\n            \\<guillemotleft>h : a \\<rightarrow> exp b\n           c\\<guillemotright>\\<rbrakk>\n           \\<Longrightarrow> \\<Lambda> a b c\n                              (C (eval b c) (local.prod h b)) =\n                             h;\n        ide a; ide b; ide c;\n        \\<guillemotleft>g : local.prod a\n                             b \\<rightarrow> c\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> C (eval b c) (local.prod (\\<Lambda> a b c g) b) = g\n 5. \\<And>a b c h.\n       \\<lbrakk>\\<And>b c.\n                   \\<lbrakk>ide b; ide c\\<rbrakk>\n                   \\<Longrightarrow> \\<guillemotleft>eval b\n                c : local.prod (exp b c) b \\<rightarrow> c\\<guillemotright>;\n        \\<And>b c.\n           \\<lbrakk>ide b; ide c\\<rbrakk> \\<Longrightarrow> ide (exp b c);\n        \\<And>b c.\n           \\<lbrakk>ide b; ide c\\<rbrakk>\n           \\<Longrightarrow> \\<guillemotleft>eval b\n        c : local.prod (exp b c) b \\<rightarrow> c\\<guillemotright>;\n        \\<And>b c a g.\n           \\<lbrakk>ide b; ide c; ide a;\n            \\<guillemotleft>g : local.prod a\n                                 b \\<rightarrow> c\\<guillemotright>\\<rbrakk>\n           \\<Longrightarrow> \\<exists>!f.\n                                \\<guillemotleft>f : a \\<rightarrow> exp b\n                               c\\<guillemotright> \\<and>\n                                g = C (eval b c) (local.prod f b);\n        \\<And>a b c g.\n           \\<lbrakk>ide a; ide b; ide c;\n            \\<guillemotleft>g : local.prod a\n                                 b \\<rightarrow> c\\<guillemotright>\\<rbrakk>\n           \\<Longrightarrow> \\<guillemotleft>\\<Lambda> a b c\n        g : a \\<rightarrow> exp b c\\<guillemotright> \\<and>\n                             g =\n                             C (eval b c)\n                              (local.prod (\\<Lambda> a b c g) b);\n        \\<And>a b c h.\n           \\<lbrakk>ide a; ide b; ide c;\n            \\<guillemotleft>h : a \\<rightarrow> exp b\n           c\\<guillemotright>\\<rbrakk>\n           \\<Longrightarrow> \\<Lambda> a b c\n                              (C (eval b c) (local.prod h b)) =\n                             h;\n        ide a; ide b; ide c;\n        \\<guillemotleft>h : a \\<rightarrow> exp b\n       c\\<guillemotright>\\<rbrakk>\n       \\<Longrightarrow> \\<Lambda> a b c (C (eval b c) (local.prod h b)) = h", "by auto"], ["", "lemma induces_elementary_cartesian_closed_category:\n    shows \"elementary_cartesian_closed_category C pr0 pr1 \\<one> trm exp eval \\<Lambda>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. elementary_cartesian_closed_category C pr0 pr1 \\<one> trm exp eval\n     \\<Lambda>", ".."], ["", "end"], ["", "context elementary_cartesian_closed_category\n  begin"], ["", "lemma left_adjoint_prod:\n    assumes \"ide b\"\n    shows \"left_adjoint_functor C C (\\<lambda>x. x \\<otimes> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left_adjoint_functor (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. left_adjoint_functor (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b)", "interpret \"functor\" C C \\<open>\\<lambda>x. x \\<otimes> b\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. functor (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b)", "proof"], ["proof (state)\ngoal (5 subgoals):\n 1. \\<And>f. \\<not> arr f \\<Longrightarrow> f \\<otimes> b = null\n 2. \\<And>f. arr f \\<Longrightarrow> arr (f \\<otimes> b)\n 3. \\<And>f.\n       arr f \\<Longrightarrow>\n       local.dom (f \\<otimes> b) = local.dom f \\<otimes> b\n 4. \\<And>f. arr f \\<Longrightarrow> cod (f \\<otimes> b) = cod f \\<otimes> b\n 5. \\<And>g f.\n       seq g f \\<Longrightarrow>\n       g \\<cdot> f \\<otimes> b = (g \\<otimes> b) \\<cdot> (f \\<otimes> b)", "show \"\\<And>f. \\<not> arr f \\<Longrightarrow> f \\<otimes> b = null\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f. \\<not> arr f \\<Longrightarrow> f \\<otimes> b = null", "using tuple_ext prod_def"], ["proof (prove)\nusing this:\n  \\<not> span ?f ?g \\<Longrightarrow> \\<langle>?f, ?g\\<rangle> = null\n  ?f \\<otimes> ?g \\<equiv>\n  \\<langle>?f \\<cdot>\n           \\<pp>\\<^sub>1[local.dom\n                          ?f, local.dom\n                               ?g], ?g \\<cdot>\n                                    \\<pp>\\<^sub>0[local.dom\n             ?f, local.dom ?g]\\<rangle>\n\ngoal (1 subgoal):\n 1. \\<And>f. \\<not> arr f \\<Longrightarrow> f \\<otimes> b = null", "by auto"], ["proof (state)\nthis:\n  \\<not> arr ?f4 \\<Longrightarrow> ?f4 \\<otimes> b = null\n\ngoal (4 subgoals):\n 1. \\<And>f. arr f \\<Longrightarrow> arr (f \\<otimes> b)\n 2. \\<And>f.\n       arr f \\<Longrightarrow>\n       local.dom (f \\<otimes> b) = local.dom f \\<otimes> b\n 3. \\<And>f. arr f \\<Longrightarrow> cod (f \\<otimes> b) = cod f \\<otimes> b\n 4. \\<And>g f.\n       seq g f \\<Longrightarrow>\n       g \\<cdot> f \\<otimes> b = (g \\<otimes> b) \\<cdot> (f \\<otimes> b)", "fix f"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>f. arr f \\<Longrightarrow> arr (f \\<otimes> b)\n 2. \\<And>f.\n       arr f \\<Longrightarrow>\n       local.dom (f \\<otimes> b) = local.dom f \\<otimes> b\n 3. \\<And>f. arr f \\<Longrightarrow> cod (f \\<otimes> b) = cod f \\<otimes> b\n 4. \\<And>g f.\n       seq g f \\<Longrightarrow>\n       g \\<cdot> f \\<otimes> b = (g \\<otimes> b) \\<cdot> (f \\<otimes> b)", "show \"arr f \\<Longrightarrow> dom (f \\<otimes> b) = dom f \\<otimes> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr f \\<Longrightarrow>\n    local.dom (f \\<otimes> b) = local.dom f \\<otimes> b", "using assms"], ["proof (prove)\nusing this:\n  ide b\n\ngoal (1 subgoal):\n 1. arr f \\<Longrightarrow>\n    local.dom (f \\<otimes> b) = local.dom f \\<otimes> b", "by simp"], ["proof (state)\nthis:\n  arr f \\<Longrightarrow>\n  local.dom (f \\<otimes> b) = local.dom f \\<otimes> b\n\ngoal (3 subgoals):\n 1. \\<And>f. arr f \\<Longrightarrow> arr (f \\<otimes> b)\n 2. \\<And>f. arr f \\<Longrightarrow> cod (f \\<otimes> b) = cod f \\<otimes> b\n 3. \\<And>g f.\n       seq g f \\<Longrightarrow>\n       g \\<cdot> f \\<otimes> b = (g \\<otimes> b) \\<cdot> (f \\<otimes> b)", "show \"arr f \\<Longrightarrow> arr (f \\<otimes> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr f \\<Longrightarrow> arr (f \\<otimes> b)", "using assms"], ["proof (prove)\nusing this:\n  ide b\n\ngoal (1 subgoal):\n 1. arr f \\<Longrightarrow> arr (f \\<otimes> b)", "by simp"], ["proof (state)\nthis:\n  arr f \\<Longrightarrow> arr (f \\<otimes> b)\n\ngoal (2 subgoals):\n 1. \\<And>f. arr f \\<Longrightarrow> cod (f \\<otimes> b) = cod f \\<otimes> b\n 2. \\<And>g f.\n       seq g f \\<Longrightarrow>\n       g \\<cdot> f \\<otimes> b = (g \\<otimes> b) \\<cdot> (f \\<otimes> b)", "show \"arr f \\<Longrightarrow> cod (f \\<otimes> b) = cod f \\<otimes> b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. arr f \\<Longrightarrow> cod (f \\<otimes> b) = cod f \\<otimes> b", "using assms"], ["proof (prove)\nusing this:\n  ide b\n\ngoal (1 subgoal):\n 1. arr f \\<Longrightarrow> cod (f \\<otimes> b) = cod f \\<otimes> b", "by simp"], ["proof (state)\nthis:\n  arr f \\<Longrightarrow> cod (f \\<otimes> b) = cod f \\<otimes> b\n\ngoal (1 subgoal):\n 1. \\<And>g f.\n       seq g f \\<Longrightarrow>\n       g \\<cdot> f \\<otimes> b = (g \\<otimes> b) \\<cdot> (f \\<otimes> b)", "fix g"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>g f.\n       seq g f \\<Longrightarrow>\n       g \\<cdot> f \\<otimes> b = (g \\<otimes> b) \\<cdot> (f \\<otimes> b)", "show \"seq g f \\<Longrightarrow> g \\<cdot> f \\<otimes> b = (g \\<otimes> b) \\<cdot> (f \\<otimes> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq g f \\<Longrightarrow>\n    g \\<cdot> f \\<otimes> b = (g \\<otimes> b) \\<cdot> (f \\<otimes> b)", "using assms interchange"], ["proof (prove)\nusing this:\n  ide b\n  \\<lbrakk>seq ?h ?f; seq ?k ?g\\<rbrakk>\n  \\<Longrightarrow> (?h \\<otimes> ?k) \\<cdot> (?f \\<otimes> ?g) =\n                    ?h \\<cdot> ?f \\<otimes> ?k \\<cdot> ?g\n\ngoal (1 subgoal):\n 1. seq g f \\<Longrightarrow>\n    g \\<cdot> f \\<otimes> b = (g \\<otimes> b) \\<cdot> (f \\<otimes> b)", "by simp"], ["proof (state)\nthis:\n  seq g f \\<Longrightarrow>\n  g \\<cdot> f \\<otimes> b = (g \\<otimes> b) \\<cdot> (f \\<otimes> b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\ngoal (1 subgoal):\n 1. left_adjoint_functor (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b)", "interpret left_adjoint_functor C C \\<open>\\<lambda>x. x \\<otimes> b\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. left_adjoint_functor (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y.\n       ide y \\<Longrightarrow>\n       \\<exists>x e.\n          terminal_arrow_from_functor (\\<cdot>) (\\<cdot>)\n           (\\<lambda>x. x \\<otimes> b) x y e", "show \"\\<And>c. ide c \\<Longrightarrow> \\<exists>x e. terminal_arrow_from_functor C C (\\<lambda>x. x \\<otimes> b) x c e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>c.\n       ide c \\<Longrightarrow>\n       \\<exists>x e.\n          terminal_arrow_from_functor (\\<cdot>) (\\<cdot>)\n           (\\<lambda>x. x \\<otimes> b) x c e", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c.\n       ide c \\<Longrightarrow>\n       \\<exists>x e.\n          terminal_arrow_from_functor (\\<cdot>) (\\<cdot>)\n           (\\<lambda>x. x \\<otimes> b) x c e", "fix c"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c.\n       ide c \\<Longrightarrow>\n       \\<exists>x e.\n          terminal_arrow_from_functor (\\<cdot>) (\\<cdot>)\n           (\\<lambda>x. x \\<otimes> b) x c e", "assume c: \"ide c\""], ["proof (state)\nthis:\n  ide c\n\ngoal (1 subgoal):\n 1. \\<And>c.\n       ide c \\<Longrightarrow>\n       \\<exists>x e.\n          terminal_arrow_from_functor (\\<cdot>) (\\<cdot>)\n           (\\<lambda>x. x \\<otimes> b) x c e", "show \"\\<exists>x e. terminal_arrow_from_functor C C (\\<lambda>x. x \\<otimes> b) x c e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>x e.\n       terminal_arrow_from_functor (\\<cdot>) (\\<cdot>)\n        (\\<lambda>x. x \\<otimes> b) x c e", "proof (intro exI)"], ["proof (state)\ngoal (1 subgoal):\n 1. terminal_arrow_from_functor (\\<cdot>) (\\<cdot>)\n     (\\<lambda>x. x \\<otimes> b) ?x c ?e1", "interpret arrow_from_functor C C \\<open>\\<lambda>x. x \\<otimes> b\\<close> \\<open>exp b c\\<close> c \\<open>eval b c\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. arrow_from_functor (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b)\n     (exp b c) c (eval b c)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. ide (exp b c) \\<and>\n    \\<guillemotleft>eval b\n                     c : exp b c \\<otimes>\n                         b \\<rightarrow> c\\<guillemotright>", "show \"ide (exp b c) \\<and> \\<guillemotleft>eval b c : exp b c \\<otimes> b \\<rightarrow> c\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide (exp b c) \\<and>\n    \\<guillemotleft>eval b\n                     c : exp b c \\<otimes>\n                         b \\<rightarrow> c\\<guillemotright>", "proof (intro conjI)"], ["proof (state)\ngoal (2 subgoals):\n 1. ide (exp b c)\n 2. \\<guillemotleft>eval b\n                     c : exp b c \\<otimes>\n                         b \\<rightarrow> c\\<guillemotright>", "show \"\\<guillemotleft>eval b c : exp b c \\<otimes> b \\<rightarrow> c\\<guillemotright>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>eval b\n                     c : exp b c \\<otimes>\n                         b \\<rightarrow> c\\<guillemotright>", "using assms c eval_in_hom"], ["proof (prove)\nusing this:\n  ide b\n  ide c\n  \\<lbrakk>ide ?b; ide ?c\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>eval ?b\n                                     ?c : exp ?b ?c \\<otimes>\n    ?b \\<rightarrow> ?c\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>eval b\n                     c : exp b c \\<otimes>\n                         b \\<rightarrow> c\\<guillemotright>", "by simp"], ["proof (state)\nthis:\n  \\<guillemotleft>eval b\n                   c : exp b c \\<otimes> b \\<rightarrow> c\\<guillemotright>\n\ngoal (1 subgoal):\n 1. ide (exp b c)", "show \"ide (exp b c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide (exp b c)", "using assms c ide_exp"], ["proof (prove)\nusing this:\n  ide b\n  ide c\n  \\<lbrakk>ide ?b; ide ?c\\<rbrakk> \\<Longrightarrow> ide (exp ?b ?c)\n\ngoal (1 subgoal):\n 1. ide (exp b c)", "by simp"], ["proof (state)\nthis:\n  ide (exp b c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ide (exp b c) \\<and>\n  \\<guillemotleft>eval b\n                   c : exp b c \\<otimes> b \\<rightarrow> c\\<guillemotright>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\ngoal (1 subgoal):\n 1. terminal_arrow_from_functor (\\<cdot>) (\\<cdot>)\n     (\\<lambda>x. x \\<otimes> b) ?x c ?e1", "interpret terminal_arrow_from_functor C C \\<open>\\<lambda>x. x \\<otimes> b\\<close> \\<open>exp b c\\<close> c \\<open>eval b c\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. terminal_arrow_from_functor (\\<cdot>) (\\<cdot>)\n     (\\<lambda>x. x \\<otimes> b) (exp b c) c (eval b c)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x' f.\n       arrow_from_functor (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b) x'\n        c f \\<Longrightarrow>\n       \\<exists>!g. is_coext x' f g", "show \"\\<And>a f. arrow_from_functor C C (\\<lambda>x. x \\<otimes> b) a c f \\<Longrightarrow>\n                            \\<exists>!g. arrow_from_functor.is_coext C C\n                                   (\\<lambda>x. x \\<otimes> b) (exp b c) (eval b c) a f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a f.\n       arrow_from_functor (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b) a\n        c f \\<Longrightarrow>\n       \\<exists>!g. is_coext a f g", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a f.\n       arrow_from_functor (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b) a\n        c f \\<Longrightarrow>\n       \\<exists>!g. is_coext a f g", "fix a f"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a f.\n       arrow_from_functor (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b) a\n        c f \\<Longrightarrow>\n       \\<exists>!g. is_coext a f g", "assume f: \"arrow_from_functor C C (\\<lambda>x. x \\<otimes> b) a c f\""], ["proof (state)\nthis:\n  arrow_from_functor (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b) a c f\n\ngoal (1 subgoal):\n 1. \\<And>a f.\n       arrow_from_functor (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b) a\n        c f \\<Longrightarrow>\n       \\<exists>!g. is_coext a f g", "interpret f: arrow_from_functor C C \\<open>\\<lambda>x. x \\<otimes> b\\<close> a c f"], ["proof (prove)\ngoal (1 subgoal):\n 1. arrow_from_functor (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b) a c f", "using f"], ["proof (prove)\nusing this:\n  arrow_from_functor (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b) a c f\n\ngoal (1 subgoal):\n 1. arrow_from_functor (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b) a c f", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a f.\n       arrow_from_functor (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b) a\n        c f \\<Longrightarrow>\n       \\<exists>!g. is_coext a f g", "show \"\\<exists>!g. is_coext a f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>!g. is_coext a f g", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. is_coext a f ?a\n 2. \\<And>g. is_coext a f g \\<Longrightarrow> g = ?a", "have a: \"ide a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ide a", "using f.arrow"], ["proof (prove)\nusing this:\n  ide a \\<and>\n  \\<guillemotleft>f : a \\<otimes> b \\<rightarrow> c\\<guillemotright>\n\ngoal (1 subgoal):\n 1. ide a", "by simp"], ["proof (state)\nthis:\n  ide a\n\ngoal (2 subgoals):\n 1. is_coext a f ?a\n 2. \\<And>g. is_coext a f g \\<Longrightarrow> g = ?a", "show \"is_coext a f (\\<Lambda> a b c f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_coext a f (\\<Lambda> a b c f)", "unfolding is_coext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<Lambda> a b c\n                     f : a \\<rightarrow> exp b c\\<guillemotright> \\<and>\n    f = eval b c \\<cdot> (\\<Lambda> a b c f \\<otimes> b)", "using assms a c lam_in_hom [of a b c f] eval_prod_lam [of a b c f]\n                          f.arrow"], ["proof (prove)\nusing this:\n  ide b\n  ide a\n  ide c\n  \\<lbrakk>ide a; ide b; ide c;\n   \\<guillemotleft>f : a \\<otimes>\n                       b \\<rightarrow> c\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> \\<guillemotleft>\\<Lambda> a b c\n                                     f : a \\<rightarrow> exp b\n                    c\\<guillemotright>\n  \\<lbrakk>ide a; ide b; ide c;\n   \\<guillemotleft>f : a \\<otimes>\n                       b \\<rightarrow> c\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> eval b c \\<cdot> (\\<Lambda> a b c f \\<otimes> b) = f\n  ide a \\<and>\n  \\<guillemotleft>f : a \\<otimes> b \\<rightarrow> c\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<guillemotleft>\\<Lambda> a b c\n                     f : a \\<rightarrow> exp b c\\<guillemotright> \\<and>\n    f = eval b c \\<cdot> (\\<Lambda> a b c f \\<otimes> b)", "by simp"], ["proof (state)\nthis:\n  is_coext a f (\\<Lambda> a b c f)\n\ngoal (1 subgoal):\n 1. \\<And>g. is_coext a f g \\<Longrightarrow> g = \\<Lambda> a b c f", "show \"\\<And>g. is_coext a f g \\<Longrightarrow> g = \\<Lambda> a b c f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g. is_coext a f g \\<Longrightarrow> g = \\<Lambda> a b c f", "unfolding is_coext_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g.\n       \\<guillemotleft>g : a \\<rightarrow> exp b c\\<guillemotright> \\<and>\n       f = eval b c \\<cdot> (g \\<otimes> b) \\<Longrightarrow>\n       g = \\<Lambda> a b c f", "using assms a c lam_eval_prod [of a b c] f.arrow"], ["proof (prove)\nusing this:\n  ide b\n  ide a\n  ide c\n  \\<lbrakk>ide a; ide b; ide c;\n   \\<guillemotleft>?h : a \\<rightarrow> exp b c\\<guillemotright>\\<rbrakk>\n  \\<Longrightarrow> \\<Lambda> a b c (eval b c \\<cdot> (?h \\<otimes> b)) = ?h\n  ide a \\<and>\n  \\<guillemotleft>f : a \\<otimes> b \\<rightarrow> c\\<guillemotright>\n\ngoal (1 subgoal):\n 1. \\<And>g.\n       \\<guillemotleft>g : a \\<rightarrow> exp b c\\<guillemotright> \\<and>\n       f = eval b c \\<cdot> (g \\<otimes> b) \\<Longrightarrow>\n       g = \\<Lambda> a b c f", "by simp"], ["proof (state)\nthis:\n  is_coext a f ?g4 \\<Longrightarrow> ?g4 = \\<Lambda> a b c f\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>!g. is_coext a f g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  arrow_from_functor (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b) ?a4 c\n   ?f4 \\<Longrightarrow>\n  \\<exists>!g. is_coext ?a4 ?f4 g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\ngoal (1 subgoal):\n 1. terminal_arrow_from_functor (\\<cdot>) (\\<cdot>)\n     (\\<lambda>x. x \\<otimes> b) ?x c ?e1", "show \"terminal_arrow_from_functor C C (\\<lambda>x. x \\<otimes> b) (exp b c) c (eval b c)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. terminal_arrow_from_functor (\\<cdot>) (\\<cdot>)\n     (\\<lambda>x. x \\<otimes> b) (exp b c) c (eval b c)", ".."], ["proof (state)\nthis:\n  terminal_arrow_from_functor (\\<cdot>) (\\<cdot>)\n   (\\<lambda>x. x \\<otimes> b) (exp b c) c (eval b c)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>x e.\n     terminal_arrow_from_functor (\\<cdot>) (\\<cdot>)\n      (\\<lambda>x. x \\<otimes> b) x c e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  ide ?c4 \\<Longrightarrow>\n  \\<exists>x e.\n     terminal_arrow_from_functor (\\<cdot>) (\\<cdot>)\n      (\\<lambda>x. x \\<otimes> b) x ?c4 e\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\ngoal (1 subgoal):\n 1. left_adjoint_functor (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. left_adjoint_functor (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b)", ".."], ["proof (state)\nthis:\n  left_adjoint_functor (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b)\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation CCC: cartesian_category C"], ["proof (prove)\ngoal (1 subgoal):\n 1. cartesian_category (\\<cdot>)", "using is_cartesian_category"], ["proof (prove)\nusing this:\n  cartesian_category (\\<cdot>)\n\ngoal (1 subgoal):\n 1. cartesian_category (\\<cdot>)", "by simp"], ["", "interpretation CCC: cartesian_closed_category C"], ["proof (prove)\ngoal (1 subgoal):\n 1. cartesian_closed_category (\\<cdot>)", "proof"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>b f.\n       \\<lbrakk>ide b; \\<not> arr f\\<rbrakk>\n       \\<Longrightarrow> CCC.prod f b = null\n 2. \\<And>b f.\n       \\<lbrakk>ide b; arr f\\<rbrakk> \\<Longrightarrow> arr (CCC.prod f b)\n 3. \\<And>b f.\n       \\<lbrakk>ide b; arr f\\<rbrakk>\n       \\<Longrightarrow> local.dom (CCC.prod f b) = CCC.prod (local.dom f) b\n 4. \\<And>b f.\n       \\<lbrakk>ide b; arr f\\<rbrakk>\n       \\<Longrightarrow> cod (CCC.prod f b) = CCC.prod (cod f) b\n 5. \\<And>b g f.\n       \\<lbrakk>ide b; seq g f\\<rbrakk>\n       \\<Longrightarrow> CCC.prod (g \\<cdot> f) b =\n                         CCC.prod g b \\<cdot> CCC.prod f b\n 6. \\<And>b y.\n       \\<lbrakk>ide b; ide y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x e.\n                            terminal_arrow_from_functor (\\<cdot>) (\\<cdot>)\n                             (\\<lambda>x. CCC.prod x b) x y e", "fix b"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>b f.\n       \\<lbrakk>ide b; \\<not> arr f\\<rbrakk>\n       \\<Longrightarrow> CCC.prod f b = null\n 2. \\<And>b f.\n       \\<lbrakk>ide b; arr f\\<rbrakk> \\<Longrightarrow> arr (CCC.prod f b)\n 3. \\<And>b f.\n       \\<lbrakk>ide b; arr f\\<rbrakk>\n       \\<Longrightarrow> local.dom (CCC.prod f b) = CCC.prod (local.dom f) b\n 4. \\<And>b f.\n       \\<lbrakk>ide b; arr f\\<rbrakk>\n       \\<Longrightarrow> cod (CCC.prod f b) = CCC.prod (cod f) b\n 5. \\<And>b g f.\n       \\<lbrakk>ide b; seq g f\\<rbrakk>\n       \\<Longrightarrow> CCC.prod (g \\<cdot> f) b =\n                         CCC.prod g b \\<cdot> CCC.prod f b\n 6. \\<And>b y.\n       \\<lbrakk>ide b; ide y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x e.\n                            terminal_arrow_from_functor (\\<cdot>) (\\<cdot>)\n                             (\\<lambda>x. CCC.prod x b) x y e", "assume b: \"ide b\""], ["proof (state)\nthis:\n  ide b\n\ngoal (6 subgoals):\n 1. \\<And>b f.\n       \\<lbrakk>ide b; \\<not> arr f\\<rbrakk>\n       \\<Longrightarrow> CCC.prod f b = null\n 2. \\<And>b f.\n       \\<lbrakk>ide b; arr f\\<rbrakk> \\<Longrightarrow> arr (CCC.prod f b)\n 3. \\<And>b f.\n       \\<lbrakk>ide b; arr f\\<rbrakk>\n       \\<Longrightarrow> local.dom (CCC.prod f b) = CCC.prod (local.dom f) b\n 4. \\<And>b f.\n       \\<lbrakk>ide b; arr f\\<rbrakk>\n       \\<Longrightarrow> cod (CCC.prod f b) = CCC.prod (cod f) b\n 5. \\<And>b g f.\n       \\<lbrakk>ide b; seq g f\\<rbrakk>\n       \\<Longrightarrow> CCC.prod (g \\<cdot> f) b =\n                         CCC.prod g b \\<cdot> CCC.prod f b\n 6. \\<And>b y.\n       \\<lbrakk>ide b; ide y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x e.\n                            terminal_arrow_from_functor (\\<cdot>) (\\<cdot>)\n                             (\\<lambda>x. CCC.prod x b) x y e", "interpret left_adjoint_functor C C \\<open>\\<lambda>x. CCC.prod x b\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. left_adjoint_functor (\\<cdot>) (\\<cdot>) (\\<lambda>x. CCC.prod x b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. left_adjoint_functor (\\<cdot>) (\\<cdot>) (\\<lambda>x. CCC.prod x b)", "(*\n         * We know that (\\<lambda>x. x \\<otimes> b) is a left adjoint functor, where \\<otimes> is the\n         * product ultimately defined in terms of the projections that are parameters\n         * to the elementary_category_with_binary_products locale that is the present context.\n         * This is not necessarily the same as (\\<lambda>x. CCC.prod x b), which is defined in terms\n         * of projections chosen arbitrarily in category_with_binary_products.\n         * However, since they are both categorical products, they are naturally isomorphic,\n         * so one is a left adjoint functor if and only if the other is.\n         *)"], ["proof (state)\ngoal (1 subgoal):\n 1. left_adjoint_functor (\\<cdot>) (\\<cdot>) (\\<lambda>x. CCC.prod x b)", "have \"naturally_isomorphic C C (\\<lambda>x. x \\<otimes> b) (\\<lambda>x. CCC.prod x b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. naturally_isomorphic (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b)\n     (\\<lambda>x. CCC.prod x b)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. naturally_isomorphic (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b)\n     (\\<lambda>x. CCC.prod x b)", "interpret CC: product_category C C"], ["proof (prove)\ngoal (1 subgoal):\n 1. product_category (\\<cdot>) (\\<cdot>)", ".."], ["proof (state)\ngoal (1 subgoal):\n 1. naturally_isomorphic (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b)\n     (\\<lambda>x. CCC.prod x b)", "interpret X: binary_functor C C C \\<open>\\<lambda>fg. fst fg \\<otimes> snd fg\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. binary_functor (\\<cdot>) (\\<cdot>) (\\<cdot>) local.Prod", "using binary_functor_Prod(1)"], ["proof (prove)\nusing this:\n  binary_functor (\\<cdot>) (\\<cdot>) (\\<cdot>) local.Prod\n\ngoal (1 subgoal):\n 1. binary_functor (\\<cdot>) (\\<cdot>) (\\<cdot>) local.Prod", "by auto"], ["proof (state)\ngoal (1 subgoal):\n 1. naturally_isomorphic (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b)\n     (\\<lambda>x. CCC.prod x b)", "interpret Xb: \"functor\" C C \\<open>\\<lambda>x. x \\<otimes> b\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. functor (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b)", "using b X.fixing_ide_gives_functor_2"], ["proof (prove)\nusing this:\n  ide b\n  ide ?a2.0 \\<Longrightarrow>\n  functor (\\<cdot>) (\\<cdot>) (\\<lambda>f1. local.Prod (f1, ?a2.0))\n\ngoal (1 subgoal):\n 1. functor (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b)", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. naturally_isomorphic (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b)\n     (\\<lambda>x. CCC.prod x b)", "interpret prod: binary_functor C C C \\<open>\\<lambda>fg. CCC.prod (fst fg) (snd fg)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. binary_functor (\\<cdot>) (\\<cdot>) (\\<cdot>) CCC.Prod", "using CCC.binary_functor_Prod(1)"], ["proof (prove)\nusing this:\n  binary_functor (\\<cdot>) (\\<cdot>) (\\<cdot>) CCC.Prod\n\ngoal (1 subgoal):\n 1. binary_functor (\\<cdot>) (\\<cdot>) (\\<cdot>) CCC.Prod", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. naturally_isomorphic (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b)\n     (\\<lambda>x. CCC.prod x b)", "interpret prod_b: \"functor\" C C \\<open>\\<lambda>x. CCC.prod x b\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. functor (\\<cdot>) (\\<cdot>) (\\<lambda>x. CCC.prod x b)", "using b prod.fixing_ide_gives_functor_2"], ["proof (prove)\nusing this:\n  ide b\n  ide ?a2.0 \\<Longrightarrow>\n  functor (\\<cdot>) (\\<cdot>) (\\<lambda>f1. CCC.Prod (f1, ?a2.0))\n\ngoal (1 subgoal):\n 1. functor (\\<cdot>) (\\<cdot>) (\\<lambda>x. CCC.prod x b)", "by simp"], ["proof (state)\ngoal (1 subgoal):\n 1. naturally_isomorphic (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b)\n     (\\<lambda>x. CCC.prod x b)", "interpret \\<phi>: transformation_by_components C C \\<open>\\<lambda>x. x \\<otimes> b\\<close> \\<open>\\<lambda>x. CCC.prod x b\\<close>\n                         \\<open>\\<lambda>a. CCC.tuple (pr1 a b) (pr0 a b)\\<close>"], ["proof (prove)\ngoal (1 subgoal):\n 1. transformation_by_components (\\<cdot>) (\\<cdot>)\n     (\\<lambda>x. x \\<otimes> b) (\\<lambda>x. CCC.prod x b)\n     (\\<lambda>a. CCC.tuple \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b])", "using b CCC.prod_tuple"], ["proof (prove)\nusing this:\n  ide b\n  \\<lbrakk>span ?f ?g; seq ?h ?f; seq ?k ?g\\<rbrakk>\n  \\<Longrightarrow> CCC.prod ?h ?k \\<cdot> CCC.tuple ?f ?g =\n                    CCC.tuple (?h \\<cdot> ?f) (?k \\<cdot> ?g)\n\ngoal (1 subgoal):\n 1. transformation_by_components (\\<cdot>) (\\<cdot>)\n     (\\<lambda>x. x \\<otimes> b) (\\<lambda>x. CCC.prod x b)\n     (\\<lambda>a. CCC.tuple \\<pp>\\<^sub>1[a, b] \\<pp>\\<^sub>0[a, b])", "by unfold_locales auto"], ["proof (state)\ngoal (1 subgoal):\n 1. naturally_isomorphic (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b)\n     (\\<lambda>x. CCC.prod x b)", "interpret \\<phi>: natural_isomorphism C C \\<open>\\<lambda>x. x \\<otimes> b\\<close> \\<open>\\<lambda>x. CCC.prod x b\\<close> \\<phi>.map"], ["proof (prove)\ngoal (1 subgoal):\n 1. natural_isomorphism (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b)\n     (\\<lambda>x. CCC.prod x b) \\<phi>.map", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. ide a \\<Longrightarrow> local.iso (\\<phi>.map a)", "fix a"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a. ide a \\<Longrightarrow> local.iso (\\<phi>.map a)", "assume a: \"ide a\""], ["proof (state)\nthis:\n  ide a\n\ngoal (1 subgoal):\n 1. \\<And>a. ide a \\<Longrightarrow> local.iso (\\<phi>.map a)", "show \"iso (\\<phi>.map a)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. local.iso (\\<phi>.map a)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. inverse_arrows (\\<phi>.map a) ?g", "show \"inverse_arrows (\\<phi>.map a) \\<langle>CCC.pr1 a b, CCC.pr0 a b\\<rangle>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. inverse_arrows (\\<phi>.map a) \\<langle>CCC.pr1 a b, CCC.pr0 a b\\<rangle>", "using a b"], ["proof (prove)\nusing this:\n  ide a\n  ide b\n\ngoal (1 subgoal):\n 1. inverse_arrows (\\<phi>.map a) \\<langle>CCC.pr1 a b, CCC.pr0 a b\\<rangle>", "by auto"], ["proof (state)\nthis:\n  inverse_arrows (\\<phi>.map a) \\<langle>CCC.pr1 a b, CCC.pr0 a b\\<rangle>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  local.iso (\\<phi>.map a)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\ngoal (1 subgoal):\n 1. naturally_isomorphic (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b)\n     (\\<lambda>x. CCC.prod x b)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. naturally_isomorphic (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b)\n     (\\<lambda>x. CCC.prod x b)", "using naturally_isomorphic_def \\<phi>.natural_isomorphism_axioms"], ["proof (prove)\nusing this:\n  naturally_isomorphic ?A ?B ?F ?G =\n  (\\<exists>\\<tau>. natural_isomorphism ?A ?B ?F ?G \\<tau>)\n  natural_isomorphism (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b)\n   (\\<lambda>x. CCC.prod x b) \\<phi>.map\n\ngoal (1 subgoal):\n 1. naturally_isomorphic (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b)\n     (\\<lambda>x. CCC.prod x b)", "by blast"], ["proof (state)\nthis:\n  naturally_isomorphic (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b)\n   (\\<lambda>x. CCC.prod x b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  naturally_isomorphic (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b)\n   (\\<lambda>x. CCC.prod x b)\n\ngoal (1 subgoal):\n 1. left_adjoint_functor (\\<cdot>) (\\<cdot>) (\\<lambda>x. CCC.prod x b)", "moreover"], ["proof (state)\nthis:\n  naturally_isomorphic (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b)\n   (\\<lambda>x. CCC.prod x b)\n\ngoal (1 subgoal):\n 1. left_adjoint_functor (\\<cdot>) (\\<cdot>) (\\<lambda>x. CCC.prod x b)", "have \"left_adjoint_functor C C (\\<lambda>x. x \\<otimes> b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. left_adjoint_functor (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b)", "using b left_adjoint_prod [of b]"], ["proof (prove)\nusing this:\n  ide b\n  ide b \\<Longrightarrow>\n  left_adjoint_functor (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b)\n\ngoal (1 subgoal):\n 1. left_adjoint_functor (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b)", "by simp"], ["proof (state)\nthis:\n  left_adjoint_functor (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b)\n\ngoal (1 subgoal):\n 1. left_adjoint_functor (\\<cdot>) (\\<cdot>) (\\<lambda>x. CCC.prod x b)", "ultimately"], ["proof (chain)\npicking this:\n  naturally_isomorphic (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b)\n   (\\<lambda>x. CCC.prod x b)\n  left_adjoint_functor (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b)", "show \"left_adjoint_functor C C (\\<lambda>x. CCC.prod x b)\""], ["proof (prove)\nusing this:\n  naturally_isomorphic (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b)\n   (\\<lambda>x. CCC.prod x b)\n  left_adjoint_functor (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b)\n\ngoal (1 subgoal):\n 1. left_adjoint_functor (\\<cdot>) (\\<cdot>) (\\<lambda>x. CCC.prod x b)", "using left_adjoint_functor_respects_naturally_isomorphic"], ["proof (prove)\nusing this:\n  naturally_isomorphic (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b)\n   (\\<lambda>x. CCC.prod x b)\n  left_adjoint_functor (\\<cdot>) (\\<cdot>) (\\<lambda>x. x \\<otimes> b)\n  \\<lbrakk>left_adjoint_functor ?D ?C ?F;\n   naturally_isomorphic ?D ?C ?F ?F'\\<rbrakk>\n  \\<Longrightarrow> left_adjoint_functor ?D ?C ?F'\n\ngoal (1 subgoal):\n 1. left_adjoint_functor (\\<cdot>) (\\<cdot>) (\\<lambda>x. CCC.prod x b)", "by auto"], ["proof (state)\nthis:\n  left_adjoint_functor (\\<cdot>) (\\<cdot>) (\\<lambda>x. CCC.prod x b)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\ngoal (6 subgoals):\n 1. \\<And>b f.\n       \\<lbrakk>ide b; \\<not> arr f\\<rbrakk>\n       \\<Longrightarrow> CCC.prod f b = null\n 2. \\<And>b f.\n       \\<lbrakk>ide b; arr f\\<rbrakk> \\<Longrightarrow> arr (CCC.prod f b)\n 3. \\<And>b f.\n       \\<lbrakk>ide b; arr f\\<rbrakk>\n       \\<Longrightarrow> local.dom (CCC.prod f b) = CCC.prod (local.dom f) b\n 4. \\<And>b f.\n       \\<lbrakk>ide b; arr f\\<rbrakk>\n       \\<Longrightarrow> cod (CCC.prod f b) = CCC.prod (cod f) b\n 5. \\<And>b g f.\n       \\<lbrakk>ide b; seq g f\\<rbrakk>\n       \\<Longrightarrow> CCC.prod (g \\<cdot> f) b =\n                         CCC.prod g b \\<cdot> CCC.prod f b\n 6. \\<And>b y.\n       \\<lbrakk>ide b; ide y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x e.\n                            terminal_arrow_from_functor (\\<cdot>) (\\<cdot>)\n                             (\\<lambda>x. CCC.prod x b) x y e", "show \"\\<And>f. \\<not> arr f \\<Longrightarrow> CCC.prod f b = null\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f. \\<not> arr f \\<Longrightarrow> CCC.prod f b = null", "using is_extensional"], ["proof (prove)\nusing this:\n  \\<not> arr ?f \\<Longrightarrow> CCC.prod ?f b = null\n\ngoal (1 subgoal):\n 1. \\<And>f. \\<not> arr f \\<Longrightarrow> CCC.prod f b = null", "by blast"], ["proof (state)\nthis:\n  \\<not> arr ?f4 \\<Longrightarrow> CCC.prod ?f4 b = null\n\ngoal (5 subgoals):\n 1. \\<And>b f.\n       \\<lbrakk>ide b; arr f\\<rbrakk> \\<Longrightarrow> arr (CCC.prod f b)\n 2. \\<And>b f.\n       \\<lbrakk>ide b; arr f\\<rbrakk>\n       \\<Longrightarrow> local.dom (CCC.prod f b) = CCC.prod (local.dom f) b\n 3. \\<And>b f.\n       \\<lbrakk>ide b; arr f\\<rbrakk>\n       \\<Longrightarrow> cod (CCC.prod f b) = CCC.prod (cod f) b\n 4. \\<And>b g f.\n       \\<lbrakk>ide b; seq g f\\<rbrakk>\n       \\<Longrightarrow> CCC.prod (g \\<cdot> f) b =\n                         CCC.prod g b \\<cdot> CCC.prod f b\n 5. \\<And>b y.\n       \\<lbrakk>ide b; ide y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x e.\n                            terminal_arrow_from_functor (\\<cdot>) (\\<cdot>)\n                             (\\<lambda>x. CCC.prod x b) x y e", "show \"\\<And>f. arr f \\<Longrightarrow> dom (CCC.prod f b) = CCC.prod (dom f) b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f.\n       arr f \\<Longrightarrow>\n       local.dom (CCC.prod f b) = CCC.prod (local.dom f) b", "by simp"], ["proof (state)\nthis:\n  arr ?f4 \\<Longrightarrow>\n  local.dom (CCC.prod ?f4 b) = CCC.prod (local.dom ?f4) b\n\ngoal (4 subgoals):\n 1. \\<And>b f.\n       \\<lbrakk>ide b; arr f\\<rbrakk> \\<Longrightarrow> arr (CCC.prod f b)\n 2. \\<And>b f.\n       \\<lbrakk>ide b; arr f\\<rbrakk>\n       \\<Longrightarrow> cod (CCC.prod f b) = CCC.prod (cod f) b\n 3. \\<And>b g f.\n       \\<lbrakk>ide b; seq g f\\<rbrakk>\n       \\<Longrightarrow> CCC.prod (g \\<cdot> f) b =\n                         CCC.prod g b \\<cdot> CCC.prod f b\n 4. \\<And>b y.\n       \\<lbrakk>ide b; ide y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x e.\n                            terminal_arrow_from_functor (\\<cdot>) (\\<cdot>)\n                             (\\<lambda>x. CCC.prod x b) x y e", "show \"\\<And>f. arr f \\<Longrightarrow> cod (CCC.prod f b) = CCC.prod (cod f) b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f. arr f \\<Longrightarrow> cod (CCC.prod f b) = CCC.prod (cod f) b", "by simp"], ["proof (state)\nthis:\n  arr ?f4 \\<Longrightarrow> cod (CCC.prod ?f4 b) = CCC.prod (cod ?f4) b\n\ngoal (3 subgoals):\n 1. \\<And>b f.\n       \\<lbrakk>ide b; arr f\\<rbrakk> \\<Longrightarrow> arr (CCC.prod f b)\n 2. \\<And>b g f.\n       \\<lbrakk>ide b; seq g f\\<rbrakk>\n       \\<Longrightarrow> CCC.prod (g \\<cdot> f) b =\n                         CCC.prod g b \\<cdot> CCC.prod f b\n 3. \\<And>b y.\n       \\<lbrakk>ide b; ide y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x e.\n                            terminal_arrow_from_functor (\\<cdot>) (\\<cdot>)\n                             (\\<lambda>x. CCC.prod x b) x y e", "show \"\\<And>f. arr f \\<Longrightarrow> arr (CCC.prod f b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>f. arr f \\<Longrightarrow> arr (CCC.prod f b)", "by simp"], ["proof (state)\nthis:\n  arr ?f4 \\<Longrightarrow> arr (CCC.prod ?f4 b)\n\ngoal (2 subgoals):\n 1. \\<And>b g f.\n       \\<lbrakk>ide b; seq g f\\<rbrakk>\n       \\<Longrightarrow> CCC.prod (g \\<cdot> f) b =\n                         CCC.prod g b \\<cdot> CCC.prod f b\n 2. \\<And>b y.\n       \\<lbrakk>ide b; ide y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x e.\n                            terminal_arrow_from_functor (\\<cdot>) (\\<cdot>)\n                             (\\<lambda>x. CCC.prod x b) x y e", "show \"\\<And>g f. seq g f \\<Longrightarrow> CCC.prod (g \\<cdot> f) b = CCC.prod g b \\<cdot> CCC.prod f b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>g f.\n       seq g f \\<Longrightarrow>\n       CCC.prod (g \\<cdot> f) b = CCC.prod g b \\<cdot> CCC.prod f b", "by simp"], ["proof (state)\nthis:\n  seq ?g4 ?f4 \\<Longrightarrow>\n  CCC.prod (?g4 \\<cdot> ?f4) b = CCC.prod ?g4 b \\<cdot> CCC.prod ?f4 b\n\ngoal (1 subgoal):\n 1. \\<And>b y.\n       \\<lbrakk>ide b; ide y\\<rbrakk>\n       \\<Longrightarrow> \\<exists>x e.\n                            terminal_arrow_from_functor (\\<cdot>) (\\<cdot>)\n                             (\\<lambda>x. CCC.prod x b) x y e", "show \"\\<And>y. ide y \\<Longrightarrow> \\<exists>x e. terminal_arrow_from_functor (\\<cdot>) (\\<cdot>) (\\<lambda>x. CCC.prod x b) x y e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>y.\n       ide y \\<Longrightarrow>\n       \\<exists>x e.\n          terminal_arrow_from_functor (\\<cdot>) (\\<cdot>)\n           (\\<lambda>x. CCC.prod x b) x y e", "using ex_terminal_arrow"], ["proof (prove)\nusing this:\n  ide ?y \\<Longrightarrow>\n  \\<exists>x e.\n     terminal_arrow_from_functor (\\<cdot>) (\\<cdot>)\n      (\\<lambda>x. CCC.prod x b) x ?y e\n\ngoal (1 subgoal):\n 1. \\<And>y.\n       ide y \\<Longrightarrow>\n       \\<exists>x e.\n          terminal_arrow_from_functor (\\<cdot>) (\\<cdot>)\n           (\\<lambda>x. CCC.prod x b) x y e", "by simp"], ["proof (state)\nthis:\n  ide ?y4 \\<Longrightarrow>\n  \\<exists>x e.\n     terminal_arrow_from_functor (\\<cdot>) (\\<cdot>)\n      (\\<lambda>x. CCC.prod x b) x ?y4 e\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_cartesian_closed_category:\n    shows \"cartesian_closed_category C\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cartesian_closed_category (\\<cdot>)", ".."], ["", "end"], ["", "end"]]}