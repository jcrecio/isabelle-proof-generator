{"file_name": "/home/qj213/afp-2021-10-22/thys/Root_Balanced_Tree/Root_Balanced_Tree_Tab.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Root_Balanced_Tree", "problem_names": ["lemma tab_correct: \"h < length tab \\<Longrightarrow> p n h = (n \\<ge> tab ! h)\"", "lemma bal_tab_correct:\n  \"\\<forall>i < length bal_tab. is_floor (bal_tab!i) i\"", "lemma ceiling_least_real: \"ceiling(r::real) = (LEAST i. r \\<le> i)\"", "lemma floor_greatest_real: \"floor(r::real) = (GREATEST i. i \\<le> r)\"", "lemma LEAST_eq_floor:\n  \"(LEAST n. int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>) = floor((2::real) powr ((real(h)-1)/c))\"", "lemma bal_i_code:\n  \"bal_i n h =\n  (if h < IArray.length bal_array then IArray.sub bal_array h \\<le> n else bal_i n h)\""], "translations": [["", "lemma tab_correct: \"h < length tab \\<Longrightarrow> p n h = (n \\<ge> tab ! h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. h < length tab \\<Longrightarrow> p n h = (tab ! h \\<le> n)", "apply auto"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>h < length tab; p n h\\<rbrakk>\n    \\<Longrightarrow> tab ! h \\<le> n\n 2. \\<lbrakk>h < length tab; tab ! h \\<le> n\\<rbrakk>\n    \\<Longrightarrow> p n h", "using not_le_imp_less not_less_Least tab_LEAST"], ["proof (prove)\nusing this:\n  \\<not> ?y \\<le> ?x \\<Longrightarrow> ?x < ?y\n  ?k < (LEAST x. ?P x) \\<Longrightarrow> \\<not> ?P ?k\n  ?h < length tab \\<Longrightarrow> tab ! ?h = (LEAST n. p n ?h)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>h < length tab; p n h\\<rbrakk>\n    \\<Longrightarrow> tab ! h \\<le> n\n 2. \\<lbrakk>h < length tab; tab ! h \\<le> n\\<rbrakk>\n    \\<Longrightarrow> p n h", "apply auto[1]"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>h < length tab; tab ! h \\<le> n\\<rbrakk>\n    \\<Longrightarrow> p n h", "by (metis LeastI mono_p p tab_LEAST)"], ["", "end"], ["", "definition bal_tab :: \"nat list\" where\n\"bal_tab = [0, 1, 1, 2, 4, 6, 10, 16, 25, 40, 64, 101, 161, 256, 406, 645, 1024,\n  1625, 2580, 4096, 6501, 10321, 16384, 26007, 41285, 65536, 104031, 165140,\n  262144, 416127, 660561, 1048576, 1664510, 2642245, 4194304, 6658042, 10568983,\n  16777216, 26632170, 42275935, 67108864, 106528681, 169103740, 268435456,\n  426114725, 676414963, 1073741824, 1704458900, 2705659852, 4294967296\\<^cancel>\\<open>,\n  6817835603\\<close>]\""], ["", "(*ML\\<open>floor (Math.pow(2.0,5.0/1.5))\\<close>*)"], ["", "axiomatization where c_def: \"c = 3/2\""], ["", "fun is_floor :: \"nat \\<Rightarrow> nat \\<Rightarrow> bool\" where\n\"is_floor n h = (let m = floor((2::real) powr ((real(h)-1)/c)) in n \\<le> m \\<and> m \\<le> n)\""], ["", "text\\<open>Note that @{prop\"n \\<le> m \\<and> m \\<le> n\"} avoids the technical restriction of the\n\\<open>approximation\\<close> method which does not support \\<open>=\\<close>, even on integers.\\<close>"], ["", "lemma bal_tab_correct:\n  \"\\<forall>i < length bal_tab. is_floor (bal_tab!i) i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>i<length bal_tab. is_floor (bal_tab ! i) i", "apply(simp add: bal_tab_def c_def All_less_Suc)"], ["proof (prove)\ngoal (1 subgoal):\n 1. 2705659852 \\<le> 2 powr (94 / 3) \\<and>\n    2 powr (94 / 3) < 2705659853 \\<and>\n    1704458900 \\<le> 2 powr (92 / 3) \\<and>\n    2 powr (92 / 3) < 1704458901 \\<and>\n    676414963 \\<le> 2 powr (88 / 3) \\<and>\n    2 powr (88 / 3) < 676414964 \\<and>\n    426114725 \\<le> 2 powr (86 / 3) \\<and>\n    2 powr (86 / 3) < 426114726 \\<and>\n    169103740 \\<le> 2 powr (82 / 3) \\<and>\n    2 powr (82 / 3) < 169103741 \\<and>\n    106528681 \\<le> 2 powr (80 / 3) \\<and>\n    2 powr (80 / 3) < 106528682 \\<and>\n    42275935 \\<le> 2 powr (76 / 3) \\<and>\n    2 powr (76 / 3) < 42275936 \\<and>\n    26632170 \\<le> 2 powr (74 / 3) \\<and>\n    2 powr (74 / 3) < 26632171 \\<and>\n    10568983 \\<le> 2 powr (70 / 3) \\<and>\n    2 powr (70 / 3) < 10568984 \\<and>\n    6658042 \\<le> 2 powr (68 / 3) \\<and>\n    2 powr (68 / 3) < 6658043 \\<and>\n    2642245 \\<le> 2 powr (64 / 3) \\<and>\n    2 powr (64 / 3) < 2642246 \\<and>\n    1664510 \\<le> 2 powr (62 / 3) \\<and>\n    2 powr (62 / 3) < 1664511 \\<and>\n    660561 \\<le> 2 powr (58 / 3) \\<and>\n    2 powr (58 / 3) < 660562 \\<and>\n    416127 \\<le> 2 powr (56 / 3) \\<and>\n    2 powr (56 / 3) < 416128 \\<and>\n    165140 \\<le> 2 powr (52 / 3) \\<and>\n    2 powr (52 / 3) < 165141 \\<and>\n    104031 \\<le> 2 powr (50 / 3) \\<and>\n    2 powr (50 / 3) < 104032 \\<and>\n    41285 \\<le> 2 powr (46 / 3) \\<and>\n    2 powr (46 / 3) < 41286 \\<and>\n    26007 \\<le> 2 powr (44 / 3) \\<and>\n    2 powr (44 / 3) < 26008 \\<and>\n    10321 \\<le> 2 powr (40 / 3) \\<and>\n    2 powr (40 / 3) < 10322 \\<and>\n    6501 \\<le> 2 powr (38 / 3) \\<and>\n    2 powr (38 / 3) < 6502 \\<and>\n    2580 \\<le> 2 powr (34 / 3) \\<and>\n    2 powr (34 / 3) < 2581 \\<and>\n    1625 \\<le> 2 powr (32 / 3) \\<and>\n    2 powr (32 / 3) < 1626 \\<and>\n    645 \\<le> 2 powr (28 / 3) \\<and>\n    2 powr (28 / 3) < 646 \\<and>\n    406 \\<le> 2 powr (26 / 3) \\<and>\n    2 powr (26 / 3) < 407 \\<and>\n    161 \\<le> 2 powr (22 / 3) \\<and>\n    2 powr (22 / 3) < 162 \\<and>\n    101 \\<le> 2 powr (20 / 3) \\<and>\n    2 powr (20 / 3) < 102 \\<and>\n    40 \\<le> 2 powr (16 / 3) \\<and>\n    2 powr (16 / 3) < 41 \\<and>\n    25 \\<le> 2 powr (14 / 3) \\<and>\n    2 powr (14 / 3) < 26 \\<and>\n    10 \\<le> 2 powr (10 / 3) \\<and>\n    2 powr (10 / 3) < 11 \\<and>\n    6 \\<le> 2 powr (8 / 3) \\<and>\n    2 powr (8 / 3) < 7 \\<and>\n    2 \\<le> 2 powr (4 / 3) \\<and>\n    2 powr (4 / 3) < 3 \\<and>\n    1 \\<le> 2 powr (2 / 3) \\<and>\n    2 powr (2 / 3) < 2 \\<and> 2 powr - (2 / 3) < 1", "apply (approximation 50)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "(* FIXME mv *)"], ["", "lemma ceiling_least_real: \"ceiling(r::real) = (LEAST i. r \\<le> i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lceil>r\\<rceil> = (LEAST i. r \\<le> real_of_int i)", "by (metis Least_equality ceiling_le le_of_int_ceiling)"], ["", "lemma floor_greatest_real: \"floor(r::real) = (GREATEST i. i \\<le> r)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>r\\<rfloor> = (GREATEST i. real_of_int i \\<le> r)", "by (metis Greatest_equality le_floor_iff of_int_floor_le)"], ["", "lemma LEAST_eq_floor:\n  \"(LEAST n. int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>) = floor((2::real) powr ((real(h)-1)/c))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int (LEAST n. int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>) =\n    \\<lfloor>2 powr ((real h - 1) / c)\\<rfloor>", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. int (LEAST n. int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>) =\n    \\<lfloor>2 powr ((real h - 1) / c)\\<rfloor>", "have \"int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>\n      \\<longleftrightarrow> 2 powr ((real(h)-1)/c) < real(n)+1\" (is \"?L = ?R\") for n"], ["proof (prove)\ngoal (1 subgoal):\n 1. (int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>) =\n    (2 powr ((real h - 1) / c) < real n + 1)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>) =\n    (2 powr ((real h - 1) / c) < real n + 1)", "have \"?L \\<longleftrightarrow> h < c * log 2 (real n + 1) + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>) =\n    (real h < c * log 2 (real n + 1) + 1)", "by linarith"], ["proof (state)\nthis:\n  (int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>) =\n  (real h < c * log 2 (real n + 1) + 1)\n\ngoal (1 subgoal):\n 1. (int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>) =\n    (2 powr ((real h - 1) / c) < real n + 1)", "also"], ["proof (state)\nthis:\n  (int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>) =\n  (real h < c * log 2 (real n + 1) + 1)\n\ngoal (1 subgoal):\n 1. (int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>) =\n    (2 powr ((real h - 1) / c) < real n + 1)", "have \"\\<dots> \\<longleftrightarrow> (real h-1)/c < log 2 (real n + 1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (real h < c * log 2 (real n + 1) + 1) =\n    ((real h - 1) / c < log 2 (real n + 1))", "using c1"], ["proof (prove)\nusing this:\n  1 < c\n\ngoal (1 subgoal):\n 1. (real h < c * log 2 (real n + 1) + 1) =\n    ((real h - 1) / c < log 2 (real n + 1))", "by(simp add: field_simps)"], ["proof (state)\nthis:\n  (real h < c * log 2 (real n + 1) + 1) =\n  ((real h - 1) / c < log 2 (real n + 1))\n\ngoal (1 subgoal):\n 1. (int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>) =\n    (2 powr ((real h - 1) / c) < real n + 1)", "also"], ["proof (state)\nthis:\n  (real h < c * log 2 (real n + 1) + 1) =\n  ((real h - 1) / c < log 2 (real n + 1))\n\ngoal (1 subgoal):\n 1. (int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>) =\n    (2 powr ((real h - 1) / c) < real n + 1)", "have \"\\<dots> \\<longleftrightarrow> 2 powr ((real h-1)/c) < 2 powr (log 2 (real n + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((real h - 1) / c < log 2 (real n + 1)) =\n    (2 powr ((real h - 1) / c) < 2 powr log 2 (real n + 1))", "by(simp del: powr_log_cancel)"], ["proof (state)\nthis:\n  ((real h - 1) / c < log 2 (real n + 1)) =\n  (2 powr ((real h - 1) / c) < 2 powr log 2 (real n + 1))\n\ngoal (1 subgoal):\n 1. (int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>) =\n    (2 powr ((real h - 1) / c) < real n + 1)", "also"], ["proof (state)\nthis:\n  ((real h - 1) / c < log 2 (real n + 1)) =\n  (2 powr ((real h - 1) / c) < 2 powr log 2 (real n + 1))\n\ngoal (1 subgoal):\n 1. (int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>) =\n    (2 powr ((real h - 1) / c) < real n + 1)", "have \"\\<dots> \\<longleftrightarrow> ?R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (2 powr ((real h - 1) / c) < 2 powr log 2 (real n + 1)) =\n    (2 powr ((real h - 1) / c) < real n + 1)", "by(simp)"], ["proof (state)\nthis:\n  (2 powr ((real h - 1) / c) < 2 powr log 2 (real n + 1)) =\n  (2 powr ((real h - 1) / c) < real n + 1)\n\ngoal (1 subgoal):\n 1. (int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>) =\n    (2 powr ((real h - 1) / c) < real n + 1)", "finally"], ["proof (chain)\npicking this:\n  (int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>) =\n  (2 powr ((real h - 1) / c) < real n + 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  (int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>) =\n  (2 powr ((real h - 1) / c) < real n + 1)\n\ngoal (1 subgoal):\n 1. (int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>) =\n    (2 powr ((real h - 1) / c) < real n + 1)", "."], ["proof (state)\nthis:\n  (int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>) =\n  (2 powr ((real h - 1) / c) < real n + 1)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (int h \\<le> \\<lceil>c * log 2 (real ?n + 1)\\<rceil>) =\n  (2 powr ((real h - 1) / c) < real ?n + 1)\n\ngoal (1 subgoal):\n 1. int (LEAST n. int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>) =\n    \\<lfloor>2 powr ((real h - 1) / c)\\<rfloor>", "moreover"], ["proof (state)\nthis:\n  (int h \\<le> \\<lceil>c * log 2 (real ?n + 1)\\<rceil>) =\n  (2 powr ((real h - 1) / c) < real ?n + 1)\n\ngoal (1 subgoal):\n 1. int (LEAST n. int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>) =\n    \\<lfloor>2 powr ((real h - 1) / c)\\<rfloor>", "have \"((LEAST n::nat. r < n+1) = nat(floor r))\" for r :: real"], ["proof (prove)\ngoal (1 subgoal):\n 1. (LEAST x. r < real x + 1) = nat \\<lfloor>r\\<rfloor>", "by(rule Least_equality) linarith+"], ["proof (state)\nthis:\n  (LEAST x. ?r < real x + 1) = nat \\<lfloor>?r\\<rfloor>\n\ngoal (1 subgoal):\n 1. int (LEAST n. int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>) =\n    \\<lfloor>2 powr ((real h - 1) / c)\\<rfloor>", "ultimately"], ["proof (chain)\npicking this:\n  (int h \\<le> \\<lceil>c * log 2 (real ?n + 1)\\<rceil>) =\n  (2 powr ((real h - 1) / c) < real ?n + 1)\n  (LEAST x. ?r < real x + 1) = nat \\<lfloor>?r\\<rfloor>", "show ?thesis"], ["proof (prove)\nusing this:\n  (int h \\<le> \\<lceil>c * log 2 (real ?n + 1)\\<rceil>) =\n  (2 powr ((real h - 1) / c) < real ?n + 1)\n  (LEAST x. ?r < real x + 1) = nat \\<lfloor>?r\\<rfloor>\n\ngoal (1 subgoal):\n 1. int (LEAST n. int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>) =\n    \\<lfloor>2 powr ((real h - 1) / c)\\<rfloor>", "by simp"], ["proof (state)\nthis:\n  int (LEAST n. int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>) =\n  \\<lfloor>2 powr ((real h - 1) / c)\\<rfloor>\n\ngoal:\nNo subgoals!", "qed"], ["", "interpretation Min_tab\nwhere p = bal_i and tab = bal_tab"], ["proof (prove)\ngoal (1 subgoal):\n 1. Min_tab bal_i bal_tab", "proof(unfold bal_i_def, standard, goal_cases)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>n n' h.\n       \\<lbrakk>n \\<le> n';\n        int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>\\<rbrakk>\n       \\<Longrightarrow> int h \\<le> \\<lceil>c * log 2 (real n' + 1)\\<rceil>\n 2. \\<And>h. \\<exists>n. int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>\n 3. \\<And>h.\n       h < length bal_tab \\<Longrightarrow>\n       bal_tab ! h =\n       (LEAST n. int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>)", "case (1 n n' h)"], ["proof (state)\nthis:\n  n \\<le> n'\n  int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>\n\ngoal (3 subgoals):\n 1. \\<And>n n' h.\n       \\<lbrakk>n \\<le> n';\n        int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>\\<rbrakk>\n       \\<Longrightarrow> int h \\<le> \\<lceil>c * log 2 (real n' + 1)\\<rceil>\n 2. \\<And>h. \\<exists>n. int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>\n 3. \\<And>h.\n       h < length bal_tab \\<Longrightarrow>\n       bal_tab ! h =\n       (LEAST n. int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>)", "have \"int h \\<le> ceiling(c * log 2 (real n + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>", "by(rule 1[unfolded bal_i_def])"], ["proof (state)\nthis:\n  int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>\n\ngoal (3 subgoals):\n 1. \\<And>n n' h.\n       \\<lbrakk>n \\<le> n';\n        int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>\\<rbrakk>\n       \\<Longrightarrow> int h \\<le> \\<lceil>c * log 2 (real n' + 1)\\<rceil>\n 2. \\<And>h. \\<exists>n. int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>\n 3. \\<And>h.\n       h < length bal_tab \\<Longrightarrow>\n       bal_tab ! h =\n       (LEAST n. int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>)", "also"], ["proof (state)\nthis:\n  int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>\n\ngoal (3 subgoals):\n 1. \\<And>n n' h.\n       \\<lbrakk>n \\<le> n';\n        int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>\\<rbrakk>\n       \\<Longrightarrow> int h \\<le> \\<lceil>c * log 2 (real n' + 1)\\<rceil>\n 2. \\<And>h. \\<exists>n. int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>\n 3. \\<And>h.\n       h < length bal_tab \\<Longrightarrow>\n       bal_tab ! h =\n       (LEAST n. int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>)", "have \"\\<dots> \\<le> ceiling(c * log 2 (real n' + 1))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lceil>c * log 2 (real n + 1)\\<rceil>\n    \\<le> \\<lceil>c * log 2 (real n' + 1)\\<rceil>", "using c1 \"1\"(1)"], ["proof (prove)\nusing this:\n  1 < c\n  n \\<le> n'\n\ngoal (1 subgoal):\n 1. \\<lceil>c * log 2 (real n + 1)\\<rceil>\n    \\<le> \\<lceil>c * log 2 (real n' + 1)\\<rceil>", "by (simp add: ceiling_mono)"], ["proof (state)\nthis:\n  \\<lceil>c * log 2 (real n + 1)\\<rceil>\n  \\<le> \\<lceil>c * log 2 (real n' + 1)\\<rceil>\n\ngoal (3 subgoals):\n 1. \\<And>n n' h.\n       \\<lbrakk>n \\<le> n';\n        int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>\\<rbrakk>\n       \\<Longrightarrow> int h \\<le> \\<lceil>c * log 2 (real n' + 1)\\<rceil>\n 2. \\<And>h. \\<exists>n. int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>\n 3. \\<And>h.\n       h < length bal_tab \\<Longrightarrow>\n       bal_tab ! h =\n       (LEAST n. int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>)", "finally"], ["proof (chain)\npicking this:\n  int h \\<le> \\<lceil>c * log 2 (real n' + 1)\\<rceil>", "show ?case"], ["proof (prove)\nusing this:\n  int h \\<le> \\<lceil>c * log 2 (real n' + 1)\\<rceil>\n\ngoal (1 subgoal):\n 1. int h \\<le> \\<lceil>c * log 2 (real n' + 1)\\<rceil>", "."], ["proof (state)\nthis:\n  int h \\<le> \\<lceil>c * log 2 (real n' + 1)\\<rceil>\n\ngoal (2 subgoals):\n 1. \\<And>h. \\<exists>n. int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>\n 2. \\<And>h.\n       h < length bal_tab \\<Longrightarrow>\n       bal_tab ! h =\n       (LEAST n. int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>h. \\<exists>n. int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>\n 2. \\<And>h.\n       h < length bal_tab \\<Longrightarrow>\n       bal_tab ! h =\n       (LEAST n. int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>)", "case (2 h)"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. \\<And>h. \\<exists>n. int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>\n 2. \\<And>h.\n       h < length bal_tab \\<Longrightarrow>\n       bal_tab ! h =\n       (LEAST n. int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>n. int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. int h \\<le> \\<lceil>c * log 2 (real ?n + 1)\\<rceil>", "show \"int h \\<le> \\<lceil>c * log 2 (real (2 ^ h - 1) + 1)\\<rceil>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. int h \\<le> \\<lceil>c * log 2 (real (2 ^ h - 1) + 1)\\<rceil>", "apply(simp add: of_nat_diff log_nat_power)"], ["proof (prove)\ngoal (1 subgoal):\n 1. int h \\<le> \\<lceil>c * real h\\<rceil>", "using c1"], ["proof (prove)\nusing this:\n  1 < c\n\ngoal (1 subgoal):\n 1. int h \\<le> \\<lceil>c * real h\\<rceil>", "by (metis ceiling_mono ceiling_of_nat order.order_iff_strict mult.left_neutral mult_eq_0_iff of_nat_0_le_iff mult_le_cancel_iff1)"], ["proof (state)\nthis:\n  int h \\<le> \\<lceil>c * log 2 (real (2 ^ h - 1) + 1)\\<rceil>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>n. int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>\n\ngoal (1 subgoal):\n 1. \\<And>h.\n       h < length bal_tab \\<Longrightarrow>\n       bal_tab ! h =\n       (LEAST n. int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>h.\n       h < length bal_tab \\<Longrightarrow>\n       bal_tab ! h =\n       (LEAST n. int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>)", "case 3"], ["proof (state)\nthis:\n  h_ < length bal_tab\n\ngoal (1 subgoal):\n 1. \\<And>h.\n       h < length bal_tab \\<Longrightarrow>\n       bal_tab ! h =\n       (LEAST n. int h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>)", "thus ?case"], ["proof (prove)\nusing this:\n  h_ < length bal_tab\n\ngoal (1 subgoal):\n 1. bal_tab ! h_ =\n    (LEAST n. int h_ \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>)", "using bal_tab_correct LEAST_eq_floor"], ["proof (prove)\nusing this:\n  h_ < length bal_tab\n  \\<forall>i<length bal_tab. is_floor (bal_tab ! i) i\n  int (LEAST n. int ?h \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>) =\n  \\<lfloor>2 powr ((real ?h - 1) / c)\\<rfloor>\n\ngoal (1 subgoal):\n 1. bal_tab ! h_ =\n    (LEAST n. int h_ \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>)", "by (simp add: eq_iff[symmetric]) (metis nat_int)"], ["proof (state)\nthis:\n  bal_tab ! h_ =\n  (LEAST n. int h_ \\<le> \\<lceil>c * log 2 (real n + 1)\\<rceil>)\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Now we replace the list by an immutable array:\\<close>"], ["", "definition bal_array :: \"nat iarray\" where\n\"bal_array = IArray bal_tab\""], ["", "text\\<open>A trick for code generation: how to get rid of the precondition:\\<close>"], ["", "lemma bal_i_code:\n  \"bal_i n h =\n  (if h < IArray.length bal_array then IArray.sub bal_array h \\<le> n else bal_i n h)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bal_i n h =\n    (if h < IArray.length bal_array then bal_array !! h \\<le> n\n     else bal_i n h)", "by (simp add: bal_array_def tab_correct)"], ["", "end"]]}