{"file_name": "/home/qj213/afp-2021-10-22/thys/LightweightJava/Lightweight_Java_Definition.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/LightweightJava", "problem_names": ["lemma [mono]:\"\n         (!! x. f x --> g x) ==> list_all (%b. b) (map f foo_list)-->\n                    list_all (%b. b) (map g foo_list) \"", "lemma [mono]: \"case_prod f p = f (fst p) (snd p)\""], "translations": [["", "lemma [mono]:\"\n         (!! x. f x --> g x) ==> list_all (%b. b) (map f foo_list)-->\n                    list_all (%b. b) (map g foo_list) \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x. f x \\<longrightarrow> g x) \\<Longrightarrow>\n    list_all (\\<lambda>b. b) (map f foo_list) \\<longrightarrow>\n    list_all (\\<lambda>b. b) (map g foo_list)", "apply(induct_tac foo_list, auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma [mono]: \"case_prod f p = f (fst p) (snd p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case p of (x, xa) \\<Rightarrow> f x xa) = f (fst p) (snd p)", "by (simp add: split_def)"], ["", "(** definitions *)\n(*defns class_name_def *)"], ["", "inductive class_name :: \"cld \\<Rightarrow> dcl \\<Rightarrow> bool\"\nwhere\n(* defn class_name *)\n\nclass_nameI: \"class_name ((cld_def dcl cl fds meth_defs)) (dcl)\""], ["", "(*defns superclass_name_def *)"], ["", "inductive superclass_name :: \"cld \\<Rightarrow> cl \\<Rightarrow> bool\"\nwhere\n(* defn superclass_name *)\n\nsuperclass_nameI: \"superclass_name ((cld_def dcl cl fds meth_defs)) (cl)\""], ["", "(*defns class_fields_def *)"], ["", "inductive class_fields :: \"cld \\<Rightarrow> fds \\<Rightarrow> bool\"\nwhere\n(* defn class_fields *)\n\nclass_fieldsI: \"class_fields ((cld_def dcl cl fds meth_defs)) (fds)\""], ["", "(*defns class_methods_def *)"], ["", "inductive class_methods :: \"cld \\<Rightarrow> meth_defs \\<Rightarrow> bool\"\nwhere\n(* defn class_methods *)\n\nclass_methodsI: \"class_methods ((cld_def dcl cl fds meth_defs)) (meth_defs)\""], ["", "(*defns method_name_def *)"], ["", "inductive method_name :: \"meth_def \\<Rightarrow> meth \\<Rightarrow> bool\"\nwhere\n(* defn method_name *)\n\nmethod_nameI: \"method_name ((meth_def_def (meth_sig_def cl meth vds) meth_body)) (meth)\""], ["", "(*defns distinct_names_def *)"], ["", "inductive distinct_names :: \"P \\<Rightarrow> bool\"\nwhere\n(* defn distinct_names *)\n\ndn_defI: \"\\<lbrakk> P  =    ((List.map (%((cld_XXX::cld),(dcl_XXX::dcl)).cld_XXX) cld_dcl_list))    ;\n list_all (\\<lambda>f. f)  ((List.map (%((cld_XXX::cld),(dcl_XXX::dcl)).class_name (cld_XXX) (dcl_XXX)) cld_dcl_list))  ;\n distinct ( ((List.map (%((cld_XXX::cld),(dcl_XXX::dcl)).dcl_XXX) cld_dcl_list)) ) \\<rbrakk> \\<Longrightarrow>\ndistinct_names (P)\""], ["", "(*defns find_cld_def *)"], ["", "inductive find_cld :: \"P \\<Rightarrow> ctx \\<Rightarrow> fqn \\<Rightarrow> ctxcld_opt \\<Rightarrow> bool\"\nwhere\n(* defn find_cld *)\n\nfc_emptyI: \"find_cld (  []  ) (ctx) (fqn) ( None )\"\n\n| fc_cons_trueI: \"\\<lbrakk> P  =    ([(cld)] @ cld_list)    ;\n cld  =  (cld_def dcl cl fds meth_defs) \\<rbrakk> \\<Longrightarrow>\nfind_cld (P) (ctx) ((fqn_def dcl)) ( (Some (  ( ctx , cld )  )) )\"\n\n| fc_cons_falseI: \"\\<lbrakk> cld  =  (cld_def dcl' cl fds meth_defs)  ;\n (cl_fqn (fqn_def dcl))  \\<noteq>  (cl_fqn (fqn_def dcl'))  ;\nfind_cld (  (cld_list)  ) (ctx) ((fqn_def dcl)) (ctxcld_opt)\\<rbrakk> \\<Longrightarrow>\nfind_cld (  ([(cld)] @ cld_list)  ) (ctx) ((fqn_def dcl)) (ctxcld_opt)\""], ["", "(*defns find_type_def *)"], ["", "inductive find_type :: \"P \\<Rightarrow> ctx \\<Rightarrow> cl \\<Rightarrow> ty_opt \\<Rightarrow> bool\"\nwhere\n(* defn find_type *)\n\nft_objI: \"find_type (P) (ctx) (cl_object) ( (Some ( ty_top )) )\"\n\n| ft_nullI: \"\\<lbrakk>find_cld (P) (ctx) (fqn) ( None )\\<rbrakk> \\<Longrightarrow>\nfind_type (P) (ctx) ((cl_fqn fqn)) ( None )\"\n\n| ft_dclI: \"\\<lbrakk>find_cld (P) (ctx) ((fqn_def dcl)) ( (Some (  ( ctx' , cld )  )) )\\<rbrakk> \\<Longrightarrow>\nfind_type (P) (ctx) ((cl_fqn (fqn_def dcl))) ( (Some ( (ty_def ctx' dcl) )) )\""], ["", "(*defns path_length_def *)"], ["", "inductive path_length :: \"P \\<Rightarrow> ctx \\<Rightarrow> cl \\<Rightarrow> nn \\<Rightarrow> bool\"\nwhere\n(* defn path_length *)\n\npl_objI: \"path_length (P) (ctx) (cl_object) ( 0 )\"\n\n| pl_fqnI: \"\\<lbrakk>find_cld (P) (ctx) (fqn) ( (Some (  ( ctx' , cld )  )) ) ;\nsuperclass_name (cld) (cl) ;\npath_length (P) (ctx') (cl) (nn)\\<rbrakk> \\<Longrightarrow>\npath_length (P) (ctx) ((cl_fqn fqn)) ( ( nn +  1  ) )\""], ["", "(*defns acyclic_clds_def *)"], ["", "inductive acyclic_clds :: \"P \\<Rightarrow> bool\"\nwhere\n(* defn acyclic_clds *)\n\nac_defI: \"\\<lbrakk> \\<forall>  ctx   fqn .   (    (  (\\<exists>  ctx'   cld  .  find_cld (P) (ctx) (fqn) ( (Some (  ( ctx' , cld )  )) ) )  )   \\<longrightarrow>     (\\<exists>  nn  .  path_length (P) (ctx) ((cl_fqn fqn)) (nn) )      )  \\<rbrakk> \\<Longrightarrow>\nacyclic_clds (P)\""], ["", "(*defns find_path_rec_def *)"], ["", "inductive find_path_rec :: \"P \\<Rightarrow> ctx \\<Rightarrow> cl \\<Rightarrow> ctxclds \\<Rightarrow> ctxclds_opt \\<Rightarrow> bool\"\nwhere\n(* defn find_path_rec *)\n\nfpr_objI: \"find_path_rec (P) (ctx) (cl_object) (ctxclds) ( Some ( ctxclds ) )\"\n\n| fpr_nullI: \"\\<lbrakk>  (  \\<not> ( acyclic_clds (P) )  )   \\<or>  find_cld (P) (ctx) (fqn) ( None ) \\<rbrakk> \\<Longrightarrow>\nfind_path_rec (P) (ctx) ((cl_fqn fqn)) (ctxclds) ( None )\"\n\n| fpr_fqnI: \"\\<lbrakk> acyclic_clds (P)  \\<and>  find_cld (P) (ctx) (fqn) ( (Some (  ( ctx' , cld )  )) )  ;\nsuperclass_name (cld) (cl) ;\nfind_path_rec (P) (ctx') (cl) ( ctxclds @[   ( ctx' , cld )   ] ) (ctxclds_opt)\\<rbrakk> \\<Longrightarrow>\nfind_path_rec (P) (ctx) ((cl_fqn fqn)) (ctxclds) (ctxclds_opt)\""], ["", "(*defns find_path_def *)"], ["", "inductive find_path :: \"P \\<Rightarrow> ctx \\<Rightarrow> cl \\<Rightarrow> ctxclds_opt \\<Rightarrow> bool\"\nwhere\n(* defn find_path *)\n\nfp_defI: \"\\<lbrakk>find_path_rec (P) (ctx) (cl) ( [] ) (ctxclds_opt)\\<rbrakk> \\<Longrightarrow>\nfind_path (P) (ctx) (cl) (ctxclds_opt)\""], ["", "(*defns find_path_ty_def *)"], ["", "inductive find_path_ty :: \"P \\<Rightarrow> ty \\<Rightarrow> ctxclds_opt \\<Rightarrow> bool\"\nwhere\n(* defn find_path_ty *)\n\nfpty_objI: \"find_path_ty (P) (ty_top) ( Some (  []  ) )\"\n\n| fpty_dclI: \"\\<lbrakk>find_path (P) (ctx) ((cl_fqn (fqn_def dcl))) (ctxclds_opt)\\<rbrakk> \\<Longrightarrow>\nfind_path_ty (P) ((ty_def ctx dcl)) (ctxclds_opt)\""], ["", "(*defns fields_in_path_def *)"], ["", "inductive fields_in_path :: \"ctxclds \\<Rightarrow> fs \\<Rightarrow> bool\"\nwhere\n(* defn fields_in_path *)\n\nfip_emptyI: \"fields_in_path ( [] ) ( [] )\"\n\n| fip_consI: \"\\<lbrakk>class_fields (cld) ( ((List.map (%((cl_XXX::cl),(f_XXX::f)).(fd_def cl_XXX f_XXX)) cl_f_list)) ) ;\nfields_in_path ( (ctxcld_list) ) (fs) ;\n fs'  =   (  ((List.map (%((cl_XXX::cl),(f_XXX::f)).f_XXX) cl_f_list))  @ fs )  \\<rbrakk> \\<Longrightarrow>\nfields_in_path ( ([( ( ctx , cld ) )] @ ctxcld_list) ) (fs')\""], ["", "(*defns fields_def *)"], ["", "inductive fields :: \"P \\<Rightarrow> ty \\<Rightarrow> fs_opt \\<Rightarrow> bool\"\nwhere\n(* defn fields *)\n\nfields_noneI: \"\\<lbrakk>find_path_ty (P) (ty) ( None )\\<rbrakk> \\<Longrightarrow>\nfields (P) (ty) ( None )\"\n\n| fields_someI: \"\\<lbrakk>find_path_ty (P) (ty) ( Some ( ctxclds ) ) ;\nfields_in_path (ctxclds) (fs)\\<rbrakk> \\<Longrightarrow>\nfields (P) (ty) ( Some ( fs ) )\""], ["", "(*defns methods_in_path_def *)"], ["", "inductive methods_in_path :: \"clds \\<Rightarrow> meths \\<Rightarrow> bool\"\nwhere\n(* defn methods_in_path *)\n\nmip_emptyI: \"methods_in_path ( [] ) ( [] )\"\n\n| mip_consI: \"\\<lbrakk>class_methods (cld) ( ((List.map (%((meth_def_XXX::meth_def),(cl_XXX::cl),(meth_XXX::meth),(vds_XXX::vds),(meth_body_XXX::meth_body)).meth_def_XXX) meth_def_cl_meth_vds_meth_body_list)) ) ;\n list_all (\\<lambda>f. f)  ((List.map (%((meth_def_XXX::meth_def),(cl_XXX::cl),(meth_XXX::meth),(vds_XXX::vds),(meth_body_XXX::meth_body)). meth_def_XXX  =  (meth_def_def (meth_sig_def cl_XXX meth_XXX vds_XXX) meth_body_XXX) ) meth_def_cl_meth_vds_meth_body_list))  ;\nmethods_in_path ( (cld_list) ) (meths') ;\n meths  =   (  ((List.map (%((meth_def_XXX::meth_def),(cl_XXX::cl),(meth_XXX::meth),(vds_XXX::vds),(meth_body_XXX::meth_body)).meth_XXX) meth_def_cl_meth_vds_meth_body_list))  @ meths' )  \\<rbrakk> \\<Longrightarrow>\nmethods_in_path ( ([(cld)] @ cld_list) ) (meths)\""], ["", "(*defns methods_def *)"], ["", "inductive methods :: \"P \\<Rightarrow> ty \\<Rightarrow> meths \\<Rightarrow> bool\"\nwhere\n(* defn methods *)\n\nmethods_methodsI: \"\\<lbrakk>find_path_ty (P) (ty) ( Some (  ((List.map (%((ctx_XXX::ctx),(cld_XXX::cld)). ( ctx_XXX , cld_XXX ) ) ctx_cld_list))  ) ) ;\nmethods_in_path ( ((List.map (%((ctx_XXX::ctx),(cld_XXX::cld)).cld_XXX) ctx_cld_list)) ) (meths)\\<rbrakk> \\<Longrightarrow>\nmethods (P) (ty) (meths)\""], ["", "(*defns ftype_in_fds_def *)"], ["", "inductive ftype_in_fds :: \"P \\<Rightarrow> ctx \\<Rightarrow> fds \\<Rightarrow> f \\<Rightarrow> ty_opt_bot \\<Rightarrow> bool\"\nwhere\n(* defn ftype_in_fds *)\n\nftif_emptyI: \"ftype_in_fds (P) (ctx) ( [] ) (f) ((ty_opt_bot_opt  None ))\"\n\n| ftif_cons_botI: \"\\<lbrakk>find_type (P) (ctx) (cl) ( None )\\<rbrakk> \\<Longrightarrow>\nftype_in_fds (P) (ctx) ( ([((fd_def cl f))] @ fd_list) ) (f) (ty_opt_bot_bot)\"\n\n| ftif_cons_trueI: \"\\<lbrakk>find_type (P) (ctx) (cl) ( (Some ( ty )) )\\<rbrakk> \\<Longrightarrow>\nftype_in_fds (P) (ctx) ( ([((fd_def cl f))] @ fd_list) ) (f) ((ty_opt_bot_opt  (Some ( ty )) ))\"\n\n| ftif_cons_falseI: \"\\<lbrakk> f  \\<noteq>  f'  ;\nftype_in_fds (P) (ctx) ( (fd_list) ) (f') (ty_opt_bot)\\<rbrakk> \\<Longrightarrow>\nftype_in_fds (P) (ctx) ( ([((fd_def cl f))] @ fd_list) ) (f') (ty_opt_bot)\""], ["", "(*defns ftype_in_path_def *)"], ["", "inductive ftype_in_path :: \"P \\<Rightarrow> ctxclds \\<Rightarrow> f \\<Rightarrow> ty_opt \\<Rightarrow> bool\"\nwhere\n(* defn ftype_in_path *)\n\nftip_emptyI: \"ftype_in_path (P) ( [] ) (f) ( None )\"\n\n| ftip_cons_botI: \"\\<lbrakk>class_fields (cld) (fds) ;\nftype_in_fds (P) (ctx) (fds) (f) (ty_opt_bot_bot)\\<rbrakk> \\<Longrightarrow>\nftype_in_path (P) ( ([( ( ctx , cld ) )] @ ctxcld_list) ) (f) ( None )\"\n\n| ftip_cons_trueI: \"\\<lbrakk>class_fields (cld) (fds) ;\nftype_in_fds (P) (ctx) (fds) (f) ((ty_opt_bot_opt  (Some ( ty )) ))\\<rbrakk> \\<Longrightarrow>\nftype_in_path (P) ( ([( ( ctx , cld ) )] @ ctxcld_list) ) (f) ( (Some ( ty )) )\"\n\n| ftip_cons_falseI: \"\\<lbrakk>class_fields (cld) (fds) ;\nftype_in_fds (P) (ctx) (fds) (f) ((ty_opt_bot_opt  None )) ;\nftype_in_path (P) ( (ctxcld_list) ) (f) (ty_opt)\\<rbrakk> \\<Longrightarrow>\nftype_in_path (P) ( ([( ( ctx , cld ) )] @ ctxcld_list) ) (f) (ty_opt)\""], ["", "(*defns ftype_def *)"], ["", "inductive ftype :: \"P \\<Rightarrow> ty \\<Rightarrow> f \\<Rightarrow> ty \\<Rightarrow> bool\"\nwhere\n(* defn ftype *)\n\nftypeI: \"\\<lbrakk>find_path_ty (P) (ty) ( Some ( ctxclds ) ) ;\nftype_in_path (P) (ctxclds) (f) ( (Some ( ty' )) )\\<rbrakk> \\<Longrightarrow>\nftype (P) (ty) (f) (ty')\""], ["", "(*defns find_meth_def_in_list_def *)"], ["", "inductive find_meth_def_in_list :: \"meth_defs \\<Rightarrow> meth \\<Rightarrow> meth_def_opt \\<Rightarrow> bool\"\nwhere\n(* defn find_meth_def_in_list *)\n\nfmdil_emptyI: \"find_meth_def_in_list ( [] ) (meth) ( None )\"\n\n| fmdil_cons_trueI: \"\\<lbrakk> meth_def  =  (meth_def_def (meth_sig_def cl meth vds) meth_body) \\<rbrakk> \\<Longrightarrow>\nfind_meth_def_in_list ( ([(meth_def)] @ meth_def_list) ) (meth) ( Some ( meth_def ) )\"\n\n| fmdil_cons_falseI: \"\\<lbrakk> meth_def  =  (meth_def_def (meth_sig_def cl meth' vds) meth_body)  ;\n meth  \\<noteq>  meth'  ;\nfind_meth_def_in_list ( (meth_def_list) ) (meth) (meth_def_opt)\\<rbrakk> \\<Longrightarrow>\nfind_meth_def_in_list ( ([(meth_def)] @ meth_def_list) ) (meth) (meth_def_opt)\""], ["", "(*defns find_meth_def_in_path_def *)"], ["", "inductive find_meth_def_in_path :: \"ctxclds \\<Rightarrow> meth \\<Rightarrow> ctxmeth_def_opt \\<Rightarrow> bool\"\nwhere\n(* defn find_meth_def_in_path *)\n\nfmdip_emptyI: \"find_meth_def_in_path ( [] ) (meth) ( (None::ctxmeth_def_opt) )\"\n\n| fmdip_cons_trueI: \"\\<lbrakk>class_methods (cld) (meth_defs) ;\nfind_meth_def_in_list (meth_defs) (meth) ( Some ( meth_def ) )\\<rbrakk> \\<Longrightarrow>\nfind_meth_def_in_path ( ([( ( ctx , cld ) )] @ ctxcld_list) ) (meth) ( (Some ( ctx , meth_def )::ctxmeth_def_opt) )\"\n\n| fmdip_cons_falseI: \"\\<lbrakk>class_methods (cld) (meth_defs) ;\nfind_meth_def_in_list (meth_defs) (meth) ( None ) ;\nfind_meth_def_in_path ( (ctxcld_list) ) (meth) (ctxmeth_def_opt)\\<rbrakk> \\<Longrightarrow>\nfind_meth_def_in_path ( ([( ( ctx , cld ) )] @ ctxcld_list) ) (meth) (ctxmeth_def_opt)\""], ["", "(*defns find_meth_def_def *)"], ["", "inductive find_meth_def :: \"P \\<Rightarrow> ty \\<Rightarrow> meth \\<Rightarrow> ctxmeth_def_opt \\<Rightarrow> bool\"\nwhere\n(* defn find_meth_def *)\n\nfmd_nullI: \"\\<lbrakk>find_path_ty (P) (ty) ( None )\\<rbrakk> \\<Longrightarrow>\nfind_meth_def (P) (ty) (meth) ( (None::ctxmeth_def_opt) )\"\n\n| fmd_optI: \"\\<lbrakk>find_path_ty (P) (ty) ( Some ( ctxclds ) ) ;\nfind_meth_def_in_path (ctxclds) (meth) (ctxmeth_def_opt)\\<rbrakk> \\<Longrightarrow>\nfind_meth_def (P) (ty) (meth) (ctxmeth_def_opt)\""], ["", "(*defns mtype_def *)"], ["", "inductive mtype :: \"P \\<Rightarrow> ty \\<Rightarrow> meth \\<Rightarrow> mty \\<Rightarrow> bool\"\nwhere\n(* defn mtype *)\n\nmtypeI: \"\\<lbrakk>find_meth_def (P) (ty) (meth) ( (Some ( ctx , meth_def )::ctxmeth_def_opt) ) ;\n meth_def  =  (meth_def_def (meth_sig_def cl meth  ((List.map (%((cl_XXX::cl),(var_XXX::var),(ty_XXX::ty)).(vd_def cl_XXX var_XXX)) cl_var_ty_list)) ) meth_body)  ;\nfind_type (P) (ctx) (cl) ( (Some ( ty' )) ) ;\n list_all (\\<lambda>f. f)  ((List.map (%((cl_XXX::cl),(var_XXX::var),(ty_XXX::ty)).find_type (P) (ctx) (cl_XXX) ( (Some ( ty_XXX )) )) cl_var_ty_list))  ;\n mty  =  (mty_def  ((List.map (%((cl_XXX::cl),(var_XXX::var),(ty_XXX::ty)).ty_XXX) cl_var_ty_list))  ty') \\<rbrakk> \\<Longrightarrow>\nmtype (P) (ty) (meth) (mty)\""], ["", "(*defns sty_one_def *)"], ["", "inductive sty_one :: \"P \\<Rightarrow> ty \\<Rightarrow> ty \\<Rightarrow> bool\"\nwhere\n(* defn one *)\n\nsty_objI: \"\\<lbrakk>find_path_ty (P) (ty) ( Some ( ctxclds ) )\\<rbrakk> \\<Longrightarrow>\nsty_one (P) (ty) (ty_top)\"\n\n| sty_dclI: \"\\<lbrakk>find_path_ty (P) (ty) ( Some (  ((List.map (%((ctx_XXX::ctx),(cld_XXX::cld),(dcl_XXX::dcl)). ( ctx_XXX , cld_XXX ) ) ctx_cld_dcl_list))  ) ) ;\n list_all (\\<lambda>f. f)  ((List.map (%((ctx_XXX::ctx),(cld_XXX::cld),(dcl_XXX::dcl)).class_name (cld_XXX) (dcl_XXX)) ctx_cld_dcl_list))  ;\n ( ctx' , dcl' ) \\<in> set  ((List.map (%((ctx_XXX::ctx),(cld_XXX::cld),(dcl_XXX::dcl)).(ctx_XXX,dcl_XXX)) ctx_cld_dcl_list)) \\<rbrakk> \\<Longrightarrow>\nsty_one (P) (ty) ((ty_def ctx' dcl'))\""], ["", "(*defns sty_many_def *)"], ["", "inductive sty_many :: \"P \\<Rightarrow> tys \\<Rightarrow> tys \\<Rightarrow> bool\"\nwhere\n(* defn many *)\n\nsty_manyI: \"\\<lbrakk> tys  =   ((List.map (%((ty_XXX::ty),(ty_'::ty)).ty_XXX) ty_ty'_list))   ;\n tys'  =   ((List.map (%((ty_XXX::ty),(ty_'::ty)).ty_') ty_ty'_list))   ;\n list_all (\\<lambda>f. f)  ((List.map (%((ty_XXX::ty),(ty_'::ty)).sty_one (P) (ty_XXX) (ty_')) ty_ty'_list)) \\<rbrakk> \\<Longrightarrow>\nsty_many (P) (tys) (tys')\""], ["", "(*defns sty_option_def *)"], ["", "inductive sty_option :: \"P \\<Rightarrow> ty_opt \\<Rightarrow> ty_opt \\<Rightarrow> bool\"\nwhere\n(* defn option *)\n\nsty_optionI: \"\\<lbrakk> ty_opt  =   (Some ( ty ))   ;\n ty_opt'  =   (Some ( ty' ))   ;\nsty_one (P) (ty) (ty')\\<rbrakk> \\<Longrightarrow>\nsty_option (P) (ty_opt) (ty_opt')\""], ["", "(*defns well_formedness *)"], ["", "inductive wf_object :: \"P \\<Rightarrow> H \\<Rightarrow> v_opt \\<Rightarrow> ty_opt \\<Rightarrow> bool\"\n and wf_varstate :: \"P \\<Rightarrow> \\<Gamma> \\<Rightarrow> H \\<Rightarrow> L \\<Rightarrow> bool\"\n and wf_heap :: \"P \\<Rightarrow> H \\<Rightarrow> bool\"\n and wf_config :: \"\\<Gamma> \\<Rightarrow> config \\<Rightarrow> bool\"\n and wf_stmt :: \"P \\<Rightarrow> \\<Gamma> \\<Rightarrow> s \\<Rightarrow> bool\"\n and wf_meth :: \"P \\<Rightarrow> ty \\<Rightarrow> meth_def \\<Rightarrow> bool\"\n and wf_class_common :: \"P \\<Rightarrow> ctx \\<Rightarrow> dcl \\<Rightarrow> cl \\<Rightarrow> fds \\<Rightarrow> meth_defs \\<Rightarrow> bool\"\n and wf_class :: \"P \\<Rightarrow> cld \\<Rightarrow> bool\"\n and wf_program :: \"P \\<Rightarrow> bool\"\nwhere\n(* defn object *)\n\nwf_nullI: \"\\<lbrakk> ty_opt  =   (Some ( ty ))  \\<rbrakk> \\<Longrightarrow>\nwf_object (P) (H) ( Some  v_null ) (ty_opt)\"\n\n| wf_objectI: \"\\<lbrakk>sty_option (P) ( (case  H   oid  of\n                     None \\<Rightarrow> None\n                   | Some tyfs \\<Rightarrow> Some (fst tyfs)) ) (ty_opt)\\<rbrakk> \\<Longrightarrow>\nwf_object (P) (H) ( Some  (v_oid oid) ) (ty_opt)\"\n\n| (* defn varstate *)\n\nwf_varstateI: \"\\<lbrakk> finite (dom ( L ))  ;\n \\<forall>  x  \\<in> dom  \\<Gamma> .  wf_object (P) (H) ( L   x ) ( \\<Gamma>   x ) \\<rbrakk> \\<Longrightarrow>\nwf_varstate (P) (\\<Gamma>) (H) (L)\"\n\n| (* defn heap *)\n\nwf_heapI: \"\\<lbrakk> finite (dom ( H ))  ;\n \\<forall>  oid  \\<in> dom  H .   (   \\<exists>  ty  .     (case  H   oid  of\n                     None \\<Rightarrow> None\n                   | Some tyfs \\<Rightarrow> Some (fst tyfs))   =   (Some ( ty ))    \\<and>   (\\<exists>  fs  .   fields (P) (ty) ( Some ( fs ) )  \\<and>     (\\<forall>  f  \\<in> set  fs .   \\<exists>  ty'  .   (   ftype (P) (ty) (f) (ty')  \\<and>   wf_object (P) (H) ( (case  H   oid  of\n                     None \\<Rightarrow> None\n                   | Some tyfs \\<Rightarrow> (snd tyfs)  f ) ) ( (Some ( ty' )) )    )   )     )     )  \\<rbrakk> \\<Longrightarrow>\nwf_heap (P) (H)\"\n\n| (* defn config *)\n\nwf_all_exI: \"\\<lbrakk>wf_program (P) ;\nwf_heap (P) (H) ;\nwf_varstate (P) (\\<Gamma>) (H) (L)\\<rbrakk> \\<Longrightarrow>\nwf_config (\\<Gamma>) ((config_ex P L H Exception))\"\n\n| wf_allI: \"\\<lbrakk>wf_program (P) ;\nwf_heap (P) (H) ;\nwf_varstate (P) (\\<Gamma>) (H) (L) ;\n list_all (\\<lambda>f. f)  ((List.map (%(s_XXX::s).wf_stmt (P) (\\<Gamma>) (s_XXX)) s_list)) \\<rbrakk> \\<Longrightarrow>\nwf_config (\\<Gamma>) ((config_normal P L H (s_list)))\"\n\n| (* defn stmt *)\n\nwf_blockI: \"\\<lbrakk> list_all (\\<lambda>f. f)  ((List.map (%(s_XXX::s).wf_stmt (P) (\\<Gamma>) (s_XXX)) s_list)) \\<rbrakk> \\<Longrightarrow>\nwf_stmt (P) (\\<Gamma>) ((s_block (s_list)))\"\n\n| wf_var_assignI: \"\\<lbrakk>sty_option (P) ( \\<Gamma>   x ) ( \\<Gamma>   (x_var var) )\\<rbrakk> \\<Longrightarrow>\nwf_stmt (P) (\\<Gamma>) ((s_ass var x))\"\n\n| wf_field_readI: \"\\<lbrakk>  \\<Gamma>   x   =   (Some ( ty ))   ;\nftype (P) (ty) (f) (ty') ;\nsty_option (P) ( (Some ( ty' )) ) ( \\<Gamma>   (x_var var) )\\<rbrakk> \\<Longrightarrow>\nwf_stmt (P) (\\<Gamma>) ((s_read var x f))\"\n\n| wf_field_writeI: \"\\<lbrakk>  \\<Gamma>   x   =   (Some ( ty ))   ;\nftype (P) (ty) (f) (ty') ;\nsty_option (P) ( \\<Gamma>   y ) ( (Some ( ty' )) )\\<rbrakk> \\<Longrightarrow>\nwf_stmt (P) (\\<Gamma>) ((s_write x f y))\"\n\n| wf_ifI: \"\\<lbrakk> sty_option (P) ( \\<Gamma>   x ) ( \\<Gamma>   y )  \\<or>  sty_option (P) ( \\<Gamma>   y ) ( \\<Gamma>   x )  ;\nwf_stmt (P) (\\<Gamma>) (s1) ;\nwf_stmt (P) (\\<Gamma>) (s2)\\<rbrakk> \\<Longrightarrow>\nwf_stmt (P) (\\<Gamma>) ((s_if x y s1 s2))\"\n\n| wf_newI: \"\\<lbrakk>find_type (P) (ctx) (cl) ( (Some ( ty )) ) ;\nsty_option (P) ( (Some ( ty )) ) ( \\<Gamma>   (x_var var) )\\<rbrakk> \\<Longrightarrow>\nwf_stmt (P) (\\<Gamma>) ((s_new var ctx cl))\"\n\n| wf_mcallI: \"\\<lbrakk> Y  =   ((List.map (%((y_XXX::x),(ty_XXX::ty)).y_XXX) y_ty_list))   ;\n  \\<Gamma>   x   =   (Some ( ty ))   ;\nmtype (P) (ty) (meth) ((mty_def  ((List.map (%((y_XXX::x),(ty_XXX::ty)).ty_XXX) y_ty_list))  ty')) ;\n list_all (\\<lambda>f. f)  ((List.map (%((y_XXX::x),(ty_XXX::ty)).sty_option (P) ( \\<Gamma>   y_XXX ) ( (Some ( ty_XXX )) )) y_ty_list))  ;\nsty_option (P) ( (Some ( ty' )) ) ( \\<Gamma>   (x_var var) )\\<rbrakk> \\<Longrightarrow>\nwf_stmt (P) (\\<Gamma>) ((s_call var x meth Y))\"\n\n| (* defn meth *)\n\nwf_methodI: \"\\<lbrakk> distinct ( ((List.map (%((cl_XXX::cl),(var_XXX::var),(ty_XXX::ty)).var_XXX) cl_var_ty_list)) )  ;\n list_all (\\<lambda>f. f)  ((List.map (%((cl_XXX::cl),(var_XXX::var),(ty_XXX::ty)).find_type (P) (ctx) (cl_XXX) ( (Some ( ty_XXX )) )) cl_var_ty_list))  ;\n \\<Gamma>  =   (  (map_of ( ((List.map (%((cl_XXX::cl),(var_XXX::var),(ty_XXX::ty)).((x_var var_XXX),ty_XXX)) cl_var_ty_list)) ))   ( x_this   \\<mapsto>   (ty_def ctx dcl) ))   ;\n list_all (\\<lambda>f. f)  ((List.map (%(s_XXX::s).wf_stmt (P) (\\<Gamma>) (s_XXX)) s_list))  ;\nfind_type (P) (ctx) (cl) ( (Some ( ty )) ) ;\nsty_option (P) ( \\<Gamma>   y ) ( (Some ( ty )) )\\<rbrakk> \\<Longrightarrow>\nwf_meth (P) ((ty_def ctx dcl)) ((meth_def_def (meth_sig_def cl meth  ((List.map (%((cl_XXX::cl),(var_XXX::var),(ty_XXX::ty)).(vd_def cl_XXX var_XXX)) cl_var_ty_list)) ) (meth_body_def (s_list) y)))\"\n\n| (* defn class_common *)\n\nwf_class_commonI: \"\\<lbrakk>find_type (P) (ctx) (cl) ( (Some ( ty )) ) ;\n (ty_def ctx dcl)  \\<noteq>  ty  ;\n distinct ( ((List.map (%((cl_XXX::cl),(f_XXX::f),(ty_XXX::ty)).f_XXX) cl_f_ty_list)) )  ;\nfields (P) (ty) ( Some ( fs ) ) ;\n (set   ((List.map (%((cl_XXX::cl),(f_XXX::f),(ty_XXX::ty)).f_XXX) cl_f_ty_list))  ) \\<inter> (set  fs ) = {}  ;\n list_all (\\<lambda>f. f)  ((List.map (%((cl_XXX::cl),(f_XXX::f),(ty_XXX::ty)).find_type (P) (ctx) (cl_XXX) ( (Some ( ty_XXX )) )) cl_f_ty_list))  ;\n list_all (\\<lambda>f. f)  ((List.map (%((meth_def_XXX::meth_def),(meth_XXX::meth)).wf_meth (P) ((ty_def ctx dcl)) (meth_def_XXX)) meth_def_meth_list))  ;\n list_all (\\<lambda>f. f)  ((List.map (%((meth_def_XXX::meth_def),(meth_XXX::meth)).method_name (meth_def_XXX) (meth_XXX)) meth_def_meth_list))  ;\n distinct ( ((List.map (%((meth_def_XXX::meth_def),(meth_XXX::meth)).meth_XXX) meth_def_meth_list)) )  ;\nmethods (P) (ty) ( ((List.map (%((meth_'::meth),(mty_XXX::mty),(mty_'::mty)).meth_') meth'_mty_mty'_list)) ) ;\n list_all (\\<lambda>f. f)  ((List.map (%((meth_'::meth),(mty_XXX::mty),(mty_'::mty)).mtype (P) ((ty_def ctx dcl)) (meth_') (mty_XXX)) meth'_mty_mty'_list))  ;\n list_all (\\<lambda>f. f)  ((List.map (%((meth_'::meth),(mty_XXX::mty),(mty_'::mty)).mtype (P) (ty) (meth_') (mty_')) meth'_mty_mty'_list))  ;\n list_all (\\<lambda>f. f)  ((List.map (%((meth_'::meth),(mty_XXX::mty),(mty_'::mty)).  meth_'  \\<in> set   ((List.map (%((meth_def_XXX::meth_def),(meth_XXX::meth)).meth_XXX) meth_def_meth_list))    \\<longrightarrow>   mty_XXX  =  mty_'  ) meth'_mty_mty'_list)) \\<rbrakk> \\<Longrightarrow>\nwf_class_common (P) (ctx) (dcl) (cl) ( ((List.map (%((cl_XXX::cl),(f_XXX::f),(ty_XXX::ty)).(fd_def cl_XXX f_XXX)) cl_f_ty_list)) ) ( ((List.map (%((meth_def_XXX::meth_def),(meth_XXX::meth)).meth_def_XXX) meth_def_meth_list)) )\"\n\n| (* defn class *)\n\nwf_classI: \"\\<lbrakk> (cld_def dcl cl fds meth_defs)  \\<in> set  P  ;\nwf_class_common (P) (ctx_def) (dcl) (cl) (fds) (meth_defs)\\<rbrakk> \\<Longrightarrow>\nwf_class (P) ((cld_def dcl cl fds meth_defs))\"\n\n| (* defn program *)\n\nwf_programI: \"\\<lbrakk> P  =    (cld_list)    ;\ndistinct_names (P) ;\n list_all (\\<lambda>f. f)  ((List.map (%(cld_XXX::cld).wf_class (P) (cld_XXX)) cld_list))  ;\nacyclic_clds (P)\\<rbrakk> \\<Longrightarrow>\nwf_program (P)\""], ["", "(*defns var_trans *)"], ["", "inductive tr_s :: \"T \\<Rightarrow> s \\<Rightarrow> s \\<Rightarrow> bool\"\nwhere\n(* defn tr_s *)\n\ntr_s_blockI: \"\\<lbrakk> list_all (\\<lambda>f. f)  ((List.map (%((s_XXX::s),(s_'::s)).tr_s (T) (s_XXX) (s_')) s_s'_list)) \\<rbrakk> \\<Longrightarrow>\ntr_s (T) ((s_block ((List.map (%((s_XXX::s),(s_'::s)).s_XXX) s_s'_list)))) ((s_block ((List.map (%((s_XXX::s),(s_'::s)).s_') s_s'_list))))\"\n\n| tr_s_var_assignI: \"\\<lbrakk> (case  T  (x_var  var ) of\n                    None \\<Rightarrow>  var  | Some x' \\<Rightarrow>\n                 (case x' of x_this \\<Rightarrow>  var\n                           | x_var var' \\<Rightarrow> var')) =  var'  ;\n (case  T   x  of None \\<Rightarrow>  x\n                                    | Some x' \\<Rightarrow> x') =  x' \\<rbrakk> \\<Longrightarrow>\ntr_s (T) ((s_ass var x)) ((s_ass var' x'))\"\n\n| tr_s_field_readI: \"\\<lbrakk> (case  T  (x_var  var ) of\n                    None \\<Rightarrow>  var  | Some x' \\<Rightarrow>\n                 (case x' of x_this \\<Rightarrow>  var\n                           | x_var var' \\<Rightarrow> var')) =  var'  ;\n (case  T   x  of None \\<Rightarrow>  x\n                                    | Some x' \\<Rightarrow> x') =  x' \\<rbrakk> \\<Longrightarrow>\ntr_s (T) ((s_read var x f)) ((s_read var' x' f))\"\n\n| tr_s_field_writeI: \"\\<lbrakk> (case  T   x  of None \\<Rightarrow>  x\n                                    | Some x' \\<Rightarrow> x') =  x'  ;\n (case  T   y  of None \\<Rightarrow>  y\n                                    | Some x' \\<Rightarrow> x') =  y' \\<rbrakk> \\<Longrightarrow>\ntr_s (T) ((s_write x f y)) ((s_write x' f y'))\"\n\n| tr_s_ifI: \"\\<lbrakk> (case  T   x  of None \\<Rightarrow>  x\n                                    | Some x' \\<Rightarrow> x') =  x'  ;\n (case  T   y  of None \\<Rightarrow>  y\n                                    | Some x' \\<Rightarrow> x') =  y'  ;\ntr_s (T) (s1) (s1') ;\ntr_s (T) (s2) (s2')\\<rbrakk> \\<Longrightarrow>\ntr_s (T) ((s_if x y s1 s2)) ((s_if x' y' s1' s2'))\"\n\n| tr_s_newI: \"\\<lbrakk> (case  T  (x_var  var ) of\n                    None \\<Rightarrow>  var  | Some x' \\<Rightarrow>\n                 (case x' of x_this \\<Rightarrow>  var\n                           | x_var var' \\<Rightarrow> var')) =  var' \\<rbrakk> \\<Longrightarrow>\ntr_s (T) ((s_new var ctx cl)) ((s_new var' ctx cl))\"\n\n| tr_s_mcallI: \"\\<lbrakk> (case  T  (x_var  var ) of\n                    None \\<Rightarrow>  var  | Some x' \\<Rightarrow>\n                 (case x' of x_this \\<Rightarrow>  var\n                           | x_var var' \\<Rightarrow> var')) =  var'  ;\n (case  T   x  of None \\<Rightarrow>  x\n                                    | Some x' \\<Rightarrow> x') =  x'  ;\n list_all (\\<lambda>f. f)  ((List.map (%((y_XXX::x),(y_'::x)). (case  T   y_XXX  of None \\<Rightarrow>  y_XXX\n                                    | Some x' \\<Rightarrow> x') =  y_' ) y_y'_list)) \\<rbrakk> \\<Longrightarrow>\ntr_s (T) ((s_call var x meth  ((List.map (%((y_XXX::x),(y_'::x)).y_XXX) y_y'_list)) )) ((s_call var' x' meth  ((List.map (%((y_XXX::x),(y_'::x)).y_') y_y'_list)) ))\""], ["", "(*defns reduction *)"], ["", "inductive r_stmt :: \"config \\<Rightarrow> config \\<Rightarrow> bool\"\nwhere\n(* defn stmt *)\n\nr_blockI: \"r_stmt ((config_normal P L H ([((s_block (s_list)))] @ s'_list))) ((config_normal P L H (s_list @ s'_list)))\"\n\n| r_var_assignI: \"\\<lbrakk>  L   x   = Some  v \\<rbrakk> \\<Longrightarrow>\nr_stmt ((config_normal P L H ([((s_ass var x))] @ s_list))) ((config_normal P  ( L  ( (x_var var)   \\<mapsto>   v ))  H (s_list)))\"\n\n| r_field_read_npeI: \"\\<lbrakk>  L   x   = Some  v_null \\<rbrakk> \\<Longrightarrow>\nr_stmt ((config_normal P L H ([((s_read var x f))] @ s_list))) ((config_ex P L H ex_npe))\"\n\n| r_field_readI: \"\\<lbrakk>  L   x   = Some  (v_oid oid)  ;\n  (case  H   oid  of\n                     None \\<Rightarrow> None\n                   | Some tyfs \\<Rightarrow> (snd tyfs)  f )   = Some  v \\<rbrakk> \\<Longrightarrow>\nr_stmt ((config_normal P L H ([((s_read var x f))] @ s_list))) ((config_normal P  ( L  ( (x_var var)   \\<mapsto>   v ))  H (s_list)))\"\n\n| r_field_write_npeI: \"\\<lbrakk>  L   x   = Some  v_null \\<rbrakk> \\<Longrightarrow>\nr_stmt ((config_normal P L H ([((s_write x f y))] @ s_list))) ((config_ex P L H ex_npe))\"\n\n| r_field_writeI: \"\\<lbrakk>  L   x   = Some  (v_oid oid)  ;\n  L   y   = Some  v \\<rbrakk> \\<Longrightarrow>\nr_stmt ((config_normal P L H ([((s_write x f y))] @ s_list))) ((config_normal P L  (case  H   oid  of\n                None \\<Rightarrow> arbitrary\n              | Some tyfs \\<Rightarrow>\n                   (( H  ( oid   \\<mapsto>\n                       (fst tyfs, snd tyfs ( f   \\<mapsto>   v ))))::H))  (s_list)))\"\n\n| r_if_trueI: \"\\<lbrakk>  L   x   = Some  v  ;\n  L   y   = Some  w  ;\n v  =  w \\<rbrakk> \\<Longrightarrow>\nr_stmt ((config_normal P L H ([((s_if x y s1 s2))] @ s'_list))) ((config_normal P L H ([(s1)] @ s'_list)))\"\n\n| r_if_falseI: \"\\<lbrakk>  L   x   = Some  v  ;\n  L   y   = Some  w  ;\n v  \\<noteq>  w \\<rbrakk> \\<Longrightarrow>\nr_stmt ((config_normal P L H ([((s_if x y s1 s2))] @ s'_list))) ((config_normal P L H ([(s2)] @ s'_list)))\"\n\n| r_newI: \"\\<lbrakk>find_type (P) (ctx) (cl) ( (Some ( ty )) ) ;\nfields (P) (ty) ( Some (  (f_list)  ) ) ;\n oid  \\<notin> dom  H  ;\n H'  =   (( H  ( oid   \\<mapsto>  ( ty ,\n                          map_of  ((List.map (%(f_XXX::f).(f_XXX,v_null)) f_list))  )))::H)  \\<rbrakk> \\<Longrightarrow>\nr_stmt ((config_normal P L H ([((s_new var ctx cl))] @ s_list))) ((config_normal P  ( L  ( (x_var var)   \\<mapsto>   (v_oid oid) ))  H' (s_list)))\"\n\n| r_mcall_npeI: \"\\<lbrakk>  L   x   = Some  v_null \\<rbrakk> \\<Longrightarrow>\nr_stmt ((config_normal P L H ([((s_call var x meth  (y_list) ))] @ s_list))) ((config_ex P L H ex_npe))\"\n\n| r_mcallI: \"\\<lbrakk>  L   x   = Some  (v_oid oid)  ;\n  (case  H   oid  of\n                     None \\<Rightarrow> None\n                   | Some tyfs \\<Rightarrow> Some (fst tyfs))   =   (Some ( ty ))   ;\nfind_meth_def (P) (ty) (meth) ( (Some ( ctx , (meth_def_def (meth_sig_def cl meth  ((List.map (%((y_XXX::x),(cl_XXX::cl),(var_XXX::var),(var_'::var),(v_XXX::v)).(vd_def cl_XXX var_XXX)) y_cl_var_var'_v_list)) ) (meth_body_def ((List.map (%((s_''::s),(s_'::s)).s_') s''_s'_list)) y)) )::ctxmeth_def_opt) ) ;\n (set  ((List.map (%((y_XXX::x),(cl_XXX::cl),(var_XXX::var),(var_'::var),(v_XXX::v)).(x_var var_')) y_cl_var_var'_v_list)) ) Int (dom  L ) = {}  ;\n distinct ( ((List.map (%((y_XXX::x),(cl_XXX::cl),(var_XXX::var),(var_'::var),(v_XXX::v)).var_') y_cl_var_var'_v_list)) )  ;\n x'  \\<notin> dom  L  ;\n x'  \\<notin> set  ((List.map (%((y_XXX::x),(cl_XXX::cl),(var_XXX::var),(var_'::var),(v_XXX::v)).(x_var var_')) y_cl_var_var'_v_list))  ;\n list_all (\\<lambda>f. f)  ((List.map (%((y_XXX::x),(cl_XXX::cl),(var_XXX::var),(var_'::var),(v_XXX::v)).  L   y_XXX   = Some  v_XXX ) y_cl_var_var'_v_list))  ;\n L'  =   (  ( L  ++ (map_of ( ((List.map (%((y_XXX::x),(cl_XXX::cl),(var_XXX::var),(var_'::var),(v_XXX::v)).((x_var var_'),v_XXX)) y_cl_var_var'_v_list)) )))   ( x'   \\<mapsto>   (v_oid oid) ))   ;\n T  =   (  (map_of ( ((List.map (%((y_XXX::x),(cl_XXX::cl),(var_XXX::var),(var_'::var),(v_XXX::v)).((x_var var_XXX),(x_var var_'))) y_cl_var_var'_v_list)) ))   ( x_this   \\<mapsto>   x' ))   ;\n list_all (\\<lambda>f. f)  ((List.map (%((s_''::s),(s_'::s)).tr_s (T) (s_') (s_'')) s''_s'_list))  ;\n (case  T   y  of None \\<Rightarrow>  y\n                                    | Some x' \\<Rightarrow> x') =  y' \\<rbrakk> \\<Longrightarrow>\nr_stmt ((config_normal P L H ([((s_call var x meth  ((List.map (%((y_XXX::x),(cl_XXX::cl),(var_XXX::var),(var_'::var),(v_XXX::v)).y_XXX) y_cl_var_var'_v_list)) ))] @ s_list))) ((config_normal P L' H ((List.map (%((s_''::s),(s_'::s)).s_'') s''_s'_list) @ [((s_ass var y'))] @ s_list)))\""], ["", "end"]]}