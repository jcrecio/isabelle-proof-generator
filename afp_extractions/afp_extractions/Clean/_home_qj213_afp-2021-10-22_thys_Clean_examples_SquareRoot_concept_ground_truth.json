{"file_name": "/home/qj213/afp-2021-10-22/thys/Clean/examples/SquareRoot_concept.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Clean", "problem_names": ["lemma tm_independent [simp]: \"\\<sharp> tm_update\"", "lemma i_independent [simp]: \"\\<sharp> i_update\"", "lemma sqsum_independent [simp]: \"\\<sharp> sqsum_update\"", "lemma tm_simp : \"tm (\\<sigma>\\<lparr>tm := t\\<rparr>) = t\"", "lemma tm_simp1 : \"tm (\\<sigma>\\<lparr>sqsum := s\\<rparr>) = tm \\<sigma>\"", "lemma tm_simp2 : \"tm (\\<sigma>\\<lparr>i := s\\<rparr>) = tm \\<sigma>\"", "lemma sqsum_simp : \"sqsum (\\<sigma>\\<lparr>sqsum := s\\<rparr>) = s\"", "lemma sqsum_simp1 : \"sqsum (\\<sigma>\\<lparr>tm := t\\<rparr>) = sqsum \\<sigma>\"", "lemma sqsum_simp2 : \"sqsum (\\<sigma>\\<lparr>i := t\\<rparr>) = sqsum \\<sigma>\"", "lemma i_simp : \"i (\\<sigma>\\<lparr>i := i'\\<rparr>) = i'\"", "lemma i_simp1 : \"i (\\<sigma>\\<lparr>tm := i'\\<rparr>) = i \\<sigma>\"", "lemma i_simp2 : \"i (\\<sigma>\\<lparr>sqsum := i'\\<rparr>) = i \\<sigma>\"", "lemmas memory_theory =\n  tm_simp tm_simp1 tm_simp2\n  sqsum_simp sqsum_simp1 sqsum_simp2\n  i_simp i_simp1 i_simp2", "lemma non_exec_assign_globalD':\n  assumes \"\\<sharp> upd\"\n  shows   \"\\<sigma> \\<Turnstile> assign_global upd rhs ;- M \\<Longrightarrow>\\<not> exec_stop \\<sigma> \\<Longrightarrow>  upd (\\<lambda>_. rhs \\<sigma>) \\<sigma> \\<Turnstile> M\"", "lemmas non_exec_assign_globalD'_tm = non_exec_assign_globalD'[OF tm_independent]", "lemmas non_exec_assign_globalD'_i = non_exec_assign_globalD'[OF i_independent]", "lemmas non_exec_assign_globalD'_sqsum = non_exec_assign_globalD'[OF sqsum_independent]", "lemma\n  assumes non_exec_stop[simp]: \"\\<not> exec_stop \\<sigma>\\<^sub>0\"\n   and    pos : \"0 \\<le> (a::int)\"\n   and    annotated_program:\n          \"\\<sigma>\\<^sub>0 \\<Turnstile> \\<open>tm := 1\\<close> ;-\n                \\<open>sqsum := 1\\<close> ;-\n                \\<open>i := 0\\<close> ;-\n                (while\\<^sub>S\\<^sub>E \\<open>sqsum <= a\\<close> do\n                   \\<open>i := i+1\\<close> ;-\n                   \\<open>tm := tm + 2\\<close> ;-\n                   \\<open>sqsum := tm + sqsum\\<close>\n                od) ;-\n                assert\\<^sub>S\\<^sub>E(\\<lambda>\\<sigma>. \\<sigma>=\\<sigma>\\<^sub>R)\"\n\n       shows \"\\<sigma>\\<^sub>R \\<Turnstile>assert\\<^sub>S\\<^sub>E \\<open>i\\<^sup>2  \\<le> a \\<and> a < (i + 1)\\<^sup>2\\<close> \""], "translations": [["", "lemma tm_independent [simp]: \"\\<sharp> tm_update\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sharp> tm_update", "unfolding control_independence_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> T b.\n       break_status (tm_update T \\<sigma>) = break_status \\<sigma> \\<and>\n       return_status (tm_update T \\<sigma>) = return_status \\<sigma> \\<and>\n       tm_update T (\\<sigma>\\<lparr>return_status := b\\<rparr>) =\n       tm_update T \\<sigma>\\<lparr>return_status := b\\<rparr> \\<and>\n       tm_update T (\\<sigma>\\<lparr>break_status := b\\<rparr>) =\n       tm_update T \\<sigma>\\<lparr>break_status := b\\<rparr>", "by auto"], ["", "lemma i_independent [simp]: \"\\<sharp> i_update\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sharp> i_update", "unfolding control_independence_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> T b.\n       break_status (i_update T \\<sigma>) = break_status \\<sigma> \\<and>\n       return_status (i_update T \\<sigma>) = return_status \\<sigma> \\<and>\n       i_update T (\\<sigma>\\<lparr>return_status := b\\<rparr>) =\n       i_update T \\<sigma>\\<lparr>return_status := b\\<rparr> \\<and>\n       i_update T (\\<sigma>\\<lparr>break_status := b\\<rparr>) =\n       i_update T \\<sigma>\\<lparr>break_status := b\\<rparr>", "by auto"], ["", "lemma sqsum_independent [simp]: \"\\<sharp> sqsum_update\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sharp> sqsum_update", "unfolding control_independence_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma> T b.\n       break_status (sqsum_update T \\<sigma>) = break_status \\<sigma> \\<and>\n       return_status (sqsum_update T \\<sigma>) =\n       return_status \\<sigma> \\<and>\n       sqsum_update T (\\<sigma>\\<lparr>return_status := b\\<rparr>) =\n       sqsum_update T \\<sigma>\\<lparr>return_status := b\\<rparr> \\<and>\n       sqsum_update T (\\<sigma>\\<lparr>break_status := b\\<rparr>) =\n       sqsum_update T \\<sigma>\\<lparr>break_status := b\\<rparr>", "by auto"], ["", "subsection\\<open> Setting for Symbolic Execution \\<close>"], ["", "text\\<open> Some lemmas to reason about memory\\<close>"], ["", "lemma tm_simp : \"tm (\\<sigma>\\<lparr>tm := t\\<rparr>) = t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tm (\\<sigma>\\<lparr>tm := t\\<rparr>) = t", "using [[simp_trace]]"], ["proof (prove)\ngoal (1 subgoal):\n 1. tm (\\<sigma>\\<lparr>tm := t\\<rparr>) = t", "by simp"], ["", "(* from trace:\n   [1]Procedure \"record\" produced rewrite rule:\n   tm (?r\\<lparr>tm := ?k\\<rparr>) \\<equiv> ?k\n\n   Unfortunately, this lemma is not exported ... It looks as if it is computed on the fly ...\n   This could explain why this is slow for our purposes ...\n*)"], ["", "lemma tm_simp1 : \"tm (\\<sigma>\\<lparr>sqsum := s\\<rparr>) = tm \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tm (\\<sigma>\\<lparr>sqsum := s\\<rparr>) = tm \\<sigma>", "by simp"], ["", "lemma tm_simp2 : \"tm (\\<sigma>\\<lparr>i := s\\<rparr>) = tm \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. tm (\\<sigma>\\<lparr>i := s\\<rparr>) = tm \\<sigma>", "by simp"], ["", "lemma sqsum_simp : \"sqsum (\\<sigma>\\<lparr>sqsum := s\\<rparr>) = s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqsum (\\<sigma>\\<lparr>sqsum := s\\<rparr>) = s", "by simp"], ["", "lemma sqsum_simp1 : \"sqsum (\\<sigma>\\<lparr>tm := t\\<rparr>) = sqsum \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqsum (\\<sigma>\\<lparr>tm := t\\<rparr>) = sqsum \\<sigma>", "by simp"], ["", "lemma sqsum_simp2 : \"sqsum (\\<sigma>\\<lparr>i := t\\<rparr>) = sqsum \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sqsum (\\<sigma>\\<lparr>i := t\\<rparr>) = sqsum \\<sigma>", "by simp"], ["", "lemma i_simp : \"i (\\<sigma>\\<lparr>i := i'\\<rparr>) = i'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i (\\<sigma>\\<lparr>i := i'\\<rparr>) = i'", "by simp"], ["", "lemma i_simp1 : \"i (\\<sigma>\\<lparr>tm := i'\\<rparr>) = i \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i (\\<sigma>\\<lparr>tm := i'\\<rparr>) = i \\<sigma>", "by simp"], ["", "lemma i_simp2 : \"i (\\<sigma>\\<lparr>sqsum := i'\\<rparr>) = i \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i (\\<sigma>\\<lparr>sqsum := i'\\<rparr>) = i \\<sigma>", "by simp"], ["", "lemmas memory_theory =\n  tm_simp tm_simp1 tm_simp2\n  sqsum_simp sqsum_simp1 sqsum_simp2\n  i_simp i_simp1 i_simp2"], ["", "declare memory_theory [memory_theory]"], ["", "lemma non_exec_assign_globalD':\n  assumes \"\\<sharp> upd\"\n  shows   \"\\<sigma> \\<Turnstile> assign_global upd rhs ;- M \\<Longrightarrow>\\<not> exec_stop \\<sigma> \\<Longrightarrow>  upd (\\<lambda>_. rhs \\<sigma>) \\<sigma> \\<Turnstile> M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<sigma> \\<Turnstile> assign_global upd rhs ;- M;\n     \\<not> exec_stop \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> upd (\\<lambda>_. rhs \\<sigma>) \\<sigma> \\<Turnstile> M", "apply(drule non_exec_assign_global'[THEN iffD1])"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<sigma> \\<Turnstile> assign_global upd rhs ;- M \\<Longrightarrow>\n    \\<sigma> \\<Turnstile> assign_global ?upd ?rhs ;- ?M\n 2. \\<lbrakk>\\<sigma> \\<Turnstile> assign_global upd rhs ;- M;\n     ?upd (\\<lambda>_. ?rhs \\<sigma>) \\<sigma> \\<Turnstile> ?M\\<rbrakk>\n    \\<Longrightarrow> upd (\\<lambda>_. rhs \\<sigma>) \\<sigma> \\<Turnstile> M", "using assms exec_stop_vs_control_independence"], ["proof (prove)\nusing this:\n  \\<sharp> upd\n  \\<sharp> ?upd \\<Longrightarrow>\n  exec_stop (?upd ?f ?\\<sigma>) = exec_stop ?\\<sigma>\n\ngoal (2 subgoals):\n 1. \\<sigma> \\<Turnstile> assign_global upd rhs ;- M \\<Longrightarrow>\n    \\<sigma> \\<Turnstile> assign_global ?upd ?rhs ;- ?M\n 2. \\<lbrakk>\\<sigma> \\<Turnstile> assign_global upd rhs ;- M;\n     ?upd (\\<lambda>_. ?rhs \\<sigma>) \\<sigma> \\<Turnstile> ?M\\<rbrakk>\n    \\<Longrightarrow> upd (\\<lambda>_. rhs \\<sigma>) \\<sigma> \\<Turnstile> M", "apply blast"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<sigma> \\<Turnstile> assign_global upd rhs ;- M;\n     upd (\\<lambda>_. rhs \\<sigma>) \\<sigma> \\<Turnstile> M\\<rbrakk>\n    \\<Longrightarrow> upd (\\<lambda>_. rhs \\<sigma>) \\<sigma> \\<Turnstile> M", "by auto"], ["", "lemmas non_exec_assign_globalD'_tm = non_exec_assign_globalD'[OF tm_independent]"], ["", "lemmas non_exec_assign_globalD'_i = non_exec_assign_globalD'[OF i_independent]"], ["", "lemmas non_exec_assign_globalD'_sqsum = non_exec_assign_globalD'[OF sqsum_independent]"], ["", "text\\<open> Now we run a symbolic execution. We run match-tactics (rather than the Isabelle simplifier\n  which would do the trick as well) in order to demonstrate a symbolic execution in Isabelle. \\<close>"], ["", "subsection\\<open> A Symbolic Execution Simulation \\<close>"], ["", "lemma\n  assumes non_exec_stop[simp]: \"\\<not> exec_stop \\<sigma>\\<^sub>0\"\n   and    pos : \"0 \\<le> (a::int)\"\n   and    annotated_program:\n          \"\\<sigma>\\<^sub>0 \\<Turnstile> \\<open>tm := 1\\<close> ;-\n                \\<open>sqsum := 1\\<close> ;-\n                \\<open>i := 0\\<close> ;-\n                (while\\<^sub>S\\<^sub>E \\<open>sqsum <= a\\<close> do\n                   \\<open>i := i+1\\<close> ;-\n                   \\<open>tm := tm + 2\\<close> ;-\n                   \\<open>sqsum := tm + sqsum\\<close>\n                od) ;-\n                assert\\<^sub>S\\<^sub>E(\\<lambda>\\<sigma>. \\<sigma>=\\<sigma>\\<^sub>R)\"\n\n       shows \"\\<sigma>\\<^sub>R \\<Turnstile>assert\\<^sub>S\\<^sub>E \\<open>i\\<^sup>2  \\<le> a \\<and> a < (i + 1)\\<^sup>2\\<close> \""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma>\\<^sub>R \\<Turnstile>\n    assert\\<^sub>S\\<^sub>E\n     (\\<lambda>\\<sigma>.\n         (i \\<sigma>)\\<^sup>2 \\<le> a \\<and> a < (i \\<sigma> + 1)\\<^sup>2)", "apply(insert annotated_program)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma>\\<^sub>0 \\<Turnstile>\n    assign_global tm_update (\\<lambda>\\<sigma>. 1) ;-\n    assign_global sqsum_update (\\<lambda>\\<sigma>. 1) ;-\n    assign_global i_update (\\<lambda>\\<sigma>. 0) ;-\n    _while_SE (\\<lambda>\\<sigma>. sqsum \\<sigma> \\<le> a)\n     (assign_global i_update (\\<lambda>\\<sigma>. i \\<sigma> + 1) ;-\n      assign_global tm_update (\\<lambda>\\<sigma>. tm \\<sigma> + 2) ;-\n      assign_global sqsum_update\n       (\\<lambda>\\<sigma>. tm \\<sigma> + sqsum \\<sigma>)) ;-\n    assert\\<^sub>S\\<^sub>E\n     (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R) \\<Longrightarrow>\n    \\<sigma>\\<^sub>R \\<Turnstile>\n    assert\\<^sub>S\\<^sub>E\n     (\\<lambda>\\<sigma>.\n         (i \\<sigma>)\\<^sup>2 \\<le> a \\<and> a < (i \\<sigma> + 1)\\<^sup>2)", "apply(tactic \"dmatch_tac @{context} [@{thm \\\"non_exec_assign_globalD'_tm\\\"}] 1\",simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma>\\<^sub>0\\<lparr>tm := 1\\<rparr> \\<Turnstile>\n    assign_global sqsum_update (\\<lambda>\\<sigma>. 1) ;-\n    assign_global i_update (\\<lambda>\\<sigma>. 0) ;-\n    _while_SE (\\<lambda>\\<sigma>. sqsum \\<sigma> \\<le> a)\n     (assign_global i_update (\\<lambda>\\<sigma>. i \\<sigma> + 1) ;-\n      assign_global tm_update (\\<lambda>\\<sigma>. tm \\<sigma> + 2) ;-\n      assign_global sqsum_update\n       (\\<lambda>\\<sigma>. tm \\<sigma> + sqsum \\<sigma>)) ;-\n    assert\\<^sub>S\\<^sub>E\n     (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R) \\<Longrightarrow>\n    \\<sigma>\\<^sub>R \\<Turnstile>\n    assert\\<^sub>S\\<^sub>E\n     (\\<lambda>\\<sigma>.\n         (i \\<sigma>)\\<^sup>2 \\<le> a \\<and> a < (i \\<sigma> + 1)\\<^sup>2)", "apply(tactic \"dmatch_tac @{context} [@{thm \\\"non_exec_assign_globalD'_sqsum\\\"}] 1\",simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma>\\<^sub>0\\<lparr>tm := 1, sqsum := 1\\<rparr> \\<Turnstile>\n    assign_global i_update (\\<lambda>\\<sigma>. 0) ;-\n    _while_SE (\\<lambda>\\<sigma>. sqsum \\<sigma> \\<le> a)\n     (assign_global i_update (\\<lambda>\\<sigma>. i \\<sigma> + 1) ;-\n      assign_global tm_update (\\<lambda>\\<sigma>. tm \\<sigma> + 2) ;-\n      assign_global sqsum_update\n       (\\<lambda>\\<sigma>. tm \\<sigma> + sqsum \\<sigma>)) ;-\n    assert\\<^sub>S\\<^sub>E\n     (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R) \\<Longrightarrow>\n    \\<sigma>\\<^sub>R \\<Turnstile>\n    assert\\<^sub>S\\<^sub>E\n     (\\<lambda>\\<sigma>.\n         (i \\<sigma>)\\<^sup>2 \\<le> a \\<and> a < (i \\<sigma> + 1)\\<^sup>2)", "apply(tactic \"dmatch_tac @{context} [@{thm \\\"non_exec_assign_globalD'_i\\\"}] 1\",simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma>\\<^sub>0\\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr> \\<Turnstile>\n    _while_SE (\\<lambda>\\<sigma>. sqsum \\<sigma> \\<le> a)\n     (assign_global i_update (\\<lambda>\\<sigma>. i \\<sigma> + 1) ;-\n      assign_global tm_update (\\<lambda>\\<sigma>. tm \\<sigma> + 2) ;-\n      assign_global sqsum_update\n       (\\<lambda>\\<sigma>. tm \\<sigma> + sqsum \\<sigma>)) ;-\n    assert\\<^sub>S\\<^sub>E\n     (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R) \\<Longrightarrow>\n    \\<sigma>\\<^sub>R \\<Turnstile>\n    assert\\<^sub>S\\<^sub>E\n     (\\<lambda>\\<sigma>.\n         (i \\<sigma>)\\<^sup>2 \\<le> a \\<and> a < (i \\<sigma> + 1)\\<^sup>2)", "apply(tactic \"dmatch_tac @{context} [@{thm \\\"exec_whileD\\\"}] 1\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<sigma>\\<^sub>0\\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr> \\<Turnstile>\n    _if_SE (\\<lambda>\\<sigma>. sqsum \\<sigma> \\<le> a)\n     ((assign_global i_update (\\<lambda>\\<sigma>. i \\<sigma> + 1) ;-\n       assign_global tm_update (\\<lambda>\\<sigma>. tm \\<sigma> + 2) ;-\n       assign_global sqsum_update\n        (\\<lambda>\\<sigma>. tm \\<sigma> + sqsum \\<sigma>)) ;-\n      _while_SE (\\<lambda>\\<sigma>. sqsum \\<sigma> \\<le> a)\n       (assign_global i_update (\\<lambda>\\<sigma>. i \\<sigma> + 1) ;-\n        assign_global tm_update (\\<lambda>\\<sigma>. tm \\<sigma> + 2) ;-\n        assign_global sqsum_update\n         (\\<lambda>\\<sigma>. tm \\<sigma> + sqsum \\<sigma>)))\n     (unit\\<^sub>S\\<^sub>E ()) ;-\n    assert\\<^sub>S\\<^sub>E\n     (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R) \\<Longrightarrow>\n    \\<sigma>\\<^sub>R \\<Turnstile>\n    assert\\<^sub>S\\<^sub>E\n     (\\<lambda>\\<sigma>.\n         (i \\<sigma>)\\<^sup>2 \\<le> a \\<and> a < (i \\<sigma> + 1)\\<^sup>2)", "apply(tactic \"ematch_tac @{context} [@{thm \\\"if_SE_execE''\\\"}] 1\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>sqsum\n              (\\<sigma>\\<^sub>0\\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr>)\n             \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr> \\<Turnstile>\n     ((assign_global i_update (\\<lambda>\\<sigma>. i \\<sigma> + 1) ;-\n       assign_global tm_update (\\<lambda>\\<sigma>. tm \\<sigma> + 2) ;-\n       assign_global sqsum_update\n        (\\<lambda>\\<sigma>. tm \\<sigma> + sqsum \\<sigma>)) ;-\n      _while_SE (\\<lambda>\\<sigma>. sqsum \\<sigma> \\<le> a)\n       (assign_global i_update (\\<lambda>\\<sigma>. i \\<sigma> + 1) ;-\n        assign_global tm_update (\\<lambda>\\<sigma>. tm \\<sigma> + 2) ;-\n        assign_global sqsum_update\n         (\\<lambda>\\<sigma>. tm \\<sigma> + sqsum \\<sigma>))) ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 2. \\<lbrakk>\\<not> sqsum\n                     (\\<sigma>\\<^sub>0\n                      \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr>)\n                    \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr> \\<Turnstile>\n     unit\\<^sub>S\\<^sub>E () ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)", "apply(simp_all only: memory_theory MonadSE.bind_assoc')"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr> \\<Turnstile>\n     assign_global i_update (\\<lambda>\\<sigma>. i \\<sigma> + 1) ;-\n     assign_global tm_update (\\<lambda>\\<sigma>. tm \\<sigma> + 2) ;-\n     assign_global sqsum_update\n      (\\<lambda>\\<sigma>. tm \\<sigma> + sqsum \\<sigma>) ;-\n     _while_SE (\\<lambda>\\<sigma>. sqsum \\<sigma> \\<le> a)\n      (assign_global i_update (\\<lambda>\\<sigma>. i \\<sigma> + 1) ;-\n       assign_global tm_update (\\<lambda>\\<sigma>. tm \\<sigma> + 2) ;-\n       assign_global sqsum_update\n        (\\<lambda>\\<sigma>. tm \\<sigma> + sqsum \\<sigma>)) ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 2. \\<lbrakk>\\<not> 1 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr> \\<Turnstile>\n     unit\\<^sub>S\\<^sub>E () ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)", "apply(tactic \"dmatch_tac @{context} [@{thm \\\"non_exec_assign_globalD'_i\\\"}] 1\",simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0,\n        i := i (\\<sigma>\\<^sub>0\n                \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr>) +\n             1\\<rparr> \\<Turnstile>\n     assign_global tm_update (\\<lambda>\\<sigma>. tm \\<sigma> + 2) ;-\n     assign_global sqsum_update\n      (\\<lambda>\\<sigma>. tm \\<sigma> + sqsum \\<sigma>) ;-\n     _while_SE (\\<lambda>\\<sigma>. sqsum \\<sigma> \\<le> a)\n      (assign_global i_update (\\<lambda>\\<sigma>. i \\<sigma> + 1) ;-\n       assign_global tm_update (\\<lambda>\\<sigma>. tm \\<sigma> + 2) ;-\n       assign_global sqsum_update\n        (\\<lambda>\\<sigma>. tm \\<sigma> + sqsum \\<sigma>)) ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 2. \\<lbrakk>\\<not> 1 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr> \\<Turnstile>\n     unit\\<^sub>S\\<^sub>E () ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)", "apply(tactic \"dmatch_tac @{context} [@{thm \\\"non_exec_assign_globalD'_tm\\\"}] 1\",simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0,\n        i := i (\\<sigma>\\<^sub>0\n                \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr>) +\n             1,\n        tm :=\n          tm (\\<sigma>\\<^sub>0\n              \\<lparr>tm := 1, sqsum := 1, i := 0,\n                 i := i (\\<sigma>\\<^sub>0\n                         \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr>) +\n                      1\\<rparr>) +\n          2\\<rparr> \\<Turnstile>\n     assign_global sqsum_update\n      (\\<lambda>\\<sigma>. tm \\<sigma> + sqsum \\<sigma>) ;-\n     _while_SE (\\<lambda>\\<sigma>. sqsum \\<sigma> \\<le> a)\n      (assign_global i_update (\\<lambda>\\<sigma>. i \\<sigma> + 1) ;-\n       assign_global tm_update (\\<lambda>\\<sigma>. tm \\<sigma> + 2) ;-\n       assign_global sqsum_update\n        (\\<lambda>\\<sigma>. tm \\<sigma> + sqsum \\<sigma>)) ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 2. \\<lbrakk>\\<not> 1 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr> \\<Turnstile>\n     unit\\<^sub>S\\<^sub>E () ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)", "apply(tactic \"dmatch_tac @{context} [@{thm \\\"non_exec_assign_globalD'_sqsum\\\"}] 1\",simp)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0,\n        i := i (\\<sigma>\\<^sub>0\n                \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr>) +\n             1,\n        tm :=\n          tm (\\<sigma>\\<^sub>0\n              \\<lparr>tm := 1, sqsum := 1, i := 0,\n                 i := i (\\<sigma>\\<^sub>0\n                         \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr>) +\n                      1\\<rparr>) +\n          2,\n        sqsum :=\n          tm (\\<sigma>\\<^sub>0\n              \\<lparr>tm := 1, sqsum := 1, i := 0,\n                 i := i (\\<sigma>\\<^sub>0\n                         \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr>) +\n                      1,\n                 tm :=\n                   tm (\\<sigma>\\<^sub>0\n                       \\<lparr>tm := 1, sqsum := 1, i := 0,\n                          i := i (\\<sigma>\\<^sub>0\n                                  \\<lparr>tm := 1, sqsum := 1,\n                                     i := 0\\<rparr>) +\n                               1\\<rparr>) +\n                   2\\<rparr>) +\n          sqsum\n           (\\<sigma>\\<^sub>0\n            \\<lparr>tm := 1, sqsum := 1, i := 0,\n               i := i (\\<sigma>\\<^sub>0\n                       \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr>) +\n                    1,\n               tm :=\n                 tm (\\<sigma>\\<^sub>0\n                     \\<lparr>tm := 1, sqsum := 1, i := 0,\n                        i := i (\\<sigma>\\<^sub>0\n                                \\<lparr>tm := 1, sqsum := 1,\n                                   i := 0\\<rparr>) +\n                             1\\<rparr>) +\n                 2\\<rparr>)\\<rparr> \\<Turnstile>\n     _while_SE (\\<lambda>\\<sigma>. sqsum \\<sigma> \\<le> a)\n      (assign_global i_update (\\<lambda>\\<sigma>. i \\<sigma> + 1) ;-\n       assign_global tm_update (\\<lambda>\\<sigma>. tm \\<sigma> + 2) ;-\n       assign_global sqsum_update\n        (\\<lambda>\\<sigma>. tm \\<sigma> + sqsum \\<sigma>)) ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 2. \\<lbrakk>\\<not> 1 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr> \\<Turnstile>\n     unit\\<^sub>S\\<^sub>E () ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)", "apply(tactic \"dmatch_tac @{context} [@{thm \\\"exec_whileD\\\"}] 1\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>1 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0,\n        i := i (\\<sigma>\\<^sub>0\n                \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr>) +\n             1,\n        tm :=\n          tm (\\<sigma>\\<^sub>0\n              \\<lparr>tm := 1, sqsum := 1, i := 0,\n                 i := i (\\<sigma>\\<^sub>0\n                         \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr>) +\n                      1\\<rparr>) +\n          2,\n        sqsum :=\n          tm (\\<sigma>\\<^sub>0\n              \\<lparr>tm := 1, sqsum := 1, i := 0,\n                 i := i (\\<sigma>\\<^sub>0\n                         \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr>) +\n                      1,\n                 tm :=\n                   tm (\\<sigma>\\<^sub>0\n                       \\<lparr>tm := 1, sqsum := 1, i := 0,\n                          i := i (\\<sigma>\\<^sub>0\n                                  \\<lparr>tm := 1, sqsum := 1,\n                                     i := 0\\<rparr>) +\n                               1\\<rparr>) +\n                   2\\<rparr>) +\n          sqsum\n           (\\<sigma>\\<^sub>0\n            \\<lparr>tm := 1, sqsum := 1, i := 0,\n               i := i (\\<sigma>\\<^sub>0\n                       \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr>) +\n                    1,\n               tm :=\n                 tm (\\<sigma>\\<^sub>0\n                     \\<lparr>tm := 1, sqsum := 1, i := 0,\n                        i := i (\\<sigma>\\<^sub>0\n                                \\<lparr>tm := 1, sqsum := 1,\n                                   i := 0\\<rparr>) +\n                             1\\<rparr>) +\n                 2\\<rparr>)\\<rparr> \\<Turnstile>\n     _if_SE (\\<lambda>\\<sigma>. sqsum \\<sigma> \\<le> a)\n      ((assign_global i_update (\\<lambda>\\<sigma>. i \\<sigma> + 1) ;-\n        assign_global tm_update (\\<lambda>\\<sigma>. tm \\<sigma> + 2) ;-\n        assign_global sqsum_update\n         (\\<lambda>\\<sigma>. tm \\<sigma> + sqsum \\<sigma>)) ;-\n       _while_SE (\\<lambda>\\<sigma>. sqsum \\<sigma> \\<le> a)\n        (assign_global i_update (\\<lambda>\\<sigma>. i \\<sigma> + 1) ;-\n         assign_global tm_update (\\<lambda>\\<sigma>. tm \\<sigma> + 2) ;-\n         assign_global sqsum_update\n          (\\<lambda>\\<sigma>. tm \\<sigma> + sqsum \\<sigma>)))\n      (unit\\<^sub>S\\<^sub>E ()) ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 2. \\<lbrakk>\\<not> 1 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr> \\<Turnstile>\n     unit\\<^sub>S\\<^sub>E () ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)", "apply(tactic \"ematch_tac @{context} [@{thm \\\"if_SE_execE''\\\"}] 1\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>1 \\<le> a;\n     sqsum\n      (\\<sigma>\\<^sub>0\n       \\<lparr>tm := 1, sqsum := 1, i := 0,\n          i := i (\\<sigma>\\<^sub>0\n                  \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr>) +\n               1,\n          tm :=\n            tm (\\<sigma>\\<^sub>0\n                \\<lparr>tm := 1, sqsum := 1, i := 0,\n                   i := i (\\<sigma>\\<^sub>0\n                           \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr>) +\n                        1\\<rparr>) +\n            2,\n          sqsum :=\n            tm (\\<sigma>\\<^sub>0\n                \\<lparr>tm := 1, sqsum := 1, i := 0,\n                   i := i (\\<sigma>\\<^sub>0\n                           \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr>) +\n                        1,\n                   tm :=\n                     tm (\\<sigma>\\<^sub>0\n                         \\<lparr>tm := 1, sqsum := 1, i := 0,\n                            i := i (\\<sigma>\\<^sub>0\n                                    \\<lparr>tm := 1, sqsum := 1,\n i := 0\\<rparr>) +\n                                 1\\<rparr>) +\n                     2\\<rparr>) +\n            sqsum\n             (\\<sigma>\\<^sub>0\n              \\<lparr>tm := 1, sqsum := 1, i := 0,\n                 i := i (\\<sigma>\\<^sub>0\n                         \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr>) +\n                      1,\n                 tm :=\n                   tm (\\<sigma>\\<^sub>0\n                       \\<lparr>tm := 1, sqsum := 1, i := 0,\n                          i := i (\\<sigma>\\<^sub>0\n                                  \\<lparr>tm := 1, sqsum := 1,\n                                     i := 0\\<rparr>) +\n                               1\\<rparr>) +\n                   2\\<rparr>)\\<rparr>)\n     \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0,\n        i := i (\\<sigma>\\<^sub>0\n                \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr>) +\n             1,\n        tm :=\n          tm (\\<sigma>\\<^sub>0\n              \\<lparr>tm := 1, sqsum := 1, i := 0,\n                 i := i (\\<sigma>\\<^sub>0\n                         \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr>) +\n                      1\\<rparr>) +\n          2,\n        sqsum :=\n          tm (\\<sigma>\\<^sub>0\n              \\<lparr>tm := 1, sqsum := 1, i := 0,\n                 i := i (\\<sigma>\\<^sub>0\n                         \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr>) +\n                      1,\n                 tm :=\n                   tm (\\<sigma>\\<^sub>0\n                       \\<lparr>tm := 1, sqsum := 1, i := 0,\n                          i := i (\\<sigma>\\<^sub>0\n                                  \\<lparr>tm := 1, sqsum := 1,\n                                     i := 0\\<rparr>) +\n                               1\\<rparr>) +\n                   2\\<rparr>) +\n          sqsum\n           (\\<sigma>\\<^sub>0\n            \\<lparr>tm := 1, sqsum := 1, i := 0,\n               i := i (\\<sigma>\\<^sub>0\n                       \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr>) +\n                    1,\n               tm :=\n                 tm (\\<sigma>\\<^sub>0\n                     \\<lparr>tm := 1, sqsum := 1, i := 0,\n                        i := i (\\<sigma>\\<^sub>0\n                                \\<lparr>tm := 1, sqsum := 1,\n                                   i := 0\\<rparr>) +\n                             1\\<rparr>) +\n                 2\\<rparr>)\\<rparr> \\<Turnstile>\n     ((assign_global i_update (\\<lambda>\\<sigma>. i \\<sigma> + 1) ;-\n       assign_global tm_update (\\<lambda>\\<sigma>. tm \\<sigma> + 2) ;-\n       assign_global sqsum_update\n        (\\<lambda>\\<sigma>. tm \\<sigma> + sqsum \\<sigma>)) ;-\n      _while_SE (\\<lambda>\\<sigma>. sqsum \\<sigma> \\<le> a)\n       (assign_global i_update (\\<lambda>\\<sigma>. i \\<sigma> + 1) ;-\n        assign_global tm_update (\\<lambda>\\<sigma>. tm \\<sigma> + 2) ;-\n        assign_global sqsum_update\n         (\\<lambda>\\<sigma>. tm \\<sigma> + sqsum \\<sigma>))) ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 2. \\<lbrakk>1 \\<le> a;\n     \\<not> sqsum\n             (\\<sigma>\\<^sub>0\n              \\<lparr>tm := 1, sqsum := 1, i := 0,\n                 i := i (\\<sigma>\\<^sub>0\n                         \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr>) +\n                      1,\n                 tm :=\n                   tm (\\<sigma>\\<^sub>0\n                       \\<lparr>tm := 1, sqsum := 1, i := 0,\n                          i := i (\\<sigma>\\<^sub>0\n                                  \\<lparr>tm := 1, sqsum := 1,\n                                     i := 0\\<rparr>) +\n                               1\\<rparr>) +\n                   2,\n                 sqsum :=\n                   tm (\\<sigma>\\<^sub>0\n                       \\<lparr>tm := 1, sqsum := 1, i := 0,\n                          i := i (\\<sigma>\\<^sub>0\n                                  \\<lparr>tm := 1, sqsum := 1,\n                                     i := 0\\<rparr>) +\n                               1,\n                          tm :=\n                            tm (\\<sigma>\\<^sub>0\n                                \\<lparr>tm := 1, sqsum := 1, i := 0,\n                                   i := i\n   (\\<sigma>\\<^sub>0\\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr>) +\n  1\\<rparr>) +\n                            2\\<rparr>) +\n                   sqsum\n                    (\\<sigma>\\<^sub>0\n                     \\<lparr>tm := 1, sqsum := 1, i := 0,\n                        i := i (\\<sigma>\\<^sub>0\n                                \\<lparr>tm := 1, sqsum := 1,\n                                   i := 0\\<rparr>) +\n                             1,\n                        tm :=\n                          tm (\\<sigma>\\<^sub>0\n                              \\<lparr>tm := 1, sqsum := 1, i := 0,\n                                 i := i\n (\\<sigma>\\<^sub>0\\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr>) +\n1\\<rparr>) +\n                          2\\<rparr>)\\<rparr>)\n            \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0,\n        i := i (\\<sigma>\\<^sub>0\n                \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr>) +\n             1,\n        tm :=\n          tm (\\<sigma>\\<^sub>0\n              \\<lparr>tm := 1, sqsum := 1, i := 0,\n                 i := i (\\<sigma>\\<^sub>0\n                         \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr>) +\n                      1\\<rparr>) +\n          2,\n        sqsum :=\n          tm (\\<sigma>\\<^sub>0\n              \\<lparr>tm := 1, sqsum := 1, i := 0,\n                 i := i (\\<sigma>\\<^sub>0\n                         \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr>) +\n                      1,\n                 tm :=\n                   tm (\\<sigma>\\<^sub>0\n                       \\<lparr>tm := 1, sqsum := 1, i := 0,\n                          i := i (\\<sigma>\\<^sub>0\n                                  \\<lparr>tm := 1, sqsum := 1,\n                                     i := 0\\<rparr>) +\n                               1\\<rparr>) +\n                   2\\<rparr>) +\n          sqsum\n           (\\<sigma>\\<^sub>0\n            \\<lparr>tm := 1, sqsum := 1, i := 0,\n               i := i (\\<sigma>\\<^sub>0\n                       \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr>) +\n                    1,\n               tm :=\n                 tm (\\<sigma>\\<^sub>0\n                     \\<lparr>tm := 1, sqsum := 1, i := 0,\n                        i := i (\\<sigma>\\<^sub>0\n                                \\<lparr>tm := 1, sqsum := 1,\n                                   i := 0\\<rparr>) +\n                             1\\<rparr>) +\n                 2\\<rparr>)\\<rparr> \\<Turnstile>\n     unit\\<^sub>S\\<^sub>E () ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 3. \\<lbrakk>\\<not> 1 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr> \\<Turnstile>\n     unit\\<^sub>S\\<^sub>E () ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)", "apply(simp_all only: memory_theory MonadSE.bind_assoc')"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>1 \\<le> a; 1 + 2 + 1 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n        sqsum := 1 + 2 + 1\\<rparr> \\<Turnstile>\n     assign_global i_update (\\<lambda>\\<sigma>. i \\<sigma> + 1) ;-\n     assign_global tm_update (\\<lambda>\\<sigma>. tm \\<sigma> + 2) ;-\n     assign_global sqsum_update\n      (\\<lambda>\\<sigma>. tm \\<sigma> + sqsum \\<sigma>) ;-\n     _while_SE (\\<lambda>\\<sigma>. sqsum \\<sigma> \\<le> a)\n      (assign_global i_update (\\<lambda>\\<sigma>. i \\<sigma> + 1) ;-\n       assign_global tm_update (\\<lambda>\\<sigma>. tm \\<sigma> + 2) ;-\n       assign_global sqsum_update\n        (\\<lambda>\\<sigma>. tm \\<sigma> + sqsum \\<sigma>)) ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 2. \\<lbrakk>1 \\<le> a; \\<not> 1 + 2 + 1 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n        sqsum := 1 + 2 + 1\\<rparr> \\<Turnstile>\n     unit\\<^sub>S\\<^sub>E () ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 3. \\<lbrakk>\\<not> 1 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr> \\<Turnstile>\n     unit\\<^sub>S\\<^sub>E () ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)", "apply(tactic \"dmatch_tac @{context} [@{thm \\\"non_exec_assign_globalD'_i\\\"}] 1\",simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>1 \\<le> a; 1 + 2 + 1 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n        sqsum := 1 + 2 + 1,\n        i := i (\\<sigma>\\<^sub>0\n                \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                   tm := 1 + 2, sqsum := 1 + 2 + 1\\<rparr>) +\n             1\\<rparr> \\<Turnstile>\n     assign_global tm_update (\\<lambda>\\<sigma>. tm \\<sigma> + 2) ;-\n     assign_global sqsum_update\n      (\\<lambda>\\<sigma>. tm \\<sigma> + sqsum \\<sigma>) ;-\n     _while_SE (\\<lambda>\\<sigma>. sqsum \\<sigma> \\<le> a)\n      (assign_global i_update (\\<lambda>\\<sigma>. i \\<sigma> + 1) ;-\n       assign_global tm_update (\\<lambda>\\<sigma>. tm \\<sigma> + 2) ;-\n       assign_global sqsum_update\n        (\\<lambda>\\<sigma>. tm \\<sigma> + sqsum \\<sigma>)) ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 2. \\<lbrakk>1 \\<le> a; \\<not> 1 + 2 + 1 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n        sqsum := 1 + 2 + 1\\<rparr> \\<Turnstile>\n     unit\\<^sub>S\\<^sub>E () ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 3. \\<lbrakk>\\<not> 1 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr> \\<Turnstile>\n     unit\\<^sub>S\\<^sub>E () ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)", "apply(tactic \"dmatch_tac @{context} [@{thm \\\"non_exec_assign_globalD'_tm\\\"}] 1\",simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>1 \\<le> a; 1 + 2 + 1 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n        sqsum := 1 + 2 + 1,\n        i := i (\\<sigma>\\<^sub>0\n                \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                   tm := 1 + 2, sqsum := 1 + 2 + 1\\<rparr>) +\n             1,\n        tm :=\n          tm (\\<sigma>\\<^sub>0\n              \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n                 sqsum := 1 + 2 + 1,\n                 i := i (\\<sigma>\\<^sub>0\n                         \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                            tm := 1 + 2, sqsum := 1 + 2 + 1\\<rparr>) +\n                      1\\<rparr>) +\n          2\\<rparr> \\<Turnstile>\n     assign_global sqsum_update\n      (\\<lambda>\\<sigma>. tm \\<sigma> + sqsum \\<sigma>) ;-\n     _while_SE (\\<lambda>\\<sigma>. sqsum \\<sigma> \\<le> a)\n      (assign_global i_update (\\<lambda>\\<sigma>. i \\<sigma> + 1) ;-\n       assign_global tm_update (\\<lambda>\\<sigma>. tm \\<sigma> + 2) ;-\n       assign_global sqsum_update\n        (\\<lambda>\\<sigma>. tm \\<sigma> + sqsum \\<sigma>)) ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 2. \\<lbrakk>1 \\<le> a; \\<not> 1 + 2 + 1 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n        sqsum := 1 + 2 + 1\\<rparr> \\<Turnstile>\n     unit\\<^sub>S\\<^sub>E () ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 3. \\<lbrakk>\\<not> 1 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr> \\<Turnstile>\n     unit\\<^sub>S\\<^sub>E () ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)", "apply(tactic \"dmatch_tac @{context} [@{thm \\\"non_exec_assign_globalD'_sqsum\\\"}] 1\",simp)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>1 \\<le> a; 1 + 2 + 1 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n        sqsum := 1 + 2 + 1,\n        i := i (\\<sigma>\\<^sub>0\n                \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                   tm := 1 + 2, sqsum := 1 + 2 + 1\\<rparr>) +\n             1,\n        tm :=\n          tm (\\<sigma>\\<^sub>0\n              \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n                 sqsum := 1 + 2 + 1,\n                 i := i (\\<sigma>\\<^sub>0\n                         \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                            tm := 1 + 2, sqsum := 1 + 2 + 1\\<rparr>) +\n                      1\\<rparr>) +\n          2,\n        sqsum :=\n          tm (\\<sigma>\\<^sub>0\n              \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n                 sqsum := 1 + 2 + 1,\n                 i := i (\\<sigma>\\<^sub>0\n                         \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                            tm := 1 + 2, sqsum := 1 + 2 + 1\\<rparr>) +\n                      1,\n                 tm :=\n                   tm (\\<sigma>\\<^sub>0\n                       \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                          tm := 1 + 2, sqsum := 1 + 2 + 1,\n                          i := i (\\<sigma>\\<^sub>0\n                                  \\<lparr>tm := 1, sqsum := 1, i := 0,\n                                     i := 0 + 1, tm := 1 + 2,\n                                     sqsum := 1 + 2 + 1\\<rparr>) +\n                               1\\<rparr>) +\n                   2\\<rparr>) +\n          sqsum\n           (\\<sigma>\\<^sub>0\n            \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n               sqsum := 1 + 2 + 1,\n               i := i (\\<sigma>\\<^sub>0\n                       \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                          tm := 1 + 2, sqsum := 1 + 2 + 1\\<rparr>) +\n                    1,\n               tm :=\n                 tm (\\<sigma>\\<^sub>0\n                     \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                        tm := 1 + 2, sqsum := 1 + 2 + 1,\n                        i := i (\\<sigma>\\<^sub>0\n                                \\<lparr>tm := 1, sqsum := 1, i := 0,\n                                   i := 0 + 1, tm := 1 + 2,\n                                   sqsum := 1 + 2 + 1\\<rparr>) +\n                             1\\<rparr>) +\n                 2\\<rparr>)\\<rparr> \\<Turnstile>\n     _while_SE (\\<lambda>\\<sigma>. sqsum \\<sigma> \\<le> a)\n      (assign_global i_update (\\<lambda>\\<sigma>. i \\<sigma> + 1) ;-\n       assign_global tm_update (\\<lambda>\\<sigma>. tm \\<sigma> + 2) ;-\n       assign_global sqsum_update\n        (\\<lambda>\\<sigma>. tm \\<sigma> + sqsum \\<sigma>)) ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 2. \\<lbrakk>1 \\<le> a; \\<not> 1 + 2 + 1 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n        sqsum := 1 + 2 + 1\\<rparr> \\<Turnstile>\n     unit\\<^sub>S\\<^sub>E () ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 3. \\<lbrakk>\\<not> 1 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr> \\<Turnstile>\n     unit\\<^sub>S\\<^sub>E () ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)", "apply(tactic \"dmatch_tac @{context} [@{thm \\\"exec_whileD\\\"}] 1\")"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>1 \\<le> a; 1 + 2 + 1 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n        sqsum := 1 + 2 + 1,\n        i := i (\\<sigma>\\<^sub>0\n                \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                   tm := 1 + 2, sqsum := 1 + 2 + 1\\<rparr>) +\n             1,\n        tm :=\n          tm (\\<sigma>\\<^sub>0\n              \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n                 sqsum := 1 + 2 + 1,\n                 i := i (\\<sigma>\\<^sub>0\n                         \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                            tm := 1 + 2, sqsum := 1 + 2 + 1\\<rparr>) +\n                      1\\<rparr>) +\n          2,\n        sqsum :=\n          tm (\\<sigma>\\<^sub>0\n              \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n                 sqsum := 1 + 2 + 1,\n                 i := i (\\<sigma>\\<^sub>0\n                         \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                            tm := 1 + 2, sqsum := 1 + 2 + 1\\<rparr>) +\n                      1,\n                 tm :=\n                   tm (\\<sigma>\\<^sub>0\n                       \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                          tm := 1 + 2, sqsum := 1 + 2 + 1,\n                          i := i (\\<sigma>\\<^sub>0\n                                  \\<lparr>tm := 1, sqsum := 1, i := 0,\n                                     i := 0 + 1, tm := 1 + 2,\n                                     sqsum := 1 + 2 + 1\\<rparr>) +\n                               1\\<rparr>) +\n                   2\\<rparr>) +\n          sqsum\n           (\\<sigma>\\<^sub>0\n            \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n               sqsum := 1 + 2 + 1,\n               i := i (\\<sigma>\\<^sub>0\n                       \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                          tm := 1 + 2, sqsum := 1 + 2 + 1\\<rparr>) +\n                    1,\n               tm :=\n                 tm (\\<sigma>\\<^sub>0\n                     \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                        tm := 1 + 2, sqsum := 1 + 2 + 1,\n                        i := i (\\<sigma>\\<^sub>0\n                                \\<lparr>tm := 1, sqsum := 1, i := 0,\n                                   i := 0 + 1, tm := 1 + 2,\n                                   sqsum := 1 + 2 + 1\\<rparr>) +\n                             1\\<rparr>) +\n                 2\\<rparr>)\\<rparr> \\<Turnstile>\n     _if_SE (\\<lambda>\\<sigma>. sqsum \\<sigma> \\<le> a)\n      ((assign_global i_update (\\<lambda>\\<sigma>. i \\<sigma> + 1) ;-\n        assign_global tm_update (\\<lambda>\\<sigma>. tm \\<sigma> + 2) ;-\n        assign_global sqsum_update\n         (\\<lambda>\\<sigma>. tm \\<sigma> + sqsum \\<sigma>)) ;-\n       _while_SE (\\<lambda>\\<sigma>. sqsum \\<sigma> \\<le> a)\n        (assign_global i_update (\\<lambda>\\<sigma>. i \\<sigma> + 1) ;-\n         assign_global tm_update (\\<lambda>\\<sigma>. tm \\<sigma> + 2) ;-\n         assign_global sqsum_update\n          (\\<lambda>\\<sigma>. tm \\<sigma> + sqsum \\<sigma>)))\n      (unit\\<^sub>S\\<^sub>E ()) ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 2. \\<lbrakk>1 \\<le> a; \\<not> 1 + 2 + 1 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n        sqsum := 1 + 2 + 1\\<rparr> \\<Turnstile>\n     unit\\<^sub>S\\<^sub>E () ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 3. \\<lbrakk>\\<not> 1 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr> \\<Turnstile>\n     unit\\<^sub>S\\<^sub>E () ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)", "apply(tactic \"ematch_tac @{context} [@{thm \\\"if_SE_execE''\\\"}] 1\")"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>1 \\<le> a; 1 + 2 + 1 \\<le> a;\n     sqsum\n      (\\<sigma>\\<^sub>0\n       \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n          sqsum := 1 + 2 + 1,\n          i := i (\\<sigma>\\<^sub>0\n                  \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                     tm := 1 + 2, sqsum := 1 + 2 + 1\\<rparr>) +\n               1,\n          tm :=\n            tm (\\<sigma>\\<^sub>0\n                \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                   tm := 1 + 2, sqsum := 1 + 2 + 1,\n                   i := i (\\<sigma>\\<^sub>0\n                           \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                              tm := 1 + 2, sqsum := 1 + 2 + 1\\<rparr>) +\n                        1\\<rparr>) +\n            2,\n          sqsum :=\n            tm (\\<sigma>\\<^sub>0\n                \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                   tm := 1 + 2, sqsum := 1 + 2 + 1,\n                   i := i (\\<sigma>\\<^sub>0\n                           \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                              tm := 1 + 2, sqsum := 1 + 2 + 1\\<rparr>) +\n                        1,\n                   tm :=\n                     tm (\\<sigma>\\<^sub>0\n                         \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                            tm := 1 + 2, sqsum := 1 + 2 + 1,\n                            i := i (\\<sigma>\\<^sub>0\n                                    \\<lparr>tm := 1, sqsum := 1, i := 0,\n i := 0 + 1, tm := 1 + 2, sqsum := 1 + 2 + 1\\<rparr>) +\n                                 1\\<rparr>) +\n                     2\\<rparr>) +\n            sqsum\n             (\\<sigma>\\<^sub>0\n              \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n                 sqsum := 1 + 2 + 1,\n                 i := i (\\<sigma>\\<^sub>0\n                         \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                            tm := 1 + 2, sqsum := 1 + 2 + 1\\<rparr>) +\n                      1,\n                 tm :=\n                   tm (\\<sigma>\\<^sub>0\n                       \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                          tm := 1 + 2, sqsum := 1 + 2 + 1,\n                          i := i (\\<sigma>\\<^sub>0\n                                  \\<lparr>tm := 1, sqsum := 1, i := 0,\n                                     i := 0 + 1, tm := 1 + 2,\n                                     sqsum := 1 + 2 + 1\\<rparr>) +\n                               1\\<rparr>) +\n                   2\\<rparr>)\\<rparr>)\n     \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n        sqsum := 1 + 2 + 1,\n        i := i (\\<sigma>\\<^sub>0\n                \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                   tm := 1 + 2, sqsum := 1 + 2 + 1\\<rparr>) +\n             1,\n        tm :=\n          tm (\\<sigma>\\<^sub>0\n              \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n                 sqsum := 1 + 2 + 1,\n                 i := i (\\<sigma>\\<^sub>0\n                         \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                            tm := 1 + 2, sqsum := 1 + 2 + 1\\<rparr>) +\n                      1\\<rparr>) +\n          2,\n        sqsum :=\n          tm (\\<sigma>\\<^sub>0\n              \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n                 sqsum := 1 + 2 + 1,\n                 i := i (\\<sigma>\\<^sub>0\n                         \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                            tm := 1 + 2, sqsum := 1 + 2 + 1\\<rparr>) +\n                      1,\n                 tm :=\n                   tm (\\<sigma>\\<^sub>0\n                       \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                          tm := 1 + 2, sqsum := 1 + 2 + 1,\n                          i := i (\\<sigma>\\<^sub>0\n                                  \\<lparr>tm := 1, sqsum := 1, i := 0,\n                                     i := 0 + 1, tm := 1 + 2,\n                                     sqsum := 1 + 2 + 1\\<rparr>) +\n                               1\\<rparr>) +\n                   2\\<rparr>) +\n          sqsum\n           (\\<sigma>\\<^sub>0\n            \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n               sqsum := 1 + 2 + 1,\n               i := i (\\<sigma>\\<^sub>0\n                       \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                          tm := 1 + 2, sqsum := 1 + 2 + 1\\<rparr>) +\n                    1,\n               tm :=\n                 tm (\\<sigma>\\<^sub>0\n                     \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                        tm := 1 + 2, sqsum := 1 + 2 + 1,\n                        i := i (\\<sigma>\\<^sub>0\n                                \\<lparr>tm := 1, sqsum := 1, i := 0,\n                                   i := 0 + 1, tm := 1 + 2,\n                                   sqsum := 1 + 2 + 1\\<rparr>) +\n                             1\\<rparr>) +\n                 2\\<rparr>)\\<rparr> \\<Turnstile>\n     ((assign_global i_update (\\<lambda>\\<sigma>. i \\<sigma> + 1) ;-\n       assign_global tm_update (\\<lambda>\\<sigma>. tm \\<sigma> + 2) ;-\n       assign_global sqsum_update\n        (\\<lambda>\\<sigma>. tm \\<sigma> + sqsum \\<sigma>)) ;-\n      _while_SE (\\<lambda>\\<sigma>. sqsum \\<sigma> \\<le> a)\n       (assign_global i_update (\\<lambda>\\<sigma>. i \\<sigma> + 1) ;-\n        assign_global tm_update (\\<lambda>\\<sigma>. tm \\<sigma> + 2) ;-\n        assign_global sqsum_update\n         (\\<lambda>\\<sigma>. tm \\<sigma> + sqsum \\<sigma>))) ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 2. \\<lbrakk>1 \\<le> a; 1 + 2 + 1 \\<le> a;\n     \\<not> sqsum\n             (\\<sigma>\\<^sub>0\n              \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n                 sqsum := 1 + 2 + 1,\n                 i := i (\\<sigma>\\<^sub>0\n                         \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                            tm := 1 + 2, sqsum := 1 + 2 + 1\\<rparr>) +\n                      1,\n                 tm :=\n                   tm (\\<sigma>\\<^sub>0\n                       \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                          tm := 1 + 2, sqsum := 1 + 2 + 1,\n                          i := i (\\<sigma>\\<^sub>0\n                                  \\<lparr>tm := 1, sqsum := 1, i := 0,\n                                     i := 0 + 1, tm := 1 + 2,\n                                     sqsum := 1 + 2 + 1\\<rparr>) +\n                               1\\<rparr>) +\n                   2,\n                 sqsum :=\n                   tm (\\<sigma>\\<^sub>0\n                       \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                          tm := 1 + 2, sqsum := 1 + 2 + 1,\n                          i := i (\\<sigma>\\<^sub>0\n                                  \\<lparr>tm := 1, sqsum := 1, i := 0,\n                                     i := 0 + 1, tm := 1 + 2,\n                                     sqsum := 1 + 2 + 1\\<rparr>) +\n                               1,\n                          tm :=\n                            tm (\\<sigma>\\<^sub>0\n                                \\<lparr>tm := 1, sqsum := 1, i := 0,\n                                   i := 0 + 1, tm := 1 + 2,\n                                   sqsum := 1 + 2 + 1,\n                                   i := i\n   (\\<sigma>\\<^sub>0\n    \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n       sqsum := 1 + 2 + 1\\<rparr>) +\n  1\\<rparr>) +\n                            2\\<rparr>) +\n                   sqsum\n                    (\\<sigma>\\<^sub>0\n                     \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                        tm := 1 + 2, sqsum := 1 + 2 + 1,\n                        i := i (\\<sigma>\\<^sub>0\n                                \\<lparr>tm := 1, sqsum := 1, i := 0,\n                                   i := 0 + 1, tm := 1 + 2,\n                                   sqsum := 1 + 2 + 1\\<rparr>) +\n                             1,\n                        tm :=\n                          tm (\\<sigma>\\<^sub>0\n                              \\<lparr>tm := 1, sqsum := 1, i := 0,\n                                 i := 0 + 1, tm := 1 + 2,\n                                 sqsum := 1 + 2 + 1,\n                                 i := i\n (\\<sigma>\\<^sub>0\n  \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n     sqsum := 1 + 2 + 1\\<rparr>) +\n1\\<rparr>) +\n                          2\\<rparr>)\\<rparr>)\n            \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n        sqsum := 1 + 2 + 1,\n        i := i (\\<sigma>\\<^sub>0\n                \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                   tm := 1 + 2, sqsum := 1 + 2 + 1\\<rparr>) +\n             1,\n        tm :=\n          tm (\\<sigma>\\<^sub>0\n              \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n                 sqsum := 1 + 2 + 1,\n                 i := i (\\<sigma>\\<^sub>0\n                         \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                            tm := 1 + 2, sqsum := 1 + 2 + 1\\<rparr>) +\n                      1\\<rparr>) +\n          2,\n        sqsum :=\n          tm (\\<sigma>\\<^sub>0\n              \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n                 sqsum := 1 + 2 + 1,\n                 i := i (\\<sigma>\\<^sub>0\n                         \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                            tm := 1 + 2, sqsum := 1 + 2 + 1\\<rparr>) +\n                      1,\n                 tm :=\n                   tm (\\<sigma>\\<^sub>0\n                       \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                          tm := 1 + 2, sqsum := 1 + 2 + 1,\n                          i := i (\\<sigma>\\<^sub>0\n                                  \\<lparr>tm := 1, sqsum := 1, i := 0,\n                                     i := 0 + 1, tm := 1 + 2,\n                                     sqsum := 1 + 2 + 1\\<rparr>) +\n                               1\\<rparr>) +\n                   2\\<rparr>) +\n          sqsum\n           (\\<sigma>\\<^sub>0\n            \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n               sqsum := 1 + 2 + 1,\n               i := i (\\<sigma>\\<^sub>0\n                       \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                          tm := 1 + 2, sqsum := 1 + 2 + 1\\<rparr>) +\n                    1,\n               tm :=\n                 tm (\\<sigma>\\<^sub>0\n                     \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                        tm := 1 + 2, sqsum := 1 + 2 + 1,\n                        i := i (\\<sigma>\\<^sub>0\n                                \\<lparr>tm := 1, sqsum := 1, i := 0,\n                                   i := 0 + 1, tm := 1 + 2,\n                                   sqsum := 1 + 2 + 1\\<rparr>) +\n                             1\\<rparr>) +\n                 2\\<rparr>)\\<rparr> \\<Turnstile>\n     unit\\<^sub>S\\<^sub>E () ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 3. \\<lbrakk>1 \\<le> a; \\<not> 1 + 2 + 1 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n        sqsum := 1 + 2 + 1\\<rparr> \\<Turnstile>\n     unit\\<^sub>S\\<^sub>E () ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 4. \\<lbrakk>\\<not> 1 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr> \\<Turnstile>\n     unit\\<^sub>S\\<^sub>E () ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)", "apply(simp_all only: memory_theory MonadSE.bind_assoc')"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>1 \\<le> a; 1 + 2 + 1 \\<le> a; 1 + 2 + 2 + (1 + 2 + 1) \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n        sqsum := 1 + 2 + 1, i := 0 + 1 + 1, tm := 1 + 2 + 2,\n        sqsum := 1 + 2 + 2 + (1 + 2 + 1)\\<rparr> \\<Turnstile>\n     assign_global i_update (\\<lambda>\\<sigma>. i \\<sigma> + 1) ;-\n     assign_global tm_update (\\<lambda>\\<sigma>. tm \\<sigma> + 2) ;-\n     assign_global sqsum_update\n      (\\<lambda>\\<sigma>. tm \\<sigma> + sqsum \\<sigma>) ;-\n     _while_SE (\\<lambda>\\<sigma>. sqsum \\<sigma> \\<le> a)\n      (assign_global i_update (\\<lambda>\\<sigma>. i \\<sigma> + 1) ;-\n       assign_global tm_update (\\<lambda>\\<sigma>. tm \\<sigma> + 2) ;-\n       assign_global sqsum_update\n        (\\<lambda>\\<sigma>. tm \\<sigma> + sqsum \\<sigma>)) ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 2. \\<lbrakk>1 \\<le> a; 1 + 2 + 1 \\<le> a;\n     \\<not> 1 + 2 + 2 + (1 + 2 + 1) \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n        sqsum := 1 + 2 + 1, i := 0 + 1 + 1, tm := 1 + 2 + 2,\n        sqsum := 1 + 2 + 2 + (1 + 2 + 1)\\<rparr> \\<Turnstile>\n     unit\\<^sub>S\\<^sub>E () ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 3. \\<lbrakk>1 \\<le> a; \\<not> 1 + 2 + 1 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n        sqsum := 1 + 2 + 1\\<rparr> \\<Turnstile>\n     unit\\<^sub>S\\<^sub>E () ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 4. \\<lbrakk>\\<not> 1 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr> \\<Turnstile>\n     unit\\<^sub>S\\<^sub>E () ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)", "apply(tactic \"dmatch_tac @{context} [@{thm \\\"non_exec_assign_globalD'_i\\\"}] 1\",simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>1 \\<le> a; 1 + 2 + 1 \\<le> a; 1 + 2 + 2 + (1 + 2 + 1) \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n        sqsum := 1 + 2 + 1, i := 0 + 1 + 1, tm := 1 + 2 + 2,\n        sqsum := 1 + 2 + 2 + (1 + 2 + 1),\n        i := i (\\<sigma>\\<^sub>0\n                \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                   tm := 1 + 2, sqsum := 1 + 2 + 1, i := 0 + 1 + 1,\n                   tm := 1 + 2 + 2,\n                   sqsum := 1 + 2 + 2 + (1 + 2 + 1)\\<rparr>) +\n             1\\<rparr> \\<Turnstile>\n     assign_global tm_update (\\<lambda>\\<sigma>. tm \\<sigma> + 2) ;-\n     assign_global sqsum_update\n      (\\<lambda>\\<sigma>. tm \\<sigma> + sqsum \\<sigma>) ;-\n     _while_SE (\\<lambda>\\<sigma>. sqsum \\<sigma> \\<le> a)\n      (assign_global i_update (\\<lambda>\\<sigma>. i \\<sigma> + 1) ;-\n       assign_global tm_update (\\<lambda>\\<sigma>. tm \\<sigma> + 2) ;-\n       assign_global sqsum_update\n        (\\<lambda>\\<sigma>. tm \\<sigma> + sqsum \\<sigma>)) ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 2. \\<lbrakk>1 \\<le> a; 1 + 2 + 1 \\<le> a;\n     \\<not> 1 + 2 + 2 + (1 + 2 + 1) \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n        sqsum := 1 + 2 + 1, i := 0 + 1 + 1, tm := 1 + 2 + 2,\n        sqsum := 1 + 2 + 2 + (1 + 2 + 1)\\<rparr> \\<Turnstile>\n     unit\\<^sub>S\\<^sub>E () ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 3. \\<lbrakk>1 \\<le> a; \\<not> 1 + 2 + 1 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n        sqsum := 1 + 2 + 1\\<rparr> \\<Turnstile>\n     unit\\<^sub>S\\<^sub>E () ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 4. \\<lbrakk>\\<not> 1 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr> \\<Turnstile>\n     unit\\<^sub>S\\<^sub>E () ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)", "apply(tactic \"dmatch_tac @{context} [@{thm \\\"non_exec_assign_globalD'_tm\\\"}] 1\",simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>1 \\<le> a; 1 + 2 + 1 \\<le> a; 1 + 2 + 2 + (1 + 2 + 1) \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n        sqsum := 1 + 2 + 1, i := 0 + 1 + 1, tm := 1 + 2 + 2,\n        sqsum := 1 + 2 + 2 + (1 + 2 + 1),\n        i := i (\\<sigma>\\<^sub>0\n                \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                   tm := 1 + 2, sqsum := 1 + 2 + 1, i := 0 + 1 + 1,\n                   tm := 1 + 2 + 2,\n                   sqsum := 1 + 2 + 2 + (1 + 2 + 1)\\<rparr>) +\n             1,\n        tm :=\n          tm (\\<sigma>\\<^sub>0\n              \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n                 sqsum := 1 + 2 + 1, i := 0 + 1 + 1, tm := 1 + 2 + 2,\n                 sqsum := 1 + 2 + 2 + (1 + 2 + 1),\n                 i := i (\\<sigma>\\<^sub>0\n                         \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                            tm := 1 + 2, sqsum := 1 + 2 + 1, i := 0 + 1 + 1,\n                            tm := 1 + 2 + 2,\n                            sqsum := 1 + 2 + 2 + (1 + 2 + 1)\\<rparr>) +\n                      1\\<rparr>) +\n          2\\<rparr> \\<Turnstile>\n     assign_global sqsum_update\n      (\\<lambda>\\<sigma>. tm \\<sigma> + sqsum \\<sigma>) ;-\n     _while_SE (\\<lambda>\\<sigma>. sqsum \\<sigma> \\<le> a)\n      (assign_global i_update (\\<lambda>\\<sigma>. i \\<sigma> + 1) ;-\n       assign_global tm_update (\\<lambda>\\<sigma>. tm \\<sigma> + 2) ;-\n       assign_global sqsum_update\n        (\\<lambda>\\<sigma>. tm \\<sigma> + sqsum \\<sigma>)) ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 2. \\<lbrakk>1 \\<le> a; 1 + 2 + 1 \\<le> a;\n     \\<not> 1 + 2 + 2 + (1 + 2 + 1) \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n        sqsum := 1 + 2 + 1, i := 0 + 1 + 1, tm := 1 + 2 + 2,\n        sqsum := 1 + 2 + 2 + (1 + 2 + 1)\\<rparr> \\<Turnstile>\n     unit\\<^sub>S\\<^sub>E () ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 3. \\<lbrakk>1 \\<le> a; \\<not> 1 + 2 + 1 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n        sqsum := 1 + 2 + 1\\<rparr> \\<Turnstile>\n     unit\\<^sub>S\\<^sub>E () ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 4. \\<lbrakk>\\<not> 1 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr> \\<Turnstile>\n     unit\\<^sub>S\\<^sub>E () ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)", "apply(tactic \"dmatch_tac @{context} [@{thm \\\"non_exec_assign_globalD'_sqsum\\\"}] 1\",simp)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>1 \\<le> a; 1 + 2 + 1 \\<le> a; 1 + 2 + 2 + (1 + 2 + 1) \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n        sqsum := 1 + 2 + 1, i := 0 + 1 + 1, tm := 1 + 2 + 2,\n        sqsum := 1 + 2 + 2 + (1 + 2 + 1),\n        i := i (\\<sigma>\\<^sub>0\n                \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                   tm := 1 + 2, sqsum := 1 + 2 + 1, i := 0 + 1 + 1,\n                   tm := 1 + 2 + 2,\n                   sqsum := 1 + 2 + 2 + (1 + 2 + 1)\\<rparr>) +\n             1,\n        tm :=\n          tm (\\<sigma>\\<^sub>0\n              \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n                 sqsum := 1 + 2 + 1, i := 0 + 1 + 1, tm := 1 + 2 + 2,\n                 sqsum := 1 + 2 + 2 + (1 + 2 + 1),\n                 i := i (\\<sigma>\\<^sub>0\n                         \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                            tm := 1 + 2, sqsum := 1 + 2 + 1, i := 0 + 1 + 1,\n                            tm := 1 + 2 + 2,\n                            sqsum := 1 + 2 + 2 + (1 + 2 + 1)\\<rparr>) +\n                      1\\<rparr>) +\n          2,\n        sqsum :=\n          tm (\\<sigma>\\<^sub>0\n              \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n                 sqsum := 1 + 2 + 1, i := 0 + 1 + 1, tm := 1 + 2 + 2,\n                 sqsum := 1 + 2 + 2 + (1 + 2 + 1),\n                 i := i (\\<sigma>\\<^sub>0\n                         \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                            tm := 1 + 2, sqsum := 1 + 2 + 1, i := 0 + 1 + 1,\n                            tm := 1 + 2 + 2,\n                            sqsum := 1 + 2 + 2 + (1 + 2 + 1)\\<rparr>) +\n                      1,\n                 tm :=\n                   tm (\\<sigma>\\<^sub>0\n                       \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                          tm := 1 + 2, sqsum := 1 + 2 + 1, i := 0 + 1 + 1,\n                          tm := 1 + 2 + 2, sqsum := 1 + 2 + 2 + (1 + 2 + 1),\n                          i := i (\\<sigma>\\<^sub>0\n                                  \\<lparr>tm := 1, sqsum := 1, i := 0,\n                                     i := 0 + 1, tm := 1 + 2,\n                                     sqsum := 1 + 2 + 1, i := 0 + 1 + 1,\n                                     tm := 1 + 2 + 2,\n                                     sqsum :=\n 1 + 2 + 2 + (1 + 2 + 1)\\<rparr>) +\n                               1\\<rparr>) +\n                   2\\<rparr>) +\n          sqsum\n           (\\<sigma>\\<^sub>0\n            \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n               sqsum := 1 + 2 + 1, i := 0 + 1 + 1, tm := 1 + 2 + 2,\n               sqsum := 1 + 2 + 2 + (1 + 2 + 1),\n               i := i (\\<sigma>\\<^sub>0\n                       \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                          tm := 1 + 2, sqsum := 1 + 2 + 1, i := 0 + 1 + 1,\n                          tm := 1 + 2 + 2,\n                          sqsum := 1 + 2 + 2 + (1 + 2 + 1)\\<rparr>) +\n                    1,\n               tm :=\n                 tm (\\<sigma>\\<^sub>0\n                     \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1,\n                        tm := 1 + 2, sqsum := 1 + 2 + 1, i := 0 + 1 + 1,\n                        tm := 1 + 2 + 2, sqsum := 1 + 2 + 2 + (1 + 2 + 1),\n                        i := i (\\<sigma>\\<^sub>0\n                                \\<lparr>tm := 1, sqsum := 1, i := 0,\n                                   i := 0 + 1, tm := 1 + 2,\n                                   sqsum := 1 + 2 + 1, i := 0 + 1 + 1,\n                                   tm := 1 + 2 + 2,\n                                   sqsum :=\n                                     1 + 2 + 2 + (1 + 2 + 1)\\<rparr>) +\n                             1\\<rparr>) +\n                 2\\<rparr>)\\<rparr> \\<Turnstile>\n     _while_SE (\\<lambda>\\<sigma>. sqsum \\<sigma> \\<le> a)\n      (assign_global i_update (\\<lambda>\\<sigma>. i \\<sigma> + 1) ;-\n       assign_global tm_update (\\<lambda>\\<sigma>. tm \\<sigma> + 2) ;-\n       assign_global sqsum_update\n        (\\<lambda>\\<sigma>. tm \\<sigma> + sqsum \\<sigma>)) ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 2. \\<lbrakk>1 \\<le> a; 1 + 2 + 1 \\<le> a;\n     \\<not> 1 + 2 + 2 + (1 + 2 + 1) \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n        sqsum := 1 + 2 + 1, i := 0 + 1 + 1, tm := 1 + 2 + 2,\n        sqsum := 1 + 2 + 2 + (1 + 2 + 1)\\<rparr> \\<Turnstile>\n     unit\\<^sub>S\\<^sub>E () ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 3. \\<lbrakk>1 \\<le> a; \\<not> 1 + 2 + 1 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0, i := 0 + 1, tm := 1 + 2,\n        sqsum := 1 + 2 + 1\\<rparr> \\<Turnstile>\n     unit\\<^sub>S\\<^sub>E () ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 4. \\<lbrakk>\\<not> 1 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr> \\<Turnstile>\n     unit\\<^sub>S\\<^sub>E () ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)", "apply(simp_all)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>9 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>i := 3, tm := 7, sqsum := 16\\<rparr> \\<Turnstile>\n     _while_SE (\\<lambda>\\<sigma>. sqsum \\<sigma> \\<le> a)\n      (assign_global i_update (\\<lambda>\\<sigma>. i \\<sigma> + 1) ;-\n       assign_global tm_update (\\<lambda>\\<sigma>. tm \\<sigma> + 2) ;-\n       assign_global sqsum_update\n        (\\<lambda>\\<sigma>. tm \\<sigma> + sqsum \\<sigma>)) ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 2. \\<lbrakk>4 \\<le> a; \\<not> 9 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>i := 2, tm := 5, sqsum := 9\\<rparr> \\<Turnstile>\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 3. \\<lbrakk>1 \\<le> a; \\<not> 4 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>i := 1, tm := 3, sqsum := 4\\<rparr> \\<Turnstile>\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 4. \\<lbrakk>\\<not> 1 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr> \\<Turnstile>\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)", "text\\<open>Here are all abstract test-cases explicit. Each subgoal correstponds to\n       a path taken through the loop.\\<close>"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>9 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>i := 3, tm := 7, sqsum := 16\\<rparr> \\<Turnstile>\n     _while_SE (\\<lambda>\\<sigma>. sqsum \\<sigma> \\<le> a)\n      (assign_global i_update (\\<lambda>\\<sigma>. i \\<sigma> + 1) ;-\n       assign_global tm_update (\\<lambda>\\<sigma>. tm \\<sigma> + 2) ;-\n       assign_global sqsum_update\n        (\\<lambda>\\<sigma>. tm \\<sigma> + sqsum \\<sigma>)) ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 2. \\<lbrakk>4 \\<le> a; \\<not> 9 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>i := 2, tm := 5, sqsum := 9\\<rparr> \\<Turnstile>\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 3. \\<lbrakk>1 \\<le> a; \\<not> 4 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>i := 1, tm := 3, sqsum := 4\\<rparr> \\<Turnstile>\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 4. \\<lbrakk>\\<not> 1 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr> \\<Turnstile>\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)", "txt\\<open>push away the test-hyp: postcond is true for programs with more than\n    three loop traversals (criterion: all-paths(k). This reveals explicitly\n    the three test-cases for  @{term \"k<3\"}. \\<close>"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>9 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>i := 3, tm := 7, sqsum := 16\\<rparr> \\<Turnstile>\n     _while_SE (\\<lambda>\\<sigma>. sqsum \\<sigma> \\<le> a)\n      (assign_global i_update (\\<lambda>\\<sigma>. i \\<sigma> + 1) ;-\n       assign_global tm_update (\\<lambda>\\<sigma>. tm \\<sigma> + 2) ;-\n       assign_global sqsum_update\n        (\\<lambda>\\<sigma>. tm \\<sigma> + sqsum \\<sigma>)) ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 2. \\<lbrakk>4 \\<le> a; \\<not> 9 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>i := 2, tm := 5, sqsum := 9\\<rparr> \\<Turnstile>\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 3. \\<lbrakk>1 \\<le> a; \\<not> 4 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>i := 1, tm := 3, sqsum := 4\\<rparr> \\<Turnstile>\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 4. \\<lbrakk>\\<not> 1 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr> \\<Turnstile>\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)", "defer 1"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>4 \\<le> a; \\<not> 9 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>i := 2, tm := 5, sqsum := 9\\<rparr> \\<Turnstile>\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 2. \\<lbrakk>1 \\<le> a; \\<not> 4 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>i := 1, tm := 3, sqsum := 4\\<rparr> \\<Turnstile>\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 3. \\<lbrakk>\\<not> 1 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr> \\<Turnstile>\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 4. \\<lbrakk>9 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>i := 3, tm := 7, sqsum := 16\\<rparr> \\<Turnstile>\n     _while_SE (\\<lambda>\\<sigma>. sqsum \\<sigma> \\<le> a)\n      (assign_global i_update (\\<lambda>\\<sigma>. i \\<sigma> + 1) ;-\n       assign_global tm_update (\\<lambda>\\<sigma>. tm \\<sigma> + 2) ;-\n       assign_global sqsum_update\n        (\\<lambda>\\<sigma>. tm \\<sigma> + sqsum \\<sigma>)) ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)", "(*\ntxt\\<open>Instead of testing, we @{emph \\<open>prove\\<close>} that the test cases satisfy the\n    post-condition for all @{term \"k<3\"} loop traversals and @{emph \\<open>all\\<close>}\n    positive inputs @{term \"a \"}.\\<close>\n   apply(auto  simp: assert_simp)\n *)"], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<lbrakk>4 \\<le> a; \\<not> 9 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>i := 2, tm := 5, sqsum := 9\\<rparr> \\<Turnstile>\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 2. \\<lbrakk>1 \\<le> a; \\<not> 4 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>i := 1, tm := 3, sqsum := 4\\<rparr> \\<Turnstile>\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 3. \\<lbrakk>\\<not> 1 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>tm := 1, sqsum := 1, i := 0\\<rparr> \\<Turnstile>\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)\n 4. \\<lbrakk>9 \\<le> a;\n     \\<sigma>\\<^sub>0\n     \\<lparr>i := 3, tm := 7, sqsum := 16\\<rparr> \\<Turnstile>\n     _while_SE (\\<lambda>\\<sigma>. sqsum \\<sigma> \\<le> a)\n      (assign_global i_update (\\<lambda>\\<sigma>. i \\<sigma> + 1) ;-\n       assign_global tm_update (\\<lambda>\\<sigma>. tm \\<sigma> + 2) ;-\n       assign_global sqsum_update\n        (\\<lambda>\\<sigma>. tm \\<sigma> + sqsum \\<sigma>)) ;-\n     assert\\<^sub>S\\<^sub>E\n      (\\<lambda>\\<sigma>. \\<sigma> = \\<sigma>\\<^sub>R)\\<rbrakk>\n    \\<Longrightarrow> \\<sigma>\\<^sub>R \\<Turnstile>\n                      assert\\<^sub>S\\<^sub>E\n                       (\\<lambda>\\<sigma>.\n                           (i \\<sigma>)\\<^sup>2 \\<le> a \\<and>\n                           a < (i \\<sigma> + 1)\\<^sup>2)", "oops"], ["", "text\\<open>TODO: re-establish  automatic test-coverage tactics of @{cite \"DBLP:conf/tap/Keller18\"}.\\<close>"], ["", "end"]]}