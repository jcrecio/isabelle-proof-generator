{"file_name": "/home/qj213/afp-2021-10-22/thys/Clean/src/Clean_Symbex.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Clean", "problem_names": ["lemma non_exec_assign  : \nassumes \"\\<not> exec_stop \\<sigma>\"\nshows \"(\\<sigma> \\<Turnstile> ( _ \\<leftarrow> assign f; M)) = ((f \\<sigma>) \\<Turnstile>  M)\"", "lemma non_exec_assign'  : \nassumes \"\\<not> exec_stop \\<sigma>\"\nshows \"(\\<sigma> \\<Turnstile> (assign f;- M)) = ((f \\<sigma>) \\<Turnstile>  M)\"", "lemma exec_assign  : \nassumes \"exec_stop \\<sigma>\"\nshows \"(\\<sigma> \\<Turnstile> ( _ \\<leftarrow> assign f; M)) = (\\<sigma> \\<Turnstile> M)\"", "lemma exec_assign'  : \nassumes \"exec_stop \\<sigma>\"\nshows \"(\\<sigma> \\<Turnstile> (assign f;- M)) = (\\<sigma> \\<Turnstile> M)\"", "lemma non_exec_assign_global  : \nassumes \"\\<not> exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> ( _ \\<leftarrow> assign_global upd rhs; M)) = ((upd (\\<lambda>_. rhs \\<sigma>) \\<sigma>) \\<Turnstile>  M)\"", "lemma non_exec_assign_global'  : \nassumes \"\\<not> exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> (assign_global upd rhs;- M)) = ((upd (\\<lambda>_. rhs \\<sigma>) \\<sigma>) \\<Turnstile>  M)\"", "lemma exec_assign_global  : \nassumes \"exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> ( _ \\<leftarrow> assign_global upd rhs; M)) = ( \\<sigma> \\<Turnstile>  M)\"", "lemma exec_assign_global'  : \nassumes \"exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> (assign_global upd rhs;- M)) = ( \\<sigma> \\<Turnstile>  M)\"", "lemma non_exec_assign_local  : \nassumes \"\\<not> exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> ( _ \\<leftarrow> assign_local upd rhs; M)) = ((upd (map_hd (\\<lambda>_. rhs \\<sigma>)) \\<sigma>) \\<Turnstile>  M)\"", "lemma non_exec_assign_local'  : \nassumes \"\\<not> exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> (assign_local upd rhs;- M)) = ((upd (map_hd (\\<lambda>_. rhs \\<sigma>)) \\<sigma>) \\<Turnstile>  M)\"", "lemmas non_exec_assign_localD'= non_exec_assign[THEN iffD1]", "lemma exec_assign_local  : \nassumes \"exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> ( _ \\<leftarrow> assign_local upd rhs; M)) = ( \\<sigma> \\<Turnstile>  M)\"", "lemma exec_assign_local'  : \nassumes \"exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> ( assign_local upd rhs;- M)) = ( \\<sigma> \\<Turnstile>  M)\"", "lemmas exec_assignD = exec_assign[THEN iffD1]", "lemmas exec_assignD' = exec_assign'[THEN iffD1]", "lemmas exec_assign_globalD =  exec_assign_global[THEN iffD1]", "lemmas exec_assign_globalD' =  exec_assign_global'[THEN iffD1]", "lemmas exec_assign_localD = exec_assign_local[THEN iffD1]", "lemmas exec_assign_localD' = exec_assign_local'[THEN iffD1]", "lemma exec_call_0  : \nassumes \"exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> ( _ \\<leftarrow> call_0\\<^sub>C M; M')) = (\\<sigma> \\<Turnstile>  M')\"", "lemma exec_call_0'  : \nassumes \"exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> (call_0\\<^sub>C M;- M')) = (\\<sigma> \\<Turnstile>  M')\"", "lemma exec_call_1  : \nassumes \"exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> ( x \\<leftarrow> call_1\\<^sub>C M A\\<^sub>1; M' x)) = (\\<sigma> \\<Turnstile>  M' undefined)\"", "lemma exec_call_1'  : \nassumes \"exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> (call_1\\<^sub>C M A\\<^sub>1;- M')) = (\\<sigma> \\<Turnstile>  M')\"", "lemma exec_call  : \nassumes \"exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> ( x \\<leftarrow> call\\<^sub>C M A\\<^sub>1; M' x)) = (\\<sigma> \\<Turnstile>  M' undefined)\"", "lemma exec_call'  : \nassumes \"exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> (call\\<^sub>C M A\\<^sub>1;- M')) = (\\<sigma> \\<Turnstile>  M')\"", "lemma exec_call_2  : \nassumes \"exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> ( _ \\<leftarrow> call_2\\<^sub>C M A\\<^sub>1 A\\<^sub>2; M')) = (\\<sigma> \\<Turnstile>  M')\"", "lemma exec_call_2'  : \nassumes \"exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> (call_2\\<^sub>C M A\\<^sub>1 A\\<^sub>2;- M')) = (\\<sigma> \\<Turnstile> M')\"", "lemma non_exec_call_0  : \nassumes \"\\<not> exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> ( _ \\<leftarrow> call_0\\<^sub>C M; M')) = (\\<sigma> \\<Turnstile> M;- M')\"", "lemma non_exec_call_0'  : \nassumes \"\\<not> exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> call_0\\<^sub>C M;- M') = (\\<sigma> \\<Turnstile> M;- M')\"", "lemma non_exec_call_1  : \nassumes \"\\<not> exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> ( x \\<leftarrow> (call_1\\<^sub>C M A\\<^sub>1); M' x)) = (\\<sigma> \\<Turnstile> (x \\<leftarrow> M (A\\<^sub>1 \\<sigma>); M' x))\"", "lemma non_exec_call_1'  : \nassumes \"\\<not> exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> call_1\\<^sub>C M A\\<^sub>1;- M') = (\\<sigma> \\<Turnstile>  M (A\\<^sub>1 \\<sigma>);- M')\"", "lemma non_exec_call  : \nassumes \"\\<not> exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> ( x \\<leftarrow> (call\\<^sub>C M A\\<^sub>1); M' x)) = (\\<sigma> \\<Turnstile> (x \\<leftarrow> M (A\\<^sub>1 \\<sigma>); M' x))\"", "lemma non_exec_call'  : \nassumes \"\\<not> exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> call\\<^sub>C M A\\<^sub>1;- M') = (\\<sigma> \\<Turnstile>  M (A\\<^sub>1 \\<sigma>);- M')\"", "lemma non_exec_call_2  : \nassumes \"\\<not> exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> ( _ \\<leftarrow> (call_2\\<^sub>C M A\\<^sub>1 A\\<^sub>2); M')) = (\\<sigma> \\<Turnstile> M (A\\<^sub>1 \\<sigma>) (A\\<^sub>2 \\<sigma>);- M')\"", "lemma non_exec_call_2'  : \nassumes \"\\<not> exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> call_2\\<^sub>C M A\\<^sub>1 A\\<^sub>2;- M') = (\\<sigma> \\<Turnstile>  M (A\\<^sub>1 \\<sigma>) (A\\<^sub>2 \\<sigma>);- M')\"", "lemma exec_If\\<^sub>C_If\\<^sub>S\\<^sub>E  : \nassumes \"\\<not> exec_stop \\<sigma>\"\nshows  \" ((if\\<^sub>C P then B\\<^sub>1 else B\\<^sub>2 fi))\\<sigma> = ((if\\<^sub>S\\<^sub>E P then B\\<^sub>1 else B\\<^sub>2 fi)) \\<sigma> \"", "lemma valid_exec_If\\<^sub>C  : \nassumes \"\\<not> exec_stop \\<sigma>\"\nshows  \"(\\<sigma> \\<Turnstile> (if\\<^sub>C P then B\\<^sub>1 else B\\<^sub>2 fi);-M) = (\\<sigma> \\<Turnstile> (if\\<^sub>S\\<^sub>E P then B\\<^sub>1 else B\\<^sub>2 fi);-M)\"", "lemma exec_If\\<^sub>C'  : \nassumes \"exec_stop \\<sigma>\"\nshows  \"(\\<sigma> \\<Turnstile> (if\\<^sub>C P then B\\<^sub>1 else B\\<^sub>2 fi);-M) = (\\<sigma> \\<Turnstile> M)\"", "lemma exec_While\\<^sub>C'  : \nassumes \"exec_stop \\<sigma>\"\nshows  \"(\\<sigma> \\<Turnstile> (while\\<^sub>C P do B\\<^sub>1 od);-M) = (\\<sigma> \\<Turnstile> M)\"", "lemma if\\<^sub>C_cond_cong : \"f \\<sigma> = g \\<sigma> \\<Longrightarrow> \n                           (if\\<^sub>C f then c else d fi) \\<sigma> = \n                           (if\\<^sub>C g then c else d fi) \\<sigma>\"", "lemma break_assign_skip [simp]: \"break ;- assign f = break\"", "lemma break_if_skip [simp]: \"break ;- (if\\<^sub>C b then c else d fi) = break\"", "lemma break_while_skip [simp]: \"break ;- (while\\<^sub>C b do c od) = break\"", "lemma unset_break_idem [simp] : \n \"( unset_break_status ;- unset_break_status ;- M) = (unset_break_status ;- M)\"", "lemma return_cancel1_idem [simp] : \n \"( return\\<^sub>C X E ;- assign_global X E' ;- M) = ( return\\<^sub>C X E ;- M)\"", "lemma return_cancel2_idem [simp] : \n \"( return\\<^sub>C X E ;- assign_local X E' ;- M) = ( return\\<^sub>C X E ;- M)\"", "lemma while\\<^sub>C_skip [simp]: \"(while\\<^sub>C (\\<lambda> x. False) do c od) = skip\\<^sub>S\\<^sub>E\"", "lemma exec_while\\<^sub>C : \n\"(\\<sigma> \\<Turnstile> ((while\\<^sub>C b do c od) ;- M)) = \n (\\<sigma> \\<Turnstile> ((if\\<^sub>C b then c ;- ((while\\<^sub>C b do c od) ;- unset_break_status) else skip\\<^sub>S\\<^sub>E fi)  ;- M))\"", "lemma while_k_SE : \"while_C = while_k k\"", "lemmas exec_while_kD = exec_while_k[THEN iffD1]"], "translations": [["", "lemma non_exec_assign  : \nassumes \"\\<not> exec_stop \\<sigma>\"\nshows \"(\\<sigma> \\<Turnstile> ( _ \\<leftarrow> assign f; M)) = ((f \\<sigma>) \\<Turnstile>  M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> \\<Turnstile> _bind_SE _ (assign f) M) =\n    (f \\<sigma> \\<Turnstile> M)", "by (simp add: assign_def assms exec_bind_SE_success)"], ["", "lemma non_exec_assign'  : \nassumes \"\\<not> exec_stop \\<sigma>\"\nshows \"(\\<sigma> \\<Turnstile> (assign f;- M)) = ((f \\<sigma>) \\<Turnstile>  M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> \\<Turnstile> assign f ;- M) = (f \\<sigma> \\<Turnstile> M)", "by (simp add: assign_def assms exec_bind_SE_success bind_SE'_def)"], ["", "lemma exec_assign  : \nassumes \"exec_stop \\<sigma>\"\nshows \"(\\<sigma> \\<Turnstile> ( _ \\<leftarrow> assign f; M)) = (\\<sigma> \\<Turnstile> M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> \\<Turnstile> _bind_SE _ (assign f) M) =\n    (\\<sigma> \\<Turnstile> M)", "by (simp add: assign_def assms exec_bind_SE_success)"], ["", "lemma exec_assign'  : \nassumes \"exec_stop \\<sigma>\"\nshows \"(\\<sigma> \\<Turnstile> (assign f;- M)) = (\\<sigma> \\<Turnstile> M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> \\<Turnstile> assign f ;- M) = (\\<sigma> \\<Turnstile> M)", "by (simp add: assign_def assms exec_bind_SE_success bind_SE'_def)"], ["", "subsection\\<open>Assign Execution Rules.  \\<close>"], ["", "lemma non_exec_assign_global  : \nassumes \"\\<not> exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> ( _ \\<leftarrow> assign_global upd rhs; M)) = ((upd (\\<lambda>_. rhs \\<sigma>) \\<sigma>) \\<Turnstile>  M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> \\<Turnstile> _bind_SE _ (assign_global upd rhs) M) =\n    (upd (\\<lambda>_. rhs \\<sigma>) \\<sigma> \\<Turnstile> M)", "by(simp add: assign_global_def non_exec_assign assms)"], ["", "lemma non_exec_assign_global'  : \nassumes \"\\<not> exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> (assign_global upd rhs;- M)) = ((upd (\\<lambda>_. rhs \\<sigma>) \\<sigma>) \\<Turnstile>  M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> \\<Turnstile> assign_global upd rhs ;- M) =\n    (upd (\\<lambda>_. rhs \\<sigma>) \\<sigma> \\<Turnstile> M)", "by (metis (full_types) assms bind_SE'_def non_exec_assign_global)"], ["", "lemma exec_assign_global  : \nassumes \"exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> ( _ \\<leftarrow> assign_global upd rhs; M)) = ( \\<sigma> \\<Turnstile>  M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> \\<Turnstile> _bind_SE _ (assign_global upd rhs) M) =\n    (\\<sigma> \\<Turnstile> M)", "by (simp add: assign_global_def assign_def assms exec_bind_SE_success)"], ["", "lemma exec_assign_global'  : \nassumes \"exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> (assign_global upd rhs;- M)) = ( \\<sigma> \\<Turnstile>  M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> \\<Turnstile> assign_global upd rhs ;- M) =\n    (\\<sigma> \\<Turnstile> M)", "by (simp add: assign_global_def assign_def assms exec_bind_SE_success bind_SE'_def)"], ["", "lemma non_exec_assign_local  : \nassumes \"\\<not> exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> ( _ \\<leftarrow> assign_local upd rhs; M)) = ((upd (map_hd (\\<lambda>_. rhs \\<sigma>)) \\<sigma>) \\<Turnstile>  M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> \\<Turnstile> _bind_SE _ (assign_local upd rhs) M) =\n    (upd (map_hd (\\<lambda>_. rhs \\<sigma>)) \\<sigma> \\<Turnstile> M)", "by(simp add: assign_local_def non_exec_assign assms)"], ["", "lemma non_exec_assign_local'  : \nassumes \"\\<not> exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> (assign_local upd rhs;- M)) = ((upd (map_hd (\\<lambda>_. rhs \\<sigma>)) \\<sigma>) \\<Turnstile>  M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> \\<Turnstile> assign_local upd rhs ;- M) =\n    (upd (map_hd (\\<lambda>_. rhs \\<sigma>)) \\<sigma> \\<Turnstile> M)", "by (metis assms bind_SE'_def non_exec_assign_local)"], ["", "lemmas non_exec_assign_localD'= non_exec_assign[THEN iffD1]"], ["", "lemma exec_assign_local  : \nassumes \"exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> ( _ \\<leftarrow> assign_local upd rhs; M)) = ( \\<sigma> \\<Turnstile>  M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> \\<Turnstile> _bind_SE _ (assign_local upd rhs) M) =\n    (\\<sigma> \\<Turnstile> M)", "by (simp add: assign_local_def assign_def assms exec_bind_SE_success)"], ["", "lemma exec_assign_local'  : \nassumes \"exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> ( assign_local upd rhs;- M)) = ( \\<sigma> \\<Turnstile>  M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> \\<Turnstile> assign_local upd rhs ;- M) =\n    (\\<sigma> \\<Turnstile> M)", "unfolding assign_local_def assign_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> \\<Turnstile>\n     (\\<lambda>\\<sigma>.\n         if exec_stop \\<sigma> then Some ((), \\<sigma>)\n         else Some\n               ((),\n                (upd \\<circ> map_hd) (\\<lambda>_. rhs \\<sigma>)\n                 \\<sigma>)) ;-\n     M) =\n    (\\<sigma> \\<Turnstile> M)", "by (simp add: assms exec_bind_SE_success2)"], ["", "lemmas exec_assignD = exec_assign[THEN iffD1]"], ["", "thm exec_assignD"], ["", "lemmas exec_assignD' = exec_assign'[THEN iffD1]"], ["", "thm exec_assignD'"], ["", "lemmas exec_assign_globalD =  exec_assign_global[THEN iffD1]"], ["", "lemmas exec_assign_globalD' =  exec_assign_global'[THEN iffD1]"], ["", "lemmas exec_assign_localD = exec_assign_local[THEN iffD1]"], ["", "thm exec_assign_localD"], ["", "lemmas exec_assign_localD' = exec_assign_local'[THEN iffD1]"], ["", "subsection\\<open>Basic Call Symbolic Execution Rules.  \\<close>"], ["", "lemma exec_call_0  : \nassumes \"exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> ( _ \\<leftarrow> call_0\\<^sub>C M; M')) = (\\<sigma> \\<Turnstile>  M')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> \\<Turnstile> _bind_SE _ (call_0\\<^sub>C M) M') =\n    (\\<sigma> \\<Turnstile> M')", "by (simp add: assms call_0\\<^sub>C_def exec_bind_SE_success)"], ["", "lemma exec_call_0'  : \nassumes \"exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> (call_0\\<^sub>C M;- M')) = (\\<sigma> \\<Turnstile>  M')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> \\<Turnstile> call_0\\<^sub>C M ;- M') =\n    (\\<sigma> \\<Turnstile> M')", "by (simp add: assms bind_SE'_def exec_call_0)"], ["", "lemma exec_call_1  : \nassumes \"exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> ( x \\<leftarrow> call_1\\<^sub>C M A\\<^sub>1; M' x)) = (\\<sigma> \\<Turnstile>  M' undefined)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> \\<Turnstile>\n     bind\\<^sub>S\\<^sub>E (call_1\\<^sub>C M A\\<^sub>1) M') =\n    (\\<sigma> \\<Turnstile> M' undefined)", "by (simp add: assms call_1\\<^sub>C_def call\\<^sub>C_def exec_bind_SE_success)"], ["", "lemma exec_call_1'  : \nassumes \"exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> (call_1\\<^sub>C M A\\<^sub>1;- M')) = (\\<sigma> \\<Turnstile>  M')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> \\<Turnstile> call_1\\<^sub>C M A\\<^sub>1 ;- M') =\n    (\\<sigma> \\<Turnstile> M')", "by (simp add: assms bind_SE'_def exec_call_1)"], ["", "lemma exec_call  : \nassumes \"exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> ( x \\<leftarrow> call\\<^sub>C M A\\<^sub>1; M' x)) = (\\<sigma> \\<Turnstile>  M' undefined)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> \\<Turnstile>\n     bind\\<^sub>S\\<^sub>E (call\\<^sub>C M A\\<^sub>1) M') =\n    (\\<sigma> \\<Turnstile> M' undefined)", "by (simp add: assms call\\<^sub>C_def call_1\\<^sub>C_def exec_bind_SE_success)"], ["", "lemma exec_call'  : \nassumes \"exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> (call\\<^sub>C M A\\<^sub>1;- M')) = (\\<sigma> \\<Turnstile>  M')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> \\<Turnstile> call\\<^sub>C M A\\<^sub>1 ;- M') =\n    (\\<sigma> \\<Turnstile> M')", "by (metis assms call_1\\<^sub>C_def exec_call_1')"], ["", "lemma exec_call_2  : \nassumes \"exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> ( _ \\<leftarrow> call_2\\<^sub>C M A\\<^sub>1 A\\<^sub>2; M')) = (\\<sigma> \\<Turnstile>  M')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> \\<Turnstile>\n     _bind_SE _ (call_2\\<^sub>C M A\\<^sub>1 A\\<^sub>2) M') =\n    (\\<sigma> \\<Turnstile> M')", "by (simp add: assms call_2\\<^sub>C_def exec_bind_SE_success)"], ["", "lemma exec_call_2'  : \nassumes \"exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> (call_2\\<^sub>C M A\\<^sub>1 A\\<^sub>2;- M')) = (\\<sigma> \\<Turnstile> M')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> \\<Turnstile> call_2\\<^sub>C M A\\<^sub>1 A\\<^sub>2 ;- M') =\n    (\\<sigma> \\<Turnstile> M')", "by (simp add: assms bind_SE'_def exec_call_2)"], ["", "subsection\\<open>Basic Call Symbolic Execution Rules.  \\<close>"], ["", "lemma non_exec_call_0  : \nassumes \"\\<not> exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> ( _ \\<leftarrow> call_0\\<^sub>C M; M')) = (\\<sigma> \\<Turnstile> M;- M')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> \\<Turnstile> _bind_SE _ (call_0\\<^sub>C M) M') =\n    (\\<sigma> \\<Turnstile> M ;- M')", "by (simp add: assms bind_SE'_def bind_SE_def call_0\\<^sub>C_def valid_SE_def)"], ["", "lemma non_exec_call_0'  : \nassumes \"\\<not> exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> call_0\\<^sub>C M;- M') = (\\<sigma> \\<Turnstile> M;- M')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> \\<Turnstile> call_0\\<^sub>C M ;- M') =\n    (\\<sigma> \\<Turnstile> M ;- M')", "by (simp add: assms bind_SE'_def non_exec_call_0)"], ["", "lemma non_exec_call_1  : \nassumes \"\\<not> exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> ( x \\<leftarrow> (call_1\\<^sub>C M A\\<^sub>1); M' x)) = (\\<sigma> \\<Turnstile> (x \\<leftarrow> M (A\\<^sub>1 \\<sigma>); M' x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> \\<Turnstile>\n     bind\\<^sub>S\\<^sub>E (call_1\\<^sub>C M A\\<^sub>1) M') =\n    (\\<sigma> \\<Turnstile> bind\\<^sub>S\\<^sub>E (M (A\\<^sub>1 \\<sigma>)) M')", "by (simp add: assms bind_SE'_def call\\<^sub>C_def bind_SE_def call_1\\<^sub>C_def valid_SE_def)"], ["", "lemma non_exec_call_1'  : \nassumes \"\\<not> exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> call_1\\<^sub>C M A\\<^sub>1;- M') = (\\<sigma> \\<Turnstile>  M (A\\<^sub>1 \\<sigma>);- M')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> \\<Turnstile> call_1\\<^sub>C M A\\<^sub>1 ;- M') =\n    (\\<sigma> \\<Turnstile> M (A\\<^sub>1 \\<sigma>) ;- M')", "by (simp add: assms bind_SE'_def non_exec_call_1)"], ["", "lemma non_exec_call  : \nassumes \"\\<not> exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> ( x \\<leftarrow> (call\\<^sub>C M A\\<^sub>1); M' x)) = (\\<sigma> \\<Turnstile> (x \\<leftarrow> M (A\\<^sub>1 \\<sigma>); M' x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> \\<Turnstile>\n     bind\\<^sub>S\\<^sub>E (call\\<^sub>C M A\\<^sub>1) M') =\n    (\\<sigma> \\<Turnstile> bind\\<^sub>S\\<^sub>E (M (A\\<^sub>1 \\<sigma>)) M')", "by (simp add: assms call\\<^sub>C_def bind_SE'_def bind_SE_def call_1\\<^sub>C_def valid_SE_def)"], ["", "lemma non_exec_call'  : \nassumes \"\\<not> exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> call\\<^sub>C M A\\<^sub>1;- M') = (\\<sigma> \\<Turnstile>  M (A\\<^sub>1 \\<sigma>);- M')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> \\<Turnstile> call\\<^sub>C M A\\<^sub>1 ;- M') =\n    (\\<sigma> \\<Turnstile> M (A\\<^sub>1 \\<sigma>) ;- M')", "by (simp add: assms bind_SE'_def non_exec_call)"], ["", "lemma non_exec_call_2  : \nassumes \"\\<not> exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> ( _ \\<leftarrow> (call_2\\<^sub>C M A\\<^sub>1 A\\<^sub>2); M')) = (\\<sigma> \\<Turnstile> M (A\\<^sub>1 \\<sigma>) (A\\<^sub>2 \\<sigma>);- M')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> \\<Turnstile>\n     _bind_SE _ (call_2\\<^sub>C M A\\<^sub>1 A\\<^sub>2) M') =\n    (\\<sigma> \\<Turnstile>\n     M (A\\<^sub>1 \\<sigma>) (A\\<^sub>2 \\<sigma>) ;- M')", "by (simp add: assms bind_SE'_def bind_SE_def call_2\\<^sub>C_def valid_SE_def)"], ["", "lemma non_exec_call_2'  : \nassumes \"\\<not> exec_stop \\<sigma>\"\nshows   \"(\\<sigma> \\<Turnstile> call_2\\<^sub>C M A\\<^sub>1 A\\<^sub>2;- M') = (\\<sigma> \\<Turnstile>  M (A\\<^sub>1 \\<sigma>) (A\\<^sub>2 \\<sigma>);- M')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> \\<Turnstile> call_2\\<^sub>C M A\\<^sub>1 A\\<^sub>2 ;- M') =\n    (\\<sigma> \\<Turnstile>\n     M (A\\<^sub>1 \\<sigma>) (A\\<^sub>2 \\<sigma>) ;- M')", "by (simp add: assms bind_SE'_def non_exec_call_2)"], ["", "subsection\\<open>Conditional.  \\<close>"], ["", "lemma exec_If\\<^sub>C_If\\<^sub>S\\<^sub>E  : \nassumes \"\\<not> exec_stop \\<sigma>\"\nshows  \" ((if\\<^sub>C P then B\\<^sub>1 else B\\<^sub>2 fi))\\<sigma> = ((if\\<^sub>S\\<^sub>E P then B\\<^sub>1 else B\\<^sub>2 fi)) \\<sigma> \""], ["proof (prove)\ngoal (1 subgoal):\n 1. (_if_SECLEAN P B\\<^sub>1 B\\<^sub>2) \\<sigma> =\n    (_if_SE P B\\<^sub>1 B\\<^sub>2) \\<sigma>", "unfolding if_SE_def MonadSE.if_SE_def Symbex_MonadSE.valid_SE_def MonadSE.bind_SE'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (_if_SECLEAN P B\\<^sub>1 B\\<^sub>2) \\<sigma> =\n    (if P \\<sigma> then B\\<^sub>1 \\<sigma> else B\\<^sub>2 \\<sigma>)", "by (simp add: assms bind_SE_def if_C_def)"], ["", "lemma valid_exec_If\\<^sub>C  : \nassumes \"\\<not> exec_stop \\<sigma>\"\nshows  \"(\\<sigma> \\<Turnstile> (if\\<^sub>C P then B\\<^sub>1 else B\\<^sub>2 fi);-M) = (\\<sigma> \\<Turnstile> (if\\<^sub>S\\<^sub>E P then B\\<^sub>1 else B\\<^sub>2 fi);-M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> \\<Turnstile> _if_SECLEAN P B\\<^sub>1 B\\<^sub>2 ;- M) =\n    (\\<sigma> \\<Turnstile> _if_SE P B\\<^sub>1 B\\<^sub>2 ;- M)", "by (meson assms exec_If\\<^sub>C_If\\<^sub>S\\<^sub>E valid_bind'_cong)"], ["", "lemma exec_If\\<^sub>C'  : \nassumes \"exec_stop \\<sigma>\"\nshows  \"(\\<sigma> \\<Turnstile> (if\\<^sub>C P then B\\<^sub>1 else B\\<^sub>2 fi);-M) = (\\<sigma> \\<Turnstile> M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> \\<Turnstile> _if_SECLEAN P B\\<^sub>1 B\\<^sub>2 ;- M) =\n    (\\<sigma> \\<Turnstile> M)", "unfolding if_SE_def MonadSE.if_SE_def Symbex_MonadSE.valid_SE_def MonadSE.bind_SE'_def bind_SE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((case (_if_SECLEAN P B\\<^sub>1 B\\<^sub>2) \\<sigma> of\n      None \\<Rightarrow> None | Some (uu_, xa) \\<Rightarrow> M xa) \\<noteq>\n     None \\<and>\n     fst (the (case (_if_SECLEAN P B\\<^sub>1 B\\<^sub>2) \\<sigma> of\n               None \\<Rightarrow> None\n               | Some (uu_, xa) \\<Rightarrow> M xa))) =\n    (M \\<sigma> \\<noteq> None \\<and> fst (the (M \\<sigma>)))", "by (simp add: assms if_C_def)"], ["", "lemma exec_While\\<^sub>C'  : \nassumes \"exec_stop \\<sigma>\"\nshows  \"(\\<sigma> \\<Turnstile> (while\\<^sub>C P do B\\<^sub>1 od);-M) = (\\<sigma> \\<Turnstile> M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> \\<Turnstile> _while_C P B\\<^sub>1 ;- M) =\n    (\\<sigma> \\<Turnstile> M)", "unfolding while_C_def MonadSE.if_SE_def Symbex_MonadSE.valid_SE_def MonadSE.bind_SE'_def bind_SE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n           else case (_while_SE\n                       (\\<lambda>\\<sigma>.\n                           \\<not> exec_stop \\<sigma> \\<and> P \\<sigma>)\n                       B\\<^sub>1)\n                      \\<sigma> of\n                None \\<Rightarrow> None\n                | Some (uu_, xa) \\<Rightarrow> unset_break_status xa of\n      None \\<Rightarrow> None | Some (uu_, xa) \\<Rightarrow> M xa) \\<noteq>\n     None \\<and>\n     fst (the (case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n                    else case (_while_SE\n                                (\\<lambda>\\<sigma>.\n                                    \\<not> exec_stop \\<sigma> \\<and>\n                                    P \\<sigma>)\n                                B\\<^sub>1)\n                               \\<sigma> of\n                         None \\<Rightarrow> None\n                         | Some (uu_, xa) \\<Rightarrow>\n                             unset_break_status xa of\n               None \\<Rightarrow> None\n               | Some (uu_, xa) \\<Rightarrow> M xa))) =\n    (M \\<sigma> \\<noteq> None \\<and> fst (the (M \\<sigma>)))", "apply simp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> exec_stop \\<sigma> \\<longrightarrow>\n    ((\\<exists>a b.\n         (case case (_while_SE\n                      (\\<lambda>\\<sigma>.\n                          \\<not> exec_stop \\<sigma> \\<and> P \\<sigma>)\n                      B\\<^sub>1)\n                     \\<sigma> of\n               None \\<Rightarrow> None\n               | Some (uu_, xa) \\<Rightarrow> unset_break_status xa of\n          None \\<Rightarrow> None | Some (uu_, xa) \\<Rightarrow> M xa) =\n         Some (a, b)) \\<and>\n     fst (the (case case (_while_SE\n                           (\\<lambda>\\<sigma>.\n                               \\<not> exec_stop \\<sigma> \\<and> P \\<sigma>)\n                           B\\<^sub>1)\n                          \\<sigma> of\n                    None \\<Rightarrow> None\n                    | Some (uu_, xa) \\<Rightarrow> unset_break_status xa of\n               None \\<Rightarrow> None\n               | Some (uu_, xa) \\<Rightarrow> M xa))) =\n    ((\\<exists>a b. M \\<sigma> = Some (a, b)) \\<and> fst (the (M \\<sigma>)))", "using assms"], ["proof (prove)\nusing this:\n  exec_stop \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> exec_stop \\<sigma> \\<longrightarrow>\n    ((\\<exists>a b.\n         (case case (_while_SE\n                      (\\<lambda>\\<sigma>.\n                          \\<not> exec_stop \\<sigma> \\<and> P \\<sigma>)\n                      B\\<^sub>1)\n                     \\<sigma> of\n               None \\<Rightarrow> None\n               | Some (uu_, xa) \\<Rightarrow> unset_break_status xa of\n          None \\<Rightarrow> None | Some (uu_, xa) \\<Rightarrow> M xa) =\n         Some (a, b)) \\<and>\n     fst (the (case case (_while_SE\n                           (\\<lambda>\\<sigma>.\n                               \\<not> exec_stop \\<sigma> \\<and> P \\<sigma>)\n                           B\\<^sub>1)\n                          \\<sigma> of\n                    None \\<Rightarrow> None\n                    | Some (uu_, xa) \\<Rightarrow> unset_break_status xa of\n               None \\<Rightarrow> None\n               | Some (uu_, xa) \\<Rightarrow> M xa))) =\n    ((\\<exists>a b. M \\<sigma> = Some (a, b)) \\<and> fst (the (M \\<sigma>)))", "by blast"], ["", "lemma if\\<^sub>C_cond_cong : \"f \\<sigma> = g \\<sigma> \\<Longrightarrow> \n                           (if\\<^sub>C f then c else d fi) \\<sigma> = \n                           (if\\<^sub>C g then c else d fi) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<sigma> = g \\<sigma> \\<Longrightarrow>\n    (_if_SECLEAN f c d) \\<sigma> = (_if_SECLEAN g c d) \\<sigma>", "unfolding if_C_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<sigma> = g \\<sigma> \\<Longrightarrow>\n    (if exec_stop \\<sigma> then Some (undefined, \\<sigma>)\n     else if f \\<sigma> then c \\<sigma> else d \\<sigma>) =\n    (if exec_stop \\<sigma> then Some (undefined, \\<sigma>)\n     else if g \\<sigma> then c \\<sigma> else d \\<sigma>)", "by simp"], ["", "subsection\\<open>Break - Rules.  \\<close>"], ["", "lemma break_assign_skip [simp]: \"break ;- assign f = break\""], ["proof (prove)\ngoal (1 subgoal):\n 1. break ;- assign f = break", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (break ;- assign f) x = break x", "unfolding break_def assign_def exec_stop_def bind_SE'_def   bind_SE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (case Some ((), x\\<lparr>break_status := True\\<rparr>) of\n        None \\<Rightarrow> None\n        | Some (uu_, \\<sigma>) \\<Rightarrow>\n            if break_status \\<sigma> \\<or> return_status \\<sigma>\n            then Some ((), \\<sigma>) else Some ((), f \\<sigma>)) =\n       Some ((), x\\<lparr>break_status := True\\<rparr>)", "by auto"], ["", "lemma break_if_skip [simp]: \"break ;- (if\\<^sub>C b then c else d fi) = break\""], ["proof (prove)\ngoal (1 subgoal):\n 1. break ;- _if_SECLEAN b c d = break", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (break ;- _if_SECLEAN b c d) x = break x", "unfolding break_def assign_def exec_stop_def if_C_def bind_SE'_def   bind_SE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (case Some ((), x\\<lparr>break_status := True\\<rparr>) of\n        None \\<Rightarrow> None\n        | Some (uu_, \\<sigma>) \\<Rightarrow>\n            if break_status \\<sigma> \\<or> return_status \\<sigma>\n            then Some (undefined, \\<sigma>)\n            else if b \\<sigma> then c \\<sigma> else d \\<sigma>) =\n       Some ((), x\\<lparr>break_status := True\\<rparr>)", "by auto"], ["", "lemma break_while_skip [simp]: \"break ;- (while\\<^sub>C b do c od) = break\""], ["proof (prove)\ngoal (1 subgoal):\n 1. break ;- _while_C b c = break", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (break ;- _while_C b c) x = break x", "unfolding while_C_def skip\\<^sub>S\\<^sub>E_def unit_SE_def bind_SE'_def bind_SE_def break_def exec_stop_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (case Some ((), x\\<lparr>break_status := True\\<rparr>) of\n        None \\<Rightarrow> None\n        | Some (uu_, \\<sigma>) \\<Rightarrow>\n            if break_status \\<sigma> \\<or> return_status \\<sigma>\n            then Some ((), \\<sigma>)\n            else case (_while_SE\n                        (\\<lambda>\\<sigma>.\n                            \\<not> (break_status \\<sigma> \\<or>\n                                    return_status \\<sigma>) \\<and>\n                            b \\<sigma>)\n                        c)\n                       \\<sigma> of\n                 None \\<Rightarrow> None\n                 | Some (uu_, xa) \\<Rightarrow> unset_break_status xa) =\n       Some ((), x\\<lparr>break_status := True\\<rparr>)", "by simp"], ["", "lemma unset_break_idem [simp] : \n \"( unset_break_status ;- unset_break_status ;- M) = (unset_break_status ;- M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unset_break_status ;- unset_break_status ;- M = unset_break_status ;- M", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (unset_break_status ;- unset_break_status ;- M) x =\n       (unset_break_status ;- M) x", "unfolding unset_break_status_def bind_SE'_def bind_SE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (case Some ((), x\\<lparr>break_status := False\\<rparr>) of\n        None \\<Rightarrow> None\n        | Some (uu_, \\<sigma>) \\<Rightarrow>\n            case Some ((), \\<sigma>\\<lparr>break_status := False\\<rparr>) of\n            None \\<Rightarrow> None | Some (uu_, xa) \\<Rightarrow> M xa) =\n       (case Some ((), x\\<lparr>break_status := False\\<rparr>) of\n        None \\<Rightarrow> None | Some (uu_, xa) \\<Rightarrow> M xa)", "by auto"], ["", "lemma return_cancel1_idem [simp] : \n \"( return\\<^sub>C X E ;- assign_global X E' ;- M) = ( return\\<^sub>C X E ;- M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. return\\<^sub>C X E ;- assign_global X E' ;- M = return\\<^sub>C X E ;- M", "apply(rule ext, rename_tac \"\\<sigma>\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       (return\\<^sub>C X E ;- assign_global X E' ;- M) \\<sigma> =\n       (return\\<^sub>C X E ;- M) \\<sigma>", "unfolding unset_break_status_def bind_SE'_def bind_SE_def\n            assign_def return\\<^sub>C_def assign_global_def assign_local_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       (case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n             else case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n                       else Some\n                             ((),\n                              (X \\<circ> map_hd) (\\<lambda>_. E \\<sigma>)\n                               \\<sigma>) of\n                  None \\<Rightarrow> None\n                  | Some (uu_, xa) \\<Rightarrow> set_return_status xa of\n        None \\<Rightarrow> None\n        | Some (uu_, \\<sigma>) \\<Rightarrow>\n            case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n                 else Some ((), X (\\<lambda>_. E' \\<sigma>) \\<sigma>) of\n            None \\<Rightarrow> None | Some (uu_, xa) \\<Rightarrow> M xa) =\n       (case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n             else case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n                       else Some\n                             ((),\n                              (X \\<circ> map_hd) (\\<lambda>_. E \\<sigma>)\n                               \\<sigma>) of\n                  None \\<Rightarrow> None\n                  | Some (uu_, xa) \\<Rightarrow> set_return_status xa of\n        None \\<Rightarrow> None | Some (uu_, xa) \\<Rightarrow> M xa)", "apply(case_tac \"exec_stop \\<sigma>\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       exec_stop \\<sigma> \\<Longrightarrow>\n       (case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n             else case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n                       else Some\n                             ((),\n                              (X \\<circ> map_hd) (\\<lambda>_. E \\<sigma>)\n                               \\<sigma>) of\n                  None \\<Rightarrow> None\n                  | Some (uu_, xa) \\<Rightarrow> set_return_status xa of\n        None \\<Rightarrow> None\n        | Some (uu_, \\<sigma>) \\<Rightarrow>\n            case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n                 else Some ((), X (\\<lambda>_. E' \\<sigma>) \\<sigma>) of\n            None \\<Rightarrow> None | Some (uu_, xa) \\<Rightarrow> M xa) =\n       (case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n             else case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n                       else Some\n                             ((),\n                              (X \\<circ> map_hd) (\\<lambda>_. E \\<sigma>)\n                               \\<sigma>) of\n                  None \\<Rightarrow> None\n                  | Some (uu_, xa) \\<Rightarrow> set_return_status xa of\n        None \\<Rightarrow> None | Some (uu_, xa) \\<Rightarrow> M xa)\n 2. \\<And>\\<sigma>.\n       \\<not> exec_stop \\<sigma> \\<Longrightarrow>\n       (case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n             else case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n                       else Some\n                             ((),\n                              (X \\<circ> map_hd) (\\<lambda>_. E \\<sigma>)\n                               \\<sigma>) of\n                  None \\<Rightarrow> None\n                  | Some (uu_, xa) \\<Rightarrow> set_return_status xa of\n        None \\<Rightarrow> None\n        | Some (uu_, \\<sigma>) \\<Rightarrow>\n            case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n                 else Some ((), X (\\<lambda>_. E' \\<sigma>) \\<sigma>) of\n            None \\<Rightarrow> None | Some (uu_, xa) \\<Rightarrow> M xa) =\n       (case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n             else case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n                       else Some\n                             ((),\n                              (X \\<circ> map_hd) (\\<lambda>_. E \\<sigma>)\n                               \\<sigma>) of\n                  None \\<Rightarrow> None\n                  | Some (uu_, xa) \\<Rightarrow> set_return_status xa of\n        None \\<Rightarrow> None | Some (uu_, xa) \\<Rightarrow> M xa)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<not> exec_stop \\<sigma> \\<Longrightarrow>\n       (case set_return_status\n              (X (map_hd (\\<lambda>_. E \\<sigma>)) \\<sigma>) of\n        None \\<Rightarrow> None\n        | Some (uu_, \\<sigma>) \\<Rightarrow>\n            case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n                 else Some ((), X (\\<lambda>_. E' \\<sigma>) \\<sigma>) of\n            None \\<Rightarrow> None | Some (uu_, xa) \\<Rightarrow> M xa) =\n       (case set_return_status\n              (X (map_hd (\\<lambda>_. E \\<sigma>)) \\<sigma>) of\n        None \\<Rightarrow> None | Some (uu_, xa) \\<Rightarrow> M xa)", "by (simp add: exec_stop_def set_return_status_def)"], ["", "lemma return_cancel2_idem [simp] : \n \"( return\\<^sub>C X E ;- assign_local X E' ;- M) = ( return\\<^sub>C X E ;- M)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. return\\<^sub>C X E ;- assign_local X E' ;- M = return\\<^sub>C X E ;- M", "apply(rule ext, rename_tac \"\\<sigma>\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       (return\\<^sub>C X E ;- assign_local X E' ;- M) \\<sigma> =\n       (return\\<^sub>C X E ;- M) \\<sigma>", "unfolding unset_break_status_def bind_SE'_def bind_SE_def\n            assign_def return\\<^sub>C_def assign_global_def assign_local_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       (case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n             else case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n                       else Some\n                             ((),\n                              (X \\<circ> map_hd) (\\<lambda>_. E \\<sigma>)\n                               \\<sigma>) of\n                  None \\<Rightarrow> None\n                  | Some (uu_, xa) \\<Rightarrow> set_return_status xa of\n        None \\<Rightarrow> None\n        | Some (uu_, \\<sigma>) \\<Rightarrow>\n            case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n                 else Some\n                       ((),\n                        (X \\<circ> map_hd) (\\<lambda>_. E' \\<sigma>)\n                         \\<sigma>) of\n            None \\<Rightarrow> None | Some (uu_, xa) \\<Rightarrow> M xa) =\n       (case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n             else case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n                       else Some\n                             ((),\n                              (X \\<circ> map_hd) (\\<lambda>_. E \\<sigma>)\n                               \\<sigma>) of\n                  None \\<Rightarrow> None\n                  | Some (uu_, xa) \\<Rightarrow> set_return_status xa of\n        None \\<Rightarrow> None | Some (uu_, xa) \\<Rightarrow> M xa)", "apply(case_tac \"exec_stop \\<sigma>\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       exec_stop \\<sigma> \\<Longrightarrow>\n       (case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n             else case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n                       else Some\n                             ((),\n                              (X \\<circ> map_hd) (\\<lambda>_. E \\<sigma>)\n                               \\<sigma>) of\n                  None \\<Rightarrow> None\n                  | Some (uu_, xa) \\<Rightarrow> set_return_status xa of\n        None \\<Rightarrow> None\n        | Some (uu_, \\<sigma>) \\<Rightarrow>\n            case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n                 else Some\n                       ((),\n                        (X \\<circ> map_hd) (\\<lambda>_. E' \\<sigma>)\n                         \\<sigma>) of\n            None \\<Rightarrow> None | Some (uu_, xa) \\<Rightarrow> M xa) =\n       (case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n             else case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n                       else Some\n                             ((),\n                              (X \\<circ> map_hd) (\\<lambda>_. E \\<sigma>)\n                               \\<sigma>) of\n                  None \\<Rightarrow> None\n                  | Some (uu_, xa) \\<Rightarrow> set_return_status xa of\n        None \\<Rightarrow> None | Some (uu_, xa) \\<Rightarrow> M xa)\n 2. \\<And>\\<sigma>.\n       \\<not> exec_stop \\<sigma> \\<Longrightarrow>\n       (case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n             else case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n                       else Some\n                             ((),\n                              (X \\<circ> map_hd) (\\<lambda>_. E \\<sigma>)\n                               \\<sigma>) of\n                  None \\<Rightarrow> None\n                  | Some (uu_, xa) \\<Rightarrow> set_return_status xa of\n        None \\<Rightarrow> None\n        | Some (uu_, \\<sigma>) \\<Rightarrow>\n            case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n                 else Some\n                       ((),\n                        (X \\<circ> map_hd) (\\<lambda>_. E' \\<sigma>)\n                         \\<sigma>) of\n            None \\<Rightarrow> None | Some (uu_, xa) \\<Rightarrow> M xa) =\n       (case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n             else case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n                       else Some\n                             ((),\n                              (X \\<circ> map_hd) (\\<lambda>_. E \\<sigma>)\n                               \\<sigma>) of\n                  None \\<Rightarrow> None\n                  | Some (uu_, xa) \\<Rightarrow> set_return_status xa of\n        None \\<Rightarrow> None | Some (uu_, xa) \\<Rightarrow> M xa)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<not> exec_stop \\<sigma> \\<Longrightarrow>\n       (case set_return_status\n              (X (map_hd (\\<lambda>_. E \\<sigma>)) \\<sigma>) of\n        None \\<Rightarrow> None\n        | Some (uu_, \\<sigma>) \\<Rightarrow>\n            case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n                 else Some\n                       ((),\n                        (X \\<circ> map_hd) (\\<lambda>_. E' \\<sigma>)\n                         \\<sigma>) of\n            None \\<Rightarrow> None | Some (uu_, xa) \\<Rightarrow> M xa) =\n       (case set_return_status\n              (X (map_hd (\\<lambda>_. E \\<sigma>)) \\<sigma>) of\n        None \\<Rightarrow> None | Some (uu_, xa) \\<Rightarrow> M xa)", "by (simp add: exec_stop_def set_return_status_def)"], ["", "subsection\\<open>While.  \\<close>"], ["", "lemma while\\<^sub>C_skip [simp]: \"(while\\<^sub>C (\\<lambda> x. False) do c od) = skip\\<^sub>S\\<^sub>E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. _while_C (\\<lambda>x. False) c = skip\\<^sub>S\\<^sub>E", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (_while_C (\\<lambda>x. False) c) x = skip\\<^sub>S\\<^sub>E x", "unfolding while_C_def skip\\<^sub>S\\<^sub>E_def unit_SE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (if exec_stop x then Some ((), x)\n        else (_while_SE\n               (\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> False)\n               c ;-\n              unset_break_status)\n              x) =\n       Some ((), x)", "apply auto"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<not> exec_stop x \\<Longrightarrow>\n       (skip\\<^sub>S\\<^sub>E ;- unset_break_status) x = Some ((), x)", "unfolding exec_stop_def skip\\<^sub>S\\<^sub>E_def unset_break_status_def bind_SE'_def unit_SE_def bind_SE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<not> (break_status x \\<or> return_status x) \\<Longrightarrow>\n       (case Some ((), x) of None \\<Rightarrow> None\n        | Some (uu_, \\<sigma>) \\<Rightarrow>\n            Some ((), \\<sigma>\\<lparr>break_status := False\\<rparr>)) =\n       Some ((), x)", "by simp"], ["", "txt\\<open> Various tactics for various coverage criteria \\<close>"], ["", "definition while_k :: \"nat \\<Rightarrow> (('\\<sigma>_ext) control_state_ext \\<Rightarrow> bool) \n                        \\<Rightarrow> (unit, ('\\<sigma>_ext) control_state_ext)MON\\<^sub>S\\<^sub>E \n                        \\<Rightarrow> (unit, ('\\<sigma>_ext) control_state_ext)MON\\<^sub>S\\<^sub>E\"\nwhere     \"while_k _ \\<equiv> while_C\""], ["", "text\\<open>Somewhat amazingly, this unfolding lemma crucial for symbolic execution still holds ... \n     Even in the presence of break or return...\\<close>"], ["", "lemma exec_while\\<^sub>C : \n\"(\\<sigma> \\<Turnstile> ((while\\<^sub>C b do c od) ;- M)) = \n (\\<sigma> \\<Turnstile> ((if\\<^sub>C b then c ;- ((while\\<^sub>C b do c od) ;- unset_break_status) else skip\\<^sub>S\\<^sub>E fi)  ;- M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> \\<Turnstile> _while_C b c ;- M) =\n    (\\<sigma> \\<Turnstile>\n     _if_SECLEAN b (c ;- _while_C b c ;- unset_break_status)\n      skip\\<^sub>S\\<^sub>E ;-\n     M)", "proof (cases \"exec_stop \\<sigma>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. exec_stop \\<sigma> \\<Longrightarrow>\n    (\\<sigma> \\<Turnstile> _while_C b c ;- M) =\n    (\\<sigma> \\<Turnstile>\n     _if_SECLEAN b (c ;- _while_C b c ;- unset_break_status)\n      skip\\<^sub>S\\<^sub>E ;-\n     M)\n 2. \\<not> exec_stop \\<sigma> \\<Longrightarrow>\n    (\\<sigma> \\<Turnstile> _while_C b c ;- M) =\n    (\\<sigma> \\<Turnstile>\n     _if_SECLEAN b (c ;- _while_C b c ;- unset_break_status)\n      skip\\<^sub>S\\<^sub>E ;-\n     M)", "case True"], ["proof (state)\nthis:\n  exec_stop \\<sigma>\n\ngoal (2 subgoals):\n 1. exec_stop \\<sigma> \\<Longrightarrow>\n    (\\<sigma> \\<Turnstile> _while_C b c ;- M) =\n    (\\<sigma> \\<Turnstile>\n     _if_SECLEAN b (c ;- _while_C b c ;- unset_break_status)\n      skip\\<^sub>S\\<^sub>E ;-\n     M)\n 2. \\<not> exec_stop \\<sigma> \\<Longrightarrow>\n    (\\<sigma> \\<Turnstile> _while_C b c ;- M) =\n    (\\<sigma> \\<Turnstile>\n     _if_SECLEAN b (c ;- _while_C b c ;- unset_break_status)\n      skip\\<^sub>S\\<^sub>E ;-\n     M)", "then"], ["proof (chain)\npicking this:\n  exec_stop \\<sigma>", "show ?thesis"], ["proof (prove)\nusing this:\n  exec_stop \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<sigma> \\<Turnstile> _while_C b c ;- M) =\n    (\\<sigma> \\<Turnstile>\n     _if_SECLEAN b (c ;- _while_C b c ;- unset_break_status)\n      skip\\<^sub>S\\<^sub>E ;-\n     M)", "by (simp add: True exec_If\\<^sub>C' exec_While\\<^sub>C')"], ["proof (state)\nthis:\n  (\\<sigma> \\<Turnstile> _while_C b c ;- M) =\n  (\\<sigma> \\<Turnstile>\n   _if_SECLEAN b (c ;- _while_C b c ;- unset_break_status)\n    skip\\<^sub>S\\<^sub>E ;-\n   M)\n\ngoal (1 subgoal):\n 1. \\<not> exec_stop \\<sigma> \\<Longrightarrow>\n    (\\<sigma> \\<Turnstile> _while_C b c ;- M) =\n    (\\<sigma> \\<Turnstile>\n     _if_SECLEAN b (c ;- _while_C b c ;- unset_break_status)\n      skip\\<^sub>S\\<^sub>E ;-\n     M)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> exec_stop \\<sigma> \\<Longrightarrow>\n    (\\<sigma> \\<Turnstile> _while_C b c ;- M) =\n    (\\<sigma> \\<Turnstile>\n     _if_SECLEAN b (c ;- _while_C b c ;- unset_break_status)\n      skip\\<^sub>S\\<^sub>E ;-\n     M)", "case False"], ["proof (state)\nthis:\n  \\<not> exec_stop \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> exec_stop \\<sigma> \\<Longrightarrow>\n    (\\<sigma> \\<Turnstile> _while_C b c ;- M) =\n    (\\<sigma> \\<Turnstile>\n     _if_SECLEAN b (c ;- _while_C b c ;- unset_break_status)\n      skip\\<^sub>S\\<^sub>E ;-\n     M)", "then"], ["proof (chain)\npicking this:\n  \\<not> exec_stop \\<sigma>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> exec_stop \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<sigma> \\<Turnstile> _while_C b c ;- M) =\n    (\\<sigma> \\<Turnstile>\n     _if_SECLEAN b (c ;- _while_C b c ;- unset_break_status)\n      skip\\<^sub>S\\<^sub>E ;-\n     M)", "proof (cases \"\\<not> b \\<sigma>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> exec_stop \\<sigma>; \\<not> b \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> (\\<sigma> \\<Turnstile> _while_C b c ;- M) =\n                      (\\<sigma> \\<Turnstile>\n                       _if_SECLEAN b\n                        (c ;- _while_C b c ;- unset_break_status)\n                        skip\\<^sub>S\\<^sub>E ;-\n                       M)\n 2. \\<lbrakk>\\<not> exec_stop \\<sigma>; \\<not> \\<not> b \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> (\\<sigma> \\<Turnstile> _while_C b c ;- M) =\n                      (\\<sigma> \\<Turnstile>\n                       _if_SECLEAN b\n                        (c ;- _while_C b c ;- unset_break_status)\n                        skip\\<^sub>S\\<^sub>E ;-\n                       M)", "case True"], ["proof (state)\nthis:\n  \\<not> b \\<sigma>\n\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> exec_stop \\<sigma>; \\<not> b \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> (\\<sigma> \\<Turnstile> _while_C b c ;- M) =\n                      (\\<sigma> \\<Turnstile>\n                       _if_SECLEAN b\n                        (c ;- _while_C b c ;- unset_break_status)\n                        skip\\<^sub>S\\<^sub>E ;-\n                       M)\n 2. \\<lbrakk>\\<not> exec_stop \\<sigma>; \\<not> \\<not> b \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> (\\<sigma> \\<Turnstile> _while_C b c ;- M) =\n                      (\\<sigma> \\<Turnstile>\n                       _if_SECLEAN b\n                        (c ;- _while_C b c ;- unset_break_status)\n                        skip\\<^sub>S\\<^sub>E ;-\n                       M)", "then"], ["proof (chain)\npicking this:\n  \\<not> b \\<sigma>", "show ?thesis"], ["proof (prove)\nusing this:\n  \\<not> b \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<sigma> \\<Turnstile> _while_C b c ;- M) =\n    (\\<sigma> \\<Turnstile>\n     _if_SECLEAN b (c ;- _while_C b c ;- unset_break_status)\n      skip\\<^sub>S\\<^sub>E ;-\n     M)", "apply(subst valid_bind'_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<not> b \\<sigma> \\<Longrightarrow>\n    (_while_C b c) \\<sigma> = ?g1 \\<sigma>\n 2. \\<not> b \\<sigma> \\<Longrightarrow>\n    (\\<sigma> \\<Turnstile> ?g1 ;- M) =\n    (\\<sigma> \\<Turnstile>\n     _if_SECLEAN b (c ;- _while_C b c ;- unset_break_status)\n      skip\\<^sub>S\\<^sub>E ;-\n     M)", "using \\<open>\\<not> exec_stop \\<sigma>\\<close>"], ["proof (prove)\nusing this:\n  \\<not> exec_stop \\<sigma>\n\ngoal (2 subgoals):\n 1. \\<not> b \\<sigma> \\<Longrightarrow>\n    (_while_C b c) \\<sigma> = ?g1 \\<sigma>\n 2. \\<not> b \\<sigma> \\<Longrightarrow>\n    (\\<sigma> \\<Turnstile> ?g1 ;- M) =\n    (\\<sigma> \\<Turnstile>\n     _if_SECLEAN b (c ;- _while_C b c ;- unset_break_status)\n      skip\\<^sub>S\\<^sub>E ;-\n     M)", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> b \\<sigma>; \\<not> exec_stop \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> (_while_C b c) \\<sigma> =\n                      (_if_SECLEAN b\n                        (c ;- _while_C b c ;- unset_break_status)\n                        skip\\<^sub>S\\<^sub>E)\n                       \\<sigma>", "apply (auto simp: skip\\<^sub>S\\<^sub>E_def unit_SE_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> b \\<sigma>; \\<not> exec_stop \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> (_while_C b c) \\<sigma> =\n                      (_if_SECLEAN b\n                        (c ;- _while_C b c ;- unset_break_status)\n                        (\\<lambda>\\<sigma>. Some ((), \\<sigma>)))\n                       \\<sigma>", "apply(subst while_C_def, simp)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> b \\<sigma>; \\<not> exec_stop \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> (_while_SE\n                        (\\<lambda>\\<sigma>.\n                            \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>)\n                        c ;-\n                       unset_break_status)\n                       \\<sigma> =\n                      (_if_SECLEAN b\n                        (c ;- _while_C b c ;- unset_break_status)\n                        (\\<lambda>\\<sigma>. Some ((), \\<sigma>)))\n                       \\<sigma>", "apply(subst bind'_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> b \\<sigma>; \\<not> exec_stop \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> (_while_SE\n                        (\\<lambda>\\<sigma>.\n                            \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>)\n                        c)\n                       \\<sigma> =\n                      ?g5 \\<sigma>\n 2. \\<lbrakk>\\<not> b \\<sigma>; \\<not> exec_stop \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> (?g5 ;- unset_break_status) \\<sigma> =\n                      (_if_SECLEAN b\n                        (c ;- _while_C b c ;- unset_break_status)\n                        (\\<lambda>\\<sigma>. Some ((), \\<sigma>)))\n                       \\<sigma>", "apply(subst MonadSE.while_SE_unfold)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrakk>\\<not> b \\<sigma>; \\<not> exec_stop \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> (_if_SE\n                        (\\<lambda>\\<sigma>.\n                            \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>)\n                        (c ;-\n                         _while_SE\n                          (\\<lambda>\\<sigma>.\n                              \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>)\n                          c)\n                        (unit\\<^sub>S\\<^sub>E ()))\n                       \\<sigma> =\n                      ?g7 \\<sigma>\n 2. \\<lbrakk>\\<not> b \\<sigma>; \\<not> exec_stop \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> (?g5 ;- unset_break_status) \\<sigma> =\n                      (_if_SECLEAN b\n                        (c ;- _while_C b c ;- unset_break_status)\n                        (\\<lambda>\\<sigma>. Some ((), \\<sigma>)))\n                       \\<sigma>\nflex-flex pairs:\n  ?g7 \\<sigma> \\<equiv>\\<^sup>? ?g5 \\<sigma>", "apply(subst if\\<^sub>S\\<^sub>E_cond_cong [of _ _ \"\\<lambda>_. False\"])"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrakk>\\<not> b \\<sigma>; \\<not> exec_stop \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> (\\<not> exec_stop \\<sigma> \\<and> b \\<sigma>) = False\n 2. \\<lbrakk>\\<not> b \\<sigma>; \\<not> exec_stop \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> (_if_SE (\\<lambda>_. False)\n                        (c ;-\n                         _while_SE\n                          (\\<lambda>\\<sigma>.\n                              \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>)\n                          c)\n                        (unit\\<^sub>S\\<^sub>E ()))\n                       \\<sigma> =\n                      ?g10 \\<sigma>\n 3. \\<lbrakk>\\<not> b \\<sigma>; \\<not> exec_stop \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> (?g5 ;- unset_break_status) \\<sigma> =\n                      (_if_SECLEAN b\n                        (c ;- _while_C b c ;- unset_break_status)\n                        (\\<lambda>\\<sigma>. Some ((), \\<sigma>)))\n                       \\<sigma>\nflex-flex pairs:\n  ?g10 \\<sigma> \\<equiv>\\<^sup>? ?g7 \\<sigma>\n  ?g7 \\<sigma> \\<equiv>\\<^sup>? ?g5 \\<sigma>", "apply simp_all"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> b \\<sigma>; \\<not> exec_stop \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> (unit\\<^sub>S\\<^sub>E () ;- unset_break_status)\n                       \\<sigma> =\n                      (_if_SECLEAN b\n                        (c ;- _while_C b c ;- unset_break_status)\n                        (\\<lambda>\\<sigma>. Some ((), \\<sigma>)))\n                       \\<sigma>", "apply(subst if\\<^sub>C_cond_cong [of _ _ \"\\<lambda>_. False\"], simp add: )"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> b \\<sigma>; \\<not> exec_stop \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> (unit\\<^sub>S\\<^sub>E () ;- unset_break_status)\n                       \\<sigma> =\n                      (_if_SECLEAN (\\<lambda>_. False)\n                        (c ;- _while_C b c ;- unset_break_status)\n                        (\\<lambda>\\<sigma>. Some ((), \\<sigma>)))\n                       \\<sigma>", "apply(subst exec_If\\<^sub>C_If\\<^sub>S\\<^sub>E,simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> b \\<sigma>; \\<not> exec_stop \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> unset_break_status \\<sigma> = Some ((), \\<sigma>)", "by (simp add: exec_stop_def unset_break_status_def)"], ["proof (state)\nthis:\n  (\\<sigma> \\<Turnstile> _while_C b c ;- M) =\n  (\\<sigma> \\<Turnstile>\n   _if_SECLEAN b (c ;- _while_C b c ;- unset_break_status)\n    skip\\<^sub>S\\<^sub>E ;-\n   M)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> exec_stop \\<sigma>; \\<not> \\<not> b \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> (\\<sigma> \\<Turnstile> _while_C b c ;- M) =\n                      (\\<sigma> \\<Turnstile>\n                       _if_SECLEAN b\n                        (c ;- _while_C b c ;- unset_break_status)\n                        skip\\<^sub>S\\<^sub>E ;-\n                       M)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> exec_stop \\<sigma>; \\<not> \\<not> b \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> (\\<sigma> \\<Turnstile> _while_C b c ;- M) =\n                      (\\<sigma> \\<Turnstile>\n                       _if_SECLEAN b\n                        (c ;- _while_C b c ;- unset_break_status)\n                        skip\\<^sub>S\\<^sub>E ;-\n                       M)", "case False"], ["proof (state)\nthis:\n  \\<not> \\<not> b \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> exec_stop \\<sigma>; \\<not> \\<not> b \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> (\\<sigma> \\<Turnstile> _while_C b c ;- M) =\n                      (\\<sigma> \\<Turnstile>\n                       _if_SECLEAN b\n                        (c ;- _while_C b c ;- unset_break_status)\n                        skip\\<^sub>S\\<^sub>E ;-\n                       M)", "have * : \"b \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<sigma>", "using False"], ["proof (prove)\nusing this:\n  \\<not> \\<not> b \\<sigma>\n\ngoal (1 subgoal):\n 1. b \\<sigma>", "by auto"], ["proof (state)\nthis:\n  b \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<not> exec_stop \\<sigma>; \\<not> \\<not> b \\<sigma>\\<rbrakk>\n    \\<Longrightarrow> (\\<sigma> \\<Turnstile> _while_C b c ;- M) =\n                      (\\<sigma> \\<Turnstile>\n                       _if_SECLEAN b\n                        (c ;- _while_C b c ;- unset_break_status)\n                        skip\\<^sub>S\\<^sub>E ;-\n                       M)", "then"], ["proof (chain)\npicking this:\n  b \\<sigma>", "show ?thesis"], ["proof (prove)\nusing this:\n  b \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<sigma> \\<Turnstile> _while_C b c ;- M) =\n    (\\<sigma> \\<Turnstile>\n     _if_SECLEAN b (c ;- _while_C b c ;- unset_break_status)\n      skip\\<^sub>S\\<^sub>E ;-\n     M)", "unfolding while_k_def"], ["proof (prove)\nusing this:\n  b \\<sigma>\n\ngoal (1 subgoal):\n 1. (\\<sigma> \\<Turnstile> _while_C b c ;- M) =\n    (\\<sigma> \\<Turnstile>\n     _if_SECLEAN b (c ;- _while_C b c ;- unset_break_status)\n      skip\\<^sub>S\\<^sub>E ;-\n     M)", "apply(subst  while_C_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<sigma> \\<Longrightarrow>\n    (\\<sigma> \\<Turnstile>\n     (\\<lambda>\\<sigma>.\n         if exec_stop \\<sigma> then Some ((), \\<sigma>)\n         else (_while_SE\n                (\\<lambda>\\<sigma>.\n                    \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>)\n                c ;-\n               unset_break_status)\n               \\<sigma>) ;-\n     M) =\n    (\\<sigma> \\<Turnstile>\n     _if_SECLEAN b (c ;- _while_C b c ;- unset_break_status)\n      skip\\<^sub>S\\<^sub>E ;-\n     M)", "apply(subst  if_C_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<sigma> \\<Longrightarrow>\n    (\\<sigma> \\<Turnstile>\n     (\\<lambda>\\<sigma>.\n         if exec_stop \\<sigma> then Some ((), \\<sigma>)\n         else (_while_SE\n                (\\<lambda>\\<sigma>.\n                    \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>)\n                c ;-\n               unset_break_status)\n               \\<sigma>) ;-\n     M) =\n    (\\<sigma> \\<Turnstile>\n     (\\<lambda>\\<sigma>.\n         if exec_stop \\<sigma> then Some (undefined, \\<sigma>)\n         else if b \\<sigma>\n              then (c ;- _while_C b c ;- unset_break_status) \\<sigma>\n              else skip\\<^sub>S\\<^sub>E \\<sigma>) ;-\n     M)", "apply(subst  valid_bind'_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. b \\<sigma> \\<Longrightarrow>\n    (if exec_stop \\<sigma> then Some ((), \\<sigma>)\n     else (_while_SE\n            (\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>)\n            c ;-\n           unset_break_status)\n           \\<sigma>) =\n    ?g1 \\<sigma>\n 2. b \\<sigma> \\<Longrightarrow>\n    (\\<sigma> \\<Turnstile> ?g1 ;- M) =\n    (\\<sigma> \\<Turnstile>\n     (\\<lambda>\\<sigma>.\n         if exec_stop \\<sigma> then Some (undefined, \\<sigma>)\n         else if b \\<sigma>\n              then (c ;- _while_C b c ;- unset_break_status) \\<sigma>\n              else skip\\<^sub>S\\<^sub>E \\<sigma>) ;-\n     M)", "apply (simp add: \\<open>\\<not> exec_stop \\<sigma>\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<sigma> \\<Longrightarrow>\n    (\\<sigma> \\<Turnstile>\n     (_while_SE\n       (\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>) c ;-\n      unset_break_status) ;-\n     M) =\n    (\\<sigma> \\<Turnstile>\n     (\\<lambda>\\<sigma>.\n         if exec_stop \\<sigma> then Some (undefined, \\<sigma>)\n         else if b \\<sigma>\n              then (c ;- _while_C b c ;- unset_break_status) \\<sigma>\n              else skip\\<^sub>S\\<^sub>E \\<sigma>) ;-\n     M)", "apply(subst  (2) valid_bind'_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. b \\<sigma> \\<Longrightarrow>\n    (if exec_stop \\<sigma> then Some (undefined, \\<sigma>)\n     else if b \\<sigma>\n          then (c ;- _while_C b c ;- unset_break_status) \\<sigma>\n          else skip\\<^sub>S\\<^sub>E \\<sigma>) =\n    ?g5 \\<sigma>\n 2. b \\<sigma> \\<Longrightarrow>\n    (\\<sigma> \\<Turnstile>\n     (_while_SE\n       (\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>) c ;-\n      unset_break_status) ;-\n     M) =\n    (\\<sigma> \\<Turnstile> ?g5 ;- M)", "apply (simp add: \\<open>\\<not> exec_stop \\<sigma>\\<close>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<sigma> \\<Longrightarrow>\n    (\\<sigma> \\<Turnstile>\n     (_while_SE\n       (\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>) c ;-\n      unset_break_status) ;-\n     M) =\n    (\\<sigma> \\<Turnstile> (c ;- _while_C b c ;- unset_break_status) ;- M)", "apply(subst MonadSE.while_SE_unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<sigma> \\<Longrightarrow>\n    (\\<sigma> \\<Turnstile>\n     (_if_SE\n       (\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>)\n       (c ;-\n        _while_SE\n         (\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>) c)\n       (unit\\<^sub>S\\<^sub>E ()) ;-\n      unset_break_status) ;-\n     M) =\n    (\\<sigma> \\<Turnstile> (c ;- _while_C b c ;- unset_break_status) ;- M)", "apply(subst valid_bind'_cong)"], ["proof (prove)\ngoal (2 subgoals):\n 1. b \\<sigma> \\<Longrightarrow>\n    (_if_SE (\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>)\n      (c ;-\n       _while_SE\n        (\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>) c)\n      (unit\\<^sub>S\\<^sub>E ()) ;-\n     unset_break_status)\n     \\<sigma> =\n    ?g10 \\<sigma>\n 2. b \\<sigma> \\<Longrightarrow>\n    (\\<sigma> \\<Turnstile> ?g10 ;- M) =\n    (\\<sigma> \\<Turnstile> (c ;- _while_C b c ;- unset_break_status) ;- M)", "apply(subst bind'_cong)"], ["proof (prove)\ngoal (3 subgoals):\n 1. b \\<sigma> \\<Longrightarrow>\n    (_if_SE (\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>)\n      (c ;-\n       _while_SE\n        (\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>) c)\n      (unit\\<^sub>S\\<^sub>E ()))\n     \\<sigma> =\n    ?g12 \\<sigma>\n 2. b \\<sigma> \\<Longrightarrow>\n    (?g12 ;- unset_break_status) \\<sigma> = ?ga12 \\<sigma>\n 3. b \\<sigma> \\<Longrightarrow>\n    (\\<sigma> \\<Turnstile> ?g10 ;- M) =\n    (\\<sigma> \\<Turnstile> (c ;- _while_C b c ;- unset_break_status) ;- M)\nflex-flex pairs:\n  ?ga12 \\<sigma> \\<equiv>\\<^sup>? ?g10 \\<sigma>", "apply(subst if\\<^sub>S\\<^sub>E_cond_cong [of _ _ \"\\<lambda>_. True\"])"], ["proof (prove)\ngoal (4 subgoals):\n 1. b \\<sigma> \\<Longrightarrow>\n    (\\<not> exec_stop \\<sigma> \\<and> b \\<sigma>) = True\n 2. b \\<sigma> \\<Longrightarrow>\n    (_if_SE (\\<lambda>_. True)\n      (c ;-\n       _while_SE\n        (\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>) c)\n      (unit\\<^sub>S\\<^sub>E ()))\n     \\<sigma> =\n    ?g15 \\<sigma>\n 3. b \\<sigma> \\<Longrightarrow>\n    (?g12 ;- unset_break_status) \\<sigma> = ?ga12 \\<sigma>\n 4. b \\<sigma> \\<Longrightarrow>\n    (\\<sigma> \\<Turnstile> ?g10 ;- M) =\n    (\\<sigma> \\<Turnstile> (c ;- _while_C b c ;- unset_break_status) ;- M)\nflex-flex pairs:\n  ?g15 \\<sigma> \\<equiv>\\<^sup>? ?g12 \\<sigma>\n  ?ga12 \\<sigma> \\<equiv>\\<^sup>? ?g10 \\<sigma>", "apply(simp_all add:   \\<open>\\<not> exec_stop \\<sigma>\\<close> )"], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<sigma> \\<Longrightarrow>\n    (\\<sigma> \\<Turnstile>\n     ((c ;-\n       _while_SE\n        (\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>)\n        c) ;-\n      unset_break_status) ;-\n     M) =\n    (\\<sigma> \\<Turnstile> c ;- _while_C b c ;- unset_break_status ;- M)", "apply(subst bind_assoc', subst bind_assoc')"], ["proof (prove)\ngoal (1 subgoal):\n 1. b \\<sigma> \\<Longrightarrow>\n    (\\<sigma> \\<Turnstile>\n     c ;-\n     (_while_SE\n       (\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>) c ;-\n      unset_break_status) ;-\n     M) =\n    (\\<sigma> \\<Turnstile> c ;- _while_C b c ;- unset_break_status ;- M)", "proof(cases \"c \\<sigma>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>b \\<sigma>; c \\<sigma> = None\\<rbrakk>\n    \\<Longrightarrow> (\\<sigma> \\<Turnstile>\n                       c ;-\n                       (_while_SE\n                         (\\<lambda>\\<sigma>.\n                             \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>)\n                         c ;-\n                        unset_break_status) ;-\n                       M) =\n                      (\\<sigma> \\<Turnstile>\n                       c ;- _while_C b c ;- unset_break_status ;- M)\n 2. \\<And>a.\n       \\<lbrakk>b \\<sigma>; c \\<sigma> = Some a\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma> \\<Turnstile>\n                          c ;-\n                          (_while_SE\n                            (\\<lambda>\\<sigma>.\n                                \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>)\n                            c ;-\n                           unset_break_status) ;-\n                          M) =\n                         (\\<sigma> \\<Turnstile>\n                          c ;- _while_C b c ;- unset_break_status ;- M)", "case None"], ["proof (state)\nthis:\n  c \\<sigma> = None\n\ngoal (2 subgoals):\n 1. \\<lbrakk>b \\<sigma>; c \\<sigma> = None\\<rbrakk>\n    \\<Longrightarrow> (\\<sigma> \\<Turnstile>\n                       c ;-\n                       (_while_SE\n                         (\\<lambda>\\<sigma>.\n                             \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>)\n                         c ;-\n                        unset_break_status) ;-\n                       M) =\n                      (\\<sigma> \\<Turnstile>\n                       c ;- _while_C b c ;- unset_break_status ;- M)\n 2. \\<And>a.\n       \\<lbrakk>b \\<sigma>; c \\<sigma> = Some a\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma> \\<Turnstile>\n                          c ;-\n                          (_while_SE\n                            (\\<lambda>\\<sigma>.\n                                \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>)\n                            c ;-\n                           unset_break_status) ;-\n                          M) =\n                         (\\<sigma> \\<Turnstile>\n                          c ;- _while_C b c ;- unset_break_status ;- M)", "then"], ["proof (chain)\npicking this:\n  c \\<sigma> = None", "show \"(\\<sigma> \\<Turnstile> c;-((while\\<^sub>S\\<^sub>E (\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>) do c od);-unset_break_status);-M) =\n                         (\\<sigma> \\<Turnstile> c;-(while\\<^sub>C b do c od) ;- unset_break_status ;- M)\""], ["proof (prove)\nusing this:\n  c \\<sigma> = None\n\ngoal (1 subgoal):\n 1. (\\<sigma> \\<Turnstile>\n     c ;-\n     (_while_SE\n       (\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>) c ;-\n      unset_break_status) ;-\n     M) =\n    (\\<sigma> \\<Turnstile> c ;- _while_C b c ;- unset_break_status ;- M)", "by (simp add: bind_SE'_def exec_bind_SE_failure)"], ["proof (state)\nthis:\n  (\\<sigma> \\<Turnstile>\n   c ;-\n   (_while_SE\n     (\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>) c ;-\n    unset_break_status) ;-\n   M) =\n  (\\<sigma> \\<Turnstile> c ;- _while_C b c ;- unset_break_status ;- M)\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>b \\<sigma>; c \\<sigma> = Some a\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma> \\<Turnstile>\n                          c ;-\n                          (_while_SE\n                            (\\<lambda>\\<sigma>.\n                                \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>)\n                            c ;-\n                           unset_break_status) ;-\n                          M) =\n                         (\\<sigma> \\<Turnstile>\n                          c ;- _while_C b c ;- unset_break_status ;- M)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>b \\<sigma>; c \\<sigma> = Some a\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma> \\<Turnstile>\n                          c ;-\n                          (_while_SE\n                            (\\<lambda>\\<sigma>.\n                                \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>)\n                            c ;-\n                           unset_break_status) ;-\n                          M) =\n                         (\\<sigma> \\<Turnstile>\n                          c ;- _while_C b c ;- unset_break_status ;- M)", "case (Some a)"], ["proof (state)\nthis:\n  c \\<sigma> = Some a\n\ngoal (1 subgoal):\n 1. \\<And>a.\n       \\<lbrakk>b \\<sigma>; c \\<sigma> = Some a\\<rbrakk>\n       \\<Longrightarrow> (\\<sigma> \\<Turnstile>\n                          c ;-\n                          (_while_SE\n                            (\\<lambda>\\<sigma>.\n                                \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>)\n                            c ;-\n                           unset_break_status) ;-\n                          M) =\n                         (\\<sigma> \\<Turnstile>\n                          c ;- _while_C b c ;- unset_break_status ;- M)", "then"], ["proof (chain)\npicking this:\n  c \\<sigma> = Some a", "show \"(\\<sigma> \\<Turnstile> c ;- ((while\\<^sub>S\\<^sub>E (\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>) do c od);-unset_break_status);-M) =\n                         (\\<sigma> \\<Turnstile> c ;- (while\\<^sub>C b do c od) ;- unset_break_status ;- M)\""], ["proof (prove)\nusing this:\n  c \\<sigma> = Some a\n\ngoal (1 subgoal):\n 1. (\\<sigma> \\<Turnstile>\n     c ;-\n     (_while_SE\n       (\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>) c ;-\n      unset_break_status) ;-\n     M) =\n    (\\<sigma> \\<Turnstile> c ;- _while_C b c ;- unset_break_status ;- M)", "apply(insert \\<open>c \\<sigma> = Some a\\<close>, subst (asm) surjective_pairing[of a])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c \\<sigma> = Some (fst a, snd a); c \\<sigma> = Some a\\<rbrakk>\n    \\<Longrightarrow> (\\<sigma> \\<Turnstile>\n                       c ;-\n                       (_while_SE\n                         (\\<lambda>\\<sigma>.\n                             \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>)\n                         c ;-\n                        unset_break_status) ;-\n                       M) =\n                      (\\<sigma> \\<Turnstile>\n                       c ;- _while_C b c ;- unset_break_status ;- M)", "apply(subst exec_bind_SE_success2, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c \\<sigma> = Some (fst a, snd a); c \\<sigma> = Some a\\<rbrakk>\n    \\<Longrightarrow> (snd a \\<Turnstile>\n                       (_while_SE\n                         (\\<lambda>\\<sigma>.\n                             \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>)\n                         c ;-\n                        unset_break_status) ;-\n                       M) =\n                      (\\<sigma> \\<Turnstile>\n                       c ;- _while_C b c ;- unset_break_status ;- M)", "apply(subst exec_bind_SE_success2, assumption)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>c \\<sigma> = Some (fst a, snd a); c \\<sigma> = Some a\\<rbrakk>\n    \\<Longrightarrow> (snd a \\<Turnstile>\n                       (_while_SE\n                         (\\<lambda>\\<sigma>.\n                             \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>)\n                         c ;-\n                        unset_break_status) ;-\n                       M) =\n                      (snd a \\<Turnstile>\n                       _while_C b c ;- unset_break_status ;- M)", "proof(cases \"exec_stop (snd a)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>c \\<sigma> = Some (fst a, snd a); c \\<sigma> = Some a;\n     exec_stop (snd a)\\<rbrakk>\n    \\<Longrightarrow> (snd a \\<Turnstile>\n                       (_while_SE\n                         (\\<lambda>\\<sigma>.\n                             \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>)\n                         c ;-\n                        unset_break_status) ;-\n                       M) =\n                      (snd a \\<Turnstile>\n                       _while_C b c ;- unset_break_status ;- M)\n 2. \\<lbrakk>c \\<sigma> = Some (fst a, snd a); c \\<sigma> = Some a;\n     \\<not> exec_stop (snd a)\\<rbrakk>\n    \\<Longrightarrow> (snd a \\<Turnstile>\n                       (_while_SE\n                         (\\<lambda>\\<sigma>.\n                             \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>)\n                         c ;-\n                        unset_break_status) ;-\n                       M) =\n                      (snd a \\<Turnstile>\n                       _while_C b c ;- unset_break_status ;- M)", "case True"], ["proof (state)\nthis:\n  exec_stop (snd a)\n\ngoal (2 subgoals):\n 1. \\<lbrakk>c \\<sigma> = Some (fst a, snd a); c \\<sigma> = Some a;\n     exec_stop (snd a)\\<rbrakk>\n    \\<Longrightarrow> (snd a \\<Turnstile>\n                       (_while_SE\n                         (\\<lambda>\\<sigma>.\n                             \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>)\n                         c ;-\n                        unset_break_status) ;-\n                       M) =\n                      (snd a \\<Turnstile>\n                       _while_C b c ;- unset_break_status ;- M)\n 2. \\<lbrakk>c \\<sigma> = Some (fst a, snd a); c \\<sigma> = Some a;\n     \\<not> exec_stop (snd a)\\<rbrakk>\n    \\<Longrightarrow> (snd a \\<Turnstile>\n                       (_while_SE\n                         (\\<lambda>\\<sigma>.\n                             \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>)\n                         c ;-\n                        unset_break_status) ;-\n                       M) =\n                      (snd a \\<Turnstile>\n                       _while_C b c ;- unset_break_status ;- M)", "then"], ["proof (chain)\npicking this:\n  exec_stop (snd a)", "show \"(snd a \\<Turnstile>((while\\<^sub>S\\<^sub>E (\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>) do c od);-unset_break_status);-M)=\n                             (snd a \\<Turnstile> (while\\<^sub>C b do c od) ;- unset_break_status ;- M)\""], ["proof (prove)\nusing this:\n  exec_stop (snd a)\n\ngoal (1 subgoal):\n 1. (snd a \\<Turnstile>\n     (_while_SE\n       (\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>) c ;-\n      unset_break_status) ;-\n     M) =\n    (snd a \\<Turnstile> _while_C b c ;- unset_break_status ;- M)", "by (metis (no_types, lifting) bind_assoc' exec_While\\<^sub>C' exec_skip if_SE_D2' \n                                                  skip\\<^sub>S\\<^sub>E_def while_SE_unfold)"], ["proof (state)\nthis:\n  (snd a \\<Turnstile>\n   (_while_SE\n     (\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>) c ;-\n    unset_break_status) ;-\n   M) =\n  (snd a \\<Turnstile> _while_C b c ;- unset_break_status ;- M)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c \\<sigma> = Some (fst a, snd a); c \\<sigma> = Some a;\n     \\<not> exec_stop (snd a)\\<rbrakk>\n    \\<Longrightarrow> (snd a \\<Turnstile>\n                       (_while_SE\n                         (\\<lambda>\\<sigma>.\n                             \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>)\n                         c ;-\n                        unset_break_status) ;-\n                       M) =\n                      (snd a \\<Turnstile>\n                       _while_C b c ;- unset_break_status ;- M)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>c \\<sigma> = Some (fst a, snd a); c \\<sigma> = Some a;\n     \\<not> exec_stop (snd a)\\<rbrakk>\n    \\<Longrightarrow> (snd a \\<Turnstile>\n                       (_while_SE\n                         (\\<lambda>\\<sigma>.\n                             \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>)\n                         c ;-\n                        unset_break_status) ;-\n                       M) =\n                      (snd a \\<Turnstile>\n                       _while_C b c ;- unset_break_status ;- M)", "case False"], ["proof (state)\nthis:\n  \\<not> exec_stop (snd a)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>c \\<sigma> = Some (fst a, snd a); c \\<sigma> = Some a;\n     \\<not> exec_stop (snd a)\\<rbrakk>\n    \\<Longrightarrow> (snd a \\<Turnstile>\n                       (_while_SE\n                         (\\<lambda>\\<sigma>.\n                             \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>)\n                         c ;-\n                        unset_break_status) ;-\n                       M) =\n                      (snd a \\<Turnstile>\n                       _while_C b c ;- unset_break_status ;- M)", "then"], ["proof (chain)\npicking this:\n  \\<not> exec_stop (snd a)", "show \"(snd a \\<Turnstile> ((while\\<^sub>S\\<^sub>E(\\<lambda>\\<sigma>. \\<not>exec_stop \\<sigma> \\<and> b \\<sigma>) do c od);-unset_break_status);-M)=\n                             (snd a \\<Turnstile> (while\\<^sub>C b do c od) ;- unset_break_status ;- M)\""], ["proof (prove)\nusing this:\n  \\<not> exec_stop (snd a)\n\ngoal (1 subgoal):\n 1. (snd a \\<Turnstile>\n     (_while_SE\n       (\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>) c ;-\n      unset_break_status) ;-\n     M) =\n    (snd a \\<Turnstile> _while_C b c ;- unset_break_status ;- M)", "unfolding  while_C_def"], ["proof (prove)\nusing this:\n  \\<not> exec_stop (snd a)\n\ngoal (1 subgoal):\n 1. (snd a \\<Turnstile>\n     (_while_SE\n       (\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>) c ;-\n      unset_break_status) ;-\n     M) =\n    (snd a \\<Turnstile>\n     (\\<lambda>\\<sigma>.\n         if exec_stop \\<sigma> then Some ((), \\<sigma>)\n         else (_while_SE\n                (\\<lambda>\\<sigma>.\n                    \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>)\n                c ;-\n               unset_break_status)\n               \\<sigma>) ;-\n     unset_break_status ;- M)", "by(subst (2) valid_bind'_cong,simp)(simp)"], ["proof (state)\nthis:\n  (snd a \\<Turnstile>\n   (_while_SE\n     (\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>) c ;-\n    unset_break_status) ;-\n   M) =\n  (snd a \\<Turnstile> _while_C b c ;- unset_break_status ;- M)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<sigma> \\<Turnstile>\n   c ;-\n   (_while_SE\n     (\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> b \\<sigma>) c ;-\n    unset_break_status) ;-\n   M) =\n  (\\<sigma> \\<Turnstile> c ;- _while_C b c ;- unset_break_status ;- M)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<sigma> \\<Turnstile> _while_C b c ;- M) =\n  (\\<sigma> \\<Turnstile>\n   _if_SECLEAN b (c ;- _while_C b c ;- unset_break_status)\n    skip\\<^sub>S\\<^sub>E ;-\n   M)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (\\<sigma> \\<Turnstile> _while_C b c ;- M) =\n  (\\<sigma> \\<Turnstile>\n   _if_SECLEAN b (c ;- _while_C b c ;- unset_break_status)\n    skip\\<^sub>S\\<^sub>E ;-\n   M)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* ... although it is, oh my god, amazingly complex to prove. *)"], ["", "lemma while_k_SE : \"while_C = while_k k\""], ["proof (prove)\ngoal (1 subgoal):\n 1. while_C = while_k k", "by (simp only: while_k_def)"], ["", "corollary exec_while_k : \n\"(\\<sigma> \\<Turnstile> ((while_k (Suc n) b c) ;- M)) = \n (\\<sigma> \\<Turnstile> ((if\\<^sub>C b then c ;- (while_k n b c) ;- unset_break_status else skip\\<^sub>S\\<^sub>E fi)  ;- M))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<sigma> \\<Turnstile> while_k (Suc n) b c ;- M) =\n    (\\<sigma> \\<Turnstile>\n     _if_SECLEAN b (c ;- while_k n b c ;- unset_break_status)\n      skip\\<^sub>S\\<^sub>E ;-\n     M)", "by (metis exec_while\\<^sub>C while_k_def)"], ["", "txt\\<open> Necessary prerequisite: turning ematch and dmatch into a proper Isar Method. \\<close>"], ["", "(* TODO : this code shoud go to TestGen Method setups *)"], ["", "ML\\<open>\nlocal\nfun method_setup b tac =\n  Method.setup b\n    (Attrib.thms >> (fn rules => fn ctxt => METHOD (HEADGOAL o K (tac ctxt rules))))\nin\nval _ =\n  Theory.setup (   method_setup @{binding ematch} ematch_tac \"fast elimination matching\"\n                #> method_setup @{binding dmatch} dmatch_tac \"fast destruction matching\"\n                #> method_setup @{binding match} match_tac \"resolution based on fast matching\")\nend\n\\<close>"], ["", "lemmas exec_while_kD = exec_while_k[THEN iffD1]"], ["", "end"]]}