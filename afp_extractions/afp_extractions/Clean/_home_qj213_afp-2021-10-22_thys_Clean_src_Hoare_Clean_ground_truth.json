{"file_name": "/home/qj213/afp-2021-10-22/thys/Clean/src/Hoare_Clean.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Clean", "problem_names": ["lemma break1: \n  \"\\<lbrace>\\<lambda>\\<sigma>.  P (\\<sigma> \\<lparr> break_status := True \\<rparr>) \\<rbrace> break \\<lbrace>\\<lambda>r \\<sigma>.  P \\<sigma> \\<and> break_status \\<sigma> \\<rbrace>\"", "lemma unset_break1: \n  \"\\<lbrace>\\<lambda>\\<sigma>.  P (\\<sigma> \\<lparr> break_status := False \\<rparr>) \\<rbrace> unset_break_status \\<lbrace>\\<lambda>r \\<sigma>. P \\<sigma> \\<and> \\<not> break_status \\<sigma> \\<rbrace>\"", "lemma set_return1: \n  \"\\<lbrace>\\<lambda>\\<sigma>.  P (\\<sigma> \\<lparr> return_status := True \\<rparr>) \\<rbrace> set_return_status \\<lbrace>\\<lambda>r \\<sigma>. P \\<sigma> \\<and> return_status \\<sigma> \\<rbrace>\"", "lemma unset_return1: \n  \"\\<lbrace>\\<lambda>\\<sigma>.  P (\\<sigma> \\<lparr> return_status := False \\<rparr>) \\<rbrace> unset_return_status \\<lbrace>\\<lambda>r \\<sigma>. P \\<sigma> \\<and> \\<not>return_status \\<sigma> \\<rbrace>\"", "lemma assign_global_skip:\n\"\\<lbrace>\\<lambda>\\<sigma>.   exec_stop \\<sigma> \\<and> P \\<sigma> \\<rbrace>  assign_global upd rhs  \\<lbrace>\\<lambda>r \\<sigma>. exec_stop \\<sigma> \\<and> P \\<sigma> \\<rbrace>\"", "lemma assign_local_skip:\n\"\\<lbrace>\\<lambda>\\<sigma>.   exec_stop \\<sigma> \\<and> P \\<sigma> \\<rbrace> assign_local upd rhs  \\<lbrace>\\<lambda>r \\<sigma>. exec_stop \\<sigma> \\<and> P \\<sigma> \\<rbrace>\"", "lemma return_skip:\n\"\\<lbrace>\\<lambda>\\<sigma>.  exec_stop \\<sigma> \\<and> P \\<sigma> \\<rbrace> return\\<^sub>C upd rhs \\<lbrace>\\<lambda>r \\<sigma>. exec_stop \\<sigma> \\<and> P \\<sigma> \\<rbrace>\"", "lemma assign_clean_skip:\n\"\\<lbrace>\\<lambda>\\<sigma>.   exec_stop \\<sigma> \\<and> P \\<sigma> \\<rbrace>  assign tr  \\<lbrace>\\<lambda>r \\<sigma>. exec_stop \\<sigma> \\<and> P \\<sigma> \\<rbrace>\"", "lemma if_clean_skip:\n\"\\<lbrace>\\<lambda>\\<sigma>.   exec_stop \\<sigma> \\<and> P \\<sigma> \\<rbrace>  if\\<^sub>C C then E else F fi \\<lbrace>\\<lambda>r \\<sigma>. exec_stop \\<sigma> \\<and> P \\<sigma> \\<rbrace>\"", "lemma while_clean_skip:\n\"\\<lbrace>\\<lambda>\\<sigma>.   exec_stop \\<sigma> \\<and> P \\<sigma> \\<rbrace>  while\\<^sub>C cond do body od  \\<lbrace>\\<lambda>r \\<sigma>. exec_stop \\<sigma> \\<and> P \\<sigma> \\<rbrace>\"", "lemma if_opcall_skip:\n\"\\<lbrace>\\<lambda>\\<sigma>.   exec_stop \\<sigma> \\<and> P \\<sigma>\\<rbrace> (call\\<^sub>C M A\\<^sub>1) \\<lbrace>\\<lambda>r \\<sigma>. exec_stop \\<sigma> \\<and> P \\<sigma>\\<rbrace>\"", "lemma if_funcall_skip:\n\"\\<lbrace>\\<lambda>\\<sigma>. exec_stop \\<sigma> \\<and> P \\<sigma>\\<rbrace>(p\\<^sub>t\\<^sub>m\\<^sub>p \\<leftarrow> call\\<^sub>C fun E ; assign_local upd (\\<lambda>\\<sigma>. p\\<^sub>t\\<^sub>m\\<^sub>p)) \\<lbrace>\\<lambda>r \\<sigma>. exec_stop \\<sigma> \\<and> P \\<sigma>\\<rbrace>\"", "lemma if_funcall_skip':\n\"\\<lbrace>\\<lambda>\\<sigma>. exec_stop \\<sigma> \\<and> P \\<sigma> \\<rbrace>(p\\<^sub>t\\<^sub>m\\<^sub>p \\<leftarrow> call\\<^sub>C fun E ; assign_global upd (\\<lambda>\\<sigma>. p\\<^sub>t\\<^sub>m\\<^sub>p)) \\<lbrace>\\<lambda>r \\<sigma>. exec_stop \\<sigma> \\<and> P \\<sigma> \\<rbrace>\"", "lemma assign_global:\n  assumes * : \"\\<sharp> upd\"\n  shows \"\\<lbrace>\\<lambda>\\<sigma>. \\<not>exec_stop \\<sigma> \\<and> P (upd (\\<lambda>_. rhs \\<sigma>) \\<sigma>) \\<rbrace> \n         assign_global upd rhs \n         \\<lbrace>\\<lambda>r \\<sigma>. \\<not>exec_stop \\<sigma> \\<and> P \\<sigma> \\<rbrace>\"", "lemma assign_local:\n  assumes * : \"\\<sharp> (upd \\<circ> map_hd)\"\n  shows \"\\<lbrace>\\<lambda>\\<sigma>.  \\<not> exec_stop \\<sigma> \\<and> P ((upd \\<circ> map_hd) (\\<lambda>_. rhs \\<sigma>) \\<sigma>) \\<rbrace>  \n          assign_local upd rhs  \n         \\<lbrace>\\<lambda>r \\<sigma>. \\<not> exec_stop \\<sigma> \\<and> P \\<sigma> \\<rbrace>\"", "lemma return_assign:\n  assumes * : \"\\<sharp> (upd \\<circ> map_hd)\"\n  shows \"\\<lbrace>\\<lambda> \\<sigma>. \\<not> exec_stop \\<sigma> \\<and> P ((upd \\<circ> map_hd) (\\<lambda>_. rhs \\<sigma>) (\\<sigma> \\<lparr> return_status := True \\<rparr>))\\<rbrace> \n          return\\<^sub>C upd rhs\n         \\<lbrace>\\<lambda>r \\<sigma>. P \\<sigma> \\<and> return_status \\<sigma> \\<rbrace>\"", "lemma cond_clean : \n  \"    \\<lbrace>\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> P \\<sigma> \\<and> cond \\<sigma>\\<rbrace> M \\<lbrace>Q\\<rbrace>\n   \\<Longrightarrow> \\<lbrace>\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> P \\<sigma> \\<and> \\<not> cond \\<sigma>\\<rbrace> M' \\<lbrace>Q\\<rbrace>  \n   \\<Longrightarrow> \\<lbrace>\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> P \\<sigma>\\<rbrace> if\\<^sub>C cond then M else M' fi\\<lbrace>Q\\<rbrace>\"", "lemma while_clean_no_break :\n  assumes  * : \"\\<lbrace>\\<lambda>\\<sigma>. \\<not> break_status \\<sigma> \\<and> cond \\<sigma> \\<and> P \\<sigma>\\<rbrace>  M \\<lbrace>\\<lambda>_. \\<lambda>\\<sigma>.  \\<not> break_status \\<sigma> \\<and> P \\<sigma> \\<rbrace>\"\n  and measure: \"\\<forall>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> cond \\<sigma> \\<and> P \\<sigma> \n                    \\<longrightarrow> M \\<sigma> \\<noteq> None \\<and> f(snd(the(M \\<sigma>))) < ((f \\<sigma>)::nat) \"\n               (is \"\\<forall>\\<sigma>. _ \\<and> cond \\<sigma> \\<and> P \\<sigma> \\<longrightarrow> ?decrease \\<sigma>\")\n  shows        \"\\<lbrace>\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> P \\<sigma>\\<rbrace> \n                while\\<^sub>C cond do M od \n                \\<lbrace>\\<lambda>_ \\<sigma>. (return_status \\<sigma> \\<or> \\<not> cond \\<sigma>) \\<and> \\<not> break_status \\<sigma> \\<and> P \\<sigma>\\<rbrace>\"\n                (is \"\\<lbrace>?pre\\<rbrace> while\\<^sub>C cond do M od \\<lbrace>\\<lambda>_ \\<sigma>. ?post1 \\<sigma> \\<and> ?post2 \\<sigma>\\<rbrace>\")", "lemma while_clean':\n  assumes  M_inv   : \"\\<lbrace>\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> cond \\<sigma> \\<and> P \\<sigma>\\<rbrace>  M \\<lbrace>\\<lambda>_. P\\<rbrace>\"\n  and cond_idpc    : \"\\<forall>x \\<sigma>.  (cond (\\<sigma>\\<lparr>break_status := x\\<rparr>)) = cond \\<sigma> \"\n  and inv_idpc     : \"\\<forall>x \\<sigma>.  (P (\\<sigma>\\<lparr>break_status := x\\<rparr>)) = P \\<sigma> \"\n  and f_is_measure : \"\\<forall>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> cond \\<sigma> \\<and> P \\<sigma> \\<longrightarrow> \n                       M \\<sigma> \\<noteq> None \\<and> f(snd(the(M \\<sigma>))) < ((f \\<sigma>)::nat) \"\nshows    \"\\<lbrace>\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> P \\<sigma>\\<rbrace> \n          while\\<^sub>C cond do M od \n          \\<lbrace>\\<lambda>_ \\<sigma>.  \\<not> break_status \\<sigma> \\<and> P \\<sigma>\\<rbrace>\""], "translations": [["", "lemma break1: \n  \"\\<lbrace>\\<lambda>\\<sigma>.  P (\\<sigma> \\<lparr> break_status := True \\<rparr>) \\<rbrace> break \\<lbrace>\\<lambda>r \\<sigma>.  P \\<sigma> \\<and> break_status \\<sigma> \\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>\\<sigma>.\n                P (\\<sigma>\\<lparr>break_status := True\\<rparr>)\\<rbrace>\n    break\n    \\<lbrace>\\<lambda>r \\<sigma>.\n                P \\<sigma> \\<and> break_status \\<sigma>\\<rbrace>", "unfolding    hoare\\<^sub>3_def break_def unit_SE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       P (\\<sigma>\\<lparr>break_status := True\\<rparr>) \\<longrightarrow>\n       (case Some ((), \\<sigma>\\<lparr>break_status := True\\<rparr>) of\n        None \\<Rightarrow> False\n        | Some (x, \\<sigma>') \\<Rightarrow>\n            P \\<sigma>' \\<and> break_status \\<sigma>')", "by auto"], ["", "lemma unset_break1: \n  \"\\<lbrace>\\<lambda>\\<sigma>.  P (\\<sigma> \\<lparr> break_status := False \\<rparr>) \\<rbrace> unset_break_status \\<lbrace>\\<lambda>r \\<sigma>. P \\<sigma> \\<and> \\<not> break_status \\<sigma> \\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>\\<sigma>.\n                P (\\<sigma>\\<lparr>break_status := False\\<rparr>)\\<rbrace>\n    unset_break_status\n    \\<lbrace>\\<lambda>r \\<sigma>.\n                P \\<sigma> \\<and> \\<not> break_status \\<sigma>\\<rbrace>", "unfolding    hoare\\<^sub>3_def unset_break_status_def unit_SE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       P (\\<sigma>\\<lparr>break_status := False\\<rparr>) \\<longrightarrow>\n       (case Some ((), \\<sigma>\\<lparr>break_status := False\\<rparr>) of\n        None \\<Rightarrow> False\n        | Some (x, \\<sigma>') \\<Rightarrow>\n            P \\<sigma>' \\<and> \\<not> break_status \\<sigma>')", "by auto"], ["", "lemma set_return1: \n  \"\\<lbrace>\\<lambda>\\<sigma>.  P (\\<sigma> \\<lparr> return_status := True \\<rparr>) \\<rbrace> set_return_status \\<lbrace>\\<lambda>r \\<sigma>. P \\<sigma> \\<and> return_status \\<sigma> \\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>\\<sigma>.\n                P (\\<sigma>\\<lparr>return_status := True\\<rparr>)\\<rbrace>\n    set_return_status\n    \\<lbrace>\\<lambda>r \\<sigma>.\n                P \\<sigma> \\<and> return_status \\<sigma>\\<rbrace>", "unfolding    hoare\\<^sub>3_def set_return_status_def unit_SE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       P (\\<sigma>\\<lparr>return_status := True\\<rparr>) \\<longrightarrow>\n       (case Some ((), \\<sigma>\\<lparr>return_status := True\\<rparr>) of\n        None \\<Rightarrow> False\n        | Some (x, \\<sigma>') \\<Rightarrow>\n            P \\<sigma>' \\<and> return_status \\<sigma>')", "by auto"], ["", "lemma unset_return1: \n  \"\\<lbrace>\\<lambda>\\<sigma>.  P (\\<sigma> \\<lparr> return_status := False \\<rparr>) \\<rbrace> unset_return_status \\<lbrace>\\<lambda>r \\<sigma>. P \\<sigma> \\<and> \\<not>return_status \\<sigma> \\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>\\<sigma>.\n                P (\\<sigma>\\<lparr>return_status := False\\<rparr>)\\<rbrace>\n    unset_return_status\n    \\<lbrace>\\<lambda>r \\<sigma>.\n                P \\<sigma> \\<and> \\<not> return_status \\<sigma>\\<rbrace>", "unfolding    hoare\\<^sub>3_def unset_return_status_def unit_SE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       P (\\<sigma>\\<lparr>return_status := False\\<rparr>) \\<longrightarrow>\n       (case Some ((), \\<sigma>\\<lparr>return_status := False\\<rparr>) of\n        None \\<Rightarrow> False\n        | Some (x, \\<sigma>') \\<Rightarrow>\n            P \\<sigma>' \\<and> \\<not> return_status \\<sigma>')", "by auto"], ["", "subsection\\<open>Clean Skip Rules\\<close>"], ["", "lemma assign_global_skip:\n\"\\<lbrace>\\<lambda>\\<sigma>.   exec_stop \\<sigma> \\<and> P \\<sigma> \\<rbrace>  assign_global upd rhs  \\<lbrace>\\<lambda>r \\<sigma>. exec_stop \\<sigma> \\<and> P \\<sigma> \\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>\\<sigma>.\n                exec_stop \\<sigma> \\<and> P \\<sigma>\\<rbrace>\n    assign_global upd rhs\n    \\<lbrace>\\<lambda>r \\<sigma>.\n                exec_stop \\<sigma> \\<and> P \\<sigma>\\<rbrace>", "unfolding    hoare\\<^sub>3_def skip\\<^sub>S\\<^sub>E_def unit_SE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       exec_stop \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n       (case assign_global upd rhs \\<sigma> of None \\<Rightarrow> False\n        | Some (x, \\<sigma>') \\<Rightarrow>\n            exec_stop \\<sigma>' \\<and> P \\<sigma>')", "by (simp add: assign_def assign_global_def)"], ["", "lemma assign_local_skip:\n\"\\<lbrace>\\<lambda>\\<sigma>.   exec_stop \\<sigma> \\<and> P \\<sigma> \\<rbrace> assign_local upd rhs  \\<lbrace>\\<lambda>r \\<sigma>. exec_stop \\<sigma> \\<and> P \\<sigma> \\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>\\<sigma>.\n                exec_stop \\<sigma> \\<and> P \\<sigma>\\<rbrace>\n    assign_local upd rhs\n    \\<lbrace>\\<lambda>r \\<sigma>.\n                exec_stop \\<sigma> \\<and> P \\<sigma>\\<rbrace>", "unfolding    hoare\\<^sub>3_def skip\\<^sub>S\\<^sub>E_def unit_SE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       exec_stop \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n       (case assign_local upd rhs \\<sigma> of None \\<Rightarrow> False\n        | Some (x, \\<sigma>') \\<Rightarrow>\n            exec_stop \\<sigma>' \\<and> P \\<sigma>')", "by (simp add: assign_def assign_local_def)"], ["", "lemma return_skip:\n\"\\<lbrace>\\<lambda>\\<sigma>.  exec_stop \\<sigma> \\<and> P \\<sigma> \\<rbrace> return\\<^sub>C upd rhs \\<lbrace>\\<lambda>r \\<sigma>. exec_stop \\<sigma> \\<and> P \\<sigma> \\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>\\<sigma>.\n                exec_stop \\<sigma> \\<and> P \\<sigma>\\<rbrace>\n    return\\<^sub>C upd rhs\n    \\<lbrace>\\<lambda>r \\<sigma>.\n                exec_stop \\<sigma> \\<and> P \\<sigma>\\<rbrace>", "unfolding hoare\\<^sub>3_def return\\<^sub>C_def unit_SE_def assign_local_def assign_def bind_SE'_def bind_SE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       exec_stop \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n       (case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n             else case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n                       else Some\n                             ((),\n                              (upd \\<circ> map_hd)\n                               (\\<lambda>_. rhs \\<sigma>) \\<sigma>) of\n                  None \\<Rightarrow> None\n                  | Some (uu_, xa) \\<Rightarrow> set_return_status xa of\n        None \\<Rightarrow> False\n        | Some (x, \\<sigma>') \\<Rightarrow>\n            exec_stop \\<sigma>' \\<and> P \\<sigma>')", "by auto"], ["", "lemma assign_clean_skip:\n\"\\<lbrace>\\<lambda>\\<sigma>.   exec_stop \\<sigma> \\<and> P \\<sigma> \\<rbrace>  assign tr  \\<lbrace>\\<lambda>r \\<sigma>. exec_stop \\<sigma> \\<and> P \\<sigma> \\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>\\<sigma>.\n                exec_stop \\<sigma> \\<and> P \\<sigma>\\<rbrace>\n    assign tr\n    \\<lbrace>\\<lambda>r \\<sigma>.\n                exec_stop \\<sigma> \\<and> P \\<sigma>\\<rbrace>", "unfolding    hoare\\<^sub>3_def skip\\<^sub>S\\<^sub>E_def unit_SE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       exec_stop \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n       (case assign tr \\<sigma> of None \\<Rightarrow> False\n        | Some (x, \\<sigma>') \\<Rightarrow>\n            exec_stop \\<sigma>' \\<and> P \\<sigma>')", "by (simp add: assign_def assign_def)"], ["", "lemma if_clean_skip:\n\"\\<lbrace>\\<lambda>\\<sigma>.   exec_stop \\<sigma> \\<and> P \\<sigma> \\<rbrace>  if\\<^sub>C C then E else F fi \\<lbrace>\\<lambda>r \\<sigma>. exec_stop \\<sigma> \\<and> P \\<sigma> \\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>\\<sigma>.\n                exec_stop \\<sigma> \\<and> P \\<sigma>\\<rbrace>\n    _if_SECLEAN C E F\n    \\<lbrace>\\<lambda>r \\<sigma>.\n                exec_stop \\<sigma> \\<and> P \\<sigma>\\<rbrace>", "unfolding    hoare\\<^sub>3_def skip\\<^sub>S\\<^sub>E_def unit_SE_def if_SE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       exec_stop \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n       (case (_if_SECLEAN C E F) \\<sigma> of None \\<Rightarrow> False\n        | Some (x, \\<sigma>') \\<Rightarrow>\n            exec_stop \\<sigma>' \\<and> P \\<sigma>')", "by (simp add: if_C_def)"], ["", "lemma while_clean_skip:\n\"\\<lbrace>\\<lambda>\\<sigma>.   exec_stop \\<sigma> \\<and> P \\<sigma> \\<rbrace>  while\\<^sub>C cond do body od  \\<lbrace>\\<lambda>r \\<sigma>. exec_stop \\<sigma> \\<and> P \\<sigma> \\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>\\<sigma>.\n                exec_stop \\<sigma> \\<and> P \\<sigma>\\<rbrace>\n    _while_C cond body\n    \\<lbrace>\\<lambda>r \\<sigma>.\n                exec_stop \\<sigma> \\<and> P \\<sigma>\\<rbrace>", "unfolding    hoare\\<^sub>3_def skip\\<^sub>S\\<^sub>E_def unit_SE_def while_C_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       exec_stop \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n       (case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n             else (_while_SE\n                    (\\<lambda>\\<sigma>.\n                        \\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>)\n                    body ;-\n                   unset_break_status)\n                   \\<sigma> of\n        None \\<Rightarrow> False\n        | Some (x, \\<sigma>') \\<Rightarrow>\n            exec_stop \\<sigma>' \\<and> P \\<sigma>')", "by auto"], ["", "lemma if_opcall_skip:\n\"\\<lbrace>\\<lambda>\\<sigma>.   exec_stop \\<sigma> \\<and> P \\<sigma>\\<rbrace> (call\\<^sub>C M A\\<^sub>1) \\<lbrace>\\<lambda>r \\<sigma>. exec_stop \\<sigma> \\<and> P \\<sigma>\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>\\<sigma>.\n                exec_stop \\<sigma> \\<and> P \\<sigma>\\<rbrace>\n    call\\<^sub>C M A\\<^sub>1\n    \\<lbrace>\\<lambda>r \\<sigma>.\n                exec_stop \\<sigma> \\<and> P \\<sigma>\\<rbrace>", "unfolding    hoare\\<^sub>3_def skip\\<^sub>S\\<^sub>E_def unit_SE_def call\\<^sub>C_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       exec_stop \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n       (case if exec_stop \\<sigma> then Some (undefined, \\<sigma>)\n             else M (A\\<^sub>1 \\<sigma>) \\<sigma> of\n        None \\<Rightarrow> False\n        | Some (x, \\<sigma>') \\<Rightarrow>\n            exec_stop \\<sigma>' \\<and> P \\<sigma>')", "by simp"], ["", "lemma if_funcall_skip:\n\"\\<lbrace>\\<lambda>\\<sigma>. exec_stop \\<sigma> \\<and> P \\<sigma>\\<rbrace>(p\\<^sub>t\\<^sub>m\\<^sub>p \\<leftarrow> call\\<^sub>C fun E ; assign_local upd (\\<lambda>\\<sigma>. p\\<^sub>t\\<^sub>m\\<^sub>p)) \\<lbrace>\\<lambda>r \\<sigma>. exec_stop \\<sigma> \\<and> P \\<sigma>\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>\\<sigma>.\n                exec_stop \\<sigma> \\<and> P \\<sigma>\\<rbrace>\n    _bind_SE p\\<^sub>t\\<^sub>m\\<^sub>p (call\\<^sub>C fun E)\n     (assign_local upd (\\<lambda>\\<sigma>. p\\<^sub>t\\<^sub>m\\<^sub>p))\n    \\<lbrace>\\<lambda>r \\<sigma>.\n                exec_stop \\<sigma> \\<and> P \\<sigma>\\<rbrace>", "unfolding    hoare\\<^sub>3_def skip\\<^sub>S\\<^sub>E_def unit_SE_def call\\<^sub>C_def assign_local_def assign_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       exec_stop \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n       (case (_bind_SE p\\<^sub>t\\<^sub>m\\<^sub>p\n               (\\<lambda>\\<sigma>.\n                   if exec_stop \\<sigma> then Some (undefined, \\<sigma>)\n                   else fun (E \\<sigma>) \\<sigma>)\n               (\\<lambda>\\<sigma>.\n                   if exec_stop \\<sigma> then Some ((), \\<sigma>)\n                   else Some\n                         ((),\n                          (upd \\<circ> map_hd)\n                           (\\<lambda>_. p\\<^sub>t\\<^sub>m\\<^sub>p)\n                           \\<sigma>)))\n              \\<sigma> of\n        None \\<Rightarrow> False\n        | Some (x, \\<sigma>') \\<Rightarrow>\n            exec_stop \\<sigma>' \\<and> P \\<sigma>')", "by (simp add: bind_SE_def)"], ["", "lemma if_funcall_skip':\n\"\\<lbrace>\\<lambda>\\<sigma>. exec_stop \\<sigma> \\<and> P \\<sigma> \\<rbrace>(p\\<^sub>t\\<^sub>m\\<^sub>p \\<leftarrow> call\\<^sub>C fun E ; assign_global upd (\\<lambda>\\<sigma>. p\\<^sub>t\\<^sub>m\\<^sub>p)) \\<lbrace>\\<lambda>r \\<sigma>. exec_stop \\<sigma> \\<and> P \\<sigma> \\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>\\<sigma>.\n                exec_stop \\<sigma> \\<and> P \\<sigma>\\<rbrace>\n    _bind_SE p\\<^sub>t\\<^sub>m\\<^sub>p (call\\<^sub>C fun E)\n     (assign_global upd (\\<lambda>\\<sigma>. p\\<^sub>t\\<^sub>m\\<^sub>p))\n    \\<lbrace>\\<lambda>r \\<sigma>.\n                exec_stop \\<sigma> \\<and> P \\<sigma>\\<rbrace>", "unfolding    hoare\\<^sub>3_def skip\\<^sub>S\\<^sub>E_def unit_SE_def call\\<^sub>C_def assign_global_def assign_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       exec_stop \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n       (case (_bind_SE p\\<^sub>t\\<^sub>m\\<^sub>p\n               (\\<lambda>\\<sigma>.\n                   if exec_stop \\<sigma> then Some (undefined, \\<sigma>)\n                   else fun (E \\<sigma>) \\<sigma>)\n               (\\<lambda>\\<sigma>.\n                   if exec_stop \\<sigma> then Some ((), \\<sigma>)\n                   else Some\n                         ((),\n                          upd (\\<lambda>_. p\\<^sub>t\\<^sub>m\\<^sub>p)\n                           \\<sigma>)))\n              \\<sigma> of\n        None \\<Rightarrow> False\n        | Some (x, \\<sigma>') \\<Rightarrow>\n            exec_stop \\<sigma>' \\<and> P \\<sigma>')", "by (simp add: bind_SE_def)"], ["", "subsection\\<open>Clean Assign Rules\\<close>"], ["", "lemma assign_global:\n  assumes * : \"\\<sharp> upd\"\n  shows \"\\<lbrace>\\<lambda>\\<sigma>. \\<not>exec_stop \\<sigma> \\<and> P (upd (\\<lambda>_. rhs \\<sigma>) \\<sigma>) \\<rbrace> \n         assign_global upd rhs \n         \\<lbrace>\\<lambda>r \\<sigma>. \\<not>exec_stop \\<sigma> \\<and> P \\<sigma> \\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>\\<sigma>.\n                \\<not> exec_stop \\<sigma> \\<and>\n                P (upd (\\<lambda>_. rhs \\<sigma>) \\<sigma>)\\<rbrace>\n    assign_global upd rhs\n    \\<lbrace>\\<lambda>r \\<sigma>.\n                \\<not> exec_stop \\<sigma> \\<and> P \\<sigma>\\<rbrace>", "unfolding    hoare\\<^sub>3_def skip\\<^sub>S\\<^sub>E_def unit_SE_def assign_global_def  assign_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<not> exec_stop \\<sigma> \\<and>\n       P (upd (\\<lambda>_. rhs \\<sigma>) \\<sigma>) \\<longrightarrow>\n       (case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n             else Some ((), upd (\\<lambda>_. rhs \\<sigma>) \\<sigma>) of\n        None \\<Rightarrow> False\n        | Some (x, \\<sigma>') \\<Rightarrow>\n            \\<not> exec_stop \\<sigma>' \\<and> P \\<sigma>')", "by(auto simp: assms)"], ["", "lemma assign_local:\n  assumes * : \"\\<sharp> (upd \\<circ> map_hd)\"\n  shows \"\\<lbrace>\\<lambda>\\<sigma>.  \\<not> exec_stop \\<sigma> \\<and> P ((upd \\<circ> map_hd) (\\<lambda>_. rhs \\<sigma>) \\<sigma>) \\<rbrace>  \n          assign_local upd rhs  \n         \\<lbrace>\\<lambda>r \\<sigma>. \\<not> exec_stop \\<sigma> \\<and> P \\<sigma> \\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>\\<sigma>.\n                \\<not> exec_stop \\<sigma> \\<and>\n                P ((upd \\<circ> map_hd) (\\<lambda>_. rhs \\<sigma>)\n                    \\<sigma>)\\<rbrace>\n    assign_local upd rhs\n    \\<lbrace>\\<lambda>r \\<sigma>.\n                \\<not> exec_stop \\<sigma> \\<and> P \\<sigma>\\<rbrace>", "unfolding    hoare\\<^sub>3_def skip\\<^sub>S\\<^sub>E_def unit_SE_def assign_local_def  assign_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<not> exec_stop \\<sigma> \\<and>\n       P ((upd \\<circ> map_hd) (\\<lambda>_. rhs \\<sigma>)\n           \\<sigma>) \\<longrightarrow>\n       (case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n             else Some\n                   ((),\n                    (upd \\<circ> map_hd) (\\<lambda>_. rhs \\<sigma>)\n                     \\<sigma>) of\n        None \\<Rightarrow> False\n        | Some (x, \\<sigma>') \\<Rightarrow>\n            \\<not> exec_stop \\<sigma>' \\<and> P \\<sigma>')", "using assms exec_stop_vs_control_independence"], ["proof (prove)\nusing this:\n  \\<sharp> (upd \\<circ> map_hd)\n  \\<sharp> ?upd \\<Longrightarrow>\n  exec_stop (?upd ?f ?\\<sigma>) = exec_stop ?\\<sigma>\n\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<not> exec_stop \\<sigma> \\<and>\n       P ((upd \\<circ> map_hd) (\\<lambda>_. rhs \\<sigma>)\n           \\<sigma>) \\<longrightarrow>\n       (case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n             else Some\n                   ((),\n                    (upd \\<circ> map_hd) (\\<lambda>_. rhs \\<sigma>)\n                     \\<sigma>) of\n        None \\<Rightarrow> False\n        | Some (x, \\<sigma>') \\<Rightarrow>\n            \\<not> exec_stop \\<sigma>' \\<and> P \\<sigma>')", "by fastforce"], ["", "lemma return_assign:\n  assumes * : \"\\<sharp> (upd \\<circ> map_hd)\"\n  shows \"\\<lbrace>\\<lambda> \\<sigma>. \\<not> exec_stop \\<sigma> \\<and> P ((upd \\<circ> map_hd) (\\<lambda>_. rhs \\<sigma>) (\\<sigma> \\<lparr> return_status := True \\<rparr>))\\<rbrace> \n          return\\<^sub>C upd rhs\n         \\<lbrace>\\<lambda>r \\<sigma>. P \\<sigma> \\<and> return_status \\<sigma> \\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>\\<sigma>.\n                \\<not> exec_stop \\<sigma> \\<and>\n                P ((upd \\<circ> map_hd) (\\<lambda>_. rhs \\<sigma>)\n                    (\\<sigma>\n                     \\<lparr>return_status := True\\<rparr>))\\<rbrace>\n    return\\<^sub>C upd rhs\n    \\<lbrace>\\<lambda>r \\<sigma>.\n                P \\<sigma> \\<and> return_status \\<sigma>\\<rbrace>", "unfolding return\\<^sub>C_def hoare\\<^sub>3_def skip\\<^sub>S\\<^sub>E_def unit_SE_def assign_local_def assign_def \n            set_return_status_def bind_SE'_def bind_SE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<not> exec_stop \\<sigma> \\<and>\n       P ((upd \\<circ> map_hd) (\\<lambda>_. rhs \\<sigma>)\n           (\\<sigma>\n            \\<lparr>return_status := True\\<rparr>)) \\<longrightarrow>\n       (case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n             else case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n                       else Some\n                             ((),\n                              (upd \\<circ> map_hd)\n                               (\\<lambda>_. rhs \\<sigma>) \\<sigma>) of\n                  None \\<Rightarrow> None\n                  | Some (uu_, \\<sigma>) \\<Rightarrow>\n                      Some\n                       ((), \\<sigma>\n                        \\<lparr>return_status := True\\<rparr>) of\n        None \\<Rightarrow> False\n        | Some (x, \\<sigma>') \\<Rightarrow>\n            P \\<sigma>' \\<and> return_status \\<sigma>')", "proof (auto)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>\\<not> exec_stop \\<sigma>;\n        P (upd (map_hd (\\<lambda>_. rhs \\<sigma>))\n            (\\<sigma>\\<lparr>return_status := True\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> P (upd (map_hd (\\<lambda>_. rhs \\<sigma>)) \\<sigma>\n                            \\<lparr>return_status := True\\<rparr>)", "fix \\<sigma> :: \"'b control_state_scheme\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>\\<not> exec_stop \\<sigma>;\n        P (upd (map_hd (\\<lambda>_. rhs \\<sigma>))\n            (\\<sigma>\\<lparr>return_status := True\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> P (upd (map_hd (\\<lambda>_. rhs \\<sigma>)) \\<sigma>\n                            \\<lparr>return_status := True\\<rparr>)", "assume a1: \"P (upd (map_hd (\\<lambda>_. rhs \\<sigma>)) (\\<sigma>\\<lparr>return_status := True\\<rparr>))\""], ["proof (state)\nthis:\n  P (upd (map_hd (\\<lambda>_. rhs \\<sigma>))\n      (\\<sigma>\\<lparr>return_status := True\\<rparr>))\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>\\<not> exec_stop \\<sigma>;\n        P (upd (map_hd (\\<lambda>_. rhs \\<sigma>))\n            (\\<sigma>\\<lparr>return_status := True\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> P (upd (map_hd (\\<lambda>_. rhs \\<sigma>)) \\<sigma>\n                            \\<lparr>return_status := True\\<rparr>)", "assume \"\\<not> exec_stop \\<sigma>\""], ["proof (state)\nthis:\n  \\<not> exec_stop \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>\\<not> exec_stop \\<sigma>;\n        P (upd (map_hd (\\<lambda>_. rhs \\<sigma>))\n            (\\<sigma>\\<lparr>return_status := True\\<rparr>))\\<rbrakk>\n       \\<Longrightarrow> P (upd (map_hd (\\<lambda>_. rhs \\<sigma>)) \\<sigma>\n                            \\<lparr>return_status := True\\<rparr>)", "show \"P (upd (map_hd (\\<lambda>_. rhs \\<sigma>)) \\<sigma>\\<lparr>return_status := True\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (upd (map_hd (\\<lambda>_. rhs \\<sigma>)) \\<sigma>\n       \\<lparr>return_status := True\\<rparr>)", "using a1 assms exec_stop_vs_control_independence'"], ["proof (prove)\nusing this:\n  P (upd (map_hd (\\<lambda>_. rhs \\<sigma>))\n      (\\<sigma>\\<lparr>return_status := True\\<rparr>))\n  \\<sharp> (upd \\<circ> map_hd)\n  \\<sharp> ?upd \\<Longrightarrow>\n  ?upd ?f (?\\<sigma>\\<lparr>return_status := ?b\\<rparr>) = ?upd ?f ?\\<sigma>\n  \\<lparr>return_status := ?b\\<rparr>\n\ngoal (1 subgoal):\n 1. P (upd (map_hd (\\<lambda>_. rhs \\<sigma>)) \\<sigma>\n       \\<lparr>return_status := True\\<rparr>)", "by fastforce"], ["proof (state)\nthis:\n  P (upd (map_hd (\\<lambda>_. rhs \\<sigma>)) \\<sigma>\n     \\<lparr>return_status := True\\<rparr>)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* do we need independence of rhs ? Not really. 'Normal' programs would never\n     be control-state dependent, and 'artificial' ones would still be correct ...*)"], ["", "subsection\\<open>Clean Construct Rules\\<close>"], ["", "lemma cond_clean : \n  \"    \\<lbrace>\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> P \\<sigma> \\<and> cond \\<sigma>\\<rbrace> M \\<lbrace>Q\\<rbrace>\n   \\<Longrightarrow> \\<lbrace>\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> P \\<sigma> \\<and> \\<not> cond \\<sigma>\\<rbrace> M' \\<lbrace>Q\\<rbrace>  \n   \\<Longrightarrow> \\<lbrace>\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> P \\<sigma>\\<rbrace> if\\<^sub>C cond then M else M' fi\\<lbrace>Q\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<lbrace>\\<lambda>\\<sigma>.\n                         \\<not> exec_stop \\<sigma> \\<and>\n                         P \\<sigma> \\<and> cond \\<sigma>\\<rbrace>\n             M \\<lbrace>Q\\<rbrace>;\n     \\<lbrace>\\<lambda>\\<sigma>.\n                 \\<not> exec_stop \\<sigma> \\<and>\n                 P \\<sigma> \\<and> \\<not> cond \\<sigma>\\<rbrace>\n     M' \\<lbrace>Q\\<rbrace>\\<rbrakk>\n    \\<Longrightarrow> \\<lbrace>\\<lambda>\\<sigma>.\n                                  \\<not> exec_stop \\<sigma> \\<and>\n                                  P \\<sigma>\\<rbrace>\n                      _if_SECLEAN cond M M' \\<lbrace>Q\\<rbrace>", "unfolding hoare\\<^sub>3_def hoare\\<^sub>3'_def bind_SE_def if_SE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<forall>\\<sigma>.\n                \\<not> exec_stop \\<sigma> \\<and>\n                P \\<sigma> \\<and> cond \\<sigma> \\<longrightarrow>\n                (case M \\<sigma> of None \\<Rightarrow> False\n                 | Some (x, \\<sigma>') \\<Rightarrow> Q x \\<sigma>');\n     \\<forall>\\<sigma>.\n        \\<not> exec_stop \\<sigma> \\<and>\n        P \\<sigma> \\<and> \\<not> cond \\<sigma> \\<longrightarrow>\n        (case M' \\<sigma> of None \\<Rightarrow> False\n         | Some (x, \\<sigma>') \\<Rightarrow> Q x \\<sigma>')\\<rbrakk>\n    \\<Longrightarrow> \\<forall>\\<sigma>.\n                         \\<not> exec_stop \\<sigma> \\<and>\n                         P \\<sigma> \\<longrightarrow>\n                         (case (_if_SECLEAN cond M M') \\<sigma> of\n                          None \\<Rightarrow> False\n                          | Some (x, \\<sigma>') \\<Rightarrow> Q x \\<sigma>')", "by (simp add: if_C_def)"], ["", "text\\<open>There is a particular difficulty with a verification of (terminating) while rules\nin a Hoare-logic for a language involving break. The first is, that break is not used\nin the toplevel of a body of a loop (there might be breaks inside an inner loop, though).\nThis scheme is covered by the rule below, which is a generalisation of the classical \nwhile loop (as presented by @{thm while}.\\<close>"], ["", "lemma while_clean_no_break :\n  assumes  * : \"\\<lbrace>\\<lambda>\\<sigma>. \\<not> break_status \\<sigma> \\<and> cond \\<sigma> \\<and> P \\<sigma>\\<rbrace>  M \\<lbrace>\\<lambda>_. \\<lambda>\\<sigma>.  \\<not> break_status \\<sigma> \\<and> P \\<sigma> \\<rbrace>\"\n  and measure: \"\\<forall>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> cond \\<sigma> \\<and> P \\<sigma> \n                    \\<longrightarrow> M \\<sigma> \\<noteq> None \\<and> f(snd(the(M \\<sigma>))) < ((f \\<sigma>)::nat) \"\n               (is \"\\<forall>\\<sigma>. _ \\<and> cond \\<sigma> \\<and> P \\<sigma> \\<longrightarrow> ?decrease \\<sigma>\")\n  shows        \"\\<lbrace>\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> P \\<sigma>\\<rbrace> \n                while\\<^sub>C cond do M od \n                \\<lbrace>\\<lambda>_ \\<sigma>. (return_status \\<sigma> \\<or> \\<not> cond \\<sigma>) \\<and> \\<not> break_status \\<sigma> \\<and> P \\<sigma>\\<rbrace>\"\n                (is \"\\<lbrace>?pre\\<rbrace> while\\<^sub>C cond do M od \\<lbrace>\\<lambda>_ \\<sigma>. ?post1 \\<sigma> \\<and> ?post2 \\<sigma>\\<rbrace>\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>\\<sigma>.\n                \\<not> exec_stop \\<sigma> \\<and> P \\<sigma>\\<rbrace>\n    _while_C cond M\n    \\<lbrace>\\<lambda>_ \\<sigma>.\n                (return_status \\<sigma> \\<or> \\<not> cond \\<sigma>) \\<and>\n                \\<not> break_status \\<sigma> \\<and> P \\<sigma>\\<rbrace>", "unfolding while_C_def hoare\\<^sub>3_def hoare\\<^sub>3'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<not> exec_stop \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n       (case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n             else (_while_SE\n                    (\\<lambda>\\<sigma>.\n                        \\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>)\n                    M ;-\n                   unset_break_status)\n                   \\<sigma> of\n        None \\<Rightarrow> False\n        | Some (x, \\<sigma>') \\<Rightarrow>\n            (return_status \\<sigma>' \\<or> \\<not> cond \\<sigma>') \\<and>\n            \\<not> break_status \\<sigma>' \\<and> P \\<sigma>')", "proof (simp add: hoare\\<^sub>3_def[symmetric],rule sequence')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrace>\\<lambda>\\<sigma>.\n                \\<not> exec_stop \\<sigma> \\<and> P \\<sigma>\\<rbrace>\n    _while_SE\n     (\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) M\n    \\<lbrace>\\<lambda>_. ?Q6\\<rbrace>\n 2. \\<lbrace>?Q6\\<rbrace> unset_break_status\n    \\<lbrace>\\<lambda>x \\<sigma>'.\n                (return_status \\<sigma>' \\<or> \\<not> cond \\<sigma>') \\<and>\n                \\<not> break_status \\<sigma>' \\<and> P \\<sigma>'\\<rbrace>", "show \"\\<lbrace>?pre\\<rbrace> \n          while\\<^sub>S\\<^sub>E (\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) do M od\n          \\<lbrace>\\<lambda>_ \\<sigma>. \\<not> (\\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) \\<and> \\<not> break_status \\<sigma> \\<and> P \\<sigma>\\<rbrace>\"\n          (is \"\\<lbrace>?pre\\<rbrace> while\\<^sub>S\\<^sub>E ?cond' do M od \\<lbrace>\\<lambda>_ \\<sigma>. \\<not> ( ?cond' \\<sigma>) \\<and> ?post2 \\<sigma>\\<rbrace>\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>\\<sigma>.\n                \\<not> exec_stop \\<sigma> \\<and> P \\<sigma>\\<rbrace>\n    _while_SE\n     (\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) M\n    \\<lbrace>\\<lambda>_ \\<sigma>.\n                \\<not> (\\<not> exec_stop \\<sigma> \\<and>\n                        cond \\<sigma>) \\<and>\n                \\<not> break_status \\<sigma> \\<and> P \\<sigma>\\<rbrace>", "proof (rule consequence_unit)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<sigma>.\n       \\<not> exec_stop \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n       ?P' \\<sigma>\n 2. \\<lbrace>?P'\\<rbrace>\n    _while_SE\n     (\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) M\n    \\<lbrace>\\<lambda>_. ?Q'\\<rbrace>\n 3. \\<And>\\<sigma>.\n       ?Q' \\<sigma> \\<longrightarrow>\n       \\<not> (\\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) \\<and>\n       \\<not> break_status \\<sigma> \\<and> P \\<sigma>", "fix \\<sigma>"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<sigma>.\n       \\<not> exec_stop \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n       ?P' \\<sigma>\n 2. \\<lbrace>?P'\\<rbrace>\n    _while_SE\n     (\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) M\n    \\<lbrace>\\<lambda>_. ?Q'\\<rbrace>\n 3. \\<And>\\<sigma>.\n       ?Q' \\<sigma> \\<longrightarrow>\n       \\<not> (\\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) \\<and>\n       \\<not> break_status \\<sigma> \\<and> P \\<sigma>", "show \" ?pre \\<sigma> \\<longrightarrow> ?post2 \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> exec_stop \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n    \\<not> break_status \\<sigma> \\<and> P \\<sigma>", "using exec_stop1"], ["proof (prove)\nusing this:\n  break_status ?\\<sigma> \\<Longrightarrow> exec_stop ?\\<sigma>\n\ngoal (1 subgoal):\n 1. \\<not> exec_stop \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n    \\<not> break_status \\<sigma> \\<and> P \\<sigma>", "by blast"], ["proof (state)\nthis:\n  \\<not> exec_stop \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n  \\<not> break_status \\<sigma> \\<and> P \\<sigma>\n\ngoal (2 subgoals):\n 1. \\<lbrace>\\<lambda>\\<sigma>.\n                \\<not> break_status \\<sigma> \\<and> P \\<sigma>\\<rbrace>\n    _while_SE\n     (\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) M\n    \\<lbrace>\\<lambda>_. ?Q'\\<rbrace>\n 2. \\<And>\\<sigma>.\n       ?Q' \\<sigma> \\<longrightarrow>\n       \\<not> (\\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) \\<and>\n       \\<not> break_status \\<sigma> \\<and> P \\<sigma>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrace>\\<lambda>\\<sigma>.\n                \\<not> break_status \\<sigma> \\<and> P \\<sigma>\\<rbrace>\n    _while_SE\n     (\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) M\n    \\<lbrace>\\<lambda>_. ?Q'\\<rbrace>\n 2. \\<And>\\<sigma>.\n       ?Q' \\<sigma> \\<longrightarrow>\n       \\<not> (\\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) \\<and>\n       \\<not> break_status \\<sigma> \\<and> P \\<sigma>", "show \"\\<lbrace>?post2\\<rbrace>while\\<^sub>S\\<^sub>E ?cond' do M od\\<lbrace>\\<lambda>x \\<sigma>. \\<not>(?cond' \\<sigma>) \\<and> ?post2 \\<sigma>\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>\\<sigma>.\n                \\<not> break_status \\<sigma> \\<and> P \\<sigma>\\<rbrace>\n    _while_SE\n     (\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) M\n    \\<lbrace>\\<lambda>x \\<sigma>.\n                \\<not> (\\<not> exec_stop \\<sigma> \\<and>\n                        cond \\<sigma>) \\<and>\n                \\<not> break_status \\<sigma> \\<and> P \\<sigma>\\<rbrace>", "proof (rule_tac f = \"f\" in while, rule consequence_unit)"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>\\<sigma>.\n       (\\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) \\<and>\n       \\<not> break_status \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n       ?P'1 \\<sigma>\n 2. \\<lbrace>?P'1\\<rbrace> M \\<lbrace>\\<lambda>_. ?Q'1\\<rbrace>\n 3. \\<And>\\<sigma>.\n       ?Q'1 \\<sigma> \\<longrightarrow>\n       \\<not> break_status \\<sigma> \\<and> P \\<sigma>\n 4. \\<forall>\\<sigma>.\n       (\\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) \\<and>\n       \\<not> break_status \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n       M \\<sigma> \\<noteq> None \\<and>\n       f (snd (the (M \\<sigma>))) < f \\<sigma>", "fix \\<sigma>"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>\\<sigma>.\n       (\\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) \\<and>\n       \\<not> break_status \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n       ?P'1 \\<sigma>\n 2. \\<lbrace>?P'1\\<rbrace> M \\<lbrace>\\<lambda>_. ?Q'1\\<rbrace>\n 3. \\<And>\\<sigma>.\n       ?Q'1 \\<sigma> \\<longrightarrow>\n       \\<not> break_status \\<sigma> \\<and> P \\<sigma>\n 4. \\<forall>\\<sigma>.\n       (\\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) \\<and>\n       \\<not> break_status \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n       M \\<sigma> \\<noteq> None \\<and>\n       f (snd (the (M \\<sigma>))) < f \\<sigma>", "show \"?cond' \\<sigma> \\<and> ?post2 \\<sigma> \\<longrightarrow> \\<not>break_status \\<sigma> \\<and> cond \\<sigma> \\<and> P \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) \\<and>\n    \\<not> break_status \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n    \\<not> break_status \\<sigma> \\<and> cond \\<sigma> \\<and> P \\<sigma>", "by simp"], ["proof (state)\nthis:\n  (\\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) \\<and>\n  \\<not> break_status \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n  \\<not> break_status \\<sigma> \\<and> cond \\<sigma> \\<and> P \\<sigma>\n\ngoal (3 subgoals):\n 1. \\<lbrace>\\<lambda>\\<sigma>.\n                \\<not> break_status \\<sigma> \\<and>\n                cond \\<sigma> \\<and> P \\<sigma>\\<rbrace>\n    M \\<lbrace>\\<lambda>_. ?Q'1\\<rbrace>\n 2. \\<And>\\<sigma>.\n       ?Q'1 \\<sigma> \\<longrightarrow>\n       \\<not> break_status \\<sigma> \\<and> P \\<sigma>\n 3. \\<forall>\\<sigma>.\n       (\\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) \\<and>\n       \\<not> break_status \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n       M \\<sigma> \\<noteq> None \\<and>\n       f (snd (the (M \\<sigma>))) < f \\<sigma>", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<lbrace>\\<lambda>\\<sigma>.\n                \\<not> break_status \\<sigma> \\<and>\n                cond \\<sigma> \\<and> P \\<sigma>\\<rbrace>\n    M \\<lbrace>\\<lambda>_. ?Q'1\\<rbrace>\n 2. \\<And>\\<sigma>.\n       ?Q'1 \\<sigma> \\<longrightarrow>\n       \\<not> break_status \\<sigma> \\<and> P \\<sigma>\n 3. \\<forall>\\<sigma>.\n       (\\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) \\<and>\n       \\<not> break_status \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n       M \\<sigma> \\<noteq> None \\<and>\n       f (snd (the (M \\<sigma>))) < f \\<sigma>", "show \"\\<lbrace>\\<lambda>\\<sigma>. \\<not> break_status \\<sigma> \\<and> cond \\<sigma> \\<and> P \\<sigma>\\<rbrace> M \\<lbrace>\\<lambda>x \\<sigma>. ?post2 \\<sigma>\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>\\<sigma>.\n                \\<not> break_status \\<sigma> \\<and>\n                cond \\<sigma> \\<and> P \\<sigma>\\<rbrace>\n    M \\<lbrace>\\<lambda>x \\<sigma>.\n                  \\<not> break_status \\<sigma> \\<and> P \\<sigma>\\<rbrace>", "using \"*\""], ["proof (prove)\nusing this:\n  \\<lbrace>\\<lambda>\\<sigma>.\n              \\<not> break_status \\<sigma> \\<and>\n              cond \\<sigma> \\<and> P \\<sigma>\\<rbrace>\n  M \\<lbrace>\\<lambda>_ \\<sigma>.\n                \\<not> break_status \\<sigma> \\<and> P \\<sigma>\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>\\<sigma>.\n                \\<not> break_status \\<sigma> \\<and>\n                cond \\<sigma> \\<and> P \\<sigma>\\<rbrace>\n    M \\<lbrace>\\<lambda>x \\<sigma>.\n                  \\<not> break_status \\<sigma> \\<and> P \\<sigma>\\<rbrace>", "by blast"], ["proof (state)\nthis:\n  \\<lbrace>\\<lambda>\\<sigma>.\n              \\<not> break_status \\<sigma> \\<and>\n              cond \\<sigma> \\<and> P \\<sigma>\\<rbrace>\n  M \\<lbrace>\\<lambda>x \\<sigma>.\n                \\<not> break_status \\<sigma> \\<and> P \\<sigma>\\<rbrace>\n\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       \\<not> break_status \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n       \\<not> break_status \\<sigma> \\<and> P \\<sigma>\n 2. \\<forall>\\<sigma>.\n       (\\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) \\<and>\n       \\<not> break_status \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n       M \\<sigma> \\<noteq> None \\<and>\n       f (snd (the (M \\<sigma>))) < f \\<sigma>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       \\<not> break_status \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n       \\<not> break_status \\<sigma> \\<and> P \\<sigma>\n 2. \\<forall>\\<sigma>.\n       (\\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) \\<and>\n       \\<not> break_status \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n       M \\<sigma> \\<noteq> None \\<and>\n       f (snd (the (M \\<sigma>))) < f \\<sigma>", "fix \\<sigma>"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       \\<not> break_status \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n       \\<not> break_status \\<sigma> \\<and> P \\<sigma>\n 2. \\<forall>\\<sigma>.\n       (\\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) \\<and>\n       \\<not> break_status \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n       M \\<sigma> \\<noteq> None \\<and>\n       f (snd (the (M \\<sigma>))) < f \\<sigma>", "show \"?post2 \\<sigma> \\<longrightarrow> ?post2 \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> break_status \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n    \\<not> break_status \\<sigma> \\<and> P \\<sigma>", "by blast"], ["proof (state)\nthis:\n  \\<not> break_status \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n  \\<not> break_status \\<sigma> \\<and> P \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       (\\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) \\<and>\n       \\<not> break_status \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n       M \\<sigma> \\<noteq> None \\<and>\n       f (snd (the (M \\<sigma>))) < f \\<sigma>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       (\\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) \\<and>\n       \\<not> break_status \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n       M \\<sigma> \\<noteq> None \\<and>\n       f (snd (the (M \\<sigma>))) < f \\<sigma>", "show \"\\<forall>\\<sigma>.?cond' \\<sigma> \\<and> ?post2 \\<sigma> \\<longrightarrow> ?decrease \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       (\\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) \\<and>\n       \\<not> break_status \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n       M \\<sigma> \\<noteq> None \\<and>\n       f (snd (the (M \\<sigma>))) < f \\<sigma>", "using measure"], ["proof (prove)\nusing this:\n  \\<forall>\\<sigma>.\n     \\<not> exec_stop \\<sigma> \\<and>\n     cond \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n     M \\<sigma> \\<noteq> None \\<and> f (snd (the (M \\<sigma>))) < f \\<sigma>\n\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       (\\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) \\<and>\n       \\<not> break_status \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n       M \\<sigma> \\<noteq> None \\<and>\n       f (snd (the (M \\<sigma>))) < f \\<sigma>", "by blast"], ["proof (state)\nthis:\n  \\<forall>\\<sigma>.\n     (\\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) \\<and>\n     \\<not> break_status \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n     M \\<sigma> \\<noteq> None \\<and> f (snd (the (M \\<sigma>))) < f \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrace>\\<lambda>\\<sigma>.\n              \\<not> break_status \\<sigma> \\<and> P \\<sigma>\\<rbrace>\n  _while_SE\n   (\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) M\n  \\<lbrace>\\<lambda>x \\<sigma>.\n              \\<not> (\\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) \\<and>\n              \\<not> break_status \\<sigma> \\<and> P \\<sigma>\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<not> (\\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) \\<and>\n       \\<not> break_status \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n       \\<not> (\\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) \\<and>\n       \\<not> break_status \\<sigma> \\<and> P \\<sigma>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<not> (\\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) \\<and>\n       \\<not> break_status \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n       \\<not> (\\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) \\<and>\n       \\<not> break_status \\<sigma> \\<and> P \\<sigma>", "fix \\<sigma>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       \\<not> (\\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) \\<and>\n       \\<not> break_status \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n       \\<not> (\\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) \\<and>\n       \\<not> break_status \\<sigma> \\<and> P \\<sigma>", "show \" \\<not>?cond' \\<sigma> \\<and> ?post2 \\<sigma> \\<longrightarrow> \\<not>?cond' \\<sigma> \\<and> ?post2 \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) \\<and>\n    \\<not> break_status \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n    \\<not> (\\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) \\<and>\n    \\<not> break_status \\<sigma> \\<and> P \\<sigma>", "by blast"], ["proof (state)\nthis:\n  \\<not> (\\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) \\<and>\n  \\<not> break_status \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n  \\<not> (\\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) \\<and>\n  \\<not> break_status \\<sigma> \\<and> P \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrace>\\<lambda>\\<sigma>.\n              \\<not> exec_stop \\<sigma> \\<and> P \\<sigma>\\<rbrace>\n  _while_SE\n   (\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) M\n  \\<lbrace>\\<lambda>_ \\<sigma>.\n              \\<not> (\\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) \\<and>\n              \\<not> break_status \\<sigma> \\<and> P \\<sigma>\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>\\<sigma>.\n                \\<not> (\\<not> exec_stop \\<sigma> \\<and>\n                        cond \\<sigma>) \\<and>\n                \\<not> break_status \\<sigma> \\<and> P \\<sigma>\\<rbrace>\n    unset_break_status\n    \\<lbrace>\\<lambda>x \\<sigma>'.\n                (return_status \\<sigma>' \\<or> \\<not> cond \\<sigma>') \\<and>\n                \\<not> break_status \\<sigma>' \\<and> P \\<sigma>'\\<rbrace>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>\\<sigma>.\n                \\<not> (\\<not> exec_stop \\<sigma> \\<and>\n                        cond \\<sigma>) \\<and>\n                \\<not> break_status \\<sigma> \\<and> P \\<sigma>\\<rbrace>\n    unset_break_status\n    \\<lbrace>\\<lambda>x \\<sigma>'.\n                (return_status \\<sigma>' \\<or> \\<not> cond \\<sigma>') \\<and>\n                \\<not> break_status \\<sigma>' \\<and> P \\<sigma>'\\<rbrace>", "show \"\\<lbrace>\\<lambda>\\<sigma>. \\<not> (\\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) \\<and> ?post2 \\<sigma>\\<rbrace> unset_break_status\n          \\<lbrace>\\<lambda>_ \\<sigma>'. (return_status \\<sigma>' \\<or> \\<not> cond \\<sigma>') \\<and> ?post2 \\<sigma>'\\<rbrace>\"\n         (is \"\\<lbrace>\\<lambda>\\<sigma>. \\<not> (?cond'' \\<sigma>) \\<and> ?post2 \\<sigma>\\<rbrace> unset_break_status \\<lbrace>\\<lambda>_ \\<sigma>'. ?post3 \\<sigma>' \\<and> ?post2 \\<sigma>' \\<rbrace>\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>\\<sigma>.\n                \\<not> (\\<not> exec_stop \\<sigma> \\<and>\n                        cond \\<sigma>) \\<and>\n                \\<not> break_status \\<sigma> \\<and> P \\<sigma>\\<rbrace>\n    unset_break_status\n    \\<lbrace>\\<lambda>_ \\<sigma>'.\n                (return_status \\<sigma>' \\<or> \\<not> cond \\<sigma>') \\<and>\n                \\<not> break_status \\<sigma>' \\<and> P \\<sigma>'\\<rbrace>", "proof (rule consequence_unit)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<sigma>'.\n       \\<not> (\\<not> exec_stop \\<sigma>' \\<and> cond \\<sigma>') \\<and>\n       \\<not> break_status \\<sigma>' \\<and> P \\<sigma>' \\<longrightarrow>\n       ?P' \\<sigma>'\n 2. \\<lbrace>?P'\\<rbrace> unset_break_status\n    \\<lbrace>\\<lambda>_. ?Q'\\<rbrace>\n 3. \\<And>\\<sigma>'.\n       ?Q' \\<sigma>' \\<longrightarrow>\n       (return_status \\<sigma>' \\<or> \\<not> cond \\<sigma>') \\<and>\n       \\<not> break_status \\<sigma>' \\<and> P \\<sigma>'", "fix \\<sigma>"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>\\<sigma>'.\n       \\<not> (\\<not> exec_stop \\<sigma>' \\<and> cond \\<sigma>') \\<and>\n       \\<not> break_status \\<sigma>' \\<and> P \\<sigma>' \\<longrightarrow>\n       ?P' \\<sigma>'\n 2. \\<lbrace>?P'\\<rbrace> unset_break_status\n    \\<lbrace>\\<lambda>_. ?Q'\\<rbrace>\n 3. \\<And>\\<sigma>'.\n       ?Q' \\<sigma>' \\<longrightarrow>\n       (return_status \\<sigma>' \\<or> \\<not> cond \\<sigma>') \\<and>\n       \\<not> break_status \\<sigma>' \\<and> P \\<sigma>'", "show \"\\<not> ?cond'' \\<sigma> \\<and> ?post2 \\<sigma> \\<longrightarrow> (\\<lambda>\\<sigma>. P \\<sigma> \\<and> ?post3 \\<sigma>) (\\<sigma>\\<lparr>break_status := False\\<rparr>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> (\\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) \\<and>\n    \\<not> break_status \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n    P (\\<sigma>\\<lparr>break_status := False\\<rparr>) \\<and>\n    (return_status (\\<sigma>\\<lparr>break_status := False\\<rparr>) \\<or>\n     \\<not> cond (\\<sigma>\\<lparr>break_status := False\\<rparr>))", "by (metis (full_types) exec_stop_def surjective update_convs(1))"], ["proof (state)\nthis:\n  \\<not> (\\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) \\<and>\n  \\<not> break_status \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n  P (\\<sigma>\\<lparr>break_status := False\\<rparr>) \\<and>\n  (return_status (\\<sigma>\\<lparr>break_status := False\\<rparr>) \\<or>\n   \\<not> cond (\\<sigma>\\<lparr>break_status := False\\<rparr>))\n\ngoal (2 subgoals):\n 1. \\<lbrace>\\<lambda>\\<sigma>'.\n                P (\\<sigma>'\\<lparr>break_status := False\\<rparr>) \\<and>\n                (return_status\n                  (\\<sigma>'\\<lparr>break_status := False\\<rparr>) \\<or>\n                 \\<not> cond\n                         (\\<sigma>'\n                          \\<lparr>break_status := False\\<rparr>))\\<rbrace>\n    unset_break_status \\<lbrace>\\<lambda>_. ?Q'\\<rbrace>\n 2. \\<And>\\<sigma>'.\n       ?Q' \\<sigma>' \\<longrightarrow>\n       (return_status \\<sigma>' \\<or> \\<not> cond \\<sigma>') \\<and>\n       \\<not> break_status \\<sigma>' \\<and> P \\<sigma>'", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrace>\\<lambda>\\<sigma>'.\n                P (\\<sigma>'\\<lparr>break_status := False\\<rparr>) \\<and>\n                (return_status\n                  (\\<sigma>'\\<lparr>break_status := False\\<rparr>) \\<or>\n                 \\<not> cond\n                         (\\<sigma>'\n                          \\<lparr>break_status := False\\<rparr>))\\<rbrace>\n    unset_break_status \\<lbrace>\\<lambda>_. ?Q'\\<rbrace>\n 2. \\<And>\\<sigma>'.\n       ?Q' \\<sigma>' \\<longrightarrow>\n       (return_status \\<sigma>' \\<or> \\<not> cond \\<sigma>') \\<and>\n       \\<not> break_status \\<sigma>' \\<and> P \\<sigma>'", "show \"\\<lbrace>\\<lambda>\\<sigma>. (\\<lambda>\\<sigma>. P \\<sigma> \\<and> ?post3 \\<sigma>) (\\<sigma>\\<lparr>break_status := False\\<rparr>)\\<rbrace>\n              unset_break_status \n              \\<lbrace>\\<lambda>x \\<sigma>. ?post3 \\<sigma> \\<and> \\<not> break_status \\<sigma> \\<and> P \\<sigma>\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>\\<sigma>.\n                P (\\<sigma>\\<lparr>break_status := False\\<rparr>) \\<and>\n                (return_status\n                  (\\<sigma>\\<lparr>break_status := False\\<rparr>) \\<or>\n                 \\<not> cond\n                         (\\<sigma>\n                          \\<lparr>break_status := False\\<rparr>))\\<rbrace>\n    unset_break_status\n    \\<lbrace>\\<lambda>x \\<sigma>.\n                (return_status \\<sigma> \\<or> \\<not> cond \\<sigma>) \\<and>\n                \\<not> break_status \\<sigma> \\<and> P \\<sigma>\\<rbrace>", "apply(subst (2) conj_commute,subst conj_assoc,subst (2) conj_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>\\<sigma>.\n                P (\\<sigma>\\<lparr>break_status := False\\<rparr>) \\<and>\n                (return_status\n                  (\\<sigma>\\<lparr>break_status := False\\<rparr>) \\<or>\n                 \\<not> cond\n                         (\\<sigma>\n                          \\<lparr>break_status := False\\<rparr>))\\<rbrace>\n    unset_break_status\n    \\<lbrace>\\<lambda>x \\<sigma>.\n                (P \\<sigma> \\<and>\n                 (return_status \\<sigma> \\<or> \\<not> cond \\<sigma>)) \\<and>\n                \\<not> break_status \\<sigma>\\<rbrace>", "by(rule unset_break1)"], ["proof (state)\nthis:\n  \\<lbrace>\\<lambda>\\<sigma>.\n              P (\\<sigma>\\<lparr>break_status := False\\<rparr>) \\<and>\n              (return_status\n                (\\<sigma>\\<lparr>break_status := False\\<rparr>) \\<or>\n               \\<not> cond\n                       (\\<sigma>\n                        \\<lparr>break_status := False\\<rparr>))\\<rbrace>\n  unset_break_status\n  \\<lbrace>\\<lambda>x \\<sigma>.\n              (return_status \\<sigma> \\<or> \\<not> cond \\<sigma>) \\<and>\n              \\<not> break_status \\<sigma> \\<and> P \\<sigma>\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>'.\n       (return_status \\<sigma>' \\<or> \\<not> cond \\<sigma>') \\<and>\n       \\<not> break_status \\<sigma>' \\<and> P \\<sigma>' \\<longrightarrow>\n       (return_status \\<sigma>' \\<or> \\<not> cond \\<sigma>') \\<and>\n       \\<not> break_status \\<sigma>' \\<and> P \\<sigma>'", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>'.\n       (return_status \\<sigma>' \\<or> \\<not> cond \\<sigma>') \\<and>\n       \\<not> break_status \\<sigma>' \\<and> P \\<sigma>' \\<longrightarrow>\n       (return_status \\<sigma>' \\<or> \\<not> cond \\<sigma>') \\<and>\n       \\<not> break_status \\<sigma>' \\<and> P \\<sigma>'", "fix \\<sigma>"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>'.\n       (return_status \\<sigma>' \\<or> \\<not> cond \\<sigma>') \\<and>\n       \\<not> break_status \\<sigma>' \\<and> P \\<sigma>' \\<longrightarrow>\n       (return_status \\<sigma>' \\<or> \\<not> cond \\<sigma>') \\<and>\n       \\<not> break_status \\<sigma>' \\<and> P \\<sigma>'", "show  \"?post3 \\<sigma> \\<and> ?post2 \\<sigma> \\<longrightarrow> ?post3 \\<sigma> \\<and> ?post2 \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (return_status \\<sigma> \\<or> \\<not> cond \\<sigma>) \\<and>\n    \\<not> break_status \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n    (return_status \\<sigma> \\<or> \\<not> cond \\<sigma>) \\<and>\n    \\<not> break_status \\<sigma> \\<and> P \\<sigma>", "by simp"], ["proof (state)\nthis:\n  (return_status \\<sigma> \\<or> \\<not> cond \\<sigma>) \\<and>\n  \\<not> break_status \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n  (return_status \\<sigma> \\<or> \\<not> cond \\<sigma>) \\<and>\n  \\<not> break_status \\<sigma> \\<and> P \\<sigma>\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrace>\\<lambda>\\<sigma>.\n              \\<not> (\\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) \\<and>\n              \\<not> break_status \\<sigma> \\<and> P \\<sigma>\\<rbrace>\n  unset_break_status\n  \\<lbrace>\\<lambda>_ \\<sigma>'.\n              (return_status \\<sigma>' \\<or> \\<not> cond \\<sigma>') \\<and>\n              \\<not> break_status \\<sigma>' \\<and> P \\<sigma>'\\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>In the following we present a version allowing a break inside the body, which implies that the \n     invariant has been established at the break-point and the condition is irrelevant. \n     A return may occur, but the @{term \"break_status\"} is guaranteed to be true\n     after leaving the loop.\\<close>"], ["", "lemma while_clean':\n  assumes  M_inv   : \"\\<lbrace>\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> cond \\<sigma> \\<and> P \\<sigma>\\<rbrace>  M \\<lbrace>\\<lambda>_. P\\<rbrace>\"\n  and cond_idpc    : \"\\<forall>x \\<sigma>.  (cond (\\<sigma>\\<lparr>break_status := x\\<rparr>)) = cond \\<sigma> \"\n  and inv_idpc     : \"\\<forall>x \\<sigma>.  (P (\\<sigma>\\<lparr>break_status := x\\<rparr>)) = P \\<sigma> \"\n  and f_is_measure : \"\\<forall>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> cond \\<sigma> \\<and> P \\<sigma> \\<longrightarrow> \n                       M \\<sigma> \\<noteq> None \\<and> f(snd(the(M \\<sigma>))) < ((f \\<sigma>)::nat) \"\nshows    \"\\<lbrace>\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> P \\<sigma>\\<rbrace> \n          while\\<^sub>C cond do M od \n          \\<lbrace>\\<lambda>_ \\<sigma>.  \\<not> break_status \\<sigma> \\<and> P \\<sigma>\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>\\<sigma>.\n                \\<not> exec_stop \\<sigma> \\<and> P \\<sigma>\\<rbrace>\n    _while_C cond M\n    \\<lbrace>\\<lambda>_ \\<sigma>.\n                \\<not> break_status \\<sigma> \\<and> P \\<sigma>\\<rbrace>", "unfolding while_C_def hoare\\<^sub>3_def hoare\\<^sub>3'_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>\\<sigma>.\n       \\<not> exec_stop \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n       (case if exec_stop \\<sigma> then Some ((), \\<sigma>)\n             else (_while_SE\n                    (\\<lambda>\\<sigma>.\n                        \\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>)\n                    M ;-\n                   unset_break_status)\n                   \\<sigma> of\n        None \\<Rightarrow> False\n        | Some (x, \\<sigma>') \\<Rightarrow>\n            \\<not> break_status \\<sigma>' \\<and> P \\<sigma>')", "proof (simp add: hoare\\<^sub>3_def[symmetric], rule sequence')"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrace>\\<lambda>\\<sigma>.\n                \\<not> exec_stop \\<sigma> \\<and> P \\<sigma>\\<rbrace>\n    _while_SE\n     (\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) M\n    \\<lbrace>\\<lambda>_. ?Q6\\<rbrace>\n 2. \\<lbrace>?Q6\\<rbrace> unset_break_status\n    \\<lbrace>\\<lambda>x \\<sigma>'.\n                \\<not> break_status \\<sigma>' \\<and> P \\<sigma>'\\<rbrace>", "show \"\\<lbrace>\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> P \\<sigma>\\<rbrace> \n            while\\<^sub>S\\<^sub>E (\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) do M od\n          \\<lbrace>\\<lambda>_ \\<sigma>. P (\\<sigma>\\<lparr>break_status := False\\<rparr>)\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>\\<sigma>.\n                \\<not> exec_stop \\<sigma> \\<and> P \\<sigma>\\<rbrace>\n    _while_SE\n     (\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) M\n    \\<lbrace>\\<lambda>_ \\<sigma>.\n                P (\\<sigma>\\<lparr>break_status := False\\<rparr>)\\<rbrace>", "apply(rule consequence_unit, rule impI, erule conjunct2)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<lbrace>P\\<rbrace>\n    _while_SE\n     (\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) M\n    \\<lbrace>\\<lambda>_. ?Q'\\<rbrace>\n 2. \\<And>\\<sigma>.\n       ?Q' \\<sigma> \\<longrightarrow>\n       P (\\<sigma>\\<lparr>break_status := False\\<rparr>)", "apply(rule_tac f = \"f\" in while)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<lbrace>\\<lambda>\\<sigma>.\n                (\\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) \\<and>\n                P \\<sigma>\\<rbrace>\n    M \\<lbrace>\\<lambda>_. P\\<rbrace>\n 2. \\<forall>\\<sigma>.\n       (\\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) \\<and>\n       P \\<sigma> \\<longrightarrow>\n       M \\<sigma> \\<noteq> None \\<and>\n       f (snd (the (M \\<sigma>))) < f \\<sigma>\n 3. \\<And>\\<sigma>.\n       \\<not> (\\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) \\<and>\n       P \\<sigma> \\<longrightarrow>\n       P (\\<sigma>\\<lparr>break_status := False\\<rparr>)", "using M_inv f_is_measure inv_idpc"], ["proof (prove)\nusing this:\n  \\<lbrace>\\<lambda>\\<sigma>.\n              \\<not> exec_stop \\<sigma> \\<and>\n              cond \\<sigma> \\<and> P \\<sigma>\\<rbrace>\n  M \\<lbrace>\\<lambda>_. P\\<rbrace>\n  \\<forall>\\<sigma>.\n     \\<not> exec_stop \\<sigma> \\<and>\n     cond \\<sigma> \\<and> P \\<sigma> \\<longrightarrow>\n     M \\<sigma> \\<noteq> None \\<and> f (snd (the (M \\<sigma>))) < f \\<sigma>\n  \\<forall>x \\<sigma>.\n     P (\\<sigma>\\<lparr>break_status := x\\<rparr>) = P \\<sigma>\n\ngoal (3 subgoals):\n 1. \\<lbrace>\\<lambda>\\<sigma>.\n                (\\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) \\<and>\n                P \\<sigma>\\<rbrace>\n    M \\<lbrace>\\<lambda>_. P\\<rbrace>\n 2. \\<forall>\\<sigma>.\n       (\\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) \\<and>\n       P \\<sigma> \\<longrightarrow>\n       M \\<sigma> \\<noteq> None \\<and>\n       f (snd (the (M \\<sigma>))) < f \\<sigma>\n 3. \\<And>\\<sigma>.\n       \\<not> (\\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) \\<and>\n       P \\<sigma> \\<longrightarrow>\n       P (\\<sigma>\\<lparr>break_status := False\\<rparr>)", "by auto"], ["proof (state)\nthis:\n  \\<lbrace>\\<lambda>\\<sigma>.\n              \\<not> exec_stop \\<sigma> \\<and> P \\<sigma>\\<rbrace>\n  _while_SE\n   (\\<lambda>\\<sigma>. \\<not> exec_stop \\<sigma> \\<and> cond \\<sigma>) M\n  \\<lbrace>\\<lambda>_ \\<sigma>.\n              P (\\<sigma>\\<lparr>break_status := False\\<rparr>)\\<rbrace>\n\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>\\<sigma>.\n                P (\\<sigma>\\<lparr>break_status := False\\<rparr>)\\<rbrace>\n    unset_break_status\n    \\<lbrace>\\<lambda>x \\<sigma>'.\n                \\<not> break_status \\<sigma>' \\<and> P \\<sigma>'\\<rbrace>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>\\<sigma>.\n                P (\\<sigma>\\<lparr>break_status := False\\<rparr>)\\<rbrace>\n    unset_break_status\n    \\<lbrace>\\<lambda>x \\<sigma>'.\n                \\<not> break_status \\<sigma>' \\<and> P \\<sigma>'\\<rbrace>", "show \"\\<lbrace>\\<lambda>\\<sigma>. P (\\<sigma>\\<lparr>break_status := False\\<rparr>)\\<rbrace> unset_break_status \n          \\<lbrace>\\<lambda>x \\<sigma>. \\<not> break_status \\<sigma> \\<and> P \\<sigma>\\<rbrace>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>\\<sigma>.\n                P (\\<sigma>\\<lparr>break_status := False\\<rparr>)\\<rbrace>\n    unset_break_status\n    \\<lbrace>\\<lambda>x \\<sigma>.\n                \\<not> break_status \\<sigma> \\<and> P \\<sigma>\\<rbrace>", "apply(subst conj_commute)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrace>\\<lambda>\\<sigma>.\n                P (\\<sigma>\\<lparr>break_status := False\\<rparr>)\\<rbrace>\n    unset_break_status\n    \\<lbrace>\\<lambda>x \\<sigma>.\n                P \\<sigma> \\<and> \\<not> break_status \\<sigma>\\<rbrace>", "by(rule  Hoare_Clean.unset_break1)"], ["proof (state)\nthis:\n  \\<lbrace>\\<lambda>\\<sigma>.\n              P (\\<sigma>\\<lparr>break_status := False\\<rparr>)\\<rbrace>\n  unset_break_status\n  \\<lbrace>\\<lambda>x \\<sigma>.\n              \\<not> break_status \\<sigma> \\<and> P \\<sigma>\\<rbrace>\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Consequence and Sequence rules where inherited from the underlying Hoare-Monad theory.\\<close>"], ["", "end"]]}