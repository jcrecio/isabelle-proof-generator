{"file_name": "/home/qj213/afp-2021-10-22/thys/Clean/src/Seq_MonadSE.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Clean", "problem_names": ["lemma mbind_unit [simp]: \n     \"mbind [] f = (result [])\"", "lemma mbind_nofailure [simp]:\n     \"mbind S f \\<sigma> \\<noteq> None\"", "lemma mbind'_unit [simp]: \n     \"mbind' [] f = (result [])\"", "lemma mbind'_bind [simp]: \n     \"(x \\<leftarrow> mbind' (a#S) F; M x) = (a \\<leftarrow> (F a); (x \\<leftarrow> mbind' S F; M (a # x)))\"", "lemma mbind_try: \n  \"(x \\<leftarrow> mbind (a#S) F; M x) = \n   (a' \\<leftarrow> try\\<^sub>S\\<^sub>E(F a); \n      if a' = None \n      then (M [])\n      else (x \\<leftarrow> mbind S F; M (the a' # x)))\""], "translations": [["", "lemma mbind_unit [simp]: \n     \"mbind [] f = (result [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mbind\\<^sub>F\\<^sub>a\\<^sub>i\\<^sub>l\\<^sub>S\\<^sub>a\\<^sub>v\\<^sub>e []\n     f =\n    unit\\<^sub>S\\<^sub>E []", "by(rule ext, simp add: unit_SE_def)"], ["", "text\\<open>The characteristic property of @{term mbind} --- which distinguishes it from \n       \\<open>mbind\\<close> defined in the sequel --- is that it never fails; it ``swallows'' internal\n       errors occuring during the computation.\\<close>"], ["", "lemma mbind_nofailure [simp]:\n     \"mbind S f \\<sigma> \\<noteq> None\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mbind\\<^sub>F\\<^sub>a\\<^sub>i\\<^sub>l\\<^sub>S\\<^sub>a\\<^sub>v\\<^sub>e S\n     f \\<sigma> \\<noteq>\n    None", "apply(rule_tac x=\\<sigma> in spec)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>x.\n       mbind\\<^sub>F\\<^sub>a\\<^sub>i\\<^sub>l\\<^sub>S\\<^sub>a\\<^sub>v\\<^sub>e\n        S f x \\<noteq>\n       None", "apply(induct S, auto simp:unit_SE_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a S x.\n       \\<forall>x.\n          \\<exists>a b.\n             mbind\\<^sub>F\\<^sub>a\\<^sub>i\\<^sub>l\\<^sub>S\\<^sub>a\\<^sub>v\\<^sub>e\n              S f x =\n             Some (a, b) \\<Longrightarrow>\n       \\<exists>aa b.\n          (case f a x of None \\<Rightarrow> Some ([], x)\n           | Some (out, \\<sigma>') \\<Rightarrow>\n               case mbind\\<^sub>F\\<^sub>a\\<^sub>i\\<^sub>l\\<^sub>S\\<^sub>a\\<^sub>v\\<^sub>e\n                     S f \\<sigma>' of\n               None \\<Rightarrow> Some ([out], \\<sigma>')\n               | Some (outs, \\<sigma>'') \\<Rightarrow>\n                   Some (out # outs, \\<sigma>'')) =\n          Some (aa, b)", "apply(case_tac \"f a x\", auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a S x aa b.\n       \\<lbrakk>\\<forall>x.\n                   \\<exists>a b.\n                      mbind\\<^sub>F\\<^sub>a\\<^sub>i\\<^sub>l\\<^sub>S\\<^sub>a\\<^sub>v\\<^sub>e\n                       S f x =\n                      Some (a, b);\n        f a x = Some (aa, b)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a ba.\n                            (case mbind\\<^sub>F\\<^sub>a\\<^sub>i\\<^sub>l\\<^sub>S\\<^sub>a\\<^sub>v\\<^sub>e\n                                   S f b of\n                             None \\<Rightarrow> Some ([aa], b)\n                             | Some (outs, \\<sigma>'') \\<Rightarrow>\n                                 Some (aa # outs, \\<sigma>'')) =\n                            Some (a, ba)", "apply(erule_tac x=\"b\" in allE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>a S x aa b.\n       \\<lbrakk>f a x = Some (aa, b);\n        \\<exists>a ba.\n           mbind\\<^sub>F\\<^sub>a\\<^sub>i\\<^sub>l\\<^sub>S\\<^sub>a\\<^sub>v\\<^sub>e\n            S f b =\n           Some (a, ba)\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a ba.\n                            (case mbind\\<^sub>F\\<^sub>a\\<^sub>i\\<^sub>l\\<^sub>S\\<^sub>a\\<^sub>v\\<^sub>e\n                                   S f b of\n                             None \\<Rightarrow> Some ([aa], b)\n                             | Some (outs, \\<sigma>'') \\<Rightarrow>\n                                 Some (aa # outs, \\<sigma>'')) =\n                            Some (a, ba)", "apply(erule exE, erule exE, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "text\\<open>In contrast, we define a fail-strict sequential execution operator.\nHe has more the characteristic to fail globally whenever one of its operation\nsteps fails.\n\nIntuitively speaking, \\<open>mbind'\\<close> corresponds to an execution of operations \nwhere a results in a System-Halt. Another interpretation of \\<open>mbind'\\<close> is to\nview it as a kind of @{term foldl} foldl over lists via @{term bind\\<^sub>S\\<^sub>E}.\\<close>"], ["", "fun    mbind' :: \"'\\<iota> list  \\<Rightarrow>  ('\\<iota> \\<Rightarrow> ('o,'\\<sigma>) MON\\<^sub>S\\<^sub>E) \\<Rightarrow> ('o list,'\\<sigma>) MON\\<^sub>S\\<^sub>E\"\nwhere \"mbind' [] iostep \\<sigma> = Some([], \\<sigma>)\" |\n      \"mbind' (a#S) iostep \\<sigma> = \n                (case iostep a \\<sigma> of \n                     None   \\<Rightarrow> None\n                  |  Some (out, \\<sigma>') \\<Rightarrow> (case mbind' S iostep \\<sigma>' of \n                                          None    \\<Rightarrow> None   \\<comment> \\<open>fail-strict\\<close> \n                                        | Some(outs,\\<sigma>'') \\<Rightarrow> Some(out#outs,\\<sigma>'')))\""], ["", "notation mbind' (\"mbind\\<^sub>F\\<^sub>a\\<^sub>i\\<^sub>l\\<^sub>S\\<^sub>t\\<^sub>o\\<^sub>p\")"], ["", "(* future name: mbind\\<^sub>F\\<^sub>a\\<^sub>i\\<^sub>l\\<^sub>S\\<^sub>t\\<^sub>o\\<^sub>p *)"], ["", "lemma mbind'_unit [simp]: \n     \"mbind' [] f = (result [])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mbind\\<^sub>F\\<^sub>a\\<^sub>i\\<^sub>l\\<^sub>S\\<^sub>t\\<^sub>o\\<^sub>p []\n     f =\n    unit\\<^sub>S\\<^sub>E []", "by(rule ext, simp add: unit_SE_def)"], ["", "lemma mbind'_bind [simp]: \n     \"(x \\<leftarrow> mbind' (a#S) F; M x) = (a \\<leftarrow> (F a); (x \\<leftarrow> mbind' S F; M (a # x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind\\<^sub>S\\<^sub>E\n     (mbind\\<^sub>F\\<^sub>a\\<^sub>i\\<^sub>l\\<^sub>S\\<^sub>t\\<^sub>o\\<^sub>p\n       (a # S) F)\n     M =\n    _bind_SE a (F a)\n     (_bind_SE x\n       (mbind\\<^sub>F\\<^sub>a\\<^sub>i\\<^sub>l\\<^sub>S\\<^sub>t\\<^sub>o\\<^sub>p\n         S F)\n       (M (a # x)))", "by(rule ext, rename_tac \"z\",simp add: bind_SE_def split: option.split)"], ["", "declare mbind'.simps[simp del]"], ["", "(* use only more abstract definitions *)"], ["", "text\\<open>The next \\<open>mbind\\<close> sequential execution operator is called \nFail-Purge. He has more the characteristic to never fail, just \"stuttering\" \nabove operation steps that fail. Another alternative in modeling.\\<close>"], ["", "fun    mbind'' :: \"'\\<iota> list  \\<Rightarrow>  ('\\<iota> \\<Rightarrow> ('o,'\\<sigma>) MON\\<^sub>S\\<^sub>E) \\<Rightarrow> ('o list,'\\<sigma>) MON\\<^sub>S\\<^sub>E\"\nwhere \"mbind'' [] iostep \\<sigma> = Some([], \\<sigma>)\" |\n      \"mbind'' (a#S) iostep \\<sigma> = \n                (case iostep a \\<sigma> of \n                     None           \\<Rightarrow> mbind'' S iostep \\<sigma>\n                  |  Some (out, \\<sigma>') \\<Rightarrow> (case mbind'' S iostep \\<sigma>' of \n                                          None    \\<Rightarrow> None   \\<comment> \\<open>does not occur\\<close> \n                                        | Some(outs,\\<sigma>'') \\<Rightarrow> Some(out#outs,\\<sigma>'')))\""], ["", "notation mbind'' (\"mbind\\<^sub>F\\<^sub>a\\<^sub>i\\<^sub>l\\<^sub>P\\<^sub>u\\<^sub>r\\<^sub>g\\<^sub>e\")"], ["", "(* future name: mbind\\<^sub>P\\<^sub>u\\<^sub>r\\<^sub>g\\<^sub>e\\<^sub>F\\<^sub>a\\<^sub>i\\<^sub>l *)"], ["", "declare  mbind''.simps[simp del]"], ["", "(* use only more abstract definitions *)"], ["", "text\\<open>mbind' as failure strict operator can be seen as a foldr on bind -\n       if the types would match \\ldots\\<close>"], ["", "subsubsection\\<open>Definition : Miscellaneous Operators and their Properties\\<close>"], ["", "lemma mbind_try: \n  \"(x \\<leftarrow> mbind (a#S) F; M x) = \n   (a' \\<leftarrow> try\\<^sub>S\\<^sub>E(F a); \n      if a' = None \n      then (M [])\n      else (x \\<leftarrow> mbind S F; M (the a' # x)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind\\<^sub>S\\<^sub>E\n     (mbind\\<^sub>F\\<^sub>a\\<^sub>i\\<^sub>l\\<^sub>S\\<^sub>a\\<^sub>v\\<^sub>e\n       (a # S) F)\n     M =\n    _bind_SE a' (try\\<^sub>S\\<^sub>E (F a))\n     (if a' = None then M []\n      else _bind_SE x\n            (mbind\\<^sub>F\\<^sub>a\\<^sub>i\\<^sub>l\\<^sub>S\\<^sub>a\\<^sub>v\\<^sub>e\n              S F)\n            (M (the a' # x)))", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       bind\\<^sub>S\\<^sub>E\n        (mbind\\<^sub>F\\<^sub>a\\<^sub>i\\<^sub>l\\<^sub>S\\<^sub>a\\<^sub>v\\<^sub>e\n          (a # S) F)\n        M x =\n       (_bind_SE a' (try\\<^sub>S\\<^sub>E (F a))\n         (if a' = None then M []\n          else _bind_SE x\n                (mbind\\<^sub>F\\<^sub>a\\<^sub>i\\<^sub>l\\<^sub>S\\<^sub>a\\<^sub>v\\<^sub>e\n                  S F)\n                (M (the a' # x))))\n        x", "apply(simp add: bind_SE_def try_SE_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (case case F a x of None \\<Rightarrow> Some ([], x)\n             | Some (out, \\<sigma>') \\<Rightarrow>\n                 case mbind\\<^sub>F\\<^sub>a\\<^sub>i\\<^sub>l\\<^sub>S\\<^sub>a\\<^sub>v\\<^sub>e\n                       S F \\<sigma>' of\n                 None \\<Rightarrow> Some ([out], \\<sigma>')\n                 | Some (outs, \\<sigma>'') \\<Rightarrow>\n                     Some (out # outs, \\<sigma>'') of\n        None \\<Rightarrow> None | Some (xa, xb) \\<Rightarrow> M xa xb) =\n       (case case F a x of None \\<Rightarrow> Some (None, x)\n             | Some (outs, \\<sigma>') \\<Rightarrow>\n                 Some (Some outs, \\<sigma>') of\n        None \\<Rightarrow> None\n        | Some (out, xa) \\<Rightarrow>\n            (if out = None then M []\n             else _bind_SE x\n                   (mbind\\<^sub>F\\<^sub>a\\<^sub>i\\<^sub>l\\<^sub>S\\<^sub>a\\<^sub>v\\<^sub>e\n                     S F)\n                   (M (the out # x)))\n             xa)", "apply(case_tac \"F a x\", auto)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x aa b.\n       F a x = Some (aa, b) \\<Longrightarrow>\n       (case case mbind\\<^sub>F\\<^sub>a\\<^sub>i\\<^sub>l\\<^sub>S\\<^sub>a\\<^sub>v\\<^sub>e\n                   S F b of\n             None \\<Rightarrow> Some ([aa], b)\n             | Some (outs, \\<sigma>'') \\<Rightarrow>\n                 Some (aa # outs, \\<sigma>'') of\n        None \\<Rightarrow> None | Some (xa, xb) \\<Rightarrow> M xa xb) =\n       (_bind_SE x\n         (mbind\\<^sub>F\\<^sub>a\\<^sub>i\\<^sub>l\\<^sub>S\\<^sub>a\\<^sub>v\\<^sub>e\n           S F)\n         (M (aa # x)))\n        b", "apply(simp add: bind_SE_def try_SE_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x aa b.\n       F a x = Some (aa, b) \\<Longrightarrow>\n       (case case mbind\\<^sub>F\\<^sub>a\\<^sub>i\\<^sub>l\\<^sub>S\\<^sub>a\\<^sub>v\\<^sub>e\n                   S F b of\n             None \\<Rightarrow> Some ([aa], b)\n             | Some (outs, \\<sigma>'') \\<Rightarrow>\n                 Some (aa # outs, \\<sigma>'') of\n        None \\<Rightarrow> None | Some (xa, xb) \\<Rightarrow> M xa xb) =\n       (case mbind\\<^sub>F\\<^sub>a\\<^sub>i\\<^sub>l\\<^sub>S\\<^sub>a\\<^sub>v\\<^sub>e\n              S F b of\n        None \\<Rightarrow> None\n        | Some (out, xa) \\<Rightarrow> M (aa # out) xa)", "apply(case_tac \"mbind S F b\", auto)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "end"]]}