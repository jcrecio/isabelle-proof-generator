{"file_name": "/home/qj213/afp-2021-10-22/thys/Clean/src/MonadSE.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Clean", "problem_names": ["lemma bind_right_unit[simp]: \"(x \\<leftarrow> m; result x) = m\"", "lemma bind_left_unit [simp]: \"(x \\<leftarrow> result c; P x) = P c\"", "lemma bind_assoc[simp]: \"(y \\<leftarrow> (x \\<leftarrow> m; k x); h y) = (x \\<leftarrow> m; (y \\<leftarrow> k x; h y))\"", "lemma bind_left_fail_SE[simp] : \"(x \\<leftarrow> fail\\<^sub>S\\<^sub>E; P x) = fail\\<^sub>S\\<^sub>E\"", "lemma bind_assoc'[simp]: \"((m;- k);- h ) = (m;- (k;- h))\"", "lemma bind_left_unit' [simp]: \"((result c);- P) = P\"", "lemma bind_left_fail_SE'[simp]: \"(fail\\<^sub>S\\<^sub>E;- P) = fail\\<^sub>S\\<^sub>E\"", "lemma bind_right_unit'[simp]: \"(m;- (result ())) = m\"", "lemma     syntax_test: \"(o1 \\<leftarrow> f1 ; o2 \\<leftarrow> f2; result (post o1 o2)) = X\"", "lemma malt_SE_mt [simp]: \"\\<Sqinter>\\<^sub>S\\<^sub>E [] = fail\\<^sub>S\\<^sub>E\"", "lemma malt_SE_cons [simp]: \"\\<Sqinter>\\<^sub>S\\<^sub>E (a # S) = (a \\<sqinter>\\<^sub>S\\<^sub>E (\\<Sqinter>\\<^sub>S\\<^sub>E S))\"", "lemma Mon2Rel_Rel2Mon_id: assumes det:\"single_valued R\" shows \"(Mon2Rel \\<circ> Rel2Mon) R = R\"", "lemma Rel2Mon_Id: \"(Rel2Mon \\<circ> Mon2Rel) x = x\"", "lemma single_valued_Mon2Rel: \"single_valued (Mon2Rel B)\"", "lemma chain_total: \"chain S ==> S i \\<le> S j \\<or> S j \\<le> S i\"", "lemma mono_if_cont: fixes f :: \"'a set \\<Rightarrow> 'b set\"\n  assumes \"cont f\" shows \"mono f\"", "lemma chain_iterates: fixes f :: \"'a set \\<Rightarrow> 'a set\"\n  assumes \"mono f\" shows \"chain(\\<lambda>n. (f^^n) {})\"", "theorem lfp_if_cont:\n  assumes \"cont f\" shows \"lfp f =  (\\<Union>n. (f ^^ n) {})\" (is \"_ = ?U\")", "lemma single_valued_UN_chain:\n  assumes \"chain S\" \"(!!n. single_valued (S n))\"\n  shows \"single_valued(UN n. S n)\"", "lemma single_valued_lfp: \nfixes f :: \"('a \\<times> 'a) set \\<Rightarrow> ('a \\<times> 'a) set\"\nassumes \"cont f\" \"\\<And>r. single_valued r \\<Longrightarrow> single_valued (f r)\"\nshows \"single_valued(lfp f)\"", "lemma cont_\\<Gamma>: \"cont (\\<Gamma> c b)\"", "theorem single_valued_lfp_Mon2Rel: \"single_valued (lfp(\\<Gamma> c (Mon2Rel B)))\"", "lemma Rel2Mon_if:\n  \"Rel2Mon {(s, t). if b s then (s, t) \\<in> Mon2Rel c O lfp (\\<Gamma> b (Mon2Rel c)) else s = t} \\<sigma> =\n  (if b \\<sigma> then Rel2Mon (Mon2Rel c O lfp (\\<Gamma> b (Mon2Rel c))) \\<sigma> else Some ((), \\<sigma>))\"", "lemma Rel2Mon_homomorphism:\n  assumes determ_X: \"single_valued X\" and determ_Y: \"single_valued Y\"\n  shows   \"Rel2Mon (X O Y) = (Rel2Mon X) ;- (Rel2Mon Y)\"", "theorem while_SE_unfold:\n\"(while\\<^sub>S\\<^sub>E b do c od) = (if\\<^sub>S\\<^sub>E b then (c ;- (while\\<^sub>S\\<^sub>E b do c od)) else result () fi)\"", "lemma bind_cong : \" f \\<sigma> = g \\<sigma> \\<Longrightarrow>  (x \\<leftarrow> f ; M x)\\<sigma> = (x \\<leftarrow> g ; M x)\\<sigma>\"", "lemma bind'_cong : \" f \\<sigma> = g \\<sigma> \\<Longrightarrow>  (f ;- M )\\<sigma> = (g ;- M )\\<sigma>\"", "lemma if\\<^sub>S\\<^sub>E_True [simp]: \"(if\\<^sub>S\\<^sub>E (\\<lambda> x. True) then c else d fi) = c\"", "lemma if\\<^sub>S\\<^sub>E_False [simp]: \"(if\\<^sub>S\\<^sub>E (\\<lambda> x. False) then c else d fi) = d\"", "lemma if\\<^sub>S\\<^sub>E_cond_cong : \"f \\<sigma> = g \\<sigma> \\<Longrightarrow> \n                           (if\\<^sub>S\\<^sub>E f then c else d fi) \\<sigma> = \n                           (if\\<^sub>S\\<^sub>E g then c else d fi) \\<sigma>\"", "lemma while\\<^sub>S\\<^sub>E_skip[simp] : \"(while\\<^sub>S\\<^sub>E (\\<lambda> x. False) do c od) = skip\\<^sub>S\\<^sub>E\""], "translations": [["", "lemma bind_right_unit[simp]: \"(x \\<leftarrow> m; result x) = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind\\<^sub>S\\<^sub>E m unit\\<^sub>S\\<^sub>E = m", "apply (simp add:  unit_SE_def bind_SE_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>\\<sigma>.\n        case m \\<sigma> of None \\<Rightarrow> None\n        | Some (out, \\<sigma>') \\<Rightarrow> Some (out, \\<sigma>')) =\n    m", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       (case m \\<sigma> of None \\<Rightarrow> None\n        | Some (out, \\<sigma>') \\<Rightarrow> Some (out, \\<sigma>')) =\n       m \\<sigma>", "apply (case_tac \"m \\<sigma>\", simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bind_left_unit [simp]: \"(x \\<leftarrow> result c; P x) = P c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind\\<^sub>S\\<^sub>E (unit\\<^sub>S\\<^sub>E c) P = P c", "by (simp add: unit_SE_def bind_SE_def)"], ["", "lemma bind_assoc[simp]: \"(y \\<leftarrow> (x \\<leftarrow> m; k x); h y) = (x \\<leftarrow> m; (y \\<leftarrow> k x; h y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind\\<^sub>S\\<^sub>E (bind\\<^sub>S\\<^sub>E m k) h =\n    _bind_SE x m (bind\\<^sub>S\\<^sub>E (k x) h)", "apply (simp add: unit_SE_def bind_SE_def, rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       (case case m \\<sigma> of None \\<Rightarrow> None\n             | Some (xa, xb) \\<Rightarrow> k xa xb of\n        None \\<Rightarrow> None\n        | Some (out, \\<sigma>') \\<Rightarrow> h out \\<sigma>') =\n       (case m \\<sigma> of None \\<Rightarrow> None\n        | Some (out, \\<sigma>') \\<Rightarrow>\n            case k out \\<sigma>' of None \\<Rightarrow> None\n            | Some (xa, xb) \\<Rightarrow> h xa xb)", "apply (case_tac \"m \\<sigma>\", simp_all)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> a.\n       m \\<sigma> = Some a \\<Longrightarrow>\n       (case case a of (x, xa) \\<Rightarrow> k x xa of\n        None \\<Rightarrow> None\n        | Some (out, \\<sigma>') \\<Rightarrow> h out \\<sigma>') =\n       (case a of\n        (out, \\<sigma>') \\<Rightarrow>\n          case k out \\<sigma>' of None \\<Rightarrow> None\n          | Some (xa, xb) \\<Rightarrow> h xa xb)", "apply (case_tac \"a\", simp_all)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "subsection\\<open>Definition : More Operators and their Properties\\<close>"], ["", "definition fail_SE :: \"('o, '\\<sigma>)MON\\<^sub>S\\<^sub>E\"\nwhere     \"fail_SE = (\\<lambda>\\<sigma>. None)\""], ["", "notation   fail_SE (\"fail\\<^sub>S\\<^sub>E\")"], ["", "definition assert_SE :: \"('\\<sigma> \\<Rightarrow> bool) \\<Rightarrow> (bool, '\\<sigma>)MON\\<^sub>S\\<^sub>E\"\nwhere     \"assert_SE P = (\\<lambda>\\<sigma>. if P \\<sigma> then Some(True,\\<sigma>) else None)\""], ["", "notation   assert_SE (\"assert\\<^sub>S\\<^sub>E\")"], ["", "definition assume_SE :: \"('\\<sigma> \\<Rightarrow> bool) \\<Rightarrow> (unit, '\\<sigma>)MON\\<^sub>S\\<^sub>E\"\nwhere     \"assume_SE P = (\\<lambda>\\<sigma>. if \\<exists>\\<sigma> . P \\<sigma> then Some((), SOME \\<sigma> . P \\<sigma>) else None)\""], ["", "notation   assume_SE (\"assume\\<^sub>S\\<^sub>E\")"], ["", "lemma bind_left_fail_SE[simp] : \"(x \\<leftarrow> fail\\<^sub>S\\<^sub>E; P x) = fail\\<^sub>S\\<^sub>E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. bind\\<^sub>S\\<^sub>E fail\\<^sub>S\\<^sub>E P = fail\\<^sub>S\\<^sub>E", "by (simp add: fail_SE_def bind_SE_def)"], ["", "text\\<open>We also provide a \"Pipe-free\" - variant of the bind operator.\nJust a \"standard\" programming sequential operator without output frills.\\<close>"], ["", "(* TODO: Eliminate/Modify this. Is a consequence of the Monad-Instantiation. *)"], ["", "definition bind_SE' :: \"('\\<alpha>, '\\<sigma>)MON\\<^sub>S\\<^sub>E \\<Rightarrow> ('\\<beta>, '\\<sigma>)MON\\<^sub>S\\<^sub>E \\<Rightarrow> ('\\<beta>, '\\<sigma>)MON\\<^sub>S\\<^sub>E\" (infixr \";-\" 60)\nwhere     \"f ;- g = (_ \\<leftarrow> f ; g)\""], ["", "lemma bind_assoc'[simp]: \"((m;- k);- h ) = (m;- (k;- h))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (m ;- k) ;- h = m ;- k ;- h", "by(simp add:bind_SE'_def)"], ["", "lemma bind_left_unit' [simp]: \"((result c);- P) = P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. unit\\<^sub>S\\<^sub>E c ;- P = P", "by (simp add:  bind_SE'_def)"], ["", "lemma bind_left_fail_SE'[simp]: \"(fail\\<^sub>S\\<^sub>E;- P) = fail\\<^sub>S\\<^sub>E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. fail\\<^sub>S\\<^sub>E ;- P = fail\\<^sub>S\\<^sub>E", "by (simp add: bind_SE'_def)"], ["", "lemma bind_right_unit'[simp]: \"(m;- (result ())) = m\""], ["proof (prove)\ngoal (1 subgoal):\n 1. m ;- unit\\<^sub>S\\<^sub>E () = m", "by (simp add:  bind_SE'_def)"], ["", "text\\<open>The bind-operator in the state-exception monad yields already\n       a semantics for the concept of an input sequence on the meta-level:\\<close>"], ["", "lemma     syntax_test: \"(o1 \\<leftarrow> f1 ; o2 \\<leftarrow> f2; result (post o1 o2)) = X\""], ["proof (prove)\ngoal (1 subgoal):\n 1. _bind_SE o1 f1 (_bind_SE o2 f2 (unit\\<^sub>S\\<^sub>E (post o1 o2))) = X", "oops"], ["", "definition yield\\<^sub>C :: \"('a  \\<Rightarrow> 'b) \\<Rightarrow>  ('b,'a ) MON\\<^sub>S\\<^sub>E\"\n    where \"yield\\<^sub>C f \\<equiv> (\\<lambda>\\<sigma>. Some(f \\<sigma>, \\<sigma>))\""], ["", "definition try_SE :: \"('o,'\\<sigma>) MON\\<^sub>S\\<^sub>E \\<Rightarrow> ('o option,'\\<sigma>) MON\\<^sub>S\\<^sub>E\" (\"try\\<^sub>S\\<^sub>E\")\nwhere     \"try\\<^sub>S\\<^sub>E ioprog = (\\<lambda>\\<sigma>. case ioprog \\<sigma> of\n                                      None \\<Rightarrow> Some(None, \\<sigma>)\n                                    | Some(outs, \\<sigma>') \\<Rightarrow> Some(Some outs, \\<sigma>'))\""], ["", "text\\<open>In contrast, mbind as a failure safe operator can roughly be seen \n       as a foldr on bind - try:\n       m1 ; try m2 ; try m3; ... Note, that the rough equivalence only holds for\n       certain predicates in the sequence - length equivalence modulo None,\n       for example. However, if a conditional is added, the equivalence\n       can be made precise:\\<close>"], ["", "text\\<open>On this basis, a symbolic evaluation scheme can be established\n  that reduces mbind-code to try\\_SE\\_code and ite-cascades.\\<close>"], ["", "definition alt_SE :: \"[('o, '\\<sigma>)MON\\<^sub>S\\<^sub>E, ('o, '\\<sigma>)MON\\<^sub>S\\<^sub>E] \\<Rightarrow> ('o, '\\<sigma>)MON\\<^sub>S\\<^sub>E\"   (infixl \"\\<sqinter>\\<^sub>S\\<^sub>E\" 10)\nwhere     \"(f \\<sqinter>\\<^sub>S\\<^sub>E g) = (\\<lambda> \\<sigma>. case f \\<sigma> of None \\<Rightarrow> g \\<sigma>\n                                      | Some H \\<Rightarrow> Some H)\""], ["", "definition malt_SE :: \"('o, '\\<sigma>)MON\\<^sub>S\\<^sub>E list \\<Rightarrow> ('o, '\\<sigma>)MON\\<^sub>S\\<^sub>E\"\nwhere     \"malt_SE S = foldr alt_SE S fail\\<^sub>S\\<^sub>E\""], ["", "notation   malt_SE (\"\\<Sqinter>\\<^sub>S\\<^sub>E\")"], ["", "lemma malt_SE_mt [simp]: \"\\<Sqinter>\\<^sub>S\\<^sub>E [] = fail\\<^sub>S\\<^sub>E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter>\\<^sub>S\\<^sub>E [] = fail\\<^sub>S\\<^sub>E", "by(simp add: malt_SE_def)"], ["", "lemma malt_SE_cons [simp]: \"\\<Sqinter>\\<^sub>S\\<^sub>E (a # S) = (a \\<sqinter>\\<^sub>S\\<^sub>E (\\<Sqinter>\\<^sub>S\\<^sub>E S))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<Sqinter>\\<^sub>S\\<^sub>E (a # S) =\n    (a \\<sqinter>\\<^sub>S\\<^sub>E \\<Sqinter>\\<^sub>S\\<^sub>E S)", "by(simp add: malt_SE_def)"], ["", "subsection\\<open>Definition : Programming Operators and their Properties\\<close>"], ["", "definition  \"skip\\<^sub>S\\<^sub>E = unit\\<^sub>S\\<^sub>E ()\""], ["", "definition if_SE :: \"['\\<sigma> \\<Rightarrow> bool, ('\\<alpha>, '\\<sigma>)MON\\<^sub>S\\<^sub>E, ('\\<alpha>, '\\<sigma>)MON\\<^sub>S\\<^sub>E] \\<Rightarrow> ('\\<alpha>, '\\<sigma>)MON\\<^sub>S\\<^sub>E\"\nwhere     \"if_SE c E F = (\\<lambda>\\<sigma>. if c \\<sigma> then E \\<sigma> else F \\<sigma>)\""], ["", "syntax    (xsymbols)\n          \"_if_SE\" :: \"['\\<sigma> \\<Rightarrow> bool,('o,'\\<sigma>)MON\\<^sub>S\\<^sub>E,('o','\\<sigma>)MON\\<^sub>S\\<^sub>E] \\<Rightarrow> ('o','\\<sigma>)MON\\<^sub>S\\<^sub>E\" \n          (\"(if\\<^sub>S\\<^sub>E _ then _ else _fi)\" [5,8,8]8)"], ["", "translations \n          \"(if\\<^sub>S\\<^sub>E cond then T1 else T2 fi)\" == \"CONST if_SE cond T1 T2\""], ["", "subsection\\<open>Theory of a Monadic While\\<close>"], ["", "text\\<open>Prerequisites\\<close>"], ["", "fun replicator :: \"[('a, '\\<sigma>)MON\\<^sub>S\\<^sub>E, nat] \\<Rightarrow> (unit, '\\<sigma>)MON\\<^sub>S\\<^sub>E\" (infixr \"^^^\" 60)\nwhere     \"f ^^^ 0      = (result ())\"\n        | \"f ^^^ (Suc n) = (f ;- f ^^^  n)\""], ["", "fun replicator2 :: \"[('a, '\\<sigma>)MON\\<^sub>S\\<^sub>E, nat, ('b, '\\<sigma>)MON\\<^sub>S\\<^sub>E] \\<Rightarrow> ('b, '\\<sigma>)MON\\<^sub>S\\<^sub>E\" (infixr \"^:^\" 60)\nwhere     \"(f ^:^ 0) M      = (M )\"\n        | \"(f ^:^ (Suc n)) M = (f ;- ((f ^:^  n) M))\""], ["", "text\\<open>First Step : Establishing an embedding between partial functions and relations\\<close>"], ["", "(* plongement *)"], ["", "definition Mon2Rel :: \"(unit, '\\<sigma>)MON\\<^sub>S\\<^sub>E \\<Rightarrow> ('\\<sigma> \\<times> '\\<sigma>) set\"\nwhere \"Mon2Rel f = {(x, y). (f x = Some((), y))}\""], ["", "(* ressortir *)"], ["", "definition Rel2Mon :: \" ('\\<sigma> \\<times> '\\<sigma>) set \\<Rightarrow> (unit, '\\<sigma>)MON\\<^sub>S\\<^sub>E \"\nwhere \"Rel2Mon S = (\\<lambda> \\<sigma>. if \\<exists>\\<sigma>'. (\\<sigma>, \\<sigma>') \\<in> S then Some((), SOME \\<sigma>'. (\\<sigma>, \\<sigma>') \\<in> S) else None)\""], ["", "lemma Mon2Rel_Rel2Mon_id: assumes det:\"single_valued R\" shows \"(Mon2Rel \\<circ> Rel2Mon) R = R\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Mon2Rel \\<circ> Rel2Mon) R = R", "apply (simp add: comp_def Mon2Rel_def Rel2Mon_def,auto)"], ["proof (prove)\ngoal (3 subgoals):\n 1. \\<And>a b.\n       (if \\<exists>\\<sigma>'. (a, \\<sigma>') \\<in> R\n        then Some ((), SOME \\<sigma>'. (a, \\<sigma>') \\<in> R) else None) =\n       Some ((), b) \\<Longrightarrow>\n       (a, b) \\<in> R\n 2. \\<And>a b \\<sigma>'.\n       \\<lbrakk>(a, b) \\<in> R; (a, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (SOME \\<sigma>'. (a, \\<sigma>') \\<in> R) = b\n 3. \\<And>a b.\n       (a, b) \\<in> R \\<Longrightarrow>\n       \\<exists>\\<sigma>'. (a, \\<sigma>') \\<in> R", "apply (case_tac \"\\<exists>\\<sigma>'. (a, \\<sigma>') \\<in> R\", auto)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a \\<sigma>'.\n       (a, \\<sigma>') \\<in> R \\<Longrightarrow>\n       (a, SOME \\<sigma>'. (a, \\<sigma>') \\<in> R) \\<in> R\n 2. \\<And>a b \\<sigma>'.\n       \\<lbrakk>(a, b) \\<in> R; (a, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (SOME \\<sigma>'. (a, \\<sigma>') \\<in> R) = b", "apply (subst (2) some_eq_ex)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>a \\<sigma>'.\n       (a, \\<sigma>') \\<in> R \\<Longrightarrow> \\<exists>x. (a, x) \\<in> R\n 2. \\<And>a b \\<sigma>'.\n       \\<lbrakk>(a, b) \\<in> R; (a, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (SOME \\<sigma>'. (a, \\<sigma>') \\<in> R) = b", "using det[simplified single_valued_def]"], ["proof (prove)\nusing this:\n  \\<forall>x y.\n     (x, y) \\<in> R \\<longrightarrow>\n     (\\<forall>z. (x, z) \\<in> R \\<longrightarrow> y = z)\n\ngoal (2 subgoals):\n 1. \\<And>a \\<sigma>'.\n       (a, \\<sigma>') \\<in> R \\<Longrightarrow> \\<exists>x. (a, x) \\<in> R\n 2. \\<And>a b \\<sigma>'.\n       \\<lbrakk>(a, b) \\<in> R; (a, \\<sigma>') \\<in> R\\<rbrakk>\n       \\<Longrightarrow> (SOME \\<sigma>'. (a, \\<sigma>') \\<in> R) = b", "by auto"], ["", "lemma Rel2Mon_Id: \"(Rel2Mon \\<circ> Mon2Rel) x = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (Rel2Mon \\<circ> Mon2Rel) x = x", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa. (Rel2Mon \\<circ> Mon2Rel) x xa = x xa", "apply (auto simp: comp_def Mon2Rel_def Rel2Mon_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>xa.\n       \\<forall>\\<sigma>'.\n          x xa \\<noteq> Some ((), \\<sigma>') \\<Longrightarrow>\n       None = x xa", "apply (erule contrapos_pp, drule HOL.not_sym, simp)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma single_valued_Mon2Rel: \"single_valued (Mon2Rel B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued (Mon2Rel B)", "by (auto simp: single_valued_def Mon2Rel_def)"], ["", "text\\<open>Second Step : Proving an induction principle allowing to establish that lfp remains\n       deterministic\\<close>"], ["", "(* A little complete partial order theory due to Tobias Nipkow *)"], ["", "definition chain :: \"(nat \\<Rightarrow> 'a set) \\<Rightarrow> bool\" \nwhere     \"chain S = (\\<forall>i. S i \\<subseteq> S(Suc i))\""], ["", "lemma chain_total: \"chain S ==> S i \\<le> S j \\<or> S j \\<le> S i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain S \\<Longrightarrow> S i \\<subseteq> S j \\<or> S j \\<subseteq> S i", "by (metis chain_def le_cases lift_Suc_mono_le)"], ["", "definition cont :: \"('a set => 'b set) => bool\" \nwhere     \"cont f = (\\<forall>S. chain S \\<longrightarrow> f(UN n. S n) = (UN n. f(S n)))\""], ["", "lemma mono_if_cont: fixes f :: \"'a set \\<Rightarrow> 'b set\"\n  assumes \"cont f\" shows \"mono f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. mono f", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<subseteq> y \\<Longrightarrow> f x \\<subseteq> f y", "fix a b :: \"'a set\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<subseteq> y \\<Longrightarrow> f x \\<subseteq> f y", "assume \"a \\<subseteq> b\""], ["proof (state)\nthis:\n  a \\<subseteq> b\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<subseteq> y \\<Longrightarrow> f x \\<subseteq> f y", "let ?S = \"\\<lambda>n::nat. if n=0 then a else b\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<subseteq> y \\<Longrightarrow> f x \\<subseteq> f y", "have \"chain ?S\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain (\\<lambda>n. if n = 0 then a else b)", "using \\<open>a \\<subseteq> b\\<close>"], ["proof (prove)\nusing this:\n  a \\<subseteq> b\n\ngoal (1 subgoal):\n 1. chain (\\<lambda>n. if n = 0 then a else b)", "by(auto simp: chain_def)"], ["proof (state)\nthis:\n  chain (\\<lambda>n. if n = 0 then a else b)\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<subseteq> y \\<Longrightarrow> f x \\<subseteq> f y", "hence \"f(UN n. ?S n) = (UN n. f(?S n))\""], ["proof (prove)\nusing this:\n  chain (\\<lambda>n. if n = 0 then a else b)\n\ngoal (1 subgoal):\n 1. f (\\<Union>n. if n = 0 then a else b) =\n    (\\<Union>n. f (if n = 0 then a else b))", "using assms"], ["proof (prove)\nusing this:\n  chain (\\<lambda>n. if n = 0 then a else b)\n  cont f\n\ngoal (1 subgoal):\n 1. f (\\<Union>n. if n = 0 then a else b) =\n    (\\<Union>n. f (if n = 0 then a else b))", "by (metis cont_def)"], ["proof (state)\nthis:\n  f (\\<Union>n. if n = 0 then a else b) =\n  (\\<Union>n. f (if n = 0 then a else b))\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<subseteq> y \\<Longrightarrow> f x \\<subseteq> f y", "moreover"], ["proof (state)\nthis:\n  f (\\<Union>n. if n = 0 then a else b) =\n  (\\<Union>n. f (if n = 0 then a else b))\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<subseteq> y \\<Longrightarrow> f x \\<subseteq> f y", "have \"(UN n. ?S n) = b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>n. if n = 0 then a else b) = b", "using \\<open>a \\<subseteq> b\\<close>"], ["proof (prove)\nusing this:\n  a \\<subseteq> b\n\ngoal (1 subgoal):\n 1. (\\<Union>n. if n = 0 then a else b) = b", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  (\\<Union>n. if n = 0 then a else b) = b\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<subseteq> y \\<Longrightarrow> f x \\<subseteq> f y", "moreover"], ["proof (state)\nthis:\n  (\\<Union>n. if n = 0 then a else b) = b\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<subseteq> y \\<Longrightarrow> f x \\<subseteq> f y", "have \"(UN n. f(?S n)) = f a \\<union> f b\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>n. f (if n = 0 then a else b)) = f a \\<union> f b", "by (auto split: if_splits)"], ["proof (state)\nthis:\n  (\\<Union>n. f (if n = 0 then a else b)) = f a \\<union> f b\n\ngoal (1 subgoal):\n 1. \\<And>x y. x \\<subseteq> y \\<Longrightarrow> f x \\<subseteq> f y", "ultimately"], ["proof (chain)\npicking this:\n  f (\\<Union>n. if n = 0 then a else b) =\n  (\\<Union>n. f (if n = 0 then a else b))\n  (\\<Union>n. if n = 0 then a else b) = b\n  (\\<Union>n. f (if n = 0 then a else b)) = f a \\<union> f b", "show \"f a \\<subseteq> f b\""], ["proof (prove)\nusing this:\n  f (\\<Union>n. if n = 0 then a else b) =\n  (\\<Union>n. f (if n = 0 then a else b))\n  (\\<Union>n. if n = 0 then a else b) = b\n  (\\<Union>n. f (if n = 0 then a else b)) = f a \\<union> f b\n\ngoal (1 subgoal):\n 1. f a \\<subseteq> f b", "by (metis Un_upper1)"], ["proof (state)\nthis:\n  f a \\<subseteq> f b\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma chain_iterates: fixes f :: \"'a set \\<Rightarrow> 'a set\"\n  assumes \"mono f\" shows \"chain(\\<lambda>n. (f^^n) {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. chain (\\<lambda>n. (f ^^ n) {})", "proof-"], ["proof (state)\ngoal (1 subgoal):\n 1. chain (\\<lambda>n. (f ^^ n) {})", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. chain (\\<lambda>n. (f ^^ n) {})", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. chain (\\<lambda>n. (f ^^ n) {})", "have \"(f ^^ n) {} \\<subseteq> (f ^^ Suc n) {}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f ^^ n) {} \\<subseteq> (f ^^ Suc n) {}", "using assms"], ["proof (prove)\nusing this:\n  mono f\n\ngoal (1 subgoal):\n 1. (f ^^ n) {} \\<subseteq> (f ^^ Suc n) {}", "by(induction n) (auto simp: mono_def)"], ["proof (state)\nthis:\n  (f ^^ n) {} \\<subseteq> (f ^^ Suc n) {}\n\ngoal (1 subgoal):\n 1. chain (\\<lambda>n. (f ^^ n) {})", "}"], ["proof (state)\nthis:\n  (f ^^ ?n2) {} \\<subseteq> (f ^^ Suc ?n2) {}\n\ngoal (1 subgoal):\n 1. chain (\\<lambda>n. (f ^^ n) {})", "thus ?thesis"], ["proof (prove)\nusing this:\n  (f ^^ ?n2) {} \\<subseteq> (f ^^ Suc ?n2) {}\n\ngoal (1 subgoal):\n 1. chain (\\<lambda>n. (f ^^ n) {})", "by(auto simp: chain_def)"], ["proof (state)\nthis:\n  chain (\\<lambda>n. (f ^^ n) {})\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem lfp_if_cont:\n  assumes \"cont f\" shows \"lfp f =  (\\<Union>n. (f ^^ n) {})\" (is \"_ = ?U\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp f = (\\<Union>n. (f ^^ n) {})", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. lfp f \\<subseteq> (\\<Union>n. (f ^^ n) {})\n 2. (\\<Union>n. (f ^^ n) {}) \\<subseteq> lfp f", "show \"lfp f \\<subseteq> ?U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lfp f \\<subseteq> (\\<Union>n. (f ^^ n) {})", "proof (rule lfp_lowerbound)"], ["proof (state)\ngoal (1 subgoal):\n 1. f (\\<Union>n. (f ^^ n) {}) \\<subseteq> (\\<Union>n. (f ^^ n) {})", "have \"f ?U = (UN n. (f^^Suc n){})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f (\\<Union>n. (f ^^ n) {}) = (\\<Union>n. (f ^^ Suc n) {})", "using chain_iterates[OF mono_if_cont[OF assms]] assms"], ["proof (prove)\nusing this:\n  chain (\\<lambda>n. (f ^^ n) {})\n  cont f\n\ngoal (1 subgoal):\n 1. f (\\<Union>n. (f ^^ n) {}) = (\\<Union>n. (f ^^ Suc n) {})", "by(simp add: cont_def)"], ["proof (state)\nthis:\n  f (\\<Union>n. (f ^^ n) {}) = (\\<Union>n. (f ^^ Suc n) {})\n\ngoal (1 subgoal):\n 1. f (\\<Union>n. (f ^^ n) {}) \\<subseteq> (\\<Union>n. (f ^^ n) {})", "also"], ["proof (state)\nthis:\n  f (\\<Union>n. (f ^^ n) {}) = (\\<Union>n. (f ^^ Suc n) {})\n\ngoal (1 subgoal):\n 1. f (\\<Union>n. (f ^^ n) {}) \\<subseteq> (\\<Union>n. (f ^^ n) {})", "have \"\\<dots> = (f^^0){} \\<union> \\<dots>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Union>n. (f ^^ Suc n) {}) =\n    (f ^^ 0) {} \\<union> (\\<Union>n. (f ^^ Suc n) {})", "by simp"], ["proof (state)\nthis:\n  (\\<Union>n. (f ^^ Suc n) {}) =\n  (f ^^ 0) {} \\<union> (\\<Union>n. (f ^^ Suc n) {})\n\ngoal (1 subgoal):\n 1. f (\\<Union>n. (f ^^ n) {}) \\<subseteq> (\\<Union>n. (f ^^ n) {})", "also"], ["proof (state)\nthis:\n  (\\<Union>n. (f ^^ Suc n) {}) =\n  (f ^^ 0) {} \\<union> (\\<Union>n. (f ^^ Suc n) {})\n\ngoal (1 subgoal):\n 1. f (\\<Union>n. (f ^^ n) {}) \\<subseteq> (\\<Union>n. (f ^^ n) {})", "have \"\\<dots> = ?U\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f ^^ 0) {} \\<union> (\\<Union>n. (f ^^ Suc n) {}) =\n    (\\<Union>n. (f ^^ n) {})", "apply(auto simp del: funpow.simps)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x n.\n       x \\<in> (f ^^ n) {} \\<Longrightarrow>\n       \\<exists>xa. x \\<in> (f ^^ Suc xa) {}", "by (metis empty_iff funpow_0 old.nat.exhaust)"], ["proof (state)\nthis:\n  (f ^^ 0) {} \\<union> (\\<Union>n. (f ^^ Suc n) {}) =\n  (\\<Union>n. (f ^^ n) {})\n\ngoal (1 subgoal):\n 1. f (\\<Union>n. (f ^^ n) {}) \\<subseteq> (\\<Union>n. (f ^^ n) {})", "finally"], ["proof (chain)\npicking this:\n  f (\\<Union>n. (f ^^ n) {}) = (\\<Union>n. (f ^^ n) {})", "show \"f ?U \\<subseteq> ?U\""], ["proof (prove)\nusing this:\n  f (\\<Union>n. (f ^^ n) {}) = (\\<Union>n. (f ^^ n) {})\n\ngoal (1 subgoal):\n 1. f (\\<Union>n. (f ^^ n) {}) \\<subseteq> (\\<Union>n. (f ^^ n) {})", "by simp"], ["proof (state)\nthis:\n  f (\\<Union>n. (f ^^ n) {}) \\<subseteq> (\\<Union>n. (f ^^ n) {})\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  lfp f \\<subseteq> (\\<Union>n. (f ^^ n) {})\n\ngoal (1 subgoal):\n 1. (\\<Union>n. (f ^^ n) {}) \\<subseteq> lfp f", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Union>n. (f ^^ n) {}) \\<subseteq> lfp f", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Union>n. (f ^^ n) {}) \\<subseteq> lfp f", "fix n p"], ["proof (state)\ngoal (1 subgoal):\n 1. (\\<Union>n. (f ^^ n) {}) \\<subseteq> lfp f", "assume \"f p \\<subseteq> p\""], ["proof (state)\nthis:\n  f p \\<subseteq> p\n\ngoal (1 subgoal):\n 1. (\\<Union>n. (f ^^ n) {}) \\<subseteq> lfp f", "have \"(f^^n){} \\<subseteq> p\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f ^^ n) {} \\<subseteq> p", "proof(induction n)"], ["proof (state)\ngoal (2 subgoals):\n 1. (f ^^ 0) {} \\<subseteq> p\n 2. \\<And>n.\n       (f ^^ n) {} \\<subseteq> p \\<Longrightarrow>\n       (f ^^ Suc n) {} \\<subseteq> p", "case 0"], ["proof (state)\nthis:\n  \n\ngoal (2 subgoals):\n 1. (f ^^ 0) {} \\<subseteq> p\n 2. \\<And>n.\n       (f ^^ n) {} \\<subseteq> p \\<Longrightarrow>\n       (f ^^ Suc n) {} \\<subseteq> p", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (f ^^ 0) {} \\<subseteq> p", "by simp"], ["proof (state)\nthis:\n  (f ^^ 0) {} \\<subseteq> p\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (f ^^ n) {} \\<subseteq> p \\<Longrightarrow>\n       (f ^^ Suc n) {} \\<subseteq> p", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       (f ^^ n) {} \\<subseteq> p \\<Longrightarrow>\n       (f ^^ Suc n) {} \\<subseteq> p", "case Suc"], ["proof (state)\nthis:\n  (f ^^ n_) {} \\<subseteq> p\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       (f ^^ n) {} \\<subseteq> p \\<Longrightarrow>\n       (f ^^ Suc n) {} \\<subseteq> p", "from monoD[OF mono_if_cont[OF assms] Suc] \\<open>f p \\<subseteq> p\\<close>"], ["proof (chain)\npicking this:\n  f ((f ^^ n_) {}) \\<subseteq> f p\n  f p \\<subseteq> p", "show ?case"], ["proof (prove)\nusing this:\n  f ((f ^^ n_) {}) \\<subseteq> f p\n  f p \\<subseteq> p\n\ngoal (1 subgoal):\n 1. (f ^^ Suc n_) {} \\<subseteq> p", "by simp"], ["proof (state)\nthis:\n  (f ^^ Suc n_) {} \\<subseteq> p\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (f ^^ n) {} \\<subseteq> p\n\ngoal (1 subgoal):\n 1. (\\<Union>n. (f ^^ n) {}) \\<subseteq> lfp f", "}"], ["proof (state)\nthis:\n  f ?p2 \\<subseteq> ?p2 \\<Longrightarrow> (f ^^ ?n2) {} \\<subseteq> ?p2\n\ngoal (1 subgoal):\n 1. (\\<Union>n. (f ^^ n) {}) \\<subseteq> lfp f", "thus \"?U \\<subseteq> lfp f\""], ["proof (prove)\nusing this:\n  f ?p2 \\<subseteq> ?p2 \\<Longrightarrow> (f ^^ ?n2) {} \\<subseteq> ?p2\n\ngoal (1 subgoal):\n 1. (\\<Union>n. (f ^^ n) {}) \\<subseteq> lfp f", "by(auto simp: lfp_def)"], ["proof (state)\nthis:\n  (\\<Union>n. (f ^^ n) {}) \\<subseteq> lfp f\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma single_valued_UN_chain:\n  assumes \"chain S\" \"(!!n. single_valued (S n))\"\n  shows \"single_valued(UN n. S n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued (\\<Union> (range S))", "proof(auto simp: single_valued_def)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa z xb.\n       \\<lbrakk>(x, y) \\<in> S xa; (x, z) \\<in> S xb\\<rbrakk>\n       \\<Longrightarrow> y = z", "fix m n x y z"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y xa z xb.\n       \\<lbrakk>(x, y) \\<in> S xa; (x, z) \\<in> S xb\\<rbrakk>\n       \\<Longrightarrow> y = z", "assume \"(x, y) \\<in> S m\" \"(x, z) \\<in> S n\""], ["proof (state)\nthis:\n  (x, y) \\<in> S m\n  (x, z) \\<in> S n\n\ngoal (1 subgoal):\n 1. \\<And>x y xa z xb.\n       \\<lbrakk>(x, y) \\<in> S xa; (x, z) \\<in> S xb\\<rbrakk>\n       \\<Longrightarrow> y = z", "with chain_total[OF assms(1), of m n] assms(2)"], ["proof (chain)\npicking this:\n  S m \\<subseteq> S n \\<or> S n \\<subseteq> S m\n  single_valued (S ?n)\n  (x, y) \\<in> S m\n  (x, z) \\<in> S n", "show \"y = z\""], ["proof (prove)\nusing this:\n  S m \\<subseteq> S n \\<or> S n \\<subseteq> S m\n  single_valued (S ?n)\n  (x, y) \\<in> S m\n  (x, z) \\<in> S n\n\ngoal (1 subgoal):\n 1. y = z", "by (auto simp: single_valued_def)"], ["proof (state)\nthis:\n  y = z\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma single_valued_lfp: \nfixes f :: \"('a \\<times> 'a) set \\<Rightarrow> ('a \\<times> 'a) set\"\nassumes \"cont f\" \"\\<And>r. single_valued r \\<Longrightarrow> single_valued (f r)\"\nshows \"single_valued(lfp f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued (lfp f)", "unfolding lfp_if_cont[OF assms(1)]"], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued (\\<Union>n. (f ^^ n) {})", "proof(rule single_valued_UN_chain[OF chain_iterates[OF mono_if_cont[OF assms(1)]]])"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. single_valued ((f ^^ n) {})", "fix n"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n. single_valued ((f ^^ n) {})", "show \"single_valued ((f ^^ n) {})\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued ((f ^^ n) {})", "by(induction n)(auto simp: assms(2))"], ["proof (state)\nthis:\n  single_valued ((f ^^ n) {})\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Third Step: Definition of the Monadic While \\<open> \\<close>\\<close>"], ["", "definition \\<Gamma> :: \"['\\<sigma> \\<Rightarrow> bool,('\\<sigma> \\<times> '\\<sigma>) set] \\<Rightarrow> (('\\<sigma> \\<times> '\\<sigma>) set \\<Rightarrow> ('\\<sigma> \\<times> '\\<sigma>) set)\" \nwhere     \"\\<Gamma> b cd = (\\<lambda>cw. {(s,t). if b s then (s, t) \\<in> cd O cw else s = t})\""], ["", "definition while_SE :: \"['\\<sigma> \\<Rightarrow> bool, (unit, '\\<sigma>)MON\\<^sub>S\\<^sub>E] \\<Rightarrow> (unit, '\\<sigma>)MON\\<^sub>S\\<^sub>E\"\nwhere     \"while_SE c B \\<equiv> (Rel2Mon(lfp(\\<Gamma> c (Mon2Rel B))))\""], ["", "syntax    (xsymbols)\n          \"_while_SE\" :: \"['\\<sigma> \\<Rightarrow> bool, (unit, '\\<sigma>)MON\\<^sub>S\\<^sub>E] \\<Rightarrow> (unit, '\\<sigma>)MON\\<^sub>S\\<^sub>E\" \n          (\"(while\\<^sub>S\\<^sub>E _ do _ od)\" [8,8]8)"], ["", "translations \n          \"while\\<^sub>S\\<^sub>E c do b od\" == \"CONST while_SE c b\""], ["", "lemma cont_\\<Gamma>: \"cont (\\<Gamma> c b)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<Gamma> c b)", "by (auto simp: cont_def \\<Gamma>_def)"], ["", "text\\<open>The fixpoint theory now allows us to establish that the lfp constructed over\n       @{term Mon2Rel} remains deterministic\\<close>"], ["", "theorem single_valued_lfp_Mon2Rel: \"single_valued (lfp(\\<Gamma> c (Mon2Rel B)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. single_valued (lfp (\\<Gamma> c (Mon2Rel B)))", "apply(rule single_valued_lfp, simp_all add: cont_\\<Gamma>)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r.\n       single_valued r \\<Longrightarrow>\n       single_valued (\\<Gamma> c (Mon2Rel B) r)", "apply(auto simp: \\<Gamma>_def single_valued_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>r ya z xb yb zb.\n       \\<lbrakk>\\<forall>x y.\n                   (x, y) \\<in> r \\<longrightarrow>\n                   (\\<forall>z. (x, z) \\<in> r \\<longrightarrow> y = z);\n        c xb; (xb, ya) \\<in> Mon2Rel B; (ya, z) \\<in> r;\n        (xb, yb) \\<in> Mon2Rel B; (yb, zb) \\<in> r\\<rbrakk>\n       \\<Longrightarrow> z = zb", "apply(metis single_valued_Mon2Rel[of \"B\"] single_valued_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma Rel2Mon_if:\n  \"Rel2Mon {(s, t). if b s then (s, t) \\<in> Mon2Rel c O lfp (\\<Gamma> b (Mon2Rel c)) else s = t} \\<sigma> =\n  (if b \\<sigma> then Rel2Mon (Mon2Rel c O lfp (\\<Gamma> b (Mon2Rel c))) \\<sigma> else Some ((), \\<sigma>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rel2Mon\n     {(s, t).\n      if b s then (s, t) \\<in> Mon2Rel c O lfp (\\<Gamma> b (Mon2Rel c))\n      else s = t}\n     \\<sigma> =\n    (if b \\<sigma>\n     then Rel2Mon (Mon2Rel c O lfp (\\<Gamma> b (Mon2Rel c))) \\<sigma>\n     else Some ((), \\<sigma>))", "by (simp add: Rel2Mon_def)"], ["", "lemma Rel2Mon_homomorphism:\n  assumes determ_X: \"single_valued X\" and determ_Y: \"single_valued Y\"\n  shows   \"Rel2Mon (X O Y) = (Rel2Mon X) ;- (Rel2Mon Y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Rel2Mon (X O Y) = Rel2Mon X ;- Rel2Mon Y", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. Rel2Mon (X O Y) = Rel2Mon X ;- Rel2Mon Y", "have relational_partial_next_in_O: \"\\<And>x E F. (\\<exists>y. (x, y) \\<in> (E O F)) \\<Longrightarrow> (\\<exists>y. (x, y) \\<in> E)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x E F.\n       \\<exists>y. (x, y) \\<in> E O F \\<Longrightarrow>\n       \\<exists>y. (x, y) \\<in> E", "by (auto)"], ["proof (state)\nthis:\n  \\<exists>y. (?x, y) \\<in> ?E O ?F \\<Longrightarrow>\n  \\<exists>y. (?x, y) \\<in> ?E\n\ngoal (1 subgoal):\n 1. Rel2Mon (X O Y) = Rel2Mon X ;- Rel2Mon Y", "have some_eq_intro: \"\\<And> X x y . single_valued X \\<Longrightarrow> (x, y) \\<in> X \\<Longrightarrow> (SOME y. (x, y) \\<in> X) = y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>X x y.\n       \\<lbrakk>single_valued X; (x, y) \\<in> X\\<rbrakk>\n       \\<Longrightarrow> (SOME y. (x, y) \\<in> X) = y", "by (auto simp: single_valued_def)"], ["proof (state)\nthis:\n  \\<lbrakk>single_valued ?X1; (?x1, ?y1) \\<in> ?X1\\<rbrakk>\n  \\<Longrightarrow> (SOME y. (?x1, y) \\<in> ?X1) = ?y1\n\ngoal (1 subgoal):\n 1. Rel2Mon (X O Y) = Rel2Mon X ;- Rel2Mon Y", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rel2Mon (X O Y) = Rel2Mon X ;- Rel2Mon Y", "apply (simp add: Rel2Mon_def bind_SE'_def bind_SE_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>\\<sigma>.\n        if \\<exists>\\<sigma>'. (\\<sigma>, \\<sigma>') \\<in> X O Y\n        then Some ((), SOME \\<sigma>'. (\\<sigma>, \\<sigma>') \\<in> X O Y)\n        else None) =\n    (\\<lambda>\\<sigma>.\n        case if \\<exists>\\<sigma>'. (\\<sigma>, \\<sigma>') \\<in> X\n             then Some ((), SOME \\<sigma>'. (\\<sigma>, \\<sigma>') \\<in> X)\n             else None of\n        None \\<Rightarrow> None\n        | Some (out, \\<sigma>') \\<Rightarrow>\n            if \\<exists>\\<sigma>''. (\\<sigma>', \\<sigma>'') \\<in> Y\n            then Some ((), SOME \\<sigma>''. (\\<sigma>', \\<sigma>'') \\<in> Y)\n            else None)", "apply (rule ext, rename_tac \"\\<sigma>\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       (if \\<exists>\\<sigma>'. (\\<sigma>, \\<sigma>') \\<in> X O Y\n        then Some ((), SOME \\<sigma>'. (\\<sigma>, \\<sigma>') \\<in> X O Y)\n        else None) =\n       (case if \\<exists>\\<sigma>'. (\\<sigma>, \\<sigma>') \\<in> X\n             then Some ((), SOME \\<sigma>'. (\\<sigma>, \\<sigma>') \\<in> X)\n             else None of\n        None \\<Rightarrow> None\n        | Some (out, \\<sigma>') \\<Rightarrow>\n            if \\<exists>\\<sigma>''. (\\<sigma>', \\<sigma>'') \\<in> Y\n            then Some ((), SOME \\<sigma>''. (\\<sigma>', \\<sigma>'') \\<in> Y)\n            else None)", "apply (case_tac \" \\<exists> \\<sigma>'. (\\<sigma>, \\<sigma>') \\<in> X O Y\")"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       \\<exists>\\<sigma>'.\n          (\\<sigma>, \\<sigma>') \\<in> X O Y \\<Longrightarrow>\n       (if \\<exists>\\<sigma>'. (\\<sigma>, \\<sigma>') \\<in> X O Y\n        then Some ((), SOME \\<sigma>'. (\\<sigma>, \\<sigma>') \\<in> X O Y)\n        else None) =\n       (case if \\<exists>\\<sigma>'. (\\<sigma>, \\<sigma>') \\<in> X\n             then Some ((), SOME \\<sigma>'. (\\<sigma>, \\<sigma>') \\<in> X)\n             else None of\n        None \\<Rightarrow> None\n        | Some (out, \\<sigma>') \\<Rightarrow>\n            if \\<exists>\\<sigma>''. (\\<sigma>', \\<sigma>'') \\<in> Y\n            then Some ((), SOME \\<sigma>''. (\\<sigma>', \\<sigma>'') \\<in> Y)\n            else None)\n 2. \\<And>\\<sigma>.\n       \\<nexists>\\<sigma>'.\n          (\\<sigma>, \\<sigma>') \\<in> X O Y \\<Longrightarrow>\n       (if \\<exists>\\<sigma>'. (\\<sigma>, \\<sigma>') \\<in> X O Y\n        then Some ((), SOME \\<sigma>'. (\\<sigma>, \\<sigma>') \\<in> X O Y)\n        else None) =\n       (case if \\<exists>\\<sigma>'. (\\<sigma>, \\<sigma>') \\<in> X\n             then Some ((), SOME \\<sigma>'. (\\<sigma>, \\<sigma>') \\<in> X)\n             else None of\n        None \\<Rightarrow> None\n        | Some (out, \\<sigma>') \\<Rightarrow>\n            if \\<exists>\\<sigma>''. (\\<sigma>', \\<sigma>'') \\<in> Y\n            then Some ((), SOME \\<sigma>''. (\\<sigma>', \\<sigma>'') \\<in> Y)\n            else None)", "apply (simp only: HOL.if_True)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       \\<exists>\\<sigma>'.\n          (\\<sigma>, \\<sigma>') \\<in> X O Y \\<Longrightarrow>\n       Some ((), SOME \\<sigma>'. (\\<sigma>, \\<sigma>') \\<in> X O Y) =\n       (case if \\<exists>\\<sigma>'. (\\<sigma>, \\<sigma>') \\<in> X\n             then Some ((), SOME \\<sigma>'. (\\<sigma>, \\<sigma>') \\<in> X)\n             else None of\n        None \\<Rightarrow> None\n        | Some (out, \\<sigma>') \\<Rightarrow>\n            if \\<exists>\\<sigma>''. (\\<sigma>', \\<sigma>'') \\<in> Y\n            then Some ((), SOME \\<sigma>''. (\\<sigma>', \\<sigma>'') \\<in> Y)\n            else None)\n 2. \\<And>\\<sigma>.\n       \\<nexists>\\<sigma>'.\n          (\\<sigma>, \\<sigma>') \\<in> X O Y \\<Longrightarrow>\n       (if \\<exists>\\<sigma>'. (\\<sigma>, \\<sigma>') \\<in> X O Y\n        then Some ((), SOME \\<sigma>'. (\\<sigma>, \\<sigma>') \\<in> X O Y)\n        else None) =\n       (case if \\<exists>\\<sigma>'. (\\<sigma>, \\<sigma>') \\<in> X\n             then Some ((), SOME \\<sigma>'. (\\<sigma>, \\<sigma>') \\<in> X)\n             else None of\n        None \\<Rightarrow> None\n        | Some (out, \\<sigma>') \\<Rightarrow>\n            if \\<exists>\\<sigma>''. (\\<sigma>', \\<sigma>'') \\<in> Y\n            then Some ((), SOME \\<sigma>''. (\\<sigma>', \\<sigma>'') \\<in> Y)\n            else None)", "apply (frule relational_partial_next_in_O)"], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>\\<sigma>.\n       \\<lbrakk>\\<exists>\\<sigma>'. (\\<sigma>, \\<sigma>') \\<in> X O Y;\n        \\<exists>y. (\\<sigma>, y) \\<in> X\\<rbrakk>\n       \\<Longrightarrow> Some\n                          ((),\n                           SOME \\<sigma>'.\n                              (\\<sigma>, \\<sigma>') \\<in> X O Y) =\n                         (case if \\<exists>\\<sigma>'.\n                                     (\\<sigma>, \\<sigma>') \\<in> X\n                               then Some\n                                     ((),\nSOME \\<sigma>'. (\\<sigma>, \\<sigma>') \\<in> X)\n                               else None of\n                          None \\<Rightarrow> None\n                          | Some (out, \\<sigma>') \\<Rightarrow>\n                              if \\<exists>\\<sigma>''.\n                                    (\\<sigma>', \\<sigma>'') \\<in> Y\n                              then Some\n                                    ((),\n                                     SOME \\<sigma>''.\n  (\\<sigma>', \\<sigma>'') \\<in> Y)\n                              else None)\n 2. \\<And>\\<sigma>.\n       \\<nexists>\\<sigma>'.\n          (\\<sigma>, \\<sigma>') \\<in> X O Y \\<Longrightarrow>\n       (if \\<exists>\\<sigma>'. (\\<sigma>, \\<sigma>') \\<in> X O Y\n        then Some ((), SOME \\<sigma>'. (\\<sigma>, \\<sigma>') \\<in> X O Y)\n        else None) =\n       (case if \\<exists>\\<sigma>'. (\\<sigma>, \\<sigma>') \\<in> X\n             then Some ((), SOME \\<sigma>'. (\\<sigma>, \\<sigma>') \\<in> X)\n             else None of\n        None \\<Rightarrow> None\n        | Some (out, \\<sigma>') \\<Rightarrow>\n            if \\<exists>\\<sigma>''. (\\<sigma>', \\<sigma>'') \\<in> Y\n            then Some ((), SOME \\<sigma>''. (\\<sigma>', \\<sigma>'') \\<in> Y)\n            else None)", "apply (auto simp: single_valued_relcomp some_eq_intro determ_X determ_Y relcomp.relcompI)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma> \\<sigma>' \\<sigma>''.\n       \\<lbrakk>\\<forall>\\<sigma>'. (\\<sigma>, \\<sigma>') \\<notin> X O Y;\n        (\\<sigma>'', \\<sigma>') \\<in> Y;\n        (\\<sigma>, \\<sigma>'') \\<in> X\\<rbrakk>\n       \\<Longrightarrow> False", "by blast"], ["proof (state)\nthis:\n  Rel2Mon (X O Y) = Rel2Mon X ;- Rel2Mon Y\n\ngoal:\nNo subgoals!", "qed"], ["", "text\\<open>Putting everything together, the theory of embedding and the invariance of\n       determinism of the while-body, gives us the usual unfold-theorem:\\<close>"], ["", "theorem while_SE_unfold:\n\"(while\\<^sub>S\\<^sub>E b do c od) = (if\\<^sub>S\\<^sub>E b then (c ;- (while\\<^sub>S\\<^sub>E b do c od)) else result () fi)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. _while_SE b c = _if_SE b (c ;- _while_SE b c) (unit\\<^sub>S\\<^sub>E ())", "apply (simp add: if_SE_def bind_SE'_def while_SE_def unit_SE_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rel2Mon (lfp (\\<Gamma> b (Mon2Rel c))) =\n    (\\<lambda>\\<sigma>.\n        if b \\<sigma>\n        then (_bind_SE _ c (Rel2Mon (lfp (\\<Gamma> b (Mon2Rel c)))))\n              \\<sigma>\n        else Some ((), \\<sigma>))", "apply (subst lfp_unfold [OF mono_if_cont, OF cont_\\<Gamma>])"], ["proof (prove)\ngoal (1 subgoal):\n 1. Rel2Mon (\\<Gamma> b (Mon2Rel c) (lfp (\\<Gamma> b (Mon2Rel c)))) =\n    (\\<lambda>\\<sigma>.\n        if b \\<sigma>\n        then (_bind_SE _ c (Rel2Mon (lfp (\\<Gamma> b (Mon2Rel c)))))\n              \\<sigma>\n        else Some ((), \\<sigma>))", "apply (rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       Rel2Mon (\\<Gamma> b (Mon2Rel c) (lfp (\\<Gamma> b (Mon2Rel c))))\n        \\<sigma> =\n       (if b \\<sigma>\n        then (_bind_SE _ c (Rel2Mon (lfp (\\<Gamma> b (Mon2Rel c)))))\n              \\<sigma>\n        else Some ((), \\<sigma>))", "apply (subst \\<Gamma>_def)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>\\<sigma>.\n       Rel2Mon\n        {(s, t).\n         if b s then (s, t) \\<in> Mon2Rel c O lfp (\\<Gamma> b (Mon2Rel c))\n         else s = t}\n        \\<sigma> =\n       (if b \\<sigma>\n        then (_bind_SE _ c (Rel2Mon (lfp (\\<Gamma> b (Mon2Rel c)))))\n              \\<sigma>\n        else Some ((), \\<sigma>))", "apply (auto simp: Rel2Mon_if Rel2Mon_homomorphism bind_SE'_def Rel2Mon_Id [simplified comp_def] \n                  single_valued_Mon2Rel single_valued_lfp_Mon2Rel )"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["", "lemma bind_cong : \" f \\<sigma> = g \\<sigma> \\<Longrightarrow>  (x \\<leftarrow> f ; M x)\\<sigma> = (x \\<leftarrow> g ; M x)\\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<sigma> = g \\<sigma> \\<Longrightarrow>\n    bind\\<^sub>S\\<^sub>E f M \\<sigma> = bind\\<^sub>S\\<^sub>E g M \\<sigma>", "unfolding bind_SE'_def bind_SE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<sigma> = g \\<sigma> \\<Longrightarrow>\n    (case f \\<sigma> of None \\<Rightarrow> None\n     | Some (xa, xb) \\<Rightarrow> M xa xb) =\n    (case g \\<sigma> of None \\<Rightarrow> None\n     | Some (xa, xb) \\<Rightarrow> M xa xb)", "by simp"], ["", "lemma bind'_cong : \" f \\<sigma> = g \\<sigma> \\<Longrightarrow>  (f ;- M )\\<sigma> = (g ;- M )\\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<sigma> = g \\<sigma> \\<Longrightarrow>\n    (f ;- M) \\<sigma> = (g ;- M) \\<sigma>", "unfolding bind_SE'_def bind_SE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<sigma> = g \\<sigma> \\<Longrightarrow>\n    (case f \\<sigma> of None \\<Rightarrow> None\n     | Some (uu_, xa) \\<Rightarrow> M xa) =\n    (case g \\<sigma> of None \\<Rightarrow> None\n     | Some (uu_, xa) \\<Rightarrow> M xa)", "by simp"], ["", "lemma if\\<^sub>S\\<^sub>E_True [simp]: \"(if\\<^sub>S\\<^sub>E (\\<lambda> x. True) then c else d fi) = c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. _if_SE (\\<lambda>x. True) c d = c", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (_if_SE (\\<lambda>x. True) c d) x = c x", "by (simp add: MonadSE.if_SE_def)"], ["", "lemma if\\<^sub>S\\<^sub>E_False [simp]: \"(if\\<^sub>S\\<^sub>E (\\<lambda> x. False) then c else d fi) = d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. _if_SE (\\<lambda>x. False) c d = d", "apply(rule ext)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x. (_if_SE (\\<lambda>x. False) c d) x = d x", "by (simp add: MonadSE.if_SE_def)"], ["", "lemma if\\<^sub>S\\<^sub>E_cond_cong : \"f \\<sigma> = g \\<sigma> \\<Longrightarrow> \n                           (if\\<^sub>S\\<^sub>E f then c else d fi) \\<sigma> = \n                           (if\\<^sub>S\\<^sub>E g then c else d fi) \\<sigma>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<sigma> = g \\<sigma> \\<Longrightarrow>\n    (_if_SE f c d) \\<sigma> = (_if_SE g c d) \\<sigma>", "unfolding if_SE_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. f \\<sigma> = g \\<sigma> \\<Longrightarrow>\n    (if f \\<sigma> then c \\<sigma> else d \\<sigma>) =\n    (if g \\<sigma> then c \\<sigma> else d \\<sigma>)", "by simp"], ["", "lemma while\\<^sub>S\\<^sub>E_skip[simp] : \"(while\\<^sub>S\\<^sub>E (\\<lambda> x. False) do c od) = skip\\<^sub>S\\<^sub>E\""], ["proof (prove)\ngoal (1 subgoal):\n 1. _while_SE (\\<lambda>x. False) c = skip\\<^sub>S\\<^sub>E", "apply(rule ext,subst MonadSE.while_SE_unfold)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>x.\n       (_if_SE (\\<lambda>x. False) (c ;- _while_SE (\\<lambda>x. False) c)\n         (unit\\<^sub>S\\<^sub>E ()))\n        x =\n       skip\\<^sub>S\\<^sub>E x", "by (simp add: MonadSE.if_SE_def skip\\<^sub>S\\<^sub>E_def)"], ["", "end"]]}