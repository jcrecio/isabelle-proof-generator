{"file_name": "/home/qj213/afp-2021-10-22/thys/BirdKMP/HOLCF_ROOT.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/BirdKMP", "problem_names": ["lemma lfp_fusion:\n  assumes \"g\\<cdot>\\<bottom> = \\<bottom>\"\n  assumes \"g oo f = h oo g\"\n  shows \"g\\<cdot>(fix\\<cdot>f) = fix\\<cdot>h\"", "lemma predE:\n  obtains (strict) \"p\\<cdot>\\<bottom> = \\<bottom>\" | (FF) \"p = (\\<Lambda> x. FF)\" | (TT) \"p = (\\<Lambda> x. TT)\"", "lemma retraction_cfcomp_strict:\n  assumes \"f oo g = ID\"\n  shows \"f\\<cdot>\\<bottom> = \\<bottom>\"", "lemma match_Pair_csplit[simp]: \"match_Pair\\<cdot>x\\<cdot>k = k\\<cdot>(cfst\\<cdot>x)\\<cdot>(csnd\\<cdot>x)\"", "lemmas oo_assoc = assoc_oo \\<comment>\\<open>Normalize name\\<close>", "lemma If_cancel[simp]: \"(If b then x else x) = seq\\<cdot>b\\<cdot>x\"", "lemma seq_below[iff]: \"seq\\<cdot>x\\<cdot>y \\<sqsubseteq> y\"", "lemma seq_strict_distr: \"f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow> seq\\<cdot>x\\<cdot>(f\\<cdot>y) = f\\<cdot>(seq\\<cdot>x\\<cdot>y)\"", "lemma strictify_below[iff]: \"strictify\\<cdot>f \\<sqsubseteq> f\"", "lemma If_distr:\n  \"\\<lbrakk>f \\<bottom> = \\<bottom>; cont f\\<rbrakk> \\<Longrightarrow> f (If b then t else e) = (If b then f t else f e)\"\n  \"\\<lbrakk>cont t'; cont e'\\<rbrakk> \\<Longrightarrow> (If b then t' else e') x = (If b then t' x else e' x)\"\n  \"(If b then t''' else e''')\\<cdot>x = (If b then t'''\\<cdot>x else e'''\\<cdot>x)\"\n  \"\\<lbrakk>g \\<bottom> = \\<bottom>; cont g\\<rbrakk> \\<Longrightarrow> g (If b then t'' else e'') y = (If b then g t'' y else g e'' y)\"", "lemma If2_split_asm: \"P (If2 Q x y) \\<longleftrightarrow> \\<not>(Q = \\<bottom> \\<and> \\<not>P \\<bottom> \\<or> Q = TT \\<and> \\<not>P x \\<or> Q = FF \\<and> \\<not>P y)\"", "lemmas If2_splits = split_If2 If2_split_asm", "lemma If2_cont[simp, cont2cont]:\n  assumes \"cont i\"\n  assumes \"cont t\"\n  assumes \"cont e\"\n  shows \"cont (\\<lambda>x. If2 (i x) (t x) (e x))\"", "lemma If_else_FF[simp]: \"(If b then t else FF) = (b andalso t)\"", "lemma If_then_TT[simp]: \"(If b then TT else e) = (b orelse e)\"", "lemma If_cong:\n  assumes \"b = b'\"\n  assumes\"b = TT \\<Longrightarrow> t = t'\"\n  assumes \"b = FF \\<Longrightarrow> e = e'\"\n  shows \"(If b then t else e) = (If b' then t' else e')\"", "lemma If_tr: \"(If b then t else e) = ((b andalso t) orelse (neg\\<cdot>b andalso e))\"", "lemma If_andalso:\n  shows \"If p andalso q then t else e = If p then If q then t else e else e\"", "lemma If_else_absorb:\n  assumes \"c = \\<bottom> \\<Longrightarrow> e = \\<bottom>\"\n  assumes \"c = TT \\<Longrightarrow> e = t\"\n  shows \"If c then t else e = e\"", "lemma andalso_cong: \"\\<lbrakk>P = P'; P' = TT \\<Longrightarrow> Q = Q'\\<rbrakk> \\<Longrightarrow> (P andalso Q) = (P' andalso Q')\"", "lemma andalso_weaken_left:\n  assumes \"P = TT \\<Longrightarrow> Q = TT\"\n  assumes \"P = FF \\<Longrightarrow> Q \\<noteq> \\<bottom>\"\n  assumes \"P = \\<bottom> \\<Longrightarrow> Q \\<noteq> FF\"\n  shows \"P = (Q andalso P)\"", "lemma orelse_cong: \"\\<lbrakk>P = P'; P' = FF \\<Longrightarrow> Q = Q'\\<rbrakk> \\<Longrightarrow> (P orelse Q) = (P' orelse Q')\"", "lemma orelse_conv[simp]:\n  \"((x orelse y) = TT) \\<longleftrightarrow> (x = TT \\<or> (x = FF \\<and> y = TT))\"\n  \"((x orelse y) = \\<bottom>) \\<longleftrightarrow> (x = \\<bottom> \\<or> (x = FF \\<and> y = \\<bottom>))\"", "lemma csplit_cfun2: \"cont F \\<Longrightarrow> (\\<Lambda> x. F x) = (\\<Lambda> (x, y). F (x, y))\"", "lemma csplit_cfun3: \"cont F \\<Longrightarrow> (\\<Lambda> x. F x) = (\\<Lambda> (x, y, z). F (x, y, z))\"", "lemma convol_strict[simp]:\n  \"convol\\<cdot>\\<bottom>\\<cdot>\\<bottom> = \\<bottom>\"", "lemma convol_simp[simp]: \"(f && g)\\<cdot>x = (f\\<cdot>x, g\\<cdot>x)\"", "lemma map_prod_cfcomp[simp]: \"(f ** m) oo (g ** n) = (f oo g) ** (m oo n)\"", "lemma map_prod_ID[simp]: \"ID ** ID = ID\"", "lemma map_prod_app[simp]: \"(f ** g)\\<cdot>x = (f\\<cdot>(cfst\\<cdot>x), g\\<cdot>(csnd\\<cdot>x))\"", "lemma map_prod_cfst[simp]: \"cfst oo (f ** g) = f oo cfst\"", "lemma map_prod_csnd[simp]: \"csnd oo (f ** g) = g oo csnd\"", "lemma eq_strict[simp]: \"eq\\<cdot>(\\<bottom>::'a::Eq_strict) = \\<bottom>\"", "lemma Integer_le_both_plus_1[simp]:\n  fixes m :: Integer\n  shows \"le\\<cdot>(m + 1)\\<cdot>(n + 1) = le\\<cdot>m\\<cdot>n\"", "lemma plus_eq_MkI_conv:\n  \"l + n = MkI\\<cdot>m \\<longleftrightarrow> (\\<exists>l' n'. l = MkI\\<cdot>l' \\<and> n = MkI\\<cdot>n' \\<and> m = l' + n')\"", "lemma lt_defined:\n  fixes x :: Integer\n  shows\n    \"lt\\<cdot>x\\<cdot>y = TT \\<Longrightarrow> (x \\<noteq> \\<bottom> \\<and> y \\<noteq> \\<bottom>)\"\n    \"lt\\<cdot>x\\<cdot>y = FF \\<Longrightarrow> (x \\<noteq> \\<bottom> \\<and> y \\<noteq> \\<bottom>)\"", "lemma le_defined:\n  fixes x :: Integer\n  shows\n    \"le\\<cdot>x\\<cdot>y = TT \\<Longrightarrow> (x \\<noteq> \\<bottom> \\<and> y \\<noteq> \\<bottom>)\"\n    \"le\\<cdot>x\\<cdot>y = FF \\<Longrightarrow> (x \\<noteq> \\<bottom> \\<and> y \\<noteq> \\<bottom>)\"", "lemma wf_Integer_ge_less_than: \"wf (Integer_ge_less_than d)\"", "lemma eq_bottom_iff[simp]: \"(eq\\<cdot>x\\<cdot>y = \\<bottom>) \\<longleftrightarrow> (x = \\<bottom> \\<or> y = \\<bottom>)\"", "lemma eq_defined_reflD[simp]:\n  \"(eq\\<cdot>a\\<cdot>a = TT) \\<longleftrightarrow> a \\<noteq> \\<bottom>\"\n  \"(TT = eq\\<cdot>a\\<cdot>a) \\<longleftrightarrow> a \\<noteq> \\<bottom>\"\n  \"a \\<noteq> \\<bottom> \\<Longrightarrow> eq\\<cdot>a\\<cdot>a = TT\"", "lemma eq_FF[simp]:\n  \"(FF = eq\\<cdot>xs\\<cdot>ys) \\<longleftrightarrow> (xs \\<noteq> \\<bottom> \\<and> ys \\<noteq> \\<bottom> \\<and> xs \\<noteq> ys)\"\n  \"(eq\\<cdot>xs\\<cdot>ys = FF) \\<longleftrightarrow> (xs \\<noteq> \\<bottom> \\<and> ys \\<noteq> \\<bottom> \\<and> xs \\<noteq> ys)\"", "lemma eq_TT[simp]:\n  \"(TT = eq\\<cdot>xs\\<cdot>ys) \\<longleftrightarrow> (xs \\<noteq> \\<bottom> \\<and> ys \\<noteq> \\<bottom> \\<and> xs = ys)\"\n  \"(eq\\<cdot>xs\\<cdot>ys = TT) \\<longleftrightarrow> (xs \\<noteq> \\<bottom> \\<and> ys \\<noteq> \\<bottom> \\<and> xs = ys)\""], "translations": [["", "lemma lfp_fusion:\n  assumes \"g\\<cdot>\\<bottom> = \\<bottom>\"\n  assumes \"g oo f = h oo g\"\n  shows \"g\\<cdot>(fix\\<cdot>f) = fix\\<cdot>h\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g\\<cdot>(fix\\<cdot>f) = fix\\<cdot>h", "proof(induct rule: parallel_fix_ind)"], ["proof (state)\ngoal (3 subgoals):\n 1. adm (\\<lambda>x. g\\<cdot>(prod.fst x) = prod.snd x)\n 2. g\\<cdot>\\<bottom> = \\<bottom>\n 3. \\<And>x y.\n       g\\<cdot>x = y \\<Longrightarrow> g\\<cdot>(f\\<cdot>x) = h\\<cdot>y", "case 2"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. adm (\\<lambda>x. g\\<cdot>(prod.fst x) = prod.snd x)\n 2. g\\<cdot>\\<bottom> = \\<bottom>\n 3. \\<And>x y.\n       g\\<cdot>x = y \\<Longrightarrow> g\\<cdot>(f\\<cdot>x) = h\\<cdot>y", "show \"g\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g\\<cdot>\\<bottom> = \\<bottom>", "by fact"], ["proof (state)\nthis:\n  g\\<cdot>\\<bottom> = \\<bottom>\n\ngoal (2 subgoals):\n 1. adm (\\<lambda>x. g\\<cdot>(prod.fst x) = prod.snd x)\n 2. \\<And>x y.\n       g\\<cdot>x = y \\<Longrightarrow> g\\<cdot>(f\\<cdot>x) = h\\<cdot>y", "case (3 x y)"], ["proof (state)\nthis:\n  g\\<cdot>x = y\n\ngoal (2 subgoals):\n 1. adm (\\<lambda>x. g\\<cdot>(prod.fst x) = prod.snd x)\n 2. \\<And>x y.\n       g\\<cdot>x = y \\<Longrightarrow> g\\<cdot>(f\\<cdot>x) = h\\<cdot>y", "from \\<open>g\\<cdot>x = y\\<close> \\<open>g oo f = h oo g\\<close>"], ["proof (chain)\npicking this:\n  g\\<cdot>x = y\n  g oo f = h oo g", "show \"g\\<cdot>(f\\<cdot>x) = h\\<cdot>y\""], ["proof (prove)\nusing this:\n  g\\<cdot>x = y\n  g oo f = h oo g\n\ngoal (1 subgoal):\n 1. g\\<cdot>(f\\<cdot>x) = h\\<cdot>y", "by (simp add: cfun_eq_iff)"], ["proof (state)\nthis:\n  g\\<cdot>(f\\<cdot>x) = h\\<cdot>y\n\ngoal (1 subgoal):\n 1. adm (\\<lambda>x. g\\<cdot>(prod.fst x) = prod.snd x)", "qed simp"], ["", "lemma predE:\n  obtains (strict) \"p\\<cdot>\\<bottom> = \\<bottom>\" | (FF) \"p = (\\<Lambda> x. FF)\" | (TT) \"p = (\\<Lambda> x. TT)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>p\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow> thesis;\n     p = (\\<Lambda> x. FF) \\<Longrightarrow> thesis;\n     p = (\\<Lambda> x. TT) \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "using flat_codom[where f=p and x=\\<bottom>]"], ["proof (prove)\nusing this:\n  p\\<cdot>\\<bottom> = ?c \\<Longrightarrow>\n  p\\<cdot>\\<bottom> = \\<bottom> \\<or> (\\<forall>z. p\\<cdot>z = ?c)\n\ngoal (1 subgoal):\n 1. \\<lbrakk>p\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow> thesis;\n     p = (\\<Lambda> x. FF) \\<Longrightarrow> thesis;\n     p = (\\<Lambda> x. TT) \\<Longrightarrow> thesis\\<rbrakk>\n    \\<Longrightarrow> thesis", "by (cases \"p\\<cdot>\\<bottom>\"; force simp: cfun_eq_iff)"], ["", "lemma retraction_cfcomp_strict:\n  assumes \"f oo g = ID\"\n  shows \"f\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f\\<cdot>\\<bottom> = \\<bottom>", "using assms retraction_strict"], ["proof (prove)\nusing this:\n  f oo g = ID\n  \\<forall>x. ?f\\<cdot>(?g\\<cdot>x) = x \\<Longrightarrow>\n  ?f\\<cdot>\\<bottom> = \\<bottom>\n\ngoal (1 subgoal):\n 1. f\\<cdot>\\<bottom> = \\<bottom>", "by (clarsimp simp: cfun_eq_iff)"], ["", "lemma match_Pair_csplit[simp]: \"match_Pair\\<cdot>x\\<cdot>k = k\\<cdot>(cfst\\<cdot>x)\\<cdot>(csnd\\<cdot>x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match_Pair\\<cdot>x\\<cdot>k = k\\<cdot>(cfst\\<cdot>x)\\<cdot>(csnd\\<cdot>x)", "by (cases x) simp"], ["", "lemmas oo_assoc = assoc_oo \\<comment>\\<open>Normalize name\\<close>"], ["", "lemma If_cancel[simp]: \"(If b then x else x) = seq\\<cdot>b\\<cdot>x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. If b then x else x = seq\\<cdot>b\\<cdot>x", "by (cases b) simp_all"], ["", "lemma seq_below[iff]: \"seq\\<cdot>x\\<cdot>y \\<sqsubseteq> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. seq\\<cdot>x\\<cdot>y \\<sqsubseteq> y", "by (simp add: seq_conv_if)"], ["", "lemma seq_strict_distr: \"f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow> seq\\<cdot>x\\<cdot>(f\\<cdot>y) = f\\<cdot>(seq\\<cdot>x\\<cdot>y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow>\n    seq\\<cdot>x\\<cdot>(f\\<cdot>y) = f\\<cdot>(seq\\<cdot>x\\<cdot>y)", "by (cases \"x = \\<bottom>\"; clarsimp)"], ["", "lemma strictify_below[iff]: \"strictify\\<cdot>f \\<sqsubseteq> f\""], ["proof (prove)\ngoal (1 subgoal):\n 1. strictify\\<cdot>f \\<sqsubseteq> f", "unfolding strictify_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> f x. seq\\<cdot>x\\<cdot>(f\\<cdot>x))\\<cdot>f \\<sqsubseteq> f", "by (clarsimp simp: cfun_below_iff)"], ["", "lemma If_distr:\n  \"\\<lbrakk>f \\<bottom> = \\<bottom>; cont f\\<rbrakk> \\<Longrightarrow> f (If b then t else e) = (If b then f t else f e)\"\n  \"\\<lbrakk>cont t'; cont e'\\<rbrakk> \\<Longrightarrow> (If b then t' else e') x = (If b then t' x else e' x)\"\n  \"(If b then t''' else e''')\\<cdot>x = (If b then t'''\\<cdot>x else e'''\\<cdot>x)\"\n  \"\\<lbrakk>g \\<bottom> = \\<bottom>; cont g\\<rbrakk> \\<Longrightarrow> g (If b then t'' else e'') y = (If b then g t'' y else g e'' y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>f \\<bottom> = \\<bottom>; cont f\\<rbrakk>\n      \\<Longrightarrow> f (If b then t else e) = If b then f t else f e) &&&\n     (\\<lbrakk>cont t'; cont e'\\<rbrakk>\n      \\<Longrightarrow> (If b then t' else e') x =\n                        If b then t' x else e' x)) &&&\n    (If b then t''' else e''')\\<cdot>x =\n    If b then t'''\\<cdot>x else e'''\\<cdot>x &&&\n    (\\<lbrakk>g \\<bottom> = \\<bottom>; cont g\\<rbrakk>\n     \\<Longrightarrow> g (If b then t'' else e'') y =\n                       If b then g t'' y else g e'' y)", "by (case_tac [!] b) simp_all"], ["", "lemma If2_split_asm: \"P (If2 Q x y) \\<longleftrightarrow> \\<not>(Q = \\<bottom> \\<and> \\<not>P \\<bottom> \\<or> Q = TT \\<and> \\<not>P x \\<or> Q = FF \\<and> \\<not>P y)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (If2 Q x y) =\n    (\\<not> (Q = \\<bottom> \\<and> \\<not> P \\<bottom> \\<or>\n             Q = TT \\<and> \\<not> P x \\<or> Q = FF \\<and> \\<not> P y))", "by (cases Q) (simp_all add: If2_def)"], ["", "lemmas If2_splits = split_If2 If2_split_asm"], ["", "lemma If2_cont[simp, cont2cont]:\n  assumes \"cont i\"\n  assumes \"cont t\"\n  assumes \"cont e\"\n  shows \"cont (\\<lambda>x. If2 (i x) (t x) (e x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont (\\<lambda>x. If2 (i x) (t x) (e x))", "using assms"], ["proof (prove)\nusing this:\n  cont i\n  cont t\n  cont e\n\ngoal (1 subgoal):\n 1. cont (\\<lambda>x. If2 (i x) (t x) (e x))", "unfolding If2_def"], ["proof (prove)\nusing this:\n  cont i\n  cont t\n  cont e\n\ngoal (1 subgoal):\n 1. cont (\\<lambda>x. If i x then t x else e x)", "by simp"], ["", "lemma If_else_FF[simp]: \"(If b then t else FF) = (b andalso t)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. If b then t else FF = (b andalso t)", "by (cases b) simp_all"], ["", "lemma If_then_TT[simp]: \"(If b then TT else e) = (b orelse e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. If b then TT else e = (b orelse e)", "by (cases b) simp_all"], ["", "lemma If_cong:\n  assumes \"b = b'\"\n  assumes\"b = TT \\<Longrightarrow> t = t'\"\n  assumes \"b = FF \\<Longrightarrow> e = e'\"\n  shows \"(If b then t else e) = (If b' then t' else e')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. If b then t else e = If b' then t' else e'", "using assms"], ["proof (prove)\nusing this:\n  b = b'\n  b = TT \\<Longrightarrow> t = t'\n  b = FF \\<Longrightarrow> e = e'\n\ngoal (1 subgoal):\n 1. If b then t else e = If b' then t' else e'", "by (cases b) simp_all"], ["", "lemma If_tr: \"(If b then t else e) = ((b andalso t) orelse (neg\\<cdot>b andalso e))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. If b then t else e = (b andalso t orelse neg\\<cdot>b andalso e)", "by (cases b) simp_all"], ["", "lemma If_andalso:\n  shows \"If p andalso q then t else e = If p then If q then t else e else e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. If p andalso q then t else e = If p then If q then t else e else e", "by (cases p) simp_all"], ["", "lemma If_else_absorb:\n  assumes \"c = \\<bottom> \\<Longrightarrow> e = \\<bottom>\"\n  assumes \"c = TT \\<Longrightarrow> e = t\"\n  shows \"If c then t else e = e\""], ["proof (prove)\ngoal (1 subgoal):\n 1. If c then t else e = e", "using assms"], ["proof (prove)\nusing this:\n  c = \\<bottom> \\<Longrightarrow> e = \\<bottom>\n  c = TT \\<Longrightarrow> e = t\n\ngoal (1 subgoal):\n 1. If c then t else e = e", "by (cases c; clarsimp)"], ["", "lemma andalso_cong: \"\\<lbrakk>P = P'; P' = TT \\<Longrightarrow> Q = Q'\\<rbrakk> \\<Longrightarrow> (P andalso Q) = (P' andalso Q')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P = P'; P' = TT \\<Longrightarrow> Q = Q'\\<rbrakk>\n    \\<Longrightarrow> (P andalso Q) = (P' andalso Q')", "by (cases P) simp_all"], ["", "lemma andalso_weaken_left:\n  assumes \"P = TT \\<Longrightarrow> Q = TT\"\n  assumes \"P = FF \\<Longrightarrow> Q \\<noteq> \\<bottom>\"\n  assumes \"P = \\<bottom> \\<Longrightarrow> Q \\<noteq> FF\"\n  shows \"P = (Q andalso P)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P = (Q andalso P)", "using assms"], ["proof (prove)\nusing this:\n  P = TT \\<Longrightarrow> Q = TT\n  P = FF \\<Longrightarrow> Q \\<noteq> \\<bottom>\n  P = \\<bottom> \\<Longrightarrow> Q \\<noteq> FF\n\ngoal (1 subgoal):\n 1. P = (Q andalso P)", "by (cases P; cases Q; simp)"], ["", "lemma orelse_cong: \"\\<lbrakk>P = P'; P' = FF \\<Longrightarrow> Q = Q'\\<rbrakk> \\<Longrightarrow> (P orelse Q) = (P' orelse Q')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>P = P'; P' = FF \\<Longrightarrow> Q = Q'\\<rbrakk>\n    \\<Longrightarrow> (P orelse Q) = (P' orelse Q')", "by (cases P) simp_all"], ["", "lemma orelse_conv[simp]:\n  \"((x orelse y) = TT) \\<longleftrightarrow> (x = TT \\<or> (x = FF \\<and> y = TT))\"\n  \"((x orelse y) = \\<bottom>) \\<longleftrightarrow> (x = \\<bottom> \\<or> (x = FF \\<and> y = \\<bottom>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((x orelse y) = TT) = (x = TT \\<or> x = FF \\<and> y = TT) &&&\n    ((x orelse y) = \\<bottom>) =\n    (x = \\<bottom> \\<or> x = FF \\<and> y = \\<bottom>)", "by (cases x; cases y; simp)+"], ["", "lemma csplit_cfun2: \"cont F \\<Longrightarrow> (\\<Lambda> x. F x) = (\\<Lambda> (x, y). F (x, y))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont F \\<Longrightarrow>\n    (\\<Lambda> x. F x) = (\\<Lambda> (x, y). F (x, y))", "by (clarsimp simp: cfun_eq_iff prod_cont_iff)"], ["", "lemma csplit_cfun3: \"cont F \\<Longrightarrow> (\\<Lambda> x. F x) = (\\<Lambda> (x, y, z). F (x, y, z))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cont F \\<Longrightarrow>\n    (\\<Lambda> x. F x) = (\\<Lambda> (x, y, z). F (x, y, z))", "by (clarsimp simp: cfun_eq_iff prod_cont_iff)"], ["", "definition convol :: \"('a::cpo \\<rightarrow> 'b::cpo) \\<rightarrow> ('a \\<rightarrow> 'c::cpo) \\<rightarrow> 'a \\<rightarrow> 'b \\<times> 'c\" where\n  \"convol = (\\<Lambda> f g x. (f\\<cdot>x, g\\<cdot>x))\""], ["", "abbreviation convol_syn :: \"('a::cpo \\<rightarrow> 'b::cpo) \\<Rightarrow> ('a \\<rightarrow> 'c::cpo) \\<Rightarrow> 'a \\<rightarrow> 'b \\<times> 'c\" (infix \"&&\" 65) where\n  \"f && g \\<equiv> convol\\<cdot>f\\<cdot>g\""], ["", "lemma convol_strict[simp]:\n  \"convol\\<cdot>\\<bottom>\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<bottom> && \\<bottom> = \\<bottom>", "unfolding convol_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> f g x. (f\\<cdot>x, g\\<cdot>x))\\<cdot>\\<bottom>\\<cdot>\n    \\<bottom> =\n    \\<bottom>", "by simp"], ["", "lemma convol_simp[simp]: \"(f && g)\\<cdot>x = (f\\<cdot>x, g\\<cdot>x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f && g)\\<cdot>x = (f\\<cdot>x, g\\<cdot>x)", "unfolding convol_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> f g x. (f\\<cdot>x, g\\<cdot>x))\\<cdot>f\\<cdot>g\\<cdot>x =\n    (f\\<cdot>x, g\\<cdot>x)", "by simp"], ["", "definition map_prod :: \"('a::cpo \\<rightarrow> 'c::cpo) \\<rightarrow> ('b::cpo \\<rightarrow> 'd) \\<rightarrow> 'a \\<times> 'b \\<rightarrow> 'c \\<times> 'd\" where\n  \"map_prod = (\\<Lambda> f g (x, y). (f\\<cdot>x, g\\<cdot>y))\""], ["", "abbreviation map_prod_syn :: \"('a \\<rightarrow> 'c) \\<Rightarrow> ('b \\<rightarrow> 'd) \\<Rightarrow> 'a \\<times> 'b \\<rightarrow> 'c \\<times> 'd\" (infix \"**\" 65) where\n  \"f ** g \\<equiv> map_prod\\<cdot>f\\<cdot>g\""], ["", "lemma map_prod_cfcomp[simp]: \"(f ** m) oo (g ** n) = (f oo g) ** (m oo n)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f ** m) oo (g ** n) = f oo g ** m oo n", "unfolding map_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> f g (x, y). (f\\<cdot>x, g\\<cdot>y))\\<cdot>f\\<cdot>m oo\n    (\\<Lambda> f g (x, y). (f\\<cdot>x, g\\<cdot>y))\\<cdot>g\\<cdot>n =\n    (\\<Lambda> f g (x, y). (f\\<cdot>x, g\\<cdot>y))\\<cdot>(f oo g)\\<cdot>\n    (m oo n)", "by (clarsimp simp: cfun_eq_iff)"], ["", "lemma map_prod_ID[simp]: \"ID ** ID = ID\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ID ** ID = ID", "unfolding map_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> f g (x, y). (f\\<cdot>x, g\\<cdot>y))\\<cdot>ID\\<cdot>ID = ID", "by (clarsimp simp: cfun_eq_iff)"], ["", "lemma map_prod_app[simp]: \"(f ** g)\\<cdot>x = (f\\<cdot>(cfst\\<cdot>x), g\\<cdot>(csnd\\<cdot>x))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f ** g)\\<cdot>x = (f\\<cdot>(cfst\\<cdot>x), g\\<cdot>(csnd\\<cdot>x))", "unfolding map_prod_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> f g (x, y). (f\\<cdot>x, g\\<cdot>y))\\<cdot>f\\<cdot>g\\<cdot>x =\n    (f\\<cdot>(cfst\\<cdot>x), g\\<cdot>(csnd\\<cdot>x))", "by (cases x) (clarsimp simp: cfun_eq_iff)"], ["", "lemma map_prod_cfst[simp]: \"cfst oo (f ** g) = f oo cfst\""], ["proof (prove)\ngoal (1 subgoal):\n 1. cfst oo (f ** g) = f oo cfst", "by (clarsimp simp: cfun_eq_iff)"], ["", "lemma map_prod_csnd[simp]: \"csnd oo (f ** g) = g oo csnd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. csnd oo (f ** g) = g oo csnd", "by (clarsimp simp: cfun_eq_iff)"], ["", "subsection\\<open> Extra HOLCF Prelude. \\<close>"], ["", "lemma eq_strict[simp]: \"eq\\<cdot>(\\<bottom>::'a::Eq_strict) = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq\\<cdot>\\<bottom> = \\<bottom>", "by (simp add: cfun_eq_iff)"], ["", "lemma Integer_le_both_plus_1[simp]:\n  fixes m :: Integer\n  shows \"le\\<cdot>(m + 1)\\<cdot>(n + 1) = le\\<cdot>m\\<cdot>n\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le\\<cdot>(m + 1)\\<cdot>(n + 1) = le\\<cdot>m\\<cdot>n", "by (cases m; cases n; simp add: one_Integer_def)"], ["", "lemma plus_eq_MkI_conv:\n  \"l + n = MkI\\<cdot>m \\<longleftrightarrow> (\\<exists>l' n'. l = MkI\\<cdot>l' \\<and> n = MkI\\<cdot>n' \\<and> m = l' + n')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (l + n = MkI\\<cdot>m) =\n    (\\<exists>l' n'.\n        l = MkI\\<cdot>l' \\<and> n = MkI\\<cdot>n' \\<and> m = l' + n')", "by (cases l, simp) (cases n, auto)"], ["", "lemma lt_defined:\n  fixes x :: Integer\n  shows\n    \"lt\\<cdot>x\\<cdot>y = TT \\<Longrightarrow> (x \\<noteq> \\<bottom> \\<and> y \\<noteq> \\<bottom>)\"\n    \"lt\\<cdot>x\\<cdot>y = FF \\<Longrightarrow> (x \\<noteq> \\<bottom> \\<and> y \\<noteq> \\<bottom>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (lt\\<cdot>x\\<cdot>y = TT \\<Longrightarrow>\n     x \\<noteq> \\<bottom> \\<and> y \\<noteq> \\<bottom>) &&&\n    (lt\\<cdot>x\\<cdot>y = FF \\<Longrightarrow>\n     x \\<noteq> \\<bottom> \\<and> y \\<noteq> \\<bottom>)", "by (cases x; cases y; clarsimp)+"], ["", "lemma le_defined:\n  fixes x :: Integer\n  shows\n    \"le\\<cdot>x\\<cdot>y = TT \\<Longrightarrow> (x \\<noteq> \\<bottom> \\<and> y \\<noteq> \\<bottom>)\"\n    \"le\\<cdot>x\\<cdot>y = FF \\<Longrightarrow> (x \\<noteq> \\<bottom> \\<and> y \\<noteq> \\<bottom>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (le\\<cdot>x\\<cdot>y = TT \\<Longrightarrow>\n     x \\<noteq> \\<bottom> \\<and> y \\<noteq> \\<bottom>) &&&\n    (le\\<cdot>x\\<cdot>y = FF \\<Longrightarrow>\n     x \\<noteq> \\<bottom> \\<and> y \\<noteq> \\<bottom>)", "by (cases x; cases y; clarsimp)+"], ["", "text\\<open>Induction on \\<open>Integer\\<close>, following the setup for the \\<open>int\\<close> type.\\<close>"], ["", "definition Integer_ge_less_than :: \"int \\<Rightarrow> (Integer \\<times> Integer) set\"\n  where \"Integer_ge_less_than d = {(MkI\\<cdot>z', MkI\\<cdot>z) |z z'. d \\<le> z' \\<and> z' < z}\""], ["", "lemma wf_Integer_ge_less_than: \"wf (Integer_ge_less_than d)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (Integer_ge_less_than d)", "proof(rule wf_subset)"], ["proof (state)\ngoal (2 subgoals):\n 1. wf ?r\n 2. Integer_ge_less_than d \\<subseteq> ?r", "show \"Integer_ge_less_than d \\<subseteq> measure (\\<lambda>z. nat (if z = \\<bottom> then d else (THE z'. z = MkI\\<cdot>z') - d))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Integer_ge_less_than d\n    \\<subseteq> measure\n                 (\\<lambda>z.\n                     nat (if z = \\<bottom> then d\n                          else (THE z'. z = MkI\\<cdot>z') - d))", "unfolding Integer_ge_less_than_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {(MkI\\<cdot>z', MkI\\<cdot>z) |z z'. d \\<le> z' \\<and> z' < z}\n    \\<subseteq> measure\n                 (\\<lambda>z.\n                     nat (if z = \\<bottom> then d\n                          else (THE z'. z = MkI\\<cdot>z') - d))", "by clarsimp"], ["proof (state)\nthis:\n  Integer_ge_less_than d\n  \\<subseteq> measure\n               (\\<lambda>z.\n                   nat (if z = \\<bottom> then d\n                        else (THE z'. z = MkI\\<cdot>z') - d))\n\ngoal (1 subgoal):\n 1. wf (measure\n         (\\<lambda>z.\n             nat (if z = \\<bottom> then d\n                  else (THE z'. z = MkI\\<cdot>z') - d)))", "qed simp"], ["", "subsection\\<open> Element equality \\label{sec:equality} \\<close>"], ["", "text\\<open>\n\nTo avoid many extraneous headaches that take us far away from the\ninteresting parts of our derivation, we assume that the elements of\nthe pattern and text are drawn from a @{class \\<open>pcpo\\<close>}\nwhere, if the @{const \\<open>eq\\<close>} function on this type is\ngiven defined arguments, then its result is defined and coincides with\n@{term \\<open>(=)\\<close>}.\n\nNote this effectively restricts us to @{class \\<open>flat\\<close>}\nelement types; see @{cite [cite_macro=citet] \\<open>\\S4.12\\<close>\n\"Paulson:1987\"} for a discussion.\n\n\\<close>"], ["", "class Eq_def = Eq_eq +\n  assumes eq_defined: \"\\<lbrakk>x \\<noteq> \\<bottom>; y \\<noteq> \\<bottom>\\<rbrakk> \\<Longrightarrow> eq\\<cdot>x\\<cdot>y \\<noteq> \\<bottom>\"\nbegin"], ["", "lemma eq_bottom_iff[simp]: \"(eq\\<cdot>x\\<cdot>y = \\<bottom>) \\<longleftrightarrow> (x = \\<bottom> \\<or> y = \\<bottom>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (eq\\<cdot>x\\<cdot>y = \\<bottom>) = (x = \\<bottom> \\<or> y = \\<bottom>)", "using eq_defined"], ["proof (prove)\nusing this:\n  \\<lbrakk>?x \\<noteq> \\<bottom>; ?y \\<noteq> \\<bottom>\\<rbrakk>\n  \\<Longrightarrow> eq\\<cdot>?x\\<cdot>?y \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. (eq\\<cdot>x\\<cdot>y = \\<bottom>) = (x = \\<bottom> \\<or> y = \\<bottom>)", "by auto"], ["", "lemma eq_defined_reflD[simp]:\n  \"(eq\\<cdot>a\\<cdot>a = TT) \\<longleftrightarrow> a \\<noteq> \\<bottom>\"\n  \"(TT = eq\\<cdot>a\\<cdot>a) \\<longleftrightarrow> a \\<noteq> \\<bottom>\"\n  \"a \\<noteq> \\<bottom> \\<Longrightarrow> eq\\<cdot>a\\<cdot>a = TT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (eq\\<cdot>a\\<cdot>a = TT) = (a \\<noteq> \\<bottom>) &&&\n    (TT = eq\\<cdot>a\\<cdot>a) = (a \\<noteq> \\<bottom>) &&&\n    (a \\<noteq> \\<bottom> \\<Longrightarrow> eq\\<cdot>a\\<cdot>a = TT)", "using eq_refl"], ["proof (prove)\nusing this:\n  eq\\<cdot>?x\\<cdot>?x \\<noteq> \\<bottom> \\<Longrightarrow>\n  eq\\<cdot>?x\\<cdot>?x = TT\n\ngoal (1 subgoal):\n 1. (eq\\<cdot>a\\<cdot>a = TT) = (a \\<noteq> \\<bottom>) &&&\n    (TT = eq\\<cdot>a\\<cdot>a) = (a \\<noteq> \\<bottom>) &&&\n    (a \\<noteq> \\<bottom> \\<Longrightarrow> eq\\<cdot>a\\<cdot>a = TT)", "by auto"], ["", "lemma eq_FF[simp]:\n  \"(FF = eq\\<cdot>xs\\<cdot>ys) \\<longleftrightarrow> (xs \\<noteq> \\<bottom> \\<and> ys \\<noteq> \\<bottom> \\<and> xs \\<noteq> ys)\"\n  \"(eq\\<cdot>xs\\<cdot>ys = FF) \\<longleftrightarrow> (xs \\<noteq> \\<bottom> \\<and> ys \\<noteq> \\<bottom> \\<and> xs \\<noteq> ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (FF = eq\\<cdot>xs\\<cdot>ys) =\n    (xs \\<noteq> \\<bottom> \\<and>\n     ys \\<noteq> \\<bottom> \\<and> xs \\<noteq> ys) &&&\n    (eq\\<cdot>xs\\<cdot>ys = FF) =\n    (xs \\<noteq> \\<bottom> \\<and>\n     ys \\<noteq> \\<bottom> \\<and> xs \\<noteq> ys)", "by (metis (mono_tags, hide_lams) Exh_tr dist_eq_tr(5) eq_TT_dest eq_bottom_iff eq_self_neq_FF')+"], ["", "lemma eq_TT[simp]:\n  \"(TT = eq\\<cdot>xs\\<cdot>ys) \\<longleftrightarrow> (xs \\<noteq> \\<bottom> \\<and> ys \\<noteq> \\<bottom> \\<and> xs = ys)\"\n  \"(eq\\<cdot>xs\\<cdot>ys = TT) \\<longleftrightarrow> (xs \\<noteq> \\<bottom> \\<and> ys \\<noteq> \\<bottom> \\<and> xs = ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (TT = eq\\<cdot>xs\\<cdot>ys) =\n    (xs \\<noteq> \\<bottom> \\<and> ys \\<noteq> \\<bottom> \\<and> xs = ys) &&&\n    (eq\\<cdot>xs\\<cdot>ys = TT) =\n    (xs \\<noteq> \\<bottom> \\<and> ys \\<noteq> \\<bottom> \\<and> xs = ys)", "by (auto simp: local.eq_TT_dest)"], ["", "end"], ["", "instance Integer :: Eq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(Integer, Eq_def_class)", "by standard simp"], ["", "subsection \\<open>Recursive let bindings\\<close>"], ["", "text\\<open>\n\n@{verbatim \\<open>\nTitle: HOL/HOLCF/ex/Letrec.thy\nAuthor: Brian Huffman\n\\<close>}\n\nSee \\S\\ref{sec:KMP:final_version} for an example use.\n\n\\<close>"], ["", "definition\n  CLetrec :: \"('a::pcpo \\<rightarrow> 'a \\<times> 'b::pcpo) \\<rightarrow> 'b\" where\n  \"CLetrec = (\\<Lambda> F. prod.snd (F\\<cdot>(\\<mu> x. prod.fst (F\\<cdot>x))))\""], ["", "nonterminal recbinds and recbindt and recbind"], ["", "syntax\n  \"_recbind\"  :: \"logic \\<Rightarrow> logic \\<Rightarrow> recbind\"         (\"(2_ =/ _)\" 10)\n  \"\"          :: \"recbind \\<Rightarrow> recbindt\"               (\"_\")\n  \"_recbindt\" :: \"recbind \\<Rightarrow> recbindt \\<Rightarrow> recbindt\"   (\"_,/ _\")\n  \"\"          :: \"recbindt \\<Rightarrow> recbinds\"              (\"_\")\n  \"_recbinds\" :: \"recbindt \\<Rightarrow> recbinds \\<Rightarrow> recbinds\"  (\"_;/ _\")\n  \"_Letrec\"   :: \"recbinds \\<Rightarrow> logic \\<Rightarrow> logic\"        (\"(Letrec (_)/ in (_))\" 10)"], ["", "translations\n  (recbindt) \"x = a, (y,ys) = (b,bs)\" == (recbindt) \"(x,y,ys) = (a,b,bs)\"\n  (recbindt) \"x = a, y = b\"          == (recbindt) \"(x,y) = (a,b)\""], ["", "translations\n  \"_Letrec (_recbinds b bs) e\" == \"_Letrec b (_Letrec bs e)\"\n  \"Letrec xs = a in (e,es)\"    == \"CONST CLetrec\\<cdot>(\\<Lambda> xs. (a,e,es))\"\n  \"Letrec xs = a in e\"         == \"CONST CLetrec\\<cdot>(\\<Lambda> xs. (a,e))\""], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}