{"file_name": "/home/qj213/afp-2021-10-22/thys/BirdKMP/Theory_Of_Lists.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/BirdKMP", "problem_names": ["lemma scons_strict[simp]: \"scons\\<cdot>\\<bottom> = \\<bottom>\"", "lemma shead_bottom_iff[simp]: \"(shead\\<cdot>xs = \\<bottom>) \\<longleftrightarrow> (xs = \\<bottom> \\<or> xs = [::])\"", "lemma stail_bottom_iff[simp]: \"(stail\\<cdot>xs = \\<bottom>) \\<longleftrightarrow> (xs = \\<bottom> \\<or> xs = [::])\"", "lemma match_snil_match_scons_slist_case: \"match_snil\\<cdot>xs\\<cdot>k1 +++ match_scons\\<cdot>xs\\<cdot>k2 = slist_case\\<cdot>k1\\<cdot>k2\\<cdot>xs\"", "lemma slist_bottom': \"slist_case\\<cdot>\\<bottom>\\<cdot>\\<bottom>\\<cdot>xs = \\<bottom>\"", "lemma slist_bottom[simp]: \"slist_case\\<cdot>\\<bottom>\\<cdot>\\<bottom> = \\<bottom>\"", "lemma slist_case_distr:\n  \"f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow> f\\<cdot>(slist_case\\<cdot>g\\<cdot>h\\<cdot>xs) = slist_case\\<cdot>(f\\<cdot>g)\\<cdot>(\\<Lambda> x xs. f\\<cdot>(h\\<cdot>x\\<cdot>xs))\\<cdot>xs\"\n  \"slist_case\\<cdot>g'\\<cdot>h'\\<cdot>xs\\<cdot>z = slist_case\\<cdot>(g'\\<cdot>z)\\<cdot>(\\<Lambda> x xs. h'\\<cdot>x\\<cdot>xs\\<cdot>z)\\<cdot>xs\"", "lemma slist_case_cong:\n  assumes \"xs = xs'\"\n  assumes \"xs' = [::] \\<Longrightarrow> n = n'\"\n  assumes \"\\<And>y ys. \\<lbrakk>xs' = y :# ys; y \\<noteq> \\<bottom>; ys \\<noteq> \\<bottom>\\<rbrakk> \\<Longrightarrow> c y ys = c' y ys\"\n  assumes \"cont (\\<lambda>(x, y). c x y)\"\n  assumes \"cont (\\<lambda>(x, y). c' x y)\"\n  shows \"slist_case\\<cdot>n\\<cdot>(\\<Lambda> x xs. c x xs)\\<cdot>xs = slist_case\\<cdot>n'\\<cdot>(\\<Lambda> x xs. c' x xs)\\<cdot>xs'\"", "lemma slist_eq_TT_snil[simp]:\n  fixes xs :: \"[:'a::Eq:]\"\n  shows \"(eq\\<cdot>xs\\<cdot>[::] = TT) \\<longleftrightarrow> (xs = [::])\"\n        \"(eq\\<cdot>[::]\\<cdot>xs = TT) \\<longleftrightarrow> (xs = [::])\"", "lemma slist_eq_FF_snil[simp]:\n  fixes xs :: \"[:'a::Eq:]\"\n  shows \"(eq\\<cdot>xs\\<cdot>[::] = FF) \\<longleftrightarrow> (\\<exists>y ys. y \\<noteq> \\<bottom> \\<and> ys \\<noteq> \\<bottom> \\<and> xs = y :# ys)\"\n        \"(eq\\<cdot>[::]\\<cdot>xs = FF) \\<longleftrightarrow> (\\<exists>y ys. y \\<noteq> \\<bottom> \\<and> ys \\<noteq> \\<bottom> \\<and> xs = y :# ys)\"", "lemma slistmem_bottom1[iff]:\n  fixes x :: \"'a\"\n  shows \"\\<not> slistmem x \\<bottom>\"", "lemma slistmem_bottom2[iff]:\n  fixes xs :: \"[:'a:]\"\n  shows \"\\<not> slistmem \\<bottom> xs\"", "lemma slistmem_nil[iff]:\n  shows \"\\<not> slistmem x [::]\"", "lemma slistmem_scons[simp]:\n  shows \"slistmem x (y :# ys) \\<longleftrightarrow> (x = y \\<and> x \\<noteq> \\<bottom> \\<and> ys \\<noteq> \\<bottom>) \\<or> (slistmem x ys \\<and> y \\<noteq> \\<bottom>)\"", "lemma sset_simp[simp]:\n  shows \"sset \\<bottom> = {}\"\n    and \"sset [::] = {}\"\n    and \"\\<lbrakk>x \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>\\<rbrakk> \\<Longrightarrow> sset (x :# xs) = insert x (sset xs)\"", "lemma sset_defined[simp]:\n  assumes \"x \\<in> sset xs\"\n  shows \"x \\<noteq> \\<bottom>\"", "lemma sset_below:\n  assumes \"y \\<in> sset ys\"\n  assumes \"xs \\<sqsubseteq> ys\"\n  assumes \"xs \\<noteq> \\<bottom>\"\n  obtains x where \"x \\<in> sset xs\" and \"x \\<sqsubseteq> y\"", "lemma snull_strict[simp]: \"snull\\<cdot>\\<bottom> = \\<bottom>\"", "lemma snull_bottom_iff[simp]: \"(snull\\<cdot>xs = \\<bottom>) \\<longleftrightarrow> (xs = \\<bottom>)\"", "lemma snull_FF_conv: \"(snull\\<cdot>xxs = FF) \\<longleftrightarrow> (\\<exists>x xs. xxs \\<noteq> \\<bottom> \\<and> xxs = x :# xs)\"", "lemma snull_TT_conv[simp]: \"(snull\\<cdot>xs = TT) \\<longleftrightarrow> (xs = [::])\"", "lemma snull_eq_snil: \"snull\\<cdot>xs = eq\\<cdot>xs\\<cdot>[::]\"", "lemma smap_strict[simp]: \"smap\\<cdot>f\\<cdot>\\<bottom> = \\<bottom>\"", "lemma smap_bottom_iff[simp]: \"(smap\\<cdot>f\\<cdot>xs = \\<bottom>) \\<longleftrightarrow> (xs = \\<bottom> \\<or> (\\<exists>x\\<in>sset xs. f\\<cdot>x = \\<bottom>))\"", "lemma smap_is_snil_conv[simp]:\n  \"(smap\\<cdot>f\\<cdot>xs = [::]) \\<longleftrightarrow> (xs = [::])\"\n  \"( [::] = smap\\<cdot>f\\<cdot>xs) \\<longleftrightarrow> (xs = [::])\"", "lemma smap_strict_scons[simp]:\n  assumes \"f\\<cdot>\\<bottom> = \\<bottom>\"\n  shows \"smap\\<cdot>f\\<cdot>(x :# xs) = f\\<cdot>x :# smap\\<cdot>f\\<cdot>xs\"", "lemma smap_ID': \"smap\\<cdot>ID\\<cdot>xs = xs\"", "lemma smap_ID[simp]: \"smap\\<cdot>ID = ID\"", "lemma smap_cong:\n  assumes \"xs = xs'\"\n  assumes \"\\<And>x. x \\<in> sset xs \\<Longrightarrow> f\\<cdot>x = f'\\<cdot>x\"\n  shows \"smap\\<cdot>f\\<cdot>xs = smap\\<cdot>f'\\<cdot>xs'\"", "lemma smap_smap'[simp]:\n  assumes \"f\\<cdot>\\<bottom> = \\<bottom>\"\n  shows \"smap\\<cdot>f\\<cdot>(smap\\<cdot>g\\<cdot>xs) = smap\\<cdot>(f oo g)\\<cdot>xs\"", "lemma smap_smap[simp]:\n  assumes \"f\\<cdot>\\<bottom> = \\<bottom>\"\n  shows \"smap\\<cdot>f oo smap\\<cdot>g = smap\\<cdot>(f oo g)\"", "lemma sset_smap[simp]:\n  assumes \"\\<And>x. x \\<in> sset xs \\<Longrightarrow> f\\<cdot>x \\<noteq> \\<bottom>\"\n  shows \"sset (smap\\<cdot>f\\<cdot>xs) = { f\\<cdot>x | x. x \\<in> sset xs }\"", "lemma shead_smap_distr:\n  assumes \"f\\<cdot>\\<bottom> = \\<bottom>\"\n  assumes \"\\<And>x. x\\<in>sset xs \\<Longrightarrow> f\\<cdot>x \\<noteq> \\<bottom>\"\n  shows \"shead\\<cdot>(smap\\<cdot>f\\<cdot>xs) = f\\<cdot>(shead\\<cdot>xs)\"", "lemma sappend_strict[simp]: \"sappend\\<cdot>\\<bottom> = \\<bottom>\"", "lemma sappend_strict2[simp]: \"xs :@ \\<bottom> = \\<bottom>\"", "lemma sappend_bottom_iff[simp]: \"(xs :@ ys = \\<bottom>) \\<longleftrightarrow> (xs = \\<bottom> \\<or> ys = \\<bottom>)\"", "lemma sappend_scons[simp]: \"(x :# xs) :@ ys = x :# xs :@ ys\"", "lemma sappend_assoc[simp]: \"(xs :@ ys) :@ zs = xs :@ (ys :@ zs)\"", "lemma sappend_snil_id_left[simp]: \"sappend\\<cdot>[::] = ID\"", "lemma sappend_snil_id_right[iff]: \"xs :@ [::] = xs\"", "lemma snil_append_iff[iff]: \"xs :@ ys = [::] \\<longleftrightarrow> xs = [::] \\<and> ys = [::]\"", "lemma smap_sappend[simp]: \"smap\\<cdot>f\\<cdot>(xs :@ ys) = smap\\<cdot>f\\<cdot>xs :@ smap\\<cdot>f\\<cdot>ys\"", "lemma stail_sappend: \"stail\\<cdot>(xs :@ ys) = (case xs of [::] \\<Rightarrow> stail\\<cdot>ys | z :# zs \\<Rightarrow> zs :@ ys)\"", "lemma stail_append2[simp]: \"xs \\<noteq> [::] \\<Longrightarrow> stail\\<cdot>(xs :@ ys) = stail\\<cdot>xs :@ ys\"", "lemma slist_case_snoc:\n  \"g\\<cdot>\\<bottom>\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow> slist_case\\<cdot>f\\<cdot>g\\<cdot>(xs :@ [:x:]) = g\\<cdot>(shead\\<cdot>(xs :@ [:x:]))\\<cdot>(stail\\<cdot>(xs :@ [:x:]))\"", "lemma sall_strict[simp]: \"sall\\<cdot>p\\<cdot>\\<bottom> = \\<bottom>\"", "lemma sall_const_TT[simp]:\n  assumes \"xs \\<noteq> \\<bottom>\"\n  shows \"sall\\<cdot>(\\<Lambda> x. TT)\\<cdot>xs = TT\"", "lemma sall_const_TT_conv[simp]: \"(sall\\<cdot>(\\<Lambda> x. TT)\\<cdot>xs = TT) \\<longleftrightarrow> (xs \\<noteq> \\<bottom>)\"", "lemma sall_TT[simp]: \"(sall\\<cdot>p\\<cdot>xs = TT) \\<longleftrightarrow> (xs \\<noteq> \\<bottom> \\<and> (\\<forall>x\\<in>sset xs. p\\<cdot>x = TT))\"", "lemma sfilter_strict[simp]: \"sfilter\\<cdot>p\\<cdot>\\<bottom> = \\<bottom>\"", "lemma sfilter_bottom_iff[simp]: \"(sfilter\\<cdot>p\\<cdot>xs = \\<bottom>) \\<longleftrightarrow> (xs = \\<bottom> \\<or> (\\<exists>x\\<in>sset xs. p\\<cdot>x = \\<bottom>))\"", "lemma sset_sfilter[simp]:\n  assumes \"\\<And>x. x \\<in> sset xs \\<Longrightarrow> p\\<cdot>x \\<noteq> \\<bottom>\"\n  shows \"sset (sfilter\\<cdot>p\\<cdot>xs) = {x |x. x \\<in> sset xs \\<and> p\\<cdot>x = TT}\"", "lemma sfilter_strict_scons[simp]:\n  assumes \"p\\<cdot>\\<bottom> = \\<bottom>\"\n  shows \"sfilter\\<cdot>p\\<cdot>(x :# xs) = If p\\<cdot>x then x :# sfilter\\<cdot>p\\<cdot>xs else sfilter\\<cdot>p\\<cdot>xs\"", "lemma sfilter_scons_let:\n  assumes \"p\\<cdot>\\<bottom> = \\<bottom>\"\n  shows \"sfilter\\<cdot>p\\<cdot>(x :# xs) = (let xs' = sfilter\\<cdot>p\\<cdot>xs in If p\\<cdot>x then x :# xs' else xs')\"", "lemma sfilter_sappend[simp]: \"sfilter\\<cdot>p\\<cdot>(xs :@ ys) = sfilter\\<cdot>p\\<cdot>xs :@ sfilter\\<cdot>p\\<cdot>ys\"", "lemma sfilter_const_FF[simp]:\n  assumes \"xs \\<noteq> \\<bottom>\"\n  shows \"sfilter\\<cdot>(\\<Lambda> x. FF)\\<cdot>xs = [::]\"", "lemma sfilter_const_FF_conv[simp]: \"(sfilter\\<cdot>(\\<Lambda> x. FF)\\<cdot>xs = [::]) \\<longleftrightarrow> (xs \\<noteq> \\<bottom>)\"", "lemma sfilter_const_TT[simp]: \"sfilter\\<cdot>(\\<Lambda> x. TT)\\<cdot>xs = xs\"", "lemma sfilter_cong:\n  assumes \"xs = xs'\"\n  assumes \"\\<And>x. x \\<in> sset xs \\<Longrightarrow> p\\<cdot>x = p'\\<cdot>x\"\n  shows \"sfilter\\<cdot>p\\<cdot>xs = sfilter\\<cdot>p'\\<cdot>xs'\"", "lemma sfilter_snil_conv[simp]: \"sfilter\\<cdot>p\\<cdot>xs = [::] \\<longleftrightarrow> sall\\<cdot>(neg oo p)\\<cdot>xs = TT\"", "lemma sfilter_sfilter': \"sfilter\\<cdot>p\\<cdot>(sfilter\\<cdot>q\\<cdot>xs) = sfilter\\<cdot>(\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)\\<cdot>xs\"", "lemma sfilter_sfilter: \"sfilter\\<cdot>p oo sfilter\\<cdot>q = sfilter\\<cdot>(\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)\"", "lemma sfilter_smap':\n  assumes \"p\\<cdot>\\<bottom> = \\<bottom>\"\n  shows \"sfilter\\<cdot>p\\<cdot>(smap\\<cdot>f\\<cdot>xs) = smap\\<cdot>f\\<cdot>(sfilter\\<cdot>(p oo f)\\<cdot>xs)\"", "lemma sfilter_smap:\n  assumes \"p\\<cdot>\\<bottom> = \\<bottom>\"\n  shows \"sfilter\\<cdot>p oo smap\\<cdot>f = smap\\<cdot>f oo sfilter\\<cdot>(p oo f)\"", "lemma sfoldl_strict[simp]: \"sfoldl\\<cdot>f\\<cdot>z\\<cdot>\\<bottom> = \\<bottom>\"", "lemma sfoldl_strict_f[simp]:\n  assumes \"f\\<cdot>\\<bottom> = \\<bottom>\"\n  shows \"sfoldl\\<cdot>f\\<cdot>\\<bottom>\\<cdot>xs = \\<bottom>\"", "lemma sfoldl_cong:\n  assumes \"xs = xs'\"\n  assumes \"z = z'\"\n  assumes \"\\<And>x z. x \\<in> sset xs \\<Longrightarrow> f\\<cdot>z\\<cdot>x = f'\\<cdot>z\\<cdot>x\"\n  shows \"sfoldl\\<cdot>f\\<cdot>z\\<cdot>xs = sfoldl\\<cdot>f'\\<cdot>z'\\<cdot>xs'\"", "lemma sfoldl_sappend[simp]:\n  assumes \"f\\<cdot>\\<bottom> = \\<bottom>\"\n  shows \"sfoldl\\<cdot>f\\<cdot>z\\<cdot>(xs :@ ys) = sfoldl\\<cdot>f\\<cdot>(sfoldl\\<cdot>f\\<cdot>z\\<cdot>xs)\\<cdot>ys\"", "lemma sfoldr_strict[simp]: \"sfoldr\\<cdot>f\\<cdot>z\\<cdot>\\<bottom> = \\<bottom>\"", "lemma sconcat_strict[simp]: \"sconcat\\<cdot>\\<bottom> = \\<bottom>\"", "lemma sconcat_scons[simp]:\n  shows \"sconcat\\<cdot>(x :# xs) = x :@ sconcat\\<cdot>xs\"", "lemma sconcat_sfoldl_aux: \"sfoldl\\<cdot>sappend\\<cdot>z\\<cdot>xs = z :@ sconcat\\<cdot>xs\"", "lemma sconcat_sfoldl: \"sconcat = sfoldl\\<cdot>sappend\\<cdot>[::]\"", "lemma sconcat_sappend[simp]: \"sconcat\\<cdot>(xs :@ ys) = sconcat\\<cdot>xs :@ sconcat\\<cdot>ys\"", "lemma slength_strict[simp]: \"slength\\<cdot>\\<bottom> = \\<bottom>\"", "lemma slength_bottom_iff[simp]: \"(slength\\<cdot>xs = \\<bottom>) \\<longleftrightarrow> (xs = \\<bottom>)\"", "lemma slength_ge_0: \"slength\\<cdot>xs = MkI\\<cdot>n \\<Longrightarrow> n \\<ge> 0\"", "lemma slengthE:\n  shows \"\\<lbrakk>xs \\<noteq> \\<bottom>; \\<And>n. \\<lbrakk>slength\\<cdot>xs = MkI\\<cdot>n; 0 \\<le> n\\<rbrakk> \\<Longrightarrow> Q\\<rbrakk> \\<Longrightarrow> Q\"", "lemma slength_0_conv[simp]:\n  \"(slength\\<cdot>xs = 0) \\<longleftrightarrow> (xs = [::])\"\n  \"(slength\\<cdot>xs = MkI\\<cdot>0) \\<longleftrightarrow> (xs = [::])\"\n  \"eq\\<cdot>0\\<cdot>(slength\\<cdot>xs) = snull\\<cdot>xs\"\n  \"eq\\<cdot>(slength\\<cdot>xs)\\<cdot>0 = snull\\<cdot>xs\"", "lemma le_slength_0[simp]: \"(le\\<cdot>0\\<cdot>(slength\\<cdot>xs) = TT) \\<longleftrightarrow> (xs \\<noteq> \\<bottom>)\"", "lemma lt_slength_0[simp]:\n  \"xs \\<noteq> \\<bottom> \\<Longrightarrow> lt\\<cdot>(slength\\<cdot>xs)\\<cdot>0 = FF\"\n  \"xs \\<noteq> \\<bottom> \\<Longrightarrow> lt\\<cdot>(slength\\<cdot>xs)\\<cdot>(slength\\<cdot>xs + 1) = TT\"", "lemma slength_smap[simp]:\n  assumes \"\\<And>x. x \\<noteq> \\<bottom> \\<Longrightarrow> f\\<cdot>x \\<noteq> \\<bottom>\"\n  shows \"slength\\<cdot>(smap\\<cdot>f\\<cdot>xs) = slength\\<cdot>xs\"", "lemma slength_sappend[simp]: \"slength\\<cdot>(xs :@ ys) = slength\\<cdot>xs + slength\\<cdot>ys\"", "lemma slength_sfoldl_aux: \"sfoldl\\<cdot>(\\<Lambda> i _. i + 1)\\<cdot>z\\<cdot>xs = z + slength\\<cdot>xs\"", "lemma slength_sfoldl: \"slength = sfoldl\\<cdot>(\\<Lambda> i _. i + 1)\\<cdot>0\"", "lemma le_slength_plus:\n  assumes \"xs \\<noteq> \\<bottom>\"\n  assumes \"n \\<noteq> \\<bottom>\"\n  shows \"le\\<cdot>n\\<cdot>(slength\\<cdot>xs + n) = TT\"", "lemma srev_strict[simp]: \"srev\\<cdot>\\<bottom> = \\<bottom>\"", "lemma srev_bottom_iff[simp]: \"(srev\\<cdot>xs = \\<bottom>) \\<longleftrightarrow> (xs = \\<bottom>)\"", "lemma srev_scons[simp]: \"srev\\<cdot>(x :# xs) = srev\\<cdot>xs :@ [:x:]\"", "lemma srev_sappend[simp]: \"srev\\<cdot>(xs :@ ys) = srev\\<cdot>ys :@ srev\\<cdot>xs\"", "lemma srev_srev_ident[simp]: \"srev\\<cdot>(srev\\<cdot>xs) = xs\"", "lemma srev_cases[case_names bottom snil ssnoc]:\n  assumes \"xs = \\<bottom> \\<Longrightarrow> P\"\n  assumes \"xs = [::] \\<Longrightarrow> P\"\n  assumes \"\\<And>y ys. \\<lbrakk>y \\<noteq> \\<bottom>; ys \\<noteq> \\<bottom>; xs = ys :@ [:y:]\\<rbrakk> \\<Longrightarrow> P\"\n  shows \"P\"", "lemma srev_induct[case_names bottom snil ssnoc]:\n  assumes \"P \\<bottom>\"\n  assumes \"P [::]\"\n  assumes \"\\<And>x xs. \\<lbrakk>x \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>; P xs\\<rbrakk> \\<Longrightarrow> P (xs :@ [:x:])\"\n  shows \"P xs\"", "lemma sfoldr_conv_sfoldl:\n  assumes \"\\<And>x. f\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\" \\<comment>\\<open>\\<open>f\\<close> must be strict in the accumulator.\\<close>\n  shows \"sfoldr\\<cdot>f\\<cdot>z\\<cdot>xs = sfoldl\\<cdot>(\\<Lambda> acc x. f\\<cdot>x\\<cdot>acc)\\<cdot>z\\<cdot>(srev\\<cdot>xs)\"", "lemma stake_strict[simp]:\n  \"stake\\<cdot>\\<bottom> = \\<bottom>\"\n  \"stake\\<cdot>i\\<cdot>\\<bottom> = \\<bottom>\"", "lemma stake_bottom_iff[simp]: \"(stake\\<cdot>i\\<cdot>xs = \\<bottom>) \\<longleftrightarrow> (i = \\<bottom> \\<or> xs = \\<bottom>)\"", "lemma stake_0[simp]:\n  \"xs \\<noteq> \\<bottom> \\<Longrightarrow> stake\\<cdot>0\\<cdot>xs = [::]\"\n  \"xs \\<noteq> \\<bottom> \\<Longrightarrow> stake\\<cdot>(MkI\\<cdot>0)\\<cdot>xs = [::]\"\n  \"stake\\<cdot>0\\<cdot>xs \\<sqsubseteq> [::]\"", "lemma stake_scons[simp]: \"le\\<cdot>1\\<cdot>i = TT \\<Longrightarrow> stake\\<cdot>i\\<cdot>(x :# xs) = x :# stake\\<cdot>(i - 1)\\<cdot>xs\"", "lemma take_MkI_scons[simp]:\n  \"0 < n \\<Longrightarrow> stake\\<cdot>(MkI\\<cdot>n)\\<cdot>(x :# xs) = x :# stake\\<cdot>(MkI\\<cdot>(n - 1))\\<cdot>xs\"", "lemma stake_numeral_scons[simp]:\n  \"xs \\<noteq> \\<bottom> \\<Longrightarrow> stake\\<cdot>1\\<cdot>(x :# xs) = [:x:]\"\n  \"stake\\<cdot>(numeral (Num.Bit0 k))\\<cdot>(x :# xs) = x :# stake\\<cdot>(numeral (Num.BitM k))\\<cdot>xs\"\n  \"stake\\<cdot>(numeral (Num.Bit1 k))\\<cdot>(x :# xs) = x :# stake\\<cdot>(numeral (Num.Bit0 k))\\<cdot>xs\"", "lemma stake_all:\n  assumes \"le\\<cdot>(slength\\<cdot>xs)\\<cdot>i = TT\"\n  shows \"stake\\<cdot>i\\<cdot>xs = xs\"", "lemma stake_all_triv[simp]: \"stake\\<cdot>(slength\\<cdot>xs)\\<cdot>xs = xs\"", "lemma stake_append[simp]: \"stake\\<cdot>i\\<cdot>(xs :@ ys) = stake\\<cdot>i\\<cdot>xs :@ stake\\<cdot>(i - slength\\<cdot>xs)\\<cdot>ys\"", "lemma sdrop_strict[simp]:\n  \"sdrop\\<cdot>\\<bottom> = \\<bottom>\"\n  \"sdrop\\<cdot>i\\<cdot>\\<bottom> = \\<bottom>\"", "lemma sdrop_bottom_iff[simp]: \"(sdrop\\<cdot>i\\<cdot>xs = \\<bottom>) \\<longleftrightarrow> (i = \\<bottom> \\<or> xs = \\<bottom>)\"", "lemma sdrop_snil[simp]:\n  assumes \"i \\<noteq> \\<bottom>\"\n  shows \"sdrop\\<cdot>i\\<cdot>[::] = [::]\"", "lemma sdrop_snil_conv[simp]: \"(sdrop\\<cdot>i\\<cdot>[::] = [::]) \\<longleftrightarrow> (i \\<noteq> \\<bottom>)\"", "lemma sdrop_0[simp]:\n  \"sdrop\\<cdot>0\\<cdot>xs = xs\"\n  \"sdrop\\<cdot>(MkI\\<cdot>0)\\<cdot>xs = xs\"", "lemma sdrop_pos:\n  \"le\\<cdot>i\\<cdot>0 = FF \\<Longrightarrow> sdrop\\<cdot>i\\<cdot>xs = (case xs of [::] \\<Rightarrow> [::] | y :# ys \\<Rightarrow> sdrop\\<cdot>(i - 1)\\<cdot>ys)\"", "lemma sdrop_neg:\n  \"le\\<cdot>i\\<cdot>0 = TT \\<Longrightarrow> sdrop\\<cdot>i\\<cdot>xs = xs\"", "lemma sdrop_numeral_scons[simp]:\n  \"x \\<noteq> \\<bottom> \\<Longrightarrow> sdrop\\<cdot>1\\<cdot>(x :# xs) = xs\"\n  \"x \\<noteq> \\<bottom> \\<Longrightarrow> sdrop\\<cdot>(numeral (Num.Bit0 k))\\<cdot>(x :# xs) = sdrop\\<cdot>(numeral (Num.BitM k))\\<cdot>xs\"\n  \"x \\<noteq> \\<bottom> \\<Longrightarrow> sdrop\\<cdot>(numeral (Num.Bit1 k))\\<cdot>(x :# xs) = sdrop\\<cdot>(numeral (Num.Bit0 k))\\<cdot>xs\"", "lemma sdrop_sappend[simp]:\n  \"sdrop\\<cdot>i\\<cdot>(xs :@ ys) = sdrop\\<cdot>i\\<cdot>xs :@ sdrop\\<cdot>(i - slength\\<cdot>xs)\\<cdot>ys\"", "lemma sdrop_all:\n  assumes \"le\\<cdot>(slength\\<cdot>xs)\\<cdot>i = TT\"\n  shows \"sdrop\\<cdot>i\\<cdot>xs = [::]\"", "lemma slength_sdrop[simp]:\n  \"slength\\<cdot>(sdrop\\<cdot>i\\<cdot>xs) = If le\\<cdot>i\\<cdot>0 then slength\\<cdot>xs else If le\\<cdot>(slength\\<cdot>xs)\\<cdot>i then 0 else slength\\<cdot>xs - i\"", "lemma sdrop_not_snilD:\n  assumes \"sdrop\\<cdot>(MkI\\<cdot>i)\\<cdot>xs \\<noteq> [::]\"\n  assumes \"xs \\<noteq> \\<bottom>\"\n  shows \"lt\\<cdot>(MkI\\<cdot>i)\\<cdot>(slength\\<cdot>xs) = TT \\<and> xs \\<noteq> [::]\"", "lemma sdrop_sappend_same:\n  assumes \"xs \\<noteq> \\<bottom>\"\n  shows \"sdrop\\<cdot>(slength\\<cdot>xs)\\<cdot>(xs :@ ys) = ys\"", "lemma sscanl_strict[simp]:\n  \"sscanl\\<cdot>f\\<cdot>\\<bottom>\\<cdot>xs = \\<bottom>\"\n  \"sscanl\\<cdot>f\\<cdot>z\\<cdot>\\<bottom> = \\<bottom>\"", "lemma sscanl_cong:\n  assumes \"xs = xs'\"\n  assumes \"z = z'\"\n  assumes \"\\<And>x z. x \\<in> sset xs \\<Longrightarrow> f\\<cdot>z\\<cdot>x = f'\\<cdot>z\\<cdot>x\"\n  shows \"sscanl\\<cdot>f\\<cdot>z\\<cdot>xs = sscanl\\<cdot>f'\\<cdot>z'\\<cdot>xs'\"", "lemma sscanl_lfp_fusion':\n  assumes \"g\\<cdot>\\<bottom> = \\<bottom>\"\n  assumes *: \"\\<And>acc x. x \\<noteq> \\<bottom> \\<Longrightarrow> g\\<cdot>(f\\<cdot>acc\\<cdot>x) = f'\\<cdot>(g\\<cdot>acc)\\<cdot>x\"\n  shows \"smap\\<cdot>g\\<cdot>(sscanl\\<cdot>f\\<cdot>z\\<cdot>xs) = sscanl\\<cdot>f'\\<cdot>(g\\<cdot>z)\\<cdot>xs\"", "lemma sscanl_lfp_fusion:\n  assumes \"g\\<cdot>\\<bottom> = \\<bottom>\"\n  assumes *: \"\\<And>acc x. x \\<noteq> \\<bottom> \\<Longrightarrow> g\\<cdot>(f\\<cdot>acc\\<cdot>x) = f'\\<cdot>(g\\<cdot>acc)\\<cdot>x\"\n  shows \"smap\\<cdot>g oo sscanl\\<cdot>f\\<cdot>z = sscanl\\<cdot>f'\\<cdot>(g\\<cdot>z)\"", "lemma sscanl_ww_fusion': \\<comment>\\<open> Worker/wrapper @{cite [cite_macro=citep] \"GillHutton:2009\" and \"Gammie:2011\"} specialised to @{const \\<open>sscanl\\<close>} \\<close>\n  fixes wrap :: \"'b \\<rightarrow> 'a\"\n  fixes unwrap :: \"'a \\<rightarrow> 'b\"\n  fixes z :: \"'a\"\n  fixes f :: \"'a \\<rightarrow> 'c \\<rightarrow> 'a\"\n  fixes f' :: \"'b \\<rightarrow> 'c \\<rightarrow> 'b\"\n  assumes ww: \"wrap oo unwrap = ID\"\n  assumes wb: \"\\<And>z x. x \\<noteq> \\<bottom> \\<Longrightarrow> unwrap\\<cdot>(f\\<cdot>(wrap\\<cdot>z)\\<cdot>x) = f'\\<cdot>(unwrap\\<cdot>(wrap\\<cdot>z))\\<cdot>x\"\n  shows \"sscanl\\<cdot>f\\<cdot>z\\<cdot>xs = smap\\<cdot>wrap\\<cdot>(sscanl\\<cdot>f'\\<cdot>(unwrap\\<cdot>z)\\<cdot>xs)\"", "lemma sscanl_ww_fusion: \\<comment>\\<open> Worker/wrapper @{cite [cite_macro=citep] \"GillHutton:2009\" and \"Gammie:2011\"} specialised to @{const \\<open>sscanl\\<close>} \\<close>\n  fixes wrap :: \"'b \\<rightarrow> 'a\"\n  fixes unwrap :: \"'a \\<rightarrow> 'b\"\n  fixes z :: \"'a\"\n  fixes f :: \"'a \\<rightarrow> 'c \\<rightarrow> 'a\"\n  fixes f' :: \"'b \\<rightarrow> 'c \\<rightarrow> 'b\"\n  assumes ww: \"wrap oo unwrap = ID\"\n  assumes wb: \"\\<And>z x. x \\<noteq> \\<bottom> \\<Longrightarrow> unwrap\\<cdot>(f\\<cdot>(wrap\\<cdot>z)\\<cdot>x) = f'\\<cdot>(unwrap\\<cdot>(wrap\\<cdot>z))\\<cdot>x\"\n  shows \"sscanl\\<cdot>f\\<cdot>z = smap\\<cdot>wrap oo sscanl\\<cdot>f'\\<cdot>(unwrap\\<cdot>z)\"", "lemma sinits_strict[simp]: \"sinits\\<cdot>\\<bottom> = \\<bottom>\"", "lemma sinits_bottom_iff[simp]: \"(sinits\\<cdot>xs = \\<bottom>) \\<longleftrightarrow> (xs = \\<bottom>)\"", "lemma sinits_not_snil[iff]: \"sinits\\<cdot>xs \\<noteq> [::]\"", "lemma sinits_empty_bottom[simp]: \"(sset (sinits\\<cdot>xs) = {}) \\<longleftrightarrow> (xs = \\<bottom>)\"", "lemma sinits_scons[simp]: \"sinits\\<cdot>(x :# xs) = [::] :# smap\\<cdot>(x :#)\\<cdot>(sinits\\<cdot>xs)\"", "lemma sinits_length[simp]: \"slength\\<cdot>(sinits\\<cdot>xs) = slength\\<cdot>xs + 1\"", "lemma sinits_snoc[simp]: \"sinits\\<cdot>(xs :@ [:x:]) = sinits\\<cdot>xs :@ [:xs :@ [:x:]:]\"", "lemma sinits_foldr': \\<comment>\\<open> @{cite [cite_macro=citet] \\<open>p30\\<close> \"Bird:1987\"} \\<close>\n  shows \"sinits\\<cdot>xs = sfoldr\\<cdot>(\\<Lambda> x xs. [:[::]:] :@ smap\\<cdot>(x :#)\\<cdot>xs)\\<cdot>[:[::]:]\\<cdot>xs\"", "lemma sinits_sscanl':\n  shows \"smap\\<cdot>(sfoldl\\<cdot>f\\<cdot>z)\\<cdot>(sinits\\<cdot>xs) = sscanl\\<cdot>f\\<cdot>z\\<cdot>xs\"", "lemma sinits_sscanl: \\<comment>\\<open> @{cite [cite_macro=citet] \\<open>Lemma~5\\<close> \"Bird:1987\"}, @{cite [cite_macro=citet] \\<open>p118 ``the scan lemma''\\<close> \"Bird:PearlsofFAD:2010\"} \\<close>\n  shows \"smap\\<cdot>(sfoldl\\<cdot>f\\<cdot>z) oo sinits = sscanl\\<cdot>f\\<cdot>z\"", "lemma sinits_all[simp]: \"(xs \\<in> sset (sinits\\<cdot>xs)) \\<longleftrightarrow> (xs \\<noteq> \\<bottom>)\"", "lemma stails_strict[simp]: \"stails\\<cdot>\\<bottom> = \\<bottom>\"", "lemma stails_bottom_iff[simp]: \"(stails\\<cdot>xs = \\<bottom>) \\<longleftrightarrow> (xs = \\<bottom>)\"", "lemma stails_not_snil[iff]: \"stails\\<cdot>xs \\<noteq> [::]\"", "lemma stails_scons[simp]: \"stails\\<cdot>(x :# xs) = (x :# xs) :# stails\\<cdot>xs\"", "lemma stails_slength[simp]: \"slength\\<cdot>(stails\\<cdot>xs) = slength\\<cdot>xs + 1\"", "lemma stails_snoc[simp]:\n  shows \"stails\\<cdot>(xs :@ [:x:]) = smap\\<cdot>(\\<Lambda> ys. ys :@ [:x:])\\<cdot>(stails\\<cdot>xs) :@ [:[::]:]\"", "lemma stails_sfoldl':\n  shows \"stails\\<cdot>xs = sfoldl\\<cdot>(\\<Lambda> xs x. smap\\<cdot>(\\<Lambda> ys. ys :@ [:x:])\\<cdot>xs :@ [:[::]:])\\<cdot>[:[::]:]\\<cdot>xs\"", "lemma stails_sfoldl:\n  shows \"stails = sfoldl\\<cdot>(\\<Lambda> xs x. smap\\<cdot>(\\<Lambda> ys. ys :@ [:x:])\\<cdot>xs :@ [:[::]:])\\<cdot>[:[::]:]\"", "lemma stails_all[simp]: \"(xs \\<in> sset (stails\\<cdot>xs)) \\<longleftrightarrow> (xs \\<noteq> \\<bottom>)\"", "lemma selem_strict[simp]: \"selem\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\"", "lemma selem_bottom_iff[simp]: \"(selem\\<cdot>x\\<cdot>xs = \\<bottom>) \\<longleftrightarrow> (xs = \\<bottom> \\<or> (xs \\<noteq> [::] \\<and> x = \\<bottom>))\"", "lemma selem_sappend[simp]:\n  assumes \"ys \\<noteq> \\<bottom>\"\n  shows \"selem\\<cdot>x\\<cdot>(xs :@ ys) = (selem\\<cdot>x\\<cdot>xs orelse selem\\<cdot>x\\<cdot>ys)\"", "lemma elem_TT[simp]: \"(selem\\<cdot>x\\<cdot>xs = TT) \\<longleftrightarrow> (x \\<in> sset xs)\"", "lemma elem_FF[simp]: \"(selem\\<cdot>x\\<cdot>xs = FF) \\<longleftrightarrow> (xs = [::] \\<or> (x \\<noteq> \\<bottom> \\<and> xs \\<noteq> \\<bottom> \\<and> x \\<notin> sset xs))\"", "lemma selem_snil_stails[iff]:\n  assumes \"xs \\<noteq> \\<bottom>\"\n  shows \"selem\\<cdot>[::]\\<cdot>(stails\\<cdot>xs) = TT\"", "lemma sconcatMap_strict[simp]: \"sconcatMap\\<cdot>f\\<cdot>\\<bottom> = \\<bottom>\"", "lemma sconcatMap_snil[simp]: \"sconcatMap\\<cdot>f\\<cdot>[::] = [::]\"", "lemma sconcatMap_scons[simp]: \"x \\<noteq> \\<bottom> \\<Longrightarrow> sconcatMap\\<cdot>f\\<cdot>(x :# xs) = f\\<cdot>x :@ sconcatMap\\<cdot>f\\<cdot>xs\"", "lemma sconcatMap_bottom_iff[simp]: \"(sconcatMap\\<cdot>f\\<cdot>xs = \\<bottom>) \\<longleftrightarrow> (xs = \\<bottom> \\<or> (\\<exists>x\\<in>sset xs. f\\<cdot>x = \\<bottom>))\"", "lemma sconcatMap_sappend[simp]: \"sconcatMap\\<cdot>f\\<cdot>(xs :@ ys) = sconcatMap\\<cdot>f\\<cdot>xs :@ sconcatMap\\<cdot>f\\<cdot>ys\"", "lemma sconcatMap_monad_laws:\n  \"sconcatMap\\<cdot>(\\<Lambda> x. [:x:])\\<cdot>xs = xs\"\n  \"sconcatMap\\<cdot>g\\<cdot>(sconcatMap\\<cdot>f\\<cdot>xs) = sconcatMap\\<cdot>(\\<Lambda> x. sconcatMap\\<cdot>g\\<cdot>(f\\<cdot>x))\\<cdot>xs\"", "lemma upto_strict[simp]:\n  \"supto\\<cdot>\\<bottom> = \\<bottom>\"\n  \"supto\\<cdot>m\\<cdot>\\<bottom> = \\<bottom>\"", "lemma supto_is_snil_conv[simp]:\n  \"(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) = [::]) \\<longleftrightarrow> (j < i)\"\n  \"([::] = supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) \\<longleftrightarrow> (j < i)\"", "lemma supto_simp[simp]:\n  \"j < i \\<Longrightarrow> supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) = [::]\"\n  \"i \\<le> j \\<Longrightarrow> supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) = MkI\\<cdot>i :# supto\\<cdot>(MkI\\<cdot>i+1)\\<cdot>(MkI\\<cdot>j)\"\n  \"supto\\<cdot>0\\<cdot>0 = [:0:]\"", "lemma supto_defined[simp]: \"supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>\" (is \"?P i j\")", "lemma supto_bottom_iff[simp]:\n  \"(supto\\<cdot>i\\<cdot>j = \\<bottom>) \\<longleftrightarrow> (i = \\<bottom> \\<or> j = \\<bottom>)\"", "lemma supto_snoc[simp]:\n  \"i \\<le> j \\<Longrightarrow> supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) = supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j-1) :@ [:MkI\\<cdot>j:]\"", "lemma slength_supto[simp]: \"slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) = MkI\\<cdot>(if j < i then 0 else j - i + 1)\" (is \"?P i j\")", "lemma sset_supto[simp]:\n  \"sset (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) = {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j}\" (is \"sset (?u i j) = ?R i j\")", "lemma supto_split1: \\<comment>\\<open>From \\<open>HOL.List\\<close>\\<close>\n  assumes \"i \\<le> j\"\n  assumes \"j \\<le> k\"\n  shows \"supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>k) = supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>(j - 1)) :@ supto\\<cdot>(MkI\\<cdot>j)\\<cdot>(MkI\\<cdot>k)\"", "lemma supto_split2: \\<comment>\\<open>From \\<open>HOL.List\\<close>\\<close>\n  assumes \"i \\<le> j\"\n  assumes \"j \\<le> k\"\n  shows \"supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>k) = supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) :@ supto\\<cdot>(MkI\\<cdot>(j + 1))\\<cdot>(MkI\\<cdot>k)\"", "lemma supto_split3: \\<comment>\\<open>From \\<open>HOL.List\\<close>\\<close>\n  assumes \"i \\<le> j\"\n  assumes \"j \\<le> k\"\n  shows \"supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>k) = supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>(j - 1)) :@ MkI\\<cdot>j :# supto\\<cdot>(MkI\\<cdot>(j + 1))\\<cdot>(MkI\\<cdot>k)\"", "lemma sinits_stake':\n  shows \"sinits\\<cdot>xs = smap\\<cdot>(\\<Lambda> i. stake\\<cdot>i\\<cdot>xs)\\<cdot>(supto\\<cdot>0\\<cdot>(slength\\<cdot>xs))\"", "lemma stails_sdrop':\n  shows \"stails\\<cdot>xs = smap\\<cdot>(\\<Lambda> i. sdrop\\<cdot>i\\<cdot>xs)\\<cdot>(supto\\<cdot>0\\<cdot>(slength\\<cdot>xs))\"", "lemma sdrop_elem_stails[iff]:\n  assumes \"xs \\<noteq> \\<bottom>\"\n  shows \"sdrop\\<cdot>(MkI\\<cdot>i)\\<cdot>xs \\<in> sset (stails\\<cdot>xs)\"", "lemma slast_strict[simp]:\n  \"slast\\<cdot>\\<bottom> = \\<bottom>\"", "lemma slast_singleton[simp]: \"slast\\<cdot>[:x:] = x\"", "lemma slast_sappend_ssnoc[simp]:\n  assumes \"xs \\<noteq> \\<bottom>\"\n  shows \"slast\\<cdot>(xs :@ [:x:]) = x\"", "lemma sbutlast_strict[simp]:\n  \"sbutlast\\<cdot>\\<bottom> = \\<bottom>\"", "lemma sbutlast_sappend_ssnoc[simp]:\n  assumes \"x \\<noteq> \\<bottom>\"\n  shows \"sbutlast\\<cdot>(xs :@ [:x:]) = xs\"", "lemma prefix_strict[simp]: \"prefix\\<cdot>\\<bottom> = \\<bottom>\"", "lemma prefix_bottom_iff[simp]: \"(prefix\\<cdot>xs\\<cdot>ys = \\<bottom>) \\<longleftrightarrow> (xs = \\<bottom> \\<or> ys = \\<bottom>)\"", "lemma prefix_definedD:\n  assumes \"prefix\\<cdot>xs\\<cdot>ys = TT\"\n  shows \"xs \\<noteq> \\<bottom> \\<and> ys \\<noteq> \\<bottom>\"", "lemma prefix_refl[simp]:\n  assumes \"xs \\<noteq> \\<bottom>\"\n  shows \"prefix\\<cdot>xs\\<cdot>xs = TT\"", "lemma prefix_refl_conv[simp]: \"(prefix\\<cdot>xs\\<cdot>xs = TT) \\<longleftrightarrow> (xs \\<noteq> \\<bottom>)\"", "lemma  prefix_of_snil[simp]: \"prefix\\<cdot>xs\\<cdot>[::] = (case xs of [::] \\<Rightarrow> TT | x :# xs \\<Rightarrow> FF)\"", "lemma prefix_singleton_TT:\n  shows \"prefix\\<cdot>[:x:]\\<cdot>ys = TT \\<longleftrightarrow> (x \\<noteq> \\<bottom> \\<and> (\\<exists>zs. zs \\<noteq> \\<bottom> \\<and> ys = x :# zs))\"", "lemma prefix_singleton_FF:\n  shows \"prefix\\<cdot>[:x:]\\<cdot>ys = FF \\<longleftrightarrow> (x \\<noteq> \\<bottom> \\<and> (ys = [::] \\<or> (\\<exists>z zs. z \\<noteq> \\<bottom> \\<and> zs \\<noteq> \\<bottom> \\<and> ys = z :# zs \\<and> x \\<noteq> z)))\"", "lemma prefix_FF_not_snilD:\n  assumes \"prefix\\<cdot>xs\\<cdot>ys = FF\"\n  shows \"xs \\<noteq> [::]\"", "lemma prefix_slength:\n  assumes \"prefix\\<cdot>xs\\<cdot>ys = TT\"\n  shows \"le\\<cdot>(slength\\<cdot>xs)\\<cdot>(slength\\<cdot>ys) = TT\"", "lemma prefix_slength_strengthen: \"prefix\\<cdot>xs\\<cdot>ys = (le\\<cdot>(slength\\<cdot>xs)\\<cdot>(slength\\<cdot>ys) andalso prefix\\<cdot>xs\\<cdot>ys)\"", "lemma prefix_scons_snil[simp]: \"prefix\\<cdot>(x :# xs)\\<cdot>[::] \\<noteq> TT\"", "lemma scons_prefix_scons[simp]:\n  \"(prefix\\<cdot>(x :# xs)\\<cdot>(y :# ys) = TT) \\<longleftrightarrow> (eq\\<cdot>x\\<cdot>y = TT \\<and> prefix\\<cdot>xs\\<cdot>ys = TT)\"", "lemma append_prefixD:\n  assumes \"prefix\\<cdot>(xs :@ ys)\\<cdot>zs = TT\"\n  shows \"prefix\\<cdot>xs\\<cdot>zs = TT\"", "lemma same_prefix_prefix[simp]:\n  assumes \"xs \\<noteq> \\<bottom>\"\n  shows \"prefix\\<cdot>(xs :@ ys)\\<cdot>(xs :@ zs) = prefix\\<cdot>ys\\<cdot>zs\"", "lemma eq_prefix_TT:\n  assumes \"eq\\<cdot>xs\\<cdot>ys = TT\"\n  shows \"prefix\\<cdot>xs\\<cdot>ys = TT\"", "lemma prefix_eq_FF:\n  assumes \"prefix\\<cdot>xs\\<cdot>ys = FF\"\n  shows \"eq\\<cdot>xs\\<cdot>ys = FF\"", "lemma prefix_slength_eq:\n  shows \"eq\\<cdot>xs\\<cdot>ys = (eq\\<cdot>(slength\\<cdot>xs)\\<cdot>(slength\\<cdot>ys) andalso prefix\\<cdot>xs\\<cdot>ys)\"", "lemma stake_slength_plus_1:\n  shows \"stake\\<cdot>(slength\\<cdot>xs + 1)\\<cdot>(y :# ys) = y :# stake\\<cdot>(slength\\<cdot>xs)\\<cdot>ys\"", "lemma sdrop_slength_plus_1:\n  assumes \"y \\<noteq> \\<bottom>\"\n  shows \"sdrop\\<cdot>(slength\\<cdot>xs + 1)\\<cdot>(y :# ys) = sdrop\\<cdot>(slength\\<cdot>xs)\\<cdot>ys\"", "lemma eq_take_length_prefix: \"prefix\\<cdot>xs\\<cdot>ys = eq\\<cdot>xs\\<cdot>(stake\\<cdot>(slength\\<cdot>xs)\\<cdot>ys)\"", "lemma prefix_sdrop_slength:\n  assumes \"prefix\\<cdot>xs\\<cdot>ys = TT\"\n  shows \"xs :@ sdrop\\<cdot>(slength\\<cdot>xs)\\<cdot>ys = ys\"", "lemma prefix_sdrop_prefix_eq:\n  assumes \"prefix\\<cdot>xs\\<cdot>ys = TT\"\n  shows \"eq\\<cdot>(sdrop\\<cdot>(slength\\<cdot>xs)\\<cdot>ys)\\<cdot>[::] = eq\\<cdot>ys\\<cdot>xs\""], "translations": [["", "lemma scons_strict[simp]: \"scons\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. scons\\<cdot>\\<bottom> = \\<bottom>", "by (clarsimp simp: cfun_eq_iff)"], ["", "lemma shead_bottom_iff[simp]: \"(shead\\<cdot>xs = \\<bottom>) \\<longleftrightarrow> (xs = \\<bottom> \\<or> xs = [::])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (shead\\<cdot>xs = \\<bottom>) = (xs = \\<bottom> \\<or> xs = [::])", "by (cases xs) simp_all"], ["", "lemma stail_bottom_iff[simp]: \"(stail\\<cdot>xs = \\<bottom>) \\<longleftrightarrow> (xs = \\<bottom> \\<or> xs = [::])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (stail\\<cdot>xs = \\<bottom>) = (xs = \\<bottom> \\<or> xs = [::])", "by (cases xs) simp_all"], ["", "lemma match_snil_match_scons_slist_case: \"match_snil\\<cdot>xs\\<cdot>k1 +++ match_scons\\<cdot>xs\\<cdot>k2 = slist_case\\<cdot>k1\\<cdot>k2\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. match_snil\\<cdot>xs\\<cdot>k1 +++ match_scons\\<cdot>xs\\<cdot>k2 =\n    slist_case\\<cdot>k1\\<cdot>k2\\<cdot>xs", "by (cases xs) simp_all"], ["", "lemma slist_bottom': \"slist_case\\<cdot>\\<bottom>\\<cdot>\\<bottom>\\<cdot>xs = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> [::]. \\<bottom>)\\<cdot>xs = \\<bottom>", "by (cases xs; simp)"], ["", "lemma slist_bottom[simp]: \"slist_case\\<cdot>\\<bottom>\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<Lambda> [::]. \\<bottom>) = \\<bottom>", "by (simp add: cfun_eq_iff slist_bottom')"], ["", "lemma slist_case_distr:\n  \"f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow> f\\<cdot>(slist_case\\<cdot>g\\<cdot>h\\<cdot>xs) = slist_case\\<cdot>(f\\<cdot>g)\\<cdot>(\\<Lambda> x xs. f\\<cdot>(h\\<cdot>x\\<cdot>xs))\\<cdot>xs\"\n  \"slist_case\\<cdot>g'\\<cdot>h'\\<cdot>xs\\<cdot>z = slist_case\\<cdot>(g'\\<cdot>z)\\<cdot>(\\<Lambda> x xs. h'\\<cdot>x\\<cdot>xs\\<cdot>z)\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (f\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow>\n     f\\<cdot>(slist_case\\<cdot>g\\<cdot>h\\<cdot>xs) =\n     (case xs of [::] \\<Rightarrow> f\\<cdot>g\n      | x :# xs \\<Rightarrow> f\\<cdot>(h\\<cdot>x\\<cdot>xs))) &&&\n    slist_case\\<cdot>g'\\<cdot>h'\\<cdot>xs\\<cdot>z =\n    (case xs of [::] \\<Rightarrow> g'\\<cdot>z\n     | x :# xs \\<Rightarrow> h'\\<cdot>x\\<cdot>xs\\<cdot>z)", "by (case_tac [!] xs) simp_all"], ["", "lemma slist_case_cong:\n  assumes \"xs = xs'\"\n  assumes \"xs' = [::] \\<Longrightarrow> n = n'\"\n  assumes \"\\<And>y ys. \\<lbrakk>xs' = y :# ys; y \\<noteq> \\<bottom>; ys \\<noteq> \\<bottom>\\<rbrakk> \\<Longrightarrow> c y ys = c' y ys\"\n  assumes \"cont (\\<lambda>(x, y). c x y)\"\n  assumes \"cont (\\<lambda>(x, y). c' x y)\"\n  shows \"slist_case\\<cdot>n\\<cdot>(\\<Lambda> x xs. c x xs)\\<cdot>xs = slist_case\\<cdot>n'\\<cdot>(\\<Lambda> x xs. c' x xs)\\<cdot>xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (case xs of [::] \\<Rightarrow> n | x :# xs \\<Rightarrow> c x xs) =\n    (case xs' of [::] \\<Rightarrow> n' | x :# xs \\<Rightarrow> c' x xs)", "using assms"], ["proof (prove)\nusing this:\n  xs = xs'\n  xs' = [::] \\<Longrightarrow> n = n'\n  \\<lbrakk>xs' = ?y :# ?ys; ?y \\<noteq> \\<bottom>;\n   ?ys \\<noteq> \\<bottom>\\<rbrakk>\n  \\<Longrightarrow> c ?y ?ys = c' ?y ?ys\n  cont (\\<lambda>(x, y). c x y)\n  cont (\\<lambda>(x, y). c' x y)\n\ngoal (1 subgoal):\n 1. (case xs of [::] \\<Rightarrow> n | x :# xs \\<Rightarrow> c x xs) =\n    (case xs' of [::] \\<Rightarrow> n' | x :# xs \\<Rightarrow> c' x xs)", "by (cases xs; cases xs'; clarsimp simp: prod_cont_iff)"], ["", "text\\<open>\n\nSection syntax for @{const \\<open>scons\\<close>} ala Haskell.\n\n\\<close>"], ["", "syntax\n  \"_scons_section\" :: \"'a \\<rightarrow> [:'a:] \\<rightarrow> [:'a:]\" (\"'(:#')\")\n  \"_scons_section_left\" :: \"'a \\<Rightarrow> [:'a:] \\<rightarrow> [:'a:]\" (\"'(_:#')\")"], ["", "translations\n  \"(x:#)\" == \"(CONST Rep_cfun) (CONST scons) x\""], ["", "abbreviation scons_section_right :: \"[:'a:] \\<Rightarrow> 'a \\<rightarrow> [:'a:]\" (\"'(:#_')\") where\n  \"(:#xs) \\<equiv> \\<Lambda> x. x :# xs\""], ["", "syntax\n  \"_strict_list\" :: \"args \\<Rightarrow> [:'a:]\" (\"[:(_):]\")"], ["", "translations\n  \"[:x, xs:]\" == \"x :# [:xs:]\"\n  \"[:x:]\" == \"x :# [::]\""], ["", "text\\<open>\n\nClass instances.\n\n\\<close>"], ["", "instantiation slist :: (Eq) Eq_strict\nbegin"], ["", "fixrec eq_slist :: \"[:'a:] \\<rightarrow> [:'a:] \\<rightarrow> tr\" where\n  \"eq_slist\\<cdot>[::]\\<cdot>[::] = TT\"\n| \"\\<lbrakk>x \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>\\<rbrakk> \\<Longrightarrow> eq_slist\\<cdot>(x :# xs)\\<cdot>[::] = FF\"\n| \"\\<lbrakk>y \\<noteq> \\<bottom>; ys \\<noteq> \\<bottom>\\<rbrakk> \\<Longrightarrow> eq_slist\\<cdot>[::]\\<cdot>(y :# ys) = FF\"\n| \"\\<lbrakk>x \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>; y \\<noteq> \\<bottom>; ys \\<noteq> \\<bottom>\\<rbrakk> \\<Longrightarrow> eq_slist\\<cdot>(x :# xs)\\<cdot>(y :# ys) = (eq\\<cdot>x\\<cdot>y andalso eq_slist\\<cdot>xs\\<cdot>ys)\""], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS([:'a:], Eq_strict_class)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. eq\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\n 2. \\<And>y. eq\\<cdot>\\<bottom>\\<cdot>y = \\<bottom>", "fix xs :: \"[:'a:]\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. eq\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\n 2. \\<And>y. eq\\<cdot>\\<bottom>\\<cdot>y = \\<bottom>", "show \"eq\\<cdot>xs\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq\\<cdot>xs\\<cdot>\\<bottom> = \\<bottom>", "by (cases xs) (subst eq_slist.unfold; simp)+"], ["proof (state)\nthis:\n  eq\\<cdot>xs\\<cdot>\\<bottom> = \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<And>y. eq\\<cdot>\\<bottom>\\<cdot>y = \\<bottom>", "show \"eq\\<cdot>\\<bottom>\\<cdot>xs = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq\\<cdot>\\<bottom>\\<cdot>xs = \\<bottom>", "by (cases xs) (subst eq_slist.unfold; simp)+"], ["proof (state)\nthis:\n  eq\\<cdot>\\<bottom>\\<cdot>xs = \\<bottom>\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "instance slist :: (Eq_sym) Eq_sym"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS([:'a:], Eq_sym_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. eq\\<cdot>x\\<cdot>y = eq\\<cdot>y\\<cdot>x", "fix xs ys :: \"[:'a:]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y. eq\\<cdot>x\\<cdot>y = eq\\<cdot>y\\<cdot>x", "show \"eq\\<cdot>xs\\<cdot>ys = eq\\<cdot>ys\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq\\<cdot>xs\\<cdot>ys = eq\\<cdot>ys\\<cdot>xs", "proof (induct xs arbitrary: ys)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ys. eq\\<cdot>\\<bottom>\\<cdot>ys = eq\\<cdot>ys\\<cdot>\\<bottom>\n 2. \\<And>ys. eq\\<cdot>[::]\\<cdot>ys = eq\\<cdot>ys\\<cdot>[::]\n 3. \\<And>a xs ys.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>ys. eq\\<cdot>xs\\<cdot>ys = eq\\<cdot>ys\\<cdot>xs\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>(a :# xs)\\<cdot>ys =\n                         eq\\<cdot>ys\\<cdot>(a :# xs)", "case snil"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>ys. eq\\<cdot>\\<bottom>\\<cdot>ys = eq\\<cdot>ys\\<cdot>\\<bottom>\n 2. \\<And>ys. eq\\<cdot>[::]\\<cdot>ys = eq\\<cdot>ys\\<cdot>[::]\n 3. \\<And>a xs ys.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>ys. eq\\<cdot>xs\\<cdot>ys = eq\\<cdot>ys\\<cdot>xs\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>(a :# xs)\\<cdot>ys =\n                         eq\\<cdot>ys\\<cdot>(a :# xs)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eq\\<cdot>[::]\\<cdot>ys = eq\\<cdot>ys\\<cdot>[::]", "by (cases ys; simp)"], ["proof (state)\nthis:\n  eq\\<cdot>[::]\\<cdot>ys = eq\\<cdot>ys\\<cdot>[::]\n\ngoal (2 subgoals):\n 1. \\<And>ys. eq\\<cdot>\\<bottom>\\<cdot>ys = eq\\<cdot>ys\\<cdot>\\<bottom>\n 2. \\<And>a xs ys.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>ys. eq\\<cdot>xs\\<cdot>ys = eq\\<cdot>ys\\<cdot>xs\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>(a :# xs)\\<cdot>ys =\n                         eq\\<cdot>ys\\<cdot>(a :# xs)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys. eq\\<cdot>\\<bottom>\\<cdot>ys = eq\\<cdot>ys\\<cdot>\\<bottom>\n 2. \\<And>a xs ys.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>ys. eq\\<cdot>xs\\<cdot>ys = eq\\<cdot>ys\\<cdot>xs\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>(a :# xs)\\<cdot>ys =\n                         eq\\<cdot>ys\\<cdot>(a :# xs)", "case scons"], ["proof (state)\nthis:\n  a_ \\<noteq> \\<bottom>\n  xs_ \\<noteq> \\<bottom>\n  eq\\<cdot>xs_\\<cdot>?ys = eq\\<cdot>?ys\\<cdot>xs_\n\ngoal (2 subgoals):\n 1. \\<And>ys. eq\\<cdot>\\<bottom>\\<cdot>ys = eq\\<cdot>ys\\<cdot>\\<bottom>\n 2. \\<And>a xs ys.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>ys. eq\\<cdot>xs\\<cdot>ys = eq\\<cdot>ys\\<cdot>xs\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>(a :# xs)\\<cdot>ys =\n                         eq\\<cdot>ys\\<cdot>(a :# xs)", "then"], ["proof (chain)\npicking this:\n  a_ \\<noteq> \\<bottom>\n  xs_ \\<noteq> \\<bottom>\n  eq\\<cdot>xs_\\<cdot>?ys = eq\\<cdot>?ys\\<cdot>xs_", "show ?case"], ["proof (prove)\nusing this:\n  a_ \\<noteq> \\<bottom>\n  xs_ \\<noteq> \\<bottom>\n  eq\\<cdot>xs_\\<cdot>?ys = eq\\<cdot>?ys\\<cdot>xs_\n\ngoal (1 subgoal):\n 1. eq\\<cdot>(a_ :# xs_)\\<cdot>ys = eq\\<cdot>ys\\<cdot>(a_ :# xs_)", "by (cases ys; simp add: eq_sym)"], ["proof (state)\nthis:\n  eq\\<cdot>(a_ :# xs_)\\<cdot>ys = eq\\<cdot>ys\\<cdot>(a_ :# xs_)\n\ngoal (1 subgoal):\n 1. \\<And>ys. eq\\<cdot>\\<bottom>\\<cdot>ys = eq\\<cdot>ys\\<cdot>\\<bottom>", "qed simp_all"], ["proof (state)\nthis:\n  eq\\<cdot>xs\\<cdot>ys = eq\\<cdot>ys\\<cdot>xs\n\ngoal:\nNo subgoals!", "qed"], ["", "instance slist :: (Eq_equiv) Eq_equiv"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS([:'a:], Eq_equiv_class)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. eq\\<cdot>x\\<cdot>x \\<noteq> FF\n 2. \\<And>x y z.\n       \\<lbrakk>eq\\<cdot>x\\<cdot>y = TT; eq\\<cdot>y\\<cdot>z = TT\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>x\\<cdot>z = TT", "fix xs ys zs :: \"[:'a:]\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. eq\\<cdot>x\\<cdot>x \\<noteq> FF\n 2. \\<And>x y z.\n       \\<lbrakk>eq\\<cdot>x\\<cdot>y = TT; eq\\<cdot>y\\<cdot>z = TT\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>x\\<cdot>z = TT", "show \"eq\\<cdot>xs\\<cdot>xs \\<noteq> FF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq\\<cdot>xs\\<cdot>xs \\<noteq> FF", "by (induct xs) simp_all"], ["proof (state)\nthis:\n  eq\\<cdot>xs\\<cdot>xs \\<noteq> FF\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>eq\\<cdot>x\\<cdot>y = TT; eq\\<cdot>y\\<cdot>z = TT\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>x\\<cdot>z = TT", "assume \"eq\\<cdot>xs\\<cdot>ys = TT\" and \"eq\\<cdot>ys\\<cdot>zs = TT\""], ["proof (state)\nthis:\n  eq\\<cdot>xs\\<cdot>ys = TT\n  eq\\<cdot>ys\\<cdot>zs = TT\n\ngoal (1 subgoal):\n 1. \\<And>x y z.\n       \\<lbrakk>eq\\<cdot>x\\<cdot>y = TT; eq\\<cdot>y\\<cdot>z = TT\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>x\\<cdot>z = TT", "then"], ["proof (chain)\npicking this:\n  eq\\<cdot>xs\\<cdot>ys = TT\n  eq\\<cdot>ys\\<cdot>zs = TT", "show \"eq\\<cdot>xs\\<cdot>zs = TT\""], ["proof (prove)\nusing this:\n  eq\\<cdot>xs\\<cdot>ys = TT\n  eq\\<cdot>ys\\<cdot>zs = TT\n\ngoal (1 subgoal):\n 1. eq\\<cdot>xs\\<cdot>zs = TT", "proof (induct xs arbitrary: ys zs)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ys zs.\n       \\<lbrakk>eq\\<cdot>\\<bottom>\\<cdot>ys = TT;\n        eq\\<cdot>ys\\<cdot>zs = TT\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>\\<bottom>\\<cdot>zs = TT\n 2. \\<And>ys zs.\n       \\<lbrakk>eq\\<cdot>[::]\\<cdot>ys = TT;\n        eq\\<cdot>ys\\<cdot>zs = TT\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>[::]\\<cdot>zs = TT\n 3. \\<And>a xs ys zs.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>ys zs.\n           \\<lbrakk>eq\\<cdot>xs\\<cdot>ys = TT;\n            eq\\<cdot>ys\\<cdot>zs = TT\\<rbrakk>\n           \\<Longrightarrow> eq\\<cdot>xs\\<cdot>zs = TT;\n        eq\\<cdot>(a :# xs)\\<cdot>ys = TT; eq\\<cdot>ys\\<cdot>zs = TT\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>(a :# xs)\\<cdot>zs = TT", "case (snil ys zs)"], ["proof (state)\nthis:\n  eq\\<cdot>[::]\\<cdot>ys = TT\n  eq\\<cdot>ys\\<cdot>zs = TT\n\ngoal (3 subgoals):\n 1. \\<And>ys zs.\n       \\<lbrakk>eq\\<cdot>\\<bottom>\\<cdot>ys = TT;\n        eq\\<cdot>ys\\<cdot>zs = TT\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>\\<bottom>\\<cdot>zs = TT\n 2. \\<And>ys zs.\n       \\<lbrakk>eq\\<cdot>[::]\\<cdot>ys = TT;\n        eq\\<cdot>ys\\<cdot>zs = TT\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>[::]\\<cdot>zs = TT\n 3. \\<And>a xs ys zs.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>ys zs.\n           \\<lbrakk>eq\\<cdot>xs\\<cdot>ys = TT;\n            eq\\<cdot>ys\\<cdot>zs = TT\\<rbrakk>\n           \\<Longrightarrow> eq\\<cdot>xs\\<cdot>zs = TT;\n        eq\\<cdot>(a :# xs)\\<cdot>ys = TT; eq\\<cdot>ys\\<cdot>zs = TT\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>(a :# xs)\\<cdot>zs = TT", "then"], ["proof (chain)\npicking this:\n  eq\\<cdot>[::]\\<cdot>ys = TT\n  eq\\<cdot>ys\\<cdot>zs = TT", "show ?case"], ["proof (prove)\nusing this:\n  eq\\<cdot>[::]\\<cdot>ys = TT\n  eq\\<cdot>ys\\<cdot>zs = TT\n\ngoal (1 subgoal):\n 1. eq\\<cdot>[::]\\<cdot>zs = TT", "by (cases ys, simp_all)"], ["proof (state)\nthis:\n  eq\\<cdot>[::]\\<cdot>zs = TT\n\ngoal (2 subgoals):\n 1. \\<And>ys zs.\n       \\<lbrakk>eq\\<cdot>\\<bottom>\\<cdot>ys = TT;\n        eq\\<cdot>ys\\<cdot>zs = TT\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>\\<bottom>\\<cdot>zs = TT\n 2. \\<And>a xs ys zs.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>ys zs.\n           \\<lbrakk>eq\\<cdot>xs\\<cdot>ys = TT;\n            eq\\<cdot>ys\\<cdot>zs = TT\\<rbrakk>\n           \\<Longrightarrow> eq\\<cdot>xs\\<cdot>zs = TT;\n        eq\\<cdot>(a :# xs)\\<cdot>ys = TT; eq\\<cdot>ys\\<cdot>zs = TT\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>(a :# xs)\\<cdot>zs = TT", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys zs.\n       \\<lbrakk>eq\\<cdot>\\<bottom>\\<cdot>ys = TT;\n        eq\\<cdot>ys\\<cdot>zs = TT\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>\\<bottom>\\<cdot>zs = TT\n 2. \\<And>a xs ys zs.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>ys zs.\n           \\<lbrakk>eq\\<cdot>xs\\<cdot>ys = TT;\n            eq\\<cdot>ys\\<cdot>zs = TT\\<rbrakk>\n           \\<Longrightarrow> eq\\<cdot>xs\\<cdot>zs = TT;\n        eq\\<cdot>(a :# xs)\\<cdot>ys = TT; eq\\<cdot>ys\\<cdot>zs = TT\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>(a :# xs)\\<cdot>zs = TT", "case (scons x xs ys zs)"], ["proof (state)\nthis:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  \\<lbrakk>eq\\<cdot>xs\\<cdot>?ys = TT; eq\\<cdot>?ys\\<cdot>?zs = TT\\<rbrakk>\n  \\<Longrightarrow> eq\\<cdot>xs\\<cdot>?zs = TT\n  eq\\<cdot>(x :# xs)\\<cdot>ys = TT\n  eq\\<cdot>ys\\<cdot>zs = TT\n\ngoal (2 subgoals):\n 1. \\<And>ys zs.\n       \\<lbrakk>eq\\<cdot>\\<bottom>\\<cdot>ys = TT;\n        eq\\<cdot>ys\\<cdot>zs = TT\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>\\<bottom>\\<cdot>zs = TT\n 2. \\<And>a xs ys zs.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>ys zs.\n           \\<lbrakk>eq\\<cdot>xs\\<cdot>ys = TT;\n            eq\\<cdot>ys\\<cdot>zs = TT\\<rbrakk>\n           \\<Longrightarrow> eq\\<cdot>xs\\<cdot>zs = TT;\n        eq\\<cdot>(a :# xs)\\<cdot>ys = TT; eq\\<cdot>ys\\<cdot>zs = TT\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>(a :# xs)\\<cdot>zs = TT", "with eq_trans"], ["proof (chain)\npicking this:\n  \\<lbrakk>eq\\<cdot>?x\\<cdot>?y = TT; eq\\<cdot>?y\\<cdot>?z = TT\\<rbrakk>\n  \\<Longrightarrow> eq\\<cdot>?x\\<cdot>?z = TT\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  \\<lbrakk>eq\\<cdot>xs\\<cdot>?ys = TT; eq\\<cdot>?ys\\<cdot>?zs = TT\\<rbrakk>\n  \\<Longrightarrow> eq\\<cdot>xs\\<cdot>?zs = TT\n  eq\\<cdot>(x :# xs)\\<cdot>ys = TT\n  eq\\<cdot>ys\\<cdot>zs = TT", "show ?case"], ["proof (prove)\nusing this:\n  \\<lbrakk>eq\\<cdot>?x\\<cdot>?y = TT; eq\\<cdot>?y\\<cdot>?z = TT\\<rbrakk>\n  \\<Longrightarrow> eq\\<cdot>?x\\<cdot>?z = TT\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  \\<lbrakk>eq\\<cdot>xs\\<cdot>?ys = TT; eq\\<cdot>?ys\\<cdot>?zs = TT\\<rbrakk>\n  \\<Longrightarrow> eq\\<cdot>xs\\<cdot>?zs = TT\n  eq\\<cdot>(x :# xs)\\<cdot>ys = TT\n  eq\\<cdot>ys\\<cdot>zs = TT\n\ngoal (1 subgoal):\n 1. eq\\<cdot>(x :# xs)\\<cdot>zs = TT", "by (cases ys; cases zs) auto"], ["proof (state)\nthis:\n  eq\\<cdot>(x :# xs)\\<cdot>zs = TT\n\ngoal (1 subgoal):\n 1. \\<And>ys zs.\n       \\<lbrakk>eq\\<cdot>\\<bottom>\\<cdot>ys = TT;\n        eq\\<cdot>ys\\<cdot>zs = TT\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>\\<bottom>\\<cdot>zs = TT", "qed simp_all"], ["proof (state)\nthis:\n  eq\\<cdot>xs\\<cdot>zs = TT\n\ngoal:\nNo subgoals!", "qed"], ["", "instance slist :: (Eq_eq) Eq_eq"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS([:'a:], Eq_eq_class)", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. eq\\<cdot>x\\<cdot>x \\<noteq> FF\n 2. \\<And>x y. eq\\<cdot>x\\<cdot>y = TT \\<Longrightarrow> x = y", "fix xs ys :: \"[:'a:]\""], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x. eq\\<cdot>x\\<cdot>x \\<noteq> FF\n 2. \\<And>x y. eq\\<cdot>x\\<cdot>y = TT \\<Longrightarrow> x = y", "show \"eq\\<cdot>xs\\<cdot>xs \\<noteq> FF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq\\<cdot>xs\\<cdot>xs \\<noteq> FF", "by (induct xs) simp_all"], ["proof (state)\nthis:\n  eq\\<cdot>xs\\<cdot>xs \\<noteq> FF\n\ngoal (1 subgoal):\n 1. \\<And>x y. eq\\<cdot>x\\<cdot>y = TT \\<Longrightarrow> x = y", "assume \"eq\\<cdot>xs\\<cdot>ys = TT\""], ["proof (state)\nthis:\n  eq\\<cdot>xs\\<cdot>ys = TT\n\ngoal (1 subgoal):\n 1. \\<And>x y. eq\\<cdot>x\\<cdot>y = TT \\<Longrightarrow> x = y", "then"], ["proof (chain)\npicking this:\n  eq\\<cdot>xs\\<cdot>ys = TT", "show \"xs = ys\""], ["proof (prove)\nusing this:\n  eq\\<cdot>xs\\<cdot>ys = TT\n\ngoal (1 subgoal):\n 1. xs = ys", "proof (induct xs arbitrary: ys)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ys.\n       eq\\<cdot>\\<bottom>\\<cdot>ys = TT \\<Longrightarrow> \\<bottom> = ys\n 2. \\<And>ys. eq\\<cdot>[::]\\<cdot>ys = TT \\<Longrightarrow> [::] = ys\n 3. \\<And>a xs ys.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>ys. eq\\<cdot>xs\\<cdot>ys = TT \\<Longrightarrow> xs = ys;\n        eq\\<cdot>(a :# xs)\\<cdot>ys = TT\\<rbrakk>\n       \\<Longrightarrow> a :# xs = ys", "case (snil ys)"], ["proof (state)\nthis:\n  eq\\<cdot>[::]\\<cdot>ys = TT\n\ngoal (3 subgoals):\n 1. \\<And>ys.\n       eq\\<cdot>\\<bottom>\\<cdot>ys = TT \\<Longrightarrow> \\<bottom> = ys\n 2. \\<And>ys. eq\\<cdot>[::]\\<cdot>ys = TT \\<Longrightarrow> [::] = ys\n 3. \\<And>a xs ys.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>ys. eq\\<cdot>xs\\<cdot>ys = TT \\<Longrightarrow> xs = ys;\n        eq\\<cdot>(a :# xs)\\<cdot>ys = TT\\<rbrakk>\n       \\<Longrightarrow> a :# xs = ys", "then"], ["proof (chain)\npicking this:\n  eq\\<cdot>[::]\\<cdot>ys = TT", "show ?case"], ["proof (prove)\nusing this:\n  eq\\<cdot>[::]\\<cdot>ys = TT\n\ngoal (1 subgoal):\n 1. [::] = ys", "by (cases ys) simp_all"], ["proof (state)\nthis:\n  [::] = ys\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       eq\\<cdot>\\<bottom>\\<cdot>ys = TT \\<Longrightarrow> \\<bottom> = ys\n 2. \\<And>a xs ys.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>ys. eq\\<cdot>xs\\<cdot>ys = TT \\<Longrightarrow> xs = ys;\n        eq\\<cdot>(a :# xs)\\<cdot>ys = TT\\<rbrakk>\n       \\<Longrightarrow> a :# xs = ys", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       eq\\<cdot>\\<bottom>\\<cdot>ys = TT \\<Longrightarrow> \\<bottom> = ys\n 2. \\<And>a xs ys.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>ys. eq\\<cdot>xs\\<cdot>ys = TT \\<Longrightarrow> xs = ys;\n        eq\\<cdot>(a :# xs)\\<cdot>ys = TT\\<rbrakk>\n       \\<Longrightarrow> a :# xs = ys", "case (scons x xs ys)"], ["proof (state)\nthis:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  eq\\<cdot>xs\\<cdot>?ys = TT \\<Longrightarrow> xs = ?ys\n  eq\\<cdot>(x :# xs)\\<cdot>ys = TT\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       eq\\<cdot>\\<bottom>\\<cdot>ys = TT \\<Longrightarrow> \\<bottom> = ys\n 2. \\<And>a xs ys.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>ys. eq\\<cdot>xs\\<cdot>ys = TT \\<Longrightarrow> xs = ys;\n        eq\\<cdot>(a :# xs)\\<cdot>ys = TT\\<rbrakk>\n       \\<Longrightarrow> a :# xs = ys", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  eq\\<cdot>xs\\<cdot>?ys = TT \\<Longrightarrow> xs = ?ys\n  eq\\<cdot>(x :# xs)\\<cdot>ys = TT", "show ?case"], ["proof (prove)\nusing this:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  eq\\<cdot>xs\\<cdot>?ys = TT \\<Longrightarrow> xs = ?ys\n  eq\\<cdot>(x :# xs)\\<cdot>ys = TT\n\ngoal (1 subgoal):\n 1. x :# xs = ys", "by (cases ys) auto"], ["proof (state)\nthis:\n  x :# xs = ys\n\ngoal (1 subgoal):\n 1. \\<And>ys.\n       eq\\<cdot>\\<bottom>\\<cdot>ys = TT \\<Longrightarrow> \\<bottom> = ys", "qed simp"], ["proof (state)\nthis:\n  xs = ys\n\ngoal:\nNo subgoals!", "qed"], ["", "instance slist :: (Eq_def) Eq_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS([:'a:], Eq_def_class)", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<noteq> \\<bottom>; y \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>x\\<cdot>y \\<noteq> \\<bottom>", "fix xs ys :: \"[:'a:]\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<noteq> \\<bottom>; y \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>x\\<cdot>y \\<noteq> \\<bottom>", "assume \"xs \\<noteq> \\<bottom>\" and \"ys \\<noteq> \\<bottom>\""], ["proof (state)\nthis:\n  xs \\<noteq> \\<bottom>\n  ys \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<And>x y.\n       \\<lbrakk>x \\<noteq> \\<bottom>; y \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>x\\<cdot>y \\<noteq> \\<bottom>", "then"], ["proof (chain)\npicking this:\n  xs \\<noteq> \\<bottom>\n  ys \\<noteq> \\<bottom>", "show \"eq\\<cdot>xs\\<cdot>ys \\<noteq> \\<bottom>\""], ["proof (prove)\nusing this:\n  xs \\<noteq> \\<bottom>\n  ys \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. eq\\<cdot>xs\\<cdot>ys \\<noteq> \\<bottom>", "proof(induct xs arbitrary: ys)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>\\<bottom> \\<noteq> \\<bottom>; ys \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>\\<bottom>\\<cdot>ys \\<noteq> \\<bottom>\n 2. \\<And>ys.\n       \\<lbrakk>[::] \\<noteq> \\<bottom>; ys \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>[::]\\<cdot>ys \\<noteq> \\<bottom>\n 3. \\<And>a xs ys.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>ys.\n           \\<lbrakk>xs \\<noteq> \\<bottom>; ys \\<noteq> \\<bottom>\\<rbrakk>\n           \\<Longrightarrow> eq\\<cdot>xs\\<cdot>ys \\<noteq> \\<bottom>;\n        a :# xs \\<noteq> \\<bottom>; ys \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>(a :# xs)\\<cdot>ys \\<noteq> \\<bottom>", "case (snil ys)"], ["proof (state)\nthis:\n  [::] \\<noteq> \\<bottom>\n  ys \\<noteq> \\<bottom>\n\ngoal (3 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>\\<bottom> \\<noteq> \\<bottom>; ys \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>\\<bottom>\\<cdot>ys \\<noteq> \\<bottom>\n 2. \\<And>ys.\n       \\<lbrakk>[::] \\<noteq> \\<bottom>; ys \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>[::]\\<cdot>ys \\<noteq> \\<bottom>\n 3. \\<And>a xs ys.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>ys.\n           \\<lbrakk>xs \\<noteq> \\<bottom>; ys \\<noteq> \\<bottom>\\<rbrakk>\n           \\<Longrightarrow> eq\\<cdot>xs\\<cdot>ys \\<noteq> \\<bottom>;\n        a :# xs \\<noteq> \\<bottom>; ys \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>(a :# xs)\\<cdot>ys \\<noteq> \\<bottom>", "then"], ["proof (chain)\npicking this:\n  [::] \\<noteq> \\<bottom>\n  ys \\<noteq> \\<bottom>", "show ?case"], ["proof (prove)\nusing this:\n  [::] \\<noteq> \\<bottom>\n  ys \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. eq\\<cdot>[::]\\<cdot>ys \\<noteq> \\<bottom>", "by (cases ys) simp_all"], ["proof (state)\nthis:\n  eq\\<cdot>[::]\\<cdot>ys \\<noteq> \\<bottom>\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>\\<bottom> \\<noteq> \\<bottom>; ys \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>\\<bottom>\\<cdot>ys \\<noteq> \\<bottom>\n 2. \\<And>a xs ys.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>ys.\n           \\<lbrakk>xs \\<noteq> \\<bottom>; ys \\<noteq> \\<bottom>\\<rbrakk>\n           \\<Longrightarrow> eq\\<cdot>xs\\<cdot>ys \\<noteq> \\<bottom>;\n        a :# xs \\<noteq> \\<bottom>; ys \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>(a :# xs)\\<cdot>ys \\<noteq> \\<bottom>", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>\\<bottom> \\<noteq> \\<bottom>; ys \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>\\<bottom>\\<cdot>ys \\<noteq> \\<bottom>\n 2. \\<And>a xs ys.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>ys.\n           \\<lbrakk>xs \\<noteq> \\<bottom>; ys \\<noteq> \\<bottom>\\<rbrakk>\n           \\<Longrightarrow> eq\\<cdot>xs\\<cdot>ys \\<noteq> \\<bottom>;\n        a :# xs \\<noteq> \\<bottom>; ys \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>(a :# xs)\\<cdot>ys \\<noteq> \\<bottom>", "case (scons a xs)"], ["proof (state)\nthis:\n  a \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  \\<lbrakk>xs \\<noteq> \\<bottom>; ?ys \\<noteq> \\<bottom>\\<rbrakk>\n  \\<Longrightarrow> eq\\<cdot>xs\\<cdot>?ys \\<noteq> \\<bottom>\n  a :# xs \\<noteq> \\<bottom>\n  ys \\<noteq> \\<bottom>\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<lbrakk>\\<bottom> \\<noteq> \\<bottom>; ys \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>\\<bottom>\\<cdot>ys \\<noteq> \\<bottom>\n 2. \\<And>a xs ys.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>ys.\n           \\<lbrakk>xs \\<noteq> \\<bottom>; ys \\<noteq> \\<bottom>\\<rbrakk>\n           \\<Longrightarrow> eq\\<cdot>xs\\<cdot>ys \\<noteq> \\<bottom>;\n        a :# xs \\<noteq> \\<bottom>; ys \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>(a :# xs)\\<cdot>ys \\<noteq> \\<bottom>", "then"], ["proof (chain)\npicking this:\n  a \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  \\<lbrakk>xs \\<noteq> \\<bottom>; ?ys \\<noteq> \\<bottom>\\<rbrakk>\n  \\<Longrightarrow> eq\\<cdot>xs\\<cdot>?ys \\<noteq> \\<bottom>\n  a :# xs \\<noteq> \\<bottom>\n  ys \\<noteq> \\<bottom>", "show ?case"], ["proof (prove)\nusing this:\n  a \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  \\<lbrakk>xs \\<noteq> \\<bottom>; ?ys \\<noteq> \\<bottom>\\<rbrakk>\n  \\<Longrightarrow> eq\\<cdot>xs\\<cdot>?ys \\<noteq> \\<bottom>\n  a :# xs \\<noteq> \\<bottom>\n  ys \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. eq\\<cdot>(a :# xs)\\<cdot>ys \\<noteq> \\<bottom>", "by (cases ys) simp_all"], ["proof (state)\nthis:\n  eq\\<cdot>(a :# xs)\\<cdot>ys \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<And>ys.\n       \\<lbrakk>\\<bottom> \\<noteq> \\<bottom>; ys \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>\\<bottom>\\<cdot>ys \\<noteq> \\<bottom>", "qed simp"], ["proof (state)\nthis:\n  eq\\<cdot>xs\\<cdot>ys \\<noteq> \\<bottom>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma slist_eq_TT_snil[simp]:\n  fixes xs :: \"[:'a::Eq:]\"\n  shows \"(eq\\<cdot>xs\\<cdot>[::] = TT) \\<longleftrightarrow> (xs = [::])\"\n        \"(eq\\<cdot>[::]\\<cdot>xs = TT) \\<longleftrightarrow> (xs = [::])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (eq\\<cdot>xs\\<cdot>[::] = TT) = (xs = [::]) &&&\n    (eq\\<cdot>[::]\\<cdot>xs = TT) = (xs = [::])", "by (cases xs; simp)+"], ["", "lemma slist_eq_FF_snil[simp]:\n  fixes xs :: \"[:'a::Eq:]\"\n  shows \"(eq\\<cdot>xs\\<cdot>[::] = FF) \\<longleftrightarrow> (\\<exists>y ys. y \\<noteq> \\<bottom> \\<and> ys \\<noteq> \\<bottom> \\<and> xs = y :# ys)\"\n        \"(eq\\<cdot>[::]\\<cdot>xs = FF) \\<longleftrightarrow> (\\<exists>y ys. y \\<noteq> \\<bottom> \\<and> ys \\<noteq> \\<bottom> \\<and> xs = y :# ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (eq\\<cdot>xs\\<cdot>[::] = FF) =\n    (\\<exists>y ys.\n        y \\<noteq> \\<bottom> \\<and>\n        ys \\<noteq> \\<bottom> \\<and> xs = y :# ys) &&&\n    (eq\\<cdot>[::]\\<cdot>xs = FF) =\n    (\\<exists>y ys.\n        y \\<noteq> \\<bottom> \\<and>\n        ys \\<noteq> \\<bottom> \\<and> xs = y :# ys)", "by (cases xs; force)+"], ["", "subsection\\<open> Some of the usual reasoning infrastructure \\<close>"], ["", "inductive slistmem :: \"'a \\<Rightarrow> [:'a:] \\<Rightarrow> bool\" where\n  \"\\<lbrakk>x \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>\\<rbrakk> \\<Longrightarrow> slistmem x (x :# xs)\"\n| \"\\<lbrakk>slistmem x xs; y \\<noteq> \\<bottom>\\<rbrakk> \\<Longrightarrow> slistmem x (y :# xs)\""], ["", "lemma slistmem_bottom1[iff]:\n  fixes x :: \"'a\"\n  shows \"\\<not> slistmem x \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> slistmem x \\<bottom>", "by rule (induct x \"\\<bottom>::[:'a:]\" rule: slistmem.induct; fastforce)"], ["", "lemma slistmem_bottom2[iff]:\n  fixes xs :: \"[:'a:]\"\n  shows \"\\<not> slistmem \\<bottom> xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> slistmem \\<bottom> xs", "by rule (induct \"\\<bottom>::'a\" xs rule: slistmem.induct; fastforce)"], ["", "lemma slistmem_nil[iff]:\n  shows \"\\<not> slistmem x [::]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<not> slistmem x [::]", "by (fastforce elim: slistmem.cases)"], ["", "lemma slistmem_scons[simp]:\n  shows \"slistmem x (y :# ys) \\<longleftrightarrow> (x = y \\<and> x \\<noteq> \\<bottom> \\<and> ys \\<noteq> \\<bottom>) \\<or> (slistmem x ys \\<and> y \\<noteq> \\<bottom>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slistmem x (y :# ys) =\n    (x = y \\<and> x \\<noteq> \\<bottom> \\<and> ys \\<noteq> \\<bottom> \\<or>\n     slistmem x ys \\<and> y \\<noteq> \\<bottom>)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. slistmem x (y :# ys) =\n    (x = y \\<and> x \\<noteq> \\<bottom> \\<and> ys \\<noteq> \\<bottom> \\<or>\n     slistmem x ys \\<and> y \\<noteq> \\<bottom>)", "have \"x = y \\<or> slistmem x ys\" if \"slistmem x (y :# ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x = y \\<or> slistmem x ys", "using that"], ["proof (prove)\nusing this:\n  slistmem x (y :# ys)\n\ngoal (1 subgoal):\n 1. x = y \\<or> slistmem x ys", "by (induct \"x\" \"y :# ys\" arbitrary: y ys rule: slistmem.induct; force)"], ["proof (state)\nthis:\n  slistmem x (y :# ys) \\<Longrightarrow> x = y \\<or> slistmem x ys\n\ngoal (1 subgoal):\n 1. slistmem x (y :# ys) =\n    (x = y \\<and> x \\<noteq> \\<bottom> \\<and> ys \\<noteq> \\<bottom> \\<or>\n     slistmem x ys \\<and> y \\<noteq> \\<bottom>)", "then"], ["proof (chain)\npicking this:\n  slistmem x (y :# ys) \\<Longrightarrow> x = y \\<or> slistmem x ys", "show ?thesis"], ["proof (prove)\nusing this:\n  slistmem x (y :# ys) \\<Longrightarrow> x = y \\<or> slistmem x ys\n\ngoal (1 subgoal):\n 1. slistmem x (y :# ys) =\n    (x = y \\<and> x \\<noteq> \\<bottom> \\<and> ys \\<noteq> \\<bottom> \\<or>\n     slistmem x ys \\<and> y \\<noteq> \\<bottom>)", "by (auto elim: slistmem.cases intro: slistmem.intros)"], ["proof (state)\nthis:\n  slistmem x (y :# ys) =\n  (x = y \\<and> x \\<noteq> \\<bottom> \\<and> ys \\<noteq> \\<bottom> \\<or>\n   slistmem x ys \\<and> y \\<noteq> \\<bottom>)\n\ngoal:\nNo subgoals!", "qed"], ["", "definition sset :: \"[:'a:] \\<Rightarrow> 'a set\" where\n  \"sset xs = {x. slistmem x xs}\""], ["", "lemma sset_simp[simp]:\n  shows \"sset \\<bottom> = {}\"\n    and \"sset [::] = {}\"\n    and \"\\<lbrakk>x \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>\\<rbrakk> \\<Longrightarrow> sset (x :# xs) = insert x (sset xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sset \\<bottom> = {} &&&\n    sset [::] = {} &&&\n    (\\<lbrakk>x \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>\\<rbrakk>\n     \\<Longrightarrow> sset (x :# xs) = insert x (sset xs))", "unfolding sset_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. {x. slistmem x \\<bottom>} = {} &&&\n    {x. slistmem x [::]} = {} &&&\n    (\\<lbrakk>x \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>\\<rbrakk>\n     \\<Longrightarrow> {xa. slistmem xa (x :# xs)} =\n                       insert x {x. slistmem x xs})", "by (auto elim: slistmem.cases intro: slistmem.intros)"], ["", "lemma sset_defined[simp]:\n  assumes \"x \\<in> sset xs\"\n  shows \"x \\<noteq> \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> \\<bottom>", "using assms sset_def"], ["proof (prove)\nusing this:\n  x \\<in> sset xs\n  sset ?xs = {x. slistmem x ?xs}\n\ngoal (1 subgoal):\n 1. x \\<noteq> \\<bottom>", "by force"], ["", "lemma sset_below:\n  assumes \"y \\<in> sset ys\"\n  assumes \"xs \\<sqsubseteq> ys\"\n  assumes \"xs \\<noteq> \\<bottom>\"\n  obtains x where \"x \\<in> sset xs\" and \"x \\<sqsubseteq> y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> sset xs; x \\<sqsubseteq> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using assms"], ["proof (prove)\nusing this:\n  y \\<in> sset ys\n  xs \\<sqsubseteq> ys\n  xs \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. (\\<And>x.\n        \\<lbrakk>x \\<in> sset xs; x \\<sqsubseteq> y\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "proof(induct ys arbitrary: xs)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> sset xs; x \\<sqsubseteq> y\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        y \\<in> sset \\<bottom>; xs \\<sqsubseteq> \\<bottom>;\n        xs \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>xs.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> sset xs; x \\<sqsubseteq> y\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        y \\<in> sset [::]; xs \\<sqsubseteq> [::];\n        xs \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>a ys xs.\n       \\<lbrakk>a \\<noteq> \\<bottom>; ys \\<noteq> \\<bottom>;\n        \\<And>xs.\n           \\<lbrakk>\\<And>x.\n                       \\<lbrakk>x \\<in> sset xs; x \\<sqsubseteq> y\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            y \\<in> sset ys; xs \\<sqsubseteq> ys;\n            xs \\<noteq> \\<bottom>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>x.\n           \\<lbrakk>x \\<in> sset xs; x \\<sqsubseteq> y\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        y \\<in> sset (a :# ys); xs \\<sqsubseteq> a :# ys;\n        xs \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> thesis", "case (scons y ys xs)"], ["proof (state)\nthis:\n  y \\<noteq> \\<bottom>\n  ys \\<noteq> \\<bottom>\n  \\<lbrakk>\\<And>x.\n              \\<lbrakk>x \\<in> sset ?xs; x \\<sqsubseteq> y\\<rbrakk>\n              \\<Longrightarrow> thesis;\n   y \\<in> sset ys; ?xs \\<sqsubseteq> ys; ?xs \\<noteq> \\<bottom>\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>?x \\<in> sset xs; ?x \\<sqsubseteq> y\\<rbrakk>\n  \\<Longrightarrow> thesis\n  y \\<in> sset (y :# ys)\n  xs \\<sqsubseteq> y :# ys\n  xs \\<noteq> \\<bottom>\n\ngoal (3 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> sset xs; x \\<sqsubseteq> y\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        y \\<in> sset \\<bottom>; xs \\<sqsubseteq> \\<bottom>;\n        xs \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>xs.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> sset xs; x \\<sqsubseteq> y\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        y \\<in> sset [::]; xs \\<sqsubseteq> [::];\n        xs \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 3. \\<And>a ys xs.\n       \\<lbrakk>a \\<noteq> \\<bottom>; ys \\<noteq> \\<bottom>;\n        \\<And>xs.\n           \\<lbrakk>\\<And>x.\n                       \\<lbrakk>x \\<in> sset xs; x \\<sqsubseteq> y\\<rbrakk>\n                       \\<Longrightarrow> thesis;\n            y \\<in> sset ys; xs \\<sqsubseteq> ys;\n            xs \\<noteq> \\<bottom>\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        \\<And>x.\n           \\<lbrakk>x \\<in> sset xs; x \\<sqsubseteq> y\\<rbrakk>\n           \\<Longrightarrow> thesis;\n        y \\<in> sset (a :# ys); xs \\<sqsubseteq> a :# ys;\n        xs \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> thesis", "then"], ["proof (chain)\npicking this:\n  y \\<noteq> \\<bottom>\n  ys \\<noteq> \\<bottom>\n  \\<lbrakk>\\<And>x.\n              \\<lbrakk>x \\<in> sset ?xs; x \\<sqsubseteq> y\\<rbrakk>\n              \\<Longrightarrow> thesis;\n   y \\<in> sset ys; ?xs \\<sqsubseteq> ys; ?xs \\<noteq> \\<bottom>\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>?x \\<in> sset xs; ?x \\<sqsubseteq> y\\<rbrakk>\n  \\<Longrightarrow> thesis\n  y \\<in> sset (y :# ys)\n  xs \\<sqsubseteq> y :# ys\n  xs \\<noteq> \\<bottom>", "show ?case"], ["proof (prove)\nusing this:\n  y \\<noteq> \\<bottom>\n  ys \\<noteq> \\<bottom>\n  \\<lbrakk>\\<And>x.\n              \\<lbrakk>x \\<in> sset ?xs; x \\<sqsubseteq> y\\<rbrakk>\n              \\<Longrightarrow> thesis;\n   y \\<in> sset ys; ?xs \\<sqsubseteq> ys; ?xs \\<noteq> \\<bottom>\\<rbrakk>\n  \\<Longrightarrow> thesis\n  \\<lbrakk>?x \\<in> sset xs; ?x \\<sqsubseteq> y\\<rbrakk>\n  \\<Longrightarrow> thesis\n  y \\<in> sset (y :# ys)\n  xs \\<sqsubseteq> y :# ys\n  xs \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. thesis", "by (cases xs) auto"], ["proof (state)\nthis:\n  thesis\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> sset xs; x \\<sqsubseteq> y\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        y \\<in> sset \\<bottom>; xs \\<sqsubseteq> \\<bottom>;\n        xs \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> thesis\n 2. \\<And>xs.\n       \\<lbrakk>\\<And>x.\n                   \\<lbrakk>x \\<in> sset xs; x \\<sqsubseteq> y\\<rbrakk>\n                   \\<Longrightarrow> thesis;\n        y \\<in> sset [::]; xs \\<sqsubseteq> [::];\n        xs \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> thesis", "qed simp_all"], ["", "subsection\\<open> Some of the usual operations \\<close>"], ["", "text\\<open>\n\nA variety of functions on lists. Drawn from @{cite [cite_macro=citet]\n\"Bird:1987\"}, @{theory \\<open>HOL.List\\<close>} and\n@{theory \\<open>HOLCF-Prelude.Data_List\\<close>}. The definitions vary because,\nfor instance, the strictness of some of those in\n@{theory \\<open>HOLCF-Prelude.Data_List\\<close>} correspond neither to those in\nHaskell nor Bird's expectations (specifically \\<open>stails\\<close>,\n\\<open>inits\\<close>, \\<open>sscanl\\<close>).\n\n\\<close>"], ["", "fixrec snull :: \"[:'a:] \\<rightarrow> tr\" where\n  \"snull\\<cdot>[::] = TT\"\n| \"\\<lbrakk>x \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>\\<rbrakk> \\<Longrightarrow> snull\\<cdot>(x :# xs) = FF\""], ["", "lemma snull_strict[simp]: \"snull\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snull\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "lemma snull_bottom_iff[simp]: \"(snull\\<cdot>xs = \\<bottom>) \\<longleftrightarrow> (xs = \\<bottom>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (snull\\<cdot>xs = \\<bottom>) = (xs = \\<bottom>)", "by (cases xs) simp_all"], ["", "lemma snull_FF_conv: \"(snull\\<cdot>xxs = FF) \\<longleftrightarrow> (\\<exists>x xs. xxs \\<noteq> \\<bottom> \\<and> xxs = x :# xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (snull\\<cdot>xxs = FF) =\n    (\\<exists>x xs. xxs \\<noteq> \\<bottom> \\<and> xxs = x :# xs)", "by (cases xxs) simp_all"], ["", "lemma snull_TT_conv[simp]: \"(snull\\<cdot>xs = TT) \\<longleftrightarrow> (xs = [::])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (snull\\<cdot>xs = TT) = (xs = [::])", "by (cases xs) simp_all"], ["", "lemma snull_eq_snil: \"snull\\<cdot>xs = eq\\<cdot>xs\\<cdot>[::]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. snull\\<cdot>xs = eq\\<cdot>xs\\<cdot>[::]", "by (cases xs) simp_all"], ["", "fixrec smap :: \"('a \\<rightarrow> 'b) \\<rightarrow> [:'a:] \\<rightarrow> [:'b:]\" where\n  \"smap\\<cdot>f\\<cdot>[::] = [::]\"\n| \"\\<lbrakk>x \\<noteq>\\<bottom>; xs \\<noteq> \\<bottom>\\<rbrakk> \\<Longrightarrow> smap\\<cdot>f\\<cdot>(x :# xs) = f\\<cdot>x :# smap\\<cdot>f\\<cdot>xs\""], ["", "lemma smap_strict[simp]: \"smap\\<cdot>f\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap\\<cdot>f\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "lemma smap_bottom_iff[simp]: \"(smap\\<cdot>f\\<cdot>xs = \\<bottom>) \\<longleftrightarrow> (xs = \\<bottom> \\<or> (\\<exists>x\\<in>sset xs. f\\<cdot>x = \\<bottom>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (smap\\<cdot>f\\<cdot>xs = \\<bottom>) =\n    (xs = \\<bottom> \\<or> (\\<exists>x\\<in>sset xs. f\\<cdot>x = \\<bottom>))", "by (induct xs) simp_all"], ["", "lemma smap_is_snil_conv[simp]:\n  \"(smap\\<cdot>f\\<cdot>xs = [::]) \\<longleftrightarrow> (xs = [::])\"\n  \"( [::] = smap\\<cdot>f\\<cdot>xs) \\<longleftrightarrow> (xs = [::])\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (smap\\<cdot>f\\<cdot>xs = [::]) = (xs = [::]) &&&\n    ([::] = smap\\<cdot>f\\<cdot>xs) = (xs = [::])", "by (cases xs; simp)+"], ["", "lemma smap_strict_scons[simp]:\n  assumes \"f\\<cdot>\\<bottom> = \\<bottom>\"\n  shows \"smap\\<cdot>f\\<cdot>(x :# xs) = f\\<cdot>x :# smap\\<cdot>f\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap\\<cdot>f\\<cdot>(x :# xs) = f\\<cdot>x :# smap\\<cdot>f\\<cdot>xs", "using assms"], ["proof (prove)\nusing this:\n  f\\<cdot>\\<bottom> = \\<bottom>\n\ngoal (1 subgoal):\n 1. smap\\<cdot>f\\<cdot>(x :# xs) = f\\<cdot>x :# smap\\<cdot>f\\<cdot>xs", "by (cases \"x :# xs = \\<bottom>\"; fastforce)"], ["", "lemma smap_ID': \"smap\\<cdot>ID\\<cdot>xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap\\<cdot>ID\\<cdot>xs = xs", "by (induct xs) simp_all"], ["", "lemma smap_ID[simp]: \"smap\\<cdot>ID = ID\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap\\<cdot>ID = ID", "by (clarsimp simp: cfun_eq_iff smap_ID')"], ["", "lemma smap_cong:\n  assumes \"xs = xs'\"\n  assumes \"\\<And>x. x \\<in> sset xs \\<Longrightarrow> f\\<cdot>x = f'\\<cdot>x\"\n  shows \"smap\\<cdot>f\\<cdot>xs = smap\\<cdot>f'\\<cdot>xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap\\<cdot>f\\<cdot>xs = smap\\<cdot>f'\\<cdot>xs'", "using assms"], ["proof (prove)\nusing this:\n  xs = xs'\n  ?x \\<in> sset xs \\<Longrightarrow> f\\<cdot>?x = f'\\<cdot>?x\n\ngoal (1 subgoal):\n 1. smap\\<cdot>f\\<cdot>xs = smap\\<cdot>f'\\<cdot>xs'", "by (induct xs arbitrary: xs') auto"], ["", "lemma smap_smap'[simp]:\n  assumes \"f\\<cdot>\\<bottom> = \\<bottom>\"\n  shows \"smap\\<cdot>f\\<cdot>(smap\\<cdot>g\\<cdot>xs) = smap\\<cdot>(f oo g)\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap\\<cdot>f\\<cdot>(smap\\<cdot>g\\<cdot>xs) =\n    smap\\<cdot>(f oo g)\\<cdot>xs", "using assms"], ["proof (prove)\nusing this:\n  f\\<cdot>\\<bottom> = \\<bottom>\n\ngoal (1 subgoal):\n 1. smap\\<cdot>f\\<cdot>(smap\\<cdot>g\\<cdot>xs) =\n    smap\\<cdot>(f oo g)\\<cdot>xs", "by (induct xs) simp_all"], ["", "lemma smap_smap[simp]:\n  assumes \"f\\<cdot>\\<bottom> = \\<bottom>\"\n  shows \"smap\\<cdot>f oo smap\\<cdot>g = smap\\<cdot>(f oo g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap\\<cdot>f oo smap\\<cdot>g = smap\\<cdot>(f oo g)", "using assms"], ["proof (prove)\nusing this:\n  f\\<cdot>\\<bottom> = \\<bottom>\n\ngoal (1 subgoal):\n 1. smap\\<cdot>f oo smap\\<cdot>g = smap\\<cdot>(f oo g)", "by (clarsimp simp: cfun_eq_iff)"], ["", "lemma sset_smap[simp]:\n  assumes \"\\<And>x. x \\<in> sset xs \\<Longrightarrow> f\\<cdot>x \\<noteq> \\<bottom>\"\n  shows \"sset (smap\\<cdot>f\\<cdot>xs) = { f\\<cdot>x | x. x \\<in> sset xs }\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sset (smap\\<cdot>f\\<cdot>xs) = {f\\<cdot>x |x. x \\<in> sset xs}", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> sset xs \\<Longrightarrow> f\\<cdot>?x \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. sset (smap\\<cdot>f\\<cdot>xs) = {f\\<cdot>x |x. x \\<in> sset xs}", "by (induct xs) auto"], ["", "lemma shead_smap_distr:\n  assumes \"f\\<cdot>\\<bottom> = \\<bottom>\"\n  assumes \"\\<And>x. x\\<in>sset xs \\<Longrightarrow> f\\<cdot>x \\<noteq> \\<bottom>\"\n  shows \"shead\\<cdot>(smap\\<cdot>f\\<cdot>xs) = f\\<cdot>(shead\\<cdot>xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shead\\<cdot>(smap\\<cdot>f\\<cdot>xs) = f\\<cdot>(shead\\<cdot>xs)", "using assms"], ["proof (prove)\nusing this:\n  f\\<cdot>\\<bottom> = \\<bottom>\n  ?x \\<in> sset xs \\<Longrightarrow> f\\<cdot>?x \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. shead\\<cdot>(smap\\<cdot>f\\<cdot>xs) = f\\<cdot>(shead\\<cdot>xs)", "by (induct xs) simp_all"], ["", "fixrec sappend :: \"[:'a:] \\<rightarrow> [:'a:] \\<rightarrow> [:'a:]\" where\n  \"sappend\\<cdot>[::]\\<cdot>ys = ys\"\n| \"\\<lbrakk>x \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>\\<rbrakk> \\<Longrightarrow> sappend\\<cdot>(x :# xs)\\<cdot>ys = x :# sappend\\<cdot>xs\\<cdot>ys\""], ["", "abbreviation sappend_syn :: \"'a slist \\<Rightarrow> 'a slist \\<Rightarrow> 'a slist\" (infixr \":@\" 65) where\n  \"xs :@ ys \\<equiv> sappend\\<cdot>xs\\<cdot>ys\""], ["", "lemma sappend_strict[simp]: \"sappend\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sappend\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "lemma sappend_strict2[simp]: \"xs :@ \\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs :@ \\<bottom> = \\<bottom>", "by (induct xs) simp_all"], ["", "lemma sappend_bottom_iff[simp]: \"(xs :@ ys = \\<bottom>) \\<longleftrightarrow> (xs = \\<bottom> \\<or> ys = \\<bottom>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs :@ ys = \\<bottom>) = (xs = \\<bottom> \\<or> ys = \\<bottom>)", "by (induct xs) simp_all"], ["", "lemma sappend_scons[simp]: \"(x :# xs) :@ ys = x :# xs :@ ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x :# xs) :@ ys = x :# xs :@ ys", "by (cases \"x :# xs = \\<bottom>\"; fastforce)"], ["", "lemma sappend_assoc[simp]: \"(xs :@ ys) :@ zs = xs :@ (ys :@ zs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs :@ ys) :@ zs = xs :@ ys :@ zs", "by (induct xs) simp_all"], ["", "lemma sappend_snil_id_left[simp]: \"sappend\\<cdot>[::] = ID\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sappend\\<cdot>[::] = ID", "by (simp add: cfun_eq_iff)"], ["", "lemma sappend_snil_id_right[iff]: \"xs :@ [::] = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs :@ [::] = xs", "by (induct xs) simp_all"], ["", "lemma snil_append_iff[iff]: \"xs :@ ys = [::] \\<longleftrightarrow> xs = [::] \\<and> ys = [::]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs :@ ys = [::]) = (xs = [::] \\<and> ys = [::])", "by (induct xs) simp_all"], ["", "lemma smap_sappend[simp]: \"smap\\<cdot>f\\<cdot>(xs :@ ys) = smap\\<cdot>f\\<cdot>xs :@ smap\\<cdot>f\\<cdot>ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap\\<cdot>f\\<cdot>(xs :@ ys) =\n    smap\\<cdot>f\\<cdot>xs :@ smap\\<cdot>f\\<cdot>ys", "by (induct xs; cases \"ys = \\<bottom>\"; simp)"], ["", "lemma stail_sappend: \"stail\\<cdot>(xs :@ ys) = (case xs of [::] \\<Rightarrow> stail\\<cdot>ys | z :# zs \\<Rightarrow> zs :@ ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stail\\<cdot>(xs :@ ys) =\n    (case xs of [::] \\<Rightarrow> stail\\<cdot>ys\n     | z :# zs \\<Rightarrow> zs :@ ys)", "by (induct xs) simp_all"], ["", "lemma stail_append2[simp]: \"xs \\<noteq> [::] \\<Longrightarrow> stail\\<cdot>(xs :@ ys) = stail\\<cdot>xs :@ ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [::] \\<Longrightarrow>\n    stail\\<cdot>(xs :@ ys) = stail\\<cdot>xs :@ ys", "by (induct xs) simp_all"], ["", "lemma slist_case_snoc:\n  \"g\\<cdot>\\<bottom>\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow> slist_case\\<cdot>f\\<cdot>g\\<cdot>(xs :@ [:x:]) = g\\<cdot>(shead\\<cdot>(xs :@ [:x:]))\\<cdot>(stail\\<cdot>(xs :@ [:x:]))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. g\\<cdot>\\<bottom>\\<cdot>\\<bottom> = \\<bottom> \\<Longrightarrow>\n    slist_case\\<cdot>f\\<cdot>g\\<cdot>(xs :@ [:x:]) =\n    g\\<cdot>(shead\\<cdot>(xs :@ [:x:]))\\<cdot>(stail\\<cdot>(xs :@ [:x:]))", "by (cases \"x = \\<bottom>\"; cases xs; clarsimp)"], ["", "fixrec sall :: \"('a \\<rightarrow> tr) \\<rightarrow> [:'a:] \\<rightarrow> tr\" where\n  \"sall\\<cdot>p\\<cdot>[::] = TT\"\n| \"\\<lbrakk>x \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>\\<rbrakk> \\<Longrightarrow> sall\\<cdot>p\\<cdot>(x :# xs) = (p\\<cdot>x andalso sall\\<cdot>p\\<cdot>xs)\""], ["", "lemma sall_strict[simp]: \"sall\\<cdot>p\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sall\\<cdot>p\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "lemma sall_const_TT[simp]:\n  assumes \"xs \\<noteq> \\<bottom>\"\n  shows \"sall\\<cdot>(\\<Lambda> x. TT)\\<cdot>xs = TT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sall\\<cdot>(\\<Lambda> x. TT)\\<cdot>xs = TT", "using assms"], ["proof (prove)\nusing this:\n  xs \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. sall\\<cdot>(\\<Lambda> x. TT)\\<cdot>xs = TT", "by (induct xs) simp_all"], ["", "lemma sall_const_TT_conv[simp]: \"(sall\\<cdot>(\\<Lambda> x. TT)\\<cdot>xs = TT) \\<longleftrightarrow> (xs \\<noteq> \\<bottom>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sall\\<cdot>(\\<Lambda> x. TT)\\<cdot>xs = TT) = (xs \\<noteq> \\<bottom>)", "by auto"], ["", "lemma sall_TT[simp]: \"(sall\\<cdot>p\\<cdot>xs = TT) \\<longleftrightarrow> (xs \\<noteq> \\<bottom> \\<and> (\\<forall>x\\<in>sset xs. p\\<cdot>x = TT))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sall\\<cdot>p\\<cdot>xs = TT) =\n    (xs \\<noteq> \\<bottom> \\<and> (\\<forall>x\\<in>sset xs. p\\<cdot>x = TT))", "by (induct xs) simp_all"], ["", "fixrec sfilter :: \"('a \\<rightarrow> tr) \\<rightarrow> [:'a:] \\<rightarrow> [:'a:]\" where\n  \"sfilter\\<cdot>p\\<cdot>[::] = [::]\"\n| \"\\<lbrakk>x \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>\\<rbrakk> \\<Longrightarrow> sfilter\\<cdot>p\\<cdot>(x :# xs) = If p\\<cdot>x then x :# sfilter\\<cdot>p\\<cdot>xs else sfilter\\<cdot>p\\<cdot>xs\""], ["", "lemma sfilter_strict[simp]: \"sfilter\\<cdot>p\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sfilter\\<cdot>p\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "lemma sfilter_bottom_iff[simp]: \"(sfilter\\<cdot>p\\<cdot>xs = \\<bottom>) \\<longleftrightarrow> (xs = \\<bottom> \\<or> (\\<exists>x\\<in>sset xs. p\\<cdot>x = \\<bottom>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sfilter\\<cdot>p\\<cdot>xs = \\<bottom>) =\n    (xs = \\<bottom> \\<or> (\\<exists>x\\<in>sset xs. p\\<cdot>x = \\<bottom>))", "by (induct xs) (use trE in auto)"], ["", "lemma sset_sfilter[simp]:\n  assumes \"\\<And>x. x \\<in> sset xs \\<Longrightarrow> p\\<cdot>x \\<noteq> \\<bottom>\"\n  shows \"sset (sfilter\\<cdot>p\\<cdot>xs) = {x |x. x \\<in> sset xs \\<and> p\\<cdot>x = TT}\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sset (sfilter\\<cdot>p\\<cdot>xs) =\n    {x |x. x \\<in> sset xs \\<and> p\\<cdot>x = TT}", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<in> sset xs \\<Longrightarrow> p\\<cdot>?x \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. sset (sfilter\\<cdot>p\\<cdot>xs) =\n    {x |x. x \\<in> sset xs \\<and> p\\<cdot>x = TT}", "by (induct xs) (fastforce simp: If2_def[symmetric] split: If2_splits)+"], ["", "lemma sfilter_strict_scons[simp]:\n  assumes \"p\\<cdot>\\<bottom> = \\<bottom>\"\n  shows \"sfilter\\<cdot>p\\<cdot>(x :# xs) = If p\\<cdot>x then x :# sfilter\\<cdot>p\\<cdot>xs else sfilter\\<cdot>p\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sfilter\\<cdot>p\\<cdot>(x :# xs) =\n    If p\\<cdot>x then x :# sfilter\\<cdot>p\\<cdot>xs\n    else sfilter\\<cdot>p\\<cdot>xs", "using assms"], ["proof (prove)\nusing this:\n  p\\<cdot>\\<bottom> = \\<bottom>\n\ngoal (1 subgoal):\n 1. sfilter\\<cdot>p\\<cdot>(x :# xs) =\n    If p\\<cdot>x then x :# sfilter\\<cdot>p\\<cdot>xs\n    else sfilter\\<cdot>p\\<cdot>xs", "by (cases \"x = \\<bottom>\"; cases \"xs = \\<bottom>\"; simp)"], ["", "lemma sfilter_scons_let:\n  assumes \"p\\<cdot>\\<bottom> = \\<bottom>\"\n  shows \"sfilter\\<cdot>p\\<cdot>(x :# xs) = (let xs' = sfilter\\<cdot>p\\<cdot>xs in If p\\<cdot>x then x :# xs' else xs')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sfilter\\<cdot>p\\<cdot>(x :# xs) =\n    (let xs' = sfilter\\<cdot>p\\<cdot>xs\n     in If p\\<cdot>x then x :# xs' else xs')", "unfolding Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. sfilter\\<cdot>p\\<cdot>(x :# xs) =\n    If p\\<cdot>x then x :# sfilter\\<cdot>p\\<cdot>xs\n    else sfilter\\<cdot>p\\<cdot>xs", "using assms"], ["proof (prove)\nusing this:\n  p\\<cdot>\\<bottom> = \\<bottom>\n\ngoal (1 subgoal):\n 1. sfilter\\<cdot>p\\<cdot>(x :# xs) =\n    If p\\<cdot>x then x :# sfilter\\<cdot>p\\<cdot>xs\n    else sfilter\\<cdot>p\\<cdot>xs", "by simp"], ["", "lemma sfilter_sappend[simp]: \"sfilter\\<cdot>p\\<cdot>(xs :@ ys) = sfilter\\<cdot>p\\<cdot>xs :@ sfilter\\<cdot>p\\<cdot>ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sfilter\\<cdot>p\\<cdot>(xs :@ ys) =\n    sfilter\\<cdot>p\\<cdot>xs :@ sfilter\\<cdot>p\\<cdot>ys", "by (cases \"ys\"; clarsimp) (induct xs; fastforce simp: If2_def[symmetric] split: If2_splits)"], ["", "lemma sfilter_const_FF[simp]:\n  assumes \"xs \\<noteq> \\<bottom>\"\n  shows \"sfilter\\<cdot>(\\<Lambda> x. FF)\\<cdot>xs = [::]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sfilter\\<cdot>(\\<Lambda> x. FF)\\<cdot>xs = [::]", "using assms"], ["proof (prove)\nusing this:\n  xs \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. sfilter\\<cdot>(\\<Lambda> x. FF)\\<cdot>xs = [::]", "by (induct xs) simp_all"], ["", "lemma sfilter_const_FF_conv[simp]: \"(sfilter\\<cdot>(\\<Lambda> x. FF)\\<cdot>xs = [::]) \\<longleftrightarrow> (xs \\<noteq> \\<bottom>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sfilter\\<cdot>(\\<Lambda> x. FF)\\<cdot>xs = [::]) =\n    (xs \\<noteq> \\<bottom>)", "by auto"], ["", "lemma sfilter_const_TT[simp]: \"sfilter\\<cdot>(\\<Lambda> x. TT)\\<cdot>xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sfilter\\<cdot>(\\<Lambda> x. TT)\\<cdot>xs = xs", "by (induct xs) simp_all"], ["", "lemma sfilter_cong:\n  assumes \"xs = xs'\"\n  assumes \"\\<And>x. x \\<in> sset xs \\<Longrightarrow> p\\<cdot>x = p'\\<cdot>x\"\n  shows \"sfilter\\<cdot>p\\<cdot>xs = sfilter\\<cdot>p'\\<cdot>xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sfilter\\<cdot>p\\<cdot>xs = sfilter\\<cdot>p'\\<cdot>xs'", "using assms"], ["proof (prove)\nusing this:\n  xs = xs'\n  ?x \\<in> sset xs \\<Longrightarrow> p\\<cdot>?x = p'\\<cdot>?x\n\ngoal (1 subgoal):\n 1. sfilter\\<cdot>p\\<cdot>xs = sfilter\\<cdot>p'\\<cdot>xs'", "by (induct xs arbitrary: xs') auto"], ["", "lemma sfilter_snil_conv[simp]: \"sfilter\\<cdot>p\\<cdot>xs = [::] \\<longleftrightarrow> sall\\<cdot>(neg oo p)\\<cdot>xs = TT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sfilter\\<cdot>p\\<cdot>xs = [::]) =\n    (sall\\<cdot>(neg oo p)\\<cdot>xs = TT)", "by (induct xs; force simp: If2_def[symmetric] split: If2_splits)"], ["", "lemma sfilter_sfilter': \"sfilter\\<cdot>p\\<cdot>(sfilter\\<cdot>q\\<cdot>xs) = sfilter\\<cdot>(\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sfilter\\<cdot>p\\<cdot>(sfilter\\<cdot>q\\<cdot>xs) =\n    sfilter\\<cdot>(\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)\\<cdot>xs", "proof(induct xs)"], ["proof (state)\ngoal (3 subgoals):\n 1. sfilter\\<cdot>p\\<cdot>(sfilter\\<cdot>q\\<cdot>\\<bottom>) =\n    sfilter\\<cdot>(\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)\\<cdot>\\<bottom>\n 2. sfilter\\<cdot>p\\<cdot>(sfilter\\<cdot>q\\<cdot>[::]) =\n    sfilter\\<cdot>(\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)\\<cdot>[::]\n 3. \\<And>a xs.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        sfilter\\<cdot>p\\<cdot>(sfilter\\<cdot>q\\<cdot>xs) =\n        sfilter\\<cdot>(\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)\\<cdot>\n        xs\\<rbrakk>\n       \\<Longrightarrow> sfilter\\<cdot>p\\<cdot>\n                         (sfilter\\<cdot>q\\<cdot>(a :# xs)) =\n                         sfilter\\<cdot>\n                         (\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)\\<cdot>\n                         (a :# xs)", "case (scons x xs)"], ["proof (state)\nthis:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  sfilter\\<cdot>p\\<cdot>(sfilter\\<cdot>q\\<cdot>xs) =\n  sfilter\\<cdot>(\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)\\<cdot>xs\n\ngoal (3 subgoals):\n 1. sfilter\\<cdot>p\\<cdot>(sfilter\\<cdot>q\\<cdot>\\<bottom>) =\n    sfilter\\<cdot>(\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)\\<cdot>\\<bottom>\n 2. sfilter\\<cdot>p\\<cdot>(sfilter\\<cdot>q\\<cdot>[::]) =\n    sfilter\\<cdot>(\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)\\<cdot>[::]\n 3. \\<And>a xs.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        sfilter\\<cdot>p\\<cdot>(sfilter\\<cdot>q\\<cdot>xs) =\n        sfilter\\<cdot>(\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)\\<cdot>\n        xs\\<rbrakk>\n       \\<Longrightarrow> sfilter\\<cdot>p\\<cdot>\n                         (sfilter\\<cdot>q\\<cdot>(a :# xs)) =\n                         sfilter\\<cdot>\n                         (\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)\\<cdot>\n                         (a :# xs)", "from scons(1, 2)"], ["proof (chain)\npicking this:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>", "show ?case"], ["proof (prove)\nusing this:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. sfilter\\<cdot>p\\<cdot>(sfilter\\<cdot>q\\<cdot>(x :# xs)) =\n    sfilter\\<cdot>(\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)\\<cdot>(x :# xs)", "by (cases \"sfilter\\<cdot>q\\<cdot>xs = \\<bottom>\")\n       (simp_all add: If_distr If_andalso scons(3)[symmetric] del: sfilter_bottom_iff)"], ["proof (state)\nthis:\n  sfilter\\<cdot>p\\<cdot>(sfilter\\<cdot>q\\<cdot>(x :# xs)) =\n  sfilter\\<cdot>(\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)\\<cdot>(x :# xs)\n\ngoal (2 subgoals):\n 1. sfilter\\<cdot>p\\<cdot>(sfilter\\<cdot>q\\<cdot>\\<bottom>) =\n    sfilter\\<cdot>(\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)\\<cdot>\\<bottom>\n 2. sfilter\\<cdot>p\\<cdot>(sfilter\\<cdot>q\\<cdot>[::]) =\n    sfilter\\<cdot>(\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)\\<cdot>[::]", "qed simp_all"], ["", "lemma sfilter_sfilter: \"sfilter\\<cdot>p oo sfilter\\<cdot>q = sfilter\\<cdot>(\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sfilter\\<cdot>p oo sfilter\\<cdot>q =\n    sfilter\\<cdot>(\\<Lambda> x. q\\<cdot>x andalso p\\<cdot>x)", "by (clarsimp simp: cfun_eq_iff sfilter_sfilter')"], ["", "lemma sfilter_smap':\n  assumes \"p\\<cdot>\\<bottom> = \\<bottom>\"\n  shows \"sfilter\\<cdot>p\\<cdot>(smap\\<cdot>f\\<cdot>xs) = smap\\<cdot>f\\<cdot>(sfilter\\<cdot>(p oo f)\\<cdot>xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sfilter\\<cdot>p\\<cdot>(smap\\<cdot>f\\<cdot>xs) =\n    smap\\<cdot>f\\<cdot>(sfilter\\<cdot>(p oo f)\\<cdot>xs)", "using assms"], ["proof (prove)\nusing this:\n  p\\<cdot>\\<bottom> = \\<bottom>\n\ngoal (1 subgoal):\n 1. sfilter\\<cdot>p\\<cdot>(smap\\<cdot>f\\<cdot>xs) =\n    smap\\<cdot>f\\<cdot>(sfilter\\<cdot>(p oo f)\\<cdot>xs)", "by (induct xs; simp add: If2_def[symmetric] split: If2_splits) (metis slist.con_rews(2) smap.simps(2) smap_strict)"], ["", "lemma sfilter_smap:\n  assumes \"p\\<cdot>\\<bottom> = \\<bottom>\"\n  shows \"sfilter\\<cdot>p oo smap\\<cdot>f = smap\\<cdot>f oo sfilter\\<cdot>(p oo f)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sfilter\\<cdot>p oo smap\\<cdot>f = smap\\<cdot>f oo sfilter\\<cdot>(p oo f)", "using assms"], ["proof (prove)\nusing this:\n  p\\<cdot>\\<bottom> = \\<bottom>\n\ngoal (1 subgoal):\n 1. sfilter\\<cdot>p oo smap\\<cdot>f = smap\\<cdot>f oo sfilter\\<cdot>(p oo f)", "by (clarsimp simp: cfun_eq_iff sfilter_smap')"], ["", "fixrec sfoldl :: \"('a::pcpo \\<rightarrow> 'b::domain \\<rightarrow> 'a) \\<rightarrow> 'a \\<rightarrow> [:'b:] \\<rightarrow> 'a\" where\n  \"sfoldl\\<cdot>f\\<cdot>z\\<cdot>[::] = z\"\n| \"\\<lbrakk>x \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>\\<rbrakk> \\<Longrightarrow> sfoldl\\<cdot>f\\<cdot>z\\<cdot>(x :# xs) = sfoldl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>x)\\<cdot>xs\""], ["", "lemma sfoldl_strict[simp]: \"sfoldl\\<cdot>f\\<cdot>z\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sfoldl\\<cdot>f\\<cdot>z\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "lemma sfoldl_strict_f[simp]:\n  assumes \"f\\<cdot>\\<bottom> = \\<bottom>\"\n  shows \"sfoldl\\<cdot>f\\<cdot>\\<bottom>\\<cdot>xs = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sfoldl\\<cdot>f\\<cdot>\\<bottom>\\<cdot>xs = \\<bottom>", "using assms"], ["proof (prove)\nusing this:\n  f\\<cdot>\\<bottom> = \\<bottom>\n\ngoal (1 subgoal):\n 1. sfoldl\\<cdot>f\\<cdot>\\<bottom>\\<cdot>xs = \\<bottom>", "by (induct xs) simp_all"], ["", "lemma sfoldl_cong:\n  assumes \"xs = xs'\"\n  assumes \"z = z'\"\n  assumes \"\\<And>x z. x \\<in> sset xs \\<Longrightarrow> f\\<cdot>z\\<cdot>x = f'\\<cdot>z\\<cdot>x\"\n  shows \"sfoldl\\<cdot>f\\<cdot>z\\<cdot>xs = sfoldl\\<cdot>f'\\<cdot>z'\\<cdot>xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sfoldl\\<cdot>f\\<cdot>z\\<cdot>xs = sfoldl\\<cdot>f'\\<cdot>z'\\<cdot>xs'", "using assms"], ["proof (prove)\nusing this:\n  xs = xs'\n  z = z'\n  ?x \\<in> sset xs \\<Longrightarrow>\n  f\\<cdot>?z\\<cdot>?x = f'\\<cdot>?z\\<cdot>?x\n\ngoal (1 subgoal):\n 1. sfoldl\\<cdot>f\\<cdot>z\\<cdot>xs = sfoldl\\<cdot>f'\\<cdot>z'\\<cdot>xs'", "by (induct xs arbitrary: xs' z z') auto"], ["", "lemma sfoldl_sappend[simp]:\n  assumes \"f\\<cdot>\\<bottom> = \\<bottom>\"\n  shows \"sfoldl\\<cdot>f\\<cdot>z\\<cdot>(xs :@ ys) = sfoldl\\<cdot>f\\<cdot>(sfoldl\\<cdot>f\\<cdot>z\\<cdot>xs)\\<cdot>ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sfoldl\\<cdot>f\\<cdot>z\\<cdot>(xs :@ ys) =\n    sfoldl\\<cdot>f\\<cdot>(sfoldl\\<cdot>f\\<cdot>z\\<cdot>xs)\\<cdot>ys", "using assms"], ["proof (prove)\nusing this:\n  f\\<cdot>\\<bottom> = \\<bottom>\n\ngoal (1 subgoal):\n 1. sfoldl\\<cdot>f\\<cdot>z\\<cdot>(xs :@ ys) =\n    sfoldl\\<cdot>f\\<cdot>(sfoldl\\<cdot>f\\<cdot>z\\<cdot>xs)\\<cdot>ys", "by (cases \"ys = \\<bottom>\", force) (induct xs arbitrary: z; simp)"], ["", "fixrec sfoldr :: \"('b \\<rightarrow> 'a::pcpo \\<rightarrow> 'a) \\<rightarrow> 'a \\<rightarrow> [:'b:] \\<rightarrow> 'a\" where\n  \"sfoldr\\<cdot>f\\<cdot>z\\<cdot>[::] = z\"\n| \"\\<lbrakk>x \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>\\<rbrakk> \\<Longrightarrow> sfoldr\\<cdot>f\\<cdot>z\\<cdot>(x :# xs) = f\\<cdot>x\\<cdot>(sfoldr\\<cdot>f\\<cdot>z\\<cdot>xs)\""], ["", "lemma sfoldr_strict[simp]: \"sfoldr\\<cdot>f\\<cdot>z\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sfoldr\\<cdot>f\\<cdot>z\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "fixrec sconcat :: \"[:[:'a:]:] \\<rightarrow> [:'a:]\" where\n  \"sconcat\\<cdot>[::] = [::]\"\n| \"\\<lbrakk>x \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>\\<rbrakk> \\<Longrightarrow> sconcat\\<cdot>(x :# xs) = x :@ sconcat\\<cdot>xs\""], ["", "lemma sconcat_strict[simp]: \"sconcat\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sconcat\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "lemma sconcat_scons[simp]:\n  shows \"sconcat\\<cdot>(x :# xs) = x :@ sconcat\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sconcat\\<cdot>(x :# xs) = x :@ sconcat\\<cdot>xs", "by (cases \"x = \\<bottom>\", force) (induct xs; fastforce)"], ["", "lemma sconcat_sfoldl_aux: \"sfoldl\\<cdot>sappend\\<cdot>z\\<cdot>xs = z :@ sconcat\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sfoldl\\<cdot>sappend\\<cdot>z\\<cdot>xs = z :@ sconcat\\<cdot>xs", "by (induct xs arbitrary: z) simp_all"], ["", "lemma sconcat_sfoldl: \"sconcat = sfoldl\\<cdot>sappend\\<cdot>[::]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sconcat = sfoldl\\<cdot>sappend\\<cdot>[::]", "by (clarsimp simp: cfun_eq_iff sconcat_sfoldl_aux)"], ["", "lemma sconcat_sappend[simp]: \"sconcat\\<cdot>(xs :@ ys) = sconcat\\<cdot>xs :@ sconcat\\<cdot>ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sconcat\\<cdot>(xs :@ ys) = sconcat\\<cdot>xs :@ sconcat\\<cdot>ys", "by (induct xs) simp_all"], ["", "fixrec slength :: \"[:'a:] \\<rightarrow> Integer\"\nwhere\n  \"slength\\<cdot>[::] = 0\"\n| \"\\<lbrakk>x \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>\\<rbrakk> \\<Longrightarrow> slength\\<cdot>(x :# xs) = slength\\<cdot>xs + 1\""], ["", "lemma slength_strict[simp]: \"slength\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slength\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "lemma slength_bottom_iff[simp]: \"(slength\\<cdot>xs = \\<bottom>) \\<longleftrightarrow> (xs = \\<bottom>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (slength\\<cdot>xs = \\<bottom>) = (xs = \\<bottom>)", "by (induct xs) force+"], ["", "lemma slength_ge_0: \"slength\\<cdot>xs = MkI\\<cdot>n \\<Longrightarrow> n \\<ge> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slength\\<cdot>xs = MkI\\<cdot>n \\<Longrightarrow> 0 \\<le> n", "by (induct xs arbitrary: n) (simp add: one_Integer_def plus_eq_MkI_conv; force)+"], ["", "lemma slengthE:\n  shows \"\\<lbrakk>xs \\<noteq> \\<bottom>; \\<And>n. \\<lbrakk>slength\\<cdot>xs = MkI\\<cdot>n; 0 \\<le> n\\<rbrakk> \\<Longrightarrow> Q\\<rbrakk> \\<Longrightarrow> Q\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>xs \\<noteq> \\<bottom>;\n     \\<And>n.\n        \\<lbrakk>slength\\<cdot>xs = MkI\\<cdot>n; 0 \\<le> n\\<rbrakk>\n        \\<Longrightarrow> Q\\<rbrakk>\n    \\<Longrightarrow> Q", "by (meson Integer.exhaust slength_bottom_iff slength_ge_0)"], ["", "lemma slength_0_conv[simp]:\n  \"(slength\\<cdot>xs = 0) \\<longleftrightarrow> (xs = [::])\"\n  \"(slength\\<cdot>xs = MkI\\<cdot>0) \\<longleftrightarrow> (xs = [::])\"\n  \"eq\\<cdot>0\\<cdot>(slength\\<cdot>xs) = snull\\<cdot>xs\"\n  \"eq\\<cdot>(slength\\<cdot>xs)\\<cdot>0 = snull\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ((slength\\<cdot>xs = 0) = (xs = [::]) &&&\n     (slength\\<cdot>xs = MkI\\<cdot>0) = (xs = [::])) &&&\n    eq\\<cdot>0\\<cdot>(slength\\<cdot>xs) = snull\\<cdot>xs &&&\n    eq\\<cdot>(slength\\<cdot>xs)\\<cdot>0 = snull\\<cdot>xs", "by (induct xs) (auto simp: one_Integer_def elim: slengthE)"], ["", "lemma le_slength_0[simp]: \"(le\\<cdot>0\\<cdot>(slength\\<cdot>xs) = TT) \\<longleftrightarrow> (xs \\<noteq> \\<bottom>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (le\\<cdot>0\\<cdot>(slength\\<cdot>xs) = TT) = (xs \\<noteq> \\<bottom>)", "by (cases \"slength\\<cdot>xs\") (auto simp: slength_ge_0 zero_Integer_def)"], ["", "lemma lt_slength_0[simp]:\n  \"xs \\<noteq> \\<bottom> \\<Longrightarrow> lt\\<cdot>(slength\\<cdot>xs)\\<cdot>0 = FF\"\n  \"xs \\<noteq> \\<bottom> \\<Longrightarrow> lt\\<cdot>(slength\\<cdot>xs)\\<cdot>(slength\\<cdot>xs + 1) = TT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs \\<noteq> \\<bottom> \\<Longrightarrow>\n     lt\\<cdot>(slength\\<cdot>xs)\\<cdot>0 = FF) &&&\n    (xs \\<noteq> \\<bottom> \\<Longrightarrow>\n     lt\\<cdot>(slength\\<cdot>xs)\\<cdot>(slength\\<cdot>xs + 1) = TT)", "unfolding zero_Integer_def one_Integer_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs \\<noteq> \\<bottom> \\<Longrightarrow>\n     lt\\<cdot>(slength\\<cdot>xs)\\<cdot>(MkI\\<cdot>0) = FF) &&&\n    (xs \\<noteq> \\<bottom> \\<Longrightarrow>\n     lt\\<cdot>(slength\\<cdot>xs)\\<cdot>(slength\\<cdot>xs + MkI\\<cdot>1) =\n     TT)", "by (auto elim: slengthE)"], ["", "lemma slength_smap[simp]:\n  assumes \"\\<And>x. x \\<noteq> \\<bottom> \\<Longrightarrow> f\\<cdot>x \\<noteq> \\<bottom>\"\n  shows \"slength\\<cdot>(smap\\<cdot>f\\<cdot>xs) = slength\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slength\\<cdot>(smap\\<cdot>f\\<cdot>xs) = slength\\<cdot>xs", "using assms"], ["proof (prove)\nusing this:\n  ?x \\<noteq> \\<bottom> \\<Longrightarrow> f\\<cdot>?x \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. slength\\<cdot>(smap\\<cdot>f\\<cdot>xs) = slength\\<cdot>xs", "by (induct xs) simp_all"], ["", "lemma slength_sappend[simp]: \"slength\\<cdot>(xs :@ ys) = slength\\<cdot>xs + slength\\<cdot>ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slength\\<cdot>(xs :@ ys) = slength\\<cdot>xs + slength\\<cdot>ys", "by (cases \"ys = \\<bottom>\", force) (induct xs; force simp: ac_simps)"], ["", "lemma slength_sfoldl_aux: \"sfoldl\\<cdot>(\\<Lambda> i _. i + 1)\\<cdot>z\\<cdot>xs = z + slength\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sfoldl\\<cdot>(\\<Lambda> i uu_. i + 1)\\<cdot>z\\<cdot>xs =\n    z + slength\\<cdot>xs", "by (induct xs arbitrary: z) (simp_all add: ac_simps)"], ["", "lemma slength_sfoldl: \"slength = sfoldl\\<cdot>(\\<Lambda> i _. i + 1)\\<cdot>0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slength = sfoldl\\<cdot>(\\<Lambda> i uu_. i + 1)\\<cdot>0", "by (clarsimp simp: cfun_eq_iff slength_sfoldl_aux)"], ["", "lemma le_slength_plus:\n  assumes \"xs \\<noteq> \\<bottom>\"\n  assumes \"n \\<noteq> \\<bottom>\"\n  shows \"le\\<cdot>n\\<cdot>(slength\\<cdot>xs + n) = TT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le\\<cdot>n\\<cdot>(slength\\<cdot>xs + n) = TT", "using assms"], ["proof (prove)\nusing this:\n  xs \\<noteq> \\<bottom>\n  n \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. le\\<cdot>n\\<cdot>(slength\\<cdot>xs + n) = TT", "by (cases n; force elim: slengthE)"], ["", "fixrec srev :: \"[:'a:] \\<rightarrow> [:'a:]\" where\n  \"srev\\<cdot>[::] = [::]\"\n| \"\\<lbrakk>x \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>\\<rbrakk> \\<Longrightarrow> srev\\<cdot>(x :# xs) = srev\\<cdot>xs :@ [:x:]\""], ["", "lemma srev_strict[simp]: \"srev\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. srev\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "lemma srev_bottom_iff[simp]: \"(srev\\<cdot>xs = \\<bottom>) \\<longleftrightarrow> (xs = \\<bottom>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (srev\\<cdot>xs = \\<bottom>) = (xs = \\<bottom>)", "by (induct xs) simp_all"], ["", "lemma srev_scons[simp]: \"srev\\<cdot>(x :# xs) = srev\\<cdot>xs :@ [:x:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. srev\\<cdot>(x :# xs) = srev\\<cdot>xs :@ [:x:]", "by (cases \"x = \\<bottom>\", clarsimp) (induct xs; force)"], ["", "lemma srev_sappend[simp]: \"srev\\<cdot>(xs :@ ys) = srev\\<cdot>ys :@ srev\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. srev\\<cdot>(xs :@ ys) = srev\\<cdot>ys :@ srev\\<cdot>xs", "by (induct xs) simp_all"], ["", "lemma srev_srev_ident[simp]: \"srev\\<cdot>(srev\\<cdot>xs) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. srev\\<cdot>(srev\\<cdot>xs) = xs", "by (induct xs) auto"], ["", "lemma srev_cases[case_names bottom snil ssnoc]:\n  assumes \"xs = \\<bottom> \\<Longrightarrow> P\"\n  assumes \"xs = [::] \\<Longrightarrow> P\"\n  assumes \"\\<And>y ys. \\<lbrakk>y \\<noteq> \\<bottom>; ys \\<noteq> \\<bottom>; xs = ys :@ [:y:]\\<rbrakk> \\<Longrightarrow> P\"\n  shows \"P\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P", "using assms"], ["proof (prove)\nusing this:\n  xs = \\<bottom> \\<Longrightarrow> P\n  xs = [::] \\<Longrightarrow> P\n  \\<lbrakk>?y \\<noteq> \\<bottom>; ?ys \\<noteq> \\<bottom>;\n   xs = ?ys :@ [:?y:]\\<rbrakk>\n  \\<Longrightarrow> P\n\ngoal (1 subgoal):\n 1. P", "by (metis slist.exhaust srev.simps(1) srev_scons srev_srev_ident srev_strict)"], ["", "lemma srev_induct[case_names bottom snil ssnoc]:\n  assumes \"P \\<bottom>\"\n  assumes \"P [::]\"\n  assumes \"\\<And>x xs. \\<lbrakk>x \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>; P xs\\<rbrakk> \\<Longrightarrow> P (xs :@ [:x:])\"\n  shows \"P xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P xs", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. P xs", "have \"P (srev\\<cdot>(srev\\<cdot>xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. P (srev\\<cdot>(srev\\<cdot>xs))", "by (rule slist.induct[where x=\"srev\\<cdot>xs\"]; simp add: assms)"], ["proof (state)\nthis:\n  P (srev\\<cdot>(srev\\<cdot>xs))\n\ngoal (1 subgoal):\n 1. P xs", "then"], ["proof (chain)\npicking this:\n  P (srev\\<cdot>(srev\\<cdot>xs))", "show ?thesis"], ["proof (prove)\nusing this:\n  P (srev\\<cdot>(srev\\<cdot>xs))\n\ngoal (1 subgoal):\n 1. P xs", "by simp"], ["proof (state)\nthis:\n  P xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sfoldr_conv_sfoldl:\n  assumes \"\\<And>x. f\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\" \\<comment>\\<open>\\<open>f\\<close> must be strict in the accumulator.\\<close>\n  shows \"sfoldr\\<cdot>f\\<cdot>z\\<cdot>xs = sfoldl\\<cdot>(\\<Lambda> acc x. f\\<cdot>x\\<cdot>acc)\\<cdot>z\\<cdot>(srev\\<cdot>xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sfoldr\\<cdot>f\\<cdot>z\\<cdot>xs =\n    sfoldl\\<cdot>(\\<Lambda> acc x. f\\<cdot>x\\<cdot>acc)\\<cdot>z\\<cdot>\n    (srev\\<cdot>xs)", "using assms"], ["proof (prove)\nusing this:\n  f\\<cdot>?x\\<cdot>\\<bottom> = \\<bottom>\n\ngoal (1 subgoal):\n 1. sfoldr\\<cdot>f\\<cdot>z\\<cdot>xs =\n    sfoldl\\<cdot>(\\<Lambda> acc x. f\\<cdot>x\\<cdot>acc)\\<cdot>z\\<cdot>\n    (srev\\<cdot>xs)", "by (induct xs arbitrary: z) simp_all"], ["", "fixrec stake :: \"Integer \\<rightarrow> [:'a:] \\<rightarrow> [:'a:]\" where \\<comment>\\<open> Note: strict in both parameters. \\<close>\n  \"stake\\<cdot>\\<bottom>\\<cdot>\\<bottom> = \\<bottom>\"\n| \"i \\<noteq> \\<bottom> \\<Longrightarrow> stake\\<cdot>i\\<cdot>[::] = [::]\"\n| \"\\<lbrakk>x \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>\\<rbrakk> \\<Longrightarrow> stake\\<cdot>i\\<cdot>(x :# xs) = If le\\<cdot>i\\<cdot>0 then [::] else x :# stake\\<cdot>(i - 1)\\<cdot>xs\""], ["", "lemma stake_strict[simp]:\n  \"stake\\<cdot>\\<bottom> = \\<bottom>\"\n  \"stake\\<cdot>i\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stake\\<cdot>\\<bottom> = \\<bottom> &&&\n    stake\\<cdot>i\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp+"], ["", "lemma stake_bottom_iff[simp]: \"(stake\\<cdot>i\\<cdot>xs = \\<bottom>) \\<longleftrightarrow> (i = \\<bottom> \\<or> xs = \\<bottom>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (stake\\<cdot>i\\<cdot>xs = \\<bottom>) =\n    (i = \\<bottom> \\<or> xs = \\<bottom>)", "by (induct xs arbitrary: i; clarsimp; case_tac i; clarsimp)"], ["", "lemma stake_0[simp]:\n  \"xs \\<noteq> \\<bottom> \\<Longrightarrow> stake\\<cdot>0\\<cdot>xs = [::]\"\n  \"xs \\<noteq> \\<bottom> \\<Longrightarrow> stake\\<cdot>(MkI\\<cdot>0)\\<cdot>xs = [::]\"\n  \"stake\\<cdot>0\\<cdot>xs \\<sqsubseteq> [::]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs \\<noteq> \\<bottom> \\<Longrightarrow>\n     stake\\<cdot>0\\<cdot>xs = [::]) &&&\n    (xs \\<noteq> \\<bottom> \\<Longrightarrow>\n     stake\\<cdot>(MkI\\<cdot>0)\\<cdot>xs = [::]) &&&\n    stake\\<cdot>0\\<cdot>xs \\<sqsubseteq> [::]", "by (cases xs; simp add: zero_Integer_def)+"], ["", "lemma stake_scons[simp]: \"le\\<cdot>1\\<cdot>i = TT \\<Longrightarrow> stake\\<cdot>i\\<cdot>(x :# xs) = x :# stake\\<cdot>(i - 1)\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le\\<cdot>1\\<cdot>i = TT \\<Longrightarrow>\n    stake\\<cdot>i\\<cdot>(x :# xs) = x :# stake\\<cdot>(i - 1)\\<cdot>xs", "by (cases i; cases \"x = \\<bottom>\"; cases \"xs = \\<bottom>\";\n    simp add: zero_Integer_def one_Integer_def split: if_splits)"], ["", "lemma take_MkI_scons[simp]:\n  \"0 < n \\<Longrightarrow> stake\\<cdot>(MkI\\<cdot>n)\\<cdot>(x :# xs) = x :# stake\\<cdot>(MkI\\<cdot>(n - 1))\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. 0 < n \\<Longrightarrow>\n    stake\\<cdot>(MkI\\<cdot>n)\\<cdot>(x :# xs) =\n    x :# stake\\<cdot>(MkI\\<cdot>(n - 1))\\<cdot>xs", "by (cases \"x = \\<bottom>\"; cases \"xs = \\<bottom>\"; simp add: zero_Integer_def one_Integer_def)"], ["", "lemma stake_numeral_scons[simp]:\n  \"xs \\<noteq> \\<bottom> \\<Longrightarrow> stake\\<cdot>1\\<cdot>(x :# xs) = [:x:]\"\n  \"stake\\<cdot>(numeral (Num.Bit0 k))\\<cdot>(x :# xs) = x :# stake\\<cdot>(numeral (Num.BitM k))\\<cdot>xs\"\n  \"stake\\<cdot>(numeral (Num.Bit1 k))\\<cdot>(x :# xs) = x :# stake\\<cdot>(numeral (Num.Bit0 k))\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs \\<noteq> \\<bottom> \\<Longrightarrow>\n     stake\\<cdot>1\\<cdot>(x :# xs) = [:x:]) &&&\n    stake\\<cdot>(numeral (num.Bit0 k))\\<cdot>(x :# xs) =\n    x :# stake\\<cdot>(numeral (Num.BitM k))\\<cdot>xs &&&\n    stake\\<cdot>(numeral (num.Bit1 k))\\<cdot>(x :# xs) =\n    x :# stake\\<cdot>(numeral (num.Bit0 k))\\<cdot>xs", "by (cases \"x = \\<bottom>\"; cases xs; simp add: zero_Integer_def one_Integer_def numeral_Integer_eq)+"], ["", "lemma stake_all:\n  assumes \"le\\<cdot>(slength\\<cdot>xs)\\<cdot>i = TT\"\n  shows \"stake\\<cdot>i\\<cdot>xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stake\\<cdot>i\\<cdot>xs = xs", "using assms"], ["proof (prove)\nusing this:\n  le\\<cdot>(slength\\<cdot>xs)\\<cdot>i = TT\n\ngoal (1 subgoal):\n 1. stake\\<cdot>i\\<cdot>xs = xs", "proof(induct xs arbitrary: i)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i.\n       le\\<cdot>(slength\\<cdot>\\<bottom>)\\<cdot>i = TT \\<Longrightarrow>\n       stake\\<cdot>i\\<cdot>\\<bottom> = \\<bottom>\n 2. \\<And>i.\n       le\\<cdot>(slength\\<cdot>[::])\\<cdot>i = TT \\<Longrightarrow>\n       stake\\<cdot>i\\<cdot>[::] = [::]\n 3. \\<And>a xs i.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>i.\n           le\\<cdot>(slength\\<cdot>xs)\\<cdot>i = TT \\<Longrightarrow>\n           stake\\<cdot>i\\<cdot>xs = xs;\n        le\\<cdot>(slength\\<cdot>(a :# xs))\\<cdot>i = TT\\<rbrakk>\n       \\<Longrightarrow> stake\\<cdot>i\\<cdot>(a :# xs) = a :# xs", "case (scons x xs i)"], ["proof (state)\nthis:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  le\\<cdot>(slength\\<cdot>xs)\\<cdot>?i = TT \\<Longrightarrow>\n  stake\\<cdot>?i\\<cdot>xs = xs\n  le\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>i = TT\n\ngoal (3 subgoals):\n 1. \\<And>i.\n       le\\<cdot>(slength\\<cdot>\\<bottom>)\\<cdot>i = TT \\<Longrightarrow>\n       stake\\<cdot>i\\<cdot>\\<bottom> = \\<bottom>\n 2. \\<And>i.\n       le\\<cdot>(slength\\<cdot>[::])\\<cdot>i = TT \\<Longrightarrow>\n       stake\\<cdot>i\\<cdot>[::] = [::]\n 3. \\<And>a xs i.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>i.\n           le\\<cdot>(slength\\<cdot>xs)\\<cdot>i = TT \\<Longrightarrow>\n           stake\\<cdot>i\\<cdot>xs = xs;\n        le\\<cdot>(slength\\<cdot>(a :# xs))\\<cdot>i = TT\\<rbrakk>\n       \\<Longrightarrow> stake\\<cdot>i\\<cdot>(a :# xs) = a :# xs", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  le\\<cdot>(slength\\<cdot>xs)\\<cdot>?i = TT \\<Longrightarrow>\n  stake\\<cdot>?i\\<cdot>xs = xs\n  le\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>i = TT", "show ?case"], ["proof (prove)\nusing this:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  le\\<cdot>(slength\\<cdot>xs)\\<cdot>?i = TT \\<Longrightarrow>\n  stake\\<cdot>?i\\<cdot>xs = xs\n  le\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>i = TT\n\ngoal (1 subgoal):\n 1. stake\\<cdot>i\\<cdot>(x :# xs) = x :# xs", "by (cases i; clarsimp simp: If2_def[symmetric] zero_Integer_def one_Integer_def split: If2_splits if_splits elim!: slengthE)"], ["proof (state)\nthis:\n  stake\\<cdot>i\\<cdot>(x :# xs) = x :# xs\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       le\\<cdot>(slength\\<cdot>\\<bottom>)\\<cdot>i = TT \\<Longrightarrow>\n       stake\\<cdot>i\\<cdot>\\<bottom> = \\<bottom>\n 2. \\<And>i.\n       le\\<cdot>(slength\\<cdot>[::])\\<cdot>i = TT \\<Longrightarrow>\n       stake\\<cdot>i\\<cdot>[::] = [::]", "qed (simp_all add: le_defined)"], ["", "lemma stake_all_triv[simp]: \"stake\\<cdot>(slength\\<cdot>xs)\\<cdot>xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stake\\<cdot>(slength\\<cdot>xs)\\<cdot>xs = xs", "by (cases \"xs = \\<bottom>\") (auto simp: stake_all)"], ["", "lemma stake_append[simp]: \"stake\\<cdot>i\\<cdot>(xs :@ ys) = stake\\<cdot>i\\<cdot>xs :@ stake\\<cdot>(i - slength\\<cdot>xs)\\<cdot>ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stake\\<cdot>i\\<cdot>(xs :@ ys) =\n    stake\\<cdot>i\\<cdot>xs :@ stake\\<cdot>(i - slength\\<cdot>xs)\\<cdot>ys", "proof(induct xs arbitrary: i)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i.\n       stake\\<cdot>i\\<cdot>(\\<bottom> :@ ys) =\n       stake\\<cdot>i\\<cdot>\\<bottom> :@\n       stake\\<cdot>(i - slength\\<cdot>\\<bottom>)\\<cdot>ys\n 2. \\<And>i.\n       stake\\<cdot>i\\<cdot>([::] :@ ys) =\n       stake\\<cdot>i\\<cdot>[::] :@\n       stake\\<cdot>(i - slength\\<cdot>[::])\\<cdot>ys\n 3. \\<And>a xs i.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>i.\n           stake\\<cdot>i\\<cdot>(xs :@ ys) =\n           stake\\<cdot>i\\<cdot>xs :@\n           stake\\<cdot>(i - slength\\<cdot>xs)\\<cdot>ys\\<rbrakk>\n       \\<Longrightarrow> stake\\<cdot>i\\<cdot>((a :# xs) :@ ys) =\n                         stake\\<cdot>i\\<cdot>(a :# xs) :@\n                         stake\\<cdot>(i - slength\\<cdot>(a :# xs))\\<cdot>ys", "case (snil i)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>i.\n       stake\\<cdot>i\\<cdot>(\\<bottom> :@ ys) =\n       stake\\<cdot>i\\<cdot>\\<bottom> :@\n       stake\\<cdot>(i - slength\\<cdot>\\<bottom>)\\<cdot>ys\n 2. \\<And>i.\n       stake\\<cdot>i\\<cdot>([::] :@ ys) =\n       stake\\<cdot>i\\<cdot>[::] :@\n       stake\\<cdot>(i - slength\\<cdot>[::])\\<cdot>ys\n 3. \\<And>a xs i.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>i.\n           stake\\<cdot>i\\<cdot>(xs :@ ys) =\n           stake\\<cdot>i\\<cdot>xs :@\n           stake\\<cdot>(i - slength\\<cdot>xs)\\<cdot>ys\\<rbrakk>\n       \\<Longrightarrow> stake\\<cdot>i\\<cdot>((a :# xs) :@ ys) =\n                         stake\\<cdot>i\\<cdot>(a :# xs) :@\n                         stake\\<cdot>(i - slength\\<cdot>(a :# xs))\\<cdot>ys", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. stake\\<cdot>i\\<cdot>([::] :@ ys) =\n    stake\\<cdot>i\\<cdot>[::] :@\n    stake\\<cdot>(i - slength\\<cdot>[::])\\<cdot>ys", "by (cases i; simp add: zero_Integer_def)"], ["proof (state)\nthis:\n  stake\\<cdot>i\\<cdot>([::] :@ ys) =\n  stake\\<cdot>i\\<cdot>[::] :@ stake\\<cdot>(i - slength\\<cdot>[::])\\<cdot>ys\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       stake\\<cdot>i\\<cdot>(\\<bottom> :@ ys) =\n       stake\\<cdot>i\\<cdot>\\<bottom> :@\n       stake\\<cdot>(i - slength\\<cdot>\\<bottom>)\\<cdot>ys\n 2. \\<And>a xs i.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>i.\n           stake\\<cdot>i\\<cdot>(xs :@ ys) =\n           stake\\<cdot>i\\<cdot>xs :@\n           stake\\<cdot>(i - slength\\<cdot>xs)\\<cdot>ys\\<rbrakk>\n       \\<Longrightarrow> stake\\<cdot>i\\<cdot>((a :# xs) :@ ys) =\n                         stake\\<cdot>i\\<cdot>(a :# xs) :@\n                         stake\\<cdot>(i - slength\\<cdot>(a :# xs))\\<cdot>ys", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       stake\\<cdot>i\\<cdot>(\\<bottom> :@ ys) =\n       stake\\<cdot>i\\<cdot>\\<bottom> :@\n       stake\\<cdot>(i - slength\\<cdot>\\<bottom>)\\<cdot>ys\n 2. \\<And>a xs i.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>i.\n           stake\\<cdot>i\\<cdot>(xs :@ ys) =\n           stake\\<cdot>i\\<cdot>xs :@\n           stake\\<cdot>(i - slength\\<cdot>xs)\\<cdot>ys\\<rbrakk>\n       \\<Longrightarrow> stake\\<cdot>i\\<cdot>((a :# xs) :@ ys) =\n                         stake\\<cdot>i\\<cdot>(a :# xs) :@\n                         stake\\<cdot>(i - slength\\<cdot>(a :# xs))\\<cdot>ys", "case (scons x xs i)"], ["proof (state)\nthis:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  stake\\<cdot>?i\\<cdot>(xs :@ ys) =\n  stake\\<cdot>?i\\<cdot>xs :@ stake\\<cdot>(?i - slength\\<cdot>xs)\\<cdot>ys\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       stake\\<cdot>i\\<cdot>(\\<bottom> :@ ys) =\n       stake\\<cdot>i\\<cdot>\\<bottom> :@\n       stake\\<cdot>(i - slength\\<cdot>\\<bottom>)\\<cdot>ys\n 2. \\<And>a xs i.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>i.\n           stake\\<cdot>i\\<cdot>(xs :@ ys) =\n           stake\\<cdot>i\\<cdot>xs :@\n           stake\\<cdot>(i - slength\\<cdot>xs)\\<cdot>ys\\<rbrakk>\n       \\<Longrightarrow> stake\\<cdot>i\\<cdot>((a :# xs) :@ ys) =\n                         stake\\<cdot>i\\<cdot>(a :# xs) :@\n                         stake\\<cdot>(i - slength\\<cdot>(a :# xs))\\<cdot>ys", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  stake\\<cdot>?i\\<cdot>(xs :@ ys) =\n  stake\\<cdot>?i\\<cdot>xs :@ stake\\<cdot>(?i - slength\\<cdot>xs)\\<cdot>ys", "show ?case"], ["proof (prove)\nusing this:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  stake\\<cdot>?i\\<cdot>(xs :@ ys) =\n  stake\\<cdot>?i\\<cdot>xs :@ stake\\<cdot>(?i - slength\\<cdot>xs)\\<cdot>ys\n\ngoal (1 subgoal):\n 1. stake\\<cdot>i\\<cdot>((x :# xs) :@ ys) =\n    stake\\<cdot>i\\<cdot>(x :# xs) :@\n    stake\\<cdot>(i - slength\\<cdot>(x :# xs))\\<cdot>ys", "by (cases i; cases ys; clarsimp simp: If2_def[symmetric] zero_Integer_def one_Integer_def split: If2_splits  elim!: slengthE)"], ["proof (state)\nthis:\n  stake\\<cdot>i\\<cdot>((x :# xs) :@ ys) =\n  stake\\<cdot>i\\<cdot>(x :# xs) :@\n  stake\\<cdot>(i - slength\\<cdot>(x :# xs))\\<cdot>ys\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       stake\\<cdot>i\\<cdot>(\\<bottom> :@ ys) =\n       stake\\<cdot>i\\<cdot>\\<bottom> :@\n       stake\\<cdot>(i - slength\\<cdot>\\<bottom>)\\<cdot>ys", "qed simp_all"], ["", "fixrec sdrop :: \"Integer \\<rightarrow> [:'a:] \\<rightarrow> [:'a:]\" where \\<comment>\\<open> Note: strict in both parameters. \\<close>\n  [simp del]: \"sdrop\\<cdot>i\\<cdot>xs = If le\\<cdot>i\\<cdot>0 then xs else (case xs of [::] \\<Rightarrow> [::] | y :# ys \\<Rightarrow> sdrop\\<cdot>(i - 1)\\<cdot>ys)\""], ["", "lemma sdrop_strict[simp]:\n  \"sdrop\\<cdot>\\<bottom> = \\<bottom>\"\n  \"sdrop\\<cdot>i\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sdrop\\<cdot>\\<bottom> = \\<bottom> &&&\n    sdrop\\<cdot>i\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp+"], ["", "lemma sdrop_bottom_iff[simp]: \"(sdrop\\<cdot>i\\<cdot>xs = \\<bottom>) \\<longleftrightarrow> (i = \\<bottom> \\<or> xs = \\<bottom>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sdrop\\<cdot>i\\<cdot>xs = \\<bottom>) =\n    (i = \\<bottom> \\<or> xs = \\<bottom>)", "proof(induct xs arbitrary: i)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i.\n       (sdrop\\<cdot>i\\<cdot>\\<bottom> = \\<bottom>) =\n       (i = \\<bottom> \\<or> \\<bottom> = \\<bottom>)\n 2. \\<And>i.\n       (sdrop\\<cdot>i\\<cdot>[::] = \\<bottom>) =\n       (i = \\<bottom> \\<or> [::] = \\<bottom>)\n 3. \\<And>a xs i.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>i.\n           (sdrop\\<cdot>i\\<cdot>xs = \\<bottom>) =\n           (i = \\<bottom> \\<or> xs = \\<bottom>)\\<rbrakk>\n       \\<Longrightarrow> (sdrop\\<cdot>i\\<cdot>(a :# xs) = \\<bottom>) =\n                         (i = \\<bottom> \\<or> a :# xs = \\<bottom>)", "case (snil i)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>i.\n       (sdrop\\<cdot>i\\<cdot>\\<bottom> = \\<bottom>) =\n       (i = \\<bottom> \\<or> \\<bottom> = \\<bottom>)\n 2. \\<And>i.\n       (sdrop\\<cdot>i\\<cdot>[::] = \\<bottom>) =\n       (i = \\<bottom> \\<or> [::] = \\<bottom>)\n 3. \\<And>a xs i.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>i.\n           (sdrop\\<cdot>i\\<cdot>xs = \\<bottom>) =\n           (i = \\<bottom> \\<or> xs = \\<bottom>)\\<rbrakk>\n       \\<Longrightarrow> (sdrop\\<cdot>i\\<cdot>(a :# xs) = \\<bottom>) =\n                         (i = \\<bottom> \\<or> a :# xs = \\<bottom>)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (sdrop\\<cdot>i\\<cdot>[::] = \\<bottom>) =\n    (i = \\<bottom> \\<or> [::] = \\<bottom>)", "by (subst sdrop.unfold) (cases i; simp)"], ["proof (state)\nthis:\n  (sdrop\\<cdot>i\\<cdot>[::] = \\<bottom>) =\n  (i = \\<bottom> \\<or> [::] = \\<bottom>)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       (sdrop\\<cdot>i\\<cdot>\\<bottom> = \\<bottom>) =\n       (i = \\<bottom> \\<or> \\<bottom> = \\<bottom>)\n 2. \\<And>a xs i.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>i.\n           (sdrop\\<cdot>i\\<cdot>xs = \\<bottom>) =\n           (i = \\<bottom> \\<or> xs = \\<bottom>)\\<rbrakk>\n       \\<Longrightarrow> (sdrop\\<cdot>i\\<cdot>(a :# xs) = \\<bottom>) =\n                         (i = \\<bottom> \\<or> a :# xs = \\<bottom>)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       (sdrop\\<cdot>i\\<cdot>\\<bottom> = \\<bottom>) =\n       (i = \\<bottom> \\<or> \\<bottom> = \\<bottom>)\n 2. \\<And>a xs i.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>i.\n           (sdrop\\<cdot>i\\<cdot>xs = \\<bottom>) =\n           (i = \\<bottom> \\<or> xs = \\<bottom>)\\<rbrakk>\n       \\<Longrightarrow> (sdrop\\<cdot>i\\<cdot>(a :# xs) = \\<bottom>) =\n                         (i = \\<bottom> \\<or> a :# xs = \\<bottom>)", "case (scons x xs i)"], ["proof (state)\nthis:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  (sdrop\\<cdot>?i\\<cdot>xs = \\<bottom>) =\n  (?i = \\<bottom> \\<or> xs = \\<bottom>)\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       (sdrop\\<cdot>i\\<cdot>\\<bottom> = \\<bottom>) =\n       (i = \\<bottom> \\<or> \\<bottom> = \\<bottom>)\n 2. \\<And>a xs i.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>i.\n           (sdrop\\<cdot>i\\<cdot>xs = \\<bottom>) =\n           (i = \\<bottom> \\<or> xs = \\<bottom>)\\<rbrakk>\n       \\<Longrightarrow> (sdrop\\<cdot>i\\<cdot>(a :# xs) = \\<bottom>) =\n                         (i = \\<bottom> \\<or> a :# xs = \\<bottom>)", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  (sdrop\\<cdot>?i\\<cdot>xs = \\<bottom>) =\n  (?i = \\<bottom> \\<or> xs = \\<bottom>)", "show ?case"], ["proof (prove)\nusing this:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  (sdrop\\<cdot>?i\\<cdot>xs = \\<bottom>) =\n  (?i = \\<bottom> \\<or> xs = \\<bottom>)\n\ngoal (1 subgoal):\n 1. (sdrop\\<cdot>i\\<cdot>(x :# xs) = \\<bottom>) =\n    (i = \\<bottom> \\<or> x :# xs = \\<bottom>)", "by (subst sdrop.unfold) fastforce"], ["proof (state)\nthis:\n  (sdrop\\<cdot>i\\<cdot>(x :# xs) = \\<bottom>) =\n  (i = \\<bottom> \\<or> x :# xs = \\<bottom>)\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       (sdrop\\<cdot>i\\<cdot>\\<bottom> = \\<bottom>) =\n       (i = \\<bottom> \\<or> \\<bottom> = \\<bottom>)", "qed simp"], ["", "lemma sdrop_snil[simp]:\n  assumes \"i \\<noteq> \\<bottom>\"\n  shows \"sdrop\\<cdot>i\\<cdot>[::] = [::]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sdrop\\<cdot>i\\<cdot>[::] = [::]", "using assms"], ["proof (prove)\nusing this:\n  i \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. sdrop\\<cdot>i\\<cdot>[::] = [::]", "by (subst sdrop.unfold; fastforce)"], ["", "lemma sdrop_snil_conv[simp]: \"(sdrop\\<cdot>i\\<cdot>[::] = [::]) \\<longleftrightarrow> (i \\<noteq> \\<bottom>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sdrop\\<cdot>i\\<cdot>[::] = [::]) = (i \\<noteq> \\<bottom>)", "by (subst sdrop.unfold; fastforce)"], ["", "lemma sdrop_0[simp]:\n  \"sdrop\\<cdot>0\\<cdot>xs = xs\"\n  \"sdrop\\<cdot>(MkI\\<cdot>0)\\<cdot>xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sdrop\\<cdot>0\\<cdot>xs = xs &&& sdrop\\<cdot>(MkI\\<cdot>0)\\<cdot>xs = xs", "by (subst sdrop.simps, simp add: zero_Integer_def)+"], ["", "lemma sdrop_pos:\n  \"le\\<cdot>i\\<cdot>0 = FF \\<Longrightarrow> sdrop\\<cdot>i\\<cdot>xs = (case xs of [::] \\<Rightarrow> [::] | y :# ys \\<Rightarrow> sdrop\\<cdot>(i - 1)\\<cdot>ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le\\<cdot>i\\<cdot>0 = FF \\<Longrightarrow>\n    sdrop\\<cdot>i\\<cdot>xs =\n    (case xs of [::] \\<Rightarrow> [::]\n     | y :# ys \\<Rightarrow> sdrop\\<cdot>(i - 1)\\<cdot>ys)", "by (subst sdrop.simps, simp)"], ["", "lemma sdrop_neg:\n  \"le\\<cdot>i\\<cdot>0 = TT \\<Longrightarrow> sdrop\\<cdot>i\\<cdot>xs = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le\\<cdot>i\\<cdot>0 = TT \\<Longrightarrow> sdrop\\<cdot>i\\<cdot>xs = xs", "by (subst sdrop.simps, simp)"], ["", "lemma sdrop_numeral_scons[simp]:\n  \"x \\<noteq> \\<bottom> \\<Longrightarrow> sdrop\\<cdot>1\\<cdot>(x :# xs) = xs\"\n  \"x \\<noteq> \\<bottom> \\<Longrightarrow> sdrop\\<cdot>(numeral (Num.Bit0 k))\\<cdot>(x :# xs) = sdrop\\<cdot>(numeral (Num.BitM k))\\<cdot>xs\"\n  \"x \\<noteq> \\<bottom> \\<Longrightarrow> sdrop\\<cdot>(numeral (Num.Bit1 k))\\<cdot>(x :# xs) = sdrop\\<cdot>(numeral (Num.Bit0 k))\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (x \\<noteq> \\<bottom> \\<Longrightarrow>\n     sdrop\\<cdot>1\\<cdot>(x :# xs) = xs) &&&\n    (x \\<noteq> \\<bottom> \\<Longrightarrow>\n     sdrop\\<cdot>(numeral (num.Bit0 k))\\<cdot>(x :# xs) =\n     sdrop\\<cdot>(numeral (Num.BitM k))\\<cdot>xs) &&&\n    (x \\<noteq> \\<bottom> \\<Longrightarrow>\n     sdrop\\<cdot>(numeral (num.Bit1 k))\\<cdot>(x :# xs) =\n     sdrop\\<cdot>(numeral (num.Bit0 k))\\<cdot>xs)", "by (subst sdrop.simps,\n    simp add: zero_Integer_def one_Integer_def numeral_Integer_eq; cases xs; simp)+"], ["", "lemma sdrop_sappend[simp]:\n  \"sdrop\\<cdot>i\\<cdot>(xs :@ ys) = sdrop\\<cdot>i\\<cdot>xs :@ sdrop\\<cdot>(i - slength\\<cdot>xs)\\<cdot>ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sdrop\\<cdot>i\\<cdot>(xs :@ ys) =\n    sdrop\\<cdot>i\\<cdot>xs :@ sdrop\\<cdot>(i - slength\\<cdot>xs)\\<cdot>ys", "proof(induct xs arbitrary: i)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i.\n       sdrop\\<cdot>i\\<cdot>(\\<bottom> :@ ys) =\n       sdrop\\<cdot>i\\<cdot>\\<bottom> :@\n       sdrop\\<cdot>(i - slength\\<cdot>\\<bottom>)\\<cdot>ys\n 2. \\<And>i.\n       sdrop\\<cdot>i\\<cdot>([::] :@ ys) =\n       sdrop\\<cdot>i\\<cdot>[::] :@\n       sdrop\\<cdot>(i - slength\\<cdot>[::])\\<cdot>ys\n 3. \\<And>a xs i.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>i.\n           sdrop\\<cdot>i\\<cdot>(xs :@ ys) =\n           sdrop\\<cdot>i\\<cdot>xs :@\n           sdrop\\<cdot>(i - slength\\<cdot>xs)\\<cdot>ys\\<rbrakk>\n       \\<Longrightarrow> sdrop\\<cdot>i\\<cdot>((a :# xs) :@ ys) =\n                         sdrop\\<cdot>i\\<cdot>(a :# xs) :@\n                         sdrop\\<cdot>(i - slength\\<cdot>(a :# xs))\\<cdot>ys", "case (snil i)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>i.\n       sdrop\\<cdot>i\\<cdot>(\\<bottom> :@ ys) =\n       sdrop\\<cdot>i\\<cdot>\\<bottom> :@\n       sdrop\\<cdot>(i - slength\\<cdot>\\<bottom>)\\<cdot>ys\n 2. \\<And>i.\n       sdrop\\<cdot>i\\<cdot>([::] :@ ys) =\n       sdrop\\<cdot>i\\<cdot>[::] :@\n       sdrop\\<cdot>(i - slength\\<cdot>[::])\\<cdot>ys\n 3. \\<And>a xs i.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>i.\n           sdrop\\<cdot>i\\<cdot>(xs :@ ys) =\n           sdrop\\<cdot>i\\<cdot>xs :@\n           sdrop\\<cdot>(i - slength\\<cdot>xs)\\<cdot>ys\\<rbrakk>\n       \\<Longrightarrow> sdrop\\<cdot>i\\<cdot>((a :# xs) :@ ys) =\n                         sdrop\\<cdot>i\\<cdot>(a :# xs) :@\n                         sdrop\\<cdot>(i - slength\\<cdot>(a :# xs))\\<cdot>ys", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. sdrop\\<cdot>i\\<cdot>([::] :@ ys) =\n    sdrop\\<cdot>i\\<cdot>[::] :@\n    sdrop\\<cdot>(i - slength\\<cdot>[::])\\<cdot>ys", "by (cases i; simp add: zero_Integer_def)"], ["proof (state)\nthis:\n  sdrop\\<cdot>i\\<cdot>([::] :@ ys) =\n  sdrop\\<cdot>i\\<cdot>[::] :@ sdrop\\<cdot>(i - slength\\<cdot>[::])\\<cdot>ys\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       sdrop\\<cdot>i\\<cdot>(\\<bottom> :@ ys) =\n       sdrop\\<cdot>i\\<cdot>\\<bottom> :@\n       sdrop\\<cdot>(i - slength\\<cdot>\\<bottom>)\\<cdot>ys\n 2. \\<And>a xs i.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>i.\n           sdrop\\<cdot>i\\<cdot>(xs :@ ys) =\n           sdrop\\<cdot>i\\<cdot>xs :@\n           sdrop\\<cdot>(i - slength\\<cdot>xs)\\<cdot>ys\\<rbrakk>\n       \\<Longrightarrow> sdrop\\<cdot>i\\<cdot>((a :# xs) :@ ys) =\n                         sdrop\\<cdot>i\\<cdot>(a :# xs) :@\n                         sdrop\\<cdot>(i - slength\\<cdot>(a :# xs))\\<cdot>ys", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       sdrop\\<cdot>i\\<cdot>(\\<bottom> :@ ys) =\n       sdrop\\<cdot>i\\<cdot>\\<bottom> :@\n       sdrop\\<cdot>(i - slength\\<cdot>\\<bottom>)\\<cdot>ys\n 2. \\<And>a xs i.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>i.\n           sdrop\\<cdot>i\\<cdot>(xs :@ ys) =\n           sdrop\\<cdot>i\\<cdot>xs :@\n           sdrop\\<cdot>(i - slength\\<cdot>xs)\\<cdot>ys\\<rbrakk>\n       \\<Longrightarrow> sdrop\\<cdot>i\\<cdot>((a :# xs) :@ ys) =\n                         sdrop\\<cdot>i\\<cdot>(a :# xs) :@\n                         sdrop\\<cdot>(i - slength\\<cdot>(a :# xs))\\<cdot>ys", "case (scons x xs i)"], ["proof (state)\nthis:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  sdrop\\<cdot>?i\\<cdot>(xs :@ ys) =\n  sdrop\\<cdot>?i\\<cdot>xs :@ sdrop\\<cdot>(?i - slength\\<cdot>xs)\\<cdot>ys\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       sdrop\\<cdot>i\\<cdot>(\\<bottom> :@ ys) =\n       sdrop\\<cdot>i\\<cdot>\\<bottom> :@\n       sdrop\\<cdot>(i - slength\\<cdot>\\<bottom>)\\<cdot>ys\n 2. \\<And>a xs i.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>i.\n           sdrop\\<cdot>i\\<cdot>(xs :@ ys) =\n           sdrop\\<cdot>i\\<cdot>xs :@\n           sdrop\\<cdot>(i - slength\\<cdot>xs)\\<cdot>ys\\<rbrakk>\n       \\<Longrightarrow> sdrop\\<cdot>i\\<cdot>((a :# xs) :@ ys) =\n                         sdrop\\<cdot>i\\<cdot>(a :# xs) :@\n                         sdrop\\<cdot>(i - slength\\<cdot>(a :# xs))\\<cdot>ys", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  sdrop\\<cdot>?i\\<cdot>(xs :@ ys) =\n  sdrop\\<cdot>?i\\<cdot>xs :@ sdrop\\<cdot>(?i - slength\\<cdot>xs)\\<cdot>ys", "show ?case"], ["proof (prove)\nusing this:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  sdrop\\<cdot>?i\\<cdot>(xs :@ ys) =\n  sdrop\\<cdot>?i\\<cdot>xs :@ sdrop\\<cdot>(?i - slength\\<cdot>xs)\\<cdot>ys\n\ngoal (1 subgoal):\n 1. sdrop\\<cdot>i\\<cdot>((x :# xs) :@ ys) =\n    sdrop\\<cdot>i\\<cdot>(x :# xs) :@\n    sdrop\\<cdot>(i - slength\\<cdot>(x :# xs))\\<cdot>ys", "by (cases \"ys = \\<bottom>\"; cases \"le\\<cdot>i\\<cdot>0\"; cases i;\n        clarsimp simp: zero_Integer_def one_Integer_def sdrop_neg sdrop_pos add.commute diff_diff_add\n                split: if_splits elim!: slengthE)"], ["proof (state)\nthis:\n  sdrop\\<cdot>i\\<cdot>((x :# xs) :@ ys) =\n  sdrop\\<cdot>i\\<cdot>(x :# xs) :@\n  sdrop\\<cdot>(i - slength\\<cdot>(x :# xs))\\<cdot>ys\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       sdrop\\<cdot>i\\<cdot>(\\<bottom> :@ ys) =\n       sdrop\\<cdot>i\\<cdot>\\<bottom> :@\n       sdrop\\<cdot>(i - slength\\<cdot>\\<bottom>)\\<cdot>ys", "qed simp"], ["", "lemma sdrop_all:\n  assumes \"le\\<cdot>(slength\\<cdot>xs)\\<cdot>i = TT\"\n  shows \"sdrop\\<cdot>i\\<cdot>xs = [::]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sdrop\\<cdot>i\\<cdot>xs = [::]", "using assms"], ["proof (prove)\nusing this:\n  le\\<cdot>(slength\\<cdot>xs)\\<cdot>i = TT\n\ngoal (1 subgoal):\n 1. sdrop\\<cdot>i\\<cdot>xs = [::]", "proof(induct xs arbitrary: i)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i.\n       le\\<cdot>(slength\\<cdot>\\<bottom>)\\<cdot>i = TT \\<Longrightarrow>\n       sdrop\\<cdot>i\\<cdot>\\<bottom> = [::]\n 2. \\<And>i.\n       le\\<cdot>(slength\\<cdot>[::])\\<cdot>i = TT \\<Longrightarrow>\n       sdrop\\<cdot>i\\<cdot>[::] = [::]\n 3. \\<And>a xs i.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>i.\n           le\\<cdot>(slength\\<cdot>xs)\\<cdot>i = TT \\<Longrightarrow>\n           sdrop\\<cdot>i\\<cdot>xs = [::];\n        le\\<cdot>(slength\\<cdot>(a :# xs))\\<cdot>i = TT\\<rbrakk>\n       \\<Longrightarrow> sdrop\\<cdot>i\\<cdot>(a :# xs) = [::]", "case (scons x xs i)"], ["proof (state)\nthis:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  le\\<cdot>(slength\\<cdot>xs)\\<cdot>?i = TT \\<Longrightarrow>\n  sdrop\\<cdot>?i\\<cdot>xs = [::]\n  le\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>i = TT\n\ngoal (3 subgoals):\n 1. \\<And>i.\n       le\\<cdot>(slength\\<cdot>\\<bottom>)\\<cdot>i = TT \\<Longrightarrow>\n       sdrop\\<cdot>i\\<cdot>\\<bottom> = [::]\n 2. \\<And>i.\n       le\\<cdot>(slength\\<cdot>[::])\\<cdot>i = TT \\<Longrightarrow>\n       sdrop\\<cdot>i\\<cdot>[::] = [::]\n 3. \\<And>a xs i.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>i.\n           le\\<cdot>(slength\\<cdot>xs)\\<cdot>i = TT \\<Longrightarrow>\n           sdrop\\<cdot>i\\<cdot>xs = [::];\n        le\\<cdot>(slength\\<cdot>(a :# xs))\\<cdot>i = TT\\<rbrakk>\n       \\<Longrightarrow> sdrop\\<cdot>i\\<cdot>(a :# xs) = [::]", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  le\\<cdot>(slength\\<cdot>xs)\\<cdot>?i = TT \\<Longrightarrow>\n  sdrop\\<cdot>?i\\<cdot>xs = [::]\n  le\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>i = TT", "show ?case"], ["proof (prove)\nusing this:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  le\\<cdot>(slength\\<cdot>xs)\\<cdot>?i = TT \\<Longrightarrow>\n  sdrop\\<cdot>?i\\<cdot>xs = [::]\n  le\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>i = TT\n\ngoal (1 subgoal):\n 1. sdrop\\<cdot>i\\<cdot>(x :# xs) = [::]", "by (subst sdrop.unfold; cases i;\n        clarsimp simp: If2_def[symmetric] zero_Integer_def one_Integer_def split: If2_splits if_splits elim!: slengthE)"], ["proof (state)\nthis:\n  sdrop\\<cdot>i\\<cdot>(x :# xs) = [::]\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       le\\<cdot>(slength\\<cdot>\\<bottom>)\\<cdot>i = TT \\<Longrightarrow>\n       sdrop\\<cdot>i\\<cdot>\\<bottom> = [::]\n 2. \\<And>i.\n       le\\<cdot>(slength\\<cdot>[::])\\<cdot>i = TT \\<Longrightarrow>\n       sdrop\\<cdot>i\\<cdot>[::] = [::]", "qed (simp_all add: le_defined)"], ["", "lemma slength_sdrop[simp]:\n  \"slength\\<cdot>(sdrop\\<cdot>i\\<cdot>xs) = If le\\<cdot>i\\<cdot>0 then slength\\<cdot>xs else If le\\<cdot>(slength\\<cdot>xs)\\<cdot>i then 0 else slength\\<cdot>xs - i\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slength\\<cdot>(sdrop\\<cdot>i\\<cdot>xs) =\n    If le\\<cdot>i\\<cdot>0 then slength\\<cdot>xs\n    else If le\\<cdot>(slength\\<cdot>xs)\\<cdot>i then 0\n         else slength\\<cdot>xs - i", "proof(induct xs arbitrary: i)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i.\n       slength\\<cdot>(sdrop\\<cdot>i\\<cdot>\\<bottom>) =\n       If le\\<cdot>i\\<cdot>0 then slength\\<cdot>\\<bottom>\n       else If le\\<cdot>(slength\\<cdot>\\<bottom>)\\<cdot>i then 0\n            else slength\\<cdot>\\<bottom> - i\n 2. \\<And>i.\n       slength\\<cdot>(sdrop\\<cdot>i\\<cdot>[::]) =\n       If le\\<cdot>i\\<cdot>0 then slength\\<cdot>[::]\n       else If le\\<cdot>(slength\\<cdot>[::])\\<cdot>i then 0\n            else slength\\<cdot>[::] - i\n 3. \\<And>a xs i.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>i.\n           slength\\<cdot>(sdrop\\<cdot>i\\<cdot>xs) =\n           If le\\<cdot>i\\<cdot>0 then slength\\<cdot>xs\n           else If le\\<cdot>(slength\\<cdot>xs)\\<cdot>i then 0\n                else slength\\<cdot>xs - i\\<rbrakk>\n       \\<Longrightarrow> slength\\<cdot>(sdrop\\<cdot>i\\<cdot>(a :# xs)) =\n                         If le\\<cdot>i\\<cdot>0 then slength\\<cdot>(a :# xs)\n                         else If le\\<cdot>(slength\\<cdot>(a :# xs))\\<cdot>i\n                              then 0 else slength\\<cdot>(a :# xs) - i", "case (snil i)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>i.\n       slength\\<cdot>(sdrop\\<cdot>i\\<cdot>\\<bottom>) =\n       If le\\<cdot>i\\<cdot>0 then slength\\<cdot>\\<bottom>\n       else If le\\<cdot>(slength\\<cdot>\\<bottom>)\\<cdot>i then 0\n            else slength\\<cdot>\\<bottom> - i\n 2. \\<And>i.\n       slength\\<cdot>(sdrop\\<cdot>i\\<cdot>[::]) =\n       If le\\<cdot>i\\<cdot>0 then slength\\<cdot>[::]\n       else If le\\<cdot>(slength\\<cdot>[::])\\<cdot>i then 0\n            else slength\\<cdot>[::] - i\n 3. \\<And>a xs i.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>i.\n           slength\\<cdot>(sdrop\\<cdot>i\\<cdot>xs) =\n           If le\\<cdot>i\\<cdot>0 then slength\\<cdot>xs\n           else If le\\<cdot>(slength\\<cdot>xs)\\<cdot>i then 0\n                else slength\\<cdot>xs - i\\<rbrakk>\n       \\<Longrightarrow> slength\\<cdot>(sdrop\\<cdot>i\\<cdot>(a :# xs)) =\n                         If le\\<cdot>i\\<cdot>0 then slength\\<cdot>(a :# xs)\n                         else If le\\<cdot>(slength\\<cdot>(a :# xs))\\<cdot>i\n                              then 0 else slength\\<cdot>(a :# xs) - i", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. slength\\<cdot>(sdrop\\<cdot>i\\<cdot>[::]) =\n    If le\\<cdot>i\\<cdot>0 then slength\\<cdot>[::]\n    else If le\\<cdot>(slength\\<cdot>[::])\\<cdot>i then 0\n         else slength\\<cdot>[::] - i", "by (cases i; simp add: zero_Integer_def)"], ["proof (state)\nthis:\n  slength\\<cdot>(sdrop\\<cdot>i\\<cdot>[::]) =\n  If le\\<cdot>i\\<cdot>0 then slength\\<cdot>[::]\n  else If le\\<cdot>(slength\\<cdot>[::])\\<cdot>i then 0\n       else slength\\<cdot>[::] - i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       slength\\<cdot>(sdrop\\<cdot>i\\<cdot>\\<bottom>) =\n       If le\\<cdot>i\\<cdot>0 then slength\\<cdot>\\<bottom>\n       else If le\\<cdot>(slength\\<cdot>\\<bottom>)\\<cdot>i then 0\n            else slength\\<cdot>\\<bottom> - i\n 2. \\<And>a xs i.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>i.\n           slength\\<cdot>(sdrop\\<cdot>i\\<cdot>xs) =\n           If le\\<cdot>i\\<cdot>0 then slength\\<cdot>xs\n           else If le\\<cdot>(slength\\<cdot>xs)\\<cdot>i then 0\n                else slength\\<cdot>xs - i\\<rbrakk>\n       \\<Longrightarrow> slength\\<cdot>(sdrop\\<cdot>i\\<cdot>(a :# xs)) =\n                         If le\\<cdot>i\\<cdot>0 then slength\\<cdot>(a :# xs)\n                         else If le\\<cdot>(slength\\<cdot>(a :# xs))\\<cdot>i\n                              then 0 else slength\\<cdot>(a :# xs) - i", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i.\n       slength\\<cdot>(sdrop\\<cdot>i\\<cdot>\\<bottom>) =\n       If le\\<cdot>i\\<cdot>0 then slength\\<cdot>\\<bottom>\n       else If le\\<cdot>(slength\\<cdot>\\<bottom>)\\<cdot>i then 0\n            else slength\\<cdot>\\<bottom> - i\n 2. \\<And>a xs i.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>i.\n           slength\\<cdot>(sdrop\\<cdot>i\\<cdot>xs) =\n           If le\\<cdot>i\\<cdot>0 then slength\\<cdot>xs\n           else If le\\<cdot>(slength\\<cdot>xs)\\<cdot>i then 0\n                else slength\\<cdot>xs - i\\<rbrakk>\n       \\<Longrightarrow> slength\\<cdot>(sdrop\\<cdot>i\\<cdot>(a :# xs)) =\n                         If le\\<cdot>i\\<cdot>0 then slength\\<cdot>(a :# xs)\n                         else If le\\<cdot>(slength\\<cdot>(a :# xs))\\<cdot>i\n                              then 0 else slength\\<cdot>(a :# xs) - i", "case (scons x xs i)"], ["proof (state)\nthis:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  slength\\<cdot>(sdrop\\<cdot>?i\\<cdot>xs) =\n  If le\\<cdot>?i\\<cdot>0 then slength\\<cdot>xs\n  else If le\\<cdot>(slength\\<cdot>xs)\\<cdot>?i then 0\n       else slength\\<cdot>xs - ?i\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       slength\\<cdot>(sdrop\\<cdot>i\\<cdot>\\<bottom>) =\n       If le\\<cdot>i\\<cdot>0 then slength\\<cdot>\\<bottom>\n       else If le\\<cdot>(slength\\<cdot>\\<bottom>)\\<cdot>i then 0\n            else slength\\<cdot>\\<bottom> - i\n 2. \\<And>a xs i.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>i.\n           slength\\<cdot>(sdrop\\<cdot>i\\<cdot>xs) =\n           If le\\<cdot>i\\<cdot>0 then slength\\<cdot>xs\n           else If le\\<cdot>(slength\\<cdot>xs)\\<cdot>i then 0\n                else slength\\<cdot>xs - i\\<rbrakk>\n       \\<Longrightarrow> slength\\<cdot>(sdrop\\<cdot>i\\<cdot>(a :# xs)) =\n                         If le\\<cdot>i\\<cdot>0 then slength\\<cdot>(a :# xs)\n                         else If le\\<cdot>(slength\\<cdot>(a :# xs))\\<cdot>i\n                              then 0 else slength\\<cdot>(a :# xs) - i", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  slength\\<cdot>(sdrop\\<cdot>?i\\<cdot>xs) =\n  If le\\<cdot>?i\\<cdot>0 then slength\\<cdot>xs\n  else If le\\<cdot>(slength\\<cdot>xs)\\<cdot>?i then 0\n       else slength\\<cdot>xs - ?i", "show ?case"], ["proof (prove)\nusing this:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  slength\\<cdot>(sdrop\\<cdot>?i\\<cdot>xs) =\n  If le\\<cdot>?i\\<cdot>0 then slength\\<cdot>xs\n  else If le\\<cdot>(slength\\<cdot>xs)\\<cdot>?i then 0\n       else slength\\<cdot>xs - ?i\n\ngoal (1 subgoal):\n 1. slength\\<cdot>(sdrop\\<cdot>i\\<cdot>(x :# xs)) =\n    If le\\<cdot>i\\<cdot>0 then slength\\<cdot>(x :# xs)\n    else If le\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>i then 0\n         else slength\\<cdot>(x :# xs) - i", "by (subst sdrop.unfold; cases i; clarsimp simp: zero_Integer_def one_Integer_def elim!: slengthE)"], ["proof (state)\nthis:\n  slength\\<cdot>(sdrop\\<cdot>i\\<cdot>(x :# xs)) =\n  If le\\<cdot>i\\<cdot>0 then slength\\<cdot>(x :# xs)\n  else If le\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>i then 0\n       else slength\\<cdot>(x :# xs) - i\n\ngoal (1 subgoal):\n 1. \\<And>i.\n       slength\\<cdot>(sdrop\\<cdot>i\\<cdot>\\<bottom>) =\n       If le\\<cdot>i\\<cdot>0 then slength\\<cdot>\\<bottom>\n       else If le\\<cdot>(slength\\<cdot>\\<bottom>)\\<cdot>i then 0\n            else slength\\<cdot>\\<bottom> - i", "qed simp"], ["", "lemma sdrop_not_snilD:\n  assumes \"sdrop\\<cdot>(MkI\\<cdot>i)\\<cdot>xs \\<noteq> [::]\"\n  assumes \"xs \\<noteq> \\<bottom>\"\n  shows \"lt\\<cdot>(MkI\\<cdot>i)\\<cdot>(slength\\<cdot>xs) = TT \\<and> xs \\<noteq> [::]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. lt\\<cdot>(MkI\\<cdot>i)\\<cdot>(slength\\<cdot>xs) = TT \\<and>\n    xs \\<noteq> [::]", "using assms"], ["proof (prove)\nusing this:\n  sdrop\\<cdot>(MkI\\<cdot>i)\\<cdot>xs \\<noteq> [::]\n  xs \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. lt\\<cdot>(MkI\\<cdot>i)\\<cdot>(slength\\<cdot>xs) = TT \\<and>\n    xs \\<noteq> [::]", "proof(induct xs arbitrary: i)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>sdrop\\<cdot>(MkI\\<cdot>i)\\<cdot>\\<bottom> \\<noteq> [::];\n        \\<bottom> \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> lt\\<cdot>(MkI\\<cdot>i)\\<cdot>\n                         (slength\\<cdot>\\<bottom>) =\n                         TT \\<and>\n                         \\<bottom> \\<noteq> [::]\n 2. \\<And>i.\n       \\<lbrakk>sdrop\\<cdot>(MkI\\<cdot>i)\\<cdot>[::] \\<noteq> [::];\n        [::] \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> lt\\<cdot>(MkI\\<cdot>i)\\<cdot>(slength\\<cdot>[::]) =\n                         TT \\<and>\n                         [::] \\<noteq> [::]\n 3. \\<And>a xs i.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>i.\n           \\<lbrakk>sdrop\\<cdot>(MkI\\<cdot>i)\\<cdot>xs \\<noteq> [::];\n            xs \\<noteq> \\<bottom>\\<rbrakk>\n           \\<Longrightarrow> lt\\<cdot>(MkI\\<cdot>i)\\<cdot>\n                             (slength\\<cdot>xs) =\n                             TT \\<and>\n                             xs \\<noteq> [::];\n        sdrop\\<cdot>(MkI\\<cdot>i)\\<cdot>(a :# xs) \\<noteq> [::];\n        a :# xs \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> lt\\<cdot>(MkI\\<cdot>i)\\<cdot>\n                         (slength\\<cdot>(a :# xs)) =\n                         TT \\<and>\n                         a :# xs \\<noteq> [::]", "case (scons x xs i)"], ["proof (state)\nthis:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  \\<lbrakk>sdrop\\<cdot>(MkI\\<cdot>?i)\\<cdot>xs \\<noteq> [::];\n   xs \\<noteq> \\<bottom>\\<rbrakk>\n  \\<Longrightarrow> lt\\<cdot>(MkI\\<cdot>?i)\\<cdot>(slength\\<cdot>xs) =\n                    TT \\<and>\n                    xs \\<noteq> [::]\n  sdrop\\<cdot>(MkI\\<cdot>i)\\<cdot>(x :# xs) \\<noteq> [::]\n  x :# xs \\<noteq> \\<bottom>\n\ngoal (3 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>sdrop\\<cdot>(MkI\\<cdot>i)\\<cdot>\\<bottom> \\<noteq> [::];\n        \\<bottom> \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> lt\\<cdot>(MkI\\<cdot>i)\\<cdot>\n                         (slength\\<cdot>\\<bottom>) =\n                         TT \\<and>\n                         \\<bottom> \\<noteq> [::]\n 2. \\<And>i.\n       \\<lbrakk>sdrop\\<cdot>(MkI\\<cdot>i)\\<cdot>[::] \\<noteq> [::];\n        [::] \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> lt\\<cdot>(MkI\\<cdot>i)\\<cdot>(slength\\<cdot>[::]) =\n                         TT \\<and>\n                         [::] \\<noteq> [::]\n 3. \\<And>a xs i.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>i.\n           \\<lbrakk>sdrop\\<cdot>(MkI\\<cdot>i)\\<cdot>xs \\<noteq> [::];\n            xs \\<noteq> \\<bottom>\\<rbrakk>\n           \\<Longrightarrow> lt\\<cdot>(MkI\\<cdot>i)\\<cdot>\n                             (slength\\<cdot>xs) =\n                             TT \\<and>\n                             xs \\<noteq> [::];\n        sdrop\\<cdot>(MkI\\<cdot>i)\\<cdot>(a :# xs) \\<noteq> [::];\n        a :# xs \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> lt\\<cdot>(MkI\\<cdot>i)\\<cdot>\n                         (slength\\<cdot>(a :# xs)) =\n                         TT \\<and>\n                         a :# xs \\<noteq> [::]", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  \\<lbrakk>sdrop\\<cdot>(MkI\\<cdot>?i)\\<cdot>xs \\<noteq> [::];\n   xs \\<noteq> \\<bottom>\\<rbrakk>\n  \\<Longrightarrow> lt\\<cdot>(MkI\\<cdot>?i)\\<cdot>(slength\\<cdot>xs) =\n                    TT \\<and>\n                    xs \\<noteq> [::]\n  sdrop\\<cdot>(MkI\\<cdot>i)\\<cdot>(x :# xs) \\<noteq> [::]\n  x :# xs \\<noteq> \\<bottom>", "show ?case"], ["proof (prove)\nusing this:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  \\<lbrakk>sdrop\\<cdot>(MkI\\<cdot>?i)\\<cdot>xs \\<noteq> [::];\n   xs \\<noteq> \\<bottom>\\<rbrakk>\n  \\<Longrightarrow> lt\\<cdot>(MkI\\<cdot>?i)\\<cdot>(slength\\<cdot>xs) =\n                    TT \\<and>\n                    xs \\<noteq> [::]\n  sdrop\\<cdot>(MkI\\<cdot>i)\\<cdot>(x :# xs) \\<noteq> [::]\n  x :# xs \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. lt\\<cdot>(MkI\\<cdot>i)\\<cdot>(slength\\<cdot>(x :# xs)) = TT \\<and>\n    x :# xs \\<noteq> [::]", "by (subst (asm) (2) sdrop.unfold, clarsimp simp: zero_Integer_def one_Integer_def not_le sdrop_all elim!: slengthE)"], ["proof (state)\nthis:\n  lt\\<cdot>(MkI\\<cdot>i)\\<cdot>(slength\\<cdot>(x :# xs)) = TT \\<and>\n  x :# xs \\<noteq> [::]\n\ngoal (2 subgoals):\n 1. \\<And>i.\n       \\<lbrakk>sdrop\\<cdot>(MkI\\<cdot>i)\\<cdot>\\<bottom> \\<noteq> [::];\n        \\<bottom> \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> lt\\<cdot>(MkI\\<cdot>i)\\<cdot>\n                         (slength\\<cdot>\\<bottom>) =\n                         TT \\<and>\n                         \\<bottom> \\<noteq> [::]\n 2. \\<And>i.\n       \\<lbrakk>sdrop\\<cdot>(MkI\\<cdot>i)\\<cdot>[::] \\<noteq> [::];\n        [::] \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> lt\\<cdot>(MkI\\<cdot>i)\\<cdot>(slength\\<cdot>[::]) =\n                         TT \\<and>\n                         [::] \\<noteq> [::]", "qed simp_all"], ["", "lemma sdrop_sappend_same:\n  assumes \"xs \\<noteq> \\<bottom>\"\n  shows \"sdrop\\<cdot>(slength\\<cdot>xs)\\<cdot>(xs :@ ys) = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sdrop\\<cdot>(slength\\<cdot>xs)\\<cdot>(xs :@ ys) = ys", "using assms"], ["proof (prove)\nusing this:\n  xs \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. sdrop\\<cdot>(slength\\<cdot>xs)\\<cdot>(xs :@ ys) = ys", "proof(induct xs arbitrary: ys)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ys.\n       \\<bottom> \\<noteq> \\<bottom> \\<Longrightarrow>\n       sdrop\\<cdot>(slength\\<cdot>\\<bottom>)\\<cdot>(\\<bottom> :@ ys) = ys\n 2. \\<And>ys.\n       [::] \\<noteq> \\<bottom> \\<Longrightarrow>\n       sdrop\\<cdot>(slength\\<cdot>[::])\\<cdot>([::] :@ ys) = ys\n 3. \\<And>a xs ys.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>ys.\n           xs \\<noteq> \\<bottom> \\<Longrightarrow>\n           sdrop\\<cdot>(slength\\<cdot>xs)\\<cdot>(xs :@ ys) = ys;\n        a :# xs \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> sdrop\\<cdot>(slength\\<cdot>(a :# xs))\\<cdot>\n                         ((a :# xs) :@ ys) =\n                         ys", "case (scons x xs ys)"], ["proof (state)\nthis:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom> \\<Longrightarrow>\n  sdrop\\<cdot>(slength\\<cdot>xs)\\<cdot>(xs :@ ?ys) = ?ys\n  x :# xs \\<noteq> \\<bottom>\n\ngoal (3 subgoals):\n 1. \\<And>ys.\n       \\<bottom> \\<noteq> \\<bottom> \\<Longrightarrow>\n       sdrop\\<cdot>(slength\\<cdot>\\<bottom>)\\<cdot>(\\<bottom> :@ ys) = ys\n 2. \\<And>ys.\n       [::] \\<noteq> \\<bottom> \\<Longrightarrow>\n       sdrop\\<cdot>(slength\\<cdot>[::])\\<cdot>([::] :@ ys) = ys\n 3. \\<And>a xs ys.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>ys.\n           xs \\<noteq> \\<bottom> \\<Longrightarrow>\n           sdrop\\<cdot>(slength\\<cdot>xs)\\<cdot>(xs :@ ys) = ys;\n        a :# xs \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> sdrop\\<cdot>(slength\\<cdot>(a :# xs))\\<cdot>\n                         ((a :# xs) :@ ys) =\n                         ys", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom> \\<Longrightarrow>\n  sdrop\\<cdot>(slength\\<cdot>xs)\\<cdot>(xs :@ ?ys) = ?ys\n  x :# xs \\<noteq> \\<bottom>", "show ?case"], ["proof (prove)\nusing this:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom> \\<Longrightarrow>\n  sdrop\\<cdot>(slength\\<cdot>xs)\\<cdot>(xs :@ ?ys) = ?ys\n  x :# xs \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. sdrop\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>((x :# xs) :@ ys) = ys", "by (cases \"ys = \\<bottom>\"; subst sdrop.unfold; clarsimp simp: zero_Integer_def one_Integer_def elim!: slengthE)"], ["proof (state)\nthis:\n  sdrop\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>((x :# xs) :@ ys) = ys\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       \\<bottom> \\<noteq> \\<bottom> \\<Longrightarrow>\n       sdrop\\<cdot>(slength\\<cdot>\\<bottom>)\\<cdot>(\\<bottom> :@ ys) = ys\n 2. \\<And>ys.\n       [::] \\<noteq> \\<bottom> \\<Longrightarrow>\n       sdrop\\<cdot>(slength\\<cdot>[::])\\<cdot>([::] :@ ys) = ys", "qed simp_all"], ["", "fixrec sscanl :: \"('a \\<rightarrow> 'b \\<rightarrow> 'a) \\<rightarrow> 'a \\<rightarrow> [:'b:] \\<rightarrow> [:'a:]\" where\n  \"sscanl\\<cdot>f\\<cdot>z\\<cdot>[::] = z :# [::]\"\n| \"\\<lbrakk>x \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>\\<rbrakk> \\<Longrightarrow> sscanl\\<cdot>f\\<cdot>z\\<cdot>(x :# xs) = z :# sscanl\\<cdot>f\\<cdot>(f\\<cdot>z\\<cdot>x)\\<cdot>xs\""], ["", "lemma sscanl_strict[simp]:\n  \"sscanl\\<cdot>f\\<cdot>\\<bottom>\\<cdot>xs = \\<bottom>\"\n  \"sscanl\\<cdot>f\\<cdot>z\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sscanl\\<cdot>f\\<cdot>\\<bottom>\\<cdot>xs = \\<bottom> &&&\n    sscanl\\<cdot>f\\<cdot>z\\<cdot>\\<bottom> = \\<bottom>", "by (cases xs) fixrec_simp+"], ["", "lemma sscanl_cong:\n  assumes \"xs = xs'\"\n  assumes \"z = z'\"\n  assumes \"\\<And>x z. x \\<in> sset xs \\<Longrightarrow> f\\<cdot>z\\<cdot>x = f'\\<cdot>z\\<cdot>x\"\n  shows \"sscanl\\<cdot>f\\<cdot>z\\<cdot>xs = sscanl\\<cdot>f'\\<cdot>z'\\<cdot>xs'\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sscanl\\<cdot>f\\<cdot>z\\<cdot>xs = sscanl\\<cdot>f'\\<cdot>z'\\<cdot>xs'", "using assms"], ["proof (prove)\nusing this:\n  xs = xs'\n  z = z'\n  ?x \\<in> sset xs \\<Longrightarrow>\n  f\\<cdot>?z\\<cdot>?x = f'\\<cdot>?z\\<cdot>?x\n\ngoal (1 subgoal):\n 1. sscanl\\<cdot>f\\<cdot>z\\<cdot>xs = sscanl\\<cdot>f'\\<cdot>z'\\<cdot>xs'", "by (induct xs arbitrary: xs' z z') auto"], ["", "lemma sscanl_lfp_fusion':\n  assumes \"g\\<cdot>\\<bottom> = \\<bottom>\"\n  assumes *: \"\\<And>acc x. x \\<noteq> \\<bottom> \\<Longrightarrow> g\\<cdot>(f\\<cdot>acc\\<cdot>x) = f'\\<cdot>(g\\<cdot>acc)\\<cdot>x\"\n  shows \"smap\\<cdot>g\\<cdot>(sscanl\\<cdot>f\\<cdot>z\\<cdot>xs) = sscanl\\<cdot>f'\\<cdot>(g\\<cdot>z)\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap\\<cdot>g\\<cdot>(sscanl\\<cdot>f\\<cdot>z\\<cdot>xs) =\n    sscanl\\<cdot>f'\\<cdot>(g\\<cdot>z)\\<cdot>xs", "using assms"], ["proof (prove)\nusing this:\n  g\\<cdot>\\<bottom> = \\<bottom>\n  ?x \\<noteq> \\<bottom> \\<Longrightarrow>\n  g\\<cdot>(f\\<cdot>?acc\\<cdot>?x) = f'\\<cdot>(g\\<cdot>?acc)\\<cdot>?x\n\ngoal (1 subgoal):\n 1. smap\\<cdot>g\\<cdot>(sscanl\\<cdot>f\\<cdot>z\\<cdot>xs) =\n    sscanl\\<cdot>f'\\<cdot>(g\\<cdot>z)\\<cdot>xs", "by (induct xs arbitrary: z) simp_all"], ["", "lemma sscanl_lfp_fusion:\n  assumes \"g\\<cdot>\\<bottom> = \\<bottom>\"\n  assumes *: \"\\<And>acc x. x \\<noteq> \\<bottom> \\<Longrightarrow> g\\<cdot>(f\\<cdot>acc\\<cdot>x) = f'\\<cdot>(g\\<cdot>acc)\\<cdot>x\"\n  shows \"smap\\<cdot>g oo sscanl\\<cdot>f\\<cdot>z = sscanl\\<cdot>f'\\<cdot>(g\\<cdot>z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap\\<cdot>g oo sscanl\\<cdot>f\\<cdot>z =\n    sscanl\\<cdot>f'\\<cdot>(g\\<cdot>z)", "using assms"], ["proof (prove)\nusing this:\n  g\\<cdot>\\<bottom> = \\<bottom>\n  ?x \\<noteq> \\<bottom> \\<Longrightarrow>\n  g\\<cdot>(f\\<cdot>?acc\\<cdot>?x) = f'\\<cdot>(g\\<cdot>?acc)\\<cdot>?x\n\ngoal (1 subgoal):\n 1. smap\\<cdot>g oo sscanl\\<cdot>f\\<cdot>z =\n    sscanl\\<cdot>f'\\<cdot>(g\\<cdot>z)", "by (clarsimp simp: cfun_eq_iff sscanl_lfp_fusion')"], ["", "lemma sscanl_ww_fusion': \\<comment>\\<open> Worker/wrapper @{cite [cite_macro=citep] \"GillHutton:2009\" and \"Gammie:2011\"} specialised to @{const \\<open>sscanl\\<close>} \\<close>\n  fixes wrap :: \"'b \\<rightarrow> 'a\"\n  fixes unwrap :: \"'a \\<rightarrow> 'b\"\n  fixes z :: \"'a\"\n  fixes f :: \"'a \\<rightarrow> 'c \\<rightarrow> 'a\"\n  fixes f' :: \"'b \\<rightarrow> 'c \\<rightarrow> 'b\"\n  assumes ww: \"wrap oo unwrap = ID\"\n  assumes wb: \"\\<And>z x. x \\<noteq> \\<bottom> \\<Longrightarrow> unwrap\\<cdot>(f\\<cdot>(wrap\\<cdot>z)\\<cdot>x) = f'\\<cdot>(unwrap\\<cdot>(wrap\\<cdot>z))\\<cdot>x\"\n  shows \"sscanl\\<cdot>f\\<cdot>z\\<cdot>xs = smap\\<cdot>wrap\\<cdot>(sscanl\\<cdot>f'\\<cdot>(unwrap\\<cdot>z)\\<cdot>xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sscanl\\<cdot>f\\<cdot>z\\<cdot>xs =\n    smap\\<cdot>wrap\\<cdot>(sscanl\\<cdot>f'\\<cdot>(unwrap\\<cdot>z)\\<cdot>xs)", "using assms"], ["proof (prove)\nusing this:\n  wrap oo unwrap = ID\n  ?x \\<noteq> \\<bottom> \\<Longrightarrow>\n  unwrap\\<cdot>(f\\<cdot>(wrap\\<cdot>?z)\\<cdot>?x) =\n  f'\\<cdot>(unwrap\\<cdot>(wrap\\<cdot>?z))\\<cdot>?x\n\ngoal (1 subgoal):\n 1. sscanl\\<cdot>f\\<cdot>z\\<cdot>xs =\n    smap\\<cdot>wrap\\<cdot>(sscanl\\<cdot>f'\\<cdot>(unwrap\\<cdot>z)\\<cdot>xs)", "by (induct xs arbitrary: z) (simp add: cfun_eq_iff retraction_cfcomp_strict | metis)+"], ["", "lemma sscanl_ww_fusion: \\<comment>\\<open> Worker/wrapper @{cite [cite_macro=citep] \"GillHutton:2009\" and \"Gammie:2011\"} specialised to @{const \\<open>sscanl\\<close>} \\<close>\n  fixes wrap :: \"'b \\<rightarrow> 'a\"\n  fixes unwrap :: \"'a \\<rightarrow> 'b\"\n  fixes z :: \"'a\"\n  fixes f :: \"'a \\<rightarrow> 'c \\<rightarrow> 'a\"\n  fixes f' :: \"'b \\<rightarrow> 'c \\<rightarrow> 'b\"\n  assumes ww: \"wrap oo unwrap = ID\"\n  assumes wb: \"\\<And>z x. x \\<noteq> \\<bottom> \\<Longrightarrow> unwrap\\<cdot>(f\\<cdot>(wrap\\<cdot>z)\\<cdot>x) = f'\\<cdot>(unwrap\\<cdot>(wrap\\<cdot>z))\\<cdot>x\"\n  shows \"sscanl\\<cdot>f\\<cdot>z = smap\\<cdot>wrap oo sscanl\\<cdot>f'\\<cdot>(unwrap\\<cdot>z)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sscanl\\<cdot>f\\<cdot>z =\n    smap\\<cdot>wrap oo sscanl\\<cdot>f'\\<cdot>(unwrap\\<cdot>z)", "using assms"], ["proof (prove)\nusing this:\n  wrap oo unwrap = ID\n  ?x \\<noteq> \\<bottom> \\<Longrightarrow>\n  unwrap\\<cdot>(f\\<cdot>(wrap\\<cdot>?z)\\<cdot>?x) =\n  f'\\<cdot>(unwrap\\<cdot>(wrap\\<cdot>?z))\\<cdot>?x\n\ngoal (1 subgoal):\n 1. sscanl\\<cdot>f\\<cdot>z =\n    smap\\<cdot>wrap oo sscanl\\<cdot>f'\\<cdot>(unwrap\\<cdot>z)", "by (clarsimp simp: cfun_eq_iff sscanl_ww_fusion')"], ["", "fixrec sinits :: \"[:'a:] \\<rightarrow> [:[:'a:]:]\" where\n  \"sinits\\<cdot>[::] = [::] :# [::]\"\n| \"\\<lbrakk>x \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>\\<rbrakk> \\<Longrightarrow> sinits\\<cdot>(x :# xs) = [::] :# smap\\<cdot>(scons\\<cdot>x)\\<cdot>(sinits\\<cdot>xs)\""], ["", "lemma sinits_strict[simp]: \"sinits\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinits\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "lemma sinits_bottom_iff[simp]: \"(sinits\\<cdot>xs = \\<bottom>) \\<longleftrightarrow> (xs = \\<bottom>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sinits\\<cdot>xs = \\<bottom>) = (xs = \\<bottom>)", "by (induct xs) simp_all"], ["", "lemma sinits_not_snil[iff]: \"sinits\\<cdot>xs \\<noteq> [::]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinits\\<cdot>xs \\<noteq> [::]", "by (cases xs) simp_all"], ["", "lemma sinits_empty_bottom[simp]: \"(sset (sinits\\<cdot>xs) = {}) \\<longleftrightarrow> (xs = \\<bottom>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sset (sinits\\<cdot>xs) = {}) = (xs = \\<bottom>)", "by (cases xs) simp_all"], ["", "lemma sinits_scons[simp]: \"sinits\\<cdot>(x :# xs) = [::] :# smap\\<cdot>(x :#)\\<cdot>(sinits\\<cdot>xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinits\\<cdot>(x :# xs) =\n    [::] :# smap\\<cdot>(x:#)\\<cdot>(sinits\\<cdot>xs)", "by (cases \"x = \\<bottom>\", force) (induct xs; force)"], ["", "lemma sinits_length[simp]: \"slength\\<cdot>(sinits\\<cdot>xs) = slength\\<cdot>xs + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slength\\<cdot>(sinits\\<cdot>xs) = slength\\<cdot>xs + 1", "by (induct xs) simp_all"], ["", "lemma sinits_snoc[simp]: \"sinits\\<cdot>(xs :@ [:x:]) = sinits\\<cdot>xs :@ [:xs :@ [:x:]:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinits\\<cdot>(xs :@ [:x:]) = sinits\\<cdot>xs :@ [:xs :@ [:x:]:]", "by (induct xs) simp_all"], ["", "lemma sinits_foldr': \\<comment>\\<open> @{cite [cite_macro=citet] \\<open>p30\\<close> \"Bird:1987\"} \\<close>\n  shows \"sinits\\<cdot>xs = sfoldr\\<cdot>(\\<Lambda> x xs. [:[::]:] :@ smap\\<cdot>(x :#)\\<cdot>xs)\\<cdot>[:[::]:]\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinits\\<cdot>xs =\n    sfoldr\\<cdot>\n    (\\<Lambda> x xs. [:[::]:] :@ smap\\<cdot>(x:#)\\<cdot>xs)\\<cdot>\n    [:[::]:]\\<cdot>\n    xs", "by (induct xs) simp_all"], ["", "lemma sinits_sscanl':\n  shows \"smap\\<cdot>(sfoldl\\<cdot>f\\<cdot>z)\\<cdot>(sinits\\<cdot>xs) = sscanl\\<cdot>f\\<cdot>z\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap\\<cdot>(sfoldl\\<cdot>f\\<cdot>z)\\<cdot>(sinits\\<cdot>xs) =\n    sscanl\\<cdot>f\\<cdot>z\\<cdot>xs", "by (induct xs arbitrary: z) (simp_all cong: smap_cong add: oo_def eta_cfun)"], ["", "lemma sinits_sscanl: \\<comment>\\<open> @{cite [cite_macro=citet] \\<open>Lemma~5\\<close> \"Bird:1987\"}, @{cite [cite_macro=citet] \\<open>p118 ``the scan lemma''\\<close> \"Bird:PearlsofFAD:2010\"} \\<close>\n  shows \"smap\\<cdot>(sfoldl\\<cdot>f\\<cdot>z) oo sinits = sscanl\\<cdot>f\\<cdot>z\""], ["proof (prove)\ngoal (1 subgoal):\n 1. smap\\<cdot>(sfoldl\\<cdot>f\\<cdot>z) oo sinits = sscanl\\<cdot>f\\<cdot>z", "by (simp add: sinits_sscanl' cfun_eq_iff)"], ["", "lemma sinits_all[simp]: \"(xs \\<in> sset (sinits\\<cdot>xs)) \\<longleftrightarrow> (xs \\<noteq> \\<bottom>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs \\<in> sset (sinits\\<cdot>xs)) = (xs \\<noteq> \\<bottom>)", "by (induct xs) simp_all"], ["", "fixrec stails :: \"[:'a:] \\<rightarrow> [:[:'a:]:]\" where\n  \"stails\\<cdot>[::] = [::] :# [::]\"\n| \"\\<lbrakk>x \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>\\<rbrakk> \\<Longrightarrow> stails\\<cdot>(x :# xs) = (x :# xs) :# stails\\<cdot>xs\""], ["", "lemma stails_strict[simp]: \"stails\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stails\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "lemma stails_bottom_iff[simp]: \"(stails\\<cdot>xs = \\<bottom>) \\<longleftrightarrow> (xs = \\<bottom>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (stails\\<cdot>xs = \\<bottom>) = (xs = \\<bottom>)", "by (induct xs) simp_all"], ["", "lemma stails_not_snil[iff]: \"stails\\<cdot>xs \\<noteq> [::]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stails\\<cdot>xs \\<noteq> [::]", "by (cases xs) simp_all"], ["", "lemma stails_scons[simp]: \"stails\\<cdot>(x :# xs) = (x :# xs) :# stails\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stails\\<cdot>(x :# xs) = (x :# xs) :# stails\\<cdot>xs", "by (induct xs) (cases \"x = \\<bottom>\"; simp)+"], ["", "lemma stails_slength[simp]: \"slength\\<cdot>(stails\\<cdot>xs) = slength\\<cdot>xs + 1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slength\\<cdot>(stails\\<cdot>xs) = slength\\<cdot>xs + 1", "by (induct xs) simp_all"], ["", "lemma stails_snoc[simp]:\n  shows \"stails\\<cdot>(xs :@ [:x:]) = smap\\<cdot>(\\<Lambda> ys. ys :@ [:x:])\\<cdot>(stails\\<cdot>xs) :@ [:[::]:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stails\\<cdot>(xs :@ [:x:]) =\n    smap\\<cdot>(\\<Lambda> ys. ys :@ [:x:])\\<cdot>(stails\\<cdot>xs) :@\n    [:[::]:]", "by (induct xs) simp_all"], ["", "lemma stails_sfoldl':\n  shows \"stails\\<cdot>xs = sfoldl\\<cdot>(\\<Lambda> xs x. smap\\<cdot>(\\<Lambda> ys. ys :@ [:x:])\\<cdot>xs :@ [:[::]:])\\<cdot>[:[::]:]\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stails\\<cdot>xs =\n    sfoldl\\<cdot>\n    (\\<Lambda> xs x.\n        smap\\<cdot>(\\<Lambda> ys. ys :@ [:x:])\\<cdot>xs :@ [:[::]:])\\<cdot>\n    [:[::]:]\\<cdot>\n    xs", "by (induct xs rule: srev_induct) simp_all"], ["", "lemma stails_sfoldl:\n  shows \"stails = sfoldl\\<cdot>(\\<Lambda> xs x. smap\\<cdot>(\\<Lambda> ys. ys :@ [:x:])\\<cdot>xs :@ [:[::]:])\\<cdot>[:[::]:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stails =\n    sfoldl\\<cdot>\n    (\\<Lambda> xs x.\n        smap\\<cdot>(\\<Lambda> ys. ys :@ [:x:])\\<cdot>xs :@ [:[::]:])\\<cdot>\n    [:[::]:]", "by (clarsimp simp: cfun_eq_iff stails_sfoldl')"], ["", "lemma stails_all[simp]: \"(xs \\<in> sset (stails\\<cdot>xs)) \\<longleftrightarrow> (xs \\<noteq> \\<bottom>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (xs \\<in> sset (stails\\<cdot>xs)) = (xs \\<noteq> \\<bottom>)", "by (cases xs) simp_all"], ["", "fixrec selem :: \"'a::Eq_def \\<rightarrow> [:'a:] \\<rightarrow> tr\" where\n  \"selem\\<cdot>x\\<cdot>[::] = FF\"\n| \"\\<lbrakk>y \\<noteq> \\<bottom>; ys \\<noteq> \\<bottom>\\<rbrakk> \\<Longrightarrow> selem\\<cdot>x\\<cdot>(y :# ys) = (eq\\<cdot>x\\<cdot>y orelse selem\\<cdot>x\\<cdot>ys)\""], ["", "lemma selem_strict[simp]: \"selem\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. selem\\<cdot>x\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "lemma selem_bottom_iff[simp]: \"(selem\\<cdot>x\\<cdot>xs = \\<bottom>) \\<longleftrightarrow> (xs = \\<bottom> \\<or> (xs \\<noteq> [::] \\<and> x = \\<bottom>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (selem\\<cdot>x\\<cdot>xs = \\<bottom>) =\n    (xs = \\<bottom> \\<or> xs \\<noteq> [::] \\<and> x = \\<bottom>)", "by (induct xs) auto"], ["", "lemma selem_sappend[simp]:\n  assumes \"ys \\<noteq> \\<bottom>\"\n  shows \"selem\\<cdot>x\\<cdot>(xs :@ ys) = (selem\\<cdot>x\\<cdot>xs orelse selem\\<cdot>x\\<cdot>ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. selem\\<cdot>x\\<cdot>(xs :@ ys) =\n    (selem\\<cdot>x\\<cdot>xs orelse selem\\<cdot>x\\<cdot>ys)", "using assms"], ["proof (prove)\nusing this:\n  ys \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. selem\\<cdot>x\\<cdot>(xs :@ ys) =\n    (selem\\<cdot>x\\<cdot>xs orelse selem\\<cdot>x\\<cdot>ys)", "by (induct xs) simp_all"], ["", "lemma elem_TT[simp]: \"(selem\\<cdot>x\\<cdot>xs = TT) \\<longleftrightarrow> (x \\<in> sset xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (selem\\<cdot>x\\<cdot>xs = TT) = (x \\<in> sset xs)", "by (induct xs; auto) (metis sset_defined)+"], ["", "lemma elem_FF[simp]: \"(selem\\<cdot>x\\<cdot>xs = FF) \\<longleftrightarrow> (xs = [::] \\<or> (x \\<noteq> \\<bottom> \\<and> xs \\<noteq> \\<bottom> \\<and> x \\<notin> sset xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (selem\\<cdot>x\\<cdot>xs = FF) =\n    (xs = [::] \\<or>\n     x \\<noteq> \\<bottom> \\<and>\n     xs \\<noteq> \\<bottom> \\<and> x \\<notin> sset xs)", "by (induct xs) auto"], ["", "lemma selem_snil_stails[iff]:\n  assumes \"xs \\<noteq> \\<bottom>\"\n  shows \"selem\\<cdot>[::]\\<cdot>(stails\\<cdot>xs) = TT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. selem\\<cdot>[::]\\<cdot>(stails\\<cdot>xs) = TT", "using assms"], ["proof (prove)\nusing this:\n  xs \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. selem\\<cdot>[::]\\<cdot>(stails\\<cdot>xs) = TT", "by (induct xs) simp_all"], ["", "fixrec sconcatMap :: \"('a \\<rightarrow> [:'b:]) \\<rightarrow> [:'a:] \\<rightarrow> [:'b:]\" where\n[simp del]: \"sconcatMap\\<cdot>f = sconcat oo smap\\<cdot>f\""], ["", "lemma sconcatMap_strict[simp]: \"sconcatMap\\<cdot>f\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sconcatMap\\<cdot>f\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "lemma sconcatMap_snil[simp]: \"sconcatMap\\<cdot>f\\<cdot>[::] = [::]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sconcatMap\\<cdot>f\\<cdot>[::] = [::]", "by fixrec_simp"], ["", "lemma sconcatMap_scons[simp]: \"x \\<noteq> \\<bottom> \\<Longrightarrow> sconcatMap\\<cdot>f\\<cdot>(x :# xs) = f\\<cdot>x :@ sconcatMap\\<cdot>f\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> \\<bottom> \\<Longrightarrow>\n    sconcatMap\\<cdot>f\\<cdot>(x :# xs) =\n    f\\<cdot>x :@ sconcatMap\\<cdot>f\\<cdot>xs", "by (cases \"xs = \\<bottom>\"; simp add: sconcatMap.unfold)"], ["", "lemma sconcatMap_bottom_iff[simp]: \"(sconcatMap\\<cdot>f\\<cdot>xs = \\<bottom>) \\<longleftrightarrow> (xs = \\<bottom> \\<or> (\\<exists>x\\<in>sset xs. f\\<cdot>x = \\<bottom>))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (sconcatMap\\<cdot>f\\<cdot>xs = \\<bottom>) =\n    (xs = \\<bottom> \\<or> (\\<exists>x\\<in>sset xs. f\\<cdot>x = \\<bottom>))", "by (induct xs) simp_all"], ["", "lemma sconcatMap_sappend[simp]: \"sconcatMap\\<cdot>f\\<cdot>(xs :@ ys) = sconcatMap\\<cdot>f\\<cdot>xs :@ sconcatMap\\<cdot>f\\<cdot>ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sconcatMap\\<cdot>f\\<cdot>(xs :@ ys) =\n    sconcatMap\\<cdot>f\\<cdot>xs :@ sconcatMap\\<cdot>f\\<cdot>ys", "by (induct xs) simp_all"], ["", "lemma sconcatMap_monad_laws:\n  \"sconcatMap\\<cdot>(\\<Lambda> x. [:x:])\\<cdot>xs = xs\"\n  \"sconcatMap\\<cdot>g\\<cdot>(sconcatMap\\<cdot>f\\<cdot>xs) = sconcatMap\\<cdot>(\\<Lambda> x. sconcatMap\\<cdot>g\\<cdot>(f\\<cdot>x))\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sconcatMap\\<cdot>(:#[::])\\<cdot>xs = xs &&&\n    sconcatMap\\<cdot>g\\<cdot>(sconcatMap\\<cdot>f\\<cdot>xs) =\n    sconcatMap\\<cdot>\n    (\\<Lambda> x. sconcatMap\\<cdot>g\\<cdot>(f\\<cdot>x))\\<cdot>\n    xs", "by (induct xs) simp_all"], ["", "fixrec supto :: \"Integer \\<rightarrow> Integer \\<rightarrow> [:Integer:]\" where\n  [simp del]: \"supto\\<cdot>i\\<cdot>j = If le\\<cdot>i\\<cdot>j then i :# supto\\<cdot>(i+1)\\<cdot>j else [::]\""], ["", "lemma upto_strict[simp]:\n  \"supto\\<cdot>\\<bottom> = \\<bottom>\"\n  \"supto\\<cdot>m\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supto\\<cdot>\\<bottom> = \\<bottom> &&&\n    supto\\<cdot>m\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp+"], ["", "lemma supto_is_snil_conv[simp]:\n  \"(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) = [::]) \\<longleftrightarrow> (j < i)\"\n  \"([::] = supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) \\<longleftrightarrow> (j < i)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) = [::]) = (j < i) &&&\n    ([::] = supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) = (j < i)", "by (subst supto.unfold; simp)+"], ["", "lemma supto_simp[simp]:\n  \"j < i \\<Longrightarrow> supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) = [::]\"\n  \"i \\<le> j \\<Longrightarrow> supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) = MkI\\<cdot>i :# supto\\<cdot>(MkI\\<cdot>i+1)\\<cdot>(MkI\\<cdot>j)\"\n  \"supto\\<cdot>0\\<cdot>0 = [:0:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (j < i \\<Longrightarrow>\n     supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) = [::]) &&&\n    (i \\<le> j \\<Longrightarrow>\n     supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) =\n     MkI\\<cdot>i :# supto\\<cdot>(MkI\\<cdot>i + 1)\\<cdot>(MkI\\<cdot>j)) &&&\n    supto\\<cdot>0\\<cdot>0 = [:0:]", "by (subst supto.simps, simp)+"], ["", "lemma supto_defined[simp]: \"supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>\" (is \"?P i j\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>", "proof (cases \"j - i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       j - i = int n \\<Longrightarrow>\n       supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>\n 2. \\<And>n.\n       j - i = - int (Suc n) \\<Longrightarrow>\n       supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>", "fix d"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       j - i = int n \\<Longrightarrow>\n       supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>\n 2. \\<And>n.\n       j - i = - int (Suc n) \\<Longrightarrow>\n       supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>", "assume \"j - i = int d\""], ["proof (state)\nthis:\n  j - i = int d\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       j - i = int n \\<Longrightarrow>\n       supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>\n 2. \\<And>n.\n       j - i = - int (Suc n) \\<Longrightarrow>\n       supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>", "then"], ["proof (chain)\npicking this:\n  j - i = int d", "show \"?P i j\""], ["proof (prove)\nusing this:\n  j - i = int d\n\ngoal (1 subgoal):\n 1. supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>", "proof (induct d arbitrary: i j)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       j - i = int 0 \\<Longrightarrow>\n       supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>\n 2. \\<And>d i j.\n       \\<lbrakk>\\<And>i j.\n                   j - i = int d \\<Longrightarrow>\n                   supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq>\n                   \\<bottom>;\n        j - i = int (Suc d)\\<rbrakk>\n       \\<Longrightarrow> supto\\<cdot>(MkI\\<cdot>i)\\<cdot>\n                         (MkI\\<cdot>j) \\<noteq>\n                         \\<bottom>", "case (Suc d i j)"], ["proof (state)\nthis:\n  ?j - ?i = int d \\<Longrightarrow>\n  supto\\<cdot>(MkI\\<cdot>?i)\\<cdot>(MkI\\<cdot>?j) \\<noteq> \\<bottom>\n  j - i = int (Suc d)\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       j - i = int 0 \\<Longrightarrow>\n       supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>\n 2. \\<And>d i j.\n       \\<lbrakk>\\<And>i j.\n                   j - i = int d \\<Longrightarrow>\n                   supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq>\n                   \\<bottom>;\n        j - i = int (Suc d)\\<rbrakk>\n       \\<Longrightarrow> supto\\<cdot>(MkI\\<cdot>i)\\<cdot>\n                         (MkI\\<cdot>j) \\<noteq>\n                         \\<bottom>", "then"], ["proof (chain)\npicking this:\n  ?j - ?i = int d \\<Longrightarrow>\n  supto\\<cdot>(MkI\\<cdot>?i)\\<cdot>(MkI\\<cdot>?j) \\<noteq> \\<bottom>\n  j - i = int (Suc d)", "have \"j - (i + 1) = int d\" and le: \"i \\<le> j\""], ["proof (prove)\nusing this:\n  ?j - ?i = int d \\<Longrightarrow>\n  supto\\<cdot>(MkI\\<cdot>?i)\\<cdot>(MkI\\<cdot>?j) \\<noteq> \\<bottom>\n  j - i = int (Suc d)\n\ngoal (1 subgoal):\n 1. j - (i + 1) = int d &&& i \\<le> j", "by simp_all"], ["proof (state)\nthis:\n  j - (i + 1) = int d\n  i \\<le> j\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       j - i = int 0 \\<Longrightarrow>\n       supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>\n 2. \\<And>d i j.\n       \\<lbrakk>\\<And>i j.\n                   j - i = int d \\<Longrightarrow>\n                   supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq>\n                   \\<bottom>;\n        j - i = int (Suc d)\\<rbrakk>\n       \\<Longrightarrow> supto\\<cdot>(MkI\\<cdot>i)\\<cdot>\n                         (MkI\\<cdot>j) \\<noteq>\n                         \\<bottom>", "from Suc(1)[OF this(1)]"], ["proof (chain)\npicking this:\n  supto\\<cdot>(MkI\\<cdot>(i + 1))\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>", "have IH: \"?P (i+1) j\""], ["proof (prove)\nusing this:\n  supto\\<cdot>(MkI\\<cdot>(i + 1))\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. supto\\<cdot>(MkI\\<cdot>(i + 1))\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>", "."], ["proof (state)\nthis:\n  supto\\<cdot>(MkI\\<cdot>(i + 1))\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       j - i = int 0 \\<Longrightarrow>\n       supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>\n 2. \\<And>d i j.\n       \\<lbrakk>\\<And>i j.\n                   j - i = int d \\<Longrightarrow>\n                   supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq>\n                   \\<bottom>;\n        j - i = int (Suc d)\\<rbrakk>\n       \\<Longrightarrow> supto\\<cdot>(MkI\\<cdot>i)\\<cdot>\n                         (MkI\\<cdot>j) \\<noteq>\n                         \\<bottom>", "then"], ["proof (chain)\npicking this:\n  supto\\<cdot>(MkI\\<cdot>(i + 1))\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>", "show ?case"], ["proof (prove)\nusing this:\n  supto\\<cdot>(MkI\\<cdot>(i + 1))\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>", "using le"], ["proof (prove)\nusing this:\n  supto\\<cdot>(MkI\\<cdot>(i + 1))\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>", "by (simp add: one_Integer_def)"], ["proof (state)\nthis:\n  supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       j - i = int 0 \\<Longrightarrow>\n       supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>", "qed (simp add: one_Integer_def)"], ["proof (state)\nthis:\n  supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       j - i = - int (Suc n) \\<Longrightarrow>\n       supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       j - i = - int (Suc n) \\<Longrightarrow>\n       supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>", "fix d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       j - i = - int (Suc n) \\<Longrightarrow>\n       supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>", "assume \"j - i = - int d\""], ["proof (state)\nthis:\n  j - i = - int d\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       j - i = - int (Suc n) \\<Longrightarrow>\n       supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>", "then"], ["proof (chain)\npicking this:\n  j - i = - int d", "have \"j \\<le> i\""], ["proof (prove)\nusing this:\n  j - i = - int d\n\ngoal (1 subgoal):\n 1. j \\<le> i", "by auto"], ["proof (state)\nthis:\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       j - i = - int (Suc n) \\<Longrightarrow>\n       supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>", "moreover"], ["proof (state)\nthis:\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       j - i = - int (Suc n) \\<Longrightarrow>\n       supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>", "{"], ["proof (state)\nthis:\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       j - i = - int (Suc n) \\<Longrightarrow>\n       supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>", "assume \"j = i\""], ["proof (state)\nthis:\n  j = i\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       j - i = - int (Suc n) \\<Longrightarrow>\n       supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>", "then"], ["proof (chain)\npicking this:\n  j = i", "have \"?P i j\""], ["proof (prove)\nusing this:\n  j = i\n\ngoal (1 subgoal):\n 1. supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>", "by (simp add: one_Integer_def)"], ["proof (state)\nthis:\n  supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       j - i = - int (Suc n) \\<Longrightarrow>\n       supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>", "}"], ["proof (state)\nthis:\n  j = i \\<Longrightarrow>\n  supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       j - i = - int (Suc n) \\<Longrightarrow>\n       supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>", "moreover"], ["proof (state)\nthis:\n  j = i \\<Longrightarrow>\n  supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       j - i = - int (Suc n) \\<Longrightarrow>\n       supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>", "{"], ["proof (state)\nthis:\n  j = i \\<Longrightarrow>\n  supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       j - i = - int (Suc n) \\<Longrightarrow>\n       supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>", "assume \"j < i\""], ["proof (state)\nthis:\n  j < i\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       j - i = - int (Suc n) \\<Longrightarrow>\n       supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>", "then"], ["proof (chain)\npicking this:\n  j < i", "have \"?P i j\""], ["proof (prove)\nusing this:\n  j < i\n\ngoal (1 subgoal):\n 1. supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>", "by (simp add: one_Integer_def)"], ["proof (state)\nthis:\n  supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       j - i = - int (Suc n) \\<Longrightarrow>\n       supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>", "}"], ["proof (state)\nthis:\n  j < i \\<Longrightarrow>\n  supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       j - i = - int (Suc n) \\<Longrightarrow>\n       supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>", "ultimately"], ["proof (chain)\npicking this:\n  j \\<le> i\n  j = i \\<Longrightarrow>\n  supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>\n  j < i \\<Longrightarrow>\n  supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>", "show ?thesis"], ["proof (prove)\nusing this:\n  j \\<le> i\n  j = i \\<Longrightarrow>\n  supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>\n  j < i \\<Longrightarrow>\n  supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>", "by arith"], ["proof (state)\nthis:\n  supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) \\<noteq> \\<bottom>\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma supto_bottom_iff[simp]:\n  \"(supto\\<cdot>i\\<cdot>j = \\<bottom>) \\<longleftrightarrow> (i = \\<bottom> \\<or> j = \\<bottom>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (supto\\<cdot>i\\<cdot>j = \\<bottom>) =\n    (i = \\<bottom> \\<or> j = \\<bottom>)", "by (cases i; simp; cases j; simp)"], ["", "lemma supto_snoc[simp]:\n  \"i \\<le> j \\<Longrightarrow> supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) = supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j-1) :@ [:MkI\\<cdot>j:]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. i \\<le> j \\<Longrightarrow>\n    supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) =\n    supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j - 1) :@ [:MkI\\<cdot>j:]", "proof(induct \"nat(j - i)\" arbitrary: i j)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>0 = nat (j - i); i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) =\n                         supto\\<cdot>(MkI\\<cdot>i)\\<cdot>\n                         (MkI\\<cdot>j - 1) :@\n                         [:MkI\\<cdot>j:]\n 2. \\<And>x i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>x = nat (j - i); i \\<le> j\\<rbrakk>\n                   \\<Longrightarrow> supto\\<cdot>(MkI\\<cdot>i)\\<cdot>\n                                     (MkI\\<cdot>j) =\n                                     supto\\<cdot>(MkI\\<cdot>i)\\<cdot>\n                                     (MkI\\<cdot>j - 1) :@\n                                     [:MkI\\<cdot>j:];\n        Suc x = nat (j - i); i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) =\n                         supto\\<cdot>(MkI\\<cdot>i)\\<cdot>\n                         (MkI\\<cdot>j - 1) :@\n                         [:MkI\\<cdot>j:]", "case 0"], ["proof (state)\nthis:\n  0 = nat (j - i)\n  i \\<le> j\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       \\<lbrakk>0 = nat (j - i); i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) =\n                         supto\\<cdot>(MkI\\<cdot>i)\\<cdot>\n                         (MkI\\<cdot>j - 1) :@\n                         [:MkI\\<cdot>j:]\n 2. \\<And>x i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>x = nat (j - i); i \\<le> j\\<rbrakk>\n                   \\<Longrightarrow> supto\\<cdot>(MkI\\<cdot>i)\\<cdot>\n                                     (MkI\\<cdot>j) =\n                                     supto\\<cdot>(MkI\\<cdot>i)\\<cdot>\n                                     (MkI\\<cdot>j - 1) :@\n                                     [:MkI\\<cdot>j:];\n        Suc x = nat (j - i); i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) =\n                         supto\\<cdot>(MkI\\<cdot>i)\\<cdot>\n                         (MkI\\<cdot>j - 1) :@\n                         [:MkI\\<cdot>j:]", "then"], ["proof (chain)\npicking this:\n  0 = nat (j - i)\n  i \\<le> j", "show ?case"], ["proof (prove)\nusing this:\n  0 = nat (j - i)\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) =\n    supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j - 1) :@ [:MkI\\<cdot>j:]", "by (simp add: one_Integer_def)"], ["proof (state)\nthis:\n  supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) =\n  supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j - 1) :@ [:MkI\\<cdot>j:]\n\ngoal (1 subgoal):\n 1. \\<And>x i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>x = nat (j - i); i \\<le> j\\<rbrakk>\n                   \\<Longrightarrow> supto\\<cdot>(MkI\\<cdot>i)\\<cdot>\n                                     (MkI\\<cdot>j) =\n                                     supto\\<cdot>(MkI\\<cdot>i)\\<cdot>\n                                     (MkI\\<cdot>j - 1) :@\n                                     [:MkI\\<cdot>j:];\n        Suc x = nat (j - i); i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) =\n                         supto\\<cdot>(MkI\\<cdot>i)\\<cdot>\n                         (MkI\\<cdot>j - 1) :@\n                         [:MkI\\<cdot>j:]", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>x = nat (j - i); i \\<le> j\\<rbrakk>\n                   \\<Longrightarrow> supto\\<cdot>(MkI\\<cdot>i)\\<cdot>\n                                     (MkI\\<cdot>j) =\n                                     supto\\<cdot>(MkI\\<cdot>i)\\<cdot>\n                                     (MkI\\<cdot>j - 1) :@\n                                     [:MkI\\<cdot>j:];\n        Suc x = nat (j - i); i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) =\n                         supto\\<cdot>(MkI\\<cdot>i)\\<cdot>\n                         (MkI\\<cdot>j - 1) :@\n                         [:MkI\\<cdot>j:]", "case (Suc k i j)"], ["proof (state)\nthis:\n  \\<lbrakk>k = nat (?j - ?i); ?i \\<le> ?j\\<rbrakk>\n  \\<Longrightarrow> supto\\<cdot>(MkI\\<cdot>?i)\\<cdot>(MkI\\<cdot>?j) =\n                    supto\\<cdot>(MkI\\<cdot>?i)\\<cdot>(MkI\\<cdot>?j - 1) :@\n                    [:MkI\\<cdot>?j:]\n  Suc k = nat (j - i)\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. \\<And>x i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>x = nat (j - i); i \\<le> j\\<rbrakk>\n                   \\<Longrightarrow> supto\\<cdot>(MkI\\<cdot>i)\\<cdot>\n                                     (MkI\\<cdot>j) =\n                                     supto\\<cdot>(MkI\\<cdot>i)\\<cdot>\n                                     (MkI\\<cdot>j - 1) :@\n                                     [:MkI\\<cdot>j:];\n        Suc x = nat (j - i); i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) =\n                         supto\\<cdot>(MkI\\<cdot>i)\\<cdot>\n                         (MkI\\<cdot>j - 1) :@\n                         [:MkI\\<cdot>j:]", "then"], ["proof (chain)\npicking this:\n  \\<lbrakk>k = nat (?j - ?i); ?i \\<le> ?j\\<rbrakk>\n  \\<Longrightarrow> supto\\<cdot>(MkI\\<cdot>?i)\\<cdot>(MkI\\<cdot>?j) =\n                    supto\\<cdot>(MkI\\<cdot>?i)\\<cdot>(MkI\\<cdot>?j - 1) :@\n                    [:MkI\\<cdot>?j:]\n  Suc k = nat (j - i)\n  i \\<le> j", "have \"k = nat (j - (i + 1))\" \"i < j\""], ["proof (prove)\nusing this:\n  \\<lbrakk>k = nat (?j - ?i); ?i \\<le> ?j\\<rbrakk>\n  \\<Longrightarrow> supto\\<cdot>(MkI\\<cdot>?i)\\<cdot>(MkI\\<cdot>?j) =\n                    supto\\<cdot>(MkI\\<cdot>?i)\\<cdot>(MkI\\<cdot>?j - 1) :@\n                    [:MkI\\<cdot>?j:]\n  Suc k = nat (j - i)\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. k = nat (j - (i + 1)) &&& i < j", "by linarith+"], ["proof (state)\nthis:\n  k = nat (j - (i + 1))\n  i < j\n\ngoal (1 subgoal):\n 1. \\<And>x i j.\n       \\<lbrakk>\\<And>i j.\n                   \\<lbrakk>x = nat (j - i); i \\<le> j\\<rbrakk>\n                   \\<Longrightarrow> supto\\<cdot>(MkI\\<cdot>i)\\<cdot>\n                                     (MkI\\<cdot>j) =\n                                     supto\\<cdot>(MkI\\<cdot>i)\\<cdot>\n                                     (MkI\\<cdot>j - 1) :@\n                                     [:MkI\\<cdot>j:];\n        Suc x = nat (j - i); i \\<le> j\\<rbrakk>\n       \\<Longrightarrow> supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) =\n                         supto\\<cdot>(MkI\\<cdot>i)\\<cdot>\n                         (MkI\\<cdot>j - 1) :@\n                         [:MkI\\<cdot>j:]", "from this(2) Suc.hyps(1)[OF this(1)] Suc(2,3)"], ["proof (chain)\npicking this:\n  i < j\n  i + 1 \\<le> j \\<Longrightarrow>\n  supto\\<cdot>(MkI\\<cdot>(i + 1))\\<cdot>(MkI\\<cdot>j) =\n  supto\\<cdot>(MkI\\<cdot>(i + 1))\\<cdot>(MkI\\<cdot>j - 1) :@ [:MkI\\<cdot>j:]\n  Suc k = nat (j - i)\n  i \\<le> j", "show ?case"], ["proof (prove)\nusing this:\n  i < j\n  i + 1 \\<le> j \\<Longrightarrow>\n  supto\\<cdot>(MkI\\<cdot>(i + 1))\\<cdot>(MkI\\<cdot>j) =\n  supto\\<cdot>(MkI\\<cdot>(i + 1))\\<cdot>(MkI\\<cdot>j - 1) :@ [:MkI\\<cdot>j:]\n  Suc k = nat (j - i)\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) =\n    supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j - 1) :@ [:MkI\\<cdot>j:]", "by (simp add: one_Integer_def)"], ["proof (state)\nthis:\n  supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) =\n  supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j - 1) :@ [:MkI\\<cdot>j:]\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma slength_supto[simp]: \"slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) = MkI\\<cdot>(if j < i then 0 else j - i + 1)\" (is \"?P i j\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n    MkI\\<cdot>(if j < i then 0 else j - i + 1)", "proof (cases \"j - i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       j - i = int n \\<Longrightarrow>\n       slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n       MkI\\<cdot>(if j < i then 0 else j - i + 1)\n 2. \\<And>n.\n       j - i = - int (Suc n) \\<Longrightarrow>\n       slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n       MkI\\<cdot>(if j < i then 0 else j - i + 1)", "fix d"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       j - i = int n \\<Longrightarrow>\n       slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n       MkI\\<cdot>(if j < i then 0 else j - i + 1)\n 2. \\<And>n.\n       j - i = - int (Suc n) \\<Longrightarrow>\n       slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n       MkI\\<cdot>(if j < i then 0 else j - i + 1)", "assume \"j - i = int d\""], ["proof (state)\nthis:\n  j - i = int d\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       j - i = int n \\<Longrightarrow>\n       slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n       MkI\\<cdot>(if j < i then 0 else j - i + 1)\n 2. \\<And>n.\n       j - i = - int (Suc n) \\<Longrightarrow>\n       slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n       MkI\\<cdot>(if j < i then 0 else j - i + 1)", "then"], ["proof (chain)\npicking this:\n  j - i = int d", "show \"?P i j\""], ["proof (prove)\nusing this:\n  j - i = int d\n\ngoal (1 subgoal):\n 1. slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n    MkI\\<cdot>(if j < i then 0 else j - i + 1)", "proof (induct d arbitrary: i j)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       j - i = int 0 \\<Longrightarrow>\n       slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n       MkI\\<cdot>(if j < i then 0 else j - i + 1)\n 2. \\<And>d i j.\n       \\<lbrakk>\\<And>i j.\n                   j - i = int d \\<Longrightarrow>\n                   slength\\<cdot>\n                   (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n                   MkI\\<cdot>(if j < i then 0 else j - i + 1);\n        j - i = int (Suc d)\\<rbrakk>\n       \\<Longrightarrow> slength\\<cdot>\n                         (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n                         MkI\\<cdot>(if j < i then 0 else j - i + 1)", "case (Suc d i j)"], ["proof (state)\nthis:\n  ?j - ?i = int d \\<Longrightarrow>\n  slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>?i)\\<cdot>(MkI\\<cdot>?j)) =\n  MkI\\<cdot>(if ?j < ?i then 0 else ?j - ?i + 1)\n  j - i = int (Suc d)\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       j - i = int 0 \\<Longrightarrow>\n       slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n       MkI\\<cdot>(if j < i then 0 else j - i + 1)\n 2. \\<And>d i j.\n       \\<lbrakk>\\<And>i j.\n                   j - i = int d \\<Longrightarrow>\n                   slength\\<cdot>\n                   (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n                   MkI\\<cdot>(if j < i then 0 else j - i + 1);\n        j - i = int (Suc d)\\<rbrakk>\n       \\<Longrightarrow> slength\\<cdot>\n                         (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n                         MkI\\<cdot>(if j < i then 0 else j - i + 1)", "then"], ["proof (chain)\npicking this:\n  ?j - ?i = int d \\<Longrightarrow>\n  slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>?i)\\<cdot>(MkI\\<cdot>?j)) =\n  MkI\\<cdot>(if ?j < ?i then 0 else ?j - ?i + 1)\n  j - i = int (Suc d)", "have \"j - (i + 1) = int d\" and le: \"i \\<le> j\""], ["proof (prove)\nusing this:\n  ?j - ?i = int d \\<Longrightarrow>\n  slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>?i)\\<cdot>(MkI\\<cdot>?j)) =\n  MkI\\<cdot>(if ?j < ?i then 0 else ?j - ?i + 1)\n  j - i = int (Suc d)\n\ngoal (1 subgoal):\n 1. j - (i + 1) = int d &&& i \\<le> j", "by simp_all"], ["proof (state)\nthis:\n  j - (i + 1) = int d\n  i \\<le> j\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       j - i = int 0 \\<Longrightarrow>\n       slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n       MkI\\<cdot>(if j < i then 0 else j - i + 1)\n 2. \\<And>d i j.\n       \\<lbrakk>\\<And>i j.\n                   j - i = int d \\<Longrightarrow>\n                   slength\\<cdot>\n                   (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n                   MkI\\<cdot>(if j < i then 0 else j - i + 1);\n        j - i = int (Suc d)\\<rbrakk>\n       \\<Longrightarrow> slength\\<cdot>\n                         (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n                         MkI\\<cdot>(if j < i then 0 else j - i + 1)", "from Suc(1)[OF this(1)]"], ["proof (chain)\npicking this:\n  slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>(i + 1))\\<cdot>(MkI\\<cdot>j)) =\n  MkI\\<cdot>(if j < i + 1 then 0 else j - (i + 1) + 1)", "have IH: \"?P (i+1) j\""], ["proof (prove)\nusing this:\n  slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>(i + 1))\\<cdot>(MkI\\<cdot>j)) =\n  MkI\\<cdot>(if j < i + 1 then 0 else j - (i + 1) + 1)\n\ngoal (1 subgoal):\n 1. slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>(i + 1))\\<cdot>(MkI\\<cdot>j)) =\n    MkI\\<cdot>(if j < i + 1 then 0 else j - (i + 1) + 1)", "."], ["proof (state)\nthis:\n  slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>(i + 1))\\<cdot>(MkI\\<cdot>j)) =\n  MkI\\<cdot>(if j < i + 1 then 0 else j - (i + 1) + 1)\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       j - i = int 0 \\<Longrightarrow>\n       slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n       MkI\\<cdot>(if j < i then 0 else j - i + 1)\n 2. \\<And>d i j.\n       \\<lbrakk>\\<And>i j.\n                   j - i = int d \\<Longrightarrow>\n                   slength\\<cdot>\n                   (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n                   MkI\\<cdot>(if j < i then 0 else j - i + 1);\n        j - i = int (Suc d)\\<rbrakk>\n       \\<Longrightarrow> slength\\<cdot>\n                         (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n                         MkI\\<cdot>(if j < i then 0 else j - i + 1)", "then"], ["proof (chain)\npicking this:\n  slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>(i + 1))\\<cdot>(MkI\\<cdot>j)) =\n  MkI\\<cdot>(if j < i + 1 then 0 else j - (i + 1) + 1)", "show ?case"], ["proof (prove)\nusing this:\n  slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>(i + 1))\\<cdot>(MkI\\<cdot>j)) =\n  MkI\\<cdot>(if j < i + 1 then 0 else j - (i + 1) + 1)\n\ngoal (1 subgoal):\n 1. slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n    MkI\\<cdot>(if j < i then 0 else j - i + 1)", "using le"], ["proof (prove)\nusing this:\n  slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>(i + 1))\\<cdot>(MkI\\<cdot>j)) =\n  MkI\\<cdot>(if j < i + 1 then 0 else j - (i + 1) + 1)\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n    MkI\\<cdot>(if j < i then 0 else j - i + 1)", "by (simp add: one_Integer_def)"], ["proof (state)\nthis:\n  slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n  MkI\\<cdot>(if j < i then 0 else j - i + 1)\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       j - i = int 0 \\<Longrightarrow>\n       slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n       MkI\\<cdot>(if j < i then 0 else j - i + 1)", "qed (simp add: one_Integer_def)"], ["proof (state)\nthis:\n  slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n  MkI\\<cdot>(if j < i then 0 else j - i + 1)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       j - i = - int (Suc n) \\<Longrightarrow>\n       slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n       MkI\\<cdot>(if j < i then 0 else j - i + 1)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       j - i = - int (Suc n) \\<Longrightarrow>\n       slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n       MkI\\<cdot>(if j < i then 0 else j - i + 1)", "fix d"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>n.\n       j - i = - int (Suc n) \\<Longrightarrow>\n       slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n       MkI\\<cdot>(if j < i then 0 else j - i + 1)", "assume \"j - i = - int d\""], ["proof (state)\nthis:\n  j - i = - int d\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       j - i = - int (Suc n) \\<Longrightarrow>\n       slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n       MkI\\<cdot>(if j < i then 0 else j - i + 1)", "then"], ["proof (chain)\npicking this:\n  j - i = - int d", "have \"j \\<le> i\""], ["proof (prove)\nusing this:\n  j - i = - int d\n\ngoal (1 subgoal):\n 1. j \\<le> i", "by auto"], ["proof (state)\nthis:\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       j - i = - int (Suc n) \\<Longrightarrow>\n       slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n       MkI\\<cdot>(if j < i then 0 else j - i + 1)", "moreover"], ["proof (state)\nthis:\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       j - i = - int (Suc n) \\<Longrightarrow>\n       slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n       MkI\\<cdot>(if j < i then 0 else j - i + 1)", "{"], ["proof (state)\nthis:\n  j \\<le> i\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       j - i = - int (Suc n) \\<Longrightarrow>\n       slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n       MkI\\<cdot>(if j < i then 0 else j - i + 1)", "assume \"j = i\""], ["proof (state)\nthis:\n  j = i\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       j - i = - int (Suc n) \\<Longrightarrow>\n       slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n       MkI\\<cdot>(if j < i then 0 else j - i + 1)", "then"], ["proof (chain)\npicking this:\n  j = i", "have \"?P i j\""], ["proof (prove)\nusing this:\n  j = i\n\ngoal (1 subgoal):\n 1. slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n    MkI\\<cdot>(if j < i then 0 else j - i + 1)", "by (simp add: one_Integer_def)"], ["proof (state)\nthis:\n  slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n  MkI\\<cdot>(if j < i then 0 else j - i + 1)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       j - i = - int (Suc n) \\<Longrightarrow>\n       slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n       MkI\\<cdot>(if j < i then 0 else j - i + 1)", "}"], ["proof (state)\nthis:\n  j = i \\<Longrightarrow>\n  slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n  MkI\\<cdot>(if j < i then 0 else j - i + 1)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       j - i = - int (Suc n) \\<Longrightarrow>\n       slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n       MkI\\<cdot>(if j < i then 0 else j - i + 1)", "moreover"], ["proof (state)\nthis:\n  j = i \\<Longrightarrow>\n  slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n  MkI\\<cdot>(if j < i then 0 else j - i + 1)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       j - i = - int (Suc n) \\<Longrightarrow>\n       slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n       MkI\\<cdot>(if j < i then 0 else j - i + 1)", "{"], ["proof (state)\nthis:\n  j = i \\<Longrightarrow>\n  slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n  MkI\\<cdot>(if j < i then 0 else j - i + 1)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       j - i = - int (Suc n) \\<Longrightarrow>\n       slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n       MkI\\<cdot>(if j < i then 0 else j - i + 1)", "assume \"j < i\""], ["proof (state)\nthis:\n  j < i\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       j - i = - int (Suc n) \\<Longrightarrow>\n       slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n       MkI\\<cdot>(if j < i then 0 else j - i + 1)", "then"], ["proof (chain)\npicking this:\n  j < i", "have \"?P i j\""], ["proof (prove)\nusing this:\n  j < i\n\ngoal (1 subgoal):\n 1. slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n    MkI\\<cdot>(if j < i then 0 else j - i + 1)", "by (simp add: one_Integer_def)"], ["proof (state)\nthis:\n  slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n  MkI\\<cdot>(if j < i then 0 else j - i + 1)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       j - i = - int (Suc n) \\<Longrightarrow>\n       slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n       MkI\\<cdot>(if j < i then 0 else j - i + 1)", "}"], ["proof (state)\nthis:\n  j < i \\<Longrightarrow>\n  slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n  MkI\\<cdot>(if j < i then 0 else j - i + 1)\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       j - i = - int (Suc n) \\<Longrightarrow>\n       slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n       MkI\\<cdot>(if j < i then 0 else j - i + 1)", "ultimately"], ["proof (chain)\npicking this:\n  j \\<le> i\n  j = i \\<Longrightarrow>\n  slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n  MkI\\<cdot>(if j < i then 0 else j - i + 1)\n  j < i \\<Longrightarrow>\n  slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n  MkI\\<cdot>(if j < i then 0 else j - i + 1)", "show ?thesis"], ["proof (prove)\nusing this:\n  j \\<le> i\n  j = i \\<Longrightarrow>\n  slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n  MkI\\<cdot>(if j < i then 0 else j - i + 1)\n  j < i \\<Longrightarrow>\n  slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n  MkI\\<cdot>(if j < i then 0 else j - i + 1)\n\ngoal (1 subgoal):\n 1. slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n    MkI\\<cdot>(if j < i then 0 else j - i + 1)", "by arith"], ["proof (state)\nthis:\n  slength\\<cdot>(supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n  MkI\\<cdot>(if j < i then 0 else j - i + 1)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma sset_supto[simp]:\n  \"sset (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) = {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j}\" (is \"sset (?u i j) = ?R i j\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. sset (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n    {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j}", "proof (cases \"j - i\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>n.\n       j - i = int n \\<Longrightarrow>\n       sset (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n       {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j}\n 2. \\<And>n.\n       j - i = - int (Suc n) \\<Longrightarrow>\n       sset (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n       {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j}", "case (nonneg k)"], ["proof (state)\nthis:\n  j - i = int k\n\ngoal (2 subgoals):\n 1. \\<And>n.\n       j - i = int n \\<Longrightarrow>\n       sset (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n       {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j}\n 2. \\<And>n.\n       j - i = - int (Suc n) \\<Longrightarrow>\n       sset (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n       {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j}", "then"], ["proof (chain)\npicking this:\n  j - i = int k", "show ?thesis"], ["proof (prove)\nusing this:\n  j - i = int k\n\ngoal (1 subgoal):\n 1. sset (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n    {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j}", "proof (induct k arbitrary: i j)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>i j.\n       j - i = int 0 \\<Longrightarrow>\n       sset (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n       {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j}\n 2. \\<And>k i j.\n       \\<lbrakk>\\<And>i j.\n                   j - i = int k \\<Longrightarrow>\n                   sset (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n                   {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j};\n        j - i = int (Suc k)\\<rbrakk>\n       \\<Longrightarrow> sset\n                          (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n                         {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j}", "case (Suc k)"], ["proof (state)\nthis:\n  ?j - ?i = int k \\<Longrightarrow>\n  sset (supto\\<cdot>(MkI\\<cdot>?i)\\<cdot>(MkI\\<cdot>?j)) =\n  {MkI\\<cdot>k |k. ?i \\<le> k \\<and> k \\<le> ?j}\n  j - i = int (Suc k)\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       j - i = int 0 \\<Longrightarrow>\n       sset (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n       {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j}\n 2. \\<And>k i j.\n       \\<lbrakk>\\<And>i j.\n                   j - i = int k \\<Longrightarrow>\n                   sset (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n                   {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j};\n        j - i = int (Suc k)\\<rbrakk>\n       \\<Longrightarrow> sset\n                          (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n                         {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j}", "then"], ["proof (chain)\npicking this:\n  ?j - ?i = int k \\<Longrightarrow>\n  sset (supto\\<cdot>(MkI\\<cdot>?i)\\<cdot>(MkI\\<cdot>?j)) =\n  {MkI\\<cdot>k |k. ?i \\<le> k \\<and> k \\<le> ?j}\n  j - i = int (Suc k)", "have *: \"j - (i + 1) = int k\""], ["proof (prove)\nusing this:\n  ?j - ?i = int k \\<Longrightarrow>\n  sset (supto\\<cdot>(MkI\\<cdot>?i)\\<cdot>(MkI\\<cdot>?j)) =\n  {MkI\\<cdot>k |k. ?i \\<le> k \\<and> k \\<le> ?j}\n  j - i = int (Suc k)\n\ngoal (1 subgoal):\n 1. j - (i + 1) = int k", "by simp"], ["proof (state)\nthis:\n  j - (i + 1) = int k\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       j - i = int 0 \\<Longrightarrow>\n       sset (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n       {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j}\n 2. \\<And>k i j.\n       \\<lbrakk>\\<And>i j.\n                   j - i = int k \\<Longrightarrow>\n                   sset (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n                   {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j};\n        j - i = int (Suc k)\\<rbrakk>\n       \\<Longrightarrow> sset\n                          (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n                         {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j}", "from Suc(1)[OF *]"], ["proof (chain)\npicking this:\n  sset (supto\\<cdot>(MkI\\<cdot>(i + 1))\\<cdot>(MkI\\<cdot>j)) =\n  {MkI\\<cdot>k |k. i + 1 \\<le> k \\<and> k \\<le> j}", "have IH: \"sset (?u (i+1) j) = ?R (i+1) j\""], ["proof (prove)\nusing this:\n  sset (supto\\<cdot>(MkI\\<cdot>(i + 1))\\<cdot>(MkI\\<cdot>j)) =\n  {MkI\\<cdot>k |k. i + 1 \\<le> k \\<and> k \\<le> j}\n\ngoal (1 subgoal):\n 1. sset (supto\\<cdot>(MkI\\<cdot>(i + 1))\\<cdot>(MkI\\<cdot>j)) =\n    {MkI\\<cdot>k |k. i + 1 \\<le> k \\<and> k \\<le> j}", "."], ["proof (state)\nthis:\n  sset (supto\\<cdot>(MkI\\<cdot>(i + 1))\\<cdot>(MkI\\<cdot>j)) =\n  {MkI\\<cdot>k |k. i + 1 \\<le> k \\<and> k \\<le> j}\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       j - i = int 0 \\<Longrightarrow>\n       sset (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n       {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j}\n 2. \\<And>k i j.\n       \\<lbrakk>\\<And>i j.\n                   j - i = int k \\<Longrightarrow>\n                   sset (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n                   {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j};\n        j - i = int (Suc k)\\<rbrakk>\n       \\<Longrightarrow> sset\n                          (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n                         {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j}", "from *"], ["proof (chain)\npicking this:\n  j - (i + 1) = int k", "have \"i \\<le> j\""], ["proof (prove)\nusing this:\n  j - (i + 1) = int k\n\ngoal (1 subgoal):\n 1. i \\<le> j", "by simp"], ["proof (state)\nthis:\n  i \\<le> j\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       j - i = int 0 \\<Longrightarrow>\n       sset (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n       {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j}\n 2. \\<And>k i j.\n       \\<lbrakk>\\<And>i j.\n                   j - i = int k \\<Longrightarrow>\n                   sset (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n                   {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j};\n        j - i = int (Suc k)\\<rbrakk>\n       \\<Longrightarrow> sset\n                          (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n                         {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j}", "then"], ["proof (chain)\npicking this:\n  i \\<le> j", "have \"sset (?u i j) = sset (MkI\\<cdot>i :# ?u (i+1) j)\""], ["proof (prove)\nusing this:\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. sset (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n    sset\n     (MkI\\<cdot>i :# supto\\<cdot>(MkI\\<cdot>(i + 1))\\<cdot>(MkI\\<cdot>j))", "by (simp add: one_Integer_def)"], ["proof (state)\nthis:\n  sset (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n  sset (MkI\\<cdot>i :# supto\\<cdot>(MkI\\<cdot>(i + 1))\\<cdot>(MkI\\<cdot>j))\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       j - i = int 0 \\<Longrightarrow>\n       sset (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n       {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j}\n 2. \\<And>k i j.\n       \\<lbrakk>\\<And>i j.\n                   j - i = int k \\<Longrightarrow>\n                   sset (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n                   {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j};\n        j - i = int (Suc k)\\<rbrakk>\n       \\<Longrightarrow> sset\n                          (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n                         {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j}", "also"], ["proof (state)\nthis:\n  sset (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n  sset (MkI\\<cdot>i :# supto\\<cdot>(MkI\\<cdot>(i + 1))\\<cdot>(MkI\\<cdot>j))\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       j - i = int 0 \\<Longrightarrow>\n       sset (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n       {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j}\n 2. \\<And>k i j.\n       \\<lbrakk>\\<And>i j.\n                   j - i = int k \\<Longrightarrow>\n                   sset (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n                   {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j};\n        j - i = int (Suc k)\\<rbrakk>\n       \\<Longrightarrow> sset\n                          (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n                         {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j}", "have \"\\<dots> = insert (MkI\\<cdot>i) (?R (i+1) j)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sset\n     (MkI\\<cdot>i :# supto\\<cdot>(MkI\\<cdot>(i + 1))\\<cdot>(MkI\\<cdot>j)) =\n    insert (MkI\\<cdot>i) {MkI\\<cdot>k |k. i + 1 \\<le> k \\<and> k \\<le> j}", "by (simp add: IH)"], ["proof (state)\nthis:\n  sset\n   (MkI\\<cdot>i :# supto\\<cdot>(MkI\\<cdot>(i + 1))\\<cdot>(MkI\\<cdot>j)) =\n  insert (MkI\\<cdot>i) {MkI\\<cdot>k |k. i + 1 \\<le> k \\<and> k \\<le> j}\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       j - i = int 0 \\<Longrightarrow>\n       sset (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n       {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j}\n 2. \\<And>k i j.\n       \\<lbrakk>\\<And>i j.\n                   j - i = int k \\<Longrightarrow>\n                   sset (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n                   {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j};\n        j - i = int (Suc k)\\<rbrakk>\n       \\<Longrightarrow> sset\n                          (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n                         {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j}", "also"], ["proof (state)\nthis:\n  sset\n   (MkI\\<cdot>i :# supto\\<cdot>(MkI\\<cdot>(i + 1))\\<cdot>(MkI\\<cdot>j)) =\n  insert (MkI\\<cdot>i) {MkI\\<cdot>k |k. i + 1 \\<le> k \\<and> k \\<le> j}\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       j - i = int 0 \\<Longrightarrow>\n       sset (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n       {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j}\n 2. \\<And>k i j.\n       \\<lbrakk>\\<And>i j.\n                   j - i = int k \\<Longrightarrow>\n                   sset (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n                   {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j};\n        j - i = int (Suc k)\\<rbrakk>\n       \\<Longrightarrow> sset\n                          (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n                         {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j}", "have \"\\<dots> = ?R i j\""], ["proof (prove)\ngoal (1 subgoal):\n 1. insert (MkI\\<cdot>i) {MkI\\<cdot>k |k. i + 1 \\<le> k \\<and> k \\<le> j} =\n    {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j}", "using \\<open>i \\<le> j\\<close>"], ["proof (prove)\nusing this:\n  i \\<le> j\n\ngoal (1 subgoal):\n 1. insert (MkI\\<cdot>i) {MkI\\<cdot>k |k. i + 1 \\<le> k \\<and> k \\<le> j} =\n    {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j}", "by auto"], ["proof (state)\nthis:\n  insert (MkI\\<cdot>i) {MkI\\<cdot>k |k. i + 1 \\<le> k \\<and> k \\<le> j} =\n  {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j}\n\ngoal (2 subgoals):\n 1. \\<And>i j.\n       j - i = int 0 \\<Longrightarrow>\n       sset (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n       {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j}\n 2. \\<And>k i j.\n       \\<lbrakk>\\<And>i j.\n                   j - i = int k \\<Longrightarrow>\n                   sset (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n                   {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j};\n        j - i = int (Suc k)\\<rbrakk>\n       \\<Longrightarrow> sset\n                          (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n                         {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j}", "finally"], ["proof (chain)\npicking this:\n  sset (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n  {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j}", "show ?case"], ["proof (prove)\nusing this:\n  sset (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n  {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j}\n\ngoal (1 subgoal):\n 1. sset (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n    {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j}", "."], ["proof (state)\nthis:\n  sset (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n  {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j}\n\ngoal (1 subgoal):\n 1. \\<And>i j.\n       j - i = int 0 \\<Longrightarrow>\n       sset (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n       {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j}", "qed (force simp: one_Integer_def)"], ["proof (state)\nthis:\n  sset (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n  {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j}\n\ngoal (1 subgoal):\n 1. \\<And>n.\n       j - i = - int (Suc n) \\<Longrightarrow>\n       sset (supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j)) =\n       {MkI\\<cdot>k |k. i \\<le> k \\<and> k \\<le> j}", "qed simp"], ["", "lemma supto_split1: \\<comment>\\<open>From \\<open>HOL.List\\<close>\\<close>\n  assumes \"i \\<le> j\"\n  assumes \"j \\<le> k\"\n  shows \"supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>k) = supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>(j - 1)) :@ supto\\<cdot>(MkI\\<cdot>j)\\<cdot>(MkI\\<cdot>k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>k) =\n    supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>(j - 1)) :@\n    supto\\<cdot>(MkI\\<cdot>j)\\<cdot>(MkI\\<cdot>k)", "using assms"], ["proof (prove)\nusing this:\n  i \\<le> j\n  j \\<le> k\n\ngoal (1 subgoal):\n 1. supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>k) =\n    supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>(j - 1)) :@\n    supto\\<cdot>(MkI\\<cdot>j)\\<cdot>(MkI\\<cdot>k)", "proof (induct j rule: int_ge_induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. i \\<le> k \\<Longrightarrow>\n    supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>k) =\n    supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>(i - 1)) :@\n    supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>k)\n 2. \\<And>ia.\n       \\<lbrakk>i \\<le> ia;\n        ia \\<le> k \\<Longrightarrow>\n        supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>k) =\n        supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>(ia - 1)) :@\n        supto\\<cdot>(MkI\\<cdot>ia)\\<cdot>(MkI\\<cdot>k);\n        ia + 1 \\<le> k\\<rbrakk>\n       \\<Longrightarrow> supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>k) =\n                         supto\\<cdot>(MkI\\<cdot>i)\\<cdot>\n                         (MkI\\<cdot>(ia + 1 - 1)) :@\n                         supto\\<cdot>(MkI\\<cdot>(ia + 1))\\<cdot>\n                         (MkI\\<cdot>k)", "case (step l)"], ["proof (state)\nthis:\n  i \\<le> l\n  l \\<le> k \\<Longrightarrow>\n  supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>k) =\n  supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>(l - 1)) :@\n  supto\\<cdot>(MkI\\<cdot>l)\\<cdot>(MkI\\<cdot>k)\n  l + 1 \\<le> k\n\ngoal (2 subgoals):\n 1. i \\<le> k \\<Longrightarrow>\n    supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>k) =\n    supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>(i - 1)) :@\n    supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>k)\n 2. \\<And>ia.\n       \\<lbrakk>i \\<le> ia;\n        ia \\<le> k \\<Longrightarrow>\n        supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>k) =\n        supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>(ia - 1)) :@\n        supto\\<cdot>(MkI\\<cdot>ia)\\<cdot>(MkI\\<cdot>k);\n        ia + 1 \\<le> k\\<rbrakk>\n       \\<Longrightarrow> supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>k) =\n                         supto\\<cdot>(MkI\\<cdot>i)\\<cdot>\n                         (MkI\\<cdot>(ia + 1 - 1)) :@\n                         supto\\<cdot>(MkI\\<cdot>(ia + 1))\\<cdot>\n                         (MkI\\<cdot>k)", "with supto_simp(2) supto_snoc"], ["proof (chain)\npicking this:\n  ?i \\<le> ?j \\<Longrightarrow>\n  supto\\<cdot>(MkI\\<cdot>?i)\\<cdot>(MkI\\<cdot>?j) =\n  MkI\\<cdot>?i :# supto\\<cdot>(MkI\\<cdot>?i + 1)\\<cdot>(MkI\\<cdot>?j)\n  ?i \\<le> ?j \\<Longrightarrow>\n  supto\\<cdot>(MkI\\<cdot>?i)\\<cdot>(MkI\\<cdot>?j) =\n  supto\\<cdot>(MkI\\<cdot>?i)\\<cdot>(MkI\\<cdot>?j - 1) :@ [:MkI\\<cdot>?j:]\n  i \\<le> l\n  l \\<le> k \\<Longrightarrow>\n  supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>k) =\n  supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>(l - 1)) :@\n  supto\\<cdot>(MkI\\<cdot>l)\\<cdot>(MkI\\<cdot>k)\n  l + 1 \\<le> k", "show ?case"], ["proof (prove)\nusing this:\n  ?i \\<le> ?j \\<Longrightarrow>\n  supto\\<cdot>(MkI\\<cdot>?i)\\<cdot>(MkI\\<cdot>?j) =\n  MkI\\<cdot>?i :# supto\\<cdot>(MkI\\<cdot>?i + 1)\\<cdot>(MkI\\<cdot>?j)\n  ?i \\<le> ?j \\<Longrightarrow>\n  supto\\<cdot>(MkI\\<cdot>?i)\\<cdot>(MkI\\<cdot>?j) =\n  supto\\<cdot>(MkI\\<cdot>?i)\\<cdot>(MkI\\<cdot>?j - 1) :@ [:MkI\\<cdot>?j:]\n  i \\<le> l\n  l \\<le> k \\<Longrightarrow>\n  supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>k) =\n  supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>(l - 1)) :@\n  supto\\<cdot>(MkI\\<cdot>l)\\<cdot>(MkI\\<cdot>k)\n  l + 1 \\<le> k\n\ngoal (1 subgoal):\n 1. supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>k) =\n    supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>(l + 1 - 1)) :@\n    supto\\<cdot>(MkI\\<cdot>(l + 1))\\<cdot>(MkI\\<cdot>k)", "by (clarsimp simp: one_Integer_def)"], ["proof (state)\nthis:\n  supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>k) =\n  supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>(l + 1 - 1)) :@\n  supto\\<cdot>(MkI\\<cdot>(l + 1))\\<cdot>(MkI\\<cdot>k)\n\ngoal (1 subgoal):\n 1. i \\<le> k \\<Longrightarrow>\n    supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>k) =\n    supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>(i - 1)) :@\n    supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>k)", "qed simp"], ["", "lemma supto_split2: \\<comment>\\<open>From \\<open>HOL.List\\<close>\\<close>\n  assumes \"i \\<le> j\"\n  assumes \"j \\<le> k\"\n  shows \"supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>k) = supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) :@ supto\\<cdot>(MkI\\<cdot>(j + 1))\\<cdot>(MkI\\<cdot>k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>k) =\n    supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) :@\n    supto\\<cdot>(MkI\\<cdot>(j + 1))\\<cdot>(MkI\\<cdot>k)", "proof(cases \"j + 1 \\<le> k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. j + 1 \\<le> k \\<Longrightarrow>\n    supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>k) =\n    supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) :@\n    supto\\<cdot>(MkI\\<cdot>(j + 1))\\<cdot>(MkI\\<cdot>k)\n 2. \\<not> j + 1 \\<le> k \\<Longrightarrow>\n    supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>k) =\n    supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) :@\n    supto\\<cdot>(MkI\\<cdot>(j + 1))\\<cdot>(MkI\\<cdot>k)", "case True"], ["proof (state)\nthis:\n  j + 1 \\<le> k\n\ngoal (2 subgoals):\n 1. j + 1 \\<le> k \\<Longrightarrow>\n    supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>k) =\n    supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) :@\n    supto\\<cdot>(MkI\\<cdot>(j + 1))\\<cdot>(MkI\\<cdot>k)\n 2. \\<not> j + 1 \\<le> k \\<Longrightarrow>\n    supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>k) =\n    supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) :@\n    supto\\<cdot>(MkI\\<cdot>(j + 1))\\<cdot>(MkI\\<cdot>k)", "with assms"], ["proof (chain)\npicking this:\n  i \\<le> j\n  j \\<le> k\n  j + 1 \\<le> k", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<le> j\n  j \\<le> k\n  j + 1 \\<le> k\n\ngoal (1 subgoal):\n 1. supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>k) =\n    supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) :@\n    supto\\<cdot>(MkI\\<cdot>(j + 1))\\<cdot>(MkI\\<cdot>k)", "by (subst supto_split1[where j=\"j + 1\" and k=k]; clarsimp simp: one_Integer_def)"], ["proof (state)\nthis:\n  supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>k) =\n  supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) :@\n  supto\\<cdot>(MkI\\<cdot>(j + 1))\\<cdot>(MkI\\<cdot>k)\n\ngoal (1 subgoal):\n 1. \\<not> j + 1 \\<le> k \\<Longrightarrow>\n    supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>k) =\n    supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) :@\n    supto\\<cdot>(MkI\\<cdot>(j + 1))\\<cdot>(MkI\\<cdot>k)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> j + 1 \\<le> k \\<Longrightarrow>\n    supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>k) =\n    supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) :@\n    supto\\<cdot>(MkI\\<cdot>(j + 1))\\<cdot>(MkI\\<cdot>k)", "case False"], ["proof (state)\nthis:\n  \\<not> j + 1 \\<le> k\n\ngoal (1 subgoal):\n 1. \\<not> j + 1 \\<le> k \\<Longrightarrow>\n    supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>k) =\n    supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) :@\n    supto\\<cdot>(MkI\\<cdot>(j + 1))\\<cdot>(MkI\\<cdot>k)", "with assms"], ["proof (chain)\npicking this:\n  i \\<le> j\n  j \\<le> k\n  \\<not> j + 1 \\<le> k", "show ?thesis"], ["proof (prove)\nusing this:\n  i \\<le> j\n  j \\<le> k\n  \\<not> j + 1 \\<le> k\n\ngoal (1 subgoal):\n 1. supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>k) =\n    supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) :@\n    supto\\<cdot>(MkI\\<cdot>(j + 1))\\<cdot>(MkI\\<cdot>k)", "by (clarsimp simp: one_Integer_def not_le)"], ["proof (state)\nthis:\n  supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>k) =\n  supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>j) :@\n  supto\\<cdot>(MkI\\<cdot>(j + 1))\\<cdot>(MkI\\<cdot>k)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma supto_split3: \\<comment>\\<open>From \\<open>HOL.List\\<close>\\<close>\n  assumes \"i \\<le> j\"\n  assumes \"j \\<le> k\"\n  shows \"supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>k) = supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>(j - 1)) :@ MkI\\<cdot>j :# supto\\<cdot>(MkI\\<cdot>(j + 1))\\<cdot>(MkI\\<cdot>k)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>k) =\n    supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>(j - 1)) :@\n    MkI\\<cdot>j :# supto\\<cdot>(MkI\\<cdot>(j + 1))\\<cdot>(MkI\\<cdot>k)", "using assms supto_simp(2) supto_split1"], ["proof (prove)\nusing this:\n  i \\<le> j\n  j \\<le> k\n  ?i \\<le> ?j \\<Longrightarrow>\n  supto\\<cdot>(MkI\\<cdot>?i)\\<cdot>(MkI\\<cdot>?j) =\n  MkI\\<cdot>?i :# supto\\<cdot>(MkI\\<cdot>?i + 1)\\<cdot>(MkI\\<cdot>?j)\n  \\<lbrakk>?i \\<le> ?j; ?j \\<le> ?k\\<rbrakk>\n  \\<Longrightarrow> supto\\<cdot>(MkI\\<cdot>?i)\\<cdot>(MkI\\<cdot>?k) =\n                    supto\\<cdot>(MkI\\<cdot>?i)\\<cdot>(MkI\\<cdot>(?j - 1)) :@\n                    supto\\<cdot>(MkI\\<cdot>?j)\\<cdot>(MkI\\<cdot>?k)\n\ngoal (1 subgoal):\n 1. supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>k) =\n    supto\\<cdot>(MkI\\<cdot>i)\\<cdot>(MkI\\<cdot>(j - 1)) :@\n    MkI\\<cdot>j :# supto\\<cdot>(MkI\\<cdot>(j + 1))\\<cdot>(MkI\\<cdot>k)", "by (metis one_Integer_def plus_MkI_MkI)"], ["", "lemma sinits_stake':\n  shows \"sinits\\<cdot>xs = smap\\<cdot>(\\<Lambda> i. stake\\<cdot>i\\<cdot>xs)\\<cdot>(supto\\<cdot>0\\<cdot>(slength\\<cdot>xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sinits\\<cdot>xs =\n    smap\\<cdot>(\\<Lambda> i. stake\\<cdot>i\\<cdot>xs)\\<cdot>\n    (supto\\<cdot>0\\<cdot>(slength\\<cdot>xs))", "proof(induct xs rule: srev_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. sinits\\<cdot>\\<bottom> =\n    smap\\<cdot>(\\<Lambda> i. stake\\<cdot>i\\<cdot>\\<bottom>)\\<cdot>\n    (supto\\<cdot>0\\<cdot>(slength\\<cdot>\\<bottom>))\n 2. sinits\\<cdot>[::] =\n    smap\\<cdot>(\\<Lambda> i. stake\\<cdot>i\\<cdot>[::])\\<cdot>\n    (supto\\<cdot>0\\<cdot>(slength\\<cdot>[::]))\n 3. \\<And>x xs.\n       \\<lbrakk>x \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        sinits\\<cdot>xs =\n        smap\\<cdot>(\\<Lambda> i. stake\\<cdot>i\\<cdot>xs)\\<cdot>\n        (supto\\<cdot>0\\<cdot>(slength\\<cdot>xs))\\<rbrakk>\n       \\<Longrightarrow> sinits\\<cdot>(xs :@ [:x:]) =\n                         smap\\<cdot>\n                         (\\<Lambda> i.\n                             stake\\<cdot>i\\<cdot>(xs :@ [:x:]))\\<cdot>\n                         (supto\\<cdot>0\\<cdot>(slength\\<cdot>(xs :@ [:x:])))", "case (ssnoc x xs)"], ["proof (state)\nthis:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  sinits\\<cdot>xs =\n  smap\\<cdot>(\\<Lambda> i. stake\\<cdot>i\\<cdot>xs)\\<cdot>\n  (supto\\<cdot>0\\<cdot>(slength\\<cdot>xs))\n\ngoal (3 subgoals):\n 1. sinits\\<cdot>\\<bottom> =\n    smap\\<cdot>(\\<Lambda> i. stake\\<cdot>i\\<cdot>\\<bottom>)\\<cdot>\n    (supto\\<cdot>0\\<cdot>(slength\\<cdot>\\<bottom>))\n 2. sinits\\<cdot>[::] =\n    smap\\<cdot>(\\<Lambda> i. stake\\<cdot>i\\<cdot>[::])\\<cdot>\n    (supto\\<cdot>0\\<cdot>(slength\\<cdot>[::]))\n 3. \\<And>x xs.\n       \\<lbrakk>x \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        sinits\\<cdot>xs =\n        smap\\<cdot>(\\<Lambda> i. stake\\<cdot>i\\<cdot>xs)\\<cdot>\n        (supto\\<cdot>0\\<cdot>(slength\\<cdot>xs))\\<rbrakk>\n       \\<Longrightarrow> sinits\\<cdot>(xs :@ [:x:]) =\n                         smap\\<cdot>\n                         (\\<Lambda> i.\n                             stake\\<cdot>i\\<cdot>(xs :@ [:x:]))\\<cdot>\n                         (supto\\<cdot>0\\<cdot>(slength\\<cdot>(xs :@ [:x:])))", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  sinits\\<cdot>xs =\n  smap\\<cdot>(\\<Lambda> i. stake\\<cdot>i\\<cdot>xs)\\<cdot>\n  (supto\\<cdot>0\\<cdot>(slength\\<cdot>xs))", "show ?case"], ["proof (prove)\nusing this:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  sinits\\<cdot>xs =\n  smap\\<cdot>(\\<Lambda> i. stake\\<cdot>i\\<cdot>xs)\\<cdot>\n  (supto\\<cdot>0\\<cdot>(slength\\<cdot>xs))\n\ngoal (1 subgoal):\n 1. sinits\\<cdot>(xs :@ [:x:]) =\n    smap\\<cdot>(\\<Lambda> i. stake\\<cdot>i\\<cdot>(xs :@ [:x:]))\\<cdot>\n    (supto\\<cdot>0\\<cdot>(slength\\<cdot>(xs :@ [:x:])))", "apply (clarsimp simp: zero_Integer_def one_Integer_def stake_all\n                simp del: supto_simp\n                   elim!: slengthE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>x \\<noteq> \\<bottom>;\n        sinits\\<cdot>xs =\n        smap\\<cdot>(\\<Lambda> i. stake\\<cdot>i\\<cdot>xs)\\<cdot>\n        (supto\\<cdot>(MkI\\<cdot>0)\\<cdot>(MkI\\<cdot>(n - 1))) :@\n        [:xs:];\n        slength\\<cdot>xs = MkI\\<cdot>n; 0 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> smap\\<cdot>\n                         (\\<Lambda> i. stake\\<cdot>i\\<cdot>xs)\\<cdot>\n                         (supto\\<cdot>(MkI\\<cdot>0)\\<cdot>\n                          (MkI\\<cdot>(n - 1))) :@\n                         [:xs, xs :@ [:x:]:] =\n                         smap\\<cdot>\n                         (\\<Lambda> i.\n                             stake\\<cdot>i\\<cdot>xs :@\n                             (If le\\<cdot>(i - MkI\\<cdot>n)\\<cdot>\n                                 (MkI\\<cdot>0)\n                              then [::]\n                              else x :#\n                                   stake\\<cdot>\n                                   (i - MkI\\<cdot>n - MkI\\<cdot>1)\\<cdot>\n                                   [::]))\\<cdot>\n                         (supto\\<cdot>(MkI\\<cdot>0)\\<cdot>\n                          (MkI\\<cdot>(n - 1))) :@\n                         [:xs, xs :@ [:x:]:]", "apply (rule arg_cong, rule smap_cong[OF refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n xa.\n       \\<lbrakk>x \\<noteq> \\<bottom>;\n        sinits\\<cdot>xs =\n        smap\\<cdot>(\\<Lambda> i. stake\\<cdot>i\\<cdot>xs)\\<cdot>\n        (supto\\<cdot>(MkI\\<cdot>0)\\<cdot>(MkI\\<cdot>(n - 1))) :@\n        [:xs:];\n        slength\\<cdot>xs = MkI\\<cdot>n; 0 \\<le> n;\n        xa \\<in> sset\n                  (supto\\<cdot>(MkI\\<cdot>0)\\<cdot>\n                   (MkI\\<cdot>(n - 1)))\\<rbrakk>\n       \\<Longrightarrow> (\\<Lambda> i. stake\\<cdot>i\\<cdot>xs)\\<cdot>xa =\n                         (\\<Lambda> i.\n                             stake\\<cdot>i\\<cdot>xs :@\n                             (If le\\<cdot>(i - MkI\\<cdot>n)\\<cdot>\n                                 (MkI\\<cdot>0)\n                              then [::]\n                              else x :#\n                                   stake\\<cdot>\n                                   (i - MkI\\<cdot>n - MkI\\<cdot>1)\\<cdot>\n                                   [::]))\\<cdot>\n                         xa", "apply clarsimp"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  sinits\\<cdot>(xs :@ [:x:]) =\n  smap\\<cdot>(\\<Lambda> i. stake\\<cdot>i\\<cdot>(xs :@ [:x:]))\\<cdot>\n  (supto\\<cdot>0\\<cdot>(slength\\<cdot>(xs :@ [:x:])))\n\ngoal (2 subgoals):\n 1. sinits\\<cdot>\\<bottom> =\n    smap\\<cdot>(\\<Lambda> i. stake\\<cdot>i\\<cdot>\\<bottom>)\\<cdot>\n    (supto\\<cdot>0\\<cdot>(slength\\<cdot>\\<bottom>))\n 2. sinits\\<cdot>[::] =\n    smap\\<cdot>(\\<Lambda> i. stake\\<cdot>i\\<cdot>[::])\\<cdot>\n    (supto\\<cdot>0\\<cdot>(slength\\<cdot>[::]))", "qed simp_all"], ["", "lemma stails_sdrop':\n  shows \"stails\\<cdot>xs = smap\\<cdot>(\\<Lambda> i. sdrop\\<cdot>i\\<cdot>xs)\\<cdot>(supto\\<cdot>0\\<cdot>(slength\\<cdot>xs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stails\\<cdot>xs =\n    smap\\<cdot>(\\<Lambda> i. sdrop\\<cdot>i\\<cdot>xs)\\<cdot>\n    (supto\\<cdot>0\\<cdot>(slength\\<cdot>xs))", "proof(induct xs rule: srev_induct)"], ["proof (state)\ngoal (3 subgoals):\n 1. stails\\<cdot>\\<bottom> =\n    smap\\<cdot>(\\<Lambda> i. sdrop\\<cdot>i\\<cdot>\\<bottom>)\\<cdot>\n    (supto\\<cdot>0\\<cdot>(slength\\<cdot>\\<bottom>))\n 2. stails\\<cdot>[::] =\n    smap\\<cdot>(\\<Lambda> i. sdrop\\<cdot>i\\<cdot>[::])\\<cdot>\n    (supto\\<cdot>0\\<cdot>(slength\\<cdot>[::]))\n 3. \\<And>x xs.\n       \\<lbrakk>x \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        stails\\<cdot>xs =\n        smap\\<cdot>(\\<Lambda> i. sdrop\\<cdot>i\\<cdot>xs)\\<cdot>\n        (supto\\<cdot>0\\<cdot>(slength\\<cdot>xs))\\<rbrakk>\n       \\<Longrightarrow> stails\\<cdot>(xs :@ [:x:]) =\n                         smap\\<cdot>\n                         (\\<Lambda> i.\n                             sdrop\\<cdot>i\\<cdot>(xs :@ [:x:]))\\<cdot>\n                         (supto\\<cdot>0\\<cdot>(slength\\<cdot>(xs :@ [:x:])))", "case (ssnoc x xs)"], ["proof (state)\nthis:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  stails\\<cdot>xs =\n  smap\\<cdot>(\\<Lambda> i. sdrop\\<cdot>i\\<cdot>xs)\\<cdot>\n  (supto\\<cdot>0\\<cdot>(slength\\<cdot>xs))\n\ngoal (3 subgoals):\n 1. stails\\<cdot>\\<bottom> =\n    smap\\<cdot>(\\<Lambda> i. sdrop\\<cdot>i\\<cdot>\\<bottom>)\\<cdot>\n    (supto\\<cdot>0\\<cdot>(slength\\<cdot>\\<bottom>))\n 2. stails\\<cdot>[::] =\n    smap\\<cdot>(\\<Lambda> i. sdrop\\<cdot>i\\<cdot>[::])\\<cdot>\n    (supto\\<cdot>0\\<cdot>(slength\\<cdot>[::]))\n 3. \\<And>x xs.\n       \\<lbrakk>x \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        stails\\<cdot>xs =\n        smap\\<cdot>(\\<Lambda> i. sdrop\\<cdot>i\\<cdot>xs)\\<cdot>\n        (supto\\<cdot>0\\<cdot>(slength\\<cdot>xs))\\<rbrakk>\n       \\<Longrightarrow> stails\\<cdot>(xs :@ [:x:]) =\n                         smap\\<cdot>\n                         (\\<Lambda> i.\n                             sdrop\\<cdot>i\\<cdot>(xs :@ [:x:]))\\<cdot>\n                         (supto\\<cdot>0\\<cdot>(slength\\<cdot>(xs :@ [:x:])))", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  stails\\<cdot>xs =\n  smap\\<cdot>(\\<Lambda> i. sdrop\\<cdot>i\\<cdot>xs)\\<cdot>\n  (supto\\<cdot>0\\<cdot>(slength\\<cdot>xs))", "show ?case"], ["proof (prove)\nusing this:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  stails\\<cdot>xs =\n  smap\\<cdot>(\\<Lambda> i. sdrop\\<cdot>i\\<cdot>xs)\\<cdot>\n  (supto\\<cdot>0\\<cdot>(slength\\<cdot>xs))\n\ngoal (1 subgoal):\n 1. stails\\<cdot>(xs :@ [:x:]) =\n    smap\\<cdot>(\\<Lambda> i. sdrop\\<cdot>i\\<cdot>(xs :@ [:x:]))\\<cdot>\n    (supto\\<cdot>0\\<cdot>(slength\\<cdot>(xs :@ [:x:])))", "apply (clarsimp simp: zero_Integer_def one_Integer_def sdrop_all\n                simp del: supto_simp\n                   elim!: slengthE)"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n.\n       \\<lbrakk>x \\<noteq> \\<bottom>;\n        stails\\<cdot>xs =\n        smap\\<cdot>(\\<Lambda> i. sdrop\\<cdot>i\\<cdot>xs)\\<cdot>\n        (supto\\<cdot>(MkI\\<cdot>0)\\<cdot>(MkI\\<cdot>(n - 1))) :@\n        [:[::]:];\n        slength\\<cdot>xs = MkI\\<cdot>n; 0 \\<le> n\\<rbrakk>\n       \\<Longrightarrow> smap\\<cdot>\n                         ((\\<Lambda> ys. ys :@ [:x:]) oo\n                          (\\<Lambda> i. sdrop\\<cdot>i\\<cdot>xs))\\<cdot>\n                         (supto\\<cdot>(MkI\\<cdot>0)\\<cdot>\n                          (MkI\\<cdot>(n - 1))) :@\n                         [:[:x:], [::]:] =\n                         smap\\<cdot>\n                         (\\<Lambda> i.\n                             sdrop\\<cdot>i\\<cdot>xs :@\n                             sdrop\\<cdot>(i - MkI\\<cdot>n)\\<cdot>\n                             [:x:])\\<cdot>\n                         (supto\\<cdot>(MkI\\<cdot>0)\\<cdot>\n                          (MkI\\<cdot>(n - 1))) :@\n                         [:[:x:], [::]:]", "apply (rule arg_cong, rule smap_cong[OF refl])"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n xa.\n       \\<lbrakk>x \\<noteq> \\<bottom>;\n        stails\\<cdot>xs =\n        smap\\<cdot>(\\<Lambda> i. sdrop\\<cdot>i\\<cdot>xs)\\<cdot>\n        (supto\\<cdot>(MkI\\<cdot>0)\\<cdot>(MkI\\<cdot>(n - 1))) :@\n        [:[::]:];\n        slength\\<cdot>xs = MkI\\<cdot>n; 0 \\<le> n;\n        xa \\<in> sset\n                  (supto\\<cdot>(MkI\\<cdot>0)\\<cdot>\n                   (MkI\\<cdot>(n - 1)))\\<rbrakk>\n       \\<Longrightarrow> ((\\<Lambda> ys. ys :@ [:x:]) oo\n                          (\\<Lambda> i. sdrop\\<cdot>i\\<cdot>xs))\\<cdot>\n                         xa =\n                         (\\<Lambda> i.\n                             sdrop\\<cdot>i\\<cdot>xs :@\n                             sdrop\\<cdot>(i - MkI\\<cdot>n)\\<cdot>\n                             [:x:])\\<cdot>\n                         xa", "apply clarsimp"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<And>n k.\n       \\<lbrakk>x \\<noteq> \\<bottom>;\n        stails\\<cdot>xs =\n        xs :#\n        smap\\<cdot>(\\<Lambda> i. sdrop\\<cdot>i\\<cdot>xs)\\<cdot>\n        (supto\\<cdot>1\\<cdot>(MkI\\<cdot>(n - 1))) :@\n        [:[::]:];\n        slength\\<cdot>xs = MkI\\<cdot>n; 0 \\<le> k; k < n\\<rbrakk>\n       \\<Longrightarrow> sdrop\\<cdot>(MkI\\<cdot>k)\\<cdot>xs :@ [:x:] =\n                         sdrop\\<cdot>(MkI\\<cdot>k)\\<cdot>xs :@\n                         sdrop\\<cdot>(MkI\\<cdot>(k - n))\\<cdot>[:x:]", "apply (subst (3) sdrop_neg; fastforce simp: zero_Integer_def)"], ["proof (prove)\ngoal:\nNo subgoals!", "done"], ["proof (state)\nthis:\n  stails\\<cdot>(xs :@ [:x:]) =\n  smap\\<cdot>(\\<Lambda> i. sdrop\\<cdot>i\\<cdot>(xs :@ [:x:]))\\<cdot>\n  (supto\\<cdot>0\\<cdot>(slength\\<cdot>(xs :@ [:x:])))\n\ngoal (2 subgoals):\n 1. stails\\<cdot>\\<bottom> =\n    smap\\<cdot>(\\<Lambda> i. sdrop\\<cdot>i\\<cdot>\\<bottom>)\\<cdot>\n    (supto\\<cdot>0\\<cdot>(slength\\<cdot>\\<bottom>))\n 2. stails\\<cdot>[::] =\n    smap\\<cdot>(\\<Lambda> i. sdrop\\<cdot>i\\<cdot>[::])\\<cdot>\n    (supto\\<cdot>0\\<cdot>(slength\\<cdot>[::]))", "qed simp_all"], ["", "lemma sdrop_elem_stails[iff]:\n  assumes \"xs \\<noteq> \\<bottom>\"\n  shows \"sdrop\\<cdot>(MkI\\<cdot>i)\\<cdot>xs \\<in> sset (stails\\<cdot>xs)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sdrop\\<cdot>(MkI\\<cdot>i)\\<cdot>xs \\<in> sset (stails\\<cdot>xs)", "using assms"], ["proof (prove)\nusing this:\n  xs \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. sdrop\\<cdot>(MkI\\<cdot>i)\\<cdot>xs \\<in> sset (stails\\<cdot>xs)", "by (clarsimp simp: stails_sdrop' zero_Integer_def one_Integer_def elim!: slengthE)\n   (metis add.left_neutral le_MkI_MkI le_cases not_less sdrop_all sdrop_neg zero_Integer_def zless_imp_add1_zle)"], ["", "fixrec slast :: \"[:'a:] \\<rightarrow> 'a\" where\n  \"slast\\<cdot>[::] = \\<bottom>\"\n| \"\\<lbrakk>x \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>\\<rbrakk> \\<Longrightarrow> slast\\<cdot>(x :# xs) = (case xs of [::] \\<Rightarrow> x | y :# ys \\<Rightarrow> slast\\<cdot>xs)\""], ["", "lemma slast_strict[simp]:\n  \"slast\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slast\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "lemma slast_singleton[simp]: \"slast\\<cdot>[:x:] = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slast\\<cdot>[:x:] = x", "by (cases \"x = \\<bottom>\"; simp)"], ["", "lemma slast_sappend_ssnoc[simp]:\n  assumes \"xs \\<noteq> \\<bottom>\"\n  shows \"slast\\<cdot>(xs :@ [:x:]) = x\""], ["proof (prove)\ngoal (1 subgoal):\n 1. slast\\<cdot>(xs :@ [:x:]) = x", "using assms"], ["proof (prove)\nusing this:\n  xs \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. slast\\<cdot>(xs :@ [:x:]) = x", "proof(induct xs)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<bottom> \\<noteq> \\<bottom> \\<Longrightarrow>\n    slast\\<cdot>(\\<bottom> :@ [:x:]) = x\n 2. [::] \\<noteq> \\<bottom> \\<Longrightarrow>\n    slast\\<cdot>([::] :@ [:x:]) = x\n 3. \\<And>a xs.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        xs \\<noteq> \\<bottom> \\<Longrightarrow>\n        slast\\<cdot>(xs :@ [:x:]) = x;\n        a :# xs \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> slast\\<cdot>((a :# xs) :@ [:x:]) = x", "case (scons y ys)"], ["proof (state)\nthis:\n  y \\<noteq> \\<bottom>\n  ys \\<noteq> \\<bottom>\n  ys \\<noteq> \\<bottom> \\<Longrightarrow> slast\\<cdot>(ys :@ [:x:]) = x\n  y :# ys \\<noteq> \\<bottom>\n\ngoal (3 subgoals):\n 1. \\<bottom> \\<noteq> \\<bottom> \\<Longrightarrow>\n    slast\\<cdot>(\\<bottom> :@ [:x:]) = x\n 2. [::] \\<noteq> \\<bottom> \\<Longrightarrow>\n    slast\\<cdot>([::] :@ [:x:]) = x\n 3. \\<And>a xs.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        xs \\<noteq> \\<bottom> \\<Longrightarrow>\n        slast\\<cdot>(xs :@ [:x:]) = x;\n        a :# xs \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> slast\\<cdot>((a :# xs) :@ [:x:]) = x", "then"], ["proof (chain)\npicking this:\n  y \\<noteq> \\<bottom>\n  ys \\<noteq> \\<bottom>\n  ys \\<noteq> \\<bottom> \\<Longrightarrow> slast\\<cdot>(ys :@ [:x:]) = x\n  y :# ys \\<noteq> \\<bottom>", "show ?case"], ["proof (prove)\nusing this:\n  y \\<noteq> \\<bottom>\n  ys \\<noteq> \\<bottom>\n  ys \\<noteq> \\<bottom> \\<Longrightarrow> slast\\<cdot>(ys :@ [:x:]) = x\n  y :# ys \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. slast\\<cdot>((y :# ys) :@ [:x:]) = x", "by (cases \"x = \\<bottom>\"; simp; cases ys; simp)"], ["proof (state)\nthis:\n  slast\\<cdot>((y :# ys) :@ [:x:]) = x\n\ngoal (2 subgoals):\n 1. \\<bottom> \\<noteq> \\<bottom> \\<Longrightarrow>\n    slast\\<cdot>(\\<bottom> :@ [:x:]) = x\n 2. [::] \\<noteq> \\<bottom> \\<Longrightarrow>\n    slast\\<cdot>([::] :@ [:x:]) = x", "qed simp_all"], ["", "fixrec sbutlast :: \"[:'a:] \\<rightarrow> [:'a:]\" where\n  \"sbutlast\\<cdot>[::] = [::]\"\n| \"\\<lbrakk>x \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>\\<rbrakk> \\<Longrightarrow> sbutlast\\<cdot>(x :# xs) = (case xs of [::] \\<Rightarrow> [::] | y :# ys \\<Rightarrow> x :# sbutlast\\<cdot>xs)\""], ["", "lemma sbutlast_strict[simp]:\n  \"sbutlast\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sbutlast\\<cdot>\\<bottom> = \\<bottom>", "by fixrec_simp"], ["", "lemma sbutlast_sappend_ssnoc[simp]:\n  assumes \"x \\<noteq> \\<bottom>\"\n  shows \"sbutlast\\<cdot>(xs :@ [:x:]) = xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sbutlast\\<cdot>(xs :@ [:x:]) = xs", "using assms"], ["proof (prove)\nusing this:\n  x \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. sbutlast\\<cdot>(xs :@ [:x:]) = xs", "proof(induct xs)"], ["proof (state)\ngoal (3 subgoals):\n 1. x \\<noteq> \\<bottom> \\<Longrightarrow>\n    sbutlast\\<cdot>(\\<bottom> :@ [:x:]) = \\<bottom>\n 2. x \\<noteq> \\<bottom> \\<Longrightarrow>\n    sbutlast\\<cdot>([::] :@ [:x:]) = [::]\n 3. \\<And>a xs.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        x \\<noteq> \\<bottom> \\<Longrightarrow>\n        sbutlast\\<cdot>(xs :@ [:x:]) = xs;\n        x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> sbutlast\\<cdot>((a :# xs) :@ [:x:]) = a :# xs", "case (scons y ys)"], ["proof (state)\nthis:\n  y \\<noteq> \\<bottom>\n  ys \\<noteq> \\<bottom>\n  x \\<noteq> \\<bottom> \\<Longrightarrow> sbutlast\\<cdot>(ys :@ [:x:]) = ys\n  x \\<noteq> \\<bottom>\n\ngoal (3 subgoals):\n 1. x \\<noteq> \\<bottom> \\<Longrightarrow>\n    sbutlast\\<cdot>(\\<bottom> :@ [:x:]) = \\<bottom>\n 2. x \\<noteq> \\<bottom> \\<Longrightarrow>\n    sbutlast\\<cdot>([::] :@ [:x:]) = [::]\n 3. \\<And>a xs.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        x \\<noteq> \\<bottom> \\<Longrightarrow>\n        sbutlast\\<cdot>(xs :@ [:x:]) = xs;\n        x \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> sbutlast\\<cdot>((a :# xs) :@ [:x:]) = a :# xs", "then"], ["proof (chain)\npicking this:\n  y \\<noteq> \\<bottom>\n  ys \\<noteq> \\<bottom>\n  x \\<noteq> \\<bottom> \\<Longrightarrow> sbutlast\\<cdot>(ys :@ [:x:]) = ys\n  x \\<noteq> \\<bottom>", "show ?case"], ["proof (prove)\nusing this:\n  y \\<noteq> \\<bottom>\n  ys \\<noteq> \\<bottom>\n  x \\<noteq> \\<bottom> \\<Longrightarrow> sbutlast\\<cdot>(ys :@ [:x:]) = ys\n  x \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. sbutlast\\<cdot>((y :# ys) :@ [:x:]) = y :# ys", "by (cases ys; simp)"], ["proof (state)\nthis:\n  sbutlast\\<cdot>((y :# ys) :@ [:x:]) = y :# ys\n\ngoal (2 subgoals):\n 1. x \\<noteq> \\<bottom> \\<Longrightarrow>\n    sbutlast\\<cdot>(\\<bottom> :@ [:x:]) = \\<bottom>\n 2. x \\<noteq> \\<bottom> \\<Longrightarrow>\n    sbutlast\\<cdot>([::] :@ [:x:]) = [::]", "qed simp_all"], ["", "fixrec prefix :: \"[:'a::Eq_def:] \\<rightarrow> [:'a:] \\<rightarrow> tr\" where\n  \"prefix\\<cdot>xs\\<cdot>\\<bottom> = \\<bottom>\"\n| \"ys \\<noteq> \\<bottom> \\<Longrightarrow> prefix\\<cdot>[::]\\<cdot>ys = TT\"\n| \"\\<lbrakk>x \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>\\<rbrakk> \\<Longrightarrow> prefix\\<cdot>(x :# xs)\\<cdot>[::] = FF\"\n| \"\\<lbrakk>x \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>; y \\<noteq> \\<bottom>; ys \\<noteq> \\<bottom>\\<rbrakk> \\<Longrightarrow> prefix\\<cdot>(x :# xs)\\<cdot>(y :# ys) = (eq\\<cdot>x\\<cdot>y andalso prefix\\<cdot>xs\\<cdot>ys)\""], ["", "lemma prefix_strict[simp]: \"prefix\\<cdot>\\<bottom> = \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix\\<cdot>\\<bottom> = \\<bottom>", "by (clarsimp simp: cfun_eq_iff) fixrec_simp"], ["", "lemma prefix_bottom_iff[simp]: \"(prefix\\<cdot>xs\\<cdot>ys = \\<bottom>) \\<longleftrightarrow> (xs = \\<bottom> \\<or> ys = \\<bottom>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (prefix\\<cdot>xs\\<cdot>ys = \\<bottom>) =\n    (xs = \\<bottom> \\<or> ys = \\<bottom>)", "proof(induct xs arbitrary: ys)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ys.\n       (prefix\\<cdot>\\<bottom>\\<cdot>ys = \\<bottom>) =\n       (\\<bottom> = \\<bottom> \\<or> ys = \\<bottom>)\n 2. \\<And>ys.\n       (prefix\\<cdot>[::]\\<cdot>ys = \\<bottom>) =\n       ([::] = \\<bottom> \\<or> ys = \\<bottom>)\n 3. \\<And>a xs ys.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>ys.\n           (prefix\\<cdot>xs\\<cdot>ys = \\<bottom>) =\n           (xs = \\<bottom> \\<or> ys = \\<bottom>)\\<rbrakk>\n       \\<Longrightarrow> (prefix\\<cdot>(a :# xs)\\<cdot>ys = \\<bottom>) =\n                         (a :# xs = \\<bottom> \\<or> ys = \\<bottom>)", "case (snil ys)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>ys.\n       (prefix\\<cdot>\\<bottom>\\<cdot>ys = \\<bottom>) =\n       (\\<bottom> = \\<bottom> \\<or> ys = \\<bottom>)\n 2. \\<And>ys.\n       (prefix\\<cdot>[::]\\<cdot>ys = \\<bottom>) =\n       ([::] = \\<bottom> \\<or> ys = \\<bottom>)\n 3. \\<And>a xs ys.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>ys.\n           (prefix\\<cdot>xs\\<cdot>ys = \\<bottom>) =\n           (xs = \\<bottom> \\<or> ys = \\<bottom>)\\<rbrakk>\n       \\<Longrightarrow> (prefix\\<cdot>(a :# xs)\\<cdot>ys = \\<bottom>) =\n                         (a :# xs = \\<bottom> \\<or> ys = \\<bottom>)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. (prefix\\<cdot>[::]\\<cdot>ys = \\<bottom>) =\n    ([::] = \\<bottom> \\<or> ys = \\<bottom>)", "by (cases ys) simp_all"], ["proof (state)\nthis:\n  (prefix\\<cdot>[::]\\<cdot>ys = \\<bottom>) =\n  ([::] = \\<bottom> \\<or> ys = \\<bottom>)\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       (prefix\\<cdot>\\<bottom>\\<cdot>ys = \\<bottom>) =\n       (\\<bottom> = \\<bottom> \\<or> ys = \\<bottom>)\n 2. \\<And>a xs ys.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>ys.\n           (prefix\\<cdot>xs\\<cdot>ys = \\<bottom>) =\n           (xs = \\<bottom> \\<or> ys = \\<bottom>)\\<rbrakk>\n       \\<Longrightarrow> (prefix\\<cdot>(a :# xs)\\<cdot>ys = \\<bottom>) =\n                         (a :# xs = \\<bottom> \\<or> ys = \\<bottom>)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       (prefix\\<cdot>\\<bottom>\\<cdot>ys = \\<bottom>) =\n       (\\<bottom> = \\<bottom> \\<or> ys = \\<bottom>)\n 2. \\<And>a xs ys.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>ys.\n           (prefix\\<cdot>xs\\<cdot>ys = \\<bottom>) =\n           (xs = \\<bottom> \\<or> ys = \\<bottom>)\\<rbrakk>\n       \\<Longrightarrow> (prefix\\<cdot>(a :# xs)\\<cdot>ys = \\<bottom>) =\n                         (a :# xs = \\<bottom> \\<or> ys = \\<bottom>)", "case (scons a xs)"], ["proof (state)\nthis:\n  a \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  (prefix\\<cdot>xs\\<cdot>?ys = \\<bottom>) =\n  (xs = \\<bottom> \\<or> ?ys = \\<bottom>)\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       (prefix\\<cdot>\\<bottom>\\<cdot>ys = \\<bottom>) =\n       (\\<bottom> = \\<bottom> \\<or> ys = \\<bottom>)\n 2. \\<And>a xs ys.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>ys.\n           (prefix\\<cdot>xs\\<cdot>ys = \\<bottom>) =\n           (xs = \\<bottom> \\<or> ys = \\<bottom>)\\<rbrakk>\n       \\<Longrightarrow> (prefix\\<cdot>(a :# xs)\\<cdot>ys = \\<bottom>) =\n                         (a :# xs = \\<bottom> \\<or> ys = \\<bottom>)", "then"], ["proof (chain)\npicking this:\n  a \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  (prefix\\<cdot>xs\\<cdot>?ys = \\<bottom>) =\n  (xs = \\<bottom> \\<or> ?ys = \\<bottom>)", "show ?case"], ["proof (prove)\nusing this:\n  a \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  (prefix\\<cdot>xs\\<cdot>?ys = \\<bottom>) =\n  (xs = \\<bottom> \\<or> ?ys = \\<bottom>)\n\ngoal (1 subgoal):\n 1. (prefix\\<cdot>(a :# xs)\\<cdot>ys = \\<bottom>) =\n    (a :# xs = \\<bottom> \\<or> ys = \\<bottom>)", "by (cases ys) simp_all"], ["proof (state)\nthis:\n  (prefix\\<cdot>(a :# xs)\\<cdot>ys = \\<bottom>) =\n  (a :# xs = \\<bottom> \\<or> ys = \\<bottom>)\n\ngoal (1 subgoal):\n 1. \\<And>ys.\n       (prefix\\<cdot>\\<bottom>\\<cdot>ys = \\<bottom>) =\n       (\\<bottom> = \\<bottom> \\<or> ys = \\<bottom>)", "qed simp"], ["", "lemma prefix_definedD:\n  assumes \"prefix\\<cdot>xs\\<cdot>ys = TT\"\n  shows \"xs \\<noteq> \\<bottom> \\<and> ys \\<noteq> \\<bottom>\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> \\<bottom> \\<and> ys \\<noteq> \\<bottom>", "using assms"], ["proof (prove)\nusing this:\n  prefix\\<cdot>xs\\<cdot>ys = TT\n\ngoal (1 subgoal):\n 1. xs \\<noteq> \\<bottom> \\<and> ys \\<noteq> \\<bottom>", "by (induct xs arbitrary: ys) auto"], ["", "lemma prefix_refl[simp]:\n  assumes \"xs \\<noteq> \\<bottom>\"\n  shows \"prefix\\<cdot>xs\\<cdot>xs = TT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix\\<cdot>xs\\<cdot>xs = TT", "using assms"], ["proof (prove)\nusing this:\n  xs \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. prefix\\<cdot>xs\\<cdot>xs = TT", "by (induct xs) simp_all"], ["", "lemma prefix_refl_conv[simp]: \"(prefix\\<cdot>xs\\<cdot>xs = TT) \\<longleftrightarrow> (xs \\<noteq> \\<bottom>)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (prefix\\<cdot>xs\\<cdot>xs = TT) = (xs \\<noteq> \\<bottom>)", "by auto"], ["", "lemma  prefix_of_snil[simp]: \"prefix\\<cdot>xs\\<cdot>[::] = (case xs of [::] \\<Rightarrow> TT | x :# xs \\<Rightarrow> FF)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix\\<cdot>xs\\<cdot>[::] =\n    (case xs of [::] \\<Rightarrow> TT | x :# xs \\<Rightarrow> FF)", "by (cases xs) simp_all"], ["", "lemma prefix_singleton_TT:\n  shows \"prefix\\<cdot>[:x:]\\<cdot>ys = TT \\<longleftrightarrow> (x \\<noteq> \\<bottom> \\<and> (\\<exists>zs. zs \\<noteq> \\<bottom> \\<and> ys = x :# zs))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (prefix\\<cdot>[:x:]\\<cdot>ys = TT) =\n    (x \\<noteq> \\<bottom> \\<and>\n     (\\<exists>zs. zs \\<noteq> \\<bottom> \\<and> ys = x :# zs))", "by (cases \"x = \\<bottom>\"; clarsimp; cases ys; fastforce)"], ["", "lemma prefix_singleton_FF:\n  shows \"prefix\\<cdot>[:x:]\\<cdot>ys = FF \\<longleftrightarrow> (x \\<noteq> \\<bottom> \\<and> (ys = [::] \\<or> (\\<exists>z zs. z \\<noteq> \\<bottom> \\<and> zs \\<noteq> \\<bottom> \\<and> ys = z :# zs \\<and> x \\<noteq> z)))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (prefix\\<cdot>[:x:]\\<cdot>ys = FF) =\n    (x \\<noteq> \\<bottom> \\<and>\n     (ys = [::] \\<or>\n      (\\<exists>z zs.\n          z \\<noteq> \\<bottom> \\<and>\n          zs \\<noteq> \\<bottom> \\<and> ys = z :# zs \\<and> x \\<noteq> z)))", "by (cases \"x = \\<bottom>\"; clarsimp; cases ys; fastforce)"], ["", "lemma prefix_FF_not_snilD:\n  assumes \"prefix\\<cdot>xs\\<cdot>ys = FF\"\n  shows \"xs \\<noteq> [::]\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs \\<noteq> [::]", "using assms"], ["proof (prove)\nusing this:\n  prefix\\<cdot>xs\\<cdot>ys = FF\n\ngoal (1 subgoal):\n 1. xs \\<noteq> [::]", "by (cases xs; cases ys; simp)"], ["", "lemma prefix_slength:\n  assumes \"prefix\\<cdot>xs\\<cdot>ys = TT\"\n  shows \"le\\<cdot>(slength\\<cdot>xs)\\<cdot>(slength\\<cdot>ys) = TT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. le\\<cdot>(slength\\<cdot>xs)\\<cdot>(slength\\<cdot>ys) = TT", "using assms"], ["proof (prove)\nusing this:\n  prefix\\<cdot>xs\\<cdot>ys = TT\n\ngoal (1 subgoal):\n 1. le\\<cdot>(slength\\<cdot>xs)\\<cdot>(slength\\<cdot>ys) = TT", "proof(induct ys arbitrary: xs)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>xs.\n       prefix\\<cdot>xs\\<cdot>\\<bottom> = TT \\<Longrightarrow>\n       le\\<cdot>(slength\\<cdot>xs)\\<cdot>(slength\\<cdot>\\<bottom>) = TT\n 2. \\<And>xs.\n       prefix\\<cdot>xs\\<cdot>[::] = TT \\<Longrightarrow>\n       le\\<cdot>(slength\\<cdot>xs)\\<cdot>(slength\\<cdot>[::]) = TT\n 3. \\<And>a ys xs.\n       \\<lbrakk>a \\<noteq> \\<bottom>; ys \\<noteq> \\<bottom>;\n        \\<And>xs.\n           prefix\\<cdot>xs\\<cdot>ys = TT \\<Longrightarrow>\n           le\\<cdot>(slength\\<cdot>xs)\\<cdot>(slength\\<cdot>ys) = TT;\n        prefix\\<cdot>xs\\<cdot>(a :# ys) = TT\\<rbrakk>\n       \\<Longrightarrow> le\\<cdot>(slength\\<cdot>xs)\\<cdot>\n                         (slength\\<cdot>(a :# ys)) =\n                         TT", "case (snil xs)"], ["proof (state)\nthis:\n  prefix\\<cdot>xs\\<cdot>[::] = TT\n\ngoal (3 subgoals):\n 1. \\<And>xs.\n       prefix\\<cdot>xs\\<cdot>\\<bottom> = TT \\<Longrightarrow>\n       le\\<cdot>(slength\\<cdot>xs)\\<cdot>(slength\\<cdot>\\<bottom>) = TT\n 2. \\<And>xs.\n       prefix\\<cdot>xs\\<cdot>[::] = TT \\<Longrightarrow>\n       le\\<cdot>(slength\\<cdot>xs)\\<cdot>(slength\\<cdot>[::]) = TT\n 3. \\<And>a ys xs.\n       \\<lbrakk>a \\<noteq> \\<bottom>; ys \\<noteq> \\<bottom>;\n        \\<And>xs.\n           prefix\\<cdot>xs\\<cdot>ys = TT \\<Longrightarrow>\n           le\\<cdot>(slength\\<cdot>xs)\\<cdot>(slength\\<cdot>ys) = TT;\n        prefix\\<cdot>xs\\<cdot>(a :# ys) = TT\\<rbrakk>\n       \\<Longrightarrow> le\\<cdot>(slength\\<cdot>xs)\\<cdot>\n                         (slength\\<cdot>(a :# ys)) =\n                         TT", "then"], ["proof (chain)\npicking this:\n  prefix\\<cdot>xs\\<cdot>[::] = TT", "show ?case"], ["proof (prove)\nusing this:\n  prefix\\<cdot>xs\\<cdot>[::] = TT\n\ngoal (1 subgoal):\n 1. le\\<cdot>(slength\\<cdot>xs)\\<cdot>(slength\\<cdot>[::]) = TT", "by (cases xs) simp_all"], ["proof (state)\nthis:\n  le\\<cdot>(slength\\<cdot>xs)\\<cdot>(slength\\<cdot>[::]) = TT\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       prefix\\<cdot>xs\\<cdot>\\<bottom> = TT \\<Longrightarrow>\n       le\\<cdot>(slength\\<cdot>xs)\\<cdot>(slength\\<cdot>\\<bottom>) = TT\n 2. \\<And>a ys xs.\n       \\<lbrakk>a \\<noteq> \\<bottom>; ys \\<noteq> \\<bottom>;\n        \\<And>xs.\n           prefix\\<cdot>xs\\<cdot>ys = TT \\<Longrightarrow>\n           le\\<cdot>(slength\\<cdot>xs)\\<cdot>(slength\\<cdot>ys) = TT;\n        prefix\\<cdot>xs\\<cdot>(a :# ys) = TT\\<rbrakk>\n       \\<Longrightarrow> le\\<cdot>(slength\\<cdot>xs)\\<cdot>\n                         (slength\\<cdot>(a :# ys)) =\n                         TT", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>xs.\n       prefix\\<cdot>xs\\<cdot>\\<bottom> = TT \\<Longrightarrow>\n       le\\<cdot>(slength\\<cdot>xs)\\<cdot>(slength\\<cdot>\\<bottom>) = TT\n 2. \\<And>a ys xs.\n       \\<lbrakk>a \\<noteq> \\<bottom>; ys \\<noteq> \\<bottom>;\n        \\<And>xs.\n           prefix\\<cdot>xs\\<cdot>ys = TT \\<Longrightarrow>\n           le\\<cdot>(slength\\<cdot>xs)\\<cdot>(slength\\<cdot>ys) = TT;\n        prefix\\<cdot>xs\\<cdot>(a :# ys) = TT\\<rbrakk>\n       \\<Longrightarrow> le\\<cdot>(slength\\<cdot>xs)\\<cdot>\n                         (slength\\<cdot>(a :# ys)) =\n                         TT", "case (scons a ys)"], ["proof (state)\nthis:\n  a \\<noteq> \\<bottom>\n  ys \\<noteq> \\<bottom>\n  prefix\\<cdot>?xs\\<cdot>ys = TT \\<Longrightarrow>\n  le\\<cdot>(slength\\<cdot>?xs)\\<cdot>(slength\\<cdot>ys) = TT\n  prefix\\<cdot>xs\\<cdot>(a :# ys) = TT\n\ngoal (2 subgoals):\n 1. \\<And>xs.\n       prefix\\<cdot>xs\\<cdot>\\<bottom> = TT \\<Longrightarrow>\n       le\\<cdot>(slength\\<cdot>xs)\\<cdot>(slength\\<cdot>\\<bottom>) = TT\n 2. \\<And>a ys xs.\n       \\<lbrakk>a \\<noteq> \\<bottom>; ys \\<noteq> \\<bottom>;\n        \\<And>xs.\n           prefix\\<cdot>xs\\<cdot>ys = TT \\<Longrightarrow>\n           le\\<cdot>(slength\\<cdot>xs)\\<cdot>(slength\\<cdot>ys) = TT;\n        prefix\\<cdot>xs\\<cdot>(a :# ys) = TT\\<rbrakk>\n       \\<Longrightarrow> le\\<cdot>(slength\\<cdot>xs)\\<cdot>\n                         (slength\\<cdot>(a :# ys)) =\n                         TT", "then"], ["proof (chain)\npicking this:\n  a \\<noteq> \\<bottom>\n  ys \\<noteq> \\<bottom>\n  prefix\\<cdot>?xs\\<cdot>ys = TT \\<Longrightarrow>\n  le\\<cdot>(slength\\<cdot>?xs)\\<cdot>(slength\\<cdot>ys) = TT\n  prefix\\<cdot>xs\\<cdot>(a :# ys) = TT", "show ?case"], ["proof (prove)\nusing this:\n  a \\<noteq> \\<bottom>\n  ys \\<noteq> \\<bottom>\n  prefix\\<cdot>?xs\\<cdot>ys = TT \\<Longrightarrow>\n  le\\<cdot>(slength\\<cdot>?xs)\\<cdot>(slength\\<cdot>ys) = TT\n  prefix\\<cdot>xs\\<cdot>(a :# ys) = TT\n\ngoal (1 subgoal):\n 1. le\\<cdot>(slength\\<cdot>xs)\\<cdot>(slength\\<cdot>(a :# ys)) = TT", "by (cases xs) (simp_all add: le_plus_1)"], ["proof (state)\nthis:\n  le\\<cdot>(slength\\<cdot>xs)\\<cdot>(slength\\<cdot>(a :# ys)) = TT\n\ngoal (1 subgoal):\n 1. \\<And>xs.\n       prefix\\<cdot>xs\\<cdot>\\<bottom> = TT \\<Longrightarrow>\n       le\\<cdot>(slength\\<cdot>xs)\\<cdot>(slength\\<cdot>\\<bottom>) = TT", "qed simp"], ["", "lemma prefix_slength_strengthen: \"prefix\\<cdot>xs\\<cdot>ys = (le\\<cdot>(slength\\<cdot>xs)\\<cdot>(slength\\<cdot>ys) andalso prefix\\<cdot>xs\\<cdot>ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix\\<cdot>xs\\<cdot>ys =\n    (le\\<cdot>(slength\\<cdot>xs)\\<cdot>\n     (slength\\<cdot>ys) andalso prefix\\<cdot>xs\\<cdot>ys)", "by (rule andalso_weaken_left) (auto dest: prefix_slength)"], ["", "lemma prefix_scons_snil[simp]: \"prefix\\<cdot>(x :# xs)\\<cdot>[::] \\<noteq> TT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix\\<cdot>(x :# xs)\\<cdot>[::] \\<noteq> TT", "by (cases \"x :# xs \\<noteq> \\<bottom>\") auto"], ["", "lemma scons_prefix_scons[simp]:\n  \"(prefix\\<cdot>(x :# xs)\\<cdot>(y :# ys) = TT) \\<longleftrightarrow> (eq\\<cdot>x\\<cdot>y = TT \\<and> prefix\\<cdot>xs\\<cdot>ys = TT)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (prefix\\<cdot>(x :# xs)\\<cdot>(y :# ys) = TT) =\n    (eq\\<cdot>x\\<cdot>y = TT \\<and> prefix\\<cdot>xs\\<cdot>ys = TT)", "by (cases \"x :# xs \\<noteq> \\<bottom> \\<and> y :# ys \\<noteq> \\<bottom>\") auto"], ["", "lemma append_prefixD:\n  assumes \"prefix\\<cdot>(xs :@ ys)\\<cdot>zs = TT\"\n  shows \"prefix\\<cdot>xs\\<cdot>zs = TT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix\\<cdot>xs\\<cdot>zs = TT", "using assms"], ["proof (prove)\nusing this:\n  prefix\\<cdot>(xs :@ ys)\\<cdot>zs = TT\n\ngoal (1 subgoal):\n 1. prefix\\<cdot>xs\\<cdot>zs = TT", "proof(induct xs arbitrary: zs)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>zs.\n       prefix\\<cdot>(\\<bottom> :@ ys)\\<cdot>zs = TT \\<Longrightarrow>\n       prefix\\<cdot>\\<bottom>\\<cdot>zs = TT\n 2. \\<And>zs.\n       prefix\\<cdot>([::] :@ ys)\\<cdot>zs = TT \\<Longrightarrow>\n       prefix\\<cdot>[::]\\<cdot>zs = TT\n 3. \\<And>a xs zs.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>zs.\n           prefix\\<cdot>(xs :@ ys)\\<cdot>zs = TT \\<Longrightarrow>\n           prefix\\<cdot>xs\\<cdot>zs = TT;\n        prefix\\<cdot>((a :# xs) :@ ys)\\<cdot>zs = TT\\<rbrakk>\n       \\<Longrightarrow> prefix\\<cdot>(a :# xs)\\<cdot>zs = TT", "case (snil zs)"], ["proof (state)\nthis:\n  prefix\\<cdot>([::] :@ ys)\\<cdot>zs = TT\n\ngoal (3 subgoals):\n 1. \\<And>zs.\n       prefix\\<cdot>(\\<bottom> :@ ys)\\<cdot>zs = TT \\<Longrightarrow>\n       prefix\\<cdot>\\<bottom>\\<cdot>zs = TT\n 2. \\<And>zs.\n       prefix\\<cdot>([::] :@ ys)\\<cdot>zs = TT \\<Longrightarrow>\n       prefix\\<cdot>[::]\\<cdot>zs = TT\n 3. \\<And>a xs zs.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>zs.\n           prefix\\<cdot>(xs :@ ys)\\<cdot>zs = TT \\<Longrightarrow>\n           prefix\\<cdot>xs\\<cdot>zs = TT;\n        prefix\\<cdot>((a :# xs) :@ ys)\\<cdot>zs = TT\\<rbrakk>\n       \\<Longrightarrow> prefix\\<cdot>(a :# xs)\\<cdot>zs = TT", "then"], ["proof (chain)\npicking this:\n  prefix\\<cdot>([::] :@ ys)\\<cdot>zs = TT", "show ?case"], ["proof (prove)\nusing this:\n  prefix\\<cdot>([::] :@ ys)\\<cdot>zs = TT\n\ngoal (1 subgoal):\n 1. prefix\\<cdot>[::]\\<cdot>zs = TT", "using prefix.simps(2)"], ["proof (prove)\nusing this:\n  prefix\\<cdot>([::] :@ ys)\\<cdot>zs = TT\n  ?ys \\<noteq> \\<bottom> \\<Longrightarrow> prefix\\<cdot>[::]\\<cdot>?ys = TT\n\ngoal (1 subgoal):\n 1. prefix\\<cdot>[::]\\<cdot>zs = TT", "by force"], ["proof (state)\nthis:\n  prefix\\<cdot>[::]\\<cdot>zs = TT\n\ngoal (2 subgoals):\n 1. \\<And>zs.\n       prefix\\<cdot>(\\<bottom> :@ ys)\\<cdot>zs = TT \\<Longrightarrow>\n       prefix\\<cdot>\\<bottom>\\<cdot>zs = TT\n 2. \\<And>a xs zs.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>zs.\n           prefix\\<cdot>(xs :@ ys)\\<cdot>zs = TT \\<Longrightarrow>\n           prefix\\<cdot>xs\\<cdot>zs = TT;\n        prefix\\<cdot>((a :# xs) :@ ys)\\<cdot>zs = TT\\<rbrakk>\n       \\<Longrightarrow> prefix\\<cdot>(a :# xs)\\<cdot>zs = TT", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>zs.\n       prefix\\<cdot>(\\<bottom> :@ ys)\\<cdot>zs = TT \\<Longrightarrow>\n       prefix\\<cdot>\\<bottom>\\<cdot>zs = TT\n 2. \\<And>a xs zs.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>zs.\n           prefix\\<cdot>(xs :@ ys)\\<cdot>zs = TT \\<Longrightarrow>\n           prefix\\<cdot>xs\\<cdot>zs = TT;\n        prefix\\<cdot>((a :# xs) :@ ys)\\<cdot>zs = TT\\<rbrakk>\n       \\<Longrightarrow> prefix\\<cdot>(a :# xs)\\<cdot>zs = TT", "case (scons x xs zs)"], ["proof (state)\nthis:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  prefix\\<cdot>(xs :@ ys)\\<cdot>?zs = TT \\<Longrightarrow>\n  prefix\\<cdot>xs\\<cdot>?zs = TT\n  prefix\\<cdot>((x :# xs) :@ ys)\\<cdot>zs = TT\n\ngoal (2 subgoals):\n 1. \\<And>zs.\n       prefix\\<cdot>(\\<bottom> :@ ys)\\<cdot>zs = TT \\<Longrightarrow>\n       prefix\\<cdot>\\<bottom>\\<cdot>zs = TT\n 2. \\<And>a xs zs.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>zs.\n           prefix\\<cdot>(xs :@ ys)\\<cdot>zs = TT \\<Longrightarrow>\n           prefix\\<cdot>xs\\<cdot>zs = TT;\n        prefix\\<cdot>((a :# xs) :@ ys)\\<cdot>zs = TT\\<rbrakk>\n       \\<Longrightarrow> prefix\\<cdot>(a :# xs)\\<cdot>zs = TT", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  prefix\\<cdot>(xs :@ ys)\\<cdot>?zs = TT \\<Longrightarrow>\n  prefix\\<cdot>xs\\<cdot>?zs = TT\n  prefix\\<cdot>((x :# xs) :@ ys)\\<cdot>zs = TT", "show ?case"], ["proof (prove)\nusing this:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  prefix\\<cdot>(xs :@ ys)\\<cdot>?zs = TT \\<Longrightarrow>\n  prefix\\<cdot>xs\\<cdot>?zs = TT\n  prefix\\<cdot>((x :# xs) :@ ys)\\<cdot>zs = TT\n\ngoal (1 subgoal):\n 1. prefix\\<cdot>(x :# xs)\\<cdot>zs = TT", "by (metis prefix.simps(1) prefix_scons_snil sappend_scons scons_prefix_scons slist.exhaust)"], ["proof (state)\nthis:\n  prefix\\<cdot>(x :# xs)\\<cdot>zs = TT\n\ngoal (1 subgoal):\n 1. \\<And>zs.\n       prefix\\<cdot>(\\<bottom> :@ ys)\\<cdot>zs = TT \\<Longrightarrow>\n       prefix\\<cdot>\\<bottom>\\<cdot>zs = TT", "qed simp"], ["", "lemma same_prefix_prefix[simp]:\n  assumes \"xs \\<noteq> \\<bottom>\"\n  shows \"prefix\\<cdot>(xs :@ ys)\\<cdot>(xs :@ zs) = prefix\\<cdot>ys\\<cdot>zs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix\\<cdot>(xs :@ ys)\\<cdot>(xs :@ zs) = prefix\\<cdot>ys\\<cdot>zs", "using assms"], ["proof (prove)\nusing this:\n  xs \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. prefix\\<cdot>(xs :@ ys)\\<cdot>(xs :@ zs) = prefix\\<cdot>ys\\<cdot>zs", "proof(cases \"ys = \\<bottom>\" \"zs = \\<bottom>\" rule: bool.exhaust[case_product bool.exhaust])"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<lbrakk>xs \\<noteq> \\<bottom>; (ys = \\<bottom>) = True;\n     (zs = \\<bottom>) = True\\<rbrakk>\n    \\<Longrightarrow> prefix\\<cdot>(xs :@ ys)\\<cdot>(xs :@ zs) =\n                      prefix\\<cdot>ys\\<cdot>zs\n 2. \\<lbrakk>xs \\<noteq> \\<bottom>; (ys = \\<bottom>) = True;\n     (zs = \\<bottom>) = False\\<rbrakk>\n    \\<Longrightarrow> prefix\\<cdot>(xs :@ ys)\\<cdot>(xs :@ zs) =\n                      prefix\\<cdot>ys\\<cdot>zs\n 3. \\<lbrakk>xs \\<noteq> \\<bottom>; (ys = \\<bottom>) = False;\n     (zs = \\<bottom>) = True\\<rbrakk>\n    \\<Longrightarrow> prefix\\<cdot>(xs :@ ys)\\<cdot>(xs :@ zs) =\n                      prefix\\<cdot>ys\\<cdot>zs\n 4. \\<lbrakk>xs \\<noteq> \\<bottom>; (ys = \\<bottom>) = False;\n     (zs = \\<bottom>) = False\\<rbrakk>\n    \\<Longrightarrow> prefix\\<cdot>(xs :@ ys)\\<cdot>(xs :@ zs) =\n                      prefix\\<cdot>ys\\<cdot>zs", "case False_False"], ["proof (state)\nthis:\n  (ys = \\<bottom>) = False\n  (zs = \\<bottom>) = False\n\ngoal (4 subgoals):\n 1. \\<lbrakk>xs \\<noteq> \\<bottom>; (ys = \\<bottom>) = True;\n     (zs = \\<bottom>) = True\\<rbrakk>\n    \\<Longrightarrow> prefix\\<cdot>(xs :@ ys)\\<cdot>(xs :@ zs) =\n                      prefix\\<cdot>ys\\<cdot>zs\n 2. \\<lbrakk>xs \\<noteq> \\<bottom>; (ys = \\<bottom>) = True;\n     (zs = \\<bottom>) = False\\<rbrakk>\n    \\<Longrightarrow> prefix\\<cdot>(xs :@ ys)\\<cdot>(xs :@ zs) =\n                      prefix\\<cdot>ys\\<cdot>zs\n 3. \\<lbrakk>xs \\<noteq> \\<bottom>; (ys = \\<bottom>) = False;\n     (zs = \\<bottom>) = True\\<rbrakk>\n    \\<Longrightarrow> prefix\\<cdot>(xs :@ ys)\\<cdot>(xs :@ zs) =\n                      prefix\\<cdot>ys\\<cdot>zs\n 4. \\<lbrakk>xs \\<noteq> \\<bottom>; (ys = \\<bottom>) = False;\n     (zs = \\<bottom>) = False\\<rbrakk>\n    \\<Longrightarrow> prefix\\<cdot>(xs :@ ys)\\<cdot>(xs :@ zs) =\n                      prefix\\<cdot>ys\\<cdot>zs", "with assms"], ["proof (chain)\npicking this:\n  xs \\<noteq> \\<bottom>\n  (ys = \\<bottom>) = False\n  (zs = \\<bottom>) = False", "show ?thesis"], ["proof (prove)\nusing this:\n  xs \\<noteq> \\<bottom>\n  (ys = \\<bottom>) = False\n  (zs = \\<bottom>) = False\n\ngoal (1 subgoal):\n 1. prefix\\<cdot>(xs :@ ys)\\<cdot>(xs :@ zs) = prefix\\<cdot>ys\\<cdot>zs", "by (induct xs) simp_all"], ["proof (state)\nthis:\n  prefix\\<cdot>(xs :@ ys)\\<cdot>(xs :@ zs) = prefix\\<cdot>ys\\<cdot>zs\n\ngoal (3 subgoals):\n 1. \\<lbrakk>xs \\<noteq> \\<bottom>; (ys = \\<bottom>) = True;\n     (zs = \\<bottom>) = True\\<rbrakk>\n    \\<Longrightarrow> prefix\\<cdot>(xs :@ ys)\\<cdot>(xs :@ zs) =\n                      prefix\\<cdot>ys\\<cdot>zs\n 2. \\<lbrakk>xs \\<noteq> \\<bottom>; (ys = \\<bottom>) = True;\n     (zs = \\<bottom>) = False\\<rbrakk>\n    \\<Longrightarrow> prefix\\<cdot>(xs :@ ys)\\<cdot>(xs :@ zs) =\n                      prefix\\<cdot>ys\\<cdot>zs\n 3. \\<lbrakk>xs \\<noteq> \\<bottom>; (ys = \\<bottom>) = False;\n     (zs = \\<bottom>) = True\\<rbrakk>\n    \\<Longrightarrow> prefix\\<cdot>(xs :@ ys)\\<cdot>(xs :@ zs) =\n                      prefix\\<cdot>ys\\<cdot>zs", "qed simp_all"], ["", "lemma eq_prefix_TT:\n  assumes \"eq\\<cdot>xs\\<cdot>ys = TT\"\n  shows \"prefix\\<cdot>xs\\<cdot>ys = TT\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix\\<cdot>xs\\<cdot>ys = TT", "using assms"], ["proof (prove)\nusing this:\n  eq\\<cdot>xs\\<cdot>ys = TT\n\ngoal (1 subgoal):\n 1. prefix\\<cdot>xs\\<cdot>ys = TT", "by (induct xs arbitrary: ys) (case_tac ys; simp)+"], ["", "lemma prefix_eq_FF:\n  assumes \"prefix\\<cdot>xs\\<cdot>ys = FF\"\n  shows \"eq\\<cdot>xs\\<cdot>ys = FF\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq\\<cdot>xs\\<cdot>ys = FF", "using assms"], ["proof (prove)\nusing this:\n  prefix\\<cdot>xs\\<cdot>ys = FF\n\ngoal (1 subgoal):\n 1. eq\\<cdot>xs\\<cdot>ys = FF", "by (induct xs arbitrary: ys) (case_tac ys; auto)+"], ["", "lemma prefix_slength_eq:\n  shows \"eq\\<cdot>xs\\<cdot>ys = (eq\\<cdot>(slength\\<cdot>xs)\\<cdot>(slength\\<cdot>ys) andalso prefix\\<cdot>xs\\<cdot>ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq\\<cdot>xs\\<cdot>ys =\n    (eq\\<cdot>(slength\\<cdot>xs)\\<cdot>\n     (slength\\<cdot>ys) andalso prefix\\<cdot>xs\\<cdot>ys)", "proof(induct xs arbitrary: ys)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ys.\n       eq\\<cdot>\\<bottom>\\<cdot>ys =\n       (eq\\<cdot>(slength\\<cdot>\\<bottom>)\\<cdot>\n        (slength\\<cdot>ys) andalso prefix\\<cdot>\\<bottom>\\<cdot>ys)\n 2. \\<And>ys.\n       eq\\<cdot>[::]\\<cdot>ys =\n       (eq\\<cdot>(slength\\<cdot>[::])\\<cdot>\n        (slength\\<cdot>ys) andalso prefix\\<cdot>[::]\\<cdot>ys)\n 3. \\<And>a xs ys.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>ys.\n           eq\\<cdot>xs\\<cdot>ys =\n           (eq\\<cdot>(slength\\<cdot>xs)\\<cdot>\n            (slength\\<cdot>ys) andalso prefix\\<cdot>xs\\<cdot>ys)\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>(a :# xs)\\<cdot>ys =\n                         (eq\\<cdot>(slength\\<cdot>(a :# xs))\\<cdot>\n                          (slength\\<cdot>\n                           ys) andalso prefix\\<cdot>(a :# xs)\\<cdot>ys)", "case (snil ys)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>ys.\n       eq\\<cdot>\\<bottom>\\<cdot>ys =\n       (eq\\<cdot>(slength\\<cdot>\\<bottom>)\\<cdot>\n        (slength\\<cdot>ys) andalso prefix\\<cdot>\\<bottom>\\<cdot>ys)\n 2. \\<And>ys.\n       eq\\<cdot>[::]\\<cdot>ys =\n       (eq\\<cdot>(slength\\<cdot>[::])\\<cdot>\n        (slength\\<cdot>ys) andalso prefix\\<cdot>[::]\\<cdot>ys)\n 3. \\<And>a xs ys.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>ys.\n           eq\\<cdot>xs\\<cdot>ys =\n           (eq\\<cdot>(slength\\<cdot>xs)\\<cdot>\n            (slength\\<cdot>ys) andalso prefix\\<cdot>xs\\<cdot>ys)\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>(a :# xs)\\<cdot>ys =\n                         (eq\\<cdot>(slength\\<cdot>(a :# xs))\\<cdot>\n                          (slength\\<cdot>\n                           ys) andalso prefix\\<cdot>(a :# xs)\\<cdot>ys)", "then"], ["proof (chain)\npicking this:", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. eq\\<cdot>[::]\\<cdot>ys =\n    (eq\\<cdot>(slength\\<cdot>[::])\\<cdot>\n     (slength\\<cdot>ys) andalso prefix\\<cdot>[::]\\<cdot>ys)", "by (cases ys; clarsimp simp: one_Integer_def elim!: slengthE)"], ["proof (state)\nthis:\n  eq\\<cdot>[::]\\<cdot>ys =\n  (eq\\<cdot>(slength\\<cdot>[::])\\<cdot>\n   (slength\\<cdot>ys) andalso prefix\\<cdot>[::]\\<cdot>ys)\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       eq\\<cdot>\\<bottom>\\<cdot>ys =\n       (eq\\<cdot>(slength\\<cdot>\\<bottom>)\\<cdot>\n        (slength\\<cdot>ys) andalso prefix\\<cdot>\\<bottom>\\<cdot>ys)\n 2. \\<And>a xs ys.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>ys.\n           eq\\<cdot>xs\\<cdot>ys =\n           (eq\\<cdot>(slength\\<cdot>xs)\\<cdot>\n            (slength\\<cdot>ys) andalso prefix\\<cdot>xs\\<cdot>ys)\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>(a :# xs)\\<cdot>ys =\n                         (eq\\<cdot>(slength\\<cdot>(a :# xs))\\<cdot>\n                          (slength\\<cdot>\n                           ys) andalso prefix\\<cdot>(a :# xs)\\<cdot>ys)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       eq\\<cdot>\\<bottom>\\<cdot>ys =\n       (eq\\<cdot>(slength\\<cdot>\\<bottom>)\\<cdot>\n        (slength\\<cdot>ys) andalso prefix\\<cdot>\\<bottom>\\<cdot>ys)\n 2. \\<And>a xs ys.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>ys.\n           eq\\<cdot>xs\\<cdot>ys =\n           (eq\\<cdot>(slength\\<cdot>xs)\\<cdot>\n            (slength\\<cdot>ys) andalso prefix\\<cdot>xs\\<cdot>ys)\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>(a :# xs)\\<cdot>ys =\n                         (eq\\<cdot>(slength\\<cdot>(a :# xs))\\<cdot>\n                          (slength\\<cdot>\n                           ys) andalso prefix\\<cdot>(a :# xs)\\<cdot>ys)", "case (scons x xs ys)"], ["proof (state)\nthis:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  eq\\<cdot>xs\\<cdot>?ys =\n  (eq\\<cdot>(slength\\<cdot>xs)\\<cdot>\n   (slength\\<cdot>?ys) andalso prefix\\<cdot>xs\\<cdot>?ys)\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       eq\\<cdot>\\<bottom>\\<cdot>ys =\n       (eq\\<cdot>(slength\\<cdot>\\<bottom>)\\<cdot>\n        (slength\\<cdot>ys) andalso prefix\\<cdot>\\<bottom>\\<cdot>ys)\n 2. \\<And>a xs ys.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>ys.\n           eq\\<cdot>xs\\<cdot>ys =\n           (eq\\<cdot>(slength\\<cdot>xs)\\<cdot>\n            (slength\\<cdot>ys) andalso prefix\\<cdot>xs\\<cdot>ys)\\<rbrakk>\n       \\<Longrightarrow> eq\\<cdot>(a :# xs)\\<cdot>ys =\n                         (eq\\<cdot>(slength\\<cdot>(a :# xs))\\<cdot>\n                          (slength\\<cdot>\n                           ys) andalso prefix\\<cdot>(a :# xs)\\<cdot>ys)", "then"], ["proof (chain)\npicking this:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  eq\\<cdot>xs\\<cdot>?ys =\n  (eq\\<cdot>(slength\\<cdot>xs)\\<cdot>\n   (slength\\<cdot>?ys) andalso prefix\\<cdot>xs\\<cdot>?ys)", "show ?case"], ["proof (prove)\nusing this:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  eq\\<cdot>xs\\<cdot>?ys =\n  (eq\\<cdot>(slength\\<cdot>xs)\\<cdot>\n   (slength\\<cdot>?ys) andalso prefix\\<cdot>xs\\<cdot>?ys)\n\ngoal (1 subgoal):\n 1. eq\\<cdot>(x :# xs)\\<cdot>ys =\n    (eq\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>\n     (slength\\<cdot>ys) andalso prefix\\<cdot>(x :# xs)\\<cdot>ys)", "by (cases ys; clarsimp simp: zero_Integer_def one_Integer_def elim!: slengthE)"], ["proof (state)\nthis:\n  eq\\<cdot>(x :# xs)\\<cdot>ys =\n  (eq\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>\n   (slength\\<cdot>ys) andalso prefix\\<cdot>(x :# xs)\\<cdot>ys)\n\ngoal (1 subgoal):\n 1. \\<And>ys.\n       eq\\<cdot>\\<bottom>\\<cdot>ys =\n       (eq\\<cdot>(slength\\<cdot>\\<bottom>)\\<cdot>\n        (slength\\<cdot>ys) andalso prefix\\<cdot>\\<bottom>\\<cdot>ys)", "qed simp"], ["", "lemma stake_slength_plus_1:\n  shows \"stake\\<cdot>(slength\\<cdot>xs + 1)\\<cdot>(y :# ys) = y :# stake\\<cdot>(slength\\<cdot>xs)\\<cdot>ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. stake\\<cdot>(slength\\<cdot>xs + 1)\\<cdot>(y :# ys) =\n    y :# stake\\<cdot>(slength\\<cdot>xs)\\<cdot>ys", "by (cases \"xs = \\<bottom>\" \"y = \\<bottom>\" \"ys = \\<bottom>\" rule: bool.exhaust[case_product bool.exhaust bool.exhaust]; clarsimp)\n   (auto simp: If2_def[symmetric] zero_Integer_def one_Integer_def split: If2_splits elim!: slengthE)"], ["", "lemma sdrop_slength_plus_1:\n  assumes \"y \\<noteq> \\<bottom>\"\n  shows \"sdrop\\<cdot>(slength\\<cdot>xs + 1)\\<cdot>(y :# ys) = sdrop\\<cdot>(slength\\<cdot>xs)\\<cdot>ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. sdrop\\<cdot>(slength\\<cdot>xs + 1)\\<cdot>(y :# ys) =\n    sdrop\\<cdot>(slength\\<cdot>xs)\\<cdot>ys", "using assms"], ["proof (prove)\nusing this:\n  y \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. sdrop\\<cdot>(slength\\<cdot>xs + 1)\\<cdot>(y :# ys) =\n    sdrop\\<cdot>(slength\\<cdot>xs)\\<cdot>ys", "by (subst sdrop.simps;\n    cases \"xs = \\<bottom>\"; clarsimp; cases \"ys = \\<bottom>\";\n    clarsimp simp: If2_def[symmetric] zero_Integer_def one_Integer_def split: If2_splits elim!: slengthE)"], ["", "lemma eq_take_length_prefix: \"prefix\\<cdot>xs\\<cdot>ys = eq\\<cdot>xs\\<cdot>(stake\\<cdot>(slength\\<cdot>xs)\\<cdot>ys)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix\\<cdot>xs\\<cdot>ys =\n    eq\\<cdot>xs\\<cdot>(stake\\<cdot>(slength\\<cdot>xs)\\<cdot>ys)", "proof (induct xs arbitrary: ys)"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ys.\n       prefix\\<cdot>\\<bottom>\\<cdot>ys =\n       eq\\<cdot>\\<bottom>\\<cdot>\n       (stake\\<cdot>(slength\\<cdot>\\<bottom>)\\<cdot>ys)\n 2. \\<And>ys.\n       prefix\\<cdot>[::]\\<cdot>ys =\n       eq\\<cdot>[::]\\<cdot>(stake\\<cdot>(slength\\<cdot>[::])\\<cdot>ys)\n 3. \\<And>a xs ys.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>ys.\n           prefix\\<cdot>xs\\<cdot>ys =\n           eq\\<cdot>xs\\<cdot>\n           (stake\\<cdot>(slength\\<cdot>xs)\\<cdot>ys)\\<rbrakk>\n       \\<Longrightarrow> prefix\\<cdot>(a :# xs)\\<cdot>ys =\n                         eq\\<cdot>(a :# xs)\\<cdot>\n                         (stake\\<cdot>(slength\\<cdot>(a :# xs))\\<cdot>ys)", "case (snil ys)"], ["proof (state)\nthis:\n  \n\ngoal (3 subgoals):\n 1. \\<And>ys.\n       prefix\\<cdot>\\<bottom>\\<cdot>ys =\n       eq\\<cdot>\\<bottom>\\<cdot>\n       (stake\\<cdot>(slength\\<cdot>\\<bottom>)\\<cdot>ys)\n 2. \\<And>ys.\n       prefix\\<cdot>[::]\\<cdot>ys =\n       eq\\<cdot>[::]\\<cdot>(stake\\<cdot>(slength\\<cdot>[::])\\<cdot>ys)\n 3. \\<And>a xs ys.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>ys.\n           prefix\\<cdot>xs\\<cdot>ys =\n           eq\\<cdot>xs\\<cdot>\n           (stake\\<cdot>(slength\\<cdot>xs)\\<cdot>ys)\\<rbrakk>\n       \\<Longrightarrow> prefix\\<cdot>(a :# xs)\\<cdot>ys =\n                         eq\\<cdot>(a :# xs)\\<cdot>\n                         (stake\\<cdot>(slength\\<cdot>(a :# xs))\\<cdot>ys)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix\\<cdot>[::]\\<cdot>ys =\n    eq\\<cdot>[::]\\<cdot>(stake\\<cdot>(slength\\<cdot>[::])\\<cdot>ys)", "by (cases ys; clarsimp)"], ["proof (state)\nthis:\n  prefix\\<cdot>[::]\\<cdot>ys =\n  eq\\<cdot>[::]\\<cdot>(stake\\<cdot>(slength\\<cdot>[::])\\<cdot>ys)\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       prefix\\<cdot>\\<bottom>\\<cdot>ys =\n       eq\\<cdot>\\<bottom>\\<cdot>\n       (stake\\<cdot>(slength\\<cdot>\\<bottom>)\\<cdot>ys)\n 2. \\<And>a xs ys.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>ys.\n           prefix\\<cdot>xs\\<cdot>ys =\n           eq\\<cdot>xs\\<cdot>\n           (stake\\<cdot>(slength\\<cdot>xs)\\<cdot>ys)\\<rbrakk>\n       \\<Longrightarrow> prefix\\<cdot>(a :# xs)\\<cdot>ys =\n                         eq\\<cdot>(a :# xs)\\<cdot>\n                         (stake\\<cdot>(slength\\<cdot>(a :# xs))\\<cdot>ys)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ys.\n       prefix\\<cdot>\\<bottom>\\<cdot>ys =\n       eq\\<cdot>\\<bottom>\\<cdot>\n       (stake\\<cdot>(slength\\<cdot>\\<bottom>)\\<cdot>ys)\n 2. \\<And>a xs ys.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>ys.\n           prefix\\<cdot>xs\\<cdot>ys =\n           eq\\<cdot>xs\\<cdot>\n           (stake\\<cdot>(slength\\<cdot>xs)\\<cdot>ys)\\<rbrakk>\n       \\<Longrightarrow> prefix\\<cdot>(a :# xs)\\<cdot>ys =\n                         eq\\<cdot>(a :# xs)\\<cdot>\n                         (stake\\<cdot>(slength\\<cdot>(a :# xs))\\<cdot>ys)", "case (scons x xs ys)"], ["proof (state)\nthis:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  prefix\\<cdot>xs\\<cdot>?ys =\n  eq\\<cdot>xs\\<cdot>(stake\\<cdot>(slength\\<cdot>xs)\\<cdot>?ys)\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       prefix\\<cdot>\\<bottom>\\<cdot>ys =\n       eq\\<cdot>\\<bottom>\\<cdot>\n       (stake\\<cdot>(slength\\<cdot>\\<bottom>)\\<cdot>ys)\n 2. \\<And>a xs ys.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>ys.\n           prefix\\<cdot>xs\\<cdot>ys =\n           eq\\<cdot>xs\\<cdot>\n           (stake\\<cdot>(slength\\<cdot>xs)\\<cdot>ys)\\<rbrakk>\n       \\<Longrightarrow> prefix\\<cdot>(a :# xs)\\<cdot>ys =\n                         eq\\<cdot>(a :# xs)\\<cdot>\n                         (stake\\<cdot>(slength\\<cdot>(a :# xs))\\<cdot>ys)", "note IH = this"], ["proof (state)\nthis:\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  prefix\\<cdot>xs\\<cdot>?ys =\n  eq\\<cdot>xs\\<cdot>(stake\\<cdot>(slength\\<cdot>xs)\\<cdot>?ys)\n\ngoal (2 subgoals):\n 1. \\<And>ys.\n       prefix\\<cdot>\\<bottom>\\<cdot>ys =\n       eq\\<cdot>\\<bottom>\\<cdot>\n       (stake\\<cdot>(slength\\<cdot>\\<bottom>)\\<cdot>ys)\n 2. \\<And>a xs ys.\n       \\<lbrakk>a \\<noteq> \\<bottom>; xs \\<noteq> \\<bottom>;\n        \\<And>ys.\n           prefix\\<cdot>xs\\<cdot>ys =\n           eq\\<cdot>xs\\<cdot>\n           (stake\\<cdot>(slength\\<cdot>xs)\\<cdot>ys)\\<rbrakk>\n       \\<Longrightarrow> prefix\\<cdot>(a :# xs)\\<cdot>ys =\n                         eq\\<cdot>(a :# xs)\\<cdot>\n                         (stake\\<cdot>(slength\\<cdot>(a :# xs))\\<cdot>ys)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix\\<cdot>(x :# xs)\\<cdot>ys =\n    eq\\<cdot>(x :# xs)\\<cdot>\n    (stake\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>ys)", "proof (cases \"slength\\<cdot>xs = \\<bottom>\")"], ["proof (state)\ngoal (2 subgoals):\n 1. slength\\<cdot>xs = \\<bottom> \\<Longrightarrow>\n    prefix\\<cdot>(x :# xs)\\<cdot>ys =\n    eq\\<cdot>(x :# xs)\\<cdot>\n    (stake\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>ys)\n 2. slength\\<cdot>xs \\<noteq> \\<bottom> \\<Longrightarrow>\n    prefix\\<cdot>(x :# xs)\\<cdot>ys =\n    eq\\<cdot>(x :# xs)\\<cdot>\n    (stake\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>ys)", "case True"], ["proof (state)\nthis:\n  slength\\<cdot>xs = \\<bottom>\n\ngoal (2 subgoals):\n 1. slength\\<cdot>xs = \\<bottom> \\<Longrightarrow>\n    prefix\\<cdot>(x :# xs)\\<cdot>ys =\n    eq\\<cdot>(x :# xs)\\<cdot>\n    (stake\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>ys)\n 2. slength\\<cdot>xs \\<noteq> \\<bottom> \\<Longrightarrow>\n    prefix\\<cdot>(x :# xs)\\<cdot>ys =\n    eq\\<cdot>(x :# xs)\\<cdot>\n    (stake\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>ys)", "then"], ["proof (chain)\npicking this:\n  slength\\<cdot>xs = \\<bottom>", "show ?thesis"], ["proof (prove)\nusing this:\n  slength\\<cdot>xs = \\<bottom>\n\ngoal (1 subgoal):\n 1. prefix\\<cdot>(x :# xs)\\<cdot>ys =\n    eq\\<cdot>(x :# xs)\\<cdot>\n    (stake\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>ys)", "by simp"], ["proof (state)\nthis:\n  prefix\\<cdot>(x :# xs)\\<cdot>ys =\n  eq\\<cdot>(x :# xs)\\<cdot>(stake\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>ys)\n\ngoal (1 subgoal):\n 1. slength\\<cdot>xs \\<noteq> \\<bottom> \\<Longrightarrow>\n    prefix\\<cdot>(x :# xs)\\<cdot>ys =\n    eq\\<cdot>(x :# xs)\\<cdot>\n    (stake\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. slength\\<cdot>xs \\<noteq> \\<bottom> \\<Longrightarrow>\n    prefix\\<cdot>(x :# xs)\\<cdot>ys =\n    eq\\<cdot>(x :# xs)\\<cdot>\n    (stake\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>ys)", "case False"], ["proof (state)\nthis:\n  slength\\<cdot>xs \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. slength\\<cdot>xs \\<noteq> \\<bottom> \\<Longrightarrow>\n    prefix\\<cdot>(x :# xs)\\<cdot>ys =\n    eq\\<cdot>(x :# xs)\\<cdot>\n    (stake\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>ys)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. prefix\\<cdot>(x :# xs)\\<cdot>ys =\n    eq\\<cdot>(x :# xs)\\<cdot>\n    (stake\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>ys)", "proof (cases ys)"], ["proof (state)\ngoal (3 subgoals):\n 1. ys = \\<bottom> \\<Longrightarrow>\n    prefix\\<cdot>(x :# xs)\\<cdot>ys =\n    eq\\<cdot>(x :# xs)\\<cdot>\n    (stake\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>ys)\n 2. ys = [::] \\<Longrightarrow>\n    prefix\\<cdot>(x :# xs)\\<cdot>ys =\n    eq\\<cdot>(x :# xs)\\<cdot>\n    (stake\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>ys)\n 3. \\<And>a slist.\n       \\<lbrakk>ys = a :# slist; a \\<noteq> \\<bottom>;\n        slist \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> prefix\\<cdot>(x :# xs)\\<cdot>ys =\n                         eq\\<cdot>(x :# xs)\\<cdot>\n                         (stake\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>ys)", "case bottom"], ["proof (state)\nthis:\n  ys = \\<bottom>\n\ngoal (3 subgoals):\n 1. ys = \\<bottom> \\<Longrightarrow>\n    prefix\\<cdot>(x :# xs)\\<cdot>ys =\n    eq\\<cdot>(x :# xs)\\<cdot>\n    (stake\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>ys)\n 2. ys = [::] \\<Longrightarrow>\n    prefix\\<cdot>(x :# xs)\\<cdot>ys =\n    eq\\<cdot>(x :# xs)\\<cdot>\n    (stake\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>ys)\n 3. \\<And>a slist.\n       \\<lbrakk>ys = a :# slist; a \\<noteq> \\<bottom>;\n        slist \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> prefix\\<cdot>(x :# xs)\\<cdot>ys =\n                         eq\\<cdot>(x :# xs)\\<cdot>\n                         (stake\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>ys)", "then"], ["proof (chain)\npicking this:\n  ys = \\<bottom>", "show ?thesis"], ["proof (prove)\nusing this:\n  ys = \\<bottom>\n\ngoal (1 subgoal):\n 1. prefix\\<cdot>(x :# xs)\\<cdot>ys =\n    eq\\<cdot>(x :# xs)\\<cdot>\n    (stake\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>ys)", "using False"], ["proof (prove)\nusing this:\n  ys = \\<bottom>\n  slength\\<cdot>xs \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. prefix\\<cdot>(x :# xs)\\<cdot>ys =\n    eq\\<cdot>(x :# xs)\\<cdot>\n    (stake\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>ys)", "using le_slength_plus[of xs 1]"], ["proof (prove)\nusing this:\n  ys = \\<bottom>\n  slength\\<cdot>xs \\<noteq> \\<bottom>\n  \\<lbrakk>xs \\<noteq> \\<bottom>; 1 \\<noteq> \\<bottom>\\<rbrakk>\n  \\<Longrightarrow> le\\<cdot>1\\<cdot>(slength\\<cdot>xs + 1) = TT\n\ngoal (1 subgoal):\n 1. prefix\\<cdot>(x :# xs)\\<cdot>ys =\n    eq\\<cdot>(x :# xs)\\<cdot>\n    (stake\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>ys)", "by simp"], ["proof (state)\nthis:\n  prefix\\<cdot>(x :# xs)\\<cdot>ys =\n  eq\\<cdot>(x :# xs)\\<cdot>(stake\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>ys)\n\ngoal (2 subgoals):\n 1. ys = [::] \\<Longrightarrow>\n    prefix\\<cdot>(x :# xs)\\<cdot>ys =\n    eq\\<cdot>(x :# xs)\\<cdot>\n    (stake\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>ys)\n 2. \\<And>a slist.\n       \\<lbrakk>ys = a :# slist; a \\<noteq> \\<bottom>;\n        slist \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> prefix\\<cdot>(x :# xs)\\<cdot>ys =\n                         eq\\<cdot>(x :# xs)\\<cdot>\n                         (stake\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>ys)", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. ys = [::] \\<Longrightarrow>\n    prefix\\<cdot>(x :# xs)\\<cdot>ys =\n    eq\\<cdot>(x :# xs)\\<cdot>\n    (stake\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>ys)\n 2. \\<And>a slist.\n       \\<lbrakk>ys = a :# slist; a \\<noteq> \\<bottom>;\n        slist \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> prefix\\<cdot>(x :# xs)\\<cdot>ys =\n                         eq\\<cdot>(x :# xs)\\<cdot>\n                         (stake\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>ys)", "case snil"], ["proof (state)\nthis:\n  ys = [::]\n\ngoal (2 subgoals):\n 1. ys = [::] \\<Longrightarrow>\n    prefix\\<cdot>(x :# xs)\\<cdot>ys =\n    eq\\<cdot>(x :# xs)\\<cdot>\n    (stake\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>ys)\n 2. \\<And>a slist.\n       \\<lbrakk>ys = a :# slist; a \\<noteq> \\<bottom>;\n        slist \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> prefix\\<cdot>(x :# xs)\\<cdot>ys =\n                         eq\\<cdot>(x :# xs)\\<cdot>\n                         (stake\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>ys)", "then"], ["proof (chain)\npicking this:\n  ys = [::]", "show ?thesis"], ["proof (prove)\nusing this:\n  ys = [::]\n\ngoal (1 subgoal):\n 1. prefix\\<cdot>(x :# xs)\\<cdot>ys =\n    eq\\<cdot>(x :# xs)\\<cdot>\n    (stake\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>ys)", "using False and IH(1,2)"], ["proof (prove)\nusing this:\n  ys = [::]\n  slength\\<cdot>xs \\<noteq> \\<bottom>\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. prefix\\<cdot>(x :# xs)\\<cdot>ys =\n    eq\\<cdot>(x :# xs)\\<cdot>\n    (stake\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>ys)", "by simp"], ["proof (state)\nthis:\n  prefix\\<cdot>(x :# xs)\\<cdot>ys =\n  eq\\<cdot>(x :# xs)\\<cdot>(stake\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>ys)\n\ngoal (1 subgoal):\n 1. \\<And>a slist.\n       \\<lbrakk>ys = a :# slist; a \\<noteq> \\<bottom>;\n        slist \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> prefix\\<cdot>(x :# xs)\\<cdot>ys =\n                         eq\\<cdot>(x :# xs)\\<cdot>\n                         (stake\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>ys)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a slist.\n       \\<lbrakk>ys = a :# slist; a \\<noteq> \\<bottom>;\n        slist \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> prefix\\<cdot>(x :# xs)\\<cdot>ys =\n                         eq\\<cdot>(x :# xs)\\<cdot>\n                         (stake\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>ys)", "case (scons z zs)"], ["proof (state)\nthis:\n  ys = z :# zs\n  z \\<noteq> \\<bottom>\n  zs \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. \\<And>a slist.\n       \\<lbrakk>ys = a :# slist; a \\<noteq> \\<bottom>;\n        slist \\<noteq> \\<bottom>\\<rbrakk>\n       \\<Longrightarrow> prefix\\<cdot>(x :# xs)\\<cdot>ys =\n                         eq\\<cdot>(x :# xs)\\<cdot>\n                         (stake\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>ys)", "then"], ["proof (chain)\npicking this:\n  ys = z :# zs\n  z \\<noteq> \\<bottom>\n  zs \\<noteq> \\<bottom>", "show ?thesis"], ["proof (prove)\nusing this:\n  ys = z :# zs\n  z \\<noteq> \\<bottom>\n  zs \\<noteq> \\<bottom>\n\ngoal (1 subgoal):\n 1. prefix\\<cdot>(x :# xs)\\<cdot>ys =\n    eq\\<cdot>(x :# xs)\\<cdot>\n    (stake\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>ys)", "using False and IH(1,2) IH(3)[of zs]"], ["proof (prove)\nusing this:\n  ys = z :# zs\n  z \\<noteq> \\<bottom>\n  zs \\<noteq> \\<bottom>\n  slength\\<cdot>xs \\<noteq> \\<bottom>\n  x \\<noteq> \\<bottom>\n  xs \\<noteq> \\<bottom>\n  prefix\\<cdot>xs\\<cdot>zs =\n  eq\\<cdot>xs\\<cdot>(stake\\<cdot>(slength\\<cdot>xs)\\<cdot>zs)\n\ngoal (1 subgoal):\n 1. prefix\\<cdot>(x :# xs)\\<cdot>ys =\n    eq\\<cdot>(x :# xs)\\<cdot>\n    (stake\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>ys)", "by (simp add: stake_slength_plus_1 monofun_cfun_arg)"], ["proof (state)\nthis:\n  prefix\\<cdot>(x :# xs)\\<cdot>ys =\n  eq\\<cdot>(x :# xs)\\<cdot>(stake\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prefix\\<cdot>(x :# xs)\\<cdot>ys =\n  eq\\<cdot>(x :# xs)\\<cdot>(stake\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>ys)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  prefix\\<cdot>(x :# xs)\\<cdot>ys =\n  eq\\<cdot>(x :# xs)\\<cdot>(stake\\<cdot>(slength\\<cdot>(x :# xs))\\<cdot>ys)\n\ngoal (1 subgoal):\n 1. \\<And>ys.\n       prefix\\<cdot>\\<bottom>\\<cdot>ys =\n       eq\\<cdot>\\<bottom>\\<cdot>\n       (stake\\<cdot>(slength\\<cdot>\\<bottom>)\\<cdot>ys)", "qed simp"], ["", "lemma prefix_sdrop_slength:\n  assumes \"prefix\\<cdot>xs\\<cdot>ys = TT\"\n  shows \"xs :@ sdrop\\<cdot>(slength\\<cdot>xs)\\<cdot>ys = ys\""], ["proof (prove)\ngoal (1 subgoal):\n 1. xs :@ sdrop\\<cdot>(slength\\<cdot>xs)\\<cdot>ys = ys", "using assms"], ["proof (prove)\nusing this:\n  prefix\\<cdot>xs\\<cdot>ys = TT\n\ngoal (1 subgoal):\n 1. xs :@ sdrop\\<cdot>(slength\\<cdot>xs)\\<cdot>ys = ys", "by (induct xs arbitrary: ys) (case_tac ys; simp add: sdrop_slength_plus_1)+"], ["", "lemma prefix_sdrop_prefix_eq:\n  assumes \"prefix\\<cdot>xs\\<cdot>ys = TT\"\n  shows \"eq\\<cdot>(sdrop\\<cdot>(slength\\<cdot>xs)\\<cdot>ys)\\<cdot>[::] = eq\\<cdot>ys\\<cdot>xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. eq\\<cdot>(sdrop\\<cdot>(slength\\<cdot>xs)\\<cdot>ys)\\<cdot>[::] =\n    eq\\<cdot>ys\\<cdot>xs", "using assms"], ["proof (prove)\nusing this:\n  prefix\\<cdot>xs\\<cdot>ys = TT\n\ngoal (1 subgoal):\n 1. eq\\<cdot>(sdrop\\<cdot>(slength\\<cdot>xs)\\<cdot>ys)\\<cdot>[::] =\n    eq\\<cdot>ys\\<cdot>xs", "by (induct xs arbitrary: ys) (case_tac ys; simp add: sdrop_slength_plus_1)+"], ["", "(*<*)"], ["", "end"], ["", "(*>*)"]]}