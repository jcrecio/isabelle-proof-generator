{"file_name": "/home/qj213/afp-2021-10-22/thys/XML/Xmlt.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/XML", "problem_names": ["lemma map_mono [partial_function_mono]:\n  fixes C :: \"xml \\<Rightarrow> ('b \\<Rightarrow> ('e +\\<^sub>\\<bottom> 'c)) \\<Rightarrow> 'e +\\<^sub>\\<bottom> 'd\"\n  assumes C: \"\\<And>y. y \\<in> set B \\<Longrightarrow> mono_sum_bot (C y)\"\n  shows \"mono_sum_bot (\\<lambda>f. map (\\<lambda>y. C y f) B)\"", "lemma guard_mono [partial_function_mono]:\n  assumes p1: \"\\<And>y. mono_sum_bot (p1 y)\"\n    and p2: \"\\<And>y. mono_sum_bot (p2 y)\"\n  shows \"mono_sum_bot (\\<lambda>g. Xmlt.guard p (\\<lambda>y. p1 y g) (\\<lambda>y. p2 y g) x)\"", "lemma singleton_mono [partial_function_mono]:\n  assumes p: \"\\<And>y. mono_sum_bot (p1 y)\"\n  shows \"mono_sum_bot (\\<lambda>g. Xmlt.singleton t (\\<lambda>y. p1 y g) f x)\"", "lemma pair_mono [partial_function_mono]:\n  assumes \"\\<And>y. mono_sum_bot (p1 y)\"\n    and \"\\<And>y. mono_sum_bot (p2 y)\"\n  shows \"mono_sum_bot (\\<lambda>g. Xmlt.pair t (\\<lambda>y. p1 y g) (\\<lambda> y. p2 y g) f x)\"", "lemma triple_mono [partial_function_mono]:\n  assumes \"\\<And>y. mono_sum_bot (p1 y)\"\n    and \"\\<And>y. mono_sum_bot (p2 y)\"\n    and \"\\<And>y. mono_sum_bot (p3 y)\"\n  shows \"mono_sum_bot (\\<lambda>g. Xmlt.triple t (\\<lambda>y. p1 y g) (\\<lambda> y. p2 y g) (\\<lambda> y. p3 y g) f x)\"", "lemma tuple4_mono [partial_function_mono]:\n  assumes \"\\<And>y. mono_sum_bot (p1 y)\"\n    and \"\\<And>y. mono_sum_bot (p2 y)\"\n    and \"\\<And>y. mono_sum_bot (p3 y)\"\n    and\"\\<And>y. mono_sum_bot (p4 y)\"\n  shows \"mono_sum_bot (\\<lambda>g. Xmlt.tuple4 t (\\<lambda>y. p1 y g) (\\<lambda> y. p2 y g) (\\<lambda> y. p3 y g) (\\<lambda> y. p4 y g) f x)\"", "lemma tuple5_mono [partial_function_mono]:\n  assumes \"\\<And>y. mono_sum_bot (p1 y)\"\n    and \"\\<And>y. mono_sum_bot (p2 y)\"\n    and \"\\<And>y. mono_sum_bot (p3 y)\"\n    and \"\\<And>y. mono_sum_bot (p4 y)\"\n    and \"\\<And>y. mono_sum_bot (p5 y)\"\n  shows \"mono_sum_bot (\\<lambda>g. Xmlt.tuple5 t (\\<lambda>y. p1 y g) (\\<lambda> y. p2 y g) (\\<lambda> y. p3 y g) (\\<lambda> y. p4 y g) (\\<lambda> y. p5 y g) f x)\"", "lemma tuple6_mono [partial_function_mono]:\n  assumes \"\\<And>y. mono_sum_bot (p1 y)\"\n    and \"\\<And>y. mono_sum_bot (p2 y)\"\n    and \"\\<And>y. mono_sum_bot (p3 y)\"\n    and \"\\<And>y. mono_sum_bot (p4 y)\"\n    and \"\\<And>y. mono_sum_bot (p5 y)\"\n    and \"\\<And>y. mono_sum_bot (p6 y)\"\n  shows \"mono_sum_bot (\\<lambda>g. Xmlt.tuple6 t (\\<lambda>y. p1 y g) (\\<lambda> y. p2 y g) (\\<lambda> y. p3 y g) (\\<lambda> y. p4 y g) (\\<lambda> y. p5 y g) (\\<lambda> y. p6 y g) f x)\"", "lemma optional_mono [partial_function_mono]:\n  assumes \"\\<And>y. mono_sum_bot (p1 y)\"\n  shows \"mono_sum_bot (\\<lambda>g. Xmlt.optional t (\\<lambda>y. p1 y g) f x)\"", "lemma xml1to2elements_mono[partial_function_mono]:\n  assumes p1: \"\\<And>y. mono_sum_bot (p1 y)\"\n              \"\\<And>y. mono_sum_bot (p2 y)\"\n  shows \"mono_sum_bot (\\<lambda>g. xml1to2elements t (\\<lambda>y. p1 y g) (\\<lambda>y. p2 y g) f x)\"", "lemma xml2nd_choice_mono [partial_function_mono]:\n  assumes p1: \"\\<And>y. mono_sum_bot (p1 y)\"\n              \"\\<And>y. mono_sum_bot (p2 y)\"\n  shows \"mono_sum_bot (\\<lambda>g. xml2nd_choice t (\\<lambda>y. p1 y g) h (\\<lambda>y. p2 y g) f x)\"", "lemma xml2to3elements_mono [partial_function_mono]:\n  assumes p1: \"\\<And>y. mono_sum_bot (p1 y)\"\n              \"\\<And>y. mono_sum_bot (p2 y)\"\n              \"\\<And>y. mono_sum_bot (p3 y)\"\n  shows \"mono_sum_bot (\\<lambda>g. xml2to3elements t (\\<lambda>y. p1 y g) (\\<lambda>y. p2 y g) (\\<lambda>y. p3 y g) f x)\"", "lemma xml3to4elements_mono [partial_function_mono]:\n  assumes p1: \"\\<And>y. mono_sum_bot (p1 y)\"\n              \"\\<And>y. mono_sum_bot (p2 y)\"\n              \"\\<And>y. mono_sum_bot (p3 y)\"\n              \"\\<And>y. mono_sum_bot (p4 y)\"\n  shows \"mono_sum_bot (\\<lambda>g. xml3to4elements t (\\<lambda>y. p1 y g) (\\<lambda>y. p2 y g) (\\<lambda>y. p3 y g) (\\<lambda>y. p4 y g) f x)\"", "lemma many_mono [partial_function_mono]:\n  fixes p1 :: \"xml \\<Rightarrow> ('b \\<Rightarrow> (string +\\<^sub>\\<bottom> 'c)) \\<Rightarrow> string +\\<^sub>\\<bottom> 'd\"\n  assumes \"\\<And>y. y \\<in> set (Xml.children x) \\<Longrightarrow> mono_sum_bot (p1 y)\"\n  shows \"mono_sum_bot (\\<lambda>g. Xmlt.many t (\\<lambda>y. p1 y g) f x)\"", "lemma many1_mono [partial_function_mono]:\n  fixes p1 :: \"xml \\<Rightarrow> ('b \\<Rightarrow> (string +\\<^sub>\\<bottom> 'c)) \\<Rightarrow> string +\\<^sub>\\<bottom> 'd\"\n  assumes \"\\<And>y. mono_sum_bot (p1 y)\"\n    and \"\\<And>y. y \\<in> set (tl (Xml.children x)) \\<Longrightarrow> mono_sum_bot (p2 y)\"\n  shows \"mono_sum_bot (\\<lambda>g. Xmlt.many1 t (\\<lambda>y. p1 y g) (\\<lambda>y. p2 y g) f x)\"", "lemma many2_mono [partial_function_mono]:\n  fixes p1 :: \"xml \\<Rightarrow> ('b \\<Rightarrow> (string +\\<^sub>\\<bottom> 'c)) \\<Rightarrow> string +\\<^sub>\\<bottom> 'd\"\n  assumes \"\\<And>y. mono_sum_bot (p1 y)\"\n    and \"\\<And>y. mono_sum_bot (p2 y)\"\n    and \"\\<And>y. mono_sum_bot (p3 y)\"\n  shows \"mono_sum_bot (\\<lambda>g. Xmlt.many2 t (\\<lambda>y. p1 y g) (\\<lambda>y. p2 y g) (\\<lambda>y. p3 y g) f x)\"", "lemma xml1many2elements_gen_mono [partial_function_mono]:\n  fixes p1 :: \"xml \\<Rightarrow> ('b \\<Rightarrow> (string +\\<^sub>\\<bottom> 'c)) \\<Rightarrow> string +\\<^sub>\\<bottom> 'd\"\n  assumes p1: \"\\<And>y. mono_sum_bot (p1 y)\"\n              \"\\<And>y. mono_sum_bot (p3 y)\"\n              \"\\<And>y. mono_sum_bot (p4 y)\"\n  shows \"mono_sum_bot (\\<lambda>g. xml1many2elements_gen t (\\<lambda>y. p1 y g) p2 (\\<lambda>y. p3 y g) (\\<lambda>y. p4 y g) f x)\"", "lemma options_mono_gen [partial_function_mono]:\n  assumes p: \"\\<And> k p. (k, p) \\<in> set ps \\<Longrightarrow> mono_sum_bot (p x)\"\n  shows \"mono_sum_bot (\\<lambda> g. Xmlt.options (map (\\<lambda> (k, p). (k, (\\<lambda> y. p y g))) ps) x)\"", "lemma choice_mono_2 [partial_function_mono]:\n  assumes p: \"mono_sum_bot (p1 x)\"\n             \"mono_sum_bot (p2 x)\"\n  shows \"mono_sum_bot (\\<lambda> g. Xmlt.choice e [(\\<lambda> y. p1 y g), (\\<lambda> y. p2 y g)] x)\"", "lemma choice_mono_3 [partial_function_mono]:\n  assumes p: \"mono_sum_bot (p1 x)\"\n             \"mono_sum_bot (p2 x)\"\n             \"mono_sum_bot (p3 x)\"\n  shows \"mono_sum_bot (\\<lambda> g. Xmlt.choice e [(\\<lambda> y. p1 y g), (\\<lambda> y. p2 y g), (\\<lambda> y. p3 y g)] x)\"", "lemma change_mono [partial_function_mono]:\n  assumes p: \"\\<And>y. mono_sum_bot (p1 y)\"\n  shows \"mono_sum_bot (\\<lambda>g. Xmlt.change (\\<lambda>y. p1 y g) f x)\""], "translations": [["", "lemma map_mono [partial_function_mono]:\n  fixes C :: \"xml \\<Rightarrow> ('b \\<Rightarrow> ('e +\\<^sub>\\<bottom> 'c)) \\<Rightarrow> 'e +\\<^sub>\\<bottom> 'd\"\n  assumes C: \"\\<And>y. y \\<in> set B \\<Longrightarrow> mono_sum_bot (C y)\"\n  shows \"mono_sum_bot (\\<lambda>f. map (\\<lambda>y. C y f) B)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>f. Xmlt.map (\\<lambda>y. C y f) B)", "unfolding map_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>f. map_sum_bot (\\<lambda>y. C y f) B)", "by (auto intro: partial_function_mono C)"], ["", "hide_const (open) map"], ["", "fun \"text\" :: \"tag \\<Rightarrow> string xmlt\"\nwhere\n  \"text tag (XML n atts [XML_text t]) = \n    (if n = tag \\<and> atts = [] then return t\n    else error (concat\n      [''could not extract text for '', tag,'' from '', ''\\<newline>'', show (XML n atts [XML_text t])]))\"\n| \"text tag xml = error (concat [''could not extract text for '', tag,'' from '', ''\\<newline>'', show xml])\""], ["", "hide_const (open) \"text\""], ["", "definition bool_of_string :: \"string \\<Rightarrow> string +\\<^sub>\\<bottom> bool\"\nwhere\n  \"bool_of_string s =\n    (if s = ''true'' then return True\n    else if s = ''false'' then return False\n    else error (''cannot convert '' @ s @ '' into Boolean''))\""], ["", "fun bool :: \"tag \\<Rightarrow> bool xmlt\"\nwhere\n  \"bool tag node = Xmlt.text tag node \\<bind> bool_of_string\""], ["", "hide_const (open) bool"], ["", "definition fail :: \"tag \\<Rightarrow> 'a xmlt\"\nwhere\n  \"fail tag xml =\n    error (concat\n      [''could not transform the following xml element (expected '', tag, '')'', ''\\<newline>'', show xml])\""], ["", "hide_const (open) fail"], ["", "definition guard :: \"(xml \\<Rightarrow> bool) \\<Rightarrow> 'a xmlt \\<Rightarrow> 'a xmlt \\<Rightarrow> 'a xmlt\"\nwhere\n  \"guard p p1 p2 x = (if p x then p1 x else p2 x)\""], ["", "hide_const (open) guard"], ["", "lemma guard_mono [partial_function_mono]:\n  assumes p1: \"\\<And>y. mono_sum_bot (p1 y)\"\n    and p2: \"\\<And>y. mono_sum_bot (p2 y)\"\n  shows \"mono_sum_bot (\\<lambda>g. Xmlt.guard p (\\<lambda>y. p1 y g) (\\<lambda>y. p2 y g) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g. Xmlt.guard p (\\<lambda>y. p1 y g) (\\<lambda>y. p2 y g) x)", "by (cases x) (auto intro!: partial_function_mono p1 p2 simp: Xmlt.guard_def)"], ["", "fun leaf :: \"tag \\<Rightarrow> 'a \\<Rightarrow> 'a xmlt\"\nwhere\n  \"leaf tag x (XML name atts cs) = \n    (if name = tag \\<and> atts = [] \\<and> cs = [] then return x \n    else Xmlt.fail tag (XML name atts cs))\" |\n  \"leaf tag x xml = Xmlt.fail tag xml\""], ["", "hide_const (open) leaf"], ["", "fun list1element :: \"'a list \\<Rightarrow> 'a option\"\nwhere\n  \"list1element [x] = Some x\" |\n  \"list1element _ = None\""], ["", "fun singleton :: \"tag \\<Rightarrow> 'a xmlt \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> 'b xmlt\"\nwhere\n  \"singleton tag p1 f xml =\n    (case xml of\n      XML name atts cs \\<Rightarrow>\n      (if name = tag \\<and> atts = [] then\n        (case list1element cs of \n          Some (cs1) \\<Rightarrow> p1 cs1 \\<bind> return \\<circ> f\n        | None \\<Rightarrow> Xmlt.fail tag xml)\n      else Xmlt.fail tag xml)\n    | _ \\<Rightarrow> Xmlt.fail tag xml)\""], ["", "hide_const (open) singleton"], ["", "lemma singleton_mono [partial_function_mono]:\n  assumes p: \"\\<And>y. mono_sum_bot (p1 y)\"\n  shows \"mono_sum_bot (\\<lambda>g. Xmlt.singleton t (\\<lambda>y. p1 y g) f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g. Xmlt.singleton t (\\<lambda>y. p1 y g) f x)", "by (cases x, cases \"list1element (Xml.children x)\") (auto intro!: partial_function_mono p)"], ["", "fun list2elements :: \"'a list \\<Rightarrow> ('a \\<times> 'a) option\"\nwhere\n  \"list2elements [x, y] = Some (x, y)\" |\n  \"list2elements _ = None\""], ["", "fun pair :: \"tag \\<Rightarrow> 'a xmlt \\<Rightarrow> 'b xmlt \\<Rightarrow> ('a \\<Rightarrow> 'b \\<Rightarrow> 'c) \\<Rightarrow> 'c xmlt\"\nwhere\n  \"pair tag p1 p2 f xml =\n    (case xml of\n      XML name atts cs \\<Rightarrow>\n      (if name = tag \\<and> atts = [] then\n        (case list2elements cs of \n          Some (cs1, cs2) \\<Rightarrow>\n          do {\n            a \\<leftarrow> p1 cs1;\n            b \\<leftarrow> p2 cs2;\n            return (f a b)\n          }\n        | None \\<Rightarrow> Xmlt.fail tag xml)\n      else Xmlt.fail tag xml)\n    | _ \\<Rightarrow> Xmlt.fail tag xml)\""], ["", "hide_const (open) pair"], ["", "lemma pair_mono [partial_function_mono]:\n  assumes \"\\<And>y. mono_sum_bot (p1 y)\"\n    and \"\\<And>y. mono_sum_bot (p2 y)\"\n  shows \"mono_sum_bot (\\<lambda>g. Xmlt.pair t (\\<lambda>y. p1 y g) (\\<lambda> y. p2 y g) f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g. Xmlt.pair t (\\<lambda>y. p1 y g) (\\<lambda>y. p2 y g) f x)", "using assms"], ["proof (prove)\nusing this:\n  monotone sum_bot.le_fun sum_bot_ord (p1 ?y)\n  monotone sum_bot.le_fun sum_bot_ord (p2 ?y)\n\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g. Xmlt.pair t (\\<lambda>y. p1 y g) (\\<lambda>y. p2 y g) f x)", "by (cases x, cases \"list2elements (Xml.children x)\") (auto intro!: partial_function_mono)"], ["", "fun list3elements :: \"'a list \\<Rightarrow> ('a \\<times> 'a \\<times> 'a) option\"\nwhere\n  \"list3elements [x, y, z] = Some (x, y, z)\" |\n  \"list3elements _ = None\""], ["", "fun triple :: \"string \\<Rightarrow> 'a xmlt \\<Rightarrow> 'b xmlt \\<Rightarrow> 'c xmlt \\<Rightarrow> ('a \\<Rightarrow> 'b \\<Rightarrow> 'c \\<Rightarrow> 'd) \\<Rightarrow> 'd xmlt\"\nwhere\n  \"triple tag p1 p2 p3 f xml = (case xml of XML name atts cs \\<Rightarrow>\n    (if name = tag \\<and> atts = [] then\n      (case list3elements cs of \n        Some (cs1, cs2, cs3) \\<Rightarrow>\n        do {\n          a \\<leftarrow> p1 cs1;\n          b \\<leftarrow> p2 cs2;\n          c \\<leftarrow> p3 cs3;\n          return (f a b c)\n        }\n      | None \\<Rightarrow> Xmlt.fail tag xml)\n    else Xmlt.fail tag xml)\n  | _ \\<Rightarrow> Xmlt.fail tag xml)\""], ["", "lemma triple_mono [partial_function_mono]:\n  assumes \"\\<And>y. mono_sum_bot (p1 y)\"\n    and \"\\<And>y. mono_sum_bot (p2 y)\"\n    and \"\\<And>y. mono_sum_bot (p3 y)\"\n  shows \"mono_sum_bot (\\<lambda>g. Xmlt.triple t (\\<lambda>y. p1 y g) (\\<lambda> y. p2 y g) (\\<lambda> y. p3 y g) f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         triple t (\\<lambda>y. p1 y g) (\\<lambda>y. p2 y g)\n          (\\<lambda>y. p3 y g) f x)", "using assms"], ["proof (prove)\nusing this:\n  monotone sum_bot.le_fun sum_bot_ord (p1 ?y)\n  monotone sum_bot.le_fun sum_bot_ord (p2 ?y)\n  monotone sum_bot.le_fun sum_bot_ord (p3 ?y)\n\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         triple t (\\<lambda>y. p1 y g) (\\<lambda>y. p2 y g)\n          (\\<lambda>y. p3 y g) f x)", "by (cases x, cases \"list3elements (Xml.children x)\", auto intro!: partial_function_mono)"], ["", "fun list4elements :: \"'a list \\<Rightarrow> ('a \\<times> 'a \\<times> 'a \\<times> 'a) option\"\nwhere\n  \"list4elements [x, y, z, u] = Some (x, y, z, u)\" |\n  \"list4elements _ = None\""], ["", "fun\n  tuple4 ::\n    \"string \\<Rightarrow> 'a xmlt \\<Rightarrow> 'b xmlt \\<Rightarrow> 'c xmlt \\<Rightarrow> 'd xmlt \\<Rightarrow> ('a \\<Rightarrow> 'b \\<Rightarrow> 'c \\<Rightarrow> 'd \\<Rightarrow> 'e) \\<Rightarrow> 'e xmlt\"\nwhere\n  \"tuple4 tag p1 p2 p3 p4 f xml =\n    (case xml of\n      XML name atts cs \\<Rightarrow>\n        (if name = tag \\<and> atts = [] then\n          (case list4elements cs of \n            Some (cs1, cs2, cs3, cs4) \\<Rightarrow>\n            do {\n              a \\<leftarrow> p1 cs1;\n              b \\<leftarrow> p2 cs2;\n              c \\<leftarrow> p3 cs3;\n              d \\<leftarrow> p4 cs4;\n              return (f a b c d)\n            }\n          | None \\<Rightarrow> Xmlt.fail tag xml)\n        else Xmlt.fail tag xml)\n   | _ \\<Rightarrow> Xmlt.fail tag xml)\""], ["", "lemma tuple4_mono [partial_function_mono]:\n  assumes \"\\<And>y. mono_sum_bot (p1 y)\"\n    and \"\\<And>y. mono_sum_bot (p2 y)\"\n    and \"\\<And>y. mono_sum_bot (p3 y)\"\n    and\"\\<And>y. mono_sum_bot (p4 y)\"\n  shows \"mono_sum_bot (\\<lambda>g. Xmlt.tuple4 t (\\<lambda>y. p1 y g) (\\<lambda> y. p2 y g) (\\<lambda> y. p3 y g) (\\<lambda> y. p4 y g) f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         tuple4 t (\\<lambda>y. p1 y g) (\\<lambda>y. p2 y g)\n          (\\<lambda>y. p3 y g) (\\<lambda>y. p4 y g) f x)", "using assms"], ["proof (prove)\nusing this:\n  monotone sum_bot.le_fun sum_bot_ord (p1 ?y)\n  monotone sum_bot.le_fun sum_bot_ord (p2 ?y)\n  monotone sum_bot.le_fun sum_bot_ord (p3 ?y)\n  monotone sum_bot.le_fun sum_bot_ord (p4 ?y)\n\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         tuple4 t (\\<lambda>y. p1 y g) (\\<lambda>y. p2 y g)\n          (\\<lambda>y. p3 y g) (\\<lambda>y. p4 y g) f x)", "by (cases x, cases \"list4elements (Xml.children x)\") (auto intro!: partial_function_mono)"], ["", "fun list5elements :: \"'a list \\<Rightarrow> ('a \\<times> 'a \\<times> 'a \\<times> 'a \\<times> 'a) option\"\nwhere\n  \"list5elements [x, y, z, u, v] = Some (x, y, z, u, v)\" |\n  \"list5elements _ = None\""], ["", "fun\n  tuple5 ::\n    \"string \\<Rightarrow> 'a xmlt \\<Rightarrow> 'b xmlt \\<Rightarrow> 'c xmlt \\<Rightarrow> 'd xmlt \\<Rightarrow> 'e xmlt \\<Rightarrow>\n      ('a \\<Rightarrow> 'b \\<Rightarrow> 'c \\<Rightarrow> 'd \\<Rightarrow> 'e \\<Rightarrow> 'f) \\<Rightarrow> 'f xmlt\"\nwhere\n  \"tuple5 tag p1 p2 p3 p4 p5 f xml =\n    (case xml of\n      XML name atts cs \\<Rightarrow>\n        (if name = tag \\<and> atts = [] then\n          (case list5elements cs of \n            Some (cs1,cs2,cs3,cs4,cs5) \\<Rightarrow>\n            do {\n              a \\<leftarrow> p1 cs1;\n              b \\<leftarrow> p2 cs2;\n              c \\<leftarrow> p3 cs3;\n              d \\<leftarrow> p4 cs4;\n              e \\<leftarrow> p5 cs5;\n              return (f a b c d e)\n            }\n          | None \\<Rightarrow> Xmlt.fail tag xml)\n        else Xmlt.fail tag xml)\n    | _ \\<Rightarrow> Xmlt.fail tag xml)\""], ["", "lemma tuple5_mono [partial_function_mono]:\n  assumes \"\\<And>y. mono_sum_bot (p1 y)\"\n    and \"\\<And>y. mono_sum_bot (p2 y)\"\n    and \"\\<And>y. mono_sum_bot (p3 y)\"\n    and \"\\<And>y. mono_sum_bot (p4 y)\"\n    and \"\\<And>y. mono_sum_bot (p5 y)\"\n  shows \"mono_sum_bot (\\<lambda>g. Xmlt.tuple5 t (\\<lambda>y. p1 y g) (\\<lambda> y. p2 y g) (\\<lambda> y. p3 y g) (\\<lambda> y. p4 y g) (\\<lambda> y. p5 y g) f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         tuple5 t (\\<lambda>y. p1 y g) (\\<lambda>y. p2 y g)\n          (\\<lambda>y. p3 y g) (\\<lambda>y. p4 y g) (\\<lambda>y. p5 y g) f\n          x)", "using assms"], ["proof (prove)\nusing this:\n  monotone sum_bot.le_fun sum_bot_ord (p1 ?y)\n  monotone sum_bot.le_fun sum_bot_ord (p2 ?y)\n  monotone sum_bot.le_fun sum_bot_ord (p3 ?y)\n  monotone sum_bot.le_fun sum_bot_ord (p4 ?y)\n  monotone sum_bot.le_fun sum_bot_ord (p5 ?y)\n\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         tuple5 t (\\<lambda>y. p1 y g) (\\<lambda>y. p2 y g)\n          (\\<lambda>y. p3 y g) (\\<lambda>y. p4 y g) (\\<lambda>y. p5 y g) f\n          x)", "by (cases x, cases \"list5elements (Xml.children x)\") (auto intro!: partial_function_mono)"], ["", "fun list6elements :: \"'a list \\<Rightarrow> ('a \\<times> 'a \\<times> 'a \\<times> 'a \\<times> 'a \\<times> 'a) option\"\nwhere\n  \"list6elements [x, y, z, u, v, w] = Some (x, y, z, u, v, w)\" |\n  \"list6elements _ = None\""], ["", "fun\n  tuple6 ::\n    \"string \\<Rightarrow> 'a xmlt \\<Rightarrow> 'b xmlt \\<Rightarrow> 'c xmlt \\<Rightarrow> 'd xmlt \\<Rightarrow> 'e xmlt \\<Rightarrow> 'f xmlt \\<Rightarrow>\n      ('a \\<Rightarrow> 'b \\<Rightarrow> 'c \\<Rightarrow> 'd \\<Rightarrow> 'e \\<Rightarrow> 'f \\<Rightarrow> 'g) \\<Rightarrow> 'g xmlt\"\nwhere\n  \"tuple6 tag p1 p2 p3 p4 p5 p6 f xml =\n    (case xml of\n      XML name atts cs  \\<Rightarrow>\n        (if name = tag \\<and> atts = [] then\n          (case list6elements cs of \n            Some (cs1,cs2,cs3,cs4,cs5,cs6) \\<Rightarrow>\n            do {\n              a \\<leftarrow> p1 cs1;\n              b \\<leftarrow> p2 cs2;\n              c \\<leftarrow> p3 cs3;\n              d \\<leftarrow> p4 cs4;\n              e \\<leftarrow> p5 cs5;\n              ff \\<leftarrow> p6 cs6;\n              return (f a b c d e ff)\n            }\n          | None \\<Rightarrow> Xmlt.fail tag xml)\n        else Xmlt.fail tag xml)\n    | _ \\<Rightarrow> Xmlt.fail tag xml)\""], ["", "lemma tuple6_mono [partial_function_mono]:\n  assumes \"\\<And>y. mono_sum_bot (p1 y)\"\n    and \"\\<And>y. mono_sum_bot (p2 y)\"\n    and \"\\<And>y. mono_sum_bot (p3 y)\"\n    and \"\\<And>y. mono_sum_bot (p4 y)\"\n    and \"\\<And>y. mono_sum_bot (p5 y)\"\n    and \"\\<And>y. mono_sum_bot (p6 y)\"\n  shows \"mono_sum_bot (\\<lambda>g. Xmlt.tuple6 t (\\<lambda>y. p1 y g) (\\<lambda> y. p2 y g) (\\<lambda> y. p3 y g) (\\<lambda> y. p4 y g) (\\<lambda> y. p5 y g) (\\<lambda> y. p6 y g) f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         tuple6 t (\\<lambda>y. p1 y g) (\\<lambda>y. p2 y g)\n          (\\<lambda>y. p3 y g) (\\<lambda>y. p4 y g) (\\<lambda>y. p5 y g)\n          (\\<lambda>y. p6 y g) f x)", "using assms"], ["proof (prove)\nusing this:\n  monotone sum_bot.le_fun sum_bot_ord (p1 ?y)\n  monotone sum_bot.le_fun sum_bot_ord (p2 ?y)\n  monotone sum_bot.le_fun sum_bot_ord (p3 ?y)\n  monotone sum_bot.le_fun sum_bot_ord (p4 ?y)\n  monotone sum_bot.le_fun sum_bot_ord (p5 ?y)\n  monotone sum_bot.le_fun sum_bot_ord (p6 ?y)\n\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         tuple6 t (\\<lambda>y. p1 y g) (\\<lambda>y. p2 y g)\n          (\\<lambda>y. p3 y g) (\\<lambda>y. p4 y g) (\\<lambda>y. p5 y g)\n          (\\<lambda>y. p6 y g) f x)", "by (cases x, cases \"list6elements (Xml.children x)\") (auto intro!: partial_function_mono)"], ["", "fun optional :: \"tag \\<Rightarrow> 'a xmlt \\<Rightarrow> ('a option \\<Rightarrow> 'b) \\<Rightarrow> 'b xmlt\"\nwhere\n  \"optional tag p1 f (XML name atts cs) =\n    (let l = length cs in\n    (if name = tag \\<and> atts = [] \\<and> l \\<ge> 0 \\<and> l \\<le> 1 then do {\n      if l = 1 then do {\n        x1 \\<leftarrow> p1 (cs ! 0);\n        return (f (Some x1))\n      } else return (f None)\n    } else Xmlt.fail tag (XML name atts cs)))\" |\n  \"optional tag p1 f xml = Xmlt.fail tag xml\""], ["", "lemma optional_mono [partial_function_mono]:\n  assumes \"\\<And>y. mono_sum_bot (p1 y)\"\n  shows \"mono_sum_bot (\\<lambda>g. Xmlt.optional t (\\<lambda>y. p1 y g) f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g. optional t (\\<lambda>y. p1 y g) f x)", "using assms"], ["proof (prove)\nusing this:\n  monotone sum_bot.le_fun sum_bot_ord (p1 ?y)\n\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g. optional t (\\<lambda>y. p1 y g) f x)", "by (cases x) (auto intro!: partial_function_mono)"], ["", "fun xml1to2elements :: \"string \\<Rightarrow> 'a xmlt \\<Rightarrow> 'b xmlt \\<Rightarrow> ('a \\<Rightarrow> 'b option \\<Rightarrow> 'c) \\<Rightarrow> 'c xmlt\"\nwhere\n  \"xml1to2elements tag p1 p2 f (XML name atts cs) = (\n     let l = length cs in\n     (if name = tag \\<and> atts = [] \\<and> l \\<ge> 1 \\<and> l \\<le> 2\n       then do {\n         x1 \\<leftarrow> p1 (cs ! 0);\n         (if l = 2\n           then do {\n             x2 \\<leftarrow> p2 (cs ! 1);\n             return (f x1 (Some x2))\n           } else return (f x1 None))\n       } else Xmlt.fail tag (XML name atts cs)))\" |\n  \"xml1to2elements tag p1 p2 f xml = Xmlt.fail tag xml\""], ["", "lemma xml1to2elements_mono[partial_function_mono]:\n  assumes p1: \"\\<And>y. mono_sum_bot (p1 y)\"\n              \"\\<And>y. mono_sum_bot (p2 y)\"\n  shows \"mono_sum_bot (\\<lambda>g. xml1to2elements t (\\<lambda>y. p1 y g) (\\<lambda>y. p2 y g) f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         xml1to2elements t (\\<lambda>y. p1 y g) (\\<lambda>y. p2 y g) f x)", "by (cases x, auto intro!: partial_function_mono p1)"], ["", "text \\<open>\n  Apply the first transformer to the first child-node, then check the second child-node,\n  which is must be a Boolean. If the Boolean is true, then apply the second transformer\n  to the last child-node.\n\\<close>"], ["", "fun xml2nd_choice :: \"tag \\<Rightarrow> 'a xmlt \\<Rightarrow> tag \\<Rightarrow> 'b xmlt \\<Rightarrow> ('a \\<Rightarrow> 'b option \\<Rightarrow> 'c) \\<Rightarrow> 'c xmlt\"\nwhere\n  \"xml2nd_choice tag p1 cn p2 f (XML name atts cs) = (\n    let l = length cs in\n    (if name = tag \\<and> atts = [] \\<and> l \\<ge> 2 then do {\n      x1 \\<leftarrow> p1 (cs ! 0);\n      b \\<leftarrow> Xmlt.bool cn (cs ! 1);\n      (if b then do {\n        x2 \\<leftarrow> p2 (cs ! (l - 1));\n        return (f x1 (Some x2))\n      } else return (f x1 None))\n    } else Xmlt.fail tag (XML name atts cs)))\" |\n  \"xml2nd_choice tag p1 cn p2 f xml = Xmlt.fail tag xml\""], ["", "lemma xml2nd_choice_mono [partial_function_mono]:\n  assumes p1: \"\\<And>y. mono_sum_bot (p1 y)\"\n              \"\\<And>y. mono_sum_bot (p2 y)\"\n  shows \"mono_sum_bot (\\<lambda>g. xml2nd_choice t (\\<lambda>y. p1 y g) h (\\<lambda>y. p2 y g) f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         xml2nd_choice t (\\<lambda>y. p1 y g) h (\\<lambda>y. p2 y g) f x)", "by (cases x, auto intro!: partial_function_mono p1)"], ["", "fun\n  xml2to3elements ::\n    \"string \\<Rightarrow> 'a xmlt \\<Rightarrow> 'b xmlt \\<Rightarrow> 'c xmlt \\<Rightarrow> ('a \\<Rightarrow> 'b \\<Rightarrow> 'c option \\<Rightarrow> 'd) \\<Rightarrow> 'd xmlt\"\nwhere\n  \"xml2to3elements tag p1 p2 p3 f (XML name atts cs) = (\n     let l = length cs in\n     (if name = tag \\<and> atts = [] \\<and> l \\<ge> 2 \\<and> l \\<le> 3 then do {\n       x1 \\<leftarrow> p1 (cs ! 0);\n       x2 \\<leftarrow> p2 (cs ! 1);\n       (if l = 3 then do {\n         x3 \\<leftarrow> p3 (cs ! 2);\n         return (f x1 x2 (Some x3))\n       } else return (f x1 x2 None))\n     } else Xmlt.fail tag (XML name atts cs)))\" |\n  \"xml2to3elements tag p1 p2 p3 f xml = Xmlt.fail tag xml\""], ["", "lemma xml2to3elements_mono [partial_function_mono]:\n  assumes p1: \"\\<And>y. mono_sum_bot (p1 y)\"\n              \"\\<And>y. mono_sum_bot (p2 y)\"\n              \"\\<And>y. mono_sum_bot (p3 y)\"\n  shows \"mono_sum_bot (\\<lambda>g. xml2to3elements t (\\<lambda>y. p1 y g) (\\<lambda>y. p2 y g) (\\<lambda>y. p3 y g) f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         xml2to3elements t (\\<lambda>y. p1 y g) (\\<lambda>y. p2 y g)\n          (\\<lambda>y. p3 y g) f x)", "by (cases x, auto intro!: partial_function_mono p1)"], ["", "fun\n  xml3to4elements ::\n    \"string \\<Rightarrow> 'a xmlt \\<Rightarrow> 'b xmlt \\<Rightarrow> 'c xmlt \\<Rightarrow> 'd xmlt \\<Rightarrow> ('a \\<Rightarrow> 'b \\<Rightarrow> 'c option \\<Rightarrow> 'd \\<Rightarrow> 'e) \\<Rightarrow>\n      'e xmlt\"\nwhere\n  \"xml3to4elements tag p1 p2 p3 p4 f (XML name atts cs) = (\n     let l = length cs in\n     (if name = tag \\<and> atts = [] \\<and> l \\<ge> 3 \\<and> l \\<le> 4 then do {\n       x1 \\<leftarrow> p1 (cs ! 0);\n       x2 \\<leftarrow> p2 (cs ! 1);\n       (if l = 4 then do {\n         x3 \\<leftarrow> p3 (cs ! 2);\n         x4 \\<leftarrow> p4 (cs ! 3);\n         return (f x1 x2 (Some x3) x4)\n       } else do {\n         x4 \\<leftarrow> p4 (cs ! 2);\n         return (f x1 x2 None x4)\n       } )\n     } else Xmlt.fail tag (XML name atts cs)))\" |\n  \"xml3to4elements tag p1 p2 p3 p4 f xml = Xmlt.fail tag xml\""], ["", "lemma xml3to4elements_mono [partial_function_mono]:\n  assumes p1: \"\\<And>y. mono_sum_bot (p1 y)\"\n              \"\\<And>y. mono_sum_bot (p2 y)\"\n              \"\\<And>y. mono_sum_bot (p3 y)\"\n              \"\\<And>y. mono_sum_bot (p4 y)\"\n  shows \"mono_sum_bot (\\<lambda>g. xml3to4elements t (\\<lambda>y. p1 y g) (\\<lambda>y. p2 y g) (\\<lambda>y. p3 y g) (\\<lambda>y. p4 y g) f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         xml3to4elements t (\\<lambda>y. p1 y g) (\\<lambda>y. p2 y g)\n          (\\<lambda>y. p3 y g) (\\<lambda>y. p4 y g) f x)", "by (cases x, auto intro!: partial_function_mono p1)"], ["", "fun many :: \"tag \\<Rightarrow> 'a xmlt \\<Rightarrow> ('a list \\<Rightarrow> 'b) \\<Rightarrow> 'b xmlt\"\nwhere\n  \"many tag p f (XML name atts cs) =\n    (if name = tag \\<and> atts = [] then (Xmlt.map p cs \\<bind> (return \\<circ> f))\n    else Xmlt.fail tag (XML name atts cs))\" |\n  \"many tag p f xml = Xmlt.fail tag xml\""], ["", "hide_const (open) many"], ["", "lemma many_mono [partial_function_mono]:\n  fixes p1 :: \"xml \\<Rightarrow> ('b \\<Rightarrow> (string +\\<^sub>\\<bottom> 'c)) \\<Rightarrow> string +\\<^sub>\\<bottom> 'd\"\n  assumes \"\\<And>y. y \\<in> set (Xml.children x) \\<Longrightarrow> mono_sum_bot (p1 y)\"\n  shows \"mono_sum_bot (\\<lambda>g. Xmlt.many t (\\<lambda>y. p1 y g) f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g. Xmlt.many t (\\<lambda>y. p1 y g) f x)", "using assms"], ["proof (prove)\nusing this:\n  ?y \\<in> set (Xml.children x) \\<Longrightarrow>\n  monotone sum_bot.le_fun sum_bot_ord (p1 ?y)\n\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g. Xmlt.many t (\\<lambda>y. p1 y g) f x)", "by (cases x) (auto intro!: partial_function_mono)"], ["", "fun many1_gen :: \"tag \\<Rightarrow> 'a xmlt \\<Rightarrow> ('a \\<Rightarrow> 'b xmlt) \\<Rightarrow> ('a \\<Rightarrow> 'b list \\<Rightarrow> 'c) \\<Rightarrow> 'c xmlt\"\nwhere\n  \"many1_gen tag p1 p2 f (XML name atts cs) =\n    (if name = tag \\<and> atts = [] \\<and> cs \\<noteq> [] then\n      (case cs of h # t \\<Rightarrow> do {\n        x \\<leftarrow> p1 h;\n        xs \\<leftarrow> Xmlt.map (p2 x) t;\n        return (f x xs)\n      })\n    else Xmlt.fail tag (XML name atts cs))\" |\n  \"many1_gen tag p1 p2 f xml = Xmlt.fail tag xml\""], ["", "(* TODO \nlemma Xmlt.many1_gen_mono[partial_function_mono]:\n  fixes p1 :: \"xml \\<Rightarrow> ('b \\<Rightarrow> 'c sum_bot) \\<Rightarrow> 'd sum_bot\"\n  assumes p1: \"\\<And>y. mono_sum_bot (p1 y)\"\n              \"\\<And>y. mono_sum_bot (p2 y)\"\n  shows \"mono_sum_bot (\\<lambda>g. Xmlt.many1_gen t (\\<lambda>y. p1 y g) (\\<lambda>y. p2 y g) f x)\" \n  by (cases x, auto intro!: partial_function_mono p1)\n*)"], ["", "definition many1 :: \"string \\<Rightarrow> 'a xmlt \\<Rightarrow> 'b xmlt \\<Rightarrow> ('a \\<Rightarrow> 'b list \\<Rightarrow> 'c) \\<Rightarrow> 'c xmlt\"\nwhere\n  \"many1 tag p1 p2 = Xmlt.many1_gen tag p1 (\\<lambda>_. p2)\""], ["", "hide_const (open) many1"], ["", "lemma many1_mono [partial_function_mono]:\n  fixes p1 :: \"xml \\<Rightarrow> ('b \\<Rightarrow> (string +\\<^sub>\\<bottom> 'c)) \\<Rightarrow> string +\\<^sub>\\<bottom> 'd\"\n  assumes \"\\<And>y. mono_sum_bot (p1 y)\"\n    and \"\\<And>y. y \\<in> set (tl (Xml.children x)) \\<Longrightarrow> mono_sum_bot (p2 y)\"\n  shows \"mono_sum_bot (\\<lambda>g. Xmlt.many1 t (\\<lambda>y. p1 y g) (\\<lambda>y. p2 y g) f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         Xmlt.many1 t (\\<lambda>y. p1 y g) (\\<lambda>y. p2 y g) f x)", "unfolding Xmlt.many1_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         many1_gen t (\\<lambda>y. p1 y g) (\\<lambda>_ y. p2 y g) f x)", "using assms"], ["proof (prove)\nusing this:\n  monotone sum_bot.le_fun sum_bot_ord (p1 ?y)\n  ?y \\<in> set (tl (Xml.children x)) \\<Longrightarrow>\n  monotone sum_bot.le_fun sum_bot_ord (p2 ?y)\n\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         many1_gen t (\\<lambda>y. p1 y g) (\\<lambda>_ y. p2 y g) f x)", "by (cases x, cases \"Xml.children x\") (auto intro!: partial_function_mono)"], ["", "fun length_ge_2 :: \"'a list \\<Rightarrow> bool\"\nwhere \n  \"length_ge_2 (_ # _ # _) = True\" |\n  \"length_ge_2 _ = False\""], ["", "fun many2 :: \"tag \\<Rightarrow> 'a xmlt \\<Rightarrow> 'b xmlt \\<Rightarrow> 'c xmlt \\<Rightarrow> ('a \\<Rightarrow> 'b \\<Rightarrow> 'c list \\<Rightarrow> 'd) \\<Rightarrow> 'd xmlt\"\nwhere\n  \"many2 tag p1 p2 p3 f (XML name atts cs) =\n    (if name = tag \\<and> atts = [] \\<and> length_ge_2 cs then\n      (case cs of cs0 # cs1 # t \\<Rightarrow> do {\n        x \\<leftarrow> p1 cs0;\n        y \\<leftarrow> p2 cs1;\n        xs \\<leftarrow> Xmlt.map p3 t;\n        return (f x y xs)\n      })\n    else Xmlt.fail tag (XML name atts cs))\" |\n  \"many2 tag p1 p2 p3 f xml = Xmlt.fail tag xml\""], ["", "lemma many2_mono [partial_function_mono]:\n  fixes p1 :: \"xml \\<Rightarrow> ('b \\<Rightarrow> (string +\\<^sub>\\<bottom> 'c)) \\<Rightarrow> string +\\<^sub>\\<bottom> 'd\"\n  assumes \"\\<And>y. mono_sum_bot (p1 y)\"\n    and \"\\<And>y. mono_sum_bot (p2 y)\"\n    and \"\\<And>y. mono_sum_bot (p3 y)\"\n  shows \"mono_sum_bot (\\<lambda>g. Xmlt.many2 t (\\<lambda>y. p1 y g) (\\<lambda>y. p2 y g) (\\<lambda>y. p3 y g) f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         many2 t (\\<lambda>y. p1 y g) (\\<lambda>y. p2 y g)\n          (\\<lambda>y. p3 y g) f x)", "using assms"], ["proof (prove)\nusing this:\n  monotone sum_bot.le_fun sum_bot_ord (p1 ?y)\n  monotone sum_bot.le_fun sum_bot_ord (p2 ?y)\n  monotone sum_bot.le_fun sum_bot_ord (p3 ?y)\n\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         many2 t (\\<lambda>y. p1 y g) (\\<lambda>y. p2 y g)\n          (\\<lambda>y. p3 y g) f x)", "by (cases x, cases \"Xml.children x\", (auto intro!: partial_function_mono)[1], cases \"tl (Xml.children x)\", auto intro!: partial_function_mono)"], ["", "fun\n  xml1or2many_elements ::\n    \"string \\<Rightarrow> 'a xmlt \\<Rightarrow> 'b xmlt \\<Rightarrow> 'c xmlt \\<Rightarrow> ('a \\<Rightarrow> 'b option \\<Rightarrow> 'c list \\<Rightarrow> 'd) \\<Rightarrow> 'd xmlt\"\nwhere\n  \"xml1or2many_elements tag p1 p2 p3 f (XML name atts cs) =\n    (if name = tag \\<and> atts = [] \\<and> cs \\<noteq> [] then\n      (case cs of\n        cs0 # tt \\<Rightarrow>\n        do { \n          x \\<leftarrow> p1 cs0;\n          (case tt of\n            cs1 # t \\<Rightarrow>\n            do {\n              try do {\n                y \\<leftarrow> p2 cs1;\n                xs \\<leftarrow> Xmlt.map p3 t;\n                return (f x (Some y) xs)\n              } catch (\\<lambda> _. do {\n                xs \\<leftarrow> Xmlt.map p3 tt;\n                return (f x None xs)\n              })\n            }\n          | [] \\<Rightarrow> return (f x None []))}) \n     else Xmlt.fail tag (XML name atts cs))\" |\n  \"xml1or2many_elements tag p1 p2 p3 f  xml = Xmlt.fail tag xml\""], ["", "fun\n  xml1many2elements_gen ::\n    \"string \\<Rightarrow> 'a xmlt \\<Rightarrow> ('a \\<Rightarrow> 'b xmlt) \\<Rightarrow> 'c xmlt \\<Rightarrow> 'd xmlt \\<Rightarrow>\n      ('a \\<Rightarrow> 'b list \\<Rightarrow> 'c \\<Rightarrow> 'd \\<Rightarrow> 'e) \\<Rightarrow> 'e xmlt\"\nwhere\n  \"xml1many2elements_gen tag p1 p2 p3 p4 f (XML name atts cs) = (\n     let ds = List.rev cs; l = length cs in\n     (if name = tag \\<and> atts = [] \\<and> l \\<ge> 3 then do {\n       x \\<leftarrow> p1 (cs ! 0);\n       xs \\<leftarrow> Xmlt.map (p2 x) (tl (take (l - 2) cs));\n       y \\<leftarrow> p3 (ds ! 1);\n       z \\<leftarrow> p4 (ds ! 0);\n       return (f x xs y z)\n     } else Xmlt.fail tag (XML name atts cs)))\" |\n  \"xml1many2elements_gen tag p1 p2 p3 p4 f xml = Xmlt.fail tag xml\""], ["", "lemma xml1many2elements_gen_mono [partial_function_mono]:\n  fixes p1 :: \"xml \\<Rightarrow> ('b \\<Rightarrow> (string +\\<^sub>\\<bottom> 'c)) \\<Rightarrow> string +\\<^sub>\\<bottom> 'd\"\n  assumes p1: \"\\<And>y. mono_sum_bot (p1 y)\"\n              \"\\<And>y. mono_sum_bot (p3 y)\"\n              \"\\<And>y. mono_sum_bot (p4 y)\"\n  shows \"mono_sum_bot (\\<lambda>g. xml1many2elements_gen t (\\<lambda>y. p1 y g) p2 (\\<lambda>y. p3 y g) (\\<lambda>y. p4 y g) f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         xml1many2elements_gen t (\\<lambda>y. p1 y g) p2\n          (\\<lambda>y. p3 y g) (\\<lambda>y. p4 y g) f x)", "by (cases x, auto intro!: partial_function_mono p1)"], ["", "fun\n  xml1many2elements ::\n    \"string \\<Rightarrow> 'a xmlt \\<Rightarrow> 'b xmlt \\<Rightarrow> 'c xmlt \\<Rightarrow> 'd xmlt \\<Rightarrow> ('a \\<Rightarrow> 'b list \\<Rightarrow> 'c \\<Rightarrow> 'd \\<Rightarrow> 'e) \\<Rightarrow>\n      'e xmlt\"\nwhere\n  \"xml1many2elements tag p1 p2 = xml1many2elements_gen tag p1 (\\<lambda>_. p2)\""], ["", "fun\n  xml_many2elements ::\n    \"string \\<Rightarrow> 'a xmlt \\<Rightarrow> 'b xmlt \\<Rightarrow> 'c xmlt \\<Rightarrow> ('a list \\<Rightarrow> 'b \\<Rightarrow> 'c \\<Rightarrow> 'd) \\<Rightarrow> 'd xmlt\"\nwhere\n  \"xml_many2elements tag p1 p2 p3 f (XML name atts cs) = (\n     let ds = List.rev cs in\n     (if name = tag \\<and> atts = [] \\<and> length_ge_2 cs then do {\n       xs \\<leftarrow> Xmlt.map p1 (List.rev (tl (tl ds)));\n       y \\<leftarrow> p2 (ds ! 1);\n       z \\<leftarrow> p3 (ds ! 0);\n       return (f xs y z)\n     } else Xmlt.fail tag (XML name atts cs)))\" |\n  \"xml_many2elements tag p1 p2 p3 f xml = Xmlt.fail tag xml\""], ["", "definition options :: \"(string \\<times> 'a xmlt) list \\<Rightarrow> 'a xmlt\"\nwhere\n  \"options ps x =\n    (case map_of ps (Xml.tag x) of \n      None \\<Rightarrow> error (concat\n        [''expected one of: '', concat (map (\\<lambda>p. fst p @ '' '') ps), ''\\<newline>'', ''but found'', ''\\<newline>'', show x])\n    | Some p \\<Rightarrow> p x)\""], ["", "hide_const (open) options"], ["", "lemma options_mono_gen [partial_function_mono]:\n  assumes p: \"\\<And> k p. (k, p) \\<in> set ps \\<Longrightarrow> mono_sum_bot (p x)\"\n  shows \"mono_sum_bot (\\<lambda> g. Xmlt.options (map (\\<lambda> (k, p). (k, (\\<lambda> y. p y g))) ps) x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         Xmlt.options (map (\\<lambda>(k, p). (k, \\<lambda>y. p y g)) ps) x)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         Xmlt.options (map (\\<lambda>(k, p). (k, \\<lambda>y. p y g)) ps) x)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         Xmlt.options (map (\\<lambda>(k, p). (k, \\<lambda>y. p y g)) ps) x)", "fix g"], ["proof (state)\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         Xmlt.options (map (\\<lambda>(k, p). (k, \\<lambda>y. p y g)) ps) x)", "have \"(map (\\<lambda>p. fst p @ '' '') (map (\\<lambda>(k, p). (k, \\<lambda>y. p y g)) ps)) = \n      map (\\<lambda>p. fst p @ '' '') ps\""], ["proof (prove)\ngoal (1 subgoal):\n 1. map (\\<lambda>p. fst p @ '' '')\n     (map (\\<lambda>(k, p). (k, \\<lambda>y. p y g)) ps) =\n    map (\\<lambda>p. fst p @ '' '') ps", "by (induct ps) (auto)"], ["proof (state)\nthis:\n  map (\\<lambda>p. fst p @ '' '')\n   (map (\\<lambda>(k, p). (k, \\<lambda>y. p y g)) ps) =\n  map (\\<lambda>p. fst p @ '' '') ps\n\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         Xmlt.options (map (\\<lambda>(k, p). (k, \\<lambda>y. p y g)) ps) x)", "}"], ["proof (state)\nthis:\n  map (\\<lambda>p. fst p @ '' '')\n   (map (\\<lambda>(k, p). (k, \\<lambda>y. p y ?g2)) ps) =\n  map (\\<lambda>p. fst p @ '' '') ps\n\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         Xmlt.options (map (\\<lambda>(k, p). (k, \\<lambda>y. p y g)) ps) x)", "note id = this"], ["proof (state)\nthis:\n  map (\\<lambda>p. fst p @ '' '')\n   (map (\\<lambda>(k, p). (k, \\<lambda>y. p y ?g2)) ps) =\n  map (\\<lambda>p. fst p @ '' '') ps\n\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         Xmlt.options (map (\\<lambda>(k, p). (k, \\<lambda>y. p y g)) ps) x)", "{"], ["proof (state)\nthis:\n  map (\\<lambda>p. fst p @ '' '')\n   (map (\\<lambda>(k, p). (k, \\<lambda>y. p y ?g2)) ps) =\n  map (\\<lambda>p. fst p @ '' '') ps\n\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         Xmlt.options (map (\\<lambda>(k, p). (k, \\<lambda>y. p y g)) ps) x)", "fix z"], ["proof (state)\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         Xmlt.options (map (\\<lambda>(k, p). (k, \\<lambda>y. p y g)) ps) x)", "have \"mono_sum_bot\n      (\\<lambda>g. case map_of (map (\\<lambda>(k, p). (k, \\<lambda>y. p y g)) ps) (Xml.tag x) of\n        None \\<Rightarrow> z\n      | Some p \\<Rightarrow> p x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         case map_of (map (\\<lambda>(k, p). (k, \\<lambda>y. p y g)) ps)\n               (Xml.tag x) of\n         None \\<Rightarrow> z | Some p \\<Rightarrow> p x)", "using p"], ["proof (prove)\nusing this:\n  (?k, ?p) \\<in> set ps \\<Longrightarrow>\n  monotone sum_bot.le_fun sum_bot_ord (?p x)\n\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         case map_of (map (\\<lambda>(k, p). (k, \\<lambda>y. p y g)) ps)\n               (Xml.tag x) of\n         None \\<Rightarrow> z | Some p \\<Rightarrow> p x)", "proof (induct ps)"], ["proof (state)\ngoal (2 subgoals):\n 1. (\\<And>k p.\n        (k, p) \\<in> set [] \\<Longrightarrow>\n        monotone sum_bot.le_fun sum_bot_ord (p x)) \\<Longrightarrow>\n    monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         case map_of (map (\\<lambda>(k, p). (k, \\<lambda>y. p y g)) [])\n               (Xml.tag x) of\n         None \\<Rightarrow> z | Some p \\<Rightarrow> p x)\n 2. \\<And>a ps.\n       \\<lbrakk>(\\<And>k p.\n                    (k, p) \\<in> set ps \\<Longrightarrow>\n                    monotone sum_bot.le_fun sum_bot_ord\n                     (p x)) \\<Longrightarrow>\n                monotone sum_bot.le_fun sum_bot_ord\n                 (\\<lambda>g.\n                     case map_of\n                           (map (\\<lambda>(k, p). (k, \\<lambda>y. p y g))\n                             ps)\n                           (Xml.tag x) of\n                     None \\<Rightarrow> z | Some p \\<Rightarrow> p x);\n        \\<And>k p.\n           (k, p) \\<in> set (a # ps) \\<Longrightarrow>\n           monotone sum_bot.le_fun sum_bot_ord (p x)\\<rbrakk>\n       \\<Longrightarrow> monotone sum_bot.le_fun sum_bot_ord\n                          (\\<lambda>g.\n                              case map_of\n                                    (map\n(\\<lambda>(k, p). (k, \\<lambda>y. p y g)) (a # ps))\n                                    (Xml.tag x) of\n                              None \\<Rightarrow> z\n                              | Some p \\<Rightarrow> p x)", "case Nil"], ["proof (state)\nthis:\n  (?k, ?p) \\<in> set [] \\<Longrightarrow>\n  monotone sum_bot.le_fun sum_bot_ord (?p x)\n\ngoal (2 subgoals):\n 1. (\\<And>k p.\n        (k, p) \\<in> set [] \\<Longrightarrow>\n        monotone sum_bot.le_fun sum_bot_ord (p x)) \\<Longrightarrow>\n    monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         case map_of (map (\\<lambda>(k, p). (k, \\<lambda>y. p y g)) [])\n               (Xml.tag x) of\n         None \\<Rightarrow> z | Some p \\<Rightarrow> p x)\n 2. \\<And>a ps.\n       \\<lbrakk>(\\<And>k p.\n                    (k, p) \\<in> set ps \\<Longrightarrow>\n                    monotone sum_bot.le_fun sum_bot_ord\n                     (p x)) \\<Longrightarrow>\n                monotone sum_bot.le_fun sum_bot_ord\n                 (\\<lambda>g.\n                     case map_of\n                           (map (\\<lambda>(k, p). (k, \\<lambda>y. p y g))\n                             ps)\n                           (Xml.tag x) of\n                     None \\<Rightarrow> z | Some p \\<Rightarrow> p x);\n        \\<And>k p.\n           (k, p) \\<in> set (a # ps) \\<Longrightarrow>\n           monotone sum_bot.le_fun sum_bot_ord (p x)\\<rbrakk>\n       \\<Longrightarrow> monotone sum_bot.le_fun sum_bot_ord\n                          (\\<lambda>g.\n                              case map_of\n                                    (map\n(\\<lambda>(k, p). (k, \\<lambda>y. p y g)) (a # ps))\n                                    (Xml.tag x) of\n                              None \\<Rightarrow> z\n                              | Some p \\<Rightarrow> p x)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         case map_of\n               (map (\\<lambda>a.\n                        case a of\n                        (k, p) \\<Rightarrow> (k, \\<lambda>y. p y g))\n                 [])\n               (Xml.tag x) of\n         None \\<Rightarrow> z | Some p \\<Rightarrow> p x)", "by (auto intro: partial_function_mono)"], ["proof (state)\nthis:\n  monotone sum_bot.le_fun sum_bot_ord\n   (\\<lambda>g.\n       case map_of\n             (map (\\<lambda>a.\n                      case a of (k, p) \\<Rightarrow> (k, \\<lambda>y. p y g))\n               [])\n             (Xml.tag x) of\n       None \\<Rightarrow> z | Some p \\<Rightarrow> p x)\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       \\<lbrakk>(\\<And>k p.\n                    (k, p) \\<in> set ps \\<Longrightarrow>\n                    monotone sum_bot.le_fun sum_bot_ord\n                     (p x)) \\<Longrightarrow>\n                monotone sum_bot.le_fun sum_bot_ord\n                 (\\<lambda>g.\n                     case map_of\n                           (map (\\<lambda>(k, p). (k, \\<lambda>y. p y g))\n                             ps)\n                           (Xml.tag x) of\n                     None \\<Rightarrow> z | Some p \\<Rightarrow> p x);\n        \\<And>k p.\n           (k, p) \\<in> set (a # ps) \\<Longrightarrow>\n           monotone sum_bot.le_fun sum_bot_ord (p x)\\<rbrakk>\n       \\<Longrightarrow> monotone sum_bot.le_fun sum_bot_ord\n                          (\\<lambda>g.\n                              case map_of\n                                    (map\n(\\<lambda>(k, p). (k, \\<lambda>y. p y g)) (a # ps))\n                                    (Xml.tag x) of\n                              None \\<Rightarrow> z\n                              | Some p \\<Rightarrow> p x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       \\<lbrakk>(\\<And>k p.\n                    (k, p) \\<in> set ps \\<Longrightarrow>\n                    monotone sum_bot.le_fun sum_bot_ord\n                     (p x)) \\<Longrightarrow>\n                monotone sum_bot.le_fun sum_bot_ord\n                 (\\<lambda>g.\n                     case map_of\n                           (map (\\<lambda>(k, p). (k, \\<lambda>y. p y g))\n                             ps)\n                           (Xml.tag x) of\n                     None \\<Rightarrow> z | Some p \\<Rightarrow> p x);\n        \\<And>k p.\n           (k, p) \\<in> set (a # ps) \\<Longrightarrow>\n           monotone sum_bot.le_fun sum_bot_ord (p x)\\<rbrakk>\n       \\<Longrightarrow> monotone sum_bot.le_fun sum_bot_ord\n                          (\\<lambda>g.\n                              case map_of\n                                    (map\n(\\<lambda>(k, p). (k, \\<lambda>y. p y g)) (a # ps))\n                                    (Xml.tag x) of\n                              None \\<Rightarrow> z\n                              | Some p \\<Rightarrow> p x)", "case (Cons kp ps)"], ["proof (state)\nthis:\n  (\\<And>k p.\n      (k, p) \\<in> set ps \\<Longrightarrow>\n      monotone sum_bot.le_fun sum_bot_ord (p x)) \\<Longrightarrow>\n  monotone sum_bot.le_fun sum_bot_ord\n   (\\<lambda>g.\n       case map_of\n             (map (\\<lambda>a.\n                      case a of (k, p) \\<Rightarrow> (k, \\<lambda>y. p y g))\n               ps)\n             (Xml.tag x) of\n       None \\<Rightarrow> z | Some p \\<Rightarrow> p x)\n  (?k, ?p) \\<in> set (kp # ps) \\<Longrightarrow>\n  monotone sum_bot.le_fun sum_bot_ord (?p x)\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       \\<lbrakk>(\\<And>k p.\n                    (k, p) \\<in> set ps \\<Longrightarrow>\n                    monotone sum_bot.le_fun sum_bot_ord\n                     (p x)) \\<Longrightarrow>\n                monotone sum_bot.le_fun sum_bot_ord\n                 (\\<lambda>g.\n                     case map_of\n                           (map (\\<lambda>(k, p). (k, \\<lambda>y. p y g))\n                             ps)\n                           (Xml.tag x) of\n                     None \\<Rightarrow> z | Some p \\<Rightarrow> p x);\n        \\<And>k p.\n           (k, p) \\<in> set (a # ps) \\<Longrightarrow>\n           monotone sum_bot.le_fun sum_bot_ord (p x)\\<rbrakk>\n       \\<Longrightarrow> monotone sum_bot.le_fun sum_bot_ord\n                          (\\<lambda>g.\n                              case map_of\n                                    (map\n(\\<lambda>(k, p). (k, \\<lambda>y. p y g)) (a # ps))\n                                    (Xml.tag x) of\n                              None \\<Rightarrow> z\n                              | Some p \\<Rightarrow> p x)", "obtain k p where kp: \"kp = (k,p)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>k p. kp = (k, p) \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  kp = (k, p)\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       \\<lbrakk>(\\<And>k p.\n                    (k, p) \\<in> set ps \\<Longrightarrow>\n                    monotone sum_bot.le_fun sum_bot_ord\n                     (p x)) \\<Longrightarrow>\n                monotone sum_bot.le_fun sum_bot_ord\n                 (\\<lambda>g.\n                     case map_of\n                           (map (\\<lambda>(k, p). (k, \\<lambda>y. p y g))\n                             ps)\n                           (Xml.tag x) of\n                     None \\<Rightarrow> z | Some p \\<Rightarrow> p x);\n        \\<And>k p.\n           (k, p) \\<in> set (a # ps) \\<Longrightarrow>\n           monotone sum_bot.le_fun sum_bot_ord (p x)\\<rbrakk>\n       \\<Longrightarrow> monotone sum_bot.le_fun sum_bot_ord\n                          (\\<lambda>g.\n                              case map_of\n                                    (map\n(\\<lambda>(k, p). (k, \\<lambda>y. p y g)) (a # ps))\n                                    (Xml.tag x) of\n                              None \\<Rightarrow> z\n                              | Some p \\<Rightarrow> p x)", "note Cons = Cons[unfolded kp]"], ["proof (state)\nthis:\n  (\\<And>k p.\n      (k, p) \\<in> set ps \\<Longrightarrow>\n      monotone sum_bot.le_fun sum_bot_ord (p x)) \\<Longrightarrow>\n  monotone sum_bot.le_fun sum_bot_ord\n   (\\<lambda>g.\n       case map_of\n             (map (\\<lambda>a.\n                      case a of (k, p) \\<Rightarrow> (k, \\<lambda>y. p y g))\n               ps)\n             (Xml.tag x) of\n       None \\<Rightarrow> z | Some p \\<Rightarrow> p x)\n  (?k, ?p) \\<in> set ((k, p) # ps) \\<Longrightarrow>\n  monotone sum_bot.le_fun sum_bot_ord (?p x)\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       \\<lbrakk>(\\<And>k p.\n                    (k, p) \\<in> set ps \\<Longrightarrow>\n                    monotone sum_bot.le_fun sum_bot_ord\n                     (p x)) \\<Longrightarrow>\n                monotone sum_bot.le_fun sum_bot_ord\n                 (\\<lambda>g.\n                     case map_of\n                           (map (\\<lambda>(k, p). (k, \\<lambda>y. p y g))\n                             ps)\n                           (Xml.tag x) of\n                     None \\<Rightarrow> z | Some p \\<Rightarrow> p x);\n        \\<And>k p.\n           (k, p) \\<in> set (a # ps) \\<Longrightarrow>\n           monotone sum_bot.le_fun sum_bot_ord (p x)\\<rbrakk>\n       \\<Longrightarrow> monotone sum_bot.le_fun sum_bot_ord\n                          (\\<lambda>g.\n                              case map_of\n                                    (map\n(\\<lambda>(k, p). (k, \\<lambda>y. p y g)) (a # ps))\n                                    (Xml.tag x) of\n                              None \\<Rightarrow> z\n                              | Some p \\<Rightarrow> p x)", "from Cons(2)"], ["proof (chain)\npicking this:\n  (?k, ?p) \\<in> set ((k, p) # ps) \\<Longrightarrow>\n  monotone sum_bot.le_fun sum_bot_ord (?p x)", "have monop: \"mono_sum_bot (p x)\" and mono: \"\\<And> k p. (k,p) \\<in> set ps \\<Longrightarrow> mono_sum_bot (p x)\""], ["proof (prove)\nusing this:\n  (?k, ?p) \\<in> set ((k, p) # ps) \\<Longrightarrow>\n  monotone sum_bot.le_fun sum_bot_ord (?p x)\n\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord (p x) &&&\n    (\\<And>k p.\n        (k, p) \\<in> set ps \\<Longrightarrow>\n        monotone sum_bot.le_fun sum_bot_ord (p x))", "by auto"], ["proof (state)\nthis:\n  monotone sum_bot.le_fun sum_bot_ord (p x)\n  (?k, ?p) \\<in> set ps \\<Longrightarrow>\n  monotone sum_bot.le_fun sum_bot_ord (?p x)\n\ngoal (1 subgoal):\n 1. \\<And>a ps.\n       \\<lbrakk>(\\<And>k p.\n                    (k, p) \\<in> set ps \\<Longrightarrow>\n                    monotone sum_bot.le_fun sum_bot_ord\n                     (p x)) \\<Longrightarrow>\n                monotone sum_bot.le_fun sum_bot_ord\n                 (\\<lambda>g.\n                     case map_of\n                           (map (\\<lambda>(k, p). (k, \\<lambda>y. p y g))\n                             ps)\n                           (Xml.tag x) of\n                     None \\<Rightarrow> z | Some p \\<Rightarrow> p x);\n        \\<And>k p.\n           (k, p) \\<in> set (a # ps) \\<Longrightarrow>\n           monotone sum_bot.le_fun sum_bot_ord (p x)\\<rbrakk>\n       \\<Longrightarrow> monotone sum_bot.le_fun sum_bot_ord\n                          (\\<lambda>g.\n                              case map_of\n                                    (map\n(\\<lambda>(k, p). (k, \\<lambda>y. p y g)) (a # ps))\n                                    (Xml.tag x) of\n                              None \\<Rightarrow> z\n                              | Some p \\<Rightarrow> p x)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         case map_of\n               (map (\\<lambda>a.\n                        case a of\n                        (k, p) \\<Rightarrow> (k, \\<lambda>y. p y g))\n                 (kp # ps))\n               (Xml.tag x) of\n         None \\<Rightarrow> z | Some p \\<Rightarrow> p x)", "proof (cases \"Xml.tag x = k\")"], ["proof (state)\ngoal (2 subgoals):\n 1. Xml.tag x = k \\<Longrightarrow>\n    monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         case map_of\n               (map (\\<lambda>a.\n                        case a of\n                        (k, p) \\<Rightarrow> (k, \\<lambda>y. p y g))\n                 (kp # ps))\n               (Xml.tag x) of\n         None \\<Rightarrow> z | Some p \\<Rightarrow> p x)\n 2. Xml.tag x \\<noteq> k \\<Longrightarrow>\n    monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         case map_of\n               (map (\\<lambda>a.\n                        case a of\n                        (k, p) \\<Rightarrow> (k, \\<lambda>y. p y g))\n                 (kp # ps))\n               (Xml.tag x) of\n         None \\<Rightarrow> z | Some p \\<Rightarrow> p x)", "case True"], ["proof (state)\nthis:\n  Xml.tag x = k\n\ngoal (2 subgoals):\n 1. Xml.tag x = k \\<Longrightarrow>\n    monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         case map_of\n               (map (\\<lambda>a.\n                        case a of\n                        (k, p) \\<Rightarrow> (k, \\<lambda>y. p y g))\n                 (kp # ps))\n               (Xml.tag x) of\n         None \\<Rightarrow> z | Some p \\<Rightarrow> p x)\n 2. Xml.tag x \\<noteq> k \\<Longrightarrow>\n    monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         case map_of\n               (map (\\<lambda>a.\n                        case a of\n                        (k, p) \\<Rightarrow> (k, \\<lambda>y. p y g))\n                 (kp # ps))\n               (Xml.tag x) of\n         None \\<Rightarrow> z | Some p \\<Rightarrow> p x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  Xml.tag x = k\n\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         case map_of\n               (map (\\<lambda>a.\n                        case a of\n                        (k, p) \\<Rightarrow> (k, \\<lambda>y. p y g))\n                 (kp # ps))\n               (Xml.tag x) of\n         None \\<Rightarrow> z | Some p \\<Rightarrow> p x)", "unfolding kp"], ["proof (prove)\nusing this:\n  Xml.tag x = k\n\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         case map_of\n               (map (\\<lambda>a.\n                        case a of\n                        (k, p) \\<Rightarrow> (k, \\<lambda>y. p y g))\n                 ((k, p) # ps))\n               (Xml.tag x) of\n         None \\<Rightarrow> z | Some p \\<Rightarrow> p x)", "using monop"], ["proof (prove)\nusing this:\n  Xml.tag x = k\n  monotone sum_bot.le_fun sum_bot_ord (p x)\n\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         case map_of\n               (map (\\<lambda>a.\n                        case a of\n                        (k, p) \\<Rightarrow> (k, \\<lambda>y. p y g))\n                 ((k, p) # ps))\n               (Xml.tag x) of\n         None \\<Rightarrow> z | Some p \\<Rightarrow> p x)", "by auto"], ["proof (state)\nthis:\n  monotone sum_bot.le_fun sum_bot_ord\n   (\\<lambda>g.\n       case map_of\n             (map (\\<lambda>a.\n                      case a of (k, p) \\<Rightarrow> (k, \\<lambda>y. p y g))\n               (kp # ps))\n             (Xml.tag x) of\n       None \\<Rightarrow> z | Some p \\<Rightarrow> p x)\n\ngoal (1 subgoal):\n 1. Xml.tag x \\<noteq> k \\<Longrightarrow>\n    monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         case map_of\n               (map (\\<lambda>a.\n                        case a of\n                        (k, p) \\<Rightarrow> (k, \\<lambda>y. p y g))\n                 (kp # ps))\n               (Xml.tag x) of\n         None \\<Rightarrow> z | Some p \\<Rightarrow> p x)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. Xml.tag x \\<noteq> k \\<Longrightarrow>\n    monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         case map_of\n               (map (\\<lambda>a.\n                        case a of\n                        (k, p) \\<Rightarrow> (k, \\<lambda>y. p y g))\n                 (kp # ps))\n               (Xml.tag x) of\n         None \\<Rightarrow> z | Some p \\<Rightarrow> p x)", "case False"], ["proof (state)\nthis:\n  Xml.tag x \\<noteq> k\n\ngoal (1 subgoal):\n 1. Xml.tag x \\<noteq> k \\<Longrightarrow>\n    monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         case map_of\n               (map (\\<lambda>a.\n                        case a of\n                        (k, p) \\<Rightarrow> (k, \\<lambda>y. p y g))\n                 (kp # ps))\n               (Xml.tag x) of\n         None \\<Rightarrow> z | Some p \\<Rightarrow> p x)", "thus ?thesis"], ["proof (prove)\nusing this:\n  Xml.tag x \\<noteq> k\n\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         case map_of\n               (map (\\<lambda>a.\n                        case a of\n                        (k, p) \\<Rightarrow> (k, \\<lambda>y. p y g))\n                 (kp # ps))\n               (Xml.tag x) of\n         None \\<Rightarrow> z | Some p \\<Rightarrow> p x)", "using Cons(1) mono"], ["proof (prove)\nusing this:\n  Xml.tag x \\<noteq> k\n  (\\<And>k p.\n      (k, p) \\<in> set ps \\<Longrightarrow>\n      monotone sum_bot.le_fun sum_bot_ord (p x)) \\<Longrightarrow>\n  monotone sum_bot.le_fun sum_bot_ord\n   (\\<lambda>g.\n       case map_of\n             (map (\\<lambda>a.\n                      case a of (k, p) \\<Rightarrow> (k, \\<lambda>y. p y g))\n               ps)\n             (Xml.tag x) of\n       None \\<Rightarrow> z | Some p \\<Rightarrow> p x)\n  (?k, ?p) \\<in> set ps \\<Longrightarrow>\n  monotone sum_bot.le_fun sum_bot_ord (?p x)\n\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         case map_of\n               (map (\\<lambda>a.\n                        case a of\n                        (k, p) \\<Rightarrow> (k, \\<lambda>y. p y g))\n                 (kp # ps))\n               (Xml.tag x) of\n         None \\<Rightarrow> z | Some p \\<Rightarrow> p x)", "unfolding kp"], ["proof (prove)\nusing this:\n  Xml.tag x \\<noteq> k\n  (\\<And>k p.\n      (k, p) \\<in> set ps \\<Longrightarrow>\n      monotone sum_bot.le_fun sum_bot_ord (p x)) \\<Longrightarrow>\n  monotone sum_bot.le_fun sum_bot_ord\n   (\\<lambda>g.\n       case map_of\n             (map (\\<lambda>a.\n                      case a of (k, p) \\<Rightarrow> (k, \\<lambda>y. p y g))\n               ps)\n             (Xml.tag x) of\n       None \\<Rightarrow> z | Some p \\<Rightarrow> p x)\n  (?k, ?p) \\<in> set ps \\<Longrightarrow>\n  monotone sum_bot.le_fun sum_bot_ord (?p x)\n\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         case map_of\n               (map (\\<lambda>a.\n                        case a of\n                        (k, p) \\<Rightarrow> (k, \\<lambda>y. p y g))\n                 ((k, p) # ps))\n               (Xml.tag x) of\n         None \\<Rightarrow> z | Some p \\<Rightarrow> p x)", "by auto"], ["proof (state)\nthis:\n  monotone sum_bot.le_fun sum_bot_ord\n   (\\<lambda>g.\n       case map_of\n             (map (\\<lambda>a.\n                      case a of (k, p) \\<Rightarrow> (k, \\<lambda>y. p y g))\n               (kp # ps))\n             (Xml.tag x) of\n       None \\<Rightarrow> z | Some p \\<Rightarrow> p x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monotone sum_bot.le_fun sum_bot_ord\n   (\\<lambda>g.\n       case map_of\n             (map (\\<lambda>a.\n                      case a of (k, p) \\<Rightarrow> (k, \\<lambda>y. p y g))\n               (kp # ps))\n             (Xml.tag x) of\n       None \\<Rightarrow> z | Some p \\<Rightarrow> p x)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  monotone sum_bot.le_fun sum_bot_ord\n   (\\<lambda>g.\n       case map_of (map (\\<lambda>(k, p). (k, \\<lambda>y. p y g)) ps)\n             (Xml.tag x) of\n       None \\<Rightarrow> z | Some p \\<Rightarrow> p x)\n\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         Xmlt.options (map (\\<lambda>(k, p). (k, \\<lambda>y. p y g)) ps) x)", "}"], ["proof (state)\nthis:\n  monotone sum_bot.le_fun sum_bot_ord\n   (\\<lambda>g.\n       case map_of (map (\\<lambda>(k, p). (k, \\<lambda>y. p y g)) ps)\n             (Xml.tag x) of\n       None \\<Rightarrow> ?z2 | Some p \\<Rightarrow> p x)\n\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         Xmlt.options (map (\\<lambda>(k, p). (k, \\<lambda>y. p y g)) ps) x)", "note main = this"], ["proof (state)\nthis:\n  monotone sum_bot.le_fun sum_bot_ord\n   (\\<lambda>g.\n       case map_of (map (\\<lambda>(k, p). (k, \\<lambda>y. p y g)) ps)\n             (Xml.tag x) of\n       None \\<Rightarrow> ?z2 | Some p \\<Rightarrow> p x)\n\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         Xmlt.options (map (\\<lambda>(k, p). (k, \\<lambda>y. p y g)) ps) x)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         Xmlt.options (map (\\<lambda>(k, p). (k, \\<lambda>y. p y g)) ps) x)", "unfolding Xmlt.options_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         case map_of (map (\\<lambda>(k, p). (k, \\<lambda>y. p y g)) ps)\n               (Xml.tag x) of\n         None \\<Rightarrow>\n           Strict_Sum.error\n            (concat\n              [''expected one of: '',\n               concat\n                (map (\\<lambda>p. fst p @ '' '')\n                  (map (\\<lambda>(k, p). (k, \\<lambda>y. p y g)) ps)),\n               ''\\<newline>'', ''but found'', ''\\<newline>'', show x])\n         | Some p \\<Rightarrow> p x)", "unfolding id"], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         case map_of (map (\\<lambda>(k, p). (k, \\<lambda>y. p y g)) ps)\n               (Xml.tag x) of\n         None \\<Rightarrow>\n           Strict_Sum.error\n            (concat\n              [''expected one of: '',\n               concat (map (\\<lambda>p. fst p @ '' '') ps), ''\\<newline>'',\n               ''but found'', ''\\<newline>'', show x])\n         | Some p \\<Rightarrow> p x)", "by (rule main)"], ["proof (state)\nthis:\n  monotone sum_bot.le_fun sum_bot_ord\n   (\\<lambda>g.\n       Xmlt.options (map (\\<lambda>(k, p). (k, \\<lambda>y. p y g)) ps) x)\n\ngoal:\nNo subgoals!", "qed"], ["", "(* instantiate this lemma to have the monotonicity lemmas for lists of variable lengths which\n   are then applicable, e.g., for lists of length 3 it would be\n\nmono_sum_bot (p1 x) \\<Longrightarrow> mono_sum_bot (p2 x) \\<Longrightarrow> mono_sum_bot (p3 x) \n\\<Longrightarrow> mono_sum_bot (\\<lambda>g. Xmlt.options [(k1, \\<lambda>y. p1 y g), (k2, \\<lambda>y. p2 y g), (k3, \\<lambda>y. p3 y g)] x)\n\n*)"], ["", "local_setup \\<open>fn lthy => \n  let\n    val N = 30 (* we require monotonicity lemmas for xml-options for lists up to length N *) \n    val thy = Proof_Context.theory_of lthy\n    val options = @{term \"Xmlt.options :: (string \\<times> (xml \\<Rightarrow> (string +\\<^sub>\\<bottom> 'd))) list \\<Rightarrow> xml \\<Rightarrow> string +\\<^sub>\\<bottom> 'd\"}\n    val mono_sum_bot = @{term \"mono_sum_bot :: (('a \\<Rightarrow> ('b +\\<^sub>\\<bottom> 'c)) \\<Rightarrow> string +\\<^sub>\\<bottom> 'd) \\<Rightarrow> bool\"}\n    val ktyp = @{typ string}\n    val x = @{term \"x :: xml\"}\n    val y = @{term \"y :: xml\"}\n    val g = @{term \"g :: 'a \\<Rightarrow> 'b +\\<^sub>\\<bottom> 'c\"}\n    val ptyp = @{typ \"xml \\<Rightarrow> ('a \\<Rightarrow> ('b +\\<^sub>\\<bottom> 'c)) \\<Rightarrow> string +\\<^sub>\\<bottom> 'd\"}\n    fun k i = Free (\"k\" ^ string_of_int i,ktyp)\n    fun p i = Free (\"p\" ^ string_of_int i,ptyp)\n    fun prem i = HOLogic.mk_Trueprop (mono_sum_bot $ (p i $ x))\n    fun prems n = 1 upto n |> map prem\n    fun pair i = HOLogic.mk_prod (k i, lambda y (p i $ y $ g))\n    fun pair2 i = HOLogic.mk_prod (k i, p i)\n    fun list n = 1 upto n |> map pair |> HOLogic.mk_list @{typ \"(string \\<times> (xml \\<Rightarrow> string +\\<^sub>\\<bottom> 'd))\"}\n    fun list2 n = 1 upto n |> map pair2 |> HOLogic.mk_list (HOLogic.mk_prodT (ktyp,ptyp))\n    fun concl n = HOLogic.mk_Trueprop (mono_sum_bot $ lambda g (options $ (list n) $ x))\n    fun xs n = x :: (1 upto n |> map (fn i => [p i, k i]) |> List.concat)\n       |> map (fst o dest_Free)\n    fun tac n pc =\n      let\n        val {prems = prems, context = ctxt} = pc\n        val mono_thm = Thm.instantiate' \n            (map (SOME o Thm.ctyp_of ctxt) [@{typ 'a},@{typ 'b},@{typ 'c},@{typ 'd}]) \n            (map (SOME o Thm.cterm_of ctxt) [list2 n,x]) @{thm Xmlt.options_mono_gen}\n      in \n        Method.insert_tac ctxt (mono_thm :: prems) 1 THEN force_tac ctxt 1\n      end\n    fun thm n = Goal.prove lthy (xs n) (prems n) (concl n) (tac n)\n    val thms = map thm (0 upto N)\n  in Local_Theory.note ((@{binding \"options_mono_thms\"}, []), thms) lthy |> snd end\n\\<close>"], ["", "declare Xmlt.options_mono_thms [partial_function_mono]"], ["", "fun choice :: \"string \\<Rightarrow> 'a xmlt list \\<Rightarrow> 'a xmlt\"\nwhere\n  \"choice e [] x = error (concat [''error in parsing choice for '', e, ''\\<newline>'', show x])\" |\n  \"choice e (p # ps) x = (try p x catch (\\<lambda>_. choice e ps x))\""], ["", "hide_const (open) choice"], ["", "lemma choice_mono_2 [partial_function_mono]:\n  assumes p: \"mono_sum_bot (p1 x)\"\n             \"mono_sum_bot (p2 x)\"\n  shows \"mono_sum_bot (\\<lambda> g. Xmlt.choice e [(\\<lambda> y. p1 y g), (\\<lambda> y. p2 y g)] x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g. Xmlt.choice e [\\<lambda>y. p1 y g, \\<lambda>y. p2 y g] x)", "using p"], ["proof (prove)\nusing this:\n  monotone sum_bot.le_fun sum_bot_ord (p1 x)\n  monotone sum_bot.le_fun sum_bot_ord (p2 x)\n\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g. Xmlt.choice e [\\<lambda>y. p1 y g, \\<lambda>y. p2 y g] x)", "by (auto intro!: partial_function_mono)"], ["", "lemma choice_mono_3 [partial_function_mono]:\n  assumes p: \"mono_sum_bot (p1 x)\"\n             \"mono_sum_bot (p2 x)\"\n             \"mono_sum_bot (p3 x)\"\n  shows \"mono_sum_bot (\\<lambda> g. Xmlt.choice e [(\\<lambda> y. p1 y g), (\\<lambda> y. p2 y g), (\\<lambda> y. p3 y g)] x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         Xmlt.choice e\n          [\\<lambda>y. p1 y g, \\<lambda>y. p2 y g, \\<lambda>y. p3 y g] x)", "using p"], ["proof (prove)\nusing this:\n  monotone sum_bot.le_fun sum_bot_ord (p1 x)\n  monotone sum_bot.le_fun sum_bot_ord (p2 x)\n  monotone sum_bot.le_fun sum_bot_ord (p3 x)\n\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g.\n         Xmlt.choice e\n          [\\<lambda>y. p1 y g, \\<lambda>y. p2 y g, \\<lambda>y. p3 y g] x)", "by (auto intro!: partial_function_mono)"], ["", "fun change :: \"'a xmlt \\<Rightarrow> ('a \\<Rightarrow> 'b) \\<Rightarrow> 'b xmlt\"\nwhere\n  \"change p f x = p x \\<bind> return \\<circ> f\""], ["", "hide_const (open) change"], ["", "lemma change_mono [partial_function_mono]:\n  assumes p: \"\\<And>y. mono_sum_bot (p1 y)\"\n  shows \"mono_sum_bot (\\<lambda>g. Xmlt.change (\\<lambda>y. p1 y g) f x)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. monotone sum_bot.le_fun sum_bot_ord\n     (\\<lambda>g. Xmlt.change (\\<lambda>y. p1 y g) f x)", "by (cases x, insert p, auto intro!: partial_function_mono)"], ["", "fun int_of_digit :: \"char \\<Rightarrow> string +\\<^sub>\\<bottom> int\"\nwhere\n  \"int_of_digit x =\n    (if x = CHR ''0'' then return 0\n    else if x = CHR ''1'' then return 1\n    else if x = CHR ''2'' then return 2\n    else if x = CHR ''3'' then return 3\n    else if x = CHR ''4'' then return 4\n    else if x = CHR ''5'' then return 5\n    else if x = CHR ''6'' then return 6\n    else if x = CHR ''7'' then return 7\n    else if x = CHR ''8'' then return 8\n    else if x = CHR ''9'' then return 9\n    else error (x # '' is not a digit''))\""], ["", "fun int_of_string_aux :: \"int \\<Rightarrow> string \\<Rightarrow> string +\\<^sub>\\<bottom> int\"\nwhere\n  \"int_of_string_aux n [] = return n\" |\n  \"int_of_string_aux n (d # s) = (int_of_digit d \\<bind> (\\<lambda>m. int_of_string_aux (10 * n + m) s))\""], ["", "definition int_of_string :: \"string \\<Rightarrow> string +\\<^sub>\\<bottom> int\"\nwhere\n  \"int_of_string s =\n    (if s = [] then error ''cannot convert empty string into number'' \n    else if take 1 s = ''-'' then int_of_string_aux 0 (tl s) \\<bind> (\\<lambda> i. return (0 - i))\n    else int_of_string_aux 0 s)\""], ["", "hide_const int_of_string_aux"], ["", "fun int :: \"tag \\<Rightarrow> int xmlt\"\nwhere\n  \"int tag x = (Xmlt.text tag x \\<bind> int_of_string)\""], ["", "hide_const (open) int"], ["", "fun nat :: \"tag \\<Rightarrow> nat xmlt\"\nwhere\n  \"nat tag x = do {\n    txt \\<leftarrow> Xmlt.text tag x;\n    i \\<leftarrow> int_of_string txt;\n    return (Int.nat i)\n  }\""], ["", "hide_const (open) nat"], ["", "definition rat :: \"rat xmlt\"\nwhere\n  \"rat = Xmlt.options [\n    (''integer'', Xmlt.change (Xmlt.int ''integer'') of_int),\n    (''rational'',\n      Xmlt.pair ''rational'' (Xmlt.int ''numerator'') (Xmlt.int ''denominator'')\n        (\\<lambda> x y. of_int x / of_int y))]\""], ["", "hide_const (open) rat"], ["", "end"]]}