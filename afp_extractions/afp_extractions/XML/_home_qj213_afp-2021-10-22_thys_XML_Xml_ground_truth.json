{"file_name": "/home/qj213/afp-2021-10-22/thys/XML/Xml.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/XML", "problem_names": ["lemma shows_attr_append:\n  \"(s +#+ shows_attr av) (r @ t) = (s +#+ shows_attr av) r @ t\"", "lemma shows_attrs_append [show_law_simps]:\n  \"shows_attrs as (r @ s) = shows_attrs as r @ s\"", "lemma append_xml':\n  \"shows_XML_indent ind i xml (r @ s) = shows_XML_indent ind i xml r @ s\"", "lemma shows_prec_xml_append [show_law_simps]:\n  \"shows_prec d (xml::xml) (r @ s) = shows_prec d xml r @ s\"", "lemma shows_prec_xmldoc_append [show_law_simps]:\n  \"shows_prec d (x::xmldoc) (r @ s) = shows_prec d x r @ s\"", "lemma is_parser_parse_text [intro]:\n  \"is_parser parse_text\"", "lemma parse_text_consumes:\n  assumes *: \"ts \\<noteq> []\" \"hd ts \\<noteq> CHR ''<''\"\n    and parse: \"parse_text ts = Inr (t, ts')\"\n  shows \"length ts' < length ts\"", "lemma is_parser_parse_attribute_value [intro]:\n  \"is_parser parse_attribute_value\"", "lemma is_letter_code [code]:\n  \"is_letter c \\<longleftrightarrow>\n    CHR ''a'' \\<le> c \\<and> c \\<le> CHR ''z'' \\<or>\n    CHR ''A'' \\<le> c \\<and> c \\<le> CHR ''Z'' \\<or>\n    CHR ''0'' \\<le> c \\<and> c \\<le> CHR ''9'' \\<or>\n    c \\<in> set ''_&;:-''\"", "lemma many_letters [code, code_unfold]:\n  \"many_letters = many is_letter\"", "lemma is_parser_parse_name [intro]:\n  \"is_parser parse_name\"", "lemma is_parser_parse_attributes [intro]:\n  \"is_parser parse_attributes\"", "lemma parse_nodes_help:\n  \"parse_nodes_dom s \\<and> (\\<forall> x r. parse_nodes s = Inr (x, r) \\<longrightarrow> length r \\<le> length s)\" (is \"?prop s\")", "lemma parse_nodes [intro]:\n  \"is_parser parse_nodes\"", "lemma oneof_closed:\n  \"oneof [''/>'', ''>''] = oneof_closed\" (is \"?l = ?r\")", "lemma If_removal:\n  \"(\\<lambda> e x. if b e then f e x else g e x) = (\\<lambda> e. if b e then f e else g e)\""], "translations": [["", "lemma shows_attr_append:\n  \"(s +#+ shows_attr av) (r @ t) = (s +#+ shows_attr av) r @ t\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (shows_string s \\<circ> shows_attr av) (r @ t) =\n    (shows_string s \\<circ> shows_attr av) r @ t", "unfolding shows_attr_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (shows_string s \\<circ>\n     (shows (fst av) \\<circ>\n      shows_string ([CHR ''='', CHR 0x22] @ snd av @ [CHR 0x22])))\n     (r @ t) =\n    (shows_string s \\<circ>\n     (shows (fst av) \\<circ>\n      shows_string ([CHR ''='', CHR 0x22] @ snd av @ [CHR 0x22])))\n     r @\n    t", "by (cases av) (auto simp: show_law_simps)"], ["", "lemma shows_attrs_append [show_law_simps]:\n  \"shows_attrs as (r @ s) = shows_attrs as r @ s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shows_attrs as (r @ s) = shows_attrs as r @ s", "using shows_attr_append"], ["proof (prove)\nusing this:\n  (shows_string ?s \\<circ> shows_attr ?av) (?r @ ?t) =\n  (shows_string ?s \\<circ> shows_attr ?av) ?r @ ?t\n\ngoal (1 subgoal):\n 1. shows_attrs as (r @ s) = shows_attrs as r @ s", "by (induct as) (simp_all add: shows_attrs_def)"], ["", "lemma append_xml':\n  \"shows_XML_indent ind i xml (r @ s) = shows_XML_indent ind i xml r @ s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shows_XML_indent ind i xml (r @ s) = shows_XML_indent ind i xml r @ s", "by (induct xml arbitrary: ind r s) (auto simp: show_law_simps)"], ["", "lemma shows_prec_xml_append [show_law_simps]:\n  \"shows_prec d (xml::xml) (r @ s) = shows_prec d xml r @ s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shows_prec d xml (r @ s) = shows_prec d xml r @ s", "unfolding shows_prec_xml_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. shows_XML_indent [] 2 xml (r @ s) = shows_XML_indent [] 2 xml r @ s", "by (rule append_xml')"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(xml, show_class)", "by standard (simp_all add: show_law_simps shows_list_xml_def)"], ["", "end"], ["", "instantiation xmldoc :: \"show\"\nbegin"], ["", "fun shows_xmldoc\nwhere\n  \"shows_xmldoc (XMLDOC h x) = shows_lines h o shows_nl o shows x\""], ["", "definition \"shows_prec (d::nat) doc = shows_xmldoc doc\""], ["", "definition \"shows_list (xs :: xmldoc list) = showsp_list shows_prec 0 xs\""], ["", "lemma shows_prec_xmldoc_append [show_law_simps]:\n  \"shows_prec d (x::xmldoc) (r @ s) = shows_prec d x r @ s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. shows_prec d x (r @ s) = shows_prec d x r @ s", "by (cases x) (auto simp: shows_prec_xmldoc_def show_law_simps)"], ["", "instance"], ["proof (prove)\ngoal (1 subgoal):\n 1. OFCLASS(xmldoc, show_class)", "by standard (simp_all add: show_law_simps shows_list_xmldoc_def)"], ["", "end"], ["", "subsection \\<open>XML-Parsing\\<close>"], ["", "definition parse_text :: \"string option parser\"\nwhere\n  \"parse_text = do {\n    ts \\<leftarrow> many ((\\<noteq>) CHR ''<'');\n    let text = trim ts;\n    if text = [] then return None\n    else return (Some (List.rev (trim (List.rev text))))\n  }\""], ["", "lemma is_parser_parse_text [intro]:\n  \"is_parser parse_text\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_parser parse_text", "by (auto simp: parse_text_def)"], ["", "lemma parse_text_consumes:\n  assumes *: \"ts \\<noteq> []\" \"hd ts \\<noteq> CHR ''<''\"\n    and parse: \"parse_text ts = Inr (t, ts')\"\n  shows \"length ts' < length ts\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length ts' < length ts", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. length ts' < length ts", "from *"], ["proof (chain)\npicking this:\n  ts \\<noteq> []\n  hd ts \\<noteq> CHR ''<''", "obtain a tss where ts: \"ts = a # tss\" and not: \"a \\<noteq> CHR ''<''\""], ["proof (prove)\nusing this:\n  ts \\<noteq> []\n  hd ts \\<noteq> CHR ''<''\n\ngoal (1 subgoal):\n 1. (\\<And>a tss.\n        \\<lbrakk>ts = a # tss; a \\<noteq> CHR ''<''\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by (cases ts, auto)"], ["proof (state)\nthis:\n  ts = a # tss\n  a \\<noteq> CHR ''<''\n\ngoal (1 subgoal):\n 1. length ts' < length ts", "note parse = parse [unfolded parse_text_def Let_def ts]"], ["proof (state)\nthis:\n  (many ((\\<noteq>) CHR ''<'') \\<bind>\n   (\\<lambda>ts.\n       if trim ts = [] then Parser_Monad.return None\n       else Parser_Monad.return (Some (rev (trim (rev (trim ts)))))))\n   (a # tss) =\n  Inr (t, ts')\n\ngoal (1 subgoal):\n 1. length ts' < length ts", "from parse"], ["proof (chain)\npicking this:\n  (many ((\\<noteq>) CHR ''<'') \\<bind>\n   (\\<lambda>ts.\n       if trim ts = [] then Parser_Monad.return None\n       else Parser_Monad.return (Some (rev (trim (rev (trim ts)))))))\n   (a # tss) =\n  Inr (t, ts')", "obtain x1 x2 where many: \"many ((\\<noteq>) CHR ''<'') tss = Inr (x1, x2)\""], ["proof (prove)\nusing this:\n  (many ((\\<noteq>) CHR ''<'') \\<bind>\n   (\\<lambda>ts.\n       if trim ts = [] then Parser_Monad.return None\n       else Parser_Monad.return (Some (rev (trim (rev (trim ts)))))))\n   (a # tss) =\n  Inr (t, ts')\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2.\n        many ((\\<noteq>) CHR ''<'') tss = Inr (x1, x2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "using not"], ["proof (prove)\nusing this:\n  (many ((\\<noteq>) CHR ''<'') \\<bind>\n   (\\<lambda>ts.\n       if trim ts = [] then Parser_Monad.return None\n       else Parser_Monad.return (Some (rev (trim (rev (trim ts)))))))\n   (a # tss) =\n  Inr (t, ts')\n  a \\<noteq> CHR ''<''\n\ngoal (1 subgoal):\n 1. (\\<And>x1 x2.\n        many ((\\<noteq>) CHR ''<'') tss = Inr (x1, x2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"many ((\\<noteq>) CHR ''<'') tss\", \n      auto simp: bind_def)"], ["proof (state)\nthis:\n  many ((\\<noteq>) CHR ''<'') tss = Inr (x1, x2)\n\ngoal (1 subgoal):\n 1. length ts' < length ts", "from is_parser_many many"], ["proof (chain)\npicking this:\n  is_parser (many ?P)\n  many ((\\<noteq>) CHR ''<'') tss = Inr (x1, x2)", "have len: \"length x2 \\<le> length tss\""], ["proof (prove)\nusing this:\n  is_parser (many ?P)\n  many ((\\<noteq>) CHR ''<'') tss = Inr (x1, x2)\n\ngoal (1 subgoal):\n 1. length x2 \\<le> length tss", "by blast"], ["proof (state)\nthis:\n  length x2 \\<le> length tss\n\ngoal (1 subgoal):\n 1. length ts' < length ts", "from parse many"], ["proof (chain)\npicking this:\n  (many ((\\<noteq>) CHR ''<'') \\<bind>\n   (\\<lambda>ts.\n       if trim ts = [] then Parser_Monad.return None\n       else Parser_Monad.return (Some (rev (trim (rev (trim ts)))))))\n   (a # tss) =\n  Inr (t, ts')\n  many ((\\<noteq>) CHR ''<'') tss = Inr (x1, x2)", "have \"length ts' \\<le> length x2\""], ["proof (prove)\nusing this:\n  (many ((\\<noteq>) CHR ''<'') \\<bind>\n   (\\<lambda>ts.\n       if trim ts = [] then Parser_Monad.return None\n       else Parser_Monad.return (Some (rev (trim (rev (trim ts)))))))\n   (a # tss) =\n  Inr (t, ts')\n  many ((\\<noteq>) CHR ''<'') tss = Inr (x1, x2)\n\ngoal (1 subgoal):\n 1. length ts' \\<le> length x2", "using not"], ["proof (prove)\nusing this:\n  (many ((\\<noteq>) CHR ''<'') \\<bind>\n   (\\<lambda>ts.\n       if trim ts = [] then Parser_Monad.return None\n       else Parser_Monad.return (Some (rev (trim (rev (trim ts)))))))\n   (a # tss) =\n  Inr (t, ts')\n  many ((\\<noteq>) CHR ''<'') tss = Inr (x1, x2)\n  a \\<noteq> CHR ''<''\n\ngoal (1 subgoal):\n 1. length ts' \\<le> length x2", "by (simp add: bind_def return_def split: if_splits)"], ["proof (state)\nthis:\n  length ts' \\<le> length x2\n\ngoal (1 subgoal):\n 1. length ts' < length ts", "with len"], ["proof (chain)\npicking this:\n  length x2 \\<le> length tss\n  length ts' \\<le> length x2", "show ?thesis"], ["proof (prove)\nusing this:\n  length x2 \\<le> length tss\n  length ts' \\<le> length x2\n\ngoal (1 subgoal):\n 1. length ts' < length ts", "unfolding ts"], ["proof (prove)\nusing this:\n  length x2 \\<le> length tss\n  length ts' \\<le> length x2\n\ngoal (1 subgoal):\n 1. length ts' < length (a # tss)", "by auto"], ["proof (state)\nthis:\n  length ts' < length ts\n\ngoal:\nNo subgoals!", "qed"], ["", "definition parse_attribute_value :: \"string parser\"\nwhere\n  \"parse_attribute_value = do {\n    exactly [CHR ''\\\"''];\n    v \\<leftarrow> many ((\\<noteq>) CHR ''\\\"'');\n    exactly [CHR ''\\\"''];\n    return v\n  }\""], ["", "lemma is_parser_parse_attribute_value [intro]:\n  \"is_parser parse_attribute_value\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_parser parse_attribute_value", "by (auto simp: parse_attribute_value_def)"], ["", "text \\<open>A list of characters that are considered to be \"letters\" for tag-names.\\<close>"], ["", "definition letters :: \"char list\"\nwhere\n  \"letters = ''abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789&;:-''\""], ["", "definition is_letter :: \"char \\<Rightarrow> bool\"\nwhere\n  \"is_letter c \\<longleftrightarrow> c \\<in> set letters\""], ["", "lemma is_letter_code [code]:\n  \"is_letter c \\<longleftrightarrow>\n    CHR ''a'' \\<le> c \\<and> c \\<le> CHR ''z'' \\<or>\n    CHR ''A'' \\<le> c \\<and> c \\<le> CHR ''Z'' \\<or>\n    CHR ''0'' \\<le> c \\<and> c \\<le> CHR ''9'' \\<or>\n    c \\<in> set ''_&;:-''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_letter c =\n    (CHR ''a'' \\<le> c \\<and> c \\<le> CHR ''z'' \\<or>\n     CHR ''A'' \\<le> c \\<and> c \\<le> CHR ''Z'' \\<or>\n     CHR ''0'' \\<le> c \\<and> c \\<le> CHR ''9'' \\<or> c \\<in> set ''_&;:-'')", "by (cases c) (simp add: is_letter_def letters_def)"], ["", "definition many_letters :: \"string parser\"\nwhere\n  [simp]: \"many_letters = manyof letters\""], ["", "lemma many_letters [code, code_unfold]:\n  \"many_letters = many is_letter\""], ["proof (prove)\ngoal (1 subgoal):\n 1. many_letters = many is_letter", "by (simp add: is_letter_def [abs_def] manyof_def)"], ["", "definition parse_name :: \"string parser\"\nwhere\n  \"parse_name s = (do {\n    n \\<leftarrow> many_letters;\n    spaces;\n    if n = [] then\n      error (''expected letter '' @ letters @ '' but first symbol is \\\"'' @ take 1 s @ ''\\\"'')\n    else return n\n  }) s\""], ["", "lemma is_parser_parse_name [intro]:\n  \"is_parser parse_name\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_parser parse_name", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s r x.\n       parse_name s = Inr (x, r) \\<Longrightarrow> length r \\<le> length s", "fix s r x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s r x.\n       parse_name s = Inr (x, r) \\<Longrightarrow> length r \\<le> length s", "assume res: \"parse_name s = Inr (x, r)\""], ["proof (state)\nthis:\n  parse_name s = Inr (x, r)\n\ngoal (1 subgoal):\n 1. \\<And>s r x.\n       parse_name s = Inr (x, r) \\<Longrightarrow> length r \\<le> length s", "let ?exp = \"do {\n    n \\<leftarrow> many_letters;\n    spaces;\n    if n = [] then\n      error (''expected letter '' @ letters @ '' but first symbol is \\\"'' @ take 1 s @ ''\\\"'')\n    else return n\n  }\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s r x.\n       parse_name s = Inr (x, r) \\<Longrightarrow> length r \\<le> length s", "have isp: \"is_parser ?exp\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_parser\n     (many_letters \\<bind>\n      (\\<lambda>n.\n          spaces \\<bind>\n          (\\<lambda>_.\n              if n = []\n              then Parser_Monad.error\n                    (''expected letter '' @\n                     letters @\n                     [CHR '' '', CHR ''b'', CHR ''u'', CHR ''t'', CHR '' '',\n                      CHR ''f'', CHR ''i'', CHR ''r'', CHR ''s'', CHR ''t'',\n                      CHR '' '', CHR ''s'', CHR ''y'', CHR ''m'', CHR ''b'',\n                      CHR ''o'', CHR ''l'', CHR '' '', CHR ''i'', CHR ''s'',\n                      CHR '' '', CHR 0x22] @\n                     take 1 s @ [CHR 0x22])\n              else Parser_Monad.return n)))", "by auto"], ["proof (state)\nthis:\n  is_parser\n   (many_letters \\<bind>\n    (\\<lambda>n.\n        spaces \\<bind>\n        (\\<lambda>_.\n            if n = []\n            then Parser_Monad.error\n                  (''expected letter '' @\n                   letters @\n                   [CHR '' '', CHR ''b'', CHR ''u'', CHR ''t'', CHR '' '',\n                    CHR ''f'', CHR ''i'', CHR ''r'', CHR ''s'', CHR ''t'',\n                    CHR '' '', CHR ''s'', CHR ''y'', CHR ''m'', CHR ''b'',\n                    CHR ''o'', CHR ''l'', CHR '' '', CHR ''i'', CHR ''s'',\n                    CHR '' '', CHR 0x22] @\n                   take 1 s @ [CHR 0x22])\n            else Parser_Monad.return n)))\n\ngoal (1 subgoal):\n 1. \\<And>s r x.\n       parse_name s = Inr (x, r) \\<Longrightarrow> length r \\<le> length s", "have id: \"parse_name s = ?exp s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parse_name s =\n    (many_letters \\<bind>\n     (\\<lambda>n.\n         spaces \\<bind>\n         (\\<lambda>_.\n             if n = []\n             then Parser_Monad.error\n                   (''expected letter '' @\n                    letters @\n                    [CHR '' '', CHR ''b'', CHR ''u'', CHR ''t'', CHR '' '',\n                     CHR ''f'', CHR ''i'', CHR ''r'', CHR ''s'', CHR ''t'',\n                     CHR '' '', CHR ''s'', CHR ''y'', CHR ''m'', CHR ''b'',\n                     CHR ''o'', CHR ''l'', CHR '' '', CHR ''i'', CHR ''s'',\n                     CHR '' '', CHR 0x22] @\n                    take 1 s @ [CHR 0x22])\n             else Parser_Monad.return n)))\n     s", "by (simp add: parse_name_def)"], ["proof (state)\nthis:\n  parse_name s =\n  (many_letters \\<bind>\n   (\\<lambda>n.\n       spaces \\<bind>\n       (\\<lambda>_.\n           if n = []\n           then Parser_Monad.error\n                 (''expected letter '' @\n                  letters @\n                  [CHR '' '', CHR ''b'', CHR ''u'', CHR ''t'', CHR '' '',\n                   CHR ''f'', CHR ''i'', CHR ''r'', CHR ''s'', CHR ''t'',\n                   CHR '' '', CHR ''s'', CHR ''y'', CHR ''m'', CHR ''b'',\n                   CHR ''o'', CHR ''l'', CHR '' '', CHR ''i'', CHR ''s'',\n                   CHR '' '', CHR 0x22] @\n                  take 1 s @ [CHR 0x22])\n           else Parser_Monad.return n)))\n   s\n\ngoal (1 subgoal):\n 1. \\<And>s r x.\n       parse_name s = Inr (x, r) \\<Longrightarrow> length r \\<le> length s", "from isp [unfolded is_parser_def, rule_format, OF res [unfolded id]]"], ["proof (chain)\npicking this:\n  length r \\<le> length s", "show \"length r \\<le> length s\""], ["proof (prove)\nusing this:\n  length r \\<le> length s\n\ngoal (1 subgoal):\n 1. length r \\<le> length s", "."], ["proof (state)\nthis:\n  length r \\<le> length s\n\ngoal:\nNo subgoals!", "qed"], ["", "function (sequential) parse_attributes :: \"(string \\<times> string) list parser\"\nwhere\n  \"parse_attributes [] = Error_Monad.return ([], [])\" |\n  \"parse_attributes (c # s) =\n    (if c \\<in> set ''/>'' then Error_Monad.return ([], c # s)\n    else (do {\n      k \\<leftarrow> parse_name;\n      exactly ''='';\n      v \\<leftarrow> parse_attribute_value;\n      atts \\<leftarrow> parse_attributes;\n      return ((k, v) # atts)\n    }) (c # s))\""], ["proof (prove)\ngoal (4 subgoals):\n 1. \\<And>P x.\n       \\<lbrakk>x = [] \\<Longrightarrow> P;\n        \\<And>c s. x = c # s \\<Longrightarrow> P\\<rbrakk>\n       \\<Longrightarrow> P\n 2. [] = [] \\<Longrightarrow> Inr ([], []) = Inr ([], [])\n 3. \\<And>c s.\n       [] = c # s \\<Longrightarrow>\n       Inr ([], []) =\n       (if c \\<in> set ''/>'' then Inr ([], c # s)\n        else (parse_name \\<bind>\n              (\\<lambda>k.\n                  exactly ''='' \\<bind>\n                  (\\<lambda>_.\n                      parse_attribute_value \\<bind>\n                      (\\<lambda>v.\n                          parse_attributes_sumC \\<bind>\n                          (\\<lambda>atts.\n                              Parser_Monad.return ((k, v) # atts))))))\n              (c # s))\n 4. \\<And>c s ca sa.\n       c # s = ca # sa \\<Longrightarrow>\n       (if c \\<in> set ''/>'' then Inr ([], c # s)\n        else (parse_name \\<bind>\n              (\\<lambda>k.\n                  exactly ''='' \\<bind>\n                  (\\<lambda>_.\n                      parse_attribute_value \\<bind>\n                      (\\<lambda>v.\n                          parse_attributes_sumC \\<bind>\n                          (\\<lambda>atts.\n                              Parser_Monad.return ((k, v) # atts))))))\n              (c # s)) =\n       (if ca \\<in> set ''/>'' then Inr ([], ca # sa)\n        else (parse_name \\<bind>\n              (\\<lambda>k.\n                  exactly ''='' \\<bind>\n                  (\\<lambda>_.\n                      parse_attribute_value \\<bind>\n                      (\\<lambda>v.\n                          parse_attributes_sumC \\<bind>\n                          (\\<lambda>atts.\n                              Parser_Monad.return ((k, v) # atts))))))\n              (ca # sa))", "by pat_completeness auto"], ["", "termination parse_attributes"], ["proof (prove)\ngoal (1 subgoal):\n 1. All parse_attributes_dom", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. wf ?R\n 2. \\<And>c s y ts ya tsa yaa tsb.\n       \\<lbrakk>c \\<notin> set ''/>''; parse_name (c # s) = Inr (y, ts);\n        exactly ''='' ts = Inr (ya, tsa);\n        parse_attribute_value tsa = Inr (yaa, tsb)\\<rbrakk>\n       \\<Longrightarrow> (tsb, c # s) \\<in> ?R", "show \"wf (measure length)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. wf (measure length)", "by simp"], ["proof (state)\nthis:\n  wf (measure length)\n\ngoal (1 subgoal):\n 1. \\<And>c s y ts ya tsa yaa tsb.\n       \\<lbrakk>c \\<notin> set ''/>''; parse_name (c # s) = Inr (y, ts);\n        exactly ''='' ts = Inr (ya, tsa);\n        parse_attribute_value tsa = Inr (yaa, tsb)\\<rbrakk>\n       \\<Longrightarrow> (tsb, c # s) \\<in> measure length", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c s y ts ya tsa yaa tsb.\n       \\<lbrakk>c \\<notin> set ''/>''; parse_name (c # s) = Inr (y, ts);\n        exactly ''='' ts = Inr (ya, tsa);\n        parse_attribute_value tsa = Inr (yaa, tsb)\\<rbrakk>\n       \\<Longrightarrow> (tsb, c # s) \\<in> measure length", "fix c s y ts ya tsa yb tsb"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>c s y ts ya tsa yaa tsb.\n       \\<lbrakk>c \\<notin> set ''/>''; parse_name (c # s) = Inr (y, ts);\n        exactly ''='' ts = Inr (ya, tsa);\n        parse_attribute_value tsa = Inr (yaa, tsb)\\<rbrakk>\n       \\<Longrightarrow> (tsb, c # s) \\<in> measure length", "assume pn: \"parse_name (c # s) = Inr (y, ts)\"\n    and oo: \"exactly ''='' ts = Inr (ya, tsa)\"\n    and pav: \"parse_attribute_value tsa = Inr (yb, tsb)\""], ["proof (state)\nthis:\n  parse_name (c # s) = Inr (y, ts)\n  exactly ''='' ts = Inr (ya, tsa)\n  parse_attribute_value tsa = Inr (yb, tsb)\n\ngoal (1 subgoal):\n 1. \\<And>c s y ts ya tsa yaa tsb.\n       \\<lbrakk>c \\<notin> set ''/>''; parse_name (c # s) = Inr (y, ts);\n        exactly ''='' ts = Inr (ya, tsa);\n        parse_attribute_value tsa = Inr (yaa, tsb)\\<rbrakk>\n       \\<Longrightarrow> (tsb, c # s) \\<in> measure length", "have cp: \"is_cparser (exactly ''='')\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_cparser (exactly ''='')", "by auto"], ["proof (state)\nthis:\n  is_cparser (exactly ''='')\n\ngoal (1 subgoal):\n 1. \\<And>c s y ts ya tsa yaa tsb.\n       \\<lbrakk>c \\<notin> set ''/>''; parse_name (c # s) = Inr (y, ts);\n        exactly ''='' ts = Inr (ya, tsa);\n        parse_attribute_value tsa = Inr (yaa, tsb)\\<rbrakk>\n       \\<Longrightarrow> (tsb, c # s) \\<in> measure length", "from cp [unfolded is_cparser_def] oo"], ["proof (chain)\npicking this:\n  \\<forall>s r x.\n     exactly ''='' s = Inr (x, r) \\<longrightarrow> length r < length s\n  exactly ''='' ts = Inr (ya, tsa)", "have 1: \"length ts > length tsa\""], ["proof (prove)\nusing this:\n  \\<forall>s r x.\n     exactly ''='' s = Inr (x, r) \\<longrightarrow> length r < length s\n  exactly ''='' ts = Inr (ya, tsa)\n\ngoal (1 subgoal):\n 1. length tsa < length ts", "by auto"], ["proof (state)\nthis:\n  length tsa < length ts\n\ngoal (1 subgoal):\n 1. \\<And>c s y ts ya tsa yaa tsb.\n       \\<lbrakk>c \\<notin> set ''/>''; parse_name (c # s) = Inr (y, ts);\n        exactly ''='' ts = Inr (ya, tsa);\n        parse_attribute_value tsa = Inr (yaa, tsb)\\<rbrakk>\n       \\<Longrightarrow> (tsb, c # s) \\<in> measure length", "from is_parser_parse_name [unfolded is_parser_def] pn"], ["proof (chain)\npicking this:\n  \\<forall>s r x.\n     parse_name s = Inr (x, r) \\<longrightarrow> length r \\<le> length s\n  parse_name (c # s) = Inr (y, ts)", "have 2: \"length (c # s) \\<ge> length ts\""], ["proof (prove)\nusing this:\n  \\<forall>s r x.\n     parse_name s = Inr (x, r) \\<longrightarrow> length r \\<le> length s\n  parse_name (c # s) = Inr (y, ts)\n\ngoal (1 subgoal):\n 1. length ts \\<le> length (c # s)", "by force"], ["proof (state)\nthis:\n  length ts \\<le> length (c # s)\n\ngoal (1 subgoal):\n 1. \\<And>c s y ts ya tsa yaa tsb.\n       \\<lbrakk>c \\<notin> set ''/>''; parse_name (c # s) = Inr (y, ts);\n        exactly ''='' ts = Inr (ya, tsa);\n        parse_attribute_value tsa = Inr (yaa, tsb)\\<rbrakk>\n       \\<Longrightarrow> (tsb, c # s) \\<in> measure length", "from is_parser_parse_attribute_value [unfolded is_parser_def] pav"], ["proof (chain)\npicking this:\n  \\<forall>s r x.\n     parse_attribute_value s = Inr (x, r) \\<longrightarrow>\n     length r \\<le> length s\n  parse_attribute_value tsa = Inr (yb, tsb)", "have 3: \"length tsa \\<ge> length tsb\""], ["proof (prove)\nusing this:\n  \\<forall>s r x.\n     parse_attribute_value s = Inr (x, r) \\<longrightarrow>\n     length r \\<le> length s\n  parse_attribute_value tsa = Inr (yb, tsb)\n\ngoal (1 subgoal):\n 1. length tsb \\<le> length tsa", "by force"], ["proof (state)\nthis:\n  length tsb \\<le> length tsa\n\ngoal (1 subgoal):\n 1. \\<And>c s y ts ya tsa yaa tsb.\n       \\<lbrakk>c \\<notin> set ''/>''; parse_name (c # s) = Inr (y, ts);\n        exactly ''='' ts = Inr (ya, tsa);\n        parse_attribute_value tsa = Inr (yaa, tsb)\\<rbrakk>\n       \\<Longrightarrow> (tsb, c # s) \\<in> measure length", "from 1 2 3"], ["proof (chain)\npicking this:\n  length tsa < length ts\n  length ts \\<le> length (c # s)\n  length tsb \\<le> length tsa", "show \"(tsb, c # s) \\<in> measure length\""], ["proof (prove)\nusing this:\n  length tsa < length ts\n  length ts \\<le> length (c # s)\n  length tsb \\<le> length tsa\n\ngoal (1 subgoal):\n 1. (tsb, c # s) \\<in> measure length", "by auto"], ["proof (state)\nthis:\n  (tsb, c # s) \\<in> measure length\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma is_parser_parse_attributes [intro]:\n  \"is_parser parse_attributes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_parser parse_attributes", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s r x.\n       parse_attributes s = Inr (x, r) \\<Longrightarrow>\n       length r \\<le> length s", "fix s r x"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>s r x.\n       parse_attributes s = Inr (x, r) \\<Longrightarrow>\n       length r \\<le> length s", "assume \"parse_attributes s = Inr (x, r)\""], ["proof (state)\nthis:\n  parse_attributes s = Inr (x, r)\n\ngoal (1 subgoal):\n 1. \\<And>s r x.\n       parse_attributes s = Inr (x, r) \\<Longrightarrow>\n       length r \\<le> length s", "then"], ["proof (chain)\npicking this:\n  parse_attributes s = Inr (x, r)", "show \"length r \\<le> length s\""], ["proof (prove)\nusing this:\n  parse_attributes s = Inr (x, r)\n\ngoal (1 subgoal):\n 1. length r \\<le> length s", "proof (induct arbitrary: x rule: parse_attributes.induct)"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>x.\n       parse_attributes [] = Inr (x, r) \\<Longrightarrow>\n       length r \\<le> length []\n 2. \\<And>c s x.\n       \\<lbrakk>\\<And>y ts ya tsa yaa tsb x.\n                   \\<lbrakk>c \\<notin> set ''/>'';\n                    parse_name (c # s) = Inr (y, ts);\n                    exactly ''='' ts = Inr (ya, tsa);\n                    parse_attribute_value tsa = Inr (yaa, tsb);\n                    parse_attributes tsb = Inr (x, r)\\<rbrakk>\n                   \\<Longrightarrow> length r \\<le> length tsb;\n        parse_attributes (c # s) = Inr (x, r)\\<rbrakk>\n       \\<Longrightarrow> length r \\<le> length (c # s)", "case (2 c s)"], ["proof (state)\nthis:\n  \\<lbrakk>c \\<notin> set ''/>''; parse_name (c # s) = Inr (?y, ?ts);\n   exactly ''='' ?ts = Inr (?ya, ?tsa);\n   parse_attribute_value ?tsa = Inr (?yaa, ?tsb);\n   parse_attributes ?tsb = Inr (?x, r)\\<rbrakk>\n  \\<Longrightarrow> length r \\<le> length ?tsb\n  parse_attributes (c # s) = Inr (x, r)\n\ngoal (2 subgoals):\n 1. \\<And>x.\n       parse_attributes [] = Inr (x, r) \\<Longrightarrow>\n       length r \\<le> length []\n 2. \\<And>c s x.\n       \\<lbrakk>\\<And>y ts ya tsa yaa tsb x.\n                   \\<lbrakk>c \\<notin> set ''/>'';\n                    parse_name (c # s) = Inr (y, ts);\n                    exactly ''='' ts = Inr (ya, tsa);\n                    parse_attribute_value tsa = Inr (yaa, tsb);\n                    parse_attributes tsb = Inr (x, r)\\<rbrakk>\n                   \\<Longrightarrow> length r \\<le> length tsb;\n        parse_attributes (c # s) = Inr (x, r)\\<rbrakk>\n       \\<Longrightarrow> length r \\<le> length (c # s)", "show ?case"], ["proof (prove)\ngoal (1 subgoal):\n 1. length r \\<le> length (c # s)", "proof (cases \"c \\<in> set ''/>''\")"], ["proof (state)\ngoal (2 subgoals):\n 1. c \\<in> set ''/>'' \\<Longrightarrow> length r \\<le> length (c # s)\n 2. c \\<notin> set ''/>'' \\<Longrightarrow> length r \\<le> length (c # s)", "case True"], ["proof (state)\nthis:\n  c \\<in> set ''/>''\n\ngoal (2 subgoals):\n 1. c \\<in> set ''/>'' \\<Longrightarrow> length r \\<le> length (c # s)\n 2. c \\<notin> set ''/>'' \\<Longrightarrow> length r \\<le> length (c # s)", "with 2(2)"], ["proof (chain)\npicking this:\n  parse_attributes (c # s) = Inr (x, r)\n  c \\<in> set ''/>''", "show ?thesis"], ["proof (prove)\nusing this:\n  parse_attributes (c # s) = Inr (x, r)\n  c \\<in> set ''/>''\n\ngoal (1 subgoal):\n 1. length r \\<le> length (c # s)", "by simp"], ["proof (state)\nthis:\n  length r \\<le> length (c # s)\n\ngoal (1 subgoal):\n 1. c \\<notin> set ''/>'' \\<Longrightarrow> length r \\<le> length (c # s)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. c \\<notin> set ''/>'' \\<Longrightarrow> length r \\<le> length (c # s)", "case False"], ["proof (state)\nthis:\n  c \\<notin> set ''/>''\n\ngoal (1 subgoal):\n 1. c \\<notin> set ''/>'' \\<Longrightarrow> length r \\<le> length (c # s)", "from False 2(2)"], ["proof (chain)\npicking this:\n  c \\<notin> set ''/>''\n  parse_attributes (c # s) = Inr (x, r)", "obtain y1 s1\n        where pn: \"parse_name (c # s) = Inr (y1, s1)\""], ["proof (prove)\nusing this:\n  c \\<notin> set ''/>''\n  parse_attributes (c # s) = Inr (x, r)\n\ngoal (1 subgoal):\n 1. (\\<And>y1 s1.\n        parse_name (c # s) = Inr (y1, s1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"parse_name (c # s)\") (auto simp: bind_def)"], ["proof (state)\nthis:\n  parse_name (c # s) = Inr (y1, s1)\n\ngoal (1 subgoal):\n 1. c \\<notin> set ''/>'' \\<Longrightarrow> length r \\<le> length (c # s)", "from False 2(2) pn"], ["proof (chain)\npicking this:\n  c \\<notin> set ''/>''\n  parse_attributes (c # s) = Inr (x, r)\n  parse_name (c # s) = Inr (y1, s1)", "obtain y2 s2\n        where oo: \"exactly ''='' s1 = Inr (y2, s2)\""], ["proof (prove)\nusing this:\n  c \\<notin> set ''/>''\n  parse_attributes (c # s) = Inr (x, r)\n  parse_name (c # s) = Inr (y1, s1)\n\ngoal (1 subgoal):\n 1. (\\<And>y2 s2.\n        exactly ''='' s1 = Inr (y2, s2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"exactly ''='' s1\") (auto simp: bind_def)"], ["proof (state)\nthis:\n  exactly ''='' s1 = Inr (y2, s2)\n\ngoal (1 subgoal):\n 1. c \\<notin> set ''/>'' \\<Longrightarrow> length r \\<le> length (c # s)", "from False 2(2) pn oo"], ["proof (chain)\npicking this:\n  c \\<notin> set ''/>''\n  parse_attributes (c # s) = Inr (x, r)\n  parse_name (c # s) = Inr (y1, s1)\n  exactly ''='' s1 = Inr (y2, s2)", "obtain y3 s3\n        where pav: \"parse_attribute_value s2 = Inr (y3, s3)\""], ["proof (prove)\nusing this:\n  c \\<notin> set ''/>''\n  parse_attributes (c # s) = Inr (x, r)\n  parse_name (c # s) = Inr (y1, s1)\n  exactly ''='' s1 = Inr (y2, s2)\n\ngoal (1 subgoal):\n 1. (\\<And>y3 s3.\n        parse_attribute_value s2 = Inr (y3, s3) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"parse_attribute_value s2\") (auto simp: bind_def)"], ["proof (state)\nthis:\n  parse_attribute_value s2 = Inr (y3, s3)\n\ngoal (1 subgoal):\n 1. c \\<notin> set ''/>'' \\<Longrightarrow> length r \\<le> length (c # s)", "from False 2(2) pn oo pav"], ["proof (chain)\npicking this:\n  c \\<notin> set ''/>''\n  parse_attributes (c # s) = Inr (x, r)\n  parse_name (c # s) = Inr (y1, s1)\n  exactly ''='' s1 = Inr (y2, s2)\n  parse_attribute_value s2 = Inr (y3, s3)", "obtain y4\n        where patts: \"parse_attributes s3 = Inr (y4, r)\""], ["proof (prove)\nusing this:\n  c \\<notin> set ''/>''\n  parse_attributes (c # s) = Inr (x, r)\n  parse_name (c # s) = Inr (y1, s1)\n  exactly ''='' s1 = Inr (y2, s2)\n  parse_attribute_value s2 = Inr (y3, s3)\n\ngoal (1 subgoal):\n 1. (\\<And>y4.\n        parse_attributes s3 = Inr (y4, r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"parse_attributes s3\") (auto simp: return_def bind_def)"], ["proof (state)\nthis:\n  parse_attributes s3 = Inr (y4, r)\n\ngoal (1 subgoal):\n 1. c \\<notin> set ''/>'' \\<Longrightarrow> length r \\<le> length (c # s)", "have \"length r \\<le> length s3\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length r \\<le> length s3", "using 2(1)[OF False pn oo pav patts]"], ["proof (prove)\nusing this:\n  length r \\<le> length s3\n\ngoal (1 subgoal):\n 1. length r \\<le> length s3", "."], ["proof (state)\nthis:\n  length r \\<le> length s3\n\ngoal (1 subgoal):\n 1. c \\<notin> set ''/>'' \\<Longrightarrow> length r \\<le> length (c # s)", "also"], ["proof (state)\nthis:\n  length r \\<le> length s3\n\ngoal (1 subgoal):\n 1. c \\<notin> set ''/>'' \\<Longrightarrow> length r \\<le> length (c # s)", "have \"\\<dots> \\<le> length s2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length s3 \\<le> length s2", "using is_parser_parse_attribute_value [unfolded is_parser_def] pav"], ["proof (prove)\nusing this:\n  \\<forall>s r x.\n     parse_attribute_value s = Inr (x, r) \\<longrightarrow>\n     length r \\<le> length s\n  parse_attribute_value s2 = Inr (y3, s3)\n\ngoal (1 subgoal):\n 1. length s3 \\<le> length s2", "by auto"], ["proof (state)\nthis:\n  length s3 \\<le> length s2\n\ngoal (1 subgoal):\n 1. c \\<notin> set ''/>'' \\<Longrightarrow> length r \\<le> length (c # s)", "also"], ["proof (state)\nthis:\n  length s3 \\<le> length s2\n\ngoal (1 subgoal):\n 1. c \\<notin> set ''/>'' \\<Longrightarrow> length r \\<le> length (c # s)", "have \"\\<dots> \\<le> length s1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length s2 \\<le> length s1", "using is_parser_exactly [unfolded is_parser_def] oo"], ["proof (prove)\nusing this:\n  \\<forall>s r x.\n     exactly ?xs s = Inr (x, r) \\<longrightarrow> length r \\<le> length s\n  exactly ''='' s1 = Inr (y2, s2)\n\ngoal (1 subgoal):\n 1. length s2 \\<le> length s1", "by auto"], ["proof (state)\nthis:\n  length s2 \\<le> length s1\n\ngoal (1 subgoal):\n 1. c \\<notin> set ''/>'' \\<Longrightarrow> length r \\<le> length (c # s)", "also"], ["proof (state)\nthis:\n  length s2 \\<le> length s1\n\ngoal (1 subgoal):\n 1. c \\<notin> set ''/>'' \\<Longrightarrow> length r \\<le> length (c # s)", "have \"\\<dots> \\<le> length (c # s)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length s1 \\<le> length (c # s)", "using is_parser_parse_name [unfolded is_parser_def] pn"], ["proof (prove)\nusing this:\n  \\<forall>s r x.\n     parse_name s = Inr (x, r) \\<longrightarrow> length r \\<le> length s\n  parse_name (c # s) = Inr (y1, s1)\n\ngoal (1 subgoal):\n 1. length s1 \\<le> length (c # s)", "by force"], ["proof (state)\nthis:\n  length s1 \\<le> length (c # s)\n\ngoal (1 subgoal):\n 1. c \\<notin> set ''/>'' \\<Longrightarrow> length r \\<le> length (c # s)", "finally"], ["proof (chain)\npicking this:\n  length r \\<le> length (c # s)", "show \"length r \\<le> length (c # s)\""], ["proof (prove)\nusing this:\n  length r \\<le> length (c # s)\n\ngoal (1 subgoal):\n 1. length r \\<le> length (c # s)", "by auto"], ["proof (state)\nthis:\n  length r \\<le> length (c # s)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length r \\<le> length (c # s)\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       parse_attributes [] = Inr (x, r) \\<Longrightarrow>\n       length r \\<le> length []", "qed simp"], ["proof (state)\nthis:\n  length r \\<le> length s\n\ngoal:\nNo subgoals!", "qed"], ["", "context notes [[function_internals]]\nbegin"], ["", "function parse_nodes :: \"xml list parser\"\nwhere\n  \"parse_nodes ts = \n    (if ts = [] \\<or> take 2 ts = ''</'' then return [] ts\n    else if hd ts \\<noteq> CHR ''<'' then (do {\n      t \\<leftarrow> parse_text;\n      ns \\<leftarrow> parse_nodes;\n      return (XML_text (the t) # ns)\n    }) ts\n    else (do {\n      exactly ''<'';\n      n \\<leftarrow> parse_name;\n      atts \\<leftarrow> parse_attributes;\n      e \\<leftarrow> oneof [''/>'', ''>''];\n      (\\<lambda> ts'.\n        if e = ''/>'' then (do {\n          cs \\<leftarrow> parse_nodes;\n          return (XML n atts [] # cs)\n        }) ts' else (do {\n          cs \\<leftarrow> parse_nodes;\n          exactly ''</'';\n          exactly n;\n          exactly ''>'';\n          ns \\<leftarrow> parse_nodes;\n          return (XML n atts cs # ns)\n        }) ts')\n    }) ts)\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x. (\\<And>ts. x = ts \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>ts tsa.\n       ts = tsa \\<Longrightarrow>\n       (if ts = [] \\<or> take 2 ts = ''</'' then Parser_Monad.return [] ts\n        else if hd ts \\<noteq> CHR ''<''\n             then (parse_text \\<bind>\n                   (\\<lambda>t.\n                       parse_nodes_sumC \\<bind>\n                       (\\<lambda>ns.\n                           Parser_Monad.return (XML_text (the t) # ns))))\n                   ts\n             else (exactly ''<'' \\<bind>\n                   (\\<lambda>_.\n                       parse_name \\<bind>\n                       (\\<lambda>n.\n                           parse_attributes \\<bind>\n                           (\\<lambda>atts.\n                               oneof [''/>'', ''>''] \\<bind>\n                               (\\<lambda>e ts'.\n                                   if e = ''/>''\n                                   then (parse_nodes_sumC \\<bind>\n   (\\<lambda>cs. Parser_Monad.return (XML n atts [] # cs)))\n   ts'\n                                   else (parse_nodes_sumC \\<bind>\n   (\\<lambda>cs.\n       exactly ''</'' \\<bind>\n       (\\<lambda>_.\n           exactly n \\<bind>\n           (\\<lambda>_.\n               exactly ''>'' \\<bind>\n               (\\<lambda>_.\n                   parse_nodes_sumC \\<bind>\n                   (\\<lambda>ns.\n                       Parser_Monad.return (XML n atts cs # ns)))))))\n   ts')))))\n                   ts) =\n       (if tsa = [] \\<or> take 2 tsa = ''</''\n        then Parser_Monad.return [] tsa\n        else if hd tsa \\<noteq> CHR ''<''\n             then (parse_text \\<bind>\n                   (\\<lambda>t.\n                       parse_nodes_sumC \\<bind>\n                       (\\<lambda>ns.\n                           Parser_Monad.return (XML_text (the t) # ns))))\n                   tsa\n             else (exactly ''<'' \\<bind>\n                   (\\<lambda>_.\n                       parse_name \\<bind>\n                       (\\<lambda>n.\n                           parse_attributes \\<bind>\n                           (\\<lambda>atts.\n                               oneof [''/>'', ''>''] \\<bind>\n                               (\\<lambda>e ts'.\n                                   if e = ''/>''\n                                   then (parse_nodes_sumC \\<bind>\n   (\\<lambda>cs. Parser_Monad.return (XML n atts [] # cs)))\n   ts'\n                                   else (parse_nodes_sumC \\<bind>\n   (\\<lambda>cs.\n       exactly ''</'' \\<bind>\n       (\\<lambda>_.\n           exactly n \\<bind>\n           (\\<lambda>_.\n               exactly ''>'' \\<bind>\n               (\\<lambda>_.\n                   parse_nodes_sumC \\<bind>\n                   (\\<lambda>ns.\n                       Parser_Monad.return (XML n atts cs # ns)))))))\n   ts')))))\n                   tsa)", "by pat_completeness auto"], ["", "end"], ["", "lemma parse_nodes_help:\n  \"parse_nodes_dom s \\<and> (\\<forall> x r. parse_nodes s = Inr (x, r) \\<longrightarrow> length r \\<le> length s)\" (is \"?prop s\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. parse_nodes_dom s \\<and>\n    (\\<forall>x r.\n        parse_nodes s = Inr (x, r) \\<longrightarrow>\n        length r \\<le> length s)", "proof (induct rule: wf_induct [where P = ?prop and r = \"measure length\"])"], ["proof (state)\ngoal (2 subgoals):\n 1. wf (measure length)\n 2. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> measure length \\<longrightarrow>\n          parse_nodes_dom y \\<and>\n          (\\<forall>x r.\n              parse_nodes y = Inr (x, r) \\<longrightarrow>\n              length r \\<le> length y) \\<Longrightarrow>\n       parse_nodes_dom x \\<and>\n       (\\<forall>xa r.\n           parse_nodes x = Inr (xa, r) \\<longrightarrow>\n           length r \\<le> length x)", "fix s"], ["proof (state)\ngoal (2 subgoals):\n 1. wf (measure length)\n 2. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> measure length \\<longrightarrow>\n          parse_nodes_dom y \\<and>\n          (\\<forall>x r.\n              parse_nodes y = Inr (x, r) \\<longrightarrow>\n              length r \\<le> length y) \\<Longrightarrow>\n       parse_nodes_dom x \\<and>\n       (\\<forall>xa r.\n           parse_nodes x = Inr (xa, r) \\<longrightarrow>\n           length r \\<le> length x)", "assume \"\\<forall> t. (t, s) \\<in> measure length \\<longrightarrow> ?prop t\""], ["proof (state)\nthis:\n  \\<forall>t.\n     (t, s) \\<in> measure length \\<longrightarrow>\n     parse_nodes_dom t \\<and>\n     (\\<forall>x r.\n         parse_nodes t = Inr (x, r) \\<longrightarrow>\n         length r \\<le> length t)\n\ngoal (2 subgoals):\n 1. wf (measure length)\n 2. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> measure length \\<longrightarrow>\n          parse_nodes_dom y \\<and>\n          (\\<forall>x r.\n              parse_nodes y = Inr (x, r) \\<longrightarrow>\n              length r \\<le> length y) \\<Longrightarrow>\n       parse_nodes_dom x \\<and>\n       (\\<forall>xa r.\n           parse_nodes x = Inr (xa, r) \\<longrightarrow>\n           length r \\<le> length x)", "then"], ["proof (chain)\npicking this:\n  \\<forall>t.\n     (t, s) \\<in> measure length \\<longrightarrow>\n     parse_nodes_dom t \\<and>\n     (\\<forall>x r.\n         parse_nodes t = Inr (x, r) \\<longrightarrow>\n         length r \\<le> length t)", "have ind1: \"\\<And> t. length t < length s \\<Longrightarrow> parse_nodes_dom t\"  \n    and ind2: \"\\<And> t x r. length t < length s \\<Longrightarrow> parse_nodes t = Inr (x,r) \\<Longrightarrow> length r \\<le> length t\""], ["proof (prove)\nusing this:\n  \\<forall>t.\n     (t, s) \\<in> measure length \\<longrightarrow>\n     parse_nodes_dom t \\<and>\n     (\\<forall>x r.\n         parse_nodes t = Inr (x, r) \\<longrightarrow>\n         length r \\<le> length t)\n\ngoal (1 subgoal):\n 1. (\\<And>t. length t < length s \\<Longrightarrow> parse_nodes_dom t) &&&\n    (\\<And>t x r.\n        \\<lbrakk>length t < length s; parse_nodes t = Inr (x, r)\\<rbrakk>\n        \\<Longrightarrow> length r \\<le> length t)", "by auto"], ["proof (state)\nthis:\n  length ?t < length s \\<Longrightarrow> parse_nodes_dom ?t\n  \\<lbrakk>length ?t < length s; parse_nodes ?t = Inr (?x, ?r)\\<rbrakk>\n  \\<Longrightarrow> length ?r \\<le> length ?t\n\ngoal (2 subgoals):\n 1. wf (measure length)\n 2. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> measure length \\<longrightarrow>\n          parse_nodes_dom y \\<and>\n          (\\<forall>x r.\n              parse_nodes y = Inr (x, r) \\<longrightarrow>\n              length r \\<le> length y) \\<Longrightarrow>\n       parse_nodes_dom x \\<and>\n       (\\<forall>xa r.\n           parse_nodes x = Inr (xa, r) \\<longrightarrow>\n           length r \\<le> length x)", "let ?check = \"\\<lambda> s. s = [] \\<or> take 2 s = ''</''\""], ["proof (state)\ngoal (2 subgoals):\n 1. wf (measure length)\n 2. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> measure length \\<longrightarrow>\n          parse_nodes_dom y \\<and>\n          (\\<forall>x r.\n              parse_nodes y = Inr (x, r) \\<longrightarrow>\n              length r \\<le> length y) \\<Longrightarrow>\n       parse_nodes_dom x \\<and>\n       (\\<forall>xa r.\n           parse_nodes x = Inr (xa, r) \\<longrightarrow>\n           length r \\<le> length x)", "let ?check2 = \"hd s \\<noteq> CHR ''<''\""], ["proof (state)\ngoal (2 subgoals):\n 1. wf (measure length)\n 2. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> measure length \\<longrightarrow>\n          parse_nodes_dom y \\<and>\n          (\\<forall>x r.\n              parse_nodes y = Inr (x, r) \\<longrightarrow>\n              length r \\<le> length y) \\<Longrightarrow>\n       parse_nodes_dom x \\<and>\n       (\\<forall>xa r.\n           parse_nodes x = Inr (xa, r) \\<longrightarrow>\n           length r \\<le> length x)", "have dom: \"parse_nodes_dom s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parse_nodes_dom s", "proof"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. parse_nodes_rel y s \\<Longrightarrow> parse_nodes_dom y", "fix y"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>y. parse_nodes_rel y s \\<Longrightarrow> parse_nodes_dom y", "assume \"parse_nodes_rel y s\""], ["proof (state)\nthis:\n  parse_nodes_rel y s\n\ngoal (1 subgoal):\n 1. \\<And>y. parse_nodes_rel y s \\<Longrightarrow> parse_nodes_dom y", "then"], ["proof (chain)\npicking this:\n  parse_nodes_rel y s", "show \"parse_nodes_dom y\""], ["proof (prove)\nusing this:\n  parse_nodes_rel y s\n\ngoal (1 subgoal):\n 1. parse_nodes_dom y", "proof"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>ts ya tsa.\n       \\<lbrakk>y = tsa; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        hd ts \\<noteq> CHR ''<''; parse_text ts = Inr (ya, tsa)\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y\n 2. \\<And>ts ya tsa yaa tsb yb tsc yc tsd.\n       \\<lbrakk>y = tsd; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd); yc = ''/>''\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y\n 3. \\<And>ts ya tsa yaa tsb yb tsc yc tsd.\n       \\<lbrakk>y = tsd; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd);\n        yc \\<noteq> ''/>''\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y\n 4. \\<And>ts ya tsa yaa tsb yb tsc yc tsd yd tse ye tsf yf tsg yg tsh.\n       \\<lbrakk>y = tsh; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd); yc \\<noteq> ''/>'';\n        parse_nodes_sumC tsd = Inr (yd, tse);\n        exactly ''</'' tse = Inr (ye, tsf); exactly yaa tsf = Inr (yf, tsg);\n        exactly ''>'' tsg = Inr (yg, tsh)\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y", "fix ts ya tsa"], ["proof (state)\ngoal (4 subgoals):\n 1. \\<And>ts ya tsa.\n       \\<lbrakk>y = tsa; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        hd ts \\<noteq> CHR ''<''; parse_text ts = Inr (ya, tsa)\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y\n 2. \\<And>ts ya tsa yaa tsb yb tsc yc tsd.\n       \\<lbrakk>y = tsd; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd); yc = ''/>''\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y\n 3. \\<And>ts ya tsa yaa tsb yb tsc yc tsd.\n       \\<lbrakk>y = tsd; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd);\n        yc \\<noteq> ''/>''\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y\n 4. \\<And>ts ya tsa yaa tsb yb tsc yc tsd yd tse ye tsf yf tsg yg tsh.\n       \\<lbrakk>y = tsh; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd); yc \\<noteq> ''/>'';\n        parse_nodes_sumC tsd = Inr (yd, tse);\n        exactly ''</'' tse = Inr (ye, tsf); exactly yaa tsf = Inr (yf, tsg);\n        exactly ''>'' tsg = Inr (yg, tsh)\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y", "assume *: \"y = tsa\"  \"s = ts\"  \"\\<not> (ts = [] \\<or> take 2 ts = ''</'')\"\n         \"hd ts \\<noteq> CHR ''<''\" and parse: \"parse_text ts = Inr (ya, tsa)\""], ["proof (state)\nthis:\n  y = tsa\n  s = ts\n  \\<not> (ts = [] \\<or> take 2 ts = ''</'')\n  hd ts \\<noteq> CHR ''<''\n  parse_text ts = Inr (ya, tsa)\n\ngoal (4 subgoals):\n 1. \\<And>ts ya tsa.\n       \\<lbrakk>y = tsa; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        hd ts \\<noteq> CHR ''<''; parse_text ts = Inr (ya, tsa)\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y\n 2. \\<And>ts ya tsa yaa tsb yb tsc yc tsd.\n       \\<lbrakk>y = tsd; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd); yc = ''/>''\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y\n 3. \\<And>ts ya tsa yaa tsb yb tsc yc tsd.\n       \\<lbrakk>y = tsd; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd);\n        yc \\<noteq> ''/>''\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y\n 4. \\<And>ts ya tsa yaa tsb yb tsc yc tsd yd tse ye tsf yf tsg yg tsh.\n       \\<lbrakk>y = tsh; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd); yc \\<noteq> ''/>'';\n        parse_nodes_sumC tsd = Inr (yd, tse);\n        exactly ''</'' tse = Inr (ye, tsf); exactly yaa tsf = Inr (yf, tsg);\n        exactly ''>'' tsg = Inr (yg, tsh)\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y", "from parse_text_consumes[OF _ _ parse] *(3-4)"], ["proof (chain)\npicking this:\n  \\<lbrakk>ts \\<noteq> []; hd ts \\<noteq> CHR ''<''\\<rbrakk>\n  \\<Longrightarrow> length tsa < length ts\n  \\<not> (ts = [] \\<or> take 2 ts = ''</'')\n  hd ts \\<noteq> CHR ''<''", "have \"length tsa < length ts\""], ["proof (prove)\nusing this:\n  \\<lbrakk>ts \\<noteq> []; hd ts \\<noteq> CHR ''<''\\<rbrakk>\n  \\<Longrightarrow> length tsa < length ts\n  \\<not> (ts = [] \\<or> take 2 ts = ''</'')\n  hd ts \\<noteq> CHR ''<''\n\ngoal (1 subgoal):\n 1. length tsa < length ts", "by auto"], ["proof (state)\nthis:\n  length tsa < length ts\n\ngoal (4 subgoals):\n 1. \\<And>ts ya tsa.\n       \\<lbrakk>y = tsa; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        hd ts \\<noteq> CHR ''<''; parse_text ts = Inr (ya, tsa)\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y\n 2. \\<And>ts ya tsa yaa tsb yb tsc yc tsd.\n       \\<lbrakk>y = tsd; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd); yc = ''/>''\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y\n 3. \\<And>ts ya tsa yaa tsb yb tsc yc tsd.\n       \\<lbrakk>y = tsd; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd);\n        yc \\<noteq> ''/>''\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y\n 4. \\<And>ts ya tsa yaa tsb yb tsc yc tsd yd tse ye tsf yf tsg yg tsh.\n       \\<lbrakk>y = tsh; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd); yc \\<noteq> ''/>'';\n        parse_nodes_sumC tsd = Inr (yd, tse);\n        exactly ''</'' tse = Inr (ye, tsf); exactly yaa tsf = Inr (yf, tsg);\n        exactly ''>'' tsg = Inr (yg, tsh)\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y", "with *"], ["proof (chain)\npicking this:\n  y = tsa\n  s = ts\n  \\<not> (ts = [] \\<or> take 2 ts = ''</'')\n  hd ts \\<noteq> CHR ''<''\n  length tsa < length ts", "have len: \"length s > length y\""], ["proof (prove)\nusing this:\n  y = tsa\n  s = ts\n  \\<not> (ts = [] \\<or> take 2 ts = ''</'')\n  hd ts \\<noteq> CHR ''<''\n  length tsa < length ts\n\ngoal (1 subgoal):\n 1. length y < length s", "by simp"], ["proof (state)\nthis:\n  length y < length s\n\ngoal (4 subgoals):\n 1. \\<And>ts ya tsa.\n       \\<lbrakk>y = tsa; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        hd ts \\<noteq> CHR ''<''; parse_text ts = Inr (ya, tsa)\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y\n 2. \\<And>ts ya tsa yaa tsb yb tsc yc tsd.\n       \\<lbrakk>y = tsd; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd); yc = ''/>''\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y\n 3. \\<And>ts ya tsa yaa tsb yb tsc yc tsd.\n       \\<lbrakk>y = tsd; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd);\n        yc \\<noteq> ''/>''\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y\n 4. \\<And>ts ya tsa yaa tsb yb tsc yc tsd yd tse ye tsf yf tsg yg tsh.\n       \\<lbrakk>y = tsh; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd); yc \\<noteq> ''/>'';\n        parse_nodes_sumC tsd = Inr (yd, tse);\n        exactly ''</'' tse = Inr (ye, tsf); exactly yaa tsf = Inr (yf, tsg);\n        exactly ''>'' tsg = Inr (yg, tsh)\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y", "from ind1[OF this]"], ["proof (chain)\npicking this:\n  parse_nodes_dom y", "show \"parse_nodes_dom y\""], ["proof (prove)\nusing this:\n  parse_nodes_dom y\n\ngoal (1 subgoal):\n 1. parse_nodes_dom y", "."], ["proof (state)\nthis:\n  parse_nodes_dom y\n\ngoal (3 subgoals):\n 1. \\<And>ts ya tsa yaa tsb yb tsc yc tsd.\n       \\<lbrakk>y = tsd; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd); yc = ''/>''\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y\n 2. \\<And>ts ya tsa yaa tsb yb tsc yc tsd.\n       \\<lbrakk>y = tsd; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd);\n        yc \\<noteq> ''/>''\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y\n 3. \\<And>ts ya tsa yaa tsb yb tsc yc tsd yd tse ye tsf yf tsg yg tsh.\n       \\<lbrakk>y = tsh; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd); yc \\<noteq> ''/>'';\n        parse_nodes_sumC tsd = Inr (yd, tse);\n        exactly ''</'' tse = Inr (ye, tsf); exactly yaa tsf = Inr (yf, tsg);\n        exactly ''>'' tsg = Inr (yg, tsh)\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y", "next"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ts ya tsa yaa tsb yb tsc yc tsd.\n       \\<lbrakk>y = tsd; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd); yc = ''/>''\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y\n 2. \\<And>ts ya tsa yaa tsb yb tsc yc tsd.\n       \\<lbrakk>y = tsd; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd);\n        yc \\<noteq> ''/>''\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y\n 3. \\<And>ts ya tsa yaa tsb yb tsc yc tsd yd tse ye tsf yf tsg yg tsh.\n       \\<lbrakk>y = tsh; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd); yc \\<noteq> ''/>'';\n        parse_nodes_sumC tsd = Inr (yd, tse);\n        exactly ''</'' tse = Inr (ye, tsf); exactly yaa tsf = Inr (yf, tsg);\n        exactly ''>'' tsg = Inr (yg, tsh)\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y", "fix ts ya tsa yaa tsb yb tsc yc tsd"], ["proof (state)\ngoal (3 subgoals):\n 1. \\<And>ts ya tsa yaa tsb yb tsc yc tsd.\n       \\<lbrakk>y = tsd; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd); yc = ''/>''\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y\n 2. \\<And>ts ya tsa yaa tsb yb tsc yc tsd.\n       \\<lbrakk>y = tsd; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd);\n        yc \\<noteq> ''/>''\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y\n 3. \\<And>ts ya tsa yaa tsb yb tsc yc tsd yd tse ye tsf yf tsg yg tsh.\n       \\<lbrakk>y = tsh; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd); yc \\<noteq> ''/>'';\n        parse_nodes_sumC tsd = Inr (yd, tse);\n        exactly ''</'' tse = Inr (ye, tsf); exactly yaa tsf = Inr (yf, tsg);\n        exactly ''>'' tsg = Inr (yg, tsh)\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y", "assume \"y = tsd\" and \"s = ts\" and \"\\<not> ?check ts\"\n        and \"exactly ''<'' ts = Inr (ya, tsa)\"\n        and \"parse_name tsa = Inr (yaa, tsb)\"\n        and \"parse_attributes tsb = Inr (yb, tsc)\"\n        and \"oneof [''/>'', ''>''] tsc = Inr (yc, tsd)\"\n        and \"yc = ''/>''\""], ["proof (state)\nthis:\n  y = tsd\n  s = ts\n  \\<not> (ts = [] \\<or> take 2 ts = ''</'')\n  exactly ''<'' ts = Inr (ya, tsa)\n  parse_name tsa = Inr (yaa, tsb)\n  parse_attributes tsb = Inr (yb, tsc)\n  oneof [''/>'', ''>''] tsc = Inr (yc, tsd)\n  yc = ''/>''\n\ngoal (3 subgoals):\n 1. \\<And>ts ya tsa yaa tsb yb tsc yc tsd.\n       \\<lbrakk>y = tsd; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd); yc = ''/>''\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y\n 2. \\<And>ts ya tsa yaa tsb yb tsc yc tsd.\n       \\<lbrakk>y = tsd; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd);\n        yc \\<noteq> ''/>''\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y\n 3. \\<And>ts ya tsa yaa tsb yb tsc yc tsd yd tse ye tsf yf tsg yg tsh.\n       \\<lbrakk>y = tsh; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd); yc \\<noteq> ''/>'';\n        parse_nodes_sumC tsd = Inr (yd, tse);\n        exactly ''</'' tse = Inr (ye, tsf); exactly yaa tsf = Inr (yf, tsg);\n        exactly ''>'' tsg = Inr (yg, tsh)\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y", "then"], ["proof (chain)\npicking this:\n  y = tsd\n  s = ts\n  \\<not> (ts = [] \\<or> take 2 ts = ''</'')\n  exactly ''<'' ts = Inr (ya, tsa)\n  parse_name tsa = Inr (yaa, tsb)\n  parse_attributes tsb = Inr (yb, tsc)\n  oneof [''/>'', ''>''] tsc = Inr (yc, tsd)\n  yc = ''/>''", "have len: \"length s > length y\""], ["proof (prove)\nusing this:\n  y = tsd\n  s = ts\n  \\<not> (ts = [] \\<or> take 2 ts = ''</'')\n  exactly ''<'' ts = Inr (ya, tsa)\n  parse_name tsa = Inr (yaa, tsb)\n  parse_attributes tsb = Inr (yb, tsc)\n  oneof [''/>'', ''>''] tsc = Inr (yc, tsd)\n  yc = ''/>''\n\ngoal (1 subgoal):\n 1. length y < length s", "using is_cparser_exactly [of \"''<''\"]\n        and is_parser_oneof [of \"[''/>'', ''>'']\"]\n        and is_parser_parse_attributes\n        and is_parser_parse_name"], ["proof (prove)\nusing this:\n  y = tsd\n  s = ts\n  \\<not> (ts = [] \\<or> take 2 ts = ''</'')\n  exactly ''<'' ts = Inr (ya, tsa)\n  parse_name tsa = Inr (yaa, tsb)\n  parse_attributes tsb = Inr (yb, tsc)\n  oneof [''/>'', ''>''] tsc = Inr (yc, tsd)\n  yc = ''/>''\n  1 \\<le> length ''<'' \\<Longrightarrow> is_cparser (exactly ''<'')\n  is_parser (oneof [''/>'', ''>''])\n  is_parser parse_attributes\n  is_parser parse_name\n\ngoal (1 subgoal):\n 1. length y < length s", "by (auto dest!: is_parser_length is_cparser_length)"], ["proof (state)\nthis:\n  length y < length s\n\ngoal (3 subgoals):\n 1. \\<And>ts ya tsa yaa tsb yb tsc yc tsd.\n       \\<lbrakk>y = tsd; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd); yc = ''/>''\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y\n 2. \\<And>ts ya tsa yaa tsb yb tsc yc tsd.\n       \\<lbrakk>y = tsd; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd);\n        yc \\<noteq> ''/>''\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y\n 3. \\<And>ts ya tsa yaa tsb yb tsc yc tsd yd tse ye tsf yf tsg yg tsh.\n       \\<lbrakk>y = tsh; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd); yc \\<noteq> ''/>'';\n        parse_nodes_sumC tsd = Inr (yd, tse);\n        exactly ''</'' tse = Inr (ye, tsf); exactly yaa tsf = Inr (yf, tsg);\n        exactly ''>'' tsg = Inr (yg, tsh)\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y", "with ind1[OF len]"], ["proof (chain)\npicking this:\n  parse_nodes_dom y\n  length y < length s", "show \"parse_nodes_dom y\""], ["proof (prove)\nusing this:\n  parse_nodes_dom y\n  length y < length s\n\ngoal (1 subgoal):\n 1. parse_nodes_dom y", "by simp"], ["proof (state)\nthis:\n  parse_nodes_dom y\n\ngoal (2 subgoals):\n 1. \\<And>ts ya tsa yaa tsb yb tsc yc tsd.\n       \\<lbrakk>y = tsd; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd);\n        yc \\<noteq> ''/>''\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y\n 2. \\<And>ts ya tsa yaa tsb yb tsc yc tsd yd tse ye tsf yf tsg yg tsh.\n       \\<lbrakk>y = tsh; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd); yc \\<noteq> ''/>'';\n        parse_nodes_sumC tsd = Inr (yd, tse);\n        exactly ''</'' tse = Inr (ye, tsf); exactly yaa tsf = Inr (yf, tsg);\n        exactly ''>'' tsg = Inr (yg, tsh)\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y", "next"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ts ya tsa yaa tsb yb tsc yc tsd.\n       \\<lbrakk>y = tsd; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd);\n        yc \\<noteq> ''/>''\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y\n 2. \\<And>ts ya tsa yaa tsb yb tsc yc tsd yd tse ye tsf yf tsg yg tsh.\n       \\<lbrakk>y = tsh; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd); yc \\<noteq> ''/>'';\n        parse_nodes_sumC tsd = Inr (yd, tse);\n        exactly ''</'' tse = Inr (ye, tsf); exactly yaa tsf = Inr (yf, tsg);\n        exactly ''>'' tsg = Inr (yg, tsh)\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y", "fix ts ya tsa yaa tsb yb tsc yc tsd"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<And>ts ya tsa yaa tsb yb tsc yc tsd.\n       \\<lbrakk>y = tsd; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd);\n        yc \\<noteq> ''/>''\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y\n 2. \\<And>ts ya tsa yaa tsb yb tsc yc tsd yd tse ye tsf yf tsg yg tsh.\n       \\<lbrakk>y = tsh; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd); yc \\<noteq> ''/>'';\n        parse_nodes_sumC tsd = Inr (yd, tse);\n        exactly ''</'' tse = Inr (ye, tsf); exactly yaa tsf = Inr (yf, tsg);\n        exactly ''>'' tsg = Inr (yg, tsh)\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y", "assume \"y = tsd\" and \"s = ts\" and \"\\<not> ?check ts\"\n        and \"exactly ''<'' ts = Inr (ya, tsa)\"\n        and \"parse_name tsa = Inr (yaa, tsb)\"\n        and \"parse_attributes tsb = Inr (yb, tsc)\"\n        and \"oneof [''/>'', ''>''] tsc = Inr (yc, tsd)\""], ["proof (state)\nthis:\n  y = tsd\n  s = ts\n  \\<not> (ts = [] \\<or> take 2 ts = ''</'')\n  exactly ''<'' ts = Inr (ya, tsa)\n  parse_name tsa = Inr (yaa, tsb)\n  parse_attributes tsb = Inr (yb, tsc)\n  oneof [''/>'', ''>''] tsc = Inr (yc, tsd)\n\ngoal (2 subgoals):\n 1. \\<And>ts ya tsa yaa tsb yb tsc yc tsd.\n       \\<lbrakk>y = tsd; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd);\n        yc \\<noteq> ''/>''\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y\n 2. \\<And>ts ya tsa yaa tsb yb tsc yc tsd yd tse ye tsf yf tsg yg tsh.\n       \\<lbrakk>y = tsh; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd); yc \\<noteq> ''/>'';\n        parse_nodes_sumC tsd = Inr (yd, tse);\n        exactly ''</'' tse = Inr (ye, tsf); exactly yaa tsf = Inr (yf, tsg);\n        exactly ''>'' tsg = Inr (yg, tsh)\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y", "then"], ["proof (chain)\npicking this:\n  y = tsd\n  s = ts\n  \\<not> (ts = [] \\<or> take 2 ts = ''</'')\n  exactly ''<'' ts = Inr (ya, tsa)\n  parse_name tsa = Inr (yaa, tsb)\n  parse_attributes tsb = Inr (yb, tsc)\n  oneof [''/>'', ''>''] tsc = Inr (yc, tsd)", "have len: \"length s > length y\""], ["proof (prove)\nusing this:\n  y = tsd\n  s = ts\n  \\<not> (ts = [] \\<or> take 2 ts = ''</'')\n  exactly ''<'' ts = Inr (ya, tsa)\n  parse_name tsa = Inr (yaa, tsb)\n  parse_attributes tsb = Inr (yb, tsc)\n  oneof [''/>'', ''>''] tsc = Inr (yc, tsd)\n\ngoal (1 subgoal):\n 1. length y < length s", "using is_cparser_exactly [of \"''<''\", simplified]\n        and is_parser_oneof [of \"[''/>'', ''>'']\"]\n        and is_parser_parse_attributes\n        and is_parser_parse_name"], ["proof (prove)\nusing this:\n  y = tsd\n  s = ts\n  \\<not> (ts = [] \\<or> take 2 ts = ''</'')\n  exactly ''<'' ts = Inr (ya, tsa)\n  parse_name tsa = Inr (yaa, tsb)\n  parse_attributes tsb = Inr (yb, tsc)\n  oneof [''/>'', ''>''] tsc = Inr (yc, tsd)\n  is_cparser (exactly ''<'')\n  is_parser (oneof [''/>'', ''>''])\n  is_parser parse_attributes\n  is_parser parse_name\n\ngoal (1 subgoal):\n 1. length y < length s", "by (auto dest!: is_parser_length is_cparser_length)"], ["proof (state)\nthis:\n  length y < length s\n\ngoal (2 subgoals):\n 1. \\<And>ts ya tsa yaa tsb yb tsc yc tsd.\n       \\<lbrakk>y = tsd; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd);\n        yc \\<noteq> ''/>''\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y\n 2. \\<And>ts ya tsa yaa tsb yb tsc yc tsd yd tse ye tsf yf tsg yg tsh.\n       \\<lbrakk>y = tsh; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd); yc \\<noteq> ''/>'';\n        parse_nodes_sumC tsd = Inr (yd, tse);\n        exactly ''</'' tse = Inr (ye, tsf); exactly yaa tsf = Inr (yf, tsg);\n        exactly ''>'' tsg = Inr (yg, tsh)\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y", "with ind1[OF len]"], ["proof (chain)\npicking this:\n  parse_nodes_dom y\n  length y < length s", "show \"parse_nodes_dom y\""], ["proof (prove)\nusing this:\n  parse_nodes_dom y\n  length y < length s\n\ngoal (1 subgoal):\n 1. parse_nodes_dom y", "by simp"], ["proof (state)\nthis:\n  parse_nodes_dom y\n\ngoal (1 subgoal):\n 1. \\<And>ts ya tsa yaa tsb yb tsc yc tsd yd tse ye tsf yf tsg yg tsh.\n       \\<lbrakk>y = tsh; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd); yc \\<noteq> ''/>'';\n        parse_nodes_sumC tsd = Inr (yd, tse);\n        exactly ''</'' tse = Inr (ye, tsf); exactly yaa tsf = Inr (yf, tsg);\n        exactly ''>'' tsg = Inr (yg, tsh)\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ts ya tsa yaa tsb yb tsc yc tsd yd tse ye tsf yf tsg yg tsh.\n       \\<lbrakk>y = tsh; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd); yc \\<noteq> ''/>'';\n        parse_nodes_sumC tsd = Inr (yd, tse);\n        exactly ''</'' tse = Inr (ye, tsf); exactly yaa tsf = Inr (yf, tsg);\n        exactly ''>'' tsg = Inr (yg, tsh)\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y", "fix ts ya tsa yaa tsb yb tsc yc tse ye tsf yf tsg yg tsh yh tsi yi tsj"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>ts ya tsa yaa tsb yb tsc yc tsd yd tse ye tsf yf tsg yg tsh.\n       \\<lbrakk>y = tsh; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd); yc \\<noteq> ''/>'';\n        parse_nodes_sumC tsd = Inr (yd, tse);\n        exactly ''</'' tse = Inr (ye, tsf); exactly yaa tsf = Inr (yf, tsg);\n        exactly ''>'' tsg = Inr (yg, tsh)\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y", "assume y: \"y = tsj\" and \"s = ts\" and \"\\<not> ?check ts\"\n        and \"exactly ''<'' ts = Inr (ya, tsa)\"\n        and \"parse_name tsa = Inr (yaa, tsb)\"\n        and \"parse_attributes tsb = Inr (yb, tsc)\"\n        and \"oneof [''/>'', ''>''] tsc = Inr (yc, tse)\"\n        and rec: \"parse_nodes_sumC tse = Inr (ye, tsf)\" \n        and last: \"exactly ''</'' tsf = Inr (yf, tsg)\"\n          \"exactly yaa tsg = Inr (yg, tsh)\"\n          \"exactly ''>'' tsh = Inr (yi, tsj)\""], ["proof (state)\nthis:\n  y = tsj\n  s = ts\n  \\<not> (ts = [] \\<or> take 2 ts = ''</'')\n  exactly ''<'' ts = Inr (ya, tsa)\n  parse_name tsa = Inr (yaa, tsb)\n  parse_attributes tsb = Inr (yb, tsc)\n  oneof [''/>'', ''>''] tsc = Inr (yc, tse)\n  parse_nodes_sumC tse = Inr (ye, tsf)\n  exactly ''</'' tsf = Inr (yf, tsg)\n  exactly yaa tsg = Inr (yg, tsh)\n  exactly ''>'' tsh = Inr (yi, tsj)\n\ngoal (1 subgoal):\n 1. \\<And>ts ya tsa yaa tsb yb tsc yc tsd yd tse ye tsf yf tsg yg tsh.\n       \\<lbrakk>y = tsh; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd); yc \\<noteq> ''/>'';\n        parse_nodes_sumC tsd = Inr (yd, tse);\n        exactly ''</'' tse = Inr (ye, tsf); exactly yaa tsf = Inr (yf, tsg);\n        exactly ''>'' tsg = Inr (yg, tsh)\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y", "then"], ["proof (chain)\npicking this:\n  y = tsj\n  s = ts\n  \\<not> (ts = [] \\<or> take 2 ts = ''</'')\n  exactly ''<'' ts = Inr (ya, tsa)\n  parse_name tsa = Inr (yaa, tsb)\n  parse_attributes tsb = Inr (yb, tsc)\n  oneof [''/>'', ''>''] tsc = Inr (yc, tse)\n  parse_nodes_sumC tse = Inr (ye, tsf)\n  exactly ''</'' tsf = Inr (yf, tsg)\n  exactly yaa tsg = Inr (yg, tsh)\n  exactly ''>'' tsh = Inr (yi, tsj)", "have len: \"length s > length tse\""], ["proof (prove)\nusing this:\n  y = tsj\n  s = ts\n  \\<not> (ts = [] \\<or> take 2 ts = ''</'')\n  exactly ''<'' ts = Inr (ya, tsa)\n  parse_name tsa = Inr (yaa, tsb)\n  parse_attributes tsb = Inr (yb, tsc)\n  oneof [''/>'', ''>''] tsc = Inr (yc, tse)\n  parse_nodes_sumC tse = Inr (ye, tsf)\n  exactly ''</'' tsf = Inr (yf, tsg)\n  exactly yaa tsg = Inr (yg, tsh)\n  exactly ''>'' tsh = Inr (yi, tsj)\n\ngoal (1 subgoal):\n 1. length tse < length s", "using is_cparser_exactly [of \"''<''\", simplified]\n        and is_parser_oneof [of \"[''/>'', ''>'']\"]\n        and is_parser_parse_attributes\n        and is_parser_parse_name"], ["proof (prove)\nusing this:\n  y = tsj\n  s = ts\n  \\<not> (ts = [] \\<or> take 2 ts = ''</'')\n  exactly ''<'' ts = Inr (ya, tsa)\n  parse_name tsa = Inr (yaa, tsb)\n  parse_attributes tsb = Inr (yb, tsc)\n  oneof [''/>'', ''>''] tsc = Inr (yc, tse)\n  parse_nodes_sumC tse = Inr (ye, tsf)\n  exactly ''</'' tsf = Inr (yf, tsg)\n  exactly yaa tsg = Inr (yg, tsh)\n  exactly ''>'' tsh = Inr (yi, tsj)\n  is_cparser (exactly ''<'')\n  is_parser (oneof [''/>'', ''>''])\n  is_parser parse_attributes\n  is_parser parse_name\n\ngoal (1 subgoal):\n 1. length tse < length s", "by (auto dest!: is_parser_length is_cparser_length)"], ["proof (state)\nthis:\n  length tse < length s\n\ngoal (1 subgoal):\n 1. \\<And>ts ya tsa yaa tsb yb tsc yc tsd yd tse ye tsf yf tsg yg tsh.\n       \\<lbrakk>y = tsh; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd); yc \\<noteq> ''/>'';\n        parse_nodes_sumC tsd = Inr (yd, tse);\n        exactly ''</'' tse = Inr (ye, tsf); exactly yaa tsf = Inr (yf, tsg);\n        exactly ''>'' tsg = Inr (yg, tsh)\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y", "from last(1) last(2)"], ["proof (chain)\npicking this:\n  exactly ''</'' tsf = Inr (yf, tsg)\n  exactly yaa tsg = Inr (yg, tsh)", "have len2a: \"length tsf \\<ge> length tsh\""], ["proof (prove)\nusing this:\n  exactly ''</'' tsf = Inr (yf, tsg)\n  exactly yaa tsg = Inr (yg, tsh)\n\ngoal (1 subgoal):\n 1. length tsh \\<le> length tsf", "using is_parser_exactly [of \"''</''\"] and is_parser_exactly [of yaa]\n        and is_parser_parse_name"], ["proof (prove)\nusing this:\n  exactly ''</'' tsf = Inr (yf, tsg)\n  exactly yaa tsg = Inr (yg, tsh)\n  is_parser (exactly ''</'')\n  is_parser (exactly yaa)\n  is_parser parse_name\n\ngoal (1 subgoal):\n 1. length tsh \\<le> length tsf", "by (auto dest!: is_parser_length)"], ["proof (state)\nthis:\n  length tsh \\<le> length tsf\n\ngoal (1 subgoal):\n 1. \\<And>ts ya tsa yaa tsb yb tsc yc tsd yd tse ye tsf yf tsg yg tsh.\n       \\<lbrakk>y = tsh; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd); yc \\<noteq> ''/>'';\n        parse_nodes_sumC tsd = Inr (yd, tse);\n        exactly ''</'' tse = Inr (ye, tsf); exactly yaa tsf = Inr (yf, tsg);\n        exactly ''>'' tsg = Inr (yg, tsh)\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y", "have len2c: \"length tsh \\<ge> length y\""], ["proof (prove)\ngoal (1 subgoal):\n 1. length y \\<le> length tsh", "using last(3)"], ["proof (prove)\nusing this:\n  exactly ''>'' tsh = Inr (yi, tsj)\n\ngoal (1 subgoal):\n 1. length y \\<le> length tsh", "using is_parser_exactly [of \"''>''\"]"], ["proof (prove)\nusing this:\n  exactly ''>'' tsh = Inr (yi, tsj)\n  is_parser (exactly ''>'')\n\ngoal (1 subgoal):\n 1. length y \\<le> length tsh", "by (auto simp: y dest!: is_parser_length)"], ["proof (state)\nthis:\n  length y \\<le> length tsh\n\ngoal (1 subgoal):\n 1. \\<And>ts ya tsa yaa tsb yb tsc yc tsd yd tse ye tsf yf tsg yg tsh.\n       \\<lbrakk>y = tsh; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd); yc \\<noteq> ''/>'';\n        parse_nodes_sumC tsd = Inr (yd, tse);\n        exactly ''</'' tse = Inr (ye, tsf); exactly yaa tsf = Inr (yf, tsg);\n        exactly ''>'' tsg = Inr (yg, tsh)\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y", "from len2a len2c"], ["proof (chain)\npicking this:\n  length tsh \\<le> length tsf\n  length y \\<le> length tsh", "have len2: \"length tsf \\<ge> length y\""], ["proof (prove)\nusing this:\n  length tsh \\<le> length tsf\n  length y \\<le> length tsh\n\ngoal (1 subgoal):\n 1. length y \\<le> length tsf", "by simp"], ["proof (state)\nthis:\n  length y \\<le> length tsf\n\ngoal (1 subgoal):\n 1. \\<And>ts ya tsa yaa tsb yb tsc yc tsd yd tse ye tsf yf tsg yg tsh.\n       \\<lbrakk>y = tsh; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd); yc \\<noteq> ''/>'';\n        parse_nodes_sumC tsd = Inr (yd, tse);\n        exactly ''</'' tse = Inr (ye, tsf); exactly yaa tsf = Inr (yf, tsg);\n        exactly ''>'' tsg = Inr (yg, tsh)\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y", "from ind2[OF len rec[unfolded parse_nodes_def[symmetric]]] len len2"], ["proof (chain)\npicking this:\n  length tsf \\<le> length tse\n  length tse < length s\n  length y \\<le> length tsf", "have \"length s > length y\""], ["proof (prove)\nusing this:\n  length tsf \\<le> length tse\n  length tse < length s\n  length y \\<le> length tsf\n\ngoal (1 subgoal):\n 1. length y < length s", "by simp"], ["proof (state)\nthis:\n  length y < length s\n\ngoal (1 subgoal):\n 1. \\<And>ts ya tsa yaa tsb yb tsc yc tsd yd tse ye tsf yf tsg yg tsh.\n       \\<lbrakk>y = tsh; s = ts; \\<not> (ts = [] \\<or> take 2 ts = ''</'');\n        \\<not> hd ts \\<noteq> CHR ''<''; exactly ''<'' ts = Inr (ya, tsa);\n        parse_name tsa = Inr (yaa, tsb);\n        parse_attributes tsb = Inr (yb, tsc);\n        oneof [''/>'', ''>''] tsc = Inr (yc, tsd); yc \\<noteq> ''/>'';\n        parse_nodes_sumC tsd = Inr (yd, tse);\n        exactly ''</'' tse = Inr (ye, tsf); exactly yaa tsf = Inr (yf, tsg);\n        exactly ''>'' tsg = Inr (yg, tsh)\\<rbrakk>\n       \\<Longrightarrow> parse_nodes_dom y", "from ind1[OF this]"], ["proof (chain)\npicking this:\n  parse_nodes_dom y", "show \"parse_nodes_dom y\""], ["proof (prove)\nusing this:\n  parse_nodes_dom y\n\ngoal (1 subgoal):\n 1. parse_nodes_dom y", "."], ["proof (state)\nthis:\n  parse_nodes_dom y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  parse_nodes_dom y\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  parse_nodes_dom s\n\ngoal (2 subgoals):\n 1. wf (measure length)\n 2. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> measure length \\<longrightarrow>\n          parse_nodes_dom y \\<and>\n          (\\<forall>x r.\n              parse_nodes y = Inr (x, r) \\<longrightarrow>\n              length r \\<le> length y) \\<Longrightarrow>\n       parse_nodes_dom x \\<and>\n       (\\<forall>xa r.\n           parse_nodes x = Inr (xa, r) \\<longrightarrow>\n           length r \\<le> length x)", "note psimps = parse_nodes.psimps[OF dom]"], ["proof (state)\nthis:\n  parse_nodes s =\n  (if s = [] \\<or> take 2 s = ''</'' then Parser_Monad.return [] s\n   else if hd s \\<noteq> CHR ''<''\n        then (parse_text \\<bind>\n              (\\<lambda>t.\n                  parse_nodes \\<bind>\n                  (\\<lambda>ns.\n                      Parser_Monad.return (XML_text (the t) # ns))))\n              s\n        else (exactly ''<'' \\<bind>\n              (\\<lambda>_.\n                  parse_name \\<bind>\n                  (\\<lambda>n.\n                      parse_attributes \\<bind>\n                      (\\<lambda>atts.\n                          oneof [''/>'', ''>''] \\<bind>\n                          (\\<lambda>e ts'.\n                              if e = ''/>''\n                              then (parse_nodes \\<bind>\n                                    (\\<lambda>cs.\n  Parser_Monad.return (XML n atts [] # cs)))\n                                    ts'\n                              else (parse_nodes \\<bind>\n                                    (\\<lambda>cs.\n  exactly ''</'' \\<bind>\n  (\\<lambda>_.\n      exactly n \\<bind>\n      (\\<lambda>_.\n          exactly ''>'' \\<bind>\n          (\\<lambda>_.\n              parse_nodes \\<bind>\n              (\\<lambda>ns. Parser_Monad.return (XML n atts cs # ns)))))))\n                                    ts')))))\n              s)\n\ngoal (2 subgoals):\n 1. wf (measure length)\n 2. \\<And>x.\n       \\<forall>y.\n          (y, x) \\<in> measure length \\<longrightarrow>\n          parse_nodes_dom y \\<and>\n          (\\<forall>x r.\n              parse_nodes y = Inr (x, r) \\<longrightarrow>\n              length r \\<le> length y) \\<Longrightarrow>\n       parse_nodes_dom x \\<and>\n       (\\<forall>xa r.\n           parse_nodes x = Inr (xa, r) \\<longrightarrow>\n           length r \\<le> length x)", "show \"?prop s\""], ["proof (prove)\ngoal (1 subgoal):\n 1. parse_nodes_dom s \\<and>\n    (\\<forall>x r.\n        parse_nodes s = Inr (x, r) \\<longrightarrow>\n        length r \\<le> length s)", "proof (intro conjI, rule dom, intro allI impI)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x r.\n       parse_nodes s = Inr (x, r) \\<Longrightarrow> length r \\<le> length s", "fix x r"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x r.\n       parse_nodes s = Inr (x, r) \\<Longrightarrow> length r \\<le> length s", "assume res: \"parse_nodes s = Inr (x,r)\""], ["proof (state)\nthis:\n  parse_nodes s = Inr (x, r)\n\ngoal (1 subgoal):\n 1. \\<And>x r.\n       parse_nodes s = Inr (x, r) \\<Longrightarrow> length r \\<le> length s", "note res = res[unfolded psimps]"], ["proof (state)\nthis:\n  (if s = [] \\<or> take 2 s = ''</'' then Parser_Monad.return [] s\n   else if hd s \\<noteq> CHR ''<''\n        then (parse_text \\<bind>\n              (\\<lambda>t.\n                  parse_nodes \\<bind>\n                  (\\<lambda>ns.\n                      Parser_Monad.return (XML_text (the t) # ns))))\n              s\n        else (exactly ''<'' \\<bind>\n              (\\<lambda>_.\n                  parse_name \\<bind>\n                  (\\<lambda>n.\n                      parse_attributes \\<bind>\n                      (\\<lambda>atts.\n                          oneof [''/>'', ''>''] \\<bind>\n                          (\\<lambda>e ts'.\n                              if e = ''/>''\n                              then (parse_nodes \\<bind>\n                                    (\\<lambda>cs.\n  Parser_Monad.return (XML n atts [] # cs)))\n                                    ts'\n                              else (parse_nodes \\<bind>\n                                    (\\<lambda>cs.\n  exactly ''</'' \\<bind>\n  (\\<lambda>_.\n      exactly n \\<bind>\n      (\\<lambda>_.\n          exactly ''>'' \\<bind>\n          (\\<lambda>_.\n              parse_nodes \\<bind>\n              (\\<lambda>ns. Parser_Monad.return (XML n atts cs # ns)))))))\n                                    ts')))))\n              s) =\n  Inr (x, r)\n\ngoal (1 subgoal):\n 1. \\<And>x r.\n       parse_nodes s = Inr (x, r) \\<Longrightarrow> length r \\<le> length s", "then"], ["proof (chain)\npicking this:\n  (if s = [] \\<or> take 2 s = ''</'' then Parser_Monad.return [] s\n   else if hd s \\<noteq> CHR ''<''\n        then (parse_text \\<bind>\n              (\\<lambda>t.\n                  parse_nodes \\<bind>\n                  (\\<lambda>ns.\n                      Parser_Monad.return (XML_text (the t) # ns))))\n              s\n        else (exactly ''<'' \\<bind>\n              (\\<lambda>_.\n                  parse_name \\<bind>\n                  (\\<lambda>n.\n                      parse_attributes \\<bind>\n                      (\\<lambda>atts.\n                          oneof [''/>'', ''>''] \\<bind>\n                          (\\<lambda>e ts'.\n                              if e = ''/>''\n                              then (parse_nodes \\<bind>\n                                    (\\<lambda>cs.\n  Parser_Monad.return (XML n atts [] # cs)))\n                                    ts'\n                              else (parse_nodes \\<bind>\n                                    (\\<lambda>cs.\n  exactly ''</'' \\<bind>\n  (\\<lambda>_.\n      exactly n \\<bind>\n      (\\<lambda>_.\n          exactly ''>'' \\<bind>\n          (\\<lambda>_.\n              parse_nodes \\<bind>\n              (\\<lambda>ns. Parser_Monad.return (XML n atts cs # ns)))))))\n                                    ts')))))\n              s) =\n  Inr (x, r)", "show \"length r \\<le> length s\""], ["proof (prove)\nusing this:\n  (if s = [] \\<or> take 2 s = ''</'' then Parser_Monad.return [] s\n   else if hd s \\<noteq> CHR ''<''\n        then (parse_text \\<bind>\n              (\\<lambda>t.\n                  parse_nodes \\<bind>\n                  (\\<lambda>ns.\n                      Parser_Monad.return (XML_text (the t) # ns))))\n              s\n        else (exactly ''<'' \\<bind>\n              (\\<lambda>_.\n                  parse_name \\<bind>\n                  (\\<lambda>n.\n                      parse_attributes \\<bind>\n                      (\\<lambda>atts.\n                          oneof [''/>'', ''>''] \\<bind>\n                          (\\<lambda>e ts'.\n                              if e = ''/>''\n                              then (parse_nodes \\<bind>\n                                    (\\<lambda>cs.\n  Parser_Monad.return (XML n atts [] # cs)))\n                                    ts'\n                              else (parse_nodes \\<bind>\n                                    (\\<lambda>cs.\n  exactly ''</'' \\<bind>\n  (\\<lambda>_.\n      exactly n \\<bind>\n      (\\<lambda>_.\n          exactly ''>'' \\<bind>\n          (\\<lambda>_.\n              parse_nodes \\<bind>\n              (\\<lambda>ns. Parser_Monad.return (XML n atts cs # ns)))))))\n                                    ts')))))\n              s) =\n  Inr (x, r)\n\ngoal (1 subgoal):\n 1. length r \\<le> length s", "proof (cases \"?check s\")"], ["proof (state)\ngoal (2 subgoals):\n 1. \\<lbrakk>(if s = [] \\<or> take 2 s = ''</''\n              then Parser_Monad.return [] s\n              else if hd s \\<noteq> CHR ''<''\n                   then (parse_text \\<bind>\n                         (\\<lambda>t.\n                             parse_nodes \\<bind>\n                             (\\<lambda>ns.\n                                 Parser_Monad.return\n                                  (XML_text (the t) # ns))))\n                         s\n                   else (exactly ''<'' \\<bind>\n                         (\\<lambda>_.\n                             parse_name \\<bind>\n                             (\\<lambda>n.\n                                 parse_attributes \\<bind>\n                                 (\\<lambda>atts.\n                                     oneof [''/>'', ''>''] \\<bind>\n                                     (\\<lambda>e ts'.\n   if e = ''/>''\n   then (parse_nodes \\<bind>\n         (\\<lambda>cs. Parser_Monad.return (XML n atts [] # cs)))\n         ts'\n   else (parse_nodes \\<bind>\n         (\\<lambda>cs.\n             exactly ''</'' \\<bind>\n             (\\<lambda>_.\n                 exactly n \\<bind>\n                 (\\<lambda>_.\n                     exactly ''>'' \\<bind>\n                     (\\<lambda>_.\n                         parse_nodes \\<bind>\n                         (\\<lambda>ns.\n                             Parser_Monad.return (XML n atts cs # ns)))))))\n         ts')))))\n                         s) =\n             Inr (x, r);\n     s = [] \\<or> take 2 s = ''</''\\<rbrakk>\n    \\<Longrightarrow> length r \\<le> length s\n 2. \\<lbrakk>(if s = [] \\<or> take 2 s = ''</''\n              then Parser_Monad.return [] s\n              else if hd s \\<noteq> CHR ''<''\n                   then (parse_text \\<bind>\n                         (\\<lambda>t.\n                             parse_nodes \\<bind>\n                             (\\<lambda>ns.\n                                 Parser_Monad.return\n                                  (XML_text (the t) # ns))))\n                         s\n                   else (exactly ''<'' \\<bind>\n                         (\\<lambda>_.\n                             parse_name \\<bind>\n                             (\\<lambda>n.\n                                 parse_attributes \\<bind>\n                                 (\\<lambda>atts.\n                                     oneof [''/>'', ''>''] \\<bind>\n                                     (\\<lambda>e ts'.\n   if e = ''/>''\n   then (parse_nodes \\<bind>\n         (\\<lambda>cs. Parser_Monad.return (XML n atts [] # cs)))\n         ts'\n   else (parse_nodes \\<bind>\n         (\\<lambda>cs.\n             exactly ''</'' \\<bind>\n             (\\<lambda>_.\n                 exactly n \\<bind>\n                 (\\<lambda>_.\n                     exactly ''>'' \\<bind>\n                     (\\<lambda>_.\n                         parse_nodes \\<bind>\n                         (\\<lambda>ns.\n                             Parser_Monad.return (XML n atts cs # ns)))))))\n         ts')))))\n                         s) =\n             Inr (x, r);\n     \\<not> (s = [] \\<or> take 2 s = ''</'')\\<rbrakk>\n    \\<Longrightarrow> length r \\<le> length s", "case True"], ["proof (state)\nthis:\n  s = [] \\<or> take 2 s = ''</''\n\ngoal (2 subgoals):\n 1. \\<lbrakk>(if s = [] \\<or> take 2 s = ''</''\n              then Parser_Monad.return [] s\n              else if hd s \\<noteq> CHR ''<''\n                   then (parse_text \\<bind>\n                         (\\<lambda>t.\n                             parse_nodes \\<bind>\n                             (\\<lambda>ns.\n                                 Parser_Monad.return\n                                  (XML_text (the t) # ns))))\n                         s\n                   else (exactly ''<'' \\<bind>\n                         (\\<lambda>_.\n                             parse_name \\<bind>\n                             (\\<lambda>n.\n                                 parse_attributes \\<bind>\n                                 (\\<lambda>atts.\n                                     oneof [''/>'', ''>''] \\<bind>\n                                     (\\<lambda>e ts'.\n   if e = ''/>''\n   then (parse_nodes \\<bind>\n         (\\<lambda>cs. Parser_Monad.return (XML n atts [] # cs)))\n         ts'\n   else (parse_nodes \\<bind>\n         (\\<lambda>cs.\n             exactly ''</'' \\<bind>\n             (\\<lambda>_.\n                 exactly n \\<bind>\n                 (\\<lambda>_.\n                     exactly ''>'' \\<bind>\n                     (\\<lambda>_.\n                         parse_nodes \\<bind>\n                         (\\<lambda>ns.\n                             Parser_Monad.return (XML n atts cs # ns)))))))\n         ts')))))\n                         s) =\n             Inr (x, r);\n     s = [] \\<or> take 2 s = ''</''\\<rbrakk>\n    \\<Longrightarrow> length r \\<le> length s\n 2. \\<lbrakk>(if s = [] \\<or> take 2 s = ''</''\n              then Parser_Monad.return [] s\n              else if hd s \\<noteq> CHR ''<''\n                   then (parse_text \\<bind>\n                         (\\<lambda>t.\n                             parse_nodes \\<bind>\n                             (\\<lambda>ns.\n                                 Parser_Monad.return\n                                  (XML_text (the t) # ns))))\n                         s\n                   else (exactly ''<'' \\<bind>\n                         (\\<lambda>_.\n                             parse_name \\<bind>\n                             (\\<lambda>n.\n                                 parse_attributes \\<bind>\n                                 (\\<lambda>atts.\n                                     oneof [''/>'', ''>''] \\<bind>\n                                     (\\<lambda>e ts'.\n   if e = ''/>''\n   then (parse_nodes \\<bind>\n         (\\<lambda>cs. Parser_Monad.return (XML n atts [] # cs)))\n         ts'\n   else (parse_nodes \\<bind>\n         (\\<lambda>cs.\n             exactly ''</'' \\<bind>\n             (\\<lambda>_.\n                 exactly n \\<bind>\n                 (\\<lambda>_.\n                     exactly ''>'' \\<bind>\n                     (\\<lambda>_.\n                         parse_nodes \\<bind>\n                         (\\<lambda>ns.\n                             Parser_Monad.return (XML n atts cs # ns)))))))\n         ts')))))\n                         s) =\n             Inr (x, r);\n     \\<not> (s = [] \\<or> take 2 s = ''</'')\\<rbrakk>\n    \\<Longrightarrow> length r \\<le> length s", "then"], ["proof (chain)\npicking this:\n  s = [] \\<or> take 2 s = ''</''", "show ?thesis"], ["proof (prove)\nusing this:\n  s = [] \\<or> take 2 s = ''</''\n\ngoal (1 subgoal):\n 1. length r \\<le> length s", "using res"], ["proof (prove)\nusing this:\n  s = [] \\<or> take 2 s = ''</''\n  (if s = [] \\<or> take 2 s = ''</'' then Parser_Monad.return [] s\n   else if hd s \\<noteq> CHR ''<''\n        then (parse_text \\<bind>\n              (\\<lambda>t.\n                  parse_nodes \\<bind>\n                  (\\<lambda>ns.\n                      Parser_Monad.return (XML_text (the t) # ns))))\n              s\n        else (exactly ''<'' \\<bind>\n              (\\<lambda>_.\n                  parse_name \\<bind>\n                  (\\<lambda>n.\n                      parse_attributes \\<bind>\n                      (\\<lambda>atts.\n                          oneof [''/>'', ''>''] \\<bind>\n                          (\\<lambda>e ts'.\n                              if e = ''/>''\n                              then (parse_nodes \\<bind>\n                                    (\\<lambda>cs.\n  Parser_Monad.return (XML n atts [] # cs)))\n                                    ts'\n                              else (parse_nodes \\<bind>\n                                    (\\<lambda>cs.\n  exactly ''</'' \\<bind>\n  (\\<lambda>_.\n      exactly n \\<bind>\n      (\\<lambda>_.\n          exactly ''>'' \\<bind>\n          (\\<lambda>_.\n              parse_nodes \\<bind>\n              (\\<lambda>ns. Parser_Monad.return (XML n atts cs # ns)))))))\n                                    ts')))))\n              s) =\n  Inr (x, r)\n\ngoal (1 subgoal):\n 1. length r \\<le> length s", "by (simp add: return_def)"], ["proof (state)\nthis:\n  length r \\<le> length s\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(if s = [] \\<or> take 2 s = ''</''\n              then Parser_Monad.return [] s\n              else if hd s \\<noteq> CHR ''<''\n                   then (parse_text \\<bind>\n                         (\\<lambda>t.\n                             parse_nodes \\<bind>\n                             (\\<lambda>ns.\n                                 Parser_Monad.return\n                                  (XML_text (the t) # ns))))\n                         s\n                   else (exactly ''<'' \\<bind>\n                         (\\<lambda>_.\n                             parse_name \\<bind>\n                             (\\<lambda>n.\n                                 parse_attributes \\<bind>\n                                 (\\<lambda>atts.\n                                     oneof [''/>'', ''>''] \\<bind>\n                                     (\\<lambda>e ts'.\n   if e = ''/>''\n   then (parse_nodes \\<bind>\n         (\\<lambda>cs. Parser_Monad.return (XML n atts [] # cs)))\n         ts'\n   else (parse_nodes \\<bind>\n         (\\<lambda>cs.\n             exactly ''</'' \\<bind>\n             (\\<lambda>_.\n                 exactly n \\<bind>\n                 (\\<lambda>_.\n                     exactly ''>'' \\<bind>\n                     (\\<lambda>_.\n                         parse_nodes \\<bind>\n                         (\\<lambda>ns.\n                             Parser_Monad.return (XML n atts cs # ns)))))))\n         ts')))))\n                         s) =\n             Inr (x, r);\n     \\<not> (s = [] \\<or> take 2 s = ''</'')\\<rbrakk>\n    \\<Longrightarrow> length r \\<le> length s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<lbrakk>(if s = [] \\<or> take 2 s = ''</''\n              then Parser_Monad.return [] s\n              else if hd s \\<noteq> CHR ''<''\n                   then (parse_text \\<bind>\n                         (\\<lambda>t.\n                             parse_nodes \\<bind>\n                             (\\<lambda>ns.\n                                 Parser_Monad.return\n                                  (XML_text (the t) # ns))))\n                         s\n                   else (exactly ''<'' \\<bind>\n                         (\\<lambda>_.\n                             parse_name \\<bind>\n                             (\\<lambda>n.\n                                 parse_attributes \\<bind>\n                                 (\\<lambda>atts.\n                                     oneof [''/>'', ''>''] \\<bind>\n                                     (\\<lambda>e ts'.\n   if e = ''/>''\n   then (parse_nodes \\<bind>\n         (\\<lambda>cs. Parser_Monad.return (XML n atts [] # cs)))\n         ts'\n   else (parse_nodes \\<bind>\n         (\\<lambda>cs.\n             exactly ''</'' \\<bind>\n             (\\<lambda>_.\n                 exactly n \\<bind>\n                 (\\<lambda>_.\n                     exactly ''>'' \\<bind>\n                     (\\<lambda>_.\n                         parse_nodes \\<bind>\n                         (\\<lambda>ns.\n                             Parser_Monad.return (XML n atts cs # ns)))))))\n         ts')))))\n                         s) =\n             Inr (x, r);\n     \\<not> (s = [] \\<or> take 2 s = ''</'')\\<rbrakk>\n    \\<Longrightarrow> length r \\<le> length s", "case False"], ["proof (state)\nthis:\n  \\<not> (s = [] \\<or> take 2 s = ''</'')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(if s = [] \\<or> take 2 s = ''</''\n              then Parser_Monad.return [] s\n              else if hd s \\<noteq> CHR ''<''\n                   then (parse_text \\<bind>\n                         (\\<lambda>t.\n                             parse_nodes \\<bind>\n                             (\\<lambda>ns.\n                                 Parser_Monad.return\n                                  (XML_text (the t) # ns))))\n                         s\n                   else (exactly ''<'' \\<bind>\n                         (\\<lambda>_.\n                             parse_name \\<bind>\n                             (\\<lambda>n.\n                                 parse_attributes \\<bind>\n                                 (\\<lambda>atts.\n                                     oneof [''/>'', ''>''] \\<bind>\n                                     (\\<lambda>e ts'.\n   if e = ''/>''\n   then (parse_nodes \\<bind>\n         (\\<lambda>cs. Parser_Monad.return (XML n atts [] # cs)))\n         ts'\n   else (parse_nodes \\<bind>\n         (\\<lambda>cs.\n             exactly ''</'' \\<bind>\n             (\\<lambda>_.\n                 exactly n \\<bind>\n                 (\\<lambda>_.\n                     exactly ''>'' \\<bind>\n                     (\\<lambda>_.\n                         parse_nodes \\<bind>\n                         (\\<lambda>ns.\n                             Parser_Monad.return (XML n atts cs # ns)))))))\n         ts')))))\n                         s) =\n             Inr (x, r);\n     \\<not> (s = [] \\<or> take 2 s = ''</'')\\<rbrakk>\n    \\<Longrightarrow> length r \\<le> length s", "note oFalse = this"], ["proof (state)\nthis:\n  \\<not> (s = [] \\<or> take 2 s = ''</'')\n\ngoal (1 subgoal):\n 1. \\<lbrakk>(if s = [] \\<or> take 2 s = ''</''\n              then Parser_Monad.return [] s\n              else if hd s \\<noteq> CHR ''<''\n                   then (parse_text \\<bind>\n                         (\\<lambda>t.\n                             parse_nodes \\<bind>\n                             (\\<lambda>ns.\n                                 Parser_Monad.return\n                                  (XML_text (the t) # ns))))\n                         s\n                   else (exactly ''<'' \\<bind>\n                         (\\<lambda>_.\n                             parse_name \\<bind>\n                             (\\<lambda>n.\n                                 parse_attributes \\<bind>\n                                 (\\<lambda>atts.\n                                     oneof [''/>'', ''>''] \\<bind>\n                                     (\\<lambda>e ts'.\n   if e = ''/>''\n   then (parse_nodes \\<bind>\n         (\\<lambda>cs. Parser_Monad.return (XML n atts [] # cs)))\n         ts'\n   else (parse_nodes \\<bind>\n         (\\<lambda>cs.\n             exactly ''</'' \\<bind>\n             (\\<lambda>_.\n                 exactly n \\<bind>\n                 (\\<lambda>_.\n                     exactly ''>'' \\<bind>\n                     (\\<lambda>_.\n                         parse_nodes \\<bind>\n                         (\\<lambda>ns.\n                             Parser_Monad.return (XML n atts cs # ns)))))))\n         ts')))))\n                         s) =\n             Inr (x, r);\n     \\<not> (s = [] \\<or> take 2 s = ''</'')\\<rbrakk>\n    \\<Longrightarrow> length r \\<le> length s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. length r \\<le> length s", "proof (cases ?check2)"], ["proof (state)\ngoal (2 subgoals):\n 1. hd s \\<noteq> CHR ''<'' \\<Longrightarrow> length r \\<le> length s\n 2. \\<not> hd s \\<noteq> CHR ''<'' \\<Longrightarrow> length r \\<le> length s", "case True"], ["proof (state)\nthis:\n  hd s \\<noteq> CHR ''<''\n\ngoal (2 subgoals):\n 1. hd s \\<noteq> CHR ''<'' \\<Longrightarrow> length r \\<le> length s\n 2. \\<not> hd s \\<noteq> CHR ''<'' \\<Longrightarrow> length r \\<le> length s", "note res = res[simplified False True, simplified]"], ["proof (state)\nthis:\n  (parse_text \\<bind>\n   (\\<lambda>t.\n       parse_nodes \\<bind>\n       (\\<lambda>ns. Parser_Monad.return (XML_text (the t) # ns))))\n   s =\n  Inr (x, r)\n\ngoal (2 subgoals):\n 1. hd s \\<noteq> CHR ''<'' \\<Longrightarrow> length r \\<le> length s\n 2. \\<not> hd s \\<noteq> CHR ''<'' \\<Longrightarrow> length r \\<le> length s", "from res"], ["proof (chain)\npicking this:\n  (parse_text \\<bind>\n   (\\<lambda>t.\n       parse_nodes \\<bind>\n       (\\<lambda>ns. Parser_Monad.return (XML_text (the t) # ns))))\n   s =\n  Inr (x, r)", "obtain y1 s1 where pt: \"parse_text s = Inr (y1, s1)\""], ["proof (prove)\nusing this:\n  (parse_text \\<bind>\n   (\\<lambda>t.\n       parse_nodes \\<bind>\n       (\\<lambda>ns. Parser_Monad.return (XML_text (the t) # ns))))\n   s =\n  Inr (x, r)\n\ngoal (1 subgoal):\n 1. (\\<And>y1 s1.\n        parse_text s = Inr (y1, s1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"parse_text s\", auto simp: bind_def)"], ["proof (state)\nthis:\n  parse_text s = Inr (y1, s1)\n\ngoal (2 subgoals):\n 1. hd s \\<noteq> CHR ''<'' \\<Longrightarrow> length r \\<le> length s\n 2. \\<not> hd s \\<noteq> CHR ''<'' \\<Longrightarrow> length r \\<le> length s", "note res = res[unfolded bind_def pt, simplified]"], ["proof (state)\nthis:\n  parse_nodes s1 \\<bind>\n  (\\<lambda>(ns, y). Parser_Monad.return (XML_text (the y1) # ns) y) =\n  Inr (x, r)\n\ngoal (2 subgoals):\n 1. hd s \\<noteq> CHR ''<'' \\<Longrightarrow> length r \\<le> length s\n 2. \\<not> hd s \\<noteq> CHR ''<'' \\<Longrightarrow> length r \\<le> length s", "from res"], ["proof (chain)\npicking this:\n  parse_nodes s1 \\<bind>\n  (\\<lambda>(ns, y). Parser_Monad.return (XML_text (the y1) # ns) y) =\n  Inr (x, r)", "obtain y2 s2\n          where pn: \"parse_nodes s1 = Inr (y2, s2)\""], ["proof (prove)\nusing this:\n  parse_nodes s1 \\<bind>\n  (\\<lambda>(ns, y). Parser_Monad.return (XML_text (the y1) # ns) y) =\n  Inr (x, r)\n\ngoal (1 subgoal):\n 1. (\\<And>y2 s2.\n        parse_nodes s1 = Inr (y2, s2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"parse_nodes s1\") (auto simp: bind_def)"], ["proof (state)\nthis:\n  parse_nodes s1 = Inr (y2, s2)\n\ngoal (2 subgoals):\n 1. hd s \\<noteq> CHR ''<'' \\<Longrightarrow> length r \\<le> length s\n 2. \\<not> hd s \\<noteq> CHR ''<'' \\<Longrightarrow> length r \\<le> length s", "note res = res[simplified bind_def pn, simplified]"], ["proof (state)\nthis:\n  Parser_Monad.return (XML_text (the y1) # y2) s2 = Inr (x, r)\n\ngoal (2 subgoals):\n 1. hd s \\<noteq> CHR ''<'' \\<Longrightarrow> length r \\<le> length s\n 2. \\<not> hd s \\<noteq> CHR ''<'' \\<Longrightarrow> length r \\<le> length s", "from res"], ["proof (chain)\npicking this:\n  Parser_Monad.return (XML_text (the y1) # y2) s2 = Inr (x, r)", "have r: \"r = s2\""], ["proof (prove)\nusing this:\n  Parser_Monad.return (XML_text (the y1) # y2) s2 = Inr (x, r)\n\ngoal (1 subgoal):\n 1. r = s2", "by (simp add: return_def bind_def)"], ["proof (state)\nthis:\n  r = s2\n\ngoal (2 subgoals):\n 1. hd s \\<noteq> CHR ''<'' \\<Longrightarrow> length r \\<le> length s\n 2. \\<not> hd s \\<noteq> CHR ''<'' \\<Longrightarrow> length r \\<le> length s", "from parse_text_consumes[OF _ True pt] False"], ["proof (chain)\npicking this:\n  s \\<noteq> [] \\<Longrightarrow> length s1 < length s\n  \\<not> (s = [] \\<or> take 2 s = ''</'')", "have lens: \"length s1 < length s\""], ["proof (prove)\nusing this:\n  s \\<noteq> [] \\<Longrightarrow> length s1 < length s\n  \\<not> (s = [] \\<or> take 2 s = ''</'')\n\ngoal (1 subgoal):\n 1. length s1 < length s", "by auto"], ["proof (state)\nthis:\n  length s1 < length s\n\ngoal (2 subgoals):\n 1. hd s \\<noteq> CHR ''<'' \\<Longrightarrow> length r \\<le> length s\n 2. \\<not> hd s \\<noteq> CHR ''<'' \\<Longrightarrow> length r \\<le> length s", "from ind2[OF lens pn]"], ["proof (chain)\npicking this:\n  length s2 \\<le> length s1", "have \"length s2 \\<le> length s1\""], ["proof (prove)\nusing this:\n  length s2 \\<le> length s1\n\ngoal (1 subgoal):\n 1. length s2 \\<le> length s1", "."], ["proof (state)\nthis:\n  length s2 \\<le> length s1\n\ngoal (2 subgoals):\n 1. hd s \\<noteq> CHR ''<'' \\<Longrightarrow> length r \\<le> length s\n 2. \\<not> hd s \\<noteq> CHR ''<'' \\<Longrightarrow> length r \\<le> length s", "then"], ["proof (chain)\npicking this:\n  length s2 \\<le> length s1", "show ?thesis"], ["proof (prove)\nusing this:\n  length s2 \\<le> length s1\n\ngoal (1 subgoal):\n 1. length r \\<le> length s", "using lens"], ["proof (prove)\nusing this:\n  length s2 \\<le> length s1\n  length s1 < length s\n\ngoal (1 subgoal):\n 1. length r \\<le> length s", "unfolding r"], ["proof (prove)\nusing this:\n  length s2 \\<le> length s1\n  length s1 < length s\n\ngoal (1 subgoal):\n 1. length s2 \\<le> length s", "by auto"], ["proof (state)\nthis:\n  length r \\<le> length s\n\ngoal (1 subgoal):\n 1. \\<not> hd s \\<noteq> CHR ''<'' \\<Longrightarrow> length r \\<le> length s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> hd s \\<noteq> CHR ''<'' \\<Longrightarrow> length r \\<le> length s", "case False"], ["proof (state)\nthis:\n  \\<not> hd s \\<noteq> CHR ''<''\n\ngoal (1 subgoal):\n 1. \\<not> hd s \\<noteq> CHR ''<'' \\<Longrightarrow> length r \\<le> length s", "note ooFalse = this"], ["proof (state)\nthis:\n  \\<not> hd s \\<noteq> CHR ''<''\n\ngoal (1 subgoal):\n 1. \\<not> hd s \\<noteq> CHR ''<'' \\<Longrightarrow> length r \\<le> length s", "note res = res[simplified oFalse ooFalse, simplified]"], ["proof (state)\nthis:\n  (exactly ''<'' \\<bind>\n   (\\<lambda>_.\n       parse_name \\<bind>\n       (\\<lambda>n.\n           parse_attributes \\<bind>\n           (\\<lambda>atts.\n               oneof [''/>'', ''>''] \\<bind>\n               (\\<lambda>e ts'.\n                   if e = ''/>''\n                   then (parse_nodes \\<bind>\n                         (\\<lambda>cs.\n                             Parser_Monad.return (XML n atts [] # cs)))\n                         ts'\n                   else (parse_nodes \\<bind>\n                         (\\<lambda>cs.\n                             exactly ''</'' \\<bind>\n                             (\\<lambda>_.\n                                 exactly n \\<bind>\n                                 (\\<lambda>_.\n                                     exactly ''>'' \\<bind>\n                                     (\\<lambda>_.\n   parse_nodes \\<bind>\n   (\\<lambda>ns. Parser_Monad.return (XML n atts cs # ns)))))))\n                         ts')))))\n   s =\n  Inr (x, r)\n\ngoal (1 subgoal):\n 1. \\<not> hd s \\<noteq> CHR ''<'' \\<Longrightarrow> length r \\<le> length s", "from res"], ["proof (chain)\npicking this:\n  (exactly ''<'' \\<bind>\n   (\\<lambda>_.\n       parse_name \\<bind>\n       (\\<lambda>n.\n           parse_attributes \\<bind>\n           (\\<lambda>atts.\n               oneof [''/>'', ''>''] \\<bind>\n               (\\<lambda>e ts'.\n                   if e = ''/>''\n                   then (parse_nodes \\<bind>\n                         (\\<lambda>cs.\n                             Parser_Monad.return (XML n atts [] # cs)))\n                         ts'\n                   else (parse_nodes \\<bind>\n                         (\\<lambda>cs.\n                             exactly ''</'' \\<bind>\n                             (\\<lambda>_.\n                                 exactly n \\<bind>\n                                 (\\<lambda>_.\n                                     exactly ''>'' \\<bind>\n                                     (\\<lambda>_.\n   parse_nodes \\<bind>\n   (\\<lambda>ns. Parser_Monad.return (XML n atts cs # ns)))))))\n                         ts')))))\n   s =\n  Inr (x, r)", "obtain y1 s1 where oo: \"exactly ''<'' s = Inr (y1, s1)\""], ["proof (prove)\nusing this:\n  (exactly ''<'' \\<bind>\n   (\\<lambda>_.\n       parse_name \\<bind>\n       (\\<lambda>n.\n           parse_attributes \\<bind>\n           (\\<lambda>atts.\n               oneof [''/>'', ''>''] \\<bind>\n               (\\<lambda>e ts'.\n                   if e = ''/>''\n                   then (parse_nodes \\<bind>\n                         (\\<lambda>cs.\n                             Parser_Monad.return (XML n atts [] # cs)))\n                         ts'\n                   else (parse_nodes \\<bind>\n                         (\\<lambda>cs.\n                             exactly ''</'' \\<bind>\n                             (\\<lambda>_.\n                                 exactly n \\<bind>\n                                 (\\<lambda>_.\n                                     exactly ''>'' \\<bind>\n                                     (\\<lambda>_.\n   parse_nodes \\<bind>\n   (\\<lambda>ns. Parser_Monad.return (XML n atts cs # ns)))))))\n                         ts')))))\n   s =\n  Inr (x, r)\n\ngoal (1 subgoal):\n 1. (\\<And>y1 s1.\n        exactly ''<'' s = Inr (y1, s1) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"exactly ''<'' s\", auto simp: bind_def)"], ["proof (state)\nthis:\n  exactly ''<'' s = Inr (y1, s1)\n\ngoal (1 subgoal):\n 1. \\<not> hd s \\<noteq> CHR ''<'' \\<Longrightarrow> length r \\<le> length s", "note res = res[unfolded bind_def oo, simplified]"], ["proof (state)\nthis:\n  parse_name s1 \\<bind>\n  (\\<lambda>(n, ts).\n      parse_attributes ts \\<bind>\n      (\\<lambda>(atts, ts).\n          oneof [''/>'', ''>''] ts \\<bind>\n          (\\<lambda>(e, ts').\n              if e = ''/>''\n              then parse_nodes ts' \\<bind>\n                   (\\<lambda>(cs, y).\n                       Parser_Monad.return (XML n atts [] # cs) y)\n              else parse_nodes ts' \\<bind>\n                   (\\<lambda>(cs, ts).\n                       exactly ''</'' ts \\<bind>\n                       (\\<lambda>(uu_, ts).\n                           exactly n ts \\<bind>\n                           (\\<lambda>(uu_, ts).\n                               exactly ''>'' ts \\<bind>\n                               (\\<lambda>(uu_, ts).\n                                   parse_nodes ts \\<bind>\n                                   (\\<lambda>(ns, y).\n Parser_Monad.return (XML n atts cs # ns) y)))))))) =\n  Inr (x, r)\n\ngoal (1 subgoal):\n 1. \\<not> hd s \\<noteq> CHR ''<'' \\<Longrightarrow> length r \\<le> length s", "from res"], ["proof (chain)\npicking this:\n  parse_name s1 \\<bind>\n  (\\<lambda>(n, ts).\n      parse_attributes ts \\<bind>\n      (\\<lambda>(atts, ts).\n          oneof [''/>'', ''>''] ts \\<bind>\n          (\\<lambda>(e, ts').\n              if e = ''/>''\n              then parse_nodes ts' \\<bind>\n                   (\\<lambda>(cs, y).\n                       Parser_Monad.return (XML n atts [] # cs) y)\n              else parse_nodes ts' \\<bind>\n                   (\\<lambda>(cs, ts).\n                       exactly ''</'' ts \\<bind>\n                       (\\<lambda>(uu_, ts).\n                           exactly n ts \\<bind>\n                           (\\<lambda>(uu_, ts).\n                               exactly ''>'' ts \\<bind>\n                               (\\<lambda>(uu_, ts).\n                                   parse_nodes ts \\<bind>\n                                   (\\<lambda>(ns, y).\n Parser_Monad.return (XML n atts cs # ns) y)))))))) =\n  Inr (x, r)", "obtain y2 s2\n          where pn: \"parse_name s1 = Inr (y2, s2)\""], ["proof (prove)\nusing this:\n  parse_name s1 \\<bind>\n  (\\<lambda>(n, ts).\n      parse_attributes ts \\<bind>\n      (\\<lambda>(atts, ts).\n          oneof [''/>'', ''>''] ts \\<bind>\n          (\\<lambda>(e, ts').\n              if e = ''/>''\n              then parse_nodes ts' \\<bind>\n                   (\\<lambda>(cs, y).\n                       Parser_Monad.return (XML n atts [] # cs) y)\n              else parse_nodes ts' \\<bind>\n                   (\\<lambda>(cs, ts).\n                       exactly ''</'' ts \\<bind>\n                       (\\<lambda>(uu_, ts).\n                           exactly n ts \\<bind>\n                           (\\<lambda>(uu_, ts).\n                               exactly ''>'' ts \\<bind>\n                               (\\<lambda>(uu_, ts).\n                                   parse_nodes ts \\<bind>\n                                   (\\<lambda>(ns, y).\n Parser_Monad.return (XML n atts cs # ns) y)))))))) =\n  Inr (x, r)\n\ngoal (1 subgoal):\n 1. (\\<And>y2 s2.\n        parse_name s1 = Inr (y2, s2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"parse_name s1\") (auto simp: bind_def psimps)"], ["proof (state)\nthis:\n  parse_name s1 = Inr (y2, s2)\n\ngoal (1 subgoal):\n 1. \\<not> hd s \\<noteq> CHR ''<'' \\<Longrightarrow> length r \\<le> length s", "note res = res[simplified bind_def pn, simplified]"], ["proof (state)\nthis:\n  parse_attributes s2 \\<bind>\n  (\\<lambda>(atts, ts).\n      oneof [''/>'', ''>''] ts \\<bind>\n      (\\<lambda>(e, ts').\n          if e = ''/>''\n          then parse_nodes ts' \\<bind>\n               (\\<lambda>(cs, y).\n                   Parser_Monad.return (XML y2 atts [] # cs) y)\n          else parse_nodes ts' \\<bind>\n               (\\<lambda>(cs, ts).\n                   exactly ''</'' ts \\<bind>\n                   (\\<lambda>(uu_, ts).\n                       exactly y2 ts \\<bind>\n                       (\\<lambda>(uu_, ts).\n                           exactly ''>'' ts \\<bind>\n                           (\\<lambda>(uu_, ts).\n                               parse_nodes ts \\<bind>\n                               (\\<lambda>(ns, y).\n                                   Parser_Monad.return (XML y2 atts cs # ns)\n                                    y))))))) =\n  Inr (x, r)\n\ngoal (1 subgoal):\n 1. \\<not> hd s \\<noteq> CHR ''<'' \\<Longrightarrow> length r \\<le> length s", "from res"], ["proof (chain)\npicking this:\n  parse_attributes s2 \\<bind>\n  (\\<lambda>(atts, ts).\n      oneof [''/>'', ''>''] ts \\<bind>\n      (\\<lambda>(e, ts').\n          if e = ''/>''\n          then parse_nodes ts' \\<bind>\n               (\\<lambda>(cs, y).\n                   Parser_Monad.return (XML y2 atts [] # cs) y)\n          else parse_nodes ts' \\<bind>\n               (\\<lambda>(cs, ts).\n                   exactly ''</'' ts \\<bind>\n                   (\\<lambda>(uu_, ts).\n                       exactly y2 ts \\<bind>\n                       (\\<lambda>(uu_, ts).\n                           exactly ''>'' ts \\<bind>\n                           (\\<lambda>(uu_, ts).\n                               parse_nodes ts \\<bind>\n                               (\\<lambda>(ns, y).\n                                   Parser_Monad.return (XML y2 atts cs # ns)\n                                    y))))))) =\n  Inr (x, r)", "obtain y3 s3 where pa: \"parse_attributes s2 = Inr (y3, s3)\""], ["proof (prove)\nusing this:\n  parse_attributes s2 \\<bind>\n  (\\<lambda>(atts, ts).\n      oneof [''/>'', ''>''] ts \\<bind>\n      (\\<lambda>(e, ts').\n          if e = ''/>''\n          then parse_nodes ts' \\<bind>\n               (\\<lambda>(cs, y).\n                   Parser_Monad.return (XML y2 atts [] # cs) y)\n          else parse_nodes ts' \\<bind>\n               (\\<lambda>(cs, ts).\n                   exactly ''</'' ts \\<bind>\n                   (\\<lambda>(uu_, ts).\n                       exactly y2 ts \\<bind>\n                       (\\<lambda>(uu_, ts).\n                           exactly ''>'' ts \\<bind>\n                           (\\<lambda>(uu_, ts).\n                               parse_nodes ts \\<bind>\n                               (\\<lambda>(ns, y).\n                                   Parser_Monad.return (XML y2 atts cs # ns)\n                                    y))))))) =\n  Inr (x, r)\n\ngoal (1 subgoal):\n 1. (\\<And>y3 s3.\n        parse_attributes s2 = Inr (y3, s3) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"parse_attributes s2\") (auto simp: return_def bind_def)"], ["proof (state)\nthis:\n  parse_attributes s2 = Inr (y3, s3)\n\ngoal (1 subgoal):\n 1. \\<not> hd s \\<noteq> CHR ''<'' \\<Longrightarrow> length r \\<le> length s", "note res = res[simplified pa, simplified]"], ["proof (state)\nthis:\n  oneof [''/>'', ''>''] s3 \\<bind>\n  (\\<lambda>(e, ts').\n      if e = ''/>''\n      then parse_nodes ts' \\<bind>\n           (\\<lambda>(cs, y). Parser_Monad.return (XML y2 y3 [] # cs) y)\n      else parse_nodes ts' \\<bind>\n           (\\<lambda>(cs, ts).\n               exactly ''</'' ts \\<bind>\n               (\\<lambda>(uu_, ts).\n                   exactly y2 ts \\<bind>\n                   (\\<lambda>(uu_, ts).\n                       exactly ''>'' ts \\<bind>\n                       (\\<lambda>(uu_, ts).\n                           parse_nodes ts \\<bind>\n                           (\\<lambda>(ns, y).\n                               Parser_Monad.return (XML y2 y3 cs # ns)\n                                y)))))) =\n  Inr (x, r)\n\ngoal (1 subgoal):\n 1. \\<not> hd s \\<noteq> CHR ''<'' \\<Longrightarrow> length r \\<le> length s", "from res"], ["proof (chain)\npicking this:\n  oneof [''/>'', ''>''] s3 \\<bind>\n  (\\<lambda>(e, ts').\n      if e = ''/>''\n      then parse_nodes ts' \\<bind>\n           (\\<lambda>(cs, y). Parser_Monad.return (XML y2 y3 [] # cs) y)\n      else parse_nodes ts' \\<bind>\n           (\\<lambda>(cs, ts).\n               exactly ''</'' ts \\<bind>\n               (\\<lambda>(uu_, ts).\n                   exactly y2 ts \\<bind>\n                   (\\<lambda>(uu_, ts).\n                       exactly ''>'' ts \\<bind>\n                       (\\<lambda>(uu_, ts).\n                           parse_nodes ts \\<bind>\n                           (\\<lambda>(ns, y).\n                               Parser_Monad.return (XML y2 y3 cs # ns)\n                                y)))))) =\n  Inr (x, r)", "obtain y4 s4\n          where oo2: \"oneof [''/>'', ''>''] s3 = Inr (y4, s4)\""], ["proof (prove)\nusing this:\n  oneof [''/>'', ''>''] s3 \\<bind>\n  (\\<lambda>(e, ts').\n      if e = ''/>''\n      then parse_nodes ts' \\<bind>\n           (\\<lambda>(cs, y). Parser_Monad.return (XML y2 y3 [] # cs) y)\n      else parse_nodes ts' \\<bind>\n           (\\<lambda>(cs, ts).\n               exactly ''</'' ts \\<bind>\n               (\\<lambda>(uu_, ts).\n                   exactly y2 ts \\<bind>\n                   (\\<lambda>(uu_, ts).\n                       exactly ''>'' ts \\<bind>\n                       (\\<lambda>(uu_, ts).\n                           parse_nodes ts \\<bind>\n                           (\\<lambda>(ns, y).\n                               Parser_Monad.return (XML y2 y3 cs # ns)\n                                y)))))) =\n  Inr (x, r)\n\ngoal (1 subgoal):\n 1. (\\<And>y4 s4.\n        oneof [''/>'', ''>''] s3 = Inr (y4, s4) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"oneof [''/>'', ''>''] s3\") (auto simp: return_def bind_def)"], ["proof (state)\nthis:\n  oneof [''/>'', ''>''] s3 = Inr (y4, s4)\n\ngoal (1 subgoal):\n 1. \\<not> hd s \\<noteq> CHR ''<'' \\<Longrightarrow> length r \\<le> length s", "note res = res[unfolded oo2, simplified]"], ["proof (state)\nthis:\n  (if y4 = ''/>''\n   then parse_nodes s4 \\<bind>\n        (\\<lambda>(cs, y). Parser_Monad.return (XML y2 y3 [] # cs) y)\n   else parse_nodes s4 \\<bind>\n        (\\<lambda>(cs, ts).\n            exactly ''</'' ts \\<bind>\n            (\\<lambda>(uu_, ts).\n                exactly y2 ts \\<bind>\n                (\\<lambda>(uu_, ts).\n                    exactly ''>'' ts \\<bind>\n                    (\\<lambda>(uu_, ts).\n                        parse_nodes ts \\<bind>\n                        (\\<lambda>(ns, y).\n                            Parser_Monad.return (XML y2 y3 cs # ns)\n                             y)))))) =\n  Inr (x, r)\n\ngoal (1 subgoal):\n 1. \\<not> hd s \\<noteq> CHR ''<'' \\<Longrightarrow> length r \\<le> length s", "from is_parser_parse_attributes and is_parser_oneof [of \"[''/>'', ''>'']\"]\n          and is_cparser_exactly [of \"''<''\", simplified] and is_parser_parse_name\n          and oo pn pa oo2"], ["proof (chain)\npicking this:\n  is_parser parse_attributes\n  is_parser (oneof [''/>'', ''>''])\n  is_cparser (exactly ''<'')\n  is_parser parse_name\n  exactly ''<'' s = Inr (y1, s1)\n  parse_name s1 = Inr (y2, s2)\n  parse_attributes s2 = Inr (y3, s3)\n  oneof [''/>'', ''>''] s3 = Inr (y4, s4)", "have s_s4: \"length s > length s4\""], ["proof (prove)\nusing this:\n  is_parser parse_attributes\n  is_parser (oneof [''/>'', ''>''])\n  is_cparser (exactly ''<'')\n  is_parser parse_name\n  exactly ''<'' s = Inr (y1, s1)\n  parse_name s1 = Inr (y2, s2)\n  parse_attributes s2 = Inr (y3, s3)\n  oneof [''/>'', ''>''] s3 = Inr (y4, s4)\n\ngoal (1 subgoal):\n 1. length s4 < length s", "by (auto dest!: is_parser_length is_cparser_length)"], ["proof (state)\nthis:\n  length s4 < length s\n\ngoal (1 subgoal):\n 1. \\<not> hd s \\<noteq> CHR ''<'' \\<Longrightarrow> length r \\<le> length s", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. length r \\<le> length s", "proof (cases \"y4 = ''/>''\")"], ["proof (state)\ngoal (2 subgoals):\n 1. y4 = ''/>'' \\<Longrightarrow> length r \\<le> length s\n 2. y4 \\<noteq> ''/>'' \\<Longrightarrow> length r \\<le> length s", "case True"], ["proof (state)\nthis:\n  y4 = ''/>''\n\ngoal (2 subgoals):\n 1. y4 = ''/>'' \\<Longrightarrow> length r \\<le> length s\n 2. y4 \\<noteq> ''/>'' \\<Longrightarrow> length r \\<le> length s", "from res True"], ["proof (chain)\npicking this:\n  (if y4 = ''/>''\n   then parse_nodes s4 \\<bind>\n        (\\<lambda>(cs, y). Parser_Monad.return (XML y2 y3 [] # cs) y)\n   else parse_nodes s4 \\<bind>\n        (\\<lambda>(cs, ts).\n            exactly ''</'' ts \\<bind>\n            (\\<lambda>(uu_, ts).\n                exactly y2 ts \\<bind>\n                (\\<lambda>(uu_, ts).\n                    exactly ''>'' ts \\<bind>\n                    (\\<lambda>(uu_, ts).\n                        parse_nodes ts \\<bind>\n                        (\\<lambda>(ns, y).\n                            Parser_Monad.return (XML y2 y3 cs # ns)\n                             y)))))) =\n  Inr (x, r)\n  y4 = ''/>''", "obtain y5\n            where pns: \"parse_nodes s4 = Inr (y5, r)\""], ["proof (prove)\nusing this:\n  (if y4 = ''/>''\n   then parse_nodes s4 \\<bind>\n        (\\<lambda>(cs, y). Parser_Monad.return (XML y2 y3 [] # cs) y)\n   else parse_nodes s4 \\<bind>\n        (\\<lambda>(cs, ts).\n            exactly ''</'' ts \\<bind>\n            (\\<lambda>(uu_, ts).\n                exactly y2 ts \\<bind>\n                (\\<lambda>(uu_, ts).\n                    exactly ''>'' ts \\<bind>\n                    (\\<lambda>(uu_, ts).\n                        parse_nodes ts \\<bind>\n                        (\\<lambda>(ns, y).\n                            Parser_Monad.return (XML y2 y3 cs # ns)\n                             y)))))) =\n  Inr (x, r)\n  y4 = ''/>''\n\ngoal (1 subgoal):\n 1. (\\<And>y5.\n        parse_nodes s4 = Inr (y5, r) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"parse_nodes s4\") (auto simp: return_def bind_def)"], ["proof (state)\nthis:\n  parse_nodes s4 = Inr (y5, r)\n\ngoal (2 subgoals):\n 1. y4 = ''/>'' \\<Longrightarrow> length r \\<le> length s\n 2. y4 \\<noteq> ''/>'' \\<Longrightarrow> length r \\<le> length s", "from ind2[OF s_s4 pns] s_s4"], ["proof (chain)\npicking this:\n  length r \\<le> length s4\n  length s4 < length s", "show \"length r \\<le> length s\""], ["proof (prove)\nusing this:\n  length r \\<le> length s4\n  length s4 < length s\n\ngoal (1 subgoal):\n 1. length r \\<le> length s", "by simp"], ["proof (state)\nthis:\n  length r \\<le> length s\n\ngoal (1 subgoal):\n 1. y4 \\<noteq> ''/>'' \\<Longrightarrow> length r \\<le> length s", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. y4 \\<noteq> ''/>'' \\<Longrightarrow> length r \\<le> length s", "case False"], ["proof (state)\nthis:\n  y4 \\<noteq> ''/>''\n\ngoal (1 subgoal):\n 1. y4 \\<noteq> ''/>'' \\<Longrightarrow> length r \\<le> length s", "note res = res[simplified False, simplified]"], ["proof (state)\nthis:\n  parse_nodes s4 \\<bind>\n  (\\<lambda>(cs, ts).\n      exactly ''</'' ts \\<bind>\n      (\\<lambda>(uu_, ts).\n          exactly y2 ts \\<bind>\n          (\\<lambda>(uu_, ts).\n              exactly ''>'' ts \\<bind>\n              (\\<lambda>(uu_, ts).\n                  parse_nodes ts \\<bind>\n                  (\\<lambda>(ns, y).\n                      Parser_Monad.return (XML y2 y3 cs # ns) y))))) =\n  Inr (x, r)\n\ngoal (1 subgoal):\n 1. y4 \\<noteq> ''/>'' \\<Longrightarrow> length r \\<le> length s", "from res"], ["proof (chain)\npicking this:\n  parse_nodes s4 \\<bind>\n  (\\<lambda>(cs, ts).\n      exactly ''</'' ts \\<bind>\n      (\\<lambda>(uu_, ts).\n          exactly y2 ts \\<bind>\n          (\\<lambda>(uu_, ts).\n              exactly ''>'' ts \\<bind>\n              (\\<lambda>(uu_, ts).\n                  parse_nodes ts \\<bind>\n                  (\\<lambda>(ns, y).\n                      Parser_Monad.return (XML y2 y3 cs # ns) y))))) =\n  Inr (x, r)", "obtain y6 s6 where pns: \"parse_nodes s4 = Inr (y6, s6)\""], ["proof (prove)\nusing this:\n  parse_nodes s4 \\<bind>\n  (\\<lambda>(cs, ts).\n      exactly ''</'' ts \\<bind>\n      (\\<lambda>(uu_, ts).\n          exactly y2 ts \\<bind>\n          (\\<lambda>(uu_, ts).\n              exactly ''>'' ts \\<bind>\n              (\\<lambda>(uu_, ts).\n                  parse_nodes ts \\<bind>\n                  (\\<lambda>(ns, y).\n                      Parser_Monad.return (XML y2 y3 cs # ns) y))))) =\n  Inr (x, r)\n\ngoal (1 subgoal):\n 1. (\\<And>y6 s6.\n        parse_nodes s4 = Inr (y6, s6) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"parse_nodes s4\") (auto simp: return_def bind_def)"], ["proof (state)\nthis:\n  parse_nodes s4 = Inr (y6, s6)\n\ngoal (1 subgoal):\n 1. y4 \\<noteq> ''/>'' \\<Longrightarrow> length r \\<le> length s", "note res = res[unfolded bind_def pns, simplified, unfolded bind_def]"], ["proof (state)\nthis:\n  exactly ''</'' s6 \\<bind>\n  (\\<lambda>(uu_, ts).\n      exactly y2 ts \\<bind>\n      (\\<lambda>(uu_, ts).\n          exactly ''>'' ts \\<bind>\n          (\\<lambda>(uu_, ts).\n              parse_nodes ts \\<bind>\n              (\\<lambda>(ns, y).\n                  Parser_Monad.return (XML y2 y3 y6 # ns) y)))) =\n  Inr (x, r)\n\ngoal (1 subgoal):\n 1. y4 \\<noteq> ''/>'' \\<Longrightarrow> length r \\<le> length s", "from res"], ["proof (chain)\npicking this:\n  exactly ''</'' s6 \\<bind>\n  (\\<lambda>(uu_, ts).\n      exactly y2 ts \\<bind>\n      (\\<lambda>(uu_, ts).\n          exactly ''>'' ts \\<bind>\n          (\\<lambda>(uu_, ts).\n              parse_nodes ts \\<bind>\n              (\\<lambda>(ns, y).\n                  Parser_Monad.return (XML y2 y3 y6 # ns) y)))) =\n  Inr (x, r)", "obtain y7 s7 where oo3: \"exactly ''</'' s6 = Inr (y7, s7)\""], ["proof (prove)\nusing this:\n  exactly ''</'' s6 \\<bind>\n  (\\<lambda>(uu_, ts).\n      exactly y2 ts \\<bind>\n      (\\<lambda>(uu_, ts).\n          exactly ''>'' ts \\<bind>\n          (\\<lambda>(uu_, ts).\n              parse_nodes ts \\<bind>\n              (\\<lambda>(ns, y).\n                  Parser_Monad.return (XML y2 y3 y6 # ns) y)))) =\n  Inr (x, r)\n\ngoal (1 subgoal):\n 1. (\\<And>y7 s7.\n        exactly ''</'' s6 = Inr (y7, s7) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"exactly ''</'' s6\", auto)"], ["proof (state)\nthis:\n  exactly ''</'' s6 = Inr (y7, s7)\n\ngoal (1 subgoal):\n 1. y4 \\<noteq> ''/>'' \\<Longrightarrow> length r \\<le> length s", "note res = res[unfolded oo3, simplified, unfolded bind_def, \n            simplified, unfolded bind_def]"], ["proof (state)\nthis:\n  exactly y2 s7 \\<bind>\n  (\\<lambda>(uu_, ts).\n      exactly ''>'' ts \\<bind>\n      (\\<lambda>(uu_, ts).\n          parse_nodes ts \\<bind>\n          (\\<lambda>(ns, y). Parser_Monad.return (XML y2 y3 y6 # ns) y))) =\n  Inr (x, r)\n\ngoal (1 subgoal):\n 1. y4 \\<noteq> ''/>'' \\<Longrightarrow> length r \\<le> length s", "from res"], ["proof (chain)\npicking this:\n  exactly y2 s7 \\<bind>\n  (\\<lambda>(uu_, ts).\n      exactly ''>'' ts \\<bind>\n      (\\<lambda>(uu_, ts).\n          parse_nodes ts \\<bind>\n          (\\<lambda>(ns, y). Parser_Monad.return (XML y2 y3 y6 # ns) y))) =\n  Inr (x, r)", "obtain y8 s8 where oo4: \"exactly y2 s7 = Inr (y8, s8)\""], ["proof (prove)\nusing this:\n  exactly y2 s7 \\<bind>\n  (\\<lambda>(uu_, ts).\n      exactly ''>'' ts \\<bind>\n      (\\<lambda>(uu_, ts).\n          parse_nodes ts \\<bind>\n          (\\<lambda>(ns, y). Parser_Monad.return (XML y2 y3 y6 # ns) y))) =\n  Inr (x, r)\n\ngoal (1 subgoal):\n 1. (\\<And>y8 s8.\n        exactly y2 s7 = Inr (y8, s8) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"exactly y2 s7\", auto)"], ["proof (state)\nthis:\n  exactly y2 s7 = Inr (y8, s8)\n\ngoal (1 subgoal):\n 1. y4 \\<noteq> ''/>'' \\<Longrightarrow> length r \\<le> length s", "note res = res[unfolded oo4 bind_def, simplified]"], ["proof (state)\nthis:\n  exactly ''>'' s8 \\<bind>\n  (\\<lambda>(uu_, ts).\n      parse_nodes ts \\<bind>\n      (\\<lambda>(ns, y). Parser_Monad.return (XML y2 y3 y6 # ns) y)) =\n  Inr (x, r)\n\ngoal (1 subgoal):\n 1. y4 \\<noteq> ''/>'' \\<Longrightarrow> length r \\<le> length s", "from res"], ["proof (chain)\npicking this:\n  exactly ''>'' s8 \\<bind>\n  (\\<lambda>(uu_, ts).\n      parse_nodes ts \\<bind>\n      (\\<lambda>(ns, y). Parser_Monad.return (XML y2 y3 y6 # ns) y)) =\n  Inr (x, r)", "obtain y10 s10 where oo5: \"exactly ''>'' s8 = Inr (y10,s10)\""], ["proof (prove)\nusing this:\n  exactly ''>'' s8 \\<bind>\n  (\\<lambda>(uu_, ts).\n      parse_nodes ts \\<bind>\n      (\\<lambda>(ns, y). Parser_Monad.return (XML y2 y3 y6 # ns) y)) =\n  Inr (x, r)\n\ngoal (1 subgoal):\n 1. (\\<And>y10 s10.\n        exactly ''>'' s8 = Inr (y10, s10) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"exactly ''>'' s8\", auto simp: bind_def)"], ["proof (state)\nthis:\n  exactly ''>'' s8 = Inr (y10, s10)\n\ngoal (1 subgoal):\n 1. y4 \\<noteq> ''/>'' \\<Longrightarrow> length r \\<le> length s", "note res = res[unfolded oo5 bind_def, simplified]"], ["proof (state)\nthis:\n  parse_nodes s10 \\<bind>\n  (\\<lambda>(ns, y). Parser_Monad.return (XML y2 y3 y6 # ns) y) =\n  Inr (x, r)\n\ngoal (1 subgoal):\n 1. y4 \\<noteq> ''/>'' \\<Longrightarrow> length r \\<le> length s", "from res"], ["proof (chain)\npicking this:\n  parse_nodes s10 \\<bind>\n  (\\<lambda>(ns, y). Parser_Monad.return (XML y2 y3 y6 # ns) y) =\n  Inr (x, r)", "obtain y11 s11 where pns2: \"parse_nodes s10 = Inr (y11, s11)\""], ["proof (prove)\nusing this:\n  parse_nodes s10 \\<bind>\n  (\\<lambda>(ns, y). Parser_Monad.return (XML y2 y3 y6 # ns) y) =\n  Inr (x, r)\n\ngoal (1 subgoal):\n 1. (\\<And>y11 s11.\n        parse_nodes s10 = Inr (y11, s11) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by (cases \"parse_nodes s10\", auto simp: bind_def)"], ["proof (state)\nthis:\n  parse_nodes s10 = Inr (y11, s11)\n\ngoal (1 subgoal):\n 1. y4 \\<noteq> ''/>'' \\<Longrightarrow> length r \\<le> length s", "note res = res[unfolded bind_def pns2, simplified]"], ["proof (state)\nthis:\n  Parser_Monad.return (XML y2 y3 y6 # y11) s11 = Inr (x, r)\n\ngoal (1 subgoal):\n 1. y4 \\<noteq> ''/>'' \\<Longrightarrow> length r \\<le> length s", "note one = is_parser_oneof [unfolded is_parser_def, rule_format]"], ["proof (state)\nthis:\n  oneof ?ts ?s = Inr (?x, ?r) \\<Longrightarrow> length ?r \\<le> length ?s\n\ngoal (1 subgoal):\n 1. y4 \\<noteq> ''/>'' \\<Longrightarrow> length r \\<le> length s", "note exact = is_parser_exactly [unfolded is_parser_def, rule_format]"], ["proof (state)\nthis:\n  exactly ?xs ?s = Inr (?x, ?r) \\<Longrightarrow> length ?r \\<le> length ?s\n\ngoal (1 subgoal):\n 1. y4 \\<noteq> ''/>'' \\<Longrightarrow> length r \\<le> length s", "from ind2[OF s_s4 pns] s_s4 exact[OF oo3] exact[OF oo4]"], ["proof (chain)\npicking this:\n  length s6 \\<le> length s4\n  length s4 < length s\n  length s7 \\<le> length s6\n  length s8 \\<le> length s7", "have s_s7: \"length s > length s8\""], ["proof (prove)\nusing this:\n  length s6 \\<le> length s4\n  length s4 < length s\n  length s7 \\<le> length s6\n  length s8 \\<le> length s7\n\ngoal (1 subgoal):\n 1. length s8 < length s", "unfolding is_parser_def"], ["proof (prove)\nusing this:\n  length s6 \\<le> length s4\n  length s4 < length s\n  length s7 \\<le> length s6\n  length s8 \\<le> length s7\n\ngoal (1 subgoal):\n 1. length s8 < length s", "by force"], ["proof (state)\nthis:\n  length s8 < length s\n\ngoal (1 subgoal):\n 1. y4 \\<noteq> ''/>'' \\<Longrightarrow> length r \\<le> length s", "with exact[OF oo5]"], ["proof (chain)\npicking this:\n  length s10 \\<le> length s8\n  length s8 < length s", "have s_s10: \"length s > length s10\""], ["proof (prove)\nusing this:\n  length s10 \\<le> length s8\n  length s8 < length s\n\ngoal (1 subgoal):\n 1. length s10 < length s", "by simp"], ["proof (state)\nthis:\n  length s10 < length s\n\ngoal (1 subgoal):\n 1. y4 \\<noteq> ''/>'' \\<Longrightarrow> length r \\<le> length s", "with ind2[OF s_s10 pns2]"], ["proof (chain)\npicking this:\n  length s11 \\<le> length s10\n  length s10 < length s", "have s_s11: \"length s > length s11\""], ["proof (prove)\nusing this:\n  length s11 \\<le> length s10\n  length s10 < length s\n\ngoal (1 subgoal):\n 1. length s11 < length s", "by simp"], ["proof (state)\nthis:\n  length s11 < length s\n\ngoal (1 subgoal):\n 1. y4 \\<noteq> ''/>'' \\<Longrightarrow> length r \\<le> length s", "then"], ["proof (chain)\npicking this:\n  length s11 < length s", "show \"length r \\<le> length s\""], ["proof (prove)\nusing this:\n  length s11 < length s\n\ngoal (1 subgoal):\n 1. length r \\<le> length s", "using res"], ["proof (prove)\nusing this:\n  length s11 < length s\n  Parser_Monad.return (XML y2 y3 y6 # y11) s11 = Inr (x, r)\n\ngoal (1 subgoal):\n 1. length r \\<le> length s", "by (auto simp: return_def)"], ["proof (state)\nthis:\n  length r \\<le> length s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length r \\<le> length s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length r \\<le> length s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  length r \\<le> length s\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  parse_nodes_dom s \\<and>\n  (\\<forall>x r.\n      parse_nodes s = Inr (x, r) \\<longrightarrow> length r \\<le> length s)\n\ngoal (1 subgoal):\n 1. wf (measure length)", "qed simp"], ["", "termination parse_nodes"], ["proof (prove)\ngoal (1 subgoal):\n 1. All parse_nodes_dom", "using parse_nodes_help"], ["proof (prove)\nusing this:\n  parse_nodes_dom ?s \\<and>\n  (\\<forall>x r.\n      parse_nodes ?s = Inr (x, r) \\<longrightarrow>\n      length r \\<le> length ?s)\n\ngoal (1 subgoal):\n 1. All parse_nodes_dom", "by blast"], ["", "lemma parse_nodes [intro]:\n  \"is_parser parse_nodes\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_parser parse_nodes", "unfolding is_parser_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<forall>s r x.\n       parse_nodes s = Inr (x, r) \\<longrightarrow> length r \\<le> length s", "using parse_nodes_help"], ["proof (prove)\nusing this:\n  parse_nodes_dom ?s \\<and>\n  (\\<forall>x r.\n      parse_nodes ?s = Inr (x, r) \\<longrightarrow>\n      length r \\<le> length ?s)\n\ngoal (1 subgoal):\n 1. \\<forall>s r x.\n       parse_nodes s = Inr (x, r) \\<longrightarrow> length r \\<le> length s", "by blast"], ["", "text \\<open>A more efficient variant of @{term \"oneof [''/>'', ''>'']\"}.\\<close>"], ["", "fun oneof_closed :: \"string parser\"\nwhere\n  \"oneof_closed (x # xs) =\n    (if x = CHR ''>'' then Error_Monad.return (''>'', trim xs)\n    else if x = CHR ''/'' \\<and> (case xs of [] \\<Rightarrow> False | y # ys \\<Rightarrow> y = CHR ''>'') then\n      Error_Monad.return (''/>'', trim (tl xs))\n    else err_expecting (''one of [/>, >]'') (x # xs))\" |\n  \"oneof_closed xs = err_expecting (''one of [/>, >]'') xs\""], ["", "lemma oneof_closed:\n  \"oneof [''/>'', ''>''] = oneof_closed\" (is \"?l = ?r\")"], ["proof (prove)\ngoal (1 subgoal):\n 1. oneof [''/>'', ''>''] = oneof_closed", "proof (rule ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. oneof [''/>'', ''>''] x = oneof_closed x", "fix xs"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x. oneof [''/>'', ''>''] x = oneof_closed x", "have id: \"''one of '' @ shows_list [''/>'', ''>''] [] = ''one of [/>, >]''\""], ["proof (prove)\ngoal (1 subgoal):\n 1. ''one of '' @ shows_list [''/>'', ''>''] [] = ''one of [/>, >]''", "by (simp add: shows_list_list_def showsp_list_def pshowsp_list_def shows_list_gen_def\n                  shows_string_def shows_prec_list_def shows_list_char_def)"], ["proof (state)\nthis:\n  ''one of '' @ shows_list [''/>'', ''>''] [] = ''one of [/>, >]''\n\ngoal (1 subgoal):\n 1. \\<And>x. oneof [''/>'', ''>''] x = oneof_closed x", "note d = oneof_def oneof_aux.simps id"], ["proof (state)\nthis:\n  oneof ?xs = ??.Parser_Monad.oneof_aux ?xs ?xs\n  ??.Parser_Monad.oneof_aux ?allowed (?x # ?xs) ?ts =\n  (if map snd (zip ?x ?ts) = ?x then Inr (?x, trim (drop (length ?x) ?ts))\n   else ??.Parser_Monad.oneof_aux ?allowed ?xs ?ts)\n  ??.Parser_Monad.oneof_aux ?allowed [] ?ts =\n  err_expecting (''one of '' @ shows_list ?allowed []) ?ts\n  ''one of '' @ shows_list [''/>'', ''>''] [] = ''one of [/>, >]''\n\ngoal (1 subgoal):\n 1. \\<And>x. oneof [''/>'', ''>''] x = oneof_closed x", "show \"?l xs = ?r xs\""], ["proof (prove)\ngoal (1 subgoal):\n 1. oneof [''/>'', ''>''] xs = oneof_closed xs", "proof (cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> oneof [''/>'', ''>''] xs = oneof_closed xs\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       oneof [''/>'', ''>''] xs = oneof_closed xs", "case Nil"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> oneof [''/>'', ''>''] xs = oneof_closed xs\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       oneof [''/>'', ''>''] xs = oneof_closed xs", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. oneof [''/>'', ''>''] xs = oneof_closed xs", "unfolding Nil d"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if map snd (zip ''/>'' []) = ''/>''\n     then Inr (''/>'', trim (drop (length ''/>'') []))\n     else if map snd (zip ''>'' []) = ''>''\n          then Inr (''>'', trim (drop (length ''>'') []))\n          else err_expecting ''one of [/>, >]'' []) =\n    oneof_closed []", "by simp"], ["proof (state)\nthis:\n  oneof [''/>'', ''>''] xs = oneof_closed xs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       oneof [''/>'', ''>''] xs = oneof_closed xs", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       oneof [''/>'', ''>''] xs = oneof_closed xs", "case (Cons x xs)"], ["proof (state)\nthis:\n  xs__ = x # xs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs__ = a # list \\<Longrightarrow>\n       oneof [''/>'', ''>''] xs__ = oneof_closed xs__", "note oCons = this"], ["proof (state)\nthis:\n  xs__ = x # xs\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs__ = a # list \\<Longrightarrow>\n       oneof [''/>'', ''>''] xs__ = oneof_closed xs__", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. oneof [''/>'', ''>''] xs__ = oneof_closed xs__", "proof (cases \"x = CHR ''>''\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = CHR ''>'' \\<Longrightarrow>\n    oneof [''/>'', ''>''] xs__ = oneof_closed xs__\n 2. x \\<noteq> CHR ''>'' \\<Longrightarrow>\n    oneof [''/>'', ''>''] xs__ = oneof_closed xs__", "case True"], ["proof (state)\nthis:\n  x = CHR ''>''\n\ngoal (2 subgoals):\n 1. x = CHR ''>'' \\<Longrightarrow>\n    oneof [''/>'', ''>''] xs__ = oneof_closed xs__\n 2. x \\<noteq> CHR ''>'' \\<Longrightarrow>\n    oneof [''/>'', ''>''] xs__ = oneof_closed xs__", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. oneof [''/>'', ''>''] xs__ = oneof_closed xs__", "unfolding Cons d True"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if map snd (zip ''/>'' (CHR ''>'' # xs)) = ''/>''\n     then Inr (''/>'', trim (drop (length ''/>'') (CHR ''>'' # xs)))\n     else if map snd (zip ''>'' (CHR ''>'' # xs)) = ''>''\n          then Inr (''>'', trim (drop (length ''>'') (CHR ''>'' # xs)))\n          else err_expecting ''one of [/>, >]'' (CHR ''>'' # xs)) =\n    oneof_closed (CHR ''>'' # xs)", "by simp"], ["proof (state)\nthis:\n  oneof [''/>'', ''>''] xs__ = oneof_closed xs__\n\ngoal (1 subgoal):\n 1. x \\<noteq> CHR ''>'' \\<Longrightarrow>\n    oneof [''/>'', ''>''] xs__ = oneof_closed xs__", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x \\<noteq> CHR ''>'' \\<Longrightarrow>\n    oneof [''/>'', ''>''] xs__ = oneof_closed xs__", "case False"], ["proof (state)\nthis:\n  x \\<noteq> CHR ''>''\n\ngoal (1 subgoal):\n 1. x \\<noteq> CHR ''>'' \\<Longrightarrow>\n    oneof [''/>'', ''>''] xs__ = oneof_closed xs__", "note oFalse = this"], ["proof (state)\nthis:\n  x \\<noteq> CHR ''>''\n\ngoal (1 subgoal):\n 1. x \\<noteq> CHR ''>'' \\<Longrightarrow>\n    oneof [''/>'', ''>''] xs__ = oneof_closed xs__", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. oneof [''/>'', ''>''] xs__ = oneof_closed xs__", "proof (cases \"x = CHR ''/''\")"], ["proof (state)\ngoal (2 subgoals):\n 1. x = CHR ''/'' \\<Longrightarrow>\n    oneof [''/>'', ''>''] xs__ = oneof_closed xs__\n 2. x \\<noteq> CHR ''/'' \\<Longrightarrow>\n    oneof [''/>'', ''>''] xs__ = oneof_closed xs__", "case False"], ["proof (state)\nthis:\n  x \\<noteq> CHR ''/''\n\ngoal (2 subgoals):\n 1. x = CHR ''/'' \\<Longrightarrow>\n    oneof [''/>'', ''>''] xs__ = oneof_closed xs__\n 2. x \\<noteq> CHR ''/'' \\<Longrightarrow>\n    oneof [''/>'', ''>''] xs__ = oneof_closed xs__", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. oneof [''/>'', ''>''] xs__ = oneof_closed xs__", "unfolding Cons d"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if map snd (zip ''/>'' (x # xs)) = ''/>''\n     then Inr (''/>'', trim (drop (length ''/>'') (x # xs)))\n     else if map snd (zip ''>'' (x # xs)) = ''>''\n          then Inr (''>'', trim (drop (length ''>'') (x # xs)))\n          else err_expecting ''one of [/>, >]'' (x # xs)) =\n    oneof_closed (x # xs)", "using False oFalse"], ["proof (prove)\nusing this:\n  x \\<noteq> CHR ''/''\n  x \\<noteq> CHR ''>''\n\ngoal (1 subgoal):\n 1. (if map snd (zip ''/>'' (x # xs)) = ''/>''\n     then Inr (''/>'', trim (drop (length ''/>'') (x # xs)))\n     else if map snd (zip ''>'' (x # xs)) = ''>''\n          then Inr (''>'', trim (drop (length ''>'') (x # xs)))\n          else err_expecting ''one of [/>, >]'' (x # xs)) =\n    oneof_closed (x # xs)", "by simp"], ["proof (state)\nthis:\n  oneof [''/>'', ''>''] xs__ = oneof_closed xs__\n\ngoal (1 subgoal):\n 1. x = CHR ''/'' \\<Longrightarrow>\n    oneof [''/>'', ''>''] xs__ = oneof_closed xs__", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. x = CHR ''/'' \\<Longrightarrow>\n    oneof [''/>'', ''>''] xs__ = oneof_closed xs__", "case True"], ["proof (state)\nthis:\n  x = CHR ''/''\n\ngoal (1 subgoal):\n 1. x = CHR ''/'' \\<Longrightarrow>\n    oneof [''/>'', ''>''] xs__ = oneof_closed xs__", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. oneof [''/>'', ''>''] xs__ = oneof_closed xs__", "proof (cases xs)"], ["proof (state)\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> oneof [''/>'', ''>''] xs__ = oneof_closed xs__\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       oneof [''/>'', ''>''] xs__ = oneof_closed xs__", "case Nil"], ["proof (state)\nthis:\n  xs = []\n\ngoal (2 subgoals):\n 1. xs = [] \\<Longrightarrow> oneof [''/>'', ''>''] xs__ = oneof_closed xs__\n 2. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       oneof [''/>'', ''>''] xs__ = oneof_closed xs__", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. oneof [''/>'', ''>''] xs__ = oneof_closed xs__", "unfolding Cons Nil d"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if map snd (zip ''/>'' [x]) = ''/>''\n     then Inr (''/>'', trim (drop (length ''/>'') [x]))\n     else if map snd (zip ''>'' [x]) = ''>''\n          then Inr (''>'', trim (drop (length ''>'') [x]))\n          else err_expecting ''one of [/>, >]'' [x]) =\n    oneof_closed [x]", "by auto"], ["proof (state)\nthis:\n  oneof [''/>'', ''>''] xs__ = oneof_closed xs__\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       oneof [''/>'', ''>''] xs__ = oneof_closed xs__", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       oneof [''/>'', ''>''] xs__ = oneof_closed xs__", "case (Cons y ys)"], ["proof (state)\nthis:\n  xs = y # ys\n\ngoal (1 subgoal):\n 1. \\<And>a list.\n       xs = a # list \\<Longrightarrow>\n       oneof [''/>'', ''>''] xs__ = oneof_closed xs__", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. oneof [''/>'', ''>''] xs__ = oneof_closed xs__", "unfolding oCons Cons d"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if map snd (zip ''/>'' (x # y # ys)) = ''/>''\n     then Inr (''/>'', trim (drop (length ''/>'') (x # y # ys)))\n     else if map snd (zip ''>'' (x # y # ys)) = ''>''\n          then Inr (''>'', trim (drop (length ''>'') (x # y # ys)))\n          else err_expecting ''one of [/>, >]'' (x # y # ys)) =\n    oneof_closed (x # y # ys)", "by simp"], ["proof (state)\nthis:\n  oneof [''/>'', ''>''] xs__ = oneof_closed xs__\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  oneof [''/>'', ''>''] xs__ = oneof_closed xs__\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  oneof [''/>'', ''>''] xs__ = oneof_closed xs__\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  oneof [''/>'', ''>''] xs__ = oneof_closed xs__\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  oneof [''/>'', ''>''] xs = oneof_closed xs\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma If_removal:\n  \"(\\<lambda> e x. if b e then f e x else g e x) = (\\<lambda> e. if b e then f e else g e)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>e x. if b e then f e x else g e x) =\n    (\\<lambda>e. if b e then f e else g e)", "by (intro ext) auto"], ["", "declare parse_nodes.simps [unfolded oneof_closed,\n  unfolded If_removal [of \"\\<lambda> e. e = ''/>''\"], code]"], ["", "definition parse_node :: \"xml parser\"\nwhere\n  \"parse_node = do {\n    exactly ''<'';\n    n \\<leftarrow> parse_name;\n    atts \\<leftarrow> parse_attributes;\n    e \\<leftarrow> oneof [''/>'', ''>''];\n    if e = ''/>'' then return (XML n atts [])\n    else do {\n      cs \\<leftarrow> parse_nodes;\n      exactly ''</'';\n      exactly n;\n      exactly ''>'';\n      return (XML n atts cs)\n    }\n  }\""], ["", "declare parse_node_def [unfolded oneof_closed, code]"], ["", "function parse_header :: \"string list parser\"\nwhere\n  \"parse_header ts =\n    (if take 2 (trim ts) = ''<?'' then (do {\n      h \\<leftarrow> scan_upto ''?>'';\n      hs \\<leftarrow> parse_header;\n      return (h # hs)\n    }) ts else (do {\n      spaces;\n      return []\n    }) ts)\""], ["proof (prove)\ngoal (2 subgoals):\n 1. \\<And>P x. (\\<And>ts. x = ts \\<Longrightarrow> P) \\<Longrightarrow> P\n 2. \\<And>ts tsa.\n       ts = tsa \\<Longrightarrow>\n       (if take 2 (trim ts) = ''<?''\n        then (scan_upto ''?>'' \\<bind>\n              (\\<lambda>h.\n                  parse_header_sumC \\<bind>\n                  (\\<lambda>hs. Parser_Monad.return (h # hs))))\n              ts\n        else (spaces \\<bind> (\\<lambda>_. Parser_Monad.return [])) ts) =\n       (if take 2 (trim tsa) = ''<?''\n        then (scan_upto ''?>'' \\<bind>\n              (\\<lambda>h.\n                  parse_header_sumC \\<bind>\n                  (\\<lambda>hs. Parser_Monad.return (h # hs))))\n              tsa\n        else (spaces \\<bind> (\\<lambda>_. Parser_Monad.return [])) tsa)", "by pat_completeness auto"], ["", "termination parse_header"], ["proof (prove)\ngoal (1 subgoal):\n 1. All parse_header_dom", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. wf ?R\n 2. \\<And>ts y tsa.\n       \\<lbrakk>take 2 (trim ts) = ''<?'';\n        scan_upto ''?>'' ts = Inr (y, tsa)\\<rbrakk>\n       \\<Longrightarrow> (tsa, ts) \\<in> ?R", "fix ts y tsa"], ["proof (state)\ngoal (2 subgoals):\n 1. wf ?R\n 2. \\<And>ts y tsa.\n       \\<lbrakk>take 2 (trim ts) = ''<?'';\n        scan_upto ''?>'' ts = Inr (y, tsa)\\<rbrakk>\n       \\<Longrightarrow> (tsa, ts) \\<in> ?R", "assume \"scan_upto ''?>'' ts = Inr (y, tsa)\""], ["proof (state)\nthis:\n  scan_upto ''?>'' ts = Inr (y, tsa)\n\ngoal (2 subgoals):\n 1. wf ?R\n 2. \\<And>ts y tsa.\n       \\<lbrakk>take 2 (trim ts) = ''<?'';\n        scan_upto ''?>'' ts = Inr (y, tsa)\\<rbrakk>\n       \\<Longrightarrow> (tsa, ts) \\<in> ?R", "with is_cparser_scan_upto"], ["proof (chain)\npicking this:\n  is_cparser (scan_upto (?e # ?end))\n  scan_upto ''?>'' ts = Inr (y, tsa)", "have \"length ts > length tsa\""], ["proof (prove)\nusing this:\n  is_cparser (scan_upto (?e # ?end))\n  scan_upto ''?>'' ts = Inr (y, tsa)\n\ngoal (1 subgoal):\n 1. length tsa < length ts", "unfolding is_cparser_def"], ["proof (prove)\nusing this:\n  \\<forall>s r x.\n     scan_upto (?e # ?end) s = Inr (x, r) \\<longrightarrow>\n     length r < length s\n  scan_upto ''?>'' ts = Inr (y, tsa)\n\ngoal (1 subgoal):\n 1. length tsa < length ts", "by force"], ["proof (state)\nthis:\n  length tsa < length ts\n\ngoal (2 subgoals):\n 1. wf ?R\n 2. \\<And>ts y tsa.\n       \\<lbrakk>take 2 (trim ts) = ''<?'';\n        scan_upto ''?>'' ts = Inr (y, tsa)\\<rbrakk>\n       \\<Longrightarrow> (tsa, ts) \\<in> ?R", "then"], ["proof (chain)\npicking this:\n  length tsa < length ts", "show \"(tsa, ts) \\<in> measure length\""], ["proof (prove)\nusing this:\n  length tsa < length ts\n\ngoal (1 subgoal):\n 1. (tsa, ts) \\<in> measure length", "by simp"], ["proof (state)\nthis:\n  (tsa, ts) \\<in> measure length\n\ngoal (1 subgoal):\n 1. wf (measure length)", "qed simp"], ["", "consts scala :: bool"], ["", "code_printing\n  constant scala \\<rightharpoonup>\n    (Haskell) \"False\" and\n    (Scala) \"true\" and\n    (SML) \"false\" and\n    (OCaml) \"false\" and\n    (Eval) \"false\""], ["", "fun remove_comments_aux :: \"bool \\<Rightarrow> string \\<Rightarrow> string\"\nwhere\n  \"remove_comments_aux False (c # cs) =\n    (if c = CHR ''<'' \\<and> take 3 cs = ''!--'' then remove_comments_aux True (tl cs)\n    else c # remove_comments_aux False cs)\" |\n  \"remove_comments_aux True (c # cs) =\n    (if c = CHR ''-'' \\<and> take 2 cs = ''->'' then remove_comments_aux False (drop 2 cs)\n    else remove_comments_aux True cs)\" |\n  \"remove_comments_aux _ [] = []\""], ["", "fun remove_comments_aux_acc :: \"string \\<Rightarrow> bool \\<Rightarrow> string \\<Rightarrow> string\"\nwhere\n  \"remove_comments_aux_acc a False (c # cs) =\n    (if c = CHR ''<'' \\<and> take 3 cs = ''!--'' then remove_comments_aux_acc a True (tl cs)\n    else remove_comments_aux_acc (c # a) False cs)\" |\n  \"remove_comments_aux_acc a True (c # cs) =\n    (if c = CHR ''-'' \\<and> take 2 cs = ''->'' then remove_comments_aux_acc a False (drop 2 cs)\n    else remove_comments_aux_acc a True cs)\" |\n  \"remove_comments_aux_acc a _ [] = a\""], ["", "text \\<open>A tail recursive variant for Scala to reduce stack size at the cost of double traversal.\\<close>"], ["", "definition remove_comments :: \"string \\<Rightarrow> string\"\nwhere\n  \"remove_comments =\n    (if scala then rev o (remove_comments_aux_acc [] False)\n    else remove_comments_aux False)\""], ["", "hide_const remove_comments_aux remove_comments_aux_acc"], ["", "definition parse_doc :: \"xmldoc parser\"\nwhere\n  \"parse_doc = do {\n    update_tokens remove_comments;\n    h \\<leftarrow> parse_header;\n    xml \\<leftarrow> parse_node;\n    eoi;\n    return (XMLDOC h xml)\n  }\""], ["", "definition doc_of_string :: \"string \\<Rightarrow> string + xmldoc\"\nwhere\n  \"doc_of_string s = do {\n    (doc, _) \\<leftarrow> parse_doc s;\n    Error_Monad.return doc\n  }\""], ["", "end"]]}