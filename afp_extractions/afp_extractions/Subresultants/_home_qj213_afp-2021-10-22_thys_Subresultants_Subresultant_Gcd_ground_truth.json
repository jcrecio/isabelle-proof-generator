{"file_name": "/home/qj213/afp-2021-10-22/thys/Subresultants/Subresultant_Gcd.thy", "working_directory": "/home/qj213/afp-2021-10-22/thys/Subresultants", "problem_names": ["lemma subresultant_prs_gcd: assumes \"subresultant_prs dichotomous_Lazard G1 G2 = (Gk, hk)\"\n  shows \"\\<exists> a b. a \\<noteq> 0 \\<and> b \\<noteq> 0 \\<and> smult a (gcd G1 G2) = smult b (normalize Gk)\"", "lemma gcd_impl_primitive: assumes \"primitive_part G1 = G1\" and \"primitive_part G2 = G2\"\nshows \"gcd_impl_primitive G1 G2 = gcd G1 G2\"", "lemma gcd_impl_main: assumes len: \"length (coeffs G1) \\<ge> length (coeffs G2)\"\n  shows \"gcd_impl_main G1 G2 = gcd G1 G2\"", "theorem gcd_impl[simp]: \"gcd_impl = gcd\"", "lemma resultant_0_gcd: \"resultant f g = 0 \\<longleftrightarrow> degree (gcd f g) \\<noteq> 0\"", "lemma gcd_impl_rec_code[code]:\n  \"gcd_impl_rec Gi_1 Gi ni_1 d1_1 hi_2 = (\n    let pmod = pseudo_mod Gi_1 Gi\n     in\n     if pmod = 0 then Gi\n        else let\n           ni = degree Gi;\n           d1 = ni_1 - ni;\n           gi_1 = lead_coeff Gi_1;\n           hi_1 = (if d1_1 = 1 then gi_1 else dichotomous_Lazard gi_1 hi_2 d1_1);\n           divisor = if d1 = 1 then gi_1 * hi_1 else if even d1 then - gi_1 * hi_1 ^ d1 else gi_1 * hi_1 ^ d1;\n           Gi_p1 = sdiv_poly pmod divisor\n       in gcd_impl_rec Gi Gi_p1 ni d1 hi_1)\"", "lemma gcd_impl_start_code[code]:\n  \"gcd_impl_start G1 G2 =\n     (let pmod = pseudo_mod G1 G2\n         in if pmod = 0 then G2\n            else let\n                 n2 = degree G2;\n                 n1 = degree G1;\n                 d1 = n1 - n2;\n                 G3 = if even d1 then - pmod else pmod;\n                 pmod = pseudo_mod G2 G3\n                 in if pmod = 0\n                    then G3\n                    else let\n                           g2 = lead_coeff G2;\n                           n3 = degree G3;\n                           h2 = (if d1 = 1 then g2 else g2 ^ d1);\n                           d2 = n2 - n3;\n                           divisor = (if d2 = 1 then g2 * h2 else if even d2 then - g2 * h2 ^ d2 else g2 * h2 ^ d2);\n                           G4 = sdiv_poly pmod divisor\n                         in gcd_impl_rec G3 G4 n3 d2 h2)\"", "lemma gcd_impl_main_code[code]:\n  \"gcd_impl_main G1 G2 = (if G1 = 0 then 0 else if G2 = 0 then normalize G1 else\n    let c1 = content G1;\n      c2 = content G2;\n      p1 = map_poly (\\<lambda> x. x div c1) G1;\n      p2 = map_poly (\\<lambda> x. x div c2) G2\n     in smult (gcd c1 c2) (normalize (primitive_part (gcd_impl_start p1 p2))))\""], "translations": [["", "lemma subresultant_prs_gcd: assumes \"subresultant_prs dichotomous_Lazard G1 G2 = (Gk, hk)\"\n  shows \"\\<exists> a b. a \\<noteq> 0 \\<and> b \\<noteq> 0 \\<and> smult a (gcd G1 G2) = smult b (normalize Gk)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       a \\<noteq> (0::'a) \\<and>\n       b \\<noteq> (0::'a) \\<and>\n       Polynomial.smult a (gcd G1 G2) = Polynomial.smult b (normalize Gk)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       a \\<noteq> (0::'a) \\<and>\n       b \\<noteq> (0::'a) \\<and>\n       Polynomial.smult a (gcd G1 G2) = Polynomial.smult b (normalize Gk)", "from subresultant_prs[OF dichotomous_Lazard assms]"], ["proof (chain)\npicking this:\n  (\\<And>x y n.\n      ff x ^ n / ff y ^ (n - 1) \\<in> range ff \\<Longrightarrow>\n      ff x ^ n / ff y ^ (n - 1) \\<in> range ff) \\<Longrightarrow>\n  F k = ffp Gk \\<and>\n  h k = ff hk \\<and>\n  (?i \\<noteq> 0 \\<longrightarrow> F ?i \\<in> range ffp) \\<and>\n  (3 \\<le> ?i \\<longrightarrow>\n   ?i \\<le> Suc k \\<longrightarrow> \\<beta> ?i \\<in> range ff)", "have Fk: \"F k = ffp Gk\" and \"\\<forall> i. \\<exists> H. i \\<noteq> 0 \\<longrightarrow> F i = ffp H\"\n    and \"\\<forall> i. \\<exists> b. 3 \\<le> i \\<longrightarrow> i \\<le> Suc k \\<longrightarrow> \\<beta> i = ff b\""], ["proof (prove)\nusing this:\n  (\\<And>x y n.\n      ff x ^ n / ff y ^ (n - 1) \\<in> range ff \\<Longrightarrow>\n      ff x ^ n / ff y ^ (n - 1) \\<in> range ff) \\<Longrightarrow>\n  F k = ffp Gk \\<and>\n  h k = ff hk \\<and>\n  (?i \\<noteq> 0 \\<longrightarrow> F ?i \\<in> range ffp) \\<and>\n  (3 \\<le> ?i \\<longrightarrow>\n   ?i \\<le> Suc k \\<longrightarrow> \\<beta> ?i \\<in> range ff)\n\ngoal (1 subgoal):\n 1. F k = ffp Gk &&&\n    \\<forall>i. \\<exists>H. i \\<noteq> 0 \\<longrightarrow> F i = ffp H &&&\n    \\<forall>i.\n       \\<exists>b.\n          3 \\<le> i \\<longrightarrow>\n          i \\<le> Suc k \\<longrightarrow> \\<beta> i = ff b", "by auto"], ["proof (state)\nthis:\n  F k = ffp Gk\n  \\<forall>i. \\<exists>H. i \\<noteq> 0 \\<longrightarrow> F i = ffp H\n  \\<forall>i.\n     \\<exists>b.\n        3 \\<le> i \\<longrightarrow>\n        i \\<le> Suc k \\<longrightarrow> \\<beta> i = ff b\n\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       a \\<noteq> (0::'a) \\<and>\n       b \\<noteq> (0::'a) \\<and>\n       Polynomial.smult a (gcd G1 G2) = Polynomial.smult b (normalize Gk)", "from choice[OF this(2)] choice[OF this(3)]"], ["proof (chain)\npicking this:\n  \\<exists>f. \\<forall>x. x \\<noteq> 0 \\<longrightarrow> F x = ffp (f x)\n  \\<exists>f.\n     \\<forall>x\\<ge>3. x \\<le> Suc k \\<longrightarrow> \\<beta> x = ff (f x)", "obtain H beta where\n    FH: \"\\<And> i. i \\<noteq> 0 \\<Longrightarrow> F i = ffp (H i)\" and\n    beta: \"\\<And> i. 3 \\<le> i \\<Longrightarrow> i \\<le> Suc k \\<Longrightarrow> \\<beta> i = ff (beta i)\""], ["proof (prove)\nusing this:\n  \\<exists>f. \\<forall>x. x \\<noteq> 0 \\<longrightarrow> F x = ffp (f x)\n  \\<exists>f.\n     \\<forall>x\\<ge>3. x \\<le> Suc k \\<longrightarrow> \\<beta> x = ff (f x)\n\ngoal (1 subgoal):\n 1. (\\<And>H beta.\n        \\<lbrakk>\\<And>i. i \\<noteq> 0 \\<Longrightarrow> F i = ffp (H i);\n         \\<And>i.\n            \\<lbrakk>3 \\<le> i; i \\<le> Suc k\\<rbrakk>\n            \\<Longrightarrow> \\<beta> i = ff (beta i)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  ?i1 \\<noteq> 0 \\<Longrightarrow> F ?i1 = ffp (H ?i1)\n  \\<lbrakk>3 \\<le> ?i1; ?i1 \\<le> Suc k\\<rbrakk>\n  \\<Longrightarrow> \\<beta> ?i1 = ff (beta ?i1)\n\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       a \\<noteq> (0::'a) \\<and>\n       b \\<noteq> (0::'a) \\<and>\n       Polynomial.smult a (gcd G1 G2) = Polynomial.smult b (normalize Gk)", "from Fk FH[OF k0] FH[of 1] FH[of 2] FH[of \"Suc k\"] F0[of \"Suc k\"] F1 F2"], ["proof (chain)\npicking this:\n  F k = ffp Gk\n  F k = ffp (H k)\n  1 \\<noteq> 0 \\<Longrightarrow> F 1 = ffp (H 1)\n  2 \\<noteq> 0 \\<Longrightarrow> F 2 = ffp (H 2)\n  Suc k \\<noteq> 0 \\<Longrightarrow> F (Suc k) = ffp (H (Suc k))\n  Suc k \\<noteq> 0 \\<Longrightarrow> (F (Suc k) = 0) = (k < Suc k)\n  F 1 = ffp G1\n  F 2 = ffp G2", "have border: \"H k = Gk\" \"H 1 = G1\" \"H 2 = G2\" \"H (Suc k) = 0\""], ["proof (prove)\nusing this:\n  F k = ffp Gk\n  F k = ffp (H k)\n  1 \\<noteq> 0 \\<Longrightarrow> F 1 = ffp (H 1)\n  2 \\<noteq> 0 \\<Longrightarrow> F 2 = ffp (H 2)\n  Suc k \\<noteq> 0 \\<Longrightarrow> F (Suc k) = ffp (H (Suc k))\n  Suc k \\<noteq> 0 \\<Longrightarrow> (F (Suc k) = 0) = (k < Suc k)\n  F 1 = ffp G1\n  F 2 = ffp G2\n\ngoal (1 subgoal):\n 1. (H k = Gk &&& H 1 = G1) &&& H 2 = G2 &&& H (Suc k) = 0", "by auto"], ["proof (state)\nthis:\n  H k = Gk\n  H 1 = G1\n  H 2 = G2\n  H (Suc k) = 0\n\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       a \\<noteq> (0::'a) \\<and>\n       b \\<noteq> (0::'a) \\<and>\n       Polynomial.smult a (gcd G1 G2) = Polynomial.smult b (normalize Gk)", "have \"i \\<noteq> 0 \\<Longrightarrow> i \\<le> k \\<Longrightarrow> \\<exists> a b. a \\<noteq> 0 \\<and> b \\<noteq> 0 \\<and> smult a (gcd G1 G2) = smult b (gcd (H i) (H (Suc i)))\" for i"], ["proof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>i \\<noteq> 0; i \\<le> k\\<rbrakk>\n    \\<Longrightarrow> \\<exists>a b.\n                         a \\<noteq> (0::'a) \\<and>\n                         b \\<noteq> (0::'a) \\<and>\n                         Polynomial.smult a (gcd G1 G2) =\n                         Polynomial.smult b (gcd (H i) (H (Suc i)))", "proof (induct i rule: less_induct)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; y \\<noteq> 0; y \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>a b.\n  a \\<noteq> (0::'a) \\<and>\n  b \\<noteq> (0::'a) \\<and>\n  Polynomial.smult a (gcd G1 G2) =\n  Polynomial.smult b (gcd (H y) (H (Suc y)));\n        x \\<noteq> 0; x \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b.\n                            a \\<noteq> (0::'a) \\<and>\n                            b \\<noteq> (0::'a) \\<and>\n                            Polynomial.smult a (gcd G1 G2) =\n                            Polynomial.smult b (gcd (H x) (H (Suc x)))", "case (less i)"], ["proof (state)\nthis:\n  \\<lbrakk>?y1 < i; ?y1 \\<noteq> 0; ?y1 \\<le> k\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a b.\n                       a \\<noteq> (0::'a) \\<and>\n                       b \\<noteq> (0::'a) \\<and>\n                       Polynomial.smult a (gcd G1 G2) =\n                       Polynomial.smult b (gcd (H ?y1) (H (Suc ?y1)))\n  i \\<noteq> 0\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; y \\<noteq> 0; y \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>a b.\n  a \\<noteq> (0::'a) \\<and>\n  b \\<noteq> (0::'a) \\<and>\n  Polynomial.smult a (gcd G1 G2) =\n  Polynomial.smult b (gcd (H y) (H (Suc y)));\n        x \\<noteq> 0; x \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b.\n                            a \\<noteq> (0::'a) \\<and>\n                            b \\<noteq> (0::'a) \\<and>\n                            Polynomial.smult a (gcd G1 G2) =\n                            Polynomial.smult b (gcd (H x) (H (Suc x)))", "from less(3)"], ["proof (chain)\npicking this:\n  i \\<le> k", "have ik: \"i \\<le> k\""], ["proof (prove)\nusing this:\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. i \\<le> k", "."], ["proof (state)\nthis:\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; y \\<noteq> 0; y \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>a b.\n  a \\<noteq> (0::'a) \\<and>\n  b \\<noteq> (0::'a) \\<and>\n  Polynomial.smult a (gcd G1 G2) =\n  Polynomial.smult b (gcd (H y) (H (Suc y)));\n        x \\<noteq> 0; x \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b.\n                            a \\<noteq> (0::'a) \\<and>\n                            b \\<noteq> (0::'a) \\<and>\n                            Polynomial.smult a (gcd G1 G2) =\n                            Polynomial.smult b (gcd (H x) (H (Suc x)))", "from less(2)"], ["proof (chain)\npicking this:\n  i \\<noteq> 0", "have \"i = 1 \\<or> i \\<ge> 2\""], ["proof (prove)\nusing this:\n  i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. i = 1 \\<or> 2 \\<le> i", "by auto"], ["proof (state)\nthis:\n  i = 1 \\<or> 2 \\<le> i\n\ngoal (1 subgoal):\n 1. \\<And>x.\n       \\<lbrakk>\\<And>y.\n                   \\<lbrakk>y < x; y \\<noteq> 0; y \\<le> k\\<rbrakk>\n                   \\<Longrightarrow> \\<exists>a b.\n  a \\<noteq> (0::'a) \\<and>\n  b \\<noteq> (0::'a) \\<and>\n  Polynomial.smult a (gcd G1 G2) =\n  Polynomial.smult b (gcd (H y) (H (Suc y)));\n        x \\<noteq> 0; x \\<le> k\\<rbrakk>\n       \\<Longrightarrow> \\<exists>a b.\n                            a \\<noteq> (0::'a) \\<and>\n                            b \\<noteq> (0::'a) \\<and>\n                            Polynomial.smult a (gcd G1 G2) =\n                            Polynomial.smult b (gcd (H x) (H (Suc x)))", "thus ?case"], ["proof (prove)\nusing this:\n  i = 1 \\<or> 2 \\<le> i\n\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       a \\<noteq> (0::'a) \\<and>\n       b \\<noteq> (0::'a) \\<and>\n       Polynomial.smult a (gcd G1 G2) =\n       Polynomial.smult b (gcd (H i) (H (Suc i)))", "proof"], ["proof (state)\ngoal (2 subgoals):\n 1. i = 1 \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> (0::'a) \\<and>\n       b \\<noteq> (0::'a) \\<and>\n       Polynomial.smult a (gcd G1 G2) =\n       Polynomial.smult b (gcd (H i) (H (Suc i)))\n 2. 2 \\<le> i \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> (0::'a) \\<and>\n       b \\<noteq> (0::'a) \\<and>\n       Polynomial.smult a (gcd G1 G2) =\n       Polynomial.smult b (gcd (H i) (H (Suc i)))", "assume \"i = 1\""], ["proof (state)\nthis:\n  i = 1\n\ngoal (2 subgoals):\n 1. i = 1 \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> (0::'a) \\<and>\n       b \\<noteq> (0::'a) \\<and>\n       Polynomial.smult a (gcd G1 G2) =\n       Polynomial.smult b (gcd (H i) (H (Suc i)))\n 2. 2 \\<le> i \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> (0::'a) \\<and>\n       b \\<noteq> (0::'a) \\<and>\n       Polynomial.smult a (gcd G1 G2) =\n       Polynomial.smult b (gcd (H i) (H (Suc i)))", "thus ?thesis"], ["proof (prove)\nusing this:\n  i = 1\n\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       a \\<noteq> (0::'a) \\<and>\n       b \\<noteq> (0::'a) \\<and>\n       Polynomial.smult a (gcd G1 G2) =\n       Polynomial.smult b (gcd (H i) (H (Suc i)))", "unfolding border[symmetric]"], ["proof (prove)\nusing this:\n  i = 1\n\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       a \\<noteq> (0::'a) \\<and>\n       b \\<noteq> (0::'a) \\<and>\n       Polynomial.smult a (gcd (H 1) (H 2)) =\n       Polynomial.smult b (gcd (H i) (H (Suc i)))", "by (intro exI[of _ 1], auto simp: numeral_2_eq_2)"], ["proof (state)\nthis:\n  \\<exists>a b.\n     a \\<noteq> (0::'a) \\<and>\n     b \\<noteq> (0::'a) \\<and>\n     Polynomial.smult a (gcd G1 G2) =\n     Polynomial.smult b (gcd (H i) (H (Suc i)))\n\ngoal (1 subgoal):\n 1. 2 \\<le> i \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> (0::'a) \\<and>\n       b \\<noteq> (0::'a) \\<and>\n       Polynomial.smult a (gcd G1 G2) =\n       Polynomial.smult b (gcd (H i) (H (Suc i)))", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. 2 \\<le> i \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> (0::'a) \\<and>\n       b \\<noteq> (0::'a) \\<and>\n       Polynomial.smult a (gcd G1 G2) =\n       Polynomial.smult b (gcd (H i) (H (Suc i)))", "assume i2: \"i \\<ge> 2\""], ["proof (state)\nthis:\n  2 \\<le> i\n\ngoal (1 subgoal):\n 1. 2 \\<le> i \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> (0::'a) \\<and>\n       b \\<noteq> (0::'a) \\<and>\n       Polynomial.smult a (gcd G1 G2) =\n       Polynomial.smult b (gcd (H i) (H (Suc i)))", "with ik"], ["proof (chain)\npicking this:\n  i \\<le> k\n  2 \\<le> i", "have \"i - 1 < i\" \"i - 1 \\<noteq> 0\" and imk: \"i - 1 \\<le> k\""], ["proof (prove)\nusing this:\n  i \\<le> k\n  2 \\<le> i\n\ngoal (1 subgoal):\n 1. (i - 1 < i &&& i - 1 \\<noteq> 0) &&& i - 1 \\<le> k", "by auto"], ["proof (state)\nthis:\n  i - 1 < i\n  i - 1 \\<noteq> 0\n  i - 1 \\<le> k\n\ngoal (1 subgoal):\n 1. 2 \\<le> i \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> (0::'a) \\<and>\n       b \\<noteq> (0::'a) \\<and>\n       Polynomial.smult a (gcd G1 G2) =\n       Polynomial.smult b (gcd (H i) (H (Suc i)))", "from less(1)[OF this] i2"], ["proof (chain)\npicking this:\n  \\<exists>a b.\n     a \\<noteq> (0::'a) \\<and>\n     b \\<noteq> (0::'a) \\<and>\n     Polynomial.smult a (gcd G1 G2) =\n     Polynomial.smult b (gcd (H (i - 1)) (H (Suc (i - 1))))\n  2 \\<le> i", "obtain a b where a: \"a \\<noteq> 0\" and b: \"b \\<noteq> 0\" and IH: \"smult a (gcd G1 G2) = smult b (gcd (H (i - 1)) (H i))\""], ["proof (prove)\nusing this:\n  \\<exists>a b.\n     a \\<noteq> (0::'a) \\<and>\n     b \\<noteq> (0::'a) \\<and>\n     Polynomial.smult a (gcd G1 G2) =\n     Polynomial.smult b (gcd (H (i - 1)) (H (Suc (i - 1))))\n  2 \\<le> i\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>a \\<noteq> (0::'a); b \\<noteq> (0::'a);\n         Polynomial.smult a (gcd G1 G2) =\n         Polynomial.smult b (gcd (H (i - 1)) (H i))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a \\<noteq> (0::'a)\n  b \\<noteq> (0::'a)\n  Polynomial.smult a (gcd G1 G2) =\n  Polynomial.smult b (gcd (H (i - 1)) (H i))\n\ngoal (1 subgoal):\n 1. 2 \\<le> i \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> (0::'a) \\<and>\n       b \\<noteq> (0::'a) \\<and>\n       Polynomial.smult a (gcd G1 G2) =\n       Polynomial.smult b (gcd (H i) (H (Suc i)))", "define M where \"M = pseudo_mod (H (i - 1)) (H i)\""], ["proof (state)\nthis:\n  M = pseudo_mod (H (i - 1)) (H i)\n\ngoal (1 subgoal):\n 1. 2 \\<le> i \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> (0::'a) \\<and>\n       b \\<noteq> (0::'a) \\<and>\n       Polynomial.smult a (gcd G1 G2) =\n       Polynomial.smult b (gcd (H i) (H (Suc i)))", "define c where \"c = \\<beta> (Suc i)\""], ["proof (state)\nthis:\n  c = \\<beta> (Suc i)\n\ngoal (1 subgoal):\n 1. 2 \\<le> i \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> (0::'a) \\<and>\n       b \\<noteq> (0::'a) \\<and>\n       Polynomial.smult a (gcd G1 G2) =\n       Polynomial.smult b (gcd (H i) (H (Suc i)))", "have M: \"pseudo_mod (F (i - 1)) (F i) = ffp M\""], ["proof (prove)\ngoal (1 subgoal):\n 1. pseudo_mod (F (i - 1)) (F i) = ffp M", "unfolding to_fract_hom.pseudo_mod_hom[symmetric] M_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. pseudo_mod (F (i - 1)) (F i) = pseudo_mod (ffp (H (i - 1))) (ffp (H i))", "using i2 FH"], ["proof (prove)\nusing this:\n  2 \\<le> i\n  ?i1 \\<noteq> 0 \\<Longrightarrow> F ?i1 = ffp (H ?i1)\n\ngoal (1 subgoal):\n 1. pseudo_mod (F (i - 1)) (F i) = pseudo_mod (ffp (H (i - 1))) (ffp (H i))", "by auto"], ["proof (state)\nthis:\n  pseudo_mod (F (i - 1)) (F i) = ffp M\n\ngoal (1 subgoal):\n 1. 2 \\<le> i \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> (0::'a) \\<and>\n       b \\<noteq> (0::'a) \\<and>\n       Polynomial.smult a (gcd G1 G2) =\n       Polynomial.smult b (gcd (H i) (H (Suc i)))", "have c: \"c \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. c \\<noteq> 0", "using \\<beta>0"], ["proof (prove)\nusing this:\n  \\<beta> ?i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. c \\<noteq> 0", "unfolding c_def"], ["proof (prove)\nusing this:\n  \\<beta> ?i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. \\<beta> (Suc i) \\<noteq> 0", "."], ["proof (state)\nthis:\n  c \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 2 \\<le> i \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> (0::'a) \\<and>\n       b \\<noteq> (0::'a) \\<and>\n       Polynomial.smult a (gcd G1 G2) =\n       Polynomial.smult b (gcd (H i) (H (Suc i)))", "from i2 ik"], ["proof (chain)\npicking this:\n  2 \\<le> i\n  i \\<le> k", "have 3: \"Suc i \\<ge> 3\" \"Suc i \\<le> Suc k\""], ["proof (prove)\nusing this:\n  2 \\<le> i\n  i \\<le> k\n\ngoal (1 subgoal):\n 1. 3 \\<le> Suc i &&& Suc i \\<le> Suc k", "by auto"], ["proof (state)\nthis:\n  3 \\<le> Suc i\n  Suc i \\<le> Suc k\n\ngoal (1 subgoal):\n 1. 2 \\<le> i \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> (0::'a) \\<and>\n       b \\<noteq> (0::'a) \\<and>\n       Polynomial.smult a (gcd G1 G2) =\n       Polynomial.smult b (gcd (H i) (H (Suc i)))", "from pmod[OF 3]"], ["proof (chain)\npicking this:\n  Polynomial.smult (\\<beta> (Suc i)) (F (Suc i)) =\n  pseudo_mod (F (Suc i - 2)) (F (Suc i - 1))", "have pm: \"smult c (F (Suc i)) = pseudo_mod (F (i - 1)) (F i)\""], ["proof (prove)\nusing this:\n  Polynomial.smult (\\<beta> (Suc i)) (F (Suc i)) =\n  pseudo_mod (F (Suc i - 2)) (F (Suc i - 1))\n\ngoal (1 subgoal):\n 1. Polynomial.smult c (F (Suc i)) = pseudo_mod (F (i - 1)) (F i)", "unfolding c_def"], ["proof (prove)\nusing this:\n  Polynomial.smult (\\<beta> (Suc i)) (F (Suc i)) =\n  pseudo_mod (F (Suc i - 2)) (F (Suc i - 1))\n\ngoal (1 subgoal):\n 1. Polynomial.smult (\\<beta> (Suc i)) (F (Suc i)) =\n    pseudo_mod (F (i - 1)) (F i)", "by simp"], ["proof (state)\nthis:\n  Polynomial.smult c (F (Suc i)) = pseudo_mod (F (i - 1)) (F i)\n\ngoal (1 subgoal):\n 1. 2 \\<le> i \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> (0::'a) \\<and>\n       b \\<noteq> (0::'a) \\<and>\n       Polynomial.smult a (gcd G1 G2) =\n       Polynomial.smult b (gcd (H i) (H (Suc i)))", "from beta[OF 3, folded c_def]"], ["proof (chain)\npicking this:\n  c = ff (beta (Suc i))", "obtain d where cd: \"c = ff d\""], ["proof (prove)\nusing this:\n  c = ff (beta (Suc i))\n\ngoal (1 subgoal):\n 1. (\\<And>d. c = ff d \\<Longrightarrow> thesis) \\<Longrightarrow> thesis", "by auto"], ["proof (state)\nthis:\n  c = ff d\n\ngoal (1 subgoal):\n 1. 2 \\<le> i \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> (0::'a) \\<and>\n       b \\<noteq> (0::'a) \\<and>\n       Polynomial.smult a (gcd G1 G2) =\n       Polynomial.smult b (gcd (H i) (H (Suc i)))", "with c"], ["proof (chain)\npicking this:\n  c \\<noteq> 0\n  c = ff d", "have d: \"d \\<noteq> 0\""], ["proof (prove)\nusing this:\n  c \\<noteq> 0\n  c = ff d\n\ngoal (1 subgoal):\n 1. d \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  d \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. 2 \\<le> i \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> (0::'a) \\<and>\n       b \\<noteq> (0::'a) \\<and>\n       Polynomial.smult a (gcd G1 G2) =\n       Polynomial.smult b (gcd (H i) (H (Suc i)))", "from pm[unfolded cd M] FH[of \"Suc i\"]"], ["proof (chain)\npicking this:\n  Polynomial.smult (ff d) (F (Suc i)) = ffp M\n  Suc i \\<noteq> 0 \\<Longrightarrow> F (Suc i) = ffp (H (Suc i))", "have \"ffp (smult d (H (Suc i))) = ffp M\""], ["proof (prove)\nusing this:\n  Polynomial.smult (ff d) (F (Suc i)) = ffp M\n  Suc i \\<noteq> 0 \\<Longrightarrow> F (Suc i) = ffp (H (Suc i))\n\ngoal (1 subgoal):\n 1. ffp (Polynomial.smult d (H (Suc i))) = ffp M", "by auto"], ["proof (state)\nthis:\n  ffp (Polynomial.smult d (H (Suc i))) = ffp M\n\ngoal (1 subgoal):\n 1. 2 \\<le> i \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> (0::'a) \\<and>\n       b \\<noteq> (0::'a) \\<and>\n       Polynomial.smult a (gcd G1 G2) =\n       Polynomial.smult b (gcd (H i) (H (Suc i)))", "hence pm: \"smult d (H (Suc i)) = M\""], ["proof (prove)\nusing this:\n  ffp (Polynomial.smult d (H (Suc i))) = ffp M\n\ngoal (1 subgoal):\n 1. Polynomial.smult d (H (Suc i)) = M", "by (rule map_poly_hom.injectivity)"], ["proof (state)\nthis:\n  Polynomial.smult d (H (Suc i)) = M\n\ngoal (1 subgoal):\n 1. 2 \\<le> i \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> (0::'a) \\<and>\n       b \\<noteq> (0::'a) \\<and>\n       Polynomial.smult a (gcd G1 G2) =\n       Polynomial.smult b (gcd (H i) (H (Suc i)))", "from ik F0[of i] i2 FH[of i]"], ["proof (chain)\npicking this:\n  i \\<le> k\n  i \\<noteq> 0 \\<Longrightarrow> (F i = 0) = (k < i)\n  2 \\<le> i\n  i \\<noteq> 0 \\<Longrightarrow> F i = ffp (H i)", "have Hi0: \"H i \\<noteq> 0\""], ["proof (prove)\nusing this:\n  i \\<le> k\n  i \\<noteq> 0 \\<Longrightarrow> (F i = 0) = (k < i)\n  2 \\<le> i\n  i \\<noteq> 0 \\<Longrightarrow> F i = ffp (H i)\n\ngoal (1 subgoal):\n 1. H i \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  H i \\<noteq> 0\n\ngoal (1 subgoal):\n 1. 2 \\<le> i \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> (0::'a) \\<and>\n       b \\<noteq> (0::'a) \\<and>\n       Polynomial.smult a (gcd G1 G2) =\n       Polynomial.smult b (gcd (H i) (H (Suc i)))", "from pseudo_mod[OF this, of \"H (i - 1)\", folded M_def]"], ["proof (chain)\npicking this:\n  \\<exists>a q.\n     a \\<noteq> (0::'a) \\<and> Polynomial.smult a (H (i - 1)) = H i * q + M\n  M = 0 \\<or> degree M < degree (H i)", "obtain c Q where c: \"c \\<noteq> 0\" and \"smult c (H (i - 1)) = H i * Q + M\""], ["proof (prove)\nusing this:\n  \\<exists>a q.\n     a \\<noteq> (0::'a) \\<and> Polynomial.smult a (H (i - 1)) = H i * q + M\n  M = 0 \\<or> degree M < degree (H i)\n\ngoal (1 subgoal):\n 1. (\\<And>c Q.\n        \\<lbrakk>c \\<noteq> (0::'a);\n         Polynomial.smult c (H (i - 1)) = H i * Q + M\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c \\<noteq> (0::'a)\n  Polynomial.smult c (H (i - 1)) = H i * Q + M\n\ngoal (1 subgoal):\n 1. 2 \\<le> i \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> (0::'a) \\<and>\n       b \\<noteq> (0::'a) \\<and>\n       Polynomial.smult a (gcd G1 G2) =\n       Polynomial.smult b (gcd (H i) (H (Suc i)))", "from this[folded pm]"], ["proof (chain)\npicking this:\n  c \\<noteq> (0::'a)\n  Polynomial.smult c (H (i - 1)) = H i * Q + Polynomial.smult d (H (Suc i))", "have \"smult c (H (i - 1)) = Q * H i + smult d (H (Suc i))\""], ["proof (prove)\nusing this:\n  c \\<noteq> (0::'a)\n  Polynomial.smult c (H (i - 1)) = H i * Q + Polynomial.smult d (H (Suc i))\n\ngoal (1 subgoal):\n 1. Polynomial.smult c (H (i - 1)) =\n    Q * H i + Polynomial.smult d (H (Suc i))", "by simp"], ["proof (state)\nthis:\n  Polynomial.smult c (H (i - 1)) = Q * H i + Polynomial.smult d (H (Suc i))\n\ngoal (1 subgoal):\n 1. 2 \\<le> i \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> (0::'a) \\<and>\n       b \\<noteq> (0::'a) \\<and>\n       Polynomial.smult a (gcd G1 G2) =\n       Polynomial.smult b (gcd (H i) (H (Suc i)))", "from gcd_add_mult[of \"H i\" Q \"smult d (H (Suc i))\", folded this]"], ["proof (chain)\npicking this:\n  gcd (H i) (Polynomial.smult c (H (i - 1))) =\n  gcd (H i) (Polynomial.smult d (H (Suc i)))", "have \"gcd (H i) (smult c (H (i - 1))) = gcd (H i) (smult d (H (Suc i)))\""], ["proof (prove)\nusing this:\n  gcd (H i) (Polynomial.smult c (H (i - 1))) =\n  gcd (H i) (Polynomial.smult d (H (Suc i)))\n\ngoal (1 subgoal):\n 1. gcd (H i) (Polynomial.smult c (H (i - 1))) =\n    gcd (H i) (Polynomial.smult d (H (Suc i)))", "."], ["proof (state)\nthis:\n  gcd (H i) (Polynomial.smult c (H (i - 1))) =\n  gcd (H i) (Polynomial.smult d (H (Suc i)))\n\ngoal (1 subgoal):\n 1. 2 \\<le> i \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> (0::'a) \\<and>\n       b \\<noteq> (0::'a) \\<and>\n       Polynomial.smult a (gcd G1 G2) =\n       Polynomial.smult b (gcd (H i) (H (Suc i)))", "with gcd_smult_ex[OF c, of \"H (i - 1)\" \"H i\"]"], ["proof (chain)\npicking this:\n  \\<exists>b.\n     gcd (Polynomial.smult c (H (i - 1))) (H i) =\n     Polynomial.smult b (gcd (H (i - 1)) (H i)) \\<and>\n     b \\<noteq> (0::'a)\n  gcd (H i) (Polynomial.smult c (H (i - 1))) =\n  gcd (H i) (Polynomial.smult d (H (Suc i)))", "obtain e where\n        e: \"e \\<noteq> 0\" and \"gcd (H i) (smult d (H (Suc i))) = smult e (gcd (H i) (H (i - 1)))\""], ["proof (prove)\nusing this:\n  \\<exists>b.\n     gcd (Polynomial.smult c (H (i - 1))) (H i) =\n     Polynomial.smult b (gcd (H (i - 1)) (H i)) \\<and>\n     b \\<noteq> (0::'a)\n  gcd (H i) (Polynomial.smult c (H (i - 1))) =\n  gcd (H i) (Polynomial.smult d (H (Suc i)))\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>e \\<noteq> (0::'a);\n         gcd (H i) (Polynomial.smult d (H (Suc i))) =\n         Polynomial.smult e (gcd (H i) (H (i - 1)))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding gcd.commute[of \"H i\"]"], ["proof (prove)\nusing this:\n  \\<exists>b.\n     gcd (Polynomial.smult c (H (i - 1))) (H i) =\n     Polynomial.smult b (gcd (H (i - 1)) (H i)) \\<and>\n     b \\<noteq> (0::'a)\n  gcd (Polynomial.smult c (H (i - 1))) (H i) =\n  gcd (Polynomial.smult d (H (Suc i))) (H i)\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>e \\<noteq> (0::'a);\n         gcd (Polynomial.smult d (H (Suc i))) (H i) =\n         Polynomial.smult e (gcd (H (i - 1)) (H i))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  e \\<noteq> (0::'a)\n  gcd (H i) (Polynomial.smult d (H (Suc i))) =\n  Polynomial.smult e (gcd (H i) (H (i - 1)))\n\ngoal (1 subgoal):\n 1. 2 \\<le> i \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> (0::'a) \\<and>\n       b \\<noteq> (0::'a) \\<and>\n       Polynomial.smult a (gcd G1 G2) =\n       Polynomial.smult b (gcd (H i) (H (Suc i)))", "with gcd_smult_ex[OF d, of \"H (Suc i)\" \"H i\"]"], ["proof (chain)\npicking this:\n  \\<exists>b.\n     gcd (Polynomial.smult d (H (Suc i))) (H i) =\n     Polynomial.smult b (gcd (H (Suc i)) (H i)) \\<and>\n     b \\<noteq> (0::'a)\n  e \\<noteq> (0::'a)\n  gcd (H i) (Polynomial.smult d (H (Suc i))) =\n  Polynomial.smult e (gcd (H i) (H (i - 1)))", "obtain c where\n        c: \"c \\<noteq> 0\" and \"smult c (gcd (H i) (H (Suc i))) = smult e (gcd (H (i - 1)) (H i))\""], ["proof (prove)\nusing this:\n  \\<exists>b.\n     gcd (Polynomial.smult d (H (Suc i))) (H i) =\n     Polynomial.smult b (gcd (H (Suc i)) (H i)) \\<and>\n     b \\<noteq> (0::'a)\n  e \\<noteq> (0::'a)\n  gcd (H i) (Polynomial.smult d (H (Suc i))) =\n  Polynomial.smult e (gcd (H i) (H (i - 1)))\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c \\<noteq> (0::'a);\n         Polynomial.smult c (gcd (H i) (H (Suc i))) =\n         Polynomial.smult e (gcd (H (i - 1)) (H i))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "unfolding gcd.commute[of \"H i\"]"], ["proof (prove)\nusing this:\n  \\<exists>b.\n     gcd (Polynomial.smult d (H (Suc i))) (H i) =\n     Polynomial.smult b (gcd (H (Suc i)) (H i)) \\<and>\n     b \\<noteq> (0::'a)\n  e \\<noteq> (0::'a)\n  gcd (Polynomial.smult d (H (Suc i))) (H i) =\n  Polynomial.smult e (gcd (H (i - 1)) (H i))\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>c \\<noteq> (0::'a);\n         Polynomial.smult c (gcd (H (Suc i)) (H i)) =\n         Polynomial.smult e (gcd (H (i - 1)) (H i))\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  c \\<noteq> (0::'a)\n  Polynomial.smult c (gcd (H i) (H (Suc i))) =\n  Polynomial.smult e (gcd (H (i - 1)) (H i))\n\ngoal (1 subgoal):\n 1. 2 \\<le> i \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> (0::'a) \\<and>\n       b \\<noteq> (0::'a) \\<and>\n       Polynomial.smult a (gcd G1 G2) =\n       Polynomial.smult b (gcd (H i) (H (Suc i)))", "from arg_cong[OF this(2), of \"smult b\"] arg_cong[OF IH, of \"smult e\"]"], ["proof (chain)\npicking this:\n  Polynomial.smult b (Polynomial.smult c (gcd (H i) (H (Suc i)))) =\n  Polynomial.smult b (Polynomial.smult e (gcd (H (i - 1)) (H i)))\n  Polynomial.smult e (Polynomial.smult a (gcd G1 G2)) =\n  Polynomial.smult e (Polynomial.smult b (gcd (H (i - 1)) (H i)))", "have \"smult (e * a) (gcd G1 G2) = smult (b * c) (gcd (H i) (H (Suc i)))\""], ["proof (prove)\nusing this:\n  Polynomial.smult b (Polynomial.smult c (gcd (H i) (H (Suc i)))) =\n  Polynomial.smult b (Polynomial.smult e (gcd (H (i - 1)) (H i)))\n  Polynomial.smult e (Polynomial.smult a (gcd G1 G2)) =\n  Polynomial.smult e (Polynomial.smult b (gcd (H (i - 1)) (H i)))\n\ngoal (1 subgoal):\n 1. Polynomial.smult (e * a) (gcd G1 G2) =\n    Polynomial.smult (b * c) (gcd (H i) (H (Suc i)))", "unfolding smult_smult"], ["proof (prove)\nusing this:\n  Polynomial.smult (b * c) (gcd (H i) (H (Suc i))) =\n  Polynomial.smult (b * e) (gcd (H (i - 1)) (H i))\n  Polynomial.smult (e * a) (gcd G1 G2) =\n  Polynomial.smult (e * b) (gcd (H (i - 1)) (H i))\n\ngoal (1 subgoal):\n 1. Polynomial.smult (e * a) (gcd G1 G2) =\n    Polynomial.smult (b * c) (gcd (H i) (H (Suc i)))", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  Polynomial.smult (e * a) (gcd G1 G2) =\n  Polynomial.smult (b * c) (gcd (H i) (H (Suc i)))\n\ngoal (1 subgoal):\n 1. 2 \\<le> i \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> (0::'a) \\<and>\n       b \\<noteq> (0::'a) \\<and>\n       Polynomial.smult a (gcd G1 G2) =\n       Polynomial.smult b (gcd (H i) (H (Suc i)))", "moreover"], ["proof (state)\nthis:\n  Polynomial.smult (e * a) (gcd G1 G2) =\n  Polynomial.smult (b * c) (gcd (H i) (H (Suc i)))\n\ngoal (1 subgoal):\n 1. 2 \\<le> i \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> (0::'a) \\<and>\n       b \\<noteq> (0::'a) \\<and>\n       Polynomial.smult a (gcd G1 G2) =\n       Polynomial.smult b (gcd (H i) (H (Suc i)))", "have \"e * a \\<noteq> 0\" \"b * c \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. e * a \\<noteq> (0::'a) &&& b * c \\<noteq> (0::'a)", "using a b c e"], ["proof (prove)\nusing this:\n  a \\<noteq> (0::'a)\n  b \\<noteq> (0::'a)\n  c \\<noteq> (0::'a)\n  e \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. e * a \\<noteq> (0::'a) &&& b * c \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  e * a \\<noteq> (0::'a)\n  b * c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. 2 \\<le> i \\<Longrightarrow>\n    \\<exists>a b.\n       a \\<noteq> (0::'a) \\<and>\n       b \\<noteq> (0::'a) \\<and>\n       Polynomial.smult a (gcd G1 G2) =\n       Polynomial.smult b (gcd (H i) (H (Suc i)))", "ultimately"], ["proof (chain)\npicking this:\n  Polynomial.smult (e * a) (gcd G1 G2) =\n  Polynomial.smult (b * c) (gcd (H i) (H (Suc i)))\n  e * a \\<noteq> (0::'a)\n  b * c \\<noteq> (0::'a)", "show ?thesis"], ["proof (prove)\nusing this:\n  Polynomial.smult (e * a) (gcd G1 G2) =\n  Polynomial.smult (b * c) (gcd (H i) (H (Suc i)))\n  e * a \\<noteq> (0::'a)\n  b * c \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       a \\<noteq> (0::'a) \\<and>\n       b \\<noteq> (0::'a) \\<and>\n       Polynomial.smult a (gcd G1 G2) =\n       Polynomial.smult b (gcd (H i) (H (Suc i)))", "by blast"], ["proof (state)\nthis:\n  \\<exists>a b.\n     a \\<noteq> (0::'a) \\<and>\n     b \\<noteq> (0::'a) \\<and>\n     Polynomial.smult a (gcd G1 G2) =\n     Polynomial.smult b (gcd (H i) (H (Suc i)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<exists>a b.\n     a \\<noteq> (0::'a) \\<and>\n     b \\<noteq> (0::'a) \\<and>\n     Polynomial.smult a (gcd G1 G2) =\n     Polynomial.smult b (gcd (H i) (H (Suc i)))\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  \\<lbrakk>?i1 \\<noteq> 0; ?i1 \\<le> k\\<rbrakk>\n  \\<Longrightarrow> \\<exists>a b.\n                       a \\<noteq> (0::'a) \\<and>\n                       b \\<noteq> (0::'a) \\<and>\n                       Polynomial.smult a (gcd G1 G2) =\n                       Polynomial.smult b (gcd (H ?i1) (H (Suc ?i1)))\n\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       a \\<noteq> (0::'a) \\<and>\n       b \\<noteq> (0::'a) \\<and>\n       Polynomial.smult a (gcd G1 G2) = Polynomial.smult b (normalize Gk)", "from this[OF k0 le_refl, unfolded border]"], ["proof (chain)\npicking this:\n  \\<exists>a b.\n     a \\<noteq> (0::'a) \\<and>\n     b \\<noteq> (0::'a) \\<and>\n     Polynomial.smult a (gcd G1 G2) = Polynomial.smult b (gcd Gk 0)", "obtain a b where \"a \\<noteq> 0\" \"b \\<noteq> 0\" and \"smult a (gcd G1 G2) = smult b (normalize Gk)\""], ["proof (prove)\nusing this:\n  \\<exists>a b.\n     a \\<noteq> (0::'a) \\<and>\n     b \\<noteq> (0::'a) \\<and>\n     Polynomial.smult a (gcd G1 G2) = Polynomial.smult b (gcd Gk 0)\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>a \\<noteq> (0::'a); b \\<noteq> (0::'a);\n         Polynomial.smult a (gcd G1 G2) =\n         Polynomial.smult b (normalize Gk)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a \\<noteq> (0::'a)\n  b \\<noteq> (0::'a)\n  Polynomial.smult a (gcd G1 G2) = Polynomial.smult b (normalize Gk)\n\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       a \\<noteq> (0::'a) \\<and>\n       b \\<noteq> (0::'a) \\<and>\n       Polynomial.smult a (gcd G1 G2) = Polynomial.smult b (normalize Gk)", "thus ?thesis"], ["proof (prove)\nusing this:\n  a \\<noteq> (0::'a)\n  b \\<noteq> (0::'a)\n  Polynomial.smult a (gcd G1 G2) = Polynomial.smult b (normalize Gk)\n\ngoal (1 subgoal):\n 1. \\<exists>a b.\n       a \\<noteq> (0::'a) \\<and>\n       b \\<noteq> (0::'a) \\<and>\n       Polynomial.smult a (gcd G1 G2) = Polynomial.smult b (normalize Gk)", "by auto"], ["proof (state)\nthis:\n  \\<exists>a b.\n     a \\<noteq> (0::'a) \\<and>\n     b \\<noteq> (0::'a) \\<and>\n     Polynomial.smult a (gcd G1 G2) = Polynomial.smult b (normalize Gk)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gcd_impl_primitive: assumes \"primitive_part G1 = G1\" and \"primitive_part G2 = G2\"\nshows \"gcd_impl_primitive G1 G2 = gcd G1 G2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd_impl_primitive G1 G2 = gcd G1 G2", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gcd_impl_primitive G1 G2 = gcd G1 G2", "let ?pp = primitive_part"], ["proof (state)\ngoal (1 subgoal):\n 1. gcd_impl_primitive G1 G2 = gcd G1 G2", "let ?c = \"content\""], ["proof (state)\ngoal (1 subgoal):\n 1. gcd_impl_primitive G1 G2 = gcd G1 G2", "let ?n = normalize"], ["proof (state)\ngoal (1 subgoal):\n 1. gcd_impl_primitive G1 G2 = gcd G1 G2", "from F2 F0[of 2] k2"], ["proof (chain)\npicking this:\n  F 2 = ffp G2\n  2 \\<noteq> 0 \\<Longrightarrow> (F 2 = 0) = (k < 2)\n  2 \\<le> k", "have G2: \"G2 \\<noteq> 0\""], ["proof (prove)\nusing this:\n  F 2 = ffp G2\n  2 \\<noteq> 0 \\<Longrightarrow> (F 2 = 0) = (k < 2)\n  2 \\<le> k\n\ngoal (1 subgoal):\n 1. G2 \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  G2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. gcd_impl_primitive G1 G2 = gcd G1 G2", "obtain Gk hk where sub: \"subresultant_prs dichotomous_Lazard G1 G2 = (Gk, hk)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Gk hk.\n        subresultant_prs dichotomous_Lazard G1 G2 =\n        (Gk, hk) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  subresultant_prs dichotomous_Lazard G1 G2 = (Gk, hk)\n\ngoal (1 subgoal):\n 1. gcd_impl_primitive G1 G2 = gcd G1 G2", "have impl: \"gcd_impl_primitive G1 G2 = ?n (?pp Gk)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd_impl_primitive G1 G2 = normalize (primitive_part Gk)", "unfolding gcd_impl_primitive_def sub"], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize (primitive_part (fst (Gk, hk))) =\n    normalize (primitive_part Gk)", "by auto"], ["proof (state)\nthis:\n  gcd_impl_primitive G1 G2 = normalize (primitive_part Gk)\n\ngoal (1 subgoal):\n 1. gcd_impl_primitive G1 G2 = gcd G1 G2", "from subresultant_prs_gcd[OF sub]"], ["proof (chain)\npicking this:\n  \\<exists>a b.\n     a \\<noteq> (0::'a) \\<and>\n     b \\<noteq> (0::'a) \\<and>\n     Polynomial.smult a (gcd G1 G2) = Polynomial.smult b (normalize Gk)", "obtain a b where a: \"a \\<noteq> 0\" and b: \"b \\<noteq> 0\" and id: \"smult a (gcd G1 G2) = smult b (?n Gk)\""], ["proof (prove)\nusing this:\n  \\<exists>a b.\n     a \\<noteq> (0::'a) \\<and>\n     b \\<noteq> (0::'a) \\<and>\n     Polynomial.smult a (gcd G1 G2) = Polynomial.smult b (normalize Gk)\n\ngoal (1 subgoal):\n 1. (\\<And>a b.\n        \\<lbrakk>a \\<noteq> (0::'a); b \\<noteq> (0::'a);\n         Polynomial.smult a (gcd G1 G2) =\n         Polynomial.smult b (normalize Gk)\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  a \\<noteq> (0::'a)\n  b \\<noteq> (0::'a)\n  Polynomial.smult a (gcd G1 G2) = Polynomial.smult b (normalize Gk)\n\ngoal (1 subgoal):\n 1. gcd_impl_primitive G1 G2 = gcd G1 G2", "define c where \"c = unit_factor (gcd G1 G2)\""], ["proof (state)\nthis:\n  c = unit_factor (gcd G1 G2)\n\ngoal (1 subgoal):\n 1. gcd_impl_primitive G1 G2 = gcd G1 G2", "define d where \"d = smult (unit_factor a) c\""], ["proof (state)\nthis:\n  d = Polynomial.smult (unit_factor a) c\n\ngoal (1 subgoal):\n 1. gcd_impl_primitive G1 G2 = gcd G1 G2", "from G2"], ["proof (chain)\npicking this:\n  G2 \\<noteq> 0", "have c: \"is_unit c\""], ["proof (prove)\nusing this:\n  G2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. is_unit c", "unfolding c_def"], ["proof (prove)\nusing this:\n  G2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. is_unit (unit_factor (gcd G1 G2))", "by auto"], ["proof (state)\nthis:\n  is_unit c\n\ngoal (1 subgoal):\n 1. gcd_impl_primitive G1 G2 = gcd G1 G2", "from arg_cong[OF id, of ?pp, unfolded primitive_part_smult primitive_part_gcd assms\n     primitive_part_normalize c_def[symmetric]]"], ["proof (chain)\npicking this:\n  Polynomial.smult (unit_factor a) (c * gcd G1 G2) =\n  Polynomial.smult (unit_factor b) (normalize (primitive_part Gk))", "have id: \"d * gcd G1 G2 = smult (unit_factor b) (?n (?pp Gk))\""], ["proof (prove)\nusing this:\n  Polynomial.smult (unit_factor a) (c * gcd G1 G2) =\n  Polynomial.smult (unit_factor b) (normalize (primitive_part Gk))\n\ngoal (1 subgoal):\n 1. d * gcd G1 G2 =\n    Polynomial.smult (unit_factor b) (normalize (primitive_part Gk))", "unfolding d_def"], ["proof (prove)\nusing this:\n  Polynomial.smult (unit_factor a) (c * gcd G1 G2) =\n  Polynomial.smult (unit_factor b) (normalize (primitive_part Gk))\n\ngoal (1 subgoal):\n 1. Polynomial.smult (unit_factor a) c * gcd G1 G2 =\n    Polynomial.smult (unit_factor b) (normalize (primitive_part Gk))", "by simp"], ["proof (state)\nthis:\n  d * gcd G1 G2 =\n  Polynomial.smult (unit_factor b) (normalize (primitive_part Gk))\n\ngoal (1 subgoal):\n 1. gcd_impl_primitive G1 G2 = gcd G1 G2", "have d: \"is_unit d\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit d", "unfolding d_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit (Polynomial.smult (unit_factor a) c)", "using c a"], ["proof (prove)\nusing this:\n  is_unit c\n  a \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. is_unit (Polynomial.smult (unit_factor a) c)", "by (simp add: is_unit_smult_iff)"], ["proof (state)\nthis:\n  is_unit d\n\ngoal (1 subgoal):\n 1. gcd_impl_primitive G1 G2 = gcd G1 G2", "from is_unitE[OF d]"], ["proof (chain)\npicking this:\n  (\\<And>b.\n      \\<lbrakk>d \\<noteq> 0; b \\<noteq> 0; is_unit b; 1 div d = b;\n       1 div b = d; d * b = 1; ?c div d = ?c * b\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain e where e: \"is_unit e\" and de: \"d * e = 1\""], ["proof (prove)\nusing this:\n  (\\<And>b.\n      \\<lbrakk>d \\<noteq> 0; b \\<noteq> 0; is_unit b; 1 div d = b;\n       1 div b = d; d * b = 1; ?c div d = ?c * b\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>e.\n        \\<lbrakk>is_unit e; d * e = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  is_unit e\n  d * e = 1\n\ngoal (1 subgoal):\n 1. gcd_impl_primitive G1 G2 = gcd G1 G2", "define a where \"a = smult (unit_factor b) e\""], ["proof (state)\nthis:\n  a = Polynomial.smult (unit_factor b) e\n\ngoal (1 subgoal):\n 1. gcd_impl_primitive G1 G2 = gcd G1 G2", "from arg_cong[OF id, of \"\\<lambda> x. e * x\"]"], ["proof (chain)\npicking this:\n  e * (d * gcd G1 G2) =\n  e * Polynomial.smult (unit_factor b) (normalize (primitive_part Gk))", "have \"(d * e) * gcd G1 G2 = a * (?n (?pp Gk))\""], ["proof (prove)\nusing this:\n  e * (d * gcd G1 G2) =\n  e * Polynomial.smult (unit_factor b) (normalize (primitive_part Gk))\n\ngoal (1 subgoal):\n 1. d * e * gcd G1 G2 = a * normalize (primitive_part Gk)", "by (simp add: ac_simps a_def)"], ["proof (state)\nthis:\n  d * e * gcd G1 G2 = a * normalize (primitive_part Gk)\n\ngoal (1 subgoal):\n 1. gcd_impl_primitive G1 G2 = gcd G1 G2", "hence id: \"gcd G1 G2 = a * (?n (?pp Gk))\""], ["proof (prove)\nusing this:\n  d * e * gcd G1 G2 = a * normalize (primitive_part Gk)\n\ngoal (1 subgoal):\n 1. gcd G1 G2 = a * normalize (primitive_part Gk)", "using de"], ["proof (prove)\nusing this:\n  d * e * gcd G1 G2 = a * normalize (primitive_part Gk)\n  d * e = 1\n\ngoal (1 subgoal):\n 1. gcd G1 G2 = a * normalize (primitive_part Gk)", "by simp"], ["proof (state)\nthis:\n  gcd G1 G2 = a * normalize (primitive_part Gk)\n\ngoal (1 subgoal):\n 1. gcd_impl_primitive G1 G2 = gcd G1 G2", "have a: \"is_unit a\""], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit a", "unfolding a_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. is_unit (Polynomial.smult (unit_factor b) e)", "using b e"], ["proof (prove)\nusing this:\n  b \\<noteq> (0::'a)\n  is_unit e\n\ngoal (1 subgoal):\n 1. is_unit (Polynomial.smult (unit_factor b) e)", "by (simp add: is_unit_smult_iff)"], ["proof (state)\nthis:\n  is_unit a\n\ngoal (1 subgoal):\n 1. gcd_impl_primitive G1 G2 = gcd G1 G2", "define b where \"b = unit_factor (?pp Gk)\""], ["proof (state)\nthis:\n  b = unit_factor (primitive_part Gk)\n\ngoal (1 subgoal):\n 1. gcd_impl_primitive G1 G2 = gcd G1 G2", "have \"Gk \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. Gk \\<noteq> 0", "using subresultant_prs[OF dichotomous_Lazard sub] F0[OF k0]"], ["proof (prove)\nusing this:\n  (\\<And>x y n.\n      ff x ^ n / ff y ^ (n - 1) \\<in> range ff \\<Longrightarrow>\n      ff x ^ n / ff y ^ (n - 1) \\<in> range ff) \\<Longrightarrow>\n  F k = ffp Gk \\<and>\n  h k = ff hk \\<and>\n  (?i \\<noteq> 0 \\<longrightarrow> F ?i \\<in> range ffp) \\<and>\n  (3 \\<le> ?i \\<longrightarrow>\n   ?i \\<le> Suc k \\<longrightarrow> \\<beta> ?i \\<in> range ff)\n  (F k = 0) = (k < k)\n\ngoal (1 subgoal):\n 1. Gk \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  Gk \\<noteq> 0\n\ngoal (1 subgoal):\n 1. gcd_impl_primitive G1 G2 = gcd G1 G2", "hence b: \"is_unit b\""], ["proof (prove)\nusing this:\n  Gk \\<noteq> 0\n\ngoal (1 subgoal):\n 1. is_unit b", "unfolding b_def"], ["proof (prove)\nusing this:\n  Gk \\<noteq> 0\n\ngoal (1 subgoal):\n 1. is_unit (unit_factor (primitive_part Gk))", "by auto"], ["proof (state)\nthis:\n  is_unit b\n\ngoal (1 subgoal):\n 1. gcd_impl_primitive G1 G2 = gcd G1 G2", "from is_unitE[OF b]"], ["proof (chain)\npicking this:\n  (\\<And>b.\n      \\<lbrakk>b \\<noteq> 0; b \\<noteq> 0; is_unit b; 1 div b = b;\n       1 div b = b; b * b = 1; ?c div b = ?c * b\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis", "obtain c where c: \"is_unit c\" and bc: \"b * c = 1\""], ["proof (prove)\nusing this:\n  (\\<And>b.\n      \\<lbrakk>b \\<noteq> 0; b \\<noteq> 0; is_unit b; 1 div b = b;\n       1 div b = b; b * b = 1; ?c div b = ?c * b\\<rbrakk>\n      \\<Longrightarrow> ?thesis) \\<Longrightarrow>\n  ?thesis\n\ngoal (1 subgoal):\n 1. (\\<And>c.\n        \\<lbrakk>is_unit c; b * c = 1\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by metis"], ["proof (state)\nthis:\n  is_unit c\n  b * c = 1\n\ngoal (1 subgoal):\n 1. gcd_impl_primitive G1 G2 = gcd G1 G2", "obtain d where d: \"is_unit d\" and dac: \"d = a * c\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>is_unit d; d = a * c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "using c a"], ["proof (prove)\nusing this:\n  is_unit c\n  is_unit a\n\ngoal (1 subgoal):\n 1. (\\<And>d.\n        \\<lbrakk>is_unit d; d = a * c\\<rbrakk>\n        \\<Longrightarrow> thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  is_unit d\n  d = a * c\n\ngoal (1 subgoal):\n 1. gcd_impl_primitive G1 G2 = gcd G1 G2", "have \"gcd G1 G2 = d * (b * ?n (?pp Gk))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd G1 G2 = d * (b * normalize (primitive_part Gk))", "unfolding id dac"], ["proof (prove)\ngoal (1 subgoal):\n 1. a * normalize (primitive_part Gk) =\n    a * c * (b * normalize (primitive_part Gk))", "using bc"], ["proof (prove)\nusing this:\n  b * c = 1\n\ngoal (1 subgoal):\n 1. a * normalize (primitive_part Gk) =\n    a * c * (b * normalize (primitive_part Gk))", "by (simp add: ac_simps)"], ["proof (state)\nthis:\n  gcd G1 G2 = d * (b * normalize (primitive_part Gk))\n\ngoal (1 subgoal):\n 1. gcd_impl_primitive G1 G2 = gcd G1 G2", "also"], ["proof (state)\nthis:\n  gcd G1 G2 = d * (b * normalize (primitive_part Gk))\n\ngoal (1 subgoal):\n 1. gcd_impl_primitive G1 G2 = gcd G1 G2", "have \"b * ?n (?pp Gk) = ?pp Gk\""], ["proof (prove)\ngoal (1 subgoal):\n 1. b * normalize (primitive_part Gk) = primitive_part Gk", "unfolding b_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. unit_factor (primitive_part Gk) * normalize (primitive_part Gk) =\n    primitive_part Gk", "by simp"], ["proof (state)\nthis:\n  b * normalize (primitive_part Gk) = primitive_part Gk\n\ngoal (1 subgoal):\n 1. gcd_impl_primitive G1 G2 = gcd G1 G2", "finally"], ["proof (chain)\npicking this:\n  gcd G1 G2 = d * primitive_part Gk", "have \"gcd G1 G2 = d * ?pp Gk\""], ["proof (prove)\nusing this:\n  gcd G1 G2 = d * primitive_part Gk\n\ngoal (1 subgoal):\n 1. gcd G1 G2 = d * primitive_part Gk", "by simp"], ["proof (state)\nthis:\n  gcd G1 G2 = d * primitive_part Gk\n\ngoal (1 subgoal):\n 1. gcd_impl_primitive G1 G2 = gcd G1 G2", "from arg_cong[OF this, of ?n]"], ["proof (chain)\npicking this:\n  normalize (gcd G1 G2) = normalize (d * primitive_part Gk)", "have \"gcd G1 G2 = ?n (d * ?pp Gk)\""], ["proof (prove)\nusing this:\n  normalize (gcd G1 G2) = normalize (d * primitive_part Gk)\n\ngoal (1 subgoal):\n 1. gcd G1 G2 = normalize (d * primitive_part Gk)", "by simp"], ["proof (state)\nthis:\n  gcd G1 G2 = normalize (d * primitive_part Gk)\n\ngoal (1 subgoal):\n 1. gcd_impl_primitive G1 G2 = gcd G1 G2", "also"], ["proof (state)\nthis:\n  gcd G1 G2 = normalize (d * primitive_part Gk)\n\ngoal (1 subgoal):\n 1. gcd_impl_primitive G1 G2 = gcd G1 G2", "have \"\\<dots> = ?n (?pp Gk)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. normalize (d * primitive_part Gk) = normalize (primitive_part Gk)", "using d"], ["proof (prove)\nusing this:\n  is_unit d\n\ngoal (1 subgoal):\n 1. normalize (d * primitive_part Gk) = normalize (primitive_part Gk)", "unfolding normalize_mult"], ["proof (prove)\nusing this:\n  is_unit d\n\ngoal (1 subgoal):\n 1. normalize d * normalize (primitive_part Gk) =\n    normalize (primitive_part Gk)", "by (simp add: is_unit_normalize)"], ["proof (state)\nthis:\n  normalize (d * primitive_part Gk) = normalize (primitive_part Gk)\n\ngoal (1 subgoal):\n 1. gcd_impl_primitive G1 G2 = gcd G1 G2", "finally"], ["proof (chain)\npicking this:\n  gcd G1 G2 = normalize (primitive_part Gk)", "show ?thesis"], ["proof (prove)\nusing this:\n  gcd G1 G2 = normalize (primitive_part Gk)\n\ngoal (1 subgoal):\n 1. gcd_impl_primitive G1 G2 = gcd G1 G2", "unfolding impl"], ["proof (prove)\nusing this:\n  gcd G1 G2 = normalize (primitive_part Gk)\n\ngoal (1 subgoal):\n 1. normalize (primitive_part Gk) = gcd G1 G2", ".."], ["proof (state)\nthis:\n  gcd_impl_primitive G1 G2 = gcd G1 G2\n\ngoal:\nNo subgoals!", "qed"], ["", "end"], ["", "lemma gcd_impl_main: assumes len: \"length (coeffs G1) \\<ge> length (coeffs G2)\"\n  shows \"gcd_impl_main G1 G2 = gcd G1 G2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd_impl_main G1 G2 = gcd G1 G2", "proof (cases \"G1 = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. G1 = 0 \\<Longrightarrow> gcd_impl_main G1 G2 = gcd G1 G2\n 2. G1 \\<noteq> 0 \\<Longrightarrow> gcd_impl_main G1 G2 = gcd G1 G2", "case G1: False"], ["proof (state)\nthis:\n  G1 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. G1 = 0 \\<Longrightarrow> gcd_impl_main G1 G2 = gcd G1 G2\n 2. G1 \\<noteq> 0 \\<Longrightarrow> gcd_impl_main G1 G2 = gcd G1 G2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd_impl_main G1 G2 = gcd G1 G2", "proof (cases \"G2 = 0\")"], ["proof (state)\ngoal (2 subgoals):\n 1. G2 = 0 \\<Longrightarrow> gcd_impl_main G1 G2 = gcd G1 G2\n 2. G2 \\<noteq> 0 \\<Longrightarrow> gcd_impl_main G1 G2 = gcd G1 G2", "case G2: False"], ["proof (state)\nthis:\n  G2 \\<noteq> 0\n\ngoal (2 subgoals):\n 1. G2 = 0 \\<Longrightarrow> gcd_impl_main G1 G2 = gcd G1 G2\n 2. G2 \\<noteq> 0 \\<Longrightarrow> gcd_impl_main G1 G2 = gcd G1 G2", "let ?pp = \"primitive_part\""], ["proof (state)\ngoal (2 subgoals):\n 1. G2 = 0 \\<Longrightarrow> gcd_impl_main G1 G2 = gcd G1 G2\n 2. G2 \\<noteq> 0 \\<Longrightarrow> gcd_impl_main G1 G2 = gcd G1 G2", "from G2"], ["proof (chain)\npicking this:\n  G2 \\<noteq> 0", "have G2: \"?pp G2 \\<noteq> 0\" and id: \"(G2 = 0) = False\""], ["proof (prove)\nusing this:\n  G2 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. primitive_part G2 \\<noteq> 0 &&& (G2 = 0) = False", "by auto"], ["proof (state)\nthis:\n  primitive_part G2 \\<noteq> 0\n  (G2 = 0) = False\n\ngoal (2 subgoals):\n 1. G2 = 0 \\<Longrightarrow> gcd_impl_main G1 G2 = gcd G1 G2\n 2. G2 \\<noteq> 0 \\<Longrightarrow> gcd_impl_main G1 G2 = gcd G1 G2", "from len"], ["proof (chain)\npicking this:\n  length (coeffs G2) \\<le> length (coeffs G1)", "have len: \"length (coeffs (?pp G1)) \\<ge> length (coeffs (?pp G2))\""], ["proof (prove)\nusing this:\n  length (coeffs G2) \\<le> length (coeffs G1)\n\ngoal (1 subgoal):\n 1. length (coeffs (primitive_part G2))\n    \\<le> length (coeffs (primitive_part G1))", "by simp"], ["proof (state)\nthis:\n  length (coeffs (primitive_part G2))\n  \\<le> length (coeffs (primitive_part G1))\n\ngoal (2 subgoals):\n 1. G2 = 0 \\<Longrightarrow> gcd_impl_main G1 G2 = gcd G1 G2\n 2. G2 \\<noteq> 0 \\<Longrightarrow> gcd_impl_main G1 G2 = gcd G1 G2", "from enter_subresultant_prs[OF len G2]"], ["proof (chain)\npicking this:\n  \\<exists>F n d f k b.\n     subresultant_prs_locale2 F n d f k b (primitive_part G1)\n      (primitive_part G2)", "obtain F n d f k b\n      where \"subresultant_prs_locale2 F n d f k b (?pp G1) (?pp G2)\""], ["proof (prove)\nusing this:\n  \\<exists>F n d f k b.\n     subresultant_prs_locale2 F n d f k b (primitive_part G1)\n      (primitive_part G2)\n\ngoal (1 subgoal):\n 1. (\\<And>F n d f k b.\n        subresultant_prs_locale2 F n d f k b (primitive_part G1)\n         (primitive_part G2) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  subresultant_prs_locale2 F n d f k b (primitive_part G1)\n   (primitive_part G2)\n\ngoal (2 subgoals):\n 1. G2 = 0 \\<Longrightarrow> gcd_impl_main G1 G2 = gcd G1 G2\n 2. G2 \\<noteq> 0 \\<Longrightarrow> gcd_impl_main G1 G2 = gcd G1 G2", "interpret subresultant_prs_locale2 F n d f k b \"?pp G1\" \"?pp G2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subresultant_prs_locale2 F n d f k b (primitive_part G1)\n     (primitive_part G2)", "by fact"], ["proof (state)\ngoal (2 subgoals):\n 1. G2 = 0 \\<Longrightarrow> gcd_impl_main G1 G2 = gcd G1 G2\n 2. G2 \\<noteq> 0 \\<Longrightarrow> gcd_impl_main G1 G2 = gcd G1 G2", "interpret subresultant_prs_gcd F n d f k b \"?pp G1\" \"?pp G2\""], ["proof (prove)\ngoal (1 subgoal):\n 1. subresultant_prs_gcd F n d f k b (primitive_part G1) (primitive_part G2)", ".."], ["proof (state)\ngoal (2 subgoals):\n 1. G2 = 0 \\<Longrightarrow> gcd_impl_main G1 G2 = gcd G1 G2\n 2. G2 \\<noteq> 0 \\<Longrightarrow> gcd_impl_main G1 G2 = gcd G1 G2", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd_impl_main G1 G2 = gcd G1 G2", "unfolding gcd_impl_main_def gcd_poly_decompose[of G1] id if_False"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if G1 = 0 then 0\n     else Polynomial.smult (gcd (content G1) (content G2))\n           (gcd_impl_primitive (primitive_part G1) (primitive_part G2))) =\n    Polynomial.smult (gcd (content G1) (content G2))\n     (gcd (primitive_part G1) (primitive_part G2))", "using G1"], ["proof (prove)\nusing this:\n  G1 \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (if G1 = 0 then 0\n     else Polynomial.smult (gcd (content G1) (content G2))\n           (gcd_impl_primitive (primitive_part G1) (primitive_part G2))) =\n    Polynomial.smult (gcd (content G1) (content G2))\n     (gcd (primitive_part G1) (primitive_part G2))", "by (subst gcd_impl_primitive, auto)"], ["proof (state)\nthis:\n  gcd_impl_main G1 G2 = gcd G1 G2\n\ngoal (1 subgoal):\n 1. G2 = 0 \\<Longrightarrow> gcd_impl_main G1 G2 = gcd G1 G2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. G2 = 0 \\<Longrightarrow> gcd_impl_main G1 G2 = gcd G1 G2", "case True"], ["proof (state)\nthis:\n  G2 = 0\n\ngoal (1 subgoal):\n 1. G2 = 0 \\<Longrightarrow> gcd_impl_main G1 G2 = gcd G1 G2", "thus ?thesis"], ["proof (prove)\nusing this:\n  G2 = 0\n\ngoal (1 subgoal):\n 1. gcd_impl_main G1 G2 = gcd G1 G2", "unfolding gcd_impl_main_def"], ["proof (prove)\nusing this:\n  G2 = 0\n\ngoal (1 subgoal):\n 1. (if G1 = 0 then 0\n     else if G2 = 0 then normalize G1\n          else Polynomial.smult (gcd (content G1) (content G2))\n                (gcd_impl_primitive (primitive_part G1)\n                  (primitive_part G2))) =\n    gcd G1 G2", "by simp"], ["proof (state)\nthis:\n  gcd_impl_main G1 G2 = gcd G1 G2\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gcd_impl_main G1 G2 = gcd G1 G2\n\ngoal (1 subgoal):\n 1. G1 = 0 \\<Longrightarrow> gcd_impl_main G1 G2 = gcd G1 G2", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. G1 = 0 \\<Longrightarrow> gcd_impl_main G1 G2 = gcd G1 G2", "case True"], ["proof (state)\nthis:\n  G1 = 0\n\ngoal (1 subgoal):\n 1. G1 = 0 \\<Longrightarrow> gcd_impl_main G1 G2 = gcd G1 G2", "with len"], ["proof (chain)\npicking this:\n  length (coeffs G2) \\<le> length (coeffs G1)\n  G1 = 0", "have \"G2 = 0\""], ["proof (prove)\nusing this:\n  length (coeffs G2) \\<le> length (coeffs G1)\n  G1 = 0\n\ngoal (1 subgoal):\n 1. G2 = 0", "by auto"], ["proof (state)\nthis:\n  G2 = 0\n\ngoal (1 subgoal):\n 1. G1 = 0 \\<Longrightarrow> gcd_impl_main G1 G2 = gcd G1 G2", "thus ?thesis"], ["proof (prove)\nusing this:\n  G2 = 0\n\ngoal (1 subgoal):\n 1. gcd_impl_main G1 G2 = gcd G1 G2", "using True"], ["proof (prove)\nusing this:\n  G2 = 0\n  G1 = 0\n\ngoal (1 subgoal):\n 1. gcd_impl_main G1 G2 = gcd G1 G2", "unfolding gcd_impl_main_def"], ["proof (prove)\nusing this:\n  G2 = 0\n  G1 = 0\n\ngoal (1 subgoal):\n 1. (if G1 = 0 then 0\n     else if G2 = 0 then normalize G1\n          else Polynomial.smult (gcd (content G1) (content G2))\n                (gcd_impl_primitive (primitive_part G1)\n                  (primitive_part G2))) =\n    gcd G1 G2", "by simp"], ["proof (state)\nthis:\n  gcd_impl_main G1 G2 = gcd G1 G2\n\ngoal:\nNo subgoals!", "qed"], ["", "theorem gcd_impl[simp]: \"gcd_impl = gcd\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd_impl = gcd", "proof (intro ext)"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa. gcd_impl x xa = gcd x xa", "fix f g :: \"'a poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. \\<And>x xa. gcd_impl x xa = gcd x xa", "show \"gcd_impl f g = gcd f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd_impl f g = gcd f g", "proof (cases \"length (coeffs f) \\<ge> length (coeffs g)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. length (coeffs g) \\<le> length (coeffs f) \\<Longrightarrow>\n    gcd_impl f g = gcd f g\n 2. \\<not> length (coeffs g) \\<le> length (coeffs f) \\<Longrightarrow>\n    gcd_impl f g = gcd f g", "case True"], ["proof (state)\nthis:\n  length (coeffs g) \\<le> length (coeffs f)\n\ngoal (2 subgoals):\n 1. length (coeffs g) \\<le> length (coeffs f) \\<Longrightarrow>\n    gcd_impl f g = gcd f g\n 2. \\<not> length (coeffs g) \\<le> length (coeffs f) \\<Longrightarrow>\n    gcd_impl f g = gcd f g", "thus ?thesis"], ["proof (prove)\nusing this:\n  length (coeffs g) \\<le> length (coeffs f)\n\ngoal (1 subgoal):\n 1. gcd_impl f g = gcd f g", "unfolding gcd_impl_def gcd_impl_main[OF True]"], ["proof (prove)\nusing this:\n  length (coeffs g) \\<le> length (coeffs f)\n\ngoal (1 subgoal):\n 1. (if length (coeffs g) \\<le> length (coeffs f) then gcd f g\n     else gcd_impl_main g f) =\n    gcd f g", "by auto"], ["proof (state)\nthis:\n  gcd_impl f g = gcd f g\n\ngoal (1 subgoal):\n 1. \\<not> length (coeffs g) \\<le> length (coeffs f) \\<Longrightarrow>\n    gcd_impl f g = gcd f g", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> length (coeffs g) \\<le> length (coeffs f) \\<Longrightarrow>\n    gcd_impl f g = gcd f g", "case False"], ["proof (state)\nthis:\n  \\<not> length (coeffs g) \\<le> length (coeffs f)\n\ngoal (1 subgoal):\n 1. \\<not> length (coeffs g) \\<le> length (coeffs f) \\<Longrightarrow>\n    gcd_impl f g = gcd f g", "hence \"length (coeffs g) \\<ge> length (coeffs f)\""], ["proof (prove)\nusing this:\n  \\<not> length (coeffs g) \\<le> length (coeffs f)\n\ngoal (1 subgoal):\n 1. length (coeffs f) \\<le> length (coeffs g)", "by auto"], ["proof (state)\nthis:\n  length (coeffs f) \\<le> length (coeffs g)\n\ngoal (1 subgoal):\n 1. \\<not> length (coeffs g) \\<le> length (coeffs f) \\<Longrightarrow>\n    gcd_impl f g = gcd f g", "from gcd_impl_main[OF this]"], ["proof (chain)\npicking this:\n  gcd_impl_main g f = gcd g f", "show ?thesis"], ["proof (prove)\nusing this:\n  gcd_impl_main g f = gcd g f\n\ngoal (1 subgoal):\n 1. gcd_impl f g = gcd f g", "unfolding gcd_impl_def gcd.commute[of f g]"], ["proof (prove)\nusing this:\n  gcd_impl_main g f = gcd g f\n\ngoal (1 subgoal):\n 1. (if length (coeffs g) \\<le> length (coeffs f) then gcd_impl_main f g\n     else gcd_impl_main g f) =\n    gcd g f", "using False"], ["proof (prove)\nusing this:\n  gcd_impl_main g f = gcd g f\n  \\<not> length (coeffs g) \\<le> length (coeffs f)\n\ngoal (1 subgoal):\n 1. (if length (coeffs g) \\<le> length (coeffs f) then gcd_impl_main f g\n     else gcd_impl_main g f) =\n    gcd g f", "by auto"], ["proof (state)\nthis:\n  gcd_impl f g = gcd f g\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  gcd_impl f g = gcd f g\n\ngoal:\nNo subgoals!", "qed"], ["", "text \\<open>The implementation also reveals an important connection between resultant and gcd.\\<close>"], ["", "lemma resultant_0_gcd: \"resultant f g = 0 \\<longleftrightarrow> degree (gcd f g) \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "{"], ["proof (state)\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "fix f g :: \"'a poly\""], ["proof (state)\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "assume len: \"length (coeffs f) \\<ge> length (coeffs g)\""], ["proof (state)\nthis:\n  length (coeffs g) \\<le> length (coeffs f)\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "{"], ["proof (state)\nthis:\n  length (coeffs g) \\<le> length (coeffs f)\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "assume g: \"g \\<noteq> 0\""], ["proof (state)\nthis:\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "with len"], ["proof (chain)\npicking this:\n  length (coeffs g) \\<le> length (coeffs f)\n  g \\<noteq> 0", "have f: \"f \\<noteq> 0\""], ["proof (prove)\nusing this:\n  length (coeffs g) \\<le> length (coeffs f)\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. f \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "let ?f = \"primitive_part f\""], ["proof (state)\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "let ?g = \"primitive_part g\""], ["proof (state)\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "let ?c = \"content\""], ["proof (state)\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "from len"], ["proof (chain)\npicking this:\n  length (coeffs g) \\<le> length (coeffs f)", "have len: \"length (coeffs ?f) \\<ge> length (coeffs ?g)\""], ["proof (prove)\nusing this:\n  length (coeffs g) \\<le> length (coeffs f)\n\ngoal (1 subgoal):\n 1. length (coeffs (primitive_part g))\n    \\<le> length (coeffs (primitive_part f))", "by simp"], ["proof (state)\nthis:\n  length (coeffs (primitive_part g))\n  \\<le> length (coeffs (primitive_part f))\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "obtain Gk hk where sub: \"subresultant_prs dichotomous_Lazard ?f ?g = (Gk,hk)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>Gk hk.\n        subresultant_prs dichotomous_Lazard (primitive_part f)\n         (primitive_part g) =\n        (Gk, hk) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by force"], ["proof (state)\nthis:\n  subresultant_prs dichotomous_Lazard (primitive_part f)\n   (primitive_part g) =\n  (Gk, hk)\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "have cf: \"?c f \\<noteq> 0\" and cg: \"?c g \\<noteq> 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. content f \\<noteq> (0::'a) &&& content g \\<noteq> (0::'a)", "using f g"], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. content f \\<noteq> (0::'a) &&& content g \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  content f \\<noteq> (0::'a)\n  content g \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "{"], ["proof (state)\nthis:\n  content f \\<noteq> (0::'a)\n  content g \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "from g"], ["proof (chain)\npicking this:\n  g \\<noteq> 0", "have \"?g \\<noteq> 0\""], ["proof (prove)\nusing this:\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. primitive_part g \\<noteq> 0", "by auto"], ["proof (state)\nthis:\n  primitive_part g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "from enter_subresultant_prs[OF len this]"], ["proof (chain)\npicking this:\n  \\<exists>F n d f k b.\n     subresultant_prs_locale2 F n d f k b (primitive_part f)\n      (primitive_part g)", "obtain F n d f k b\n          where \"subresultant_prs_locale2 F n d f k b ?f ?g\""], ["proof (prove)\nusing this:\n  \\<exists>F n d f k b.\n     subresultant_prs_locale2 F n d f k b (primitive_part f)\n      (primitive_part g)\n\ngoal (1 subgoal):\n 1. (\\<And>F n d f k b.\n        subresultant_prs_locale2 F n d f k b (primitive_part f)\n         (primitive_part g) \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  subresultant_prs_locale2 F n d f k b (primitive_part fa__)\n   (primitive_part g)\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "interpret subresultant_prs_locale2 F n d f k b ?f ?g"], ["proof (prove)\ngoal (1 subgoal):\n 1. subresultant_prs_locale2 F n d f k b (primitive_part fa__)\n     (primitive_part g)", "by fact"], ["proof (state)\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "from subresultant_prs[OF dichotomous_Lazard sub]"], ["proof (chain)\npicking this:\n  (\\<And>x y n.\n      ff x ^ n / ff y ^ (n - 1) \\<in> range ff \\<Longrightarrow>\n      ff x ^ n / ff y ^ (n - 1) \\<in> range ff) \\<Longrightarrow>\n  F k = ffp Gk \\<and>\n  h k = ff hk \\<and>\n  (?i \\<noteq> 0 \\<longrightarrow> F ?i \\<in> range ffp) \\<and>\n  (3 \\<le> ?i \\<longrightarrow>\n   ?i \\<le> Suc k \\<longrightarrow> b ?i \\<in> range ff)", "have \"h k = ff hk\""], ["proof (prove)\nusing this:\n  (\\<And>x y n.\n      ff x ^ n / ff y ^ (n - 1) \\<in> range ff \\<Longrightarrow>\n      ff x ^ n / ff y ^ (n - 1) \\<in> range ff) \\<Longrightarrow>\n  F k = ffp Gk \\<and>\n  h k = ff hk \\<and>\n  (?i \\<noteq> 0 \\<longrightarrow> F ?i \\<in> range ffp) \\<and>\n  (3 \\<le> ?i \\<longrightarrow>\n   ?i \\<le> Suc k \\<longrightarrow> b ?i \\<in> range ff)\n\ngoal (1 subgoal):\n 1. h k = ff hk", "by auto"], ["proof (state)\nthis:\n  h k = ff hk\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "with h0[OF le_refl]"], ["proof (chain)\npicking this:\n  h k \\<noteq> 0\n  h k = ff hk", "have \"hk \\<noteq> 0\""], ["proof (prove)\nusing this:\n  h k \\<noteq> 0\n  h k = ff hk\n\ngoal (1 subgoal):\n 1. hk \\<noteq> (0::'a)", "by auto"], ["proof (state)\nthis:\n  hk \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "}"], ["proof (state)\nthis:\n  hk \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "note hk0 = this"], ["proof (state)\nthis:\n  hk \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "have \"resultant f g = 0 \\<longleftrightarrow> resultant (smult (?c f) ?f) (smult (?c g) ?g) = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) =\n    (resultant (Polynomial.smult (content f) (primitive_part f))\n      (Polynomial.smult (content g) (primitive_part g)) =\n     (0::'a))", "by simp"], ["proof (state)\nthis:\n  (resultant f g = (0::'a)) =\n  (resultant (Polynomial.smult (content f) (primitive_part f))\n    (Polynomial.smult (content g) (primitive_part g)) =\n   (0::'a))\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "also"], ["proof (state)\nthis:\n  (resultant f g = (0::'a)) =\n  (resultant (Polynomial.smult (content f) (primitive_part f))\n    (Polynomial.smult (content g) (primitive_part g)) =\n   (0::'a))\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "have \"\\<dots> \\<longleftrightarrow> resultant ?f ?g = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (resultant (Polynomial.smult (content f) (primitive_part f))\n      (Polynomial.smult (content g) (primitive_part g)) =\n     (0::'a)) =\n    (resultant (primitive_part f) (primitive_part g) = (0::'a))", "unfolding resultant_smult_left[OF cf] resultant_smult_right[OF cg]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (content g ^ degree (Polynomial.smult (content f) (primitive_part f)) *\n     (content f ^ degree (primitive_part g) *\n      resultant (primitive_part f) (primitive_part g)) =\n     (0::'a)) =\n    (resultant (primitive_part f) (primitive_part g) = (0::'a))", "using cf cg"], ["proof (prove)\nusing this:\n  content f \\<noteq> (0::'a)\n  content g \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. (content g ^ degree (Polynomial.smult (content f) (primitive_part f)) *\n     (content f ^ degree (primitive_part g) *\n      resultant (primitive_part f) (primitive_part g)) =\n     (0::'a)) =\n    (resultant (primitive_part f) (primitive_part g) = (0::'a))", "by auto"], ["proof (state)\nthis:\n  (resultant (Polynomial.smult (content f) (primitive_part f))\n    (Polynomial.smult (content g) (primitive_part g)) =\n   (0::'a)) =\n  (resultant (primitive_part f) (primitive_part g) = (0::'a))\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "also"], ["proof (state)\nthis:\n  (resultant (Polynomial.smult (content f) (primitive_part f))\n    (Polynomial.smult (content g) (primitive_part g)) =\n   (0::'a)) =\n  (resultant (primitive_part f) (primitive_part g) = (0::'a))\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "have \"\\<dots> \\<longleftrightarrow> resultant_impl_main dichotomous_Lazard ?f ?g = 0\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (resultant (primitive_part f) (primitive_part g) = (0::'a)) =\n    (resultant_impl_main dichotomous_Lazard (primitive_part f)\n      (primitive_part g) =\n     (0::'a))", "unfolding resultant_impl[symmetric] resultant_impl_def resultant_impl_main_def \n        resultant_impl_generic_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if length (coeffs (primitive_part g))\n         \\<le> length (coeffs (primitive_part f))\n      then if primitive_part g = 0\n           then if degree (primitive_part f) = 0 then 1::'a else (0::'a)\n           else case subresultant_prs dichotomous_Lazard (primitive_part f)\n                      (primitive_part g) of\n                (Gk, hk) \\<Rightarrow> if degree Gk = 0 then hk else (0::'a)\n      else let res =\n                 if primitive_part f = 0\n                 then if degree (primitive_part g) = 0 then 1::'a\n                      else (0::'a)\n                 else case subresultant_prs dichotomous_Lazard\n                            (primitive_part g) (primitive_part f) of\n                      (Gk, hk) \\<Rightarrow>\n                        if degree Gk = 0 then hk else (0::'a)\n           in if even (degree (primitive_part f)) \\<or>\n                 even (degree (primitive_part g))\n              then res else - res) =\n     (0::'a)) =\n    ((if primitive_part g = 0\n      then if degree (primitive_part f) = 0 then 1::'a else (0::'a)\n      else case subresultant_prs dichotomous_Lazard (primitive_part f)\n                 (primitive_part g) of\n           (Gk, hk) \\<Rightarrow> if degree Gk = 0 then hk else (0::'a)) =\n     (0::'a))", "using len"], ["proof (prove)\nusing this:\n  length (coeffs (primitive_part g))\n  \\<le> length (coeffs (primitive_part f))\n\ngoal (1 subgoal):\n 1. ((if length (coeffs (primitive_part g))\n         \\<le> length (coeffs (primitive_part f))\n      then if primitive_part g = 0\n           then if degree (primitive_part f) = 0 then 1::'a else (0::'a)\n           else case subresultant_prs dichotomous_Lazard (primitive_part f)\n                      (primitive_part g) of\n                (Gk, hk) \\<Rightarrow> if degree Gk = 0 then hk else (0::'a)\n      else let res =\n                 if primitive_part f = 0\n                 then if degree (primitive_part g) = 0 then 1::'a\n                      else (0::'a)\n                 else case subresultant_prs dichotomous_Lazard\n                            (primitive_part g) (primitive_part f) of\n                      (Gk, hk) \\<Rightarrow>\n                        if degree Gk = 0 then hk else (0::'a)\n           in if even (degree (primitive_part f)) \\<or>\n                 even (degree (primitive_part g))\n              then res else - res) =\n     (0::'a)) =\n    ((if primitive_part g = 0\n      then if degree (primitive_part f) = 0 then 1::'a else (0::'a)\n      else case subresultant_prs dichotomous_Lazard (primitive_part f)\n                 (primitive_part g) of\n           (Gk, hk) \\<Rightarrow> if degree Gk = 0 then hk else (0::'a)) =\n     (0::'a))", "by auto"], ["proof (state)\nthis:\n  (resultant (primitive_part f) (primitive_part g) = (0::'a)) =\n  (resultant_impl_main dichotomous_Lazard (primitive_part f)\n    (primitive_part g) =\n   (0::'a))\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "also"], ["proof (state)\nthis:\n  (resultant (primitive_part f) (primitive_part g) = (0::'a)) =\n  (resultant_impl_main dichotomous_Lazard (primitive_part f)\n    (primitive_part g) =\n   (0::'a))\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "have \"\\<dots> \\<longleftrightarrow> (degree Gk \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (resultant_impl_main dichotomous_Lazard (primitive_part f)\n      (primitive_part g) =\n     (0::'a)) =\n    (degree Gk \\<noteq> 0)", "unfolding resultant_impl_main_def sub split"], ["proof (prove)\ngoal (1 subgoal):\n 1. ((if primitive_part g = 0\n      then if degree (primitive_part f) = 0 then 1::'a else (0::'a)\n      else if degree Gk = 0 then hk else (0::'a)) =\n     (0::'a)) =\n    (degree Gk \\<noteq> 0)", "using g hk0"], ["proof (prove)\nusing this:\n  g \\<noteq> 0\n  hk \\<noteq> (0::'a)\n\ngoal (1 subgoal):\n 1. ((if primitive_part g = 0\n      then if degree (primitive_part f) = 0 then 1::'a else (0::'a)\n      else if degree Gk = 0 then hk else (0::'a)) =\n     (0::'a)) =\n    (degree Gk \\<noteq> 0)", "by auto"], ["proof (state)\nthis:\n  (resultant_impl_main dichotomous_Lazard (primitive_part f)\n    (primitive_part g) =\n   (0::'a)) =\n  (degree Gk \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "also"], ["proof (state)\nthis:\n  (resultant_impl_main dichotomous_Lazard (primitive_part f)\n    (primitive_part g) =\n   (0::'a)) =\n  (degree Gk \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "have \"degree Gk = degree (gcd_impl_primitive ?f ?g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree Gk =\n    degree (gcd_impl_primitive (primitive_part f) (primitive_part g))", "unfolding gcd_impl_primitive_def sub"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree Gk = degree (normalize (primitive_part (fst (Gk, hk))))", "by simp"], ["proof (state)\nthis:\n  degree Gk =\n  degree (gcd_impl_primitive (primitive_part f) (primitive_part g))\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "also"], ["proof (state)\nthis:\n  degree Gk =\n  degree (gcd_impl_primitive (primitive_part f) (primitive_part g))\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "have \"\\<dots> = degree (gcd_impl_main f g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (gcd_impl_primitive (primitive_part f) (primitive_part g)) =\n    degree (gcd_impl_main f g)", "unfolding gcd_impl_main_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (gcd_impl_primitive (primitive_part f) (primitive_part g)) =\n    degree\n     (if f = 0 then 0\n      else if g = 0 then normalize f\n           else Polynomial.smult (gcd (content f) (content g))\n                 (gcd_impl_primitive (primitive_part f) (primitive_part g)))", "using f g"], ["proof (prove)\nusing this:\n  f \\<noteq> 0\n  g \\<noteq> 0\n\ngoal (1 subgoal):\n 1. degree (gcd_impl_primitive (primitive_part f) (primitive_part g)) =\n    degree\n     (if f = 0 then 0\n      else if g = 0 then normalize f\n           else Polynomial.smult (gcd (content f) (content g))\n                 (gcd_impl_primitive (primitive_part f) (primitive_part g)))", "by auto"], ["proof (state)\nthis:\n  degree (gcd_impl_primitive (primitive_part f) (primitive_part g)) =\n  degree (gcd_impl_main f g)\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "also"], ["proof (state)\nthis:\n  degree (gcd_impl_primitive (primitive_part f) (primitive_part g)) =\n  degree (gcd_impl_main f g)\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "have \"\\<dots> = degree (gcd f g)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (gcd_impl_main f g) = degree (gcd f g)", "unfolding gcd_impl[symmetric] gcd_impl_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. degree (gcd_impl_main f g) =\n    degree\n     (if length (coeffs g) \\<le> length (coeffs f) then gcd_impl_main f g\n      else gcd_impl_main g f)", "using len"], ["proof (prove)\nusing this:\n  length (coeffs (primitive_part g))\n  \\<le> length (coeffs (primitive_part f))\n\ngoal (1 subgoal):\n 1. degree (gcd_impl_main f g) =\n    degree\n     (if length (coeffs g) \\<le> length (coeffs f) then gcd_impl_main f g\n      else gcd_impl_main g f)", "by auto"], ["proof (state)\nthis:\n  degree (gcd_impl_main f g) = degree (gcd f g)\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "finally"], ["proof (chain)\npicking this:\n  (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "have \"(resultant f g = 0) = (degree (gcd f g) \\<noteq> 0)\""], ["proof (prove)\nusing this:\n  (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "."], ["proof (state)\nthis:\n  (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "}"], ["proof (state)\nthis:\n  g \\<noteq> 0 \\<Longrightarrow>\n  (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "moreover"], ["proof (state)\nthis:\n  g \\<noteq> 0 \\<Longrightarrow>\n  (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "{"], ["proof (state)\nthis:\n  g \\<noteq> 0 \\<Longrightarrow>\n  (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "assume g: \"g = 0\" and f: \"degree f \\<noteq> 0\""], ["proof (state)\nthis:\n  g = 0\n  degree f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "have \"(resultant f g = 0) = (degree (gcd f g) \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "unfolding g"], ["proof (prove)\ngoal (1 subgoal):\n 1. (resultant f 0 = (0::'a)) = (degree (gcd f 0) \\<noteq> 0)", "using f"], ["proof (prove)\nusing this:\n  degree f \\<noteq> 0\n\ngoal (1 subgoal):\n 1. (resultant f 0 = (0::'a)) = (degree (gcd f 0) \\<noteq> 0)", "by auto"], ["proof (state)\nthis:\n  (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>g = 0; degree f \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (resultant f g = (0::'a)) =\n                    (degree (gcd f g) \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "moreover"], ["proof (state)\nthis:\n  \\<lbrakk>g = 0; degree f \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (resultant f g = (0::'a)) =\n                    (degree (gcd f g) \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "{"], ["proof (state)\nthis:\n  \\<lbrakk>g = 0; degree f \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (resultant f g = (0::'a)) =\n                    (degree (gcd f g) \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "assume g: \"g = 0\" and f: \"degree f = 0\""], ["proof (state)\nthis:\n  g = 0\n  degree f = 0\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "have \"(resultant f g = 0) = (degree (gcd f g) \\<noteq> 0)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "unfolding g"], ["proof (prove)\ngoal (1 subgoal):\n 1. (resultant f 0 = (0::'a)) = (degree (gcd f 0) \\<noteq> 0)", "using f"], ["proof (prove)\nusing this:\n  degree f = 0\n\ngoal (1 subgoal):\n 1. (resultant f 0 = (0::'a)) = (degree (gcd f 0) \\<noteq> 0)", "by (auto simp: resultant_def sylvester_mat_def sylvester_mat_sub_def)"], ["proof (state)\nthis:\n  (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "}"], ["proof (state)\nthis:\n  \\<lbrakk>g = 0; degree f = 0\\<rbrakk>\n  \\<Longrightarrow> (resultant f g = (0::'a)) =\n                    (degree (gcd f g) \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "ultimately"], ["proof (chain)\npicking this:\n  g \\<noteq> 0 \\<Longrightarrow>\n  (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)\n  \\<lbrakk>g = 0; degree f \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (resultant f g = (0::'a)) =\n                    (degree (gcd f g) \\<noteq> 0)\n  \\<lbrakk>g = 0; degree f = 0\\<rbrakk>\n  \\<Longrightarrow> (resultant f g = (0::'a)) =\n                    (degree (gcd f g) \\<noteq> 0)", "have \"(resultant f g = 0) = (degree (gcd f g) \\<noteq> 0)\""], ["proof (prove)\nusing this:\n  g \\<noteq> 0 \\<Longrightarrow>\n  (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)\n  \\<lbrakk>g = 0; degree f \\<noteq> 0\\<rbrakk>\n  \\<Longrightarrow> (resultant f g = (0::'a)) =\n                    (degree (gcd f g) \\<noteq> 0)\n  \\<lbrakk>g = 0; degree f = 0\\<rbrakk>\n  \\<Longrightarrow> (resultant f g = (0::'a)) =\n                    (degree (gcd f g) \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "by blast"], ["proof (state)\nthis:\n  (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "}"], ["proof (state)\nthis:\n  length (coeffs ?ga2) \\<le> length (coeffs ?fa2) \\<Longrightarrow>\n  (resultant ?fa2 ?ga2 = (0::'a)) = (degree (gcd ?fa2 ?ga2) \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "note main = this"], ["proof (state)\nthis:\n  length (coeffs ?ga2) \\<le> length (coeffs ?fa2) \\<Longrightarrow>\n  (resultant ?fa2 ?ga2 = (0::'a)) = (degree (gcd ?fa2 ?ga2) \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "proof (cases \"length (coeffs f) \\<ge> length (coeffs g)\")"], ["proof (state)\ngoal (2 subgoals):\n 1. length (coeffs g) \\<le> length (coeffs f) \\<Longrightarrow>\n    (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)\n 2. \\<not> length (coeffs g) \\<le> length (coeffs f) \\<Longrightarrow>\n    (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "case True"], ["proof (state)\nthis:\n  length (coeffs g) \\<le> length (coeffs f)\n\ngoal (2 subgoals):\n 1. length (coeffs g) \\<le> length (coeffs f) \\<Longrightarrow>\n    (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)\n 2. \\<not> length (coeffs g) \\<le> length (coeffs f) \\<Longrightarrow>\n    (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "from main[OF True]"], ["proof (chain)\npicking this:\n  (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "."], ["proof (state)\nthis:\n  (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. \\<not> length (coeffs g) \\<le> length (coeffs f) \\<Longrightarrow>\n    (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "next"], ["proof (state)\ngoal (1 subgoal):\n 1. \\<not> length (coeffs g) \\<le> length (coeffs f) \\<Longrightarrow>\n    (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "case False"], ["proof (state)\nthis:\n  \\<not> length (coeffs g) \\<le> length (coeffs f)\n\ngoal (1 subgoal):\n 1. \\<not> length (coeffs g) \\<le> length (coeffs f) \\<Longrightarrow>\n    (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "hence \"length (coeffs g) \\<ge> length (coeffs f)\""], ["proof (prove)\nusing this:\n  \\<not> length (coeffs g) \\<le> length (coeffs f)\n\ngoal (1 subgoal):\n 1. length (coeffs f) \\<le> length (coeffs g)", "by auto"], ["proof (state)\nthis:\n  length (coeffs f) \\<le> length (coeffs g)\n\ngoal (1 subgoal):\n 1. \\<not> length (coeffs g) \\<le> length (coeffs f) \\<Longrightarrow>\n    (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "from main[OF this]"], ["proof (chain)\npicking this:\n  (resultant g f = (0::'a)) = (degree (gcd g f) \\<noteq> 0)", "show ?thesis"], ["proof (prove)\nusing this:\n  (resultant g f = (0::'a)) = (degree (gcd g f) \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "unfolding gcd.commute[of g f] resultant_swap[of g f]"], ["proof (prove)\nusing this:\n  ((- (1::'a)) ^ (degree g * degree f) * resultant f g = (0::'a)) =\n  (degree (gcd f g) \\<noteq> 0)\n\ngoal (1 subgoal):\n 1. (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)", "by (simp split: if_splits)"], ["proof (state)\nthis:\n  (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)\n\ngoal:\nNo subgoals!", "qed"], ["proof (state)\nthis:\n  (resultant f g = (0::'a)) = (degree (gcd f g) \\<noteq> 0)\n\ngoal:\nNo subgoals!", "qed"], ["", "subsection \\<open>Code Equations\\<close>"], ["", "definition [code del]:\n  \"gcd_impl_rec = subresultant_prs_main_impl fst\""], ["", "definition [code del]:\n  \"gcd_impl_start = subresultant_prs_impl fst\""], ["", "lemma gcd_impl_rec_code[code]:\n  \"gcd_impl_rec Gi_1 Gi ni_1 d1_1 hi_2 = (\n    let pmod = pseudo_mod Gi_1 Gi\n     in\n     if pmod = 0 then Gi\n        else let\n           ni = degree Gi;\n           d1 = ni_1 - ni;\n           gi_1 = lead_coeff Gi_1;\n           hi_1 = (if d1_1 = 1 then gi_1 else dichotomous_Lazard gi_1 hi_2 d1_1);\n           divisor = if d1 = 1 then gi_1 * hi_1 else if even d1 then - gi_1 * hi_1 ^ d1 else gi_1 * hi_1 ^ d1;\n           Gi_p1 = sdiv_poly pmod divisor\n       in gcd_impl_rec Gi Gi_p1 ni d1 hi_1)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd_impl_rec Gi_1 Gi ni_1 d1_1 hi_2 =\n    (let pmod = pseudo_mod Gi_1 Gi\n     in if pmod = 0 then Gi\n        else let ni = degree Gi; d1 = ni_1 - ni; gi_1 = lead_coeff Gi_1;\n                 hi_1 =\n                   if d1_1 = 1 then gi_1\n                   else dichotomous_Lazard gi_1 hi_2 d1_1;\n                 divisor =\n                   if d1 = 1 then gi_1 * hi_1\n                   else if even d1 then - gi_1 * hi_1 ^ d1\n                        else gi_1 * hi_1 ^ d1;\n                 Gi_p1 = sdiv_poly pmod divisor\n             in gcd_impl_rec Gi Gi_p1 ni d1 hi_1)", "unfolding gcd_impl_rec_def subresultant_prs_main_impl.simps[of _ Gi_1] split Let_def"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if pseudo_mod Gi_1 Gi = 0\n     then fst (Gi,\n               if ni_1 - degree Gi = 1 then lead_coeff Gi\n               else dichotomous_Lazard (lead_coeff Gi)\n                     (if d1_1 = 1 then lead_coeff Gi_1\n                      else dichotomous_Lazard (lead_coeff Gi_1) hi_2 d1_1)\n                     (ni_1 - degree Gi))\n     else subresultant_prs_main_impl fst Gi\n           (sdiv_poly (pseudo_mod Gi_1 Gi)\n             ((- (1::'a)) ^ (ni_1 - degree Gi + 1) * lead_coeff Gi_1 *\n              (if d1_1 = 1 then lead_coeff Gi_1\n               else dichotomous_Lazard (lead_coeff Gi_1) hi_2 d1_1) ^\n              (ni_1 - degree Gi)))\n           (degree Gi) (ni_1 - degree Gi)\n           (if d1_1 = 1 then lead_coeff Gi_1\n            else dichotomous_Lazard (lead_coeff Gi_1) hi_2 d1_1)) =\n    (if pseudo_mod Gi_1 Gi = 0 then Gi\n     else subresultant_prs_main_impl fst Gi\n           (sdiv_poly (pseudo_mod Gi_1 Gi)\n             (if ni_1 - degree Gi = 1\n              then lead_coeff Gi_1 *\n                   (if d1_1 = 1 then lead_coeff Gi_1\n                    else dichotomous_Lazard (lead_coeff Gi_1) hi_2 d1_1)\n              else if even (ni_1 - degree Gi)\n                   then - lead_coeff Gi_1 *\n                        (if d1_1 = 1 then lead_coeff Gi_1\n                         else dichotomous_Lazard (lead_coeff Gi_1) hi_2\n                               d1_1) ^\n                        (ni_1 - degree Gi)\n                   else lead_coeff Gi_1 *\n                        (if d1_1 = 1 then lead_coeff Gi_1\n                         else dichotomous_Lazard (lead_coeff Gi_1) hi_2\n                               d1_1) ^\n                        (ni_1 - degree Gi)))\n           (degree Gi) (ni_1 - degree Gi)\n           (if d1_1 = 1 then lead_coeff Gi_1\n            else dichotomous_Lazard (lead_coeff Gi_1) hi_2 d1_1))", "unfolding gcd_impl_rec_def[symmetric]"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if pseudo_mod Gi_1 Gi = 0\n     then fst (Gi,\n               if ni_1 - degree Gi = 1 then lead_coeff Gi\n               else dichotomous_Lazard (lead_coeff Gi)\n                     (if d1_1 = 1 then lead_coeff Gi_1\n                      else dichotomous_Lazard (lead_coeff Gi_1) hi_2 d1_1)\n                     (ni_1 - degree Gi))\n     else gcd_impl_rec Gi\n           (sdiv_poly (pseudo_mod Gi_1 Gi)\n             ((- (1::'a)) ^ (ni_1 - degree Gi + 1) * lead_coeff Gi_1 *\n              (if d1_1 = 1 then lead_coeff Gi_1\n               else dichotomous_Lazard (lead_coeff Gi_1) hi_2 d1_1) ^\n              (ni_1 - degree Gi)))\n           (degree Gi) (ni_1 - degree Gi)\n           (if d1_1 = 1 then lead_coeff Gi_1\n            else dichotomous_Lazard (lead_coeff Gi_1) hi_2 d1_1)) =\n    (if pseudo_mod Gi_1 Gi = 0 then Gi\n     else gcd_impl_rec Gi\n           (sdiv_poly (pseudo_mod Gi_1 Gi)\n             (if ni_1 - degree Gi = 1\n              then lead_coeff Gi_1 *\n                   (if d1_1 = 1 then lead_coeff Gi_1\n                    else dichotomous_Lazard (lead_coeff Gi_1) hi_2 d1_1)\n              else if even (ni_1 - degree Gi)\n                   then - lead_coeff Gi_1 *\n                        (if d1_1 = 1 then lead_coeff Gi_1\n                         else dichotomous_Lazard (lead_coeff Gi_1) hi_2\n                               d1_1) ^\n                        (ni_1 - degree Gi)\n                   else lead_coeff Gi_1 *\n                        (if d1_1 = 1 then lead_coeff Gi_1\n                         else dichotomous_Lazard (lead_coeff Gi_1) hi_2\n                               d1_1) ^\n                        (ni_1 - degree Gi)))\n           (degree Gi) (ni_1 - degree Gi)\n           (if d1_1 = 1 then lead_coeff Gi_1\n            else dichotomous_Lazard (lead_coeff Gi_1) hi_2 d1_1))", "by (rule if_cong, auto)"], ["", "lemma gcd_impl_start_code[code]:\n  \"gcd_impl_start G1 G2 =\n     (let pmod = pseudo_mod G1 G2\n         in if pmod = 0 then G2\n            else let\n                 n2 = degree G2;\n                 n1 = degree G1;\n                 d1 = n1 - n2;\n                 G3 = if even d1 then - pmod else pmod;\n                 pmod = pseudo_mod G2 G3\n                 in if pmod = 0\n                    then G3\n                    else let\n                           g2 = lead_coeff G2;\n                           n3 = degree G3;\n                           h2 = (if d1 = 1 then g2 else g2 ^ d1);\n                           d2 = n2 - n3;\n                           divisor = (if d2 = 1 then g2 * h2 else if even d2 then - g2 * h2 ^ d2 else g2 * h2 ^ d2);\n                           G4 = sdiv_poly pmod divisor\n                         in gcd_impl_rec G3 G4 n3 d2 h2)\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd_impl_start G1 G2 =\n    (let pmod = pseudo_mod G1 G2\n     in if pmod = 0 then G2\n        else let n2 = degree G2; n1 = degree G1; d1 = n1 - n2;\n                 G3 = if even d1 then - pmod else pmod;\n                 pmod = pseudo_mod G2 G3\n             in if pmod = 0 then G3\n                else let g2 = lead_coeff G2; n3 = degree G3;\n                         h2 = if d1 = 1 then g2 else g2 ^ d1; d2 = n2 - n3;\n                         divisor =\n                           if d2 = 1 then g2 * h2\n                           else if even d2 then - g2 * h2 ^ d2\n                                else g2 * h2 ^ d2;\n                         G4 = sdiv_poly pmod divisor\n                     in gcd_impl_rec G3 G4 n3 d2 h2)", "proof -"], ["proof (state)\ngoal (1 subgoal):\n 1. gcd_impl_start G1 G2 =\n    (let pmod = pseudo_mod G1 G2\n     in if pmod = 0 then G2\n        else let n2 = degree G2; n1 = degree G1; d1 = n1 - n2;\n                 G3 = if even d1 then - pmod else pmod;\n                 pmod = pseudo_mod G2 G3\n             in if pmod = 0 then G3\n                else let g2 = lead_coeff G2; n3 = degree G3;\n                         h2 = if d1 = 1 then g2 else g2 ^ d1; d2 = n2 - n3;\n                         divisor =\n                           if d2 = 1 then g2 * h2\n                           else if even d2 then - g2 * h2 ^ d2\n                                else g2 * h2 ^ d2;\n                         G4 = sdiv_poly pmod divisor\n                     in gcd_impl_rec G3 G4 n3 d2 h2)", "obtain d1 where d1: \"degree G1 - degree G2 = d1\""], ["proof (prove)\ngoal (1 subgoal):\n 1. (\\<And>d1.\n        degree G1 - degree G2 = d1 \\<Longrightarrow>\n        thesis) \\<Longrightarrow>\n    thesis", "by auto"], ["proof (state)\nthis:\n  degree G1 - degree G2 = d1\n\ngoal (1 subgoal):\n 1. gcd_impl_start G1 G2 =\n    (let pmod = pseudo_mod G1 G2\n     in if pmod = 0 then G2\n        else let n2 = degree G2; n1 = degree G1; d1 = n1 - n2;\n                 G3 = if even d1 then - pmod else pmod;\n                 pmod = pseudo_mod G2 G3\n             in if pmod = 0 then G3\n                else let g2 = lead_coeff G2; n3 = degree G3;\n                         h2 = if d1 = 1 then g2 else g2 ^ d1; d2 = n2 - n3;\n                         divisor =\n                           if d2 = 1 then g2 * h2\n                           else if even d2 then - g2 * h2 ^ d2\n                                else g2 * h2 ^ d2;\n                         G4 = sdiv_poly pmod divisor\n                     in gcd_impl_rec G3 G4 n3 d2 h2)", "have id1: \"(if even d1 then - pmod else pmod) = (-1)^ (d1 + 1) * (pmod :: 'a poly)\" for pmod"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if even d1 then - pmod else pmod) = (- 1) ^ (d1 + 1) * pmod", "by simp"], ["proof (state)\nthis:\n  (if even d1 then - ?pmod else ?pmod) = (- 1) ^ (d1 + 1) * ?pmod\n\ngoal (1 subgoal):\n 1. gcd_impl_start G1 G2 =\n    (let pmod = pseudo_mod G1 G2\n     in if pmod = 0 then G2\n        else let n2 = degree G2; n1 = degree G1; d1 = n1 - n2;\n                 G3 = if even d1 then - pmod else pmod;\n                 pmod = pseudo_mod G2 G3\n             in if pmod = 0 then G3\n                else let g2 = lead_coeff G2; n3 = degree G3;\n                         h2 = if d1 = 1 then g2 else g2 ^ d1; d2 = n2 - n3;\n                         divisor =\n                           if d2 = 1 then g2 * h2\n                           else if even d2 then - g2 * h2 ^ d2\n                                else g2 * h2 ^ d2;\n                         G4 = sdiv_poly pmod divisor\n                     in gcd_impl_rec G3 G4 n3 d2 h2)", "show ?thesis"], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd_impl_start G1 G2 =\n    (let pmod = pseudo_mod G1 G2\n     in if pmod = 0 then G2\n        else let n2 = degree G2; n1 = degree G1; d1 = n1 - n2;\n                 G3 = if even d1 then - pmod else pmod;\n                 pmod = pseudo_mod G2 G3\n             in if pmod = 0 then G3\n                else let g2 = lead_coeff G2; n3 = degree G3;\n                         h2 = if d1 = 1 then g2 else g2 ^ d1; d2 = n2 - n3;\n                         divisor =\n                           if d2 = 1 then g2 * h2\n                           else if even d2 then - g2 * h2 ^ d2\n                                else g2 * h2 ^ d2;\n                         G4 = sdiv_poly pmod divisor\n                     in gcd_impl_rec G3 G4 n3 d2 h2)", "unfolding gcd_impl_start_def subresultant_prs_impl_def gcd_impl_rec_def[symmetric] Let_def split"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if pseudo_mod G1 G2 = 0\n     then fst (G2, lead_coeff G2 ^ (degree G1 - degree G2))\n     else if pseudo_mod G2\n              ((- 1) ^ (degree G1 - degree G2 + 1) * pseudo_mod G1 G2) =\n             0\n          then fst ((- 1) ^ (degree G1 - degree G2 + 1) * pseudo_mod G1 G2,\n                    if degree G2 -\n                       degree\n                        ((- 1) ^ (degree G1 - degree G2 + 1) *\n                         pseudo_mod G1 G2) =\n                       1\n                    then lead_coeff\n                          ((- 1) ^ (degree G1 - degree G2 + 1) *\n                           pseudo_mod G1 G2)\n                    else dichotomous_Lazard\n                          (lead_coeff\n                            ((- 1) ^ (degree G1 - degree G2 + 1) *\n                             pseudo_mod G1 G2))\n                          (lead_coeff G2 ^ (degree G1 - degree G2))\n                          (degree G2 -\n                           degree\n                            ((- 1) ^ (degree G1 - degree G2 + 1) *\n                             pseudo_mod G1 G2)))\n          else gcd_impl_rec\n                ((- 1) ^ (degree G1 - degree G2 + 1) * pseudo_mod G1 G2)\n                (sdiv_poly\n                  (pseudo_mod G2\n                    ((- 1) ^ (degree G1 - degree G2 + 1) *\n                     pseudo_mod G1 G2))\n                  ((- (1::'a)) ^\n                   (degree G2 -\n                    degree\n                     ((- 1) ^ (degree G1 - degree G2 + 1) *\n                      pseudo_mod G1 G2) +\n                    1) *\n                   lead_coeff G2 *\n                   (lead_coeff G2 ^ (degree G1 - degree G2)) ^\n                   (degree G2 -\n                    degree\n                     ((- 1) ^ (degree G1 - degree G2 + 1) *\n                      pseudo_mod G1 G2))))\n                (degree\n                  ((- 1) ^ (degree G1 - degree G2 + 1) * pseudo_mod G1 G2))\n                (degree G2 -\n                 degree\n                  ((- 1) ^ (degree G1 - degree G2 + 1) * pseudo_mod G1 G2))\n                (lead_coeff G2 ^ (degree G1 - degree G2))) =\n    (if pseudo_mod G1 G2 = 0 then G2\n     else if pseudo_mod G2\n              (if even (degree G1 - degree G2) then - pseudo_mod G1 G2\n               else pseudo_mod G1 G2) =\n             0\n          then if even (degree G1 - degree G2) then - pseudo_mod G1 G2\n               else pseudo_mod G1 G2\n          else gcd_impl_rec\n                (if even (degree G1 - degree G2) then - pseudo_mod G1 G2\n                 else pseudo_mod G1 G2)\n                (sdiv_poly\n                  (pseudo_mod G2\n                    (if even (degree G1 - degree G2) then - pseudo_mod G1 G2\n                     else pseudo_mod G1 G2))\n                  (if degree G2 -\n                      degree\n                       (if even (degree G1 - degree G2)\n                        then - pseudo_mod G1 G2 else pseudo_mod G1 G2) =\n                      1\n                   then lead_coeff G2 *\n                        (if degree G1 - degree G2 = 1 then lead_coeff G2\n                         else lead_coeff G2 ^ (degree G1 - degree G2))\n                   else if even\n                            (degree G2 -\n                             degree\n                              (if even (degree G1 - degree G2)\n                               then - pseudo_mod G1 G2\n                               else pseudo_mod G1 G2))\n                        then - lead_coeff G2 *\n                             (if degree G1 - degree G2 = 1\n                              then lead_coeff G2\n                              else lead_coeff G2 ^\n                                   (degree G1 - degree G2)) ^\n                             (degree G2 -\n                              degree\n                               (if even (degree G1 - degree G2)\n                                then - pseudo_mod G1 G2\n                                else pseudo_mod G1 G2))\n                        else lead_coeff G2 *\n                             (if degree G1 - degree G2 = 1\n                              then lead_coeff G2\n                              else lead_coeff G2 ^\n                                   (degree G1 - degree G2)) ^\n                             (degree G2 -\n                              degree\n                               (if even (degree G1 - degree G2)\n                                then - pseudo_mod G1 G2\n                                else pseudo_mod G1 G2))))\n                (degree\n                  (if even (degree G1 - degree G2) then - pseudo_mod G1 G2\n                   else pseudo_mod G1 G2))\n                (degree G2 -\n                 degree\n                  (if even (degree G1 - degree G2) then - pseudo_mod G1 G2\n                   else pseudo_mod G1 G2))\n                (if degree G1 - degree G2 = 1 then lead_coeff G2\n                 else lead_coeff G2 ^ (degree G1 - degree G2)))", "unfolding d1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if pseudo_mod G1 G2 = 0 then fst (G2, lead_coeff G2 ^ d1)\n     else if pseudo_mod G2 ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2) = 0\n          then fst ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2,\n                    if degree G2 -\n                       degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2) =\n                       1\n                    then lead_coeff ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2)\n                    else dichotomous_Lazard\n                          (lead_coeff ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))\n                          (lead_coeff G2 ^ d1)\n                          (degree G2 -\n                           degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2)))\n          else gcd_impl_rec ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2)\n                (sdiv_poly\n                  (pseudo_mod G2 ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))\n                  ((- (1::'a)) ^\n                   (degree G2 -\n                    degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2) +\n                    1) *\n                   lead_coeff G2 *\n                   (lead_coeff G2 ^ d1) ^\n                   (degree G2 -\n                    degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))))\n                (degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))\n                (degree G2 - degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))\n                (lead_coeff G2 ^ d1)) =\n    (if pseudo_mod G1 G2 = 0 then G2\n     else if pseudo_mod G2\n              (if even d1 then - pseudo_mod G1 G2 else pseudo_mod G1 G2) =\n             0\n          then if even d1 then - pseudo_mod G1 G2 else pseudo_mod G1 G2\n          else gcd_impl_rec\n                (if even d1 then - pseudo_mod G1 G2 else pseudo_mod G1 G2)\n                (sdiv_poly\n                  (pseudo_mod G2\n                    (if even d1 then - pseudo_mod G1 G2\n                     else pseudo_mod G1 G2))\n                  (if degree G2 -\n                      degree\n                       (if even d1 then - pseudo_mod G1 G2\n                        else pseudo_mod G1 G2) =\n                      1\n                   then lead_coeff G2 *\n                        (if d1 = 1 then lead_coeff G2\n                         else lead_coeff G2 ^ d1)\n                   else if even\n                            (degree G2 -\n                             degree\n                              (if even d1 then - pseudo_mod G1 G2\n                               else pseudo_mod G1 G2))\n                        then - lead_coeff G2 *\n                             (if d1 = 1 then lead_coeff G2\n                              else lead_coeff G2 ^ d1) ^\n                             (degree G2 -\n                              degree\n                               (if even d1 then - pseudo_mod G1 G2\n                                else pseudo_mod G1 G2))\n                        else lead_coeff G2 *\n                             (if d1 = 1 then lead_coeff G2\n                              else lead_coeff G2 ^ d1) ^\n                             (degree G2 -\n                              degree\n                               (if even d1 then - pseudo_mod G1 G2\n                                else pseudo_mod G1 G2))))\n                (degree\n                  (if even d1 then - pseudo_mod G1 G2\n                   else pseudo_mod G1 G2))\n                (degree G2 -\n                 degree\n                  (if even d1 then - pseudo_mod G1 G2\n                   else pseudo_mod G1 G2))\n                (if d1 = 1 then lead_coeff G2 else lead_coeff G2 ^ d1))", "unfolding id1"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if pseudo_mod G1 G2 = 0 then fst (G2, lead_coeff G2 ^ d1)\n     else if pseudo_mod G2 ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2) = 0\n          then fst ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2,\n                    if degree G2 -\n                       degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2) =\n                       1\n                    then lead_coeff ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2)\n                    else dichotomous_Lazard\n                          (lead_coeff ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))\n                          (lead_coeff G2 ^ d1)\n                          (degree G2 -\n                           degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2)))\n          else gcd_impl_rec ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2)\n                (sdiv_poly\n                  (pseudo_mod G2 ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))\n                  ((- (1::'a)) ^\n                   (degree G2 -\n                    degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2) +\n                    1) *\n                   lead_coeff G2 *\n                   (lead_coeff G2 ^ d1) ^\n                   (degree G2 -\n                    degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))))\n                (degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))\n                (degree G2 - degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))\n                (lead_coeff G2 ^ d1)) =\n    (if pseudo_mod G1 G2 = 0 then G2\n     else if pseudo_mod G2 ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2) = 0\n          then (- 1) ^ (d1 + 1) * pseudo_mod G1 G2\n          else gcd_impl_rec ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2)\n                (sdiv_poly\n                  (pseudo_mod G2 ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))\n                  (if degree G2 -\n                      degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2) =\n                      1\n                   then lead_coeff G2 *\n                        (if d1 = 1 then lead_coeff G2\n                         else lead_coeff G2 ^ d1)\n                   else if even\n                            (degree G2 -\n                             degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))\n                        then - lead_coeff G2 *\n                             (if d1 = 1 then lead_coeff G2\n                              else lead_coeff G2 ^ d1) ^\n                             (degree G2 -\n                              degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))\n                        else lead_coeff G2 *\n                             (if d1 = 1 then lead_coeff G2\n                              else lead_coeff G2 ^ d1) ^\n                             (degree G2 -\n                              degree\n                               ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))))\n                (degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))\n                (degree G2 - degree ((- 1) ^ (d1 + 1) * pseudo_mod G1 G2))\n                (if d1 = 1 then lead_coeff G2 else lead_coeff G2 ^ d1))", "by (rule if_cong, auto)"], ["proof (state)\nthis:\n  gcd_impl_start G1 G2 =\n  (let pmod = pseudo_mod G1 G2\n   in if pmod = 0 then G2\n      else let n2 = degree G2; n1 = degree G1; d1 = n1 - n2;\n               G3 = if even d1 then - pmod else pmod;\n               pmod = pseudo_mod G2 G3\n           in if pmod = 0 then G3\n              else let g2 = lead_coeff G2; n3 = degree G3;\n                       h2 = if d1 = 1 then g2 else g2 ^ d1; d2 = n2 - n3;\n                       divisor =\n                         if d2 = 1 then g2 * h2\n                         else if even d2 then - g2 * h2 ^ d2\n                              else g2 * h2 ^ d2;\n                       G4 = sdiv_poly pmod divisor\n                   in gcd_impl_rec G3 G4 n3 d2 h2)\n\ngoal:\nNo subgoals!", "qed"], ["", "lemma gcd_impl_main_code[code]:\n  \"gcd_impl_main G1 G2 = (if G1 = 0 then 0 else if G2 = 0 then normalize G1 else\n    let c1 = content G1;\n      c2 = content G2;\n      p1 = map_poly (\\<lambda> x. x div c1) G1;\n      p2 = map_poly (\\<lambda> x. x div c2) G2\n     in smult (gcd c1 c2) (normalize (primitive_part (gcd_impl_start p1 p2))))\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd_impl_main G1 G2 =\n    (if G1 = 0 then 0\n     else if G2 = 0 then normalize G1\n          else let c1 = content G1; c2 = content G2;\n                   p1 = map_poly (\\<lambda>x. x div c1) G1;\n                   p2 = map_poly (\\<lambda>x. x div c2) G2\n               in Polynomial.smult (gcd c1 c2)\n                   (normalize (primitive_part (gcd_impl_start p1 p2))))", "unfolding gcd_impl_main_def Let_def primitive_part_def gcd_impl_start_def gcd_impl_primitive_def\n    subresultant_prs_impl"], ["proof (prove)\ngoal (1 subgoal):\n 1. (if G1 = 0 then 0\n     else if G2 = 0 then normalize G1\n          else Polynomial.smult (gcd (content G1) (content G2))\n                (normalize\n                  (map_poly\n                    (\\<lambda>x.\n                        x div\n                        content\n                         (fst (subresultant_prs dichotomous_Lazard\n                                (map_poly (\\<lambda>x. x div content G1) G1)\n                                (map_poly (\\<lambda>x. x div content G2)\n                                  G2))))\n                    (fst (subresultant_prs dichotomous_Lazard\n                           (map_poly (\\<lambda>x. x div content G1) G1)\n                           (map_poly (\\<lambda>x. x div content G2)\n                             G2)))))) =\n    (if G1 = 0 then 0\n     else if G2 = 0 then normalize G1\n          else Polynomial.smult (gcd (content G1) (content G2))\n                (normalize\n                  (map_poly\n                    (\\<lambda>x.\n                        x div\n                        content\n                         (fst (subresultant_prs dichotomous_Lazard\n                                (map_poly (\\<lambda>x. x div content G1) G1)\n                                (map_poly (\\<lambda>x. x div content G2)\n                                  G2))))\n                    (fst (subresultant_prs dichotomous_Lazard\n                           (map_poly (\\<lambda>x. x div content G1) G1)\n                           (map_poly (\\<lambda>x. x div content G2) G2))))))", "by simp"], ["", "corollary gcd_via_subresultant: \"gcd f g = gcd_impl f g\""], ["proof (prove)\ngoal (1 subgoal):\n 1. gcd f g = gcd_impl f g", "by simp"], ["", "text \\<open>Note that we did not activate @{thm gcd_via_subresultant} as code-equation, since according to our experiments,\n  the subresultant-gcd algorithm is not always more efficient than the currently active equation.\n  In particular, on @{typ \"int poly\"} @{const gcd_impl} performs worse, but on multi-variate polynomials,\n  e.g., @{typ \"int poly poly poly\"}, @{const gcd_impl} is preferable.\\<close>"], ["", "end"]]}